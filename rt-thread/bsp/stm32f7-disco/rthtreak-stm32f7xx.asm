
rtthread-stm32f7xx.axf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <_stext>:
 8000000:	200107ac 	.word	0x200107ac
 8000004:	0800af99 	.word	0x0800af99
 8000008:	0800f8cd 	.word	0x0800f8cd
 800000c:	080002a7 	.word	0x080002a7
 8000010:	0800afe9 	.word	0x0800afe9
 8000014:	0800f8d9 	.word	0x0800f8d9
 8000018:	0800f8e1 	.word	0x0800f8e1
	...
 800002c:	0800afe9 	.word	0x0800afe9
 8000030:	0800f8e9 	.word	0x0800f8e9
 8000034:	00000000 	.word	0x00000000
 8000038:	080001f5 	.word	0x080001f5
 800003c:	0800d689 	.word	0x0800d689
 8000040:	0800afe9 	.word	0x0800afe9
 8000044:	0800afe9 	.word	0x0800afe9
 8000048:	0800afe9 	.word	0x0800afe9
 800004c:	0800afe9 	.word	0x0800afe9
 8000050:	0800afe9 	.word	0x0800afe9
 8000054:	0800afe9 	.word	0x0800afe9
 8000058:	0800afe9 	.word	0x0800afe9
 800005c:	0800afe9 	.word	0x0800afe9
 8000060:	0800afe9 	.word	0x0800afe9
 8000064:	0800afe9 	.word	0x0800afe9
 8000068:	0800afe9 	.word	0x0800afe9
 800006c:	0800afe9 	.word	0x0800afe9
 8000070:	0800f5e9 	.word	0x0800f5e9
 8000074:	0800afe9 	.word	0x0800afe9
 8000078:	0800afe9 	.word	0x0800afe9
 800007c:	0800afe9 	.word	0x0800afe9
 8000080:	0800afe9 	.word	0x0800afe9
 8000084:	0800afe9 	.word	0x0800afe9
 8000088:	0800dec5 	.word	0x0800dec5
 800008c:	0800cd1d 	.word	0x0800cd1d
 8000090:	0800cd91 	.word	0x0800cd91
 8000094:	0800cdb5 	.word	0x0800cdb5
 8000098:	0800cead 	.word	0x0800cead
 800009c:	0800afe9 	.word	0x0800afe9
 80000a0:	0800afe9 	.word	0x0800afe9
 80000a4:	0800afe9 	.word	0x0800afe9
 80000a8:	0800afe9 	.word	0x0800afe9
 80000ac:	0800afe9 	.word	0x0800afe9
 80000b0:	0800afe9 	.word	0x0800afe9
 80000b4:	0800afe9 	.word	0x0800afe9
 80000b8:	0800afe9 	.word	0x0800afe9
 80000bc:	0800afe9 	.word	0x0800afe9
 80000c0:	0800afe9 	.word	0x0800afe9
 80000c4:	0800afe9 	.word	0x0800afe9
 80000c8:	0800afe9 	.word	0x0800afe9
 80000cc:	0800afe9 	.word	0x0800afe9
 80000d0:	0800afe9 	.word	0x0800afe9
 80000d4:	0800f525 	.word	0x0800f525
 80000d8:	0800afe9 	.word	0x0800afe9
 80000dc:	0800f579 	.word	0x0800f579
 80000e0:	0800afe9 	.word	0x0800afe9
 80000e4:	0800afe9 	.word	0x0800afe9
 80000e8:	0800afe9 	.word	0x0800afe9
 80000ec:	0800ebe5 	.word	0x0800ebe5
 80000f0:	0800ec09 	.word	0x0800ec09
 80000f4:	0800afe9 	.word	0x0800afe9
 80000f8:	0800afe9 	.word	0x0800afe9
 80000fc:	0800afe9 	.word	0x0800afe9
 8000100:	0800afe9 	.word	0x0800afe9
 8000104:	0800afe9 	.word	0x0800afe9
 8000108:	0800e4ed 	.word	0x0800e4ed
 800010c:	0800afe9 	.word	0x0800afe9
 8000110:	0800afe9 	.word	0x0800afe9
 8000114:	0800afe9 	.word	0x0800afe9
 8000118:	0800afe9 	.word	0x0800afe9
 800011c:	0800afe9 	.word	0x0800afe9
 8000120:	0800eb75 	.word	0x0800eb75
 8000124:	0800afe9 	.word	0x0800afe9
 8000128:	0800afe9 	.word	0x0800afe9
 800012c:	0800afe9 	.word	0x0800afe9
 8000130:	0800afe9 	.word	0x0800afe9
 8000134:	0800afe9 	.word	0x0800afe9
 8000138:	0800afe9 	.word	0x0800afe9
 800013c:	0800afe9 	.word	0x0800afe9
 8000140:	0800afe9 	.word	0x0800afe9
 8000144:	0800afe9 	.word	0x0800afe9
 8000148:	0800afe9 	.word	0x0800afe9
 800014c:	0800afe9 	.word	0x0800afe9
 8000150:	0800afe9 	.word	0x0800afe9
 8000154:	0800afe9 	.word	0x0800afe9
 8000158:	0800afe9 	.word	0x0800afe9
 800015c:	0800afe9 	.word	0x0800afe9
 8000160:	0800afe9 	.word	0x0800afe9
 8000164:	0800afe9 	.word	0x0800afe9
 8000168:	0800afe9 	.word	0x0800afe9
 800016c:	0800afe9 	.word	0x0800afe9
 8000170:	0800afe9 	.word	0x0800afe9
 8000174:	0800afe9 	.word	0x0800afe9
 8000178:	0800afe9 	.word	0x0800afe9
 800017c:	00000000 	.word	0x00000000
 8000180:	0800afe9 	.word	0x0800afe9
 8000184:	0800afe9 	.word	0x0800afe9
 8000188:	0800afe9 	.word	0x0800afe9
 800018c:	0800afe9 	.word	0x0800afe9
 8000190:	0800afe9 	.word	0x0800afe9
 8000194:	0800afe9 	.word	0x0800afe9
 8000198:	0800afe9 	.word	0x0800afe9
 800019c:	0800afe9 	.word	0x0800afe9
 80001a0:	0800afe9 	.word	0x0800afe9
 80001a4:	0800afe9 	.word	0x0800afe9
 80001a8:	0800afe9 	.word	0x0800afe9
 80001ac:	0800afe9 	.word	0x0800afe9
 80001b0:	0800afe9 	.word	0x0800afe9
 80001b4:	0800afe9 	.word	0x0800afe9
 80001b8:	0800afe9 	.word	0x0800afe9
 80001bc:	0800afe9 	.word	0x0800afe9
 80001c0:	0800afe9 	.word	0x0800afe9
 80001c4:	0800afe9 	.word	0x0800afe9

080001c8 <rt_hw_interrupt_disable>:
 * rt_base_t rt_hw_interrupt_disable();
 */
.global rt_hw_interrupt_disable
.type rt_hw_interrupt_disable, %function
rt_hw_interrupt_disable:
    MRS     r0, PRIMASK
 80001c8:	f3ef 8010 	mrs	r0, PRIMASK
    CPSID   I
 80001cc:	b672      	cpsid	i
    BX      LR
 80001ce:	4770      	bx	lr

080001d0 <rt_hw_interrupt_enable>:
 * void rt_hw_interrupt_enable(rt_base_t level);
 */
.global rt_hw_interrupt_enable
.type rt_hw_interrupt_enable, %function
rt_hw_interrupt_enable:
    MSR     PRIMASK, r0
 80001d0:	f380 8810 	msr	PRIMASK, r0
    BX      LR
 80001d4:	4770      	bx	lr

080001d6 <rt_hw_context_switch>:
.type rt_hw_context_switch, %function

rt_hw_context_switch_interrupt:
rt_hw_context_switch:
    /* set rt_thread_switch_interrupt_flag to 1 */
    LDR     r2, =rt_thread_switch_interrupt_flag
 80001d6:	4a39      	ldr	r2, [pc, #228]	; (80002bc <HardFault_Handler+0x16>)
    LDR     r3, [r2]
 80001d8:	6813      	ldr	r3, [r2, #0]
    CMP     r3, #1
 80001da:	2b01      	cmp	r3, #1
    BEQ     _reswitch
 80001dc:	d004      	beq.n	80001e8 <_reswitch>
    MOV     r3, #1
 80001de:	f04f 0301 	mov.w	r3, #1
    STR     r3, [r2]
 80001e2:	6013      	str	r3, [r2, #0]

    LDR     r2, =rt_interrupt_from_thread   /* set rt_interrupt_from_thread */
 80001e4:	4a36      	ldr	r2, [pc, #216]	; (80002c0 <HardFault_Handler+0x1a>)
    STR     r0, [r2]
 80001e6:	6010      	str	r0, [r2, #0]

080001e8 <_reswitch>:

_reswitch:
    LDR     r2, =rt_interrupt_to_thread     /* set rt_interrupt_to_thread */
 80001e8:	4a36      	ldr	r2, [pc, #216]	; (80002c4 <HardFault_Handler+0x1e>)
    STR     r1, [r2]
 80001ea:	6011      	str	r1, [r2, #0]

    LDR r0, =NVIC_INT_CTRL              /* trigger the PendSV exception (causes context switch) */
 80001ec:	4836      	ldr	r0, [pc, #216]	; (80002c8 <HardFault_Handler+0x22>)
    LDR r1, =NVIC_PENDSVSET
 80001ee:	4937      	ldr	r1, [pc, #220]	; (80002cc <HardFault_Handler+0x26>)
    STR r1, [r0]
 80001f0:	6001      	str	r1, [r0, #0]
    BX  LR
 80001f2:	4770      	bx	lr

080001f4 <PendSV_Handler>:
 */
.global PendSV_Handler
.type PendSV_Handler, %function
PendSV_Handler:
    /* disable interrupt to protect context switch */
    MRS r2, PRIMASK
 80001f4:	f3ef 8210 	mrs	r2, PRIMASK
    CPSID   I
 80001f8:	b672      	cpsid	i

    /* get rt_thread_switch_interrupt_flag */
    LDR r0, =rt_thread_switch_interrupt_flag
 80001fa:	4830      	ldr	r0, [pc, #192]	; (80002bc <HardFault_Handler+0x16>)
    LDR r1, [r0]
 80001fc:	6801      	ldr	r1, [r0, #0]
    CBZ r1, pendsv_exit         /* pendsv already handled */
 80001fe:	b321      	cbz	r1, 800024a <pendsv_exit>

    /* clear rt_thread_switch_interrupt_flag to 0 */
    MOV r1, #0x00
 8000200:	f04f 0100 	mov.w	r1, #0
    STR r1, [r0]
 8000204:	6001      	str	r1, [r0, #0]

    LDR r0, =rt_interrupt_from_thread
 8000206:	482e      	ldr	r0, [pc, #184]	; (80002c0 <HardFault_Handler+0x1a>)
    LDR r1, [r0]
 8000208:	6801      	ldr	r1, [r0, #0]
    CBZ r1, switch_to_thread    /* skip register save at the first time */
 800020a:	b191      	cbz	r1, 8000232 <switch_to_thread>

    MRS r1, psp                 /* get from thread stack pointer */
 800020c:	f3ef 8109 	mrs	r1, PSP
    
#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    TST     lr, #0x10           /* if(!EXC_RETURN[4]) */
 8000210:	f01e 0f10 	tst.w	lr, #16
    VSTMDBEQ r1!, {d8 - d15}    /* push FPU register s16~s31 */
 8000214:	bf08      	it	eq
 8000216:	ed21 8b10 	vstmdbeq	r1!, {d8-d15}
#endif
    
    STMFD   r1!, {r4 - r11}     /* push r4 - r11 register */
 800021a:	e921 0ff0 	stmdb	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    MOV     r4, #0x00           /* flag = 0 */
 800021e:	f04f 0400 	mov.w	r4, #0

    TST     lr, #0x10           /* if(!EXC_RETURN[4]) */
 8000222:	f01e 0f10 	tst.w	lr, #16
    MOVEQ   r4, #0x01           /* flag = 1 */
 8000226:	bf08      	it	eq
 8000228:	2401      	moveq	r4, #1

    STMFD   r1!, {r4}           /* push flag */
 800022a:	f841 4d04 	str.w	r4, [r1, #-4]!
#endif

    LDR r0, [r0]
 800022e:	6800      	ldr	r0, [r0, #0]
    STR r1, [r0]                /* update from thread stack pointer */
 8000230:	6001      	str	r1, [r0, #0]

08000232 <switch_to_thread>:

switch_to_thread:
    LDR r1, =rt_interrupt_to_thread
 8000232:	4924      	ldr	r1, [pc, #144]	; (80002c4 <HardFault_Handler+0x1e>)
    LDR r1, [r1]
 8000234:	6809      	ldr	r1, [r1, #0]
    LDR r1, [r1]                /* load thread stack pointer */
 8000236:	6809      	ldr	r1, [r1, #0]

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    LDMFD   r1!, {r3}           /* pop flag */
 8000238:	c908      	ldmia	r1!, {r3}
#endif

    LDMFD   r1!, {r4 - r11}     /* pop r4 - r11 register */
 800023a:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    CMP     r3,  #0             /* if(flag_r3 != 0) */
 800023e:	2b00      	cmp	r3, #0
    VLDMIANE  r1!, {d8 - d15}   /* pop FPU register s16~s31 */
 8000240:	bf18      	it	ne
 8000242:	ecb1 8b10 	vldmiane	r1!, {d8-d15}
#endif

    MSR psp, r1                 /* update stack pointer */
 8000246:	f381 8809 	msr	PSP, r1

0800024a <pendsv_exit>:

pendsv_exit:
    /* restore interrupt */
    MSR PRIMASK, r2
 800024a:	f382 8810 	msr	PRIMASK, r2

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    ORR     lr, lr, #0x10       /* lr |=  (1 << 4), clean FPCA. */
 800024e:	f04e 0e10 	orr.w	lr, lr, #16
    CMP     r3,  #0             /* if(flag_r3 != 0) */
 8000252:	2b00      	cmp	r3, #0
    BICNE   lr, lr, #0x10       /* lr &= ~(1 << 4), set FPCA. */
 8000254:	bf18      	it	ne
 8000256:	f02e 0e10 	bicne.w	lr, lr, #16
#endif

    ORR lr, lr, #0x04
 800025a:	f04e 0e04 	orr.w	lr, lr, #4
    BX  lr
 800025e:	4770      	bx	lr

08000260 <rt_hw_context_switch_to>:
 * r0 --> to
 */
.global rt_hw_context_switch_to
.type rt_hw_context_switch_to, %function
rt_hw_context_switch_to:
    LDR r1, =rt_interrupt_to_thread
 8000260:	4918      	ldr	r1, [pc, #96]	; (80002c4 <HardFault_Handler+0x1e>)
    STR r0, [r1]
 8000262:	6008      	str	r0, [r1, #0]

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    /* CLEAR CONTROL.FPCA */
    MRS     r2, CONTROL         /* read */
 8000264:	f3ef 8214 	mrs	r2, CONTROL
    BIC     r2, #0x04           /* modify */
 8000268:	f022 0204 	bic.w	r2, r2, #4
    MSR     CONTROL, r2         /* write-back */
 800026c:	f382 8814 	msr	CONTROL, r2
#endif

    /* set from thread to 0 */
    LDR r1, =rt_interrupt_from_thread
 8000270:	4913      	ldr	r1, [pc, #76]	; (80002c0 <HardFault_Handler+0x1a>)
    MOV r0, #0x0
 8000272:	f04f 0000 	mov.w	r0, #0
    STR r0, [r1]
 8000276:	6008      	str	r0, [r1, #0]

    /* set interrupt flag to 1 */
    LDR     r1, =rt_thread_switch_interrupt_flag
 8000278:	4910      	ldr	r1, [pc, #64]	; (80002bc <HardFault_Handler+0x16>)
    MOV     r0, #1
 800027a:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r1]
 800027e:	6008      	str	r0, [r1, #0]

    /* set the PendSV exception priority */
    LDR r0, =NVIC_SYSPRI2
 8000280:	4813      	ldr	r0, [pc, #76]	; (80002d0 <HardFault_Handler+0x2a>)
    LDR r1, =NVIC_PENDSV_PRI
 8000282:	4914      	ldr	r1, [pc, #80]	; (80002d4 <HardFault_Handler+0x2e>)
    LDR.W   r2, [r0,#0x00]       /* read       */
 8000284:	f8d0 2000 	ldr.w	r2, [r0]
    ORR     r1,r1,r2             /* modify     */
 8000288:	ea41 0102 	orr.w	r1, r1, r2
    STR     r1, [r0]             /* write-back */
 800028c:	6001      	str	r1, [r0, #0]

    LDR r0, =NVIC_INT_CTRL      /* trigger the PendSV exception (causes context switch) */
 800028e:	480e      	ldr	r0, [pc, #56]	; (80002c8 <HardFault_Handler+0x22>)
    LDR r1, =NVIC_PENDSVSET
 8000290:	490e      	ldr	r1, [pc, #56]	; (80002cc <HardFault_Handler+0x26>)
    STR r1, [r0]
 8000292:	6001      	str	r1, [r0, #0]

    /* restore MSP */
    LDR     r0, =SCB_VTOR
 8000294:	4810      	ldr	r0, [pc, #64]	; (80002d8 <HardFault_Handler+0x32>)
    LDR     r0, [r0]
 8000296:	6800      	ldr	r0, [r0, #0]
    LDR     r0, [r0]
 8000298:	6800      	ldr	r0, [r0, #0]
    NOP
 800029a:	bf00      	nop
    MSR     msp, r0
 800029c:	f380 8808 	msr	MSP, r0

    CPSIE   I                       /* enable interrupts at processor level */
 80002a0:	b662      	cpsie	i

080002a2 <rt_hw_interrupt_thread_switch>:

/* compatible with old version */
.global rt_hw_interrupt_thread_switch
.type rt_hw_interrupt_thread_switch, %function
rt_hw_interrupt_thread_switch:
    BX  lr
 80002a2:	4770      	bx	lr
    NOP
 80002a4:	bf00      	nop

080002a6 <HardFault_Handler>:

.global HardFault_Handler
.type HardFault_Handler, %function
HardFault_Handler:
    /* get current context */
    MRS     r0, psp                 /* get fault thread stack pointer */
 80002a6:	f3ef 8009 	mrs	r0, PSP
    PUSH    {lr}
 80002aa:	b500      	push	{lr}
    BL      rt_hw_hard_fault_exception
 80002ac:	f015 fca6 	bl	8015bfc <rt_hw_hard_fault_exception>
    POP     {lr}
 80002b0:	f85d eb04 	ldr.w	lr, [sp], #4

    ORR     lr, lr, #0x04
 80002b4:	f04e 0e04 	orr.w	lr, lr, #4
    BX      lr
 80002b8:	4770      	bx	lr
 80002ba:	0000      	.short	0x0000
.type rt_hw_context_switch, %function

rt_hw_context_switch_interrupt:
rt_hw_context_switch:
    /* set rt_thread_switch_interrupt_flag to 1 */
    LDR     r2, =rt_thread_switch_interrupt_flag
 80002bc:	20012694 	.word	0x20012694
    CMP     r3, #1
    BEQ     _reswitch
    MOV     r3, #1
    STR     r3, [r2]

    LDR     r2, =rt_interrupt_from_thread   /* set rt_interrupt_from_thread */
 80002c0:	20012690 	.word	0x20012690
    STR     r0, [r2]

_reswitch:
    LDR     r2, =rt_interrupt_to_thread     /* set rt_interrupt_to_thread */
 80002c4:	2001268c 	.word	0x2001268c
    STR     r1, [r2]

    LDR r0, =NVIC_INT_CTRL              /* trigger the PendSV exception (causes context switch) */
 80002c8:	e000ed04 	.word	0xe000ed04
    LDR r1, =NVIC_PENDSVSET
 80002cc:	10000000 	.word	0x10000000
    LDR     r1, =rt_thread_switch_interrupt_flag
    MOV     r0, #1
    STR     r0, [r1]

    /* set the PendSV exception priority */
    LDR r0, =NVIC_SYSPRI2
 80002d0:	e000ed20 	.word	0xe000ed20
    LDR r1, =NVIC_PENDSV_PRI
 80002d4:	00ff0000 	.word	0x00ff0000
    LDR r0, =NVIC_INT_CTRL      /* trigger the PendSV exception (causes context switch) */
    LDR r1, =NVIC_PENDSVSET
    STR r1, [r0]

    /* restore MSP */
    LDR     r0, =SCB_VTOR
 80002d8:	e000ed08 	.word	0xe000ed08

080002dc <memcpy>:
 80002dc:	4684      	mov	ip, r0
 80002de:	ea41 0300 	orr.w	r3, r1, r0
 80002e2:	f013 0303 	ands.w	r3, r3, #3
 80002e6:	d16d      	bne.n	80003c4 <memcpy+0xe8>
 80002e8:	3a40      	subs	r2, #64	; 0x40
 80002ea:	d341      	bcc.n	8000370 <memcpy+0x94>
 80002ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f0:	f840 3b04 	str.w	r3, [r0], #4
 80002f4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f8:	f840 3b04 	str.w	r3, [r0], #4
 80002fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000300:	f840 3b04 	str.w	r3, [r0], #4
 8000304:	f851 3b04 	ldr.w	r3, [r1], #4
 8000308:	f840 3b04 	str.w	r3, [r0], #4
 800030c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000310:	f840 3b04 	str.w	r3, [r0], #4
 8000314:	f851 3b04 	ldr.w	r3, [r1], #4
 8000318:	f840 3b04 	str.w	r3, [r0], #4
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	3a40      	subs	r2, #64	; 0x40
 800036e:	d2bd      	bcs.n	80002ec <memcpy+0x10>
 8000370:	3230      	adds	r2, #48	; 0x30
 8000372:	d311      	bcc.n	8000398 <memcpy+0xbc>
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000380:	f840 3b04 	str.w	r3, [r0], #4
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	3a10      	subs	r2, #16
 8000396:	d2ed      	bcs.n	8000374 <memcpy+0x98>
 8000398:	320c      	adds	r2, #12
 800039a:	d305      	bcc.n	80003a8 <memcpy+0xcc>
 800039c:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a0:	f840 3b04 	str.w	r3, [r0], #4
 80003a4:	3a04      	subs	r2, #4
 80003a6:	d2f9      	bcs.n	800039c <memcpy+0xc0>
 80003a8:	3204      	adds	r2, #4
 80003aa:	d008      	beq.n	80003be <memcpy+0xe2>
 80003ac:	07d2      	lsls	r2, r2, #31
 80003ae:	bf1c      	itt	ne
 80003b0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003b4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003b8:	d301      	bcc.n	80003be <memcpy+0xe2>
 80003ba:	880b      	ldrh	r3, [r1, #0]
 80003bc:	8003      	strh	r3, [r0, #0]
 80003be:	4660      	mov	r0, ip
 80003c0:	4770      	bx	lr
 80003c2:	bf00      	nop
 80003c4:	2a08      	cmp	r2, #8
 80003c6:	d313      	bcc.n	80003f0 <memcpy+0x114>
 80003c8:	078b      	lsls	r3, r1, #30
 80003ca:	d08d      	beq.n	80002e8 <memcpy+0xc>
 80003cc:	f010 0303 	ands.w	r3, r0, #3
 80003d0:	d08a      	beq.n	80002e8 <memcpy+0xc>
 80003d2:	f1c3 0304 	rsb	r3, r3, #4
 80003d6:	1ad2      	subs	r2, r2, r3
 80003d8:	07db      	lsls	r3, r3, #31
 80003da:	bf1c      	itt	ne
 80003dc:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003e0:	f800 3b01 	strbne.w	r3, [r0], #1
 80003e4:	d380      	bcc.n	80002e8 <memcpy+0xc>
 80003e6:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003ea:	f820 3b02 	strh.w	r3, [r0], #2
 80003ee:	e77b      	b.n	80002e8 <memcpy+0xc>
 80003f0:	3a04      	subs	r2, #4
 80003f2:	d3d9      	bcc.n	80003a8 <memcpy+0xcc>
 80003f4:	3a01      	subs	r2, #1
 80003f6:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003fa:	f800 3b01 	strb.w	r3, [r0], #1
 80003fe:	d2f9      	bcs.n	80003f4 <memcpy+0x118>
 8000400:	780b      	ldrb	r3, [r1, #0]
 8000402:	7003      	strb	r3, [r0, #0]
 8000404:	784b      	ldrb	r3, [r1, #1]
 8000406:	7043      	strb	r3, [r0, #1]
 8000408:	788b      	ldrb	r3, [r1, #2]
 800040a:	7083      	strb	r3, [r0, #2]
 800040c:	4660      	mov	r0, ip
 800040e:	4770      	bx	lr
	...
 8000420:	eba2 0003 	sub.w	r0, r2, r3
 8000424:	4770      	bx	lr
 8000426:	bf00      	nop

08000428 <strcmp>:
 8000428:	7802      	ldrb	r2, [r0, #0]
 800042a:	780b      	ldrb	r3, [r1, #0]
 800042c:	2a01      	cmp	r2, #1
 800042e:	bf28      	it	cs
 8000430:	429a      	cmpcs	r2, r3
 8000432:	d1f5      	bne.n	8000420 <memcpy+0x144>
 8000434:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000438:	ea40 0401 	orr.w	r4, r0, r1
 800043c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000440:	f06f 0c00 	mvn.w	ip, #0
 8000444:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000448:	b312      	cbz	r2, 8000490 <strcmp+0x68>
 800044a:	ea80 0401 	eor.w	r4, r0, r1
 800044e:	f014 0f07 	tst.w	r4, #7
 8000452:	d16a      	bne.n	800052a <strcmp+0x102>
 8000454:	f000 0407 	and.w	r4, r0, #7
 8000458:	f020 0007 	bic.w	r0, r0, #7
 800045c:	f004 0503 	and.w	r5, r4, #3
 8000460:	f021 0107 	bic.w	r1, r1, #7
 8000464:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000468:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800046c:	f014 0f04 	tst.w	r4, #4
 8000470:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000474:	fa0c f405 	lsl.w	r4, ip, r5
 8000478:	ea62 0204 	orn	r2, r2, r4
 800047c:	ea66 0604 	orn	r6, r6, r4
 8000480:	d00a      	beq.n	8000498 <strcmp+0x70>
 8000482:	ea63 0304 	orn	r3, r3, r4
 8000486:	4662      	mov	r2, ip
 8000488:	ea67 0704 	orn	r7, r7, r4
 800048c:	4666      	mov	r6, ip
 800048e:	e003      	b.n	8000498 <strcmp+0x70>
 8000490:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000494:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000498:	fa82 f54c 	uadd8	r5, r2, ip
 800049c:	ea82 0406 	eor.w	r4, r2, r6
 80004a0:	faa4 f48c 	sel	r4, r4, ip
 80004a4:	bb6c      	cbnz	r4, 8000502 <strcmp+0xda>
 80004a6:	fa83 f54c 	uadd8	r5, r3, ip
 80004aa:	ea83 0507 	eor.w	r5, r3, r7
 80004ae:	faa5 f58c 	sel	r5, r5, ip
 80004b2:	b995      	cbnz	r5, 80004da <strcmp+0xb2>
 80004b4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80004b8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80004bc:	fa82 f54c 	uadd8	r5, r2, ip
 80004c0:	ea82 0406 	eor.w	r4, r2, r6
 80004c4:	faa4 f48c 	sel	r4, r4, ip
 80004c8:	fa83 f54c 	uadd8	r5, r3, ip
 80004cc:	ea83 0507 	eor.w	r5, r3, r7
 80004d0:	faa5 f58c 	sel	r5, r5, ip
 80004d4:	4325      	orrs	r5, r4
 80004d6:	d0db      	beq.n	8000490 <strcmp+0x68>
 80004d8:	b99c      	cbnz	r4, 8000502 <strcmp+0xda>
 80004da:	ba2d      	rev	r5, r5
 80004dc:	fab5 f485 	clz	r4, r5
 80004e0:	f024 0407 	bic.w	r4, r4, #7
 80004e4:	fa27 f104 	lsr.w	r1, r7, r4
 80004e8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80004ec:	fa23 f304 	lsr.w	r3, r3, r4
 80004f0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80004f4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80004f8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80004fc:	eba0 0001 	sub.w	r0, r0, r1
 8000500:	4770      	bx	lr
 8000502:	ba24      	rev	r4, r4
 8000504:	fab4 f484 	clz	r4, r4
 8000508:	f024 0407 	bic.w	r4, r4, #7
 800050c:	fa26 f104 	lsr.w	r1, r6, r4
 8000510:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000514:	fa22 f204 	lsr.w	r2, r2, r4
 8000518:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800051c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000520:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000524:	eba0 0001 	sub.w	r0, r0, r1
 8000528:	4770      	bx	lr
 800052a:	f014 0f03 	tst.w	r4, #3
 800052e:	d13c      	bne.n	80005aa <strcmp+0x182>
 8000530:	f010 0403 	ands.w	r4, r0, #3
 8000534:	d128      	bne.n	8000588 <strcmp+0x160>
 8000536:	f850 2b08 	ldr.w	r2, [r0], #8
 800053a:	f851 3b08 	ldr.w	r3, [r1], #8
 800053e:	fa82 f54c 	uadd8	r5, r2, ip
 8000542:	ea82 0503 	eor.w	r5, r2, r3
 8000546:	faa5 f58c 	sel	r5, r5, ip
 800054a:	b95d      	cbnz	r5, 8000564 <strcmp+0x13c>
 800054c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000550:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000554:	fa82 f54c 	uadd8	r5, r2, ip
 8000558:	ea82 0503 	eor.w	r5, r2, r3
 800055c:	faa5 f58c 	sel	r5, r5, ip
 8000560:	2d00      	cmp	r5, #0
 8000562:	d0e8      	beq.n	8000536 <strcmp+0x10e>
 8000564:	ba2d      	rev	r5, r5
 8000566:	fab5 f485 	clz	r4, r5
 800056a:	f024 0407 	bic.w	r4, r4, #7
 800056e:	fa23 f104 	lsr.w	r1, r3, r4
 8000572:	fa22 f204 	lsr.w	r2, r2, r4
 8000576:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800057a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800057e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000582:	eba0 0001 	sub.w	r0, r0, r1
 8000586:	4770      	bx	lr
 8000588:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800058c:	f020 0003 	bic.w	r0, r0, #3
 8000590:	f850 2b08 	ldr.w	r2, [r0], #8
 8000594:	f021 0103 	bic.w	r1, r1, #3
 8000598:	f851 3b08 	ldr.w	r3, [r1], #8
 800059c:	fa0c f404 	lsl.w	r4, ip, r4
 80005a0:	ea62 0204 	orn	r2, r2, r4
 80005a4:	ea63 0304 	orn	r3, r3, r4
 80005a8:	e7c9      	b.n	800053e <strcmp+0x116>
 80005aa:	f010 0403 	ands.w	r4, r0, #3
 80005ae:	d01a      	beq.n	80005e6 <strcmp+0x1be>
 80005b0:	eba1 0104 	sub.w	r1, r1, r4
 80005b4:	f020 0003 	bic.w	r0, r0, #3
 80005b8:	07e4      	lsls	r4, r4, #31
 80005ba:	f850 2b04 	ldr.w	r2, [r0], #4
 80005be:	d006      	beq.n	80005ce <strcmp+0x1a6>
 80005c0:	d20f      	bcs.n	80005e2 <strcmp+0x1ba>
 80005c2:	788b      	ldrb	r3, [r1, #2]
 80005c4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80005c8:	1ae4      	subs	r4, r4, r3
 80005ca:	d106      	bne.n	80005da <strcmp+0x1b2>
 80005cc:	b12b      	cbz	r3, 80005da <strcmp+0x1b2>
 80005ce:	78cb      	ldrb	r3, [r1, #3]
 80005d0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80005d4:	1ae4      	subs	r4, r4, r3
 80005d6:	d100      	bne.n	80005da <strcmp+0x1b2>
 80005d8:	b91b      	cbnz	r3, 80005e2 <strcmp+0x1ba>
 80005da:	4620      	mov	r0, r4
 80005dc:	f85d 4b10 	ldr.w	r4, [sp], #16
 80005e0:	4770      	bx	lr
 80005e2:	f101 0104 	add.w	r1, r1, #4
 80005e6:	f850 2b04 	ldr.w	r2, [r0], #4
 80005ea:	07cc      	lsls	r4, r1, #31
 80005ec:	f021 0103 	bic.w	r1, r1, #3
 80005f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80005f4:	d848      	bhi.n	8000688 <strcmp+0x260>
 80005f6:	d224      	bcs.n	8000642 <strcmp+0x21a>
 80005f8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 80005fc:	fa82 f54c 	uadd8	r5, r2, ip
 8000600:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000604:	faa5 f58c 	sel	r5, r5, ip
 8000608:	d10a      	bne.n	8000620 <strcmp+0x1f8>
 800060a:	b965      	cbnz	r5, 8000626 <strcmp+0x1fe>
 800060c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000610:	ea84 0402 	eor.w	r4, r4, r2
 8000614:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000618:	d10e      	bne.n	8000638 <strcmp+0x210>
 800061a:	f850 2b04 	ldr.w	r2, [r0], #4
 800061e:	e7eb      	b.n	80005f8 <strcmp+0x1d0>
 8000620:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000624:	e055      	b.n	80006d2 <strcmp+0x2aa>
 8000626:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800062a:	d14d      	bne.n	80006c8 <strcmp+0x2a0>
 800062c:	7808      	ldrb	r0, [r1, #0]
 800062e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000632:	f1c0 0000 	rsb	r0, r0, #0
 8000636:	4770      	bx	lr
 8000638:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800063c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000640:	e047      	b.n	80006d2 <strcmp+0x2aa>
 8000642:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000646:	fa82 f54c 	uadd8	r5, r2, ip
 800064a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800064e:	faa5 f58c 	sel	r5, r5, ip
 8000652:	d10a      	bne.n	800066a <strcmp+0x242>
 8000654:	b965      	cbnz	r5, 8000670 <strcmp+0x248>
 8000656:	f851 3b04 	ldr.w	r3, [r1], #4
 800065a:	ea84 0402 	eor.w	r4, r4, r2
 800065e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000662:	d10c      	bne.n	800067e <strcmp+0x256>
 8000664:	f850 2b04 	ldr.w	r2, [r0], #4
 8000668:	e7eb      	b.n	8000642 <strcmp+0x21a>
 800066a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800066e:	e030      	b.n	80006d2 <strcmp+0x2aa>
 8000670:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000674:	d128      	bne.n	80006c8 <strcmp+0x2a0>
 8000676:	880b      	ldrh	r3, [r1, #0]
 8000678:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800067c:	e029      	b.n	80006d2 <strcmp+0x2aa>
 800067e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000682:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000686:	e024      	b.n	80006d2 <strcmp+0x2aa>
 8000688:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800068c:	fa82 f54c 	uadd8	r5, r2, ip
 8000690:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000694:	faa5 f58c 	sel	r5, r5, ip
 8000698:	d10a      	bne.n	80006b0 <strcmp+0x288>
 800069a:	b965      	cbnz	r5, 80006b6 <strcmp+0x28e>
 800069c:	f851 3b04 	ldr.w	r3, [r1], #4
 80006a0:	ea84 0402 	eor.w	r4, r4, r2
 80006a4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80006a8:	d109      	bne.n	80006be <strcmp+0x296>
 80006aa:	f850 2b04 	ldr.w	r2, [r0], #4
 80006ae:	e7eb      	b.n	8000688 <strcmp+0x260>
 80006b0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006b4:	e00d      	b.n	80006d2 <strcmp+0x2aa>
 80006b6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80006ba:	d105      	bne.n	80006c8 <strcmp+0x2a0>
 80006bc:	680b      	ldr	r3, [r1, #0]
 80006be:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80006c2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80006c6:	e004      	b.n	80006d2 <strcmp+0x2aa>
 80006c8:	f04f 0000 	mov.w	r0, #0
 80006cc:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006d0:	4770      	bx	lr
 80006d2:	ba12      	rev	r2, r2
 80006d4:	ba1b      	rev	r3, r3
 80006d6:	fa82 f44c 	uadd8	r4, r2, ip
 80006da:	ea82 0403 	eor.w	r4, r2, r3
 80006de:	faa4 f58c 	sel	r5, r4, ip
 80006e2:	fab5 f485 	clz	r4, r5
 80006e6:	fa02 f204 	lsl.w	r2, r2, r4
 80006ea:	fa03 f304 	lsl.w	r3, r3, r4
 80006ee:	ea4f 6012 	mov.w	r0, r2, lsr #24
 80006f2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006f6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 80006fa:	4770      	bx	lr
 80006fc:	f3af 8000 	nop.w

08000700 <__aeabi_drsub>:
 8000700:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000704:	e002      	b.n	800070c <__adddf3>
 8000706:	bf00      	nop

08000708 <__aeabi_dsub>:
 8000708:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800070c <__adddf3>:
 800070c:	b530      	push	{r4, r5, lr}
 800070e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000712:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000716:	ea94 0f05 	teq	r4, r5
 800071a:	bf08      	it	eq
 800071c:	ea90 0f02 	teqeq	r0, r2
 8000720:	bf1f      	itttt	ne
 8000722:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000726:	ea55 0c02 	orrsne.w	ip, r5, r2
 800072a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800072e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000732:	f000 80e2 	beq.w	80008fa <__adddf3+0x1ee>
 8000736:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800073a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800073e:	bfb8      	it	lt
 8000740:	426d      	neglt	r5, r5
 8000742:	dd0c      	ble.n	800075e <__adddf3+0x52>
 8000744:	442c      	add	r4, r5
 8000746:	ea80 0202 	eor.w	r2, r0, r2
 800074a:	ea81 0303 	eor.w	r3, r1, r3
 800074e:	ea82 0000 	eor.w	r0, r2, r0
 8000752:	ea83 0101 	eor.w	r1, r3, r1
 8000756:	ea80 0202 	eor.w	r2, r0, r2
 800075a:	ea81 0303 	eor.w	r3, r1, r3
 800075e:	2d36      	cmp	r5, #54	; 0x36
 8000760:	bf88      	it	hi
 8000762:	bd30      	pophi	{r4, r5, pc}
 8000764:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000768:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800076c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000770:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000774:	d002      	beq.n	800077c <__adddf3+0x70>
 8000776:	4240      	negs	r0, r0
 8000778:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800077c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000780:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000784:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000788:	d002      	beq.n	8000790 <__adddf3+0x84>
 800078a:	4252      	negs	r2, r2
 800078c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000790:	ea94 0f05 	teq	r4, r5
 8000794:	f000 80a7 	beq.w	80008e6 <__adddf3+0x1da>
 8000798:	f1a4 0401 	sub.w	r4, r4, #1
 800079c:	f1d5 0e20 	rsbs	lr, r5, #32
 80007a0:	db0d      	blt.n	80007be <__adddf3+0xb2>
 80007a2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80007a6:	fa22 f205 	lsr.w	r2, r2, r5
 80007aa:	1880      	adds	r0, r0, r2
 80007ac:	f141 0100 	adc.w	r1, r1, #0
 80007b0:	fa03 f20e 	lsl.w	r2, r3, lr
 80007b4:	1880      	adds	r0, r0, r2
 80007b6:	fa43 f305 	asr.w	r3, r3, r5
 80007ba:	4159      	adcs	r1, r3
 80007bc:	e00e      	b.n	80007dc <__adddf3+0xd0>
 80007be:	f1a5 0520 	sub.w	r5, r5, #32
 80007c2:	f10e 0e20 	add.w	lr, lr, #32
 80007c6:	2a01      	cmp	r2, #1
 80007c8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80007cc:	bf28      	it	cs
 80007ce:	f04c 0c02 	orrcs.w	ip, ip, #2
 80007d2:	fa43 f305 	asr.w	r3, r3, r5
 80007d6:	18c0      	adds	r0, r0, r3
 80007d8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80007dc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80007e0:	d507      	bpl.n	80007f2 <__adddf3+0xe6>
 80007e2:	f04f 0e00 	mov.w	lr, #0
 80007e6:	f1dc 0c00 	rsbs	ip, ip, #0
 80007ea:	eb7e 0000 	sbcs.w	r0, lr, r0
 80007ee:	eb6e 0101 	sbc.w	r1, lr, r1
 80007f2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80007f6:	d31b      	bcc.n	8000830 <__adddf3+0x124>
 80007f8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80007fc:	d30c      	bcc.n	8000818 <__adddf3+0x10c>
 80007fe:	0849      	lsrs	r1, r1, #1
 8000800:	ea5f 0030 	movs.w	r0, r0, rrx
 8000804:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000808:	f104 0401 	add.w	r4, r4, #1
 800080c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000810:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000814:	f080 809a 	bcs.w	800094c <__adddf3+0x240>
 8000818:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800081c:	bf08      	it	eq
 800081e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000822:	f150 0000 	adcs.w	r0, r0, #0
 8000826:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800082a:	ea41 0105 	orr.w	r1, r1, r5
 800082e:	bd30      	pop	{r4, r5, pc}
 8000830:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000834:	4140      	adcs	r0, r0
 8000836:	eb41 0101 	adc.w	r1, r1, r1
 800083a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800083e:	f1a4 0401 	sub.w	r4, r4, #1
 8000842:	d1e9      	bne.n	8000818 <__adddf3+0x10c>
 8000844:	f091 0f00 	teq	r1, #0
 8000848:	bf04      	itt	eq
 800084a:	4601      	moveq	r1, r0
 800084c:	2000      	moveq	r0, #0
 800084e:	fab1 f381 	clz	r3, r1
 8000852:	bf08      	it	eq
 8000854:	3320      	addeq	r3, #32
 8000856:	f1a3 030b 	sub.w	r3, r3, #11
 800085a:	f1b3 0220 	subs.w	r2, r3, #32
 800085e:	da0c      	bge.n	800087a <__adddf3+0x16e>
 8000860:	320c      	adds	r2, #12
 8000862:	dd08      	ble.n	8000876 <__adddf3+0x16a>
 8000864:	f102 0c14 	add.w	ip, r2, #20
 8000868:	f1c2 020c 	rsb	r2, r2, #12
 800086c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000870:	fa21 f102 	lsr.w	r1, r1, r2
 8000874:	e00c      	b.n	8000890 <__adddf3+0x184>
 8000876:	f102 0214 	add.w	r2, r2, #20
 800087a:	bfd8      	it	le
 800087c:	f1c2 0c20 	rsble	ip, r2, #32
 8000880:	fa01 f102 	lsl.w	r1, r1, r2
 8000884:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000888:	bfdc      	itt	le
 800088a:	ea41 010c 	orrle.w	r1, r1, ip
 800088e:	4090      	lslle	r0, r2
 8000890:	1ae4      	subs	r4, r4, r3
 8000892:	bfa2      	ittt	ge
 8000894:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000898:	4329      	orrge	r1, r5
 800089a:	bd30      	popge	{r4, r5, pc}
 800089c:	ea6f 0404 	mvn.w	r4, r4
 80008a0:	3c1f      	subs	r4, #31
 80008a2:	da1c      	bge.n	80008de <__adddf3+0x1d2>
 80008a4:	340c      	adds	r4, #12
 80008a6:	dc0e      	bgt.n	80008c6 <__adddf3+0x1ba>
 80008a8:	f104 0414 	add.w	r4, r4, #20
 80008ac:	f1c4 0220 	rsb	r2, r4, #32
 80008b0:	fa20 f004 	lsr.w	r0, r0, r4
 80008b4:	fa01 f302 	lsl.w	r3, r1, r2
 80008b8:	ea40 0003 	orr.w	r0, r0, r3
 80008bc:	fa21 f304 	lsr.w	r3, r1, r4
 80008c0:	ea45 0103 	orr.w	r1, r5, r3
 80008c4:	bd30      	pop	{r4, r5, pc}
 80008c6:	f1c4 040c 	rsb	r4, r4, #12
 80008ca:	f1c4 0220 	rsb	r2, r4, #32
 80008ce:	fa20 f002 	lsr.w	r0, r0, r2
 80008d2:	fa01 f304 	lsl.w	r3, r1, r4
 80008d6:	ea40 0003 	orr.w	r0, r0, r3
 80008da:	4629      	mov	r1, r5
 80008dc:	bd30      	pop	{r4, r5, pc}
 80008de:	fa21 f004 	lsr.w	r0, r1, r4
 80008e2:	4629      	mov	r1, r5
 80008e4:	bd30      	pop	{r4, r5, pc}
 80008e6:	f094 0f00 	teq	r4, #0
 80008ea:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80008ee:	bf06      	itte	eq
 80008f0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80008f4:	3401      	addeq	r4, #1
 80008f6:	3d01      	subne	r5, #1
 80008f8:	e74e      	b.n	8000798 <__adddf3+0x8c>
 80008fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80008fe:	bf18      	it	ne
 8000900:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000904:	d029      	beq.n	800095a <__adddf3+0x24e>
 8000906:	ea94 0f05 	teq	r4, r5
 800090a:	bf08      	it	eq
 800090c:	ea90 0f02 	teqeq	r0, r2
 8000910:	d005      	beq.n	800091e <__adddf3+0x212>
 8000912:	ea54 0c00 	orrs.w	ip, r4, r0
 8000916:	bf04      	itt	eq
 8000918:	4619      	moveq	r1, r3
 800091a:	4610      	moveq	r0, r2
 800091c:	bd30      	pop	{r4, r5, pc}
 800091e:	ea91 0f03 	teq	r1, r3
 8000922:	bf1e      	ittt	ne
 8000924:	2100      	movne	r1, #0
 8000926:	2000      	movne	r0, #0
 8000928:	bd30      	popne	{r4, r5, pc}
 800092a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800092e:	d105      	bne.n	800093c <__adddf3+0x230>
 8000930:	0040      	lsls	r0, r0, #1
 8000932:	4149      	adcs	r1, r1
 8000934:	bf28      	it	cs
 8000936:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800093a:	bd30      	pop	{r4, r5, pc}
 800093c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000940:	bf3c      	itt	cc
 8000942:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000946:	bd30      	popcc	{r4, r5, pc}
 8000948:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800094c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000950:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000954:	f04f 0000 	mov.w	r0, #0
 8000958:	bd30      	pop	{r4, r5, pc}
 800095a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800095e:	bf1a      	itte	ne
 8000960:	4619      	movne	r1, r3
 8000962:	4610      	movne	r0, r2
 8000964:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000968:	bf1c      	itt	ne
 800096a:	460b      	movne	r3, r1
 800096c:	4602      	movne	r2, r0
 800096e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000972:	bf06      	itte	eq
 8000974:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000978:	ea91 0f03 	teqeq	r1, r3
 800097c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000980:	bd30      	pop	{r4, r5, pc}
 8000982:	bf00      	nop

08000984 <__aeabi_ui2d>:
 8000984:	f090 0f00 	teq	r0, #0
 8000988:	bf04      	itt	eq
 800098a:	2100      	moveq	r1, #0
 800098c:	4770      	bxeq	lr
 800098e:	b530      	push	{r4, r5, lr}
 8000990:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000994:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000998:	f04f 0500 	mov.w	r5, #0
 800099c:	f04f 0100 	mov.w	r1, #0
 80009a0:	e750      	b.n	8000844 <__adddf3+0x138>
 80009a2:	bf00      	nop

080009a4 <__aeabi_i2d>:
 80009a4:	f090 0f00 	teq	r0, #0
 80009a8:	bf04      	itt	eq
 80009aa:	2100      	moveq	r1, #0
 80009ac:	4770      	bxeq	lr
 80009ae:	b530      	push	{r4, r5, lr}
 80009b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80009b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80009b8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80009bc:	bf48      	it	mi
 80009be:	4240      	negmi	r0, r0
 80009c0:	f04f 0100 	mov.w	r1, #0
 80009c4:	e73e      	b.n	8000844 <__adddf3+0x138>
 80009c6:	bf00      	nop

080009c8 <__aeabi_f2d>:
 80009c8:	0042      	lsls	r2, r0, #1
 80009ca:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80009ce:	ea4f 0131 	mov.w	r1, r1, rrx
 80009d2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80009d6:	bf1f      	itttt	ne
 80009d8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80009dc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80009e0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80009e4:	4770      	bxne	lr
 80009e6:	f092 0f00 	teq	r2, #0
 80009ea:	bf14      	ite	ne
 80009ec:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80009f0:	4770      	bxeq	lr
 80009f2:	b530      	push	{r4, r5, lr}
 80009f4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80009f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80009fc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000a00:	e720      	b.n	8000844 <__adddf3+0x138>
 8000a02:	bf00      	nop

08000a04 <__aeabi_ul2d>:
 8000a04:	ea50 0201 	orrs.w	r2, r0, r1
 8000a08:	bf08      	it	eq
 8000a0a:	4770      	bxeq	lr
 8000a0c:	b530      	push	{r4, r5, lr}
 8000a0e:	f04f 0500 	mov.w	r5, #0
 8000a12:	e00a      	b.n	8000a2a <__aeabi_l2d+0x16>

08000a14 <__aeabi_l2d>:
 8000a14:	ea50 0201 	orrs.w	r2, r0, r1
 8000a18:	bf08      	it	eq
 8000a1a:	4770      	bxeq	lr
 8000a1c:	b530      	push	{r4, r5, lr}
 8000a1e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000a22:	d502      	bpl.n	8000a2a <__aeabi_l2d+0x16>
 8000a24:	4240      	negs	r0, r0
 8000a26:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000a2a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000a2e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000a32:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000a36:	f43f aedc 	beq.w	80007f2 <__adddf3+0xe6>
 8000a3a:	f04f 0203 	mov.w	r2, #3
 8000a3e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000a42:	bf18      	it	ne
 8000a44:	3203      	addne	r2, #3
 8000a46:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000a4a:	bf18      	it	ne
 8000a4c:	3203      	addne	r2, #3
 8000a4e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000a52:	f1c2 0320 	rsb	r3, r2, #32
 8000a56:	fa00 fc03 	lsl.w	ip, r0, r3
 8000a5a:	fa20 f002 	lsr.w	r0, r0, r2
 8000a5e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000a62:	ea40 000e 	orr.w	r0, r0, lr
 8000a66:	fa21 f102 	lsr.w	r1, r1, r2
 8000a6a:	4414      	add	r4, r2
 8000a6c:	e6c1      	b.n	80007f2 <__adddf3+0xe6>
 8000a6e:	bf00      	nop

08000a70 <__aeabi_dmul>:
 8000a70:	b570      	push	{r4, r5, r6, lr}
 8000a72:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000a76:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000a7a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000a7e:	bf1d      	ittte	ne
 8000a80:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000a84:	ea94 0f0c 	teqne	r4, ip
 8000a88:	ea95 0f0c 	teqne	r5, ip
 8000a8c:	f000 f8de 	bleq	8000c4c <__aeabi_dmul+0x1dc>
 8000a90:	442c      	add	r4, r5
 8000a92:	ea81 0603 	eor.w	r6, r1, r3
 8000a96:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000a9a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000a9e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000aa2:	bf18      	it	ne
 8000aa4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000aa8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000aac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000ab0:	d038      	beq.n	8000b24 <__aeabi_dmul+0xb4>
 8000ab2:	fba0 ce02 	umull	ip, lr, r0, r2
 8000ab6:	f04f 0500 	mov.w	r5, #0
 8000aba:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000abe:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000ac2:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000ac6:	f04f 0600 	mov.w	r6, #0
 8000aca:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000ace:	f09c 0f00 	teq	ip, #0
 8000ad2:	bf18      	it	ne
 8000ad4:	f04e 0e01 	orrne.w	lr, lr, #1
 8000ad8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000adc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000ae0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000ae4:	d204      	bcs.n	8000af0 <__aeabi_dmul+0x80>
 8000ae6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000aea:	416d      	adcs	r5, r5
 8000aec:	eb46 0606 	adc.w	r6, r6, r6
 8000af0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000af4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000af8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000afc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000b00:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000b04:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000b08:	bf88      	it	hi
 8000b0a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000b0e:	d81e      	bhi.n	8000b4e <__aeabi_dmul+0xde>
 8000b10:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000b14:	bf08      	it	eq
 8000b16:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000b1a:	f150 0000 	adcs.w	r0, r0, #0
 8000b1e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000b22:	bd70      	pop	{r4, r5, r6, pc}
 8000b24:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000b28:	ea46 0101 	orr.w	r1, r6, r1
 8000b2c:	ea40 0002 	orr.w	r0, r0, r2
 8000b30:	ea81 0103 	eor.w	r1, r1, r3
 8000b34:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000b38:	bfc2      	ittt	gt
 8000b3a:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000b3e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000b42:	bd70      	popgt	{r4, r5, r6, pc}
 8000b44:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000b48:	f04f 0e00 	mov.w	lr, #0
 8000b4c:	3c01      	subs	r4, #1
 8000b4e:	f300 80ab 	bgt.w	8000ca8 <__aeabi_dmul+0x238>
 8000b52:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000b56:	bfde      	ittt	le
 8000b58:	2000      	movle	r0, #0
 8000b5a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000b5e:	bd70      	pople	{r4, r5, r6, pc}
 8000b60:	f1c4 0400 	rsb	r4, r4, #0
 8000b64:	3c20      	subs	r4, #32
 8000b66:	da35      	bge.n	8000bd4 <__aeabi_dmul+0x164>
 8000b68:	340c      	adds	r4, #12
 8000b6a:	dc1b      	bgt.n	8000ba4 <__aeabi_dmul+0x134>
 8000b6c:	f104 0414 	add.w	r4, r4, #20
 8000b70:	f1c4 0520 	rsb	r5, r4, #32
 8000b74:	fa00 f305 	lsl.w	r3, r0, r5
 8000b78:	fa20 f004 	lsr.w	r0, r0, r4
 8000b7c:	fa01 f205 	lsl.w	r2, r1, r5
 8000b80:	ea40 0002 	orr.w	r0, r0, r2
 8000b84:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000b88:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000b8c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000b90:	fa21 f604 	lsr.w	r6, r1, r4
 8000b94:	eb42 0106 	adc.w	r1, r2, r6
 8000b98:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000b9c:	bf08      	it	eq
 8000b9e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000ba2:	bd70      	pop	{r4, r5, r6, pc}
 8000ba4:	f1c4 040c 	rsb	r4, r4, #12
 8000ba8:	f1c4 0520 	rsb	r5, r4, #32
 8000bac:	fa00 f304 	lsl.w	r3, r0, r4
 8000bb0:	fa20 f005 	lsr.w	r0, r0, r5
 8000bb4:	fa01 f204 	lsl.w	r2, r1, r4
 8000bb8:	ea40 0002 	orr.w	r0, r0, r2
 8000bbc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000bc0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000bc4:	f141 0100 	adc.w	r1, r1, #0
 8000bc8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000bcc:	bf08      	it	eq
 8000bce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000bd2:	bd70      	pop	{r4, r5, r6, pc}
 8000bd4:	f1c4 0520 	rsb	r5, r4, #32
 8000bd8:	fa00 f205 	lsl.w	r2, r0, r5
 8000bdc:	ea4e 0e02 	orr.w	lr, lr, r2
 8000be0:	fa20 f304 	lsr.w	r3, r0, r4
 8000be4:	fa01 f205 	lsl.w	r2, r1, r5
 8000be8:	ea43 0302 	orr.w	r3, r3, r2
 8000bec:	fa21 f004 	lsr.w	r0, r1, r4
 8000bf0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000bf4:	fa21 f204 	lsr.w	r2, r1, r4
 8000bf8:	ea20 0002 	bic.w	r0, r0, r2
 8000bfc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000c00:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000c04:	bf08      	it	eq
 8000c06:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000c0a:	bd70      	pop	{r4, r5, r6, pc}
 8000c0c:	f094 0f00 	teq	r4, #0
 8000c10:	d10f      	bne.n	8000c32 <__aeabi_dmul+0x1c2>
 8000c12:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000c16:	0040      	lsls	r0, r0, #1
 8000c18:	eb41 0101 	adc.w	r1, r1, r1
 8000c1c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000c20:	bf08      	it	eq
 8000c22:	3c01      	subeq	r4, #1
 8000c24:	d0f7      	beq.n	8000c16 <__aeabi_dmul+0x1a6>
 8000c26:	ea41 0106 	orr.w	r1, r1, r6
 8000c2a:	f095 0f00 	teq	r5, #0
 8000c2e:	bf18      	it	ne
 8000c30:	4770      	bxne	lr
 8000c32:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000c36:	0052      	lsls	r2, r2, #1
 8000c38:	eb43 0303 	adc.w	r3, r3, r3
 8000c3c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000c40:	bf08      	it	eq
 8000c42:	3d01      	subeq	r5, #1
 8000c44:	d0f7      	beq.n	8000c36 <__aeabi_dmul+0x1c6>
 8000c46:	ea43 0306 	orr.w	r3, r3, r6
 8000c4a:	4770      	bx	lr
 8000c4c:	ea94 0f0c 	teq	r4, ip
 8000c50:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000c54:	bf18      	it	ne
 8000c56:	ea95 0f0c 	teqne	r5, ip
 8000c5a:	d00c      	beq.n	8000c76 <__aeabi_dmul+0x206>
 8000c5c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000c60:	bf18      	it	ne
 8000c62:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000c66:	d1d1      	bne.n	8000c0c <__aeabi_dmul+0x19c>
 8000c68:	ea81 0103 	eor.w	r1, r1, r3
 8000c6c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000c70:	f04f 0000 	mov.w	r0, #0
 8000c74:	bd70      	pop	{r4, r5, r6, pc}
 8000c76:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000c7a:	bf06      	itte	eq
 8000c7c:	4610      	moveq	r0, r2
 8000c7e:	4619      	moveq	r1, r3
 8000c80:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000c84:	d019      	beq.n	8000cba <__aeabi_dmul+0x24a>
 8000c86:	ea94 0f0c 	teq	r4, ip
 8000c8a:	d102      	bne.n	8000c92 <__aeabi_dmul+0x222>
 8000c8c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000c90:	d113      	bne.n	8000cba <__aeabi_dmul+0x24a>
 8000c92:	ea95 0f0c 	teq	r5, ip
 8000c96:	d105      	bne.n	8000ca4 <__aeabi_dmul+0x234>
 8000c98:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000c9c:	bf1c      	itt	ne
 8000c9e:	4610      	movne	r0, r2
 8000ca0:	4619      	movne	r1, r3
 8000ca2:	d10a      	bne.n	8000cba <__aeabi_dmul+0x24a>
 8000ca4:	ea81 0103 	eor.w	r1, r1, r3
 8000ca8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000cac:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000cb0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000cb4:	f04f 0000 	mov.w	r0, #0
 8000cb8:	bd70      	pop	{r4, r5, r6, pc}
 8000cba:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000cbe:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000cc2:	bd70      	pop	{r4, r5, r6, pc}

08000cc4 <__aeabi_ddiv>:
 8000cc4:	b570      	push	{r4, r5, r6, lr}
 8000cc6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000cca:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000cce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000cd2:	bf1d      	ittte	ne
 8000cd4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000cd8:	ea94 0f0c 	teqne	r4, ip
 8000cdc:	ea95 0f0c 	teqne	r5, ip
 8000ce0:	f000 f8a7 	bleq	8000e32 <__aeabi_ddiv+0x16e>
 8000ce4:	eba4 0405 	sub.w	r4, r4, r5
 8000ce8:	ea81 0e03 	eor.w	lr, r1, r3
 8000cec:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000cf0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000cf4:	f000 8088 	beq.w	8000e08 <__aeabi_ddiv+0x144>
 8000cf8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000cfc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000d00:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000d04:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000d08:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000d0c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000d10:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000d14:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000d18:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000d1c:	429d      	cmp	r5, r3
 8000d1e:	bf08      	it	eq
 8000d20:	4296      	cmpeq	r6, r2
 8000d22:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000d26:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000d2a:	d202      	bcs.n	8000d32 <__aeabi_ddiv+0x6e>
 8000d2c:	085b      	lsrs	r3, r3, #1
 8000d2e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d32:	1ab6      	subs	r6, r6, r2
 8000d34:	eb65 0503 	sbc.w	r5, r5, r3
 8000d38:	085b      	lsrs	r3, r3, #1
 8000d3a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d3e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000d42:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000d46:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d4a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d4e:	bf22      	ittt	cs
 8000d50:	1ab6      	subcs	r6, r6, r2
 8000d52:	4675      	movcs	r5, lr
 8000d54:	ea40 000c 	orrcs.w	r0, r0, ip
 8000d58:	085b      	lsrs	r3, r3, #1
 8000d5a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d5e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d62:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d66:	bf22      	ittt	cs
 8000d68:	1ab6      	subcs	r6, r6, r2
 8000d6a:	4675      	movcs	r5, lr
 8000d6c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000d70:	085b      	lsrs	r3, r3, #1
 8000d72:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d76:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d7a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d7e:	bf22      	ittt	cs
 8000d80:	1ab6      	subcs	r6, r6, r2
 8000d82:	4675      	movcs	r5, lr
 8000d84:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000d88:	085b      	lsrs	r3, r3, #1
 8000d8a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d8e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d92:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d96:	bf22      	ittt	cs
 8000d98:	1ab6      	subcs	r6, r6, r2
 8000d9a:	4675      	movcs	r5, lr
 8000d9c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000da0:	ea55 0e06 	orrs.w	lr, r5, r6
 8000da4:	d018      	beq.n	8000dd8 <__aeabi_ddiv+0x114>
 8000da6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000daa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000dae:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000db2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000db6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000dba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000dbe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000dc2:	d1c0      	bne.n	8000d46 <__aeabi_ddiv+0x82>
 8000dc4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000dc8:	d10b      	bne.n	8000de2 <__aeabi_ddiv+0x11e>
 8000dca:	ea41 0100 	orr.w	r1, r1, r0
 8000dce:	f04f 0000 	mov.w	r0, #0
 8000dd2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000dd6:	e7b6      	b.n	8000d46 <__aeabi_ddiv+0x82>
 8000dd8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000ddc:	bf04      	itt	eq
 8000dde:	4301      	orreq	r1, r0
 8000de0:	2000      	moveq	r0, #0
 8000de2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000de6:	bf88      	it	hi
 8000de8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000dec:	f63f aeaf 	bhi.w	8000b4e <__aeabi_dmul+0xde>
 8000df0:	ebb5 0c03 	subs.w	ip, r5, r3
 8000df4:	bf04      	itt	eq
 8000df6:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000dfa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000dfe:	f150 0000 	adcs.w	r0, r0, #0
 8000e02:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000e06:	bd70      	pop	{r4, r5, r6, pc}
 8000e08:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000e0c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000e10:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000e14:	bfc2      	ittt	gt
 8000e16:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000e1a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000e1e:	bd70      	popgt	{r4, r5, r6, pc}
 8000e20:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000e24:	f04f 0e00 	mov.w	lr, #0
 8000e28:	3c01      	subs	r4, #1
 8000e2a:	e690      	b.n	8000b4e <__aeabi_dmul+0xde>
 8000e2c:	ea45 0e06 	orr.w	lr, r5, r6
 8000e30:	e68d      	b.n	8000b4e <__aeabi_dmul+0xde>
 8000e32:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000e36:	ea94 0f0c 	teq	r4, ip
 8000e3a:	bf08      	it	eq
 8000e3c:	ea95 0f0c 	teqeq	r5, ip
 8000e40:	f43f af3b 	beq.w	8000cba <__aeabi_dmul+0x24a>
 8000e44:	ea94 0f0c 	teq	r4, ip
 8000e48:	d10a      	bne.n	8000e60 <__aeabi_ddiv+0x19c>
 8000e4a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000e4e:	f47f af34 	bne.w	8000cba <__aeabi_dmul+0x24a>
 8000e52:	ea95 0f0c 	teq	r5, ip
 8000e56:	f47f af25 	bne.w	8000ca4 <__aeabi_dmul+0x234>
 8000e5a:	4610      	mov	r0, r2
 8000e5c:	4619      	mov	r1, r3
 8000e5e:	e72c      	b.n	8000cba <__aeabi_dmul+0x24a>
 8000e60:	ea95 0f0c 	teq	r5, ip
 8000e64:	d106      	bne.n	8000e74 <__aeabi_ddiv+0x1b0>
 8000e66:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000e6a:	f43f aefd 	beq.w	8000c68 <__aeabi_dmul+0x1f8>
 8000e6e:	4610      	mov	r0, r2
 8000e70:	4619      	mov	r1, r3
 8000e72:	e722      	b.n	8000cba <__aeabi_dmul+0x24a>
 8000e74:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000e78:	bf18      	it	ne
 8000e7a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000e7e:	f47f aec5 	bne.w	8000c0c <__aeabi_dmul+0x19c>
 8000e82:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000e86:	f47f af0d 	bne.w	8000ca4 <__aeabi_dmul+0x234>
 8000e8a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000e8e:	f47f aeeb 	bne.w	8000c68 <__aeabi_dmul+0x1f8>
 8000e92:	e712      	b.n	8000cba <__aeabi_dmul+0x24a>

08000e94 <__gedf2>:
 8000e94:	f04f 3cff 	mov.w	ip, #4294967295
 8000e98:	e006      	b.n	8000ea8 <__cmpdf2+0x4>
 8000e9a:	bf00      	nop

08000e9c <__ledf2>:
 8000e9c:	f04f 0c01 	mov.w	ip, #1
 8000ea0:	e002      	b.n	8000ea8 <__cmpdf2+0x4>
 8000ea2:	bf00      	nop

08000ea4 <__cmpdf2>:
 8000ea4:	f04f 0c01 	mov.w	ip, #1
 8000ea8:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000eac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000eb0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000eb4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000eb8:	bf18      	it	ne
 8000eba:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000ebe:	d01b      	beq.n	8000ef8 <__cmpdf2+0x54>
 8000ec0:	b001      	add	sp, #4
 8000ec2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000ec6:	bf0c      	ite	eq
 8000ec8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000ecc:	ea91 0f03 	teqne	r1, r3
 8000ed0:	bf02      	ittt	eq
 8000ed2:	ea90 0f02 	teqeq	r0, r2
 8000ed6:	2000      	moveq	r0, #0
 8000ed8:	4770      	bxeq	lr
 8000eda:	f110 0f00 	cmn.w	r0, #0
 8000ede:	ea91 0f03 	teq	r1, r3
 8000ee2:	bf58      	it	pl
 8000ee4:	4299      	cmppl	r1, r3
 8000ee6:	bf08      	it	eq
 8000ee8:	4290      	cmpeq	r0, r2
 8000eea:	bf2c      	ite	cs
 8000eec:	17d8      	asrcs	r0, r3, #31
 8000eee:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000ef2:	f040 0001 	orr.w	r0, r0, #1
 8000ef6:	4770      	bx	lr
 8000ef8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000efc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f00:	d102      	bne.n	8000f08 <__cmpdf2+0x64>
 8000f02:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000f06:	d107      	bne.n	8000f18 <__cmpdf2+0x74>
 8000f08:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000f0c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f10:	d1d6      	bne.n	8000ec0 <__cmpdf2+0x1c>
 8000f12:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000f16:	d0d3      	beq.n	8000ec0 <__cmpdf2+0x1c>
 8000f18:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000f1c:	4770      	bx	lr
 8000f1e:	bf00      	nop

08000f20 <__aeabi_cdrcmple>:
 8000f20:	4684      	mov	ip, r0
 8000f22:	4610      	mov	r0, r2
 8000f24:	4662      	mov	r2, ip
 8000f26:	468c      	mov	ip, r1
 8000f28:	4619      	mov	r1, r3
 8000f2a:	4663      	mov	r3, ip
 8000f2c:	e000      	b.n	8000f30 <__aeabi_cdcmpeq>
 8000f2e:	bf00      	nop

08000f30 <__aeabi_cdcmpeq>:
 8000f30:	b501      	push	{r0, lr}
 8000f32:	f7ff ffb7 	bl	8000ea4 <__cmpdf2>
 8000f36:	2800      	cmp	r0, #0
 8000f38:	bf48      	it	mi
 8000f3a:	f110 0f00 	cmnmi.w	r0, #0
 8000f3e:	bd01      	pop	{r0, pc}

08000f40 <__aeabi_dcmpeq>:
 8000f40:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f44:	f7ff fff4 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f48:	bf0c      	ite	eq
 8000f4a:	2001      	moveq	r0, #1
 8000f4c:	2000      	movne	r0, #0
 8000f4e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f52:	bf00      	nop

08000f54 <__aeabi_dcmplt>:
 8000f54:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f58:	f7ff ffea 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f5c:	bf34      	ite	cc
 8000f5e:	2001      	movcc	r0, #1
 8000f60:	2000      	movcs	r0, #0
 8000f62:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f66:	bf00      	nop

08000f68 <__aeabi_dcmple>:
 8000f68:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f6c:	f7ff ffe0 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f70:	bf94      	ite	ls
 8000f72:	2001      	movls	r0, #1
 8000f74:	2000      	movhi	r0, #0
 8000f76:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f7a:	bf00      	nop

08000f7c <__aeabi_dcmpge>:
 8000f7c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f80:	f7ff ffce 	bl	8000f20 <__aeabi_cdrcmple>
 8000f84:	bf94      	ite	ls
 8000f86:	2001      	movls	r0, #1
 8000f88:	2000      	movhi	r0, #0
 8000f8a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f8e:	bf00      	nop

08000f90 <__aeabi_dcmpgt>:
 8000f90:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f94:	f7ff ffc4 	bl	8000f20 <__aeabi_cdrcmple>
 8000f98:	bf34      	ite	cc
 8000f9a:	2001      	movcc	r0, #1
 8000f9c:	2000      	movcs	r0, #0
 8000f9e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000fa2:	bf00      	nop

08000fa4 <__aeabi_d2uiz>:
 8000fa4:	004a      	lsls	r2, r1, #1
 8000fa6:	d211      	bcs.n	8000fcc <__aeabi_d2uiz+0x28>
 8000fa8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000fac:	d211      	bcs.n	8000fd2 <__aeabi_d2uiz+0x2e>
 8000fae:	d50d      	bpl.n	8000fcc <__aeabi_d2uiz+0x28>
 8000fb0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000fb4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000fb8:	d40e      	bmi.n	8000fd8 <__aeabi_d2uiz+0x34>
 8000fba:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000fbe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000fc2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000fc6:	fa23 f002 	lsr.w	r0, r3, r2
 8000fca:	4770      	bx	lr
 8000fcc:	f04f 0000 	mov.w	r0, #0
 8000fd0:	4770      	bx	lr
 8000fd2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000fd6:	d102      	bne.n	8000fde <__aeabi_d2uiz+0x3a>
 8000fd8:	f04f 30ff 	mov.w	r0, #4294967295
 8000fdc:	4770      	bx	lr
 8000fde:	f04f 0000 	mov.w	r0, #0
 8000fe2:	4770      	bx	lr

08000fe4 <__aeabi_uldivmod>:
 8000fe4:	b94b      	cbnz	r3, 8000ffa <__aeabi_uldivmod+0x16>
 8000fe6:	b942      	cbnz	r2, 8000ffa <__aeabi_uldivmod+0x16>
 8000fe8:	2900      	cmp	r1, #0
 8000fea:	bf08      	it	eq
 8000fec:	2800      	cmpeq	r0, #0
 8000fee:	d002      	beq.n	8000ff6 <__aeabi_uldivmod+0x12>
 8000ff0:	f04f 31ff 	mov.w	r1, #4294967295
 8000ff4:	4608      	mov	r0, r1
 8000ff6:	f000 b83b 	b.w	8001070 <__aeabi_idiv0>
 8000ffa:	b082      	sub	sp, #8
 8000ffc:	46ec      	mov	ip, sp
 8000ffe:	e92d 5000 	stmdb	sp!, {ip, lr}
 8001002:	f000 f81d 	bl	8001040 <__gnu_uldivmod_helper>
 8001006:	f8dd e004 	ldr.w	lr, [sp, #4]
 800100a:	b002      	add	sp, #8
 800100c:	bc0c      	pop	{r2, r3}
 800100e:	4770      	bx	lr

08001010 <__gnu_ldivmod_helper>:
 8001010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001014:	9c06      	ldr	r4, [sp, #24]
 8001016:	4615      	mov	r5, r2
 8001018:	4606      	mov	r6, r0
 800101a:	460f      	mov	r7, r1
 800101c:	4698      	mov	r8, r3
 800101e:	f000 f829 	bl	8001074 <__divdi3>
 8001022:	fb05 f301 	mul.w	r3, r5, r1
 8001026:	fb00 3808 	mla	r8, r0, r8, r3
 800102a:	fba5 2300 	umull	r2, r3, r5, r0
 800102e:	1ab2      	subs	r2, r6, r2
 8001030:	4443      	add	r3, r8
 8001032:	eb67 0303 	sbc.w	r3, r7, r3
 8001036:	e9c4 2300 	strd	r2, r3, [r4]
 800103a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800103e:	bf00      	nop

08001040 <__gnu_uldivmod_helper>:
 8001040:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001044:	9c06      	ldr	r4, [sp, #24]
 8001046:	4690      	mov	r8, r2
 8001048:	4606      	mov	r6, r0
 800104a:	460f      	mov	r7, r1
 800104c:	461d      	mov	r5, r3
 800104e:	f000 f95f 	bl	8001310 <__udivdi3>
 8001052:	fb00 f505 	mul.w	r5, r0, r5
 8001056:	fba0 2308 	umull	r2, r3, r0, r8
 800105a:	fb08 5501 	mla	r5, r8, r1, r5
 800105e:	1ab2      	subs	r2, r6, r2
 8001060:	442b      	add	r3, r5
 8001062:	eb67 0303 	sbc.w	r3, r7, r3
 8001066:	e9c4 2300 	strd	r2, r3, [r4]
 800106a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800106e:	bf00      	nop

08001070 <__aeabi_idiv0>:
 8001070:	4770      	bx	lr
 8001072:	bf00      	nop

08001074 <__divdi3>:
 8001074:	2900      	cmp	r1, #0
 8001076:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800107a:	f2c0 80a6 	blt.w	80011ca <__divdi3+0x156>
 800107e:	2600      	movs	r6, #0
 8001080:	2b00      	cmp	r3, #0
 8001082:	f2c0 809c 	blt.w	80011be <__divdi3+0x14a>
 8001086:	4688      	mov	r8, r1
 8001088:	4694      	mov	ip, r2
 800108a:	469e      	mov	lr, r3
 800108c:	4615      	mov	r5, r2
 800108e:	4604      	mov	r4, r0
 8001090:	460f      	mov	r7, r1
 8001092:	2b00      	cmp	r3, #0
 8001094:	d13d      	bne.n	8001112 <__divdi3+0x9e>
 8001096:	428a      	cmp	r2, r1
 8001098:	d959      	bls.n	800114e <__divdi3+0xda>
 800109a:	fab2 f382 	clz	r3, r2
 800109e:	b13b      	cbz	r3, 80010b0 <__divdi3+0x3c>
 80010a0:	f1c3 0220 	rsb	r2, r3, #32
 80010a4:	409f      	lsls	r7, r3
 80010a6:	fa20 f202 	lsr.w	r2, r0, r2
 80010aa:	409d      	lsls	r5, r3
 80010ac:	4317      	orrs	r7, r2
 80010ae:	409c      	lsls	r4, r3
 80010b0:	0c29      	lsrs	r1, r5, #16
 80010b2:	0c22      	lsrs	r2, r4, #16
 80010b4:	fbb7 fef1 	udiv	lr, r7, r1
 80010b8:	b2a8      	uxth	r0, r5
 80010ba:	fb01 771e 	mls	r7, r1, lr, r7
 80010be:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 80010c2:	fb00 f30e 	mul.w	r3, r0, lr
 80010c6:	42bb      	cmp	r3, r7
 80010c8:	d90a      	bls.n	80010e0 <__divdi3+0x6c>
 80010ca:	197f      	adds	r7, r7, r5
 80010cc:	f10e 32ff 	add.w	r2, lr, #4294967295
 80010d0:	f080 8105 	bcs.w	80012de <__divdi3+0x26a>
 80010d4:	42bb      	cmp	r3, r7
 80010d6:	f240 8102 	bls.w	80012de <__divdi3+0x26a>
 80010da:	f1ae 0e02 	sub.w	lr, lr, #2
 80010de:	442f      	add	r7, r5
 80010e0:	1aff      	subs	r7, r7, r3
 80010e2:	b2a4      	uxth	r4, r4
 80010e4:	fbb7 f3f1 	udiv	r3, r7, r1
 80010e8:	fb01 7713 	mls	r7, r1, r3, r7
 80010ec:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 80010f0:	fb00 f003 	mul.w	r0, r0, r3
 80010f4:	42b8      	cmp	r0, r7
 80010f6:	d908      	bls.n	800110a <__divdi3+0x96>
 80010f8:	197f      	adds	r7, r7, r5
 80010fa:	f103 32ff 	add.w	r2, r3, #4294967295
 80010fe:	f080 80f0 	bcs.w	80012e2 <__divdi3+0x26e>
 8001102:	42b8      	cmp	r0, r7
 8001104:	f240 80ed 	bls.w	80012e2 <__divdi3+0x26e>
 8001108:	3b02      	subs	r3, #2
 800110a:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 800110e:	2200      	movs	r2, #0
 8001110:	e003      	b.n	800111a <__divdi3+0xa6>
 8001112:	428b      	cmp	r3, r1
 8001114:	d90f      	bls.n	8001136 <__divdi3+0xc2>
 8001116:	2200      	movs	r2, #0
 8001118:	4613      	mov	r3, r2
 800111a:	1c34      	adds	r4, r6, #0
 800111c:	bf18      	it	ne
 800111e:	2401      	movne	r4, #1
 8001120:	4260      	negs	r0, r4
 8001122:	f04f 0500 	mov.w	r5, #0
 8001126:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 800112a:	4058      	eors	r0, r3
 800112c:	4051      	eors	r1, r2
 800112e:	1900      	adds	r0, r0, r4
 8001130:	4169      	adcs	r1, r5
 8001132:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001136:	fab3 f283 	clz	r2, r3
 800113a:	2a00      	cmp	r2, #0
 800113c:	f040 8086 	bne.w	800124c <__divdi3+0x1d8>
 8001140:	428b      	cmp	r3, r1
 8001142:	d302      	bcc.n	800114a <__divdi3+0xd6>
 8001144:	4584      	cmp	ip, r0
 8001146:	f200 80db 	bhi.w	8001300 <__divdi3+0x28c>
 800114a:	2301      	movs	r3, #1
 800114c:	e7e5      	b.n	800111a <__divdi3+0xa6>
 800114e:	b912      	cbnz	r2, 8001156 <__divdi3+0xe2>
 8001150:	2301      	movs	r3, #1
 8001152:	fbb3 f5f2 	udiv	r5, r3, r2
 8001156:	fab5 f085 	clz	r0, r5
 800115a:	2800      	cmp	r0, #0
 800115c:	d13b      	bne.n	80011d6 <__divdi3+0x162>
 800115e:	1b78      	subs	r0, r7, r5
 8001160:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001164:	fa1f fc85 	uxth.w	ip, r5
 8001168:	2201      	movs	r2, #1
 800116a:	fbb0 f8fe 	udiv	r8, r0, lr
 800116e:	0c21      	lsrs	r1, r4, #16
 8001170:	fb0e 0718 	mls	r7, lr, r8, r0
 8001174:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 8001178:	fb0c f308 	mul.w	r3, ip, r8
 800117c:	42bb      	cmp	r3, r7
 800117e:	d907      	bls.n	8001190 <__divdi3+0x11c>
 8001180:	197f      	adds	r7, r7, r5
 8001182:	f108 31ff 	add.w	r1, r8, #4294967295
 8001186:	d202      	bcs.n	800118e <__divdi3+0x11a>
 8001188:	42bb      	cmp	r3, r7
 800118a:	f200 80bd 	bhi.w	8001308 <__divdi3+0x294>
 800118e:	4688      	mov	r8, r1
 8001190:	1aff      	subs	r7, r7, r3
 8001192:	b2a4      	uxth	r4, r4
 8001194:	fbb7 f3fe 	udiv	r3, r7, lr
 8001198:	fb0e 7713 	mls	r7, lr, r3, r7
 800119c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 80011a0:	fb0c fc03 	mul.w	ip, ip, r3
 80011a4:	45bc      	cmp	ip, r7
 80011a6:	d907      	bls.n	80011b8 <__divdi3+0x144>
 80011a8:	197f      	adds	r7, r7, r5
 80011aa:	f103 31ff 	add.w	r1, r3, #4294967295
 80011ae:	d202      	bcs.n	80011b6 <__divdi3+0x142>
 80011b0:	45bc      	cmp	ip, r7
 80011b2:	f200 80a7 	bhi.w	8001304 <__divdi3+0x290>
 80011b6:	460b      	mov	r3, r1
 80011b8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80011bc:	e7ad      	b.n	800111a <__divdi3+0xa6>
 80011be:	4252      	negs	r2, r2
 80011c0:	ea6f 0606 	mvn.w	r6, r6
 80011c4:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80011c8:	e75d      	b.n	8001086 <__divdi3+0x12>
 80011ca:	4240      	negs	r0, r0
 80011cc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80011d0:	f04f 36ff 	mov.w	r6, #4294967295
 80011d4:	e754      	b.n	8001080 <__divdi3+0xc>
 80011d6:	f1c0 0220 	rsb	r2, r0, #32
 80011da:	fa24 f102 	lsr.w	r1, r4, r2
 80011de:	fa07 f300 	lsl.w	r3, r7, r0
 80011e2:	4085      	lsls	r5, r0
 80011e4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80011e8:	40d7      	lsrs	r7, r2
 80011ea:	4319      	orrs	r1, r3
 80011ec:	fbb7 f2fe 	udiv	r2, r7, lr
 80011f0:	0c0b      	lsrs	r3, r1, #16
 80011f2:	fb0e 7712 	mls	r7, lr, r2, r7
 80011f6:	fa1f fc85 	uxth.w	ip, r5
 80011fa:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80011fe:	fb0c f702 	mul.w	r7, ip, r2
 8001202:	429f      	cmp	r7, r3
 8001204:	fa04 f400 	lsl.w	r4, r4, r0
 8001208:	d907      	bls.n	800121a <__divdi3+0x1a6>
 800120a:	195b      	adds	r3, r3, r5
 800120c:	f102 30ff 	add.w	r0, r2, #4294967295
 8001210:	d274      	bcs.n	80012fc <__divdi3+0x288>
 8001212:	429f      	cmp	r7, r3
 8001214:	d972      	bls.n	80012fc <__divdi3+0x288>
 8001216:	3a02      	subs	r2, #2
 8001218:	442b      	add	r3, r5
 800121a:	1bdf      	subs	r7, r3, r7
 800121c:	b289      	uxth	r1, r1
 800121e:	fbb7 f8fe 	udiv	r8, r7, lr
 8001222:	fb0e 7318 	mls	r3, lr, r8, r7
 8001226:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800122a:	fb0c f708 	mul.w	r7, ip, r8
 800122e:	429f      	cmp	r7, r3
 8001230:	d908      	bls.n	8001244 <__divdi3+0x1d0>
 8001232:	195b      	adds	r3, r3, r5
 8001234:	f108 31ff 	add.w	r1, r8, #4294967295
 8001238:	d25c      	bcs.n	80012f4 <__divdi3+0x280>
 800123a:	429f      	cmp	r7, r3
 800123c:	d95a      	bls.n	80012f4 <__divdi3+0x280>
 800123e:	f1a8 0802 	sub.w	r8, r8, #2
 8001242:	442b      	add	r3, r5
 8001244:	1bd8      	subs	r0, r3, r7
 8001246:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 800124a:	e78e      	b.n	800116a <__divdi3+0xf6>
 800124c:	f1c2 0320 	rsb	r3, r2, #32
 8001250:	fa2c f103 	lsr.w	r1, ip, r3
 8001254:	fa0e fe02 	lsl.w	lr, lr, r2
 8001258:	fa20 f703 	lsr.w	r7, r0, r3
 800125c:	ea41 0e0e 	orr.w	lr, r1, lr
 8001260:	fa08 f002 	lsl.w	r0, r8, r2
 8001264:	fa28 f103 	lsr.w	r1, r8, r3
 8001268:	ea4f 451e 	mov.w	r5, lr, lsr #16
 800126c:	4338      	orrs	r0, r7
 800126e:	fbb1 f8f5 	udiv	r8, r1, r5
 8001272:	0c03      	lsrs	r3, r0, #16
 8001274:	fb05 1118 	mls	r1, r5, r8, r1
 8001278:	fa1f f78e 	uxth.w	r7, lr
 800127c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8001280:	fb07 f308 	mul.w	r3, r7, r8
 8001284:	428b      	cmp	r3, r1
 8001286:	fa0c fc02 	lsl.w	ip, ip, r2
 800128a:	d909      	bls.n	80012a0 <__divdi3+0x22c>
 800128c:	eb11 010e 	adds.w	r1, r1, lr
 8001290:	f108 39ff 	add.w	r9, r8, #4294967295
 8001294:	d230      	bcs.n	80012f8 <__divdi3+0x284>
 8001296:	428b      	cmp	r3, r1
 8001298:	d92e      	bls.n	80012f8 <__divdi3+0x284>
 800129a:	f1a8 0802 	sub.w	r8, r8, #2
 800129e:	4471      	add	r1, lr
 80012a0:	1ac9      	subs	r1, r1, r3
 80012a2:	b280      	uxth	r0, r0
 80012a4:	fbb1 f3f5 	udiv	r3, r1, r5
 80012a8:	fb05 1113 	mls	r1, r5, r3, r1
 80012ac:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80012b0:	fb07 f703 	mul.w	r7, r7, r3
 80012b4:	428f      	cmp	r7, r1
 80012b6:	d908      	bls.n	80012ca <__divdi3+0x256>
 80012b8:	eb11 010e 	adds.w	r1, r1, lr
 80012bc:	f103 30ff 	add.w	r0, r3, #4294967295
 80012c0:	d216      	bcs.n	80012f0 <__divdi3+0x27c>
 80012c2:	428f      	cmp	r7, r1
 80012c4:	d914      	bls.n	80012f0 <__divdi3+0x27c>
 80012c6:	3b02      	subs	r3, #2
 80012c8:	4471      	add	r1, lr
 80012ca:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80012ce:	1bc9      	subs	r1, r1, r7
 80012d0:	fba3 890c 	umull	r8, r9, r3, ip
 80012d4:	4549      	cmp	r1, r9
 80012d6:	d309      	bcc.n	80012ec <__divdi3+0x278>
 80012d8:	d005      	beq.n	80012e6 <__divdi3+0x272>
 80012da:	2200      	movs	r2, #0
 80012dc:	e71d      	b.n	800111a <__divdi3+0xa6>
 80012de:	4696      	mov	lr, r2
 80012e0:	e6fe      	b.n	80010e0 <__divdi3+0x6c>
 80012e2:	4613      	mov	r3, r2
 80012e4:	e711      	b.n	800110a <__divdi3+0x96>
 80012e6:	4094      	lsls	r4, r2
 80012e8:	4544      	cmp	r4, r8
 80012ea:	d2f6      	bcs.n	80012da <__divdi3+0x266>
 80012ec:	3b01      	subs	r3, #1
 80012ee:	e7f4      	b.n	80012da <__divdi3+0x266>
 80012f0:	4603      	mov	r3, r0
 80012f2:	e7ea      	b.n	80012ca <__divdi3+0x256>
 80012f4:	4688      	mov	r8, r1
 80012f6:	e7a5      	b.n	8001244 <__divdi3+0x1d0>
 80012f8:	46c8      	mov	r8, r9
 80012fa:	e7d1      	b.n	80012a0 <__divdi3+0x22c>
 80012fc:	4602      	mov	r2, r0
 80012fe:	e78c      	b.n	800121a <__divdi3+0x1a6>
 8001300:	4613      	mov	r3, r2
 8001302:	e70a      	b.n	800111a <__divdi3+0xa6>
 8001304:	3b02      	subs	r3, #2
 8001306:	e757      	b.n	80011b8 <__divdi3+0x144>
 8001308:	f1a8 0802 	sub.w	r8, r8, #2
 800130c:	442f      	add	r7, r5
 800130e:	e73f      	b.n	8001190 <__divdi3+0x11c>

08001310 <__udivdi3>:
 8001310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001314:	2b00      	cmp	r3, #0
 8001316:	d144      	bne.n	80013a2 <__udivdi3+0x92>
 8001318:	428a      	cmp	r2, r1
 800131a:	4615      	mov	r5, r2
 800131c:	4604      	mov	r4, r0
 800131e:	d94f      	bls.n	80013c0 <__udivdi3+0xb0>
 8001320:	fab2 f782 	clz	r7, r2
 8001324:	460e      	mov	r6, r1
 8001326:	b14f      	cbz	r7, 800133c <__udivdi3+0x2c>
 8001328:	f1c7 0320 	rsb	r3, r7, #32
 800132c:	40b9      	lsls	r1, r7
 800132e:	fa20 f603 	lsr.w	r6, r0, r3
 8001332:	fa02 f507 	lsl.w	r5, r2, r7
 8001336:	430e      	orrs	r6, r1
 8001338:	fa00 f407 	lsl.w	r4, r0, r7
 800133c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001340:	0c23      	lsrs	r3, r4, #16
 8001342:	fbb6 f0fe 	udiv	r0, r6, lr
 8001346:	b2af      	uxth	r7, r5
 8001348:	fb0e 6110 	mls	r1, lr, r0, r6
 800134c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8001350:	fb07 f100 	mul.w	r1, r7, r0
 8001354:	4299      	cmp	r1, r3
 8001356:	d909      	bls.n	800136c <__udivdi3+0x5c>
 8001358:	195b      	adds	r3, r3, r5
 800135a:	f100 32ff 	add.w	r2, r0, #4294967295
 800135e:	f080 80ec 	bcs.w	800153a <__udivdi3+0x22a>
 8001362:	4299      	cmp	r1, r3
 8001364:	f240 80e9 	bls.w	800153a <__udivdi3+0x22a>
 8001368:	3802      	subs	r0, #2
 800136a:	442b      	add	r3, r5
 800136c:	1a5a      	subs	r2, r3, r1
 800136e:	b2a4      	uxth	r4, r4
 8001370:	fbb2 f3fe 	udiv	r3, r2, lr
 8001374:	fb0e 2213 	mls	r2, lr, r3, r2
 8001378:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 800137c:	fb07 f703 	mul.w	r7, r7, r3
 8001380:	4297      	cmp	r7, r2
 8001382:	d908      	bls.n	8001396 <__udivdi3+0x86>
 8001384:	1952      	adds	r2, r2, r5
 8001386:	f103 31ff 	add.w	r1, r3, #4294967295
 800138a:	f080 80d8 	bcs.w	800153e <__udivdi3+0x22e>
 800138e:	4297      	cmp	r7, r2
 8001390:	f240 80d5 	bls.w	800153e <__udivdi3+0x22e>
 8001394:	3b02      	subs	r3, #2
 8001396:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 800139a:	2600      	movs	r6, #0
 800139c:	4631      	mov	r1, r6
 800139e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80013a2:	428b      	cmp	r3, r1
 80013a4:	d847      	bhi.n	8001436 <__udivdi3+0x126>
 80013a6:	fab3 f683 	clz	r6, r3
 80013aa:	2e00      	cmp	r6, #0
 80013ac:	d148      	bne.n	8001440 <__udivdi3+0x130>
 80013ae:	428b      	cmp	r3, r1
 80013b0:	d302      	bcc.n	80013b8 <__udivdi3+0xa8>
 80013b2:	4282      	cmp	r2, r0
 80013b4:	f200 80cd 	bhi.w	8001552 <__udivdi3+0x242>
 80013b8:	2001      	movs	r0, #1
 80013ba:	4631      	mov	r1, r6
 80013bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80013c0:	b912      	cbnz	r2, 80013c8 <__udivdi3+0xb8>
 80013c2:	2501      	movs	r5, #1
 80013c4:	fbb5 f5f2 	udiv	r5, r5, r2
 80013c8:	fab5 f885 	clz	r8, r5
 80013cc:	f1b8 0f00 	cmp.w	r8, #0
 80013d0:	d177      	bne.n	80014c2 <__udivdi3+0x1b2>
 80013d2:	1b4a      	subs	r2, r1, r5
 80013d4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80013d8:	b2af      	uxth	r7, r5
 80013da:	2601      	movs	r6, #1
 80013dc:	fbb2 f0fe 	udiv	r0, r2, lr
 80013e0:	0c23      	lsrs	r3, r4, #16
 80013e2:	fb0e 2110 	mls	r1, lr, r0, r2
 80013e6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80013ea:	fb07 f300 	mul.w	r3, r7, r0
 80013ee:	428b      	cmp	r3, r1
 80013f0:	d907      	bls.n	8001402 <__udivdi3+0xf2>
 80013f2:	1949      	adds	r1, r1, r5
 80013f4:	f100 32ff 	add.w	r2, r0, #4294967295
 80013f8:	d202      	bcs.n	8001400 <__udivdi3+0xf0>
 80013fa:	428b      	cmp	r3, r1
 80013fc:	f200 80ba 	bhi.w	8001574 <__udivdi3+0x264>
 8001400:	4610      	mov	r0, r2
 8001402:	1ac9      	subs	r1, r1, r3
 8001404:	b2a4      	uxth	r4, r4
 8001406:	fbb1 f3fe 	udiv	r3, r1, lr
 800140a:	fb0e 1113 	mls	r1, lr, r3, r1
 800140e:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8001412:	fb07 f703 	mul.w	r7, r7, r3
 8001416:	42a7      	cmp	r7, r4
 8001418:	d908      	bls.n	800142c <__udivdi3+0x11c>
 800141a:	1964      	adds	r4, r4, r5
 800141c:	f103 32ff 	add.w	r2, r3, #4294967295
 8001420:	f080 808f 	bcs.w	8001542 <__udivdi3+0x232>
 8001424:	42a7      	cmp	r7, r4
 8001426:	f240 808c 	bls.w	8001542 <__udivdi3+0x232>
 800142a:	3b02      	subs	r3, #2
 800142c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8001430:	4631      	mov	r1, r6
 8001432:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001436:	2600      	movs	r6, #0
 8001438:	4630      	mov	r0, r6
 800143a:	4631      	mov	r1, r6
 800143c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001440:	f1c6 0420 	rsb	r4, r6, #32
 8001444:	fa22 f504 	lsr.w	r5, r2, r4
 8001448:	40b3      	lsls	r3, r6
 800144a:	432b      	orrs	r3, r5
 800144c:	fa20 fc04 	lsr.w	ip, r0, r4
 8001450:	fa01 f706 	lsl.w	r7, r1, r6
 8001454:	fa21 f504 	lsr.w	r5, r1, r4
 8001458:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 800145c:	ea4c 0707 	orr.w	r7, ip, r7
 8001460:	fbb5 f8fe 	udiv	r8, r5, lr
 8001464:	0c39      	lsrs	r1, r7, #16
 8001466:	fb0e 5518 	mls	r5, lr, r8, r5
 800146a:	fa1f fc83 	uxth.w	ip, r3
 800146e:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 8001472:	fb0c f108 	mul.w	r1, ip, r8
 8001476:	42a9      	cmp	r1, r5
 8001478:	fa02 f206 	lsl.w	r2, r2, r6
 800147c:	d904      	bls.n	8001488 <__udivdi3+0x178>
 800147e:	18ed      	adds	r5, r5, r3
 8001480:	f108 34ff 	add.w	r4, r8, #4294967295
 8001484:	d367      	bcc.n	8001556 <__udivdi3+0x246>
 8001486:	46a0      	mov	r8, r4
 8001488:	1a6d      	subs	r5, r5, r1
 800148a:	b2bf      	uxth	r7, r7
 800148c:	fbb5 f4fe 	udiv	r4, r5, lr
 8001490:	fb0e 5514 	mls	r5, lr, r4, r5
 8001494:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 8001498:	fb0c fc04 	mul.w	ip, ip, r4
 800149c:	458c      	cmp	ip, r1
 800149e:	d904      	bls.n	80014aa <__udivdi3+0x19a>
 80014a0:	18c9      	adds	r1, r1, r3
 80014a2:	f104 35ff 	add.w	r5, r4, #4294967295
 80014a6:	d35c      	bcc.n	8001562 <__udivdi3+0x252>
 80014a8:	462c      	mov	r4, r5
 80014aa:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 80014ae:	ebcc 0101 	rsb	r1, ip, r1
 80014b2:	fba4 2302 	umull	r2, r3, r4, r2
 80014b6:	4299      	cmp	r1, r3
 80014b8:	d348      	bcc.n	800154c <__udivdi3+0x23c>
 80014ba:	d044      	beq.n	8001546 <__udivdi3+0x236>
 80014bc:	4620      	mov	r0, r4
 80014be:	2600      	movs	r6, #0
 80014c0:	e76c      	b.n	800139c <__udivdi3+0x8c>
 80014c2:	f1c8 0420 	rsb	r4, r8, #32
 80014c6:	fa01 f308 	lsl.w	r3, r1, r8
 80014ca:	fa05 f508 	lsl.w	r5, r5, r8
 80014ce:	fa20 f704 	lsr.w	r7, r0, r4
 80014d2:	40e1      	lsrs	r1, r4
 80014d4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80014d8:	431f      	orrs	r7, r3
 80014da:	fbb1 f6fe 	udiv	r6, r1, lr
 80014de:	0c3a      	lsrs	r2, r7, #16
 80014e0:	fb0e 1116 	mls	r1, lr, r6, r1
 80014e4:	fa1f fc85 	uxth.w	ip, r5
 80014e8:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 80014ec:	fb0c f206 	mul.w	r2, ip, r6
 80014f0:	429a      	cmp	r2, r3
 80014f2:	fa00 f408 	lsl.w	r4, r0, r8
 80014f6:	d907      	bls.n	8001508 <__udivdi3+0x1f8>
 80014f8:	195b      	adds	r3, r3, r5
 80014fa:	f106 31ff 	add.w	r1, r6, #4294967295
 80014fe:	d237      	bcs.n	8001570 <__udivdi3+0x260>
 8001500:	429a      	cmp	r2, r3
 8001502:	d935      	bls.n	8001570 <__udivdi3+0x260>
 8001504:	3e02      	subs	r6, #2
 8001506:	442b      	add	r3, r5
 8001508:	1a9b      	subs	r3, r3, r2
 800150a:	b2bf      	uxth	r7, r7
 800150c:	fbb3 f0fe 	udiv	r0, r3, lr
 8001510:	fb0e 3310 	mls	r3, lr, r0, r3
 8001514:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 8001518:	fb0c f100 	mul.w	r1, ip, r0
 800151c:	4299      	cmp	r1, r3
 800151e:	d907      	bls.n	8001530 <__udivdi3+0x220>
 8001520:	195b      	adds	r3, r3, r5
 8001522:	f100 32ff 	add.w	r2, r0, #4294967295
 8001526:	d221      	bcs.n	800156c <__udivdi3+0x25c>
 8001528:	4299      	cmp	r1, r3
 800152a:	d91f      	bls.n	800156c <__udivdi3+0x25c>
 800152c:	3802      	subs	r0, #2
 800152e:	442b      	add	r3, r5
 8001530:	1a5a      	subs	r2, r3, r1
 8001532:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8001536:	4667      	mov	r7, ip
 8001538:	e750      	b.n	80013dc <__udivdi3+0xcc>
 800153a:	4610      	mov	r0, r2
 800153c:	e716      	b.n	800136c <__udivdi3+0x5c>
 800153e:	460b      	mov	r3, r1
 8001540:	e729      	b.n	8001396 <__udivdi3+0x86>
 8001542:	4613      	mov	r3, r2
 8001544:	e772      	b.n	800142c <__udivdi3+0x11c>
 8001546:	40b0      	lsls	r0, r6
 8001548:	4290      	cmp	r0, r2
 800154a:	d2b7      	bcs.n	80014bc <__udivdi3+0x1ac>
 800154c:	1e60      	subs	r0, r4, #1
 800154e:	2600      	movs	r6, #0
 8001550:	e724      	b.n	800139c <__udivdi3+0x8c>
 8001552:	4630      	mov	r0, r6
 8001554:	e722      	b.n	800139c <__udivdi3+0x8c>
 8001556:	42a9      	cmp	r1, r5
 8001558:	d995      	bls.n	8001486 <__udivdi3+0x176>
 800155a:	f1a8 0802 	sub.w	r8, r8, #2
 800155e:	441d      	add	r5, r3
 8001560:	e792      	b.n	8001488 <__udivdi3+0x178>
 8001562:	458c      	cmp	ip, r1
 8001564:	d9a0      	bls.n	80014a8 <__udivdi3+0x198>
 8001566:	3c02      	subs	r4, #2
 8001568:	4419      	add	r1, r3
 800156a:	e79e      	b.n	80014aa <__udivdi3+0x19a>
 800156c:	4610      	mov	r0, r2
 800156e:	e7df      	b.n	8001530 <__udivdi3+0x220>
 8001570:	460e      	mov	r6, r1
 8001572:	e7c9      	b.n	8001508 <__udivdi3+0x1f8>
 8001574:	3802      	subs	r0, #2
 8001576:	4429      	add	r1, r5
 8001578:	e743      	b.n	8001402 <__udivdi3+0xf2>
 800157a:	bf00      	nop

0800157c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800157c:	b580      	push	{r7, lr}
 800157e:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch and Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 8001580:	4a08      	ldr	r2, [pc, #32]	; (80015a4 <HAL_Init+0x28>)
 8001582:	4b08      	ldr	r3, [pc, #32]	; (80015a4 <HAL_Init+0x28>)
 8001584:	681b      	ldr	r3, [r3, #0]
 8001586:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800158a:	6013      	str	r3, [r2, #0]
#endif /* ART_ACCLERATOR_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP);
 800158c:	2003      	movs	r0, #3
 800158e:	f002 f821 	bl	80035d4 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(SYSTICK_IRQ_PREEMPT);
 8001592:	200f      	movs	r0, #15
 8001594:	f00c f886 	bl	800d6a4 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 8001598:	f006 ffea 	bl	8008570 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
 800159c:	2300      	movs	r3, #0
}
 800159e:	4618      	mov	r0, r3
 80015a0:	bd80      	pop	{r7, pc}
 80015a2:	bf00      	nop
 80015a4:	40023c00 	.word	0x40023c00

080015a8 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80015a8:	b480      	push	{r7}
 80015aa:	af00      	add	r7, sp, #0
  uwTick++;
 80015ac:	4b04      	ldr	r3, [pc, #16]	; (80015c0 <HAL_IncTick+0x18>)
 80015ae:	681b      	ldr	r3, [r3, #0]
 80015b0:	3301      	adds	r3, #1
 80015b2:	4a03      	ldr	r2, [pc, #12]	; (80015c0 <HAL_IncTick+0x18>)
 80015b4:	6013      	str	r3, [r2, #0]
}
 80015b6:	46bd      	mov	sp, r7
 80015b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015bc:	4770      	bx	lr
 80015be:	bf00      	nop
 80015c0:	200107ac 	.word	0x200107ac

080015c4 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80015c4:	b480      	push	{r7}
 80015c6:	af00      	add	r7, sp, #0
  return uwTick;
 80015c8:	4b03      	ldr	r3, [pc, #12]	; (80015d8 <HAL_GetTick+0x14>)
 80015ca:	681b      	ldr	r3, [r3, #0]
}
 80015cc:	4618      	mov	r0, r3
 80015ce:	46bd      	mov	sp, r7
 80015d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015d4:	4770      	bx	lr
 80015d6:	bf00      	nop
 80015d8:	200107ac 	.word	0x200107ac

080015dc <HAL_ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 80015dc:	b580      	push	{r7, lr}
 80015de:	b082      	sub	sp, #8
 80015e0:	af00      	add	r7, sp, #0
 80015e2:	6078      	str	r0, [r7, #4]
  /* Check ADC handle */
  if(hadc == NULL)
 80015e4:	687b      	ldr	r3, [r7, #4]
 80015e6:	2b00      	cmp	r3, #0
 80015e8:	d101      	bne.n	80015ee <HAL_ADC_Init+0x12>
  {
     return HAL_ERROR;
 80015ea:	2301      	movs	r3, #1
 80015ec:	e01f      	b.n	800162e <HAL_ADC_Init+0x52>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }

  if(hadc->State == HAL_ADC_STATE_RESET)
 80015ee:	687b      	ldr	r3, [r7, #4]
 80015f0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80015f4:	b2db      	uxtb	r3, r3
 80015f6:	2b00      	cmp	r3, #0
 80015f8:	d106      	bne.n	8001608 <HAL_ADC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 80015fa:	687b      	ldr	r3, [r7, #4]
 80015fc:	2200      	movs	r2, #0
 80015fe:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8001602:	6878      	ldr	r0, [r7, #4]
 8001604:	f00c fc7c 	bl	800df00 <HAL_ADC_MspInit>
  }

  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 8001608:	687b      	ldr	r3, [r7, #4]
 800160a:	2202      	movs	r2, #2
 800160c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Set ADC parameters */
  ADC_Init(hadc);
 8001610:	6878      	ldr	r0, [r7, #4]
 8001612:	f000 fb41 	bl	8001c98 <ADC_Init>
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8001616:	687b      	ldr	r3, [r7, #4]
 8001618:	2200      	movs	r2, #0
 800161a:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 800161c:	687b      	ldr	r3, [r7, #4]
 800161e:	2201      	movs	r2, #1
 8001620:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hadc);
 8001624:	687b      	ldr	r3, [r7, #4]
 8001626:	2200      	movs	r2, #0
 8001628:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Return function status */
  return HAL_OK;
 800162c:	2300      	movs	r3, #0
}
 800162e:	4618      	mov	r0, r3
 8001630:	3708      	adds	r7, #8
 8001632:	46bd      	mov	sp, r7
 8001634:	bd80      	pop	{r7, pc}
 8001636:	bf00      	nop

08001638 <HAL_ADC_DeInit>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
{
 8001638:	b580      	push	{r7, lr}
 800163a:	b082      	sub	sp, #8
 800163c:	af00      	add	r7, sp, #0
 800163e:	6078      	str	r0, [r7, #4]
  /* Check ADC handle */
  if(hadc == NULL)
 8001640:	687b      	ldr	r3, [r7, #4]
 8001642:	2b00      	cmp	r3, #0
 8001644:	d101      	bne.n	800164a <HAL_ADC_DeInit+0x12>
  {
     return HAL_ERROR;
 8001646:	2301      	movs	r3, #1
 8001648:	e00e      	b.n	8001668 <HAL_ADC_DeInit+0x30>
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 800164a:	687b      	ldr	r3, [r7, #4]
 800164c:	2202      	movs	r2, #2
 800164e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* DeInit the low level hardware */
  HAL_ADC_MspDeInit(hadc);
 8001652:	6878      	ldr	r0, [r7, #4]
 8001654:	f00c fe9c 	bl	800e390 <HAL_ADC_MspDeInit>
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8001658:	687b      	ldr	r3, [r7, #4]
 800165a:	2200      	movs	r2, #0
 800165c:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_RESET;
 800165e:	687b      	ldr	r3, [r7, #4]
 8001660:	2200      	movs	r2, #0
 8001662:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8001666:	2300      	movs	r3, #0
}
 8001668:	4618      	mov	r0, r3
 800166a:	3708      	adds	r7, #8
 800166c:	46bd      	mov	sp, r7
 800166e:	bd80      	pop	{r7, pc}

08001670 <HAL_ADC_Start>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
{
 8001670:	b480      	push	{r7}
 8001672:	b085      	sub	sp, #20
 8001674:	af00      	add	r7, sp, #0
 8001676:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 8001678:	2300      	movs	r3, #0
 800167a:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
  
  /* Process locked */
  __HAL_LOCK(hadc);
 800167c:	687b      	ldr	r3, [r7, #4]
 800167e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8001682:	2b01      	cmp	r3, #1
 8001684:	d101      	bne.n	800168a <HAL_ADC_Start+0x1a>
 8001686:	2302      	movs	r3, #2
 8001688:	e061      	b.n	800174e <HAL_ADC_Start+0xde>
 800168a:	687b      	ldr	r3, [r7, #4]
 800168c:	2201      	movs	r2, #1
 800168e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if an injected conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
 8001692:	687b      	ldr	r3, [r7, #4]
 8001694:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8001698:	b2db      	uxtb	r3, r3
 800169a:	2b22      	cmp	r3, #34	; 0x22
 800169c:	d104      	bne.n	80016a8 <HAL_ADC_Start+0x38>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 800169e:	687b      	ldr	r3, [r7, #4]
 80016a0:	2232      	movs	r2, #50	; 0x32
 80016a2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 80016a6:	e003      	b.n	80016b0 <HAL_ADC_Start+0x40>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_REG;
 80016a8:	687b      	ldr	r3, [r7, #4]
 80016aa:	2212      	movs	r2, #18
 80016ac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  } 
    
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
  Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 80016b0:	687b      	ldr	r3, [r7, #4]
 80016b2:	681b      	ldr	r3, [r3, #0]
 80016b4:	689b      	ldr	r3, [r3, #8]
 80016b6:	f003 0301 	and.w	r3, r3, #1
 80016ba:	2b00      	cmp	r3, #0
 80016bc:	d118      	bne.n	80016f0 <HAL_ADC_Start+0x80>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 80016be:	687b      	ldr	r3, [r7, #4]
 80016c0:	681b      	ldr	r3, [r3, #0]
 80016c2:	687a      	ldr	r2, [r7, #4]
 80016c4:	6812      	ldr	r2, [r2, #0]
 80016c6:	6892      	ldr	r2, [r2, #8]
 80016c8:	f042 0201 	orr.w	r2, r2, #1
 80016cc:	609a      	str	r2, [r3, #8]
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 80016ce:	4b23      	ldr	r3, [pc, #140]	; (800175c <HAL_ADC_Start+0xec>)
 80016d0:	681b      	ldr	r3, [r3, #0]
 80016d2:	4a23      	ldr	r2, [pc, #140]	; (8001760 <HAL_ADC_Start+0xf0>)
 80016d4:	fba2 2303 	umull	r2, r3, r2, r3
 80016d8:	0c9a      	lsrs	r2, r3, #18
 80016da:	4613      	mov	r3, r2
 80016dc:	005b      	lsls	r3, r3, #1
 80016de:	4413      	add	r3, r2
 80016e0:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 80016e2:	e002      	b.n	80016ea <HAL_ADC_Start+0x7a>
    {
      counter--;
 80016e4:	68fb      	ldr	r3, [r7, #12]
 80016e6:	3b01      	subs	r3, #1
 80016e8:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 80016ea:	68fb      	ldr	r3, [r7, #12]
 80016ec:	2b00      	cmp	r3, #0
 80016ee:	d1f9      	bne.n	80016e4 <HAL_ADC_Start+0x74>
      counter--;
    }
  }
	
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80016f0:	687b      	ldr	r3, [r7, #4]
 80016f2:	2200      	movs	r2, #0
 80016f4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 80016f8:	4b1a      	ldr	r3, [pc, #104]	; (8001764 <HAL_ADC_Start+0xf4>)
 80016fa:	685b      	ldr	r3, [r3, #4]
 80016fc:	f003 031f 	and.w	r3, r3, #31
 8001700:	2b00      	cmp	r3, #0
 8001702:	d10f      	bne.n	8001724 <HAL_ADC_Start+0xb4>
  {
    /* if no external trigger present enable software conversion of regular channels */
    if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
 8001704:	687b      	ldr	r3, [r7, #4]
 8001706:	681b      	ldr	r3, [r3, #0]
 8001708:	689b      	ldr	r3, [r3, #8]
 800170a:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 800170e:	2b00      	cmp	r3, #0
 8001710:	d11c      	bne.n	800174c <HAL_ADC_Start+0xdc>
    {
      /* Enable the selected ADC software conversion for regular group */
      hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8001712:	687b      	ldr	r3, [r7, #4]
 8001714:	681b      	ldr	r3, [r3, #0]
 8001716:	687a      	ldr	r2, [r7, #4]
 8001718:	6812      	ldr	r2, [r2, #0]
 800171a:	6892      	ldr	r2, [r2, #8]
 800171c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8001720:	609a      	str	r2, [r3, #8]
 8001722:	e013      	b.n	800174c <HAL_ADC_Start+0xdc>
    }
  }
  else
  {
    /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
    if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8001724:	687b      	ldr	r3, [r7, #4]
 8001726:	681b      	ldr	r3, [r3, #0]
 8001728:	4a0f      	ldr	r2, [pc, #60]	; (8001768 <HAL_ADC_Start+0xf8>)
 800172a:	4293      	cmp	r3, r2
 800172c:	d10e      	bne.n	800174c <HAL_ADC_Start+0xdc>
 800172e:	687b      	ldr	r3, [r7, #4]
 8001730:	681b      	ldr	r3, [r3, #0]
 8001732:	689b      	ldr	r3, [r3, #8]
 8001734:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8001738:	2b00      	cmp	r3, #0
 800173a:	d107      	bne.n	800174c <HAL_ADC_Start+0xdc>
    {
      /* Enable the selected ADC software conversion for regular group */
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 800173c:	687b      	ldr	r3, [r7, #4]
 800173e:	681b      	ldr	r3, [r3, #0]
 8001740:	687a      	ldr	r2, [r7, #4]
 8001742:	6812      	ldr	r2, [r2, #0]
 8001744:	6892      	ldr	r2, [r2, #8]
 8001746:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 800174a:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Return function status */
  return HAL_OK;
 800174c:	2300      	movs	r3, #0
}
 800174e:	4618      	mov	r0, r3
 8001750:	3714      	adds	r7, #20
 8001752:	46bd      	mov	sp, r7
 8001754:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001758:	4770      	bx	lr
 800175a:	bf00      	nop
 800175c:	20010000 	.word	0x20010000
 8001760:	431bde83 	.word	0x431bde83
 8001764:	40012300 	.word	0x40012300
 8001768:	40012000 	.word	0x40012000

0800176c <HAL_ADC_Stop>:
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
{
 800176c:	b480      	push	{r7}
 800176e:	b083      	sub	sp, #12
 8001770:	af00      	add	r7, sp, #0
 8001772:	6078      	str	r0, [r7, #4]
  /* Disable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8001774:	687b      	ldr	r3, [r7, #4]
 8001776:	681b      	ldr	r3, [r3, #0]
 8001778:	687a      	ldr	r2, [r7, #4]
 800177a:	6812      	ldr	r2, [r2, #0]
 800177c:	6892      	ldr	r2, [r2, #8]
 800177e:	f022 0201 	bic.w	r2, r2, #1
 8001782:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8001784:	687b      	ldr	r3, [r7, #4]
 8001786:	2201      	movs	r2, #1
 8001788:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 800178c:	2300      	movs	r3, #0
}
 800178e:	4618      	mov	r0, r3
 8001790:	370c      	adds	r7, #12
 8001792:	46bd      	mov	sp, r7
 8001794:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001798:	4770      	bx	lr
 800179a:	bf00      	nop

0800179c <HAL_ADC_IRQHandler>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
{
 800179c:	b580      	push	{r7, lr}
 800179e:	b084      	sub	sp, #16
 80017a0:	af00      	add	r7, sp, #0
 80017a2:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0;
 80017a4:	2300      	movs	r3, #0
 80017a6:	60fb      	str	r3, [r7, #12]
 80017a8:	2300      	movs	r3, #0
 80017aa:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
  assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
 80017ac:	687b      	ldr	r3, [r7, #4]
 80017ae:	681b      	ldr	r3, [r3, #0]
 80017b0:	681b      	ldr	r3, [r3, #0]
 80017b2:	f003 0302 	and.w	r3, r3, #2
 80017b6:	2b00      	cmp	r3, #0
 80017b8:	bf14      	ite	ne
 80017ba:	2301      	movne	r3, #1
 80017bc:	2300      	moveq	r3, #0
 80017be:	b2db      	uxtb	r3, r3
 80017c0:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
 80017c2:	687b      	ldr	r3, [r7, #4]
 80017c4:	681b      	ldr	r3, [r3, #0]
 80017c6:	685b      	ldr	r3, [r3, #4]
 80017c8:	f003 0320 	and.w	r3, r3, #32
 80017cc:	2b00      	cmp	r3, #0
 80017ce:	bf14      	ite	ne
 80017d0:	2301      	movne	r3, #1
 80017d2:	2300      	moveq	r3, #0
 80017d4:	b2db      	uxtb	r3, r3
 80017d6:	60bb      	str	r3, [r7, #8]
  /* Check End of conversion flag for regular channels */
  if(tmp1 && tmp2)
 80017d8:	68fb      	ldr	r3, [r7, #12]
 80017da:	2b00      	cmp	r3, #0
 80017dc:	d05a      	beq.n	8001894 <HAL_ADC_IRQHandler+0xf8>
 80017de:	68bb      	ldr	r3, [r7, #8]
 80017e0:	2b00      	cmp	r3, #0
 80017e2:	d057      	beq.n	8001894 <HAL_ADC_IRQHandler+0xf8>
  {
    /* Check if an injected conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_INJ)
 80017e4:	687b      	ldr	r3, [r7, #4]
 80017e6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80017ea:	b2db      	uxtb	r3, r3
 80017ec:	2b25      	cmp	r3, #37	; 0x25
 80017ee:	d104      	bne.n	80017fa <HAL_ADC_IRQHandler+0x5e>
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 80017f0:	687b      	ldr	r3, [r7, #4]
 80017f2:	2235      	movs	r2, #53	; 0x35
 80017f4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 80017f8:	e003      	b.n	8001802 <HAL_ADC_IRQHandler+0x66>
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_REG;
 80017fa:	687b      	ldr	r3, [r7, #4]
 80017fc:	2215      	movs	r2, #21
 80017fe:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }

    if((hadc->Init.ContinuousConvMode == DISABLE) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8001802:	687b      	ldr	r3, [r7, #4]
 8001804:	699b      	ldr	r3, [r3, #24]
 8001806:	2b00      	cmp	r3, #0
 8001808:	d13c      	bne.n	8001884 <HAL_ADC_IRQHandler+0xe8>
 800180a:	687b      	ldr	r3, [r7, #4]
 800180c:	681b      	ldr	r3, [r3, #0]
 800180e:	689b      	ldr	r3, [r3, #8]
 8001810:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8001814:	2b00      	cmp	r3, #0
 8001816:	d135      	bne.n	8001884 <HAL_ADC_IRQHandler+0xe8>
    {
      if(hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8001818:	687b      	ldr	r3, [r7, #4]
 800181a:	695b      	ldr	r3, [r3, #20]
 800181c:	2b00      	cmp	r3, #0
 800181e:	d110      	bne.n	8001842 <HAL_ADC_IRQHandler+0xa6>
      { 
        /* DISABLE the ADC end of conversion interrupt for regular group */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8001820:	687b      	ldr	r3, [r7, #4]
 8001822:	681b      	ldr	r3, [r3, #0]
 8001824:	687a      	ldr	r2, [r7, #4]
 8001826:	6812      	ldr	r2, [r2, #0]
 8001828:	6852      	ldr	r2, [r2, #4]
 800182a:	f022 0220 	bic.w	r2, r2, #32
 800182e:	605a      	str	r2, [r3, #4]
        
        /* DISABLE the ADC overrun interrupt */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8001830:	687b      	ldr	r3, [r7, #4]
 8001832:	681b      	ldr	r3, [r3, #0]
 8001834:	687a      	ldr	r2, [r7, #4]
 8001836:	6812      	ldr	r2, [r2, #0]
 8001838:	6852      	ldr	r2, [r2, #4]
 800183a:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 800183e:	605a      	str	r2, [r3, #4]
 8001840:	e020      	b.n	8001884 <HAL_ADC_IRQHandler+0xe8>
      }
      else
      {
        if (hadc->NbrOfCurrentConversionRank == 0)
 8001842:	687b      	ldr	r3, [r7, #4]
 8001844:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001846:	2b00      	cmp	r3, #0
 8001848:	d103      	bne.n	8001852 <HAL_ADC_IRQHandler+0xb6>
        {
          hadc->NbrOfCurrentConversionRank = hadc->Init.NbrOfConversion;
 800184a:	687b      	ldr	r3, [r7, #4]
 800184c:	6a1a      	ldr	r2, [r3, #32]
 800184e:	687b      	ldr	r3, [r7, #4]
 8001850:	635a      	str	r2, [r3, #52]	; 0x34
        }
        
        /* Decrement the number of conversion when an interrupt occurs */
        hadc->NbrOfCurrentConversionRank--;
 8001852:	687b      	ldr	r3, [r7, #4]
 8001854:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001856:	1e5a      	subs	r2, r3, #1
 8001858:	687b      	ldr	r3, [r7, #4]
 800185a:	635a      	str	r2, [r3, #52]	; 0x34
        
        /* Check if all conversions are finished */
        if(hadc->NbrOfCurrentConversionRank == 0)
 800185c:	687b      	ldr	r3, [r7, #4]
 800185e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001860:	2b00      	cmp	r3, #0
 8001862:	d10f      	bne.n	8001884 <HAL_ADC_IRQHandler+0xe8>
        {
          /* DISABLE the ADC end of conversion interrupt for regular group */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8001864:	687b      	ldr	r3, [r7, #4]
 8001866:	681b      	ldr	r3, [r3, #0]
 8001868:	687a      	ldr	r2, [r7, #4]
 800186a:	6812      	ldr	r2, [r2, #0]
 800186c:	6852      	ldr	r2, [r2, #4]
 800186e:	f022 0220 	bic.w	r2, r2, #32
 8001872:	605a      	str	r2, [r3, #4]
          
          /* DISABLE the ADC overrun interrupt */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8001874:	687b      	ldr	r3, [r7, #4]
 8001876:	681b      	ldr	r3, [r3, #0]
 8001878:	687a      	ldr	r2, [r7, #4]
 800187a:	6812      	ldr	r2, [r2, #0]
 800187c:	6852      	ldr	r2, [r2, #4]
 800187e:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8001882:	605a      	str	r2, [r3, #4]
        }
      }
    }
    
    /* Conversion complete callback */ 
    HAL_ADC_ConvCpltCallback(hadc);
 8001884:	6878      	ldr	r0, [r7, #4]
 8001886:	f000 f8c7 	bl	8001a18 <HAL_ADC_ConvCpltCallback>
    
   /* Clear the ADCx flag for regular end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800188a:	687b      	ldr	r3, [r7, #4]
 800188c:	681b      	ldr	r3, [r3, #0]
 800188e:	f06f 0202 	mvn.w	r2, #2
 8001892:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
 8001894:	687b      	ldr	r3, [r7, #4]
 8001896:	681b      	ldr	r3, [r3, #0]
 8001898:	681b      	ldr	r3, [r3, #0]
 800189a:	f003 0304 	and.w	r3, r3, #4
 800189e:	2b00      	cmp	r3, #0
 80018a0:	bf14      	ite	ne
 80018a2:	2301      	movne	r3, #1
 80018a4:	2300      	moveq	r3, #0
 80018a6:	b2db      	uxtb	r3, r3
 80018a8:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
 80018aa:	687b      	ldr	r3, [r7, #4]
 80018ac:	681b      	ldr	r3, [r3, #0]
 80018ae:	685b      	ldr	r3, [r3, #4]
 80018b0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80018b4:	2b00      	cmp	r3, #0
 80018b6:	bf14      	ite	ne
 80018b8:	2301      	movne	r3, #1
 80018ba:	2300      	moveq	r3, #0
 80018bc:	b2db      	uxtb	r3, r3
 80018be:	60bb      	str	r3, [r7, #8]
  /* Check End of conversion flag for injected channels */
  if(tmp1 && tmp2)
 80018c0:	68fb      	ldr	r3, [r7, #12]
 80018c2:	2b00      	cmp	r3, #0
 80018c4:	d041      	beq.n	800194a <HAL_ADC_IRQHandler+0x1ae>
 80018c6:	68bb      	ldr	r3, [r7, #8]
 80018c8:	2b00      	cmp	r3, #0
 80018ca:	d03e      	beq.n	800194a <HAL_ADC_IRQHandler+0x1ae>
  {
    /* Check if a regular conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_REG)
 80018cc:	687b      	ldr	r3, [r7, #4]
 80018ce:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80018d2:	b2db      	uxtb	r3, r3
 80018d4:	2b15      	cmp	r3, #21
 80018d6:	d104      	bne.n	80018e2 <HAL_ADC_IRQHandler+0x146>
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 80018d8:	687b      	ldr	r3, [r7, #4]
 80018da:	2235      	movs	r2, #53	; 0x35
 80018dc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 80018e0:	e003      	b.n	80018ea <HAL_ADC_IRQHandler+0x14e>
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ;
 80018e2:	687b      	ldr	r3, [r7, #4]
 80018e4:	2225      	movs	r2, #37	; 0x25
 80018e6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }
    
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 80018ea:	687b      	ldr	r3, [r7, #4]
 80018ec:	681b      	ldr	r3, [r3, #0]
 80018ee:	685b      	ldr	r3, [r3, #4]
 80018f0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80018f4:	2b00      	cmp	r3, #0
 80018f6:	bf0c      	ite	eq
 80018f8:	2301      	moveq	r3, #1
 80018fa:	2300      	movne	r3, #0
 80018fc:	b2db      	uxtb	r3, r3
 80018fe:	60fb      	str	r3, [r7, #12]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8001900:	687b      	ldr	r3, [r7, #4]
 8001902:	681b      	ldr	r3, [r3, #0]
 8001904:	689b      	ldr	r3, [r3, #8]
 8001906:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 800190a:	2b00      	cmp	r3, #0
 800190c:	bf0c      	ite	eq
 800190e:	2301      	moveq	r3, #1
 8001910:	2300      	movne	r3, #0
 8001912:	b2db      	uxtb	r3, r3
 8001914:	60bb      	str	r3, [r7, #8]
    if(((hadc->Init.ContinuousConvMode == DISABLE) || tmp1) && tmp2)
 8001916:	687b      	ldr	r3, [r7, #4]
 8001918:	699b      	ldr	r3, [r3, #24]
 800191a:	2b00      	cmp	r3, #0
 800191c:	d002      	beq.n	8001924 <HAL_ADC_IRQHandler+0x188>
 800191e:	68fb      	ldr	r3, [r7, #12]
 8001920:	2b00      	cmp	r3, #0
 8001922:	d00a      	beq.n	800193a <HAL_ADC_IRQHandler+0x19e>
 8001924:	68bb      	ldr	r3, [r7, #8]
 8001926:	2b00      	cmp	r3, #0
 8001928:	d007      	beq.n	800193a <HAL_ADC_IRQHandler+0x19e>
    {
      /* DISABLE the ADC end of conversion interrupt for injected group */
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 800192a:	687b      	ldr	r3, [r7, #4]
 800192c:	681b      	ldr	r3, [r3, #0]
 800192e:	687a      	ldr	r2, [r7, #4]
 8001930:	6812      	ldr	r2, [r2, #0]
 8001932:	6852      	ldr	r2, [r2, #4]
 8001934:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001938:	605a      	str	r2, [r3, #4]
    }
    
    /* Conversion complete callback */ 
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 800193a:	6878      	ldr	r0, [r7, #4]
 800193c:	f00c fa00 	bl	800dd40 <HAL_ADCEx_InjectedConvCpltCallback>
    
   /* Clear the ADCx flag for injected end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 8001940:	687b      	ldr	r3, [r7, #4]
 8001942:	681b      	ldr	r3, [r3, #0]
 8001944:	f06f 0204 	mvn.w	r2, #4
 8001948:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
 800194a:	687b      	ldr	r3, [r7, #4]
 800194c:	681b      	ldr	r3, [r3, #0]
 800194e:	681b      	ldr	r3, [r3, #0]
 8001950:	f003 0301 	and.w	r3, r3, #1
 8001954:	2b00      	cmp	r3, #0
 8001956:	bf14      	ite	ne
 8001958:	2301      	movne	r3, #1
 800195a:	2300      	moveq	r3, #0
 800195c:	b2db      	uxtb	r3, r3
 800195e:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
 8001960:	687b      	ldr	r3, [r7, #4]
 8001962:	681b      	ldr	r3, [r3, #0]
 8001964:	685b      	ldr	r3, [r3, #4]
 8001966:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800196a:	2b00      	cmp	r3, #0
 800196c:	bf14      	ite	ne
 800196e:	2301      	movne	r3, #1
 8001970:	2300      	moveq	r3, #0
 8001972:	b2db      	uxtb	r3, r3
 8001974:	60bb      	str	r3, [r7, #8]
  /* Check Analog watchdog flag */
  if(tmp1 && tmp2)
 8001976:	68fb      	ldr	r3, [r7, #12]
 8001978:	2b00      	cmp	r3, #0
 800197a:	d00e      	beq.n	800199a <HAL_ADC_IRQHandler+0x1fe>
 800197c:	68bb      	ldr	r3, [r7, #8]
 800197e:	2b00      	cmp	r3, #0
 8001980:	d00b      	beq.n	800199a <HAL_ADC_IRQHandler+0x1fe>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_AWD;
 8001982:	687b      	ldr	r3, [r7, #4]
 8001984:	2206      	movs	r2, #6
 8001986:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      
    /* Clear the ADCx's Analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_AWD);
 800198a:	687b      	ldr	r3, [r7, #4]
 800198c:	681b      	ldr	r3, [r3, #0]
 800198e:	f06f 0201 	mvn.w	r2, #1
 8001992:	601a      	str	r2, [r3, #0]
    
    /* Level out of window callback */ 
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8001994:	6878      	ldr	r0, [r7, #4]
 8001996:	f000 f849 	bl	8001a2c <HAL_ADC_LevelOutOfWindowCallback>
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
 800199a:	687b      	ldr	r3, [r7, #4]
 800199c:	681b      	ldr	r3, [r3, #0]
 800199e:	681b      	ldr	r3, [r3, #0]
 80019a0:	f003 0320 	and.w	r3, r3, #32
 80019a4:	2b00      	cmp	r3, #0
 80019a6:	bf14      	ite	ne
 80019a8:	2301      	movne	r3, #1
 80019aa:	2300      	moveq	r3, #0
 80019ac:	b2db      	uxtb	r3, r3
 80019ae:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
 80019b0:	687b      	ldr	r3, [r7, #4]
 80019b2:	681b      	ldr	r3, [r3, #0]
 80019b4:	685b      	ldr	r3, [r3, #4]
 80019b6:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80019ba:	2b00      	cmp	r3, #0
 80019bc:	bf14      	ite	ne
 80019be:	2301      	movne	r3, #1
 80019c0:	2300      	moveq	r3, #0
 80019c2:	b2db      	uxtb	r3, r3
 80019c4:	60bb      	str	r3, [r7, #8]
  /* Check Overrun flag */
  if(tmp1 && tmp2)
 80019c6:	68fb      	ldr	r3, [r7, #12]
 80019c8:	2b00      	cmp	r3, #0
 80019ca:	d014      	beq.n	80019f6 <HAL_ADC_IRQHandler+0x25a>
 80019cc:	68bb      	ldr	r3, [r7, #8]
 80019ce:	2b00      	cmp	r3, #0
 80019d0:	d011      	beq.n	80019f6 <HAL_ADC_IRQHandler+0x25a>
  {
    /* Change ADC state to overrun state */
    hadc->State = HAL_ADC_STATE_ERROR;
 80019d2:	687b      	ldr	r3, [r7, #4]
 80019d4:	2204      	movs	r2, #4
 80019d6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    
    /* Set ADC error code to overrun */
    hadc->ErrorCode |= HAL_ADC_ERROR_OVR;
 80019da:	687b      	ldr	r3, [r7, #4]
 80019dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80019de:	f043 0201 	orr.w	r2, r3, #1
 80019e2:	687b      	ldr	r3, [r7, #4]
 80019e4:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Clear the Overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_OVR);
 80019e6:	687b      	ldr	r3, [r7, #4]
 80019e8:	681b      	ldr	r3, [r3, #0]
 80019ea:	f06f 0220 	mvn.w	r2, #32
 80019ee:	601a      	str	r2, [r3, #0]
    
    /* Error callback */ 
    HAL_ADC_ErrorCallback(hadc);
 80019f0:	6878      	ldr	r0, [r7, #4]
 80019f2:	f000 f825 	bl	8001a40 <HAL_ADC_ErrorCallback>
  }
}
 80019f6:	3710      	adds	r7, #16
 80019f8:	46bd      	mov	sp, r7
 80019fa:	bd80      	pop	{r7, pc}

080019fc <HAL_ADC_GetValue>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval Converted value
  */
uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
{       
 80019fc:	b480      	push	{r7}
 80019fe:	b083      	sub	sp, #12
 8001a00:	af00      	add	r7, sp, #0
 8001a02:	6078      	str	r0, [r7, #4]
  /* Return the selected ADC converted value */ 
  return hadc->Instance->DR;
 8001a04:	687b      	ldr	r3, [r7, #4]
 8001a06:	681b      	ldr	r3, [r3, #0]
 8001a08:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
 8001a0a:	4618      	mov	r0, r3
 8001a0c:	370c      	adds	r7, #12
 8001a0e:	46bd      	mov	sp, r7
 8001a10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a14:	4770      	bx	lr
 8001a16:	bf00      	nop

08001a18 <HAL_ADC_ConvCpltCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 8001a18:	b480      	push	{r7}
 8001a1a:	b083      	sub	sp, #12
 8001a1c:	af00      	add	r7, sp, #0
 8001a1e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ConvCpltCallback could be implemented in the user file
   */
}
 8001a20:	370c      	adds	r7, #12
 8001a22:	46bd      	mov	sp, r7
 8001a24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a28:	4770      	bx	lr
 8001a2a:	bf00      	nop

08001a2c <HAL_ADC_LevelOutOfWindowCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
{
 8001a2c:	b480      	push	{r7}
 8001a2e:	b083      	sub	sp, #12
 8001a30:	af00      	add	r7, sp, #0
 8001a32:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
   */
}
 8001a34:	370c      	adds	r7, #12
 8001a36:	46bd      	mov	sp, r7
 8001a38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a3c:	4770      	bx	lr
 8001a3e:	bf00      	nop

08001a40 <HAL_ADC_ErrorCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
 8001a40:	b480      	push	{r7}
 8001a42:	b083      	sub	sp, #12
 8001a44:	af00      	add	r7, sp, #0
 8001a46:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ErrorCallback could be implemented in the user file
   */
}
 8001a48:	370c      	adds	r7, #12
 8001a4a:	46bd      	mov	sp, r7
 8001a4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a50:	4770      	bx	lr
 8001a52:	bf00      	nop

08001a54 <HAL_ADC_ConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfig: ADC configuration structure. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 8001a54:	b490      	push	{r4, r7}
 8001a56:	b084      	sub	sp, #16
 8001a58:	af00      	add	r7, sp, #0
 8001a5a:	6078      	str	r0, [r7, #4]
 8001a5c:	6039      	str	r1, [r7, #0]
  __IO uint32_t counter = 0;
 8001a5e:	2300      	movs	r3, #0
 8001a60:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001a62:	687b      	ldr	r3, [r7, #4]
 8001a64:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8001a68:	2b01      	cmp	r3, #1
 8001a6a:	d101      	bne.n	8001a70 <HAL_ADC_ConfigChannel+0x1c>
 8001a6c:	2302      	movs	r3, #2
 8001a6e:	e105      	b.n	8001c7c <HAL_ADC_ConfigChannel+0x228>
 8001a70:	687b      	ldr	r3, [r7, #4]
 8001a72:	2201      	movs	r2, #1
 8001a74:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 8001a78:	683b      	ldr	r3, [r7, #0]
 8001a7a:	681b      	ldr	r3, [r3, #0]
 8001a7c:	2b09      	cmp	r3, #9
 8001a7e:	d926      	bls.n	8001ace <HAL_ADC_ConfigChannel+0x7a>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8001a80:	687b      	ldr	r3, [r7, #4]
 8001a82:	681a      	ldr	r2, [r3, #0]
 8001a84:	687b      	ldr	r3, [r7, #4]
 8001a86:	681b      	ldr	r3, [r3, #0]
 8001a88:	68d9      	ldr	r1, [r3, #12]
 8001a8a:	683b      	ldr	r3, [r7, #0]
 8001a8c:	681b      	ldr	r3, [r3, #0]
 8001a8e:	b29b      	uxth	r3, r3
 8001a90:	4618      	mov	r0, r3
 8001a92:	4603      	mov	r3, r0
 8001a94:	005b      	lsls	r3, r3, #1
 8001a96:	4403      	add	r3, r0
 8001a98:	3b1e      	subs	r3, #30
 8001a9a:	4618      	mov	r0, r3
 8001a9c:	2307      	movs	r3, #7
 8001a9e:	4083      	lsls	r3, r0
 8001aa0:	43db      	mvns	r3, r3
 8001aa2:	400b      	ands	r3, r1
 8001aa4:	60d3      	str	r3, [r2, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 8001aa6:	687b      	ldr	r3, [r7, #4]
 8001aa8:	681a      	ldr	r2, [r3, #0]
 8001aaa:	687b      	ldr	r3, [r7, #4]
 8001aac:	681b      	ldr	r3, [r3, #0]
 8001aae:	68d9      	ldr	r1, [r3, #12]
 8001ab0:	683b      	ldr	r3, [r7, #0]
 8001ab2:	6898      	ldr	r0, [r3, #8]
 8001ab4:	683b      	ldr	r3, [r7, #0]
 8001ab6:	681b      	ldr	r3, [r3, #0]
 8001ab8:	b29b      	uxth	r3, r3
 8001aba:	461c      	mov	r4, r3
 8001abc:	4623      	mov	r3, r4
 8001abe:	005b      	lsls	r3, r3, #1
 8001ac0:	4423      	add	r3, r4
 8001ac2:	3b1e      	subs	r3, #30
 8001ac4:	fa00 f303 	lsl.w	r3, r0, r3
 8001ac8:	430b      	orrs	r3, r1
 8001aca:	60d3      	str	r3, [r2, #12]
 8001acc:	e023      	b.n	8001b16 <HAL_ADC_ConfigChannel+0xc2>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8001ace:	687b      	ldr	r3, [r7, #4]
 8001ad0:	681a      	ldr	r2, [r3, #0]
 8001ad2:	687b      	ldr	r3, [r7, #4]
 8001ad4:	681b      	ldr	r3, [r3, #0]
 8001ad6:	6919      	ldr	r1, [r3, #16]
 8001ad8:	683b      	ldr	r3, [r7, #0]
 8001ada:	681b      	ldr	r3, [r3, #0]
 8001adc:	b29b      	uxth	r3, r3
 8001ade:	4618      	mov	r0, r3
 8001ae0:	4603      	mov	r3, r0
 8001ae2:	005b      	lsls	r3, r3, #1
 8001ae4:	4403      	add	r3, r0
 8001ae6:	4618      	mov	r0, r3
 8001ae8:	2307      	movs	r3, #7
 8001aea:	4083      	lsls	r3, r0
 8001aec:	43db      	mvns	r3, r3
 8001aee:	400b      	ands	r3, r1
 8001af0:	6113      	str	r3, [r2, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8001af2:	687b      	ldr	r3, [r7, #4]
 8001af4:	681a      	ldr	r2, [r3, #0]
 8001af6:	687b      	ldr	r3, [r7, #4]
 8001af8:	681b      	ldr	r3, [r3, #0]
 8001afa:	6919      	ldr	r1, [r3, #16]
 8001afc:	683b      	ldr	r3, [r7, #0]
 8001afe:	6898      	ldr	r0, [r3, #8]
 8001b00:	683b      	ldr	r3, [r7, #0]
 8001b02:	681b      	ldr	r3, [r3, #0]
 8001b04:	b29b      	uxth	r3, r3
 8001b06:	461c      	mov	r4, r3
 8001b08:	4623      	mov	r3, r4
 8001b0a:	005b      	lsls	r3, r3, #1
 8001b0c:	4423      	add	r3, r4
 8001b0e:	fa00 f303 	lsl.w	r3, r0, r3
 8001b12:	430b      	orrs	r3, r1
 8001b14:	6113      	str	r3, [r2, #16]
  }
  
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 8001b16:	683b      	ldr	r3, [r7, #0]
 8001b18:	685b      	ldr	r3, [r3, #4]
 8001b1a:	2b06      	cmp	r3, #6
 8001b1c:	d824      	bhi.n	8001b68 <HAL_ADC_ConfigChannel+0x114>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8001b1e:	687b      	ldr	r3, [r7, #4]
 8001b20:	6819      	ldr	r1, [r3, #0]
 8001b22:	687b      	ldr	r3, [r7, #4]
 8001b24:	681b      	ldr	r3, [r3, #0]
 8001b26:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8001b28:	683b      	ldr	r3, [r7, #0]
 8001b2a:	685a      	ldr	r2, [r3, #4]
 8001b2c:	4613      	mov	r3, r2
 8001b2e:	009b      	lsls	r3, r3, #2
 8001b30:	4413      	add	r3, r2
 8001b32:	3b05      	subs	r3, #5
 8001b34:	461a      	mov	r2, r3
 8001b36:	231f      	movs	r3, #31
 8001b38:	4093      	lsls	r3, r2
 8001b3a:	43db      	mvns	r3, r3
 8001b3c:	4003      	ands	r3, r0
 8001b3e:	634b      	str	r3, [r1, #52]	; 0x34
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8001b40:	687b      	ldr	r3, [r7, #4]
 8001b42:	6819      	ldr	r1, [r3, #0]
 8001b44:	687b      	ldr	r3, [r7, #4]
 8001b46:	681b      	ldr	r3, [r3, #0]
 8001b48:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8001b4a:	683b      	ldr	r3, [r7, #0]
 8001b4c:	681b      	ldr	r3, [r3, #0]
 8001b4e:	b29b      	uxth	r3, r3
 8001b50:	461c      	mov	r4, r3
 8001b52:	683b      	ldr	r3, [r7, #0]
 8001b54:	685a      	ldr	r2, [r3, #4]
 8001b56:	4613      	mov	r3, r2
 8001b58:	009b      	lsls	r3, r3, #2
 8001b5a:	4413      	add	r3, r2
 8001b5c:	3b05      	subs	r3, #5
 8001b5e:	fa04 f303 	lsl.w	r3, r4, r3
 8001b62:	4303      	orrs	r3, r0
 8001b64:	634b      	str	r3, [r1, #52]	; 0x34
 8001b66:	e04c      	b.n	8001c02 <HAL_ADC_ConfigChannel+0x1ae>
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13)
 8001b68:	683b      	ldr	r3, [r7, #0]
 8001b6a:	685b      	ldr	r3, [r3, #4]
 8001b6c:	2b0c      	cmp	r3, #12
 8001b6e:	d824      	bhi.n	8001bba <HAL_ADC_ConfigChannel+0x166>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 8001b70:	687b      	ldr	r3, [r7, #4]
 8001b72:	6819      	ldr	r1, [r3, #0]
 8001b74:	687b      	ldr	r3, [r7, #4]
 8001b76:	681b      	ldr	r3, [r3, #0]
 8001b78:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8001b7a:	683b      	ldr	r3, [r7, #0]
 8001b7c:	685a      	ldr	r2, [r3, #4]
 8001b7e:	4613      	mov	r3, r2
 8001b80:	009b      	lsls	r3, r3, #2
 8001b82:	4413      	add	r3, r2
 8001b84:	3b23      	subs	r3, #35	; 0x23
 8001b86:	461a      	mov	r2, r3
 8001b88:	231f      	movs	r3, #31
 8001b8a:	4093      	lsls	r3, r2
 8001b8c:	43db      	mvns	r3, r3
 8001b8e:	4003      	ands	r3, r0
 8001b90:	630b      	str	r3, [r1, #48]	; 0x30
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8001b92:	687b      	ldr	r3, [r7, #4]
 8001b94:	6819      	ldr	r1, [r3, #0]
 8001b96:	687b      	ldr	r3, [r7, #4]
 8001b98:	681b      	ldr	r3, [r3, #0]
 8001b9a:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8001b9c:	683b      	ldr	r3, [r7, #0]
 8001b9e:	681b      	ldr	r3, [r3, #0]
 8001ba0:	b29b      	uxth	r3, r3
 8001ba2:	461c      	mov	r4, r3
 8001ba4:	683b      	ldr	r3, [r7, #0]
 8001ba6:	685a      	ldr	r2, [r3, #4]
 8001ba8:	4613      	mov	r3, r2
 8001baa:	009b      	lsls	r3, r3, #2
 8001bac:	4413      	add	r3, r2
 8001bae:	3b23      	subs	r3, #35	; 0x23
 8001bb0:	fa04 f303 	lsl.w	r3, r4, r3
 8001bb4:	4303      	orrs	r3, r0
 8001bb6:	630b      	str	r3, [r1, #48]	; 0x30
 8001bb8:	e023      	b.n	8001c02 <HAL_ADC_ConfigChannel+0x1ae>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8001bba:	687b      	ldr	r3, [r7, #4]
 8001bbc:	6819      	ldr	r1, [r3, #0]
 8001bbe:	687b      	ldr	r3, [r7, #4]
 8001bc0:	681b      	ldr	r3, [r3, #0]
 8001bc2:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8001bc4:	683b      	ldr	r3, [r7, #0]
 8001bc6:	685a      	ldr	r2, [r3, #4]
 8001bc8:	4613      	mov	r3, r2
 8001bca:	009b      	lsls	r3, r3, #2
 8001bcc:	4413      	add	r3, r2
 8001bce:	3b41      	subs	r3, #65	; 0x41
 8001bd0:	461a      	mov	r2, r3
 8001bd2:	231f      	movs	r3, #31
 8001bd4:	4093      	lsls	r3, r2
 8001bd6:	43db      	mvns	r3, r3
 8001bd8:	4003      	ands	r3, r0
 8001bda:	62cb      	str	r3, [r1, #44]	; 0x2c
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8001bdc:	687b      	ldr	r3, [r7, #4]
 8001bde:	6819      	ldr	r1, [r3, #0]
 8001be0:	687b      	ldr	r3, [r7, #4]
 8001be2:	681b      	ldr	r3, [r3, #0]
 8001be4:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8001be6:	683b      	ldr	r3, [r7, #0]
 8001be8:	681b      	ldr	r3, [r3, #0]
 8001bea:	b29b      	uxth	r3, r3
 8001bec:	461c      	mov	r4, r3
 8001bee:	683b      	ldr	r3, [r7, #0]
 8001bf0:	685a      	ldr	r2, [r3, #4]
 8001bf2:	4613      	mov	r3, r2
 8001bf4:	009b      	lsls	r3, r3, #2
 8001bf6:	4413      	add	r3, r2
 8001bf8:	3b41      	subs	r3, #65	; 0x41
 8001bfa:	fa04 f303 	lsl.w	r3, r4, r3
 8001bfe:	4303      	orrs	r3, r0
 8001c00:	62cb      	str	r3, [r1, #44]	; 0x2c
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8001c02:	687b      	ldr	r3, [r7, #4]
 8001c04:	681b      	ldr	r3, [r3, #0]
 8001c06:	4a20      	ldr	r2, [pc, #128]	; (8001c88 <HAL_ADC_ConfigChannel+0x234>)
 8001c08:	4293      	cmp	r3, r2
 8001c0a:	d109      	bne.n	8001c20 <HAL_ADC_ConfigChannel+0x1cc>
 8001c0c:	683b      	ldr	r3, [r7, #0]
 8001c0e:	681b      	ldr	r3, [r3, #0]
 8001c10:	2b12      	cmp	r3, #18
 8001c12:	d105      	bne.n	8001c20 <HAL_ADC_ConfigChannel+0x1cc>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 8001c14:	4a1d      	ldr	r2, [pc, #116]	; (8001c8c <HAL_ADC_ConfigChannel+0x238>)
 8001c16:	4b1d      	ldr	r3, [pc, #116]	; (8001c8c <HAL_ADC_ConfigChannel+0x238>)
 8001c18:	685b      	ldr	r3, [r3, #4]
 8001c1a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001c1e:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 8001c20:	687b      	ldr	r3, [r7, #4]
 8001c22:	681b      	ldr	r3, [r3, #0]
 8001c24:	4a18      	ldr	r2, [pc, #96]	; (8001c88 <HAL_ADC_ConfigChannel+0x234>)
 8001c26:	4293      	cmp	r3, r2
 8001c28:	d123      	bne.n	8001c72 <HAL_ADC_ConfigChannel+0x21e>
 8001c2a:	683b      	ldr	r3, [r7, #0]
 8001c2c:	681b      	ldr	r3, [r3, #0]
 8001c2e:	2b10      	cmp	r3, #16
 8001c30:	d003      	beq.n	8001c3a <HAL_ADC_ConfigChannel+0x1e6>
 8001c32:	683b      	ldr	r3, [r7, #0]
 8001c34:	681b      	ldr	r3, [r3, #0]
 8001c36:	2b11      	cmp	r3, #17
 8001c38:	d11b      	bne.n	8001c72 <HAL_ADC_ConfigChannel+0x21e>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 8001c3a:	4a14      	ldr	r2, [pc, #80]	; (8001c8c <HAL_ADC_ConfigChannel+0x238>)
 8001c3c:	4b13      	ldr	r3, [pc, #76]	; (8001c8c <HAL_ADC_ConfigChannel+0x238>)
 8001c3e:	685b      	ldr	r3, [r3, #4]
 8001c40:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8001c44:	6053      	str	r3, [r2, #4]

    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8001c46:	683b      	ldr	r3, [r7, #0]
 8001c48:	681b      	ldr	r3, [r3, #0]
 8001c4a:	2b10      	cmp	r3, #16
 8001c4c:	d111      	bne.n	8001c72 <HAL_ADC_ConfigChannel+0x21e>
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 8001c4e:	4b10      	ldr	r3, [pc, #64]	; (8001c90 <HAL_ADC_ConfigChannel+0x23c>)
 8001c50:	681b      	ldr	r3, [r3, #0]
 8001c52:	4a10      	ldr	r2, [pc, #64]	; (8001c94 <HAL_ADC_ConfigChannel+0x240>)
 8001c54:	fba2 2303 	umull	r2, r3, r2, r3
 8001c58:	0c9a      	lsrs	r2, r3, #18
 8001c5a:	4613      	mov	r3, r2
 8001c5c:	009b      	lsls	r3, r3, #2
 8001c5e:	4413      	add	r3, r2
 8001c60:	005b      	lsls	r3, r3, #1
 8001c62:	60fb      	str	r3, [r7, #12]
      while(counter != 0)
 8001c64:	e002      	b.n	8001c6c <HAL_ADC_ConfigChannel+0x218>
      {
        counter--;
 8001c66:	68fb      	ldr	r3, [r7, #12]
 8001c68:	3b01      	subs	r3, #1
 8001c6a:	60fb      	str	r3, [r7, #12]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
      while(counter != 0)
 8001c6c:	68fb      	ldr	r3, [r7, #12]
 8001c6e:	2b00      	cmp	r3, #0
 8001c70:	d1f9      	bne.n	8001c66 <HAL_ADC_ConfigChannel+0x212>
      }
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001c72:	687b      	ldr	r3, [r7, #4]
 8001c74:	2200      	movs	r2, #0
 8001c76:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8001c7a:	2300      	movs	r3, #0
}
 8001c7c:	4618      	mov	r0, r3
 8001c7e:	3710      	adds	r7, #16
 8001c80:	46bd      	mov	sp, r7
 8001c82:	bc90      	pop	{r4, r7}
 8001c84:	4770      	bx	lr
 8001c86:	bf00      	nop
 8001c88:	40012000 	.word	0x40012000
 8001c8c:	40012300 	.word	0x40012300
 8001c90:	20010000 	.word	0x20010000
 8001c94:	431bde83 	.word	0x431bde83

08001c98 <ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
 8001c98:	b480      	push	{r7}
 8001c9a:	b085      	sub	sp, #20
 8001c9c:	af00      	add	r7, sp, #0
 8001c9e:	6078      	str	r0, [r7, #4]
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8001ca0:	4a7c      	ldr	r2, [pc, #496]	; (8001e94 <ADC_Init+0x1fc>)
 8001ca2:	4b7c      	ldr	r3, [pc, #496]	; (8001e94 <ADC_Init+0x1fc>)
 8001ca4:	685b      	ldr	r3, [r3, #4]
 8001ca6:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8001caa:	6053      	str	r3, [r2, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 8001cac:	4979      	ldr	r1, [pc, #484]	; (8001e94 <ADC_Init+0x1fc>)
 8001cae:	4b79      	ldr	r3, [pc, #484]	; (8001e94 <ADC_Init+0x1fc>)
 8001cb0:	685a      	ldr	r2, [r3, #4]
 8001cb2:	687b      	ldr	r3, [r7, #4]
 8001cb4:	685b      	ldr	r3, [r3, #4]
 8001cb6:	4313      	orrs	r3, r2
 8001cb8:	604b      	str	r3, [r1, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8001cba:	687b      	ldr	r3, [r7, #4]
 8001cbc:	681b      	ldr	r3, [r3, #0]
 8001cbe:	687a      	ldr	r2, [r7, #4]
 8001cc0:	6812      	ldr	r2, [r2, #0]
 8001cc2:	6852      	ldr	r2, [r2, #4]
 8001cc4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001cc8:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8001cca:	687b      	ldr	r3, [r7, #4]
 8001ccc:	681b      	ldr	r3, [r3, #0]
 8001cce:	687a      	ldr	r2, [r7, #4]
 8001cd0:	6812      	ldr	r2, [r2, #0]
 8001cd2:	6851      	ldr	r1, [r2, #4]
 8001cd4:	687a      	ldr	r2, [r7, #4]
 8001cd6:	6912      	ldr	r2, [r2, #16]
 8001cd8:	0212      	lsls	r2, r2, #8
 8001cda:	430a      	orrs	r2, r1
 8001cdc:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8001cde:	687b      	ldr	r3, [r7, #4]
 8001ce0:	681b      	ldr	r3, [r3, #0]
 8001ce2:	687a      	ldr	r2, [r7, #4]
 8001ce4:	6812      	ldr	r2, [r2, #0]
 8001ce6:	6852      	ldr	r2, [r2, #4]
 8001ce8:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001cec:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8001cee:	687b      	ldr	r3, [r7, #4]
 8001cf0:	681b      	ldr	r3, [r3, #0]
 8001cf2:	687a      	ldr	r2, [r7, #4]
 8001cf4:	6812      	ldr	r2, [r2, #0]
 8001cf6:	6851      	ldr	r1, [r2, #4]
 8001cf8:	687a      	ldr	r2, [r7, #4]
 8001cfa:	6892      	ldr	r2, [r2, #8]
 8001cfc:	430a      	orrs	r2, r1
 8001cfe:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8001d00:	687b      	ldr	r3, [r7, #4]
 8001d02:	681b      	ldr	r3, [r3, #0]
 8001d04:	687a      	ldr	r2, [r7, #4]
 8001d06:	6812      	ldr	r2, [r2, #0]
 8001d08:	6892      	ldr	r2, [r2, #8]
 8001d0a:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001d0e:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8001d10:	687b      	ldr	r3, [r7, #4]
 8001d12:	681b      	ldr	r3, [r3, #0]
 8001d14:	687a      	ldr	r2, [r7, #4]
 8001d16:	6812      	ldr	r2, [r2, #0]
 8001d18:	6891      	ldr	r1, [r2, #8]
 8001d1a:	687a      	ldr	r2, [r7, #4]
 8001d1c:	68d2      	ldr	r2, [r2, #12]
 8001d1e:	430a      	orrs	r2, r1
 8001d20:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8001d22:	687b      	ldr	r3, [r7, #4]
 8001d24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001d26:	4a5c      	ldr	r2, [pc, #368]	; (8001e98 <ADC_Init+0x200>)
 8001d28:	4293      	cmp	r3, r2
 8001d2a:	d022      	beq.n	8001d72 <ADC_Init+0xda>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8001d2c:	687b      	ldr	r3, [r7, #4]
 8001d2e:	681b      	ldr	r3, [r3, #0]
 8001d30:	687a      	ldr	r2, [r7, #4]
 8001d32:	6812      	ldr	r2, [r2, #0]
 8001d34:	6892      	ldr	r2, [r2, #8]
 8001d36:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8001d3a:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 8001d3c:	687b      	ldr	r3, [r7, #4]
 8001d3e:	681b      	ldr	r3, [r3, #0]
 8001d40:	687a      	ldr	r2, [r7, #4]
 8001d42:	6812      	ldr	r2, [r2, #0]
 8001d44:	6891      	ldr	r1, [r2, #8]
 8001d46:	687a      	ldr	r2, [r7, #4]
 8001d48:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001d4a:	430a      	orrs	r2, r1
 8001d4c:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8001d4e:	687b      	ldr	r3, [r7, #4]
 8001d50:	681b      	ldr	r3, [r3, #0]
 8001d52:	687a      	ldr	r2, [r7, #4]
 8001d54:	6812      	ldr	r2, [r2, #0]
 8001d56:	6892      	ldr	r2, [r2, #8]
 8001d58:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8001d5c:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 8001d5e:	687b      	ldr	r3, [r7, #4]
 8001d60:	681b      	ldr	r3, [r3, #0]
 8001d62:	687a      	ldr	r2, [r7, #4]
 8001d64:	6812      	ldr	r2, [r2, #0]
 8001d66:	6891      	ldr	r1, [r2, #8]
 8001d68:	687a      	ldr	r2, [r7, #4]
 8001d6a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8001d6c:	430a      	orrs	r2, r1
 8001d6e:	609a      	str	r2, [r3, #8]
 8001d70:	e00f      	b.n	8001d92 <ADC_Init+0xfa>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8001d72:	687b      	ldr	r3, [r7, #4]
 8001d74:	681b      	ldr	r3, [r3, #0]
 8001d76:	687a      	ldr	r2, [r7, #4]
 8001d78:	6812      	ldr	r2, [r2, #0]
 8001d7a:	6892      	ldr	r2, [r2, #8]
 8001d7c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8001d80:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8001d82:	687b      	ldr	r3, [r7, #4]
 8001d84:	681b      	ldr	r3, [r3, #0]
 8001d86:	687a      	ldr	r2, [r7, #4]
 8001d88:	6812      	ldr	r2, [r2, #0]
 8001d8a:	6892      	ldr	r2, [r2, #8]
 8001d8c:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8001d90:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8001d92:	687b      	ldr	r3, [r7, #4]
 8001d94:	681b      	ldr	r3, [r3, #0]
 8001d96:	687a      	ldr	r2, [r7, #4]
 8001d98:	6812      	ldr	r2, [r2, #0]
 8001d9a:	6892      	ldr	r2, [r2, #8]
 8001d9c:	f022 0202 	bic.w	r2, r2, #2
 8001da0:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 8001da2:	687b      	ldr	r3, [r7, #4]
 8001da4:	681b      	ldr	r3, [r3, #0]
 8001da6:	687a      	ldr	r2, [r7, #4]
 8001da8:	6812      	ldr	r2, [r2, #0]
 8001daa:	6891      	ldr	r1, [r2, #8]
 8001dac:	687a      	ldr	r2, [r7, #4]
 8001dae:	6992      	ldr	r2, [r2, #24]
 8001db0:	0052      	lsls	r2, r2, #1
 8001db2:	430a      	orrs	r2, r1
 8001db4:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 8001db6:	687b      	ldr	r3, [r7, #4]
 8001db8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001dba:	2b00      	cmp	r3, #0
 8001dbc:	d025      	beq.n	8001e0a <ADC_Init+0x172>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8001dbe:	687b      	ldr	r3, [r7, #4]
 8001dc0:	681b      	ldr	r3, [r3, #0]
 8001dc2:	687a      	ldr	r2, [r7, #4]
 8001dc4:	6812      	ldr	r2, [r2, #0]
 8001dc6:	6852      	ldr	r2, [r2, #4]
 8001dc8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001dcc:	605a      	str	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 8001dce:	687b      	ldr	r3, [r7, #4]
 8001dd0:	681b      	ldr	r3, [r3, #0]
 8001dd2:	687a      	ldr	r2, [r7, #4]
 8001dd4:	6812      	ldr	r2, [r2, #0]
 8001dd6:	6852      	ldr	r2, [r2, #4]
 8001dd8:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8001ddc:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8001dde:	687b      	ldr	r3, [r7, #4]
 8001de0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001de2:	1e5a      	subs	r2, r3, #1
 8001de4:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8001de8:	60fb      	str	r3, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001dea:	68fb      	ldr	r3, [r7, #12]
 8001dec:	fa93 f3a3 	rbit	r3, r3
 8001df0:	60bb      	str	r3, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8001df2:	68bb      	ldr	r3, [r7, #8]
 8001df4:	fab3 f383 	clz	r3, r3
 8001df8:	409a      	lsls	r2, r3
 8001dfa:	687b      	ldr	r3, [r7, #4]
 8001dfc:	681b      	ldr	r3, [r3, #0]
 8001dfe:	6879      	ldr	r1, [r7, #4]
 8001e00:	6809      	ldr	r1, [r1, #0]
 8001e02:	6849      	ldr	r1, [r1, #4]
 8001e04:	430a      	orrs	r2, r1
 8001e06:	605a      	str	r2, [r3, #4]
 8001e08:	e007      	b.n	8001e1a <ADC_Init+0x182>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8001e0a:	687b      	ldr	r3, [r7, #4]
 8001e0c:	681b      	ldr	r3, [r3, #0]
 8001e0e:	687a      	ldr	r2, [r7, #4]
 8001e10:	6812      	ldr	r2, [r2, #0]
 8001e12:	6852      	ldr	r2, [r2, #4]
 8001e14:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001e18:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8001e1a:	687b      	ldr	r3, [r7, #4]
 8001e1c:	681b      	ldr	r3, [r3, #0]
 8001e1e:	687a      	ldr	r2, [r7, #4]
 8001e20:	6812      	ldr	r2, [r2, #0]
 8001e22:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001e24:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 8001e28:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8001e2a:	687b      	ldr	r3, [r7, #4]
 8001e2c:	681b      	ldr	r3, [r3, #0]
 8001e2e:	687a      	ldr	r2, [r7, #4]
 8001e30:	6812      	ldr	r2, [r2, #0]
 8001e32:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8001e34:	687a      	ldr	r2, [r7, #4]
 8001e36:	6a12      	ldr	r2, [r2, #32]
 8001e38:	3a01      	subs	r2, #1
 8001e3a:	0512      	lsls	r2, r2, #20
 8001e3c:	430a      	orrs	r2, r1
 8001e3e:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 8001e40:	687b      	ldr	r3, [r7, #4]
 8001e42:	681b      	ldr	r3, [r3, #0]
 8001e44:	687a      	ldr	r2, [r7, #4]
 8001e46:	6812      	ldr	r2, [r2, #0]
 8001e48:	6892      	ldr	r2, [r2, #8]
 8001e4a:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001e4e:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 8001e50:	687b      	ldr	r3, [r7, #4]
 8001e52:	681b      	ldr	r3, [r3, #0]
 8001e54:	687a      	ldr	r2, [r7, #4]
 8001e56:	6812      	ldr	r2, [r2, #0]
 8001e58:	6891      	ldr	r1, [r2, #8]
 8001e5a:	687a      	ldr	r2, [r7, #4]
 8001e5c:	69d2      	ldr	r2, [r2, #28]
 8001e5e:	0252      	lsls	r2, r2, #9
 8001e60:	430a      	orrs	r2, r1
 8001e62:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8001e64:	687b      	ldr	r3, [r7, #4]
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	687a      	ldr	r2, [r7, #4]
 8001e6a:	6812      	ldr	r2, [r2, #0]
 8001e6c:	6892      	ldr	r2, [r2, #8]
 8001e6e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001e72:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8001e74:	687b      	ldr	r3, [r7, #4]
 8001e76:	681b      	ldr	r3, [r3, #0]
 8001e78:	687a      	ldr	r2, [r7, #4]
 8001e7a:	6812      	ldr	r2, [r2, #0]
 8001e7c:	6891      	ldr	r1, [r2, #8]
 8001e7e:	687a      	ldr	r2, [r7, #4]
 8001e80:	6952      	ldr	r2, [r2, #20]
 8001e82:	0292      	lsls	r2, r2, #10
 8001e84:	430a      	orrs	r2, r1
 8001e86:	609a      	str	r2, [r3, #8]
}
 8001e88:	3714      	adds	r7, #20
 8001e8a:	46bd      	mov	sp, r7
 8001e8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e90:	4770      	bx	lr
 8001e92:	bf00      	nop
 8001e94:	40012300 	.word	0x40012300
 8001e98:	0f000001 	.word	0x0f000001

08001e9c <HAL_ADCEx_InjectedStart_IT>:
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
{
 8001e9c:	b480      	push	{r7}
 8001e9e:	b087      	sub	sp, #28
 8001ea0:	af00      	add	r7, sp, #0
 8001ea2:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 8001ea4:	2300      	movs	r3, #0
 8001ea6:	60fb      	str	r3, [r7, #12]
  uint32_t tmp1 = 0, tmp2 =0;
 8001ea8:	2300      	movs	r3, #0
 8001eaa:	617b      	str	r3, [r7, #20]
 8001eac:	2300      	movs	r3, #0
 8001eae:	613b      	str	r3, [r7, #16]
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001eb0:	687b      	ldr	r3, [r7, #4]
 8001eb2:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8001eb6:	2b01      	cmp	r3, #1
 8001eb8:	d101      	bne.n	8001ebe <HAL_ADCEx_InjectedStart_IT+0x22>
 8001eba:	2302      	movs	r3, #2
 8001ebc:	e09e      	b.n	8001ffc <HAL_ADCEx_InjectedStart_IT+0x160>
 8001ebe:	687b      	ldr	r3, [r7, #4]
 8001ec0:	2201      	movs	r2, #1
 8001ec2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if a regular conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_REG)
 8001ec6:	687b      	ldr	r3, [r7, #4]
 8001ec8:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8001ecc:	b2db      	uxtb	r3, r3
 8001ece:	2b12      	cmp	r3, #18
 8001ed0:	d104      	bne.n	8001edc <HAL_ADCEx_InjectedStart_IT+0x40>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 8001ed2:	687b      	ldr	r3, [r7, #4]
 8001ed4:	2232      	movs	r2, #50	; 0x32
 8001ed6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8001eda:	e003      	b.n	8001ee4 <HAL_ADCEx_InjectedStart_IT+0x48>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ;
 8001edc:	687b      	ldr	r3, [r7, #4]
 8001ede:	2222      	movs	r2, #34	; 0x22
 8001ee0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8001ee4:	687b      	ldr	r3, [r7, #4]
 8001ee6:	2200      	movs	r2, #0
 8001ee8:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8001eea:	687b      	ldr	r3, [r7, #4]
 8001eec:	681b      	ldr	r3, [r3, #0]
 8001eee:	689b      	ldr	r3, [r3, #8]
 8001ef0:	f003 0301 	and.w	r3, r3, #1
 8001ef4:	2b00      	cmp	r3, #0
 8001ef6:	d118      	bne.n	8001f2a <HAL_ADCEx_InjectedStart_IT+0x8e>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8001ef8:	687b      	ldr	r3, [r7, #4]
 8001efa:	681b      	ldr	r3, [r3, #0]
 8001efc:	687a      	ldr	r2, [r7, #4]
 8001efe:	6812      	ldr	r2, [r2, #0]
 8001f00:	6892      	ldr	r2, [r2, #8]
 8001f02:	f042 0201 	orr.w	r2, r2, #1
 8001f06:	609a      	str	r2, [r3, #8]
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8001f08:	4b3f      	ldr	r3, [pc, #252]	; (8002008 <HAL_ADCEx_InjectedStart_IT+0x16c>)
 8001f0a:	681b      	ldr	r3, [r3, #0]
 8001f0c:	4a3f      	ldr	r2, [pc, #252]	; (800200c <HAL_ADCEx_InjectedStart_IT+0x170>)
 8001f0e:	fba2 2303 	umull	r2, r3, r2, r3
 8001f12:	0c9a      	lsrs	r2, r3, #18
 8001f14:	4613      	mov	r3, r2
 8001f16:	005b      	lsls	r3, r3, #1
 8001f18:	4413      	add	r3, r2
 8001f1a:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8001f1c:	e002      	b.n	8001f24 <HAL_ADCEx_InjectedStart_IT+0x88>
    {
      counter--;
 8001f1e:	68fb      	ldr	r3, [r7, #12]
 8001f20:	3b01      	subs	r3, #1
 8001f22:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8001f24:	68fb      	ldr	r3, [r7, #12]
 8001f26:	2b00      	cmp	r3, #0
 8001f28:	d1f9      	bne.n	8001f1e <HAL_ADCEx_InjectedStart_IT+0x82>
      counter--;
    }
  }
  
  /* Enable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
 8001f2a:	687b      	ldr	r3, [r7, #4]
 8001f2c:	681b      	ldr	r3, [r3, #0]
 8001f2e:	687a      	ldr	r2, [r7, #4]
 8001f30:	6812      	ldr	r2, [r2, #0]
 8001f32:	6852      	ldr	r2, [r2, #4]
 8001f34:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001f38:	605a      	str	r2, [r3, #4]
  
  /* Enable the ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8001f3a:	687b      	ldr	r3, [r7, #4]
 8001f3c:	681b      	ldr	r3, [r3, #0]
 8001f3e:	687a      	ldr	r2, [r7, #4]
 8001f40:	6812      	ldr	r2, [r2, #0]
 8001f42:	6852      	ldr	r2, [r2, #4]
 8001f44:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8001f48:	605a      	str	r2, [r3, #4]
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8001f4a:	4b31      	ldr	r3, [pc, #196]	; (8002010 <HAL_ADCEx_InjectedStart_IT+0x174>)
 8001f4c:	685b      	ldr	r3, [r3, #4]
 8001f4e:	f003 031f 	and.w	r3, r3, #31
 8001f52:	2b00      	cmp	r3, #0
 8001f54:	d124      	bne.n	8001fa0 <HAL_ADCEx_InjectedStart_IT+0x104>
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8001f56:	687b      	ldr	r3, [r7, #4]
 8001f58:	681b      	ldr	r3, [r3, #0]
 8001f5a:	689b      	ldr	r3, [r3, #8]
 8001f5c:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8001f60:	2b00      	cmp	r3, #0
 8001f62:	bf0c      	ite	eq
 8001f64:	2301      	moveq	r3, #1
 8001f66:	2300      	movne	r3, #0
 8001f68:	b2db      	uxtb	r3, r3
 8001f6a:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8001f6c:	687b      	ldr	r3, [r7, #4]
 8001f6e:	681b      	ldr	r3, [r3, #0]
 8001f70:	685b      	ldr	r3, [r3, #4]
 8001f72:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8001f76:	2b00      	cmp	r3, #0
 8001f78:	bf0c      	ite	eq
 8001f7a:	2301      	moveq	r3, #1
 8001f7c:	2300      	movne	r3, #0
 8001f7e:	b2db      	uxtb	r3, r3
 8001f80:	613b      	str	r3, [r7, #16]
    if(tmp1 && tmp2)
 8001f82:	697b      	ldr	r3, [r7, #20]
 8001f84:	2b00      	cmp	r3, #0
 8001f86:	d034      	beq.n	8001ff2 <HAL_ADCEx_InjectedStart_IT+0x156>
 8001f88:	693b      	ldr	r3, [r7, #16]
 8001f8a:	2b00      	cmp	r3, #0
 8001f8c:	d031      	beq.n	8001ff2 <HAL_ADCEx_InjectedStart_IT+0x156>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 8001f8e:	687b      	ldr	r3, [r7, #4]
 8001f90:	681b      	ldr	r3, [r3, #0]
 8001f92:	687a      	ldr	r2, [r7, #4]
 8001f94:	6812      	ldr	r2, [r2, #0]
 8001f96:	6892      	ldr	r2, [r2, #8]
 8001f98:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8001f9c:	609a      	str	r2, [r3, #8]
 8001f9e:	e028      	b.n	8001ff2 <HAL_ADCEx_InjectedStart_IT+0x156>
    }
  }
  else
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8001fa0:	687b      	ldr	r3, [r7, #4]
 8001fa2:	681b      	ldr	r3, [r3, #0]
 8001fa4:	689b      	ldr	r3, [r3, #8]
 8001fa6:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8001faa:	2b00      	cmp	r3, #0
 8001fac:	bf0c      	ite	eq
 8001fae:	2301      	moveq	r3, #1
 8001fb0:	2300      	movne	r3, #0
 8001fb2:	b2db      	uxtb	r3, r3
 8001fb4:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8001fb6:	687b      	ldr	r3, [r7, #4]
 8001fb8:	681b      	ldr	r3, [r3, #0]
 8001fba:	685b      	ldr	r3, [r3, #4]
 8001fbc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8001fc0:	2b00      	cmp	r3, #0
 8001fc2:	bf0c      	ite	eq
 8001fc4:	2301      	moveq	r3, #1
 8001fc6:	2300      	movne	r3, #0
 8001fc8:	b2db      	uxtb	r3, r3
 8001fca:	613b      	str	r3, [r7, #16]
    if((hadc->Instance == ADC1) && tmp1 && tmp2)  
 8001fcc:	687b      	ldr	r3, [r7, #4]
 8001fce:	681b      	ldr	r3, [r3, #0]
 8001fd0:	4a10      	ldr	r2, [pc, #64]	; (8002014 <HAL_ADCEx_InjectedStart_IT+0x178>)
 8001fd2:	4293      	cmp	r3, r2
 8001fd4:	d10d      	bne.n	8001ff2 <HAL_ADCEx_InjectedStart_IT+0x156>
 8001fd6:	697b      	ldr	r3, [r7, #20]
 8001fd8:	2b00      	cmp	r3, #0
 8001fda:	d00a      	beq.n	8001ff2 <HAL_ADCEx_InjectedStart_IT+0x156>
 8001fdc:	693b      	ldr	r3, [r7, #16]
 8001fde:	2b00      	cmp	r3, #0
 8001fe0:	d007      	beq.n	8001ff2 <HAL_ADCEx_InjectedStart_IT+0x156>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 8001fe2:	687b      	ldr	r3, [r7, #4]
 8001fe4:	681b      	ldr	r3, [r3, #0]
 8001fe6:	687a      	ldr	r2, [r7, #4]
 8001fe8:	6812      	ldr	r2, [r2, #0]
 8001fea:	6892      	ldr	r2, [r2, #8]
 8001fec:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8001ff0:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001ff2:	687b      	ldr	r3, [r7, #4]
 8001ff4:	2200      	movs	r2, #0
 8001ff6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8001ffa:	2300      	movs	r3, #0
}
 8001ffc:	4618      	mov	r0, r3
 8001ffe:	371c      	adds	r7, #28
 8002000:	46bd      	mov	sp, r7
 8002002:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002006:	4770      	bx	lr
 8002008:	20010000 	.word	0x20010000
 800200c:	431bde83 	.word	0x431bde83
 8002010:	40012300 	.word	0x40012300
 8002014:	40012000 	.word	0x40012000

08002018 <HAL_ADCEx_InjectedStop_IT>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
{
 8002018:	b480      	push	{r7}
 800201a:	b083      	sub	sp, #12
 800201c:	af00      	add	r7, sp, #0
 800201e:	6078      	str	r0, [r7, #4]
  /* Disable the ADC end of conversion interrupt for regular group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8002020:	687b      	ldr	r3, [r7, #4]
 8002022:	681b      	ldr	r3, [r3, #0]
 8002024:	687a      	ldr	r2, [r7, #4]
 8002026:	6812      	ldr	r2, [r2, #0]
 8002028:	6852      	ldr	r2, [r2, #4]
 800202a:	f022 0220 	bic.w	r2, r2, #32
 800202e:	605a      	str	r2, [r3, #4]
  
  /* Disable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_CR1_JEOCIE);
 8002030:	687b      	ldr	r3, [r7, #4]
 8002032:	681b      	ldr	r3, [r3, #0]
 8002034:	687a      	ldr	r2, [r7, #4]
 8002036:	6812      	ldr	r2, [r2, #0]
 8002038:	6852      	ldr	r2, [r2, #4]
 800203a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800203e:	605a      	str	r2, [r3, #4]
  
  /* Enable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8002040:	687b      	ldr	r3, [r7, #4]
 8002042:	681b      	ldr	r3, [r3, #0]
 8002044:	687a      	ldr	r2, [r7, #4]
 8002046:	6812      	ldr	r2, [r2, #0]
 8002048:	6892      	ldr	r2, [r2, #8]
 800204a:	f022 0201 	bic.w	r2, r2, #1
 800204e:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8002050:	687b      	ldr	r3, [r7, #4]
 8002052:	2201      	movs	r2, #1
 8002054:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8002058:	2300      	movs	r3, #0
}
 800205a:	4618      	mov	r0, r3
 800205c:	370c      	adds	r7, #12
 800205e:	46bd      	mov	sp, r7
 8002060:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002064:	4770      	bx	lr
 8002066:	bf00      	nop

08002068 <HAL_ADCEx_InjectedGetValue>:
  *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
  *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
  * @retval None
  */
uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
{
 8002068:	b480      	push	{r7}
 800206a:	b085      	sub	sp, #20
 800206c:	af00      	add	r7, sp, #0
 800206e:	6078      	str	r0, [r7, #4]
 8002070:	6039      	str	r1, [r7, #0]
  __IO uint32_t tmp = 0;
 8002072:	2300      	movs	r3, #0
 8002074:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
  
   /* Clear the ADCx's flag for injected end of conversion */
   __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 8002076:	687b      	ldr	r3, [r7, #4]
 8002078:	681b      	ldr	r3, [r3, #0]
 800207a:	f06f 0204 	mvn.w	r2, #4
 800207e:	601a      	str	r2, [r3, #0]
  
  /* Return the selected ADC converted value */ 
  switch(InjectedRank)
 8002080:	683b      	ldr	r3, [r7, #0]
 8002082:	3b01      	subs	r3, #1
 8002084:	2b03      	cmp	r3, #3
 8002086:	d81f      	bhi.n	80020c8 <HAL_ADCEx_InjectedGetValue+0x60>
 8002088:	a201      	add	r2, pc, #4	; (adr r2, 8002090 <HAL_ADCEx_InjectedGetValue+0x28>)
 800208a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800208e:	bf00      	nop
 8002090:	080020bf 	.word	0x080020bf
 8002094:	080020b5 	.word	0x080020b5
 8002098:	080020ab 	.word	0x080020ab
 800209c:	080020a1 	.word	0x080020a1
  {  
    case ADC_INJECTED_RANK_4:
    {
      tmp =  hadc->Instance->JDR4;
 80020a0:	687b      	ldr	r3, [r7, #4]
 80020a2:	681b      	ldr	r3, [r3, #0]
 80020a4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80020a6:	60fb      	str	r3, [r7, #12]
    }  
    break;
 80020a8:	e00f      	b.n	80020ca <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_3: 
    {  
      tmp =  hadc->Instance->JDR3;
 80020aa:	687b      	ldr	r3, [r7, #4]
 80020ac:	681b      	ldr	r3, [r3, #0]
 80020ae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80020b0:	60fb      	str	r3, [r7, #12]
    }  
    break;
 80020b2:	e00a      	b.n	80020ca <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_2: 
    {  
      tmp =  hadc->Instance->JDR2;
 80020b4:	687b      	ldr	r3, [r7, #4]
 80020b6:	681b      	ldr	r3, [r3, #0]
 80020b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80020ba:	60fb      	str	r3, [r7, #12]
    }
    break;
 80020bc:	e005      	b.n	80020ca <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_1:
    {
      tmp =  hadc->Instance->JDR1;
 80020be:	687b      	ldr	r3, [r7, #4]
 80020c0:	681b      	ldr	r3, [r3, #0]
 80020c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80020c4:	60fb      	str	r3, [r7, #12]
    }
    break;
 80020c6:	e000      	b.n	80020ca <HAL_ADCEx_InjectedGetValue+0x62>
    default:
    break;  
 80020c8:	bf00      	nop
  }
  return tmp;
 80020ca:	68fb      	ldr	r3, [r7, #12]
}
 80020cc:	4618      	mov	r0, r3
 80020ce:	3714      	adds	r7, #20
 80020d0:	46bd      	mov	sp, r7
 80020d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020d6:	4770      	bx	lr

080020d8 <HAL_ADCEx_InjectedConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfigInjected: ADC configuration structure for injected channel. 
  * @retval None
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
{
 80020d8:	b490      	push	{r4, r7}
 80020da:	b082      	sub	sp, #8
 80020dc:	af00      	add	r7, sp, #0
 80020de:	6078      	str	r0, [r7, #4]
 80020e0:	6039      	str	r1, [r7, #0]
  tmp = ADC_GET_RESOLUTION(hadc);
  assert_param(IS_ADC_RANGE(tmp, sConfigInjected->InjectedOffset));
#endif /* USE_FULL_ASSERT  */

  /* Process locked */
  __HAL_LOCK(hadc);
 80020e2:	687b      	ldr	r3, [r7, #4]
 80020e4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80020e8:	2b01      	cmp	r3, #1
 80020ea:	d101      	bne.n	80020f0 <HAL_ADCEx_InjectedConfigChannel+0x18>
 80020ec:	2302      	movs	r3, #2
 80020ee:	e15c      	b.n	80023aa <HAL_ADCEx_InjectedConfigChannel+0x2d2>
 80020f0:	687b      	ldr	r3, [r7, #4]
 80020f2:	2201      	movs	r2, #1
 80020f4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
 80020f8:	683b      	ldr	r3, [r7, #0]
 80020fa:	681b      	ldr	r3, [r3, #0]
 80020fc:	2b09      	cmp	r3, #9
 80020fe:	d926      	bls.n	800214e <HAL_ADCEx_InjectedConfigChannel+0x76>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
 8002100:	687b      	ldr	r3, [r7, #4]
 8002102:	681a      	ldr	r2, [r3, #0]
 8002104:	687b      	ldr	r3, [r7, #4]
 8002106:	681b      	ldr	r3, [r3, #0]
 8002108:	68d9      	ldr	r1, [r3, #12]
 800210a:	683b      	ldr	r3, [r7, #0]
 800210c:	681b      	ldr	r3, [r3, #0]
 800210e:	b29b      	uxth	r3, r3
 8002110:	4618      	mov	r0, r3
 8002112:	4603      	mov	r3, r0
 8002114:	005b      	lsls	r3, r3, #1
 8002116:	4403      	add	r3, r0
 8002118:	3b1e      	subs	r3, #30
 800211a:	4618      	mov	r0, r3
 800211c:	2307      	movs	r3, #7
 800211e:	4083      	lsls	r3, r0
 8002120:	43db      	mvns	r3, r3
 8002122:	400b      	ands	r3, r1
 8002124:	60d3      	str	r3, [r2, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8002126:	687b      	ldr	r3, [r7, #4]
 8002128:	681a      	ldr	r2, [r3, #0]
 800212a:	687b      	ldr	r3, [r7, #4]
 800212c:	681b      	ldr	r3, [r3, #0]
 800212e:	68d9      	ldr	r1, [r3, #12]
 8002130:	683b      	ldr	r3, [r7, #0]
 8002132:	6898      	ldr	r0, [r3, #8]
 8002134:	683b      	ldr	r3, [r7, #0]
 8002136:	681b      	ldr	r3, [r3, #0]
 8002138:	b29b      	uxth	r3, r3
 800213a:	461c      	mov	r4, r3
 800213c:	4623      	mov	r3, r4
 800213e:	005b      	lsls	r3, r3, #1
 8002140:	4423      	add	r3, r4
 8002142:	3b1e      	subs	r3, #30
 8002144:	fa00 f303 	lsl.w	r3, r0, r3
 8002148:	430b      	orrs	r3, r1
 800214a:	60d3      	str	r3, [r2, #12]
 800214c:	e023      	b.n	8002196 <HAL_ADCEx_InjectedConfigChannel+0xbe>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
 800214e:	687b      	ldr	r3, [r7, #4]
 8002150:	681a      	ldr	r2, [r3, #0]
 8002152:	687b      	ldr	r3, [r7, #4]
 8002154:	681b      	ldr	r3, [r3, #0]
 8002156:	6919      	ldr	r1, [r3, #16]
 8002158:	683b      	ldr	r3, [r7, #0]
 800215a:	681b      	ldr	r3, [r3, #0]
 800215c:	b29b      	uxth	r3, r3
 800215e:	4618      	mov	r0, r3
 8002160:	4603      	mov	r3, r0
 8002162:	005b      	lsls	r3, r3, #1
 8002164:	4403      	add	r3, r0
 8002166:	4618      	mov	r0, r3
 8002168:	2307      	movs	r3, #7
 800216a:	4083      	lsls	r3, r0
 800216c:	43db      	mvns	r3, r3
 800216e:	400b      	ands	r3, r1
 8002170:	6113      	str	r3, [r2, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8002172:	687b      	ldr	r3, [r7, #4]
 8002174:	681a      	ldr	r2, [r3, #0]
 8002176:	687b      	ldr	r3, [r7, #4]
 8002178:	681b      	ldr	r3, [r3, #0]
 800217a:	6919      	ldr	r1, [r3, #16]
 800217c:	683b      	ldr	r3, [r7, #0]
 800217e:	6898      	ldr	r0, [r3, #8]
 8002180:	683b      	ldr	r3, [r7, #0]
 8002182:	681b      	ldr	r3, [r3, #0]
 8002184:	b29b      	uxth	r3, r3
 8002186:	461c      	mov	r4, r3
 8002188:	4623      	mov	r3, r4
 800218a:	005b      	lsls	r3, r3, #1
 800218c:	4423      	add	r3, r4
 800218e:	fa00 f303 	lsl.w	r3, r0, r3
 8002192:	430b      	orrs	r3, r1
 8002194:	6113      	str	r3, [r2, #16]
  }
  
  /*---------------------------- ADCx JSQR Configuration -----------------*/
  hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
 8002196:	687b      	ldr	r3, [r7, #4]
 8002198:	681b      	ldr	r3, [r3, #0]
 800219a:	687a      	ldr	r2, [r7, #4]
 800219c:	6812      	ldr	r2, [r2, #0]
 800219e:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80021a0:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80021a4:	639a      	str	r2, [r3, #56]	; 0x38
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 80021a6:	687b      	ldr	r3, [r7, #4]
 80021a8:	681b      	ldr	r3, [r3, #0]
 80021aa:	687a      	ldr	r2, [r7, #4]
 80021ac:	6812      	ldr	r2, [r2, #0]
 80021ae:	6b91      	ldr	r1, [r2, #56]	; 0x38
 80021b0:	683a      	ldr	r2, [r7, #0]
 80021b2:	6912      	ldr	r2, [r2, #16]
 80021b4:	3a01      	subs	r2, #1
 80021b6:	0512      	lsls	r2, r2, #20
 80021b8:	430a      	orrs	r2, r1
 80021ba:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Rank configuration */
  
  /* Clear the old SQx bits for the selected rank */
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 80021bc:	687b      	ldr	r3, [r7, #4]
 80021be:	681a      	ldr	r2, [r3, #0]
 80021c0:	687b      	ldr	r3, [r7, #4]
 80021c2:	681b      	ldr	r3, [r3, #0]
 80021c4:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80021c6:	683b      	ldr	r3, [r7, #0]
 80021c8:	685b      	ldr	r3, [r3, #4]
 80021ca:	b2d8      	uxtb	r0, r3
 80021cc:	683b      	ldr	r3, [r7, #0]
 80021ce:	691b      	ldr	r3, [r3, #16]
 80021d0:	b2db      	uxtb	r3, r3
 80021d2:	1ac3      	subs	r3, r0, r3
 80021d4:	b2db      	uxtb	r3, r3
 80021d6:	3303      	adds	r3, #3
 80021d8:	b2db      	uxtb	r3, r3
 80021da:	4618      	mov	r0, r3
 80021dc:	4603      	mov	r3, r0
 80021de:	009b      	lsls	r3, r3, #2
 80021e0:	4403      	add	r3, r0
 80021e2:	201f      	movs	r0, #31
 80021e4:	fa00 f303 	lsl.w	r3, r0, r3
 80021e8:	43db      	mvns	r3, r3
 80021ea:	400b      	ands	r3, r1
 80021ec:	6393      	str	r3, [r2, #56]	; 0x38
   
  /* Set the SQx bits for the selected rank */
  hadc->Instance->JSQR |= ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 80021ee:	687b      	ldr	r3, [r7, #4]
 80021f0:	681a      	ldr	r2, [r3, #0]
 80021f2:	687b      	ldr	r3, [r7, #4]
 80021f4:	681b      	ldr	r3, [r3, #0]
 80021f6:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80021f8:	683b      	ldr	r3, [r7, #0]
 80021fa:	681b      	ldr	r3, [r3, #0]
 80021fc:	b29b      	uxth	r3, r3
 80021fe:	461c      	mov	r4, r3
 8002200:	683b      	ldr	r3, [r7, #0]
 8002202:	685b      	ldr	r3, [r3, #4]
 8002204:	b2d8      	uxtb	r0, r3
 8002206:	683b      	ldr	r3, [r7, #0]
 8002208:	691b      	ldr	r3, [r3, #16]
 800220a:	b2db      	uxtb	r3, r3
 800220c:	1ac3      	subs	r3, r0, r3
 800220e:	b2db      	uxtb	r3, r3
 8002210:	3303      	adds	r3, #3
 8002212:	b2db      	uxtb	r3, r3
 8002214:	4618      	mov	r0, r3
 8002216:	4603      	mov	r3, r0
 8002218:	009b      	lsls	r3, r3, #2
 800221a:	4403      	add	r3, r0
 800221c:	fa04 f303 	lsl.w	r3, r4, r3
 8002220:	430b      	orrs	r3, r1
 8002222:	6393      	str	r3, [r2, #56]	; 0x38

  /* Select external trigger to start conversion */
  hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
 8002224:	687b      	ldr	r3, [r7, #4]
 8002226:	681b      	ldr	r3, [r3, #0]
 8002228:	687a      	ldr	r2, [r7, #4]
 800222a:	6812      	ldr	r2, [r2, #0]
 800222c:	6892      	ldr	r2, [r2, #8]
 800222e:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8002232:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
 8002234:	687b      	ldr	r3, [r7, #4]
 8002236:	681b      	ldr	r3, [r3, #0]
 8002238:	687a      	ldr	r2, [r7, #4]
 800223a:	6812      	ldr	r2, [r2, #0]
 800223c:	6891      	ldr	r1, [r2, #8]
 800223e:	683a      	ldr	r2, [r7, #0]
 8002240:	6a12      	ldr	r2, [r2, #32]
 8002242:	430a      	orrs	r2, r1
 8002244:	609a      	str	r2, [r3, #8]
  
  /* Select external trigger polarity */
  hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
 8002246:	687b      	ldr	r3, [r7, #4]
 8002248:	681b      	ldr	r3, [r3, #0]
 800224a:	687a      	ldr	r2, [r7, #4]
 800224c:	6812      	ldr	r2, [r2, #0]
 800224e:	6892      	ldr	r2, [r2, #8]
 8002250:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8002254:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
 8002256:	687b      	ldr	r3, [r7, #4]
 8002258:	681b      	ldr	r3, [r3, #0]
 800225a:	687a      	ldr	r2, [r7, #4]
 800225c:	6812      	ldr	r2, [r2, #0]
 800225e:	6891      	ldr	r1, [r2, #8]
 8002260:	683a      	ldr	r2, [r7, #0]
 8002262:	69d2      	ldr	r2, [r2, #28]
 8002264:	430a      	orrs	r2, r1
 8002266:	609a      	str	r2, [r3, #8]
  
  if (sConfigInjected->AutoInjectedConv != DISABLE)
 8002268:	683b      	ldr	r3, [r7, #0]
 800226a:	695b      	ldr	r3, [r3, #20]
 800226c:	2b00      	cmp	r3, #0
 800226e:	d008      	beq.n	8002282 <HAL_ADCEx_InjectedConfigChannel+0x1aa>
  {
    /* Enable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 |= ADC_CR1_JAUTO;
 8002270:	687b      	ldr	r3, [r7, #4]
 8002272:	681b      	ldr	r3, [r3, #0]
 8002274:	687a      	ldr	r2, [r7, #4]
 8002276:	6812      	ldr	r2, [r2, #0]
 8002278:	6852      	ldr	r2, [r2, #4]
 800227a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800227e:	605a      	str	r2, [r3, #4]
 8002280:	e007      	b.n	8002292 <HAL_ADCEx_InjectedConfigChannel+0x1ba>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
 8002282:	687b      	ldr	r3, [r7, #4]
 8002284:	681b      	ldr	r3, [r3, #0]
 8002286:	687a      	ldr	r2, [r7, #4]
 8002288:	6812      	ldr	r2, [r2, #0]
 800228a:	6852      	ldr	r2, [r2, #4]
 800228c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002290:	605a      	str	r2, [r3, #4]
  }
  
  if (sConfigInjected->InjectedDiscontinuousConvMode != DISABLE)
 8002292:	683b      	ldr	r3, [r7, #0]
 8002294:	699b      	ldr	r3, [r3, #24]
 8002296:	2b00      	cmp	r3, #0
 8002298:	d008      	beq.n	80022ac <HAL_ADCEx_InjectedConfigChannel+0x1d4>
  {
    /* Enable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
 800229a:	687b      	ldr	r3, [r7, #4]
 800229c:	681b      	ldr	r3, [r3, #0]
 800229e:	687a      	ldr	r2, [r7, #4]
 80022a0:	6812      	ldr	r2, [r2, #0]
 80022a2:	6852      	ldr	r2, [r2, #4]
 80022a4:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80022a8:	605a      	str	r2, [r3, #4]
 80022aa:	e007      	b.n	80022bc <HAL_ADCEx_InjectedConfigChannel+0x1e4>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
 80022ac:	687b      	ldr	r3, [r7, #4]
 80022ae:	681b      	ldr	r3, [r3, #0]
 80022b0:	687a      	ldr	r2, [r7, #4]
 80022b2:	6812      	ldr	r2, [r2, #0]
 80022b4:	6852      	ldr	r2, [r2, #4]
 80022b6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80022ba:	605a      	str	r2, [r3, #4]
  }
  
  switch(sConfigInjected->InjectedRank)
 80022bc:	683b      	ldr	r3, [r7, #0]
 80022be:	685b      	ldr	r3, [r3, #4]
 80022c0:	2b02      	cmp	r3, #2
 80022c2:	d015      	beq.n	80022f0 <HAL_ADCEx_InjectedConfigChannel+0x218>
 80022c4:	2b03      	cmp	r3, #3
 80022c6:	d025      	beq.n	8002314 <HAL_ADCEx_InjectedConfigChannel+0x23c>
 80022c8:	2b01      	cmp	r3, #1
 80022ca:	d135      	bne.n	8002338 <HAL_ADCEx_InjectedConfigChannel+0x260>
  {
    case 1:
      /* Set injected channel 1 offset */
      hadc->Instance->JOFR1 &= ~(ADC_JOFR1_JOFFSET1);
 80022cc:	687b      	ldr	r3, [r7, #4]
 80022ce:	681a      	ldr	r2, [r3, #0]
 80022d0:	687b      	ldr	r3, [r7, #4]
 80022d2:	681b      	ldr	r3, [r3, #0]
 80022d4:	6959      	ldr	r1, [r3, #20]
 80022d6:	4b37      	ldr	r3, [pc, #220]	; (80023b4 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 80022d8:	400b      	ands	r3, r1
 80022da:	6153      	str	r3, [r2, #20]
      hadc->Instance->JOFR1 |= sConfigInjected->InjectedOffset;
 80022dc:	687b      	ldr	r3, [r7, #4]
 80022de:	681b      	ldr	r3, [r3, #0]
 80022e0:	687a      	ldr	r2, [r7, #4]
 80022e2:	6812      	ldr	r2, [r2, #0]
 80022e4:	6951      	ldr	r1, [r2, #20]
 80022e6:	683a      	ldr	r2, [r7, #0]
 80022e8:	68d2      	ldr	r2, [r2, #12]
 80022ea:	430a      	orrs	r2, r1
 80022ec:	615a      	str	r2, [r3, #20]
      break;
 80022ee:	e035      	b.n	800235c <HAL_ADCEx_InjectedConfigChannel+0x284>
    case 2:
      /* Set injected channel 2 offset */
      hadc->Instance->JOFR2 &= ~(ADC_JOFR2_JOFFSET2);
 80022f0:	687b      	ldr	r3, [r7, #4]
 80022f2:	681a      	ldr	r2, [r3, #0]
 80022f4:	687b      	ldr	r3, [r7, #4]
 80022f6:	681b      	ldr	r3, [r3, #0]
 80022f8:	6999      	ldr	r1, [r3, #24]
 80022fa:	4b2e      	ldr	r3, [pc, #184]	; (80023b4 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 80022fc:	400b      	ands	r3, r1
 80022fe:	6193      	str	r3, [r2, #24]
      hadc->Instance->JOFR2 |= sConfigInjected->InjectedOffset;
 8002300:	687b      	ldr	r3, [r7, #4]
 8002302:	681b      	ldr	r3, [r3, #0]
 8002304:	687a      	ldr	r2, [r7, #4]
 8002306:	6812      	ldr	r2, [r2, #0]
 8002308:	6991      	ldr	r1, [r2, #24]
 800230a:	683a      	ldr	r2, [r7, #0]
 800230c:	68d2      	ldr	r2, [r2, #12]
 800230e:	430a      	orrs	r2, r1
 8002310:	619a      	str	r2, [r3, #24]
      break;
 8002312:	e023      	b.n	800235c <HAL_ADCEx_InjectedConfigChannel+0x284>
    case 3:
      /* Set injected channel 3 offset */
      hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
 8002314:	687b      	ldr	r3, [r7, #4]
 8002316:	681a      	ldr	r2, [r3, #0]
 8002318:	687b      	ldr	r3, [r7, #4]
 800231a:	681b      	ldr	r3, [r3, #0]
 800231c:	69d9      	ldr	r1, [r3, #28]
 800231e:	4b25      	ldr	r3, [pc, #148]	; (80023b4 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8002320:	400b      	ands	r3, r1
 8002322:	61d3      	str	r3, [r2, #28]
      hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
 8002324:	687b      	ldr	r3, [r7, #4]
 8002326:	681b      	ldr	r3, [r3, #0]
 8002328:	687a      	ldr	r2, [r7, #4]
 800232a:	6812      	ldr	r2, [r2, #0]
 800232c:	69d1      	ldr	r1, [r2, #28]
 800232e:	683a      	ldr	r2, [r7, #0]
 8002330:	68d2      	ldr	r2, [r2, #12]
 8002332:	430a      	orrs	r2, r1
 8002334:	61da      	str	r2, [r3, #28]
      break;
 8002336:	e011      	b.n	800235c <HAL_ADCEx_InjectedConfigChannel+0x284>
    default:
      /* Set injected channel 4 offset */
      hadc->Instance->JOFR4 &= ~(ADC_JOFR4_JOFFSET4);
 8002338:	687b      	ldr	r3, [r7, #4]
 800233a:	681a      	ldr	r2, [r3, #0]
 800233c:	687b      	ldr	r3, [r7, #4]
 800233e:	681b      	ldr	r3, [r3, #0]
 8002340:	6a19      	ldr	r1, [r3, #32]
 8002342:	4b1c      	ldr	r3, [pc, #112]	; (80023b4 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8002344:	400b      	ands	r3, r1
 8002346:	6213      	str	r3, [r2, #32]
      hadc->Instance->JOFR4 |= sConfigInjected->InjectedOffset;
 8002348:	687b      	ldr	r3, [r7, #4]
 800234a:	681b      	ldr	r3, [r3, #0]
 800234c:	687a      	ldr	r2, [r7, #4]
 800234e:	6812      	ldr	r2, [r2, #0]
 8002350:	6a11      	ldr	r1, [r2, #32]
 8002352:	683a      	ldr	r2, [r7, #0]
 8002354:	68d2      	ldr	r2, [r2, #12]
 8002356:	430a      	orrs	r2, r1
 8002358:	621a      	str	r2, [r3, #32]
      break;
 800235a:	bf00      	nop
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
 800235c:	687b      	ldr	r3, [r7, #4]
 800235e:	681b      	ldr	r3, [r3, #0]
 8002360:	4a15      	ldr	r2, [pc, #84]	; (80023b8 <HAL_ADCEx_InjectedConfigChannel+0x2e0>)
 8002362:	4293      	cmp	r3, r2
 8002364:	d109      	bne.n	800237a <HAL_ADCEx_InjectedConfigChannel+0x2a2>
 8002366:	683b      	ldr	r3, [r7, #0]
 8002368:	681b      	ldr	r3, [r3, #0]
 800236a:	2b12      	cmp	r3, #18
 800236c:	d105      	bne.n	800237a <HAL_ADCEx_InjectedConfigChannel+0x2a2>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 800236e:	4a13      	ldr	r2, [pc, #76]	; (80023bc <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 8002370:	4b12      	ldr	r3, [pc, #72]	; (80023bc <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 8002372:	685b      	ldr	r3, [r3, #4]
 8002374:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8002378:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) || (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)))
 800237a:	687b      	ldr	r3, [r7, #4]
 800237c:	681b      	ldr	r3, [r3, #0]
 800237e:	4a0e      	ldr	r2, [pc, #56]	; (80023b8 <HAL_ADCEx_InjectedConfigChannel+0x2e0>)
 8002380:	4293      	cmp	r3, r2
 8002382:	d10d      	bne.n	80023a0 <HAL_ADCEx_InjectedConfigChannel+0x2c8>
 8002384:	683b      	ldr	r3, [r7, #0]
 8002386:	681b      	ldr	r3, [r3, #0]
 8002388:	2b10      	cmp	r3, #16
 800238a:	d003      	beq.n	8002394 <HAL_ADCEx_InjectedConfigChannel+0x2bc>
 800238c:	683b      	ldr	r3, [r7, #0]
 800238e:	681b      	ldr	r3, [r3, #0]
 8002390:	2b11      	cmp	r3, #17
 8002392:	d105      	bne.n	80023a0 <HAL_ADCEx_InjectedConfigChannel+0x2c8>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 8002394:	4a09      	ldr	r2, [pc, #36]	; (80023bc <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 8002396:	4b09      	ldr	r3, [pc, #36]	; (80023bc <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 8002398:	685b      	ldr	r3, [r3, #4]
 800239a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800239e:	6053      	str	r3, [r2, #4]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80023a0:	687b      	ldr	r3, [r7, #4]
 80023a2:	2200      	movs	r2, #0
 80023a4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 80023a8:	2300      	movs	r3, #0
}
 80023aa:	4618      	mov	r0, r3
 80023ac:	3708      	adds	r7, #8
 80023ae:	46bd      	mov	sp, r7
 80023b0:	bc90      	pop	{r4, r7}
 80023b2:	4770      	bx	lr
 80023b4:	fffff000 	.word	0xfffff000
 80023b8:	40012000 	.word	0x40012000
 80023bc:	40012300 	.word	0x40012300

080023c0 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param  multimode : pointer to an ADC_MultiModeTypeDef structure that contains 
  *                     the configuration information for  multimode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
{
 80023c0:	b480      	push	{r7}
 80023c2:	b083      	sub	sp, #12
 80023c4:	af00      	add	r7, sp, #0
 80023c6:	6078      	str	r0, [r7, #4]
 80023c8:	6039      	str	r1, [r7, #0]
  assert_param(IS_ADC_MODE(multimode->Mode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(multimode->DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80023ca:	687b      	ldr	r3, [r7, #4]
 80023cc:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80023d0:	2b01      	cmp	r3, #1
 80023d2:	d101      	bne.n	80023d8 <HAL_ADCEx_MultiModeConfigChannel+0x18>
 80023d4:	2302      	movs	r3, #2
 80023d6:	e02f      	b.n	8002438 <HAL_ADCEx_MultiModeConfigChannel+0x78>
 80023d8:	687b      	ldr	r3, [r7, #4]
 80023da:	2201      	movs	r2, #1
 80023dc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Set ADC mode */
  ADC->CCR &= ~(ADC_CCR_MULTI);
 80023e0:	4a18      	ldr	r2, [pc, #96]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80023e2:	4b18      	ldr	r3, [pc, #96]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80023e4:	685b      	ldr	r3, [r3, #4]
 80023e6:	f023 031f 	bic.w	r3, r3, #31
 80023ea:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->Mode;
 80023ec:	4915      	ldr	r1, [pc, #84]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80023ee:	4b15      	ldr	r3, [pc, #84]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80023f0:	685a      	ldr	r2, [r3, #4]
 80023f2:	683b      	ldr	r3, [r7, #0]
 80023f4:	681b      	ldr	r3, [r3, #0]
 80023f6:	4313      	orrs	r3, r2
 80023f8:	604b      	str	r3, [r1, #4]
  
  /* Set the ADC DMA access mode */
  ADC->CCR &= ~(ADC_CCR_DMA);
 80023fa:	4a12      	ldr	r2, [pc, #72]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80023fc:	4b11      	ldr	r3, [pc, #68]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80023fe:	685b      	ldr	r3, [r3, #4]
 8002400:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002404:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->DMAAccessMode;
 8002406:	490f      	ldr	r1, [pc, #60]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8002408:	4b0e      	ldr	r3, [pc, #56]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 800240a:	685a      	ldr	r2, [r3, #4]
 800240c:	683b      	ldr	r3, [r7, #0]
 800240e:	685b      	ldr	r3, [r3, #4]
 8002410:	4313      	orrs	r3, r2
 8002412:	604b      	str	r3, [r1, #4]
  
  /* Set delay between two sampling phases */
  ADC->CCR &= ~(ADC_CCR_DELAY);
 8002414:	4a0b      	ldr	r2, [pc, #44]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8002416:	4b0b      	ldr	r3, [pc, #44]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8002418:	685b      	ldr	r3, [r3, #4]
 800241a:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800241e:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->TwoSamplingDelay;
 8002420:	4908      	ldr	r1, [pc, #32]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8002422:	4b08      	ldr	r3, [pc, #32]	; (8002444 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8002424:	685a      	ldr	r2, [r3, #4]
 8002426:	683b      	ldr	r3, [r7, #0]
 8002428:	689b      	ldr	r3, [r3, #8]
 800242a:	4313      	orrs	r3, r2
 800242c:	604b      	str	r3, [r1, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800242e:	687b      	ldr	r3, [r7, #4]
 8002430:	2200      	movs	r2, #0
 8002432:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8002436:	2300      	movs	r3, #0
}
 8002438:	4618      	mov	r0, r3
 800243a:	370c      	adds	r7, #12
 800243c:	46bd      	mov	sp, r7
 800243e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002442:	4770      	bx	lr
 8002444:	40012300 	.word	0x40012300

08002448 <HAL_CAN_Init>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef* hcan)
{
 8002448:	b580      	push	{r7, lr}
 800244a:	b084      	sub	sp, #16
 800244c:	af00      	add	r7, sp, #0
 800244e:	6078      	str	r0, [r7, #4]
  uint32_t InitStatus = 3;
 8002450:	2303      	movs	r3, #3
 8002452:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart = 0;
 8002454:	2300      	movs	r3, #0
 8002456:	60bb      	str	r3, [r7, #8]
  
  /* Check CAN handle */
  if(hcan == NULL)
 8002458:	687b      	ldr	r3, [r7, #4]
 800245a:	2b00      	cmp	r3, #0
 800245c:	d101      	bne.n	8002462 <HAL_CAN_Init+0x1a>
  {
     return HAL_ERROR;
 800245e:	2301      	movs	r3, #1
 8002460:	e117      	b.n	8002692 <HAL_CAN_Init+0x24a>
  assert_param(IS_CAN_BS1(hcan->Init.BS1));
  assert_param(IS_CAN_BS2(hcan->Init.BS2));
  assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));
  

  if(hcan->State == HAL_CAN_STATE_RESET)
 8002462:	687b      	ldr	r3, [r7, #4]
 8002464:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8002468:	b2db      	uxtb	r3, r3
 800246a:	2b00      	cmp	r3, #0
 800246c:	d106      	bne.n	800247c <HAL_CAN_Init+0x34>
  {
    /* Allocate lock resource and initialize it */
    hcan->Lock = HAL_UNLOCKED;
 800246e:	687b      	ldr	r3, [r7, #4]
 8002470:	2200      	movs	r2, #0
 8002472:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    /* Init the low level hardware */
    HAL_CAN_MspInit(hcan);
 8002476:	6878      	ldr	r0, [r7, #4]
 8002478:	f00a fd26 	bl	800cec8 <HAL_CAN_MspInit>
  }
  
  /* Initialize the CAN state*/
  hcan->State = HAL_CAN_STATE_BUSY;
 800247c:	687b      	ldr	r3, [r7, #4]
 800247e:	2202      	movs	r2, #2
 8002480:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  /* Exit from sleep mode */
  hcan->Instance->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
 8002484:	687b      	ldr	r3, [r7, #4]
 8002486:	681b      	ldr	r3, [r3, #0]
 8002488:	687a      	ldr	r2, [r7, #4]
 800248a:	6812      	ldr	r2, [r2, #0]
 800248c:	6812      	ldr	r2, [r2, #0]
 800248e:	f022 0202 	bic.w	r2, r2, #2
 8002492:	601a      	str	r2, [r3, #0]

  /* Request initialisation */
  hcan->Instance->MCR |= CAN_MCR_INRQ ;
 8002494:	687b      	ldr	r3, [r7, #4]
 8002496:	681b      	ldr	r3, [r3, #0]
 8002498:	687a      	ldr	r2, [r7, #4]
 800249a:	6812      	ldr	r2, [r2, #0]
 800249c:	6812      	ldr	r2, [r2, #0]
 800249e:	f042 0201 	orr.w	r2, r2, #1
 80024a2:	601a      	str	r2, [r3, #0]
  
  /* Get tick */
  tickstart = HAL_GetTick();
 80024a4:	f7ff f88e 	bl	80015c4 <HAL_GetTick>
 80024a8:	60b8      	str	r0, [r7, #8]

  /* Wait the acknowledge */
  while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 80024aa:	e010      	b.n	80024ce <HAL_CAN_Init+0x86>
  {
    if((HAL_GetTick() - tickstart ) > CAN_TIMEOUT_VALUE)
 80024ac:	f7ff f88a 	bl	80015c4 <HAL_GetTick>
 80024b0:	4602      	mov	r2, r0
 80024b2:	68bb      	ldr	r3, [r7, #8]
 80024b4:	1ad3      	subs	r3, r2, r3
 80024b6:	2b0a      	cmp	r3, #10
 80024b8:	d909      	bls.n	80024ce <HAL_CAN_Init+0x86>
    {
      hcan->State= HAL_CAN_STATE_TIMEOUT;
 80024ba:	687b      	ldr	r3, [r7, #4]
 80024bc:	2203      	movs	r2, #3
 80024be:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 80024c2:	687b      	ldr	r3, [r7, #4]
 80024c4:	2200      	movs	r2, #0
 80024c6:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
      return HAL_TIMEOUT;
 80024ca:	2303      	movs	r3, #3
 80024cc:	e0e1      	b.n	8002692 <HAL_CAN_Init+0x24a>
  
  /* Get tick */
  tickstart = HAL_GetTick();

  /* Wait the acknowledge */
  while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 80024ce:	687b      	ldr	r3, [r7, #4]
 80024d0:	681b      	ldr	r3, [r3, #0]
 80024d2:	685b      	ldr	r3, [r3, #4]
 80024d4:	f003 0301 	and.w	r3, r3, #1
 80024d8:	2b00      	cmp	r3, #0
 80024da:	d0e7      	beq.n	80024ac <HAL_CAN_Init+0x64>
      return HAL_TIMEOUT;
    }
  }

  /* Check acknowledge */
  if ((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 80024dc:	687b      	ldr	r3, [r7, #4]
 80024de:	681b      	ldr	r3, [r3, #0]
 80024e0:	685b      	ldr	r3, [r3, #4]
 80024e2:	f003 0301 	and.w	r3, r3, #1
 80024e6:	2b00      	cmp	r3, #0
 80024e8:	d102      	bne.n	80024f0 <HAL_CAN_Init+0xa8>
  {
    InitStatus = CAN_INITSTATUS_FAILED;
 80024ea:	2300      	movs	r3, #0
 80024ec:	60fb      	str	r3, [r7, #12]
 80024ee:	e0bf      	b.n	8002670 <HAL_CAN_Init+0x228>
  }
  else 
  {
    /* Set the time triggered communication mode */
    if (hcan->Init.TTCM == ENABLE)
 80024f0:	687b      	ldr	r3, [r7, #4]
 80024f2:	699b      	ldr	r3, [r3, #24]
 80024f4:	2b01      	cmp	r3, #1
 80024f6:	d108      	bne.n	800250a <HAL_CAN_Init+0xc2>
    {
      hcan->Instance->MCR |= CAN_MCR_TTCM;
 80024f8:	687b      	ldr	r3, [r7, #4]
 80024fa:	681b      	ldr	r3, [r3, #0]
 80024fc:	687a      	ldr	r2, [r7, #4]
 80024fe:	6812      	ldr	r2, [r2, #0]
 8002500:	6812      	ldr	r2, [r2, #0]
 8002502:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002506:	601a      	str	r2, [r3, #0]
 8002508:	e007      	b.n	800251a <HAL_CAN_Init+0xd2>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 800250a:	687b      	ldr	r3, [r7, #4]
 800250c:	681b      	ldr	r3, [r3, #0]
 800250e:	687a      	ldr	r2, [r7, #4]
 8002510:	6812      	ldr	r2, [r2, #0]
 8002512:	6812      	ldr	r2, [r2, #0]
 8002514:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002518:	601a      	str	r2, [r3, #0]
    }

    /* Set the automatic bus-off management */
    if (hcan->Init.ABOM == ENABLE)
 800251a:	687b      	ldr	r3, [r7, #4]
 800251c:	69db      	ldr	r3, [r3, #28]
 800251e:	2b01      	cmp	r3, #1
 8002520:	d108      	bne.n	8002534 <HAL_CAN_Init+0xec>
    {
      hcan->Instance->MCR |= CAN_MCR_ABOM;
 8002522:	687b      	ldr	r3, [r7, #4]
 8002524:	681b      	ldr	r3, [r3, #0]
 8002526:	687a      	ldr	r2, [r7, #4]
 8002528:	6812      	ldr	r2, [r2, #0]
 800252a:	6812      	ldr	r2, [r2, #0]
 800252c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002530:	601a      	str	r2, [r3, #0]
 8002532:	e007      	b.n	8002544 <HAL_CAN_Init+0xfc>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 8002534:	687b      	ldr	r3, [r7, #4]
 8002536:	681b      	ldr	r3, [r3, #0]
 8002538:	687a      	ldr	r2, [r7, #4]
 800253a:	6812      	ldr	r2, [r2, #0]
 800253c:	6812      	ldr	r2, [r2, #0]
 800253e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002542:	601a      	str	r2, [r3, #0]
    }

    /* Set the automatic wake-up mode */
    if (hcan->Init.AWUM == ENABLE)
 8002544:	687b      	ldr	r3, [r7, #4]
 8002546:	6a1b      	ldr	r3, [r3, #32]
 8002548:	2b01      	cmp	r3, #1
 800254a:	d108      	bne.n	800255e <HAL_CAN_Init+0x116>
    {
      hcan->Instance->MCR |= CAN_MCR_AWUM;
 800254c:	687b      	ldr	r3, [r7, #4]
 800254e:	681b      	ldr	r3, [r3, #0]
 8002550:	687a      	ldr	r2, [r7, #4]
 8002552:	6812      	ldr	r2, [r2, #0]
 8002554:	6812      	ldr	r2, [r2, #0]
 8002556:	f042 0220 	orr.w	r2, r2, #32
 800255a:	601a      	str	r2, [r3, #0]
 800255c:	e007      	b.n	800256e <HAL_CAN_Init+0x126>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 800255e:	687b      	ldr	r3, [r7, #4]
 8002560:	681b      	ldr	r3, [r3, #0]
 8002562:	687a      	ldr	r2, [r7, #4]
 8002564:	6812      	ldr	r2, [r2, #0]
 8002566:	6812      	ldr	r2, [r2, #0]
 8002568:	f022 0220 	bic.w	r2, r2, #32
 800256c:	601a      	str	r2, [r3, #0]
    }

    /* Set the no automatic retransmission */
    if (hcan->Init.NART == ENABLE)
 800256e:	687b      	ldr	r3, [r7, #4]
 8002570:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002572:	2b01      	cmp	r3, #1
 8002574:	d108      	bne.n	8002588 <HAL_CAN_Init+0x140>
    {
      hcan->Instance->MCR |= CAN_MCR_NART;
 8002576:	687b      	ldr	r3, [r7, #4]
 8002578:	681b      	ldr	r3, [r3, #0]
 800257a:	687a      	ldr	r2, [r7, #4]
 800257c:	6812      	ldr	r2, [r2, #0]
 800257e:	6812      	ldr	r2, [r2, #0]
 8002580:	f042 0210 	orr.w	r2, r2, #16
 8002584:	601a      	str	r2, [r3, #0]
 8002586:	e007      	b.n	8002598 <HAL_CAN_Init+0x150>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_NART;
 8002588:	687b      	ldr	r3, [r7, #4]
 800258a:	681b      	ldr	r3, [r3, #0]
 800258c:	687a      	ldr	r2, [r7, #4]
 800258e:	6812      	ldr	r2, [r2, #0]
 8002590:	6812      	ldr	r2, [r2, #0]
 8002592:	f022 0210 	bic.w	r2, r2, #16
 8002596:	601a      	str	r2, [r3, #0]
    }

    /* Set the receive FIFO locked mode */
    if (hcan->Init.RFLM == ENABLE)
 8002598:	687b      	ldr	r3, [r7, #4]
 800259a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800259c:	2b01      	cmp	r3, #1
 800259e:	d108      	bne.n	80025b2 <HAL_CAN_Init+0x16a>
    {
      hcan->Instance->MCR |= CAN_MCR_RFLM;
 80025a0:	687b      	ldr	r3, [r7, #4]
 80025a2:	681b      	ldr	r3, [r3, #0]
 80025a4:	687a      	ldr	r2, [r7, #4]
 80025a6:	6812      	ldr	r2, [r2, #0]
 80025a8:	6812      	ldr	r2, [r2, #0]
 80025aa:	f042 0208 	orr.w	r2, r2, #8
 80025ae:	601a      	str	r2, [r3, #0]
 80025b0:	e007      	b.n	80025c2 <HAL_CAN_Init+0x17a>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 80025b2:	687b      	ldr	r3, [r7, #4]
 80025b4:	681b      	ldr	r3, [r3, #0]
 80025b6:	687a      	ldr	r2, [r7, #4]
 80025b8:	6812      	ldr	r2, [r2, #0]
 80025ba:	6812      	ldr	r2, [r2, #0]
 80025bc:	f022 0208 	bic.w	r2, r2, #8
 80025c0:	601a      	str	r2, [r3, #0]
    }

    /* Set the transmit FIFO priority */
    if (hcan->Init.TXFP == ENABLE)
 80025c2:	687b      	ldr	r3, [r7, #4]
 80025c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80025c6:	2b01      	cmp	r3, #1
 80025c8:	d108      	bne.n	80025dc <HAL_CAN_Init+0x194>
    {
      hcan->Instance->MCR |= CAN_MCR_TXFP;
 80025ca:	687b      	ldr	r3, [r7, #4]
 80025cc:	681b      	ldr	r3, [r3, #0]
 80025ce:	687a      	ldr	r2, [r7, #4]
 80025d0:	6812      	ldr	r2, [r2, #0]
 80025d2:	6812      	ldr	r2, [r2, #0]
 80025d4:	f042 0204 	orr.w	r2, r2, #4
 80025d8:	601a      	str	r2, [r3, #0]
 80025da:	e007      	b.n	80025ec <HAL_CAN_Init+0x1a4>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 80025dc:	687b      	ldr	r3, [r7, #4]
 80025de:	681b      	ldr	r3, [r3, #0]
 80025e0:	687a      	ldr	r2, [r7, #4]
 80025e2:	6812      	ldr	r2, [r2, #0]
 80025e4:	6812      	ldr	r2, [r2, #0]
 80025e6:	f022 0204 	bic.w	r2, r2, #4
 80025ea:	601a      	str	r2, [r3, #0]
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 80025ec:	687b      	ldr	r3, [r7, #4]
 80025ee:	681b      	ldr	r3, [r3, #0]
 80025f0:	687a      	ldr	r2, [r7, #4]
 80025f2:	6891      	ldr	r1, [r2, #8]
                ((uint32_t)hcan->Init.SJW) | \
 80025f4:	687a      	ldr	r2, [r7, #4]
 80025f6:	68d2      	ldr	r2, [r2, #12]
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 80025f8:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
 80025fa:	687a      	ldr	r2, [r7, #4]
 80025fc:	6912      	ldr	r2, [r2, #16]
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
 80025fe:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
 8002600:	687a      	ldr	r2, [r7, #4]
 8002602:	6952      	ldr	r2, [r2, #20]
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
 8002604:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.BS2) | \
               ((uint32_t)hcan->Init.Prescaler - 1);
 8002606:	687a      	ldr	r2, [r7, #4]
 8002608:	6852      	ldr	r2, [r2, #4]
 800260a:	3a01      	subs	r2, #1

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
 800260c:	430a      	orrs	r2, r1
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 800260e:	61da      	str	r2, [r3, #28]
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
               ((uint32_t)hcan->Init.Prescaler - 1);

    /* Request leave initialisation */
    hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 8002610:	687b      	ldr	r3, [r7, #4]
 8002612:	681b      	ldr	r3, [r3, #0]
 8002614:	687a      	ldr	r2, [r7, #4]
 8002616:	6812      	ldr	r2, [r2, #0]
 8002618:	6812      	ldr	r2, [r2, #0]
 800261a:	f022 0201 	bic.w	r2, r2, #1
 800261e:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8002620:	f7fe ffd0 	bl	80015c4 <HAL_GetTick>
 8002624:	60b8      	str	r0, [r7, #8]

   /* Wait the acknowledge */
   while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 8002626:	e010      	b.n	800264a <HAL_CAN_Init+0x202>
   {
    if((HAL_GetTick() - tickstart ) > CAN_TIMEOUT_VALUE)
 8002628:	f7fe ffcc 	bl	80015c4 <HAL_GetTick>
 800262c:	4602      	mov	r2, r0
 800262e:	68bb      	ldr	r3, [r7, #8]
 8002630:	1ad3      	subs	r3, r2, r3
 8002632:	2b0a      	cmp	r3, #10
 8002634:	d909      	bls.n	800264a <HAL_CAN_Init+0x202>
     {
       hcan->State= HAL_CAN_STATE_TIMEOUT;
 8002636:	687b      	ldr	r3, [r7, #4]
 8002638:	2203      	movs	r2, #3
 800263a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
       /* Process unlocked */
       __HAL_UNLOCK(hcan);
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	2200      	movs	r2, #0
 8002642:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
       return HAL_TIMEOUT;
 8002646:	2303      	movs	r3, #3
 8002648:	e023      	b.n	8002692 <HAL_CAN_Init+0x24a>

  /* Get tick */
  tickstart = HAL_GetTick();

   /* Wait the acknowledge */
   while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 800264a:	687b      	ldr	r3, [r7, #4]
 800264c:	681b      	ldr	r3, [r3, #0]
 800264e:	685b      	ldr	r3, [r3, #4]
 8002650:	f003 0301 	and.w	r3, r3, #1
 8002654:	2b00      	cmp	r3, #0
 8002656:	d1e7      	bne.n	8002628 <HAL_CAN_Init+0x1e0>
       return HAL_TIMEOUT;
     }
   }

    /* Check acknowledged */
    if ((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 8002658:	687b      	ldr	r3, [r7, #4]
 800265a:	681b      	ldr	r3, [r3, #0]
 800265c:	685b      	ldr	r3, [r3, #4]
 800265e:	f003 0301 	and.w	r3, r3, #1
 8002662:	2b00      	cmp	r3, #0
 8002664:	d002      	beq.n	800266c <HAL_CAN_Init+0x224>
    {
      InitStatus = CAN_INITSTATUS_FAILED;
 8002666:	2300      	movs	r3, #0
 8002668:	60fb      	str	r3, [r7, #12]
 800266a:	e001      	b.n	8002670 <HAL_CAN_Init+0x228>
    }
    else
    {
      InitStatus = CAN_INITSTATUS_SUCCESS;
 800266c:	2301      	movs	r3, #1
 800266e:	60fb      	str	r3, [r7, #12]
    }
  }
 
  if(InitStatus == CAN_INITSTATUS_SUCCESS)
 8002670:	68fb      	ldr	r3, [r7, #12]
 8002672:	2b01      	cmp	r3, #1
 8002674:	d108      	bne.n	8002688 <HAL_CAN_Init+0x240>
  {
    /* Set CAN error code to none */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8002676:	687b      	ldr	r3, [r7, #4]
 8002678:	2200      	movs	r2, #0
 800267a:	63da      	str	r2, [r3, #60]	; 0x3c
    
    /* Initialize the CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 800267c:	687b      	ldr	r3, [r7, #4]
 800267e:	2201      	movs	r2, #1
 8002680:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
    /* Return function status */
    return HAL_OK;
 8002684:	2300      	movs	r3, #0
 8002686:	e004      	b.n	8002692 <HAL_CAN_Init+0x24a>
  }
  else
  {
    /* Initialize the CAN state */
    hcan->State = HAL_CAN_STATE_ERROR;
 8002688:	687b      	ldr	r3, [r7, #4]
 800268a:	2204      	movs	r2, #4
 800268c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Return function status */
    return HAL_ERROR;
 8002690:	2301      	movs	r3, #1
  }
}
 8002692:	4618      	mov	r0, r3
 8002694:	3710      	adds	r7, #16
 8002696:	46bd      	mov	sp, r7
 8002698:	bd80      	pop	{r7, pc}
 800269a:	bf00      	nop

0800269c <HAL_CAN_ConfigFilter>:
  * @param  sFilterConfig: pointer to a CAN_FilterConfTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef* hcan, CAN_FilterConfTypeDef* sFilterConfig)
{
 800269c:	b480      	push	{r7}
 800269e:	b085      	sub	sp, #20
 80026a0:	af00      	add	r7, sp, #0
 80026a2:	6078      	str	r0, [r7, #4]
 80026a4:	6039      	str	r1, [r7, #0]
  uint32_t filternbrbitpos = 0;
 80026a6:	2300      	movs	r3, #0
 80026a8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));
  assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));
  assert_param(IS_FUNCTIONAL_STATE(sFilterConfig->FilterActivation));
  assert_param(IS_CAN_BANKNUMBER(sFilterConfig->BankNumber));
  
  filternbrbitpos = ((uint32_t)1) << sFilterConfig->FilterNumber;
 80026aa:	683b      	ldr	r3, [r7, #0]
 80026ac:	695b      	ldr	r3, [r3, #20]
 80026ae:	461a      	mov	r2, r3
 80026b0:	2301      	movs	r3, #1
 80026b2:	4093      	lsls	r3, r2
 80026b4:	60fb      	str	r3, [r7, #12]

  /* Initialisation mode for the filter */
  CAN1->FMR |= (uint32_t)CAN_FMR_FINIT;
 80026b6:	4a5e      	ldr	r2, [pc, #376]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80026b8:	4b5d      	ldr	r3, [pc, #372]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80026ba:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 80026be:	f043 0301 	orr.w	r3, r3, #1
 80026c2:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  
  /* Select the start slave bank */
  CAN1->FMR &= ~((uint32_t)CAN_FMR_CAN2SB);
 80026c6:	4a5a      	ldr	r2, [pc, #360]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80026c8:	4b59      	ldr	r3, [pc, #356]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80026ca:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 80026ce:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 80026d2:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  CAN1->FMR |= (uint32_t)(sFilterConfig->BankNumber << 8);
 80026d6:	4956      	ldr	r1, [pc, #344]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80026d8:	4b55      	ldr	r3, [pc, #340]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80026da:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 80026de:	683b      	ldr	r3, [r7, #0]
 80026e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80026e2:	021b      	lsls	r3, r3, #8
 80026e4:	4313      	orrs	r3, r2
 80026e6:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
     
  /* Filter Deactivation */
  CAN1->FA1R &= ~(uint32_t)filternbrbitpos;
 80026ea:	4951      	ldr	r1, [pc, #324]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80026ec:	4b50      	ldr	r3, [pc, #320]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80026ee:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 80026f2:	68fb      	ldr	r3, [r7, #12]
 80026f4:	43db      	mvns	r3, r3
 80026f6:	4013      	ands	r3, r2
 80026f8:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c

  /* Filter Scale */
  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 80026fc:	683b      	ldr	r3, [r7, #0]
 80026fe:	69db      	ldr	r3, [r3, #28]
 8002700:	2b00      	cmp	r3, #0
 8002702:	d123      	bne.n	800274c <HAL_CAN_ConfigFilter+0xb0>
  {
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;
 8002704:	494a      	ldr	r1, [pc, #296]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002706:	4b4a      	ldr	r3, [pc, #296]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002708:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 800270c:	68fb      	ldr	r3, [r7, #12]
 800270e:	43db      	mvns	r3, r3
 8002710:	4013      	ands	r3, r2
 8002712:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 8002716:	4846      	ldr	r0, [pc, #280]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002718:	683b      	ldr	r3, [r7, #0]
 800271a:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
 800271c:	683a      	ldr	r2, [r7, #0]
 800271e:	68d2      	ldr	r2, [r2, #12]
 8002720:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
 8002722:	683a      	ldr	r2, [r7, #0]
 8002724:	6852      	ldr	r2, [r2, #4]
 8002726:	b292      	uxth	r2, r2
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
 8002728:	430a      	orrs	r2, r1
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 800272a:	3348      	adds	r3, #72	; 0x48
 800272c:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8002730:	483f      	ldr	r0, [pc, #252]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002732:	683b      	ldr	r3, [r7, #0]
 8002734:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8002736:	683a      	ldr	r2, [r7, #0]
 8002738:	6892      	ldr	r2, [r2, #8]
 800273a:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
 800273c:	683a      	ldr	r2, [r7, #0]
 800273e:	6812      	ldr	r2, [r2, #0]
 8002740:	b292      	uxth	r2, r2
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8002742:	430a      	orrs	r2, r1
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8002744:	3348      	adds	r3, #72	; 0x48
 8002746:	00db      	lsls	r3, r3, #3
 8002748:	4403      	add	r3, r0
 800274a:	605a      	str	r2, [r3, #4]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
  }

  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 800274c:	683b      	ldr	r3, [r7, #0]
 800274e:	69db      	ldr	r3, [r3, #28]
 8002750:	2b01      	cmp	r3, #1
 8002752:	d122      	bne.n	800279a <HAL_CAN_ConfigFilter+0xfe>
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
 8002754:	4936      	ldr	r1, [pc, #216]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002756:	4b36      	ldr	r3, [pc, #216]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002758:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 800275c:	68fb      	ldr	r3, [r7, #12]
 800275e:	4313      	orrs	r3, r2
 8002760:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 8002764:	4832      	ldr	r0, [pc, #200]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002766:	683b      	ldr	r3, [r7, #0]
 8002768:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
 800276a:	683a      	ldr	r2, [r7, #0]
 800276c:	6812      	ldr	r2, [r2, #0]
 800276e:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
 8002770:	683a      	ldr	r2, [r7, #0]
 8002772:	6852      	ldr	r2, [r2, #4]
 8002774:	b292      	uxth	r2, r2
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
 8002776:	430a      	orrs	r2, r1
  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 8002778:	3348      	adds	r3, #72	; 0x48
 800277a:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 800277e:	482c      	ldr	r0, [pc, #176]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002780:	683b      	ldr	r3, [r7, #0]
 8002782:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8002784:	683a      	ldr	r2, [r7, #0]
 8002786:	6892      	ldr	r2, [r2, #8]
 8002788:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
 800278a:	683a      	ldr	r2, [r7, #0]
 800278c:	68d2      	ldr	r2, [r2, #12]
 800278e:	b292      	uxth	r2, r2
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8002790:	430a      	orrs	r2, r1
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8002792:	3348      	adds	r3, #72	; 0x48
 8002794:	00db      	lsls	r3, r3, #3
 8002796:	4403      	add	r3, r0
 8002798:	605a      	str	r2, [r3, #4]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
  }

  /* Filter Mode */
  if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 800279a:	683b      	ldr	r3, [r7, #0]
 800279c:	699b      	ldr	r3, [r3, #24]
 800279e:	2b00      	cmp	r3, #0
 80027a0:	d109      	bne.n	80027b6 <HAL_CAN_ConfigFilter+0x11a>
  {
    /*Id/Mask mode for the filter*/
    CAN1->FM1R &= ~(uint32_t)filternbrbitpos;
 80027a2:	4923      	ldr	r1, [pc, #140]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80027a4:	4b22      	ldr	r3, [pc, #136]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80027a6:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 80027aa:	68fb      	ldr	r3, [r7, #12]
 80027ac:	43db      	mvns	r3, r3
 80027ae:	4013      	ands	r3, r2
 80027b0:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
 80027b4:	e007      	b.n	80027c6 <HAL_CAN_ConfigFilter+0x12a>
  }
  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
  {
    /*Identifier list mode for the filter*/
    CAN1->FM1R |= (uint32_t)filternbrbitpos;
 80027b6:	491e      	ldr	r1, [pc, #120]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80027b8:	4b1d      	ldr	r3, [pc, #116]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80027ba:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 80027be:	68fb      	ldr	r3, [r7, #12]
 80027c0:	4313      	orrs	r3, r2
 80027c2:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
  }

  /* Filter FIFO assignment */
  if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 80027c6:	683b      	ldr	r3, [r7, #0]
 80027c8:	691b      	ldr	r3, [r3, #16]
 80027ca:	2b00      	cmp	r3, #0
 80027cc:	d108      	bne.n	80027e0 <HAL_CAN_ConfigFilter+0x144>
  {
    /* FIFO 0 assignation for the filter */
    CAN1->FFA1R &= ~(uint32_t)filternbrbitpos;
 80027ce:	4918      	ldr	r1, [pc, #96]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80027d0:	4b17      	ldr	r3, [pc, #92]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80027d2:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 80027d6:	68fb      	ldr	r3, [r7, #12]
 80027d8:	43db      	mvns	r3, r3
 80027da:	4013      	ands	r3, r2
 80027dc:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
  }

  if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO1)
 80027e0:	683b      	ldr	r3, [r7, #0]
 80027e2:	691b      	ldr	r3, [r3, #16]
 80027e4:	2b01      	cmp	r3, #1
 80027e6:	d107      	bne.n	80027f8 <HAL_CAN_ConfigFilter+0x15c>
  {
    /* FIFO 1 assignation for the filter */
    CAN1->FFA1R |= (uint32_t)filternbrbitpos;
 80027e8:	4911      	ldr	r1, [pc, #68]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80027ea:	4b11      	ldr	r3, [pc, #68]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 80027ec:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 80027f0:	68fb      	ldr	r3, [r7, #12]
 80027f2:	4313      	orrs	r3, r2
 80027f4:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
  }
  
  /* Filter activation */
  if (sFilterConfig->FilterActivation == ENABLE)
 80027f8:	683b      	ldr	r3, [r7, #0]
 80027fa:	6a1b      	ldr	r3, [r3, #32]
 80027fc:	2b01      	cmp	r3, #1
 80027fe:	d107      	bne.n	8002810 <HAL_CAN_ConfigFilter+0x174>
  {
    CAN1->FA1R |= filternbrbitpos;
 8002800:	490b      	ldr	r1, [pc, #44]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002802:	4b0b      	ldr	r3, [pc, #44]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002804:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8002808:	68fb      	ldr	r3, [r7, #12]
 800280a:	4313      	orrs	r3, r2
 800280c:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c
  }

  /* Leave the initialisation mode for the filter */
  CAN1->FMR &= ~((uint32_t)CAN_FMR_FINIT);
 8002810:	4a07      	ldr	r2, [pc, #28]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002812:	4b07      	ldr	r3, [pc, #28]	; (8002830 <HAL_CAN_ConfigFilter+0x194>)
 8002814:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8002818:	f023 0301 	bic.w	r3, r3, #1
 800281c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  
  /* Return function status */
  return HAL_OK;
 8002820:	2300      	movs	r3, #0
}
 8002822:	4618      	mov	r0, r3
 8002824:	3714      	adds	r7, #20
 8002826:	46bd      	mov	sp, r7
 8002828:	f85d 7b04 	ldr.w	r7, [sp], #4
 800282c:	4770      	bx	lr
 800282e:	bf00      	nop
 8002830:	40006400 	.word	0x40006400

08002834 <HAL_CAN_DeInit>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef* hcan)
{
 8002834:	b580      	push	{r7, lr}
 8002836:	b082      	sub	sp, #8
 8002838:	af00      	add	r7, sp, #0
 800283a:	6078      	str	r0, [r7, #4]
  /* Check CAN handle */
  if(hcan == NULL)
 800283c:	687b      	ldr	r3, [r7, #4]
 800283e:	2b00      	cmp	r3, #0
 8002840:	d101      	bne.n	8002846 <HAL_CAN_DeInit+0x12>
  {
     return HAL_ERROR;
 8002842:	2301      	movs	r3, #1
 8002844:	e00f      	b.n	8002866 <HAL_CAN_DeInit+0x32>
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_BUSY;
 8002846:	687b      	ldr	r3, [r7, #4]
 8002848:	2202      	movs	r2, #2
 800284a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  /* DeInit the low level hardware */
  HAL_CAN_MspDeInit(hcan);
 800284e:	6878      	ldr	r0, [r7, #4]
 8002850:	f000 f80e 	bl	8002870 <HAL_CAN_MspDeInit>
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_RESET;
 8002854:	687b      	ldr	r3, [r7, #4]
 8002856:	2200      	movs	r2, #0
 8002858:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Release Lock */
  __HAL_UNLOCK(hcan);
 800285c:	687b      	ldr	r3, [r7, #4]
 800285e:	2200      	movs	r2, #0
 8002860:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Return function status */
  return HAL_OK;
 8002864:	2300      	movs	r3, #0
}
 8002866:	4618      	mov	r0, r3
 8002868:	3708      	adds	r7, #8
 800286a:	46bd      	mov	sp, r7
 800286c:	bd80      	pop	{r7, pc}
 800286e:	bf00      	nop

08002870 <HAL_CAN_MspDeInit>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval None
  */
__weak void HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan)
{
 8002870:	b480      	push	{r7}
 8002872:	b083      	sub	sp, #12
 8002874:	af00      	add	r7, sp, #0
 8002876:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_MspDeInit could be implemented in the user file
   */ 
}
 8002878:	370c      	adds	r7, #12
 800287a:	46bd      	mov	sp, r7
 800287c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002880:	4770      	bx	lr
 8002882:	bf00      	nop

08002884 <HAL_CAN_Transmit>:
  *         the configuration information for the specified CAN.  
  * @param  Timeout: Specify Timeout value   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Transmit(CAN_HandleTypeDef* hcan, uint32_t Timeout)
{
 8002884:	b580      	push	{r7, lr}
 8002886:	b084      	sub	sp, #16
 8002888:	af00      	add	r7, sp, #0
 800288a:	6078      	str	r0, [r7, #4]
 800288c:	6039      	str	r1, [r7, #0]
  uint32_t  transmitmailbox = 5;
 800288e:	2305      	movs	r3, #5
 8002890:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart = 0;
 8002892:	2300      	movs	r3, #0
 8002894:	60bb      	str	r3, [r7, #8]
  assert_param(IS_CAN_IDTYPE(hcan->pTxMsg->IDE));
  assert_param(IS_CAN_RTR(hcan->pTxMsg->RTR));
  assert_param(IS_CAN_DLC(hcan->pTxMsg->DLC));
  
  /* Process locked */
  __HAL_LOCK(hcan);
 8002896:	687b      	ldr	r3, [r7, #4]
 8002898:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800289c:	2b01      	cmp	r3, #1
 800289e:	d101      	bne.n	80028a4 <HAL_CAN_Transmit+0x20>
 80028a0:	2302      	movs	r3, #2
 80028a2:	e156      	b.n	8002b52 <HAL_CAN_Transmit+0x2ce>
 80028a4:	687b      	ldr	r3, [r7, #4]
 80028a6:	2201      	movs	r2, #1
 80028a8:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  if(hcan->State == HAL_CAN_STATE_BUSY_RX) 
 80028ac:	687b      	ldr	r3, [r7, #4]
 80028ae:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80028b2:	b2db      	uxtb	r3, r3
 80028b4:	2b22      	cmp	r3, #34	; 0x22
 80028b6:	d104      	bne.n	80028c2 <HAL_CAN_Transmit+0x3e>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
 80028b8:	687b      	ldr	r3, [r7, #4]
 80028ba:	2232      	movs	r2, #50	; 0x32
 80028bc:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 80028c0:	e003      	b.n	80028ca <HAL_CAN_Transmit+0x46>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 80028c2:	687b      	ldr	r3, [r7, #4]
 80028c4:	2212      	movs	r2, #18
 80028c6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
  
  /* Select one empty transmit mailbox */
  if ((hcan->Instance->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 80028ca:	687b      	ldr	r3, [r7, #4]
 80028cc:	681b      	ldr	r3, [r3, #0]
 80028ce:	689b      	ldr	r3, [r3, #8]
 80028d0:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80028d4:	2b00      	cmp	r3, #0
 80028d6:	d002      	beq.n	80028de <HAL_CAN_Transmit+0x5a>
  {
    transmitmailbox = 0;
 80028d8:	2300      	movs	r3, #0
 80028da:	60fb      	str	r3, [r7, #12]
 80028dc:	e015      	b.n	800290a <HAL_CAN_Transmit+0x86>
  }
  else if ((hcan->Instance->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
 80028de:	687b      	ldr	r3, [r7, #4]
 80028e0:	681b      	ldr	r3, [r3, #0]
 80028e2:	689b      	ldr	r3, [r3, #8]
 80028e4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80028e8:	2b00      	cmp	r3, #0
 80028ea:	d002      	beq.n	80028f2 <HAL_CAN_Transmit+0x6e>
  {
    transmitmailbox = 1;
 80028ec:	2301      	movs	r3, #1
 80028ee:	60fb      	str	r3, [r7, #12]
 80028f0:	e00b      	b.n	800290a <HAL_CAN_Transmit+0x86>
  }
  else if ((hcan->Instance->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
 80028f2:	687b      	ldr	r3, [r7, #4]
 80028f4:	681b      	ldr	r3, [r3, #0]
 80028f6:	689b      	ldr	r3, [r3, #8]
 80028f8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80028fc:	2b00      	cmp	r3, #0
 80028fe:	d002      	beq.n	8002906 <HAL_CAN_Transmit+0x82>
  {
    transmitmailbox = 2;
 8002900:	2302      	movs	r3, #2
 8002902:	60fb      	str	r3, [r7, #12]
 8002904:	e001      	b.n	800290a <HAL_CAN_Transmit+0x86>
  }
  else
  {
    transmitmailbox = CAN_TXSTATUS_NOMAILBOX;
 8002906:	2304      	movs	r3, #4
 8002908:	60fb      	str	r3, [r7, #12]
  }

  if (transmitmailbox != CAN_TXSTATUS_NOMAILBOX)
 800290a:	68fb      	ldr	r3, [r7, #12]
 800290c:	2b04      	cmp	r3, #4
 800290e:	f000 8117 	beq.w	8002b40 <HAL_CAN_Transmit+0x2bc>
  {
    /* Set up the Id */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR &= CAN_TI0R_TXRQ;
 8002912:	687b      	ldr	r3, [r7, #4]
 8002914:	6819      	ldr	r1, [r3, #0]
 8002916:	687b      	ldr	r3, [r7, #4]
 8002918:	681a      	ldr	r2, [r3, #0]
 800291a:	68fb      	ldr	r3, [r7, #12]
 800291c:	3318      	adds	r3, #24
 800291e:	011b      	lsls	r3, r3, #4
 8002920:	4413      	add	r3, r2
 8002922:	681b      	ldr	r3, [r3, #0]
 8002924:	f003 0201 	and.w	r2, r3, #1
 8002928:	68fb      	ldr	r3, [r7, #12]
 800292a:	3318      	adds	r3, #24
 800292c:	011b      	lsls	r3, r3, #4
 800292e:	440b      	add	r3, r1
 8002930:	601a      	str	r2, [r3, #0]
    if (hcan->pTxMsg->IDE == CAN_ID_STD)
 8002932:	687b      	ldr	r3, [r7, #4]
 8002934:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002936:	689b      	ldr	r3, [r3, #8]
 8002938:	2b00      	cmp	r3, #0
 800293a:	d117      	bne.n	800296c <HAL_CAN_Transmit+0xe8>
    {
      assert_param(IS_CAN_STDID(hcan->pTxMsg->StdId));  
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->StdId << 21) | \
 800293c:	687b      	ldr	r3, [r7, #4]
 800293e:	6819      	ldr	r1, [r3, #0]
 8002940:	687b      	ldr	r3, [r7, #4]
 8002942:	681a      	ldr	r2, [r3, #0]
 8002944:	68fb      	ldr	r3, [r7, #12]
 8002946:	3318      	adds	r3, #24
 8002948:	011b      	lsls	r3, r3, #4
 800294a:	4413      	add	r3, r2
 800294c:	681a      	ldr	r2, [r3, #0]
 800294e:	687b      	ldr	r3, [r7, #4]
 8002950:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002952:	681b      	ldr	r3, [r3, #0]
 8002954:	0558      	lsls	r0, r3, #21
                                                  hcan->pTxMsg->RTR);
 8002956:	687b      	ldr	r3, [r7, #4]
 8002958:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800295a:	68db      	ldr	r3, [r3, #12]
    /* Set up the Id */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR &= CAN_TI0R_TXRQ;
    if (hcan->pTxMsg->IDE == CAN_ID_STD)
    {
      assert_param(IS_CAN_STDID(hcan->pTxMsg->StdId));  
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->StdId << 21) | \
 800295c:	4303      	orrs	r3, r0
 800295e:	431a      	orrs	r2, r3
 8002960:	68fb      	ldr	r3, [r7, #12]
 8002962:	3318      	adds	r3, #24
 8002964:	011b      	lsls	r3, r3, #4
 8002966:	440b      	add	r3, r1
 8002968:	601a      	str	r2, [r3, #0]
 800296a:	e01a      	b.n	80029a2 <HAL_CAN_Transmit+0x11e>
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 800296c:	687b      	ldr	r3, [r7, #4]
 800296e:	6819      	ldr	r1, [r3, #0]
 8002970:	687b      	ldr	r3, [r7, #4]
 8002972:	681a      	ldr	r2, [r3, #0]
 8002974:	68fb      	ldr	r3, [r7, #12]
 8002976:	3318      	adds	r3, #24
 8002978:	011b      	lsls	r3, r3, #4
 800297a:	4413      	add	r3, r2
 800297c:	681a      	ldr	r2, [r3, #0]
 800297e:	687b      	ldr	r3, [r7, #4]
 8002980:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002982:	685b      	ldr	r3, [r3, #4]
 8002984:	00d8      	lsls	r0, r3, #3
                                                  hcan->pTxMsg->IDE | \
 8002986:	687b      	ldr	r3, [r7, #4]
 8002988:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800298a:	689b      	ldr	r3, [r3, #8]
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 800298c:	4318      	orrs	r0, r3
                                                  hcan->pTxMsg->IDE | \
                                                  hcan->pTxMsg->RTR);
 800298e:	687b      	ldr	r3, [r7, #4]
 8002990:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002992:	68db      	ldr	r3, [r3, #12]
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
                                                  hcan->pTxMsg->IDE | \
 8002994:	4303      	orrs	r3, r0
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 8002996:	431a      	orrs	r2, r3
 8002998:	68fb      	ldr	r3, [r7, #12]
 800299a:	3318      	adds	r3, #24
 800299c:	011b      	lsls	r3, r3, #4
 800299e:	440b      	add	r3, r1
 80029a0:	601a      	str	r2, [r3, #0]
                                                  hcan->pTxMsg->IDE | \
                                                  hcan->pTxMsg->RTR);
    }
    
    /* Set up the DLC */
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
 80029a2:	687b      	ldr	r3, [r7, #4]
 80029a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80029a6:	687a      	ldr	r2, [r7, #4]
 80029a8:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80029aa:	6912      	ldr	r2, [r2, #16]
 80029ac:	f002 020f 	and.w	r2, r2, #15
 80029b0:	611a      	str	r2, [r3, #16]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 80029b2:	687b      	ldr	r3, [r7, #4]
 80029b4:	6819      	ldr	r1, [r3, #0]
 80029b6:	687b      	ldr	r3, [r7, #4]
 80029b8:	681a      	ldr	r2, [r3, #0]
 80029ba:	68fb      	ldr	r3, [r7, #12]
 80029bc:	3318      	adds	r3, #24
 80029be:	011b      	lsls	r3, r3, #4
 80029c0:	4413      	add	r3, r2
 80029c2:	685b      	ldr	r3, [r3, #4]
 80029c4:	f023 020f 	bic.w	r2, r3, #15
 80029c8:	68fb      	ldr	r3, [r7, #12]
 80029ca:	3318      	adds	r3, #24
 80029cc:	011b      	lsls	r3, r3, #4
 80029ce:	440b      	add	r3, r1
 80029d0:	605a      	str	r2, [r3, #4]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;
 80029d2:	687b      	ldr	r3, [r7, #4]
 80029d4:	6819      	ldr	r1, [r3, #0]
 80029d6:	687b      	ldr	r3, [r7, #4]
 80029d8:	681a      	ldr	r2, [r3, #0]
 80029da:	68fb      	ldr	r3, [r7, #12]
 80029dc:	3318      	adds	r3, #24
 80029de:	011b      	lsls	r3, r3, #4
 80029e0:	4413      	add	r3, r2
 80029e2:	685a      	ldr	r2, [r3, #4]
 80029e4:	687b      	ldr	r3, [r7, #4]
 80029e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80029e8:	691b      	ldr	r3, [r3, #16]
 80029ea:	431a      	orrs	r2, r3
 80029ec:	68fb      	ldr	r3, [r7, #12]
 80029ee:	3318      	adds	r3, #24
 80029f0:	011b      	lsls	r3, r3, #4
 80029f2:	440b      	add	r3, r1
 80029f4:	605a      	str	r2, [r3, #4]

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 80029f6:	687b      	ldr	r3, [r7, #4]
 80029f8:	6819      	ldr	r1, [r3, #0]
 80029fa:	687b      	ldr	r3, [r7, #4]
 80029fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80029fe:	7ddb      	ldrb	r3, [r3, #23]
 8002a00:	061a      	lsls	r2, r3, #24
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
 8002a02:	687b      	ldr	r3, [r7, #4]
 8002a04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002a06:	7d9b      	ldrb	r3, [r3, #22]
 8002a08:	041b      	lsls	r3, r3, #16
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 8002a0a:	431a      	orrs	r2, r3
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
 8002a0c:	687b      	ldr	r3, [r7, #4]
 8002a0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002a10:	7d5b      	ldrb	r3, [r3, #21]
 8002a12:	021b      	lsls	r3, r3, #8
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
 8002a14:	4313      	orrs	r3, r2
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
 8002a16:	687a      	ldr	r2, [r7, #4]
 8002a18:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002a1a:	7d12      	ldrb	r2, [r2, #20]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
 8002a1c:	431a      	orrs	r2, r3
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 8002a1e:	68fb      	ldr	r3, [r7, #12]
 8002a20:	011b      	lsls	r3, r3, #4
 8002a22:	440b      	add	r3, r1
 8002a24:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8002a28:	601a      	str	r2, [r3, #0]
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 8002a2a:	687b      	ldr	r3, [r7, #4]
 8002a2c:	6819      	ldr	r1, [r3, #0]
 8002a2e:	687b      	ldr	r3, [r7, #4]
 8002a30:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002a32:	7edb      	ldrb	r3, [r3, #27]
 8002a34:	061a      	lsls	r2, r3, #24
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
 8002a36:	687b      	ldr	r3, [r7, #4]
 8002a38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002a3a:	7e9b      	ldrb	r3, [r3, #26]
 8002a3c:	041b      	lsls	r3, r3, #16
    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 8002a3e:	431a      	orrs	r2, r3
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
 8002a40:	687b      	ldr	r3, [r7, #4]
 8002a42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002a44:	7e5b      	ldrb	r3, [r3, #25]
 8002a46:	021b      	lsls	r3, r3, #8
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
 8002a48:	4313      	orrs	r3, r2
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
                                             ((uint32_t)hcan->pTxMsg->Data[4]));
 8002a4a:	687a      	ldr	r2, [r7, #4]
 8002a4c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002a4e:	7e12      	ldrb	r2, [r2, #24]
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
 8002a50:	431a      	orrs	r2, r3
    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 8002a52:	68fb      	ldr	r3, [r7, #12]
 8002a54:	011b      	lsls	r3, r3, #4
 8002a56:	440b      	add	r3, r1
 8002a58:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8002a5c:	605a      	str	r2, [r3, #4]
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
                                             ((uint32_t)hcan->pTxMsg->Data[4]));
    /* Request transmission */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR |= CAN_TI0R_TXRQ;
 8002a5e:	687b      	ldr	r3, [r7, #4]
 8002a60:	6819      	ldr	r1, [r3, #0]
 8002a62:	687b      	ldr	r3, [r7, #4]
 8002a64:	681a      	ldr	r2, [r3, #0]
 8002a66:	68fb      	ldr	r3, [r7, #12]
 8002a68:	3318      	adds	r3, #24
 8002a6a:	011b      	lsls	r3, r3, #4
 8002a6c:	4413      	add	r3, r2
 8002a6e:	681b      	ldr	r3, [r3, #0]
 8002a70:	f043 0201 	orr.w	r2, r3, #1
 8002a74:	68fb      	ldr	r3, [r7, #12]
 8002a76:	3318      	adds	r3, #24
 8002a78:	011b      	lsls	r3, r3, #4
 8002a7a:	440b      	add	r3, r1
 8002a7c:	601a      	str	r2, [r3, #0]
  
  /* Get tick */ 
  tickstart = HAL_GetTick();
 8002a7e:	f7fe fda1 	bl	80015c4 <HAL_GetTick>
 8002a82:	60b8      	str	r0, [r7, #8]
  
    /* Check End of transmission flag */
    while(!(__HAL_CAN_TRANSMIT_STATUS(hcan, transmitmailbox)))
 8002a84:	e018      	b.n	8002ab8 <HAL_CAN_Transmit+0x234>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 8002a86:	683b      	ldr	r3, [r7, #0]
 8002a88:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002a8c:	d014      	beq.n	8002ab8 <HAL_CAN_Transmit+0x234>
      {
       if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002a8e:	683b      	ldr	r3, [r7, #0]
 8002a90:	2b00      	cmp	r3, #0
 8002a92:	d007      	beq.n	8002aa4 <HAL_CAN_Transmit+0x220>
 8002a94:	f7fe fd96 	bl	80015c4 <HAL_GetTick>
 8002a98:	4602      	mov	r2, r0
 8002a9a:	68bb      	ldr	r3, [r7, #8]
 8002a9c:	1ad2      	subs	r2, r2, r3
 8002a9e:	683b      	ldr	r3, [r7, #0]
 8002aa0:	429a      	cmp	r2, r3
 8002aa2:	d909      	bls.n	8002ab8 <HAL_CAN_Transmit+0x234>
       {
         hcan->State = HAL_CAN_STATE_TIMEOUT;
 8002aa4:	687b      	ldr	r3, [r7, #4]
 8002aa6:	2203      	movs	r2, #3
 8002aa8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
         /* Process unlocked */
         __HAL_UNLOCK(hcan);
 8002aac:	687b      	ldr	r3, [r7, #4]
 8002aae:	2200      	movs	r2, #0
 8002ab0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
         return HAL_TIMEOUT;
 8002ab4:	2303      	movs	r3, #3
 8002ab6:	e04c      	b.n	8002b52 <HAL_CAN_Transmit+0x2ce>
  
  /* Get tick */ 
  tickstart = HAL_GetTick();
  
    /* Check End of transmission flag */
    while(!(__HAL_CAN_TRANSMIT_STATUS(hcan, transmitmailbox)))
 8002ab8:	68fb      	ldr	r3, [r7, #12]
 8002aba:	2b00      	cmp	r3, #0
 8002abc:	d10b      	bne.n	8002ad6 <HAL_CAN_Transmit+0x252>
 8002abe:	687b      	ldr	r3, [r7, #4]
 8002ac0:	681b      	ldr	r3, [r3, #0]
 8002ac2:	689a      	ldr	r2, [r3, #8]
 8002ac4:	4b25      	ldr	r3, [pc, #148]	; (8002b5c <HAL_CAN_Transmit+0x2d8>)
 8002ac6:	4013      	ands	r3, r2
 8002ac8:	4a24      	ldr	r2, [pc, #144]	; (8002b5c <HAL_CAN_Transmit+0x2d8>)
 8002aca:	4293      	cmp	r3, r2
 8002acc:	bf14      	ite	ne
 8002ace:	2301      	movne	r3, #1
 8002ad0:	2300      	moveq	r3, #0
 8002ad2:	b2db      	uxtb	r3, r3
 8002ad4:	e019      	b.n	8002b0a <HAL_CAN_Transmit+0x286>
 8002ad6:	68fb      	ldr	r3, [r7, #12]
 8002ad8:	2b01      	cmp	r3, #1
 8002ada:	d10b      	bne.n	8002af4 <HAL_CAN_Transmit+0x270>
 8002adc:	687b      	ldr	r3, [r7, #4]
 8002ade:	681b      	ldr	r3, [r3, #0]
 8002ae0:	689a      	ldr	r2, [r3, #8]
 8002ae2:	4b1f      	ldr	r3, [pc, #124]	; (8002b60 <HAL_CAN_Transmit+0x2dc>)
 8002ae4:	4013      	ands	r3, r2
 8002ae6:	4a1e      	ldr	r2, [pc, #120]	; (8002b60 <HAL_CAN_Transmit+0x2dc>)
 8002ae8:	4293      	cmp	r3, r2
 8002aea:	bf14      	ite	ne
 8002aec:	2301      	movne	r3, #1
 8002aee:	2300      	moveq	r3, #0
 8002af0:	b2db      	uxtb	r3, r3
 8002af2:	e00a      	b.n	8002b0a <HAL_CAN_Transmit+0x286>
 8002af4:	687b      	ldr	r3, [r7, #4]
 8002af6:	681b      	ldr	r3, [r3, #0]
 8002af8:	689a      	ldr	r2, [r3, #8]
 8002afa:	4b1a      	ldr	r3, [pc, #104]	; (8002b64 <HAL_CAN_Transmit+0x2e0>)
 8002afc:	4013      	ands	r3, r2
 8002afe:	4a19      	ldr	r2, [pc, #100]	; (8002b64 <HAL_CAN_Transmit+0x2e0>)
 8002b00:	4293      	cmp	r3, r2
 8002b02:	bf14      	ite	ne
 8002b04:	2301      	movne	r3, #1
 8002b06:	2300      	moveq	r3, #0
 8002b08:	b2db      	uxtb	r3, r3
 8002b0a:	2b00      	cmp	r3, #0
 8002b0c:	d1bb      	bne.n	8002a86 <HAL_CAN_Transmit+0x202>
         __HAL_UNLOCK(hcan);
         return HAL_TIMEOUT;
        }
      }
    }
    if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 8002b0e:	687b      	ldr	r3, [r7, #4]
 8002b10:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8002b14:	b2db      	uxtb	r3, r3
 8002b16:	2b32      	cmp	r3, #50	; 0x32
 8002b18:	d108      	bne.n	8002b2c <HAL_CAN_Transmit+0x2a8>
    {
      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_BUSY_RX;
 8002b1a:	687b      	ldr	r3, [r7, #4]
 8002b1c:	2222      	movs	r2, #34	; 0x22
 8002b1e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 8002b22:	687b      	ldr	r3, [r7, #4]
 8002b24:	2200      	movs	r2, #0
 8002b26:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 8002b2a:	e007      	b.n	8002b3c <HAL_CAN_Transmit+0x2b8>
    }
    else
    {
      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_READY;
 8002b2c:	687b      	ldr	r3, [r7, #4]
 8002b2e:	2201      	movs	r2, #1
 8002b30:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 8002b34:	687b      	ldr	r3, [r7, #4]
 8002b36:	2200      	movs	r2, #0
 8002b38:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    }
    
    /* Return function status */
    return HAL_OK;
 8002b3c:	2300      	movs	r3, #0
 8002b3e:	e008      	b.n	8002b52 <HAL_CAN_Transmit+0x2ce>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_ERROR;
 8002b40:	687b      	ldr	r3, [r7, #4]
 8002b42:	2204      	movs	r2, #4
 8002b44:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8002b48:	687b      	ldr	r3, [r7, #4]
 8002b4a:	2200      	movs	r2, #0
 8002b4c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    /* Return function status */
    return HAL_ERROR;
 8002b50:	2301      	movs	r3, #1
  }
}
 8002b52:	4618      	mov	r0, r3
 8002b54:	3710      	adds	r7, #16
 8002b56:	46bd      	mov	sp, r7
 8002b58:	bd80      	pop	{r7, pc}
 8002b5a:	bf00      	nop
 8002b5c:	04000003 	.word	0x04000003
 8002b60:	08000300 	.word	0x08000300
 8002b64:	10030000 	.word	0x10030000

08002b68 <HAL_CAN_Receive>:
  * @param  FIFONumber: FIFO Number value
  * @param  Timeout: Specify Timeout value 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Receive(CAN_HandleTypeDef* hcan, uint8_t FIFONumber, uint32_t Timeout)
{
 8002b68:	b580      	push	{r7, lr}
 8002b6a:	b086      	sub	sp, #24
 8002b6c:	af00      	add	r7, sp, #0
 8002b6e:	60f8      	str	r0, [r7, #12]
 8002b70:	460b      	mov	r3, r1
 8002b72:	607a      	str	r2, [r7, #4]
 8002b74:	72fb      	strb	r3, [r7, #11]
  uint32_t tickstart = 0;
 8002b76:	2300      	movs	r3, #0
 8002b78:	617b      	str	r3, [r7, #20]
   
  /* Check the parameters */
  assert_param(IS_CAN_FIFO(FIFONumber));
  
  /* Process locked */
  __HAL_LOCK(hcan);
 8002b7a:	68fb      	ldr	r3, [r7, #12]
 8002b7c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8002b80:	2b01      	cmp	r3, #1
 8002b82:	d101      	bne.n	8002b88 <HAL_CAN_Receive+0x20>
 8002b84:	2302      	movs	r3, #2
 8002b86:	e129      	b.n	8002ddc <HAL_CAN_Receive+0x274>
 8002b88:	68fb      	ldr	r3, [r7, #12]
 8002b8a:	2201      	movs	r2, #1
 8002b8c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX) 
 8002b90:	68fb      	ldr	r3, [r7, #12]
 8002b92:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8002b96:	b2db      	uxtb	r3, r3
 8002b98:	2b12      	cmp	r3, #18
 8002b9a:	d104      	bne.n	8002ba6 <HAL_CAN_Receive+0x3e>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
 8002b9c:	68fb      	ldr	r3, [r7, #12]
 8002b9e:	2232      	movs	r2, #50	; 0x32
 8002ba0:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8002ba4:	e003      	b.n	8002bae <HAL_CAN_Receive+0x46>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_RX;
 8002ba6:	68fb      	ldr	r3, [r7, #12]
 8002ba8:	2222      	movs	r2, #34	; 0x22
 8002baa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
    
  /* Get tick */ 
  tickstart = HAL_GetTick();
 8002bae:	f7fe fd09 	bl	80015c4 <HAL_GetTick>
 8002bb2:	6178      	str	r0, [r7, #20]
  
  /* Check pending message */
  while(__HAL_CAN_MSG_PENDING(hcan, FIFONumber) == 0)
 8002bb4:	e018      	b.n	8002be8 <HAL_CAN_Receive+0x80>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8002bb6:	687b      	ldr	r3, [r7, #4]
 8002bb8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002bbc:	d014      	beq.n	8002be8 <HAL_CAN_Receive+0x80>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002bbe:	687b      	ldr	r3, [r7, #4]
 8002bc0:	2b00      	cmp	r3, #0
 8002bc2:	d007      	beq.n	8002bd4 <HAL_CAN_Receive+0x6c>
 8002bc4:	f7fe fcfe 	bl	80015c4 <HAL_GetTick>
 8002bc8:	4602      	mov	r2, r0
 8002bca:	697b      	ldr	r3, [r7, #20]
 8002bcc:	1ad2      	subs	r2, r2, r3
 8002bce:	687b      	ldr	r3, [r7, #4]
 8002bd0:	429a      	cmp	r2, r3
 8002bd2:	d909      	bls.n	8002be8 <HAL_CAN_Receive+0x80>
      {
        hcan->State = HAL_CAN_STATE_TIMEOUT;
 8002bd4:	68fb      	ldr	r3, [r7, #12]
 8002bd6:	2203      	movs	r2, #3
 8002bd8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
        /* Process unlocked */
        __HAL_UNLOCK(hcan);
 8002bdc:	68fb      	ldr	r3, [r7, #12]
 8002bde:	2200      	movs	r2, #0
 8002be0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
        return HAL_TIMEOUT;
 8002be4:	2303      	movs	r3, #3
 8002be6:	e0f9      	b.n	8002ddc <HAL_CAN_Receive+0x274>
    
  /* Get tick */ 
  tickstart = HAL_GetTick();
  
  /* Check pending message */
  while(__HAL_CAN_MSG_PENDING(hcan, FIFONumber) == 0)
 8002be8:	7afb      	ldrb	r3, [r7, #11]
 8002bea:	2b00      	cmp	r3, #0
 8002bec:	d10b      	bne.n	8002c06 <HAL_CAN_Receive+0x9e>
 8002bee:	68fb      	ldr	r3, [r7, #12]
 8002bf0:	681b      	ldr	r3, [r3, #0]
 8002bf2:	68db      	ldr	r3, [r3, #12]
 8002bf4:	b2db      	uxtb	r3, r3
 8002bf6:	f003 0303 	and.w	r3, r3, #3
 8002bfa:	2b00      	cmp	r3, #0
 8002bfc:	bf0c      	ite	eq
 8002bfe:	2301      	moveq	r3, #1
 8002c00:	2300      	movne	r3, #0
 8002c02:	b2db      	uxtb	r3, r3
 8002c04:	e00a      	b.n	8002c1c <HAL_CAN_Receive+0xb4>
 8002c06:	68fb      	ldr	r3, [r7, #12]
 8002c08:	681b      	ldr	r3, [r3, #0]
 8002c0a:	691b      	ldr	r3, [r3, #16]
 8002c0c:	b2db      	uxtb	r3, r3
 8002c0e:	f003 0303 	and.w	r3, r3, #3
 8002c12:	2b00      	cmp	r3, #0
 8002c14:	bf0c      	ite	eq
 8002c16:	2301      	moveq	r3, #1
 8002c18:	2300      	movne	r3, #0
 8002c1a:	b2db      	uxtb	r3, r3
 8002c1c:	2b00      	cmp	r3, #0
 8002c1e:	d1ca      	bne.n	8002bb6 <HAL_CAN_Receive+0x4e>
      }
    }
  }
  
  /* Get the Id */
  hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 8002c20:	68fb      	ldr	r3, [r7, #12]
 8002c22:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c24:	68fa      	ldr	r2, [r7, #12]
 8002c26:	6811      	ldr	r1, [r2, #0]
 8002c28:	7afa      	ldrb	r2, [r7, #11]
 8002c2a:	321b      	adds	r2, #27
 8002c2c:	0112      	lsls	r2, r2, #4
 8002c2e:	440a      	add	r2, r1
 8002c30:	6812      	ldr	r2, [r2, #0]
 8002c32:	f002 0204 	and.w	r2, r2, #4
 8002c36:	609a      	str	r2, [r3, #8]
  if (hcan->pRxMsg->IDE == CAN_ID_STD)
 8002c38:	68fb      	ldr	r3, [r7, #12]
 8002c3a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c3c:	689b      	ldr	r3, [r3, #8]
 8002c3e:	2b00      	cmp	r3, #0
 8002c40:	d10b      	bne.n	8002c5a <HAL_CAN_Receive+0xf2>
  {
    hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
 8002c42:	68fb      	ldr	r3, [r7, #12]
 8002c44:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c46:	68fa      	ldr	r2, [r7, #12]
 8002c48:	6811      	ldr	r1, [r2, #0]
 8002c4a:	7afa      	ldrb	r2, [r7, #11]
 8002c4c:	321b      	adds	r2, #27
 8002c4e:	0112      	lsls	r2, r2, #4
 8002c50:	440a      	add	r2, r1
 8002c52:	6812      	ldr	r2, [r2, #0]
 8002c54:	0d52      	lsrs	r2, r2, #21
 8002c56:	601a      	str	r2, [r3, #0]
 8002c58:	e00a      	b.n	8002c70 <HAL_CAN_Receive+0x108>
  }
  else
  {
    hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
 8002c5a:	68fb      	ldr	r3, [r7, #12]
 8002c5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c5e:	68fa      	ldr	r2, [r7, #12]
 8002c60:	6811      	ldr	r1, [r2, #0]
 8002c62:	7afa      	ldrb	r2, [r7, #11]
 8002c64:	321b      	adds	r2, #27
 8002c66:	0112      	lsls	r2, r2, #4
 8002c68:	440a      	add	r2, r1
 8002c6a:	6812      	ldr	r2, [r2, #0]
 8002c6c:	08d2      	lsrs	r2, r2, #3
 8002c6e:	605a      	str	r2, [r3, #4]
  }
  
  hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 8002c70:	68fb      	ldr	r3, [r7, #12]
 8002c72:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c74:	68fa      	ldr	r2, [r7, #12]
 8002c76:	6811      	ldr	r1, [r2, #0]
 8002c78:	7afa      	ldrb	r2, [r7, #11]
 8002c7a:	321b      	adds	r2, #27
 8002c7c:	0112      	lsls	r2, r2, #4
 8002c7e:	440a      	add	r2, r1
 8002c80:	6812      	ldr	r2, [r2, #0]
 8002c82:	f002 0202 	and.w	r2, r2, #2
 8002c86:	60da      	str	r2, [r3, #12]
  /* Get the DLC */
  hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
 8002c88:	68fb      	ldr	r3, [r7, #12]
 8002c8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c8c:	68fa      	ldr	r2, [r7, #12]
 8002c8e:	6811      	ldr	r1, [r2, #0]
 8002c90:	7afa      	ldrb	r2, [r7, #11]
 8002c92:	321b      	adds	r2, #27
 8002c94:	0112      	lsls	r2, r2, #4
 8002c96:	440a      	add	r2, r1
 8002c98:	6852      	ldr	r2, [r2, #4]
 8002c9a:	f002 020f 	and.w	r2, r2, #15
 8002c9e:	611a      	str	r2, [r3, #16]
  /* Get the FMI */
  hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
 8002ca0:	68fb      	ldr	r3, [r7, #12]
 8002ca2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002ca4:	68fa      	ldr	r2, [r7, #12]
 8002ca6:	6811      	ldr	r1, [r2, #0]
 8002ca8:	7afa      	ldrb	r2, [r7, #11]
 8002caa:	321b      	adds	r2, #27
 8002cac:	0112      	lsls	r2, r2, #4
 8002cae:	440a      	add	r2, r1
 8002cb0:	6852      	ldr	r2, [r2, #4]
 8002cb2:	0a12      	lsrs	r2, r2, #8
 8002cb4:	b2d2      	uxtb	r2, r2
 8002cb6:	61da      	str	r2, [r3, #28]
  /* Get the data field */
  hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
 8002cb8:	68fb      	ldr	r3, [r7, #12]
 8002cba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002cbc:	68fa      	ldr	r2, [r7, #12]
 8002cbe:	6811      	ldr	r1, [r2, #0]
 8002cc0:	7afa      	ldrb	r2, [r7, #11]
 8002cc2:	0112      	lsls	r2, r2, #4
 8002cc4:	440a      	add	r2, r1
 8002cc6:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8002cca:	6812      	ldr	r2, [r2, #0]
 8002ccc:	b2d2      	uxtb	r2, r2
 8002cce:	751a      	strb	r2, [r3, #20]
  hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
 8002cd0:	68fb      	ldr	r3, [r7, #12]
 8002cd2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002cd4:	68fa      	ldr	r2, [r7, #12]
 8002cd6:	6811      	ldr	r1, [r2, #0]
 8002cd8:	7afa      	ldrb	r2, [r7, #11]
 8002cda:	0112      	lsls	r2, r2, #4
 8002cdc:	440a      	add	r2, r1
 8002cde:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8002ce2:	6812      	ldr	r2, [r2, #0]
 8002ce4:	0a12      	lsrs	r2, r2, #8
 8002ce6:	b2d2      	uxtb	r2, r2
 8002ce8:	755a      	strb	r2, [r3, #21]
  hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
 8002cea:	68fb      	ldr	r3, [r7, #12]
 8002cec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002cee:	68fa      	ldr	r2, [r7, #12]
 8002cf0:	6811      	ldr	r1, [r2, #0]
 8002cf2:	7afa      	ldrb	r2, [r7, #11]
 8002cf4:	0112      	lsls	r2, r2, #4
 8002cf6:	440a      	add	r2, r1
 8002cf8:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8002cfc:	6812      	ldr	r2, [r2, #0]
 8002cfe:	0c12      	lsrs	r2, r2, #16
 8002d00:	b2d2      	uxtb	r2, r2
 8002d02:	759a      	strb	r2, [r3, #22]
  hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
 8002d04:	68fb      	ldr	r3, [r7, #12]
 8002d06:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d08:	68fa      	ldr	r2, [r7, #12]
 8002d0a:	6811      	ldr	r1, [r2, #0]
 8002d0c:	7afa      	ldrb	r2, [r7, #11]
 8002d0e:	0112      	lsls	r2, r2, #4
 8002d10:	440a      	add	r2, r1
 8002d12:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8002d16:	6812      	ldr	r2, [r2, #0]
 8002d18:	0e12      	lsrs	r2, r2, #24
 8002d1a:	b2d2      	uxtb	r2, r2
 8002d1c:	75da      	strb	r2, [r3, #23]
  hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
 8002d1e:	68fb      	ldr	r3, [r7, #12]
 8002d20:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d22:	68fa      	ldr	r2, [r7, #12]
 8002d24:	6811      	ldr	r1, [r2, #0]
 8002d26:	7afa      	ldrb	r2, [r7, #11]
 8002d28:	0112      	lsls	r2, r2, #4
 8002d2a:	440a      	add	r2, r1
 8002d2c:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8002d30:	6852      	ldr	r2, [r2, #4]
 8002d32:	b2d2      	uxtb	r2, r2
 8002d34:	761a      	strb	r2, [r3, #24]
  hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
 8002d36:	68fb      	ldr	r3, [r7, #12]
 8002d38:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d3a:	68fa      	ldr	r2, [r7, #12]
 8002d3c:	6811      	ldr	r1, [r2, #0]
 8002d3e:	7afa      	ldrb	r2, [r7, #11]
 8002d40:	0112      	lsls	r2, r2, #4
 8002d42:	440a      	add	r2, r1
 8002d44:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8002d48:	6852      	ldr	r2, [r2, #4]
 8002d4a:	0a12      	lsrs	r2, r2, #8
 8002d4c:	b2d2      	uxtb	r2, r2
 8002d4e:	765a      	strb	r2, [r3, #25]
  hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
 8002d50:	68fb      	ldr	r3, [r7, #12]
 8002d52:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d54:	68fa      	ldr	r2, [r7, #12]
 8002d56:	6811      	ldr	r1, [r2, #0]
 8002d58:	7afa      	ldrb	r2, [r7, #11]
 8002d5a:	0112      	lsls	r2, r2, #4
 8002d5c:	440a      	add	r2, r1
 8002d5e:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8002d62:	6852      	ldr	r2, [r2, #4]
 8002d64:	0c12      	lsrs	r2, r2, #16
 8002d66:	b2d2      	uxtb	r2, r2
 8002d68:	769a      	strb	r2, [r3, #26]
  hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
 8002d6a:	68fb      	ldr	r3, [r7, #12]
 8002d6c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002d6e:	68fa      	ldr	r2, [r7, #12]
 8002d70:	6811      	ldr	r1, [r2, #0]
 8002d72:	7afa      	ldrb	r2, [r7, #11]
 8002d74:	0112      	lsls	r2, r2, #4
 8002d76:	440a      	add	r2, r1
 8002d78:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8002d7c:	6852      	ldr	r2, [r2, #4]
 8002d7e:	0e12      	lsrs	r2, r2, #24
 8002d80:	b2d2      	uxtb	r2, r2
 8002d82:	76da      	strb	r2, [r3, #27]
  
  /* Release the FIFO */
  if(FIFONumber == CAN_FIFO0)
 8002d84:	7afb      	ldrb	r3, [r7, #11]
 8002d86:	2b00      	cmp	r3, #0
 8002d88:	d108      	bne.n	8002d9c <HAL_CAN_Receive+0x234>
  {
    /* Release FIFO0 */
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
 8002d8a:	68fb      	ldr	r3, [r7, #12]
 8002d8c:	681b      	ldr	r3, [r3, #0]
 8002d8e:	68fa      	ldr	r2, [r7, #12]
 8002d90:	6812      	ldr	r2, [r2, #0]
 8002d92:	68d2      	ldr	r2, [r2, #12]
 8002d94:	f042 0220 	orr.w	r2, r2, #32
 8002d98:	60da      	str	r2, [r3, #12]
 8002d9a:	e007      	b.n	8002dac <HAL_CAN_Receive+0x244>
  }
  else /* FIFONumber == CAN_FIFO1 */
  {
    /* Release FIFO1 */
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
 8002d9c:	68fb      	ldr	r3, [r7, #12]
 8002d9e:	681b      	ldr	r3, [r3, #0]
 8002da0:	68fa      	ldr	r2, [r7, #12]
 8002da2:	6812      	ldr	r2, [r2, #0]
 8002da4:	6912      	ldr	r2, [r2, #16]
 8002da6:	f042 0220 	orr.w	r2, r2, #32
 8002daa:	611a      	str	r2, [r3, #16]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 8002dac:	68fb      	ldr	r3, [r7, #12]
 8002dae:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8002db2:	b2db      	uxtb	r3, r3
 8002db4:	2b32      	cmp	r3, #50	; 0x32
 8002db6:	d108      	bne.n	8002dca <HAL_CAN_Receive+0x262>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 8002db8:	68fb      	ldr	r3, [r7, #12]
 8002dba:	2212      	movs	r2, #18
 8002dbc:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8002dc0:	68fb      	ldr	r3, [r7, #12]
 8002dc2:	2200      	movs	r2, #0
 8002dc4:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 8002dc8:	e007      	b.n	8002dda <HAL_CAN_Receive+0x272>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 8002dca:	68fb      	ldr	r3, [r7, #12]
 8002dcc:	2201      	movs	r2, #1
 8002dce:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8002dd2:	68fb      	ldr	r3, [r7, #12]
 8002dd4:	2200      	movs	r2, #0
 8002dd6:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  }
  
  /* Return function status */
  return HAL_OK;
 8002dda:	2300      	movs	r3, #0
}
 8002ddc:	4618      	mov	r0, r3
 8002dde:	3718      	adds	r7, #24
 8002de0:	46bd      	mov	sp, r7
 8002de2:	bd80      	pop	{r7, pc}

08002de4 <HAL_CAN_IRQHandler>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
void HAL_CAN_IRQHandler(CAN_HandleTypeDef* hcan)
{
 8002de4:	b580      	push	{r7, lr}
 8002de6:	b086      	sub	sp, #24
 8002de8:	af00      	add	r7, sp, #0
 8002dea:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
 8002dec:	2300      	movs	r3, #0
 8002dee:	617b      	str	r3, [r7, #20]
 8002df0:	2300      	movs	r3, #0
 8002df2:	613b      	str	r3, [r7, #16]
 8002df4:	2300      	movs	r3, #0
 8002df6:	60fb      	str	r3, [r7, #12]
  
  /* Check End of transmission flag */
  if(__HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_TME))
 8002df8:	687b      	ldr	r3, [r7, #4]
 8002dfa:	681b      	ldr	r3, [r3, #0]
 8002dfc:	695b      	ldr	r3, [r3, #20]
 8002dfe:	f003 0301 	and.w	r3, r3, #1
 8002e02:	2b00      	cmp	r3, #0
 8002e04:	d037      	beq.n	8002e76 <HAL_CAN_IRQHandler+0x92>
  {
    tmp1 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_0);
 8002e06:	687b      	ldr	r3, [r7, #4]
 8002e08:	681b      	ldr	r3, [r3, #0]
 8002e0a:	689a      	ldr	r2, [r3, #8]
 8002e0c:	4b15      	ldr	r3, [pc, #84]	; (8002e64 <HAL_CAN_IRQHandler+0x80>)
 8002e0e:	4013      	ands	r3, r2
 8002e10:	4a14      	ldr	r2, [pc, #80]	; (8002e64 <HAL_CAN_IRQHandler+0x80>)
 8002e12:	4293      	cmp	r3, r2
 8002e14:	bf0c      	ite	eq
 8002e16:	2301      	moveq	r3, #1
 8002e18:	2300      	movne	r3, #0
 8002e1a:	b2db      	uxtb	r3, r3
 8002e1c:	617b      	str	r3, [r7, #20]
    tmp2 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_1);
 8002e1e:	687b      	ldr	r3, [r7, #4]
 8002e20:	681b      	ldr	r3, [r3, #0]
 8002e22:	689a      	ldr	r2, [r3, #8]
 8002e24:	4b10      	ldr	r3, [pc, #64]	; (8002e68 <HAL_CAN_IRQHandler+0x84>)
 8002e26:	4013      	ands	r3, r2
 8002e28:	4a0f      	ldr	r2, [pc, #60]	; (8002e68 <HAL_CAN_IRQHandler+0x84>)
 8002e2a:	4293      	cmp	r3, r2
 8002e2c:	bf0c      	ite	eq
 8002e2e:	2301      	moveq	r3, #1
 8002e30:	2300      	movne	r3, #0
 8002e32:	b2db      	uxtb	r3, r3
 8002e34:	613b      	str	r3, [r7, #16]
    tmp3 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_2);
 8002e36:	687b      	ldr	r3, [r7, #4]
 8002e38:	681b      	ldr	r3, [r3, #0]
 8002e3a:	689a      	ldr	r2, [r3, #8]
 8002e3c:	4b0b      	ldr	r3, [pc, #44]	; (8002e6c <HAL_CAN_IRQHandler+0x88>)
 8002e3e:	4013      	ands	r3, r2
 8002e40:	4a0a      	ldr	r2, [pc, #40]	; (8002e6c <HAL_CAN_IRQHandler+0x88>)
 8002e42:	4293      	cmp	r3, r2
 8002e44:	bf0c      	ite	eq
 8002e46:	2301      	moveq	r3, #1
 8002e48:	2300      	movne	r3, #0
 8002e4a:	b2db      	uxtb	r3, r3
 8002e4c:	60fb      	str	r3, [r7, #12]
    if(tmp1 || tmp2 || tmp3)  
 8002e4e:	697b      	ldr	r3, [r7, #20]
 8002e50:	2b00      	cmp	r3, #0
 8002e52:	d10d      	bne.n	8002e70 <HAL_CAN_IRQHandler+0x8c>
 8002e54:	693b      	ldr	r3, [r7, #16]
 8002e56:	2b00      	cmp	r3, #0
 8002e58:	d10a      	bne.n	8002e70 <HAL_CAN_IRQHandler+0x8c>
 8002e5a:	68fb      	ldr	r3, [r7, #12]
 8002e5c:	2b00      	cmp	r3, #0
 8002e5e:	d00a      	beq.n	8002e76 <HAL_CAN_IRQHandler+0x92>
 8002e60:	e006      	b.n	8002e70 <HAL_CAN_IRQHandler+0x8c>
 8002e62:	bf00      	nop
 8002e64:	04000003 	.word	0x04000003
 8002e68:	08000300 	.word	0x08000300
 8002e6c:	10030000 	.word	0x10030000
    {
      /* Call transmit function */
      CAN_Transmit_IT(hcan);
 8002e70:	6878      	ldr	r0, [r7, #4]
 8002e72:	f000 f959 	bl	8003128 <CAN_Transmit_IT>
    }
  }
  tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO0);
 8002e76:	687b      	ldr	r3, [r7, #4]
 8002e78:	681b      	ldr	r3, [r3, #0]
 8002e7a:	68db      	ldr	r3, [r3, #12]
 8002e7c:	b2db      	uxtb	r3, r3
 8002e7e:	f003 0303 	and.w	r3, r3, #3
 8002e82:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP0);
 8002e84:	687b      	ldr	r3, [r7, #4]
 8002e86:	681b      	ldr	r3, [r3, #0]
 8002e88:	695b      	ldr	r3, [r3, #20]
 8002e8a:	f003 0302 	and.w	r3, r3, #2
 8002e8e:	2b00      	cmp	r3, #0
 8002e90:	bf14      	ite	ne
 8002e92:	2301      	movne	r3, #1
 8002e94:	2300      	moveq	r3, #0
 8002e96:	b2db      	uxtb	r3, r3
 8002e98:	613b      	str	r3, [r7, #16]
  /* Check End of reception flag for FIFO0 */
  if((tmp1 != 0) && tmp2)
 8002e9a:	697b      	ldr	r3, [r7, #20]
 8002e9c:	2b00      	cmp	r3, #0
 8002e9e:	d006      	beq.n	8002eae <HAL_CAN_IRQHandler+0xca>
 8002ea0:	693b      	ldr	r3, [r7, #16]
 8002ea2:	2b00      	cmp	r3, #0
 8002ea4:	d003      	beq.n	8002eae <HAL_CAN_IRQHandler+0xca>
  {
    /* Call receive function */
    CAN_Receive_IT(hcan, CAN_FIFO0);
 8002ea6:	6878      	ldr	r0, [r7, #4]
 8002ea8:	2100      	movs	r1, #0
 8002eaa:	f000 f98f 	bl	80031cc <CAN_Receive_IT>
  }
  
  tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO1);
 8002eae:	687b      	ldr	r3, [r7, #4]
 8002eb0:	681b      	ldr	r3, [r3, #0]
 8002eb2:	691b      	ldr	r3, [r3, #16]
 8002eb4:	b2db      	uxtb	r3, r3
 8002eb6:	f003 0303 	and.w	r3, r3, #3
 8002eba:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP1);
 8002ebc:	687b      	ldr	r3, [r7, #4]
 8002ebe:	681b      	ldr	r3, [r3, #0]
 8002ec0:	695b      	ldr	r3, [r3, #20]
 8002ec2:	f003 0310 	and.w	r3, r3, #16
 8002ec6:	2b00      	cmp	r3, #0
 8002ec8:	bf14      	ite	ne
 8002eca:	2301      	movne	r3, #1
 8002ecc:	2300      	moveq	r3, #0
 8002ece:	b2db      	uxtb	r3, r3
 8002ed0:	613b      	str	r3, [r7, #16]
  /* Check End of reception flag for FIFO1 */
  if((tmp1 != 0) && tmp2)
 8002ed2:	697b      	ldr	r3, [r7, #20]
 8002ed4:	2b00      	cmp	r3, #0
 8002ed6:	d006      	beq.n	8002ee6 <HAL_CAN_IRQHandler+0x102>
 8002ed8:	693b      	ldr	r3, [r7, #16]
 8002eda:	2b00      	cmp	r3, #0
 8002edc:	d003      	beq.n	8002ee6 <HAL_CAN_IRQHandler+0x102>
  {
    /* Call receive function */
    CAN_Receive_IT(hcan, CAN_FIFO1);
 8002ede:	6878      	ldr	r0, [r7, #4]
 8002ee0:	2101      	movs	r1, #1
 8002ee2:	f000 f973 	bl	80031cc <CAN_Receive_IT>
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EWG);
 8002ee6:	687b      	ldr	r3, [r7, #4]
 8002ee8:	681b      	ldr	r3, [r3, #0]
 8002eea:	699b      	ldr	r3, [r3, #24]
 8002eec:	f003 0301 	and.w	r3, r3, #1
 8002ef0:	2b00      	cmp	r3, #0
 8002ef2:	bf14      	ite	ne
 8002ef4:	2301      	movne	r3, #1
 8002ef6:	2300      	moveq	r3, #0
 8002ef8:	b2db      	uxtb	r3, r3
 8002efa:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EWG);
 8002efc:	687b      	ldr	r3, [r7, #4]
 8002efe:	681b      	ldr	r3, [r3, #0]
 8002f00:	695b      	ldr	r3, [r3, #20]
 8002f02:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002f06:	2b00      	cmp	r3, #0
 8002f08:	bf14      	ite	ne
 8002f0a:	2301      	movne	r3, #1
 8002f0c:	2300      	moveq	r3, #0
 8002f0e:	b2db      	uxtb	r3, r3
 8002f10:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
 8002f12:	687b      	ldr	r3, [r7, #4]
 8002f14:	681b      	ldr	r3, [r3, #0]
 8002f16:	695b      	ldr	r3, [r3, #20]
 8002f18:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002f1c:	2b00      	cmp	r3, #0
 8002f1e:	bf14      	ite	ne
 8002f20:	2301      	movne	r3, #1
 8002f22:	2300      	moveq	r3, #0
 8002f24:	b2db      	uxtb	r3, r3
 8002f26:	60fb      	str	r3, [r7, #12]
  /* Check Error Warning Flag */
  if(tmp1 && tmp2 && tmp3)
 8002f28:	697b      	ldr	r3, [r7, #20]
 8002f2a:	2b00      	cmp	r3, #0
 8002f2c:	d010      	beq.n	8002f50 <HAL_CAN_IRQHandler+0x16c>
 8002f2e:	693b      	ldr	r3, [r7, #16]
 8002f30:	2b00      	cmp	r3, #0
 8002f32:	d00d      	beq.n	8002f50 <HAL_CAN_IRQHandler+0x16c>
 8002f34:	68fb      	ldr	r3, [r7, #12]
 8002f36:	2b00      	cmp	r3, #0
 8002f38:	d00a      	beq.n	8002f50 <HAL_CAN_IRQHandler+0x16c>
  {
    /* Set CAN error code to EWG error */
    hcan->ErrorCode |= HAL_CAN_ERROR_EWG;
 8002f3a:	687b      	ldr	r3, [r7, #4]
 8002f3c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002f3e:	f043 0201 	orr.w	r2, r3, #1
 8002f42:	687b      	ldr	r3, [r7, #4]
 8002f44:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Error Warning Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EWG);
 8002f46:	687b      	ldr	r3, [r7, #4]
 8002f48:	681b      	ldr	r3, [r3, #0]
 8002f4a:	f06f 0201 	mvn.w	r2, #1
 8002f4e:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EPV);
 8002f50:	687b      	ldr	r3, [r7, #4]
 8002f52:	681b      	ldr	r3, [r3, #0]
 8002f54:	699b      	ldr	r3, [r3, #24]
 8002f56:	f003 0302 	and.w	r3, r3, #2
 8002f5a:	2b00      	cmp	r3, #0
 8002f5c:	bf14      	ite	ne
 8002f5e:	2301      	movne	r3, #1
 8002f60:	2300      	moveq	r3, #0
 8002f62:	b2db      	uxtb	r3, r3
 8002f64:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EPV);
 8002f66:	687b      	ldr	r3, [r7, #4]
 8002f68:	681b      	ldr	r3, [r3, #0]
 8002f6a:	695b      	ldr	r3, [r3, #20]
 8002f6c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002f70:	2b00      	cmp	r3, #0
 8002f72:	bf14      	ite	ne
 8002f74:	2301      	movne	r3, #1
 8002f76:	2300      	moveq	r3, #0
 8002f78:	b2db      	uxtb	r3, r3
 8002f7a:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR); 
 8002f7c:	687b      	ldr	r3, [r7, #4]
 8002f7e:	681b      	ldr	r3, [r3, #0]
 8002f80:	695b      	ldr	r3, [r3, #20]
 8002f82:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002f86:	2b00      	cmp	r3, #0
 8002f88:	bf14      	ite	ne
 8002f8a:	2301      	movne	r3, #1
 8002f8c:	2300      	moveq	r3, #0
 8002f8e:	b2db      	uxtb	r3, r3
 8002f90:	60fb      	str	r3, [r7, #12]
  /* Check Error Passive Flag */
  if(tmp1 && tmp2 && tmp3)
 8002f92:	697b      	ldr	r3, [r7, #20]
 8002f94:	2b00      	cmp	r3, #0
 8002f96:	d010      	beq.n	8002fba <HAL_CAN_IRQHandler+0x1d6>
 8002f98:	693b      	ldr	r3, [r7, #16]
 8002f9a:	2b00      	cmp	r3, #0
 8002f9c:	d00d      	beq.n	8002fba <HAL_CAN_IRQHandler+0x1d6>
 8002f9e:	68fb      	ldr	r3, [r7, #12]
 8002fa0:	2b00      	cmp	r3, #0
 8002fa2:	d00a      	beq.n	8002fba <HAL_CAN_IRQHandler+0x1d6>
  {
    /* Set CAN error code to EPV error */
    hcan->ErrorCode |= HAL_CAN_ERROR_EPV;
 8002fa4:	687b      	ldr	r3, [r7, #4]
 8002fa6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002fa8:	f043 0202 	orr.w	r2, r3, #2
 8002fac:	687b      	ldr	r3, [r7, #4]
 8002fae:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Error Passive Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EPV);
 8002fb0:	687b      	ldr	r3, [r7, #4]
 8002fb2:	681b      	ldr	r3, [r3, #0]
 8002fb4:	f06f 0202 	mvn.w	r2, #2
 8002fb8:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_BOF);
 8002fba:	687b      	ldr	r3, [r7, #4]
 8002fbc:	681b      	ldr	r3, [r3, #0]
 8002fbe:	699b      	ldr	r3, [r3, #24]
 8002fc0:	f003 0304 	and.w	r3, r3, #4
 8002fc4:	2b00      	cmp	r3, #0
 8002fc6:	bf14      	ite	ne
 8002fc8:	2301      	movne	r3, #1
 8002fca:	2300      	moveq	r3, #0
 8002fcc:	b2db      	uxtb	r3, r3
 8002fce:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_BOF);
 8002fd0:	687b      	ldr	r3, [r7, #4]
 8002fd2:	681b      	ldr	r3, [r3, #0]
 8002fd4:	695b      	ldr	r3, [r3, #20]
 8002fd6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002fda:	2b00      	cmp	r3, #0
 8002fdc:	bf14      	ite	ne
 8002fde:	2301      	movne	r3, #1
 8002fe0:	2300      	moveq	r3, #0
 8002fe2:	b2db      	uxtb	r3, r3
 8002fe4:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);  
 8002fe6:	687b      	ldr	r3, [r7, #4]
 8002fe8:	681b      	ldr	r3, [r3, #0]
 8002fea:	695b      	ldr	r3, [r3, #20]
 8002fec:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002ff0:	2b00      	cmp	r3, #0
 8002ff2:	bf14      	ite	ne
 8002ff4:	2301      	movne	r3, #1
 8002ff6:	2300      	moveq	r3, #0
 8002ff8:	b2db      	uxtb	r3, r3
 8002ffa:	60fb      	str	r3, [r7, #12]
  /* Check Bus-Off Flag */
  if(tmp1 && tmp2 && tmp3)
 8002ffc:	697b      	ldr	r3, [r7, #20]
 8002ffe:	2b00      	cmp	r3, #0
 8003000:	d010      	beq.n	8003024 <HAL_CAN_IRQHandler+0x240>
 8003002:	693b      	ldr	r3, [r7, #16]
 8003004:	2b00      	cmp	r3, #0
 8003006:	d00d      	beq.n	8003024 <HAL_CAN_IRQHandler+0x240>
 8003008:	68fb      	ldr	r3, [r7, #12]
 800300a:	2b00      	cmp	r3, #0
 800300c:	d00a      	beq.n	8003024 <HAL_CAN_IRQHandler+0x240>
  {
    /* Set CAN error code to BOF error */
    hcan->ErrorCode |= HAL_CAN_ERROR_BOF;
 800300e:	687b      	ldr	r3, [r7, #4]
 8003010:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003012:	f043 0204 	orr.w	r2, r3, #4
 8003016:	687b      	ldr	r3, [r7, #4]
 8003018:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Bus-Off Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_BOF);
 800301a:	687b      	ldr	r3, [r7, #4]
 800301c:	681b      	ldr	r3, [r3, #0]
 800301e:	f06f 0204 	mvn.w	r2, #4
 8003022:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = HAL_IS_BIT_CLR(hcan->Instance->ESR, CAN_ESR_LEC);
 8003024:	687b      	ldr	r3, [r7, #4]
 8003026:	681b      	ldr	r3, [r3, #0]
 8003028:	699b      	ldr	r3, [r3, #24]
 800302a:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800302e:	2b00      	cmp	r3, #0
 8003030:	bf0c      	ite	eq
 8003032:	2301      	moveq	r3, #1
 8003034:	2300      	movne	r3, #0
 8003036:	b2db      	uxtb	r3, r3
 8003038:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_LEC);
 800303a:	687b      	ldr	r3, [r7, #4]
 800303c:	681b      	ldr	r3, [r3, #0]
 800303e:	695b      	ldr	r3, [r3, #20]
 8003040:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003044:	2b00      	cmp	r3, #0
 8003046:	bf14      	ite	ne
 8003048:	2301      	movne	r3, #1
 800304a:	2300      	moveq	r3, #0
 800304c:	b2db      	uxtb	r3, r3
 800304e:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
 8003050:	687b      	ldr	r3, [r7, #4]
 8003052:	681b      	ldr	r3, [r3, #0]
 8003054:	695b      	ldr	r3, [r3, #20]
 8003056:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800305a:	2b00      	cmp	r3, #0
 800305c:	bf14      	ite	ne
 800305e:	2301      	movne	r3, #1
 8003060:	2300      	moveq	r3, #0
 8003062:	b2db      	uxtb	r3, r3
 8003064:	60fb      	str	r3, [r7, #12]
  /* Check Last error code Flag */
  if((!tmp1) && tmp2 && tmp3)
 8003066:	697b      	ldr	r3, [r7, #20]
 8003068:	2b00      	cmp	r3, #0
 800306a:	d14e      	bne.n	800310a <HAL_CAN_IRQHandler+0x326>
 800306c:	693b      	ldr	r3, [r7, #16]
 800306e:	2b00      	cmp	r3, #0
 8003070:	d04b      	beq.n	800310a <HAL_CAN_IRQHandler+0x326>
 8003072:	68fb      	ldr	r3, [r7, #12]
 8003074:	2b00      	cmp	r3, #0
 8003076:	d048      	beq.n	800310a <HAL_CAN_IRQHandler+0x326>
  {
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
 8003078:	687b      	ldr	r3, [r7, #4]
 800307a:	681b      	ldr	r3, [r3, #0]
 800307c:	699b      	ldr	r3, [r3, #24]
 800307e:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8003082:	617b      	str	r3, [r7, #20]
    switch(tmp1)
 8003084:	697b      	ldr	r3, [r7, #20]
 8003086:	2b30      	cmp	r3, #48	; 0x30
 8003088:	d01b      	beq.n	80030c2 <HAL_CAN_IRQHandler+0x2de>
 800308a:	2b30      	cmp	r3, #48	; 0x30
 800308c:	d804      	bhi.n	8003098 <HAL_CAN_IRQHandler+0x2b4>
 800308e:	2b10      	cmp	r3, #16
 8003090:	d009      	beq.n	80030a6 <HAL_CAN_IRQHandler+0x2c2>
 8003092:	2b20      	cmp	r3, #32
 8003094:	d00e      	beq.n	80030b4 <HAL_CAN_IRQHandler+0x2d0>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
          break;
      default:
          break;
 8003096:	e030      	b.n	80030fa <HAL_CAN_IRQHandler+0x316>
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
  /* Check Last error code Flag */
  if((!tmp1) && tmp2 && tmp3)
  {
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
    switch(tmp1)
 8003098:	2b50      	cmp	r3, #80	; 0x50
 800309a:	d020      	beq.n	80030de <HAL_CAN_IRQHandler+0x2fa>
 800309c:	2b60      	cmp	r3, #96	; 0x60
 800309e:	d025      	beq.n	80030ec <HAL_CAN_IRQHandler+0x308>
 80030a0:	2b40      	cmp	r3, #64	; 0x40
 80030a2:	d015      	beq.n	80030d0 <HAL_CAN_IRQHandler+0x2ec>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
          break;
      default:
          break;
 80030a4:	e029      	b.n	80030fa <HAL_CAN_IRQHandler+0x316>
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
    switch(tmp1)
    {
      case(CAN_ESR_LEC_0):
          /* Set CAN error code to STF error */
          hcan->ErrorCode |= HAL_CAN_ERROR_STF;
 80030a6:	687b      	ldr	r3, [r7, #4]
 80030a8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030aa:	f043 0208 	orr.w	r2, r3, #8
 80030ae:	687b      	ldr	r3, [r7, #4]
 80030b0:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80030b2:	e022      	b.n	80030fa <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_1):
          /* Set CAN error code to FOR error */
          hcan->ErrorCode |= HAL_CAN_ERROR_FOR;
 80030b4:	687b      	ldr	r3, [r7, #4]
 80030b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030b8:	f043 0210 	orr.w	r2, r3, #16
 80030bc:	687b      	ldr	r3, [r7, #4]
 80030be:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80030c0:	e01b      	b.n	80030fa <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_1 | CAN_ESR_LEC_0):
          /* Set CAN error code to ACK error */
          hcan->ErrorCode |= HAL_CAN_ERROR_ACK;
 80030c2:	687b      	ldr	r3, [r7, #4]
 80030c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030c6:	f043 0220 	orr.w	r2, r3, #32
 80030ca:	687b      	ldr	r3, [r7, #4]
 80030cc:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80030ce:	e014      	b.n	80030fa <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2):
          /* Set CAN error code to BR error */
          hcan->ErrorCode |= HAL_CAN_ERROR_BR;
 80030d0:	687b      	ldr	r3, [r7, #4]
 80030d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030d4:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80030d8:	687b      	ldr	r3, [r7, #4]
 80030da:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80030dc:	e00d      	b.n	80030fa <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_0):
          /* Set CAN error code to BD error */
          hcan->ErrorCode |= HAL_CAN_ERROR_BD;
 80030de:	687b      	ldr	r3, [r7, #4]
 80030e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030e2:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80030e6:	687b      	ldr	r3, [r7, #4]
 80030e8:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80030ea:	e006      	b.n	80030fa <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
 80030ec:	687b      	ldr	r3, [r7, #4]
 80030ee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80030f0:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 80030f4:	687b      	ldr	r3, [r7, #4]
 80030f6:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80030f8:	bf00      	nop
      default:
          break;
    }

    /* Clear Last error code Flag */ 
    hcan->Instance->ESR &= ~(CAN_ESR_LEC);
 80030fa:	687b      	ldr	r3, [r7, #4]
 80030fc:	681b      	ldr	r3, [r3, #0]
 80030fe:	687a      	ldr	r2, [r7, #4]
 8003100:	6812      	ldr	r2, [r2, #0]
 8003102:	6992      	ldr	r2, [r2, #24]
 8003104:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003108:	619a      	str	r2, [r3, #24]
  }

  /* Call the Error call Back in case of Errors */
  if(hcan->ErrorCode != HAL_CAN_ERROR_NONE)
 800310a:	687b      	ldr	r3, [r7, #4]
 800310c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800310e:	2b00      	cmp	r3, #0
 8003110:	d006      	beq.n	8003120 <HAL_CAN_IRQHandler+0x33c>
  {
    /* Set the CAN state ready to be able to start again the process */
    hcan->State = HAL_CAN_STATE_READY;
 8003112:	687b      	ldr	r3, [r7, #4]
 8003114:	2201      	movs	r2, #1
 8003116:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Call Error callback function */
    HAL_CAN_ErrorCallback(hcan);
 800311a:	6878      	ldr	r0, [r7, #4]
 800311c:	f009 fe5c 	bl	800cdd8 <HAL_CAN_ErrorCallback>
  }  
}
 8003120:	3718      	adds	r7, #24
 8003122:	46bd      	mov	sp, r7
 8003124:	bd80      	pop	{r7, pc}
 8003126:	bf00      	nop

08003128 <CAN_Transmit_IT>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
static HAL_StatusTypeDef CAN_Transmit_IT(CAN_HandleTypeDef* hcan)
{
 8003128:	b580      	push	{r7, lr}
 800312a:	b082      	sub	sp, #8
 800312c:	af00      	add	r7, sp, #0
 800312e:	6078      	str	r0, [r7, #4]
  /* Disable Transmit mailbox empty Interrupt */
  __HAL_CAN_DISABLE_IT(hcan, CAN_IT_TME);
 8003130:	687b      	ldr	r3, [r7, #4]
 8003132:	681b      	ldr	r3, [r3, #0]
 8003134:	687a      	ldr	r2, [r7, #4]
 8003136:	6812      	ldr	r2, [r2, #0]
 8003138:	6952      	ldr	r2, [r2, #20]
 800313a:	f022 0201 	bic.w	r2, r2, #1
 800313e:	615a      	str	r2, [r3, #20]
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX)
 8003140:	687b      	ldr	r3, [r7, #4]
 8003142:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8003146:	b2db      	uxtb	r3, r3
 8003148:	2b12      	cmp	r3, #18
 800314a:	d127      	bne.n	800319c <CAN_Transmit_IT+0x74>
  {   
    /* Disable Error warning Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
 800314c:	687b      	ldr	r3, [r7, #4]
 800314e:	681b      	ldr	r3, [r3, #0]
 8003150:	687a      	ldr	r2, [r7, #4]
 8003152:	6812      	ldr	r2, [r2, #0]
 8003154:	6952      	ldr	r2, [r2, #20]
 8003156:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800315a:	615a      	str	r2, [r3, #20]
    
    /* Disable Error passive Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
 800315c:	687b      	ldr	r3, [r7, #4]
 800315e:	681b      	ldr	r3, [r3, #0]
 8003160:	687a      	ldr	r2, [r7, #4]
 8003162:	6812      	ldr	r2, [r2, #0]
 8003164:	6952      	ldr	r2, [r2, #20]
 8003166:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800316a:	615a      	str	r2, [r3, #20]
    
    /* Disable Bus-off Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
 800316c:	687b      	ldr	r3, [r7, #4]
 800316e:	681b      	ldr	r3, [r3, #0]
 8003170:	687a      	ldr	r2, [r7, #4]
 8003172:	6812      	ldr	r2, [r2, #0]
 8003174:	6952      	ldr	r2, [r2, #20]
 8003176:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800317a:	615a      	str	r2, [r3, #20]
    
    /* Disable Last error code Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
 800317c:	687b      	ldr	r3, [r7, #4]
 800317e:	681b      	ldr	r3, [r3, #0]
 8003180:	687a      	ldr	r2, [r7, #4]
 8003182:	6812      	ldr	r2, [r2, #0]
 8003184:	6952      	ldr	r2, [r2, #20]
 8003186:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800318a:	615a      	str	r2, [r3, #20]
    
    /* Disable Error Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
 800318c:	687b      	ldr	r3, [r7, #4]
 800318e:	681b      	ldr	r3, [r3, #0]
 8003190:	687a      	ldr	r2, [r7, #4]
 8003192:	6812      	ldr	r2, [r2, #0]
 8003194:	6952      	ldr	r2, [r2, #20]
 8003196:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800319a:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 800319c:	687b      	ldr	r3, [r7, #4]
 800319e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80031a2:	b2db      	uxtb	r3, r3
 80031a4:	2b32      	cmp	r3, #50	; 0x32
 80031a6:	d104      	bne.n	80031b2 <CAN_Transmit_IT+0x8a>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_RX;
 80031a8:	687b      	ldr	r3, [r7, #4]
 80031aa:	2222      	movs	r2, #34	; 0x22
 80031ac:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 80031b0:	e003      	b.n	80031ba <CAN_Transmit_IT+0x92>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 80031b2:	687b      	ldr	r3, [r7, #4]
 80031b4:	2201      	movs	r2, #1
 80031b6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
  
  /* Transmission complete callback */ 
  HAL_CAN_TxCpltCallback(hcan);
 80031ba:	6878      	ldr	r0, [r7, #4]
 80031bc:	f009 fda2 	bl	800cd04 <HAL_CAN_TxCpltCallback>
  
  return HAL_OK;
 80031c0:	2300      	movs	r3, #0
}
 80031c2:	4618      	mov	r0, r3
 80031c4:	3708      	adds	r7, #8
 80031c6:	46bd      	mov	sp, r7
 80031c8:	bd80      	pop	{r7, pc}
 80031ca:	bf00      	nop

080031cc <CAN_Receive_IT>:
  * @param  FIFONumber: Specify the FIFO number    
  * @retval HAL status
  * @retval None
  */
static HAL_StatusTypeDef CAN_Receive_IT(CAN_HandleTypeDef* hcan, uint8_t FIFONumber)
{
 80031cc:	b580      	push	{r7, lr}
 80031ce:	b082      	sub	sp, #8
 80031d0:	af00      	add	r7, sp, #0
 80031d2:	6078      	str	r0, [r7, #4]
 80031d4:	460b      	mov	r3, r1
 80031d6:	70fb      	strb	r3, [r7, #3]
  /* Get the Id */
  hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 80031d8:	687b      	ldr	r3, [r7, #4]
 80031da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80031dc:	687a      	ldr	r2, [r7, #4]
 80031de:	6811      	ldr	r1, [r2, #0]
 80031e0:	78fa      	ldrb	r2, [r7, #3]
 80031e2:	321b      	adds	r2, #27
 80031e4:	0112      	lsls	r2, r2, #4
 80031e6:	440a      	add	r2, r1
 80031e8:	6812      	ldr	r2, [r2, #0]
 80031ea:	f002 0204 	and.w	r2, r2, #4
 80031ee:	609a      	str	r2, [r3, #8]
  if (hcan->pRxMsg->IDE == CAN_ID_STD)
 80031f0:	687b      	ldr	r3, [r7, #4]
 80031f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80031f4:	689b      	ldr	r3, [r3, #8]
 80031f6:	2b00      	cmp	r3, #0
 80031f8:	d10b      	bne.n	8003212 <CAN_Receive_IT+0x46>
  {
    hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
 80031fa:	687b      	ldr	r3, [r7, #4]
 80031fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80031fe:	687a      	ldr	r2, [r7, #4]
 8003200:	6811      	ldr	r1, [r2, #0]
 8003202:	78fa      	ldrb	r2, [r7, #3]
 8003204:	321b      	adds	r2, #27
 8003206:	0112      	lsls	r2, r2, #4
 8003208:	440a      	add	r2, r1
 800320a:	6812      	ldr	r2, [r2, #0]
 800320c:	0d52      	lsrs	r2, r2, #21
 800320e:	601a      	str	r2, [r3, #0]
 8003210:	e00a      	b.n	8003228 <CAN_Receive_IT+0x5c>
  }
  else
  {
    hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
 8003212:	687b      	ldr	r3, [r7, #4]
 8003214:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003216:	687a      	ldr	r2, [r7, #4]
 8003218:	6811      	ldr	r1, [r2, #0]
 800321a:	78fa      	ldrb	r2, [r7, #3]
 800321c:	321b      	adds	r2, #27
 800321e:	0112      	lsls	r2, r2, #4
 8003220:	440a      	add	r2, r1
 8003222:	6812      	ldr	r2, [r2, #0]
 8003224:	08d2      	lsrs	r2, r2, #3
 8003226:	605a      	str	r2, [r3, #4]
  }
  
  hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 8003228:	687b      	ldr	r3, [r7, #4]
 800322a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800322c:	687a      	ldr	r2, [r7, #4]
 800322e:	6811      	ldr	r1, [r2, #0]
 8003230:	78fa      	ldrb	r2, [r7, #3]
 8003232:	321b      	adds	r2, #27
 8003234:	0112      	lsls	r2, r2, #4
 8003236:	440a      	add	r2, r1
 8003238:	6812      	ldr	r2, [r2, #0]
 800323a:	f002 0202 	and.w	r2, r2, #2
 800323e:	60da      	str	r2, [r3, #12]
  /* Get the DLC */
  hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
 8003240:	687b      	ldr	r3, [r7, #4]
 8003242:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003244:	687a      	ldr	r2, [r7, #4]
 8003246:	6811      	ldr	r1, [r2, #0]
 8003248:	78fa      	ldrb	r2, [r7, #3]
 800324a:	321b      	adds	r2, #27
 800324c:	0112      	lsls	r2, r2, #4
 800324e:	440a      	add	r2, r1
 8003250:	6852      	ldr	r2, [r2, #4]
 8003252:	f002 020f 	and.w	r2, r2, #15
 8003256:	611a      	str	r2, [r3, #16]
  /* Get the FMI */
  hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
 8003258:	687b      	ldr	r3, [r7, #4]
 800325a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800325c:	687a      	ldr	r2, [r7, #4]
 800325e:	6811      	ldr	r1, [r2, #0]
 8003260:	78fa      	ldrb	r2, [r7, #3]
 8003262:	321b      	adds	r2, #27
 8003264:	0112      	lsls	r2, r2, #4
 8003266:	440a      	add	r2, r1
 8003268:	6852      	ldr	r2, [r2, #4]
 800326a:	0a12      	lsrs	r2, r2, #8
 800326c:	b2d2      	uxtb	r2, r2
 800326e:	61da      	str	r2, [r3, #28]
  /* Get the data field */
  hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
 8003270:	687b      	ldr	r3, [r7, #4]
 8003272:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003274:	687a      	ldr	r2, [r7, #4]
 8003276:	6811      	ldr	r1, [r2, #0]
 8003278:	78fa      	ldrb	r2, [r7, #3]
 800327a:	0112      	lsls	r2, r2, #4
 800327c:	440a      	add	r2, r1
 800327e:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8003282:	6812      	ldr	r2, [r2, #0]
 8003284:	b2d2      	uxtb	r2, r2
 8003286:	751a      	strb	r2, [r3, #20]
  hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
 8003288:	687b      	ldr	r3, [r7, #4]
 800328a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800328c:	687a      	ldr	r2, [r7, #4]
 800328e:	6811      	ldr	r1, [r2, #0]
 8003290:	78fa      	ldrb	r2, [r7, #3]
 8003292:	0112      	lsls	r2, r2, #4
 8003294:	440a      	add	r2, r1
 8003296:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 800329a:	6812      	ldr	r2, [r2, #0]
 800329c:	0a12      	lsrs	r2, r2, #8
 800329e:	b2d2      	uxtb	r2, r2
 80032a0:	755a      	strb	r2, [r3, #21]
  hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
 80032a2:	687b      	ldr	r3, [r7, #4]
 80032a4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80032a6:	687a      	ldr	r2, [r7, #4]
 80032a8:	6811      	ldr	r1, [r2, #0]
 80032aa:	78fa      	ldrb	r2, [r7, #3]
 80032ac:	0112      	lsls	r2, r2, #4
 80032ae:	440a      	add	r2, r1
 80032b0:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80032b4:	6812      	ldr	r2, [r2, #0]
 80032b6:	0c12      	lsrs	r2, r2, #16
 80032b8:	b2d2      	uxtb	r2, r2
 80032ba:	759a      	strb	r2, [r3, #22]
  hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
 80032bc:	687b      	ldr	r3, [r7, #4]
 80032be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80032c0:	687a      	ldr	r2, [r7, #4]
 80032c2:	6811      	ldr	r1, [r2, #0]
 80032c4:	78fa      	ldrb	r2, [r7, #3]
 80032c6:	0112      	lsls	r2, r2, #4
 80032c8:	440a      	add	r2, r1
 80032ca:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80032ce:	6812      	ldr	r2, [r2, #0]
 80032d0:	0e12      	lsrs	r2, r2, #24
 80032d2:	b2d2      	uxtb	r2, r2
 80032d4:	75da      	strb	r2, [r3, #23]
  hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
 80032d6:	687b      	ldr	r3, [r7, #4]
 80032d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80032da:	687a      	ldr	r2, [r7, #4]
 80032dc:	6811      	ldr	r1, [r2, #0]
 80032de:	78fa      	ldrb	r2, [r7, #3]
 80032e0:	0112      	lsls	r2, r2, #4
 80032e2:	440a      	add	r2, r1
 80032e4:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80032e8:	6852      	ldr	r2, [r2, #4]
 80032ea:	b2d2      	uxtb	r2, r2
 80032ec:	761a      	strb	r2, [r3, #24]
  hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
 80032ee:	687b      	ldr	r3, [r7, #4]
 80032f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80032f2:	687a      	ldr	r2, [r7, #4]
 80032f4:	6811      	ldr	r1, [r2, #0]
 80032f6:	78fa      	ldrb	r2, [r7, #3]
 80032f8:	0112      	lsls	r2, r2, #4
 80032fa:	440a      	add	r2, r1
 80032fc:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8003300:	6852      	ldr	r2, [r2, #4]
 8003302:	0a12      	lsrs	r2, r2, #8
 8003304:	b2d2      	uxtb	r2, r2
 8003306:	765a      	strb	r2, [r3, #25]
  hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
 8003308:	687b      	ldr	r3, [r7, #4]
 800330a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800330c:	687a      	ldr	r2, [r7, #4]
 800330e:	6811      	ldr	r1, [r2, #0]
 8003310:	78fa      	ldrb	r2, [r7, #3]
 8003312:	0112      	lsls	r2, r2, #4
 8003314:	440a      	add	r2, r1
 8003316:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 800331a:	6852      	ldr	r2, [r2, #4]
 800331c:	0c12      	lsrs	r2, r2, #16
 800331e:	b2d2      	uxtb	r2, r2
 8003320:	769a      	strb	r2, [r3, #26]
  hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
 8003322:	687b      	ldr	r3, [r7, #4]
 8003324:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003326:	687a      	ldr	r2, [r7, #4]
 8003328:	6811      	ldr	r1, [r2, #0]
 800332a:	78fa      	ldrb	r2, [r7, #3]
 800332c:	0112      	lsls	r2, r2, #4
 800332e:	440a      	add	r2, r1
 8003330:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8003334:	6852      	ldr	r2, [r2, #4]
 8003336:	0e12      	lsrs	r2, r2, #24
 8003338:	b2d2      	uxtb	r2, r2
 800333a:	76da      	strb	r2, [r3, #27]
  /* Release the FIFO */
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
 800333c:	78fb      	ldrb	r3, [r7, #3]
 800333e:	2b00      	cmp	r3, #0
 8003340:	d110      	bne.n	8003364 <CAN_Receive_IT+0x198>
  {
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
 8003342:	687b      	ldr	r3, [r7, #4]
 8003344:	681b      	ldr	r3, [r3, #0]
 8003346:	687a      	ldr	r2, [r7, #4]
 8003348:	6812      	ldr	r2, [r2, #0]
 800334a:	68d2      	ldr	r2, [r2, #12]
 800334c:	f042 0220 	orr.w	r2, r2, #32
 8003350:	60da      	str	r2, [r3, #12]
    
    /* Disable FIFO 0 message pending Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP0);
 8003352:	687b      	ldr	r3, [r7, #4]
 8003354:	681b      	ldr	r3, [r3, #0]
 8003356:	687a      	ldr	r2, [r7, #4]
 8003358:	6812      	ldr	r2, [r2, #0]
 800335a:	6952      	ldr	r2, [r2, #20]
 800335c:	f022 0202 	bic.w	r2, r2, #2
 8003360:	615a      	str	r2, [r3, #20]
 8003362:	e00f      	b.n	8003384 <CAN_Receive_IT+0x1b8>
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
 8003364:	687b      	ldr	r3, [r7, #4]
 8003366:	681b      	ldr	r3, [r3, #0]
 8003368:	687a      	ldr	r2, [r7, #4]
 800336a:	6812      	ldr	r2, [r2, #0]
 800336c:	6912      	ldr	r2, [r2, #16]
 800336e:	f042 0220 	orr.w	r2, r2, #32
 8003372:	611a      	str	r2, [r3, #16]
    
    /* Disable FIFO 1 message pending Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP1);
 8003374:	687b      	ldr	r3, [r7, #4]
 8003376:	681b      	ldr	r3, [r3, #0]
 8003378:	687a      	ldr	r2, [r7, #4]
 800337a:	6812      	ldr	r2, [r2, #0]
 800337c:	6952      	ldr	r2, [r2, #20]
 800337e:	f022 0210 	bic.w	r2, r2, #16
 8003382:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_RX)
 8003384:	687b      	ldr	r3, [r7, #4]
 8003386:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800338a:	b2db      	uxtb	r3, r3
 800338c:	2b22      	cmp	r3, #34	; 0x22
 800338e:	d127      	bne.n	80033e0 <CAN_Receive_IT+0x214>
  {   
    /* Disable Error warning Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
 8003390:	687b      	ldr	r3, [r7, #4]
 8003392:	681b      	ldr	r3, [r3, #0]
 8003394:	687a      	ldr	r2, [r7, #4]
 8003396:	6812      	ldr	r2, [r2, #0]
 8003398:	6952      	ldr	r2, [r2, #20]
 800339a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800339e:	615a      	str	r2, [r3, #20]
    
    /* Disable Error passive Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
 80033a0:	687b      	ldr	r3, [r7, #4]
 80033a2:	681b      	ldr	r3, [r3, #0]
 80033a4:	687a      	ldr	r2, [r7, #4]
 80033a6:	6812      	ldr	r2, [r2, #0]
 80033a8:	6952      	ldr	r2, [r2, #20]
 80033aa:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80033ae:	615a      	str	r2, [r3, #20]
    
    /* Disable Bus-off Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
 80033b0:	687b      	ldr	r3, [r7, #4]
 80033b2:	681b      	ldr	r3, [r3, #0]
 80033b4:	687a      	ldr	r2, [r7, #4]
 80033b6:	6812      	ldr	r2, [r2, #0]
 80033b8:	6952      	ldr	r2, [r2, #20]
 80033ba:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80033be:	615a      	str	r2, [r3, #20]
    
    /* Disable Last error code Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
 80033c0:	687b      	ldr	r3, [r7, #4]
 80033c2:	681b      	ldr	r3, [r3, #0]
 80033c4:	687a      	ldr	r2, [r7, #4]
 80033c6:	6812      	ldr	r2, [r2, #0]
 80033c8:	6952      	ldr	r2, [r2, #20]
 80033ca:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80033ce:	615a      	str	r2, [r3, #20]
    
    /* Disable Error Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
 80033d0:	687b      	ldr	r3, [r7, #4]
 80033d2:	681b      	ldr	r3, [r3, #0]
 80033d4:	687a      	ldr	r2, [r7, #4]
 80033d6:	6812      	ldr	r2, [r2, #0]
 80033d8:	6952      	ldr	r2, [r2, #20]
 80033da:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80033de:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 80033e0:	687b      	ldr	r3, [r7, #4]
 80033e2:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80033e6:	b2db      	uxtb	r3, r3
 80033e8:	2b32      	cmp	r3, #50	; 0x32
 80033ea:	d104      	bne.n	80033f6 <CAN_Receive_IT+0x22a>
  {
    /* Disable CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 80033ec:	687b      	ldr	r3, [r7, #4]
 80033ee:	2212      	movs	r2, #18
 80033f0:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 80033f4:	e003      	b.n	80033fe <CAN_Receive_IT+0x232>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 80033f6:	687b      	ldr	r3, [r7, #4]
 80033f8:	2201      	movs	r2, #1
 80033fa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }

  /* Receive complete callback */ 
  HAL_CAN_RxCpltCallback(hcan);
 80033fe:	6878      	ldr	r0, [r7, #4]
 8003400:	f009 fc9e 	bl	800cd40 <HAL_CAN_RxCpltCallback>

  /* Return function status */
  return HAL_OK;
 8003404:	2300      	movs	r3, #0
}
 8003406:	4618      	mov	r0, r3
 8003408:	3708      	adds	r7, #8
 800340a:	46bd      	mov	sp, r7
 800340c:	bd80      	pop	{r7, pc}
 800340e:	bf00      	nop

08003410 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8003410:	b480      	push	{r7}
 8003412:	b085      	sub	sp, #20
 8003414:	af00      	add	r7, sp, #0
 8003416:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8003418:	687b      	ldr	r3, [r7, #4]
 800341a:	f003 0307 	and.w	r3, r3, #7
 800341e:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003420:	4b0b      	ldr	r3, [pc, #44]	; (8003450 <NVIC_SetPriorityGrouping+0x40>)
 8003422:	68db      	ldr	r3, [r3, #12]
 8003424:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8003426:	68ba      	ldr	r2, [r7, #8]
 8003428:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800342c:	4013      	ands	r3, r2
 800342e:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 8003430:	68fb      	ldr	r3, [r7, #12]
 8003432:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8003434:	68bb      	ldr	r3, [r7, #8]
 8003436:	431a      	orrs	r2, r3
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8003438:	4b06      	ldr	r3, [pc, #24]	; (8003454 <NVIC_SetPriorityGrouping+0x44>)
 800343a:	4313      	orrs	r3, r2
 800343c:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800343e:	4a04      	ldr	r2, [pc, #16]	; (8003450 <NVIC_SetPriorityGrouping+0x40>)
 8003440:	68bb      	ldr	r3, [r7, #8]
 8003442:	60d3      	str	r3, [r2, #12]
}
 8003444:	3714      	adds	r7, #20
 8003446:	46bd      	mov	sp, r7
 8003448:	f85d 7b04 	ldr.w	r7, [sp], #4
 800344c:	4770      	bx	lr
 800344e:	bf00      	nop
 8003450:	e000ed00 	.word	0xe000ed00
 8003454:	05fa0000 	.word	0x05fa0000

08003458 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 8003458:	b480      	push	{r7}
 800345a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800345c:	4b04      	ldr	r3, [pc, #16]	; (8003470 <NVIC_GetPriorityGrouping+0x18>)
 800345e:	68db      	ldr	r3, [r3, #12]
 8003460:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8003464:	0a1b      	lsrs	r3, r3, #8
}
 8003466:	4618      	mov	r0, r3
 8003468:	46bd      	mov	sp, r7
 800346a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800346e:	4770      	bx	lr
 8003470:	e000ed00 	.word	0xe000ed00

08003474 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8003474:	b480      	push	{r7}
 8003476:	b083      	sub	sp, #12
 8003478:	af00      	add	r7, sp, #0
 800347a:	4603      	mov	r3, r0
 800347c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800347e:	4908      	ldr	r1, [pc, #32]	; (80034a0 <NVIC_EnableIRQ+0x2c>)
 8003480:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003484:	095b      	lsrs	r3, r3, #5
 8003486:	79fa      	ldrb	r2, [r7, #7]
 8003488:	f002 021f 	and.w	r2, r2, #31
 800348c:	2001      	movs	r0, #1
 800348e:	fa00 f202 	lsl.w	r2, r0, r2
 8003492:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8003496:	370c      	adds	r7, #12
 8003498:	46bd      	mov	sp, r7
 800349a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800349e:	4770      	bx	lr
 80034a0:	e000e100 	.word	0xe000e100

080034a4 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 80034a4:	b480      	push	{r7}
 80034a6:	b083      	sub	sp, #12
 80034a8:	af00      	add	r7, sp, #0
 80034aa:	4603      	mov	r3, r0
 80034ac:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80034ae:	4909      	ldr	r1, [pc, #36]	; (80034d4 <NVIC_DisableIRQ+0x30>)
 80034b0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80034b4:	095b      	lsrs	r3, r3, #5
 80034b6:	79fa      	ldrb	r2, [r7, #7]
 80034b8:	f002 021f 	and.w	r2, r2, #31
 80034bc:	2001      	movs	r0, #1
 80034be:	fa00 f202 	lsl.w	r2, r0, r2
 80034c2:	3320      	adds	r3, #32
 80034c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80034c8:	370c      	adds	r7, #12
 80034ca:	46bd      	mov	sp, r7
 80034cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034d0:	4770      	bx	lr
 80034d2:	bf00      	nop
 80034d4:	e000e100 	.word	0xe000e100

080034d8 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80034d8:	b480      	push	{r7}
 80034da:	b083      	sub	sp, #12
 80034dc:	af00      	add	r7, sp, #0
 80034de:	4603      	mov	r3, r0
 80034e0:	6039      	str	r1, [r7, #0]
 80034e2:	71fb      	strb	r3, [r7, #7]
  if((int32_t)IRQn < 0) {
 80034e4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80034e8:	2b00      	cmp	r3, #0
 80034ea:	da0b      	bge.n	8003504 <NVIC_SetPriority+0x2c>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80034ec:	490d      	ldr	r1, [pc, #52]	; (8003524 <NVIC_SetPriority+0x4c>)
 80034ee:	79fb      	ldrb	r3, [r7, #7]
 80034f0:	f003 030f 	and.w	r3, r3, #15
 80034f4:	3b04      	subs	r3, #4
 80034f6:	683a      	ldr	r2, [r7, #0]
 80034f8:	b2d2      	uxtb	r2, r2
 80034fa:	0112      	lsls	r2, r2, #4
 80034fc:	b2d2      	uxtb	r2, r2
 80034fe:	440b      	add	r3, r1
 8003500:	761a      	strb	r2, [r3, #24]
 8003502:	e009      	b.n	8003518 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003504:	4908      	ldr	r1, [pc, #32]	; (8003528 <NVIC_SetPriority+0x50>)
 8003506:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800350a:	683a      	ldr	r2, [r7, #0]
 800350c:	b2d2      	uxtb	r2, r2
 800350e:	0112      	lsls	r2, r2, #4
 8003510:	b2d2      	uxtb	r2, r2
 8003512:	440b      	add	r3, r1
 8003514:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8003518:	370c      	adds	r7, #12
 800351a:	46bd      	mov	sp, r7
 800351c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003520:	4770      	bx	lr
 8003522:	bf00      	nop
 8003524:	e000ed00 	.word	0xe000ed00
 8003528:	e000e100 	.word	0xe000e100

0800352c <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800352c:	b480      	push	{r7}
 800352e:	b089      	sub	sp, #36	; 0x24
 8003530:	af00      	add	r7, sp, #0
 8003532:	60f8      	str	r0, [r7, #12]
 8003534:	60b9      	str	r1, [r7, #8]
 8003536:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8003538:	68fb      	ldr	r3, [r7, #12]
 800353a:	f003 0307 	and.w	r3, r3, #7
 800353e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8003540:	69fb      	ldr	r3, [r7, #28]
 8003542:	f1c3 0307 	rsb	r3, r3, #7
 8003546:	2b04      	cmp	r3, #4
 8003548:	bf28      	it	cs
 800354a:	2304      	movcs	r3, #4
 800354c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800354e:	69fb      	ldr	r3, [r7, #28]
 8003550:	3304      	adds	r3, #4
 8003552:	2b06      	cmp	r3, #6
 8003554:	d902      	bls.n	800355c <NVIC_EncodePriority+0x30>
 8003556:	69fb      	ldr	r3, [r7, #28]
 8003558:	3b03      	subs	r3, #3
 800355a:	e000      	b.n	800355e <NVIC_EncodePriority+0x32>
 800355c:	2300      	movs	r3, #0
 800355e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8003560:	69bb      	ldr	r3, [r7, #24]
 8003562:	2201      	movs	r2, #1
 8003564:	fa02 f303 	lsl.w	r3, r2, r3
 8003568:	1e5a      	subs	r2, r3, #1
 800356a:	68bb      	ldr	r3, [r7, #8]
 800356c:	401a      	ands	r2, r3
 800356e:	697b      	ldr	r3, [r7, #20]
 8003570:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8003572:	697b      	ldr	r3, [r7, #20]
 8003574:	2101      	movs	r1, #1
 8003576:	fa01 f303 	lsl.w	r3, r1, r3
 800357a:	1e59      	subs	r1, r3, #1
 800357c:	687b      	ldr	r3, [r7, #4]
 800357e:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8003580:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 8003582:	4618      	mov	r0, r3
 8003584:	3724      	adds	r7, #36	; 0x24
 8003586:	46bd      	mov	sp, r7
 8003588:	f85d 7b04 	ldr.w	r7, [sp], #4
 800358c:	4770      	bx	lr
 800358e:	bf00      	nop

08003590 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8003590:	b580      	push	{r7, lr}
 8003592:	b082      	sub	sp, #8
 8003594:	af00      	add	r7, sp, #0
 8003596:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 8003598:	687b      	ldr	r3, [r7, #4]
 800359a:	3b01      	subs	r3, #1
 800359c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80035a0:	d301      	bcc.n	80035a6 <SysTick_Config+0x16>
 80035a2:	2301      	movs	r3, #1
 80035a4:	e00f      	b.n	80035c6 <SysTick_Config+0x36>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80035a6:	4a0a      	ldr	r2, [pc, #40]	; (80035d0 <SysTick_Config+0x40>)
 80035a8:	687b      	ldr	r3, [r7, #4]
 80035aa:	3b01      	subs	r3, #1
 80035ac:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80035ae:	f04f 30ff 	mov.w	r0, #4294967295
 80035b2:	210f      	movs	r1, #15
 80035b4:	f7ff ff90 	bl	80034d8 <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80035b8:	4b05      	ldr	r3, [pc, #20]	; (80035d0 <SysTick_Config+0x40>)
 80035ba:	2200      	movs	r2, #0
 80035bc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80035be:	4b04      	ldr	r3, [pc, #16]	; (80035d0 <SysTick_Config+0x40>)
 80035c0:	2207      	movs	r2, #7
 80035c2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80035c4:	2300      	movs	r3, #0
}
 80035c6:	4618      	mov	r0, r3
 80035c8:	3708      	adds	r7, #8
 80035ca:	46bd      	mov	sp, r7
 80035cc:	bd80      	pop	{r7, pc}
 80035ce:	bf00      	nop
 80035d0:	e000e010 	.word	0xe000e010

080035d4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80035d4:	b580      	push	{r7, lr}
 80035d6:	b082      	sub	sp, #8
 80035d8:	af00      	add	r7, sp, #0
 80035da:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80035dc:	6878      	ldr	r0, [r7, #4]
 80035de:	f7ff ff17 	bl	8003410 <NVIC_SetPriorityGrouping>
}
 80035e2:	3708      	adds	r7, #8
 80035e4:	46bd      	mov	sp, r7
 80035e6:	bd80      	pop	{r7, pc}

080035e8 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80035e8:	b580      	push	{r7, lr}
 80035ea:	b086      	sub	sp, #24
 80035ec:	af00      	add	r7, sp, #0
 80035ee:	4603      	mov	r3, r0
 80035f0:	60b9      	str	r1, [r7, #8]
 80035f2:	607a      	str	r2, [r7, #4]
 80035f4:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 80035f6:	2300      	movs	r3, #0
 80035f8:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 80035fa:	f7ff ff2d 	bl	8003458 <NVIC_GetPriorityGrouping>
 80035fe:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8003600:	6978      	ldr	r0, [r7, #20]
 8003602:	68b9      	ldr	r1, [r7, #8]
 8003604:	687a      	ldr	r2, [r7, #4]
 8003606:	f7ff ff91 	bl	800352c <NVIC_EncodePriority>
 800360a:	4602      	mov	r2, r0
 800360c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8003610:	4618      	mov	r0, r3
 8003612:	4611      	mov	r1, r2
 8003614:	f7ff ff60 	bl	80034d8 <NVIC_SetPriority>
}
 8003618:	3718      	adds	r7, #24
 800361a:	46bd      	mov	sp, r7
 800361c:	bd80      	pop	{r7, pc}
 800361e:	bf00      	nop

08003620 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8003620:	b580      	push	{r7, lr}
 8003622:	b082      	sub	sp, #8
 8003624:	af00      	add	r7, sp, #0
 8003626:	4603      	mov	r3, r0
 8003628:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800362a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800362e:	4618      	mov	r0, r3
 8003630:	f7ff ff20 	bl	8003474 <NVIC_EnableIRQ>
}
 8003634:	3708      	adds	r7, #8
 8003636:	46bd      	mov	sp, r7
 8003638:	bd80      	pop	{r7, pc}
 800363a:	bf00      	nop

0800363c <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800363c:	b580      	push	{r7, lr}
 800363e:	b082      	sub	sp, #8
 8003640:	af00      	add	r7, sp, #0
 8003642:	4603      	mov	r3, r0
 8003644:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 8003646:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800364a:	4618      	mov	r0, r3
 800364c:	f7ff ff2a 	bl	80034a4 <NVIC_DisableIRQ>
}
 8003650:	3708      	adds	r7, #8
 8003652:	46bd      	mov	sp, r7
 8003654:	bd80      	pop	{r7, pc}
 8003656:	bf00      	nop

08003658 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8003658:	b580      	push	{r7, lr}
 800365a:	b082      	sub	sp, #8
 800365c:	af00      	add	r7, sp, #0
 800365e:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8003660:	6878      	ldr	r0, [r7, #4]
 8003662:	f7ff ff95 	bl	8003590 <SysTick_Config>
 8003666:	4603      	mov	r3, r0
}
 8003668:	4618      	mov	r0, r3
 800366a:	3708      	adds	r7, #8
 800366c:	46bd      	mov	sp, r7
 800366e:	bd80      	pop	{r7, pc}

08003670 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init: Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8003670:	b480      	push	{r7}
 8003672:	b083      	sub	sp, #12
 8003674:	af00      	add	r7, sp, #0
 8003676:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8003678:	4a1d      	ldr	r2, [pc, #116]	; (80036f0 <HAL_MPU_ConfigRegion+0x80>)
 800367a:	687b      	ldr	r3, [r7, #4]
 800367c:	785b      	ldrb	r3, [r3, #1]
 800367e:	6093      	str	r3, [r2, #8]

  if ((MPU_Init->Enable) != RESET)
 8003680:	687b      	ldr	r3, [r7, #4]
 8003682:	781b      	ldrb	r3, [r3, #0]
 8003684:	2b00      	cmp	r3, #0
 8003686:	d028      	beq.n	80036da <HAL_MPU_ConfigRegion+0x6a>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
 8003688:	4a19      	ldr	r2, [pc, #100]	; (80036f0 <HAL_MPU_ConfigRegion+0x80>)
 800368a:	687b      	ldr	r3, [r7, #4]
 800368c:	685b      	ldr	r3, [r3, #4]
 800368e:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8003690:	4917      	ldr	r1, [pc, #92]	; (80036f0 <HAL_MPU_ConfigRegion+0x80>)
 8003692:	687b      	ldr	r3, [r7, #4]
 8003694:	7b1b      	ldrb	r3, [r3, #12]
 8003696:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8003698:	687b      	ldr	r3, [r7, #4]
 800369a:	7adb      	ldrb	r3, [r3, #11]
 800369c:	061b      	lsls	r3, r3, #24
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800369e:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80036a0:	687b      	ldr	r3, [r7, #4]
 80036a2:	7a9b      	ldrb	r3, [r3, #10]
 80036a4:	04db      	lsls	r3, r3, #19
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80036a6:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80036a8:	687b      	ldr	r3, [r7, #4]
 80036aa:	7b5b      	ldrb	r3, [r3, #13]
 80036ac:	049b      	lsls	r3, r3, #18
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80036ae:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 80036b0:	687b      	ldr	r3, [r7, #4]
 80036b2:	7b9b      	ldrb	r3, [r3, #14]
 80036b4:	045b      	lsls	r3, r3, #17
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80036b6:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 80036b8:	687b      	ldr	r3, [r7, #4]
 80036ba:	7bdb      	ldrb	r3, [r3, #15]
 80036bc:	041b      	lsls	r3, r3, #16
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 80036be:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 80036c0:	687b      	ldr	r3, [r7, #4]
 80036c2:	7a5b      	ldrb	r3, [r3, #9]
 80036c4:	021b      	lsls	r3, r3, #8
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 80036c6:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80036c8:	687b      	ldr	r3, [r7, #4]
 80036ca:	7a1b      	ldrb	r3, [r3, #8]
 80036cc:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 80036ce:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 80036d0:	687a      	ldr	r2, [r7, #4]
 80036d2:	7812      	ldrb	r2, [r2, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80036d4:	4313      	orrs	r3, r2
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80036d6:	610b      	str	r3, [r1, #16]
 80036d8:	e005      	b.n	80036e6 <HAL_MPU_ConfigRegion+0x76>
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 80036da:	4b05      	ldr	r3, [pc, #20]	; (80036f0 <HAL_MPU_ConfigRegion+0x80>)
 80036dc:	2200      	movs	r2, #0
 80036de:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
 80036e0:	4b03      	ldr	r3, [pc, #12]	; (80036f0 <HAL_MPU_ConfigRegion+0x80>)
 80036e2:	2200      	movs	r2, #0
 80036e4:	611a      	str	r2, [r3, #16]
  }
}
 80036e6:	370c      	adds	r7, #12
 80036e8:	46bd      	mov	sp, r7
 80036ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80036ee:	4770      	bx	lr
 80036f0:	e000ed90 	.word	0xe000ed90

080036f4 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80036f4:	b480      	push	{r7}
 80036f6:	b085      	sub	sp, #20
 80036f8:	af00      	add	r7, sp, #0
 80036fa:	60f8      	str	r0, [r7, #12]
 80036fc:	60b9      	str	r1, [r7, #8]
 80036fe:	607a      	str	r2, [r7, #4]
 8003700:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8003702:	68fb      	ldr	r3, [r7, #12]
 8003704:	681b      	ldr	r3, [r3, #0]
 8003706:	68fa      	ldr	r2, [r7, #12]
 8003708:	6812      	ldr	r2, [r2, #0]
 800370a:	6812      	ldr	r2, [r2, #0]
 800370c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003710:	601a      	str	r2, [r3, #0]
	
  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 8003712:	68fb      	ldr	r3, [r7, #12]
 8003714:	681b      	ldr	r3, [r3, #0]
 8003716:	683a      	ldr	r2, [r7, #0]
 8003718:	605a      	str	r2, [r3, #4]

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800371a:	68fb      	ldr	r3, [r7, #12]
 800371c:	689b      	ldr	r3, [r3, #8]
 800371e:	2b40      	cmp	r3, #64	; 0x40
 8003720:	d108      	bne.n	8003734 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 8003722:	68fb      	ldr	r3, [r7, #12]
 8003724:	681b      	ldr	r3, [r3, #0]
 8003726:	687a      	ldr	r2, [r7, #4]
 8003728:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 800372a:	68fb      	ldr	r3, [r7, #12]
 800372c:	681b      	ldr	r3, [r3, #0]
 800372e:	68ba      	ldr	r2, [r7, #8]
 8003730:	60da      	str	r2, [r3, #12]
 8003732:	e007      	b.n	8003744 <DMA_SetConfig+0x50>
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Stream source address */
    hdma->Instance->PAR = SrcAddress;
 8003734:	68fb      	ldr	r3, [r7, #12]
 8003736:	681b      	ldr	r3, [r3, #0]
 8003738:	68ba      	ldr	r2, [r7, #8]
 800373a:	609a      	str	r2, [r3, #8]
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
 800373c:	68fb      	ldr	r3, [r7, #12]
 800373e:	681b      	ldr	r3, [r3, #0]
 8003740:	687a      	ldr	r2, [r7, #4]
 8003742:	60da      	str	r2, [r3, #12]
  }
}
 8003744:	3714      	adds	r7, #20
 8003746:	46bd      	mov	sp, r7
 8003748:	f85d 7b04 	ldr.w	r7, [sp], #4
 800374c:	4770      	bx	lr
 800374e:	bf00      	nop

08003750 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 8003750:	b480      	push	{r7}
 8003752:	b085      	sub	sp, #20
 8003754:	af00      	add	r7, sp, #0
 8003756:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8003758:	2300      	movs	r3, #0
 800375a:	60fb      	str	r3, [r7, #12]
  
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 800375c:	687b      	ldr	r3, [r7, #4]
 800375e:	2b00      	cmp	r3, #0
 8003760:	d101      	bne.n	8003766 <HAL_DMA_Init+0x16>
  {
    return HAL_ERROR;
 8003762:	2301      	movs	r3, #1
 8003764:	e057      	b.n	8003816 <HAL_DMA_Init+0xc6>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8003766:	687b      	ldr	r3, [r7, #4]
 8003768:	2202      	movs	r2, #2
 800376a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 800376e:	687b      	ldr	r3, [r7, #4]
 8003770:	681b      	ldr	r3, [r3, #0]
 8003772:	681b      	ldr	r3, [r3, #0]
 8003774:	60fb      	str	r3, [r7, #12]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8003776:	68fa      	ldr	r2, [r7, #12]
 8003778:	4b2a      	ldr	r3, [pc, #168]	; (8003824 <HAL_DMA_Init+0xd4>)
 800377a:	4013      	ands	r3, r2
 800377c:	60fb      	str	r3, [r7, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800377e:	687b      	ldr	r3, [r7, #4]
 8003780:	685a      	ldr	r2, [r3, #4]
 8003782:	687b      	ldr	r3, [r7, #4]
 8003784:	689b      	ldr	r3, [r3, #8]
 8003786:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8003788:	687b      	ldr	r3, [r7, #4]
 800378a:	68db      	ldr	r3, [r3, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800378c:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800378e:	687b      	ldr	r3, [r7, #4]
 8003790:	691b      	ldr	r3, [r3, #16]
 8003792:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8003794:	687b      	ldr	r3, [r7, #4]
 8003796:	695b      	ldr	r3, [r3, #20]
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8003798:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800379a:	687b      	ldr	r3, [r7, #4]
 800379c:	699b      	ldr	r3, [r3, #24]
 800379e:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 80037a0:	687b      	ldr	r3, [r7, #4]
 80037a2:	69db      	ldr	r3, [r3, #28]
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80037a4:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 80037a6:	687b      	ldr	r3, [r7, #4]
 80037a8:	6a1b      	ldr	r3, [r3, #32]
 80037aa:	4313      	orrs	r3, r2
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80037ac:	68fa      	ldr	r2, [r7, #12]
 80037ae:	4313      	orrs	r3, r2
 80037b0:	60fb      	str	r3, [r7, #12]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80037b2:	687b      	ldr	r3, [r7, #4]
 80037b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80037b6:	2b04      	cmp	r3, #4
 80037b8:	d107      	bne.n	80037ca <HAL_DMA_Init+0x7a>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80037ba:	687b      	ldr	r3, [r7, #4]
 80037bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80037be:	687b      	ldr	r3, [r7, #4]
 80037c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80037c2:	4313      	orrs	r3, r2
 80037c4:	68fa      	ldr	r2, [r7, #12]
 80037c6:	4313      	orrs	r3, r2
 80037c8:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 80037ca:	687b      	ldr	r3, [r7, #4]
 80037cc:	681b      	ldr	r3, [r3, #0]
 80037ce:	68fa      	ldr	r2, [r7, #12]
 80037d0:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 80037d2:	687b      	ldr	r3, [r7, #4]
 80037d4:	681b      	ldr	r3, [r3, #0]
 80037d6:	695b      	ldr	r3, [r3, #20]
 80037d8:	60fb      	str	r3, [r7, #12]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80037da:	68fb      	ldr	r3, [r7, #12]
 80037dc:	f023 0307 	bic.w	r3, r3, #7
 80037e0:	60fb      	str	r3, [r7, #12]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 80037e2:	687b      	ldr	r3, [r7, #4]
 80037e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80037e6:	68fa      	ldr	r2, [r7, #12]
 80037e8:	4313      	orrs	r3, r2
 80037ea:	60fb      	str	r3, [r7, #12]

  /* the FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80037ec:	687b      	ldr	r3, [r7, #4]
 80037ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80037f0:	2b04      	cmp	r3, #4
 80037f2:	d104      	bne.n	80037fe <HAL_DMA_Init+0xae>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 80037f4:	687b      	ldr	r3, [r7, #4]
 80037f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80037f8:	68fa      	ldr	r2, [r7, #12]
 80037fa:	4313      	orrs	r3, r2
 80037fc:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 80037fe:	687b      	ldr	r3, [r7, #4]
 8003800:	681b      	ldr	r3, [r3, #0]
 8003802:	68fa      	ldr	r2, [r7, #12]
 8003804:	615a      	str	r2, [r3, #20]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003806:	687b      	ldr	r3, [r7, #4]
 8003808:	2200      	movs	r2, #0
 800380a:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 800380c:	687b      	ldr	r3, [r7, #4]
 800380e:	2201      	movs	r2, #1
 8003810:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 8003814:	2300      	movs	r3, #0
}
 8003816:	4618      	mov	r0, r3
 8003818:	3714      	adds	r7, #20
 800381a:	46bd      	mov	sp, r7
 800381c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003820:	4770      	bx	lr
 8003822:	bf00      	nop
 8003824:	f010803f 	.word	0xf010803f

08003828 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 8003828:	b480      	push	{r7}
 800382a:	b083      	sub	sp, #12
 800382c:	af00      	add	r7, sp, #0
 800382e:	6078      	str	r0, [r7, #4]
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8003830:	687b      	ldr	r3, [r7, #4]
 8003832:	2b00      	cmp	r3, #0
 8003834:	d102      	bne.n	800383c <HAL_DMA_DeInit+0x14>
  {
    return HAL_ERROR;
 8003836:	2301      	movs	r3, #1
 8003838:	f001 b9f5 	b.w	8004c26 <HAL_DMA_DeInit+0x13fe>
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 800383c:	687b      	ldr	r3, [r7, #4]
 800383e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8003842:	b2db      	uxtb	r3, r3
 8003844:	2b02      	cmp	r3, #2
 8003846:	d102      	bne.n	800384e <HAL_DMA_DeInit+0x26>
  {
     return HAL_ERROR;
 8003848:	2301      	movs	r3, #1
 800384a:	f001 b9ec 	b.w	8004c26 <HAL_DMA_DeInit+0x13fe>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
 800384e:	687b      	ldr	r3, [r7, #4]
 8003850:	681b      	ldr	r3, [r3, #0]
 8003852:	687a      	ldr	r2, [r7, #4]
 8003854:	6812      	ldr	r2, [r2, #0]
 8003856:	6812      	ldr	r2, [r2, #0]
 8003858:	f022 0201 	bic.w	r2, r2, #1
 800385c:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0;
 800385e:	687b      	ldr	r3, [r7, #4]
 8003860:	681b      	ldr	r3, [r3, #0]
 8003862:	2200      	movs	r2, #0
 8003864:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0;
 8003866:	687b      	ldr	r3, [r7, #4]
 8003868:	681b      	ldr	r3, [r3, #0]
 800386a:	2200      	movs	r2, #0
 800386c:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0;
 800386e:	687b      	ldr	r3, [r7, #4]
 8003870:	681b      	ldr	r3, [r3, #0]
 8003872:	2200      	movs	r2, #0
 8003874:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0;
 8003876:	687b      	ldr	r3, [r7, #4]
 8003878:	681b      	ldr	r3, [r3, #0]
 800387a:	2200      	movs	r2, #0
 800387c:	60da      	str	r2, [r3, #12]

  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0;
 800387e:	687b      	ldr	r3, [r7, #4]
 8003880:	681b      	ldr	r3, [r3, #0]
 8003882:	2200      	movs	r2, #0
 8003884:	611a      	str	r2, [r3, #16]

  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021;
 8003886:	687b      	ldr	r3, [r7, #4]
 8003888:	681b      	ldr	r3, [r3, #0]
 800388a:	2221      	movs	r2, #33	; 0x21
 800388c:	615a      	str	r2, [r3, #20]

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 800388e:	687b      	ldr	r3, [r7, #4]
 8003890:	681b      	ldr	r3, [r3, #0]
 8003892:	461a      	mov	r2, r3
 8003894:	4b9c      	ldr	r3, [pc, #624]	; (8003b08 <HAL_DMA_DeInit+0x2e0>)
 8003896:	429a      	cmp	r2, r3
 8003898:	d96c      	bls.n	8003974 <HAL_DMA_DeInit+0x14c>
 800389a:	4a9c      	ldr	r2, [pc, #624]	; (8003b0c <HAL_DMA_DeInit+0x2e4>)
 800389c:	687b      	ldr	r3, [r7, #4]
 800389e:	681b      	ldr	r3, [r3, #0]
 80038a0:	4619      	mov	r1, r3
 80038a2:	4b9b      	ldr	r3, [pc, #620]	; (8003b10 <HAL_DMA_DeInit+0x2e8>)
 80038a4:	4299      	cmp	r1, r3
 80038a6:	d062      	beq.n	800396e <HAL_DMA_DeInit+0x146>
 80038a8:	687b      	ldr	r3, [r7, #4]
 80038aa:	681b      	ldr	r3, [r3, #0]
 80038ac:	4619      	mov	r1, r3
 80038ae:	4b99      	ldr	r3, [pc, #612]	; (8003b14 <HAL_DMA_DeInit+0x2ec>)
 80038b0:	4299      	cmp	r1, r3
 80038b2:	d05a      	beq.n	800396a <HAL_DMA_DeInit+0x142>
 80038b4:	687b      	ldr	r3, [r7, #4]
 80038b6:	681b      	ldr	r3, [r3, #0]
 80038b8:	4619      	mov	r1, r3
 80038ba:	4b97      	ldr	r3, [pc, #604]	; (8003b18 <HAL_DMA_DeInit+0x2f0>)
 80038bc:	4299      	cmp	r1, r3
 80038be:	d052      	beq.n	8003966 <HAL_DMA_DeInit+0x13e>
 80038c0:	687b      	ldr	r3, [r7, #4]
 80038c2:	681b      	ldr	r3, [r3, #0]
 80038c4:	4619      	mov	r1, r3
 80038c6:	4b95      	ldr	r3, [pc, #596]	; (8003b1c <HAL_DMA_DeInit+0x2f4>)
 80038c8:	4299      	cmp	r1, r3
 80038ca:	d04a      	beq.n	8003962 <HAL_DMA_DeInit+0x13a>
 80038cc:	687b      	ldr	r3, [r7, #4]
 80038ce:	681b      	ldr	r3, [r3, #0]
 80038d0:	4619      	mov	r1, r3
 80038d2:	4b93      	ldr	r3, [pc, #588]	; (8003b20 <HAL_DMA_DeInit+0x2f8>)
 80038d4:	4299      	cmp	r1, r3
 80038d6:	d041      	beq.n	800395c <HAL_DMA_DeInit+0x134>
 80038d8:	687b      	ldr	r3, [r7, #4]
 80038da:	681b      	ldr	r3, [r3, #0]
 80038dc:	4619      	mov	r1, r3
 80038de:	4b91      	ldr	r3, [pc, #580]	; (8003b24 <HAL_DMA_DeInit+0x2fc>)
 80038e0:	4299      	cmp	r1, r3
 80038e2:	d038      	beq.n	8003956 <HAL_DMA_DeInit+0x12e>
 80038e4:	687b      	ldr	r3, [r7, #4]
 80038e6:	681b      	ldr	r3, [r3, #0]
 80038e8:	4619      	mov	r1, r3
 80038ea:	4b8f      	ldr	r3, [pc, #572]	; (8003b28 <HAL_DMA_DeInit+0x300>)
 80038ec:	4299      	cmp	r1, r3
 80038ee:	d02f      	beq.n	8003950 <HAL_DMA_DeInit+0x128>
 80038f0:	687b      	ldr	r3, [r7, #4]
 80038f2:	681b      	ldr	r3, [r3, #0]
 80038f4:	4619      	mov	r1, r3
 80038f6:	4b8d      	ldr	r3, [pc, #564]	; (8003b2c <HAL_DMA_DeInit+0x304>)
 80038f8:	4299      	cmp	r1, r3
 80038fa:	d026      	beq.n	800394a <HAL_DMA_DeInit+0x122>
 80038fc:	687b      	ldr	r3, [r7, #4]
 80038fe:	681b      	ldr	r3, [r3, #0]
 8003900:	4619      	mov	r1, r3
 8003902:	4b8b      	ldr	r3, [pc, #556]	; (8003b30 <HAL_DMA_DeInit+0x308>)
 8003904:	4299      	cmp	r1, r3
 8003906:	d01d      	beq.n	8003944 <HAL_DMA_DeInit+0x11c>
 8003908:	687b      	ldr	r3, [r7, #4]
 800390a:	681b      	ldr	r3, [r3, #0]
 800390c:	4619      	mov	r1, r3
 800390e:	4b89      	ldr	r3, [pc, #548]	; (8003b34 <HAL_DMA_DeInit+0x30c>)
 8003910:	4299      	cmp	r1, r3
 8003912:	d014      	beq.n	800393e <HAL_DMA_DeInit+0x116>
 8003914:	687b      	ldr	r3, [r7, #4]
 8003916:	681b      	ldr	r3, [r3, #0]
 8003918:	4619      	mov	r1, r3
 800391a:	4b87      	ldr	r3, [pc, #540]	; (8003b38 <HAL_DMA_DeInit+0x310>)
 800391c:	4299      	cmp	r1, r3
 800391e:	d00b      	beq.n	8003938 <HAL_DMA_DeInit+0x110>
 8003920:	687b      	ldr	r3, [r7, #4]
 8003922:	681b      	ldr	r3, [r3, #0]
 8003924:	4619      	mov	r1, r3
 8003926:	4b85      	ldr	r3, [pc, #532]	; (8003b3c <HAL_DMA_DeInit+0x314>)
 8003928:	4299      	cmp	r1, r3
 800392a:	d102      	bne.n	8003932 <HAL_DMA_DeInit+0x10a>
 800392c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003930:	e01e      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 8003932:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003936:	e01b      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 8003938:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800393c:	e018      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 800393e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003942:	e015      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 8003944:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003948:	e012      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 800394a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800394e:	e00f      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 8003950:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003954:	e00c      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 8003956:	f44f 7380 	mov.w	r3, #256	; 0x100
 800395a:	e009      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 800395c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003960:	e006      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 8003962:	4b77      	ldr	r3, [pc, #476]	; (8003b40 <HAL_DMA_DeInit+0x318>)
 8003964:	e004      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 8003966:	4b76      	ldr	r3, [pc, #472]	; (8003b40 <HAL_DMA_DeInit+0x318>)
 8003968:	e002      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 800396a:	4b75      	ldr	r3, [pc, #468]	; (8003b40 <HAL_DMA_DeInit+0x318>)
 800396c:	e000      	b.n	8003970 <HAL_DMA_DeInit+0x148>
 800396e:	4b74      	ldr	r3, [pc, #464]	; (8003b40 <HAL_DMA_DeInit+0x318>)
 8003970:	60d3      	str	r3, [r2, #12]
 8003972:	e177      	b.n	8003c64 <HAL_DMA_DeInit+0x43c>
 8003974:	687b      	ldr	r3, [r7, #4]
 8003976:	681b      	ldr	r3, [r3, #0]
 8003978:	461a      	mov	r2, r3
 800397a:	4b72      	ldr	r3, [pc, #456]	; (8003b44 <HAL_DMA_DeInit+0x31c>)
 800397c:	429a      	cmp	r2, r3
 800397e:	d96c      	bls.n	8003a5a <HAL_DMA_DeInit+0x232>
 8003980:	4a62      	ldr	r2, [pc, #392]	; (8003b0c <HAL_DMA_DeInit+0x2e4>)
 8003982:	687b      	ldr	r3, [r7, #4]
 8003984:	681b      	ldr	r3, [r3, #0]
 8003986:	4619      	mov	r1, r3
 8003988:	4b61      	ldr	r3, [pc, #388]	; (8003b10 <HAL_DMA_DeInit+0x2e8>)
 800398a:	4299      	cmp	r1, r3
 800398c:	d062      	beq.n	8003a54 <HAL_DMA_DeInit+0x22c>
 800398e:	687b      	ldr	r3, [r7, #4]
 8003990:	681b      	ldr	r3, [r3, #0]
 8003992:	4619      	mov	r1, r3
 8003994:	4b5f      	ldr	r3, [pc, #380]	; (8003b14 <HAL_DMA_DeInit+0x2ec>)
 8003996:	4299      	cmp	r1, r3
 8003998:	d05a      	beq.n	8003a50 <HAL_DMA_DeInit+0x228>
 800399a:	687b      	ldr	r3, [r7, #4]
 800399c:	681b      	ldr	r3, [r3, #0]
 800399e:	4619      	mov	r1, r3
 80039a0:	4b5d      	ldr	r3, [pc, #372]	; (8003b18 <HAL_DMA_DeInit+0x2f0>)
 80039a2:	4299      	cmp	r1, r3
 80039a4:	d052      	beq.n	8003a4c <HAL_DMA_DeInit+0x224>
 80039a6:	687b      	ldr	r3, [r7, #4]
 80039a8:	681b      	ldr	r3, [r3, #0]
 80039aa:	4619      	mov	r1, r3
 80039ac:	4b5b      	ldr	r3, [pc, #364]	; (8003b1c <HAL_DMA_DeInit+0x2f4>)
 80039ae:	4299      	cmp	r1, r3
 80039b0:	d04a      	beq.n	8003a48 <HAL_DMA_DeInit+0x220>
 80039b2:	687b      	ldr	r3, [r7, #4]
 80039b4:	681b      	ldr	r3, [r3, #0]
 80039b6:	4619      	mov	r1, r3
 80039b8:	4b59      	ldr	r3, [pc, #356]	; (8003b20 <HAL_DMA_DeInit+0x2f8>)
 80039ba:	4299      	cmp	r1, r3
 80039bc:	d041      	beq.n	8003a42 <HAL_DMA_DeInit+0x21a>
 80039be:	687b      	ldr	r3, [r7, #4]
 80039c0:	681b      	ldr	r3, [r3, #0]
 80039c2:	4619      	mov	r1, r3
 80039c4:	4b57      	ldr	r3, [pc, #348]	; (8003b24 <HAL_DMA_DeInit+0x2fc>)
 80039c6:	4299      	cmp	r1, r3
 80039c8:	d038      	beq.n	8003a3c <HAL_DMA_DeInit+0x214>
 80039ca:	687b      	ldr	r3, [r7, #4]
 80039cc:	681b      	ldr	r3, [r3, #0]
 80039ce:	4619      	mov	r1, r3
 80039d0:	4b55      	ldr	r3, [pc, #340]	; (8003b28 <HAL_DMA_DeInit+0x300>)
 80039d2:	4299      	cmp	r1, r3
 80039d4:	d02f      	beq.n	8003a36 <HAL_DMA_DeInit+0x20e>
 80039d6:	687b      	ldr	r3, [r7, #4]
 80039d8:	681b      	ldr	r3, [r3, #0]
 80039da:	4619      	mov	r1, r3
 80039dc:	4b53      	ldr	r3, [pc, #332]	; (8003b2c <HAL_DMA_DeInit+0x304>)
 80039de:	4299      	cmp	r1, r3
 80039e0:	d026      	beq.n	8003a30 <HAL_DMA_DeInit+0x208>
 80039e2:	687b      	ldr	r3, [r7, #4]
 80039e4:	681b      	ldr	r3, [r3, #0]
 80039e6:	4619      	mov	r1, r3
 80039e8:	4b51      	ldr	r3, [pc, #324]	; (8003b30 <HAL_DMA_DeInit+0x308>)
 80039ea:	4299      	cmp	r1, r3
 80039ec:	d01d      	beq.n	8003a2a <HAL_DMA_DeInit+0x202>
 80039ee:	687b      	ldr	r3, [r7, #4]
 80039f0:	681b      	ldr	r3, [r3, #0]
 80039f2:	4619      	mov	r1, r3
 80039f4:	4b4f      	ldr	r3, [pc, #316]	; (8003b34 <HAL_DMA_DeInit+0x30c>)
 80039f6:	4299      	cmp	r1, r3
 80039f8:	d014      	beq.n	8003a24 <HAL_DMA_DeInit+0x1fc>
 80039fa:	687b      	ldr	r3, [r7, #4]
 80039fc:	681b      	ldr	r3, [r3, #0]
 80039fe:	4619      	mov	r1, r3
 8003a00:	4b4d      	ldr	r3, [pc, #308]	; (8003b38 <HAL_DMA_DeInit+0x310>)
 8003a02:	4299      	cmp	r1, r3
 8003a04:	d00b      	beq.n	8003a1e <HAL_DMA_DeInit+0x1f6>
 8003a06:	687b      	ldr	r3, [r7, #4]
 8003a08:	681b      	ldr	r3, [r3, #0]
 8003a0a:	4619      	mov	r1, r3
 8003a0c:	4b4b      	ldr	r3, [pc, #300]	; (8003b3c <HAL_DMA_DeInit+0x314>)
 8003a0e:	4299      	cmp	r1, r3
 8003a10:	d102      	bne.n	8003a18 <HAL_DMA_DeInit+0x1f0>
 8003a12:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003a16:	e01e      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a18:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003a1c:	e01b      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a1e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003a22:	e018      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a24:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003a28:	e015      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a2a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003a2e:	e012      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a30:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003a34:	e00f      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a36:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003a3a:	e00c      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a3c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003a40:	e009      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a42:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003a46:	e006      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a48:	4b3d      	ldr	r3, [pc, #244]	; (8003b40 <HAL_DMA_DeInit+0x318>)
 8003a4a:	e004      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a4c:	4b3c      	ldr	r3, [pc, #240]	; (8003b40 <HAL_DMA_DeInit+0x318>)
 8003a4e:	e002      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a50:	4b3b      	ldr	r3, [pc, #236]	; (8003b40 <HAL_DMA_DeInit+0x318>)
 8003a52:	e000      	b.n	8003a56 <HAL_DMA_DeInit+0x22e>
 8003a54:	4b3a      	ldr	r3, [pc, #232]	; (8003b40 <HAL_DMA_DeInit+0x318>)
 8003a56:	6093      	str	r3, [r2, #8]
 8003a58:	e104      	b.n	8003c64 <HAL_DMA_DeInit+0x43c>
 8003a5a:	687b      	ldr	r3, [r7, #4]
 8003a5c:	681b      	ldr	r3, [r3, #0]
 8003a5e:	461a      	mov	r2, r3
 8003a60:	4b39      	ldr	r3, [pc, #228]	; (8003b48 <HAL_DMA_DeInit+0x320>)
 8003a62:	429a      	cmp	r2, r3
 8003a64:	f240 8092 	bls.w	8003b8c <HAL_DMA_DeInit+0x364>
 8003a68:	4a38      	ldr	r2, [pc, #224]	; (8003b4c <HAL_DMA_DeInit+0x324>)
 8003a6a:	687b      	ldr	r3, [r7, #4]
 8003a6c:	681b      	ldr	r3, [r3, #0]
 8003a6e:	4619      	mov	r1, r3
 8003a70:	4b27      	ldr	r3, [pc, #156]	; (8003b10 <HAL_DMA_DeInit+0x2e8>)
 8003a72:	4299      	cmp	r1, r3
 8003a74:	f000 8087 	beq.w	8003b86 <HAL_DMA_DeInit+0x35e>
 8003a78:	687b      	ldr	r3, [r7, #4]
 8003a7a:	681b      	ldr	r3, [r3, #0]
 8003a7c:	4619      	mov	r1, r3
 8003a7e:	4b25      	ldr	r3, [pc, #148]	; (8003b14 <HAL_DMA_DeInit+0x2ec>)
 8003a80:	4299      	cmp	r1, r3
 8003a82:	d07e      	beq.n	8003b82 <HAL_DMA_DeInit+0x35a>
 8003a84:	687b      	ldr	r3, [r7, #4]
 8003a86:	681b      	ldr	r3, [r3, #0]
 8003a88:	4619      	mov	r1, r3
 8003a8a:	4b23      	ldr	r3, [pc, #140]	; (8003b18 <HAL_DMA_DeInit+0x2f0>)
 8003a8c:	4299      	cmp	r1, r3
 8003a8e:	d076      	beq.n	8003b7e <HAL_DMA_DeInit+0x356>
 8003a90:	687b      	ldr	r3, [r7, #4]
 8003a92:	681b      	ldr	r3, [r3, #0]
 8003a94:	4619      	mov	r1, r3
 8003a96:	4b21      	ldr	r3, [pc, #132]	; (8003b1c <HAL_DMA_DeInit+0x2f4>)
 8003a98:	4299      	cmp	r1, r3
 8003a9a:	d06e      	beq.n	8003b7a <HAL_DMA_DeInit+0x352>
 8003a9c:	687b      	ldr	r3, [r7, #4]
 8003a9e:	681b      	ldr	r3, [r3, #0]
 8003aa0:	4619      	mov	r1, r3
 8003aa2:	4b1f      	ldr	r3, [pc, #124]	; (8003b20 <HAL_DMA_DeInit+0x2f8>)
 8003aa4:	4299      	cmp	r1, r3
 8003aa6:	d065      	beq.n	8003b74 <HAL_DMA_DeInit+0x34c>
 8003aa8:	687b      	ldr	r3, [r7, #4]
 8003aaa:	681b      	ldr	r3, [r3, #0]
 8003aac:	4619      	mov	r1, r3
 8003aae:	4b1d      	ldr	r3, [pc, #116]	; (8003b24 <HAL_DMA_DeInit+0x2fc>)
 8003ab0:	4299      	cmp	r1, r3
 8003ab2:	d05c      	beq.n	8003b6e <HAL_DMA_DeInit+0x346>
 8003ab4:	687b      	ldr	r3, [r7, #4]
 8003ab6:	681b      	ldr	r3, [r3, #0]
 8003ab8:	4619      	mov	r1, r3
 8003aba:	4b1b      	ldr	r3, [pc, #108]	; (8003b28 <HAL_DMA_DeInit+0x300>)
 8003abc:	4299      	cmp	r1, r3
 8003abe:	d053      	beq.n	8003b68 <HAL_DMA_DeInit+0x340>
 8003ac0:	687b      	ldr	r3, [r7, #4]
 8003ac2:	681b      	ldr	r3, [r3, #0]
 8003ac4:	4619      	mov	r1, r3
 8003ac6:	4b19      	ldr	r3, [pc, #100]	; (8003b2c <HAL_DMA_DeInit+0x304>)
 8003ac8:	4299      	cmp	r1, r3
 8003aca:	d04a      	beq.n	8003b62 <HAL_DMA_DeInit+0x33a>
 8003acc:	687b      	ldr	r3, [r7, #4]
 8003ace:	681b      	ldr	r3, [r3, #0]
 8003ad0:	4619      	mov	r1, r3
 8003ad2:	4b17      	ldr	r3, [pc, #92]	; (8003b30 <HAL_DMA_DeInit+0x308>)
 8003ad4:	4299      	cmp	r1, r3
 8003ad6:	d041      	beq.n	8003b5c <HAL_DMA_DeInit+0x334>
 8003ad8:	687b      	ldr	r3, [r7, #4]
 8003ada:	681b      	ldr	r3, [r3, #0]
 8003adc:	4619      	mov	r1, r3
 8003ade:	4b15      	ldr	r3, [pc, #84]	; (8003b34 <HAL_DMA_DeInit+0x30c>)
 8003ae0:	4299      	cmp	r1, r3
 8003ae2:	d038      	beq.n	8003b56 <HAL_DMA_DeInit+0x32e>
 8003ae4:	687b      	ldr	r3, [r7, #4]
 8003ae6:	681b      	ldr	r3, [r3, #0]
 8003ae8:	4619      	mov	r1, r3
 8003aea:	4b13      	ldr	r3, [pc, #76]	; (8003b38 <HAL_DMA_DeInit+0x310>)
 8003aec:	4299      	cmp	r1, r3
 8003aee:	d02f      	beq.n	8003b50 <HAL_DMA_DeInit+0x328>
 8003af0:	687b      	ldr	r3, [r7, #4]
 8003af2:	681b      	ldr	r3, [r3, #0]
 8003af4:	4619      	mov	r1, r3
 8003af6:	4b11      	ldr	r3, [pc, #68]	; (8003b3c <HAL_DMA_DeInit+0x314>)
 8003af8:	4299      	cmp	r1, r3
 8003afa:	d102      	bne.n	8003b02 <HAL_DMA_DeInit+0x2da>
 8003afc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003b00:	e042      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b02:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003b06:	e03f      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b08:	40026458 	.word	0x40026458
 8003b0c:	40026400 	.word	0x40026400
 8003b10:	40026010 	.word	0x40026010
 8003b14:	40026410 	.word	0x40026410
 8003b18:	40026070 	.word	0x40026070
 8003b1c:	40026470 	.word	0x40026470
 8003b20:	40026028 	.word	0x40026028
 8003b24:	40026428 	.word	0x40026428
 8003b28:	40026088 	.word	0x40026088
 8003b2c:	40026488 	.word	0x40026488
 8003b30:	40026040 	.word	0x40026040
 8003b34:	40026440 	.word	0x40026440
 8003b38:	400260a0 	.word	0x400260a0
 8003b3c:	400264a0 	.word	0x400264a0
 8003b40:	00800004 	.word	0x00800004
 8003b44:	400260b8 	.word	0x400260b8
 8003b48:	40026058 	.word	0x40026058
 8003b4c:	40026000 	.word	0x40026000
 8003b50:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003b54:	e018      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b56:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003b5a:	e015      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b5c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003b60:	e012      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b62:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003b66:	e00f      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b68:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003b6c:	e00c      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b6e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003b72:	e009      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b74:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003b78:	e006      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b7a:	4b74      	ldr	r3, [pc, #464]	; (8003d4c <HAL_DMA_DeInit+0x524>)
 8003b7c:	e004      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b7e:	4b73      	ldr	r3, [pc, #460]	; (8003d4c <HAL_DMA_DeInit+0x524>)
 8003b80:	e002      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b82:	4b72      	ldr	r3, [pc, #456]	; (8003d4c <HAL_DMA_DeInit+0x524>)
 8003b84:	e000      	b.n	8003b88 <HAL_DMA_DeInit+0x360>
 8003b86:	4b71      	ldr	r3, [pc, #452]	; (8003d4c <HAL_DMA_DeInit+0x524>)
 8003b88:	60d3      	str	r3, [r2, #12]
 8003b8a:	e06b      	b.n	8003c64 <HAL_DMA_DeInit+0x43c>
 8003b8c:	4a70      	ldr	r2, [pc, #448]	; (8003d50 <HAL_DMA_DeInit+0x528>)
 8003b8e:	687b      	ldr	r3, [r7, #4]
 8003b90:	681b      	ldr	r3, [r3, #0]
 8003b92:	4619      	mov	r1, r3
 8003b94:	4b6f      	ldr	r3, [pc, #444]	; (8003d54 <HAL_DMA_DeInit+0x52c>)
 8003b96:	4299      	cmp	r1, r3
 8003b98:	d062      	beq.n	8003c60 <HAL_DMA_DeInit+0x438>
 8003b9a:	687b      	ldr	r3, [r7, #4]
 8003b9c:	681b      	ldr	r3, [r3, #0]
 8003b9e:	4619      	mov	r1, r3
 8003ba0:	4b6d      	ldr	r3, [pc, #436]	; (8003d58 <HAL_DMA_DeInit+0x530>)
 8003ba2:	4299      	cmp	r1, r3
 8003ba4:	d05a      	beq.n	8003c5c <HAL_DMA_DeInit+0x434>
 8003ba6:	687b      	ldr	r3, [r7, #4]
 8003ba8:	681b      	ldr	r3, [r3, #0]
 8003baa:	4619      	mov	r1, r3
 8003bac:	4b6b      	ldr	r3, [pc, #428]	; (8003d5c <HAL_DMA_DeInit+0x534>)
 8003bae:	4299      	cmp	r1, r3
 8003bb0:	d052      	beq.n	8003c58 <HAL_DMA_DeInit+0x430>
 8003bb2:	687b      	ldr	r3, [r7, #4]
 8003bb4:	681b      	ldr	r3, [r3, #0]
 8003bb6:	4619      	mov	r1, r3
 8003bb8:	4b69      	ldr	r3, [pc, #420]	; (8003d60 <HAL_DMA_DeInit+0x538>)
 8003bba:	4299      	cmp	r1, r3
 8003bbc:	d04a      	beq.n	8003c54 <HAL_DMA_DeInit+0x42c>
 8003bbe:	687b      	ldr	r3, [r7, #4]
 8003bc0:	681b      	ldr	r3, [r3, #0]
 8003bc2:	4619      	mov	r1, r3
 8003bc4:	4b67      	ldr	r3, [pc, #412]	; (8003d64 <HAL_DMA_DeInit+0x53c>)
 8003bc6:	4299      	cmp	r1, r3
 8003bc8:	d041      	beq.n	8003c4e <HAL_DMA_DeInit+0x426>
 8003bca:	687b      	ldr	r3, [r7, #4]
 8003bcc:	681b      	ldr	r3, [r3, #0]
 8003bce:	4619      	mov	r1, r3
 8003bd0:	4b65      	ldr	r3, [pc, #404]	; (8003d68 <HAL_DMA_DeInit+0x540>)
 8003bd2:	4299      	cmp	r1, r3
 8003bd4:	d038      	beq.n	8003c48 <HAL_DMA_DeInit+0x420>
 8003bd6:	687b      	ldr	r3, [r7, #4]
 8003bd8:	681b      	ldr	r3, [r3, #0]
 8003bda:	4619      	mov	r1, r3
 8003bdc:	4b63      	ldr	r3, [pc, #396]	; (8003d6c <HAL_DMA_DeInit+0x544>)
 8003bde:	4299      	cmp	r1, r3
 8003be0:	d02f      	beq.n	8003c42 <HAL_DMA_DeInit+0x41a>
 8003be2:	687b      	ldr	r3, [r7, #4]
 8003be4:	681b      	ldr	r3, [r3, #0]
 8003be6:	4619      	mov	r1, r3
 8003be8:	4b61      	ldr	r3, [pc, #388]	; (8003d70 <HAL_DMA_DeInit+0x548>)
 8003bea:	4299      	cmp	r1, r3
 8003bec:	d026      	beq.n	8003c3c <HAL_DMA_DeInit+0x414>
 8003bee:	687b      	ldr	r3, [r7, #4]
 8003bf0:	681b      	ldr	r3, [r3, #0]
 8003bf2:	4619      	mov	r1, r3
 8003bf4:	4b5f      	ldr	r3, [pc, #380]	; (8003d74 <HAL_DMA_DeInit+0x54c>)
 8003bf6:	4299      	cmp	r1, r3
 8003bf8:	d01d      	beq.n	8003c36 <HAL_DMA_DeInit+0x40e>
 8003bfa:	687b      	ldr	r3, [r7, #4]
 8003bfc:	681b      	ldr	r3, [r3, #0]
 8003bfe:	4619      	mov	r1, r3
 8003c00:	4b5d      	ldr	r3, [pc, #372]	; (8003d78 <HAL_DMA_DeInit+0x550>)
 8003c02:	4299      	cmp	r1, r3
 8003c04:	d014      	beq.n	8003c30 <HAL_DMA_DeInit+0x408>
 8003c06:	687b      	ldr	r3, [r7, #4]
 8003c08:	681b      	ldr	r3, [r3, #0]
 8003c0a:	4619      	mov	r1, r3
 8003c0c:	4b5b      	ldr	r3, [pc, #364]	; (8003d7c <HAL_DMA_DeInit+0x554>)
 8003c0e:	4299      	cmp	r1, r3
 8003c10:	d00b      	beq.n	8003c2a <HAL_DMA_DeInit+0x402>
 8003c12:	687b      	ldr	r3, [r7, #4]
 8003c14:	681b      	ldr	r3, [r3, #0]
 8003c16:	4619      	mov	r1, r3
 8003c18:	4b59      	ldr	r3, [pc, #356]	; (8003d80 <HAL_DMA_DeInit+0x558>)
 8003c1a:	4299      	cmp	r1, r3
 8003c1c:	d102      	bne.n	8003c24 <HAL_DMA_DeInit+0x3fc>
 8003c1e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003c22:	e01e      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c24:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003c28:	e01b      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c2a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003c2e:	e018      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c30:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003c34:	e015      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c36:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8003c3a:	e012      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c3c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003c40:	e00f      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c42:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003c46:	e00c      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c48:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003c4c:	e009      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c4e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003c52:	e006      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c54:	4b3d      	ldr	r3, [pc, #244]	; (8003d4c <HAL_DMA_DeInit+0x524>)
 8003c56:	e004      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c58:	4b3c      	ldr	r3, [pc, #240]	; (8003d4c <HAL_DMA_DeInit+0x524>)
 8003c5a:	e002      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c5c:	4b3b      	ldr	r3, [pc, #236]	; (8003d4c <HAL_DMA_DeInit+0x524>)
 8003c5e:	e000      	b.n	8003c62 <HAL_DMA_DeInit+0x43a>
 8003c60:	4b3a      	ldr	r3, [pc, #232]	; (8003d4c <HAL_DMA_DeInit+0x524>)
 8003c62:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003c64:	687b      	ldr	r3, [r7, #4]
 8003c66:	681b      	ldr	r3, [r3, #0]
 8003c68:	461a      	mov	r2, r3
 8003c6a:	4b46      	ldr	r3, [pc, #280]	; (8003d84 <HAL_DMA_DeInit+0x55c>)
 8003c6c:	429a      	cmp	r2, r3
 8003c6e:	f240 808d 	bls.w	8003d8c <HAL_DMA_DeInit+0x564>
 8003c72:	4a45      	ldr	r2, [pc, #276]	; (8003d88 <HAL_DMA_DeInit+0x560>)
 8003c74:	687b      	ldr	r3, [r7, #4]
 8003c76:	681b      	ldr	r3, [r3, #0]
 8003c78:	4619      	mov	r1, r3
 8003c7a:	4b36      	ldr	r3, [pc, #216]	; (8003d54 <HAL_DMA_DeInit+0x52c>)
 8003c7c:	4299      	cmp	r1, r3
 8003c7e:	d062      	beq.n	8003d46 <HAL_DMA_DeInit+0x51e>
 8003c80:	687b      	ldr	r3, [r7, #4]
 8003c82:	681b      	ldr	r3, [r3, #0]
 8003c84:	4619      	mov	r1, r3
 8003c86:	4b34      	ldr	r3, [pc, #208]	; (8003d58 <HAL_DMA_DeInit+0x530>)
 8003c88:	4299      	cmp	r1, r3
 8003c8a:	d05a      	beq.n	8003d42 <HAL_DMA_DeInit+0x51a>
 8003c8c:	687b      	ldr	r3, [r7, #4]
 8003c8e:	681b      	ldr	r3, [r3, #0]
 8003c90:	4619      	mov	r1, r3
 8003c92:	4b32      	ldr	r3, [pc, #200]	; (8003d5c <HAL_DMA_DeInit+0x534>)
 8003c94:	4299      	cmp	r1, r3
 8003c96:	d052      	beq.n	8003d3e <HAL_DMA_DeInit+0x516>
 8003c98:	687b      	ldr	r3, [r7, #4]
 8003c9a:	681b      	ldr	r3, [r3, #0]
 8003c9c:	4619      	mov	r1, r3
 8003c9e:	4b30      	ldr	r3, [pc, #192]	; (8003d60 <HAL_DMA_DeInit+0x538>)
 8003ca0:	4299      	cmp	r1, r3
 8003ca2:	d04a      	beq.n	8003d3a <HAL_DMA_DeInit+0x512>
 8003ca4:	687b      	ldr	r3, [r7, #4]
 8003ca6:	681b      	ldr	r3, [r3, #0]
 8003ca8:	4619      	mov	r1, r3
 8003caa:	4b2e      	ldr	r3, [pc, #184]	; (8003d64 <HAL_DMA_DeInit+0x53c>)
 8003cac:	4299      	cmp	r1, r3
 8003cae:	d041      	beq.n	8003d34 <HAL_DMA_DeInit+0x50c>
 8003cb0:	687b      	ldr	r3, [r7, #4]
 8003cb2:	681b      	ldr	r3, [r3, #0]
 8003cb4:	4619      	mov	r1, r3
 8003cb6:	4b2c      	ldr	r3, [pc, #176]	; (8003d68 <HAL_DMA_DeInit+0x540>)
 8003cb8:	4299      	cmp	r1, r3
 8003cba:	d038      	beq.n	8003d2e <HAL_DMA_DeInit+0x506>
 8003cbc:	687b      	ldr	r3, [r7, #4]
 8003cbe:	681b      	ldr	r3, [r3, #0]
 8003cc0:	4619      	mov	r1, r3
 8003cc2:	4b2a      	ldr	r3, [pc, #168]	; (8003d6c <HAL_DMA_DeInit+0x544>)
 8003cc4:	4299      	cmp	r1, r3
 8003cc6:	d02f      	beq.n	8003d28 <HAL_DMA_DeInit+0x500>
 8003cc8:	687b      	ldr	r3, [r7, #4]
 8003cca:	681b      	ldr	r3, [r3, #0]
 8003ccc:	4619      	mov	r1, r3
 8003cce:	4b28      	ldr	r3, [pc, #160]	; (8003d70 <HAL_DMA_DeInit+0x548>)
 8003cd0:	4299      	cmp	r1, r3
 8003cd2:	d026      	beq.n	8003d22 <HAL_DMA_DeInit+0x4fa>
 8003cd4:	687b      	ldr	r3, [r7, #4]
 8003cd6:	681b      	ldr	r3, [r3, #0]
 8003cd8:	4619      	mov	r1, r3
 8003cda:	4b26      	ldr	r3, [pc, #152]	; (8003d74 <HAL_DMA_DeInit+0x54c>)
 8003cdc:	4299      	cmp	r1, r3
 8003cde:	d01d      	beq.n	8003d1c <HAL_DMA_DeInit+0x4f4>
 8003ce0:	687b      	ldr	r3, [r7, #4]
 8003ce2:	681b      	ldr	r3, [r3, #0]
 8003ce4:	4619      	mov	r1, r3
 8003ce6:	4b24      	ldr	r3, [pc, #144]	; (8003d78 <HAL_DMA_DeInit+0x550>)
 8003ce8:	4299      	cmp	r1, r3
 8003cea:	d014      	beq.n	8003d16 <HAL_DMA_DeInit+0x4ee>
 8003cec:	687b      	ldr	r3, [r7, #4]
 8003cee:	681b      	ldr	r3, [r3, #0]
 8003cf0:	4619      	mov	r1, r3
 8003cf2:	4b22      	ldr	r3, [pc, #136]	; (8003d7c <HAL_DMA_DeInit+0x554>)
 8003cf4:	4299      	cmp	r1, r3
 8003cf6:	d00b      	beq.n	8003d10 <HAL_DMA_DeInit+0x4e8>
 8003cf8:	687b      	ldr	r3, [r7, #4]
 8003cfa:	681b      	ldr	r3, [r3, #0]
 8003cfc:	4619      	mov	r1, r3
 8003cfe:	4b20      	ldr	r3, [pc, #128]	; (8003d80 <HAL_DMA_DeInit+0x558>)
 8003d00:	4299      	cmp	r1, r3
 8003d02:	d102      	bne.n	8003d0a <HAL_DMA_DeInit+0x4e2>
 8003d04:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003d08:	e01e      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d0a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003d0e:	e01b      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d10:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003d14:	e018      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d16:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003d1a:	e015      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d1c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003d20:	e012      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d22:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003d26:	e00f      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d28:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003d2c:	e00c      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d2e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003d32:	e009      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d34:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003d38:	e006      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d3a:	2320      	movs	r3, #32
 8003d3c:	e004      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d3e:	2320      	movs	r3, #32
 8003d40:	e002      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d42:	2320      	movs	r3, #32
 8003d44:	e000      	b.n	8003d48 <HAL_DMA_DeInit+0x520>
 8003d46:	2320      	movs	r3, #32
 8003d48:	60d3      	str	r3, [r2, #12]
 8003d4a:	e192      	b.n	8004072 <HAL_DMA_DeInit+0x84a>
 8003d4c:	00800004 	.word	0x00800004
 8003d50:	40026000 	.word	0x40026000
 8003d54:	40026010 	.word	0x40026010
 8003d58:	40026410 	.word	0x40026410
 8003d5c:	40026070 	.word	0x40026070
 8003d60:	40026470 	.word	0x40026470
 8003d64:	40026028 	.word	0x40026028
 8003d68:	40026428 	.word	0x40026428
 8003d6c:	40026088 	.word	0x40026088
 8003d70:	40026488 	.word	0x40026488
 8003d74:	40026040 	.word	0x40026040
 8003d78:	40026440 	.word	0x40026440
 8003d7c:	400260a0 	.word	0x400260a0
 8003d80:	400264a0 	.word	0x400264a0
 8003d84:	40026458 	.word	0x40026458
 8003d88:	40026400 	.word	0x40026400
 8003d8c:	687b      	ldr	r3, [r7, #4]
 8003d8e:	681b      	ldr	r3, [r3, #0]
 8003d90:	461a      	mov	r2, r3
 8003d92:	4b9f      	ldr	r3, [pc, #636]	; (8004010 <HAL_DMA_DeInit+0x7e8>)
 8003d94:	429a      	cmp	r2, r3
 8003d96:	d96c      	bls.n	8003e72 <HAL_DMA_DeInit+0x64a>
 8003d98:	4a9e      	ldr	r2, [pc, #632]	; (8004014 <HAL_DMA_DeInit+0x7ec>)
 8003d9a:	687b      	ldr	r3, [r7, #4]
 8003d9c:	681b      	ldr	r3, [r3, #0]
 8003d9e:	4619      	mov	r1, r3
 8003da0:	4b9d      	ldr	r3, [pc, #628]	; (8004018 <HAL_DMA_DeInit+0x7f0>)
 8003da2:	4299      	cmp	r1, r3
 8003da4:	d062      	beq.n	8003e6c <HAL_DMA_DeInit+0x644>
 8003da6:	687b      	ldr	r3, [r7, #4]
 8003da8:	681b      	ldr	r3, [r3, #0]
 8003daa:	4619      	mov	r1, r3
 8003dac:	4b9b      	ldr	r3, [pc, #620]	; (800401c <HAL_DMA_DeInit+0x7f4>)
 8003dae:	4299      	cmp	r1, r3
 8003db0:	d05a      	beq.n	8003e68 <HAL_DMA_DeInit+0x640>
 8003db2:	687b      	ldr	r3, [r7, #4]
 8003db4:	681b      	ldr	r3, [r3, #0]
 8003db6:	4619      	mov	r1, r3
 8003db8:	4b99      	ldr	r3, [pc, #612]	; (8004020 <HAL_DMA_DeInit+0x7f8>)
 8003dba:	4299      	cmp	r1, r3
 8003dbc:	d052      	beq.n	8003e64 <HAL_DMA_DeInit+0x63c>
 8003dbe:	687b      	ldr	r3, [r7, #4]
 8003dc0:	681b      	ldr	r3, [r3, #0]
 8003dc2:	4619      	mov	r1, r3
 8003dc4:	4b97      	ldr	r3, [pc, #604]	; (8004024 <HAL_DMA_DeInit+0x7fc>)
 8003dc6:	4299      	cmp	r1, r3
 8003dc8:	d04a      	beq.n	8003e60 <HAL_DMA_DeInit+0x638>
 8003dca:	687b      	ldr	r3, [r7, #4]
 8003dcc:	681b      	ldr	r3, [r3, #0]
 8003dce:	4619      	mov	r1, r3
 8003dd0:	4b95      	ldr	r3, [pc, #596]	; (8004028 <HAL_DMA_DeInit+0x800>)
 8003dd2:	4299      	cmp	r1, r3
 8003dd4:	d041      	beq.n	8003e5a <HAL_DMA_DeInit+0x632>
 8003dd6:	687b      	ldr	r3, [r7, #4]
 8003dd8:	681b      	ldr	r3, [r3, #0]
 8003dda:	4619      	mov	r1, r3
 8003ddc:	4b93      	ldr	r3, [pc, #588]	; (800402c <HAL_DMA_DeInit+0x804>)
 8003dde:	4299      	cmp	r1, r3
 8003de0:	d038      	beq.n	8003e54 <HAL_DMA_DeInit+0x62c>
 8003de2:	687b      	ldr	r3, [r7, #4]
 8003de4:	681b      	ldr	r3, [r3, #0]
 8003de6:	4619      	mov	r1, r3
 8003de8:	4b91      	ldr	r3, [pc, #580]	; (8004030 <HAL_DMA_DeInit+0x808>)
 8003dea:	4299      	cmp	r1, r3
 8003dec:	d02f      	beq.n	8003e4e <HAL_DMA_DeInit+0x626>
 8003dee:	687b      	ldr	r3, [r7, #4]
 8003df0:	681b      	ldr	r3, [r3, #0]
 8003df2:	4619      	mov	r1, r3
 8003df4:	4b8f      	ldr	r3, [pc, #572]	; (8004034 <HAL_DMA_DeInit+0x80c>)
 8003df6:	4299      	cmp	r1, r3
 8003df8:	d026      	beq.n	8003e48 <HAL_DMA_DeInit+0x620>
 8003dfa:	687b      	ldr	r3, [r7, #4]
 8003dfc:	681b      	ldr	r3, [r3, #0]
 8003dfe:	4619      	mov	r1, r3
 8003e00:	4b8d      	ldr	r3, [pc, #564]	; (8004038 <HAL_DMA_DeInit+0x810>)
 8003e02:	4299      	cmp	r1, r3
 8003e04:	d01d      	beq.n	8003e42 <HAL_DMA_DeInit+0x61a>
 8003e06:	687b      	ldr	r3, [r7, #4]
 8003e08:	681b      	ldr	r3, [r3, #0]
 8003e0a:	4619      	mov	r1, r3
 8003e0c:	4b8b      	ldr	r3, [pc, #556]	; (800403c <HAL_DMA_DeInit+0x814>)
 8003e0e:	4299      	cmp	r1, r3
 8003e10:	d014      	beq.n	8003e3c <HAL_DMA_DeInit+0x614>
 8003e12:	687b      	ldr	r3, [r7, #4]
 8003e14:	681b      	ldr	r3, [r3, #0]
 8003e16:	4619      	mov	r1, r3
 8003e18:	4b89      	ldr	r3, [pc, #548]	; (8004040 <HAL_DMA_DeInit+0x818>)
 8003e1a:	4299      	cmp	r1, r3
 8003e1c:	d00b      	beq.n	8003e36 <HAL_DMA_DeInit+0x60e>
 8003e1e:	687b      	ldr	r3, [r7, #4]
 8003e20:	681b      	ldr	r3, [r3, #0]
 8003e22:	4619      	mov	r1, r3
 8003e24:	4b87      	ldr	r3, [pc, #540]	; (8004044 <HAL_DMA_DeInit+0x81c>)
 8003e26:	4299      	cmp	r1, r3
 8003e28:	d102      	bne.n	8003e30 <HAL_DMA_DeInit+0x608>
 8003e2a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003e2e:	e01e      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e30:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003e34:	e01b      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e36:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003e3a:	e018      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e3c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003e40:	e015      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e42:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003e46:	e012      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e48:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003e4c:	e00f      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e4e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003e52:	e00c      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e54:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003e58:	e009      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e5a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003e5e:	e006      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e60:	2320      	movs	r3, #32
 8003e62:	e004      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e64:	2320      	movs	r3, #32
 8003e66:	e002      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e68:	2320      	movs	r3, #32
 8003e6a:	e000      	b.n	8003e6e <HAL_DMA_DeInit+0x646>
 8003e6c:	2320      	movs	r3, #32
 8003e6e:	6093      	str	r3, [r2, #8]
 8003e70:	e0ff      	b.n	8004072 <HAL_DMA_DeInit+0x84a>
 8003e72:	687b      	ldr	r3, [r7, #4]
 8003e74:	681b      	ldr	r3, [r3, #0]
 8003e76:	461a      	mov	r2, r3
 8003e78:	4b73      	ldr	r3, [pc, #460]	; (8004048 <HAL_DMA_DeInit+0x820>)
 8003e7a:	429a      	cmp	r2, r3
 8003e7c:	d96c      	bls.n	8003f58 <HAL_DMA_DeInit+0x730>
 8003e7e:	4a73      	ldr	r2, [pc, #460]	; (800404c <HAL_DMA_DeInit+0x824>)
 8003e80:	687b      	ldr	r3, [r7, #4]
 8003e82:	681b      	ldr	r3, [r3, #0]
 8003e84:	4619      	mov	r1, r3
 8003e86:	4b64      	ldr	r3, [pc, #400]	; (8004018 <HAL_DMA_DeInit+0x7f0>)
 8003e88:	4299      	cmp	r1, r3
 8003e8a:	d062      	beq.n	8003f52 <HAL_DMA_DeInit+0x72a>
 8003e8c:	687b      	ldr	r3, [r7, #4]
 8003e8e:	681b      	ldr	r3, [r3, #0]
 8003e90:	4619      	mov	r1, r3
 8003e92:	4b62      	ldr	r3, [pc, #392]	; (800401c <HAL_DMA_DeInit+0x7f4>)
 8003e94:	4299      	cmp	r1, r3
 8003e96:	d05a      	beq.n	8003f4e <HAL_DMA_DeInit+0x726>
 8003e98:	687b      	ldr	r3, [r7, #4]
 8003e9a:	681b      	ldr	r3, [r3, #0]
 8003e9c:	4619      	mov	r1, r3
 8003e9e:	4b60      	ldr	r3, [pc, #384]	; (8004020 <HAL_DMA_DeInit+0x7f8>)
 8003ea0:	4299      	cmp	r1, r3
 8003ea2:	d052      	beq.n	8003f4a <HAL_DMA_DeInit+0x722>
 8003ea4:	687b      	ldr	r3, [r7, #4]
 8003ea6:	681b      	ldr	r3, [r3, #0]
 8003ea8:	4619      	mov	r1, r3
 8003eaa:	4b5e      	ldr	r3, [pc, #376]	; (8004024 <HAL_DMA_DeInit+0x7fc>)
 8003eac:	4299      	cmp	r1, r3
 8003eae:	d04a      	beq.n	8003f46 <HAL_DMA_DeInit+0x71e>
 8003eb0:	687b      	ldr	r3, [r7, #4]
 8003eb2:	681b      	ldr	r3, [r3, #0]
 8003eb4:	4619      	mov	r1, r3
 8003eb6:	4b5c      	ldr	r3, [pc, #368]	; (8004028 <HAL_DMA_DeInit+0x800>)
 8003eb8:	4299      	cmp	r1, r3
 8003eba:	d041      	beq.n	8003f40 <HAL_DMA_DeInit+0x718>
 8003ebc:	687b      	ldr	r3, [r7, #4]
 8003ebe:	681b      	ldr	r3, [r3, #0]
 8003ec0:	4619      	mov	r1, r3
 8003ec2:	4b5a      	ldr	r3, [pc, #360]	; (800402c <HAL_DMA_DeInit+0x804>)
 8003ec4:	4299      	cmp	r1, r3
 8003ec6:	d038      	beq.n	8003f3a <HAL_DMA_DeInit+0x712>
 8003ec8:	687b      	ldr	r3, [r7, #4]
 8003eca:	681b      	ldr	r3, [r3, #0]
 8003ecc:	4619      	mov	r1, r3
 8003ece:	4b58      	ldr	r3, [pc, #352]	; (8004030 <HAL_DMA_DeInit+0x808>)
 8003ed0:	4299      	cmp	r1, r3
 8003ed2:	d02f      	beq.n	8003f34 <HAL_DMA_DeInit+0x70c>
 8003ed4:	687b      	ldr	r3, [r7, #4]
 8003ed6:	681b      	ldr	r3, [r3, #0]
 8003ed8:	4619      	mov	r1, r3
 8003eda:	4b56      	ldr	r3, [pc, #344]	; (8004034 <HAL_DMA_DeInit+0x80c>)
 8003edc:	4299      	cmp	r1, r3
 8003ede:	d026      	beq.n	8003f2e <HAL_DMA_DeInit+0x706>
 8003ee0:	687b      	ldr	r3, [r7, #4]
 8003ee2:	681b      	ldr	r3, [r3, #0]
 8003ee4:	4619      	mov	r1, r3
 8003ee6:	4b54      	ldr	r3, [pc, #336]	; (8004038 <HAL_DMA_DeInit+0x810>)
 8003ee8:	4299      	cmp	r1, r3
 8003eea:	d01d      	beq.n	8003f28 <HAL_DMA_DeInit+0x700>
 8003eec:	687b      	ldr	r3, [r7, #4]
 8003eee:	681b      	ldr	r3, [r3, #0]
 8003ef0:	4619      	mov	r1, r3
 8003ef2:	4b52      	ldr	r3, [pc, #328]	; (800403c <HAL_DMA_DeInit+0x814>)
 8003ef4:	4299      	cmp	r1, r3
 8003ef6:	d014      	beq.n	8003f22 <HAL_DMA_DeInit+0x6fa>
 8003ef8:	687b      	ldr	r3, [r7, #4]
 8003efa:	681b      	ldr	r3, [r3, #0]
 8003efc:	4619      	mov	r1, r3
 8003efe:	4b50      	ldr	r3, [pc, #320]	; (8004040 <HAL_DMA_DeInit+0x818>)
 8003f00:	4299      	cmp	r1, r3
 8003f02:	d00b      	beq.n	8003f1c <HAL_DMA_DeInit+0x6f4>
 8003f04:	687b      	ldr	r3, [r7, #4]
 8003f06:	681b      	ldr	r3, [r3, #0]
 8003f08:	4619      	mov	r1, r3
 8003f0a:	4b4e      	ldr	r3, [pc, #312]	; (8004044 <HAL_DMA_DeInit+0x81c>)
 8003f0c:	4299      	cmp	r1, r3
 8003f0e:	d102      	bne.n	8003f16 <HAL_DMA_DeInit+0x6ee>
 8003f10:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003f14:	e01e      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f16:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003f1a:	e01b      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f1c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003f20:	e018      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f22:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003f26:	e015      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f28:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003f2c:	e012      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f2e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003f32:	e00f      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f34:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003f38:	e00c      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f3a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003f3e:	e009      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f40:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003f44:	e006      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f46:	2320      	movs	r3, #32
 8003f48:	e004      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f4a:	2320      	movs	r3, #32
 8003f4c:	e002      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f4e:	2320      	movs	r3, #32
 8003f50:	e000      	b.n	8003f54 <HAL_DMA_DeInit+0x72c>
 8003f52:	2320      	movs	r3, #32
 8003f54:	60d3      	str	r3, [r2, #12]
 8003f56:	e08c      	b.n	8004072 <HAL_DMA_DeInit+0x84a>
 8003f58:	4a3c      	ldr	r2, [pc, #240]	; (800404c <HAL_DMA_DeInit+0x824>)
 8003f5a:	687b      	ldr	r3, [r7, #4]
 8003f5c:	681b      	ldr	r3, [r3, #0]
 8003f5e:	4619      	mov	r1, r3
 8003f60:	4b2d      	ldr	r3, [pc, #180]	; (8004018 <HAL_DMA_DeInit+0x7f0>)
 8003f62:	4299      	cmp	r1, r3
 8003f64:	f000 8083 	beq.w	800406e <HAL_DMA_DeInit+0x846>
 8003f68:	687b      	ldr	r3, [r7, #4]
 8003f6a:	681b      	ldr	r3, [r3, #0]
 8003f6c:	4619      	mov	r1, r3
 8003f6e:	4b2b      	ldr	r3, [pc, #172]	; (800401c <HAL_DMA_DeInit+0x7f4>)
 8003f70:	4299      	cmp	r1, r3
 8003f72:	d07a      	beq.n	800406a <HAL_DMA_DeInit+0x842>
 8003f74:	687b      	ldr	r3, [r7, #4]
 8003f76:	681b      	ldr	r3, [r3, #0]
 8003f78:	4619      	mov	r1, r3
 8003f7a:	4b29      	ldr	r3, [pc, #164]	; (8004020 <HAL_DMA_DeInit+0x7f8>)
 8003f7c:	4299      	cmp	r1, r3
 8003f7e:	d072      	beq.n	8004066 <HAL_DMA_DeInit+0x83e>
 8003f80:	687b      	ldr	r3, [r7, #4]
 8003f82:	681b      	ldr	r3, [r3, #0]
 8003f84:	4619      	mov	r1, r3
 8003f86:	4b27      	ldr	r3, [pc, #156]	; (8004024 <HAL_DMA_DeInit+0x7fc>)
 8003f88:	4299      	cmp	r1, r3
 8003f8a:	d06a      	beq.n	8004062 <HAL_DMA_DeInit+0x83a>
 8003f8c:	687b      	ldr	r3, [r7, #4]
 8003f8e:	681b      	ldr	r3, [r3, #0]
 8003f90:	4619      	mov	r1, r3
 8003f92:	4b25      	ldr	r3, [pc, #148]	; (8004028 <HAL_DMA_DeInit+0x800>)
 8003f94:	4299      	cmp	r1, r3
 8003f96:	d061      	beq.n	800405c <HAL_DMA_DeInit+0x834>
 8003f98:	687b      	ldr	r3, [r7, #4]
 8003f9a:	681b      	ldr	r3, [r3, #0]
 8003f9c:	4619      	mov	r1, r3
 8003f9e:	4b23      	ldr	r3, [pc, #140]	; (800402c <HAL_DMA_DeInit+0x804>)
 8003fa0:	4299      	cmp	r1, r3
 8003fa2:	d058      	beq.n	8004056 <HAL_DMA_DeInit+0x82e>
 8003fa4:	687b      	ldr	r3, [r7, #4]
 8003fa6:	681b      	ldr	r3, [r3, #0]
 8003fa8:	4619      	mov	r1, r3
 8003faa:	4b21      	ldr	r3, [pc, #132]	; (8004030 <HAL_DMA_DeInit+0x808>)
 8003fac:	4299      	cmp	r1, r3
 8003fae:	d04f      	beq.n	8004050 <HAL_DMA_DeInit+0x828>
 8003fb0:	687b      	ldr	r3, [r7, #4]
 8003fb2:	681b      	ldr	r3, [r3, #0]
 8003fb4:	4619      	mov	r1, r3
 8003fb6:	4b1f      	ldr	r3, [pc, #124]	; (8004034 <HAL_DMA_DeInit+0x80c>)
 8003fb8:	4299      	cmp	r1, r3
 8003fba:	d026      	beq.n	800400a <HAL_DMA_DeInit+0x7e2>
 8003fbc:	687b      	ldr	r3, [r7, #4]
 8003fbe:	681b      	ldr	r3, [r3, #0]
 8003fc0:	4619      	mov	r1, r3
 8003fc2:	4b1d      	ldr	r3, [pc, #116]	; (8004038 <HAL_DMA_DeInit+0x810>)
 8003fc4:	4299      	cmp	r1, r3
 8003fc6:	d01d      	beq.n	8004004 <HAL_DMA_DeInit+0x7dc>
 8003fc8:	687b      	ldr	r3, [r7, #4]
 8003fca:	681b      	ldr	r3, [r3, #0]
 8003fcc:	4619      	mov	r1, r3
 8003fce:	4b1b      	ldr	r3, [pc, #108]	; (800403c <HAL_DMA_DeInit+0x814>)
 8003fd0:	4299      	cmp	r1, r3
 8003fd2:	d014      	beq.n	8003ffe <HAL_DMA_DeInit+0x7d6>
 8003fd4:	687b      	ldr	r3, [r7, #4]
 8003fd6:	681b      	ldr	r3, [r3, #0]
 8003fd8:	4619      	mov	r1, r3
 8003fda:	4b19      	ldr	r3, [pc, #100]	; (8004040 <HAL_DMA_DeInit+0x818>)
 8003fdc:	4299      	cmp	r1, r3
 8003fde:	d00b      	beq.n	8003ff8 <HAL_DMA_DeInit+0x7d0>
 8003fe0:	687b      	ldr	r3, [r7, #4]
 8003fe2:	681b      	ldr	r3, [r3, #0]
 8003fe4:	4619      	mov	r1, r3
 8003fe6:	4b17      	ldr	r3, [pc, #92]	; (8004044 <HAL_DMA_DeInit+0x81c>)
 8003fe8:	4299      	cmp	r1, r3
 8003fea:	d102      	bne.n	8003ff2 <HAL_DMA_DeInit+0x7ca>
 8003fec:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003ff0:	e03e      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 8003ff2:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003ff6:	e03b      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 8003ff8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003ffc:	e038      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 8003ffe:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8004002:	e035      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 8004004:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8004008:	e032      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 800400a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800400e:	e02f      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 8004010:	400260b8 	.word	0x400260b8
 8004014:	40026400 	.word	0x40026400
 8004018:	40026010 	.word	0x40026010
 800401c:	40026410 	.word	0x40026410
 8004020:	40026070 	.word	0x40026070
 8004024:	40026470 	.word	0x40026470
 8004028:	40026028 	.word	0x40026028
 800402c:	40026428 	.word	0x40026428
 8004030:	40026088 	.word	0x40026088
 8004034:	40026488 	.word	0x40026488
 8004038:	40026040 	.word	0x40026040
 800403c:	40026440 	.word	0x40026440
 8004040:	400260a0 	.word	0x400260a0
 8004044:	400264a0 	.word	0x400264a0
 8004048:	40026058 	.word	0x40026058
 800404c:	40026000 	.word	0x40026000
 8004050:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8004054:	e00c      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 8004056:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800405a:	e009      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 800405c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8004060:	e006      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 8004062:	2320      	movs	r3, #32
 8004064:	e004      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 8004066:	2320      	movs	r3, #32
 8004068:	e002      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 800406a:	2320      	movs	r3, #32
 800406c:	e000      	b.n	8004070 <HAL_DMA_DeInit+0x848>
 800406e:	2320      	movs	r3, #32
 8004070:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8004072:	687b      	ldr	r3, [r7, #4]
 8004074:	681b      	ldr	r3, [r3, #0]
 8004076:	461a      	mov	r2, r3
 8004078:	4b9f      	ldr	r3, [pc, #636]	; (80042f8 <HAL_DMA_DeInit+0xad0>)
 800407a:	429a      	cmp	r2, r3
 800407c:	d96c      	bls.n	8004158 <HAL_DMA_DeInit+0x930>
 800407e:	4a9f      	ldr	r2, [pc, #636]	; (80042fc <HAL_DMA_DeInit+0xad4>)
 8004080:	687b      	ldr	r3, [r7, #4]
 8004082:	681b      	ldr	r3, [r3, #0]
 8004084:	4619      	mov	r1, r3
 8004086:	4b9e      	ldr	r3, [pc, #632]	; (8004300 <HAL_DMA_DeInit+0xad8>)
 8004088:	4299      	cmp	r1, r3
 800408a:	d062      	beq.n	8004152 <HAL_DMA_DeInit+0x92a>
 800408c:	687b      	ldr	r3, [r7, #4]
 800408e:	681b      	ldr	r3, [r3, #0]
 8004090:	4619      	mov	r1, r3
 8004092:	4b9c      	ldr	r3, [pc, #624]	; (8004304 <HAL_DMA_DeInit+0xadc>)
 8004094:	4299      	cmp	r1, r3
 8004096:	d05a      	beq.n	800414e <HAL_DMA_DeInit+0x926>
 8004098:	687b      	ldr	r3, [r7, #4]
 800409a:	681b      	ldr	r3, [r3, #0]
 800409c:	4619      	mov	r1, r3
 800409e:	4b9a      	ldr	r3, [pc, #616]	; (8004308 <HAL_DMA_DeInit+0xae0>)
 80040a0:	4299      	cmp	r1, r3
 80040a2:	d052      	beq.n	800414a <HAL_DMA_DeInit+0x922>
 80040a4:	687b      	ldr	r3, [r7, #4]
 80040a6:	681b      	ldr	r3, [r3, #0]
 80040a8:	4619      	mov	r1, r3
 80040aa:	4b98      	ldr	r3, [pc, #608]	; (800430c <HAL_DMA_DeInit+0xae4>)
 80040ac:	4299      	cmp	r1, r3
 80040ae:	d04a      	beq.n	8004146 <HAL_DMA_DeInit+0x91e>
 80040b0:	687b      	ldr	r3, [r7, #4]
 80040b2:	681b      	ldr	r3, [r3, #0]
 80040b4:	4619      	mov	r1, r3
 80040b6:	4b96      	ldr	r3, [pc, #600]	; (8004310 <HAL_DMA_DeInit+0xae8>)
 80040b8:	4299      	cmp	r1, r3
 80040ba:	d041      	beq.n	8004140 <HAL_DMA_DeInit+0x918>
 80040bc:	687b      	ldr	r3, [r7, #4]
 80040be:	681b      	ldr	r3, [r3, #0]
 80040c0:	4619      	mov	r1, r3
 80040c2:	4b94      	ldr	r3, [pc, #592]	; (8004314 <HAL_DMA_DeInit+0xaec>)
 80040c4:	4299      	cmp	r1, r3
 80040c6:	d038      	beq.n	800413a <HAL_DMA_DeInit+0x912>
 80040c8:	687b      	ldr	r3, [r7, #4]
 80040ca:	681b      	ldr	r3, [r3, #0]
 80040cc:	4619      	mov	r1, r3
 80040ce:	4b92      	ldr	r3, [pc, #584]	; (8004318 <HAL_DMA_DeInit+0xaf0>)
 80040d0:	4299      	cmp	r1, r3
 80040d2:	d02f      	beq.n	8004134 <HAL_DMA_DeInit+0x90c>
 80040d4:	687b      	ldr	r3, [r7, #4]
 80040d6:	681b      	ldr	r3, [r3, #0]
 80040d8:	4619      	mov	r1, r3
 80040da:	4b90      	ldr	r3, [pc, #576]	; (800431c <HAL_DMA_DeInit+0xaf4>)
 80040dc:	4299      	cmp	r1, r3
 80040de:	d026      	beq.n	800412e <HAL_DMA_DeInit+0x906>
 80040e0:	687b      	ldr	r3, [r7, #4]
 80040e2:	681b      	ldr	r3, [r3, #0]
 80040e4:	4619      	mov	r1, r3
 80040e6:	4b8e      	ldr	r3, [pc, #568]	; (8004320 <HAL_DMA_DeInit+0xaf8>)
 80040e8:	4299      	cmp	r1, r3
 80040ea:	d01d      	beq.n	8004128 <HAL_DMA_DeInit+0x900>
 80040ec:	687b      	ldr	r3, [r7, #4]
 80040ee:	681b      	ldr	r3, [r3, #0]
 80040f0:	4619      	mov	r1, r3
 80040f2:	4b8c      	ldr	r3, [pc, #560]	; (8004324 <HAL_DMA_DeInit+0xafc>)
 80040f4:	4299      	cmp	r1, r3
 80040f6:	d014      	beq.n	8004122 <HAL_DMA_DeInit+0x8fa>
 80040f8:	687b      	ldr	r3, [r7, #4]
 80040fa:	681b      	ldr	r3, [r3, #0]
 80040fc:	4619      	mov	r1, r3
 80040fe:	4b8a      	ldr	r3, [pc, #552]	; (8004328 <HAL_DMA_DeInit+0xb00>)
 8004100:	4299      	cmp	r1, r3
 8004102:	d00b      	beq.n	800411c <HAL_DMA_DeInit+0x8f4>
 8004104:	687b      	ldr	r3, [r7, #4]
 8004106:	681b      	ldr	r3, [r3, #0]
 8004108:	4619      	mov	r1, r3
 800410a:	4b88      	ldr	r3, [pc, #544]	; (800432c <HAL_DMA_DeInit+0xb04>)
 800410c:	4299      	cmp	r1, r3
 800410e:	d102      	bne.n	8004116 <HAL_DMA_DeInit+0x8ee>
 8004110:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004114:	e01e      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 8004116:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800411a:	e01b      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 800411c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004120:	e018      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 8004122:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004126:	e015      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 8004128:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800412c:	e012      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 800412e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004132:	e00f      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 8004134:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004138:	e00c      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 800413a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800413e:	e009      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 8004140:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004144:	e006      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 8004146:	2308      	movs	r3, #8
 8004148:	e004      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 800414a:	2308      	movs	r3, #8
 800414c:	e002      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 800414e:	2308      	movs	r3, #8
 8004150:	e000      	b.n	8004154 <HAL_DMA_DeInit+0x92c>
 8004152:	2308      	movs	r3, #8
 8004154:	60d3      	str	r3, [r2, #12]
 8004156:	e175      	b.n	8004444 <HAL_DMA_DeInit+0xc1c>
 8004158:	687b      	ldr	r3, [r7, #4]
 800415a:	681b      	ldr	r3, [r3, #0]
 800415c:	461a      	mov	r2, r3
 800415e:	4b74      	ldr	r3, [pc, #464]	; (8004330 <HAL_DMA_DeInit+0xb08>)
 8004160:	429a      	cmp	r2, r3
 8004162:	d96c      	bls.n	800423e <HAL_DMA_DeInit+0xa16>
 8004164:	4a65      	ldr	r2, [pc, #404]	; (80042fc <HAL_DMA_DeInit+0xad4>)
 8004166:	687b      	ldr	r3, [r7, #4]
 8004168:	681b      	ldr	r3, [r3, #0]
 800416a:	4619      	mov	r1, r3
 800416c:	4b64      	ldr	r3, [pc, #400]	; (8004300 <HAL_DMA_DeInit+0xad8>)
 800416e:	4299      	cmp	r1, r3
 8004170:	d062      	beq.n	8004238 <HAL_DMA_DeInit+0xa10>
 8004172:	687b      	ldr	r3, [r7, #4]
 8004174:	681b      	ldr	r3, [r3, #0]
 8004176:	4619      	mov	r1, r3
 8004178:	4b62      	ldr	r3, [pc, #392]	; (8004304 <HAL_DMA_DeInit+0xadc>)
 800417a:	4299      	cmp	r1, r3
 800417c:	d05a      	beq.n	8004234 <HAL_DMA_DeInit+0xa0c>
 800417e:	687b      	ldr	r3, [r7, #4]
 8004180:	681b      	ldr	r3, [r3, #0]
 8004182:	4619      	mov	r1, r3
 8004184:	4b60      	ldr	r3, [pc, #384]	; (8004308 <HAL_DMA_DeInit+0xae0>)
 8004186:	4299      	cmp	r1, r3
 8004188:	d052      	beq.n	8004230 <HAL_DMA_DeInit+0xa08>
 800418a:	687b      	ldr	r3, [r7, #4]
 800418c:	681b      	ldr	r3, [r3, #0]
 800418e:	4619      	mov	r1, r3
 8004190:	4b5e      	ldr	r3, [pc, #376]	; (800430c <HAL_DMA_DeInit+0xae4>)
 8004192:	4299      	cmp	r1, r3
 8004194:	d04a      	beq.n	800422c <HAL_DMA_DeInit+0xa04>
 8004196:	687b      	ldr	r3, [r7, #4]
 8004198:	681b      	ldr	r3, [r3, #0]
 800419a:	4619      	mov	r1, r3
 800419c:	4b5c      	ldr	r3, [pc, #368]	; (8004310 <HAL_DMA_DeInit+0xae8>)
 800419e:	4299      	cmp	r1, r3
 80041a0:	d041      	beq.n	8004226 <HAL_DMA_DeInit+0x9fe>
 80041a2:	687b      	ldr	r3, [r7, #4]
 80041a4:	681b      	ldr	r3, [r3, #0]
 80041a6:	4619      	mov	r1, r3
 80041a8:	4b5a      	ldr	r3, [pc, #360]	; (8004314 <HAL_DMA_DeInit+0xaec>)
 80041aa:	4299      	cmp	r1, r3
 80041ac:	d038      	beq.n	8004220 <HAL_DMA_DeInit+0x9f8>
 80041ae:	687b      	ldr	r3, [r7, #4]
 80041b0:	681b      	ldr	r3, [r3, #0]
 80041b2:	4619      	mov	r1, r3
 80041b4:	4b58      	ldr	r3, [pc, #352]	; (8004318 <HAL_DMA_DeInit+0xaf0>)
 80041b6:	4299      	cmp	r1, r3
 80041b8:	d02f      	beq.n	800421a <HAL_DMA_DeInit+0x9f2>
 80041ba:	687b      	ldr	r3, [r7, #4]
 80041bc:	681b      	ldr	r3, [r3, #0]
 80041be:	4619      	mov	r1, r3
 80041c0:	4b56      	ldr	r3, [pc, #344]	; (800431c <HAL_DMA_DeInit+0xaf4>)
 80041c2:	4299      	cmp	r1, r3
 80041c4:	d026      	beq.n	8004214 <HAL_DMA_DeInit+0x9ec>
 80041c6:	687b      	ldr	r3, [r7, #4]
 80041c8:	681b      	ldr	r3, [r3, #0]
 80041ca:	4619      	mov	r1, r3
 80041cc:	4b54      	ldr	r3, [pc, #336]	; (8004320 <HAL_DMA_DeInit+0xaf8>)
 80041ce:	4299      	cmp	r1, r3
 80041d0:	d01d      	beq.n	800420e <HAL_DMA_DeInit+0x9e6>
 80041d2:	687b      	ldr	r3, [r7, #4]
 80041d4:	681b      	ldr	r3, [r3, #0]
 80041d6:	4619      	mov	r1, r3
 80041d8:	4b52      	ldr	r3, [pc, #328]	; (8004324 <HAL_DMA_DeInit+0xafc>)
 80041da:	4299      	cmp	r1, r3
 80041dc:	d014      	beq.n	8004208 <HAL_DMA_DeInit+0x9e0>
 80041de:	687b      	ldr	r3, [r7, #4]
 80041e0:	681b      	ldr	r3, [r3, #0]
 80041e2:	4619      	mov	r1, r3
 80041e4:	4b50      	ldr	r3, [pc, #320]	; (8004328 <HAL_DMA_DeInit+0xb00>)
 80041e6:	4299      	cmp	r1, r3
 80041e8:	d00b      	beq.n	8004202 <HAL_DMA_DeInit+0x9da>
 80041ea:	687b      	ldr	r3, [r7, #4]
 80041ec:	681b      	ldr	r3, [r3, #0]
 80041ee:	4619      	mov	r1, r3
 80041f0:	4b4e      	ldr	r3, [pc, #312]	; (800432c <HAL_DMA_DeInit+0xb04>)
 80041f2:	4299      	cmp	r1, r3
 80041f4:	d102      	bne.n	80041fc <HAL_DMA_DeInit+0x9d4>
 80041f6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80041fa:	e01e      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 80041fc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8004200:	e01b      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 8004202:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004206:	e018      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 8004208:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800420c:	e015      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 800420e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004212:	e012      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 8004214:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004218:	e00f      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 800421a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800421e:	e00c      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 8004220:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004224:	e009      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 8004226:	f44f 7300 	mov.w	r3, #512	; 0x200
 800422a:	e006      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 800422c:	2308      	movs	r3, #8
 800422e:	e004      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 8004230:	2308      	movs	r3, #8
 8004232:	e002      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 8004234:	2308      	movs	r3, #8
 8004236:	e000      	b.n	800423a <HAL_DMA_DeInit+0xa12>
 8004238:	2308      	movs	r3, #8
 800423a:	6093      	str	r3, [r2, #8]
 800423c:	e102      	b.n	8004444 <HAL_DMA_DeInit+0xc1c>
 800423e:	687b      	ldr	r3, [r7, #4]
 8004240:	681b      	ldr	r3, [r3, #0]
 8004242:	461a      	mov	r2, r3
 8004244:	4b3b      	ldr	r3, [pc, #236]	; (8004334 <HAL_DMA_DeInit+0xb0c>)
 8004246:	429a      	cmp	r2, r3
 8004248:	f240 8090 	bls.w	800436c <HAL_DMA_DeInit+0xb44>
 800424c:	4a3a      	ldr	r2, [pc, #232]	; (8004338 <HAL_DMA_DeInit+0xb10>)
 800424e:	687b      	ldr	r3, [r7, #4]
 8004250:	681b      	ldr	r3, [r3, #0]
 8004252:	4619      	mov	r1, r3
 8004254:	4b2a      	ldr	r3, [pc, #168]	; (8004300 <HAL_DMA_DeInit+0xad8>)
 8004256:	4299      	cmp	r1, r3
 8004258:	f000 8085 	beq.w	8004366 <HAL_DMA_DeInit+0xb3e>
 800425c:	687b      	ldr	r3, [r7, #4]
 800425e:	681b      	ldr	r3, [r3, #0]
 8004260:	4619      	mov	r1, r3
 8004262:	4b28      	ldr	r3, [pc, #160]	; (8004304 <HAL_DMA_DeInit+0xadc>)
 8004264:	4299      	cmp	r1, r3
 8004266:	d07c      	beq.n	8004362 <HAL_DMA_DeInit+0xb3a>
 8004268:	687b      	ldr	r3, [r7, #4]
 800426a:	681b      	ldr	r3, [r3, #0]
 800426c:	4619      	mov	r1, r3
 800426e:	4b26      	ldr	r3, [pc, #152]	; (8004308 <HAL_DMA_DeInit+0xae0>)
 8004270:	4299      	cmp	r1, r3
 8004272:	d074      	beq.n	800435e <HAL_DMA_DeInit+0xb36>
 8004274:	687b      	ldr	r3, [r7, #4]
 8004276:	681b      	ldr	r3, [r3, #0]
 8004278:	4619      	mov	r1, r3
 800427a:	4b24      	ldr	r3, [pc, #144]	; (800430c <HAL_DMA_DeInit+0xae4>)
 800427c:	4299      	cmp	r1, r3
 800427e:	d06c      	beq.n	800435a <HAL_DMA_DeInit+0xb32>
 8004280:	687b      	ldr	r3, [r7, #4]
 8004282:	681b      	ldr	r3, [r3, #0]
 8004284:	4619      	mov	r1, r3
 8004286:	4b22      	ldr	r3, [pc, #136]	; (8004310 <HAL_DMA_DeInit+0xae8>)
 8004288:	4299      	cmp	r1, r3
 800428a:	d063      	beq.n	8004354 <HAL_DMA_DeInit+0xb2c>
 800428c:	687b      	ldr	r3, [r7, #4]
 800428e:	681b      	ldr	r3, [r3, #0]
 8004290:	4619      	mov	r1, r3
 8004292:	4b20      	ldr	r3, [pc, #128]	; (8004314 <HAL_DMA_DeInit+0xaec>)
 8004294:	4299      	cmp	r1, r3
 8004296:	d05a      	beq.n	800434e <HAL_DMA_DeInit+0xb26>
 8004298:	687b      	ldr	r3, [r7, #4]
 800429a:	681b      	ldr	r3, [r3, #0]
 800429c:	4619      	mov	r1, r3
 800429e:	4b1e      	ldr	r3, [pc, #120]	; (8004318 <HAL_DMA_DeInit+0xaf0>)
 80042a0:	4299      	cmp	r1, r3
 80042a2:	d051      	beq.n	8004348 <HAL_DMA_DeInit+0xb20>
 80042a4:	687b      	ldr	r3, [r7, #4]
 80042a6:	681b      	ldr	r3, [r3, #0]
 80042a8:	4619      	mov	r1, r3
 80042aa:	4b1c      	ldr	r3, [pc, #112]	; (800431c <HAL_DMA_DeInit+0xaf4>)
 80042ac:	4299      	cmp	r1, r3
 80042ae:	d048      	beq.n	8004342 <HAL_DMA_DeInit+0xb1a>
 80042b0:	687b      	ldr	r3, [r7, #4]
 80042b2:	681b      	ldr	r3, [r3, #0]
 80042b4:	4619      	mov	r1, r3
 80042b6:	4b1a      	ldr	r3, [pc, #104]	; (8004320 <HAL_DMA_DeInit+0xaf8>)
 80042b8:	4299      	cmp	r1, r3
 80042ba:	d03f      	beq.n	800433c <HAL_DMA_DeInit+0xb14>
 80042bc:	687b      	ldr	r3, [r7, #4]
 80042be:	681b      	ldr	r3, [r3, #0]
 80042c0:	4619      	mov	r1, r3
 80042c2:	4b18      	ldr	r3, [pc, #96]	; (8004324 <HAL_DMA_DeInit+0xafc>)
 80042c4:	4299      	cmp	r1, r3
 80042c6:	d014      	beq.n	80042f2 <HAL_DMA_DeInit+0xaca>
 80042c8:	687b      	ldr	r3, [r7, #4]
 80042ca:	681b      	ldr	r3, [r3, #0]
 80042cc:	4619      	mov	r1, r3
 80042ce:	4b16      	ldr	r3, [pc, #88]	; (8004328 <HAL_DMA_DeInit+0xb00>)
 80042d0:	4299      	cmp	r1, r3
 80042d2:	d00b      	beq.n	80042ec <HAL_DMA_DeInit+0xac4>
 80042d4:	687b      	ldr	r3, [r7, #4]
 80042d6:	681b      	ldr	r3, [r3, #0]
 80042d8:	4619      	mov	r1, r3
 80042da:	4b14      	ldr	r3, [pc, #80]	; (800432c <HAL_DMA_DeInit+0xb04>)
 80042dc:	4299      	cmp	r1, r3
 80042de:	d102      	bne.n	80042e6 <HAL_DMA_DeInit+0xabe>
 80042e0:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80042e4:	e040      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 80042e6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80042ea:	e03d      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 80042ec:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80042f0:	e03a      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 80042f2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80042f6:	e037      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 80042f8:	40026458 	.word	0x40026458
 80042fc:	40026400 	.word	0x40026400
 8004300:	40026010 	.word	0x40026010
 8004304:	40026410 	.word	0x40026410
 8004308:	40026070 	.word	0x40026070
 800430c:	40026470 	.word	0x40026470
 8004310:	40026028 	.word	0x40026028
 8004314:	40026428 	.word	0x40026428
 8004318:	40026088 	.word	0x40026088
 800431c:	40026488 	.word	0x40026488
 8004320:	40026040 	.word	0x40026040
 8004324:	40026440 	.word	0x40026440
 8004328:	400260a0 	.word	0x400260a0
 800432c:	400264a0 	.word	0x400264a0
 8004330:	400260b8 	.word	0x400260b8
 8004334:	40026058 	.word	0x40026058
 8004338:	40026000 	.word	0x40026000
 800433c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004340:	e012      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 8004342:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004346:	e00f      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 8004348:	f44f 7300 	mov.w	r3, #512	; 0x200
 800434c:	e00c      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 800434e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004352:	e009      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 8004354:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004358:	e006      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 800435a:	2308      	movs	r3, #8
 800435c:	e004      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 800435e:	2308      	movs	r3, #8
 8004360:	e002      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 8004362:	2308      	movs	r3, #8
 8004364:	e000      	b.n	8004368 <HAL_DMA_DeInit+0xb40>
 8004366:	2308      	movs	r3, #8
 8004368:	60d3      	str	r3, [r2, #12]
 800436a:	e06b      	b.n	8004444 <HAL_DMA_DeInit+0xc1c>
 800436c:	4a9e      	ldr	r2, [pc, #632]	; (80045e8 <HAL_DMA_DeInit+0xdc0>)
 800436e:	687b      	ldr	r3, [r7, #4]
 8004370:	681b      	ldr	r3, [r3, #0]
 8004372:	4619      	mov	r1, r3
 8004374:	4b9d      	ldr	r3, [pc, #628]	; (80045ec <HAL_DMA_DeInit+0xdc4>)
 8004376:	4299      	cmp	r1, r3
 8004378:	d062      	beq.n	8004440 <HAL_DMA_DeInit+0xc18>
 800437a:	687b      	ldr	r3, [r7, #4]
 800437c:	681b      	ldr	r3, [r3, #0]
 800437e:	4619      	mov	r1, r3
 8004380:	4b9b      	ldr	r3, [pc, #620]	; (80045f0 <HAL_DMA_DeInit+0xdc8>)
 8004382:	4299      	cmp	r1, r3
 8004384:	d05a      	beq.n	800443c <HAL_DMA_DeInit+0xc14>
 8004386:	687b      	ldr	r3, [r7, #4]
 8004388:	681b      	ldr	r3, [r3, #0]
 800438a:	4619      	mov	r1, r3
 800438c:	4b99      	ldr	r3, [pc, #612]	; (80045f4 <HAL_DMA_DeInit+0xdcc>)
 800438e:	4299      	cmp	r1, r3
 8004390:	d052      	beq.n	8004438 <HAL_DMA_DeInit+0xc10>
 8004392:	687b      	ldr	r3, [r7, #4]
 8004394:	681b      	ldr	r3, [r3, #0]
 8004396:	4619      	mov	r1, r3
 8004398:	4b97      	ldr	r3, [pc, #604]	; (80045f8 <HAL_DMA_DeInit+0xdd0>)
 800439a:	4299      	cmp	r1, r3
 800439c:	d04a      	beq.n	8004434 <HAL_DMA_DeInit+0xc0c>
 800439e:	687b      	ldr	r3, [r7, #4]
 80043a0:	681b      	ldr	r3, [r3, #0]
 80043a2:	4619      	mov	r1, r3
 80043a4:	4b95      	ldr	r3, [pc, #596]	; (80045fc <HAL_DMA_DeInit+0xdd4>)
 80043a6:	4299      	cmp	r1, r3
 80043a8:	d041      	beq.n	800442e <HAL_DMA_DeInit+0xc06>
 80043aa:	687b      	ldr	r3, [r7, #4]
 80043ac:	681b      	ldr	r3, [r3, #0]
 80043ae:	4619      	mov	r1, r3
 80043b0:	4b93      	ldr	r3, [pc, #588]	; (8004600 <HAL_DMA_DeInit+0xdd8>)
 80043b2:	4299      	cmp	r1, r3
 80043b4:	d038      	beq.n	8004428 <HAL_DMA_DeInit+0xc00>
 80043b6:	687b      	ldr	r3, [r7, #4]
 80043b8:	681b      	ldr	r3, [r3, #0]
 80043ba:	4619      	mov	r1, r3
 80043bc:	4b91      	ldr	r3, [pc, #580]	; (8004604 <HAL_DMA_DeInit+0xddc>)
 80043be:	4299      	cmp	r1, r3
 80043c0:	d02f      	beq.n	8004422 <HAL_DMA_DeInit+0xbfa>
 80043c2:	687b      	ldr	r3, [r7, #4]
 80043c4:	681b      	ldr	r3, [r3, #0]
 80043c6:	4619      	mov	r1, r3
 80043c8:	4b8f      	ldr	r3, [pc, #572]	; (8004608 <HAL_DMA_DeInit+0xde0>)
 80043ca:	4299      	cmp	r1, r3
 80043cc:	d026      	beq.n	800441c <HAL_DMA_DeInit+0xbf4>
 80043ce:	687b      	ldr	r3, [r7, #4]
 80043d0:	681b      	ldr	r3, [r3, #0]
 80043d2:	4619      	mov	r1, r3
 80043d4:	4b8d      	ldr	r3, [pc, #564]	; (800460c <HAL_DMA_DeInit+0xde4>)
 80043d6:	4299      	cmp	r1, r3
 80043d8:	d01d      	beq.n	8004416 <HAL_DMA_DeInit+0xbee>
 80043da:	687b      	ldr	r3, [r7, #4]
 80043dc:	681b      	ldr	r3, [r3, #0]
 80043de:	4619      	mov	r1, r3
 80043e0:	4b8b      	ldr	r3, [pc, #556]	; (8004610 <HAL_DMA_DeInit+0xde8>)
 80043e2:	4299      	cmp	r1, r3
 80043e4:	d014      	beq.n	8004410 <HAL_DMA_DeInit+0xbe8>
 80043e6:	687b      	ldr	r3, [r7, #4]
 80043e8:	681b      	ldr	r3, [r3, #0]
 80043ea:	4619      	mov	r1, r3
 80043ec:	4b89      	ldr	r3, [pc, #548]	; (8004614 <HAL_DMA_DeInit+0xdec>)
 80043ee:	4299      	cmp	r1, r3
 80043f0:	d00b      	beq.n	800440a <HAL_DMA_DeInit+0xbe2>
 80043f2:	687b      	ldr	r3, [r7, #4]
 80043f4:	681b      	ldr	r3, [r3, #0]
 80043f6:	4619      	mov	r1, r3
 80043f8:	4b87      	ldr	r3, [pc, #540]	; (8004618 <HAL_DMA_DeInit+0xdf0>)
 80043fa:	4299      	cmp	r1, r3
 80043fc:	d102      	bne.n	8004404 <HAL_DMA_DeInit+0xbdc>
 80043fe:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004402:	e01e      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 8004404:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8004408:	e01b      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 800440a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800440e:	e018      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 8004410:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004414:	e015      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 8004416:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800441a:	e012      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 800441c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004420:	e00f      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 8004422:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004426:	e00c      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 8004428:	f44f 7300 	mov.w	r3, #512	; 0x200
 800442c:	e009      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 800442e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004432:	e006      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 8004434:	2308      	movs	r3, #8
 8004436:	e004      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 8004438:	2308      	movs	r3, #8
 800443a:	e002      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 800443c:	2308      	movs	r3, #8
 800443e:	e000      	b.n	8004442 <HAL_DMA_DeInit+0xc1a>
 8004440:	2308      	movs	r3, #8
 8004442:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8004444:	687b      	ldr	r3, [r7, #4]
 8004446:	681b      	ldr	r3, [r3, #0]
 8004448:	461a      	mov	r2, r3
 800444a:	4b74      	ldr	r3, [pc, #464]	; (800461c <HAL_DMA_DeInit+0xdf4>)
 800444c:	429a      	cmp	r2, r3
 800444e:	d968      	bls.n	8004522 <HAL_DMA_DeInit+0xcfa>
 8004450:	4a73      	ldr	r2, [pc, #460]	; (8004620 <HAL_DMA_DeInit+0xdf8>)
 8004452:	687b      	ldr	r3, [r7, #4]
 8004454:	681b      	ldr	r3, [r3, #0]
 8004456:	4619      	mov	r1, r3
 8004458:	4b64      	ldr	r3, [pc, #400]	; (80045ec <HAL_DMA_DeInit+0xdc4>)
 800445a:	4299      	cmp	r1, r3
 800445c:	d05e      	beq.n	800451c <HAL_DMA_DeInit+0xcf4>
 800445e:	687b      	ldr	r3, [r7, #4]
 8004460:	681b      	ldr	r3, [r3, #0]
 8004462:	4619      	mov	r1, r3
 8004464:	4b62      	ldr	r3, [pc, #392]	; (80045f0 <HAL_DMA_DeInit+0xdc8>)
 8004466:	4299      	cmp	r1, r3
 8004468:	d056      	beq.n	8004518 <HAL_DMA_DeInit+0xcf0>
 800446a:	687b      	ldr	r3, [r7, #4]
 800446c:	681b      	ldr	r3, [r3, #0]
 800446e:	4619      	mov	r1, r3
 8004470:	4b60      	ldr	r3, [pc, #384]	; (80045f4 <HAL_DMA_DeInit+0xdcc>)
 8004472:	4299      	cmp	r1, r3
 8004474:	d04e      	beq.n	8004514 <HAL_DMA_DeInit+0xcec>
 8004476:	687b      	ldr	r3, [r7, #4]
 8004478:	681b      	ldr	r3, [r3, #0]
 800447a:	4619      	mov	r1, r3
 800447c:	4b5e      	ldr	r3, [pc, #376]	; (80045f8 <HAL_DMA_DeInit+0xdd0>)
 800447e:	4299      	cmp	r1, r3
 8004480:	d046      	beq.n	8004510 <HAL_DMA_DeInit+0xce8>
 8004482:	687b      	ldr	r3, [r7, #4]
 8004484:	681b      	ldr	r3, [r3, #0]
 8004486:	4619      	mov	r1, r3
 8004488:	4b5c      	ldr	r3, [pc, #368]	; (80045fc <HAL_DMA_DeInit+0xdd4>)
 800448a:	4299      	cmp	r1, r3
 800448c:	d03e      	beq.n	800450c <HAL_DMA_DeInit+0xce4>
 800448e:	687b      	ldr	r3, [r7, #4]
 8004490:	681b      	ldr	r3, [r3, #0]
 8004492:	4619      	mov	r1, r3
 8004494:	4b5a      	ldr	r3, [pc, #360]	; (8004600 <HAL_DMA_DeInit+0xdd8>)
 8004496:	4299      	cmp	r1, r3
 8004498:	d036      	beq.n	8004508 <HAL_DMA_DeInit+0xce0>
 800449a:	687b      	ldr	r3, [r7, #4]
 800449c:	681b      	ldr	r3, [r3, #0]
 800449e:	4619      	mov	r1, r3
 80044a0:	4b58      	ldr	r3, [pc, #352]	; (8004604 <HAL_DMA_DeInit+0xddc>)
 80044a2:	4299      	cmp	r1, r3
 80044a4:	d02e      	beq.n	8004504 <HAL_DMA_DeInit+0xcdc>
 80044a6:	687b      	ldr	r3, [r7, #4]
 80044a8:	681b      	ldr	r3, [r3, #0]
 80044aa:	4619      	mov	r1, r3
 80044ac:	4b56      	ldr	r3, [pc, #344]	; (8004608 <HAL_DMA_DeInit+0xde0>)
 80044ae:	4299      	cmp	r1, r3
 80044b0:	d026      	beq.n	8004500 <HAL_DMA_DeInit+0xcd8>
 80044b2:	687b      	ldr	r3, [r7, #4]
 80044b4:	681b      	ldr	r3, [r3, #0]
 80044b6:	4619      	mov	r1, r3
 80044b8:	4b54      	ldr	r3, [pc, #336]	; (800460c <HAL_DMA_DeInit+0xde4>)
 80044ba:	4299      	cmp	r1, r3
 80044bc:	d01d      	beq.n	80044fa <HAL_DMA_DeInit+0xcd2>
 80044be:	687b      	ldr	r3, [r7, #4]
 80044c0:	681b      	ldr	r3, [r3, #0]
 80044c2:	4619      	mov	r1, r3
 80044c4:	4b52      	ldr	r3, [pc, #328]	; (8004610 <HAL_DMA_DeInit+0xde8>)
 80044c6:	4299      	cmp	r1, r3
 80044c8:	d014      	beq.n	80044f4 <HAL_DMA_DeInit+0xccc>
 80044ca:	687b      	ldr	r3, [r7, #4]
 80044cc:	681b      	ldr	r3, [r3, #0]
 80044ce:	4619      	mov	r1, r3
 80044d0:	4b50      	ldr	r3, [pc, #320]	; (8004614 <HAL_DMA_DeInit+0xdec>)
 80044d2:	4299      	cmp	r1, r3
 80044d4:	d00b      	beq.n	80044ee <HAL_DMA_DeInit+0xcc6>
 80044d6:	687b      	ldr	r3, [r7, #4]
 80044d8:	681b      	ldr	r3, [r3, #0]
 80044da:	4619      	mov	r1, r3
 80044dc:	4b4e      	ldr	r3, [pc, #312]	; (8004618 <HAL_DMA_DeInit+0xdf0>)
 80044de:	4299      	cmp	r1, r3
 80044e0:	d102      	bne.n	80044e8 <HAL_DMA_DeInit+0xcc0>
 80044e2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80044e6:	e01a      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 80044e8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80044ec:	e017      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 80044ee:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80044f2:	e014      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 80044f4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80044f8:	e011      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 80044fa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80044fe:	e00e      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 8004500:	2340      	movs	r3, #64	; 0x40
 8004502:	e00c      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 8004504:	2340      	movs	r3, #64	; 0x40
 8004506:	e00a      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 8004508:	2340      	movs	r3, #64	; 0x40
 800450a:	e008      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 800450c:	2340      	movs	r3, #64	; 0x40
 800450e:	e006      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 8004510:	4b44      	ldr	r3, [pc, #272]	; (8004624 <HAL_DMA_DeInit+0xdfc>)
 8004512:	e004      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 8004514:	4b43      	ldr	r3, [pc, #268]	; (8004624 <HAL_DMA_DeInit+0xdfc>)
 8004516:	e002      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 8004518:	4b42      	ldr	r3, [pc, #264]	; (8004624 <HAL_DMA_DeInit+0xdfc>)
 800451a:	e000      	b.n	800451e <HAL_DMA_DeInit+0xcf6>
 800451c:	4b41      	ldr	r3, [pc, #260]	; (8004624 <HAL_DMA_DeInit+0xdfc>)
 800451e:	60d3      	str	r3, [r2, #12]
 8004520:	e16a      	b.n	80047f8 <HAL_DMA_DeInit+0xfd0>
 8004522:	687b      	ldr	r3, [r7, #4]
 8004524:	681b      	ldr	r3, [r3, #0]
 8004526:	461a      	mov	r2, r3
 8004528:	4b3f      	ldr	r3, [pc, #252]	; (8004628 <HAL_DMA_DeInit+0xe00>)
 800452a:	429a      	cmp	r2, r3
 800452c:	f240 808d 	bls.w	800464a <HAL_DMA_DeInit+0xe22>
 8004530:	4a3b      	ldr	r2, [pc, #236]	; (8004620 <HAL_DMA_DeInit+0xdf8>)
 8004532:	687b      	ldr	r3, [r7, #4]
 8004534:	681b      	ldr	r3, [r3, #0]
 8004536:	4619      	mov	r1, r3
 8004538:	4b2c      	ldr	r3, [pc, #176]	; (80045ec <HAL_DMA_DeInit+0xdc4>)
 800453a:	4299      	cmp	r1, r3
 800453c:	f000 8082 	beq.w	8004644 <HAL_DMA_DeInit+0xe1c>
 8004540:	687b      	ldr	r3, [r7, #4]
 8004542:	681b      	ldr	r3, [r3, #0]
 8004544:	4619      	mov	r1, r3
 8004546:	4b2a      	ldr	r3, [pc, #168]	; (80045f0 <HAL_DMA_DeInit+0xdc8>)
 8004548:	4299      	cmp	r1, r3
 800454a:	d079      	beq.n	8004640 <HAL_DMA_DeInit+0xe18>
 800454c:	687b      	ldr	r3, [r7, #4]
 800454e:	681b      	ldr	r3, [r3, #0]
 8004550:	4619      	mov	r1, r3
 8004552:	4b28      	ldr	r3, [pc, #160]	; (80045f4 <HAL_DMA_DeInit+0xdcc>)
 8004554:	4299      	cmp	r1, r3
 8004556:	d071      	beq.n	800463c <HAL_DMA_DeInit+0xe14>
 8004558:	687b      	ldr	r3, [r7, #4]
 800455a:	681b      	ldr	r3, [r3, #0]
 800455c:	4619      	mov	r1, r3
 800455e:	4b26      	ldr	r3, [pc, #152]	; (80045f8 <HAL_DMA_DeInit+0xdd0>)
 8004560:	4299      	cmp	r1, r3
 8004562:	d069      	beq.n	8004638 <HAL_DMA_DeInit+0xe10>
 8004564:	687b      	ldr	r3, [r7, #4]
 8004566:	681b      	ldr	r3, [r3, #0]
 8004568:	4619      	mov	r1, r3
 800456a:	4b24      	ldr	r3, [pc, #144]	; (80045fc <HAL_DMA_DeInit+0xdd4>)
 800456c:	4299      	cmp	r1, r3
 800456e:	d061      	beq.n	8004634 <HAL_DMA_DeInit+0xe0c>
 8004570:	687b      	ldr	r3, [r7, #4]
 8004572:	681b      	ldr	r3, [r3, #0]
 8004574:	4619      	mov	r1, r3
 8004576:	4b22      	ldr	r3, [pc, #136]	; (8004600 <HAL_DMA_DeInit+0xdd8>)
 8004578:	4299      	cmp	r1, r3
 800457a:	d059      	beq.n	8004630 <HAL_DMA_DeInit+0xe08>
 800457c:	687b      	ldr	r3, [r7, #4]
 800457e:	681b      	ldr	r3, [r3, #0]
 8004580:	4619      	mov	r1, r3
 8004582:	4b20      	ldr	r3, [pc, #128]	; (8004604 <HAL_DMA_DeInit+0xddc>)
 8004584:	4299      	cmp	r1, r3
 8004586:	d051      	beq.n	800462c <HAL_DMA_DeInit+0xe04>
 8004588:	687b      	ldr	r3, [r7, #4]
 800458a:	681b      	ldr	r3, [r3, #0]
 800458c:	4619      	mov	r1, r3
 800458e:	4b1e      	ldr	r3, [pc, #120]	; (8004608 <HAL_DMA_DeInit+0xde0>)
 8004590:	4299      	cmp	r1, r3
 8004592:	d026      	beq.n	80045e2 <HAL_DMA_DeInit+0xdba>
 8004594:	687b      	ldr	r3, [r7, #4]
 8004596:	681b      	ldr	r3, [r3, #0]
 8004598:	4619      	mov	r1, r3
 800459a:	4b1c      	ldr	r3, [pc, #112]	; (800460c <HAL_DMA_DeInit+0xde4>)
 800459c:	4299      	cmp	r1, r3
 800459e:	d01d      	beq.n	80045dc <HAL_DMA_DeInit+0xdb4>
 80045a0:	687b      	ldr	r3, [r7, #4]
 80045a2:	681b      	ldr	r3, [r3, #0]
 80045a4:	4619      	mov	r1, r3
 80045a6:	4b1a      	ldr	r3, [pc, #104]	; (8004610 <HAL_DMA_DeInit+0xde8>)
 80045a8:	4299      	cmp	r1, r3
 80045aa:	d014      	beq.n	80045d6 <HAL_DMA_DeInit+0xdae>
 80045ac:	687b      	ldr	r3, [r7, #4]
 80045ae:	681b      	ldr	r3, [r3, #0]
 80045b0:	4619      	mov	r1, r3
 80045b2:	4b18      	ldr	r3, [pc, #96]	; (8004614 <HAL_DMA_DeInit+0xdec>)
 80045b4:	4299      	cmp	r1, r3
 80045b6:	d00b      	beq.n	80045d0 <HAL_DMA_DeInit+0xda8>
 80045b8:	687b      	ldr	r3, [r7, #4]
 80045ba:	681b      	ldr	r3, [r3, #0]
 80045bc:	4619      	mov	r1, r3
 80045be:	4b16      	ldr	r3, [pc, #88]	; (8004618 <HAL_DMA_DeInit+0xdf0>)
 80045c0:	4299      	cmp	r1, r3
 80045c2:	d102      	bne.n	80045ca <HAL_DMA_DeInit+0xda2>
 80045c4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80045c8:	e03d      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 80045ca:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80045ce:	e03a      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 80045d0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80045d4:	e037      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 80045d6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80045da:	e034      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 80045dc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80045e0:	e031      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 80045e2:	2340      	movs	r3, #64	; 0x40
 80045e4:	e02f      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 80045e6:	bf00      	nop
 80045e8:	40026000 	.word	0x40026000
 80045ec:	40026010 	.word	0x40026010
 80045f0:	40026410 	.word	0x40026410
 80045f4:	40026070 	.word	0x40026070
 80045f8:	40026470 	.word	0x40026470
 80045fc:	40026028 	.word	0x40026028
 8004600:	40026428 	.word	0x40026428
 8004604:	40026088 	.word	0x40026088
 8004608:	40026488 	.word	0x40026488
 800460c:	40026040 	.word	0x40026040
 8004610:	40026440 	.word	0x40026440
 8004614:	400260a0 	.word	0x400260a0
 8004618:	400264a0 	.word	0x400264a0
 800461c:	40026458 	.word	0x40026458
 8004620:	40026400 	.word	0x40026400
 8004624:	00800001 	.word	0x00800001
 8004628:	400260b8 	.word	0x400260b8
 800462c:	2340      	movs	r3, #64	; 0x40
 800462e:	e00a      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 8004630:	2340      	movs	r3, #64	; 0x40
 8004632:	e008      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 8004634:	2340      	movs	r3, #64	; 0x40
 8004636:	e006      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 8004638:	4b99      	ldr	r3, [pc, #612]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 800463a:	e004      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 800463c:	4b98      	ldr	r3, [pc, #608]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 800463e:	e002      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 8004640:	4b97      	ldr	r3, [pc, #604]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 8004642:	e000      	b.n	8004646 <HAL_DMA_DeInit+0xe1e>
 8004644:	4b96      	ldr	r3, [pc, #600]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 8004646:	6093      	str	r3, [r2, #8]
 8004648:	e0d6      	b.n	80047f8 <HAL_DMA_DeInit+0xfd0>
 800464a:	687b      	ldr	r3, [r7, #4]
 800464c:	681b      	ldr	r3, [r3, #0]
 800464e:	461a      	mov	r2, r3
 8004650:	4b94      	ldr	r3, [pc, #592]	; (80048a4 <HAL_DMA_DeInit+0x107c>)
 8004652:	429a      	cmp	r2, r3
 8004654:	d968      	bls.n	8004728 <HAL_DMA_DeInit+0xf00>
 8004656:	4a94      	ldr	r2, [pc, #592]	; (80048a8 <HAL_DMA_DeInit+0x1080>)
 8004658:	687b      	ldr	r3, [r7, #4]
 800465a:	681b      	ldr	r3, [r3, #0]
 800465c:	4619      	mov	r1, r3
 800465e:	4b93      	ldr	r3, [pc, #588]	; (80048ac <HAL_DMA_DeInit+0x1084>)
 8004660:	4299      	cmp	r1, r3
 8004662:	d05e      	beq.n	8004722 <HAL_DMA_DeInit+0xefa>
 8004664:	687b      	ldr	r3, [r7, #4]
 8004666:	681b      	ldr	r3, [r3, #0]
 8004668:	4619      	mov	r1, r3
 800466a:	4b91      	ldr	r3, [pc, #580]	; (80048b0 <HAL_DMA_DeInit+0x1088>)
 800466c:	4299      	cmp	r1, r3
 800466e:	d056      	beq.n	800471e <HAL_DMA_DeInit+0xef6>
 8004670:	687b      	ldr	r3, [r7, #4]
 8004672:	681b      	ldr	r3, [r3, #0]
 8004674:	4619      	mov	r1, r3
 8004676:	4b8f      	ldr	r3, [pc, #572]	; (80048b4 <HAL_DMA_DeInit+0x108c>)
 8004678:	4299      	cmp	r1, r3
 800467a:	d04e      	beq.n	800471a <HAL_DMA_DeInit+0xef2>
 800467c:	687b      	ldr	r3, [r7, #4]
 800467e:	681b      	ldr	r3, [r3, #0]
 8004680:	4619      	mov	r1, r3
 8004682:	4b8d      	ldr	r3, [pc, #564]	; (80048b8 <HAL_DMA_DeInit+0x1090>)
 8004684:	4299      	cmp	r1, r3
 8004686:	d046      	beq.n	8004716 <HAL_DMA_DeInit+0xeee>
 8004688:	687b      	ldr	r3, [r7, #4]
 800468a:	681b      	ldr	r3, [r3, #0]
 800468c:	4619      	mov	r1, r3
 800468e:	4b8b      	ldr	r3, [pc, #556]	; (80048bc <HAL_DMA_DeInit+0x1094>)
 8004690:	4299      	cmp	r1, r3
 8004692:	d03e      	beq.n	8004712 <HAL_DMA_DeInit+0xeea>
 8004694:	687b      	ldr	r3, [r7, #4]
 8004696:	681b      	ldr	r3, [r3, #0]
 8004698:	4619      	mov	r1, r3
 800469a:	4b89      	ldr	r3, [pc, #548]	; (80048c0 <HAL_DMA_DeInit+0x1098>)
 800469c:	4299      	cmp	r1, r3
 800469e:	d036      	beq.n	800470e <HAL_DMA_DeInit+0xee6>
 80046a0:	687b      	ldr	r3, [r7, #4]
 80046a2:	681b      	ldr	r3, [r3, #0]
 80046a4:	4619      	mov	r1, r3
 80046a6:	4b87      	ldr	r3, [pc, #540]	; (80048c4 <HAL_DMA_DeInit+0x109c>)
 80046a8:	4299      	cmp	r1, r3
 80046aa:	d02e      	beq.n	800470a <HAL_DMA_DeInit+0xee2>
 80046ac:	687b      	ldr	r3, [r7, #4]
 80046ae:	681b      	ldr	r3, [r3, #0]
 80046b0:	4619      	mov	r1, r3
 80046b2:	4b85      	ldr	r3, [pc, #532]	; (80048c8 <HAL_DMA_DeInit+0x10a0>)
 80046b4:	4299      	cmp	r1, r3
 80046b6:	d026      	beq.n	8004706 <HAL_DMA_DeInit+0xede>
 80046b8:	687b      	ldr	r3, [r7, #4]
 80046ba:	681b      	ldr	r3, [r3, #0]
 80046bc:	4619      	mov	r1, r3
 80046be:	4b83      	ldr	r3, [pc, #524]	; (80048cc <HAL_DMA_DeInit+0x10a4>)
 80046c0:	4299      	cmp	r1, r3
 80046c2:	d01d      	beq.n	8004700 <HAL_DMA_DeInit+0xed8>
 80046c4:	687b      	ldr	r3, [r7, #4]
 80046c6:	681b      	ldr	r3, [r3, #0]
 80046c8:	4619      	mov	r1, r3
 80046ca:	4b81      	ldr	r3, [pc, #516]	; (80048d0 <HAL_DMA_DeInit+0x10a8>)
 80046cc:	4299      	cmp	r1, r3
 80046ce:	d014      	beq.n	80046fa <HAL_DMA_DeInit+0xed2>
 80046d0:	687b      	ldr	r3, [r7, #4]
 80046d2:	681b      	ldr	r3, [r3, #0]
 80046d4:	4619      	mov	r1, r3
 80046d6:	4b7f      	ldr	r3, [pc, #508]	; (80048d4 <HAL_DMA_DeInit+0x10ac>)
 80046d8:	4299      	cmp	r1, r3
 80046da:	d00b      	beq.n	80046f4 <HAL_DMA_DeInit+0xecc>
 80046dc:	687b      	ldr	r3, [r7, #4]
 80046de:	681b      	ldr	r3, [r3, #0]
 80046e0:	4619      	mov	r1, r3
 80046e2:	4b7d      	ldr	r3, [pc, #500]	; (80048d8 <HAL_DMA_DeInit+0x10b0>)
 80046e4:	4299      	cmp	r1, r3
 80046e6:	d102      	bne.n	80046ee <HAL_DMA_DeInit+0xec6>
 80046e8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80046ec:	e01a      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 80046ee:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80046f2:	e017      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 80046f4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80046f8:	e014      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 80046fa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80046fe:	e011      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 8004700:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004704:	e00e      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 8004706:	2340      	movs	r3, #64	; 0x40
 8004708:	e00c      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 800470a:	2340      	movs	r3, #64	; 0x40
 800470c:	e00a      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 800470e:	2340      	movs	r3, #64	; 0x40
 8004710:	e008      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 8004712:	2340      	movs	r3, #64	; 0x40
 8004714:	e006      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 8004716:	4b62      	ldr	r3, [pc, #392]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 8004718:	e004      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 800471a:	4b61      	ldr	r3, [pc, #388]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 800471c:	e002      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 800471e:	4b60      	ldr	r3, [pc, #384]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 8004720:	e000      	b.n	8004724 <HAL_DMA_DeInit+0xefc>
 8004722:	4b5f      	ldr	r3, [pc, #380]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 8004724:	60d3      	str	r3, [r2, #12]
 8004726:	e067      	b.n	80047f8 <HAL_DMA_DeInit+0xfd0>
 8004728:	4a5f      	ldr	r2, [pc, #380]	; (80048a8 <HAL_DMA_DeInit+0x1080>)
 800472a:	687b      	ldr	r3, [r7, #4]
 800472c:	681b      	ldr	r3, [r3, #0]
 800472e:	4619      	mov	r1, r3
 8004730:	4b5e      	ldr	r3, [pc, #376]	; (80048ac <HAL_DMA_DeInit+0x1084>)
 8004732:	4299      	cmp	r1, r3
 8004734:	d05e      	beq.n	80047f4 <HAL_DMA_DeInit+0xfcc>
 8004736:	687b      	ldr	r3, [r7, #4]
 8004738:	681b      	ldr	r3, [r3, #0]
 800473a:	4619      	mov	r1, r3
 800473c:	4b5c      	ldr	r3, [pc, #368]	; (80048b0 <HAL_DMA_DeInit+0x1088>)
 800473e:	4299      	cmp	r1, r3
 8004740:	d056      	beq.n	80047f0 <HAL_DMA_DeInit+0xfc8>
 8004742:	687b      	ldr	r3, [r7, #4]
 8004744:	681b      	ldr	r3, [r3, #0]
 8004746:	4619      	mov	r1, r3
 8004748:	4b5a      	ldr	r3, [pc, #360]	; (80048b4 <HAL_DMA_DeInit+0x108c>)
 800474a:	4299      	cmp	r1, r3
 800474c:	d04e      	beq.n	80047ec <HAL_DMA_DeInit+0xfc4>
 800474e:	687b      	ldr	r3, [r7, #4]
 8004750:	681b      	ldr	r3, [r3, #0]
 8004752:	4619      	mov	r1, r3
 8004754:	4b58      	ldr	r3, [pc, #352]	; (80048b8 <HAL_DMA_DeInit+0x1090>)
 8004756:	4299      	cmp	r1, r3
 8004758:	d046      	beq.n	80047e8 <HAL_DMA_DeInit+0xfc0>
 800475a:	687b      	ldr	r3, [r7, #4]
 800475c:	681b      	ldr	r3, [r3, #0]
 800475e:	4619      	mov	r1, r3
 8004760:	4b56      	ldr	r3, [pc, #344]	; (80048bc <HAL_DMA_DeInit+0x1094>)
 8004762:	4299      	cmp	r1, r3
 8004764:	d03e      	beq.n	80047e4 <HAL_DMA_DeInit+0xfbc>
 8004766:	687b      	ldr	r3, [r7, #4]
 8004768:	681b      	ldr	r3, [r3, #0]
 800476a:	4619      	mov	r1, r3
 800476c:	4b54      	ldr	r3, [pc, #336]	; (80048c0 <HAL_DMA_DeInit+0x1098>)
 800476e:	4299      	cmp	r1, r3
 8004770:	d036      	beq.n	80047e0 <HAL_DMA_DeInit+0xfb8>
 8004772:	687b      	ldr	r3, [r7, #4]
 8004774:	681b      	ldr	r3, [r3, #0]
 8004776:	4619      	mov	r1, r3
 8004778:	4b52      	ldr	r3, [pc, #328]	; (80048c4 <HAL_DMA_DeInit+0x109c>)
 800477a:	4299      	cmp	r1, r3
 800477c:	d02e      	beq.n	80047dc <HAL_DMA_DeInit+0xfb4>
 800477e:	687b      	ldr	r3, [r7, #4]
 8004780:	681b      	ldr	r3, [r3, #0]
 8004782:	4619      	mov	r1, r3
 8004784:	4b50      	ldr	r3, [pc, #320]	; (80048c8 <HAL_DMA_DeInit+0x10a0>)
 8004786:	4299      	cmp	r1, r3
 8004788:	d026      	beq.n	80047d8 <HAL_DMA_DeInit+0xfb0>
 800478a:	687b      	ldr	r3, [r7, #4]
 800478c:	681b      	ldr	r3, [r3, #0]
 800478e:	4619      	mov	r1, r3
 8004790:	4b4e      	ldr	r3, [pc, #312]	; (80048cc <HAL_DMA_DeInit+0x10a4>)
 8004792:	4299      	cmp	r1, r3
 8004794:	d01d      	beq.n	80047d2 <HAL_DMA_DeInit+0xfaa>
 8004796:	687b      	ldr	r3, [r7, #4]
 8004798:	681b      	ldr	r3, [r3, #0]
 800479a:	4619      	mov	r1, r3
 800479c:	4b4c      	ldr	r3, [pc, #304]	; (80048d0 <HAL_DMA_DeInit+0x10a8>)
 800479e:	4299      	cmp	r1, r3
 80047a0:	d014      	beq.n	80047cc <HAL_DMA_DeInit+0xfa4>
 80047a2:	687b      	ldr	r3, [r7, #4]
 80047a4:	681b      	ldr	r3, [r3, #0]
 80047a6:	4619      	mov	r1, r3
 80047a8:	4b4a      	ldr	r3, [pc, #296]	; (80048d4 <HAL_DMA_DeInit+0x10ac>)
 80047aa:	4299      	cmp	r1, r3
 80047ac:	d00b      	beq.n	80047c6 <HAL_DMA_DeInit+0xf9e>
 80047ae:	687b      	ldr	r3, [r7, #4]
 80047b0:	681b      	ldr	r3, [r3, #0]
 80047b2:	4619      	mov	r1, r3
 80047b4:	4b48      	ldr	r3, [pc, #288]	; (80048d8 <HAL_DMA_DeInit+0x10b0>)
 80047b6:	4299      	cmp	r1, r3
 80047b8:	d102      	bne.n	80047c0 <HAL_DMA_DeInit+0xf98>
 80047ba:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80047be:	e01a      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047c0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80047c4:	e017      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047c6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80047ca:	e014      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047cc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80047d0:	e011      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047d2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80047d6:	e00e      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047d8:	2340      	movs	r3, #64	; 0x40
 80047da:	e00c      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047dc:	2340      	movs	r3, #64	; 0x40
 80047de:	e00a      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047e0:	2340      	movs	r3, #64	; 0x40
 80047e2:	e008      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047e4:	2340      	movs	r3, #64	; 0x40
 80047e6:	e006      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047e8:	4b2d      	ldr	r3, [pc, #180]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 80047ea:	e004      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047ec:	4b2c      	ldr	r3, [pc, #176]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 80047ee:	e002      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047f0:	4b2b      	ldr	r3, [pc, #172]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 80047f2:	e000      	b.n	80047f6 <HAL_DMA_DeInit+0xfce>
 80047f4:	4b2a      	ldr	r3, [pc, #168]	; (80048a0 <HAL_DMA_DeInit+0x1078>)
 80047f6:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80047f8:	687b      	ldr	r3, [r7, #4]
 80047fa:	681b      	ldr	r3, [r3, #0]
 80047fc:	461a      	mov	r2, r3
 80047fe:	4b37      	ldr	r3, [pc, #220]	; (80048dc <HAL_DMA_DeInit+0x10b4>)
 8004800:	429a      	cmp	r2, r3
 8004802:	f240 8090 	bls.w	8004926 <HAL_DMA_DeInit+0x10fe>
 8004806:	4a36      	ldr	r2, [pc, #216]	; (80048e0 <HAL_DMA_DeInit+0x10b8>)
 8004808:	687b      	ldr	r3, [r7, #4]
 800480a:	681b      	ldr	r3, [r3, #0]
 800480c:	4619      	mov	r1, r3
 800480e:	4b27      	ldr	r3, [pc, #156]	; (80048ac <HAL_DMA_DeInit+0x1084>)
 8004810:	4299      	cmp	r1, r3
 8004812:	f000 8085 	beq.w	8004920 <HAL_DMA_DeInit+0x10f8>
 8004816:	687b      	ldr	r3, [r7, #4]
 8004818:	681b      	ldr	r3, [r3, #0]
 800481a:	4619      	mov	r1, r3
 800481c:	4b24      	ldr	r3, [pc, #144]	; (80048b0 <HAL_DMA_DeInit+0x1088>)
 800481e:	4299      	cmp	r1, r3
 8004820:	d07c      	beq.n	800491c <HAL_DMA_DeInit+0x10f4>
 8004822:	687b      	ldr	r3, [r7, #4]
 8004824:	681b      	ldr	r3, [r3, #0]
 8004826:	4619      	mov	r1, r3
 8004828:	4b22      	ldr	r3, [pc, #136]	; (80048b4 <HAL_DMA_DeInit+0x108c>)
 800482a:	4299      	cmp	r1, r3
 800482c:	d074      	beq.n	8004918 <HAL_DMA_DeInit+0x10f0>
 800482e:	687b      	ldr	r3, [r7, #4]
 8004830:	681b      	ldr	r3, [r3, #0]
 8004832:	4619      	mov	r1, r3
 8004834:	4b20      	ldr	r3, [pc, #128]	; (80048b8 <HAL_DMA_DeInit+0x1090>)
 8004836:	4299      	cmp	r1, r3
 8004838:	d06c      	beq.n	8004914 <HAL_DMA_DeInit+0x10ec>
 800483a:	687b      	ldr	r3, [r7, #4]
 800483c:	681b      	ldr	r3, [r3, #0]
 800483e:	4619      	mov	r1, r3
 8004840:	4b1e      	ldr	r3, [pc, #120]	; (80048bc <HAL_DMA_DeInit+0x1094>)
 8004842:	4299      	cmp	r1, r3
 8004844:	d063      	beq.n	800490e <HAL_DMA_DeInit+0x10e6>
 8004846:	687b      	ldr	r3, [r7, #4]
 8004848:	681b      	ldr	r3, [r3, #0]
 800484a:	4619      	mov	r1, r3
 800484c:	4b1c      	ldr	r3, [pc, #112]	; (80048c0 <HAL_DMA_DeInit+0x1098>)
 800484e:	4299      	cmp	r1, r3
 8004850:	d05a      	beq.n	8004908 <HAL_DMA_DeInit+0x10e0>
 8004852:	687b      	ldr	r3, [r7, #4]
 8004854:	681b      	ldr	r3, [r3, #0]
 8004856:	4619      	mov	r1, r3
 8004858:	4b1a      	ldr	r3, [pc, #104]	; (80048c4 <HAL_DMA_DeInit+0x109c>)
 800485a:	4299      	cmp	r1, r3
 800485c:	d051      	beq.n	8004902 <HAL_DMA_DeInit+0x10da>
 800485e:	687b      	ldr	r3, [r7, #4]
 8004860:	681b      	ldr	r3, [r3, #0]
 8004862:	4619      	mov	r1, r3
 8004864:	4b18      	ldr	r3, [pc, #96]	; (80048c8 <HAL_DMA_DeInit+0x10a0>)
 8004866:	4299      	cmp	r1, r3
 8004868:	d048      	beq.n	80048fc <HAL_DMA_DeInit+0x10d4>
 800486a:	687b      	ldr	r3, [r7, #4]
 800486c:	681b      	ldr	r3, [r3, #0]
 800486e:	4619      	mov	r1, r3
 8004870:	4b16      	ldr	r3, [pc, #88]	; (80048cc <HAL_DMA_DeInit+0x10a4>)
 8004872:	4299      	cmp	r1, r3
 8004874:	d03f      	beq.n	80048f6 <HAL_DMA_DeInit+0x10ce>
 8004876:	687b      	ldr	r3, [r7, #4]
 8004878:	681b      	ldr	r3, [r3, #0]
 800487a:	4619      	mov	r1, r3
 800487c:	4b14      	ldr	r3, [pc, #80]	; (80048d0 <HAL_DMA_DeInit+0x10a8>)
 800487e:	4299      	cmp	r1, r3
 8004880:	d036      	beq.n	80048f0 <HAL_DMA_DeInit+0x10c8>
 8004882:	687b      	ldr	r3, [r7, #4]
 8004884:	681b      	ldr	r3, [r3, #0]
 8004886:	4619      	mov	r1, r3
 8004888:	4b12      	ldr	r3, [pc, #72]	; (80048d4 <HAL_DMA_DeInit+0x10ac>)
 800488a:	4299      	cmp	r1, r3
 800488c:	d02d      	beq.n	80048ea <HAL_DMA_DeInit+0x10c2>
 800488e:	687b      	ldr	r3, [r7, #4]
 8004890:	681b      	ldr	r3, [r3, #0]
 8004892:	4619      	mov	r1, r3
 8004894:	4b10      	ldr	r3, [pc, #64]	; (80048d8 <HAL_DMA_DeInit+0x10b0>)
 8004896:	4299      	cmp	r1, r3
 8004898:	d124      	bne.n	80048e4 <HAL_DMA_DeInit+0x10bc>
 800489a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800489e:	e040      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 80048a0:	00800001 	.word	0x00800001
 80048a4:	40026058 	.word	0x40026058
 80048a8:	40026000 	.word	0x40026000
 80048ac:	40026010 	.word	0x40026010
 80048b0:	40026410 	.word	0x40026410
 80048b4:	40026070 	.word	0x40026070
 80048b8:	40026470 	.word	0x40026470
 80048bc:	40026028 	.word	0x40026028
 80048c0:	40026428 	.word	0x40026428
 80048c4:	40026088 	.word	0x40026088
 80048c8:	40026488 	.word	0x40026488
 80048cc:	40026040 	.word	0x40026040
 80048d0:	40026440 	.word	0x40026440
 80048d4:	400260a0 	.word	0x400260a0
 80048d8:	400264a0 	.word	0x400264a0
 80048dc:	40026458 	.word	0x40026458
 80048e0:	40026400 	.word	0x40026400
 80048e4:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 80048e8:	e01b      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 80048ea:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80048ee:	e018      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 80048f0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80048f4:	e015      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 80048f6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80048fa:	e012      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 80048fc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004900:	e00f      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 8004902:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004906:	e00c      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 8004908:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800490c:	e009      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 800490e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004912:	e006      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 8004914:	2310      	movs	r3, #16
 8004916:	e004      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 8004918:	2310      	movs	r3, #16
 800491a:	e002      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 800491c:	2310      	movs	r3, #16
 800491e:	e000      	b.n	8004922 <HAL_DMA_DeInit+0x10fa>
 8004920:	2310      	movs	r3, #16
 8004922:	60d3      	str	r3, [r2, #12]
 8004924:	e173      	b.n	8004c0e <HAL_DMA_DeInit+0x13e6>
 8004926:	687b      	ldr	r3, [r7, #4]
 8004928:	681b      	ldr	r3, [r3, #0]
 800492a:	461a      	mov	r2, r3
 800492c:	4b9f      	ldr	r3, [pc, #636]	; (8004bac <HAL_DMA_DeInit+0x1384>)
 800492e:	429a      	cmp	r2, r3
 8004930:	d96c      	bls.n	8004a0c <HAL_DMA_DeInit+0x11e4>
 8004932:	4a9f      	ldr	r2, [pc, #636]	; (8004bb0 <HAL_DMA_DeInit+0x1388>)
 8004934:	687b      	ldr	r3, [r7, #4]
 8004936:	681b      	ldr	r3, [r3, #0]
 8004938:	4619      	mov	r1, r3
 800493a:	4b9e      	ldr	r3, [pc, #632]	; (8004bb4 <HAL_DMA_DeInit+0x138c>)
 800493c:	4299      	cmp	r1, r3
 800493e:	d062      	beq.n	8004a06 <HAL_DMA_DeInit+0x11de>
 8004940:	687b      	ldr	r3, [r7, #4]
 8004942:	681b      	ldr	r3, [r3, #0]
 8004944:	4619      	mov	r1, r3
 8004946:	4b9c      	ldr	r3, [pc, #624]	; (8004bb8 <HAL_DMA_DeInit+0x1390>)
 8004948:	4299      	cmp	r1, r3
 800494a:	d05a      	beq.n	8004a02 <HAL_DMA_DeInit+0x11da>
 800494c:	687b      	ldr	r3, [r7, #4]
 800494e:	681b      	ldr	r3, [r3, #0]
 8004950:	4619      	mov	r1, r3
 8004952:	4b9a      	ldr	r3, [pc, #616]	; (8004bbc <HAL_DMA_DeInit+0x1394>)
 8004954:	4299      	cmp	r1, r3
 8004956:	d052      	beq.n	80049fe <HAL_DMA_DeInit+0x11d6>
 8004958:	687b      	ldr	r3, [r7, #4]
 800495a:	681b      	ldr	r3, [r3, #0]
 800495c:	4619      	mov	r1, r3
 800495e:	4b98      	ldr	r3, [pc, #608]	; (8004bc0 <HAL_DMA_DeInit+0x1398>)
 8004960:	4299      	cmp	r1, r3
 8004962:	d04a      	beq.n	80049fa <HAL_DMA_DeInit+0x11d2>
 8004964:	687b      	ldr	r3, [r7, #4]
 8004966:	681b      	ldr	r3, [r3, #0]
 8004968:	4619      	mov	r1, r3
 800496a:	4b96      	ldr	r3, [pc, #600]	; (8004bc4 <HAL_DMA_DeInit+0x139c>)
 800496c:	4299      	cmp	r1, r3
 800496e:	d041      	beq.n	80049f4 <HAL_DMA_DeInit+0x11cc>
 8004970:	687b      	ldr	r3, [r7, #4]
 8004972:	681b      	ldr	r3, [r3, #0]
 8004974:	4619      	mov	r1, r3
 8004976:	4b94      	ldr	r3, [pc, #592]	; (8004bc8 <HAL_DMA_DeInit+0x13a0>)
 8004978:	4299      	cmp	r1, r3
 800497a:	d038      	beq.n	80049ee <HAL_DMA_DeInit+0x11c6>
 800497c:	687b      	ldr	r3, [r7, #4]
 800497e:	681b      	ldr	r3, [r3, #0]
 8004980:	4619      	mov	r1, r3
 8004982:	4b92      	ldr	r3, [pc, #584]	; (8004bcc <HAL_DMA_DeInit+0x13a4>)
 8004984:	4299      	cmp	r1, r3
 8004986:	d02f      	beq.n	80049e8 <HAL_DMA_DeInit+0x11c0>
 8004988:	687b      	ldr	r3, [r7, #4]
 800498a:	681b      	ldr	r3, [r3, #0]
 800498c:	4619      	mov	r1, r3
 800498e:	4b90      	ldr	r3, [pc, #576]	; (8004bd0 <HAL_DMA_DeInit+0x13a8>)
 8004990:	4299      	cmp	r1, r3
 8004992:	d026      	beq.n	80049e2 <HAL_DMA_DeInit+0x11ba>
 8004994:	687b      	ldr	r3, [r7, #4]
 8004996:	681b      	ldr	r3, [r3, #0]
 8004998:	4619      	mov	r1, r3
 800499a:	4b8e      	ldr	r3, [pc, #568]	; (8004bd4 <HAL_DMA_DeInit+0x13ac>)
 800499c:	4299      	cmp	r1, r3
 800499e:	d01d      	beq.n	80049dc <HAL_DMA_DeInit+0x11b4>
 80049a0:	687b      	ldr	r3, [r7, #4]
 80049a2:	681b      	ldr	r3, [r3, #0]
 80049a4:	4619      	mov	r1, r3
 80049a6:	4b8c      	ldr	r3, [pc, #560]	; (8004bd8 <HAL_DMA_DeInit+0x13b0>)
 80049a8:	4299      	cmp	r1, r3
 80049aa:	d014      	beq.n	80049d6 <HAL_DMA_DeInit+0x11ae>
 80049ac:	687b      	ldr	r3, [r7, #4]
 80049ae:	681b      	ldr	r3, [r3, #0]
 80049b0:	4619      	mov	r1, r3
 80049b2:	4b8a      	ldr	r3, [pc, #552]	; (8004bdc <HAL_DMA_DeInit+0x13b4>)
 80049b4:	4299      	cmp	r1, r3
 80049b6:	d00b      	beq.n	80049d0 <HAL_DMA_DeInit+0x11a8>
 80049b8:	687b      	ldr	r3, [r7, #4]
 80049ba:	681b      	ldr	r3, [r3, #0]
 80049bc:	4619      	mov	r1, r3
 80049be:	4b88      	ldr	r3, [pc, #544]	; (8004be0 <HAL_DMA_DeInit+0x13b8>)
 80049c0:	4299      	cmp	r1, r3
 80049c2:	d102      	bne.n	80049ca <HAL_DMA_DeInit+0x11a2>
 80049c4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80049c8:	e01e      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049ca:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 80049ce:	e01b      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049d0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80049d4:	e018      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049d6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80049da:	e015      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049dc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80049e0:	e012      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049e2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80049e6:	e00f      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80049ec:	e00c      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049ee:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80049f2:	e009      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049f4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80049f8:	e006      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049fa:	2310      	movs	r3, #16
 80049fc:	e004      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 80049fe:	2310      	movs	r3, #16
 8004a00:	e002      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 8004a02:	2310      	movs	r3, #16
 8004a04:	e000      	b.n	8004a08 <HAL_DMA_DeInit+0x11e0>
 8004a06:	2310      	movs	r3, #16
 8004a08:	6093      	str	r3, [r2, #8]
 8004a0a:	e100      	b.n	8004c0e <HAL_DMA_DeInit+0x13e6>
 8004a0c:	687b      	ldr	r3, [r7, #4]
 8004a0e:	681b      	ldr	r3, [r3, #0]
 8004a10:	461a      	mov	r2, r3
 8004a12:	4b74      	ldr	r3, [pc, #464]	; (8004be4 <HAL_DMA_DeInit+0x13bc>)
 8004a14:	429a      	cmp	r2, r3
 8004a16:	d96c      	bls.n	8004af2 <HAL_DMA_DeInit+0x12ca>
 8004a18:	4a73      	ldr	r2, [pc, #460]	; (8004be8 <HAL_DMA_DeInit+0x13c0>)
 8004a1a:	687b      	ldr	r3, [r7, #4]
 8004a1c:	681b      	ldr	r3, [r3, #0]
 8004a1e:	4619      	mov	r1, r3
 8004a20:	4b64      	ldr	r3, [pc, #400]	; (8004bb4 <HAL_DMA_DeInit+0x138c>)
 8004a22:	4299      	cmp	r1, r3
 8004a24:	d062      	beq.n	8004aec <HAL_DMA_DeInit+0x12c4>
 8004a26:	687b      	ldr	r3, [r7, #4]
 8004a28:	681b      	ldr	r3, [r3, #0]
 8004a2a:	4619      	mov	r1, r3
 8004a2c:	4b62      	ldr	r3, [pc, #392]	; (8004bb8 <HAL_DMA_DeInit+0x1390>)
 8004a2e:	4299      	cmp	r1, r3
 8004a30:	d05a      	beq.n	8004ae8 <HAL_DMA_DeInit+0x12c0>
 8004a32:	687b      	ldr	r3, [r7, #4]
 8004a34:	681b      	ldr	r3, [r3, #0]
 8004a36:	4619      	mov	r1, r3
 8004a38:	4b60      	ldr	r3, [pc, #384]	; (8004bbc <HAL_DMA_DeInit+0x1394>)
 8004a3a:	4299      	cmp	r1, r3
 8004a3c:	d052      	beq.n	8004ae4 <HAL_DMA_DeInit+0x12bc>
 8004a3e:	687b      	ldr	r3, [r7, #4]
 8004a40:	681b      	ldr	r3, [r3, #0]
 8004a42:	4619      	mov	r1, r3
 8004a44:	4b5e      	ldr	r3, [pc, #376]	; (8004bc0 <HAL_DMA_DeInit+0x1398>)
 8004a46:	4299      	cmp	r1, r3
 8004a48:	d04a      	beq.n	8004ae0 <HAL_DMA_DeInit+0x12b8>
 8004a4a:	687b      	ldr	r3, [r7, #4]
 8004a4c:	681b      	ldr	r3, [r3, #0]
 8004a4e:	4619      	mov	r1, r3
 8004a50:	4b5c      	ldr	r3, [pc, #368]	; (8004bc4 <HAL_DMA_DeInit+0x139c>)
 8004a52:	4299      	cmp	r1, r3
 8004a54:	d041      	beq.n	8004ada <HAL_DMA_DeInit+0x12b2>
 8004a56:	687b      	ldr	r3, [r7, #4]
 8004a58:	681b      	ldr	r3, [r3, #0]
 8004a5a:	4619      	mov	r1, r3
 8004a5c:	4b5a      	ldr	r3, [pc, #360]	; (8004bc8 <HAL_DMA_DeInit+0x13a0>)
 8004a5e:	4299      	cmp	r1, r3
 8004a60:	d038      	beq.n	8004ad4 <HAL_DMA_DeInit+0x12ac>
 8004a62:	687b      	ldr	r3, [r7, #4]
 8004a64:	681b      	ldr	r3, [r3, #0]
 8004a66:	4619      	mov	r1, r3
 8004a68:	4b58      	ldr	r3, [pc, #352]	; (8004bcc <HAL_DMA_DeInit+0x13a4>)
 8004a6a:	4299      	cmp	r1, r3
 8004a6c:	d02f      	beq.n	8004ace <HAL_DMA_DeInit+0x12a6>
 8004a6e:	687b      	ldr	r3, [r7, #4]
 8004a70:	681b      	ldr	r3, [r3, #0]
 8004a72:	4619      	mov	r1, r3
 8004a74:	4b56      	ldr	r3, [pc, #344]	; (8004bd0 <HAL_DMA_DeInit+0x13a8>)
 8004a76:	4299      	cmp	r1, r3
 8004a78:	d026      	beq.n	8004ac8 <HAL_DMA_DeInit+0x12a0>
 8004a7a:	687b      	ldr	r3, [r7, #4]
 8004a7c:	681b      	ldr	r3, [r3, #0]
 8004a7e:	4619      	mov	r1, r3
 8004a80:	4b54      	ldr	r3, [pc, #336]	; (8004bd4 <HAL_DMA_DeInit+0x13ac>)
 8004a82:	4299      	cmp	r1, r3
 8004a84:	d01d      	beq.n	8004ac2 <HAL_DMA_DeInit+0x129a>
 8004a86:	687b      	ldr	r3, [r7, #4]
 8004a88:	681b      	ldr	r3, [r3, #0]
 8004a8a:	4619      	mov	r1, r3
 8004a8c:	4b52      	ldr	r3, [pc, #328]	; (8004bd8 <HAL_DMA_DeInit+0x13b0>)
 8004a8e:	4299      	cmp	r1, r3
 8004a90:	d014      	beq.n	8004abc <HAL_DMA_DeInit+0x1294>
 8004a92:	687b      	ldr	r3, [r7, #4]
 8004a94:	681b      	ldr	r3, [r3, #0]
 8004a96:	4619      	mov	r1, r3
 8004a98:	4b50      	ldr	r3, [pc, #320]	; (8004bdc <HAL_DMA_DeInit+0x13b4>)
 8004a9a:	4299      	cmp	r1, r3
 8004a9c:	d00b      	beq.n	8004ab6 <HAL_DMA_DeInit+0x128e>
 8004a9e:	687b      	ldr	r3, [r7, #4]
 8004aa0:	681b      	ldr	r3, [r3, #0]
 8004aa2:	4619      	mov	r1, r3
 8004aa4:	4b4e      	ldr	r3, [pc, #312]	; (8004be0 <HAL_DMA_DeInit+0x13b8>)
 8004aa6:	4299      	cmp	r1, r3
 8004aa8:	d102      	bne.n	8004ab0 <HAL_DMA_DeInit+0x1288>
 8004aaa:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004aae:	e01e      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ab0:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8004ab4:	e01b      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ab6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004aba:	e018      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004abc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004ac0:	e015      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ac2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004ac6:	e012      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ac8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004acc:	e00f      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ace:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004ad2:	e00c      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ad4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004ad8:	e009      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ada:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004ade:	e006      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ae0:	2310      	movs	r3, #16
 8004ae2:	e004      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ae4:	2310      	movs	r3, #16
 8004ae6:	e002      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004ae8:	2310      	movs	r3, #16
 8004aea:	e000      	b.n	8004aee <HAL_DMA_DeInit+0x12c6>
 8004aec:	2310      	movs	r3, #16
 8004aee:	60d3      	str	r3, [r2, #12]
 8004af0:	e08d      	b.n	8004c0e <HAL_DMA_DeInit+0x13e6>
 8004af2:	4a3d      	ldr	r2, [pc, #244]	; (8004be8 <HAL_DMA_DeInit+0x13c0>)
 8004af4:	687b      	ldr	r3, [r7, #4]
 8004af6:	681b      	ldr	r3, [r3, #0]
 8004af8:	4619      	mov	r1, r3
 8004afa:	4b2e      	ldr	r3, [pc, #184]	; (8004bb4 <HAL_DMA_DeInit+0x138c>)
 8004afc:	4299      	cmp	r1, r3
 8004afe:	f000 8084 	beq.w	8004c0a <HAL_DMA_DeInit+0x13e2>
 8004b02:	687b      	ldr	r3, [r7, #4]
 8004b04:	681b      	ldr	r3, [r3, #0]
 8004b06:	4619      	mov	r1, r3
 8004b08:	4b2b      	ldr	r3, [pc, #172]	; (8004bb8 <HAL_DMA_DeInit+0x1390>)
 8004b0a:	4299      	cmp	r1, r3
 8004b0c:	d07b      	beq.n	8004c06 <HAL_DMA_DeInit+0x13de>
 8004b0e:	687b      	ldr	r3, [r7, #4]
 8004b10:	681b      	ldr	r3, [r3, #0]
 8004b12:	4619      	mov	r1, r3
 8004b14:	4b29      	ldr	r3, [pc, #164]	; (8004bbc <HAL_DMA_DeInit+0x1394>)
 8004b16:	4299      	cmp	r1, r3
 8004b18:	d073      	beq.n	8004c02 <HAL_DMA_DeInit+0x13da>
 8004b1a:	687b      	ldr	r3, [r7, #4]
 8004b1c:	681b      	ldr	r3, [r3, #0]
 8004b1e:	4619      	mov	r1, r3
 8004b20:	4b27      	ldr	r3, [pc, #156]	; (8004bc0 <HAL_DMA_DeInit+0x1398>)
 8004b22:	4299      	cmp	r1, r3
 8004b24:	d06b      	beq.n	8004bfe <HAL_DMA_DeInit+0x13d6>
 8004b26:	687b      	ldr	r3, [r7, #4]
 8004b28:	681b      	ldr	r3, [r3, #0]
 8004b2a:	4619      	mov	r1, r3
 8004b2c:	4b25      	ldr	r3, [pc, #148]	; (8004bc4 <HAL_DMA_DeInit+0x139c>)
 8004b2e:	4299      	cmp	r1, r3
 8004b30:	d062      	beq.n	8004bf8 <HAL_DMA_DeInit+0x13d0>
 8004b32:	687b      	ldr	r3, [r7, #4]
 8004b34:	681b      	ldr	r3, [r3, #0]
 8004b36:	4619      	mov	r1, r3
 8004b38:	4b23      	ldr	r3, [pc, #140]	; (8004bc8 <HAL_DMA_DeInit+0x13a0>)
 8004b3a:	4299      	cmp	r1, r3
 8004b3c:	d059      	beq.n	8004bf2 <HAL_DMA_DeInit+0x13ca>
 8004b3e:	687b      	ldr	r3, [r7, #4]
 8004b40:	681b      	ldr	r3, [r3, #0]
 8004b42:	4619      	mov	r1, r3
 8004b44:	4b21      	ldr	r3, [pc, #132]	; (8004bcc <HAL_DMA_DeInit+0x13a4>)
 8004b46:	4299      	cmp	r1, r3
 8004b48:	d050      	beq.n	8004bec <HAL_DMA_DeInit+0x13c4>
 8004b4a:	687b      	ldr	r3, [r7, #4]
 8004b4c:	681b      	ldr	r3, [r3, #0]
 8004b4e:	4619      	mov	r1, r3
 8004b50:	4b1f      	ldr	r3, [pc, #124]	; (8004bd0 <HAL_DMA_DeInit+0x13a8>)
 8004b52:	4299      	cmp	r1, r3
 8004b54:	d026      	beq.n	8004ba4 <HAL_DMA_DeInit+0x137c>
 8004b56:	687b      	ldr	r3, [r7, #4]
 8004b58:	681b      	ldr	r3, [r3, #0]
 8004b5a:	4619      	mov	r1, r3
 8004b5c:	4b1d      	ldr	r3, [pc, #116]	; (8004bd4 <HAL_DMA_DeInit+0x13ac>)
 8004b5e:	4299      	cmp	r1, r3
 8004b60:	d01d      	beq.n	8004b9e <HAL_DMA_DeInit+0x1376>
 8004b62:	687b      	ldr	r3, [r7, #4]
 8004b64:	681b      	ldr	r3, [r3, #0]
 8004b66:	4619      	mov	r1, r3
 8004b68:	4b1b      	ldr	r3, [pc, #108]	; (8004bd8 <HAL_DMA_DeInit+0x13b0>)
 8004b6a:	4299      	cmp	r1, r3
 8004b6c:	d014      	beq.n	8004b98 <HAL_DMA_DeInit+0x1370>
 8004b6e:	687b      	ldr	r3, [r7, #4]
 8004b70:	681b      	ldr	r3, [r3, #0]
 8004b72:	4619      	mov	r1, r3
 8004b74:	4b19      	ldr	r3, [pc, #100]	; (8004bdc <HAL_DMA_DeInit+0x13b4>)
 8004b76:	4299      	cmp	r1, r3
 8004b78:	d00b      	beq.n	8004b92 <HAL_DMA_DeInit+0x136a>
 8004b7a:	687b      	ldr	r3, [r7, #4]
 8004b7c:	681b      	ldr	r3, [r3, #0]
 8004b7e:	4619      	mov	r1, r3
 8004b80:	4b17      	ldr	r3, [pc, #92]	; (8004be0 <HAL_DMA_DeInit+0x13b8>)
 8004b82:	4299      	cmp	r1, r3
 8004b84:	d102      	bne.n	8004b8c <HAL_DMA_DeInit+0x1364>
 8004b86:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004b8a:	e03f      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004b8c:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8004b90:	e03c      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004b92:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004b96:	e039      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004b98:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004b9c:	e036      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004b9e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004ba2:	e033      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004ba4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004ba8:	e030      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004baa:	bf00      	nop
 8004bac:	400260b8 	.word	0x400260b8
 8004bb0:	40026400 	.word	0x40026400
 8004bb4:	40026010 	.word	0x40026010
 8004bb8:	40026410 	.word	0x40026410
 8004bbc:	40026070 	.word	0x40026070
 8004bc0:	40026470 	.word	0x40026470
 8004bc4:	40026028 	.word	0x40026028
 8004bc8:	40026428 	.word	0x40026428
 8004bcc:	40026088 	.word	0x40026088
 8004bd0:	40026488 	.word	0x40026488
 8004bd4:	40026040 	.word	0x40026040
 8004bd8:	40026440 	.word	0x40026440
 8004bdc:	400260a0 	.word	0x400260a0
 8004be0:	400264a0 	.word	0x400264a0
 8004be4:	40026058 	.word	0x40026058
 8004be8:	40026000 	.word	0x40026000
 8004bec:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004bf0:	e00c      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004bf2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004bf6:	e009      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004bf8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004bfc:	e006      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004bfe:	2310      	movs	r3, #16
 8004c00:	e004      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004c02:	2310      	movs	r3, #16
 8004c04:	e002      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004c06:	2310      	movs	r3, #16
 8004c08:	e000      	b.n	8004c0c <HAL_DMA_DeInit+0x13e4>
 8004c0a:	2310      	movs	r3, #16
 8004c0c:	6093      	str	r3, [r2, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8004c0e:	687b      	ldr	r3, [r7, #4]
 8004c10:	2200      	movs	r2, #0
 8004c12:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 8004c14:	687b      	ldr	r3, [r7, #4]
 8004c16:	2200      	movs	r2, #0
 8004c18:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 8004c1c:	687b      	ldr	r3, [r7, #4]
 8004c1e:	2200      	movs	r2, #0
 8004c20:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
 8004c24:	2300      	movs	r3, #0
}
 8004c26:	4618      	mov	r0, r3
 8004c28:	370c      	adds	r7, #12
 8004c2a:	46bd      	mov	sp, r7
 8004c2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c30:	4770      	bx	lr
 8004c32:	bf00      	nop

08004c34 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8004c34:	b580      	push	{r7, lr}
 8004c36:	b084      	sub	sp, #16
 8004c38:	af00      	add	r7, sp, #0
 8004c3a:	60f8      	str	r0, [r7, #12]
 8004c3c:	60b9      	str	r1, [r7, #8]
 8004c3e:	607a      	str	r2, [r7, #4]
 8004c40:	603b      	str	r3, [r7, #0]
  /* Process locked */
  __HAL_LOCK(hdma);
 8004c42:	68fb      	ldr	r3, [r7, #12]
 8004c44:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8004c48:	2b01      	cmp	r3, #1
 8004c4a:	d101      	bne.n	8004c50 <HAL_DMA_Start_IT+0x1c>
 8004c4c:	2302      	movs	r3, #2
 8004c4e:	e046      	b.n	8004cde <HAL_DMA_Start_IT+0xaa>
 8004c50:	68fb      	ldr	r3, [r7, #12]
 8004c52:	2201      	movs	r2, #1
 8004c54:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8004c58:	68fb      	ldr	r3, [r7, #12]
 8004c5a:	2202      	movs	r2, #2
 8004c5c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8004c60:	68fb      	ldr	r3, [r7, #12]
 8004c62:	681b      	ldr	r3, [r3, #0]
 8004c64:	68fa      	ldr	r2, [r7, #12]
 8004c66:	6812      	ldr	r2, [r2, #0]
 8004c68:	6812      	ldr	r2, [r2, #0]
 8004c6a:	f022 0201 	bic.w	r2, r2, #1
 8004c6e:	601a      	str	r2, [r3, #0]

  /* Configure the source, destination address and the data length */
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8004c70:	68f8      	ldr	r0, [r7, #12]
 8004c72:	68b9      	ldr	r1, [r7, #8]
 8004c74:	687a      	ldr	r2, [r7, #4]
 8004c76:	683b      	ldr	r3, [r7, #0]
 8004c78:	f7fe fd3c 	bl	80036f4 <DMA_SetConfig>

  /* Enable the transfer complete interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
 8004c7c:	68fb      	ldr	r3, [r7, #12]
 8004c7e:	681b      	ldr	r3, [r3, #0]
 8004c80:	68fa      	ldr	r2, [r7, #12]
 8004c82:	6812      	ldr	r2, [r2, #0]
 8004c84:	6812      	ldr	r2, [r2, #0]
 8004c86:	f042 0210 	orr.w	r2, r2, #16
 8004c8a:	601a      	str	r2, [r3, #0]

  /* Enable the Half transfer complete interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);  
 8004c8c:	68fb      	ldr	r3, [r7, #12]
 8004c8e:	681b      	ldr	r3, [r3, #0]
 8004c90:	68fa      	ldr	r2, [r7, #12]
 8004c92:	6812      	ldr	r2, [r2, #0]
 8004c94:	6812      	ldr	r2, [r2, #0]
 8004c96:	f042 0208 	orr.w	r2, r2, #8
 8004c9a:	601a      	str	r2, [r3, #0]

  /* Enable the transfer Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TE);
 8004c9c:	68fb      	ldr	r3, [r7, #12]
 8004c9e:	681b      	ldr	r3, [r3, #0]
 8004ca0:	68fa      	ldr	r2, [r7, #12]
 8004ca2:	6812      	ldr	r2, [r2, #0]
 8004ca4:	6812      	ldr	r2, [r2, #0]
 8004ca6:	f042 0204 	orr.w	r2, r2, #4
 8004caa:	601a      	str	r2, [r3, #0]

  /* Enable the FIFO Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_FE);
 8004cac:	68fb      	ldr	r3, [r7, #12]
 8004cae:	681b      	ldr	r3, [r3, #0]
 8004cb0:	68fa      	ldr	r2, [r7, #12]
 8004cb2:	6812      	ldr	r2, [r2, #0]
 8004cb4:	6952      	ldr	r2, [r2, #20]
 8004cb6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8004cba:	615a      	str	r2, [r3, #20]

  /* Enable the direct mode Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_DME);
 8004cbc:	68fb      	ldr	r3, [r7, #12]
 8004cbe:	681b      	ldr	r3, [r3, #0]
 8004cc0:	68fa      	ldr	r2, [r7, #12]
 8004cc2:	6812      	ldr	r2, [r2, #0]
 8004cc4:	6812      	ldr	r2, [r2, #0]
 8004cc6:	f042 0202 	orr.w	r2, r2, #2
 8004cca:	601a      	str	r2, [r3, #0]

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 8004ccc:	68fb      	ldr	r3, [r7, #12]
 8004cce:	681b      	ldr	r3, [r3, #0]
 8004cd0:	68fa      	ldr	r2, [r7, #12]
 8004cd2:	6812      	ldr	r2, [r2, #0]
 8004cd4:	6812      	ldr	r2, [r2, #0]
 8004cd6:	f042 0201 	orr.w	r2, r2, #1
 8004cda:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 8004cdc:	2300      	movs	r3, #0
} 
 8004cde:	4618      	mov	r0, r3
 8004ce0:	3710      	adds	r7, #16
 8004ce2:	46bd      	mov	sp, r7
 8004ce4:	bd80      	pop	{r7, pc}
 8004ce6:	bf00      	nop

08004ce8 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8004ce8:	b580      	push	{r7, lr}
 8004cea:	b082      	sub	sp, #8
 8004cec:	af00      	add	r7, sp, #0
 8004cee:	6078      	str	r0, [r7, #4]
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8004cf0:	687b      	ldr	r3, [r7, #4]
 8004cf2:	681b      	ldr	r3, [r3, #0]
 8004cf4:	461a      	mov	r2, r3
 8004cf6:	4b78      	ldr	r3, [pc, #480]	; (8004ed8 <HAL_DMA_IRQHandler+0x1f0>)
 8004cf8:	429a      	cmp	r2, r3
 8004cfa:	d972      	bls.n	8004de2 <HAL_DMA_IRQHandler+0xfa>
 8004cfc:	4b77      	ldr	r3, [pc, #476]	; (8004edc <HAL_DMA_IRQHandler+0x1f4>)
 8004cfe:	685a      	ldr	r2, [r3, #4]
 8004d00:	687b      	ldr	r3, [r7, #4]
 8004d02:	681b      	ldr	r3, [r3, #0]
 8004d04:	4619      	mov	r1, r3
 8004d06:	4b76      	ldr	r3, [pc, #472]	; (8004ee0 <HAL_DMA_IRQHandler+0x1f8>)
 8004d08:	4299      	cmp	r1, r3
 8004d0a:	d062      	beq.n	8004dd2 <HAL_DMA_IRQHandler+0xea>
 8004d0c:	687b      	ldr	r3, [r7, #4]
 8004d0e:	681b      	ldr	r3, [r3, #0]
 8004d10:	4619      	mov	r1, r3
 8004d12:	4b74      	ldr	r3, [pc, #464]	; (8004ee4 <HAL_DMA_IRQHandler+0x1fc>)
 8004d14:	4299      	cmp	r1, r3
 8004d16:	d05a      	beq.n	8004dce <HAL_DMA_IRQHandler+0xe6>
 8004d18:	687b      	ldr	r3, [r7, #4]
 8004d1a:	681b      	ldr	r3, [r3, #0]
 8004d1c:	4619      	mov	r1, r3
 8004d1e:	4b72      	ldr	r3, [pc, #456]	; (8004ee8 <HAL_DMA_IRQHandler+0x200>)
 8004d20:	4299      	cmp	r1, r3
 8004d22:	d052      	beq.n	8004dca <HAL_DMA_IRQHandler+0xe2>
 8004d24:	687b      	ldr	r3, [r7, #4]
 8004d26:	681b      	ldr	r3, [r3, #0]
 8004d28:	4619      	mov	r1, r3
 8004d2a:	4b70      	ldr	r3, [pc, #448]	; (8004eec <HAL_DMA_IRQHandler+0x204>)
 8004d2c:	4299      	cmp	r1, r3
 8004d2e:	d04a      	beq.n	8004dc6 <HAL_DMA_IRQHandler+0xde>
 8004d30:	687b      	ldr	r3, [r7, #4]
 8004d32:	681b      	ldr	r3, [r3, #0]
 8004d34:	4619      	mov	r1, r3
 8004d36:	4b6e      	ldr	r3, [pc, #440]	; (8004ef0 <HAL_DMA_IRQHandler+0x208>)
 8004d38:	4299      	cmp	r1, r3
 8004d3a:	d041      	beq.n	8004dc0 <HAL_DMA_IRQHandler+0xd8>
 8004d3c:	687b      	ldr	r3, [r7, #4]
 8004d3e:	681b      	ldr	r3, [r3, #0]
 8004d40:	4619      	mov	r1, r3
 8004d42:	4b6c      	ldr	r3, [pc, #432]	; (8004ef4 <HAL_DMA_IRQHandler+0x20c>)
 8004d44:	4299      	cmp	r1, r3
 8004d46:	d038      	beq.n	8004dba <HAL_DMA_IRQHandler+0xd2>
 8004d48:	687b      	ldr	r3, [r7, #4]
 8004d4a:	681b      	ldr	r3, [r3, #0]
 8004d4c:	4619      	mov	r1, r3
 8004d4e:	4b6a      	ldr	r3, [pc, #424]	; (8004ef8 <HAL_DMA_IRQHandler+0x210>)
 8004d50:	4299      	cmp	r1, r3
 8004d52:	d02f      	beq.n	8004db4 <HAL_DMA_IRQHandler+0xcc>
 8004d54:	687b      	ldr	r3, [r7, #4]
 8004d56:	681b      	ldr	r3, [r3, #0]
 8004d58:	4619      	mov	r1, r3
 8004d5a:	4b68      	ldr	r3, [pc, #416]	; (8004efc <HAL_DMA_IRQHandler+0x214>)
 8004d5c:	4299      	cmp	r1, r3
 8004d5e:	d026      	beq.n	8004dae <HAL_DMA_IRQHandler+0xc6>
 8004d60:	687b      	ldr	r3, [r7, #4]
 8004d62:	681b      	ldr	r3, [r3, #0]
 8004d64:	4619      	mov	r1, r3
 8004d66:	4b66      	ldr	r3, [pc, #408]	; (8004f00 <HAL_DMA_IRQHandler+0x218>)
 8004d68:	4299      	cmp	r1, r3
 8004d6a:	d01d      	beq.n	8004da8 <HAL_DMA_IRQHandler+0xc0>
 8004d6c:	687b      	ldr	r3, [r7, #4]
 8004d6e:	681b      	ldr	r3, [r3, #0]
 8004d70:	4619      	mov	r1, r3
 8004d72:	4b64      	ldr	r3, [pc, #400]	; (8004f04 <HAL_DMA_IRQHandler+0x21c>)
 8004d74:	4299      	cmp	r1, r3
 8004d76:	d014      	beq.n	8004da2 <HAL_DMA_IRQHandler+0xba>
 8004d78:	687b      	ldr	r3, [r7, #4]
 8004d7a:	681b      	ldr	r3, [r3, #0]
 8004d7c:	4619      	mov	r1, r3
 8004d7e:	4b62      	ldr	r3, [pc, #392]	; (8004f08 <HAL_DMA_IRQHandler+0x220>)
 8004d80:	4299      	cmp	r1, r3
 8004d82:	d00b      	beq.n	8004d9c <HAL_DMA_IRQHandler+0xb4>
 8004d84:	687b      	ldr	r3, [r7, #4]
 8004d86:	681b      	ldr	r3, [r3, #0]
 8004d88:	4619      	mov	r1, r3
 8004d8a:	4b60      	ldr	r3, [pc, #384]	; (8004f0c <HAL_DMA_IRQHandler+0x224>)
 8004d8c:	4299      	cmp	r1, r3
 8004d8e:	d102      	bne.n	8004d96 <HAL_DMA_IRQHandler+0xae>
 8004d90:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004d94:	e01e      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004d96:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8004d9a:	e01b      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004d9c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004da0:	e018      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004da2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004da6:	e015      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004da8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004dac:	e012      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004dae:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004db2:	e00f      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004db4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004db8:	e00c      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004dba:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004dbe:	e009      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004dc0:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004dc4:	e006      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004dc6:	2308      	movs	r3, #8
 8004dc8:	e004      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004dca:	2308      	movs	r3, #8
 8004dcc:	e002      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004dce:	2308      	movs	r3, #8
 8004dd0:	e000      	b.n	8004dd4 <HAL_DMA_IRQHandler+0xec>
 8004dd2:	2308      	movs	r3, #8
 8004dd4:	4013      	ands	r3, r2
 8004dd6:	2b00      	cmp	r3, #0
 8004dd8:	bf14      	ite	ne
 8004dda:	2301      	movne	r3, #1
 8004ddc:	2300      	moveq	r3, #0
 8004dde:	b2db      	uxtb	r3, r3
 8004de0:	e19f      	b.n	8005122 <HAL_DMA_IRQHandler+0x43a>
 8004de2:	687b      	ldr	r3, [r7, #4]
 8004de4:	681b      	ldr	r3, [r3, #0]
 8004de6:	461a      	mov	r2, r3
 8004de8:	4b49      	ldr	r3, [pc, #292]	; (8004f10 <HAL_DMA_IRQHandler+0x228>)
 8004dea:	429a      	cmp	r2, r3
 8004dec:	f240 8092 	bls.w	8004f14 <HAL_DMA_IRQHandler+0x22c>
 8004df0:	4b3a      	ldr	r3, [pc, #232]	; (8004edc <HAL_DMA_IRQHandler+0x1f4>)
 8004df2:	681a      	ldr	r2, [r3, #0]
 8004df4:	687b      	ldr	r3, [r7, #4]
 8004df6:	681b      	ldr	r3, [r3, #0]
 8004df8:	4619      	mov	r1, r3
 8004dfa:	4b39      	ldr	r3, [pc, #228]	; (8004ee0 <HAL_DMA_IRQHandler+0x1f8>)
 8004dfc:	4299      	cmp	r1, r3
 8004dfe:	d062      	beq.n	8004ec6 <HAL_DMA_IRQHandler+0x1de>
 8004e00:	687b      	ldr	r3, [r7, #4]
 8004e02:	681b      	ldr	r3, [r3, #0]
 8004e04:	4619      	mov	r1, r3
 8004e06:	4b37      	ldr	r3, [pc, #220]	; (8004ee4 <HAL_DMA_IRQHandler+0x1fc>)
 8004e08:	4299      	cmp	r1, r3
 8004e0a:	d05a      	beq.n	8004ec2 <HAL_DMA_IRQHandler+0x1da>
 8004e0c:	687b      	ldr	r3, [r7, #4]
 8004e0e:	681b      	ldr	r3, [r3, #0]
 8004e10:	4619      	mov	r1, r3
 8004e12:	4b35      	ldr	r3, [pc, #212]	; (8004ee8 <HAL_DMA_IRQHandler+0x200>)
 8004e14:	4299      	cmp	r1, r3
 8004e16:	d052      	beq.n	8004ebe <HAL_DMA_IRQHandler+0x1d6>
 8004e18:	687b      	ldr	r3, [r7, #4]
 8004e1a:	681b      	ldr	r3, [r3, #0]
 8004e1c:	4619      	mov	r1, r3
 8004e1e:	4b33      	ldr	r3, [pc, #204]	; (8004eec <HAL_DMA_IRQHandler+0x204>)
 8004e20:	4299      	cmp	r1, r3
 8004e22:	d04a      	beq.n	8004eba <HAL_DMA_IRQHandler+0x1d2>
 8004e24:	687b      	ldr	r3, [r7, #4]
 8004e26:	681b      	ldr	r3, [r3, #0]
 8004e28:	4619      	mov	r1, r3
 8004e2a:	4b31      	ldr	r3, [pc, #196]	; (8004ef0 <HAL_DMA_IRQHandler+0x208>)
 8004e2c:	4299      	cmp	r1, r3
 8004e2e:	d041      	beq.n	8004eb4 <HAL_DMA_IRQHandler+0x1cc>
 8004e30:	687b      	ldr	r3, [r7, #4]
 8004e32:	681b      	ldr	r3, [r3, #0]
 8004e34:	4619      	mov	r1, r3
 8004e36:	4b2f      	ldr	r3, [pc, #188]	; (8004ef4 <HAL_DMA_IRQHandler+0x20c>)
 8004e38:	4299      	cmp	r1, r3
 8004e3a:	d038      	beq.n	8004eae <HAL_DMA_IRQHandler+0x1c6>
 8004e3c:	687b      	ldr	r3, [r7, #4]
 8004e3e:	681b      	ldr	r3, [r3, #0]
 8004e40:	4619      	mov	r1, r3
 8004e42:	4b2d      	ldr	r3, [pc, #180]	; (8004ef8 <HAL_DMA_IRQHandler+0x210>)
 8004e44:	4299      	cmp	r1, r3
 8004e46:	d02f      	beq.n	8004ea8 <HAL_DMA_IRQHandler+0x1c0>
 8004e48:	687b      	ldr	r3, [r7, #4]
 8004e4a:	681b      	ldr	r3, [r3, #0]
 8004e4c:	4619      	mov	r1, r3
 8004e4e:	4b2b      	ldr	r3, [pc, #172]	; (8004efc <HAL_DMA_IRQHandler+0x214>)
 8004e50:	4299      	cmp	r1, r3
 8004e52:	d026      	beq.n	8004ea2 <HAL_DMA_IRQHandler+0x1ba>
 8004e54:	687b      	ldr	r3, [r7, #4]
 8004e56:	681b      	ldr	r3, [r3, #0]
 8004e58:	4619      	mov	r1, r3
 8004e5a:	4b29      	ldr	r3, [pc, #164]	; (8004f00 <HAL_DMA_IRQHandler+0x218>)
 8004e5c:	4299      	cmp	r1, r3
 8004e5e:	d01d      	beq.n	8004e9c <HAL_DMA_IRQHandler+0x1b4>
 8004e60:	687b      	ldr	r3, [r7, #4]
 8004e62:	681b      	ldr	r3, [r3, #0]
 8004e64:	4619      	mov	r1, r3
 8004e66:	4b27      	ldr	r3, [pc, #156]	; (8004f04 <HAL_DMA_IRQHandler+0x21c>)
 8004e68:	4299      	cmp	r1, r3
 8004e6a:	d014      	beq.n	8004e96 <HAL_DMA_IRQHandler+0x1ae>
 8004e6c:	687b      	ldr	r3, [r7, #4]
 8004e6e:	681b      	ldr	r3, [r3, #0]
 8004e70:	4619      	mov	r1, r3
 8004e72:	4b25      	ldr	r3, [pc, #148]	; (8004f08 <HAL_DMA_IRQHandler+0x220>)
 8004e74:	4299      	cmp	r1, r3
 8004e76:	d00b      	beq.n	8004e90 <HAL_DMA_IRQHandler+0x1a8>
 8004e78:	687b      	ldr	r3, [r7, #4]
 8004e7a:	681b      	ldr	r3, [r3, #0]
 8004e7c:	4619      	mov	r1, r3
 8004e7e:	4b23      	ldr	r3, [pc, #140]	; (8004f0c <HAL_DMA_IRQHandler+0x224>)
 8004e80:	4299      	cmp	r1, r3
 8004e82:	d102      	bne.n	8004e8a <HAL_DMA_IRQHandler+0x1a2>
 8004e84:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004e88:	e01e      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004e8a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8004e8e:	e01b      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004e90:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004e94:	e018      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004e96:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004e9a:	e015      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004e9c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004ea0:	e012      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004ea2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004ea6:	e00f      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004ea8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004eac:	e00c      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004eae:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004eb2:	e009      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004eb4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004eb8:	e006      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004eba:	2308      	movs	r3, #8
 8004ebc:	e004      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004ebe:	2308      	movs	r3, #8
 8004ec0:	e002      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004ec2:	2308      	movs	r3, #8
 8004ec4:	e000      	b.n	8004ec8 <HAL_DMA_IRQHandler+0x1e0>
 8004ec6:	2308      	movs	r3, #8
 8004ec8:	4013      	ands	r3, r2
 8004eca:	2b00      	cmp	r3, #0
 8004ecc:	bf14      	ite	ne
 8004ece:	2301      	movne	r3, #1
 8004ed0:	2300      	moveq	r3, #0
 8004ed2:	b2db      	uxtb	r3, r3
 8004ed4:	e125      	b.n	8005122 <HAL_DMA_IRQHandler+0x43a>
 8004ed6:	bf00      	nop
 8004ed8:	40026458 	.word	0x40026458
 8004edc:	40026400 	.word	0x40026400
 8004ee0:	40026010 	.word	0x40026010
 8004ee4:	40026410 	.word	0x40026410
 8004ee8:	40026070 	.word	0x40026070
 8004eec:	40026470 	.word	0x40026470
 8004ef0:	40026028 	.word	0x40026028
 8004ef4:	40026428 	.word	0x40026428
 8004ef8:	40026088 	.word	0x40026088
 8004efc:	40026488 	.word	0x40026488
 8004f00:	40026040 	.word	0x40026040
 8004f04:	40026440 	.word	0x40026440
 8004f08:	400260a0 	.word	0x400260a0
 8004f0c:	400264a0 	.word	0x400264a0
 8004f10:	400260b8 	.word	0x400260b8
 8004f14:	687b      	ldr	r3, [r7, #4]
 8004f16:	681b      	ldr	r3, [r3, #0]
 8004f18:	461a      	mov	r2, r3
 8004f1a:	4b70      	ldr	r3, [pc, #448]	; (80050dc <HAL_DMA_IRQHandler+0x3f4>)
 8004f1c:	429a      	cmp	r2, r3
 8004f1e:	d972      	bls.n	8005006 <HAL_DMA_IRQHandler+0x31e>
 8004f20:	4b6f      	ldr	r3, [pc, #444]	; (80050e0 <HAL_DMA_IRQHandler+0x3f8>)
 8004f22:	685a      	ldr	r2, [r3, #4]
 8004f24:	687b      	ldr	r3, [r7, #4]
 8004f26:	681b      	ldr	r3, [r3, #0]
 8004f28:	4619      	mov	r1, r3
 8004f2a:	4b6e      	ldr	r3, [pc, #440]	; (80050e4 <HAL_DMA_IRQHandler+0x3fc>)
 8004f2c:	4299      	cmp	r1, r3
 8004f2e:	d062      	beq.n	8004ff6 <HAL_DMA_IRQHandler+0x30e>
 8004f30:	687b      	ldr	r3, [r7, #4]
 8004f32:	681b      	ldr	r3, [r3, #0]
 8004f34:	4619      	mov	r1, r3
 8004f36:	4b6c      	ldr	r3, [pc, #432]	; (80050e8 <HAL_DMA_IRQHandler+0x400>)
 8004f38:	4299      	cmp	r1, r3
 8004f3a:	d05a      	beq.n	8004ff2 <HAL_DMA_IRQHandler+0x30a>
 8004f3c:	687b      	ldr	r3, [r7, #4]
 8004f3e:	681b      	ldr	r3, [r3, #0]
 8004f40:	4619      	mov	r1, r3
 8004f42:	4b6a      	ldr	r3, [pc, #424]	; (80050ec <HAL_DMA_IRQHandler+0x404>)
 8004f44:	4299      	cmp	r1, r3
 8004f46:	d052      	beq.n	8004fee <HAL_DMA_IRQHandler+0x306>
 8004f48:	687b      	ldr	r3, [r7, #4]
 8004f4a:	681b      	ldr	r3, [r3, #0]
 8004f4c:	4619      	mov	r1, r3
 8004f4e:	4b68      	ldr	r3, [pc, #416]	; (80050f0 <HAL_DMA_IRQHandler+0x408>)
 8004f50:	4299      	cmp	r1, r3
 8004f52:	d04a      	beq.n	8004fea <HAL_DMA_IRQHandler+0x302>
 8004f54:	687b      	ldr	r3, [r7, #4]
 8004f56:	681b      	ldr	r3, [r3, #0]
 8004f58:	4619      	mov	r1, r3
 8004f5a:	4b66      	ldr	r3, [pc, #408]	; (80050f4 <HAL_DMA_IRQHandler+0x40c>)
 8004f5c:	4299      	cmp	r1, r3
 8004f5e:	d041      	beq.n	8004fe4 <HAL_DMA_IRQHandler+0x2fc>
 8004f60:	687b      	ldr	r3, [r7, #4]
 8004f62:	681b      	ldr	r3, [r3, #0]
 8004f64:	4619      	mov	r1, r3
 8004f66:	4b64      	ldr	r3, [pc, #400]	; (80050f8 <HAL_DMA_IRQHandler+0x410>)
 8004f68:	4299      	cmp	r1, r3
 8004f6a:	d038      	beq.n	8004fde <HAL_DMA_IRQHandler+0x2f6>
 8004f6c:	687b      	ldr	r3, [r7, #4]
 8004f6e:	681b      	ldr	r3, [r3, #0]
 8004f70:	4619      	mov	r1, r3
 8004f72:	4b62      	ldr	r3, [pc, #392]	; (80050fc <HAL_DMA_IRQHandler+0x414>)
 8004f74:	4299      	cmp	r1, r3
 8004f76:	d02f      	beq.n	8004fd8 <HAL_DMA_IRQHandler+0x2f0>
 8004f78:	687b      	ldr	r3, [r7, #4]
 8004f7a:	681b      	ldr	r3, [r3, #0]
 8004f7c:	4619      	mov	r1, r3
 8004f7e:	4b60      	ldr	r3, [pc, #384]	; (8005100 <HAL_DMA_IRQHandler+0x418>)
 8004f80:	4299      	cmp	r1, r3
 8004f82:	d026      	beq.n	8004fd2 <HAL_DMA_IRQHandler+0x2ea>
 8004f84:	687b      	ldr	r3, [r7, #4]
 8004f86:	681b      	ldr	r3, [r3, #0]
 8004f88:	4619      	mov	r1, r3
 8004f8a:	4b5e      	ldr	r3, [pc, #376]	; (8005104 <HAL_DMA_IRQHandler+0x41c>)
 8004f8c:	4299      	cmp	r1, r3
 8004f8e:	d01d      	beq.n	8004fcc <HAL_DMA_IRQHandler+0x2e4>
 8004f90:	687b      	ldr	r3, [r7, #4]
 8004f92:	681b      	ldr	r3, [r3, #0]
 8004f94:	4619      	mov	r1, r3
 8004f96:	4b5c      	ldr	r3, [pc, #368]	; (8005108 <HAL_DMA_IRQHandler+0x420>)
 8004f98:	4299      	cmp	r1, r3
 8004f9a:	d014      	beq.n	8004fc6 <HAL_DMA_IRQHandler+0x2de>
 8004f9c:	687b      	ldr	r3, [r7, #4]
 8004f9e:	681b      	ldr	r3, [r3, #0]
 8004fa0:	4619      	mov	r1, r3
 8004fa2:	4b5a      	ldr	r3, [pc, #360]	; (800510c <HAL_DMA_IRQHandler+0x424>)
 8004fa4:	4299      	cmp	r1, r3
 8004fa6:	d00b      	beq.n	8004fc0 <HAL_DMA_IRQHandler+0x2d8>
 8004fa8:	687b      	ldr	r3, [r7, #4]
 8004faa:	681b      	ldr	r3, [r3, #0]
 8004fac:	4619      	mov	r1, r3
 8004fae:	4b58      	ldr	r3, [pc, #352]	; (8005110 <HAL_DMA_IRQHandler+0x428>)
 8004fb0:	4299      	cmp	r1, r3
 8004fb2:	d102      	bne.n	8004fba <HAL_DMA_IRQHandler+0x2d2>
 8004fb4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004fb8:	e01e      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fba:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8004fbe:	e01b      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fc0:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004fc4:	e018      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fc6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004fca:	e015      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fcc:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004fd0:	e012      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fd2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004fd6:	e00f      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fd8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004fdc:	e00c      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fde:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004fe2:	e009      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fe4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004fe8:	e006      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fea:	2308      	movs	r3, #8
 8004fec:	e004      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004fee:	2308      	movs	r3, #8
 8004ff0:	e002      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004ff2:	2308      	movs	r3, #8
 8004ff4:	e000      	b.n	8004ff8 <HAL_DMA_IRQHandler+0x310>
 8004ff6:	2308      	movs	r3, #8
 8004ff8:	4013      	ands	r3, r2
 8004ffa:	2b00      	cmp	r3, #0
 8004ffc:	bf14      	ite	ne
 8004ffe:	2301      	movne	r3, #1
 8005000:	2300      	moveq	r3, #0
 8005002:	b2db      	uxtb	r3, r3
 8005004:	e08d      	b.n	8005122 <HAL_DMA_IRQHandler+0x43a>
 8005006:	4b36      	ldr	r3, [pc, #216]	; (80050e0 <HAL_DMA_IRQHandler+0x3f8>)
 8005008:	681a      	ldr	r2, [r3, #0]
 800500a:	687b      	ldr	r3, [r7, #4]
 800500c:	681b      	ldr	r3, [r3, #0]
 800500e:	4619      	mov	r1, r3
 8005010:	4b34      	ldr	r3, [pc, #208]	; (80050e4 <HAL_DMA_IRQHandler+0x3fc>)
 8005012:	4299      	cmp	r1, r3
 8005014:	d07e      	beq.n	8005114 <HAL_DMA_IRQHandler+0x42c>
 8005016:	687b      	ldr	r3, [r7, #4]
 8005018:	681b      	ldr	r3, [r3, #0]
 800501a:	4619      	mov	r1, r3
 800501c:	4b32      	ldr	r3, [pc, #200]	; (80050e8 <HAL_DMA_IRQHandler+0x400>)
 800501e:	4299      	cmp	r1, r3
 8005020:	d05a      	beq.n	80050d8 <HAL_DMA_IRQHandler+0x3f0>
 8005022:	687b      	ldr	r3, [r7, #4]
 8005024:	681b      	ldr	r3, [r3, #0]
 8005026:	4619      	mov	r1, r3
 8005028:	4b30      	ldr	r3, [pc, #192]	; (80050ec <HAL_DMA_IRQHandler+0x404>)
 800502a:	4299      	cmp	r1, r3
 800502c:	d052      	beq.n	80050d4 <HAL_DMA_IRQHandler+0x3ec>
 800502e:	687b      	ldr	r3, [r7, #4]
 8005030:	681b      	ldr	r3, [r3, #0]
 8005032:	4619      	mov	r1, r3
 8005034:	4b2e      	ldr	r3, [pc, #184]	; (80050f0 <HAL_DMA_IRQHandler+0x408>)
 8005036:	4299      	cmp	r1, r3
 8005038:	d04a      	beq.n	80050d0 <HAL_DMA_IRQHandler+0x3e8>
 800503a:	687b      	ldr	r3, [r7, #4]
 800503c:	681b      	ldr	r3, [r3, #0]
 800503e:	4619      	mov	r1, r3
 8005040:	4b2c      	ldr	r3, [pc, #176]	; (80050f4 <HAL_DMA_IRQHandler+0x40c>)
 8005042:	4299      	cmp	r1, r3
 8005044:	d041      	beq.n	80050ca <HAL_DMA_IRQHandler+0x3e2>
 8005046:	687b      	ldr	r3, [r7, #4]
 8005048:	681b      	ldr	r3, [r3, #0]
 800504a:	4619      	mov	r1, r3
 800504c:	4b2a      	ldr	r3, [pc, #168]	; (80050f8 <HAL_DMA_IRQHandler+0x410>)
 800504e:	4299      	cmp	r1, r3
 8005050:	d038      	beq.n	80050c4 <HAL_DMA_IRQHandler+0x3dc>
 8005052:	687b      	ldr	r3, [r7, #4]
 8005054:	681b      	ldr	r3, [r3, #0]
 8005056:	4619      	mov	r1, r3
 8005058:	4b28      	ldr	r3, [pc, #160]	; (80050fc <HAL_DMA_IRQHandler+0x414>)
 800505a:	4299      	cmp	r1, r3
 800505c:	d02f      	beq.n	80050be <HAL_DMA_IRQHandler+0x3d6>
 800505e:	687b      	ldr	r3, [r7, #4]
 8005060:	681b      	ldr	r3, [r3, #0]
 8005062:	4619      	mov	r1, r3
 8005064:	4b26      	ldr	r3, [pc, #152]	; (8005100 <HAL_DMA_IRQHandler+0x418>)
 8005066:	4299      	cmp	r1, r3
 8005068:	d026      	beq.n	80050b8 <HAL_DMA_IRQHandler+0x3d0>
 800506a:	687b      	ldr	r3, [r7, #4]
 800506c:	681b      	ldr	r3, [r3, #0]
 800506e:	4619      	mov	r1, r3
 8005070:	4b24      	ldr	r3, [pc, #144]	; (8005104 <HAL_DMA_IRQHandler+0x41c>)
 8005072:	4299      	cmp	r1, r3
 8005074:	d01d      	beq.n	80050b2 <HAL_DMA_IRQHandler+0x3ca>
 8005076:	687b      	ldr	r3, [r7, #4]
 8005078:	681b      	ldr	r3, [r3, #0]
 800507a:	4619      	mov	r1, r3
 800507c:	4b22      	ldr	r3, [pc, #136]	; (8005108 <HAL_DMA_IRQHandler+0x420>)
 800507e:	4299      	cmp	r1, r3
 8005080:	d014      	beq.n	80050ac <HAL_DMA_IRQHandler+0x3c4>
 8005082:	687b      	ldr	r3, [r7, #4]
 8005084:	681b      	ldr	r3, [r3, #0]
 8005086:	4619      	mov	r1, r3
 8005088:	4b20      	ldr	r3, [pc, #128]	; (800510c <HAL_DMA_IRQHandler+0x424>)
 800508a:	4299      	cmp	r1, r3
 800508c:	d00b      	beq.n	80050a6 <HAL_DMA_IRQHandler+0x3be>
 800508e:	687b      	ldr	r3, [r7, #4]
 8005090:	681b      	ldr	r3, [r3, #0]
 8005092:	4619      	mov	r1, r3
 8005094:	4b1e      	ldr	r3, [pc, #120]	; (8005110 <HAL_DMA_IRQHandler+0x428>)
 8005096:	4299      	cmp	r1, r3
 8005098:	d102      	bne.n	80050a0 <HAL_DMA_IRQHandler+0x3b8>
 800509a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800509e:	e03a      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050a0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80050a4:	e037      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050a6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80050aa:	e034      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050ac:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80050b0:	e031      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050b2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80050b6:	e02e      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050b8:	f44f 7300 	mov.w	r3, #512	; 0x200
 80050bc:	e02b      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050be:	f44f 7300 	mov.w	r3, #512	; 0x200
 80050c2:	e028      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050c4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80050c8:	e025      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050ca:	f44f 7300 	mov.w	r3, #512	; 0x200
 80050ce:	e022      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050d0:	2308      	movs	r3, #8
 80050d2:	e020      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050d4:	2308      	movs	r3, #8
 80050d6:	e01e      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050d8:	2308      	movs	r3, #8
 80050da:	e01c      	b.n	8005116 <HAL_DMA_IRQHandler+0x42e>
 80050dc:	40026058 	.word	0x40026058
 80050e0:	40026000 	.word	0x40026000
 80050e4:	40026010 	.word	0x40026010
 80050e8:	40026410 	.word	0x40026410
 80050ec:	40026070 	.word	0x40026070
 80050f0:	40026470 	.word	0x40026470
 80050f4:	40026028 	.word	0x40026028
 80050f8:	40026428 	.word	0x40026428
 80050fc:	40026088 	.word	0x40026088
 8005100:	40026488 	.word	0x40026488
 8005104:	40026040 	.word	0x40026040
 8005108:	40026440 	.word	0x40026440
 800510c:	400260a0 	.word	0x400260a0
 8005110:	400264a0 	.word	0x400264a0
 8005114:	2308      	movs	r3, #8
 8005116:	4013      	ands	r3, r2
 8005118:	2b00      	cmp	r3, #0
 800511a:	bf14      	ite	ne
 800511c:	2301      	movne	r3, #1
 800511e:	2300      	moveq	r3, #0
 8005120:	b2db      	uxtb	r3, r3
 8005122:	2b00      	cmp	r3, #0
 8005124:	f000 8210 	beq.w	8005548 <HAL_DMA_IRQHandler+0x860>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8005128:	687b      	ldr	r3, [r7, #4]
 800512a:	681b      	ldr	r3, [r3, #0]
 800512c:	681b      	ldr	r3, [r3, #0]
 800512e:	f003 0304 	and.w	r3, r3, #4
 8005132:	2b00      	cmp	r3, #0
 8005134:	f000 8208 	beq.w	8005548 <HAL_DMA_IRQHandler+0x860>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 8005138:	687b      	ldr	r3, [r7, #4]
 800513a:	681b      	ldr	r3, [r3, #0]
 800513c:	687a      	ldr	r2, [r7, #4]
 800513e:	6812      	ldr	r2, [r2, #0]
 8005140:	6812      	ldr	r2, [r2, #0]
 8005142:	f022 0204 	bic.w	r2, r2, #4
 8005146:	601a      	str	r2, [r3, #0]

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8005148:	687b      	ldr	r3, [r7, #4]
 800514a:	681b      	ldr	r3, [r3, #0]
 800514c:	461a      	mov	r2, r3
 800514e:	4ba0      	ldr	r3, [pc, #640]	; (80053d0 <HAL_DMA_IRQHandler+0x6e8>)
 8005150:	429a      	cmp	r2, r3
 8005152:	d96c      	bls.n	800522e <HAL_DMA_IRQHandler+0x546>
 8005154:	4a9f      	ldr	r2, [pc, #636]	; (80053d4 <HAL_DMA_IRQHandler+0x6ec>)
 8005156:	687b      	ldr	r3, [r7, #4]
 8005158:	681b      	ldr	r3, [r3, #0]
 800515a:	4619      	mov	r1, r3
 800515c:	4b9e      	ldr	r3, [pc, #632]	; (80053d8 <HAL_DMA_IRQHandler+0x6f0>)
 800515e:	4299      	cmp	r1, r3
 8005160:	d062      	beq.n	8005228 <HAL_DMA_IRQHandler+0x540>
 8005162:	687b      	ldr	r3, [r7, #4]
 8005164:	681b      	ldr	r3, [r3, #0]
 8005166:	4619      	mov	r1, r3
 8005168:	4b9c      	ldr	r3, [pc, #624]	; (80053dc <HAL_DMA_IRQHandler+0x6f4>)
 800516a:	4299      	cmp	r1, r3
 800516c:	d05a      	beq.n	8005224 <HAL_DMA_IRQHandler+0x53c>
 800516e:	687b      	ldr	r3, [r7, #4]
 8005170:	681b      	ldr	r3, [r3, #0]
 8005172:	4619      	mov	r1, r3
 8005174:	4b9a      	ldr	r3, [pc, #616]	; (80053e0 <HAL_DMA_IRQHandler+0x6f8>)
 8005176:	4299      	cmp	r1, r3
 8005178:	d052      	beq.n	8005220 <HAL_DMA_IRQHandler+0x538>
 800517a:	687b      	ldr	r3, [r7, #4]
 800517c:	681b      	ldr	r3, [r3, #0]
 800517e:	4619      	mov	r1, r3
 8005180:	4b98      	ldr	r3, [pc, #608]	; (80053e4 <HAL_DMA_IRQHandler+0x6fc>)
 8005182:	4299      	cmp	r1, r3
 8005184:	d04a      	beq.n	800521c <HAL_DMA_IRQHandler+0x534>
 8005186:	687b      	ldr	r3, [r7, #4]
 8005188:	681b      	ldr	r3, [r3, #0]
 800518a:	4619      	mov	r1, r3
 800518c:	4b96      	ldr	r3, [pc, #600]	; (80053e8 <HAL_DMA_IRQHandler+0x700>)
 800518e:	4299      	cmp	r1, r3
 8005190:	d041      	beq.n	8005216 <HAL_DMA_IRQHandler+0x52e>
 8005192:	687b      	ldr	r3, [r7, #4]
 8005194:	681b      	ldr	r3, [r3, #0]
 8005196:	4619      	mov	r1, r3
 8005198:	4b94      	ldr	r3, [pc, #592]	; (80053ec <HAL_DMA_IRQHandler+0x704>)
 800519a:	4299      	cmp	r1, r3
 800519c:	d038      	beq.n	8005210 <HAL_DMA_IRQHandler+0x528>
 800519e:	687b      	ldr	r3, [r7, #4]
 80051a0:	681b      	ldr	r3, [r3, #0]
 80051a2:	4619      	mov	r1, r3
 80051a4:	4b92      	ldr	r3, [pc, #584]	; (80053f0 <HAL_DMA_IRQHandler+0x708>)
 80051a6:	4299      	cmp	r1, r3
 80051a8:	d02f      	beq.n	800520a <HAL_DMA_IRQHandler+0x522>
 80051aa:	687b      	ldr	r3, [r7, #4]
 80051ac:	681b      	ldr	r3, [r3, #0]
 80051ae:	4619      	mov	r1, r3
 80051b0:	4b90      	ldr	r3, [pc, #576]	; (80053f4 <HAL_DMA_IRQHandler+0x70c>)
 80051b2:	4299      	cmp	r1, r3
 80051b4:	d026      	beq.n	8005204 <HAL_DMA_IRQHandler+0x51c>
 80051b6:	687b      	ldr	r3, [r7, #4]
 80051b8:	681b      	ldr	r3, [r3, #0]
 80051ba:	4619      	mov	r1, r3
 80051bc:	4b8e      	ldr	r3, [pc, #568]	; (80053f8 <HAL_DMA_IRQHandler+0x710>)
 80051be:	4299      	cmp	r1, r3
 80051c0:	d01d      	beq.n	80051fe <HAL_DMA_IRQHandler+0x516>
 80051c2:	687b      	ldr	r3, [r7, #4]
 80051c4:	681b      	ldr	r3, [r3, #0]
 80051c6:	4619      	mov	r1, r3
 80051c8:	4b8c      	ldr	r3, [pc, #560]	; (80053fc <HAL_DMA_IRQHandler+0x714>)
 80051ca:	4299      	cmp	r1, r3
 80051cc:	d014      	beq.n	80051f8 <HAL_DMA_IRQHandler+0x510>
 80051ce:	687b      	ldr	r3, [r7, #4]
 80051d0:	681b      	ldr	r3, [r3, #0]
 80051d2:	4619      	mov	r1, r3
 80051d4:	4b8a      	ldr	r3, [pc, #552]	; (8005400 <HAL_DMA_IRQHandler+0x718>)
 80051d6:	4299      	cmp	r1, r3
 80051d8:	d00b      	beq.n	80051f2 <HAL_DMA_IRQHandler+0x50a>
 80051da:	687b      	ldr	r3, [r7, #4]
 80051dc:	681b      	ldr	r3, [r3, #0]
 80051de:	4619      	mov	r1, r3
 80051e0:	4b88      	ldr	r3, [pc, #544]	; (8005404 <HAL_DMA_IRQHandler+0x71c>)
 80051e2:	4299      	cmp	r1, r3
 80051e4:	d102      	bne.n	80051ec <HAL_DMA_IRQHandler+0x504>
 80051e6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80051ea:	e01e      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 80051ec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80051f0:	e01b      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 80051f2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80051f6:	e018      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 80051f8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80051fc:	e015      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 80051fe:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8005202:	e012      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 8005204:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005208:	e00f      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 800520a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800520e:	e00c      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 8005210:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005214:	e009      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 8005216:	f44f 7300 	mov.w	r3, #512	; 0x200
 800521a:	e006      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 800521c:	2308      	movs	r3, #8
 800521e:	e004      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 8005220:	2308      	movs	r3, #8
 8005222:	e002      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 8005224:	2308      	movs	r3, #8
 8005226:	e000      	b.n	800522a <HAL_DMA_IRQHandler+0x542>
 8005228:	2308      	movs	r3, #8
 800522a:	60d3      	str	r3, [r2, #12]
 800522c:	e176      	b.n	800551c <HAL_DMA_IRQHandler+0x834>
 800522e:	687b      	ldr	r3, [r7, #4]
 8005230:	681b      	ldr	r3, [r3, #0]
 8005232:	461a      	mov	r2, r3
 8005234:	4b74      	ldr	r3, [pc, #464]	; (8005408 <HAL_DMA_IRQHandler+0x720>)
 8005236:	429a      	cmp	r2, r3
 8005238:	d96c      	bls.n	8005314 <HAL_DMA_IRQHandler+0x62c>
 800523a:	4a66      	ldr	r2, [pc, #408]	; (80053d4 <HAL_DMA_IRQHandler+0x6ec>)
 800523c:	687b      	ldr	r3, [r7, #4]
 800523e:	681b      	ldr	r3, [r3, #0]
 8005240:	4619      	mov	r1, r3
 8005242:	4b65      	ldr	r3, [pc, #404]	; (80053d8 <HAL_DMA_IRQHandler+0x6f0>)
 8005244:	4299      	cmp	r1, r3
 8005246:	d062      	beq.n	800530e <HAL_DMA_IRQHandler+0x626>
 8005248:	687b      	ldr	r3, [r7, #4]
 800524a:	681b      	ldr	r3, [r3, #0]
 800524c:	4619      	mov	r1, r3
 800524e:	4b63      	ldr	r3, [pc, #396]	; (80053dc <HAL_DMA_IRQHandler+0x6f4>)
 8005250:	4299      	cmp	r1, r3
 8005252:	d05a      	beq.n	800530a <HAL_DMA_IRQHandler+0x622>
 8005254:	687b      	ldr	r3, [r7, #4]
 8005256:	681b      	ldr	r3, [r3, #0]
 8005258:	4619      	mov	r1, r3
 800525a:	4b61      	ldr	r3, [pc, #388]	; (80053e0 <HAL_DMA_IRQHandler+0x6f8>)
 800525c:	4299      	cmp	r1, r3
 800525e:	d052      	beq.n	8005306 <HAL_DMA_IRQHandler+0x61e>
 8005260:	687b      	ldr	r3, [r7, #4]
 8005262:	681b      	ldr	r3, [r3, #0]
 8005264:	4619      	mov	r1, r3
 8005266:	4b5f      	ldr	r3, [pc, #380]	; (80053e4 <HAL_DMA_IRQHandler+0x6fc>)
 8005268:	4299      	cmp	r1, r3
 800526a:	d04a      	beq.n	8005302 <HAL_DMA_IRQHandler+0x61a>
 800526c:	687b      	ldr	r3, [r7, #4]
 800526e:	681b      	ldr	r3, [r3, #0]
 8005270:	4619      	mov	r1, r3
 8005272:	4b5d      	ldr	r3, [pc, #372]	; (80053e8 <HAL_DMA_IRQHandler+0x700>)
 8005274:	4299      	cmp	r1, r3
 8005276:	d041      	beq.n	80052fc <HAL_DMA_IRQHandler+0x614>
 8005278:	687b      	ldr	r3, [r7, #4]
 800527a:	681b      	ldr	r3, [r3, #0]
 800527c:	4619      	mov	r1, r3
 800527e:	4b5b      	ldr	r3, [pc, #364]	; (80053ec <HAL_DMA_IRQHandler+0x704>)
 8005280:	4299      	cmp	r1, r3
 8005282:	d038      	beq.n	80052f6 <HAL_DMA_IRQHandler+0x60e>
 8005284:	687b      	ldr	r3, [r7, #4]
 8005286:	681b      	ldr	r3, [r3, #0]
 8005288:	4619      	mov	r1, r3
 800528a:	4b59      	ldr	r3, [pc, #356]	; (80053f0 <HAL_DMA_IRQHandler+0x708>)
 800528c:	4299      	cmp	r1, r3
 800528e:	d02f      	beq.n	80052f0 <HAL_DMA_IRQHandler+0x608>
 8005290:	687b      	ldr	r3, [r7, #4]
 8005292:	681b      	ldr	r3, [r3, #0]
 8005294:	4619      	mov	r1, r3
 8005296:	4b57      	ldr	r3, [pc, #348]	; (80053f4 <HAL_DMA_IRQHandler+0x70c>)
 8005298:	4299      	cmp	r1, r3
 800529a:	d026      	beq.n	80052ea <HAL_DMA_IRQHandler+0x602>
 800529c:	687b      	ldr	r3, [r7, #4]
 800529e:	681b      	ldr	r3, [r3, #0]
 80052a0:	4619      	mov	r1, r3
 80052a2:	4b55      	ldr	r3, [pc, #340]	; (80053f8 <HAL_DMA_IRQHandler+0x710>)
 80052a4:	4299      	cmp	r1, r3
 80052a6:	d01d      	beq.n	80052e4 <HAL_DMA_IRQHandler+0x5fc>
 80052a8:	687b      	ldr	r3, [r7, #4]
 80052aa:	681b      	ldr	r3, [r3, #0]
 80052ac:	4619      	mov	r1, r3
 80052ae:	4b53      	ldr	r3, [pc, #332]	; (80053fc <HAL_DMA_IRQHandler+0x714>)
 80052b0:	4299      	cmp	r1, r3
 80052b2:	d014      	beq.n	80052de <HAL_DMA_IRQHandler+0x5f6>
 80052b4:	687b      	ldr	r3, [r7, #4]
 80052b6:	681b      	ldr	r3, [r3, #0]
 80052b8:	4619      	mov	r1, r3
 80052ba:	4b51      	ldr	r3, [pc, #324]	; (8005400 <HAL_DMA_IRQHandler+0x718>)
 80052bc:	4299      	cmp	r1, r3
 80052be:	d00b      	beq.n	80052d8 <HAL_DMA_IRQHandler+0x5f0>
 80052c0:	687b      	ldr	r3, [r7, #4]
 80052c2:	681b      	ldr	r3, [r3, #0]
 80052c4:	4619      	mov	r1, r3
 80052c6:	4b4f      	ldr	r3, [pc, #316]	; (8005404 <HAL_DMA_IRQHandler+0x71c>)
 80052c8:	4299      	cmp	r1, r3
 80052ca:	d102      	bne.n	80052d2 <HAL_DMA_IRQHandler+0x5ea>
 80052cc:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80052d0:	e01e      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 80052d2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80052d6:	e01b      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 80052d8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80052dc:	e018      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 80052de:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80052e2:	e015      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 80052e4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80052e8:	e012      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 80052ea:	f44f 7300 	mov.w	r3, #512	; 0x200
 80052ee:	e00f      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 80052f0:	f44f 7300 	mov.w	r3, #512	; 0x200
 80052f4:	e00c      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 80052f6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80052fa:	e009      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 80052fc:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005300:	e006      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 8005302:	2308      	movs	r3, #8
 8005304:	e004      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 8005306:	2308      	movs	r3, #8
 8005308:	e002      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 800530a:	2308      	movs	r3, #8
 800530c:	e000      	b.n	8005310 <HAL_DMA_IRQHandler+0x628>
 800530e:	2308      	movs	r3, #8
 8005310:	6093      	str	r3, [r2, #8]
 8005312:	e103      	b.n	800551c <HAL_DMA_IRQHandler+0x834>
 8005314:	687b      	ldr	r3, [r7, #4]
 8005316:	681b      	ldr	r3, [r3, #0]
 8005318:	461a      	mov	r2, r3
 800531a:	4b3c      	ldr	r3, [pc, #240]	; (800540c <HAL_DMA_IRQHandler+0x724>)
 800531c:	429a      	cmp	r2, r3
 800531e:	f240 8091 	bls.w	8005444 <HAL_DMA_IRQHandler+0x75c>
 8005322:	4a3b      	ldr	r2, [pc, #236]	; (8005410 <HAL_DMA_IRQHandler+0x728>)
 8005324:	687b      	ldr	r3, [r7, #4]
 8005326:	681b      	ldr	r3, [r3, #0]
 8005328:	4619      	mov	r1, r3
 800532a:	4b2b      	ldr	r3, [pc, #172]	; (80053d8 <HAL_DMA_IRQHandler+0x6f0>)
 800532c:	4299      	cmp	r1, r3
 800532e:	f000 8086 	beq.w	800543e <HAL_DMA_IRQHandler+0x756>
 8005332:	687b      	ldr	r3, [r7, #4]
 8005334:	681b      	ldr	r3, [r3, #0]
 8005336:	4619      	mov	r1, r3
 8005338:	4b28      	ldr	r3, [pc, #160]	; (80053dc <HAL_DMA_IRQHandler+0x6f4>)
 800533a:	4299      	cmp	r1, r3
 800533c:	d07d      	beq.n	800543a <HAL_DMA_IRQHandler+0x752>
 800533e:	687b      	ldr	r3, [r7, #4]
 8005340:	681b      	ldr	r3, [r3, #0]
 8005342:	4619      	mov	r1, r3
 8005344:	4b26      	ldr	r3, [pc, #152]	; (80053e0 <HAL_DMA_IRQHandler+0x6f8>)
 8005346:	4299      	cmp	r1, r3
 8005348:	d075      	beq.n	8005436 <HAL_DMA_IRQHandler+0x74e>
 800534a:	687b      	ldr	r3, [r7, #4]
 800534c:	681b      	ldr	r3, [r3, #0]
 800534e:	4619      	mov	r1, r3
 8005350:	4b24      	ldr	r3, [pc, #144]	; (80053e4 <HAL_DMA_IRQHandler+0x6fc>)
 8005352:	4299      	cmp	r1, r3
 8005354:	d06d      	beq.n	8005432 <HAL_DMA_IRQHandler+0x74a>
 8005356:	687b      	ldr	r3, [r7, #4]
 8005358:	681b      	ldr	r3, [r3, #0]
 800535a:	4619      	mov	r1, r3
 800535c:	4b22      	ldr	r3, [pc, #136]	; (80053e8 <HAL_DMA_IRQHandler+0x700>)
 800535e:	4299      	cmp	r1, r3
 8005360:	d064      	beq.n	800542c <HAL_DMA_IRQHandler+0x744>
 8005362:	687b      	ldr	r3, [r7, #4]
 8005364:	681b      	ldr	r3, [r3, #0]
 8005366:	4619      	mov	r1, r3
 8005368:	4b20      	ldr	r3, [pc, #128]	; (80053ec <HAL_DMA_IRQHandler+0x704>)
 800536a:	4299      	cmp	r1, r3
 800536c:	d05b      	beq.n	8005426 <HAL_DMA_IRQHandler+0x73e>
 800536e:	687b      	ldr	r3, [r7, #4]
 8005370:	681b      	ldr	r3, [r3, #0]
 8005372:	4619      	mov	r1, r3
 8005374:	4b1e      	ldr	r3, [pc, #120]	; (80053f0 <HAL_DMA_IRQHandler+0x708>)
 8005376:	4299      	cmp	r1, r3
 8005378:	d052      	beq.n	8005420 <HAL_DMA_IRQHandler+0x738>
 800537a:	687b      	ldr	r3, [r7, #4]
 800537c:	681b      	ldr	r3, [r3, #0]
 800537e:	4619      	mov	r1, r3
 8005380:	4b1c      	ldr	r3, [pc, #112]	; (80053f4 <HAL_DMA_IRQHandler+0x70c>)
 8005382:	4299      	cmp	r1, r3
 8005384:	d049      	beq.n	800541a <HAL_DMA_IRQHandler+0x732>
 8005386:	687b      	ldr	r3, [r7, #4]
 8005388:	681b      	ldr	r3, [r3, #0]
 800538a:	4619      	mov	r1, r3
 800538c:	4b1a      	ldr	r3, [pc, #104]	; (80053f8 <HAL_DMA_IRQHandler+0x710>)
 800538e:	4299      	cmp	r1, r3
 8005390:	d040      	beq.n	8005414 <HAL_DMA_IRQHandler+0x72c>
 8005392:	687b      	ldr	r3, [r7, #4]
 8005394:	681b      	ldr	r3, [r3, #0]
 8005396:	4619      	mov	r1, r3
 8005398:	4b18      	ldr	r3, [pc, #96]	; (80053fc <HAL_DMA_IRQHandler+0x714>)
 800539a:	4299      	cmp	r1, r3
 800539c:	d014      	beq.n	80053c8 <HAL_DMA_IRQHandler+0x6e0>
 800539e:	687b      	ldr	r3, [r7, #4]
 80053a0:	681b      	ldr	r3, [r3, #0]
 80053a2:	4619      	mov	r1, r3
 80053a4:	4b16      	ldr	r3, [pc, #88]	; (8005400 <HAL_DMA_IRQHandler+0x718>)
 80053a6:	4299      	cmp	r1, r3
 80053a8:	d00b      	beq.n	80053c2 <HAL_DMA_IRQHandler+0x6da>
 80053aa:	687b      	ldr	r3, [r7, #4]
 80053ac:	681b      	ldr	r3, [r3, #0]
 80053ae:	4619      	mov	r1, r3
 80053b0:	4b14      	ldr	r3, [pc, #80]	; (8005404 <HAL_DMA_IRQHandler+0x71c>)
 80053b2:	4299      	cmp	r1, r3
 80053b4:	d102      	bne.n	80053bc <HAL_DMA_IRQHandler+0x6d4>
 80053b6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80053ba:	e041      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 80053bc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80053c0:	e03e      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 80053c2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80053c6:	e03b      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 80053c8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80053cc:	e038      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 80053ce:	bf00      	nop
 80053d0:	40026458 	.word	0x40026458
 80053d4:	40026400 	.word	0x40026400
 80053d8:	40026010 	.word	0x40026010
 80053dc:	40026410 	.word	0x40026410
 80053e0:	40026070 	.word	0x40026070
 80053e4:	40026470 	.word	0x40026470
 80053e8:	40026028 	.word	0x40026028
 80053ec:	40026428 	.word	0x40026428
 80053f0:	40026088 	.word	0x40026088
 80053f4:	40026488 	.word	0x40026488
 80053f8:	40026040 	.word	0x40026040
 80053fc:	40026440 	.word	0x40026440
 8005400:	400260a0 	.word	0x400260a0
 8005404:	400264a0 	.word	0x400264a0
 8005408:	400260b8 	.word	0x400260b8
 800540c:	40026058 	.word	0x40026058
 8005410:	40026000 	.word	0x40026000
 8005414:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8005418:	e012      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 800541a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800541e:	e00f      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 8005420:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005424:	e00c      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 8005426:	f44f 7300 	mov.w	r3, #512	; 0x200
 800542a:	e009      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 800542c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005430:	e006      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 8005432:	2308      	movs	r3, #8
 8005434:	e004      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 8005436:	2308      	movs	r3, #8
 8005438:	e002      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 800543a:	2308      	movs	r3, #8
 800543c:	e000      	b.n	8005440 <HAL_DMA_IRQHandler+0x758>
 800543e:	2308      	movs	r3, #8
 8005440:	60d3      	str	r3, [r2, #12]
 8005442:	e06b      	b.n	800551c <HAL_DMA_IRQHandler+0x834>
 8005444:	4a7b      	ldr	r2, [pc, #492]	; (8005634 <HAL_DMA_IRQHandler+0x94c>)
 8005446:	687b      	ldr	r3, [r7, #4]
 8005448:	681b      	ldr	r3, [r3, #0]
 800544a:	4619      	mov	r1, r3
 800544c:	4b7a      	ldr	r3, [pc, #488]	; (8005638 <HAL_DMA_IRQHandler+0x950>)
 800544e:	4299      	cmp	r1, r3
 8005450:	d062      	beq.n	8005518 <HAL_DMA_IRQHandler+0x830>
 8005452:	687b      	ldr	r3, [r7, #4]
 8005454:	681b      	ldr	r3, [r3, #0]
 8005456:	4619      	mov	r1, r3
 8005458:	4b78      	ldr	r3, [pc, #480]	; (800563c <HAL_DMA_IRQHandler+0x954>)
 800545a:	4299      	cmp	r1, r3
 800545c:	d05a      	beq.n	8005514 <HAL_DMA_IRQHandler+0x82c>
 800545e:	687b      	ldr	r3, [r7, #4]
 8005460:	681b      	ldr	r3, [r3, #0]
 8005462:	4619      	mov	r1, r3
 8005464:	4b76      	ldr	r3, [pc, #472]	; (8005640 <HAL_DMA_IRQHandler+0x958>)
 8005466:	4299      	cmp	r1, r3
 8005468:	d052      	beq.n	8005510 <HAL_DMA_IRQHandler+0x828>
 800546a:	687b      	ldr	r3, [r7, #4]
 800546c:	681b      	ldr	r3, [r3, #0]
 800546e:	4619      	mov	r1, r3
 8005470:	4b74      	ldr	r3, [pc, #464]	; (8005644 <HAL_DMA_IRQHandler+0x95c>)
 8005472:	4299      	cmp	r1, r3
 8005474:	d04a      	beq.n	800550c <HAL_DMA_IRQHandler+0x824>
 8005476:	687b      	ldr	r3, [r7, #4]
 8005478:	681b      	ldr	r3, [r3, #0]
 800547a:	4619      	mov	r1, r3
 800547c:	4b72      	ldr	r3, [pc, #456]	; (8005648 <HAL_DMA_IRQHandler+0x960>)
 800547e:	4299      	cmp	r1, r3
 8005480:	d041      	beq.n	8005506 <HAL_DMA_IRQHandler+0x81e>
 8005482:	687b      	ldr	r3, [r7, #4]
 8005484:	681b      	ldr	r3, [r3, #0]
 8005486:	4619      	mov	r1, r3
 8005488:	4b70      	ldr	r3, [pc, #448]	; (800564c <HAL_DMA_IRQHandler+0x964>)
 800548a:	4299      	cmp	r1, r3
 800548c:	d038      	beq.n	8005500 <HAL_DMA_IRQHandler+0x818>
 800548e:	687b      	ldr	r3, [r7, #4]
 8005490:	681b      	ldr	r3, [r3, #0]
 8005492:	4619      	mov	r1, r3
 8005494:	4b6e      	ldr	r3, [pc, #440]	; (8005650 <HAL_DMA_IRQHandler+0x968>)
 8005496:	4299      	cmp	r1, r3
 8005498:	d02f      	beq.n	80054fa <HAL_DMA_IRQHandler+0x812>
 800549a:	687b      	ldr	r3, [r7, #4]
 800549c:	681b      	ldr	r3, [r3, #0]
 800549e:	4619      	mov	r1, r3
 80054a0:	4b6c      	ldr	r3, [pc, #432]	; (8005654 <HAL_DMA_IRQHandler+0x96c>)
 80054a2:	4299      	cmp	r1, r3
 80054a4:	d026      	beq.n	80054f4 <HAL_DMA_IRQHandler+0x80c>
 80054a6:	687b      	ldr	r3, [r7, #4]
 80054a8:	681b      	ldr	r3, [r3, #0]
 80054aa:	4619      	mov	r1, r3
 80054ac:	4b6a      	ldr	r3, [pc, #424]	; (8005658 <HAL_DMA_IRQHandler+0x970>)
 80054ae:	4299      	cmp	r1, r3
 80054b0:	d01d      	beq.n	80054ee <HAL_DMA_IRQHandler+0x806>
 80054b2:	687b      	ldr	r3, [r7, #4]
 80054b4:	681b      	ldr	r3, [r3, #0]
 80054b6:	4619      	mov	r1, r3
 80054b8:	4b68      	ldr	r3, [pc, #416]	; (800565c <HAL_DMA_IRQHandler+0x974>)
 80054ba:	4299      	cmp	r1, r3
 80054bc:	d014      	beq.n	80054e8 <HAL_DMA_IRQHandler+0x800>
 80054be:	687b      	ldr	r3, [r7, #4]
 80054c0:	681b      	ldr	r3, [r3, #0]
 80054c2:	4619      	mov	r1, r3
 80054c4:	4b66      	ldr	r3, [pc, #408]	; (8005660 <HAL_DMA_IRQHandler+0x978>)
 80054c6:	4299      	cmp	r1, r3
 80054c8:	d00b      	beq.n	80054e2 <HAL_DMA_IRQHandler+0x7fa>
 80054ca:	687b      	ldr	r3, [r7, #4]
 80054cc:	681b      	ldr	r3, [r3, #0]
 80054ce:	4619      	mov	r1, r3
 80054d0:	4b64      	ldr	r3, [pc, #400]	; (8005664 <HAL_DMA_IRQHandler+0x97c>)
 80054d2:	4299      	cmp	r1, r3
 80054d4:	d102      	bne.n	80054dc <HAL_DMA_IRQHandler+0x7f4>
 80054d6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80054da:	e01e      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 80054dc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80054e0:	e01b      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 80054e2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80054e6:	e018      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 80054e8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80054ec:	e015      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 80054ee:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80054f2:	e012      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 80054f4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80054f8:	e00f      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 80054fa:	f44f 7300 	mov.w	r3, #512	; 0x200
 80054fe:	e00c      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 8005500:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005504:	e009      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 8005506:	f44f 7300 	mov.w	r3, #512	; 0x200
 800550a:	e006      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 800550c:	2308      	movs	r3, #8
 800550e:	e004      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 8005510:	2308      	movs	r3, #8
 8005512:	e002      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 8005514:	2308      	movs	r3, #8
 8005516:	e000      	b.n	800551a <HAL_DMA_IRQHandler+0x832>
 8005518:	2308      	movs	r3, #8
 800551a:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800551c:	687b      	ldr	r3, [r7, #4]
 800551e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005520:	f043 0201 	orr.w	r2, r3, #1
 8005524:	687b      	ldr	r3, [r7, #4]
 8005526:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8005528:	687b      	ldr	r3, [r7, #4]
 800552a:	2204      	movs	r2, #4
 800552c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma); 
 8005530:	687b      	ldr	r3, [r7, #4]
 8005532:	2200      	movs	r2, #0
 8005534:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 8005538:	687b      	ldr	r3, [r7, #4]
 800553a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800553c:	2b00      	cmp	r3, #0
 800553e:	d003      	beq.n	8005548 <HAL_DMA_IRQHandler+0x860>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8005540:	687b      	ldr	r3, [r7, #4]
 8005542:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005544:	6878      	ldr	r0, [r7, #4]
 8005546:	4798      	blx	r3
      }
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8005548:	687b      	ldr	r3, [r7, #4]
 800554a:	681b      	ldr	r3, [r3, #0]
 800554c:	461a      	mov	r2, r3
 800554e:	4b46      	ldr	r3, [pc, #280]	; (8005668 <HAL_DMA_IRQHandler+0x980>)
 8005550:	429a      	cmp	r2, r3
 8005552:	f240 808f 	bls.w	8005674 <HAL_DMA_IRQHandler+0x98c>
 8005556:	4b45      	ldr	r3, [pc, #276]	; (800566c <HAL_DMA_IRQHandler+0x984>)
 8005558:	685a      	ldr	r2, [r3, #4]
 800555a:	687b      	ldr	r3, [r7, #4]
 800555c:	681b      	ldr	r3, [r3, #0]
 800555e:	4619      	mov	r1, r3
 8005560:	4b35      	ldr	r3, [pc, #212]	; (8005638 <HAL_DMA_IRQHandler+0x950>)
 8005562:	4299      	cmp	r1, r3
 8005564:	d05e      	beq.n	8005624 <HAL_DMA_IRQHandler+0x93c>
 8005566:	687b      	ldr	r3, [r7, #4]
 8005568:	681b      	ldr	r3, [r3, #0]
 800556a:	4619      	mov	r1, r3
 800556c:	4b33      	ldr	r3, [pc, #204]	; (800563c <HAL_DMA_IRQHandler+0x954>)
 800556e:	4299      	cmp	r1, r3
 8005570:	d056      	beq.n	8005620 <HAL_DMA_IRQHandler+0x938>
 8005572:	687b      	ldr	r3, [r7, #4]
 8005574:	681b      	ldr	r3, [r3, #0]
 8005576:	4619      	mov	r1, r3
 8005578:	4b31      	ldr	r3, [pc, #196]	; (8005640 <HAL_DMA_IRQHandler+0x958>)
 800557a:	4299      	cmp	r1, r3
 800557c:	d04e      	beq.n	800561c <HAL_DMA_IRQHandler+0x934>
 800557e:	687b      	ldr	r3, [r7, #4]
 8005580:	681b      	ldr	r3, [r3, #0]
 8005582:	4619      	mov	r1, r3
 8005584:	4b2f      	ldr	r3, [pc, #188]	; (8005644 <HAL_DMA_IRQHandler+0x95c>)
 8005586:	4299      	cmp	r1, r3
 8005588:	d046      	beq.n	8005618 <HAL_DMA_IRQHandler+0x930>
 800558a:	687b      	ldr	r3, [r7, #4]
 800558c:	681b      	ldr	r3, [r3, #0]
 800558e:	4619      	mov	r1, r3
 8005590:	4b2d      	ldr	r3, [pc, #180]	; (8005648 <HAL_DMA_IRQHandler+0x960>)
 8005592:	4299      	cmp	r1, r3
 8005594:	d03e      	beq.n	8005614 <HAL_DMA_IRQHandler+0x92c>
 8005596:	687b      	ldr	r3, [r7, #4]
 8005598:	681b      	ldr	r3, [r3, #0]
 800559a:	4619      	mov	r1, r3
 800559c:	4b2b      	ldr	r3, [pc, #172]	; (800564c <HAL_DMA_IRQHandler+0x964>)
 800559e:	4299      	cmp	r1, r3
 80055a0:	d036      	beq.n	8005610 <HAL_DMA_IRQHandler+0x928>
 80055a2:	687b      	ldr	r3, [r7, #4]
 80055a4:	681b      	ldr	r3, [r3, #0]
 80055a6:	4619      	mov	r1, r3
 80055a8:	4b29      	ldr	r3, [pc, #164]	; (8005650 <HAL_DMA_IRQHandler+0x968>)
 80055aa:	4299      	cmp	r1, r3
 80055ac:	d02e      	beq.n	800560c <HAL_DMA_IRQHandler+0x924>
 80055ae:	687b      	ldr	r3, [r7, #4]
 80055b0:	681b      	ldr	r3, [r3, #0]
 80055b2:	4619      	mov	r1, r3
 80055b4:	4b27      	ldr	r3, [pc, #156]	; (8005654 <HAL_DMA_IRQHandler+0x96c>)
 80055b6:	4299      	cmp	r1, r3
 80055b8:	d026      	beq.n	8005608 <HAL_DMA_IRQHandler+0x920>
 80055ba:	687b      	ldr	r3, [r7, #4]
 80055bc:	681b      	ldr	r3, [r3, #0]
 80055be:	4619      	mov	r1, r3
 80055c0:	4b25      	ldr	r3, [pc, #148]	; (8005658 <HAL_DMA_IRQHandler+0x970>)
 80055c2:	4299      	cmp	r1, r3
 80055c4:	d01d      	beq.n	8005602 <HAL_DMA_IRQHandler+0x91a>
 80055c6:	687b      	ldr	r3, [r7, #4]
 80055c8:	681b      	ldr	r3, [r3, #0]
 80055ca:	4619      	mov	r1, r3
 80055cc:	4b23      	ldr	r3, [pc, #140]	; (800565c <HAL_DMA_IRQHandler+0x974>)
 80055ce:	4299      	cmp	r1, r3
 80055d0:	d014      	beq.n	80055fc <HAL_DMA_IRQHandler+0x914>
 80055d2:	687b      	ldr	r3, [r7, #4]
 80055d4:	681b      	ldr	r3, [r3, #0]
 80055d6:	4619      	mov	r1, r3
 80055d8:	4b21      	ldr	r3, [pc, #132]	; (8005660 <HAL_DMA_IRQHandler+0x978>)
 80055da:	4299      	cmp	r1, r3
 80055dc:	d00b      	beq.n	80055f6 <HAL_DMA_IRQHandler+0x90e>
 80055de:	687b      	ldr	r3, [r7, #4]
 80055e0:	681b      	ldr	r3, [r3, #0]
 80055e2:	4619      	mov	r1, r3
 80055e4:	4b1f      	ldr	r3, [pc, #124]	; (8005664 <HAL_DMA_IRQHandler+0x97c>)
 80055e6:	4299      	cmp	r1, r3
 80055e8:	d102      	bne.n	80055f0 <HAL_DMA_IRQHandler+0x908>
 80055ea:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80055ee:	e01a      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 80055f0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80055f4:	e017      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 80055f6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80055fa:	e014      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 80055fc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005600:	e011      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 8005602:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005606:	e00e      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 8005608:	2340      	movs	r3, #64	; 0x40
 800560a:	e00c      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 800560c:	2340      	movs	r3, #64	; 0x40
 800560e:	e00a      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 8005610:	2340      	movs	r3, #64	; 0x40
 8005612:	e008      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 8005614:	2340      	movs	r3, #64	; 0x40
 8005616:	e006      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 8005618:	4b15      	ldr	r3, [pc, #84]	; (8005670 <HAL_DMA_IRQHandler+0x988>)
 800561a:	e004      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 800561c:	4b14      	ldr	r3, [pc, #80]	; (8005670 <HAL_DMA_IRQHandler+0x988>)
 800561e:	e002      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 8005620:	4b13      	ldr	r3, [pc, #76]	; (8005670 <HAL_DMA_IRQHandler+0x988>)
 8005622:	e000      	b.n	8005626 <HAL_DMA_IRQHandler+0x93e>
 8005624:	4b12      	ldr	r3, [pc, #72]	; (8005670 <HAL_DMA_IRQHandler+0x988>)
 8005626:	4013      	ands	r3, r2
 8005628:	2b00      	cmp	r3, #0
 800562a:	bf14      	ite	ne
 800562c:	2301      	movne	r3, #1
 800562e:	2300      	moveq	r3, #0
 8005630:	b2db      	uxtb	r3, r3
 8005632:	e19a      	b.n	800596a <HAL_DMA_IRQHandler+0xc82>
 8005634:	40026000 	.word	0x40026000
 8005638:	40026010 	.word	0x40026010
 800563c:	40026410 	.word	0x40026410
 8005640:	40026070 	.word	0x40026070
 8005644:	40026470 	.word	0x40026470
 8005648:	40026028 	.word	0x40026028
 800564c:	40026428 	.word	0x40026428
 8005650:	40026088 	.word	0x40026088
 8005654:	40026488 	.word	0x40026488
 8005658:	40026040 	.word	0x40026040
 800565c:	40026440 	.word	0x40026440
 8005660:	400260a0 	.word	0x400260a0
 8005664:	400264a0 	.word	0x400264a0
 8005668:	40026458 	.word	0x40026458
 800566c:	40026400 	.word	0x40026400
 8005670:	00800001 	.word	0x00800001
 8005674:	687b      	ldr	r3, [r7, #4]
 8005676:	681b      	ldr	r3, [r3, #0]
 8005678:	461a      	mov	r2, r3
 800567a:	4b9a      	ldr	r3, [pc, #616]	; (80058e4 <HAL_DMA_IRQHandler+0xbfc>)
 800567c:	429a      	cmp	r2, r3
 800567e:	d96e      	bls.n	800575e <HAL_DMA_IRQHandler+0xa76>
 8005680:	4b99      	ldr	r3, [pc, #612]	; (80058e8 <HAL_DMA_IRQHandler+0xc00>)
 8005682:	681a      	ldr	r2, [r3, #0]
 8005684:	687b      	ldr	r3, [r7, #4]
 8005686:	681b      	ldr	r3, [r3, #0]
 8005688:	4619      	mov	r1, r3
 800568a:	4b98      	ldr	r3, [pc, #608]	; (80058ec <HAL_DMA_IRQHandler+0xc04>)
 800568c:	4299      	cmp	r1, r3
 800568e:	d05e      	beq.n	800574e <HAL_DMA_IRQHandler+0xa66>
 8005690:	687b      	ldr	r3, [r7, #4]
 8005692:	681b      	ldr	r3, [r3, #0]
 8005694:	4619      	mov	r1, r3
 8005696:	4b96      	ldr	r3, [pc, #600]	; (80058f0 <HAL_DMA_IRQHandler+0xc08>)
 8005698:	4299      	cmp	r1, r3
 800569a:	d056      	beq.n	800574a <HAL_DMA_IRQHandler+0xa62>
 800569c:	687b      	ldr	r3, [r7, #4]
 800569e:	681b      	ldr	r3, [r3, #0]
 80056a0:	4619      	mov	r1, r3
 80056a2:	4b94      	ldr	r3, [pc, #592]	; (80058f4 <HAL_DMA_IRQHandler+0xc0c>)
 80056a4:	4299      	cmp	r1, r3
 80056a6:	d04e      	beq.n	8005746 <HAL_DMA_IRQHandler+0xa5e>
 80056a8:	687b      	ldr	r3, [r7, #4]
 80056aa:	681b      	ldr	r3, [r3, #0]
 80056ac:	4619      	mov	r1, r3
 80056ae:	4b92      	ldr	r3, [pc, #584]	; (80058f8 <HAL_DMA_IRQHandler+0xc10>)
 80056b0:	4299      	cmp	r1, r3
 80056b2:	d046      	beq.n	8005742 <HAL_DMA_IRQHandler+0xa5a>
 80056b4:	687b      	ldr	r3, [r7, #4]
 80056b6:	681b      	ldr	r3, [r3, #0]
 80056b8:	4619      	mov	r1, r3
 80056ba:	4b90      	ldr	r3, [pc, #576]	; (80058fc <HAL_DMA_IRQHandler+0xc14>)
 80056bc:	4299      	cmp	r1, r3
 80056be:	d03e      	beq.n	800573e <HAL_DMA_IRQHandler+0xa56>
 80056c0:	687b      	ldr	r3, [r7, #4]
 80056c2:	681b      	ldr	r3, [r3, #0]
 80056c4:	4619      	mov	r1, r3
 80056c6:	4b8e      	ldr	r3, [pc, #568]	; (8005900 <HAL_DMA_IRQHandler+0xc18>)
 80056c8:	4299      	cmp	r1, r3
 80056ca:	d036      	beq.n	800573a <HAL_DMA_IRQHandler+0xa52>
 80056cc:	687b      	ldr	r3, [r7, #4]
 80056ce:	681b      	ldr	r3, [r3, #0]
 80056d0:	4619      	mov	r1, r3
 80056d2:	4b8c      	ldr	r3, [pc, #560]	; (8005904 <HAL_DMA_IRQHandler+0xc1c>)
 80056d4:	4299      	cmp	r1, r3
 80056d6:	d02e      	beq.n	8005736 <HAL_DMA_IRQHandler+0xa4e>
 80056d8:	687b      	ldr	r3, [r7, #4]
 80056da:	681b      	ldr	r3, [r3, #0]
 80056dc:	4619      	mov	r1, r3
 80056de:	4b8a      	ldr	r3, [pc, #552]	; (8005908 <HAL_DMA_IRQHandler+0xc20>)
 80056e0:	4299      	cmp	r1, r3
 80056e2:	d026      	beq.n	8005732 <HAL_DMA_IRQHandler+0xa4a>
 80056e4:	687b      	ldr	r3, [r7, #4]
 80056e6:	681b      	ldr	r3, [r3, #0]
 80056e8:	4619      	mov	r1, r3
 80056ea:	4b88      	ldr	r3, [pc, #544]	; (800590c <HAL_DMA_IRQHandler+0xc24>)
 80056ec:	4299      	cmp	r1, r3
 80056ee:	d01d      	beq.n	800572c <HAL_DMA_IRQHandler+0xa44>
 80056f0:	687b      	ldr	r3, [r7, #4]
 80056f2:	681b      	ldr	r3, [r3, #0]
 80056f4:	4619      	mov	r1, r3
 80056f6:	4b86      	ldr	r3, [pc, #536]	; (8005910 <HAL_DMA_IRQHandler+0xc28>)
 80056f8:	4299      	cmp	r1, r3
 80056fa:	d014      	beq.n	8005726 <HAL_DMA_IRQHandler+0xa3e>
 80056fc:	687b      	ldr	r3, [r7, #4]
 80056fe:	681b      	ldr	r3, [r3, #0]
 8005700:	4619      	mov	r1, r3
 8005702:	4b84      	ldr	r3, [pc, #528]	; (8005914 <HAL_DMA_IRQHandler+0xc2c>)
 8005704:	4299      	cmp	r1, r3
 8005706:	d00b      	beq.n	8005720 <HAL_DMA_IRQHandler+0xa38>
 8005708:	687b      	ldr	r3, [r7, #4]
 800570a:	681b      	ldr	r3, [r3, #0]
 800570c:	4619      	mov	r1, r3
 800570e:	4b82      	ldr	r3, [pc, #520]	; (8005918 <HAL_DMA_IRQHandler+0xc30>)
 8005710:	4299      	cmp	r1, r3
 8005712:	d102      	bne.n	800571a <HAL_DMA_IRQHandler+0xa32>
 8005714:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005718:	e01a      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 800571a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800571e:	e017      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 8005720:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005724:	e014      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 8005726:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800572a:	e011      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 800572c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005730:	e00e      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 8005732:	2340      	movs	r3, #64	; 0x40
 8005734:	e00c      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 8005736:	2340      	movs	r3, #64	; 0x40
 8005738:	e00a      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 800573a:	2340      	movs	r3, #64	; 0x40
 800573c:	e008      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 800573e:	2340      	movs	r3, #64	; 0x40
 8005740:	e006      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 8005742:	4b76      	ldr	r3, [pc, #472]	; (800591c <HAL_DMA_IRQHandler+0xc34>)
 8005744:	e004      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 8005746:	4b75      	ldr	r3, [pc, #468]	; (800591c <HAL_DMA_IRQHandler+0xc34>)
 8005748:	e002      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 800574a:	4b74      	ldr	r3, [pc, #464]	; (800591c <HAL_DMA_IRQHandler+0xc34>)
 800574c:	e000      	b.n	8005750 <HAL_DMA_IRQHandler+0xa68>
 800574e:	4b73      	ldr	r3, [pc, #460]	; (800591c <HAL_DMA_IRQHandler+0xc34>)
 8005750:	4013      	ands	r3, r2
 8005752:	2b00      	cmp	r3, #0
 8005754:	bf14      	ite	ne
 8005756:	2301      	movne	r3, #1
 8005758:	2300      	moveq	r3, #0
 800575a:	b2db      	uxtb	r3, r3
 800575c:	e105      	b.n	800596a <HAL_DMA_IRQHandler+0xc82>
 800575e:	687b      	ldr	r3, [r7, #4]
 8005760:	681b      	ldr	r3, [r3, #0]
 8005762:	461a      	mov	r2, r3
 8005764:	4b6e      	ldr	r3, [pc, #440]	; (8005920 <HAL_DMA_IRQHandler+0xc38>)
 8005766:	429a      	cmp	r2, r3
 8005768:	d96e      	bls.n	8005848 <HAL_DMA_IRQHandler+0xb60>
 800576a:	4b6e      	ldr	r3, [pc, #440]	; (8005924 <HAL_DMA_IRQHandler+0xc3c>)
 800576c:	685a      	ldr	r2, [r3, #4]
 800576e:	687b      	ldr	r3, [r7, #4]
 8005770:	681b      	ldr	r3, [r3, #0]
 8005772:	4619      	mov	r1, r3
 8005774:	4b5d      	ldr	r3, [pc, #372]	; (80058ec <HAL_DMA_IRQHandler+0xc04>)
 8005776:	4299      	cmp	r1, r3
 8005778:	d05e      	beq.n	8005838 <HAL_DMA_IRQHandler+0xb50>
 800577a:	687b      	ldr	r3, [r7, #4]
 800577c:	681b      	ldr	r3, [r3, #0]
 800577e:	4619      	mov	r1, r3
 8005780:	4b5b      	ldr	r3, [pc, #364]	; (80058f0 <HAL_DMA_IRQHandler+0xc08>)
 8005782:	4299      	cmp	r1, r3
 8005784:	d056      	beq.n	8005834 <HAL_DMA_IRQHandler+0xb4c>
 8005786:	687b      	ldr	r3, [r7, #4]
 8005788:	681b      	ldr	r3, [r3, #0]
 800578a:	4619      	mov	r1, r3
 800578c:	4b59      	ldr	r3, [pc, #356]	; (80058f4 <HAL_DMA_IRQHandler+0xc0c>)
 800578e:	4299      	cmp	r1, r3
 8005790:	d04e      	beq.n	8005830 <HAL_DMA_IRQHandler+0xb48>
 8005792:	687b      	ldr	r3, [r7, #4]
 8005794:	681b      	ldr	r3, [r3, #0]
 8005796:	4619      	mov	r1, r3
 8005798:	4b57      	ldr	r3, [pc, #348]	; (80058f8 <HAL_DMA_IRQHandler+0xc10>)
 800579a:	4299      	cmp	r1, r3
 800579c:	d046      	beq.n	800582c <HAL_DMA_IRQHandler+0xb44>
 800579e:	687b      	ldr	r3, [r7, #4]
 80057a0:	681b      	ldr	r3, [r3, #0]
 80057a2:	4619      	mov	r1, r3
 80057a4:	4b55      	ldr	r3, [pc, #340]	; (80058fc <HAL_DMA_IRQHandler+0xc14>)
 80057a6:	4299      	cmp	r1, r3
 80057a8:	d03e      	beq.n	8005828 <HAL_DMA_IRQHandler+0xb40>
 80057aa:	687b      	ldr	r3, [r7, #4]
 80057ac:	681b      	ldr	r3, [r3, #0]
 80057ae:	4619      	mov	r1, r3
 80057b0:	4b53      	ldr	r3, [pc, #332]	; (8005900 <HAL_DMA_IRQHandler+0xc18>)
 80057b2:	4299      	cmp	r1, r3
 80057b4:	d036      	beq.n	8005824 <HAL_DMA_IRQHandler+0xb3c>
 80057b6:	687b      	ldr	r3, [r7, #4]
 80057b8:	681b      	ldr	r3, [r3, #0]
 80057ba:	4619      	mov	r1, r3
 80057bc:	4b51      	ldr	r3, [pc, #324]	; (8005904 <HAL_DMA_IRQHandler+0xc1c>)
 80057be:	4299      	cmp	r1, r3
 80057c0:	d02e      	beq.n	8005820 <HAL_DMA_IRQHandler+0xb38>
 80057c2:	687b      	ldr	r3, [r7, #4]
 80057c4:	681b      	ldr	r3, [r3, #0]
 80057c6:	4619      	mov	r1, r3
 80057c8:	4b4f      	ldr	r3, [pc, #316]	; (8005908 <HAL_DMA_IRQHandler+0xc20>)
 80057ca:	4299      	cmp	r1, r3
 80057cc:	d026      	beq.n	800581c <HAL_DMA_IRQHandler+0xb34>
 80057ce:	687b      	ldr	r3, [r7, #4]
 80057d0:	681b      	ldr	r3, [r3, #0]
 80057d2:	4619      	mov	r1, r3
 80057d4:	4b4d      	ldr	r3, [pc, #308]	; (800590c <HAL_DMA_IRQHandler+0xc24>)
 80057d6:	4299      	cmp	r1, r3
 80057d8:	d01d      	beq.n	8005816 <HAL_DMA_IRQHandler+0xb2e>
 80057da:	687b      	ldr	r3, [r7, #4]
 80057dc:	681b      	ldr	r3, [r3, #0]
 80057de:	4619      	mov	r1, r3
 80057e0:	4b4b      	ldr	r3, [pc, #300]	; (8005910 <HAL_DMA_IRQHandler+0xc28>)
 80057e2:	4299      	cmp	r1, r3
 80057e4:	d014      	beq.n	8005810 <HAL_DMA_IRQHandler+0xb28>
 80057e6:	687b      	ldr	r3, [r7, #4]
 80057e8:	681b      	ldr	r3, [r3, #0]
 80057ea:	4619      	mov	r1, r3
 80057ec:	4b49      	ldr	r3, [pc, #292]	; (8005914 <HAL_DMA_IRQHandler+0xc2c>)
 80057ee:	4299      	cmp	r1, r3
 80057f0:	d00b      	beq.n	800580a <HAL_DMA_IRQHandler+0xb22>
 80057f2:	687b      	ldr	r3, [r7, #4]
 80057f4:	681b      	ldr	r3, [r3, #0]
 80057f6:	4619      	mov	r1, r3
 80057f8:	4b47      	ldr	r3, [pc, #284]	; (8005918 <HAL_DMA_IRQHandler+0xc30>)
 80057fa:	4299      	cmp	r1, r3
 80057fc:	d102      	bne.n	8005804 <HAL_DMA_IRQHandler+0xb1c>
 80057fe:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005802:	e01a      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005804:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8005808:	e017      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 800580a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800580e:	e014      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005810:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005814:	e011      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005816:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800581a:	e00e      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 800581c:	2340      	movs	r3, #64	; 0x40
 800581e:	e00c      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005820:	2340      	movs	r3, #64	; 0x40
 8005822:	e00a      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005824:	2340      	movs	r3, #64	; 0x40
 8005826:	e008      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005828:	2340      	movs	r3, #64	; 0x40
 800582a:	e006      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 800582c:	4b3b      	ldr	r3, [pc, #236]	; (800591c <HAL_DMA_IRQHandler+0xc34>)
 800582e:	e004      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005830:	4b3a      	ldr	r3, [pc, #232]	; (800591c <HAL_DMA_IRQHandler+0xc34>)
 8005832:	e002      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005834:	4b39      	ldr	r3, [pc, #228]	; (800591c <HAL_DMA_IRQHandler+0xc34>)
 8005836:	e000      	b.n	800583a <HAL_DMA_IRQHandler+0xb52>
 8005838:	4b38      	ldr	r3, [pc, #224]	; (800591c <HAL_DMA_IRQHandler+0xc34>)
 800583a:	4013      	ands	r3, r2
 800583c:	2b00      	cmp	r3, #0
 800583e:	bf14      	ite	ne
 8005840:	2301      	movne	r3, #1
 8005842:	2300      	moveq	r3, #0
 8005844:	b2db      	uxtb	r3, r3
 8005846:	e090      	b.n	800596a <HAL_DMA_IRQHandler+0xc82>
 8005848:	4b36      	ldr	r3, [pc, #216]	; (8005924 <HAL_DMA_IRQHandler+0xc3c>)
 800584a:	681a      	ldr	r2, [r3, #0]
 800584c:	687b      	ldr	r3, [r7, #4]
 800584e:	681b      	ldr	r3, [r3, #0]
 8005850:	4619      	mov	r1, r3
 8005852:	4b26      	ldr	r3, [pc, #152]	; (80058ec <HAL_DMA_IRQHandler+0xc04>)
 8005854:	4299      	cmp	r1, r3
 8005856:	f000 8081 	beq.w	800595c <HAL_DMA_IRQHandler+0xc74>
 800585a:	687b      	ldr	r3, [r7, #4]
 800585c:	681b      	ldr	r3, [r3, #0]
 800585e:	4619      	mov	r1, r3
 8005860:	4b23      	ldr	r3, [pc, #140]	; (80058f0 <HAL_DMA_IRQHandler+0xc08>)
 8005862:	4299      	cmp	r1, r3
 8005864:	d078      	beq.n	8005958 <HAL_DMA_IRQHandler+0xc70>
 8005866:	687b      	ldr	r3, [r7, #4]
 8005868:	681b      	ldr	r3, [r3, #0]
 800586a:	4619      	mov	r1, r3
 800586c:	4b21      	ldr	r3, [pc, #132]	; (80058f4 <HAL_DMA_IRQHandler+0xc0c>)
 800586e:	4299      	cmp	r1, r3
 8005870:	d070      	beq.n	8005954 <HAL_DMA_IRQHandler+0xc6c>
 8005872:	687b      	ldr	r3, [r7, #4]
 8005874:	681b      	ldr	r3, [r3, #0]
 8005876:	4619      	mov	r1, r3
 8005878:	4b1f      	ldr	r3, [pc, #124]	; (80058f8 <HAL_DMA_IRQHandler+0xc10>)
 800587a:	4299      	cmp	r1, r3
 800587c:	d068      	beq.n	8005950 <HAL_DMA_IRQHandler+0xc68>
 800587e:	687b      	ldr	r3, [r7, #4]
 8005880:	681b      	ldr	r3, [r3, #0]
 8005882:	4619      	mov	r1, r3
 8005884:	4b1d      	ldr	r3, [pc, #116]	; (80058fc <HAL_DMA_IRQHandler+0xc14>)
 8005886:	4299      	cmp	r1, r3
 8005888:	d060      	beq.n	800594c <HAL_DMA_IRQHandler+0xc64>
 800588a:	687b      	ldr	r3, [r7, #4]
 800588c:	681b      	ldr	r3, [r3, #0]
 800588e:	4619      	mov	r1, r3
 8005890:	4b1b      	ldr	r3, [pc, #108]	; (8005900 <HAL_DMA_IRQHandler+0xc18>)
 8005892:	4299      	cmp	r1, r3
 8005894:	d058      	beq.n	8005948 <HAL_DMA_IRQHandler+0xc60>
 8005896:	687b      	ldr	r3, [r7, #4]
 8005898:	681b      	ldr	r3, [r3, #0]
 800589a:	4619      	mov	r1, r3
 800589c:	4b19      	ldr	r3, [pc, #100]	; (8005904 <HAL_DMA_IRQHandler+0xc1c>)
 800589e:	4299      	cmp	r1, r3
 80058a0:	d050      	beq.n	8005944 <HAL_DMA_IRQHandler+0xc5c>
 80058a2:	687b      	ldr	r3, [r7, #4]
 80058a4:	681b      	ldr	r3, [r3, #0]
 80058a6:	4619      	mov	r1, r3
 80058a8:	4b17      	ldr	r3, [pc, #92]	; (8005908 <HAL_DMA_IRQHandler+0xc20>)
 80058aa:	4299      	cmp	r1, r3
 80058ac:	d048      	beq.n	8005940 <HAL_DMA_IRQHandler+0xc58>
 80058ae:	687b      	ldr	r3, [r7, #4]
 80058b0:	681b      	ldr	r3, [r3, #0]
 80058b2:	4619      	mov	r1, r3
 80058b4:	4b15      	ldr	r3, [pc, #84]	; (800590c <HAL_DMA_IRQHandler+0xc24>)
 80058b6:	4299      	cmp	r1, r3
 80058b8:	d03f      	beq.n	800593a <HAL_DMA_IRQHandler+0xc52>
 80058ba:	687b      	ldr	r3, [r7, #4]
 80058bc:	681b      	ldr	r3, [r3, #0]
 80058be:	4619      	mov	r1, r3
 80058c0:	4b13      	ldr	r3, [pc, #76]	; (8005910 <HAL_DMA_IRQHandler+0xc28>)
 80058c2:	4299      	cmp	r1, r3
 80058c4:	d036      	beq.n	8005934 <HAL_DMA_IRQHandler+0xc4c>
 80058c6:	687b      	ldr	r3, [r7, #4]
 80058c8:	681b      	ldr	r3, [r3, #0]
 80058ca:	4619      	mov	r1, r3
 80058cc:	4b11      	ldr	r3, [pc, #68]	; (8005914 <HAL_DMA_IRQHandler+0xc2c>)
 80058ce:	4299      	cmp	r1, r3
 80058d0:	d02d      	beq.n	800592e <HAL_DMA_IRQHandler+0xc46>
 80058d2:	687b      	ldr	r3, [r7, #4]
 80058d4:	681b      	ldr	r3, [r3, #0]
 80058d6:	4619      	mov	r1, r3
 80058d8:	4b0f      	ldr	r3, [pc, #60]	; (8005918 <HAL_DMA_IRQHandler+0xc30>)
 80058da:	4299      	cmp	r1, r3
 80058dc:	d124      	bne.n	8005928 <HAL_DMA_IRQHandler+0xc40>
 80058de:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80058e2:	e03c      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 80058e4:	400260b8 	.word	0x400260b8
 80058e8:	40026400 	.word	0x40026400
 80058ec:	40026010 	.word	0x40026010
 80058f0:	40026410 	.word	0x40026410
 80058f4:	40026070 	.word	0x40026070
 80058f8:	40026470 	.word	0x40026470
 80058fc:	40026028 	.word	0x40026028
 8005900:	40026428 	.word	0x40026428
 8005904:	40026088 	.word	0x40026088
 8005908:	40026488 	.word	0x40026488
 800590c:	40026040 	.word	0x40026040
 8005910:	40026440 	.word	0x40026440
 8005914:	400260a0 	.word	0x400260a0
 8005918:	400264a0 	.word	0x400264a0
 800591c:	00800001 	.word	0x00800001
 8005920:	40026058 	.word	0x40026058
 8005924:	40026000 	.word	0x40026000
 8005928:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800592c:	e017      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 800592e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005932:	e014      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 8005934:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005938:	e011      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 800593a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800593e:	e00e      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 8005940:	2340      	movs	r3, #64	; 0x40
 8005942:	e00c      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 8005944:	2340      	movs	r3, #64	; 0x40
 8005946:	e00a      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 8005948:	2340      	movs	r3, #64	; 0x40
 800594a:	e008      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 800594c:	2340      	movs	r3, #64	; 0x40
 800594e:	e006      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 8005950:	4b7f      	ldr	r3, [pc, #508]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005952:	e004      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 8005954:	4b7e      	ldr	r3, [pc, #504]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005956:	e002      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 8005958:	4b7d      	ldr	r3, [pc, #500]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 800595a:	e000      	b.n	800595e <HAL_DMA_IRQHandler+0xc76>
 800595c:	4b7c      	ldr	r3, [pc, #496]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 800595e:	4013      	ands	r3, r2
 8005960:	2b00      	cmp	r3, #0
 8005962:	bf14      	ite	ne
 8005964:	2301      	movne	r3, #1
 8005966:	2300      	moveq	r3, #0
 8005968:	b2db      	uxtb	r3, r3
 800596a:	2b00      	cmp	r3, #0
 800596c:	f000 821c 	beq.w	8005da8 <HAL_DMA_IRQHandler+0x10c0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8005970:	687b      	ldr	r3, [r7, #4]
 8005972:	681b      	ldr	r3, [r3, #0]
 8005974:	695b      	ldr	r3, [r3, #20]
 8005976:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800597a:	2b00      	cmp	r3, #0
 800597c:	f000 8214 	beq.w	8005da8 <HAL_DMA_IRQHandler+0x10c0>
    {
      /* Disable the FIFO Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
 8005980:	687b      	ldr	r3, [r7, #4]
 8005982:	681b      	ldr	r3, [r3, #0]
 8005984:	687a      	ldr	r2, [r7, #4]
 8005986:	6812      	ldr	r2, [r2, #0]
 8005988:	6952      	ldr	r2, [r2, #20]
 800598a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800598e:	615a      	str	r2, [r3, #20]

      /* Clear the FIFO error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8005990:	687b      	ldr	r3, [r7, #4]
 8005992:	681b      	ldr	r3, [r3, #0]
 8005994:	461a      	mov	r2, r3
 8005996:	4b6f      	ldr	r3, [pc, #444]	; (8005b54 <HAL_DMA_IRQHandler+0xe6c>)
 8005998:	429a      	cmp	r2, r3
 800599a:	d968      	bls.n	8005a6e <HAL_DMA_IRQHandler+0xd86>
 800599c:	4a6e      	ldr	r2, [pc, #440]	; (8005b58 <HAL_DMA_IRQHandler+0xe70>)
 800599e:	687b      	ldr	r3, [r7, #4]
 80059a0:	681b      	ldr	r3, [r3, #0]
 80059a2:	4619      	mov	r1, r3
 80059a4:	4b6d      	ldr	r3, [pc, #436]	; (8005b5c <HAL_DMA_IRQHandler+0xe74>)
 80059a6:	4299      	cmp	r1, r3
 80059a8:	d05e      	beq.n	8005a68 <HAL_DMA_IRQHandler+0xd80>
 80059aa:	687b      	ldr	r3, [r7, #4]
 80059ac:	681b      	ldr	r3, [r3, #0]
 80059ae:	4619      	mov	r1, r3
 80059b0:	4b6b      	ldr	r3, [pc, #428]	; (8005b60 <HAL_DMA_IRQHandler+0xe78>)
 80059b2:	4299      	cmp	r1, r3
 80059b4:	d056      	beq.n	8005a64 <HAL_DMA_IRQHandler+0xd7c>
 80059b6:	687b      	ldr	r3, [r7, #4]
 80059b8:	681b      	ldr	r3, [r3, #0]
 80059ba:	4619      	mov	r1, r3
 80059bc:	4b69      	ldr	r3, [pc, #420]	; (8005b64 <HAL_DMA_IRQHandler+0xe7c>)
 80059be:	4299      	cmp	r1, r3
 80059c0:	d04e      	beq.n	8005a60 <HAL_DMA_IRQHandler+0xd78>
 80059c2:	687b      	ldr	r3, [r7, #4]
 80059c4:	681b      	ldr	r3, [r3, #0]
 80059c6:	4619      	mov	r1, r3
 80059c8:	4b67      	ldr	r3, [pc, #412]	; (8005b68 <HAL_DMA_IRQHandler+0xe80>)
 80059ca:	4299      	cmp	r1, r3
 80059cc:	d046      	beq.n	8005a5c <HAL_DMA_IRQHandler+0xd74>
 80059ce:	687b      	ldr	r3, [r7, #4]
 80059d0:	681b      	ldr	r3, [r3, #0]
 80059d2:	4619      	mov	r1, r3
 80059d4:	4b65      	ldr	r3, [pc, #404]	; (8005b6c <HAL_DMA_IRQHandler+0xe84>)
 80059d6:	4299      	cmp	r1, r3
 80059d8:	d03e      	beq.n	8005a58 <HAL_DMA_IRQHandler+0xd70>
 80059da:	687b      	ldr	r3, [r7, #4]
 80059dc:	681b      	ldr	r3, [r3, #0]
 80059de:	4619      	mov	r1, r3
 80059e0:	4b63      	ldr	r3, [pc, #396]	; (8005b70 <HAL_DMA_IRQHandler+0xe88>)
 80059e2:	4299      	cmp	r1, r3
 80059e4:	d036      	beq.n	8005a54 <HAL_DMA_IRQHandler+0xd6c>
 80059e6:	687b      	ldr	r3, [r7, #4]
 80059e8:	681b      	ldr	r3, [r3, #0]
 80059ea:	4619      	mov	r1, r3
 80059ec:	4b61      	ldr	r3, [pc, #388]	; (8005b74 <HAL_DMA_IRQHandler+0xe8c>)
 80059ee:	4299      	cmp	r1, r3
 80059f0:	d02e      	beq.n	8005a50 <HAL_DMA_IRQHandler+0xd68>
 80059f2:	687b      	ldr	r3, [r7, #4]
 80059f4:	681b      	ldr	r3, [r3, #0]
 80059f6:	4619      	mov	r1, r3
 80059f8:	4b5f      	ldr	r3, [pc, #380]	; (8005b78 <HAL_DMA_IRQHandler+0xe90>)
 80059fa:	4299      	cmp	r1, r3
 80059fc:	d026      	beq.n	8005a4c <HAL_DMA_IRQHandler+0xd64>
 80059fe:	687b      	ldr	r3, [r7, #4]
 8005a00:	681b      	ldr	r3, [r3, #0]
 8005a02:	4619      	mov	r1, r3
 8005a04:	4b5d      	ldr	r3, [pc, #372]	; (8005b7c <HAL_DMA_IRQHandler+0xe94>)
 8005a06:	4299      	cmp	r1, r3
 8005a08:	d01d      	beq.n	8005a46 <HAL_DMA_IRQHandler+0xd5e>
 8005a0a:	687b      	ldr	r3, [r7, #4]
 8005a0c:	681b      	ldr	r3, [r3, #0]
 8005a0e:	4619      	mov	r1, r3
 8005a10:	4b5b      	ldr	r3, [pc, #364]	; (8005b80 <HAL_DMA_IRQHandler+0xe98>)
 8005a12:	4299      	cmp	r1, r3
 8005a14:	d014      	beq.n	8005a40 <HAL_DMA_IRQHandler+0xd58>
 8005a16:	687b      	ldr	r3, [r7, #4]
 8005a18:	681b      	ldr	r3, [r3, #0]
 8005a1a:	4619      	mov	r1, r3
 8005a1c:	4b59      	ldr	r3, [pc, #356]	; (8005b84 <HAL_DMA_IRQHandler+0xe9c>)
 8005a1e:	4299      	cmp	r1, r3
 8005a20:	d00b      	beq.n	8005a3a <HAL_DMA_IRQHandler+0xd52>
 8005a22:	687b      	ldr	r3, [r7, #4]
 8005a24:	681b      	ldr	r3, [r3, #0]
 8005a26:	4619      	mov	r1, r3
 8005a28:	4b57      	ldr	r3, [pc, #348]	; (8005b88 <HAL_DMA_IRQHandler+0xea0>)
 8005a2a:	4299      	cmp	r1, r3
 8005a2c:	d102      	bne.n	8005a34 <HAL_DMA_IRQHandler+0xd4c>
 8005a2e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005a32:	e01a      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a34:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8005a38:	e017      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a3a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005a3e:	e014      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a40:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005a44:	e011      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a46:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005a4a:	e00e      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a4c:	2340      	movs	r3, #64	; 0x40
 8005a4e:	e00c      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a50:	2340      	movs	r3, #64	; 0x40
 8005a52:	e00a      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a54:	2340      	movs	r3, #64	; 0x40
 8005a56:	e008      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a58:	2340      	movs	r3, #64	; 0x40
 8005a5a:	e006      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a5c:	4b3c      	ldr	r3, [pc, #240]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005a5e:	e004      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a60:	4b3b      	ldr	r3, [pc, #236]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005a62:	e002      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a64:	4b3a      	ldr	r3, [pc, #232]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005a66:	e000      	b.n	8005a6a <HAL_DMA_IRQHandler+0xd82>
 8005a68:	4b39      	ldr	r3, [pc, #228]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005a6a:	60d3      	str	r3, [r2, #12]
 8005a6c:	e186      	b.n	8005d7c <HAL_DMA_IRQHandler+0x1094>
 8005a6e:	687b      	ldr	r3, [r7, #4]
 8005a70:	681b      	ldr	r3, [r3, #0]
 8005a72:	461a      	mov	r2, r3
 8005a74:	4b45      	ldr	r3, [pc, #276]	; (8005b8c <HAL_DMA_IRQHandler+0xea4>)
 8005a76:	429a      	cmp	r2, r3
 8005a78:	f240 808a 	bls.w	8005b90 <HAL_DMA_IRQHandler+0xea8>
 8005a7c:	4a36      	ldr	r2, [pc, #216]	; (8005b58 <HAL_DMA_IRQHandler+0xe70>)
 8005a7e:	687b      	ldr	r3, [r7, #4]
 8005a80:	681b      	ldr	r3, [r3, #0]
 8005a82:	4619      	mov	r1, r3
 8005a84:	4b35      	ldr	r3, [pc, #212]	; (8005b5c <HAL_DMA_IRQHandler+0xe74>)
 8005a86:	4299      	cmp	r1, r3
 8005a88:	d05e      	beq.n	8005b48 <HAL_DMA_IRQHandler+0xe60>
 8005a8a:	687b      	ldr	r3, [r7, #4]
 8005a8c:	681b      	ldr	r3, [r3, #0]
 8005a8e:	4619      	mov	r1, r3
 8005a90:	4b33      	ldr	r3, [pc, #204]	; (8005b60 <HAL_DMA_IRQHandler+0xe78>)
 8005a92:	4299      	cmp	r1, r3
 8005a94:	d056      	beq.n	8005b44 <HAL_DMA_IRQHandler+0xe5c>
 8005a96:	687b      	ldr	r3, [r7, #4]
 8005a98:	681b      	ldr	r3, [r3, #0]
 8005a9a:	4619      	mov	r1, r3
 8005a9c:	4b31      	ldr	r3, [pc, #196]	; (8005b64 <HAL_DMA_IRQHandler+0xe7c>)
 8005a9e:	4299      	cmp	r1, r3
 8005aa0:	d04e      	beq.n	8005b40 <HAL_DMA_IRQHandler+0xe58>
 8005aa2:	687b      	ldr	r3, [r7, #4]
 8005aa4:	681b      	ldr	r3, [r3, #0]
 8005aa6:	4619      	mov	r1, r3
 8005aa8:	4b2f      	ldr	r3, [pc, #188]	; (8005b68 <HAL_DMA_IRQHandler+0xe80>)
 8005aaa:	4299      	cmp	r1, r3
 8005aac:	d046      	beq.n	8005b3c <HAL_DMA_IRQHandler+0xe54>
 8005aae:	687b      	ldr	r3, [r7, #4]
 8005ab0:	681b      	ldr	r3, [r3, #0]
 8005ab2:	4619      	mov	r1, r3
 8005ab4:	4b2d      	ldr	r3, [pc, #180]	; (8005b6c <HAL_DMA_IRQHandler+0xe84>)
 8005ab6:	4299      	cmp	r1, r3
 8005ab8:	d03e      	beq.n	8005b38 <HAL_DMA_IRQHandler+0xe50>
 8005aba:	687b      	ldr	r3, [r7, #4]
 8005abc:	681b      	ldr	r3, [r3, #0]
 8005abe:	4619      	mov	r1, r3
 8005ac0:	4b2b      	ldr	r3, [pc, #172]	; (8005b70 <HAL_DMA_IRQHandler+0xe88>)
 8005ac2:	4299      	cmp	r1, r3
 8005ac4:	d036      	beq.n	8005b34 <HAL_DMA_IRQHandler+0xe4c>
 8005ac6:	687b      	ldr	r3, [r7, #4]
 8005ac8:	681b      	ldr	r3, [r3, #0]
 8005aca:	4619      	mov	r1, r3
 8005acc:	4b29      	ldr	r3, [pc, #164]	; (8005b74 <HAL_DMA_IRQHandler+0xe8c>)
 8005ace:	4299      	cmp	r1, r3
 8005ad0:	d02e      	beq.n	8005b30 <HAL_DMA_IRQHandler+0xe48>
 8005ad2:	687b      	ldr	r3, [r7, #4]
 8005ad4:	681b      	ldr	r3, [r3, #0]
 8005ad6:	4619      	mov	r1, r3
 8005ad8:	4b27      	ldr	r3, [pc, #156]	; (8005b78 <HAL_DMA_IRQHandler+0xe90>)
 8005ada:	4299      	cmp	r1, r3
 8005adc:	d026      	beq.n	8005b2c <HAL_DMA_IRQHandler+0xe44>
 8005ade:	687b      	ldr	r3, [r7, #4]
 8005ae0:	681b      	ldr	r3, [r3, #0]
 8005ae2:	4619      	mov	r1, r3
 8005ae4:	4b25      	ldr	r3, [pc, #148]	; (8005b7c <HAL_DMA_IRQHandler+0xe94>)
 8005ae6:	4299      	cmp	r1, r3
 8005ae8:	d01d      	beq.n	8005b26 <HAL_DMA_IRQHandler+0xe3e>
 8005aea:	687b      	ldr	r3, [r7, #4]
 8005aec:	681b      	ldr	r3, [r3, #0]
 8005aee:	4619      	mov	r1, r3
 8005af0:	4b23      	ldr	r3, [pc, #140]	; (8005b80 <HAL_DMA_IRQHandler+0xe98>)
 8005af2:	4299      	cmp	r1, r3
 8005af4:	d014      	beq.n	8005b20 <HAL_DMA_IRQHandler+0xe38>
 8005af6:	687b      	ldr	r3, [r7, #4]
 8005af8:	681b      	ldr	r3, [r3, #0]
 8005afa:	4619      	mov	r1, r3
 8005afc:	4b21      	ldr	r3, [pc, #132]	; (8005b84 <HAL_DMA_IRQHandler+0xe9c>)
 8005afe:	4299      	cmp	r1, r3
 8005b00:	d00b      	beq.n	8005b1a <HAL_DMA_IRQHandler+0xe32>
 8005b02:	687b      	ldr	r3, [r7, #4]
 8005b04:	681b      	ldr	r3, [r3, #0]
 8005b06:	4619      	mov	r1, r3
 8005b08:	4b1f      	ldr	r3, [pc, #124]	; (8005b88 <HAL_DMA_IRQHandler+0xea0>)
 8005b0a:	4299      	cmp	r1, r3
 8005b0c:	d102      	bne.n	8005b14 <HAL_DMA_IRQHandler+0xe2c>
 8005b0e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005b12:	e01a      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b14:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8005b18:	e017      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b1a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005b1e:	e014      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b20:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005b24:	e011      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b26:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005b2a:	e00e      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b2c:	2340      	movs	r3, #64	; 0x40
 8005b2e:	e00c      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b30:	2340      	movs	r3, #64	; 0x40
 8005b32:	e00a      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b34:	2340      	movs	r3, #64	; 0x40
 8005b36:	e008      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b38:	2340      	movs	r3, #64	; 0x40
 8005b3a:	e006      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b3c:	4b04      	ldr	r3, [pc, #16]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005b3e:	e004      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b40:	4b03      	ldr	r3, [pc, #12]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005b42:	e002      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b44:	4b02      	ldr	r3, [pc, #8]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005b46:	e000      	b.n	8005b4a <HAL_DMA_IRQHandler+0xe62>
 8005b48:	4b01      	ldr	r3, [pc, #4]	; (8005b50 <HAL_DMA_IRQHandler+0xe68>)
 8005b4a:	6093      	str	r3, [r2, #8]
 8005b4c:	e116      	b.n	8005d7c <HAL_DMA_IRQHandler+0x1094>
 8005b4e:	bf00      	nop
 8005b50:	00800001 	.word	0x00800001
 8005b54:	40026458 	.word	0x40026458
 8005b58:	40026400 	.word	0x40026400
 8005b5c:	40026010 	.word	0x40026010
 8005b60:	40026410 	.word	0x40026410
 8005b64:	40026070 	.word	0x40026070
 8005b68:	40026470 	.word	0x40026470
 8005b6c:	40026028 	.word	0x40026028
 8005b70:	40026428 	.word	0x40026428
 8005b74:	40026088 	.word	0x40026088
 8005b78:	40026488 	.word	0x40026488
 8005b7c:	40026040 	.word	0x40026040
 8005b80:	40026440 	.word	0x40026440
 8005b84:	400260a0 	.word	0x400260a0
 8005b88:	400264a0 	.word	0x400264a0
 8005b8c:	400260b8 	.word	0x400260b8
 8005b90:	687b      	ldr	r3, [r7, #4]
 8005b92:	681b      	ldr	r3, [r3, #0]
 8005b94:	461a      	mov	r2, r3
 8005b96:	4b69      	ldr	r3, [pc, #420]	; (8005d3c <HAL_DMA_IRQHandler+0x1054>)
 8005b98:	429a      	cmp	r2, r3
 8005b9a:	d968      	bls.n	8005c6e <HAL_DMA_IRQHandler+0xf86>
 8005b9c:	4a68      	ldr	r2, [pc, #416]	; (8005d40 <HAL_DMA_IRQHandler+0x1058>)
 8005b9e:	687b      	ldr	r3, [r7, #4]
 8005ba0:	681b      	ldr	r3, [r3, #0]
 8005ba2:	4619      	mov	r1, r3
 8005ba4:	4b67      	ldr	r3, [pc, #412]	; (8005d44 <HAL_DMA_IRQHandler+0x105c>)
 8005ba6:	4299      	cmp	r1, r3
 8005ba8:	d05e      	beq.n	8005c68 <HAL_DMA_IRQHandler+0xf80>
 8005baa:	687b      	ldr	r3, [r7, #4]
 8005bac:	681b      	ldr	r3, [r3, #0]
 8005bae:	4619      	mov	r1, r3
 8005bb0:	4b65      	ldr	r3, [pc, #404]	; (8005d48 <HAL_DMA_IRQHandler+0x1060>)
 8005bb2:	4299      	cmp	r1, r3
 8005bb4:	d056      	beq.n	8005c64 <HAL_DMA_IRQHandler+0xf7c>
 8005bb6:	687b      	ldr	r3, [r7, #4]
 8005bb8:	681b      	ldr	r3, [r3, #0]
 8005bba:	4619      	mov	r1, r3
 8005bbc:	4b63      	ldr	r3, [pc, #396]	; (8005d4c <HAL_DMA_IRQHandler+0x1064>)
 8005bbe:	4299      	cmp	r1, r3
 8005bc0:	d04e      	beq.n	8005c60 <HAL_DMA_IRQHandler+0xf78>
 8005bc2:	687b      	ldr	r3, [r7, #4]
 8005bc4:	681b      	ldr	r3, [r3, #0]
 8005bc6:	4619      	mov	r1, r3
 8005bc8:	4b61      	ldr	r3, [pc, #388]	; (8005d50 <HAL_DMA_IRQHandler+0x1068>)
 8005bca:	4299      	cmp	r1, r3
 8005bcc:	d046      	beq.n	8005c5c <HAL_DMA_IRQHandler+0xf74>
 8005bce:	687b      	ldr	r3, [r7, #4]
 8005bd0:	681b      	ldr	r3, [r3, #0]
 8005bd2:	4619      	mov	r1, r3
 8005bd4:	4b5f      	ldr	r3, [pc, #380]	; (8005d54 <HAL_DMA_IRQHandler+0x106c>)
 8005bd6:	4299      	cmp	r1, r3
 8005bd8:	d03e      	beq.n	8005c58 <HAL_DMA_IRQHandler+0xf70>
 8005bda:	687b      	ldr	r3, [r7, #4]
 8005bdc:	681b      	ldr	r3, [r3, #0]
 8005bde:	4619      	mov	r1, r3
 8005be0:	4b5d      	ldr	r3, [pc, #372]	; (8005d58 <HAL_DMA_IRQHandler+0x1070>)
 8005be2:	4299      	cmp	r1, r3
 8005be4:	d036      	beq.n	8005c54 <HAL_DMA_IRQHandler+0xf6c>
 8005be6:	687b      	ldr	r3, [r7, #4]
 8005be8:	681b      	ldr	r3, [r3, #0]
 8005bea:	4619      	mov	r1, r3
 8005bec:	4b5b      	ldr	r3, [pc, #364]	; (8005d5c <HAL_DMA_IRQHandler+0x1074>)
 8005bee:	4299      	cmp	r1, r3
 8005bf0:	d02e      	beq.n	8005c50 <HAL_DMA_IRQHandler+0xf68>
 8005bf2:	687b      	ldr	r3, [r7, #4]
 8005bf4:	681b      	ldr	r3, [r3, #0]
 8005bf6:	4619      	mov	r1, r3
 8005bf8:	4b59      	ldr	r3, [pc, #356]	; (8005d60 <HAL_DMA_IRQHandler+0x1078>)
 8005bfa:	4299      	cmp	r1, r3
 8005bfc:	d026      	beq.n	8005c4c <HAL_DMA_IRQHandler+0xf64>
 8005bfe:	687b      	ldr	r3, [r7, #4]
 8005c00:	681b      	ldr	r3, [r3, #0]
 8005c02:	4619      	mov	r1, r3
 8005c04:	4b57      	ldr	r3, [pc, #348]	; (8005d64 <HAL_DMA_IRQHandler+0x107c>)
 8005c06:	4299      	cmp	r1, r3
 8005c08:	d01d      	beq.n	8005c46 <HAL_DMA_IRQHandler+0xf5e>
 8005c0a:	687b      	ldr	r3, [r7, #4]
 8005c0c:	681b      	ldr	r3, [r3, #0]
 8005c0e:	4619      	mov	r1, r3
 8005c10:	4b55      	ldr	r3, [pc, #340]	; (8005d68 <HAL_DMA_IRQHandler+0x1080>)
 8005c12:	4299      	cmp	r1, r3
 8005c14:	d014      	beq.n	8005c40 <HAL_DMA_IRQHandler+0xf58>
 8005c16:	687b      	ldr	r3, [r7, #4]
 8005c18:	681b      	ldr	r3, [r3, #0]
 8005c1a:	4619      	mov	r1, r3
 8005c1c:	4b53      	ldr	r3, [pc, #332]	; (8005d6c <HAL_DMA_IRQHandler+0x1084>)
 8005c1e:	4299      	cmp	r1, r3
 8005c20:	d00b      	beq.n	8005c3a <HAL_DMA_IRQHandler+0xf52>
 8005c22:	687b      	ldr	r3, [r7, #4]
 8005c24:	681b      	ldr	r3, [r3, #0]
 8005c26:	4619      	mov	r1, r3
 8005c28:	4b51      	ldr	r3, [pc, #324]	; (8005d70 <HAL_DMA_IRQHandler+0x1088>)
 8005c2a:	4299      	cmp	r1, r3
 8005c2c:	d102      	bne.n	8005c34 <HAL_DMA_IRQHandler+0xf4c>
 8005c2e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005c32:	e01a      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c34:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8005c38:	e017      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c3a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005c3e:	e014      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c40:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005c44:	e011      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c46:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005c4a:	e00e      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c4c:	2340      	movs	r3, #64	; 0x40
 8005c4e:	e00c      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c50:	2340      	movs	r3, #64	; 0x40
 8005c52:	e00a      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c54:	2340      	movs	r3, #64	; 0x40
 8005c56:	e008      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c58:	2340      	movs	r3, #64	; 0x40
 8005c5a:	e006      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c5c:	4b45      	ldr	r3, [pc, #276]	; (8005d74 <HAL_DMA_IRQHandler+0x108c>)
 8005c5e:	e004      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c60:	4b44      	ldr	r3, [pc, #272]	; (8005d74 <HAL_DMA_IRQHandler+0x108c>)
 8005c62:	e002      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c64:	4b43      	ldr	r3, [pc, #268]	; (8005d74 <HAL_DMA_IRQHandler+0x108c>)
 8005c66:	e000      	b.n	8005c6a <HAL_DMA_IRQHandler+0xf82>
 8005c68:	4b42      	ldr	r3, [pc, #264]	; (8005d74 <HAL_DMA_IRQHandler+0x108c>)
 8005c6a:	60d3      	str	r3, [r2, #12]
 8005c6c:	e086      	b.n	8005d7c <HAL_DMA_IRQHandler+0x1094>
 8005c6e:	4a34      	ldr	r2, [pc, #208]	; (8005d40 <HAL_DMA_IRQHandler+0x1058>)
 8005c70:	687b      	ldr	r3, [r7, #4]
 8005c72:	681b      	ldr	r3, [r3, #0]
 8005c74:	4619      	mov	r1, r3
 8005c76:	4b33      	ldr	r3, [pc, #204]	; (8005d44 <HAL_DMA_IRQHandler+0x105c>)
 8005c78:	4299      	cmp	r1, r3
 8005c7a:	d07d      	beq.n	8005d78 <HAL_DMA_IRQHandler+0x1090>
 8005c7c:	687b      	ldr	r3, [r7, #4]
 8005c7e:	681b      	ldr	r3, [r3, #0]
 8005c80:	4619      	mov	r1, r3
 8005c82:	4b31      	ldr	r3, [pc, #196]	; (8005d48 <HAL_DMA_IRQHandler+0x1060>)
 8005c84:	4299      	cmp	r1, r3
 8005c86:	d056      	beq.n	8005d36 <HAL_DMA_IRQHandler+0x104e>
 8005c88:	687b      	ldr	r3, [r7, #4]
 8005c8a:	681b      	ldr	r3, [r3, #0]
 8005c8c:	4619      	mov	r1, r3
 8005c8e:	4b2f      	ldr	r3, [pc, #188]	; (8005d4c <HAL_DMA_IRQHandler+0x1064>)
 8005c90:	4299      	cmp	r1, r3
 8005c92:	d04e      	beq.n	8005d32 <HAL_DMA_IRQHandler+0x104a>
 8005c94:	687b      	ldr	r3, [r7, #4]
 8005c96:	681b      	ldr	r3, [r3, #0]
 8005c98:	4619      	mov	r1, r3
 8005c9a:	4b2d      	ldr	r3, [pc, #180]	; (8005d50 <HAL_DMA_IRQHandler+0x1068>)
 8005c9c:	4299      	cmp	r1, r3
 8005c9e:	d046      	beq.n	8005d2e <HAL_DMA_IRQHandler+0x1046>
 8005ca0:	687b      	ldr	r3, [r7, #4]
 8005ca2:	681b      	ldr	r3, [r3, #0]
 8005ca4:	4619      	mov	r1, r3
 8005ca6:	4b2b      	ldr	r3, [pc, #172]	; (8005d54 <HAL_DMA_IRQHandler+0x106c>)
 8005ca8:	4299      	cmp	r1, r3
 8005caa:	d03e      	beq.n	8005d2a <HAL_DMA_IRQHandler+0x1042>
 8005cac:	687b      	ldr	r3, [r7, #4]
 8005cae:	681b      	ldr	r3, [r3, #0]
 8005cb0:	4619      	mov	r1, r3
 8005cb2:	4b29      	ldr	r3, [pc, #164]	; (8005d58 <HAL_DMA_IRQHandler+0x1070>)
 8005cb4:	4299      	cmp	r1, r3
 8005cb6:	d036      	beq.n	8005d26 <HAL_DMA_IRQHandler+0x103e>
 8005cb8:	687b      	ldr	r3, [r7, #4]
 8005cba:	681b      	ldr	r3, [r3, #0]
 8005cbc:	4619      	mov	r1, r3
 8005cbe:	4b27      	ldr	r3, [pc, #156]	; (8005d5c <HAL_DMA_IRQHandler+0x1074>)
 8005cc0:	4299      	cmp	r1, r3
 8005cc2:	d02e      	beq.n	8005d22 <HAL_DMA_IRQHandler+0x103a>
 8005cc4:	687b      	ldr	r3, [r7, #4]
 8005cc6:	681b      	ldr	r3, [r3, #0]
 8005cc8:	4619      	mov	r1, r3
 8005cca:	4b25      	ldr	r3, [pc, #148]	; (8005d60 <HAL_DMA_IRQHandler+0x1078>)
 8005ccc:	4299      	cmp	r1, r3
 8005cce:	d026      	beq.n	8005d1e <HAL_DMA_IRQHandler+0x1036>
 8005cd0:	687b      	ldr	r3, [r7, #4]
 8005cd2:	681b      	ldr	r3, [r3, #0]
 8005cd4:	4619      	mov	r1, r3
 8005cd6:	4b23      	ldr	r3, [pc, #140]	; (8005d64 <HAL_DMA_IRQHandler+0x107c>)
 8005cd8:	4299      	cmp	r1, r3
 8005cda:	d01d      	beq.n	8005d18 <HAL_DMA_IRQHandler+0x1030>
 8005cdc:	687b      	ldr	r3, [r7, #4]
 8005cde:	681b      	ldr	r3, [r3, #0]
 8005ce0:	4619      	mov	r1, r3
 8005ce2:	4b21      	ldr	r3, [pc, #132]	; (8005d68 <HAL_DMA_IRQHandler+0x1080>)
 8005ce4:	4299      	cmp	r1, r3
 8005ce6:	d014      	beq.n	8005d12 <HAL_DMA_IRQHandler+0x102a>
 8005ce8:	687b      	ldr	r3, [r7, #4]
 8005cea:	681b      	ldr	r3, [r3, #0]
 8005cec:	4619      	mov	r1, r3
 8005cee:	4b1f      	ldr	r3, [pc, #124]	; (8005d6c <HAL_DMA_IRQHandler+0x1084>)
 8005cf0:	4299      	cmp	r1, r3
 8005cf2:	d00b      	beq.n	8005d0c <HAL_DMA_IRQHandler+0x1024>
 8005cf4:	687b      	ldr	r3, [r7, #4]
 8005cf6:	681b      	ldr	r3, [r3, #0]
 8005cf8:	4619      	mov	r1, r3
 8005cfa:	4b1d      	ldr	r3, [pc, #116]	; (8005d70 <HAL_DMA_IRQHandler+0x1088>)
 8005cfc:	4299      	cmp	r1, r3
 8005cfe:	d102      	bne.n	8005d06 <HAL_DMA_IRQHandler+0x101e>
 8005d00:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005d04:	e039      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d06:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8005d0a:	e036      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d0c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005d10:	e033      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d12:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005d16:	e030      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d18:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005d1c:	e02d      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d1e:	2340      	movs	r3, #64	; 0x40
 8005d20:	e02b      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d22:	2340      	movs	r3, #64	; 0x40
 8005d24:	e029      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d26:	2340      	movs	r3, #64	; 0x40
 8005d28:	e027      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d2a:	2340      	movs	r3, #64	; 0x40
 8005d2c:	e025      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d2e:	4b11      	ldr	r3, [pc, #68]	; (8005d74 <HAL_DMA_IRQHandler+0x108c>)
 8005d30:	e023      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d32:	4b10      	ldr	r3, [pc, #64]	; (8005d74 <HAL_DMA_IRQHandler+0x108c>)
 8005d34:	e021      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d36:	4b0f      	ldr	r3, [pc, #60]	; (8005d74 <HAL_DMA_IRQHandler+0x108c>)
 8005d38:	e01f      	b.n	8005d7a <HAL_DMA_IRQHandler+0x1092>
 8005d3a:	bf00      	nop
 8005d3c:	40026058 	.word	0x40026058
 8005d40:	40026000 	.word	0x40026000
 8005d44:	40026010 	.word	0x40026010
 8005d48:	40026410 	.word	0x40026410
 8005d4c:	40026070 	.word	0x40026070
 8005d50:	40026470 	.word	0x40026470
 8005d54:	40026028 	.word	0x40026028
 8005d58:	40026428 	.word	0x40026428
 8005d5c:	40026088 	.word	0x40026088
 8005d60:	40026488 	.word	0x40026488
 8005d64:	40026040 	.word	0x40026040
 8005d68:	40026440 	.word	0x40026440
 8005d6c:	400260a0 	.word	0x400260a0
 8005d70:	400264a0 	.word	0x400264a0
 8005d74:	00800001 	.word	0x00800001
 8005d78:	4b85      	ldr	r3, [pc, #532]	; (8005f90 <HAL_DMA_IRQHandler+0x12a8>)
 8005d7a:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8005d7c:	687b      	ldr	r3, [r7, #4]
 8005d7e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005d80:	f043 0202 	orr.w	r2, r3, #2
 8005d84:	687b      	ldr	r3, [r7, #4]
 8005d86:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8005d88:	687b      	ldr	r3, [r7, #4]
 8005d8a:	2204      	movs	r2, #4
 8005d8c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8005d90:	687b      	ldr	r3, [r7, #4]
 8005d92:	2200      	movs	r2, #0
 8005d94:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 8005d98:	687b      	ldr	r3, [r7, #4]
 8005d9a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005d9c:	2b00      	cmp	r3, #0
 8005d9e:	d003      	beq.n	8005da8 <HAL_DMA_IRQHandler+0x10c0>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8005da0:	687b      	ldr	r3, [r7, #4]
 8005da2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005da4:	6878      	ldr	r0, [r7, #4]
 8005da6:	4798      	blx	r3
      }
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8005da8:	687b      	ldr	r3, [r7, #4]
 8005daa:	681b      	ldr	r3, [r3, #0]
 8005dac:	461a      	mov	r2, r3
 8005dae:	4b79      	ldr	r3, [pc, #484]	; (8005f94 <HAL_DMA_IRQHandler+0x12ac>)
 8005db0:	429a      	cmp	r2, r3
 8005db2:	d972      	bls.n	8005e9a <HAL_DMA_IRQHandler+0x11b2>
 8005db4:	4b78      	ldr	r3, [pc, #480]	; (8005f98 <HAL_DMA_IRQHandler+0x12b0>)
 8005db6:	685a      	ldr	r2, [r3, #4]
 8005db8:	687b      	ldr	r3, [r7, #4]
 8005dba:	681b      	ldr	r3, [r3, #0]
 8005dbc:	4619      	mov	r1, r3
 8005dbe:	4b77      	ldr	r3, [pc, #476]	; (8005f9c <HAL_DMA_IRQHandler+0x12b4>)
 8005dc0:	4299      	cmp	r1, r3
 8005dc2:	d062      	beq.n	8005e8a <HAL_DMA_IRQHandler+0x11a2>
 8005dc4:	687b      	ldr	r3, [r7, #4]
 8005dc6:	681b      	ldr	r3, [r3, #0]
 8005dc8:	4619      	mov	r1, r3
 8005dca:	4b75      	ldr	r3, [pc, #468]	; (8005fa0 <HAL_DMA_IRQHandler+0x12b8>)
 8005dcc:	4299      	cmp	r1, r3
 8005dce:	d05a      	beq.n	8005e86 <HAL_DMA_IRQHandler+0x119e>
 8005dd0:	687b      	ldr	r3, [r7, #4]
 8005dd2:	681b      	ldr	r3, [r3, #0]
 8005dd4:	4619      	mov	r1, r3
 8005dd6:	4b73      	ldr	r3, [pc, #460]	; (8005fa4 <HAL_DMA_IRQHandler+0x12bc>)
 8005dd8:	4299      	cmp	r1, r3
 8005dda:	d052      	beq.n	8005e82 <HAL_DMA_IRQHandler+0x119a>
 8005ddc:	687b      	ldr	r3, [r7, #4]
 8005dde:	681b      	ldr	r3, [r3, #0]
 8005de0:	4619      	mov	r1, r3
 8005de2:	4b71      	ldr	r3, [pc, #452]	; (8005fa8 <HAL_DMA_IRQHandler+0x12c0>)
 8005de4:	4299      	cmp	r1, r3
 8005de6:	d04a      	beq.n	8005e7e <HAL_DMA_IRQHandler+0x1196>
 8005de8:	687b      	ldr	r3, [r7, #4]
 8005dea:	681b      	ldr	r3, [r3, #0]
 8005dec:	4619      	mov	r1, r3
 8005dee:	4b6f      	ldr	r3, [pc, #444]	; (8005fac <HAL_DMA_IRQHandler+0x12c4>)
 8005df0:	4299      	cmp	r1, r3
 8005df2:	d041      	beq.n	8005e78 <HAL_DMA_IRQHandler+0x1190>
 8005df4:	687b      	ldr	r3, [r7, #4]
 8005df6:	681b      	ldr	r3, [r3, #0]
 8005df8:	4619      	mov	r1, r3
 8005dfa:	4b6d      	ldr	r3, [pc, #436]	; (8005fb0 <HAL_DMA_IRQHandler+0x12c8>)
 8005dfc:	4299      	cmp	r1, r3
 8005dfe:	d038      	beq.n	8005e72 <HAL_DMA_IRQHandler+0x118a>
 8005e00:	687b      	ldr	r3, [r7, #4]
 8005e02:	681b      	ldr	r3, [r3, #0]
 8005e04:	4619      	mov	r1, r3
 8005e06:	4b6b      	ldr	r3, [pc, #428]	; (8005fb4 <HAL_DMA_IRQHandler+0x12cc>)
 8005e08:	4299      	cmp	r1, r3
 8005e0a:	d02f      	beq.n	8005e6c <HAL_DMA_IRQHandler+0x1184>
 8005e0c:	687b      	ldr	r3, [r7, #4]
 8005e0e:	681b      	ldr	r3, [r3, #0]
 8005e10:	4619      	mov	r1, r3
 8005e12:	4b69      	ldr	r3, [pc, #420]	; (8005fb8 <HAL_DMA_IRQHandler+0x12d0>)
 8005e14:	4299      	cmp	r1, r3
 8005e16:	d026      	beq.n	8005e66 <HAL_DMA_IRQHandler+0x117e>
 8005e18:	687b      	ldr	r3, [r7, #4]
 8005e1a:	681b      	ldr	r3, [r3, #0]
 8005e1c:	4619      	mov	r1, r3
 8005e1e:	4b67      	ldr	r3, [pc, #412]	; (8005fbc <HAL_DMA_IRQHandler+0x12d4>)
 8005e20:	4299      	cmp	r1, r3
 8005e22:	d01d      	beq.n	8005e60 <HAL_DMA_IRQHandler+0x1178>
 8005e24:	687b      	ldr	r3, [r7, #4]
 8005e26:	681b      	ldr	r3, [r3, #0]
 8005e28:	4619      	mov	r1, r3
 8005e2a:	4b65      	ldr	r3, [pc, #404]	; (8005fc0 <HAL_DMA_IRQHandler+0x12d8>)
 8005e2c:	4299      	cmp	r1, r3
 8005e2e:	d014      	beq.n	8005e5a <HAL_DMA_IRQHandler+0x1172>
 8005e30:	687b      	ldr	r3, [r7, #4]
 8005e32:	681b      	ldr	r3, [r3, #0]
 8005e34:	4619      	mov	r1, r3
 8005e36:	4b63      	ldr	r3, [pc, #396]	; (8005fc4 <HAL_DMA_IRQHandler+0x12dc>)
 8005e38:	4299      	cmp	r1, r3
 8005e3a:	d00b      	beq.n	8005e54 <HAL_DMA_IRQHandler+0x116c>
 8005e3c:	687b      	ldr	r3, [r7, #4]
 8005e3e:	681b      	ldr	r3, [r3, #0]
 8005e40:	4619      	mov	r1, r3
 8005e42:	4b61      	ldr	r3, [pc, #388]	; (8005fc8 <HAL_DMA_IRQHandler+0x12e0>)
 8005e44:	4299      	cmp	r1, r3
 8005e46:	d102      	bne.n	8005e4e <HAL_DMA_IRQHandler+0x1166>
 8005e48:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8005e4c:	e01e      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e4e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8005e52:	e01b      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e54:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8005e58:	e018      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e5a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8005e5e:	e015      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e60:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8005e64:	e012      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e66:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005e6a:	e00f      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e6c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005e70:	e00c      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e72:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005e76:	e009      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e78:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005e7c:	e006      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e7e:	4b53      	ldr	r3, [pc, #332]	; (8005fcc <HAL_DMA_IRQHandler+0x12e4>)
 8005e80:	e004      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e82:	4b52      	ldr	r3, [pc, #328]	; (8005fcc <HAL_DMA_IRQHandler+0x12e4>)
 8005e84:	e002      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e86:	4b51      	ldr	r3, [pc, #324]	; (8005fcc <HAL_DMA_IRQHandler+0x12e4>)
 8005e88:	e000      	b.n	8005e8c <HAL_DMA_IRQHandler+0x11a4>
 8005e8a:	4b50      	ldr	r3, [pc, #320]	; (8005fcc <HAL_DMA_IRQHandler+0x12e4>)
 8005e8c:	4013      	ands	r3, r2
 8005e8e:	2b00      	cmp	r3, #0
 8005e90:	bf14      	ite	ne
 8005e92:	2301      	movne	r3, #1
 8005e94:	2300      	moveq	r3, #0
 8005e96:	b2db      	uxtb	r3, r3
 8005e98:	e1a7      	b.n	80061ea <HAL_DMA_IRQHandler+0x1502>
 8005e9a:	687b      	ldr	r3, [r7, #4]
 8005e9c:	681b      	ldr	r3, [r3, #0]
 8005e9e:	461a      	mov	r2, r3
 8005ea0:	4b4b      	ldr	r3, [pc, #300]	; (8005fd0 <HAL_DMA_IRQHandler+0x12e8>)
 8005ea2:	429a      	cmp	r2, r3
 8005ea4:	f240 8096 	bls.w	8005fd4 <HAL_DMA_IRQHandler+0x12ec>
 8005ea8:	4b3b      	ldr	r3, [pc, #236]	; (8005f98 <HAL_DMA_IRQHandler+0x12b0>)
 8005eaa:	681a      	ldr	r2, [r3, #0]
 8005eac:	687b      	ldr	r3, [r7, #4]
 8005eae:	681b      	ldr	r3, [r3, #0]
 8005eb0:	4619      	mov	r1, r3
 8005eb2:	4b3a      	ldr	r3, [pc, #232]	; (8005f9c <HAL_DMA_IRQHandler+0x12b4>)
 8005eb4:	4299      	cmp	r1, r3
 8005eb6:	d062      	beq.n	8005f7e <HAL_DMA_IRQHandler+0x1296>
 8005eb8:	687b      	ldr	r3, [r7, #4]
 8005eba:	681b      	ldr	r3, [r3, #0]
 8005ebc:	4619      	mov	r1, r3
 8005ebe:	4b38      	ldr	r3, [pc, #224]	; (8005fa0 <HAL_DMA_IRQHandler+0x12b8>)
 8005ec0:	4299      	cmp	r1, r3
 8005ec2:	d05a      	beq.n	8005f7a <HAL_DMA_IRQHandler+0x1292>
 8005ec4:	687b      	ldr	r3, [r7, #4]
 8005ec6:	681b      	ldr	r3, [r3, #0]
 8005ec8:	4619      	mov	r1, r3
 8005eca:	4b36      	ldr	r3, [pc, #216]	; (8005fa4 <HAL_DMA_IRQHandler+0x12bc>)
 8005ecc:	4299      	cmp	r1, r3
 8005ece:	d052      	beq.n	8005f76 <HAL_DMA_IRQHandler+0x128e>
 8005ed0:	687b      	ldr	r3, [r7, #4]
 8005ed2:	681b      	ldr	r3, [r3, #0]
 8005ed4:	4619      	mov	r1, r3
 8005ed6:	4b34      	ldr	r3, [pc, #208]	; (8005fa8 <HAL_DMA_IRQHandler+0x12c0>)
 8005ed8:	4299      	cmp	r1, r3
 8005eda:	d04a      	beq.n	8005f72 <HAL_DMA_IRQHandler+0x128a>
 8005edc:	687b      	ldr	r3, [r7, #4]
 8005ede:	681b      	ldr	r3, [r3, #0]
 8005ee0:	4619      	mov	r1, r3
 8005ee2:	4b32      	ldr	r3, [pc, #200]	; (8005fac <HAL_DMA_IRQHandler+0x12c4>)
 8005ee4:	4299      	cmp	r1, r3
 8005ee6:	d041      	beq.n	8005f6c <HAL_DMA_IRQHandler+0x1284>
 8005ee8:	687b      	ldr	r3, [r7, #4]
 8005eea:	681b      	ldr	r3, [r3, #0]
 8005eec:	4619      	mov	r1, r3
 8005eee:	4b30      	ldr	r3, [pc, #192]	; (8005fb0 <HAL_DMA_IRQHandler+0x12c8>)
 8005ef0:	4299      	cmp	r1, r3
 8005ef2:	d038      	beq.n	8005f66 <HAL_DMA_IRQHandler+0x127e>
 8005ef4:	687b      	ldr	r3, [r7, #4]
 8005ef6:	681b      	ldr	r3, [r3, #0]
 8005ef8:	4619      	mov	r1, r3
 8005efa:	4b2e      	ldr	r3, [pc, #184]	; (8005fb4 <HAL_DMA_IRQHandler+0x12cc>)
 8005efc:	4299      	cmp	r1, r3
 8005efe:	d02f      	beq.n	8005f60 <HAL_DMA_IRQHandler+0x1278>
 8005f00:	687b      	ldr	r3, [r7, #4]
 8005f02:	681b      	ldr	r3, [r3, #0]
 8005f04:	4619      	mov	r1, r3
 8005f06:	4b2c      	ldr	r3, [pc, #176]	; (8005fb8 <HAL_DMA_IRQHandler+0x12d0>)
 8005f08:	4299      	cmp	r1, r3
 8005f0a:	d026      	beq.n	8005f5a <HAL_DMA_IRQHandler+0x1272>
 8005f0c:	687b      	ldr	r3, [r7, #4]
 8005f0e:	681b      	ldr	r3, [r3, #0]
 8005f10:	4619      	mov	r1, r3
 8005f12:	4b2a      	ldr	r3, [pc, #168]	; (8005fbc <HAL_DMA_IRQHandler+0x12d4>)
 8005f14:	4299      	cmp	r1, r3
 8005f16:	d01d      	beq.n	8005f54 <HAL_DMA_IRQHandler+0x126c>
 8005f18:	687b      	ldr	r3, [r7, #4]
 8005f1a:	681b      	ldr	r3, [r3, #0]
 8005f1c:	4619      	mov	r1, r3
 8005f1e:	4b28      	ldr	r3, [pc, #160]	; (8005fc0 <HAL_DMA_IRQHandler+0x12d8>)
 8005f20:	4299      	cmp	r1, r3
 8005f22:	d014      	beq.n	8005f4e <HAL_DMA_IRQHandler+0x1266>
 8005f24:	687b      	ldr	r3, [r7, #4]
 8005f26:	681b      	ldr	r3, [r3, #0]
 8005f28:	4619      	mov	r1, r3
 8005f2a:	4b26      	ldr	r3, [pc, #152]	; (8005fc4 <HAL_DMA_IRQHandler+0x12dc>)
 8005f2c:	4299      	cmp	r1, r3
 8005f2e:	d00b      	beq.n	8005f48 <HAL_DMA_IRQHandler+0x1260>
 8005f30:	687b      	ldr	r3, [r7, #4]
 8005f32:	681b      	ldr	r3, [r3, #0]
 8005f34:	4619      	mov	r1, r3
 8005f36:	4b24      	ldr	r3, [pc, #144]	; (8005fc8 <HAL_DMA_IRQHandler+0x12e0>)
 8005f38:	4299      	cmp	r1, r3
 8005f3a:	d102      	bne.n	8005f42 <HAL_DMA_IRQHandler+0x125a>
 8005f3c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8005f40:	e01e      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f42:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8005f46:	e01b      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f48:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8005f4c:	e018      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f4e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8005f52:	e015      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f54:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8005f58:	e012      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f5a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005f5e:	e00f      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f60:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005f64:	e00c      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f66:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005f6a:	e009      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f6c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005f70:	e006      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f72:	4b16      	ldr	r3, [pc, #88]	; (8005fcc <HAL_DMA_IRQHandler+0x12e4>)
 8005f74:	e004      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f76:	4b15      	ldr	r3, [pc, #84]	; (8005fcc <HAL_DMA_IRQHandler+0x12e4>)
 8005f78:	e002      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f7a:	4b14      	ldr	r3, [pc, #80]	; (8005fcc <HAL_DMA_IRQHandler+0x12e4>)
 8005f7c:	e000      	b.n	8005f80 <HAL_DMA_IRQHandler+0x1298>
 8005f7e:	4b13      	ldr	r3, [pc, #76]	; (8005fcc <HAL_DMA_IRQHandler+0x12e4>)
 8005f80:	4013      	ands	r3, r2
 8005f82:	2b00      	cmp	r3, #0
 8005f84:	bf14      	ite	ne
 8005f86:	2301      	movne	r3, #1
 8005f88:	2300      	moveq	r3, #0
 8005f8a:	b2db      	uxtb	r3, r3
 8005f8c:	e12d      	b.n	80061ea <HAL_DMA_IRQHandler+0x1502>
 8005f8e:	bf00      	nop
 8005f90:	00800001 	.word	0x00800001
 8005f94:	40026458 	.word	0x40026458
 8005f98:	40026400 	.word	0x40026400
 8005f9c:	40026010 	.word	0x40026010
 8005fa0:	40026410 	.word	0x40026410
 8005fa4:	40026070 	.word	0x40026070
 8005fa8:	40026470 	.word	0x40026470
 8005fac:	40026028 	.word	0x40026028
 8005fb0:	40026428 	.word	0x40026428
 8005fb4:	40026088 	.word	0x40026088
 8005fb8:	40026488 	.word	0x40026488
 8005fbc:	40026040 	.word	0x40026040
 8005fc0:	40026440 	.word	0x40026440
 8005fc4:	400260a0 	.word	0x400260a0
 8005fc8:	400264a0 	.word	0x400264a0
 8005fcc:	00800004 	.word	0x00800004
 8005fd0:	400260b8 	.word	0x400260b8
 8005fd4:	687b      	ldr	r3, [r7, #4]
 8005fd6:	681b      	ldr	r3, [r3, #0]
 8005fd8:	461a      	mov	r2, r3
 8005fda:	4b71      	ldr	r3, [pc, #452]	; (80061a0 <HAL_DMA_IRQHandler+0x14b8>)
 8005fdc:	429a      	cmp	r2, r3
 8005fde:	d972      	bls.n	80060c6 <HAL_DMA_IRQHandler+0x13de>
 8005fe0:	4b70      	ldr	r3, [pc, #448]	; (80061a4 <HAL_DMA_IRQHandler+0x14bc>)
 8005fe2:	685a      	ldr	r2, [r3, #4]
 8005fe4:	687b      	ldr	r3, [r7, #4]
 8005fe6:	681b      	ldr	r3, [r3, #0]
 8005fe8:	4619      	mov	r1, r3
 8005fea:	4b6f      	ldr	r3, [pc, #444]	; (80061a8 <HAL_DMA_IRQHandler+0x14c0>)
 8005fec:	4299      	cmp	r1, r3
 8005fee:	d062      	beq.n	80060b6 <HAL_DMA_IRQHandler+0x13ce>
 8005ff0:	687b      	ldr	r3, [r7, #4]
 8005ff2:	681b      	ldr	r3, [r3, #0]
 8005ff4:	4619      	mov	r1, r3
 8005ff6:	4b6d      	ldr	r3, [pc, #436]	; (80061ac <HAL_DMA_IRQHandler+0x14c4>)
 8005ff8:	4299      	cmp	r1, r3
 8005ffa:	d05a      	beq.n	80060b2 <HAL_DMA_IRQHandler+0x13ca>
 8005ffc:	687b      	ldr	r3, [r7, #4]
 8005ffe:	681b      	ldr	r3, [r3, #0]
 8006000:	4619      	mov	r1, r3
 8006002:	4b6b      	ldr	r3, [pc, #428]	; (80061b0 <HAL_DMA_IRQHandler+0x14c8>)
 8006004:	4299      	cmp	r1, r3
 8006006:	d052      	beq.n	80060ae <HAL_DMA_IRQHandler+0x13c6>
 8006008:	687b      	ldr	r3, [r7, #4]
 800600a:	681b      	ldr	r3, [r3, #0]
 800600c:	4619      	mov	r1, r3
 800600e:	4b69      	ldr	r3, [pc, #420]	; (80061b4 <HAL_DMA_IRQHandler+0x14cc>)
 8006010:	4299      	cmp	r1, r3
 8006012:	d04a      	beq.n	80060aa <HAL_DMA_IRQHandler+0x13c2>
 8006014:	687b      	ldr	r3, [r7, #4]
 8006016:	681b      	ldr	r3, [r3, #0]
 8006018:	4619      	mov	r1, r3
 800601a:	4b67      	ldr	r3, [pc, #412]	; (80061b8 <HAL_DMA_IRQHandler+0x14d0>)
 800601c:	4299      	cmp	r1, r3
 800601e:	d041      	beq.n	80060a4 <HAL_DMA_IRQHandler+0x13bc>
 8006020:	687b      	ldr	r3, [r7, #4]
 8006022:	681b      	ldr	r3, [r3, #0]
 8006024:	4619      	mov	r1, r3
 8006026:	4b65      	ldr	r3, [pc, #404]	; (80061bc <HAL_DMA_IRQHandler+0x14d4>)
 8006028:	4299      	cmp	r1, r3
 800602a:	d038      	beq.n	800609e <HAL_DMA_IRQHandler+0x13b6>
 800602c:	687b      	ldr	r3, [r7, #4]
 800602e:	681b      	ldr	r3, [r3, #0]
 8006030:	4619      	mov	r1, r3
 8006032:	4b63      	ldr	r3, [pc, #396]	; (80061c0 <HAL_DMA_IRQHandler+0x14d8>)
 8006034:	4299      	cmp	r1, r3
 8006036:	d02f      	beq.n	8006098 <HAL_DMA_IRQHandler+0x13b0>
 8006038:	687b      	ldr	r3, [r7, #4]
 800603a:	681b      	ldr	r3, [r3, #0]
 800603c:	4619      	mov	r1, r3
 800603e:	4b61      	ldr	r3, [pc, #388]	; (80061c4 <HAL_DMA_IRQHandler+0x14dc>)
 8006040:	4299      	cmp	r1, r3
 8006042:	d026      	beq.n	8006092 <HAL_DMA_IRQHandler+0x13aa>
 8006044:	687b      	ldr	r3, [r7, #4]
 8006046:	681b      	ldr	r3, [r3, #0]
 8006048:	4619      	mov	r1, r3
 800604a:	4b5f      	ldr	r3, [pc, #380]	; (80061c8 <HAL_DMA_IRQHandler+0x14e0>)
 800604c:	4299      	cmp	r1, r3
 800604e:	d01d      	beq.n	800608c <HAL_DMA_IRQHandler+0x13a4>
 8006050:	687b      	ldr	r3, [r7, #4]
 8006052:	681b      	ldr	r3, [r3, #0]
 8006054:	4619      	mov	r1, r3
 8006056:	4b5d      	ldr	r3, [pc, #372]	; (80061cc <HAL_DMA_IRQHandler+0x14e4>)
 8006058:	4299      	cmp	r1, r3
 800605a:	d014      	beq.n	8006086 <HAL_DMA_IRQHandler+0x139e>
 800605c:	687b      	ldr	r3, [r7, #4]
 800605e:	681b      	ldr	r3, [r3, #0]
 8006060:	4619      	mov	r1, r3
 8006062:	4b5b      	ldr	r3, [pc, #364]	; (80061d0 <HAL_DMA_IRQHandler+0x14e8>)
 8006064:	4299      	cmp	r1, r3
 8006066:	d00b      	beq.n	8006080 <HAL_DMA_IRQHandler+0x1398>
 8006068:	687b      	ldr	r3, [r7, #4]
 800606a:	681b      	ldr	r3, [r3, #0]
 800606c:	4619      	mov	r1, r3
 800606e:	4b59      	ldr	r3, [pc, #356]	; (80061d4 <HAL_DMA_IRQHandler+0x14ec>)
 8006070:	4299      	cmp	r1, r3
 8006072:	d102      	bne.n	800607a <HAL_DMA_IRQHandler+0x1392>
 8006074:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006078:	e01e      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 800607a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800607e:	e01b      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 8006080:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006084:	e018      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 8006086:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800608a:	e015      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 800608c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006090:	e012      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 8006092:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006096:	e00f      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 8006098:	f44f 7380 	mov.w	r3, #256	; 0x100
 800609c:	e00c      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 800609e:	f44f 7380 	mov.w	r3, #256	; 0x100
 80060a2:	e009      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 80060a4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80060a8:	e006      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 80060aa:	4b4b      	ldr	r3, [pc, #300]	; (80061d8 <HAL_DMA_IRQHandler+0x14f0>)
 80060ac:	e004      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 80060ae:	4b4a      	ldr	r3, [pc, #296]	; (80061d8 <HAL_DMA_IRQHandler+0x14f0>)
 80060b0:	e002      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 80060b2:	4b49      	ldr	r3, [pc, #292]	; (80061d8 <HAL_DMA_IRQHandler+0x14f0>)
 80060b4:	e000      	b.n	80060b8 <HAL_DMA_IRQHandler+0x13d0>
 80060b6:	4b48      	ldr	r3, [pc, #288]	; (80061d8 <HAL_DMA_IRQHandler+0x14f0>)
 80060b8:	4013      	ands	r3, r2
 80060ba:	2b00      	cmp	r3, #0
 80060bc:	bf14      	ite	ne
 80060be:	2301      	movne	r3, #1
 80060c0:	2300      	moveq	r3, #0
 80060c2:	b2db      	uxtb	r3, r3
 80060c4:	e091      	b.n	80061ea <HAL_DMA_IRQHandler+0x1502>
 80060c6:	4b37      	ldr	r3, [pc, #220]	; (80061a4 <HAL_DMA_IRQHandler+0x14bc>)
 80060c8:	681a      	ldr	r2, [r3, #0]
 80060ca:	687b      	ldr	r3, [r7, #4]
 80060cc:	681b      	ldr	r3, [r3, #0]
 80060ce:	4619      	mov	r1, r3
 80060d0:	4b35      	ldr	r3, [pc, #212]	; (80061a8 <HAL_DMA_IRQHandler+0x14c0>)
 80060d2:	4299      	cmp	r1, r3
 80060d4:	f000 8082 	beq.w	80061dc <HAL_DMA_IRQHandler+0x14f4>
 80060d8:	687b      	ldr	r3, [r7, #4]
 80060da:	681b      	ldr	r3, [r3, #0]
 80060dc:	4619      	mov	r1, r3
 80060de:	4b33      	ldr	r3, [pc, #204]	; (80061ac <HAL_DMA_IRQHandler+0x14c4>)
 80060e0:	4299      	cmp	r1, r3
 80060e2:	d05a      	beq.n	800619a <HAL_DMA_IRQHandler+0x14b2>
 80060e4:	687b      	ldr	r3, [r7, #4]
 80060e6:	681b      	ldr	r3, [r3, #0]
 80060e8:	4619      	mov	r1, r3
 80060ea:	4b31      	ldr	r3, [pc, #196]	; (80061b0 <HAL_DMA_IRQHandler+0x14c8>)
 80060ec:	4299      	cmp	r1, r3
 80060ee:	d052      	beq.n	8006196 <HAL_DMA_IRQHandler+0x14ae>
 80060f0:	687b      	ldr	r3, [r7, #4]
 80060f2:	681b      	ldr	r3, [r3, #0]
 80060f4:	4619      	mov	r1, r3
 80060f6:	4b2f      	ldr	r3, [pc, #188]	; (80061b4 <HAL_DMA_IRQHandler+0x14cc>)
 80060f8:	4299      	cmp	r1, r3
 80060fa:	d04a      	beq.n	8006192 <HAL_DMA_IRQHandler+0x14aa>
 80060fc:	687b      	ldr	r3, [r7, #4]
 80060fe:	681b      	ldr	r3, [r3, #0]
 8006100:	4619      	mov	r1, r3
 8006102:	4b2d      	ldr	r3, [pc, #180]	; (80061b8 <HAL_DMA_IRQHandler+0x14d0>)
 8006104:	4299      	cmp	r1, r3
 8006106:	d041      	beq.n	800618c <HAL_DMA_IRQHandler+0x14a4>
 8006108:	687b      	ldr	r3, [r7, #4]
 800610a:	681b      	ldr	r3, [r3, #0]
 800610c:	4619      	mov	r1, r3
 800610e:	4b2b      	ldr	r3, [pc, #172]	; (80061bc <HAL_DMA_IRQHandler+0x14d4>)
 8006110:	4299      	cmp	r1, r3
 8006112:	d038      	beq.n	8006186 <HAL_DMA_IRQHandler+0x149e>
 8006114:	687b      	ldr	r3, [r7, #4]
 8006116:	681b      	ldr	r3, [r3, #0]
 8006118:	4619      	mov	r1, r3
 800611a:	4b29      	ldr	r3, [pc, #164]	; (80061c0 <HAL_DMA_IRQHandler+0x14d8>)
 800611c:	4299      	cmp	r1, r3
 800611e:	d02f      	beq.n	8006180 <HAL_DMA_IRQHandler+0x1498>
 8006120:	687b      	ldr	r3, [r7, #4]
 8006122:	681b      	ldr	r3, [r3, #0]
 8006124:	4619      	mov	r1, r3
 8006126:	4b27      	ldr	r3, [pc, #156]	; (80061c4 <HAL_DMA_IRQHandler+0x14dc>)
 8006128:	4299      	cmp	r1, r3
 800612a:	d026      	beq.n	800617a <HAL_DMA_IRQHandler+0x1492>
 800612c:	687b      	ldr	r3, [r7, #4]
 800612e:	681b      	ldr	r3, [r3, #0]
 8006130:	4619      	mov	r1, r3
 8006132:	4b25      	ldr	r3, [pc, #148]	; (80061c8 <HAL_DMA_IRQHandler+0x14e0>)
 8006134:	4299      	cmp	r1, r3
 8006136:	d01d      	beq.n	8006174 <HAL_DMA_IRQHandler+0x148c>
 8006138:	687b      	ldr	r3, [r7, #4]
 800613a:	681b      	ldr	r3, [r3, #0]
 800613c:	4619      	mov	r1, r3
 800613e:	4b23      	ldr	r3, [pc, #140]	; (80061cc <HAL_DMA_IRQHandler+0x14e4>)
 8006140:	4299      	cmp	r1, r3
 8006142:	d014      	beq.n	800616e <HAL_DMA_IRQHandler+0x1486>
 8006144:	687b      	ldr	r3, [r7, #4]
 8006146:	681b      	ldr	r3, [r3, #0]
 8006148:	4619      	mov	r1, r3
 800614a:	4b21      	ldr	r3, [pc, #132]	; (80061d0 <HAL_DMA_IRQHandler+0x14e8>)
 800614c:	4299      	cmp	r1, r3
 800614e:	d00b      	beq.n	8006168 <HAL_DMA_IRQHandler+0x1480>
 8006150:	687b      	ldr	r3, [r7, #4]
 8006152:	681b      	ldr	r3, [r3, #0]
 8006154:	4619      	mov	r1, r3
 8006156:	4b1f      	ldr	r3, [pc, #124]	; (80061d4 <HAL_DMA_IRQHandler+0x14ec>)
 8006158:	4299      	cmp	r1, r3
 800615a:	d102      	bne.n	8006162 <HAL_DMA_IRQHandler+0x147a>
 800615c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006160:	e03d      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 8006162:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8006166:	e03a      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 8006168:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800616c:	e037      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 800616e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006172:	e034      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 8006174:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006178:	e031      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 800617a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800617e:	e02e      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 8006180:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006184:	e02b      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 8006186:	f44f 7380 	mov.w	r3, #256	; 0x100
 800618a:	e028      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 800618c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006190:	e025      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 8006192:	4b11      	ldr	r3, [pc, #68]	; (80061d8 <HAL_DMA_IRQHandler+0x14f0>)
 8006194:	e023      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 8006196:	4b10      	ldr	r3, [pc, #64]	; (80061d8 <HAL_DMA_IRQHandler+0x14f0>)
 8006198:	e021      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 800619a:	4b0f      	ldr	r3, [pc, #60]	; (80061d8 <HAL_DMA_IRQHandler+0x14f0>)
 800619c:	e01f      	b.n	80061de <HAL_DMA_IRQHandler+0x14f6>
 800619e:	bf00      	nop
 80061a0:	40026058 	.word	0x40026058
 80061a4:	40026000 	.word	0x40026000
 80061a8:	40026010 	.word	0x40026010
 80061ac:	40026410 	.word	0x40026410
 80061b0:	40026070 	.word	0x40026070
 80061b4:	40026470 	.word	0x40026470
 80061b8:	40026028 	.word	0x40026028
 80061bc:	40026428 	.word	0x40026428
 80061c0:	40026088 	.word	0x40026088
 80061c4:	40026488 	.word	0x40026488
 80061c8:	40026040 	.word	0x40026040
 80061cc:	40026440 	.word	0x40026440
 80061d0:	400260a0 	.word	0x400260a0
 80061d4:	400264a0 	.word	0x400264a0
 80061d8:	00800004 	.word	0x00800004
 80061dc:	4b80      	ldr	r3, [pc, #512]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80061de:	4013      	ands	r3, r2
 80061e0:	2b00      	cmp	r3, #0
 80061e2:	bf14      	ite	ne
 80061e4:	2301      	movne	r3, #1
 80061e6:	2300      	moveq	r3, #0
 80061e8:	b2db      	uxtb	r3, r3
 80061ea:	2b00      	cmp	r3, #0
 80061ec:	f000 822c 	beq.w	8006648 <HAL_DMA_IRQHandler+0x1960>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 80061f0:	687b      	ldr	r3, [r7, #4]
 80061f2:	681b      	ldr	r3, [r3, #0]
 80061f4:	681b      	ldr	r3, [r3, #0]
 80061f6:	f003 0302 	and.w	r3, r3, #2
 80061fa:	2b00      	cmp	r3, #0
 80061fc:	f000 8224 	beq.w	8006648 <HAL_DMA_IRQHandler+0x1960>
    {
      /* Disable the direct mode Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
 8006200:	687b      	ldr	r3, [r7, #4]
 8006202:	681b      	ldr	r3, [r3, #0]
 8006204:	687a      	ldr	r2, [r7, #4]
 8006206:	6812      	ldr	r2, [r2, #0]
 8006208:	6812      	ldr	r2, [r2, #0]
 800620a:	f022 0202 	bic.w	r2, r2, #2
 800620e:	601a      	str	r2, [r3, #0]

      /* Clear the direct mode error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8006210:	687b      	ldr	r3, [r7, #4]
 8006212:	681b      	ldr	r3, [r3, #0]
 8006214:	461a      	mov	r2, r3
 8006216:	4b73      	ldr	r3, [pc, #460]	; (80063e4 <HAL_DMA_IRQHandler+0x16fc>)
 8006218:	429a      	cmp	r2, r3
 800621a:	d96c      	bls.n	80062f6 <HAL_DMA_IRQHandler+0x160e>
 800621c:	4a72      	ldr	r2, [pc, #456]	; (80063e8 <HAL_DMA_IRQHandler+0x1700>)
 800621e:	687b      	ldr	r3, [r7, #4]
 8006220:	681b      	ldr	r3, [r3, #0]
 8006222:	4619      	mov	r1, r3
 8006224:	4b71      	ldr	r3, [pc, #452]	; (80063ec <HAL_DMA_IRQHandler+0x1704>)
 8006226:	4299      	cmp	r1, r3
 8006228:	d062      	beq.n	80062f0 <HAL_DMA_IRQHandler+0x1608>
 800622a:	687b      	ldr	r3, [r7, #4]
 800622c:	681b      	ldr	r3, [r3, #0]
 800622e:	4619      	mov	r1, r3
 8006230:	4b6f      	ldr	r3, [pc, #444]	; (80063f0 <HAL_DMA_IRQHandler+0x1708>)
 8006232:	4299      	cmp	r1, r3
 8006234:	d05a      	beq.n	80062ec <HAL_DMA_IRQHandler+0x1604>
 8006236:	687b      	ldr	r3, [r7, #4]
 8006238:	681b      	ldr	r3, [r3, #0]
 800623a:	4619      	mov	r1, r3
 800623c:	4b6d      	ldr	r3, [pc, #436]	; (80063f4 <HAL_DMA_IRQHandler+0x170c>)
 800623e:	4299      	cmp	r1, r3
 8006240:	d052      	beq.n	80062e8 <HAL_DMA_IRQHandler+0x1600>
 8006242:	687b      	ldr	r3, [r7, #4]
 8006244:	681b      	ldr	r3, [r3, #0]
 8006246:	4619      	mov	r1, r3
 8006248:	4b6b      	ldr	r3, [pc, #428]	; (80063f8 <HAL_DMA_IRQHandler+0x1710>)
 800624a:	4299      	cmp	r1, r3
 800624c:	d04a      	beq.n	80062e4 <HAL_DMA_IRQHandler+0x15fc>
 800624e:	687b      	ldr	r3, [r7, #4]
 8006250:	681b      	ldr	r3, [r3, #0]
 8006252:	4619      	mov	r1, r3
 8006254:	4b69      	ldr	r3, [pc, #420]	; (80063fc <HAL_DMA_IRQHandler+0x1714>)
 8006256:	4299      	cmp	r1, r3
 8006258:	d041      	beq.n	80062de <HAL_DMA_IRQHandler+0x15f6>
 800625a:	687b      	ldr	r3, [r7, #4]
 800625c:	681b      	ldr	r3, [r3, #0]
 800625e:	4619      	mov	r1, r3
 8006260:	4b67      	ldr	r3, [pc, #412]	; (8006400 <HAL_DMA_IRQHandler+0x1718>)
 8006262:	4299      	cmp	r1, r3
 8006264:	d038      	beq.n	80062d8 <HAL_DMA_IRQHandler+0x15f0>
 8006266:	687b      	ldr	r3, [r7, #4]
 8006268:	681b      	ldr	r3, [r3, #0]
 800626a:	4619      	mov	r1, r3
 800626c:	4b65      	ldr	r3, [pc, #404]	; (8006404 <HAL_DMA_IRQHandler+0x171c>)
 800626e:	4299      	cmp	r1, r3
 8006270:	d02f      	beq.n	80062d2 <HAL_DMA_IRQHandler+0x15ea>
 8006272:	687b      	ldr	r3, [r7, #4]
 8006274:	681b      	ldr	r3, [r3, #0]
 8006276:	4619      	mov	r1, r3
 8006278:	4b63      	ldr	r3, [pc, #396]	; (8006408 <HAL_DMA_IRQHandler+0x1720>)
 800627a:	4299      	cmp	r1, r3
 800627c:	d026      	beq.n	80062cc <HAL_DMA_IRQHandler+0x15e4>
 800627e:	687b      	ldr	r3, [r7, #4]
 8006280:	681b      	ldr	r3, [r3, #0]
 8006282:	4619      	mov	r1, r3
 8006284:	4b61      	ldr	r3, [pc, #388]	; (800640c <HAL_DMA_IRQHandler+0x1724>)
 8006286:	4299      	cmp	r1, r3
 8006288:	d01d      	beq.n	80062c6 <HAL_DMA_IRQHandler+0x15de>
 800628a:	687b      	ldr	r3, [r7, #4]
 800628c:	681b      	ldr	r3, [r3, #0]
 800628e:	4619      	mov	r1, r3
 8006290:	4b5f      	ldr	r3, [pc, #380]	; (8006410 <HAL_DMA_IRQHandler+0x1728>)
 8006292:	4299      	cmp	r1, r3
 8006294:	d014      	beq.n	80062c0 <HAL_DMA_IRQHandler+0x15d8>
 8006296:	687b      	ldr	r3, [r7, #4]
 8006298:	681b      	ldr	r3, [r3, #0]
 800629a:	4619      	mov	r1, r3
 800629c:	4b5d      	ldr	r3, [pc, #372]	; (8006414 <HAL_DMA_IRQHandler+0x172c>)
 800629e:	4299      	cmp	r1, r3
 80062a0:	d00b      	beq.n	80062ba <HAL_DMA_IRQHandler+0x15d2>
 80062a2:	687b      	ldr	r3, [r7, #4]
 80062a4:	681b      	ldr	r3, [r3, #0]
 80062a6:	4619      	mov	r1, r3
 80062a8:	4b5b      	ldr	r3, [pc, #364]	; (8006418 <HAL_DMA_IRQHandler+0x1730>)
 80062aa:	4299      	cmp	r1, r3
 80062ac:	d102      	bne.n	80062b4 <HAL_DMA_IRQHandler+0x15cc>
 80062ae:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80062b2:	e01e      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062b4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80062b8:	e01b      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062ba:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80062be:	e018      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062c0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80062c4:	e015      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062c6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80062ca:	e012      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062cc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80062d0:	e00f      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062d2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80062d6:	e00c      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062d8:	f44f 7380 	mov.w	r3, #256	; 0x100
 80062dc:	e009      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062de:	f44f 7380 	mov.w	r3, #256	; 0x100
 80062e2:	e006      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062e4:	4b3e      	ldr	r3, [pc, #248]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80062e6:	e004      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062e8:	4b3d      	ldr	r3, [pc, #244]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80062ea:	e002      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062ec:	4b3c      	ldr	r3, [pc, #240]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80062ee:	e000      	b.n	80062f2 <HAL_DMA_IRQHandler+0x160a>
 80062f0:	4b3b      	ldr	r3, [pc, #236]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80062f2:	60d3      	str	r3, [r2, #12]
 80062f4:	e192      	b.n	800661c <HAL_DMA_IRQHandler+0x1934>
 80062f6:	687b      	ldr	r3, [r7, #4]
 80062f8:	681b      	ldr	r3, [r3, #0]
 80062fa:	461a      	mov	r2, r3
 80062fc:	4b47      	ldr	r3, [pc, #284]	; (800641c <HAL_DMA_IRQHandler+0x1734>)
 80062fe:	429a      	cmp	r2, r3
 8006300:	f240 808e 	bls.w	8006420 <HAL_DMA_IRQHandler+0x1738>
 8006304:	4a38      	ldr	r2, [pc, #224]	; (80063e8 <HAL_DMA_IRQHandler+0x1700>)
 8006306:	687b      	ldr	r3, [r7, #4]
 8006308:	681b      	ldr	r3, [r3, #0]
 800630a:	4619      	mov	r1, r3
 800630c:	4b37      	ldr	r3, [pc, #220]	; (80063ec <HAL_DMA_IRQHandler+0x1704>)
 800630e:	4299      	cmp	r1, r3
 8006310:	d062      	beq.n	80063d8 <HAL_DMA_IRQHandler+0x16f0>
 8006312:	687b      	ldr	r3, [r7, #4]
 8006314:	681b      	ldr	r3, [r3, #0]
 8006316:	4619      	mov	r1, r3
 8006318:	4b35      	ldr	r3, [pc, #212]	; (80063f0 <HAL_DMA_IRQHandler+0x1708>)
 800631a:	4299      	cmp	r1, r3
 800631c:	d05a      	beq.n	80063d4 <HAL_DMA_IRQHandler+0x16ec>
 800631e:	687b      	ldr	r3, [r7, #4]
 8006320:	681b      	ldr	r3, [r3, #0]
 8006322:	4619      	mov	r1, r3
 8006324:	4b33      	ldr	r3, [pc, #204]	; (80063f4 <HAL_DMA_IRQHandler+0x170c>)
 8006326:	4299      	cmp	r1, r3
 8006328:	d052      	beq.n	80063d0 <HAL_DMA_IRQHandler+0x16e8>
 800632a:	687b      	ldr	r3, [r7, #4]
 800632c:	681b      	ldr	r3, [r3, #0]
 800632e:	4619      	mov	r1, r3
 8006330:	4b31      	ldr	r3, [pc, #196]	; (80063f8 <HAL_DMA_IRQHandler+0x1710>)
 8006332:	4299      	cmp	r1, r3
 8006334:	d04a      	beq.n	80063cc <HAL_DMA_IRQHandler+0x16e4>
 8006336:	687b      	ldr	r3, [r7, #4]
 8006338:	681b      	ldr	r3, [r3, #0]
 800633a:	4619      	mov	r1, r3
 800633c:	4b2f      	ldr	r3, [pc, #188]	; (80063fc <HAL_DMA_IRQHandler+0x1714>)
 800633e:	4299      	cmp	r1, r3
 8006340:	d041      	beq.n	80063c6 <HAL_DMA_IRQHandler+0x16de>
 8006342:	687b      	ldr	r3, [r7, #4]
 8006344:	681b      	ldr	r3, [r3, #0]
 8006346:	4619      	mov	r1, r3
 8006348:	4b2d      	ldr	r3, [pc, #180]	; (8006400 <HAL_DMA_IRQHandler+0x1718>)
 800634a:	4299      	cmp	r1, r3
 800634c:	d038      	beq.n	80063c0 <HAL_DMA_IRQHandler+0x16d8>
 800634e:	687b      	ldr	r3, [r7, #4]
 8006350:	681b      	ldr	r3, [r3, #0]
 8006352:	4619      	mov	r1, r3
 8006354:	4b2b      	ldr	r3, [pc, #172]	; (8006404 <HAL_DMA_IRQHandler+0x171c>)
 8006356:	4299      	cmp	r1, r3
 8006358:	d02f      	beq.n	80063ba <HAL_DMA_IRQHandler+0x16d2>
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	681b      	ldr	r3, [r3, #0]
 800635e:	4619      	mov	r1, r3
 8006360:	4b29      	ldr	r3, [pc, #164]	; (8006408 <HAL_DMA_IRQHandler+0x1720>)
 8006362:	4299      	cmp	r1, r3
 8006364:	d026      	beq.n	80063b4 <HAL_DMA_IRQHandler+0x16cc>
 8006366:	687b      	ldr	r3, [r7, #4]
 8006368:	681b      	ldr	r3, [r3, #0]
 800636a:	4619      	mov	r1, r3
 800636c:	4b27      	ldr	r3, [pc, #156]	; (800640c <HAL_DMA_IRQHandler+0x1724>)
 800636e:	4299      	cmp	r1, r3
 8006370:	d01d      	beq.n	80063ae <HAL_DMA_IRQHandler+0x16c6>
 8006372:	687b      	ldr	r3, [r7, #4]
 8006374:	681b      	ldr	r3, [r3, #0]
 8006376:	4619      	mov	r1, r3
 8006378:	4b25      	ldr	r3, [pc, #148]	; (8006410 <HAL_DMA_IRQHandler+0x1728>)
 800637a:	4299      	cmp	r1, r3
 800637c:	d014      	beq.n	80063a8 <HAL_DMA_IRQHandler+0x16c0>
 800637e:	687b      	ldr	r3, [r7, #4]
 8006380:	681b      	ldr	r3, [r3, #0]
 8006382:	4619      	mov	r1, r3
 8006384:	4b23      	ldr	r3, [pc, #140]	; (8006414 <HAL_DMA_IRQHandler+0x172c>)
 8006386:	4299      	cmp	r1, r3
 8006388:	d00b      	beq.n	80063a2 <HAL_DMA_IRQHandler+0x16ba>
 800638a:	687b      	ldr	r3, [r7, #4]
 800638c:	681b      	ldr	r3, [r3, #0]
 800638e:	4619      	mov	r1, r3
 8006390:	4b21      	ldr	r3, [pc, #132]	; (8006418 <HAL_DMA_IRQHandler+0x1730>)
 8006392:	4299      	cmp	r1, r3
 8006394:	d102      	bne.n	800639c <HAL_DMA_IRQHandler+0x16b4>
 8006396:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800639a:	e01e      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 800639c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80063a0:	e01b      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063a2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80063a6:	e018      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063a8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80063ac:	e015      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063ae:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80063b2:	e012      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063b4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80063b8:	e00f      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063ba:	f44f 7380 	mov.w	r3, #256	; 0x100
 80063be:	e00c      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063c0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80063c4:	e009      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063c6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80063ca:	e006      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063cc:	4b04      	ldr	r3, [pc, #16]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80063ce:	e004      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063d0:	4b03      	ldr	r3, [pc, #12]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80063d2:	e002      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063d4:	4b02      	ldr	r3, [pc, #8]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80063d6:	e000      	b.n	80063da <HAL_DMA_IRQHandler+0x16f2>
 80063d8:	4b01      	ldr	r3, [pc, #4]	; (80063e0 <HAL_DMA_IRQHandler+0x16f8>)
 80063da:	6093      	str	r3, [r2, #8]
 80063dc:	e11e      	b.n	800661c <HAL_DMA_IRQHandler+0x1934>
 80063de:	bf00      	nop
 80063e0:	00800004 	.word	0x00800004
 80063e4:	40026458 	.word	0x40026458
 80063e8:	40026400 	.word	0x40026400
 80063ec:	40026010 	.word	0x40026010
 80063f0:	40026410 	.word	0x40026410
 80063f4:	40026070 	.word	0x40026070
 80063f8:	40026470 	.word	0x40026470
 80063fc:	40026028 	.word	0x40026028
 8006400:	40026428 	.word	0x40026428
 8006404:	40026088 	.word	0x40026088
 8006408:	40026488 	.word	0x40026488
 800640c:	40026040 	.word	0x40026040
 8006410:	40026440 	.word	0x40026440
 8006414:	400260a0 	.word	0x400260a0
 8006418:	400264a0 	.word	0x400264a0
 800641c:	400260b8 	.word	0x400260b8
 8006420:	687b      	ldr	r3, [r7, #4]
 8006422:	681b      	ldr	r3, [r3, #0]
 8006424:	461a      	mov	r2, r3
 8006426:	4b6d      	ldr	r3, [pc, #436]	; (80065dc <HAL_DMA_IRQHandler+0x18f4>)
 8006428:	429a      	cmp	r2, r3
 800642a:	d96c      	bls.n	8006506 <HAL_DMA_IRQHandler+0x181e>
 800642c:	4a6c      	ldr	r2, [pc, #432]	; (80065e0 <HAL_DMA_IRQHandler+0x18f8>)
 800642e:	687b      	ldr	r3, [r7, #4]
 8006430:	681b      	ldr	r3, [r3, #0]
 8006432:	4619      	mov	r1, r3
 8006434:	4b6b      	ldr	r3, [pc, #428]	; (80065e4 <HAL_DMA_IRQHandler+0x18fc>)
 8006436:	4299      	cmp	r1, r3
 8006438:	d062      	beq.n	8006500 <HAL_DMA_IRQHandler+0x1818>
 800643a:	687b      	ldr	r3, [r7, #4]
 800643c:	681b      	ldr	r3, [r3, #0]
 800643e:	4619      	mov	r1, r3
 8006440:	4b69      	ldr	r3, [pc, #420]	; (80065e8 <HAL_DMA_IRQHandler+0x1900>)
 8006442:	4299      	cmp	r1, r3
 8006444:	d05a      	beq.n	80064fc <HAL_DMA_IRQHandler+0x1814>
 8006446:	687b      	ldr	r3, [r7, #4]
 8006448:	681b      	ldr	r3, [r3, #0]
 800644a:	4619      	mov	r1, r3
 800644c:	4b67      	ldr	r3, [pc, #412]	; (80065ec <HAL_DMA_IRQHandler+0x1904>)
 800644e:	4299      	cmp	r1, r3
 8006450:	d052      	beq.n	80064f8 <HAL_DMA_IRQHandler+0x1810>
 8006452:	687b      	ldr	r3, [r7, #4]
 8006454:	681b      	ldr	r3, [r3, #0]
 8006456:	4619      	mov	r1, r3
 8006458:	4b65      	ldr	r3, [pc, #404]	; (80065f0 <HAL_DMA_IRQHandler+0x1908>)
 800645a:	4299      	cmp	r1, r3
 800645c:	d04a      	beq.n	80064f4 <HAL_DMA_IRQHandler+0x180c>
 800645e:	687b      	ldr	r3, [r7, #4]
 8006460:	681b      	ldr	r3, [r3, #0]
 8006462:	4619      	mov	r1, r3
 8006464:	4b63      	ldr	r3, [pc, #396]	; (80065f4 <HAL_DMA_IRQHandler+0x190c>)
 8006466:	4299      	cmp	r1, r3
 8006468:	d041      	beq.n	80064ee <HAL_DMA_IRQHandler+0x1806>
 800646a:	687b      	ldr	r3, [r7, #4]
 800646c:	681b      	ldr	r3, [r3, #0]
 800646e:	4619      	mov	r1, r3
 8006470:	4b61      	ldr	r3, [pc, #388]	; (80065f8 <HAL_DMA_IRQHandler+0x1910>)
 8006472:	4299      	cmp	r1, r3
 8006474:	d038      	beq.n	80064e8 <HAL_DMA_IRQHandler+0x1800>
 8006476:	687b      	ldr	r3, [r7, #4]
 8006478:	681b      	ldr	r3, [r3, #0]
 800647a:	4619      	mov	r1, r3
 800647c:	4b5f      	ldr	r3, [pc, #380]	; (80065fc <HAL_DMA_IRQHandler+0x1914>)
 800647e:	4299      	cmp	r1, r3
 8006480:	d02f      	beq.n	80064e2 <HAL_DMA_IRQHandler+0x17fa>
 8006482:	687b      	ldr	r3, [r7, #4]
 8006484:	681b      	ldr	r3, [r3, #0]
 8006486:	4619      	mov	r1, r3
 8006488:	4b5d      	ldr	r3, [pc, #372]	; (8006600 <HAL_DMA_IRQHandler+0x1918>)
 800648a:	4299      	cmp	r1, r3
 800648c:	d026      	beq.n	80064dc <HAL_DMA_IRQHandler+0x17f4>
 800648e:	687b      	ldr	r3, [r7, #4]
 8006490:	681b      	ldr	r3, [r3, #0]
 8006492:	4619      	mov	r1, r3
 8006494:	4b5b      	ldr	r3, [pc, #364]	; (8006604 <HAL_DMA_IRQHandler+0x191c>)
 8006496:	4299      	cmp	r1, r3
 8006498:	d01d      	beq.n	80064d6 <HAL_DMA_IRQHandler+0x17ee>
 800649a:	687b      	ldr	r3, [r7, #4]
 800649c:	681b      	ldr	r3, [r3, #0]
 800649e:	4619      	mov	r1, r3
 80064a0:	4b59      	ldr	r3, [pc, #356]	; (8006608 <HAL_DMA_IRQHandler+0x1920>)
 80064a2:	4299      	cmp	r1, r3
 80064a4:	d014      	beq.n	80064d0 <HAL_DMA_IRQHandler+0x17e8>
 80064a6:	687b      	ldr	r3, [r7, #4]
 80064a8:	681b      	ldr	r3, [r3, #0]
 80064aa:	4619      	mov	r1, r3
 80064ac:	4b57      	ldr	r3, [pc, #348]	; (800660c <HAL_DMA_IRQHandler+0x1924>)
 80064ae:	4299      	cmp	r1, r3
 80064b0:	d00b      	beq.n	80064ca <HAL_DMA_IRQHandler+0x17e2>
 80064b2:	687b      	ldr	r3, [r7, #4]
 80064b4:	681b      	ldr	r3, [r3, #0]
 80064b6:	4619      	mov	r1, r3
 80064b8:	4b55      	ldr	r3, [pc, #340]	; (8006610 <HAL_DMA_IRQHandler+0x1928>)
 80064ba:	4299      	cmp	r1, r3
 80064bc:	d102      	bne.n	80064c4 <HAL_DMA_IRQHandler+0x17dc>
 80064be:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80064c2:	e01e      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064c4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80064c8:	e01b      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064ca:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80064ce:	e018      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064d0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80064d4:	e015      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064d6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80064da:	e012      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064dc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80064e0:	e00f      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064e2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80064e6:	e00c      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064e8:	f44f 7380 	mov.w	r3, #256	; 0x100
 80064ec:	e009      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064ee:	f44f 7380 	mov.w	r3, #256	; 0x100
 80064f2:	e006      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064f4:	4b47      	ldr	r3, [pc, #284]	; (8006614 <HAL_DMA_IRQHandler+0x192c>)
 80064f6:	e004      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064f8:	4b46      	ldr	r3, [pc, #280]	; (8006614 <HAL_DMA_IRQHandler+0x192c>)
 80064fa:	e002      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 80064fc:	4b45      	ldr	r3, [pc, #276]	; (8006614 <HAL_DMA_IRQHandler+0x192c>)
 80064fe:	e000      	b.n	8006502 <HAL_DMA_IRQHandler+0x181a>
 8006500:	4b44      	ldr	r3, [pc, #272]	; (8006614 <HAL_DMA_IRQHandler+0x192c>)
 8006502:	60d3      	str	r3, [r2, #12]
 8006504:	e08a      	b.n	800661c <HAL_DMA_IRQHandler+0x1934>
 8006506:	4a36      	ldr	r2, [pc, #216]	; (80065e0 <HAL_DMA_IRQHandler+0x18f8>)
 8006508:	687b      	ldr	r3, [r7, #4]
 800650a:	681b      	ldr	r3, [r3, #0]
 800650c:	4619      	mov	r1, r3
 800650e:	4b35      	ldr	r3, [pc, #212]	; (80065e4 <HAL_DMA_IRQHandler+0x18fc>)
 8006510:	4299      	cmp	r1, r3
 8006512:	f000 8081 	beq.w	8006618 <HAL_DMA_IRQHandler+0x1930>
 8006516:	687b      	ldr	r3, [r7, #4]
 8006518:	681b      	ldr	r3, [r3, #0]
 800651a:	4619      	mov	r1, r3
 800651c:	4b32      	ldr	r3, [pc, #200]	; (80065e8 <HAL_DMA_IRQHandler+0x1900>)
 800651e:	4299      	cmp	r1, r3
 8006520:	d05a      	beq.n	80065d8 <HAL_DMA_IRQHandler+0x18f0>
 8006522:	687b      	ldr	r3, [r7, #4]
 8006524:	681b      	ldr	r3, [r3, #0]
 8006526:	4619      	mov	r1, r3
 8006528:	4b30      	ldr	r3, [pc, #192]	; (80065ec <HAL_DMA_IRQHandler+0x1904>)
 800652a:	4299      	cmp	r1, r3
 800652c:	d052      	beq.n	80065d4 <HAL_DMA_IRQHandler+0x18ec>
 800652e:	687b      	ldr	r3, [r7, #4]
 8006530:	681b      	ldr	r3, [r3, #0]
 8006532:	4619      	mov	r1, r3
 8006534:	4b2e      	ldr	r3, [pc, #184]	; (80065f0 <HAL_DMA_IRQHandler+0x1908>)
 8006536:	4299      	cmp	r1, r3
 8006538:	d04a      	beq.n	80065d0 <HAL_DMA_IRQHandler+0x18e8>
 800653a:	687b      	ldr	r3, [r7, #4]
 800653c:	681b      	ldr	r3, [r3, #0]
 800653e:	4619      	mov	r1, r3
 8006540:	4b2c      	ldr	r3, [pc, #176]	; (80065f4 <HAL_DMA_IRQHandler+0x190c>)
 8006542:	4299      	cmp	r1, r3
 8006544:	d041      	beq.n	80065ca <HAL_DMA_IRQHandler+0x18e2>
 8006546:	687b      	ldr	r3, [r7, #4]
 8006548:	681b      	ldr	r3, [r3, #0]
 800654a:	4619      	mov	r1, r3
 800654c:	4b2a      	ldr	r3, [pc, #168]	; (80065f8 <HAL_DMA_IRQHandler+0x1910>)
 800654e:	4299      	cmp	r1, r3
 8006550:	d038      	beq.n	80065c4 <HAL_DMA_IRQHandler+0x18dc>
 8006552:	687b      	ldr	r3, [r7, #4]
 8006554:	681b      	ldr	r3, [r3, #0]
 8006556:	4619      	mov	r1, r3
 8006558:	4b28      	ldr	r3, [pc, #160]	; (80065fc <HAL_DMA_IRQHandler+0x1914>)
 800655a:	4299      	cmp	r1, r3
 800655c:	d02f      	beq.n	80065be <HAL_DMA_IRQHandler+0x18d6>
 800655e:	687b      	ldr	r3, [r7, #4]
 8006560:	681b      	ldr	r3, [r3, #0]
 8006562:	4619      	mov	r1, r3
 8006564:	4b26      	ldr	r3, [pc, #152]	; (8006600 <HAL_DMA_IRQHandler+0x1918>)
 8006566:	4299      	cmp	r1, r3
 8006568:	d026      	beq.n	80065b8 <HAL_DMA_IRQHandler+0x18d0>
 800656a:	687b      	ldr	r3, [r7, #4]
 800656c:	681b      	ldr	r3, [r3, #0]
 800656e:	4619      	mov	r1, r3
 8006570:	4b24      	ldr	r3, [pc, #144]	; (8006604 <HAL_DMA_IRQHandler+0x191c>)
 8006572:	4299      	cmp	r1, r3
 8006574:	d01d      	beq.n	80065b2 <HAL_DMA_IRQHandler+0x18ca>
 8006576:	687b      	ldr	r3, [r7, #4]
 8006578:	681b      	ldr	r3, [r3, #0]
 800657a:	4619      	mov	r1, r3
 800657c:	4b22      	ldr	r3, [pc, #136]	; (8006608 <HAL_DMA_IRQHandler+0x1920>)
 800657e:	4299      	cmp	r1, r3
 8006580:	d014      	beq.n	80065ac <HAL_DMA_IRQHandler+0x18c4>
 8006582:	687b      	ldr	r3, [r7, #4]
 8006584:	681b      	ldr	r3, [r3, #0]
 8006586:	4619      	mov	r1, r3
 8006588:	4b20      	ldr	r3, [pc, #128]	; (800660c <HAL_DMA_IRQHandler+0x1924>)
 800658a:	4299      	cmp	r1, r3
 800658c:	d00b      	beq.n	80065a6 <HAL_DMA_IRQHandler+0x18be>
 800658e:	687b      	ldr	r3, [r7, #4]
 8006590:	681b      	ldr	r3, [r3, #0]
 8006592:	4619      	mov	r1, r3
 8006594:	4b1e      	ldr	r3, [pc, #120]	; (8006610 <HAL_DMA_IRQHandler+0x1928>)
 8006596:	4299      	cmp	r1, r3
 8006598:	d102      	bne.n	80065a0 <HAL_DMA_IRQHandler+0x18b8>
 800659a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800659e:	e03c      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065a0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80065a4:	e039      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065a6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80065aa:	e036      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065ac:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80065b0:	e033      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065b2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80065b6:	e030      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065b8:	f44f 7380 	mov.w	r3, #256	; 0x100
 80065bc:	e02d      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065be:	f44f 7380 	mov.w	r3, #256	; 0x100
 80065c2:	e02a      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065c4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80065c8:	e027      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065ca:	f44f 7380 	mov.w	r3, #256	; 0x100
 80065ce:	e024      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065d0:	4b10      	ldr	r3, [pc, #64]	; (8006614 <HAL_DMA_IRQHandler+0x192c>)
 80065d2:	e022      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065d4:	4b0f      	ldr	r3, [pc, #60]	; (8006614 <HAL_DMA_IRQHandler+0x192c>)
 80065d6:	e020      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065d8:	4b0e      	ldr	r3, [pc, #56]	; (8006614 <HAL_DMA_IRQHandler+0x192c>)
 80065da:	e01e      	b.n	800661a <HAL_DMA_IRQHandler+0x1932>
 80065dc:	40026058 	.word	0x40026058
 80065e0:	40026000 	.word	0x40026000
 80065e4:	40026010 	.word	0x40026010
 80065e8:	40026410 	.word	0x40026410
 80065ec:	40026070 	.word	0x40026070
 80065f0:	40026470 	.word	0x40026470
 80065f4:	40026028 	.word	0x40026028
 80065f8:	40026428 	.word	0x40026428
 80065fc:	40026088 	.word	0x40026088
 8006600:	40026488 	.word	0x40026488
 8006604:	40026040 	.word	0x40026040
 8006608:	40026440 	.word	0x40026440
 800660c:	400260a0 	.word	0x400260a0
 8006610:	400264a0 	.word	0x400264a0
 8006614:	00800004 	.word	0x00800004
 8006618:	4b85      	ldr	r3, [pc, #532]	; (8006830 <HAL_DMA_IRQHandler+0x1b48>)
 800661a:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 800661c:	687b      	ldr	r3, [r7, #4]
 800661e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8006620:	f043 0204 	orr.w	r2, r3, #4
 8006624:	687b      	ldr	r3, [r7, #4]
 8006626:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8006628:	687b      	ldr	r3, [r7, #4]
 800662a:	2204      	movs	r2, #4
 800662c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8006630:	687b      	ldr	r3, [r7, #4]
 8006632:	2200      	movs	r2, #0
 8006634:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 8006638:	687b      	ldr	r3, [r7, #4]
 800663a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800663c:	2b00      	cmp	r3, #0
 800663e:	d003      	beq.n	8006648 <HAL_DMA_IRQHandler+0x1960>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8006640:	687b      	ldr	r3, [r7, #4]
 8006642:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8006644:	6878      	ldr	r0, [r7, #4]
 8006646:	4798      	blx	r3
      }
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8006648:	687b      	ldr	r3, [r7, #4]
 800664a:	681b      	ldr	r3, [r3, #0]
 800664c:	461a      	mov	r2, r3
 800664e:	4b79      	ldr	r3, [pc, #484]	; (8006834 <HAL_DMA_IRQHandler+0x1b4c>)
 8006650:	429a      	cmp	r2, r3
 8006652:	d972      	bls.n	800673a <HAL_DMA_IRQHandler+0x1a52>
 8006654:	4b78      	ldr	r3, [pc, #480]	; (8006838 <HAL_DMA_IRQHandler+0x1b50>)
 8006656:	685a      	ldr	r2, [r3, #4]
 8006658:	687b      	ldr	r3, [r7, #4]
 800665a:	681b      	ldr	r3, [r3, #0]
 800665c:	4619      	mov	r1, r3
 800665e:	4b77      	ldr	r3, [pc, #476]	; (800683c <HAL_DMA_IRQHandler+0x1b54>)
 8006660:	4299      	cmp	r1, r3
 8006662:	d062      	beq.n	800672a <HAL_DMA_IRQHandler+0x1a42>
 8006664:	687b      	ldr	r3, [r7, #4]
 8006666:	681b      	ldr	r3, [r3, #0]
 8006668:	4619      	mov	r1, r3
 800666a:	4b75      	ldr	r3, [pc, #468]	; (8006840 <HAL_DMA_IRQHandler+0x1b58>)
 800666c:	4299      	cmp	r1, r3
 800666e:	d05a      	beq.n	8006726 <HAL_DMA_IRQHandler+0x1a3e>
 8006670:	687b      	ldr	r3, [r7, #4]
 8006672:	681b      	ldr	r3, [r3, #0]
 8006674:	4619      	mov	r1, r3
 8006676:	4b73      	ldr	r3, [pc, #460]	; (8006844 <HAL_DMA_IRQHandler+0x1b5c>)
 8006678:	4299      	cmp	r1, r3
 800667a:	d052      	beq.n	8006722 <HAL_DMA_IRQHandler+0x1a3a>
 800667c:	687b      	ldr	r3, [r7, #4]
 800667e:	681b      	ldr	r3, [r3, #0]
 8006680:	4619      	mov	r1, r3
 8006682:	4b71      	ldr	r3, [pc, #452]	; (8006848 <HAL_DMA_IRQHandler+0x1b60>)
 8006684:	4299      	cmp	r1, r3
 8006686:	d04a      	beq.n	800671e <HAL_DMA_IRQHandler+0x1a36>
 8006688:	687b      	ldr	r3, [r7, #4]
 800668a:	681b      	ldr	r3, [r3, #0]
 800668c:	4619      	mov	r1, r3
 800668e:	4b6f      	ldr	r3, [pc, #444]	; (800684c <HAL_DMA_IRQHandler+0x1b64>)
 8006690:	4299      	cmp	r1, r3
 8006692:	d041      	beq.n	8006718 <HAL_DMA_IRQHandler+0x1a30>
 8006694:	687b      	ldr	r3, [r7, #4]
 8006696:	681b      	ldr	r3, [r3, #0]
 8006698:	4619      	mov	r1, r3
 800669a:	4b6d      	ldr	r3, [pc, #436]	; (8006850 <HAL_DMA_IRQHandler+0x1b68>)
 800669c:	4299      	cmp	r1, r3
 800669e:	d038      	beq.n	8006712 <HAL_DMA_IRQHandler+0x1a2a>
 80066a0:	687b      	ldr	r3, [r7, #4]
 80066a2:	681b      	ldr	r3, [r3, #0]
 80066a4:	4619      	mov	r1, r3
 80066a6:	4b6b      	ldr	r3, [pc, #428]	; (8006854 <HAL_DMA_IRQHandler+0x1b6c>)
 80066a8:	4299      	cmp	r1, r3
 80066aa:	d02f      	beq.n	800670c <HAL_DMA_IRQHandler+0x1a24>
 80066ac:	687b      	ldr	r3, [r7, #4]
 80066ae:	681b      	ldr	r3, [r3, #0]
 80066b0:	4619      	mov	r1, r3
 80066b2:	4b69      	ldr	r3, [pc, #420]	; (8006858 <HAL_DMA_IRQHandler+0x1b70>)
 80066b4:	4299      	cmp	r1, r3
 80066b6:	d026      	beq.n	8006706 <HAL_DMA_IRQHandler+0x1a1e>
 80066b8:	687b      	ldr	r3, [r7, #4]
 80066ba:	681b      	ldr	r3, [r3, #0]
 80066bc:	4619      	mov	r1, r3
 80066be:	4b67      	ldr	r3, [pc, #412]	; (800685c <HAL_DMA_IRQHandler+0x1b74>)
 80066c0:	4299      	cmp	r1, r3
 80066c2:	d01d      	beq.n	8006700 <HAL_DMA_IRQHandler+0x1a18>
 80066c4:	687b      	ldr	r3, [r7, #4]
 80066c6:	681b      	ldr	r3, [r3, #0]
 80066c8:	4619      	mov	r1, r3
 80066ca:	4b65      	ldr	r3, [pc, #404]	; (8006860 <HAL_DMA_IRQHandler+0x1b78>)
 80066cc:	4299      	cmp	r1, r3
 80066ce:	d014      	beq.n	80066fa <HAL_DMA_IRQHandler+0x1a12>
 80066d0:	687b      	ldr	r3, [r7, #4]
 80066d2:	681b      	ldr	r3, [r3, #0]
 80066d4:	4619      	mov	r1, r3
 80066d6:	4b63      	ldr	r3, [pc, #396]	; (8006864 <HAL_DMA_IRQHandler+0x1b7c>)
 80066d8:	4299      	cmp	r1, r3
 80066da:	d00b      	beq.n	80066f4 <HAL_DMA_IRQHandler+0x1a0c>
 80066dc:	687b      	ldr	r3, [r7, #4]
 80066de:	681b      	ldr	r3, [r3, #0]
 80066e0:	4619      	mov	r1, r3
 80066e2:	4b61      	ldr	r3, [pc, #388]	; (8006868 <HAL_DMA_IRQHandler+0x1b80>)
 80066e4:	4299      	cmp	r1, r3
 80066e6:	d102      	bne.n	80066ee <HAL_DMA_IRQHandler+0x1a06>
 80066e8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80066ec:	e01e      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 80066ee:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 80066f2:	e01b      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 80066f4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80066f8:	e018      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 80066fa:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80066fe:	e015      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 8006700:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006704:	e012      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 8006706:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800670a:	e00f      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 800670c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006710:	e00c      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 8006712:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006716:	e009      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 8006718:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800671c:	e006      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 800671e:	2310      	movs	r3, #16
 8006720:	e004      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 8006722:	2310      	movs	r3, #16
 8006724:	e002      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 8006726:	2310      	movs	r3, #16
 8006728:	e000      	b.n	800672c <HAL_DMA_IRQHandler+0x1a44>
 800672a:	2310      	movs	r3, #16
 800672c:	4013      	ands	r3, r2
 800672e:	2b00      	cmp	r3, #0
 8006730:	bf14      	ite	ne
 8006732:	2301      	movne	r3, #1
 8006734:	2300      	moveq	r3, #0
 8006736:	b2db      	uxtb	r3, r3
 8006738:	e1a1      	b.n	8006a7e <HAL_DMA_IRQHandler+0x1d96>
 800673a:	687b      	ldr	r3, [r7, #4]
 800673c:	681b      	ldr	r3, [r3, #0]
 800673e:	461a      	mov	r2, r3
 8006740:	4b4a      	ldr	r3, [pc, #296]	; (800686c <HAL_DMA_IRQHandler+0x1b84>)
 8006742:	429a      	cmp	r2, r3
 8006744:	f240 8094 	bls.w	8006870 <HAL_DMA_IRQHandler+0x1b88>
 8006748:	4b3b      	ldr	r3, [pc, #236]	; (8006838 <HAL_DMA_IRQHandler+0x1b50>)
 800674a:	681a      	ldr	r2, [r3, #0]
 800674c:	687b      	ldr	r3, [r7, #4]
 800674e:	681b      	ldr	r3, [r3, #0]
 8006750:	4619      	mov	r1, r3
 8006752:	4b3a      	ldr	r3, [pc, #232]	; (800683c <HAL_DMA_IRQHandler+0x1b54>)
 8006754:	4299      	cmp	r1, r3
 8006756:	d062      	beq.n	800681e <HAL_DMA_IRQHandler+0x1b36>
 8006758:	687b      	ldr	r3, [r7, #4]
 800675a:	681b      	ldr	r3, [r3, #0]
 800675c:	4619      	mov	r1, r3
 800675e:	4b38      	ldr	r3, [pc, #224]	; (8006840 <HAL_DMA_IRQHandler+0x1b58>)
 8006760:	4299      	cmp	r1, r3
 8006762:	d05a      	beq.n	800681a <HAL_DMA_IRQHandler+0x1b32>
 8006764:	687b      	ldr	r3, [r7, #4]
 8006766:	681b      	ldr	r3, [r3, #0]
 8006768:	4619      	mov	r1, r3
 800676a:	4b36      	ldr	r3, [pc, #216]	; (8006844 <HAL_DMA_IRQHandler+0x1b5c>)
 800676c:	4299      	cmp	r1, r3
 800676e:	d052      	beq.n	8006816 <HAL_DMA_IRQHandler+0x1b2e>
 8006770:	687b      	ldr	r3, [r7, #4]
 8006772:	681b      	ldr	r3, [r3, #0]
 8006774:	4619      	mov	r1, r3
 8006776:	4b34      	ldr	r3, [pc, #208]	; (8006848 <HAL_DMA_IRQHandler+0x1b60>)
 8006778:	4299      	cmp	r1, r3
 800677a:	d04a      	beq.n	8006812 <HAL_DMA_IRQHandler+0x1b2a>
 800677c:	687b      	ldr	r3, [r7, #4]
 800677e:	681b      	ldr	r3, [r3, #0]
 8006780:	4619      	mov	r1, r3
 8006782:	4b32      	ldr	r3, [pc, #200]	; (800684c <HAL_DMA_IRQHandler+0x1b64>)
 8006784:	4299      	cmp	r1, r3
 8006786:	d041      	beq.n	800680c <HAL_DMA_IRQHandler+0x1b24>
 8006788:	687b      	ldr	r3, [r7, #4]
 800678a:	681b      	ldr	r3, [r3, #0]
 800678c:	4619      	mov	r1, r3
 800678e:	4b30      	ldr	r3, [pc, #192]	; (8006850 <HAL_DMA_IRQHandler+0x1b68>)
 8006790:	4299      	cmp	r1, r3
 8006792:	d038      	beq.n	8006806 <HAL_DMA_IRQHandler+0x1b1e>
 8006794:	687b      	ldr	r3, [r7, #4]
 8006796:	681b      	ldr	r3, [r3, #0]
 8006798:	4619      	mov	r1, r3
 800679a:	4b2e      	ldr	r3, [pc, #184]	; (8006854 <HAL_DMA_IRQHandler+0x1b6c>)
 800679c:	4299      	cmp	r1, r3
 800679e:	d02f      	beq.n	8006800 <HAL_DMA_IRQHandler+0x1b18>
 80067a0:	687b      	ldr	r3, [r7, #4]
 80067a2:	681b      	ldr	r3, [r3, #0]
 80067a4:	4619      	mov	r1, r3
 80067a6:	4b2c      	ldr	r3, [pc, #176]	; (8006858 <HAL_DMA_IRQHandler+0x1b70>)
 80067a8:	4299      	cmp	r1, r3
 80067aa:	d026      	beq.n	80067fa <HAL_DMA_IRQHandler+0x1b12>
 80067ac:	687b      	ldr	r3, [r7, #4]
 80067ae:	681b      	ldr	r3, [r3, #0]
 80067b0:	4619      	mov	r1, r3
 80067b2:	4b2a      	ldr	r3, [pc, #168]	; (800685c <HAL_DMA_IRQHandler+0x1b74>)
 80067b4:	4299      	cmp	r1, r3
 80067b6:	d01d      	beq.n	80067f4 <HAL_DMA_IRQHandler+0x1b0c>
 80067b8:	687b      	ldr	r3, [r7, #4]
 80067ba:	681b      	ldr	r3, [r3, #0]
 80067bc:	4619      	mov	r1, r3
 80067be:	4b28      	ldr	r3, [pc, #160]	; (8006860 <HAL_DMA_IRQHandler+0x1b78>)
 80067c0:	4299      	cmp	r1, r3
 80067c2:	d014      	beq.n	80067ee <HAL_DMA_IRQHandler+0x1b06>
 80067c4:	687b      	ldr	r3, [r7, #4]
 80067c6:	681b      	ldr	r3, [r3, #0]
 80067c8:	4619      	mov	r1, r3
 80067ca:	4b26      	ldr	r3, [pc, #152]	; (8006864 <HAL_DMA_IRQHandler+0x1b7c>)
 80067cc:	4299      	cmp	r1, r3
 80067ce:	d00b      	beq.n	80067e8 <HAL_DMA_IRQHandler+0x1b00>
 80067d0:	687b      	ldr	r3, [r7, #4]
 80067d2:	681b      	ldr	r3, [r3, #0]
 80067d4:	4619      	mov	r1, r3
 80067d6:	4b24      	ldr	r3, [pc, #144]	; (8006868 <HAL_DMA_IRQHandler+0x1b80>)
 80067d8:	4299      	cmp	r1, r3
 80067da:	d102      	bne.n	80067e2 <HAL_DMA_IRQHandler+0x1afa>
 80067dc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80067e0:	e01e      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 80067e2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 80067e6:	e01b      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 80067e8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80067ec:	e018      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 80067ee:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80067f2:	e015      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 80067f4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80067f8:	e012      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 80067fa:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80067fe:	e00f      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 8006800:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006804:	e00c      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 8006806:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800680a:	e009      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 800680c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006810:	e006      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 8006812:	2310      	movs	r3, #16
 8006814:	e004      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 8006816:	2310      	movs	r3, #16
 8006818:	e002      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 800681a:	2310      	movs	r3, #16
 800681c:	e000      	b.n	8006820 <HAL_DMA_IRQHandler+0x1b38>
 800681e:	2310      	movs	r3, #16
 8006820:	4013      	ands	r3, r2
 8006822:	2b00      	cmp	r3, #0
 8006824:	bf14      	ite	ne
 8006826:	2301      	movne	r3, #1
 8006828:	2300      	moveq	r3, #0
 800682a:	b2db      	uxtb	r3, r3
 800682c:	e127      	b.n	8006a7e <HAL_DMA_IRQHandler+0x1d96>
 800682e:	bf00      	nop
 8006830:	00800004 	.word	0x00800004
 8006834:	40026458 	.word	0x40026458
 8006838:	40026400 	.word	0x40026400
 800683c:	40026010 	.word	0x40026010
 8006840:	40026410 	.word	0x40026410
 8006844:	40026070 	.word	0x40026070
 8006848:	40026470 	.word	0x40026470
 800684c:	40026028 	.word	0x40026028
 8006850:	40026428 	.word	0x40026428
 8006854:	40026088 	.word	0x40026088
 8006858:	40026488 	.word	0x40026488
 800685c:	40026040 	.word	0x40026040
 8006860:	40026440 	.word	0x40026440
 8006864:	400260a0 	.word	0x400260a0
 8006868:	400264a0 	.word	0x400264a0
 800686c:	400260b8 	.word	0x400260b8
 8006870:	687b      	ldr	r3, [r7, #4]
 8006872:	681b      	ldr	r3, [r3, #0]
 8006874:	461a      	mov	r2, r3
 8006876:	4b70      	ldr	r3, [pc, #448]	; (8006a38 <HAL_DMA_IRQHandler+0x1d50>)
 8006878:	429a      	cmp	r2, r3
 800687a:	d972      	bls.n	8006962 <HAL_DMA_IRQHandler+0x1c7a>
 800687c:	4b6f      	ldr	r3, [pc, #444]	; (8006a3c <HAL_DMA_IRQHandler+0x1d54>)
 800687e:	685a      	ldr	r2, [r3, #4]
 8006880:	687b      	ldr	r3, [r7, #4]
 8006882:	681b      	ldr	r3, [r3, #0]
 8006884:	4619      	mov	r1, r3
 8006886:	4b6e      	ldr	r3, [pc, #440]	; (8006a40 <HAL_DMA_IRQHandler+0x1d58>)
 8006888:	4299      	cmp	r1, r3
 800688a:	d062      	beq.n	8006952 <HAL_DMA_IRQHandler+0x1c6a>
 800688c:	687b      	ldr	r3, [r7, #4]
 800688e:	681b      	ldr	r3, [r3, #0]
 8006890:	4619      	mov	r1, r3
 8006892:	4b6c      	ldr	r3, [pc, #432]	; (8006a44 <HAL_DMA_IRQHandler+0x1d5c>)
 8006894:	4299      	cmp	r1, r3
 8006896:	d05a      	beq.n	800694e <HAL_DMA_IRQHandler+0x1c66>
 8006898:	687b      	ldr	r3, [r7, #4]
 800689a:	681b      	ldr	r3, [r3, #0]
 800689c:	4619      	mov	r1, r3
 800689e:	4b6a      	ldr	r3, [pc, #424]	; (8006a48 <HAL_DMA_IRQHandler+0x1d60>)
 80068a0:	4299      	cmp	r1, r3
 80068a2:	d052      	beq.n	800694a <HAL_DMA_IRQHandler+0x1c62>
 80068a4:	687b      	ldr	r3, [r7, #4]
 80068a6:	681b      	ldr	r3, [r3, #0]
 80068a8:	4619      	mov	r1, r3
 80068aa:	4b68      	ldr	r3, [pc, #416]	; (8006a4c <HAL_DMA_IRQHandler+0x1d64>)
 80068ac:	4299      	cmp	r1, r3
 80068ae:	d04a      	beq.n	8006946 <HAL_DMA_IRQHandler+0x1c5e>
 80068b0:	687b      	ldr	r3, [r7, #4]
 80068b2:	681b      	ldr	r3, [r3, #0]
 80068b4:	4619      	mov	r1, r3
 80068b6:	4b66      	ldr	r3, [pc, #408]	; (8006a50 <HAL_DMA_IRQHandler+0x1d68>)
 80068b8:	4299      	cmp	r1, r3
 80068ba:	d041      	beq.n	8006940 <HAL_DMA_IRQHandler+0x1c58>
 80068bc:	687b      	ldr	r3, [r7, #4]
 80068be:	681b      	ldr	r3, [r3, #0]
 80068c0:	4619      	mov	r1, r3
 80068c2:	4b64      	ldr	r3, [pc, #400]	; (8006a54 <HAL_DMA_IRQHandler+0x1d6c>)
 80068c4:	4299      	cmp	r1, r3
 80068c6:	d038      	beq.n	800693a <HAL_DMA_IRQHandler+0x1c52>
 80068c8:	687b      	ldr	r3, [r7, #4]
 80068ca:	681b      	ldr	r3, [r3, #0]
 80068cc:	4619      	mov	r1, r3
 80068ce:	4b62      	ldr	r3, [pc, #392]	; (8006a58 <HAL_DMA_IRQHandler+0x1d70>)
 80068d0:	4299      	cmp	r1, r3
 80068d2:	d02f      	beq.n	8006934 <HAL_DMA_IRQHandler+0x1c4c>
 80068d4:	687b      	ldr	r3, [r7, #4]
 80068d6:	681b      	ldr	r3, [r3, #0]
 80068d8:	4619      	mov	r1, r3
 80068da:	4b60      	ldr	r3, [pc, #384]	; (8006a5c <HAL_DMA_IRQHandler+0x1d74>)
 80068dc:	4299      	cmp	r1, r3
 80068de:	d026      	beq.n	800692e <HAL_DMA_IRQHandler+0x1c46>
 80068e0:	687b      	ldr	r3, [r7, #4]
 80068e2:	681b      	ldr	r3, [r3, #0]
 80068e4:	4619      	mov	r1, r3
 80068e6:	4b5e      	ldr	r3, [pc, #376]	; (8006a60 <HAL_DMA_IRQHandler+0x1d78>)
 80068e8:	4299      	cmp	r1, r3
 80068ea:	d01d      	beq.n	8006928 <HAL_DMA_IRQHandler+0x1c40>
 80068ec:	687b      	ldr	r3, [r7, #4]
 80068ee:	681b      	ldr	r3, [r3, #0]
 80068f0:	4619      	mov	r1, r3
 80068f2:	4b5c      	ldr	r3, [pc, #368]	; (8006a64 <HAL_DMA_IRQHandler+0x1d7c>)
 80068f4:	4299      	cmp	r1, r3
 80068f6:	d014      	beq.n	8006922 <HAL_DMA_IRQHandler+0x1c3a>
 80068f8:	687b      	ldr	r3, [r7, #4]
 80068fa:	681b      	ldr	r3, [r3, #0]
 80068fc:	4619      	mov	r1, r3
 80068fe:	4b5a      	ldr	r3, [pc, #360]	; (8006a68 <HAL_DMA_IRQHandler+0x1d80>)
 8006900:	4299      	cmp	r1, r3
 8006902:	d00b      	beq.n	800691c <HAL_DMA_IRQHandler+0x1c34>
 8006904:	687b      	ldr	r3, [r7, #4]
 8006906:	681b      	ldr	r3, [r3, #0]
 8006908:	4619      	mov	r1, r3
 800690a:	4b58      	ldr	r3, [pc, #352]	; (8006a6c <HAL_DMA_IRQHandler+0x1d84>)
 800690c:	4299      	cmp	r1, r3
 800690e:	d102      	bne.n	8006916 <HAL_DMA_IRQHandler+0x1c2e>
 8006910:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006914:	e01e      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 8006916:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800691a:	e01b      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 800691c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006920:	e018      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 8006922:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006926:	e015      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 8006928:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800692c:	e012      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 800692e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006932:	e00f      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 8006934:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006938:	e00c      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 800693a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800693e:	e009      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 8006940:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006944:	e006      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 8006946:	2310      	movs	r3, #16
 8006948:	e004      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 800694a:	2310      	movs	r3, #16
 800694c:	e002      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 800694e:	2310      	movs	r3, #16
 8006950:	e000      	b.n	8006954 <HAL_DMA_IRQHandler+0x1c6c>
 8006952:	2310      	movs	r3, #16
 8006954:	4013      	ands	r3, r2
 8006956:	2b00      	cmp	r3, #0
 8006958:	bf14      	ite	ne
 800695a:	2301      	movne	r3, #1
 800695c:	2300      	moveq	r3, #0
 800695e:	b2db      	uxtb	r3, r3
 8006960:	e08d      	b.n	8006a7e <HAL_DMA_IRQHandler+0x1d96>
 8006962:	4b36      	ldr	r3, [pc, #216]	; (8006a3c <HAL_DMA_IRQHandler+0x1d54>)
 8006964:	681a      	ldr	r2, [r3, #0]
 8006966:	687b      	ldr	r3, [r7, #4]
 8006968:	681b      	ldr	r3, [r3, #0]
 800696a:	4619      	mov	r1, r3
 800696c:	4b34      	ldr	r3, [pc, #208]	; (8006a40 <HAL_DMA_IRQHandler+0x1d58>)
 800696e:	4299      	cmp	r1, r3
 8006970:	d07e      	beq.n	8006a70 <HAL_DMA_IRQHandler+0x1d88>
 8006972:	687b      	ldr	r3, [r7, #4]
 8006974:	681b      	ldr	r3, [r3, #0]
 8006976:	4619      	mov	r1, r3
 8006978:	4b32      	ldr	r3, [pc, #200]	; (8006a44 <HAL_DMA_IRQHandler+0x1d5c>)
 800697a:	4299      	cmp	r1, r3
 800697c:	d05a      	beq.n	8006a34 <HAL_DMA_IRQHandler+0x1d4c>
 800697e:	687b      	ldr	r3, [r7, #4]
 8006980:	681b      	ldr	r3, [r3, #0]
 8006982:	4619      	mov	r1, r3
 8006984:	4b30      	ldr	r3, [pc, #192]	; (8006a48 <HAL_DMA_IRQHandler+0x1d60>)
 8006986:	4299      	cmp	r1, r3
 8006988:	d052      	beq.n	8006a30 <HAL_DMA_IRQHandler+0x1d48>
 800698a:	687b      	ldr	r3, [r7, #4]
 800698c:	681b      	ldr	r3, [r3, #0]
 800698e:	4619      	mov	r1, r3
 8006990:	4b2e      	ldr	r3, [pc, #184]	; (8006a4c <HAL_DMA_IRQHandler+0x1d64>)
 8006992:	4299      	cmp	r1, r3
 8006994:	d04a      	beq.n	8006a2c <HAL_DMA_IRQHandler+0x1d44>
 8006996:	687b      	ldr	r3, [r7, #4]
 8006998:	681b      	ldr	r3, [r3, #0]
 800699a:	4619      	mov	r1, r3
 800699c:	4b2c      	ldr	r3, [pc, #176]	; (8006a50 <HAL_DMA_IRQHandler+0x1d68>)
 800699e:	4299      	cmp	r1, r3
 80069a0:	d041      	beq.n	8006a26 <HAL_DMA_IRQHandler+0x1d3e>
 80069a2:	687b      	ldr	r3, [r7, #4]
 80069a4:	681b      	ldr	r3, [r3, #0]
 80069a6:	4619      	mov	r1, r3
 80069a8:	4b2a      	ldr	r3, [pc, #168]	; (8006a54 <HAL_DMA_IRQHandler+0x1d6c>)
 80069aa:	4299      	cmp	r1, r3
 80069ac:	d038      	beq.n	8006a20 <HAL_DMA_IRQHandler+0x1d38>
 80069ae:	687b      	ldr	r3, [r7, #4]
 80069b0:	681b      	ldr	r3, [r3, #0]
 80069b2:	4619      	mov	r1, r3
 80069b4:	4b28      	ldr	r3, [pc, #160]	; (8006a58 <HAL_DMA_IRQHandler+0x1d70>)
 80069b6:	4299      	cmp	r1, r3
 80069b8:	d02f      	beq.n	8006a1a <HAL_DMA_IRQHandler+0x1d32>
 80069ba:	687b      	ldr	r3, [r7, #4]
 80069bc:	681b      	ldr	r3, [r3, #0]
 80069be:	4619      	mov	r1, r3
 80069c0:	4b26      	ldr	r3, [pc, #152]	; (8006a5c <HAL_DMA_IRQHandler+0x1d74>)
 80069c2:	4299      	cmp	r1, r3
 80069c4:	d026      	beq.n	8006a14 <HAL_DMA_IRQHandler+0x1d2c>
 80069c6:	687b      	ldr	r3, [r7, #4]
 80069c8:	681b      	ldr	r3, [r3, #0]
 80069ca:	4619      	mov	r1, r3
 80069cc:	4b24      	ldr	r3, [pc, #144]	; (8006a60 <HAL_DMA_IRQHandler+0x1d78>)
 80069ce:	4299      	cmp	r1, r3
 80069d0:	d01d      	beq.n	8006a0e <HAL_DMA_IRQHandler+0x1d26>
 80069d2:	687b      	ldr	r3, [r7, #4]
 80069d4:	681b      	ldr	r3, [r3, #0]
 80069d6:	4619      	mov	r1, r3
 80069d8:	4b22      	ldr	r3, [pc, #136]	; (8006a64 <HAL_DMA_IRQHandler+0x1d7c>)
 80069da:	4299      	cmp	r1, r3
 80069dc:	d014      	beq.n	8006a08 <HAL_DMA_IRQHandler+0x1d20>
 80069de:	687b      	ldr	r3, [r7, #4]
 80069e0:	681b      	ldr	r3, [r3, #0]
 80069e2:	4619      	mov	r1, r3
 80069e4:	4b20      	ldr	r3, [pc, #128]	; (8006a68 <HAL_DMA_IRQHandler+0x1d80>)
 80069e6:	4299      	cmp	r1, r3
 80069e8:	d00b      	beq.n	8006a02 <HAL_DMA_IRQHandler+0x1d1a>
 80069ea:	687b      	ldr	r3, [r7, #4]
 80069ec:	681b      	ldr	r3, [r3, #0]
 80069ee:	4619      	mov	r1, r3
 80069f0:	4b1e      	ldr	r3, [pc, #120]	; (8006a6c <HAL_DMA_IRQHandler+0x1d84>)
 80069f2:	4299      	cmp	r1, r3
 80069f4:	d102      	bne.n	80069fc <HAL_DMA_IRQHandler+0x1d14>
 80069f6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80069fa:	e03a      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 80069fc:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8006a00:	e037      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a02:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006a06:	e034      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a08:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006a0c:	e031      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a0e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006a12:	e02e      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a14:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006a18:	e02b      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a1a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006a1e:	e028      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a20:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006a24:	e025      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a26:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006a2a:	e022      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a2c:	2310      	movs	r3, #16
 8006a2e:	e020      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a30:	2310      	movs	r3, #16
 8006a32:	e01e      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a34:	2310      	movs	r3, #16
 8006a36:	e01c      	b.n	8006a72 <HAL_DMA_IRQHandler+0x1d8a>
 8006a38:	40026058 	.word	0x40026058
 8006a3c:	40026000 	.word	0x40026000
 8006a40:	40026010 	.word	0x40026010
 8006a44:	40026410 	.word	0x40026410
 8006a48:	40026070 	.word	0x40026070
 8006a4c:	40026470 	.word	0x40026470
 8006a50:	40026028 	.word	0x40026028
 8006a54:	40026428 	.word	0x40026428
 8006a58:	40026088 	.word	0x40026088
 8006a5c:	40026488 	.word	0x40026488
 8006a60:	40026040 	.word	0x40026040
 8006a64:	40026440 	.word	0x40026440
 8006a68:	400260a0 	.word	0x400260a0
 8006a6c:	400264a0 	.word	0x400264a0
 8006a70:	2310      	movs	r3, #16
 8006a72:	4013      	ands	r3, r2
 8006a74:	2b00      	cmp	r3, #0
 8006a76:	bf14      	ite	ne
 8006a78:	2301      	movne	r3, #1
 8006a7a:	2300      	moveq	r3, #0
 8006a7c:	b2db      	uxtb	r3, r3
 8006a7e:	2b00      	cmp	r3, #0
 8006a80:	f000 8433 	beq.w	80072ea <HAL_DMA_IRQHandler+0x2602>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8006a84:	687b      	ldr	r3, [r7, #4]
 8006a86:	681b      	ldr	r3, [r3, #0]
 8006a88:	681b      	ldr	r3, [r3, #0]
 8006a8a:	f003 0308 	and.w	r3, r3, #8
 8006a8e:	2b00      	cmp	r3, #0
 8006a90:	f000 842b 	beq.w	80072ea <HAL_DMA_IRQHandler+0x2602>
    { 
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 8006a94:	687b      	ldr	r3, [r7, #4]
 8006a96:	681b      	ldr	r3, [r3, #0]
 8006a98:	681b      	ldr	r3, [r3, #0]
 8006a9a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8006a9e:	2b00      	cmp	r3, #0
 8006aa0:	f000 8203 	beq.w	8006eaa <HAL_DMA_IRQHandler+0x21c2>
      {
        /* Clear the half transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8006aa4:	687b      	ldr	r3, [r7, #4]
 8006aa6:	681b      	ldr	r3, [r3, #0]
 8006aa8:	461a      	mov	r2, r3
 8006aaa:	4ba0      	ldr	r3, [pc, #640]	; (8006d2c <HAL_DMA_IRQHandler+0x2044>)
 8006aac:	429a      	cmp	r2, r3
 8006aae:	d96c      	bls.n	8006b8a <HAL_DMA_IRQHandler+0x1ea2>
 8006ab0:	4a9f      	ldr	r2, [pc, #636]	; (8006d30 <HAL_DMA_IRQHandler+0x2048>)
 8006ab2:	687b      	ldr	r3, [r7, #4]
 8006ab4:	681b      	ldr	r3, [r3, #0]
 8006ab6:	4619      	mov	r1, r3
 8006ab8:	4b9e      	ldr	r3, [pc, #632]	; (8006d34 <HAL_DMA_IRQHandler+0x204c>)
 8006aba:	4299      	cmp	r1, r3
 8006abc:	d062      	beq.n	8006b84 <HAL_DMA_IRQHandler+0x1e9c>
 8006abe:	687b      	ldr	r3, [r7, #4]
 8006ac0:	681b      	ldr	r3, [r3, #0]
 8006ac2:	4619      	mov	r1, r3
 8006ac4:	4b9c      	ldr	r3, [pc, #624]	; (8006d38 <HAL_DMA_IRQHandler+0x2050>)
 8006ac6:	4299      	cmp	r1, r3
 8006ac8:	d05a      	beq.n	8006b80 <HAL_DMA_IRQHandler+0x1e98>
 8006aca:	687b      	ldr	r3, [r7, #4]
 8006acc:	681b      	ldr	r3, [r3, #0]
 8006ace:	4619      	mov	r1, r3
 8006ad0:	4b9a      	ldr	r3, [pc, #616]	; (8006d3c <HAL_DMA_IRQHandler+0x2054>)
 8006ad2:	4299      	cmp	r1, r3
 8006ad4:	d052      	beq.n	8006b7c <HAL_DMA_IRQHandler+0x1e94>
 8006ad6:	687b      	ldr	r3, [r7, #4]
 8006ad8:	681b      	ldr	r3, [r3, #0]
 8006ada:	4619      	mov	r1, r3
 8006adc:	4b98      	ldr	r3, [pc, #608]	; (8006d40 <HAL_DMA_IRQHandler+0x2058>)
 8006ade:	4299      	cmp	r1, r3
 8006ae0:	d04a      	beq.n	8006b78 <HAL_DMA_IRQHandler+0x1e90>
 8006ae2:	687b      	ldr	r3, [r7, #4]
 8006ae4:	681b      	ldr	r3, [r3, #0]
 8006ae6:	4619      	mov	r1, r3
 8006ae8:	4b96      	ldr	r3, [pc, #600]	; (8006d44 <HAL_DMA_IRQHandler+0x205c>)
 8006aea:	4299      	cmp	r1, r3
 8006aec:	d041      	beq.n	8006b72 <HAL_DMA_IRQHandler+0x1e8a>
 8006aee:	687b      	ldr	r3, [r7, #4]
 8006af0:	681b      	ldr	r3, [r3, #0]
 8006af2:	4619      	mov	r1, r3
 8006af4:	4b94      	ldr	r3, [pc, #592]	; (8006d48 <HAL_DMA_IRQHandler+0x2060>)
 8006af6:	4299      	cmp	r1, r3
 8006af8:	d038      	beq.n	8006b6c <HAL_DMA_IRQHandler+0x1e84>
 8006afa:	687b      	ldr	r3, [r7, #4]
 8006afc:	681b      	ldr	r3, [r3, #0]
 8006afe:	4619      	mov	r1, r3
 8006b00:	4b92      	ldr	r3, [pc, #584]	; (8006d4c <HAL_DMA_IRQHandler+0x2064>)
 8006b02:	4299      	cmp	r1, r3
 8006b04:	d02f      	beq.n	8006b66 <HAL_DMA_IRQHandler+0x1e7e>
 8006b06:	687b      	ldr	r3, [r7, #4]
 8006b08:	681b      	ldr	r3, [r3, #0]
 8006b0a:	4619      	mov	r1, r3
 8006b0c:	4b90      	ldr	r3, [pc, #576]	; (8006d50 <HAL_DMA_IRQHandler+0x2068>)
 8006b0e:	4299      	cmp	r1, r3
 8006b10:	d026      	beq.n	8006b60 <HAL_DMA_IRQHandler+0x1e78>
 8006b12:	687b      	ldr	r3, [r7, #4]
 8006b14:	681b      	ldr	r3, [r3, #0]
 8006b16:	4619      	mov	r1, r3
 8006b18:	4b8e      	ldr	r3, [pc, #568]	; (8006d54 <HAL_DMA_IRQHandler+0x206c>)
 8006b1a:	4299      	cmp	r1, r3
 8006b1c:	d01d      	beq.n	8006b5a <HAL_DMA_IRQHandler+0x1e72>
 8006b1e:	687b      	ldr	r3, [r7, #4]
 8006b20:	681b      	ldr	r3, [r3, #0]
 8006b22:	4619      	mov	r1, r3
 8006b24:	4b8c      	ldr	r3, [pc, #560]	; (8006d58 <HAL_DMA_IRQHandler+0x2070>)
 8006b26:	4299      	cmp	r1, r3
 8006b28:	d014      	beq.n	8006b54 <HAL_DMA_IRQHandler+0x1e6c>
 8006b2a:	687b      	ldr	r3, [r7, #4]
 8006b2c:	681b      	ldr	r3, [r3, #0]
 8006b2e:	4619      	mov	r1, r3
 8006b30:	4b8a      	ldr	r3, [pc, #552]	; (8006d5c <HAL_DMA_IRQHandler+0x2074>)
 8006b32:	4299      	cmp	r1, r3
 8006b34:	d00b      	beq.n	8006b4e <HAL_DMA_IRQHandler+0x1e66>
 8006b36:	687b      	ldr	r3, [r7, #4]
 8006b38:	681b      	ldr	r3, [r3, #0]
 8006b3a:	4619      	mov	r1, r3
 8006b3c:	4b88      	ldr	r3, [pc, #544]	; (8006d60 <HAL_DMA_IRQHandler+0x2078>)
 8006b3e:	4299      	cmp	r1, r3
 8006b40:	d102      	bne.n	8006b48 <HAL_DMA_IRQHandler+0x1e60>
 8006b42:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006b46:	e01e      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b48:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8006b4c:	e01b      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b4e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006b52:	e018      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b54:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006b58:	e015      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b5a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006b5e:	e012      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b60:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006b64:	e00f      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b66:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006b6a:	e00c      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b6c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006b70:	e009      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b72:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006b76:	e006      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b78:	2310      	movs	r3, #16
 8006b7a:	e004      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b7c:	2310      	movs	r3, #16
 8006b7e:	e002      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b80:	2310      	movs	r3, #16
 8006b82:	e000      	b.n	8006b86 <HAL_DMA_IRQHandler+0x1e9e>
 8006b84:	2310      	movs	r3, #16
 8006b86:	60d3      	str	r3, [r2, #12]
 8006b88:	e176      	b.n	8006e78 <HAL_DMA_IRQHandler+0x2190>
 8006b8a:	687b      	ldr	r3, [r7, #4]
 8006b8c:	681b      	ldr	r3, [r3, #0]
 8006b8e:	461a      	mov	r2, r3
 8006b90:	4b74      	ldr	r3, [pc, #464]	; (8006d64 <HAL_DMA_IRQHandler+0x207c>)
 8006b92:	429a      	cmp	r2, r3
 8006b94:	d96c      	bls.n	8006c70 <HAL_DMA_IRQHandler+0x1f88>
 8006b96:	4a66      	ldr	r2, [pc, #408]	; (8006d30 <HAL_DMA_IRQHandler+0x2048>)
 8006b98:	687b      	ldr	r3, [r7, #4]
 8006b9a:	681b      	ldr	r3, [r3, #0]
 8006b9c:	4619      	mov	r1, r3
 8006b9e:	4b65      	ldr	r3, [pc, #404]	; (8006d34 <HAL_DMA_IRQHandler+0x204c>)
 8006ba0:	4299      	cmp	r1, r3
 8006ba2:	d062      	beq.n	8006c6a <HAL_DMA_IRQHandler+0x1f82>
 8006ba4:	687b      	ldr	r3, [r7, #4]
 8006ba6:	681b      	ldr	r3, [r3, #0]
 8006ba8:	4619      	mov	r1, r3
 8006baa:	4b63      	ldr	r3, [pc, #396]	; (8006d38 <HAL_DMA_IRQHandler+0x2050>)
 8006bac:	4299      	cmp	r1, r3
 8006bae:	d05a      	beq.n	8006c66 <HAL_DMA_IRQHandler+0x1f7e>
 8006bb0:	687b      	ldr	r3, [r7, #4]
 8006bb2:	681b      	ldr	r3, [r3, #0]
 8006bb4:	4619      	mov	r1, r3
 8006bb6:	4b61      	ldr	r3, [pc, #388]	; (8006d3c <HAL_DMA_IRQHandler+0x2054>)
 8006bb8:	4299      	cmp	r1, r3
 8006bba:	d052      	beq.n	8006c62 <HAL_DMA_IRQHandler+0x1f7a>
 8006bbc:	687b      	ldr	r3, [r7, #4]
 8006bbe:	681b      	ldr	r3, [r3, #0]
 8006bc0:	4619      	mov	r1, r3
 8006bc2:	4b5f      	ldr	r3, [pc, #380]	; (8006d40 <HAL_DMA_IRQHandler+0x2058>)
 8006bc4:	4299      	cmp	r1, r3
 8006bc6:	d04a      	beq.n	8006c5e <HAL_DMA_IRQHandler+0x1f76>
 8006bc8:	687b      	ldr	r3, [r7, #4]
 8006bca:	681b      	ldr	r3, [r3, #0]
 8006bcc:	4619      	mov	r1, r3
 8006bce:	4b5d      	ldr	r3, [pc, #372]	; (8006d44 <HAL_DMA_IRQHandler+0x205c>)
 8006bd0:	4299      	cmp	r1, r3
 8006bd2:	d041      	beq.n	8006c58 <HAL_DMA_IRQHandler+0x1f70>
 8006bd4:	687b      	ldr	r3, [r7, #4]
 8006bd6:	681b      	ldr	r3, [r3, #0]
 8006bd8:	4619      	mov	r1, r3
 8006bda:	4b5b      	ldr	r3, [pc, #364]	; (8006d48 <HAL_DMA_IRQHandler+0x2060>)
 8006bdc:	4299      	cmp	r1, r3
 8006bde:	d038      	beq.n	8006c52 <HAL_DMA_IRQHandler+0x1f6a>
 8006be0:	687b      	ldr	r3, [r7, #4]
 8006be2:	681b      	ldr	r3, [r3, #0]
 8006be4:	4619      	mov	r1, r3
 8006be6:	4b59      	ldr	r3, [pc, #356]	; (8006d4c <HAL_DMA_IRQHandler+0x2064>)
 8006be8:	4299      	cmp	r1, r3
 8006bea:	d02f      	beq.n	8006c4c <HAL_DMA_IRQHandler+0x1f64>
 8006bec:	687b      	ldr	r3, [r7, #4]
 8006bee:	681b      	ldr	r3, [r3, #0]
 8006bf0:	4619      	mov	r1, r3
 8006bf2:	4b57      	ldr	r3, [pc, #348]	; (8006d50 <HAL_DMA_IRQHandler+0x2068>)
 8006bf4:	4299      	cmp	r1, r3
 8006bf6:	d026      	beq.n	8006c46 <HAL_DMA_IRQHandler+0x1f5e>
 8006bf8:	687b      	ldr	r3, [r7, #4]
 8006bfa:	681b      	ldr	r3, [r3, #0]
 8006bfc:	4619      	mov	r1, r3
 8006bfe:	4b55      	ldr	r3, [pc, #340]	; (8006d54 <HAL_DMA_IRQHandler+0x206c>)
 8006c00:	4299      	cmp	r1, r3
 8006c02:	d01d      	beq.n	8006c40 <HAL_DMA_IRQHandler+0x1f58>
 8006c04:	687b      	ldr	r3, [r7, #4]
 8006c06:	681b      	ldr	r3, [r3, #0]
 8006c08:	4619      	mov	r1, r3
 8006c0a:	4b53      	ldr	r3, [pc, #332]	; (8006d58 <HAL_DMA_IRQHandler+0x2070>)
 8006c0c:	4299      	cmp	r1, r3
 8006c0e:	d014      	beq.n	8006c3a <HAL_DMA_IRQHandler+0x1f52>
 8006c10:	687b      	ldr	r3, [r7, #4]
 8006c12:	681b      	ldr	r3, [r3, #0]
 8006c14:	4619      	mov	r1, r3
 8006c16:	4b51      	ldr	r3, [pc, #324]	; (8006d5c <HAL_DMA_IRQHandler+0x2074>)
 8006c18:	4299      	cmp	r1, r3
 8006c1a:	d00b      	beq.n	8006c34 <HAL_DMA_IRQHandler+0x1f4c>
 8006c1c:	687b      	ldr	r3, [r7, #4]
 8006c1e:	681b      	ldr	r3, [r3, #0]
 8006c20:	4619      	mov	r1, r3
 8006c22:	4b4f      	ldr	r3, [pc, #316]	; (8006d60 <HAL_DMA_IRQHandler+0x2078>)
 8006c24:	4299      	cmp	r1, r3
 8006c26:	d102      	bne.n	8006c2e <HAL_DMA_IRQHandler+0x1f46>
 8006c28:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006c2c:	e01e      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c2e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8006c32:	e01b      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c34:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006c38:	e018      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c3a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006c3e:	e015      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c40:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006c44:	e012      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c46:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006c4a:	e00f      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c4c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006c50:	e00c      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c52:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006c56:	e009      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c58:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006c5c:	e006      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c5e:	2310      	movs	r3, #16
 8006c60:	e004      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c62:	2310      	movs	r3, #16
 8006c64:	e002      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c66:	2310      	movs	r3, #16
 8006c68:	e000      	b.n	8006c6c <HAL_DMA_IRQHandler+0x1f84>
 8006c6a:	2310      	movs	r3, #16
 8006c6c:	6093      	str	r3, [r2, #8]
 8006c6e:	e103      	b.n	8006e78 <HAL_DMA_IRQHandler+0x2190>
 8006c70:	687b      	ldr	r3, [r7, #4]
 8006c72:	681b      	ldr	r3, [r3, #0]
 8006c74:	461a      	mov	r2, r3
 8006c76:	4b3c      	ldr	r3, [pc, #240]	; (8006d68 <HAL_DMA_IRQHandler+0x2080>)
 8006c78:	429a      	cmp	r2, r3
 8006c7a:	f240 8091 	bls.w	8006da0 <HAL_DMA_IRQHandler+0x20b8>
 8006c7e:	4a3b      	ldr	r2, [pc, #236]	; (8006d6c <HAL_DMA_IRQHandler+0x2084>)
 8006c80:	687b      	ldr	r3, [r7, #4]
 8006c82:	681b      	ldr	r3, [r3, #0]
 8006c84:	4619      	mov	r1, r3
 8006c86:	4b2b      	ldr	r3, [pc, #172]	; (8006d34 <HAL_DMA_IRQHandler+0x204c>)
 8006c88:	4299      	cmp	r1, r3
 8006c8a:	f000 8086 	beq.w	8006d9a <HAL_DMA_IRQHandler+0x20b2>
 8006c8e:	687b      	ldr	r3, [r7, #4]
 8006c90:	681b      	ldr	r3, [r3, #0]
 8006c92:	4619      	mov	r1, r3
 8006c94:	4b28      	ldr	r3, [pc, #160]	; (8006d38 <HAL_DMA_IRQHandler+0x2050>)
 8006c96:	4299      	cmp	r1, r3
 8006c98:	d07d      	beq.n	8006d96 <HAL_DMA_IRQHandler+0x20ae>
 8006c9a:	687b      	ldr	r3, [r7, #4]
 8006c9c:	681b      	ldr	r3, [r3, #0]
 8006c9e:	4619      	mov	r1, r3
 8006ca0:	4b26      	ldr	r3, [pc, #152]	; (8006d3c <HAL_DMA_IRQHandler+0x2054>)
 8006ca2:	4299      	cmp	r1, r3
 8006ca4:	d075      	beq.n	8006d92 <HAL_DMA_IRQHandler+0x20aa>
 8006ca6:	687b      	ldr	r3, [r7, #4]
 8006ca8:	681b      	ldr	r3, [r3, #0]
 8006caa:	4619      	mov	r1, r3
 8006cac:	4b24      	ldr	r3, [pc, #144]	; (8006d40 <HAL_DMA_IRQHandler+0x2058>)
 8006cae:	4299      	cmp	r1, r3
 8006cb0:	d06d      	beq.n	8006d8e <HAL_DMA_IRQHandler+0x20a6>
 8006cb2:	687b      	ldr	r3, [r7, #4]
 8006cb4:	681b      	ldr	r3, [r3, #0]
 8006cb6:	4619      	mov	r1, r3
 8006cb8:	4b22      	ldr	r3, [pc, #136]	; (8006d44 <HAL_DMA_IRQHandler+0x205c>)
 8006cba:	4299      	cmp	r1, r3
 8006cbc:	d064      	beq.n	8006d88 <HAL_DMA_IRQHandler+0x20a0>
 8006cbe:	687b      	ldr	r3, [r7, #4]
 8006cc0:	681b      	ldr	r3, [r3, #0]
 8006cc2:	4619      	mov	r1, r3
 8006cc4:	4b20      	ldr	r3, [pc, #128]	; (8006d48 <HAL_DMA_IRQHandler+0x2060>)
 8006cc6:	4299      	cmp	r1, r3
 8006cc8:	d05b      	beq.n	8006d82 <HAL_DMA_IRQHandler+0x209a>
 8006cca:	687b      	ldr	r3, [r7, #4]
 8006ccc:	681b      	ldr	r3, [r3, #0]
 8006cce:	4619      	mov	r1, r3
 8006cd0:	4b1e      	ldr	r3, [pc, #120]	; (8006d4c <HAL_DMA_IRQHandler+0x2064>)
 8006cd2:	4299      	cmp	r1, r3
 8006cd4:	d052      	beq.n	8006d7c <HAL_DMA_IRQHandler+0x2094>
 8006cd6:	687b      	ldr	r3, [r7, #4]
 8006cd8:	681b      	ldr	r3, [r3, #0]
 8006cda:	4619      	mov	r1, r3
 8006cdc:	4b1c      	ldr	r3, [pc, #112]	; (8006d50 <HAL_DMA_IRQHandler+0x2068>)
 8006cde:	4299      	cmp	r1, r3
 8006ce0:	d049      	beq.n	8006d76 <HAL_DMA_IRQHandler+0x208e>
 8006ce2:	687b      	ldr	r3, [r7, #4]
 8006ce4:	681b      	ldr	r3, [r3, #0]
 8006ce6:	4619      	mov	r1, r3
 8006ce8:	4b1a      	ldr	r3, [pc, #104]	; (8006d54 <HAL_DMA_IRQHandler+0x206c>)
 8006cea:	4299      	cmp	r1, r3
 8006cec:	d040      	beq.n	8006d70 <HAL_DMA_IRQHandler+0x2088>
 8006cee:	687b      	ldr	r3, [r7, #4]
 8006cf0:	681b      	ldr	r3, [r3, #0]
 8006cf2:	4619      	mov	r1, r3
 8006cf4:	4b18      	ldr	r3, [pc, #96]	; (8006d58 <HAL_DMA_IRQHandler+0x2070>)
 8006cf6:	4299      	cmp	r1, r3
 8006cf8:	d014      	beq.n	8006d24 <HAL_DMA_IRQHandler+0x203c>
 8006cfa:	687b      	ldr	r3, [r7, #4]
 8006cfc:	681b      	ldr	r3, [r3, #0]
 8006cfe:	4619      	mov	r1, r3
 8006d00:	4b16      	ldr	r3, [pc, #88]	; (8006d5c <HAL_DMA_IRQHandler+0x2074>)
 8006d02:	4299      	cmp	r1, r3
 8006d04:	d00b      	beq.n	8006d1e <HAL_DMA_IRQHandler+0x2036>
 8006d06:	687b      	ldr	r3, [r7, #4]
 8006d08:	681b      	ldr	r3, [r3, #0]
 8006d0a:	4619      	mov	r1, r3
 8006d0c:	4b14      	ldr	r3, [pc, #80]	; (8006d60 <HAL_DMA_IRQHandler+0x2078>)
 8006d0e:	4299      	cmp	r1, r3
 8006d10:	d102      	bne.n	8006d18 <HAL_DMA_IRQHandler+0x2030>
 8006d12:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006d16:	e041      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d18:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8006d1c:	e03e      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d1e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006d22:	e03b      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d24:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006d28:	e038      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d2a:	bf00      	nop
 8006d2c:	40026458 	.word	0x40026458
 8006d30:	40026400 	.word	0x40026400
 8006d34:	40026010 	.word	0x40026010
 8006d38:	40026410 	.word	0x40026410
 8006d3c:	40026070 	.word	0x40026070
 8006d40:	40026470 	.word	0x40026470
 8006d44:	40026028 	.word	0x40026028
 8006d48:	40026428 	.word	0x40026428
 8006d4c:	40026088 	.word	0x40026088
 8006d50:	40026488 	.word	0x40026488
 8006d54:	40026040 	.word	0x40026040
 8006d58:	40026440 	.word	0x40026440
 8006d5c:	400260a0 	.word	0x400260a0
 8006d60:	400264a0 	.word	0x400264a0
 8006d64:	400260b8 	.word	0x400260b8
 8006d68:	40026058 	.word	0x40026058
 8006d6c:	40026000 	.word	0x40026000
 8006d70:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006d74:	e012      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d76:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006d7a:	e00f      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d7c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006d80:	e00c      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d82:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006d86:	e009      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d88:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006d8c:	e006      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d8e:	2310      	movs	r3, #16
 8006d90:	e004      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d92:	2310      	movs	r3, #16
 8006d94:	e002      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d96:	2310      	movs	r3, #16
 8006d98:	e000      	b.n	8006d9c <HAL_DMA_IRQHandler+0x20b4>
 8006d9a:	2310      	movs	r3, #16
 8006d9c:	60d3      	str	r3, [r2, #12]
 8006d9e:	e06b      	b.n	8006e78 <HAL_DMA_IRQHandler+0x2190>
 8006da0:	4a83      	ldr	r2, [pc, #524]	; (8006fb0 <HAL_DMA_IRQHandler+0x22c8>)
 8006da2:	687b      	ldr	r3, [r7, #4]
 8006da4:	681b      	ldr	r3, [r3, #0]
 8006da6:	4619      	mov	r1, r3
 8006da8:	4b82      	ldr	r3, [pc, #520]	; (8006fb4 <HAL_DMA_IRQHandler+0x22cc>)
 8006daa:	4299      	cmp	r1, r3
 8006dac:	d062      	beq.n	8006e74 <HAL_DMA_IRQHandler+0x218c>
 8006dae:	687b      	ldr	r3, [r7, #4]
 8006db0:	681b      	ldr	r3, [r3, #0]
 8006db2:	4619      	mov	r1, r3
 8006db4:	4b80      	ldr	r3, [pc, #512]	; (8006fb8 <HAL_DMA_IRQHandler+0x22d0>)
 8006db6:	4299      	cmp	r1, r3
 8006db8:	d05a      	beq.n	8006e70 <HAL_DMA_IRQHandler+0x2188>
 8006dba:	687b      	ldr	r3, [r7, #4]
 8006dbc:	681b      	ldr	r3, [r3, #0]
 8006dbe:	4619      	mov	r1, r3
 8006dc0:	4b7e      	ldr	r3, [pc, #504]	; (8006fbc <HAL_DMA_IRQHandler+0x22d4>)
 8006dc2:	4299      	cmp	r1, r3
 8006dc4:	d052      	beq.n	8006e6c <HAL_DMA_IRQHandler+0x2184>
 8006dc6:	687b      	ldr	r3, [r7, #4]
 8006dc8:	681b      	ldr	r3, [r3, #0]
 8006dca:	4619      	mov	r1, r3
 8006dcc:	4b7c      	ldr	r3, [pc, #496]	; (8006fc0 <HAL_DMA_IRQHandler+0x22d8>)
 8006dce:	4299      	cmp	r1, r3
 8006dd0:	d04a      	beq.n	8006e68 <HAL_DMA_IRQHandler+0x2180>
 8006dd2:	687b      	ldr	r3, [r7, #4]
 8006dd4:	681b      	ldr	r3, [r3, #0]
 8006dd6:	4619      	mov	r1, r3
 8006dd8:	4b7a      	ldr	r3, [pc, #488]	; (8006fc4 <HAL_DMA_IRQHandler+0x22dc>)
 8006dda:	4299      	cmp	r1, r3
 8006ddc:	d041      	beq.n	8006e62 <HAL_DMA_IRQHandler+0x217a>
 8006dde:	687b      	ldr	r3, [r7, #4]
 8006de0:	681b      	ldr	r3, [r3, #0]
 8006de2:	4619      	mov	r1, r3
 8006de4:	4b78      	ldr	r3, [pc, #480]	; (8006fc8 <HAL_DMA_IRQHandler+0x22e0>)
 8006de6:	4299      	cmp	r1, r3
 8006de8:	d038      	beq.n	8006e5c <HAL_DMA_IRQHandler+0x2174>
 8006dea:	687b      	ldr	r3, [r7, #4]
 8006dec:	681b      	ldr	r3, [r3, #0]
 8006dee:	4619      	mov	r1, r3
 8006df0:	4b76      	ldr	r3, [pc, #472]	; (8006fcc <HAL_DMA_IRQHandler+0x22e4>)
 8006df2:	4299      	cmp	r1, r3
 8006df4:	d02f      	beq.n	8006e56 <HAL_DMA_IRQHandler+0x216e>
 8006df6:	687b      	ldr	r3, [r7, #4]
 8006df8:	681b      	ldr	r3, [r3, #0]
 8006dfa:	4619      	mov	r1, r3
 8006dfc:	4b74      	ldr	r3, [pc, #464]	; (8006fd0 <HAL_DMA_IRQHandler+0x22e8>)
 8006dfe:	4299      	cmp	r1, r3
 8006e00:	d026      	beq.n	8006e50 <HAL_DMA_IRQHandler+0x2168>
 8006e02:	687b      	ldr	r3, [r7, #4]
 8006e04:	681b      	ldr	r3, [r3, #0]
 8006e06:	4619      	mov	r1, r3
 8006e08:	4b72      	ldr	r3, [pc, #456]	; (8006fd4 <HAL_DMA_IRQHandler+0x22ec>)
 8006e0a:	4299      	cmp	r1, r3
 8006e0c:	d01d      	beq.n	8006e4a <HAL_DMA_IRQHandler+0x2162>
 8006e0e:	687b      	ldr	r3, [r7, #4]
 8006e10:	681b      	ldr	r3, [r3, #0]
 8006e12:	4619      	mov	r1, r3
 8006e14:	4b70      	ldr	r3, [pc, #448]	; (8006fd8 <HAL_DMA_IRQHandler+0x22f0>)
 8006e16:	4299      	cmp	r1, r3
 8006e18:	d014      	beq.n	8006e44 <HAL_DMA_IRQHandler+0x215c>
 8006e1a:	687b      	ldr	r3, [r7, #4]
 8006e1c:	681b      	ldr	r3, [r3, #0]
 8006e1e:	4619      	mov	r1, r3
 8006e20:	4b6e      	ldr	r3, [pc, #440]	; (8006fdc <HAL_DMA_IRQHandler+0x22f4>)
 8006e22:	4299      	cmp	r1, r3
 8006e24:	d00b      	beq.n	8006e3e <HAL_DMA_IRQHandler+0x2156>
 8006e26:	687b      	ldr	r3, [r7, #4]
 8006e28:	681b      	ldr	r3, [r3, #0]
 8006e2a:	4619      	mov	r1, r3
 8006e2c:	4b6c      	ldr	r3, [pc, #432]	; (8006fe0 <HAL_DMA_IRQHandler+0x22f8>)
 8006e2e:	4299      	cmp	r1, r3
 8006e30:	d102      	bne.n	8006e38 <HAL_DMA_IRQHandler+0x2150>
 8006e32:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006e36:	e01e      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e38:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8006e3c:	e01b      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e3e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006e42:	e018      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e44:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006e48:	e015      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e4a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006e4e:	e012      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e50:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006e54:	e00f      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e56:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006e5a:	e00c      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e5c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006e60:	e009      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e62:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006e66:	e006      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e68:	2310      	movs	r3, #16
 8006e6a:	e004      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e6c:	2310      	movs	r3, #16
 8006e6e:	e002      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e70:	2310      	movs	r3, #16
 8006e72:	e000      	b.n	8006e76 <HAL_DMA_IRQHandler+0x218e>
 8006e74:	2310      	movs	r3, #16
 8006e76:	6093      	str	r3, [r2, #8]

        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8006e78:	687b      	ldr	r3, [r7, #4]
 8006e7a:	681b      	ldr	r3, [r3, #0]
 8006e7c:	681b      	ldr	r3, [r3, #0]
 8006e7e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8006e82:	2b00      	cmp	r3, #0
 8006e84:	d104      	bne.n	8006e90 <HAL_DMA_IRQHandler+0x21a8>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 8006e86:	687b      	ldr	r3, [r7, #4]
 8006e88:	2231      	movs	r2, #49	; 0x31
 8006e8a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8006e8e:	e224      	b.n	80072da <HAL_DMA_IRQHandler+0x25f2>
        }
        /* Current memory buffer used is Memory 1 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8006e90:	687b      	ldr	r3, [r7, #4]
 8006e92:	681b      	ldr	r3, [r3, #0]
 8006e94:	681b      	ldr	r3, [r3, #0]
 8006e96:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8006e9a:	2b00      	cmp	r3, #0
 8006e9c:	f000 821d 	beq.w	80072da <HAL_DMA_IRQHandler+0x25f2>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
 8006ea0:	687b      	ldr	r3, [r7, #4]
 8006ea2:	2241      	movs	r2, #65	; 0x41
 8006ea4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8006ea8:	e217      	b.n	80072da <HAL_DMA_IRQHandler+0x25f2>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8006eaa:	687b      	ldr	r3, [r7, #4]
 8006eac:	681b      	ldr	r3, [r3, #0]
 8006eae:	681b      	ldr	r3, [r3, #0]
 8006eb0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006eb4:	2b00      	cmp	r3, #0
 8006eb6:	d107      	bne.n	8006ec8 <HAL_DMA_IRQHandler+0x21e0>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8006eb8:	687b      	ldr	r3, [r7, #4]
 8006eba:	681b      	ldr	r3, [r3, #0]
 8006ebc:	687a      	ldr	r2, [r7, #4]
 8006ebe:	6812      	ldr	r2, [r2, #0]
 8006ec0:	6812      	ldr	r2, [r2, #0]
 8006ec2:	f022 0208 	bic.w	r2, r2, #8
 8006ec6:	601a      	str	r2, [r3, #0]
        }
        /* Clear the half transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8006ec8:	687b      	ldr	r3, [r7, #4]
 8006eca:	681b      	ldr	r3, [r3, #0]
 8006ecc:	461a      	mov	r2, r3
 8006ece:	4b45      	ldr	r3, [pc, #276]	; (8006fe4 <HAL_DMA_IRQHandler+0x22fc>)
 8006ed0:	429a      	cmp	r2, r3
 8006ed2:	f240 808b 	bls.w	8006fec <HAL_DMA_IRQHandler+0x2304>
 8006ed6:	4a44      	ldr	r2, [pc, #272]	; (8006fe8 <HAL_DMA_IRQHandler+0x2300>)
 8006ed8:	687b      	ldr	r3, [r7, #4]
 8006eda:	681b      	ldr	r3, [r3, #0]
 8006edc:	4619      	mov	r1, r3
 8006ede:	4b35      	ldr	r3, [pc, #212]	; (8006fb4 <HAL_DMA_IRQHandler+0x22cc>)
 8006ee0:	4299      	cmp	r1, r3
 8006ee2:	d062      	beq.n	8006faa <HAL_DMA_IRQHandler+0x22c2>
 8006ee4:	687b      	ldr	r3, [r7, #4]
 8006ee6:	681b      	ldr	r3, [r3, #0]
 8006ee8:	4619      	mov	r1, r3
 8006eea:	4b33      	ldr	r3, [pc, #204]	; (8006fb8 <HAL_DMA_IRQHandler+0x22d0>)
 8006eec:	4299      	cmp	r1, r3
 8006eee:	d05a      	beq.n	8006fa6 <HAL_DMA_IRQHandler+0x22be>
 8006ef0:	687b      	ldr	r3, [r7, #4]
 8006ef2:	681b      	ldr	r3, [r3, #0]
 8006ef4:	4619      	mov	r1, r3
 8006ef6:	4b31      	ldr	r3, [pc, #196]	; (8006fbc <HAL_DMA_IRQHandler+0x22d4>)
 8006ef8:	4299      	cmp	r1, r3
 8006efa:	d052      	beq.n	8006fa2 <HAL_DMA_IRQHandler+0x22ba>
 8006efc:	687b      	ldr	r3, [r7, #4]
 8006efe:	681b      	ldr	r3, [r3, #0]
 8006f00:	4619      	mov	r1, r3
 8006f02:	4b2f      	ldr	r3, [pc, #188]	; (8006fc0 <HAL_DMA_IRQHandler+0x22d8>)
 8006f04:	4299      	cmp	r1, r3
 8006f06:	d04a      	beq.n	8006f9e <HAL_DMA_IRQHandler+0x22b6>
 8006f08:	687b      	ldr	r3, [r7, #4]
 8006f0a:	681b      	ldr	r3, [r3, #0]
 8006f0c:	4619      	mov	r1, r3
 8006f0e:	4b2d      	ldr	r3, [pc, #180]	; (8006fc4 <HAL_DMA_IRQHandler+0x22dc>)
 8006f10:	4299      	cmp	r1, r3
 8006f12:	d041      	beq.n	8006f98 <HAL_DMA_IRQHandler+0x22b0>
 8006f14:	687b      	ldr	r3, [r7, #4]
 8006f16:	681b      	ldr	r3, [r3, #0]
 8006f18:	4619      	mov	r1, r3
 8006f1a:	4b2b      	ldr	r3, [pc, #172]	; (8006fc8 <HAL_DMA_IRQHandler+0x22e0>)
 8006f1c:	4299      	cmp	r1, r3
 8006f1e:	d038      	beq.n	8006f92 <HAL_DMA_IRQHandler+0x22aa>
 8006f20:	687b      	ldr	r3, [r7, #4]
 8006f22:	681b      	ldr	r3, [r3, #0]
 8006f24:	4619      	mov	r1, r3
 8006f26:	4b29      	ldr	r3, [pc, #164]	; (8006fcc <HAL_DMA_IRQHandler+0x22e4>)
 8006f28:	4299      	cmp	r1, r3
 8006f2a:	d02f      	beq.n	8006f8c <HAL_DMA_IRQHandler+0x22a4>
 8006f2c:	687b      	ldr	r3, [r7, #4]
 8006f2e:	681b      	ldr	r3, [r3, #0]
 8006f30:	4619      	mov	r1, r3
 8006f32:	4b27      	ldr	r3, [pc, #156]	; (8006fd0 <HAL_DMA_IRQHandler+0x22e8>)
 8006f34:	4299      	cmp	r1, r3
 8006f36:	d026      	beq.n	8006f86 <HAL_DMA_IRQHandler+0x229e>
 8006f38:	687b      	ldr	r3, [r7, #4]
 8006f3a:	681b      	ldr	r3, [r3, #0]
 8006f3c:	4619      	mov	r1, r3
 8006f3e:	4b25      	ldr	r3, [pc, #148]	; (8006fd4 <HAL_DMA_IRQHandler+0x22ec>)
 8006f40:	4299      	cmp	r1, r3
 8006f42:	d01d      	beq.n	8006f80 <HAL_DMA_IRQHandler+0x2298>
 8006f44:	687b      	ldr	r3, [r7, #4]
 8006f46:	681b      	ldr	r3, [r3, #0]
 8006f48:	4619      	mov	r1, r3
 8006f4a:	4b23      	ldr	r3, [pc, #140]	; (8006fd8 <HAL_DMA_IRQHandler+0x22f0>)
 8006f4c:	4299      	cmp	r1, r3
 8006f4e:	d014      	beq.n	8006f7a <HAL_DMA_IRQHandler+0x2292>
 8006f50:	687b      	ldr	r3, [r7, #4]
 8006f52:	681b      	ldr	r3, [r3, #0]
 8006f54:	4619      	mov	r1, r3
 8006f56:	4b21      	ldr	r3, [pc, #132]	; (8006fdc <HAL_DMA_IRQHandler+0x22f4>)
 8006f58:	4299      	cmp	r1, r3
 8006f5a:	d00b      	beq.n	8006f74 <HAL_DMA_IRQHandler+0x228c>
 8006f5c:	687b      	ldr	r3, [r7, #4]
 8006f5e:	681b      	ldr	r3, [r3, #0]
 8006f60:	4619      	mov	r1, r3
 8006f62:	4b1f      	ldr	r3, [pc, #124]	; (8006fe0 <HAL_DMA_IRQHandler+0x22f8>)
 8006f64:	4299      	cmp	r1, r3
 8006f66:	d102      	bne.n	8006f6e <HAL_DMA_IRQHandler+0x2286>
 8006f68:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006f6c:	e01e      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f6e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8006f72:	e01b      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f74:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006f78:	e018      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f7a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006f7e:	e015      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f80:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006f84:	e012      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f86:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006f8a:	e00f      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f8c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006f90:	e00c      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f92:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006f96:	e009      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f98:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006f9c:	e006      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006f9e:	2310      	movs	r3, #16
 8006fa0:	e004      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006fa2:	2310      	movs	r3, #16
 8006fa4:	e002      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006fa6:	2310      	movs	r3, #16
 8006fa8:	e000      	b.n	8006fac <HAL_DMA_IRQHandler+0x22c4>
 8006faa:	2310      	movs	r3, #16
 8006fac:	60d3      	str	r3, [r2, #12]
 8006fae:	e190      	b.n	80072d2 <HAL_DMA_IRQHandler+0x25ea>
 8006fb0:	40026000 	.word	0x40026000
 8006fb4:	40026010 	.word	0x40026010
 8006fb8:	40026410 	.word	0x40026410
 8006fbc:	40026070 	.word	0x40026070
 8006fc0:	40026470 	.word	0x40026470
 8006fc4:	40026028 	.word	0x40026028
 8006fc8:	40026428 	.word	0x40026428
 8006fcc:	40026088 	.word	0x40026088
 8006fd0:	40026488 	.word	0x40026488
 8006fd4:	40026040 	.word	0x40026040
 8006fd8:	40026440 	.word	0x40026440
 8006fdc:	400260a0 	.word	0x400260a0
 8006fe0:	400264a0 	.word	0x400264a0
 8006fe4:	40026458 	.word	0x40026458
 8006fe8:	40026400 	.word	0x40026400
 8006fec:	687b      	ldr	r3, [r7, #4]
 8006fee:	681b      	ldr	r3, [r3, #0]
 8006ff0:	461a      	mov	r2, r3
 8006ff2:	4b9f      	ldr	r3, [pc, #636]	; (8007270 <HAL_DMA_IRQHandler+0x2588>)
 8006ff4:	429a      	cmp	r2, r3
 8006ff6:	d96c      	bls.n	80070d2 <HAL_DMA_IRQHandler+0x23ea>
 8006ff8:	4a9e      	ldr	r2, [pc, #632]	; (8007274 <HAL_DMA_IRQHandler+0x258c>)
 8006ffa:	687b      	ldr	r3, [r7, #4]
 8006ffc:	681b      	ldr	r3, [r3, #0]
 8006ffe:	4619      	mov	r1, r3
 8007000:	4b9d      	ldr	r3, [pc, #628]	; (8007278 <HAL_DMA_IRQHandler+0x2590>)
 8007002:	4299      	cmp	r1, r3
 8007004:	d062      	beq.n	80070cc <HAL_DMA_IRQHandler+0x23e4>
 8007006:	687b      	ldr	r3, [r7, #4]
 8007008:	681b      	ldr	r3, [r3, #0]
 800700a:	4619      	mov	r1, r3
 800700c:	4b9b      	ldr	r3, [pc, #620]	; (800727c <HAL_DMA_IRQHandler+0x2594>)
 800700e:	4299      	cmp	r1, r3
 8007010:	d05a      	beq.n	80070c8 <HAL_DMA_IRQHandler+0x23e0>
 8007012:	687b      	ldr	r3, [r7, #4]
 8007014:	681b      	ldr	r3, [r3, #0]
 8007016:	4619      	mov	r1, r3
 8007018:	4b99      	ldr	r3, [pc, #612]	; (8007280 <HAL_DMA_IRQHandler+0x2598>)
 800701a:	4299      	cmp	r1, r3
 800701c:	d052      	beq.n	80070c4 <HAL_DMA_IRQHandler+0x23dc>
 800701e:	687b      	ldr	r3, [r7, #4]
 8007020:	681b      	ldr	r3, [r3, #0]
 8007022:	4619      	mov	r1, r3
 8007024:	4b97      	ldr	r3, [pc, #604]	; (8007284 <HAL_DMA_IRQHandler+0x259c>)
 8007026:	4299      	cmp	r1, r3
 8007028:	d04a      	beq.n	80070c0 <HAL_DMA_IRQHandler+0x23d8>
 800702a:	687b      	ldr	r3, [r7, #4]
 800702c:	681b      	ldr	r3, [r3, #0]
 800702e:	4619      	mov	r1, r3
 8007030:	4b95      	ldr	r3, [pc, #596]	; (8007288 <HAL_DMA_IRQHandler+0x25a0>)
 8007032:	4299      	cmp	r1, r3
 8007034:	d041      	beq.n	80070ba <HAL_DMA_IRQHandler+0x23d2>
 8007036:	687b      	ldr	r3, [r7, #4]
 8007038:	681b      	ldr	r3, [r3, #0]
 800703a:	4619      	mov	r1, r3
 800703c:	4b93      	ldr	r3, [pc, #588]	; (800728c <HAL_DMA_IRQHandler+0x25a4>)
 800703e:	4299      	cmp	r1, r3
 8007040:	d038      	beq.n	80070b4 <HAL_DMA_IRQHandler+0x23cc>
 8007042:	687b      	ldr	r3, [r7, #4]
 8007044:	681b      	ldr	r3, [r3, #0]
 8007046:	4619      	mov	r1, r3
 8007048:	4b91      	ldr	r3, [pc, #580]	; (8007290 <HAL_DMA_IRQHandler+0x25a8>)
 800704a:	4299      	cmp	r1, r3
 800704c:	d02f      	beq.n	80070ae <HAL_DMA_IRQHandler+0x23c6>
 800704e:	687b      	ldr	r3, [r7, #4]
 8007050:	681b      	ldr	r3, [r3, #0]
 8007052:	4619      	mov	r1, r3
 8007054:	4b8f      	ldr	r3, [pc, #572]	; (8007294 <HAL_DMA_IRQHandler+0x25ac>)
 8007056:	4299      	cmp	r1, r3
 8007058:	d026      	beq.n	80070a8 <HAL_DMA_IRQHandler+0x23c0>
 800705a:	687b      	ldr	r3, [r7, #4]
 800705c:	681b      	ldr	r3, [r3, #0]
 800705e:	4619      	mov	r1, r3
 8007060:	4b8d      	ldr	r3, [pc, #564]	; (8007298 <HAL_DMA_IRQHandler+0x25b0>)
 8007062:	4299      	cmp	r1, r3
 8007064:	d01d      	beq.n	80070a2 <HAL_DMA_IRQHandler+0x23ba>
 8007066:	687b      	ldr	r3, [r7, #4]
 8007068:	681b      	ldr	r3, [r3, #0]
 800706a:	4619      	mov	r1, r3
 800706c:	4b8b      	ldr	r3, [pc, #556]	; (800729c <HAL_DMA_IRQHandler+0x25b4>)
 800706e:	4299      	cmp	r1, r3
 8007070:	d014      	beq.n	800709c <HAL_DMA_IRQHandler+0x23b4>
 8007072:	687b      	ldr	r3, [r7, #4]
 8007074:	681b      	ldr	r3, [r3, #0]
 8007076:	4619      	mov	r1, r3
 8007078:	4b89      	ldr	r3, [pc, #548]	; (80072a0 <HAL_DMA_IRQHandler+0x25b8>)
 800707a:	4299      	cmp	r1, r3
 800707c:	d00b      	beq.n	8007096 <HAL_DMA_IRQHandler+0x23ae>
 800707e:	687b      	ldr	r3, [r7, #4]
 8007080:	681b      	ldr	r3, [r3, #0]
 8007082:	4619      	mov	r1, r3
 8007084:	4b87      	ldr	r3, [pc, #540]	; (80072a4 <HAL_DMA_IRQHandler+0x25bc>)
 8007086:	4299      	cmp	r1, r3
 8007088:	d102      	bne.n	8007090 <HAL_DMA_IRQHandler+0x23a8>
 800708a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800708e:	e01e      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 8007090:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8007094:	e01b      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 8007096:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800709a:	e018      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 800709c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80070a0:	e015      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070a2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80070a6:	e012      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070a8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80070ac:	e00f      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80070b2:	e00c      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80070b8:	e009      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070ba:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80070be:	e006      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070c0:	2310      	movs	r3, #16
 80070c2:	e004      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070c4:	2310      	movs	r3, #16
 80070c6:	e002      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070c8:	2310      	movs	r3, #16
 80070ca:	e000      	b.n	80070ce <HAL_DMA_IRQHandler+0x23e6>
 80070cc:	2310      	movs	r3, #16
 80070ce:	6093      	str	r3, [r2, #8]
 80070d0:	e0ff      	b.n	80072d2 <HAL_DMA_IRQHandler+0x25ea>
 80070d2:	687b      	ldr	r3, [r7, #4]
 80070d4:	681b      	ldr	r3, [r3, #0]
 80070d6:	461a      	mov	r2, r3
 80070d8:	4b73      	ldr	r3, [pc, #460]	; (80072a8 <HAL_DMA_IRQHandler+0x25c0>)
 80070da:	429a      	cmp	r2, r3
 80070dc:	d96c      	bls.n	80071b8 <HAL_DMA_IRQHandler+0x24d0>
 80070de:	4a73      	ldr	r2, [pc, #460]	; (80072ac <HAL_DMA_IRQHandler+0x25c4>)
 80070e0:	687b      	ldr	r3, [r7, #4]
 80070e2:	681b      	ldr	r3, [r3, #0]
 80070e4:	4619      	mov	r1, r3
 80070e6:	4b64      	ldr	r3, [pc, #400]	; (8007278 <HAL_DMA_IRQHandler+0x2590>)
 80070e8:	4299      	cmp	r1, r3
 80070ea:	d062      	beq.n	80071b2 <HAL_DMA_IRQHandler+0x24ca>
 80070ec:	687b      	ldr	r3, [r7, #4]
 80070ee:	681b      	ldr	r3, [r3, #0]
 80070f0:	4619      	mov	r1, r3
 80070f2:	4b62      	ldr	r3, [pc, #392]	; (800727c <HAL_DMA_IRQHandler+0x2594>)
 80070f4:	4299      	cmp	r1, r3
 80070f6:	d05a      	beq.n	80071ae <HAL_DMA_IRQHandler+0x24c6>
 80070f8:	687b      	ldr	r3, [r7, #4]
 80070fa:	681b      	ldr	r3, [r3, #0]
 80070fc:	4619      	mov	r1, r3
 80070fe:	4b60      	ldr	r3, [pc, #384]	; (8007280 <HAL_DMA_IRQHandler+0x2598>)
 8007100:	4299      	cmp	r1, r3
 8007102:	d052      	beq.n	80071aa <HAL_DMA_IRQHandler+0x24c2>
 8007104:	687b      	ldr	r3, [r7, #4]
 8007106:	681b      	ldr	r3, [r3, #0]
 8007108:	4619      	mov	r1, r3
 800710a:	4b5e      	ldr	r3, [pc, #376]	; (8007284 <HAL_DMA_IRQHandler+0x259c>)
 800710c:	4299      	cmp	r1, r3
 800710e:	d04a      	beq.n	80071a6 <HAL_DMA_IRQHandler+0x24be>
 8007110:	687b      	ldr	r3, [r7, #4]
 8007112:	681b      	ldr	r3, [r3, #0]
 8007114:	4619      	mov	r1, r3
 8007116:	4b5c      	ldr	r3, [pc, #368]	; (8007288 <HAL_DMA_IRQHandler+0x25a0>)
 8007118:	4299      	cmp	r1, r3
 800711a:	d041      	beq.n	80071a0 <HAL_DMA_IRQHandler+0x24b8>
 800711c:	687b      	ldr	r3, [r7, #4]
 800711e:	681b      	ldr	r3, [r3, #0]
 8007120:	4619      	mov	r1, r3
 8007122:	4b5a      	ldr	r3, [pc, #360]	; (800728c <HAL_DMA_IRQHandler+0x25a4>)
 8007124:	4299      	cmp	r1, r3
 8007126:	d038      	beq.n	800719a <HAL_DMA_IRQHandler+0x24b2>
 8007128:	687b      	ldr	r3, [r7, #4]
 800712a:	681b      	ldr	r3, [r3, #0]
 800712c:	4619      	mov	r1, r3
 800712e:	4b58      	ldr	r3, [pc, #352]	; (8007290 <HAL_DMA_IRQHandler+0x25a8>)
 8007130:	4299      	cmp	r1, r3
 8007132:	d02f      	beq.n	8007194 <HAL_DMA_IRQHandler+0x24ac>
 8007134:	687b      	ldr	r3, [r7, #4]
 8007136:	681b      	ldr	r3, [r3, #0]
 8007138:	4619      	mov	r1, r3
 800713a:	4b56      	ldr	r3, [pc, #344]	; (8007294 <HAL_DMA_IRQHandler+0x25ac>)
 800713c:	4299      	cmp	r1, r3
 800713e:	d026      	beq.n	800718e <HAL_DMA_IRQHandler+0x24a6>
 8007140:	687b      	ldr	r3, [r7, #4]
 8007142:	681b      	ldr	r3, [r3, #0]
 8007144:	4619      	mov	r1, r3
 8007146:	4b54      	ldr	r3, [pc, #336]	; (8007298 <HAL_DMA_IRQHandler+0x25b0>)
 8007148:	4299      	cmp	r1, r3
 800714a:	d01d      	beq.n	8007188 <HAL_DMA_IRQHandler+0x24a0>
 800714c:	687b      	ldr	r3, [r7, #4]
 800714e:	681b      	ldr	r3, [r3, #0]
 8007150:	4619      	mov	r1, r3
 8007152:	4b52      	ldr	r3, [pc, #328]	; (800729c <HAL_DMA_IRQHandler+0x25b4>)
 8007154:	4299      	cmp	r1, r3
 8007156:	d014      	beq.n	8007182 <HAL_DMA_IRQHandler+0x249a>
 8007158:	687b      	ldr	r3, [r7, #4]
 800715a:	681b      	ldr	r3, [r3, #0]
 800715c:	4619      	mov	r1, r3
 800715e:	4b50      	ldr	r3, [pc, #320]	; (80072a0 <HAL_DMA_IRQHandler+0x25b8>)
 8007160:	4299      	cmp	r1, r3
 8007162:	d00b      	beq.n	800717c <HAL_DMA_IRQHandler+0x2494>
 8007164:	687b      	ldr	r3, [r7, #4]
 8007166:	681b      	ldr	r3, [r3, #0]
 8007168:	4619      	mov	r1, r3
 800716a:	4b4e      	ldr	r3, [pc, #312]	; (80072a4 <HAL_DMA_IRQHandler+0x25bc>)
 800716c:	4299      	cmp	r1, r3
 800716e:	d102      	bne.n	8007176 <HAL_DMA_IRQHandler+0x248e>
 8007170:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8007174:	e01e      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 8007176:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800717a:	e01b      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 800717c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8007180:	e018      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 8007182:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8007186:	e015      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 8007188:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800718c:	e012      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 800718e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007192:	e00f      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 8007194:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007198:	e00c      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 800719a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800719e:	e009      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 80071a0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80071a4:	e006      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 80071a6:	2310      	movs	r3, #16
 80071a8:	e004      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 80071aa:	2310      	movs	r3, #16
 80071ac:	e002      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 80071ae:	2310      	movs	r3, #16
 80071b0:	e000      	b.n	80071b4 <HAL_DMA_IRQHandler+0x24cc>
 80071b2:	2310      	movs	r3, #16
 80071b4:	60d3      	str	r3, [r2, #12]
 80071b6:	e08c      	b.n	80072d2 <HAL_DMA_IRQHandler+0x25ea>
 80071b8:	4a3c      	ldr	r2, [pc, #240]	; (80072ac <HAL_DMA_IRQHandler+0x25c4>)
 80071ba:	687b      	ldr	r3, [r7, #4]
 80071bc:	681b      	ldr	r3, [r3, #0]
 80071be:	4619      	mov	r1, r3
 80071c0:	4b2d      	ldr	r3, [pc, #180]	; (8007278 <HAL_DMA_IRQHandler+0x2590>)
 80071c2:	4299      	cmp	r1, r3
 80071c4:	f000 8083 	beq.w	80072ce <HAL_DMA_IRQHandler+0x25e6>
 80071c8:	687b      	ldr	r3, [r7, #4]
 80071ca:	681b      	ldr	r3, [r3, #0]
 80071cc:	4619      	mov	r1, r3
 80071ce:	4b2b      	ldr	r3, [pc, #172]	; (800727c <HAL_DMA_IRQHandler+0x2594>)
 80071d0:	4299      	cmp	r1, r3
 80071d2:	d07a      	beq.n	80072ca <HAL_DMA_IRQHandler+0x25e2>
 80071d4:	687b      	ldr	r3, [r7, #4]
 80071d6:	681b      	ldr	r3, [r3, #0]
 80071d8:	4619      	mov	r1, r3
 80071da:	4b29      	ldr	r3, [pc, #164]	; (8007280 <HAL_DMA_IRQHandler+0x2598>)
 80071dc:	4299      	cmp	r1, r3
 80071de:	d072      	beq.n	80072c6 <HAL_DMA_IRQHandler+0x25de>
 80071e0:	687b      	ldr	r3, [r7, #4]
 80071e2:	681b      	ldr	r3, [r3, #0]
 80071e4:	4619      	mov	r1, r3
 80071e6:	4b27      	ldr	r3, [pc, #156]	; (8007284 <HAL_DMA_IRQHandler+0x259c>)
 80071e8:	4299      	cmp	r1, r3
 80071ea:	d06a      	beq.n	80072c2 <HAL_DMA_IRQHandler+0x25da>
 80071ec:	687b      	ldr	r3, [r7, #4]
 80071ee:	681b      	ldr	r3, [r3, #0]
 80071f0:	4619      	mov	r1, r3
 80071f2:	4b25      	ldr	r3, [pc, #148]	; (8007288 <HAL_DMA_IRQHandler+0x25a0>)
 80071f4:	4299      	cmp	r1, r3
 80071f6:	d061      	beq.n	80072bc <HAL_DMA_IRQHandler+0x25d4>
 80071f8:	687b      	ldr	r3, [r7, #4]
 80071fa:	681b      	ldr	r3, [r3, #0]
 80071fc:	4619      	mov	r1, r3
 80071fe:	4b23      	ldr	r3, [pc, #140]	; (800728c <HAL_DMA_IRQHandler+0x25a4>)
 8007200:	4299      	cmp	r1, r3
 8007202:	d058      	beq.n	80072b6 <HAL_DMA_IRQHandler+0x25ce>
 8007204:	687b      	ldr	r3, [r7, #4]
 8007206:	681b      	ldr	r3, [r3, #0]
 8007208:	4619      	mov	r1, r3
 800720a:	4b21      	ldr	r3, [pc, #132]	; (8007290 <HAL_DMA_IRQHandler+0x25a8>)
 800720c:	4299      	cmp	r1, r3
 800720e:	d04f      	beq.n	80072b0 <HAL_DMA_IRQHandler+0x25c8>
 8007210:	687b      	ldr	r3, [r7, #4]
 8007212:	681b      	ldr	r3, [r3, #0]
 8007214:	4619      	mov	r1, r3
 8007216:	4b1f      	ldr	r3, [pc, #124]	; (8007294 <HAL_DMA_IRQHandler+0x25ac>)
 8007218:	4299      	cmp	r1, r3
 800721a:	d026      	beq.n	800726a <HAL_DMA_IRQHandler+0x2582>
 800721c:	687b      	ldr	r3, [r7, #4]
 800721e:	681b      	ldr	r3, [r3, #0]
 8007220:	4619      	mov	r1, r3
 8007222:	4b1d      	ldr	r3, [pc, #116]	; (8007298 <HAL_DMA_IRQHandler+0x25b0>)
 8007224:	4299      	cmp	r1, r3
 8007226:	d01d      	beq.n	8007264 <HAL_DMA_IRQHandler+0x257c>
 8007228:	687b      	ldr	r3, [r7, #4]
 800722a:	681b      	ldr	r3, [r3, #0]
 800722c:	4619      	mov	r1, r3
 800722e:	4b1b      	ldr	r3, [pc, #108]	; (800729c <HAL_DMA_IRQHandler+0x25b4>)
 8007230:	4299      	cmp	r1, r3
 8007232:	d014      	beq.n	800725e <HAL_DMA_IRQHandler+0x2576>
 8007234:	687b      	ldr	r3, [r7, #4]
 8007236:	681b      	ldr	r3, [r3, #0]
 8007238:	4619      	mov	r1, r3
 800723a:	4b19      	ldr	r3, [pc, #100]	; (80072a0 <HAL_DMA_IRQHandler+0x25b8>)
 800723c:	4299      	cmp	r1, r3
 800723e:	d00b      	beq.n	8007258 <HAL_DMA_IRQHandler+0x2570>
 8007240:	687b      	ldr	r3, [r7, #4]
 8007242:	681b      	ldr	r3, [r3, #0]
 8007244:	4619      	mov	r1, r3
 8007246:	4b17      	ldr	r3, [pc, #92]	; (80072a4 <HAL_DMA_IRQHandler+0x25bc>)
 8007248:	4299      	cmp	r1, r3
 800724a:	d102      	bne.n	8007252 <HAL_DMA_IRQHandler+0x256a>
 800724c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8007250:	e03e      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 8007252:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8007256:	e03b      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 8007258:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800725c:	e038      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 800725e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8007262:	e035      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 8007264:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8007268:	e032      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 800726a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800726e:	e02f      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 8007270:	400260b8 	.word	0x400260b8
 8007274:	40026400 	.word	0x40026400
 8007278:	40026010 	.word	0x40026010
 800727c:	40026410 	.word	0x40026410
 8007280:	40026070 	.word	0x40026070
 8007284:	40026470 	.word	0x40026470
 8007288:	40026028 	.word	0x40026028
 800728c:	40026428 	.word	0x40026428
 8007290:	40026088 	.word	0x40026088
 8007294:	40026488 	.word	0x40026488
 8007298:	40026040 	.word	0x40026040
 800729c:	40026440 	.word	0x40026440
 80072a0:	400260a0 	.word	0x400260a0
 80072a4:	400264a0 	.word	0x400264a0
 80072a8:	40026058 	.word	0x40026058
 80072ac:	40026000 	.word	0x40026000
 80072b0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80072b4:	e00c      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 80072b6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80072ba:	e009      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 80072bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80072c0:	e006      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 80072c2:	2310      	movs	r3, #16
 80072c4:	e004      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 80072c6:	2310      	movs	r3, #16
 80072c8:	e002      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 80072ca:	2310      	movs	r3, #16
 80072cc:	e000      	b.n	80072d0 <HAL_DMA_IRQHandler+0x25e8>
 80072ce:	2310      	movs	r3, #16
 80072d0:	6093      	str	r3, [r2, #8]

        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 80072d2:	687b      	ldr	r3, [r7, #4]
 80072d4:	2231      	movs	r2, #49	; 0x31
 80072d6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      }

      if(hdma->XferHalfCpltCallback != NULL)
 80072da:	687b      	ldr	r3, [r7, #4]
 80072dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80072de:	2b00      	cmp	r3, #0
 80072e0:	d003      	beq.n	80072ea <HAL_DMA_IRQHandler+0x2602>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 80072e2:	687b      	ldr	r3, [r7, #4]
 80072e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80072e6:	6878      	ldr	r0, [r7, #4]
 80072e8:	4798      	blx	r3
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 80072ea:	687b      	ldr	r3, [r7, #4]
 80072ec:	681b      	ldr	r3, [r3, #0]
 80072ee:	461a      	mov	r2, r3
 80072f0:	4b77      	ldr	r3, [pc, #476]	; (80074d0 <HAL_DMA_IRQHandler+0x27e8>)
 80072f2:	429a      	cmp	r2, r3
 80072f4:	d972      	bls.n	80073dc <HAL_DMA_IRQHandler+0x26f4>
 80072f6:	4b77      	ldr	r3, [pc, #476]	; (80074d4 <HAL_DMA_IRQHandler+0x27ec>)
 80072f8:	685a      	ldr	r2, [r3, #4]
 80072fa:	687b      	ldr	r3, [r7, #4]
 80072fc:	681b      	ldr	r3, [r3, #0]
 80072fe:	4619      	mov	r1, r3
 8007300:	4b75      	ldr	r3, [pc, #468]	; (80074d8 <HAL_DMA_IRQHandler+0x27f0>)
 8007302:	4299      	cmp	r1, r3
 8007304:	d062      	beq.n	80073cc <HAL_DMA_IRQHandler+0x26e4>
 8007306:	687b      	ldr	r3, [r7, #4]
 8007308:	681b      	ldr	r3, [r3, #0]
 800730a:	4619      	mov	r1, r3
 800730c:	4b73      	ldr	r3, [pc, #460]	; (80074dc <HAL_DMA_IRQHandler+0x27f4>)
 800730e:	4299      	cmp	r1, r3
 8007310:	d05a      	beq.n	80073c8 <HAL_DMA_IRQHandler+0x26e0>
 8007312:	687b      	ldr	r3, [r7, #4]
 8007314:	681b      	ldr	r3, [r3, #0]
 8007316:	4619      	mov	r1, r3
 8007318:	4b71      	ldr	r3, [pc, #452]	; (80074e0 <HAL_DMA_IRQHandler+0x27f8>)
 800731a:	4299      	cmp	r1, r3
 800731c:	d052      	beq.n	80073c4 <HAL_DMA_IRQHandler+0x26dc>
 800731e:	687b      	ldr	r3, [r7, #4]
 8007320:	681b      	ldr	r3, [r3, #0]
 8007322:	4619      	mov	r1, r3
 8007324:	4b6f      	ldr	r3, [pc, #444]	; (80074e4 <HAL_DMA_IRQHandler+0x27fc>)
 8007326:	4299      	cmp	r1, r3
 8007328:	d04a      	beq.n	80073c0 <HAL_DMA_IRQHandler+0x26d8>
 800732a:	687b      	ldr	r3, [r7, #4]
 800732c:	681b      	ldr	r3, [r3, #0]
 800732e:	4619      	mov	r1, r3
 8007330:	4b6d      	ldr	r3, [pc, #436]	; (80074e8 <HAL_DMA_IRQHandler+0x2800>)
 8007332:	4299      	cmp	r1, r3
 8007334:	d041      	beq.n	80073ba <HAL_DMA_IRQHandler+0x26d2>
 8007336:	687b      	ldr	r3, [r7, #4]
 8007338:	681b      	ldr	r3, [r3, #0]
 800733a:	4619      	mov	r1, r3
 800733c:	4b6b      	ldr	r3, [pc, #428]	; (80074ec <HAL_DMA_IRQHandler+0x2804>)
 800733e:	4299      	cmp	r1, r3
 8007340:	d038      	beq.n	80073b4 <HAL_DMA_IRQHandler+0x26cc>
 8007342:	687b      	ldr	r3, [r7, #4]
 8007344:	681b      	ldr	r3, [r3, #0]
 8007346:	4619      	mov	r1, r3
 8007348:	4b69      	ldr	r3, [pc, #420]	; (80074f0 <HAL_DMA_IRQHandler+0x2808>)
 800734a:	4299      	cmp	r1, r3
 800734c:	d02f      	beq.n	80073ae <HAL_DMA_IRQHandler+0x26c6>
 800734e:	687b      	ldr	r3, [r7, #4]
 8007350:	681b      	ldr	r3, [r3, #0]
 8007352:	4619      	mov	r1, r3
 8007354:	4b67      	ldr	r3, [pc, #412]	; (80074f4 <HAL_DMA_IRQHandler+0x280c>)
 8007356:	4299      	cmp	r1, r3
 8007358:	d026      	beq.n	80073a8 <HAL_DMA_IRQHandler+0x26c0>
 800735a:	687b      	ldr	r3, [r7, #4]
 800735c:	681b      	ldr	r3, [r3, #0]
 800735e:	4619      	mov	r1, r3
 8007360:	4b65      	ldr	r3, [pc, #404]	; (80074f8 <HAL_DMA_IRQHandler+0x2810>)
 8007362:	4299      	cmp	r1, r3
 8007364:	d01d      	beq.n	80073a2 <HAL_DMA_IRQHandler+0x26ba>
 8007366:	687b      	ldr	r3, [r7, #4]
 8007368:	681b      	ldr	r3, [r3, #0]
 800736a:	4619      	mov	r1, r3
 800736c:	4b63      	ldr	r3, [pc, #396]	; (80074fc <HAL_DMA_IRQHandler+0x2814>)
 800736e:	4299      	cmp	r1, r3
 8007370:	d014      	beq.n	800739c <HAL_DMA_IRQHandler+0x26b4>
 8007372:	687b      	ldr	r3, [r7, #4]
 8007374:	681b      	ldr	r3, [r3, #0]
 8007376:	4619      	mov	r1, r3
 8007378:	4b61      	ldr	r3, [pc, #388]	; (8007500 <HAL_DMA_IRQHandler+0x2818>)
 800737a:	4299      	cmp	r1, r3
 800737c:	d00b      	beq.n	8007396 <HAL_DMA_IRQHandler+0x26ae>
 800737e:	687b      	ldr	r3, [r7, #4]
 8007380:	681b      	ldr	r3, [r3, #0]
 8007382:	4619      	mov	r1, r3
 8007384:	4b5f      	ldr	r3, [pc, #380]	; (8007504 <HAL_DMA_IRQHandler+0x281c>)
 8007386:	4299      	cmp	r1, r3
 8007388:	d102      	bne.n	8007390 <HAL_DMA_IRQHandler+0x26a8>
 800738a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800738e:	e01e      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 8007390:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007394:	e01b      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 8007396:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800739a:	e018      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 800739c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80073a0:	e015      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073a2:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80073a6:	e012      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073a8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80073ac:	e00f      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073ae:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80073b2:	e00c      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073b4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80073b8:	e009      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073ba:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80073be:	e006      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073c0:	2320      	movs	r3, #32
 80073c2:	e004      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073c4:	2320      	movs	r3, #32
 80073c6:	e002      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073c8:	2320      	movs	r3, #32
 80073ca:	e000      	b.n	80073ce <HAL_DMA_IRQHandler+0x26e6>
 80073cc:	2320      	movs	r3, #32
 80073ce:	4013      	ands	r3, r2
 80073d0:	2b00      	cmp	r3, #0
 80073d2:	bf14      	ite	ne
 80073d4:	2301      	movne	r3, #1
 80073d6:	2300      	moveq	r3, #0
 80073d8:	b2db      	uxtb	r3, r3
 80073da:	e19e      	b.n	800771a <HAL_DMA_IRQHandler+0x2a32>
 80073dc:	687b      	ldr	r3, [r7, #4]
 80073de:	681b      	ldr	r3, [r3, #0]
 80073e0:	461a      	mov	r2, r3
 80073e2:	4b49      	ldr	r3, [pc, #292]	; (8007508 <HAL_DMA_IRQHandler+0x2820>)
 80073e4:	429a      	cmp	r2, r3
 80073e6:	f240 8091 	bls.w	800750c <HAL_DMA_IRQHandler+0x2824>
 80073ea:	4b3a      	ldr	r3, [pc, #232]	; (80074d4 <HAL_DMA_IRQHandler+0x27ec>)
 80073ec:	681a      	ldr	r2, [r3, #0]
 80073ee:	687b      	ldr	r3, [r7, #4]
 80073f0:	681b      	ldr	r3, [r3, #0]
 80073f2:	4619      	mov	r1, r3
 80073f4:	4b38      	ldr	r3, [pc, #224]	; (80074d8 <HAL_DMA_IRQHandler+0x27f0>)
 80073f6:	4299      	cmp	r1, r3
 80073f8:	d062      	beq.n	80074c0 <HAL_DMA_IRQHandler+0x27d8>
 80073fa:	687b      	ldr	r3, [r7, #4]
 80073fc:	681b      	ldr	r3, [r3, #0]
 80073fe:	4619      	mov	r1, r3
 8007400:	4b36      	ldr	r3, [pc, #216]	; (80074dc <HAL_DMA_IRQHandler+0x27f4>)
 8007402:	4299      	cmp	r1, r3
 8007404:	d05a      	beq.n	80074bc <HAL_DMA_IRQHandler+0x27d4>
 8007406:	687b      	ldr	r3, [r7, #4]
 8007408:	681b      	ldr	r3, [r3, #0]
 800740a:	4619      	mov	r1, r3
 800740c:	4b34      	ldr	r3, [pc, #208]	; (80074e0 <HAL_DMA_IRQHandler+0x27f8>)
 800740e:	4299      	cmp	r1, r3
 8007410:	d052      	beq.n	80074b8 <HAL_DMA_IRQHandler+0x27d0>
 8007412:	687b      	ldr	r3, [r7, #4]
 8007414:	681b      	ldr	r3, [r3, #0]
 8007416:	4619      	mov	r1, r3
 8007418:	4b32      	ldr	r3, [pc, #200]	; (80074e4 <HAL_DMA_IRQHandler+0x27fc>)
 800741a:	4299      	cmp	r1, r3
 800741c:	d04a      	beq.n	80074b4 <HAL_DMA_IRQHandler+0x27cc>
 800741e:	687b      	ldr	r3, [r7, #4]
 8007420:	681b      	ldr	r3, [r3, #0]
 8007422:	4619      	mov	r1, r3
 8007424:	4b30      	ldr	r3, [pc, #192]	; (80074e8 <HAL_DMA_IRQHandler+0x2800>)
 8007426:	4299      	cmp	r1, r3
 8007428:	d041      	beq.n	80074ae <HAL_DMA_IRQHandler+0x27c6>
 800742a:	687b      	ldr	r3, [r7, #4]
 800742c:	681b      	ldr	r3, [r3, #0]
 800742e:	4619      	mov	r1, r3
 8007430:	4b2e      	ldr	r3, [pc, #184]	; (80074ec <HAL_DMA_IRQHandler+0x2804>)
 8007432:	4299      	cmp	r1, r3
 8007434:	d038      	beq.n	80074a8 <HAL_DMA_IRQHandler+0x27c0>
 8007436:	687b      	ldr	r3, [r7, #4]
 8007438:	681b      	ldr	r3, [r3, #0]
 800743a:	4619      	mov	r1, r3
 800743c:	4b2c      	ldr	r3, [pc, #176]	; (80074f0 <HAL_DMA_IRQHandler+0x2808>)
 800743e:	4299      	cmp	r1, r3
 8007440:	d02f      	beq.n	80074a2 <HAL_DMA_IRQHandler+0x27ba>
 8007442:	687b      	ldr	r3, [r7, #4]
 8007444:	681b      	ldr	r3, [r3, #0]
 8007446:	4619      	mov	r1, r3
 8007448:	4b2a      	ldr	r3, [pc, #168]	; (80074f4 <HAL_DMA_IRQHandler+0x280c>)
 800744a:	4299      	cmp	r1, r3
 800744c:	d026      	beq.n	800749c <HAL_DMA_IRQHandler+0x27b4>
 800744e:	687b      	ldr	r3, [r7, #4]
 8007450:	681b      	ldr	r3, [r3, #0]
 8007452:	4619      	mov	r1, r3
 8007454:	4b28      	ldr	r3, [pc, #160]	; (80074f8 <HAL_DMA_IRQHandler+0x2810>)
 8007456:	4299      	cmp	r1, r3
 8007458:	d01d      	beq.n	8007496 <HAL_DMA_IRQHandler+0x27ae>
 800745a:	687b      	ldr	r3, [r7, #4]
 800745c:	681b      	ldr	r3, [r3, #0]
 800745e:	4619      	mov	r1, r3
 8007460:	4b26      	ldr	r3, [pc, #152]	; (80074fc <HAL_DMA_IRQHandler+0x2814>)
 8007462:	4299      	cmp	r1, r3
 8007464:	d014      	beq.n	8007490 <HAL_DMA_IRQHandler+0x27a8>
 8007466:	687b      	ldr	r3, [r7, #4]
 8007468:	681b      	ldr	r3, [r3, #0]
 800746a:	4619      	mov	r1, r3
 800746c:	4b24      	ldr	r3, [pc, #144]	; (8007500 <HAL_DMA_IRQHandler+0x2818>)
 800746e:	4299      	cmp	r1, r3
 8007470:	d00b      	beq.n	800748a <HAL_DMA_IRQHandler+0x27a2>
 8007472:	687b      	ldr	r3, [r7, #4]
 8007474:	681b      	ldr	r3, [r3, #0]
 8007476:	4619      	mov	r1, r3
 8007478:	4b22      	ldr	r3, [pc, #136]	; (8007504 <HAL_DMA_IRQHandler+0x281c>)
 800747a:	4299      	cmp	r1, r3
 800747c:	d102      	bne.n	8007484 <HAL_DMA_IRQHandler+0x279c>
 800747e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007482:	e01e      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 8007484:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007488:	e01b      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 800748a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800748e:	e018      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 8007490:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007494:	e015      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 8007496:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800749a:	e012      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 800749c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80074a0:	e00f      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 80074a2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80074a6:	e00c      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 80074a8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80074ac:	e009      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 80074ae:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80074b2:	e006      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 80074b4:	2320      	movs	r3, #32
 80074b6:	e004      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 80074b8:	2320      	movs	r3, #32
 80074ba:	e002      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 80074bc:	2320      	movs	r3, #32
 80074be:	e000      	b.n	80074c2 <HAL_DMA_IRQHandler+0x27da>
 80074c0:	2320      	movs	r3, #32
 80074c2:	4013      	ands	r3, r2
 80074c4:	2b00      	cmp	r3, #0
 80074c6:	bf14      	ite	ne
 80074c8:	2301      	movne	r3, #1
 80074ca:	2300      	moveq	r3, #0
 80074cc:	b2db      	uxtb	r3, r3
 80074ce:	e124      	b.n	800771a <HAL_DMA_IRQHandler+0x2a32>
 80074d0:	40026458 	.word	0x40026458
 80074d4:	40026400 	.word	0x40026400
 80074d8:	40026010 	.word	0x40026010
 80074dc:	40026410 	.word	0x40026410
 80074e0:	40026070 	.word	0x40026070
 80074e4:	40026470 	.word	0x40026470
 80074e8:	40026028 	.word	0x40026028
 80074ec:	40026428 	.word	0x40026428
 80074f0:	40026088 	.word	0x40026088
 80074f4:	40026488 	.word	0x40026488
 80074f8:	40026040 	.word	0x40026040
 80074fc:	40026440 	.word	0x40026440
 8007500:	400260a0 	.word	0x400260a0
 8007504:	400264a0 	.word	0x400264a0
 8007508:	400260b8 	.word	0x400260b8
 800750c:	687b      	ldr	r3, [r7, #4]
 800750e:	681b      	ldr	r3, [r3, #0]
 8007510:	461a      	mov	r2, r3
 8007512:	4b70      	ldr	r3, [pc, #448]	; (80076d4 <HAL_DMA_IRQHandler+0x29ec>)
 8007514:	429a      	cmp	r2, r3
 8007516:	d972      	bls.n	80075fe <HAL_DMA_IRQHandler+0x2916>
 8007518:	4b6f      	ldr	r3, [pc, #444]	; (80076d8 <HAL_DMA_IRQHandler+0x29f0>)
 800751a:	685a      	ldr	r2, [r3, #4]
 800751c:	687b      	ldr	r3, [r7, #4]
 800751e:	681b      	ldr	r3, [r3, #0]
 8007520:	4619      	mov	r1, r3
 8007522:	4b6e      	ldr	r3, [pc, #440]	; (80076dc <HAL_DMA_IRQHandler+0x29f4>)
 8007524:	4299      	cmp	r1, r3
 8007526:	d062      	beq.n	80075ee <HAL_DMA_IRQHandler+0x2906>
 8007528:	687b      	ldr	r3, [r7, #4]
 800752a:	681b      	ldr	r3, [r3, #0]
 800752c:	4619      	mov	r1, r3
 800752e:	4b6c      	ldr	r3, [pc, #432]	; (80076e0 <HAL_DMA_IRQHandler+0x29f8>)
 8007530:	4299      	cmp	r1, r3
 8007532:	d05a      	beq.n	80075ea <HAL_DMA_IRQHandler+0x2902>
 8007534:	687b      	ldr	r3, [r7, #4]
 8007536:	681b      	ldr	r3, [r3, #0]
 8007538:	4619      	mov	r1, r3
 800753a:	4b6a      	ldr	r3, [pc, #424]	; (80076e4 <HAL_DMA_IRQHandler+0x29fc>)
 800753c:	4299      	cmp	r1, r3
 800753e:	d052      	beq.n	80075e6 <HAL_DMA_IRQHandler+0x28fe>
 8007540:	687b      	ldr	r3, [r7, #4]
 8007542:	681b      	ldr	r3, [r3, #0]
 8007544:	4619      	mov	r1, r3
 8007546:	4b68      	ldr	r3, [pc, #416]	; (80076e8 <HAL_DMA_IRQHandler+0x2a00>)
 8007548:	4299      	cmp	r1, r3
 800754a:	d04a      	beq.n	80075e2 <HAL_DMA_IRQHandler+0x28fa>
 800754c:	687b      	ldr	r3, [r7, #4]
 800754e:	681b      	ldr	r3, [r3, #0]
 8007550:	4619      	mov	r1, r3
 8007552:	4b66      	ldr	r3, [pc, #408]	; (80076ec <HAL_DMA_IRQHandler+0x2a04>)
 8007554:	4299      	cmp	r1, r3
 8007556:	d041      	beq.n	80075dc <HAL_DMA_IRQHandler+0x28f4>
 8007558:	687b      	ldr	r3, [r7, #4]
 800755a:	681b      	ldr	r3, [r3, #0]
 800755c:	4619      	mov	r1, r3
 800755e:	4b64      	ldr	r3, [pc, #400]	; (80076f0 <HAL_DMA_IRQHandler+0x2a08>)
 8007560:	4299      	cmp	r1, r3
 8007562:	d038      	beq.n	80075d6 <HAL_DMA_IRQHandler+0x28ee>
 8007564:	687b      	ldr	r3, [r7, #4]
 8007566:	681b      	ldr	r3, [r3, #0]
 8007568:	4619      	mov	r1, r3
 800756a:	4b62      	ldr	r3, [pc, #392]	; (80076f4 <HAL_DMA_IRQHandler+0x2a0c>)
 800756c:	4299      	cmp	r1, r3
 800756e:	d02f      	beq.n	80075d0 <HAL_DMA_IRQHandler+0x28e8>
 8007570:	687b      	ldr	r3, [r7, #4]
 8007572:	681b      	ldr	r3, [r3, #0]
 8007574:	4619      	mov	r1, r3
 8007576:	4b60      	ldr	r3, [pc, #384]	; (80076f8 <HAL_DMA_IRQHandler+0x2a10>)
 8007578:	4299      	cmp	r1, r3
 800757a:	d026      	beq.n	80075ca <HAL_DMA_IRQHandler+0x28e2>
 800757c:	687b      	ldr	r3, [r7, #4]
 800757e:	681b      	ldr	r3, [r3, #0]
 8007580:	4619      	mov	r1, r3
 8007582:	4b5e      	ldr	r3, [pc, #376]	; (80076fc <HAL_DMA_IRQHandler+0x2a14>)
 8007584:	4299      	cmp	r1, r3
 8007586:	d01d      	beq.n	80075c4 <HAL_DMA_IRQHandler+0x28dc>
 8007588:	687b      	ldr	r3, [r7, #4]
 800758a:	681b      	ldr	r3, [r3, #0]
 800758c:	4619      	mov	r1, r3
 800758e:	4b5c      	ldr	r3, [pc, #368]	; (8007700 <HAL_DMA_IRQHandler+0x2a18>)
 8007590:	4299      	cmp	r1, r3
 8007592:	d014      	beq.n	80075be <HAL_DMA_IRQHandler+0x28d6>
 8007594:	687b      	ldr	r3, [r7, #4]
 8007596:	681b      	ldr	r3, [r3, #0]
 8007598:	4619      	mov	r1, r3
 800759a:	4b5a      	ldr	r3, [pc, #360]	; (8007704 <HAL_DMA_IRQHandler+0x2a1c>)
 800759c:	4299      	cmp	r1, r3
 800759e:	d00b      	beq.n	80075b8 <HAL_DMA_IRQHandler+0x28d0>
 80075a0:	687b      	ldr	r3, [r7, #4]
 80075a2:	681b      	ldr	r3, [r3, #0]
 80075a4:	4619      	mov	r1, r3
 80075a6:	4b58      	ldr	r3, [pc, #352]	; (8007708 <HAL_DMA_IRQHandler+0x2a20>)
 80075a8:	4299      	cmp	r1, r3
 80075aa:	d102      	bne.n	80075b2 <HAL_DMA_IRQHandler+0x28ca>
 80075ac:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80075b0:	e01e      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075b2:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80075b6:	e01b      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075b8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80075bc:	e018      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075be:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80075c2:	e015      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075c4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80075c8:	e012      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075ca:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80075ce:	e00f      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075d0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80075d4:	e00c      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075d6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80075da:	e009      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075dc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80075e0:	e006      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075e2:	2320      	movs	r3, #32
 80075e4:	e004      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075e6:	2320      	movs	r3, #32
 80075e8:	e002      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075ea:	2320      	movs	r3, #32
 80075ec:	e000      	b.n	80075f0 <HAL_DMA_IRQHandler+0x2908>
 80075ee:	2320      	movs	r3, #32
 80075f0:	4013      	ands	r3, r2
 80075f2:	2b00      	cmp	r3, #0
 80075f4:	bf14      	ite	ne
 80075f6:	2301      	movne	r3, #1
 80075f8:	2300      	moveq	r3, #0
 80075fa:	b2db      	uxtb	r3, r3
 80075fc:	e08d      	b.n	800771a <HAL_DMA_IRQHandler+0x2a32>
 80075fe:	4b36      	ldr	r3, [pc, #216]	; (80076d8 <HAL_DMA_IRQHandler+0x29f0>)
 8007600:	681a      	ldr	r2, [r3, #0]
 8007602:	687b      	ldr	r3, [r7, #4]
 8007604:	681b      	ldr	r3, [r3, #0]
 8007606:	4619      	mov	r1, r3
 8007608:	4b34      	ldr	r3, [pc, #208]	; (80076dc <HAL_DMA_IRQHandler+0x29f4>)
 800760a:	4299      	cmp	r1, r3
 800760c:	d07e      	beq.n	800770c <HAL_DMA_IRQHandler+0x2a24>
 800760e:	687b      	ldr	r3, [r7, #4]
 8007610:	681b      	ldr	r3, [r3, #0]
 8007612:	4619      	mov	r1, r3
 8007614:	4b32      	ldr	r3, [pc, #200]	; (80076e0 <HAL_DMA_IRQHandler+0x29f8>)
 8007616:	4299      	cmp	r1, r3
 8007618:	d05a      	beq.n	80076d0 <HAL_DMA_IRQHandler+0x29e8>
 800761a:	687b      	ldr	r3, [r7, #4]
 800761c:	681b      	ldr	r3, [r3, #0]
 800761e:	4619      	mov	r1, r3
 8007620:	4b30      	ldr	r3, [pc, #192]	; (80076e4 <HAL_DMA_IRQHandler+0x29fc>)
 8007622:	4299      	cmp	r1, r3
 8007624:	d052      	beq.n	80076cc <HAL_DMA_IRQHandler+0x29e4>
 8007626:	687b      	ldr	r3, [r7, #4]
 8007628:	681b      	ldr	r3, [r3, #0]
 800762a:	4619      	mov	r1, r3
 800762c:	4b2e      	ldr	r3, [pc, #184]	; (80076e8 <HAL_DMA_IRQHandler+0x2a00>)
 800762e:	4299      	cmp	r1, r3
 8007630:	d04a      	beq.n	80076c8 <HAL_DMA_IRQHandler+0x29e0>
 8007632:	687b      	ldr	r3, [r7, #4]
 8007634:	681b      	ldr	r3, [r3, #0]
 8007636:	4619      	mov	r1, r3
 8007638:	4b2c      	ldr	r3, [pc, #176]	; (80076ec <HAL_DMA_IRQHandler+0x2a04>)
 800763a:	4299      	cmp	r1, r3
 800763c:	d041      	beq.n	80076c2 <HAL_DMA_IRQHandler+0x29da>
 800763e:	687b      	ldr	r3, [r7, #4]
 8007640:	681b      	ldr	r3, [r3, #0]
 8007642:	4619      	mov	r1, r3
 8007644:	4b2a      	ldr	r3, [pc, #168]	; (80076f0 <HAL_DMA_IRQHandler+0x2a08>)
 8007646:	4299      	cmp	r1, r3
 8007648:	d038      	beq.n	80076bc <HAL_DMA_IRQHandler+0x29d4>
 800764a:	687b      	ldr	r3, [r7, #4]
 800764c:	681b      	ldr	r3, [r3, #0]
 800764e:	4619      	mov	r1, r3
 8007650:	4b28      	ldr	r3, [pc, #160]	; (80076f4 <HAL_DMA_IRQHandler+0x2a0c>)
 8007652:	4299      	cmp	r1, r3
 8007654:	d02f      	beq.n	80076b6 <HAL_DMA_IRQHandler+0x29ce>
 8007656:	687b      	ldr	r3, [r7, #4]
 8007658:	681b      	ldr	r3, [r3, #0]
 800765a:	4619      	mov	r1, r3
 800765c:	4b26      	ldr	r3, [pc, #152]	; (80076f8 <HAL_DMA_IRQHandler+0x2a10>)
 800765e:	4299      	cmp	r1, r3
 8007660:	d026      	beq.n	80076b0 <HAL_DMA_IRQHandler+0x29c8>
 8007662:	687b      	ldr	r3, [r7, #4]
 8007664:	681b      	ldr	r3, [r3, #0]
 8007666:	4619      	mov	r1, r3
 8007668:	4b24      	ldr	r3, [pc, #144]	; (80076fc <HAL_DMA_IRQHandler+0x2a14>)
 800766a:	4299      	cmp	r1, r3
 800766c:	d01d      	beq.n	80076aa <HAL_DMA_IRQHandler+0x29c2>
 800766e:	687b      	ldr	r3, [r7, #4]
 8007670:	681b      	ldr	r3, [r3, #0]
 8007672:	4619      	mov	r1, r3
 8007674:	4b22      	ldr	r3, [pc, #136]	; (8007700 <HAL_DMA_IRQHandler+0x2a18>)
 8007676:	4299      	cmp	r1, r3
 8007678:	d014      	beq.n	80076a4 <HAL_DMA_IRQHandler+0x29bc>
 800767a:	687b      	ldr	r3, [r7, #4]
 800767c:	681b      	ldr	r3, [r3, #0]
 800767e:	4619      	mov	r1, r3
 8007680:	4b20      	ldr	r3, [pc, #128]	; (8007704 <HAL_DMA_IRQHandler+0x2a1c>)
 8007682:	4299      	cmp	r1, r3
 8007684:	d00b      	beq.n	800769e <HAL_DMA_IRQHandler+0x29b6>
 8007686:	687b      	ldr	r3, [r7, #4]
 8007688:	681b      	ldr	r3, [r3, #0]
 800768a:	4619      	mov	r1, r3
 800768c:	4b1e      	ldr	r3, [pc, #120]	; (8007708 <HAL_DMA_IRQHandler+0x2a20>)
 800768e:	4299      	cmp	r1, r3
 8007690:	d102      	bne.n	8007698 <HAL_DMA_IRQHandler+0x29b0>
 8007692:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007696:	e03a      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 8007698:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800769c:	e037      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 800769e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80076a2:	e034      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076a4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80076a8:	e031      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076aa:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80076ae:	e02e      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076b0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80076b4:	e02b      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076b6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80076ba:	e028      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076bc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80076c0:	e025      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076c2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80076c6:	e022      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076c8:	2320      	movs	r3, #32
 80076ca:	e020      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076cc:	2320      	movs	r3, #32
 80076ce:	e01e      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076d0:	2320      	movs	r3, #32
 80076d2:	e01c      	b.n	800770e <HAL_DMA_IRQHandler+0x2a26>
 80076d4:	40026058 	.word	0x40026058
 80076d8:	40026000 	.word	0x40026000
 80076dc:	40026010 	.word	0x40026010
 80076e0:	40026410 	.word	0x40026410
 80076e4:	40026070 	.word	0x40026070
 80076e8:	40026470 	.word	0x40026470
 80076ec:	40026028 	.word	0x40026028
 80076f0:	40026428 	.word	0x40026428
 80076f4:	40026088 	.word	0x40026088
 80076f8:	40026488 	.word	0x40026488
 80076fc:	40026040 	.word	0x40026040
 8007700:	40026440 	.word	0x40026440
 8007704:	400260a0 	.word	0x400260a0
 8007708:	400264a0 	.word	0x400264a0
 800770c:	2320      	movs	r3, #32
 800770e:	4013      	ands	r3, r2
 8007710:	2b00      	cmp	r3, #0
 8007712:	bf14      	ite	ne
 8007714:	2301      	movne	r3, #1
 8007716:	2300      	moveq	r3, #0
 8007718:	b2db      	uxtb	r3, r3
 800771a:	2b00      	cmp	r3, #0
 800771c:	f000 8445 	beq.w	8007faa <HAL_DMA_IRQHandler+0x32c2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8007720:	687b      	ldr	r3, [r7, #4]
 8007722:	681b      	ldr	r3, [r3, #0]
 8007724:	681b      	ldr	r3, [r3, #0]
 8007726:	f003 0310 	and.w	r3, r3, #16
 800772a:	2b00      	cmp	r3, #0
 800772c:	f000 843d 	beq.w	8007faa <HAL_DMA_IRQHandler+0x32c2>
    {
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 8007730:	687b      	ldr	r3, [r7, #4]
 8007732:	681b      	ldr	r3, [r3, #0]
 8007734:	681b      	ldr	r3, [r3, #0]
 8007736:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800773a:	2b00      	cmp	r3, #0
 800773c:	f000 820d 	beq.w	8007b5a <HAL_DMA_IRQHandler+0x2e72>
      {
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8007740:	687b      	ldr	r3, [r7, #4]
 8007742:	681b      	ldr	r3, [r3, #0]
 8007744:	461a      	mov	r2, r3
 8007746:	4ba0      	ldr	r3, [pc, #640]	; (80079c8 <HAL_DMA_IRQHandler+0x2ce0>)
 8007748:	429a      	cmp	r2, r3
 800774a:	d96c      	bls.n	8007826 <HAL_DMA_IRQHandler+0x2b3e>
 800774c:	4a9f      	ldr	r2, [pc, #636]	; (80079cc <HAL_DMA_IRQHandler+0x2ce4>)
 800774e:	687b      	ldr	r3, [r7, #4]
 8007750:	681b      	ldr	r3, [r3, #0]
 8007752:	4619      	mov	r1, r3
 8007754:	4b9e      	ldr	r3, [pc, #632]	; (80079d0 <HAL_DMA_IRQHandler+0x2ce8>)
 8007756:	4299      	cmp	r1, r3
 8007758:	d062      	beq.n	8007820 <HAL_DMA_IRQHandler+0x2b38>
 800775a:	687b      	ldr	r3, [r7, #4]
 800775c:	681b      	ldr	r3, [r3, #0]
 800775e:	4619      	mov	r1, r3
 8007760:	4b9c      	ldr	r3, [pc, #624]	; (80079d4 <HAL_DMA_IRQHandler+0x2cec>)
 8007762:	4299      	cmp	r1, r3
 8007764:	d05a      	beq.n	800781c <HAL_DMA_IRQHandler+0x2b34>
 8007766:	687b      	ldr	r3, [r7, #4]
 8007768:	681b      	ldr	r3, [r3, #0]
 800776a:	4619      	mov	r1, r3
 800776c:	4b9a      	ldr	r3, [pc, #616]	; (80079d8 <HAL_DMA_IRQHandler+0x2cf0>)
 800776e:	4299      	cmp	r1, r3
 8007770:	d052      	beq.n	8007818 <HAL_DMA_IRQHandler+0x2b30>
 8007772:	687b      	ldr	r3, [r7, #4]
 8007774:	681b      	ldr	r3, [r3, #0]
 8007776:	4619      	mov	r1, r3
 8007778:	4b98      	ldr	r3, [pc, #608]	; (80079dc <HAL_DMA_IRQHandler+0x2cf4>)
 800777a:	4299      	cmp	r1, r3
 800777c:	d04a      	beq.n	8007814 <HAL_DMA_IRQHandler+0x2b2c>
 800777e:	687b      	ldr	r3, [r7, #4]
 8007780:	681b      	ldr	r3, [r3, #0]
 8007782:	4619      	mov	r1, r3
 8007784:	4b96      	ldr	r3, [pc, #600]	; (80079e0 <HAL_DMA_IRQHandler+0x2cf8>)
 8007786:	4299      	cmp	r1, r3
 8007788:	d041      	beq.n	800780e <HAL_DMA_IRQHandler+0x2b26>
 800778a:	687b      	ldr	r3, [r7, #4]
 800778c:	681b      	ldr	r3, [r3, #0]
 800778e:	4619      	mov	r1, r3
 8007790:	4b94      	ldr	r3, [pc, #592]	; (80079e4 <HAL_DMA_IRQHandler+0x2cfc>)
 8007792:	4299      	cmp	r1, r3
 8007794:	d038      	beq.n	8007808 <HAL_DMA_IRQHandler+0x2b20>
 8007796:	687b      	ldr	r3, [r7, #4]
 8007798:	681b      	ldr	r3, [r3, #0]
 800779a:	4619      	mov	r1, r3
 800779c:	4b92      	ldr	r3, [pc, #584]	; (80079e8 <HAL_DMA_IRQHandler+0x2d00>)
 800779e:	4299      	cmp	r1, r3
 80077a0:	d02f      	beq.n	8007802 <HAL_DMA_IRQHandler+0x2b1a>
 80077a2:	687b      	ldr	r3, [r7, #4]
 80077a4:	681b      	ldr	r3, [r3, #0]
 80077a6:	4619      	mov	r1, r3
 80077a8:	4b90      	ldr	r3, [pc, #576]	; (80079ec <HAL_DMA_IRQHandler+0x2d04>)
 80077aa:	4299      	cmp	r1, r3
 80077ac:	d026      	beq.n	80077fc <HAL_DMA_IRQHandler+0x2b14>
 80077ae:	687b      	ldr	r3, [r7, #4]
 80077b0:	681b      	ldr	r3, [r3, #0]
 80077b2:	4619      	mov	r1, r3
 80077b4:	4b8e      	ldr	r3, [pc, #568]	; (80079f0 <HAL_DMA_IRQHandler+0x2d08>)
 80077b6:	4299      	cmp	r1, r3
 80077b8:	d01d      	beq.n	80077f6 <HAL_DMA_IRQHandler+0x2b0e>
 80077ba:	687b      	ldr	r3, [r7, #4]
 80077bc:	681b      	ldr	r3, [r3, #0]
 80077be:	4619      	mov	r1, r3
 80077c0:	4b8c      	ldr	r3, [pc, #560]	; (80079f4 <HAL_DMA_IRQHandler+0x2d0c>)
 80077c2:	4299      	cmp	r1, r3
 80077c4:	d014      	beq.n	80077f0 <HAL_DMA_IRQHandler+0x2b08>
 80077c6:	687b      	ldr	r3, [r7, #4]
 80077c8:	681b      	ldr	r3, [r3, #0]
 80077ca:	4619      	mov	r1, r3
 80077cc:	4b8a      	ldr	r3, [pc, #552]	; (80079f8 <HAL_DMA_IRQHandler+0x2d10>)
 80077ce:	4299      	cmp	r1, r3
 80077d0:	d00b      	beq.n	80077ea <HAL_DMA_IRQHandler+0x2b02>
 80077d2:	687b      	ldr	r3, [r7, #4]
 80077d4:	681b      	ldr	r3, [r3, #0]
 80077d6:	4619      	mov	r1, r3
 80077d8:	4b88      	ldr	r3, [pc, #544]	; (80079fc <HAL_DMA_IRQHandler+0x2d14>)
 80077da:	4299      	cmp	r1, r3
 80077dc:	d102      	bne.n	80077e4 <HAL_DMA_IRQHandler+0x2afc>
 80077de:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80077e2:	e01e      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 80077e4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80077e8:	e01b      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 80077ea:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80077ee:	e018      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 80077f0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80077f4:	e015      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 80077f6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80077fa:	e012      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 80077fc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007800:	e00f      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 8007802:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007806:	e00c      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 8007808:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800780c:	e009      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 800780e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007812:	e006      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 8007814:	2320      	movs	r3, #32
 8007816:	e004      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 8007818:	2320      	movs	r3, #32
 800781a:	e002      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 800781c:	2320      	movs	r3, #32
 800781e:	e000      	b.n	8007822 <HAL_DMA_IRQHandler+0x2b3a>
 8007820:	2320      	movs	r3, #32
 8007822:	60d3      	str	r3, [r2, #12]
 8007824:	e176      	b.n	8007b14 <HAL_DMA_IRQHandler+0x2e2c>
 8007826:	687b      	ldr	r3, [r7, #4]
 8007828:	681b      	ldr	r3, [r3, #0]
 800782a:	461a      	mov	r2, r3
 800782c:	4b74      	ldr	r3, [pc, #464]	; (8007a00 <HAL_DMA_IRQHandler+0x2d18>)
 800782e:	429a      	cmp	r2, r3
 8007830:	d96c      	bls.n	800790c <HAL_DMA_IRQHandler+0x2c24>
 8007832:	4a66      	ldr	r2, [pc, #408]	; (80079cc <HAL_DMA_IRQHandler+0x2ce4>)
 8007834:	687b      	ldr	r3, [r7, #4]
 8007836:	681b      	ldr	r3, [r3, #0]
 8007838:	4619      	mov	r1, r3
 800783a:	4b65      	ldr	r3, [pc, #404]	; (80079d0 <HAL_DMA_IRQHandler+0x2ce8>)
 800783c:	4299      	cmp	r1, r3
 800783e:	d062      	beq.n	8007906 <HAL_DMA_IRQHandler+0x2c1e>
 8007840:	687b      	ldr	r3, [r7, #4]
 8007842:	681b      	ldr	r3, [r3, #0]
 8007844:	4619      	mov	r1, r3
 8007846:	4b63      	ldr	r3, [pc, #396]	; (80079d4 <HAL_DMA_IRQHandler+0x2cec>)
 8007848:	4299      	cmp	r1, r3
 800784a:	d05a      	beq.n	8007902 <HAL_DMA_IRQHandler+0x2c1a>
 800784c:	687b      	ldr	r3, [r7, #4]
 800784e:	681b      	ldr	r3, [r3, #0]
 8007850:	4619      	mov	r1, r3
 8007852:	4b61      	ldr	r3, [pc, #388]	; (80079d8 <HAL_DMA_IRQHandler+0x2cf0>)
 8007854:	4299      	cmp	r1, r3
 8007856:	d052      	beq.n	80078fe <HAL_DMA_IRQHandler+0x2c16>
 8007858:	687b      	ldr	r3, [r7, #4]
 800785a:	681b      	ldr	r3, [r3, #0]
 800785c:	4619      	mov	r1, r3
 800785e:	4b5f      	ldr	r3, [pc, #380]	; (80079dc <HAL_DMA_IRQHandler+0x2cf4>)
 8007860:	4299      	cmp	r1, r3
 8007862:	d04a      	beq.n	80078fa <HAL_DMA_IRQHandler+0x2c12>
 8007864:	687b      	ldr	r3, [r7, #4]
 8007866:	681b      	ldr	r3, [r3, #0]
 8007868:	4619      	mov	r1, r3
 800786a:	4b5d      	ldr	r3, [pc, #372]	; (80079e0 <HAL_DMA_IRQHandler+0x2cf8>)
 800786c:	4299      	cmp	r1, r3
 800786e:	d041      	beq.n	80078f4 <HAL_DMA_IRQHandler+0x2c0c>
 8007870:	687b      	ldr	r3, [r7, #4]
 8007872:	681b      	ldr	r3, [r3, #0]
 8007874:	4619      	mov	r1, r3
 8007876:	4b5b      	ldr	r3, [pc, #364]	; (80079e4 <HAL_DMA_IRQHandler+0x2cfc>)
 8007878:	4299      	cmp	r1, r3
 800787a:	d038      	beq.n	80078ee <HAL_DMA_IRQHandler+0x2c06>
 800787c:	687b      	ldr	r3, [r7, #4]
 800787e:	681b      	ldr	r3, [r3, #0]
 8007880:	4619      	mov	r1, r3
 8007882:	4b59      	ldr	r3, [pc, #356]	; (80079e8 <HAL_DMA_IRQHandler+0x2d00>)
 8007884:	4299      	cmp	r1, r3
 8007886:	d02f      	beq.n	80078e8 <HAL_DMA_IRQHandler+0x2c00>
 8007888:	687b      	ldr	r3, [r7, #4]
 800788a:	681b      	ldr	r3, [r3, #0]
 800788c:	4619      	mov	r1, r3
 800788e:	4b57      	ldr	r3, [pc, #348]	; (80079ec <HAL_DMA_IRQHandler+0x2d04>)
 8007890:	4299      	cmp	r1, r3
 8007892:	d026      	beq.n	80078e2 <HAL_DMA_IRQHandler+0x2bfa>
 8007894:	687b      	ldr	r3, [r7, #4]
 8007896:	681b      	ldr	r3, [r3, #0]
 8007898:	4619      	mov	r1, r3
 800789a:	4b55      	ldr	r3, [pc, #340]	; (80079f0 <HAL_DMA_IRQHandler+0x2d08>)
 800789c:	4299      	cmp	r1, r3
 800789e:	d01d      	beq.n	80078dc <HAL_DMA_IRQHandler+0x2bf4>
 80078a0:	687b      	ldr	r3, [r7, #4]
 80078a2:	681b      	ldr	r3, [r3, #0]
 80078a4:	4619      	mov	r1, r3
 80078a6:	4b53      	ldr	r3, [pc, #332]	; (80079f4 <HAL_DMA_IRQHandler+0x2d0c>)
 80078a8:	4299      	cmp	r1, r3
 80078aa:	d014      	beq.n	80078d6 <HAL_DMA_IRQHandler+0x2bee>
 80078ac:	687b      	ldr	r3, [r7, #4]
 80078ae:	681b      	ldr	r3, [r3, #0]
 80078b0:	4619      	mov	r1, r3
 80078b2:	4b51      	ldr	r3, [pc, #324]	; (80079f8 <HAL_DMA_IRQHandler+0x2d10>)
 80078b4:	4299      	cmp	r1, r3
 80078b6:	d00b      	beq.n	80078d0 <HAL_DMA_IRQHandler+0x2be8>
 80078b8:	687b      	ldr	r3, [r7, #4]
 80078ba:	681b      	ldr	r3, [r3, #0]
 80078bc:	4619      	mov	r1, r3
 80078be:	4b4f      	ldr	r3, [pc, #316]	; (80079fc <HAL_DMA_IRQHandler+0x2d14>)
 80078c0:	4299      	cmp	r1, r3
 80078c2:	d102      	bne.n	80078ca <HAL_DMA_IRQHandler+0x2be2>
 80078c4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80078c8:	e01e      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078ca:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80078ce:	e01b      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078d0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80078d4:	e018      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078d6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80078da:	e015      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078dc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80078e0:	e012      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078e2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80078e6:	e00f      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078e8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80078ec:	e00c      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078ee:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80078f2:	e009      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078f4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80078f8:	e006      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078fa:	2320      	movs	r3, #32
 80078fc:	e004      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 80078fe:	2320      	movs	r3, #32
 8007900:	e002      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 8007902:	2320      	movs	r3, #32
 8007904:	e000      	b.n	8007908 <HAL_DMA_IRQHandler+0x2c20>
 8007906:	2320      	movs	r3, #32
 8007908:	6093      	str	r3, [r2, #8]
 800790a:	e103      	b.n	8007b14 <HAL_DMA_IRQHandler+0x2e2c>
 800790c:	687b      	ldr	r3, [r7, #4]
 800790e:	681b      	ldr	r3, [r3, #0]
 8007910:	461a      	mov	r2, r3
 8007912:	4b3c      	ldr	r3, [pc, #240]	; (8007a04 <HAL_DMA_IRQHandler+0x2d1c>)
 8007914:	429a      	cmp	r2, r3
 8007916:	f240 8091 	bls.w	8007a3c <HAL_DMA_IRQHandler+0x2d54>
 800791a:	4a3b      	ldr	r2, [pc, #236]	; (8007a08 <HAL_DMA_IRQHandler+0x2d20>)
 800791c:	687b      	ldr	r3, [r7, #4]
 800791e:	681b      	ldr	r3, [r3, #0]
 8007920:	4619      	mov	r1, r3
 8007922:	4b2b      	ldr	r3, [pc, #172]	; (80079d0 <HAL_DMA_IRQHandler+0x2ce8>)
 8007924:	4299      	cmp	r1, r3
 8007926:	f000 8086 	beq.w	8007a36 <HAL_DMA_IRQHandler+0x2d4e>
 800792a:	687b      	ldr	r3, [r7, #4]
 800792c:	681b      	ldr	r3, [r3, #0]
 800792e:	4619      	mov	r1, r3
 8007930:	4b28      	ldr	r3, [pc, #160]	; (80079d4 <HAL_DMA_IRQHandler+0x2cec>)
 8007932:	4299      	cmp	r1, r3
 8007934:	d07d      	beq.n	8007a32 <HAL_DMA_IRQHandler+0x2d4a>
 8007936:	687b      	ldr	r3, [r7, #4]
 8007938:	681b      	ldr	r3, [r3, #0]
 800793a:	4619      	mov	r1, r3
 800793c:	4b26      	ldr	r3, [pc, #152]	; (80079d8 <HAL_DMA_IRQHandler+0x2cf0>)
 800793e:	4299      	cmp	r1, r3
 8007940:	d075      	beq.n	8007a2e <HAL_DMA_IRQHandler+0x2d46>
 8007942:	687b      	ldr	r3, [r7, #4]
 8007944:	681b      	ldr	r3, [r3, #0]
 8007946:	4619      	mov	r1, r3
 8007948:	4b24      	ldr	r3, [pc, #144]	; (80079dc <HAL_DMA_IRQHandler+0x2cf4>)
 800794a:	4299      	cmp	r1, r3
 800794c:	d06d      	beq.n	8007a2a <HAL_DMA_IRQHandler+0x2d42>
 800794e:	687b      	ldr	r3, [r7, #4]
 8007950:	681b      	ldr	r3, [r3, #0]
 8007952:	4619      	mov	r1, r3
 8007954:	4b22      	ldr	r3, [pc, #136]	; (80079e0 <HAL_DMA_IRQHandler+0x2cf8>)
 8007956:	4299      	cmp	r1, r3
 8007958:	d064      	beq.n	8007a24 <HAL_DMA_IRQHandler+0x2d3c>
 800795a:	687b      	ldr	r3, [r7, #4]
 800795c:	681b      	ldr	r3, [r3, #0]
 800795e:	4619      	mov	r1, r3
 8007960:	4b20      	ldr	r3, [pc, #128]	; (80079e4 <HAL_DMA_IRQHandler+0x2cfc>)
 8007962:	4299      	cmp	r1, r3
 8007964:	d05b      	beq.n	8007a1e <HAL_DMA_IRQHandler+0x2d36>
 8007966:	687b      	ldr	r3, [r7, #4]
 8007968:	681b      	ldr	r3, [r3, #0]
 800796a:	4619      	mov	r1, r3
 800796c:	4b1e      	ldr	r3, [pc, #120]	; (80079e8 <HAL_DMA_IRQHandler+0x2d00>)
 800796e:	4299      	cmp	r1, r3
 8007970:	d052      	beq.n	8007a18 <HAL_DMA_IRQHandler+0x2d30>
 8007972:	687b      	ldr	r3, [r7, #4]
 8007974:	681b      	ldr	r3, [r3, #0]
 8007976:	4619      	mov	r1, r3
 8007978:	4b1c      	ldr	r3, [pc, #112]	; (80079ec <HAL_DMA_IRQHandler+0x2d04>)
 800797a:	4299      	cmp	r1, r3
 800797c:	d049      	beq.n	8007a12 <HAL_DMA_IRQHandler+0x2d2a>
 800797e:	687b      	ldr	r3, [r7, #4]
 8007980:	681b      	ldr	r3, [r3, #0]
 8007982:	4619      	mov	r1, r3
 8007984:	4b1a      	ldr	r3, [pc, #104]	; (80079f0 <HAL_DMA_IRQHandler+0x2d08>)
 8007986:	4299      	cmp	r1, r3
 8007988:	d040      	beq.n	8007a0c <HAL_DMA_IRQHandler+0x2d24>
 800798a:	687b      	ldr	r3, [r7, #4]
 800798c:	681b      	ldr	r3, [r3, #0]
 800798e:	4619      	mov	r1, r3
 8007990:	4b18      	ldr	r3, [pc, #96]	; (80079f4 <HAL_DMA_IRQHandler+0x2d0c>)
 8007992:	4299      	cmp	r1, r3
 8007994:	d014      	beq.n	80079c0 <HAL_DMA_IRQHandler+0x2cd8>
 8007996:	687b      	ldr	r3, [r7, #4]
 8007998:	681b      	ldr	r3, [r3, #0]
 800799a:	4619      	mov	r1, r3
 800799c:	4b16      	ldr	r3, [pc, #88]	; (80079f8 <HAL_DMA_IRQHandler+0x2d10>)
 800799e:	4299      	cmp	r1, r3
 80079a0:	d00b      	beq.n	80079ba <HAL_DMA_IRQHandler+0x2cd2>
 80079a2:	687b      	ldr	r3, [r7, #4]
 80079a4:	681b      	ldr	r3, [r3, #0]
 80079a6:	4619      	mov	r1, r3
 80079a8:	4b14      	ldr	r3, [pc, #80]	; (80079fc <HAL_DMA_IRQHandler+0x2d14>)
 80079aa:	4299      	cmp	r1, r3
 80079ac:	d102      	bne.n	80079b4 <HAL_DMA_IRQHandler+0x2ccc>
 80079ae:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80079b2:	e041      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 80079b4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80079b8:	e03e      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 80079ba:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80079be:	e03b      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 80079c0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80079c4:	e038      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 80079c6:	bf00      	nop
 80079c8:	40026458 	.word	0x40026458
 80079cc:	40026400 	.word	0x40026400
 80079d0:	40026010 	.word	0x40026010
 80079d4:	40026410 	.word	0x40026410
 80079d8:	40026070 	.word	0x40026070
 80079dc:	40026470 	.word	0x40026470
 80079e0:	40026028 	.word	0x40026028
 80079e4:	40026428 	.word	0x40026428
 80079e8:	40026088 	.word	0x40026088
 80079ec:	40026488 	.word	0x40026488
 80079f0:	40026040 	.word	0x40026040
 80079f4:	40026440 	.word	0x40026440
 80079f8:	400260a0 	.word	0x400260a0
 80079fc:	400264a0 	.word	0x400264a0
 8007a00:	400260b8 	.word	0x400260b8
 8007a04:	40026058 	.word	0x40026058
 8007a08:	40026000 	.word	0x40026000
 8007a0c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007a10:	e012      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 8007a12:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007a16:	e00f      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 8007a18:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007a1c:	e00c      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 8007a1e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007a22:	e009      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 8007a24:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007a28:	e006      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 8007a2a:	2320      	movs	r3, #32
 8007a2c:	e004      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 8007a2e:	2320      	movs	r3, #32
 8007a30:	e002      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 8007a32:	2320      	movs	r3, #32
 8007a34:	e000      	b.n	8007a38 <HAL_DMA_IRQHandler+0x2d50>
 8007a36:	2320      	movs	r3, #32
 8007a38:	60d3      	str	r3, [r2, #12]
 8007a3a:	e06b      	b.n	8007b14 <HAL_DMA_IRQHandler+0x2e2c>
 8007a3c:	4a88      	ldr	r2, [pc, #544]	; (8007c60 <HAL_DMA_IRQHandler+0x2f78>)
 8007a3e:	687b      	ldr	r3, [r7, #4]
 8007a40:	681b      	ldr	r3, [r3, #0]
 8007a42:	4619      	mov	r1, r3
 8007a44:	4b87      	ldr	r3, [pc, #540]	; (8007c64 <HAL_DMA_IRQHandler+0x2f7c>)
 8007a46:	4299      	cmp	r1, r3
 8007a48:	d062      	beq.n	8007b10 <HAL_DMA_IRQHandler+0x2e28>
 8007a4a:	687b      	ldr	r3, [r7, #4]
 8007a4c:	681b      	ldr	r3, [r3, #0]
 8007a4e:	4619      	mov	r1, r3
 8007a50:	4b85      	ldr	r3, [pc, #532]	; (8007c68 <HAL_DMA_IRQHandler+0x2f80>)
 8007a52:	4299      	cmp	r1, r3
 8007a54:	d05a      	beq.n	8007b0c <HAL_DMA_IRQHandler+0x2e24>
 8007a56:	687b      	ldr	r3, [r7, #4]
 8007a58:	681b      	ldr	r3, [r3, #0]
 8007a5a:	4619      	mov	r1, r3
 8007a5c:	4b83      	ldr	r3, [pc, #524]	; (8007c6c <HAL_DMA_IRQHandler+0x2f84>)
 8007a5e:	4299      	cmp	r1, r3
 8007a60:	d052      	beq.n	8007b08 <HAL_DMA_IRQHandler+0x2e20>
 8007a62:	687b      	ldr	r3, [r7, #4]
 8007a64:	681b      	ldr	r3, [r3, #0]
 8007a66:	4619      	mov	r1, r3
 8007a68:	4b81      	ldr	r3, [pc, #516]	; (8007c70 <HAL_DMA_IRQHandler+0x2f88>)
 8007a6a:	4299      	cmp	r1, r3
 8007a6c:	d04a      	beq.n	8007b04 <HAL_DMA_IRQHandler+0x2e1c>
 8007a6e:	687b      	ldr	r3, [r7, #4]
 8007a70:	681b      	ldr	r3, [r3, #0]
 8007a72:	4619      	mov	r1, r3
 8007a74:	4b7f      	ldr	r3, [pc, #508]	; (8007c74 <HAL_DMA_IRQHandler+0x2f8c>)
 8007a76:	4299      	cmp	r1, r3
 8007a78:	d041      	beq.n	8007afe <HAL_DMA_IRQHandler+0x2e16>
 8007a7a:	687b      	ldr	r3, [r7, #4]
 8007a7c:	681b      	ldr	r3, [r3, #0]
 8007a7e:	4619      	mov	r1, r3
 8007a80:	4b7d      	ldr	r3, [pc, #500]	; (8007c78 <HAL_DMA_IRQHandler+0x2f90>)
 8007a82:	4299      	cmp	r1, r3
 8007a84:	d038      	beq.n	8007af8 <HAL_DMA_IRQHandler+0x2e10>
 8007a86:	687b      	ldr	r3, [r7, #4]
 8007a88:	681b      	ldr	r3, [r3, #0]
 8007a8a:	4619      	mov	r1, r3
 8007a8c:	4b7b      	ldr	r3, [pc, #492]	; (8007c7c <HAL_DMA_IRQHandler+0x2f94>)
 8007a8e:	4299      	cmp	r1, r3
 8007a90:	d02f      	beq.n	8007af2 <HAL_DMA_IRQHandler+0x2e0a>
 8007a92:	687b      	ldr	r3, [r7, #4]
 8007a94:	681b      	ldr	r3, [r3, #0]
 8007a96:	4619      	mov	r1, r3
 8007a98:	4b79      	ldr	r3, [pc, #484]	; (8007c80 <HAL_DMA_IRQHandler+0x2f98>)
 8007a9a:	4299      	cmp	r1, r3
 8007a9c:	d026      	beq.n	8007aec <HAL_DMA_IRQHandler+0x2e04>
 8007a9e:	687b      	ldr	r3, [r7, #4]
 8007aa0:	681b      	ldr	r3, [r3, #0]
 8007aa2:	4619      	mov	r1, r3
 8007aa4:	4b77      	ldr	r3, [pc, #476]	; (8007c84 <HAL_DMA_IRQHandler+0x2f9c>)
 8007aa6:	4299      	cmp	r1, r3
 8007aa8:	d01d      	beq.n	8007ae6 <HAL_DMA_IRQHandler+0x2dfe>
 8007aaa:	687b      	ldr	r3, [r7, #4]
 8007aac:	681b      	ldr	r3, [r3, #0]
 8007aae:	4619      	mov	r1, r3
 8007ab0:	4b75      	ldr	r3, [pc, #468]	; (8007c88 <HAL_DMA_IRQHandler+0x2fa0>)
 8007ab2:	4299      	cmp	r1, r3
 8007ab4:	d014      	beq.n	8007ae0 <HAL_DMA_IRQHandler+0x2df8>
 8007ab6:	687b      	ldr	r3, [r7, #4]
 8007ab8:	681b      	ldr	r3, [r3, #0]
 8007aba:	4619      	mov	r1, r3
 8007abc:	4b73      	ldr	r3, [pc, #460]	; (8007c8c <HAL_DMA_IRQHandler+0x2fa4>)
 8007abe:	4299      	cmp	r1, r3
 8007ac0:	d00b      	beq.n	8007ada <HAL_DMA_IRQHandler+0x2df2>
 8007ac2:	687b      	ldr	r3, [r7, #4]
 8007ac4:	681b      	ldr	r3, [r3, #0]
 8007ac6:	4619      	mov	r1, r3
 8007ac8:	4b71      	ldr	r3, [pc, #452]	; (8007c90 <HAL_DMA_IRQHandler+0x2fa8>)
 8007aca:	4299      	cmp	r1, r3
 8007acc:	d102      	bne.n	8007ad4 <HAL_DMA_IRQHandler+0x2dec>
 8007ace:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007ad2:	e01e      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007ad4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007ad8:	e01b      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007ada:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007ade:	e018      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007ae0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007ae4:	e015      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007ae6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007aea:	e012      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007aec:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007af0:	e00f      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007af2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007af6:	e00c      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007af8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007afc:	e009      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007afe:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007b02:	e006      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007b04:	2320      	movs	r3, #32
 8007b06:	e004      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007b08:	2320      	movs	r3, #32
 8007b0a:	e002      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007b0c:	2320      	movs	r3, #32
 8007b0e:	e000      	b.n	8007b12 <HAL_DMA_IRQHandler+0x2e2a>
 8007b10:	2320      	movs	r3, #32
 8007b12:	6093      	str	r3, [r2, #8]

        /* Current memory buffer used is Memory 1 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8007b14:	687b      	ldr	r3, [r7, #4]
 8007b16:	681b      	ldr	r3, [r3, #0]
 8007b18:	681b      	ldr	r3, [r3, #0]
 8007b1a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8007b1e:	2b00      	cmp	r3, #0
 8007b20:	d109      	bne.n	8007b36 <HAL_DMA_IRQHandler+0x2e4e>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8007b22:	687b      	ldr	r3, [r7, #4]
 8007b24:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b26:	2b00      	cmp	r3, #0
 8007b28:	f000 823f 	beq.w	8007faa <HAL_DMA_IRQHandler+0x32c2>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 8007b2c:	687b      	ldr	r3, [r7, #4]
 8007b2e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b30:	6878      	ldr	r0, [r7, #4]
 8007b32:	4798      	blx	r3
 8007b34:	e239      	b.n	8007faa <HAL_DMA_IRQHandler+0x32c2>
          }
        }
        /* Current memory buffer used is Memory 0 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0) 
 8007b36:	687b      	ldr	r3, [r7, #4]
 8007b38:	681b      	ldr	r3, [r3, #0]
 8007b3a:	681b      	ldr	r3, [r3, #0]
 8007b3c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8007b40:	2b00      	cmp	r3, #0
 8007b42:	f000 8232 	beq.w	8007faa <HAL_DMA_IRQHandler+0x32c2>
        {
          if(hdma->XferCpltCallback != NULL)
 8007b46:	687b      	ldr	r3, [r7, #4]
 8007b48:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007b4a:	2b00      	cmp	r3, #0
 8007b4c:	f000 822d 	beq.w	8007faa <HAL_DMA_IRQHandler+0x32c2>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 8007b50:	687b      	ldr	r3, [r7, #4]
 8007b52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007b54:	6878      	ldr	r0, [r7, #4]
 8007b56:	4798      	blx	r3
 8007b58:	e227      	b.n	8007faa <HAL_DMA_IRQHandler+0x32c2>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8007b5a:	687b      	ldr	r3, [r7, #4]
 8007b5c:	681b      	ldr	r3, [r3, #0]
 8007b5e:	681b      	ldr	r3, [r3, #0]
 8007b60:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8007b64:	2b00      	cmp	r3, #0
 8007b66:	d107      	bne.n	8007b78 <HAL_DMA_IRQHandler+0x2e90>
        {
          /* Disable the transfer complete interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 8007b68:	687b      	ldr	r3, [r7, #4]
 8007b6a:	681b      	ldr	r3, [r3, #0]
 8007b6c:	687a      	ldr	r2, [r7, #4]
 8007b6e:	6812      	ldr	r2, [r2, #0]
 8007b70:	6812      	ldr	r2, [r2, #0]
 8007b72:	f022 0210 	bic.w	r2, r2, #16
 8007b76:	601a      	str	r2, [r3, #0]
        }
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8007b78:	687b      	ldr	r3, [r7, #4]
 8007b7a:	681b      	ldr	r3, [r3, #0]
 8007b7c:	461a      	mov	r2, r3
 8007b7e:	4b45      	ldr	r3, [pc, #276]	; (8007c94 <HAL_DMA_IRQHandler+0x2fac>)
 8007b80:	429a      	cmp	r2, r3
 8007b82:	f240 808b 	bls.w	8007c9c <HAL_DMA_IRQHandler+0x2fb4>
 8007b86:	4a44      	ldr	r2, [pc, #272]	; (8007c98 <HAL_DMA_IRQHandler+0x2fb0>)
 8007b88:	687b      	ldr	r3, [r7, #4]
 8007b8a:	681b      	ldr	r3, [r3, #0]
 8007b8c:	4619      	mov	r1, r3
 8007b8e:	4b35      	ldr	r3, [pc, #212]	; (8007c64 <HAL_DMA_IRQHandler+0x2f7c>)
 8007b90:	4299      	cmp	r1, r3
 8007b92:	d062      	beq.n	8007c5a <HAL_DMA_IRQHandler+0x2f72>
 8007b94:	687b      	ldr	r3, [r7, #4]
 8007b96:	681b      	ldr	r3, [r3, #0]
 8007b98:	4619      	mov	r1, r3
 8007b9a:	4b33      	ldr	r3, [pc, #204]	; (8007c68 <HAL_DMA_IRQHandler+0x2f80>)
 8007b9c:	4299      	cmp	r1, r3
 8007b9e:	d05a      	beq.n	8007c56 <HAL_DMA_IRQHandler+0x2f6e>
 8007ba0:	687b      	ldr	r3, [r7, #4]
 8007ba2:	681b      	ldr	r3, [r3, #0]
 8007ba4:	4619      	mov	r1, r3
 8007ba6:	4b31      	ldr	r3, [pc, #196]	; (8007c6c <HAL_DMA_IRQHandler+0x2f84>)
 8007ba8:	4299      	cmp	r1, r3
 8007baa:	d052      	beq.n	8007c52 <HAL_DMA_IRQHandler+0x2f6a>
 8007bac:	687b      	ldr	r3, [r7, #4]
 8007bae:	681b      	ldr	r3, [r3, #0]
 8007bb0:	4619      	mov	r1, r3
 8007bb2:	4b2f      	ldr	r3, [pc, #188]	; (8007c70 <HAL_DMA_IRQHandler+0x2f88>)
 8007bb4:	4299      	cmp	r1, r3
 8007bb6:	d04a      	beq.n	8007c4e <HAL_DMA_IRQHandler+0x2f66>
 8007bb8:	687b      	ldr	r3, [r7, #4]
 8007bba:	681b      	ldr	r3, [r3, #0]
 8007bbc:	4619      	mov	r1, r3
 8007bbe:	4b2d      	ldr	r3, [pc, #180]	; (8007c74 <HAL_DMA_IRQHandler+0x2f8c>)
 8007bc0:	4299      	cmp	r1, r3
 8007bc2:	d041      	beq.n	8007c48 <HAL_DMA_IRQHandler+0x2f60>
 8007bc4:	687b      	ldr	r3, [r7, #4]
 8007bc6:	681b      	ldr	r3, [r3, #0]
 8007bc8:	4619      	mov	r1, r3
 8007bca:	4b2b      	ldr	r3, [pc, #172]	; (8007c78 <HAL_DMA_IRQHandler+0x2f90>)
 8007bcc:	4299      	cmp	r1, r3
 8007bce:	d038      	beq.n	8007c42 <HAL_DMA_IRQHandler+0x2f5a>
 8007bd0:	687b      	ldr	r3, [r7, #4]
 8007bd2:	681b      	ldr	r3, [r3, #0]
 8007bd4:	4619      	mov	r1, r3
 8007bd6:	4b29      	ldr	r3, [pc, #164]	; (8007c7c <HAL_DMA_IRQHandler+0x2f94>)
 8007bd8:	4299      	cmp	r1, r3
 8007bda:	d02f      	beq.n	8007c3c <HAL_DMA_IRQHandler+0x2f54>
 8007bdc:	687b      	ldr	r3, [r7, #4]
 8007bde:	681b      	ldr	r3, [r3, #0]
 8007be0:	4619      	mov	r1, r3
 8007be2:	4b27      	ldr	r3, [pc, #156]	; (8007c80 <HAL_DMA_IRQHandler+0x2f98>)
 8007be4:	4299      	cmp	r1, r3
 8007be6:	d026      	beq.n	8007c36 <HAL_DMA_IRQHandler+0x2f4e>
 8007be8:	687b      	ldr	r3, [r7, #4]
 8007bea:	681b      	ldr	r3, [r3, #0]
 8007bec:	4619      	mov	r1, r3
 8007bee:	4b25      	ldr	r3, [pc, #148]	; (8007c84 <HAL_DMA_IRQHandler+0x2f9c>)
 8007bf0:	4299      	cmp	r1, r3
 8007bf2:	d01d      	beq.n	8007c30 <HAL_DMA_IRQHandler+0x2f48>
 8007bf4:	687b      	ldr	r3, [r7, #4]
 8007bf6:	681b      	ldr	r3, [r3, #0]
 8007bf8:	4619      	mov	r1, r3
 8007bfa:	4b23      	ldr	r3, [pc, #140]	; (8007c88 <HAL_DMA_IRQHandler+0x2fa0>)
 8007bfc:	4299      	cmp	r1, r3
 8007bfe:	d014      	beq.n	8007c2a <HAL_DMA_IRQHandler+0x2f42>
 8007c00:	687b      	ldr	r3, [r7, #4]
 8007c02:	681b      	ldr	r3, [r3, #0]
 8007c04:	4619      	mov	r1, r3
 8007c06:	4b21      	ldr	r3, [pc, #132]	; (8007c8c <HAL_DMA_IRQHandler+0x2fa4>)
 8007c08:	4299      	cmp	r1, r3
 8007c0a:	d00b      	beq.n	8007c24 <HAL_DMA_IRQHandler+0x2f3c>
 8007c0c:	687b      	ldr	r3, [r7, #4]
 8007c0e:	681b      	ldr	r3, [r3, #0]
 8007c10:	4619      	mov	r1, r3
 8007c12:	4b1f      	ldr	r3, [pc, #124]	; (8007c90 <HAL_DMA_IRQHandler+0x2fa8>)
 8007c14:	4299      	cmp	r1, r3
 8007c16:	d102      	bne.n	8007c1e <HAL_DMA_IRQHandler+0x2f36>
 8007c18:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007c1c:	e01e      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c1e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007c22:	e01b      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c24:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007c28:	e018      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c2a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007c2e:	e015      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c30:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007c34:	e012      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c36:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007c3a:	e00f      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c3c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007c40:	e00c      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c42:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007c46:	e009      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c48:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007c4c:	e006      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c4e:	2320      	movs	r3, #32
 8007c50:	e004      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c52:	2320      	movs	r3, #32
 8007c54:	e002      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c56:	2320      	movs	r3, #32
 8007c58:	e000      	b.n	8007c5c <HAL_DMA_IRQHandler+0x2f74>
 8007c5a:	2320      	movs	r3, #32
 8007c5c:	60d3      	str	r3, [r2, #12]
 8007c5e:	e190      	b.n	8007f82 <HAL_DMA_IRQHandler+0x329a>
 8007c60:	40026000 	.word	0x40026000
 8007c64:	40026010 	.word	0x40026010
 8007c68:	40026410 	.word	0x40026410
 8007c6c:	40026070 	.word	0x40026070
 8007c70:	40026470 	.word	0x40026470
 8007c74:	40026028 	.word	0x40026028
 8007c78:	40026428 	.word	0x40026428
 8007c7c:	40026088 	.word	0x40026088
 8007c80:	40026488 	.word	0x40026488
 8007c84:	40026040 	.word	0x40026040
 8007c88:	40026440 	.word	0x40026440
 8007c8c:	400260a0 	.word	0x400260a0
 8007c90:	400264a0 	.word	0x400264a0
 8007c94:	40026458 	.word	0x40026458
 8007c98:	40026400 	.word	0x40026400
 8007c9c:	687b      	ldr	r3, [r7, #4]
 8007c9e:	681b      	ldr	r3, [r3, #0]
 8007ca0:	461a      	mov	r2, r3
 8007ca2:	4b9f      	ldr	r3, [pc, #636]	; (8007f20 <HAL_DMA_IRQHandler+0x3238>)
 8007ca4:	429a      	cmp	r2, r3
 8007ca6:	d96c      	bls.n	8007d82 <HAL_DMA_IRQHandler+0x309a>
 8007ca8:	4a9e      	ldr	r2, [pc, #632]	; (8007f24 <HAL_DMA_IRQHandler+0x323c>)
 8007caa:	687b      	ldr	r3, [r7, #4]
 8007cac:	681b      	ldr	r3, [r3, #0]
 8007cae:	4619      	mov	r1, r3
 8007cb0:	4b9d      	ldr	r3, [pc, #628]	; (8007f28 <HAL_DMA_IRQHandler+0x3240>)
 8007cb2:	4299      	cmp	r1, r3
 8007cb4:	d062      	beq.n	8007d7c <HAL_DMA_IRQHandler+0x3094>
 8007cb6:	687b      	ldr	r3, [r7, #4]
 8007cb8:	681b      	ldr	r3, [r3, #0]
 8007cba:	4619      	mov	r1, r3
 8007cbc:	4b9b      	ldr	r3, [pc, #620]	; (8007f2c <HAL_DMA_IRQHandler+0x3244>)
 8007cbe:	4299      	cmp	r1, r3
 8007cc0:	d05a      	beq.n	8007d78 <HAL_DMA_IRQHandler+0x3090>
 8007cc2:	687b      	ldr	r3, [r7, #4]
 8007cc4:	681b      	ldr	r3, [r3, #0]
 8007cc6:	4619      	mov	r1, r3
 8007cc8:	4b99      	ldr	r3, [pc, #612]	; (8007f30 <HAL_DMA_IRQHandler+0x3248>)
 8007cca:	4299      	cmp	r1, r3
 8007ccc:	d052      	beq.n	8007d74 <HAL_DMA_IRQHandler+0x308c>
 8007cce:	687b      	ldr	r3, [r7, #4]
 8007cd0:	681b      	ldr	r3, [r3, #0]
 8007cd2:	4619      	mov	r1, r3
 8007cd4:	4b97      	ldr	r3, [pc, #604]	; (8007f34 <HAL_DMA_IRQHandler+0x324c>)
 8007cd6:	4299      	cmp	r1, r3
 8007cd8:	d04a      	beq.n	8007d70 <HAL_DMA_IRQHandler+0x3088>
 8007cda:	687b      	ldr	r3, [r7, #4]
 8007cdc:	681b      	ldr	r3, [r3, #0]
 8007cde:	4619      	mov	r1, r3
 8007ce0:	4b95      	ldr	r3, [pc, #596]	; (8007f38 <HAL_DMA_IRQHandler+0x3250>)
 8007ce2:	4299      	cmp	r1, r3
 8007ce4:	d041      	beq.n	8007d6a <HAL_DMA_IRQHandler+0x3082>
 8007ce6:	687b      	ldr	r3, [r7, #4]
 8007ce8:	681b      	ldr	r3, [r3, #0]
 8007cea:	4619      	mov	r1, r3
 8007cec:	4b93      	ldr	r3, [pc, #588]	; (8007f3c <HAL_DMA_IRQHandler+0x3254>)
 8007cee:	4299      	cmp	r1, r3
 8007cf0:	d038      	beq.n	8007d64 <HAL_DMA_IRQHandler+0x307c>
 8007cf2:	687b      	ldr	r3, [r7, #4]
 8007cf4:	681b      	ldr	r3, [r3, #0]
 8007cf6:	4619      	mov	r1, r3
 8007cf8:	4b91      	ldr	r3, [pc, #580]	; (8007f40 <HAL_DMA_IRQHandler+0x3258>)
 8007cfa:	4299      	cmp	r1, r3
 8007cfc:	d02f      	beq.n	8007d5e <HAL_DMA_IRQHandler+0x3076>
 8007cfe:	687b      	ldr	r3, [r7, #4]
 8007d00:	681b      	ldr	r3, [r3, #0]
 8007d02:	4619      	mov	r1, r3
 8007d04:	4b8f      	ldr	r3, [pc, #572]	; (8007f44 <HAL_DMA_IRQHandler+0x325c>)
 8007d06:	4299      	cmp	r1, r3
 8007d08:	d026      	beq.n	8007d58 <HAL_DMA_IRQHandler+0x3070>
 8007d0a:	687b      	ldr	r3, [r7, #4]
 8007d0c:	681b      	ldr	r3, [r3, #0]
 8007d0e:	4619      	mov	r1, r3
 8007d10:	4b8d      	ldr	r3, [pc, #564]	; (8007f48 <HAL_DMA_IRQHandler+0x3260>)
 8007d12:	4299      	cmp	r1, r3
 8007d14:	d01d      	beq.n	8007d52 <HAL_DMA_IRQHandler+0x306a>
 8007d16:	687b      	ldr	r3, [r7, #4]
 8007d18:	681b      	ldr	r3, [r3, #0]
 8007d1a:	4619      	mov	r1, r3
 8007d1c:	4b8b      	ldr	r3, [pc, #556]	; (8007f4c <HAL_DMA_IRQHandler+0x3264>)
 8007d1e:	4299      	cmp	r1, r3
 8007d20:	d014      	beq.n	8007d4c <HAL_DMA_IRQHandler+0x3064>
 8007d22:	687b      	ldr	r3, [r7, #4]
 8007d24:	681b      	ldr	r3, [r3, #0]
 8007d26:	4619      	mov	r1, r3
 8007d28:	4b89      	ldr	r3, [pc, #548]	; (8007f50 <HAL_DMA_IRQHandler+0x3268>)
 8007d2a:	4299      	cmp	r1, r3
 8007d2c:	d00b      	beq.n	8007d46 <HAL_DMA_IRQHandler+0x305e>
 8007d2e:	687b      	ldr	r3, [r7, #4]
 8007d30:	681b      	ldr	r3, [r3, #0]
 8007d32:	4619      	mov	r1, r3
 8007d34:	4b87      	ldr	r3, [pc, #540]	; (8007f54 <HAL_DMA_IRQHandler+0x326c>)
 8007d36:	4299      	cmp	r1, r3
 8007d38:	d102      	bne.n	8007d40 <HAL_DMA_IRQHandler+0x3058>
 8007d3a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007d3e:	e01e      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d40:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007d44:	e01b      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d46:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007d4a:	e018      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d4c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007d50:	e015      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d52:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007d56:	e012      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d58:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007d5c:	e00f      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d5e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007d62:	e00c      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d64:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007d68:	e009      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d6a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007d6e:	e006      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d70:	2320      	movs	r3, #32
 8007d72:	e004      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d74:	2320      	movs	r3, #32
 8007d76:	e002      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d78:	2320      	movs	r3, #32
 8007d7a:	e000      	b.n	8007d7e <HAL_DMA_IRQHandler+0x3096>
 8007d7c:	2320      	movs	r3, #32
 8007d7e:	6093      	str	r3, [r2, #8]
 8007d80:	e0ff      	b.n	8007f82 <HAL_DMA_IRQHandler+0x329a>
 8007d82:	687b      	ldr	r3, [r7, #4]
 8007d84:	681b      	ldr	r3, [r3, #0]
 8007d86:	461a      	mov	r2, r3
 8007d88:	4b73      	ldr	r3, [pc, #460]	; (8007f58 <HAL_DMA_IRQHandler+0x3270>)
 8007d8a:	429a      	cmp	r2, r3
 8007d8c:	d96c      	bls.n	8007e68 <HAL_DMA_IRQHandler+0x3180>
 8007d8e:	4a73      	ldr	r2, [pc, #460]	; (8007f5c <HAL_DMA_IRQHandler+0x3274>)
 8007d90:	687b      	ldr	r3, [r7, #4]
 8007d92:	681b      	ldr	r3, [r3, #0]
 8007d94:	4619      	mov	r1, r3
 8007d96:	4b64      	ldr	r3, [pc, #400]	; (8007f28 <HAL_DMA_IRQHandler+0x3240>)
 8007d98:	4299      	cmp	r1, r3
 8007d9a:	d062      	beq.n	8007e62 <HAL_DMA_IRQHandler+0x317a>
 8007d9c:	687b      	ldr	r3, [r7, #4]
 8007d9e:	681b      	ldr	r3, [r3, #0]
 8007da0:	4619      	mov	r1, r3
 8007da2:	4b62      	ldr	r3, [pc, #392]	; (8007f2c <HAL_DMA_IRQHandler+0x3244>)
 8007da4:	4299      	cmp	r1, r3
 8007da6:	d05a      	beq.n	8007e5e <HAL_DMA_IRQHandler+0x3176>
 8007da8:	687b      	ldr	r3, [r7, #4]
 8007daa:	681b      	ldr	r3, [r3, #0]
 8007dac:	4619      	mov	r1, r3
 8007dae:	4b60      	ldr	r3, [pc, #384]	; (8007f30 <HAL_DMA_IRQHandler+0x3248>)
 8007db0:	4299      	cmp	r1, r3
 8007db2:	d052      	beq.n	8007e5a <HAL_DMA_IRQHandler+0x3172>
 8007db4:	687b      	ldr	r3, [r7, #4]
 8007db6:	681b      	ldr	r3, [r3, #0]
 8007db8:	4619      	mov	r1, r3
 8007dba:	4b5e      	ldr	r3, [pc, #376]	; (8007f34 <HAL_DMA_IRQHandler+0x324c>)
 8007dbc:	4299      	cmp	r1, r3
 8007dbe:	d04a      	beq.n	8007e56 <HAL_DMA_IRQHandler+0x316e>
 8007dc0:	687b      	ldr	r3, [r7, #4]
 8007dc2:	681b      	ldr	r3, [r3, #0]
 8007dc4:	4619      	mov	r1, r3
 8007dc6:	4b5c      	ldr	r3, [pc, #368]	; (8007f38 <HAL_DMA_IRQHandler+0x3250>)
 8007dc8:	4299      	cmp	r1, r3
 8007dca:	d041      	beq.n	8007e50 <HAL_DMA_IRQHandler+0x3168>
 8007dcc:	687b      	ldr	r3, [r7, #4]
 8007dce:	681b      	ldr	r3, [r3, #0]
 8007dd0:	4619      	mov	r1, r3
 8007dd2:	4b5a      	ldr	r3, [pc, #360]	; (8007f3c <HAL_DMA_IRQHandler+0x3254>)
 8007dd4:	4299      	cmp	r1, r3
 8007dd6:	d038      	beq.n	8007e4a <HAL_DMA_IRQHandler+0x3162>
 8007dd8:	687b      	ldr	r3, [r7, #4]
 8007dda:	681b      	ldr	r3, [r3, #0]
 8007ddc:	4619      	mov	r1, r3
 8007dde:	4b58      	ldr	r3, [pc, #352]	; (8007f40 <HAL_DMA_IRQHandler+0x3258>)
 8007de0:	4299      	cmp	r1, r3
 8007de2:	d02f      	beq.n	8007e44 <HAL_DMA_IRQHandler+0x315c>
 8007de4:	687b      	ldr	r3, [r7, #4]
 8007de6:	681b      	ldr	r3, [r3, #0]
 8007de8:	4619      	mov	r1, r3
 8007dea:	4b56      	ldr	r3, [pc, #344]	; (8007f44 <HAL_DMA_IRQHandler+0x325c>)
 8007dec:	4299      	cmp	r1, r3
 8007dee:	d026      	beq.n	8007e3e <HAL_DMA_IRQHandler+0x3156>
 8007df0:	687b      	ldr	r3, [r7, #4]
 8007df2:	681b      	ldr	r3, [r3, #0]
 8007df4:	4619      	mov	r1, r3
 8007df6:	4b54      	ldr	r3, [pc, #336]	; (8007f48 <HAL_DMA_IRQHandler+0x3260>)
 8007df8:	4299      	cmp	r1, r3
 8007dfa:	d01d      	beq.n	8007e38 <HAL_DMA_IRQHandler+0x3150>
 8007dfc:	687b      	ldr	r3, [r7, #4]
 8007dfe:	681b      	ldr	r3, [r3, #0]
 8007e00:	4619      	mov	r1, r3
 8007e02:	4b52      	ldr	r3, [pc, #328]	; (8007f4c <HAL_DMA_IRQHandler+0x3264>)
 8007e04:	4299      	cmp	r1, r3
 8007e06:	d014      	beq.n	8007e32 <HAL_DMA_IRQHandler+0x314a>
 8007e08:	687b      	ldr	r3, [r7, #4]
 8007e0a:	681b      	ldr	r3, [r3, #0]
 8007e0c:	4619      	mov	r1, r3
 8007e0e:	4b50      	ldr	r3, [pc, #320]	; (8007f50 <HAL_DMA_IRQHandler+0x3268>)
 8007e10:	4299      	cmp	r1, r3
 8007e12:	d00b      	beq.n	8007e2c <HAL_DMA_IRQHandler+0x3144>
 8007e14:	687b      	ldr	r3, [r7, #4]
 8007e16:	681b      	ldr	r3, [r3, #0]
 8007e18:	4619      	mov	r1, r3
 8007e1a:	4b4e      	ldr	r3, [pc, #312]	; (8007f54 <HAL_DMA_IRQHandler+0x326c>)
 8007e1c:	4299      	cmp	r1, r3
 8007e1e:	d102      	bne.n	8007e26 <HAL_DMA_IRQHandler+0x313e>
 8007e20:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007e24:	e01e      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e26:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007e2a:	e01b      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e2c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007e30:	e018      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e32:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007e36:	e015      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e38:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007e3c:	e012      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e3e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007e42:	e00f      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e44:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007e48:	e00c      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e4a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007e4e:	e009      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e50:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007e54:	e006      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e56:	2320      	movs	r3, #32
 8007e58:	e004      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e5a:	2320      	movs	r3, #32
 8007e5c:	e002      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e5e:	2320      	movs	r3, #32
 8007e60:	e000      	b.n	8007e64 <HAL_DMA_IRQHandler+0x317c>
 8007e62:	2320      	movs	r3, #32
 8007e64:	60d3      	str	r3, [r2, #12]
 8007e66:	e08c      	b.n	8007f82 <HAL_DMA_IRQHandler+0x329a>
 8007e68:	4a3c      	ldr	r2, [pc, #240]	; (8007f5c <HAL_DMA_IRQHandler+0x3274>)
 8007e6a:	687b      	ldr	r3, [r7, #4]
 8007e6c:	681b      	ldr	r3, [r3, #0]
 8007e6e:	4619      	mov	r1, r3
 8007e70:	4b2d      	ldr	r3, [pc, #180]	; (8007f28 <HAL_DMA_IRQHandler+0x3240>)
 8007e72:	4299      	cmp	r1, r3
 8007e74:	f000 8083 	beq.w	8007f7e <HAL_DMA_IRQHandler+0x3296>
 8007e78:	687b      	ldr	r3, [r7, #4]
 8007e7a:	681b      	ldr	r3, [r3, #0]
 8007e7c:	4619      	mov	r1, r3
 8007e7e:	4b2b      	ldr	r3, [pc, #172]	; (8007f2c <HAL_DMA_IRQHandler+0x3244>)
 8007e80:	4299      	cmp	r1, r3
 8007e82:	d07a      	beq.n	8007f7a <HAL_DMA_IRQHandler+0x3292>
 8007e84:	687b      	ldr	r3, [r7, #4]
 8007e86:	681b      	ldr	r3, [r3, #0]
 8007e88:	4619      	mov	r1, r3
 8007e8a:	4b29      	ldr	r3, [pc, #164]	; (8007f30 <HAL_DMA_IRQHandler+0x3248>)
 8007e8c:	4299      	cmp	r1, r3
 8007e8e:	d072      	beq.n	8007f76 <HAL_DMA_IRQHandler+0x328e>
 8007e90:	687b      	ldr	r3, [r7, #4]
 8007e92:	681b      	ldr	r3, [r3, #0]
 8007e94:	4619      	mov	r1, r3
 8007e96:	4b27      	ldr	r3, [pc, #156]	; (8007f34 <HAL_DMA_IRQHandler+0x324c>)
 8007e98:	4299      	cmp	r1, r3
 8007e9a:	d06a      	beq.n	8007f72 <HAL_DMA_IRQHandler+0x328a>
 8007e9c:	687b      	ldr	r3, [r7, #4]
 8007e9e:	681b      	ldr	r3, [r3, #0]
 8007ea0:	4619      	mov	r1, r3
 8007ea2:	4b25      	ldr	r3, [pc, #148]	; (8007f38 <HAL_DMA_IRQHandler+0x3250>)
 8007ea4:	4299      	cmp	r1, r3
 8007ea6:	d061      	beq.n	8007f6c <HAL_DMA_IRQHandler+0x3284>
 8007ea8:	687b      	ldr	r3, [r7, #4]
 8007eaa:	681b      	ldr	r3, [r3, #0]
 8007eac:	4619      	mov	r1, r3
 8007eae:	4b23      	ldr	r3, [pc, #140]	; (8007f3c <HAL_DMA_IRQHandler+0x3254>)
 8007eb0:	4299      	cmp	r1, r3
 8007eb2:	d058      	beq.n	8007f66 <HAL_DMA_IRQHandler+0x327e>
 8007eb4:	687b      	ldr	r3, [r7, #4]
 8007eb6:	681b      	ldr	r3, [r3, #0]
 8007eb8:	4619      	mov	r1, r3
 8007eba:	4b21      	ldr	r3, [pc, #132]	; (8007f40 <HAL_DMA_IRQHandler+0x3258>)
 8007ebc:	4299      	cmp	r1, r3
 8007ebe:	d04f      	beq.n	8007f60 <HAL_DMA_IRQHandler+0x3278>
 8007ec0:	687b      	ldr	r3, [r7, #4]
 8007ec2:	681b      	ldr	r3, [r3, #0]
 8007ec4:	4619      	mov	r1, r3
 8007ec6:	4b1f      	ldr	r3, [pc, #124]	; (8007f44 <HAL_DMA_IRQHandler+0x325c>)
 8007ec8:	4299      	cmp	r1, r3
 8007eca:	d026      	beq.n	8007f1a <HAL_DMA_IRQHandler+0x3232>
 8007ecc:	687b      	ldr	r3, [r7, #4]
 8007ece:	681b      	ldr	r3, [r3, #0]
 8007ed0:	4619      	mov	r1, r3
 8007ed2:	4b1d      	ldr	r3, [pc, #116]	; (8007f48 <HAL_DMA_IRQHandler+0x3260>)
 8007ed4:	4299      	cmp	r1, r3
 8007ed6:	d01d      	beq.n	8007f14 <HAL_DMA_IRQHandler+0x322c>
 8007ed8:	687b      	ldr	r3, [r7, #4]
 8007eda:	681b      	ldr	r3, [r3, #0]
 8007edc:	4619      	mov	r1, r3
 8007ede:	4b1b      	ldr	r3, [pc, #108]	; (8007f4c <HAL_DMA_IRQHandler+0x3264>)
 8007ee0:	4299      	cmp	r1, r3
 8007ee2:	d014      	beq.n	8007f0e <HAL_DMA_IRQHandler+0x3226>
 8007ee4:	687b      	ldr	r3, [r7, #4]
 8007ee6:	681b      	ldr	r3, [r3, #0]
 8007ee8:	4619      	mov	r1, r3
 8007eea:	4b19      	ldr	r3, [pc, #100]	; (8007f50 <HAL_DMA_IRQHandler+0x3268>)
 8007eec:	4299      	cmp	r1, r3
 8007eee:	d00b      	beq.n	8007f08 <HAL_DMA_IRQHandler+0x3220>
 8007ef0:	687b      	ldr	r3, [r7, #4]
 8007ef2:	681b      	ldr	r3, [r3, #0]
 8007ef4:	4619      	mov	r1, r3
 8007ef6:	4b17      	ldr	r3, [pc, #92]	; (8007f54 <HAL_DMA_IRQHandler+0x326c>)
 8007ef8:	4299      	cmp	r1, r3
 8007efa:	d102      	bne.n	8007f02 <HAL_DMA_IRQHandler+0x321a>
 8007efc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007f00:	e03e      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f02:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007f06:	e03b      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f08:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007f0c:	e038      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f0e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007f12:	e035      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f14:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8007f18:	e032      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f1a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007f1e:	e02f      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f20:	400260b8 	.word	0x400260b8
 8007f24:	40026400 	.word	0x40026400
 8007f28:	40026010 	.word	0x40026010
 8007f2c:	40026410 	.word	0x40026410
 8007f30:	40026070 	.word	0x40026070
 8007f34:	40026470 	.word	0x40026470
 8007f38:	40026028 	.word	0x40026028
 8007f3c:	40026428 	.word	0x40026428
 8007f40:	40026088 	.word	0x40026088
 8007f44:	40026488 	.word	0x40026488
 8007f48:	40026040 	.word	0x40026040
 8007f4c:	40026440 	.word	0x40026440
 8007f50:	400260a0 	.word	0x400260a0
 8007f54:	400264a0 	.word	0x400264a0
 8007f58:	40026058 	.word	0x40026058
 8007f5c:	40026000 	.word	0x40026000
 8007f60:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007f64:	e00c      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f66:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007f6a:	e009      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f6c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007f70:	e006      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f72:	2320      	movs	r3, #32
 8007f74:	e004      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f76:	2320      	movs	r3, #32
 8007f78:	e002      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f7a:	2320      	movs	r3, #32
 8007f7c:	e000      	b.n	8007f80 <HAL_DMA_IRQHandler+0x3298>
 8007f7e:	2320      	movs	r3, #32
 8007f80:	6093      	str	r3, [r2, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 8007f82:	687b      	ldr	r3, [r7, #4]
 8007f84:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007f86:	687b      	ldr	r3, [r7, #4]
 8007f88:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY_MEM0;
 8007f8a:	687b      	ldr	r3, [r7, #4]
 8007f8c:	2211      	movs	r2, #17
 8007f8e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);      
 8007f92:	687b      	ldr	r3, [r7, #4]
 8007f94:	2200      	movs	r2, #0
 8007f96:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        if(hdma->XferCpltCallback != NULL)
 8007f9a:	687b      	ldr	r3, [r7, #4]
 8007f9c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007f9e:	2b00      	cmp	r3, #0
 8007fa0:	d003      	beq.n	8007faa <HAL_DMA_IRQHandler+0x32c2>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8007fa2:	687b      	ldr	r3, [r7, #4]
 8007fa4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007fa6:	6878      	ldr	r0, [r7, #4]
 8007fa8:	4798      	blx	r3
        }
      }
    }
  }
}
 8007faa:	3708      	adds	r7, #8
 8007fac:	46bd      	mov	sp, r7
 8007fae:	bd80      	pop	{r7, pc}

08007fb0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8007fb0:	b480      	push	{r7}
 8007fb2:	b089      	sub	sp, #36	; 0x24
 8007fb4:	af00      	add	r7, sp, #0
 8007fb6:	6078      	str	r0, [r7, #4]
 8007fb8:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
 8007fba:	2300      	movs	r3, #0
 8007fbc:	61fb      	str	r3, [r7, #28]
  uint32_t ioposition = 0x00;
 8007fbe:	2300      	movs	r3, #0
 8007fc0:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
 8007fc2:	2300      	movs	r3, #0
 8007fc4:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
 8007fc6:	2300      	movs	r3, #0
 8007fc8:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8007fca:	2300      	movs	r3, #0
 8007fcc:	61fb      	str	r3, [r7, #28]
 8007fce:	e171      	b.n	80082b4 <HAL_GPIO_Init+0x304>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8007fd0:	69fb      	ldr	r3, [r7, #28]
 8007fd2:	2201      	movs	r2, #1
 8007fd4:	fa02 f303 	lsl.w	r3, r2, r3
 8007fd8:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8007fda:	683b      	ldr	r3, [r7, #0]
 8007fdc:	681a      	ldr	r2, [r3, #0]
 8007fde:	697b      	ldr	r3, [r7, #20]
 8007fe0:	4013      	ands	r3, r2
 8007fe2:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8007fe4:	693a      	ldr	r2, [r7, #16]
 8007fe6:	697b      	ldr	r3, [r7, #20]
 8007fe8:	429a      	cmp	r2, r3
 8007fea:	f040 8160 	bne.w	80082ae <HAL_GPIO_Init+0x2fe>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8007fee:	683b      	ldr	r3, [r7, #0]
 8007ff0:	685b      	ldr	r3, [r3, #4]
 8007ff2:	2b02      	cmp	r3, #2
 8007ff4:	d003      	beq.n	8007ffe <HAL_GPIO_Init+0x4e>
 8007ff6:	683b      	ldr	r3, [r7, #0]
 8007ff8:	685b      	ldr	r3, [r3, #4]
 8007ffa:	2b12      	cmp	r3, #18
 8007ffc:	d122      	bne.n	8008044 <HAL_GPIO_Init+0x94>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8007ffe:	69fb      	ldr	r3, [r7, #28]
 8008000:	08da      	lsrs	r2, r3, #3
 8008002:	687b      	ldr	r3, [r7, #4]
 8008004:	3208      	adds	r2, #8
 8008006:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800800a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800800c:	69fb      	ldr	r3, [r7, #28]
 800800e:	f003 0307 	and.w	r3, r3, #7
 8008012:	009b      	lsls	r3, r3, #2
 8008014:	461a      	mov	r2, r3
 8008016:	230f      	movs	r3, #15
 8008018:	4093      	lsls	r3, r2
 800801a:	43db      	mvns	r3, r3
 800801c:	69ba      	ldr	r2, [r7, #24]
 800801e:	4013      	ands	r3, r2
 8008020:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8008022:	683b      	ldr	r3, [r7, #0]
 8008024:	691b      	ldr	r3, [r3, #16]
 8008026:	69fa      	ldr	r2, [r7, #28]
 8008028:	f002 0207 	and.w	r2, r2, #7
 800802c:	0092      	lsls	r2, r2, #2
 800802e:	4093      	lsls	r3, r2
 8008030:	69ba      	ldr	r2, [r7, #24]
 8008032:	4313      	orrs	r3, r2
 8008034:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
 8008036:	69fb      	ldr	r3, [r7, #28]
 8008038:	08da      	lsrs	r2, r3, #3
 800803a:	687b      	ldr	r3, [r7, #4]
 800803c:	3208      	adds	r2, #8
 800803e:	69b9      	ldr	r1, [r7, #24]
 8008040:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8008044:	687b      	ldr	r3, [r7, #4]
 8008046:	681b      	ldr	r3, [r3, #0]
 8008048:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800804a:	69fb      	ldr	r3, [r7, #28]
 800804c:	005b      	lsls	r3, r3, #1
 800804e:	461a      	mov	r2, r3
 8008050:	2303      	movs	r3, #3
 8008052:	4093      	lsls	r3, r2
 8008054:	43db      	mvns	r3, r3
 8008056:	69ba      	ldr	r2, [r7, #24]
 8008058:	4013      	ands	r3, r2
 800805a:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800805c:	683b      	ldr	r3, [r7, #0]
 800805e:	685b      	ldr	r3, [r3, #4]
 8008060:	f003 0303 	and.w	r3, r3, #3
 8008064:	69fa      	ldr	r2, [r7, #28]
 8008066:	0052      	lsls	r2, r2, #1
 8008068:	4093      	lsls	r3, r2
 800806a:	69ba      	ldr	r2, [r7, #24]
 800806c:	4313      	orrs	r3, r2
 800806e:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8008070:	687b      	ldr	r3, [r7, #4]
 8008072:	69ba      	ldr	r2, [r7, #24]
 8008074:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8008076:	683b      	ldr	r3, [r7, #0]
 8008078:	685b      	ldr	r3, [r3, #4]
 800807a:	2b01      	cmp	r3, #1
 800807c:	d00b      	beq.n	8008096 <HAL_GPIO_Init+0xe6>
 800807e:	683b      	ldr	r3, [r7, #0]
 8008080:	685b      	ldr	r3, [r3, #4]
 8008082:	2b02      	cmp	r3, #2
 8008084:	d007      	beq.n	8008096 <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8008086:	683b      	ldr	r3, [r7, #0]
 8008088:	685b      	ldr	r3, [r3, #4]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800808a:	2b11      	cmp	r3, #17
 800808c:	d003      	beq.n	8008096 <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800808e:	683b      	ldr	r3, [r7, #0]
 8008090:	685b      	ldr	r3, [r3, #4]
 8008092:	2b12      	cmp	r3, #18
 8008094:	d12f      	bne.n	80080f6 <HAL_GPIO_Init+0x146>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8008096:	687b      	ldr	r3, [r7, #4]
 8008098:	689b      	ldr	r3, [r3, #8]
 800809a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800809c:	69fb      	ldr	r3, [r7, #28]
 800809e:	005b      	lsls	r3, r3, #1
 80080a0:	461a      	mov	r2, r3
 80080a2:	2303      	movs	r3, #3
 80080a4:	4093      	lsls	r3, r2
 80080a6:	43db      	mvns	r3, r3
 80080a8:	69ba      	ldr	r2, [r7, #24]
 80080aa:	4013      	ands	r3, r2
 80080ac:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
 80080ae:	683b      	ldr	r3, [r7, #0]
 80080b0:	68db      	ldr	r3, [r3, #12]
 80080b2:	69fa      	ldr	r2, [r7, #28]
 80080b4:	0052      	lsls	r2, r2, #1
 80080b6:	4093      	lsls	r3, r2
 80080b8:	69ba      	ldr	r2, [r7, #24]
 80080ba:	4313      	orrs	r3, r2
 80080bc:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 80080be:	687b      	ldr	r3, [r7, #4]
 80080c0:	69ba      	ldr	r2, [r7, #24]
 80080c2:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80080c4:	687b      	ldr	r3, [r7, #4]
 80080c6:	685b      	ldr	r3, [r3, #4]
 80080c8:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80080ca:	69fb      	ldr	r3, [r7, #28]
 80080cc:	2201      	movs	r2, #1
 80080ce:	fa02 f303 	lsl.w	r3, r2, r3
 80080d2:	43db      	mvns	r3, r3
 80080d4:	69ba      	ldr	r2, [r7, #24]
 80080d6:	4013      	ands	r3, r2
 80080d8:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80080da:	683b      	ldr	r3, [r7, #0]
 80080dc:	685b      	ldr	r3, [r3, #4]
 80080de:	f003 0310 	and.w	r3, r3, #16
 80080e2:	091a      	lsrs	r2, r3, #4
 80080e4:	69fb      	ldr	r3, [r7, #28]
 80080e6:	fa02 f303 	lsl.w	r3, r2, r3
 80080ea:	69ba      	ldr	r2, [r7, #24]
 80080ec:	4313      	orrs	r3, r2
 80080ee:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 80080f0:	687b      	ldr	r3, [r7, #4]
 80080f2:	69ba      	ldr	r2, [r7, #24]
 80080f4:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80080f6:	687b      	ldr	r3, [r7, #4]
 80080f8:	68db      	ldr	r3, [r3, #12]
 80080fa:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 80080fc:	69fb      	ldr	r3, [r7, #28]
 80080fe:	005b      	lsls	r3, r3, #1
 8008100:	461a      	mov	r2, r3
 8008102:	2303      	movs	r3, #3
 8008104:	4093      	lsls	r3, r2
 8008106:	43db      	mvns	r3, r3
 8008108:	69ba      	ldr	r2, [r7, #24]
 800810a:	4013      	ands	r3, r2
 800810c:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
 800810e:	683b      	ldr	r3, [r7, #0]
 8008110:	689b      	ldr	r3, [r3, #8]
 8008112:	69fa      	ldr	r2, [r7, #28]
 8008114:	0052      	lsls	r2, r2, #1
 8008116:	4093      	lsls	r3, r2
 8008118:	69ba      	ldr	r2, [r7, #24]
 800811a:	4313      	orrs	r3, r2
 800811c:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 800811e:	687b      	ldr	r3, [r7, #4]
 8008120:	69ba      	ldr	r2, [r7, #24]
 8008122:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8008124:	683b      	ldr	r3, [r7, #0]
 8008126:	685b      	ldr	r3, [r3, #4]
 8008128:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800812c:	2b00      	cmp	r3, #0
 800812e:	f000 80be 	beq.w	80082ae <HAL_GPIO_Init+0x2fe>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008132:	4a65      	ldr	r2, [pc, #404]	; (80082c8 <HAL_GPIO_Init+0x318>)
 8008134:	4b64      	ldr	r3, [pc, #400]	; (80082c8 <HAL_GPIO_Init+0x318>)
 8008136:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008138:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800813c:	6453      	str	r3, [r2, #68]	; 0x44
 800813e:	4b62      	ldr	r3, [pc, #392]	; (80082c8 <HAL_GPIO_Init+0x318>)
 8008140:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008142:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8008146:	60fb      	str	r3, [r7, #12]
 8008148:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 800814a:	4a60      	ldr	r2, [pc, #384]	; (80082cc <HAL_GPIO_Init+0x31c>)
 800814c:	69fb      	ldr	r3, [r7, #28]
 800814e:	089b      	lsrs	r3, r3, #2
 8008150:	3302      	adds	r3, #2
 8008152:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8008156:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8008158:	69fb      	ldr	r3, [r7, #28]
 800815a:	f003 0303 	and.w	r3, r3, #3
 800815e:	009b      	lsls	r3, r3, #2
 8008160:	461a      	mov	r2, r3
 8008162:	230f      	movs	r3, #15
 8008164:	4093      	lsls	r3, r2
 8008166:	43db      	mvns	r3, r3
 8008168:	69ba      	ldr	r2, [r7, #24]
 800816a:	4013      	ands	r3, r2
 800816c:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800816e:	687b      	ldr	r3, [r7, #4]
 8008170:	4a57      	ldr	r2, [pc, #348]	; (80082d0 <HAL_GPIO_Init+0x320>)
 8008172:	4293      	cmp	r3, r2
 8008174:	d037      	beq.n	80081e6 <HAL_GPIO_Init+0x236>
 8008176:	687b      	ldr	r3, [r7, #4]
 8008178:	4a56      	ldr	r2, [pc, #344]	; (80082d4 <HAL_GPIO_Init+0x324>)
 800817a:	4293      	cmp	r3, r2
 800817c:	d031      	beq.n	80081e2 <HAL_GPIO_Init+0x232>
 800817e:	687b      	ldr	r3, [r7, #4]
 8008180:	4a55      	ldr	r2, [pc, #340]	; (80082d8 <HAL_GPIO_Init+0x328>)
 8008182:	4293      	cmp	r3, r2
 8008184:	d02b      	beq.n	80081de <HAL_GPIO_Init+0x22e>
 8008186:	687b      	ldr	r3, [r7, #4]
 8008188:	4a54      	ldr	r2, [pc, #336]	; (80082dc <HAL_GPIO_Init+0x32c>)
 800818a:	4293      	cmp	r3, r2
 800818c:	d025      	beq.n	80081da <HAL_GPIO_Init+0x22a>
 800818e:	687b      	ldr	r3, [r7, #4]
 8008190:	4a53      	ldr	r2, [pc, #332]	; (80082e0 <HAL_GPIO_Init+0x330>)
 8008192:	4293      	cmp	r3, r2
 8008194:	d01f      	beq.n	80081d6 <HAL_GPIO_Init+0x226>
 8008196:	687b      	ldr	r3, [r7, #4]
 8008198:	4a52      	ldr	r2, [pc, #328]	; (80082e4 <HAL_GPIO_Init+0x334>)
 800819a:	4293      	cmp	r3, r2
 800819c:	d019      	beq.n	80081d2 <HAL_GPIO_Init+0x222>
 800819e:	687b      	ldr	r3, [r7, #4]
 80081a0:	4a51      	ldr	r2, [pc, #324]	; (80082e8 <HAL_GPIO_Init+0x338>)
 80081a2:	4293      	cmp	r3, r2
 80081a4:	d013      	beq.n	80081ce <HAL_GPIO_Init+0x21e>
 80081a6:	687b      	ldr	r3, [r7, #4]
 80081a8:	4a50      	ldr	r2, [pc, #320]	; (80082ec <HAL_GPIO_Init+0x33c>)
 80081aa:	4293      	cmp	r3, r2
 80081ac:	d00d      	beq.n	80081ca <HAL_GPIO_Init+0x21a>
 80081ae:	687b      	ldr	r3, [r7, #4]
 80081b0:	4a4f      	ldr	r2, [pc, #316]	; (80082f0 <HAL_GPIO_Init+0x340>)
 80081b2:	4293      	cmp	r3, r2
 80081b4:	d007      	beq.n	80081c6 <HAL_GPIO_Init+0x216>
 80081b6:	687b      	ldr	r3, [r7, #4]
 80081b8:	4a4e      	ldr	r2, [pc, #312]	; (80082f4 <HAL_GPIO_Init+0x344>)
 80081ba:	4293      	cmp	r3, r2
 80081bc:	d101      	bne.n	80081c2 <HAL_GPIO_Init+0x212>
 80081be:	2309      	movs	r3, #9
 80081c0:	e012      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081c2:	230a      	movs	r3, #10
 80081c4:	e010      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081c6:	2308      	movs	r3, #8
 80081c8:	e00e      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081ca:	2307      	movs	r3, #7
 80081cc:	e00c      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081ce:	2306      	movs	r3, #6
 80081d0:	e00a      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081d2:	2305      	movs	r3, #5
 80081d4:	e008      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081d6:	2304      	movs	r3, #4
 80081d8:	e006      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081da:	2303      	movs	r3, #3
 80081dc:	e004      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081de:	2302      	movs	r3, #2
 80081e0:	e002      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081e2:	2301      	movs	r3, #1
 80081e4:	e000      	b.n	80081e8 <HAL_GPIO_Init+0x238>
 80081e6:	2300      	movs	r3, #0
 80081e8:	69fa      	ldr	r2, [r7, #28]
 80081ea:	f002 0203 	and.w	r2, r2, #3
 80081ee:	0092      	lsls	r2, r2, #2
 80081f0:	4093      	lsls	r3, r2
 80081f2:	69ba      	ldr	r2, [r7, #24]
 80081f4:	4313      	orrs	r3, r2
 80081f6:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
 80081f8:	4934      	ldr	r1, [pc, #208]	; (80082cc <HAL_GPIO_Init+0x31c>)
 80081fa:	69fb      	ldr	r3, [r7, #28]
 80081fc:	089b      	lsrs	r3, r3, #2
 80081fe:	3302      	adds	r3, #2
 8008200:	69ba      	ldr	r2, [r7, #24]
 8008202:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8008206:	4b3c      	ldr	r3, [pc, #240]	; (80082f8 <HAL_GPIO_Init+0x348>)
 8008208:	681b      	ldr	r3, [r3, #0]
 800820a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800820c:	693b      	ldr	r3, [r7, #16]
 800820e:	43db      	mvns	r3, r3
 8008210:	69ba      	ldr	r2, [r7, #24]
 8008212:	4013      	ands	r3, r2
 8008214:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8008216:	683b      	ldr	r3, [r7, #0]
 8008218:	685b      	ldr	r3, [r3, #4]
 800821a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800821e:	2b00      	cmp	r3, #0
 8008220:	d003      	beq.n	800822a <HAL_GPIO_Init+0x27a>
        {
          temp |= iocurrent;
 8008222:	69ba      	ldr	r2, [r7, #24]
 8008224:	693b      	ldr	r3, [r7, #16]
 8008226:	4313      	orrs	r3, r2
 8008228:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 800822a:	4a33      	ldr	r2, [pc, #204]	; (80082f8 <HAL_GPIO_Init+0x348>)
 800822c:	69bb      	ldr	r3, [r7, #24]
 800822e:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 8008230:	4b31      	ldr	r3, [pc, #196]	; (80082f8 <HAL_GPIO_Init+0x348>)
 8008232:	685b      	ldr	r3, [r3, #4]
 8008234:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8008236:	693b      	ldr	r3, [r7, #16]
 8008238:	43db      	mvns	r3, r3
 800823a:	69ba      	ldr	r2, [r7, #24]
 800823c:	4013      	ands	r3, r2
 800823e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8008240:	683b      	ldr	r3, [r7, #0]
 8008242:	685b      	ldr	r3, [r3, #4]
 8008244:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008248:	2b00      	cmp	r3, #0
 800824a:	d003      	beq.n	8008254 <HAL_GPIO_Init+0x2a4>
        {
          temp |= iocurrent;
 800824c:	69ba      	ldr	r2, [r7, #24]
 800824e:	693b      	ldr	r3, [r7, #16]
 8008250:	4313      	orrs	r3, r2
 8008252:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8008254:	4a28      	ldr	r2, [pc, #160]	; (80082f8 <HAL_GPIO_Init+0x348>)
 8008256:	69bb      	ldr	r3, [r7, #24]
 8008258:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800825a:	4b27      	ldr	r3, [pc, #156]	; (80082f8 <HAL_GPIO_Init+0x348>)
 800825c:	689b      	ldr	r3, [r3, #8]
 800825e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8008260:	693b      	ldr	r3, [r7, #16]
 8008262:	43db      	mvns	r3, r3
 8008264:	69ba      	ldr	r2, [r7, #24]
 8008266:	4013      	ands	r3, r2
 8008268:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800826a:	683b      	ldr	r3, [r7, #0]
 800826c:	685b      	ldr	r3, [r3, #4]
 800826e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8008272:	2b00      	cmp	r3, #0
 8008274:	d003      	beq.n	800827e <HAL_GPIO_Init+0x2ce>
        {
          temp |= iocurrent;
 8008276:	69ba      	ldr	r2, [r7, #24]
 8008278:	693b      	ldr	r3, [r7, #16]
 800827a:	4313      	orrs	r3, r2
 800827c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800827e:	4a1e      	ldr	r2, [pc, #120]	; (80082f8 <HAL_GPIO_Init+0x348>)
 8008280:	69bb      	ldr	r3, [r7, #24]
 8008282:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8008284:	4b1c      	ldr	r3, [pc, #112]	; (80082f8 <HAL_GPIO_Init+0x348>)
 8008286:	68db      	ldr	r3, [r3, #12]
 8008288:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800828a:	693b      	ldr	r3, [r7, #16]
 800828c:	43db      	mvns	r3, r3
 800828e:	69ba      	ldr	r2, [r7, #24]
 8008290:	4013      	ands	r3, r2
 8008292:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8008294:	683b      	ldr	r3, [r7, #0]
 8008296:	685b      	ldr	r3, [r3, #4]
 8008298:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800829c:	2b00      	cmp	r3, #0
 800829e:	d003      	beq.n	80082a8 <HAL_GPIO_Init+0x2f8>
        {
          temp |= iocurrent;
 80082a0:	69ba      	ldr	r2, [r7, #24]
 80082a2:	693b      	ldr	r3, [r7, #16]
 80082a4:	4313      	orrs	r3, r2
 80082a6:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 80082a8:	4a13      	ldr	r2, [pc, #76]	; (80082f8 <HAL_GPIO_Init+0x348>)
 80082aa:	69bb      	ldr	r3, [r7, #24]
 80082ac:	60d3      	str	r3, [r2, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 80082ae:	69fb      	ldr	r3, [r7, #28]
 80082b0:	3301      	adds	r3, #1
 80082b2:	61fb      	str	r3, [r7, #28]
 80082b4:	69fb      	ldr	r3, [r7, #28]
 80082b6:	2b0f      	cmp	r3, #15
 80082b8:	f67f ae8a 	bls.w	8007fd0 <HAL_GPIO_Init+0x20>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 80082bc:	3724      	adds	r7, #36	; 0x24
 80082be:	46bd      	mov	sp, r7
 80082c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082c4:	4770      	bx	lr
 80082c6:	bf00      	nop
 80082c8:	40023800 	.word	0x40023800
 80082cc:	40013800 	.word	0x40013800
 80082d0:	40020000 	.word	0x40020000
 80082d4:	40020400 	.word	0x40020400
 80082d8:	40020800 	.word	0x40020800
 80082dc:	40020c00 	.word	0x40020c00
 80082e0:	40021000 	.word	0x40021000
 80082e4:	40021400 	.word	0x40021400
 80082e8:	40021800 	.word	0x40021800
 80082ec:	40021c00 	.word	0x40021c00
 80082f0:	40022000 	.word	0x40022000
 80082f4:	40022400 	.word	0x40022400
 80082f8:	40013c00 	.word	0x40013c00

080082fc <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 80082fc:	b480      	push	{r7}
 80082fe:	b087      	sub	sp, #28
 8008300:	af00      	add	r7, sp, #0
 8008302:	6078      	str	r0, [r7, #4]
 8008304:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00;
 8008306:	2300      	movs	r3, #0
 8008308:	613b      	str	r3, [r7, #16]
  uint32_t iocurrent = 0x00;
 800830a:	2300      	movs	r3, #0
 800830c:	60fb      	str	r3, [r7, #12]
  uint32_t tmp = 0x00;
 800830e:	2300      	movs	r3, #0
 8008310:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8008312:	2300      	movs	r3, #0
 8008314:	617b      	str	r3, [r7, #20]
 8008316:	e0da      	b.n	80084ce <HAL_GPIO_DeInit+0x1d2>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8008318:	697b      	ldr	r3, [r7, #20]
 800831a:	2201      	movs	r2, #1
 800831c:	fa02 f303 	lsl.w	r3, r2, r3
 8008320:	613b      	str	r3, [r7, #16]
    /* Get the current IO position */
    iocurrent = (GPIO_Pin) & ioposition;
 8008322:	683a      	ldr	r2, [r7, #0]
 8008324:	693b      	ldr	r3, [r7, #16]
 8008326:	4013      	ands	r3, r2
 8008328:	60fb      	str	r3, [r7, #12]

    if(iocurrent == ioposition)
 800832a:	68fa      	ldr	r2, [r7, #12]
 800832c:	693b      	ldr	r3, [r7, #16]
 800832e:	429a      	cmp	r2, r3
 8008330:	f040 80ca 	bne.w	80084c8 <HAL_GPIO_DeInit+0x1cc>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
 8008334:	687b      	ldr	r3, [r7, #4]
 8008336:	681a      	ldr	r2, [r3, #0]
 8008338:	697b      	ldr	r3, [r7, #20]
 800833a:	005b      	lsls	r3, r3, #1
 800833c:	4619      	mov	r1, r3
 800833e:	2303      	movs	r3, #3
 8008340:	408b      	lsls	r3, r1
 8008342:	43db      	mvns	r3, r3
 8008344:	401a      	ands	r2, r3
 8008346:	687b      	ldr	r3, [r7, #4]
 8008348:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800834a:	697b      	ldr	r3, [r7, #20]
 800834c:	08da      	lsrs	r2, r3, #3
 800834e:	697b      	ldr	r3, [r7, #20]
 8008350:	08d9      	lsrs	r1, r3, #3
 8008352:	687b      	ldr	r3, [r7, #4]
 8008354:	3108      	adds	r1, #8
 8008356:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 800835a:	697b      	ldr	r3, [r7, #20]
 800835c:	f003 0307 	and.w	r3, r3, #7
 8008360:	009b      	lsls	r3, r3, #2
 8008362:	4618      	mov	r0, r3
 8008364:	230f      	movs	r3, #15
 8008366:	4083      	lsls	r3, r0
 8008368:	43db      	mvns	r3, r3
 800836a:	4019      	ands	r1, r3
 800836c:	687b      	ldr	r3, [r7, #4]
 800836e:	3208      	adds	r2, #8
 8008370:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8008374:	687b      	ldr	r3, [r7, #4]
 8008376:	689a      	ldr	r2, [r3, #8]
 8008378:	697b      	ldr	r3, [r7, #20]
 800837a:	005b      	lsls	r3, r3, #1
 800837c:	4619      	mov	r1, r3
 800837e:	2303      	movs	r3, #3
 8008380:	408b      	lsls	r3, r1
 8008382:	43db      	mvns	r3, r3
 8008384:	401a      	ands	r2, r3
 8008386:	687b      	ldr	r3, [r7, #4]
 8008388:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 800838a:	687b      	ldr	r3, [r7, #4]
 800838c:	685a      	ldr	r2, [r3, #4]
 800838e:	697b      	ldr	r3, [r7, #20]
 8008390:	2101      	movs	r1, #1
 8008392:	fa01 f303 	lsl.w	r3, r1, r3
 8008396:	43db      	mvns	r3, r3
 8008398:	401a      	ands	r2, r3
 800839a:	687b      	ldr	r3, [r7, #4]
 800839c:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800839e:	687b      	ldr	r3, [r7, #4]
 80083a0:	68da      	ldr	r2, [r3, #12]
 80083a2:	697b      	ldr	r3, [r7, #20]
 80083a4:	005b      	lsls	r3, r3, #1
 80083a6:	4619      	mov	r1, r3
 80083a8:	2303      	movs	r3, #3
 80083aa:	408b      	lsls	r3, r1
 80083ac:	43db      	mvns	r3, r3
 80083ae:	401a      	ands	r2, r3
 80083b0:	687b      	ldr	r3, [r7, #4]
 80083b2:	60da      	str	r2, [r3, #12]

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2];
 80083b4:	4a4a      	ldr	r2, [pc, #296]	; (80084e0 <HAL_GPIO_DeInit+0x1e4>)
 80083b6:	697b      	ldr	r3, [r7, #20]
 80083b8:	089b      	lsrs	r3, r3, #2
 80083ba:	3302      	adds	r3, #2
 80083bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80083c0:	60bb      	str	r3, [r7, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 80083c2:	697b      	ldr	r3, [r7, #20]
 80083c4:	f003 0303 	and.w	r3, r3, #3
 80083c8:	009b      	lsls	r3, r3, #2
 80083ca:	461a      	mov	r2, r3
 80083cc:	230f      	movs	r3, #15
 80083ce:	4093      	lsls	r3, r2
 80083d0:	68ba      	ldr	r2, [r7, #8]
 80083d2:	4013      	ands	r3, r2
 80083d4:	60bb      	str	r3, [r7, #8]
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 80083d6:	687b      	ldr	r3, [r7, #4]
 80083d8:	4a42      	ldr	r2, [pc, #264]	; (80084e4 <HAL_GPIO_DeInit+0x1e8>)
 80083da:	4293      	cmp	r3, r2
 80083dc:	d037      	beq.n	800844e <HAL_GPIO_DeInit+0x152>
 80083de:	687b      	ldr	r3, [r7, #4]
 80083e0:	4a41      	ldr	r2, [pc, #260]	; (80084e8 <HAL_GPIO_DeInit+0x1ec>)
 80083e2:	4293      	cmp	r3, r2
 80083e4:	d031      	beq.n	800844a <HAL_GPIO_DeInit+0x14e>
 80083e6:	687b      	ldr	r3, [r7, #4]
 80083e8:	4a40      	ldr	r2, [pc, #256]	; (80084ec <HAL_GPIO_DeInit+0x1f0>)
 80083ea:	4293      	cmp	r3, r2
 80083ec:	d02b      	beq.n	8008446 <HAL_GPIO_DeInit+0x14a>
 80083ee:	687b      	ldr	r3, [r7, #4]
 80083f0:	4a3f      	ldr	r2, [pc, #252]	; (80084f0 <HAL_GPIO_DeInit+0x1f4>)
 80083f2:	4293      	cmp	r3, r2
 80083f4:	d025      	beq.n	8008442 <HAL_GPIO_DeInit+0x146>
 80083f6:	687b      	ldr	r3, [r7, #4]
 80083f8:	4a3e      	ldr	r2, [pc, #248]	; (80084f4 <HAL_GPIO_DeInit+0x1f8>)
 80083fa:	4293      	cmp	r3, r2
 80083fc:	d01f      	beq.n	800843e <HAL_GPIO_DeInit+0x142>
 80083fe:	687b      	ldr	r3, [r7, #4]
 8008400:	4a3d      	ldr	r2, [pc, #244]	; (80084f8 <HAL_GPIO_DeInit+0x1fc>)
 8008402:	4293      	cmp	r3, r2
 8008404:	d019      	beq.n	800843a <HAL_GPIO_DeInit+0x13e>
 8008406:	687b      	ldr	r3, [r7, #4]
 8008408:	4a3c      	ldr	r2, [pc, #240]	; (80084fc <HAL_GPIO_DeInit+0x200>)
 800840a:	4293      	cmp	r3, r2
 800840c:	d013      	beq.n	8008436 <HAL_GPIO_DeInit+0x13a>
 800840e:	687b      	ldr	r3, [r7, #4]
 8008410:	4a3b      	ldr	r2, [pc, #236]	; (8008500 <HAL_GPIO_DeInit+0x204>)
 8008412:	4293      	cmp	r3, r2
 8008414:	d00d      	beq.n	8008432 <HAL_GPIO_DeInit+0x136>
 8008416:	687b      	ldr	r3, [r7, #4]
 8008418:	4a3a      	ldr	r2, [pc, #232]	; (8008504 <HAL_GPIO_DeInit+0x208>)
 800841a:	4293      	cmp	r3, r2
 800841c:	d007      	beq.n	800842e <HAL_GPIO_DeInit+0x132>
 800841e:	687b      	ldr	r3, [r7, #4]
 8008420:	4a39      	ldr	r2, [pc, #228]	; (8008508 <HAL_GPIO_DeInit+0x20c>)
 8008422:	4293      	cmp	r3, r2
 8008424:	d101      	bne.n	800842a <HAL_GPIO_DeInit+0x12e>
 8008426:	2309      	movs	r3, #9
 8008428:	e012      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 800842a:	230a      	movs	r3, #10
 800842c:	e010      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 800842e:	2308      	movs	r3, #8
 8008430:	e00e      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 8008432:	2307      	movs	r3, #7
 8008434:	e00c      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 8008436:	2306      	movs	r3, #6
 8008438:	e00a      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 800843a:	2305      	movs	r3, #5
 800843c:	e008      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 800843e:	2304      	movs	r3, #4
 8008440:	e006      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 8008442:	2303      	movs	r3, #3
 8008444:	e004      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 8008446:	2302      	movs	r3, #2
 8008448:	e002      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 800844a:	2301      	movs	r3, #1
 800844c:	e000      	b.n	8008450 <HAL_GPIO_DeInit+0x154>
 800844e:	2300      	movs	r3, #0
 8008450:	697a      	ldr	r2, [r7, #20]
 8008452:	f002 0203 	and.w	r2, r2, #3
 8008456:	0092      	lsls	r2, r2, #2
 8008458:	fa03 f202 	lsl.w	r2, r3, r2
 800845c:	68bb      	ldr	r3, [r7, #8]
 800845e:	429a      	cmp	r2, r3
 8008460:	d132      	bne.n	80084c8 <HAL_GPIO_DeInit+0x1cc>
      {
        /* Configure the External Interrupt or event for the current IO */
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
 8008462:	697b      	ldr	r3, [r7, #20]
 8008464:	f003 0303 	and.w	r3, r3, #3
 8008468:	009b      	lsls	r3, r3, #2
 800846a:	461a      	mov	r2, r3
 800846c:	230f      	movs	r3, #15
 800846e:	4093      	lsls	r3, r2
 8008470:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8008472:	481b      	ldr	r0, [pc, #108]	; (80084e0 <HAL_GPIO_DeInit+0x1e4>)
 8008474:	697b      	ldr	r3, [r7, #20]
 8008476:	089b      	lsrs	r3, r3, #2
 8008478:	4919      	ldr	r1, [pc, #100]	; (80084e0 <HAL_GPIO_DeInit+0x1e4>)
 800847a:	697a      	ldr	r2, [r7, #20]
 800847c:	0892      	lsrs	r2, r2, #2
 800847e:	3202      	adds	r2, #2
 8008480:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 8008484:	68ba      	ldr	r2, [r7, #8]
 8008486:	43d2      	mvns	r2, r2
 8008488:	400a      	ands	r2, r1
 800848a:	3302      	adds	r3, #2
 800848c:	f840 2023 	str.w	r2, [r0, r3, lsl #2]

        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 8008490:	491e      	ldr	r1, [pc, #120]	; (800850c <HAL_GPIO_DeInit+0x210>)
 8008492:	4b1e      	ldr	r3, [pc, #120]	; (800850c <HAL_GPIO_DeInit+0x210>)
 8008494:	681a      	ldr	r2, [r3, #0]
 8008496:	68fb      	ldr	r3, [r7, #12]
 8008498:	43db      	mvns	r3, r3
 800849a:	4013      	ands	r3, r2
 800849c:	600b      	str	r3, [r1, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 800849e:	491b      	ldr	r1, [pc, #108]	; (800850c <HAL_GPIO_DeInit+0x210>)
 80084a0:	4b1a      	ldr	r3, [pc, #104]	; (800850c <HAL_GPIO_DeInit+0x210>)
 80084a2:	685a      	ldr	r2, [r3, #4]
 80084a4:	68fb      	ldr	r3, [r7, #12]
 80084a6:	43db      	mvns	r3, r3
 80084a8:	4013      	ands	r3, r2
 80084aa:	604b      	str	r3, [r1, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 80084ac:	4917      	ldr	r1, [pc, #92]	; (800850c <HAL_GPIO_DeInit+0x210>)
 80084ae:	4b17      	ldr	r3, [pc, #92]	; (800850c <HAL_GPIO_DeInit+0x210>)
 80084b0:	689a      	ldr	r2, [r3, #8]
 80084b2:	68fb      	ldr	r3, [r7, #12]
 80084b4:	43db      	mvns	r3, r3
 80084b6:	4013      	ands	r3, r2
 80084b8:	608b      	str	r3, [r1, #8]
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 80084ba:	4914      	ldr	r1, [pc, #80]	; (800850c <HAL_GPIO_DeInit+0x210>)
 80084bc:	4b13      	ldr	r3, [pc, #76]	; (800850c <HAL_GPIO_DeInit+0x210>)
 80084be:	68da      	ldr	r2, [r3, #12]
 80084c0:	68fb      	ldr	r3, [r7, #12]
 80084c2:	43db      	mvns	r3, r3
 80084c4:	4013      	ands	r3, r2
 80084c6:	60cb      	str	r3, [r1, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 80084c8:	697b      	ldr	r3, [r7, #20]
 80084ca:	3301      	adds	r3, #1
 80084cc:	617b      	str	r3, [r7, #20]
 80084ce:	697b      	ldr	r3, [r7, #20]
 80084d0:	2b0f      	cmp	r3, #15
 80084d2:	f67f af21 	bls.w	8008318 <HAL_GPIO_DeInit+0x1c>
        EXTI->RTSR &= ~((uint32_t)iocurrent);
        EXTI->FTSR &= ~((uint32_t)iocurrent);
	  }
    }
  }
}
 80084d6:	371c      	adds	r7, #28
 80084d8:	46bd      	mov	sp, r7
 80084da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084de:	4770      	bx	lr
 80084e0:	40013800 	.word	0x40013800
 80084e4:	40020000 	.word	0x40020000
 80084e8:	40020400 	.word	0x40020400
 80084ec:	40020800 	.word	0x40020800
 80084f0:	40020c00 	.word	0x40020c00
 80084f4:	40021000 	.word	0x40021000
 80084f8:	40021400 	.word	0x40021400
 80084fc:	40021800 	.word	0x40021800
 8008500:	40021c00 	.word	0x40021c00
 8008504:	40022000 	.word	0x40022000
 8008508:	40022400 	.word	0x40022400
 800850c:	40013c00 	.word	0x40013c00

08008510 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8008510:	b480      	push	{r7}
 8008512:	b085      	sub	sp, #20
 8008514:	af00      	add	r7, sp, #0
 8008516:	6078      	str	r0, [r7, #4]
 8008518:	460b      	mov	r3, r1
 800851a:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 800851c:	687b      	ldr	r3, [r7, #4]
 800851e:	691a      	ldr	r2, [r3, #16]
 8008520:	887b      	ldrh	r3, [r7, #2]
 8008522:	4013      	ands	r3, r2
 8008524:	2b00      	cmp	r3, #0
 8008526:	d002      	beq.n	800852e <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 8008528:	2301      	movs	r3, #1
 800852a:	73fb      	strb	r3, [r7, #15]
 800852c:	e001      	b.n	8008532 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 800852e:	2300      	movs	r3, #0
 8008530:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8008532:	7bfb      	ldrb	r3, [r7, #15]
}
 8008534:	4618      	mov	r0, r3
 8008536:	3714      	adds	r7, #20
 8008538:	46bd      	mov	sp, r7
 800853a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800853e:	4770      	bx	lr

08008540 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8008540:	b480      	push	{r7}
 8008542:	b083      	sub	sp, #12
 8008544:	af00      	add	r7, sp, #0
 8008546:	6078      	str	r0, [r7, #4]
 8008548:	460b      	mov	r3, r1
 800854a:	807b      	strh	r3, [r7, #2]
 800854c:	4613      	mov	r3, r2
 800854e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8008550:	787b      	ldrb	r3, [r7, #1]
 8008552:	2b00      	cmp	r3, #0
 8008554:	d003      	beq.n	800855e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8008556:	887a      	ldrh	r2, [r7, #2]
 8008558:	687b      	ldr	r3, [r7, #4]
 800855a:	619a      	str	r2, [r3, #24]
 800855c:	e003      	b.n	8008566 <HAL_GPIO_WritePin+0x26>
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 800855e:	887b      	ldrh	r3, [r7, #2]
 8008560:	041a      	lsls	r2, r3, #16
 8008562:	687b      	ldr	r3, [r7, #4]
 8008564:	619a      	str	r2, [r3, #24]
  }
}
 8008566:	370c      	adds	r7, #12
 8008568:	46bd      	mov	sp, r7
 800856a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800856e:	4770      	bx	lr

08008570 <HAL_MspInit>:
/**
  * @brief  Initializes the Global MSP.
  * @retval None
  */
void HAL_MspInit(void)
{
 8008570:	b480      	push	{r7}
 8008572:	af00      	add	r7, sp, #0
  /* NOTE : This function is generated automatically by STM32CubeMX and eventually  
            modified by the user
   */ 
}
 8008574:	46bd      	mov	sp, r7
 8008576:	f85d 7b04 	ldr.w	r7, [sp], #4
 800857a:	4770      	bx	lr

0800857c <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 800857c:	b580      	push	{r7, lr}
 800857e:	b082      	sub	sp, #8
 8008580:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
 8008582:	2300      	movs	r3, #0
 8008584:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
 8008586:	4a22      	ldr	r2, [pc, #136]	; (8008610 <HAL_PWREx_EnableOverDrive+0x94>)
 8008588:	4b21      	ldr	r3, [pc, #132]	; (8008610 <HAL_PWREx_EnableOverDrive+0x94>)
 800858a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800858c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8008590:	6413      	str	r3, [r2, #64]	; 0x40
 8008592:	4b1f      	ldr	r3, [pc, #124]	; (8008610 <HAL_PWREx_EnableOverDrive+0x94>)
 8008594:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008596:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800859a:	603b      	str	r3, [r7, #0]
 800859c:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800859e:	4a1d      	ldr	r2, [pc, #116]	; (8008614 <HAL_PWREx_EnableOverDrive+0x98>)
 80085a0:	4b1c      	ldr	r3, [pc, #112]	; (8008614 <HAL_PWREx_EnableOverDrive+0x98>)
 80085a2:	681b      	ldr	r3, [r3, #0]
 80085a4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80085a8:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 80085aa:	f7f9 f80b 	bl	80015c4 <HAL_GetTick>
 80085ae:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 80085b0:	e009      	b.n	80085c6 <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 80085b2:	f7f9 f807 	bl	80015c4 <HAL_GetTick>
 80085b6:	4602      	mov	r2, r0
 80085b8:	687b      	ldr	r3, [r7, #4]
 80085ba:	1ad3      	subs	r3, r2, r3
 80085bc:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80085c0:	d901      	bls.n	80085c6 <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
 80085c2:	2303      	movs	r3, #3
 80085c4:	e020      	b.n	8008608 <HAL_PWREx_EnableOverDrive+0x8c>
  __HAL_PWR_OVERDRIVE_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 80085c6:	4b13      	ldr	r3, [pc, #76]	; (8008614 <HAL_PWREx_EnableOverDrive+0x98>)
 80085c8:	685b      	ldr	r3, [r3, #4]
 80085ca:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80085ce:	2b00      	cmp	r3, #0
 80085d0:	d0ef      	beq.n	80085b2 <HAL_PWREx_EnableOverDrive+0x36>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 80085d2:	4a10      	ldr	r2, [pc, #64]	; (8008614 <HAL_PWREx_EnableOverDrive+0x98>)
 80085d4:	4b0f      	ldr	r3, [pc, #60]	; (8008614 <HAL_PWREx_EnableOverDrive+0x98>)
 80085d6:	681b      	ldr	r3, [r3, #0]
 80085d8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80085dc:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 80085de:	f7f8 fff1 	bl	80015c4 <HAL_GetTick>
 80085e2:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80085e4:	e009      	b.n	80085fa <HAL_PWREx_EnableOverDrive+0x7e>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 80085e6:	f7f8 ffed 	bl	80015c4 <HAL_GetTick>
 80085ea:	4602      	mov	r2, r0
 80085ec:	687b      	ldr	r3, [r7, #4]
 80085ee:	1ad3      	subs	r3, r2, r3
 80085f0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80085f4:	d901      	bls.n	80085fa <HAL_PWREx_EnableOverDrive+0x7e>
    {
      return HAL_TIMEOUT;
 80085f6:	2303      	movs	r3, #3
 80085f8:	e006      	b.n	8008608 <HAL_PWREx_EnableOverDrive+0x8c>
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80085fa:	4b06      	ldr	r3, [pc, #24]	; (8008614 <HAL_PWREx_EnableOverDrive+0x98>)
 80085fc:	685b      	ldr	r3, [r3, #4]
 80085fe:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008602:	2b00      	cmp	r3, #0
 8008604:	d0ef      	beq.n	80085e6 <HAL_PWREx_EnableOverDrive+0x6a>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8008606:	2300      	movs	r3, #0
}
 8008608:	4618      	mov	r0, r3
 800860a:	3708      	adds	r7, #8
 800860c:	46bd      	mov	sp, r7
 800860e:	bd80      	pop	{r7, pc}
 8008610:	40023800 	.word	0x40023800
 8008614:	40007000 	.word	0x40007000

08008618 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8008618:	b580      	push	{r7, lr}
 800861a:	b08e      	sub	sp, #56	; 0x38
 800861c:	af00      	add	r7, sp, #0
 800861e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;  
 8008620:	2300      	movs	r3, #0
 8008622:	637b      	str	r3, [r7, #52]	; 0x34
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8008624:	687b      	ldr	r3, [r7, #4]
 8008626:	681b      	ldr	r3, [r3, #0]
 8008628:	f003 0301 	and.w	r3, r3, #1
 800862c:	2b00      	cmp	r3, #0
 800862e:	f000 80ab 	beq.w	8008788 <HAL_RCC_OscConfig+0x170>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8008632:	4ba6      	ldr	r3, [pc, #664]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008634:	689b      	ldr	r3, [r3, #8]
 8008636:	f003 030c 	and.w	r3, r3, #12
 800863a:	2b04      	cmp	r3, #4
 800863c:	d00b      	beq.n	8008656 <HAL_RCC_OscConfig+0x3e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800863e:	4ba3      	ldr	r3, [pc, #652]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008640:	689b      	ldr	r3, [r3, #8]
 8008642:	f003 030c 	and.w	r3, r3, #12
 8008646:	2b08      	cmp	r3, #8
 8008648:	d112      	bne.n	8008670 <HAL_RCC_OscConfig+0x58>
 800864a:	4ba0      	ldr	r3, [pc, #640]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 800864c:	685b      	ldr	r3, [r3, #4]
 800864e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8008652:	2b00      	cmp	r3, #0
 8008654:	d00c      	beq.n	8008670 <HAL_RCC_OscConfig+0x58>
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8008656:	4b9d      	ldr	r3, [pc, #628]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008658:	681b      	ldr	r3, [r3, #0]
 800865a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800865e:	2b00      	cmp	r3, #0
 8008660:	d005      	beq.n	800866e <HAL_RCC_OscConfig+0x56>
 8008662:	687b      	ldr	r3, [r7, #4]
 8008664:	685b      	ldr	r3, [r3, #4]
 8008666:	2b00      	cmp	r3, #0
 8008668:	d101      	bne.n	800866e <HAL_RCC_OscConfig+0x56>
      {
        return HAL_ERROR;
 800866a:	2301      	movs	r3, #1
 800866c:	e2a3      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800866e:	e08b      	b.n	8008788 <HAL_RCC_OscConfig+0x170>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8008670:	4a96      	ldr	r2, [pc, #600]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008672:	4b96      	ldr	r3, [pc, #600]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008674:	681b      	ldr	r3, [r3, #0]
 8008676:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800867a:	6013      	str	r3, [r2, #0]
 800867c:	4a93      	ldr	r2, [pc, #588]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 800867e:	4b93      	ldr	r3, [pc, #588]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008680:	681b      	ldr	r3, [r3, #0]
 8008682:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8008686:	6013      	str	r3, [r2, #0]
 8008688:	4a90      	ldr	r2, [pc, #576]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 800868a:	4b90      	ldr	r3, [pc, #576]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 800868c:	681b      	ldr	r3, [r3, #0]
 800868e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008692:	6013      	str	r3, [r2, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008694:	f7f8 ff96 	bl	80015c4 <HAL_GetTick>
 8008698:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800869a:	e00a      	b.n	80086b2 <HAL_RCC_OscConfig+0x9a>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800869c:	f7f8 ff92 	bl	80015c4 <HAL_GetTick>
 80086a0:	4602      	mov	r2, r0
 80086a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80086a4:	1ad3      	subs	r3, r2, r3
 80086a6:	f241 3288 	movw	r2, #5000	; 0x1388
 80086aa:	4293      	cmp	r3, r2
 80086ac:	d901      	bls.n	80086b2 <HAL_RCC_OscConfig+0x9a>
        {
          return HAL_TIMEOUT;
 80086ae:	2303      	movs	r3, #3
 80086b0:	e281      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80086b2:	4b86      	ldr	r3, [pc, #536]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086b4:	681b      	ldr	r3, [r3, #0]
 80086b6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80086ba:	2b00      	cmp	r3, #0
 80086bc:	d1ee      	bne.n	800869c <HAL_RCC_OscConfig+0x84>
          return HAL_TIMEOUT;
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80086be:	4a83      	ldr	r2, [pc, #524]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086c0:	4b82      	ldr	r3, [pc, #520]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086c2:	681b      	ldr	r3, [r3, #0]
 80086c4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80086c8:	6013      	str	r3, [r2, #0]
 80086ca:	687b      	ldr	r3, [r7, #4]
 80086cc:	685b      	ldr	r3, [r3, #4]
 80086ce:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80086d2:	d10c      	bne.n	80086ee <HAL_RCC_OscConfig+0xd6>
 80086d4:	4a7d      	ldr	r2, [pc, #500]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086d6:	4b7d      	ldr	r3, [pc, #500]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086d8:	681b      	ldr	r3, [r3, #0]
 80086da:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80086de:	6013      	str	r3, [r2, #0]
 80086e0:	4a7a      	ldr	r2, [pc, #488]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086e2:	4b7a      	ldr	r3, [pc, #488]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086e4:	681b      	ldr	r3, [r3, #0]
 80086e6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80086ea:	6013      	str	r3, [r2, #0]
 80086ec:	e01d      	b.n	800872a <HAL_RCC_OscConfig+0x112>
 80086ee:	687b      	ldr	r3, [r7, #4]
 80086f0:	685b      	ldr	r3, [r3, #4]
 80086f2:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80086f6:	d10c      	bne.n	8008712 <HAL_RCC_OscConfig+0xfa>
 80086f8:	4a74      	ldr	r2, [pc, #464]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086fa:	4b74      	ldr	r3, [pc, #464]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80086fc:	681b      	ldr	r3, [r3, #0]
 80086fe:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8008702:	6013      	str	r3, [r2, #0]
 8008704:	4a71      	ldr	r2, [pc, #452]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008706:	4b71      	ldr	r3, [pc, #452]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008708:	681b      	ldr	r3, [r3, #0]
 800870a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800870e:	6013      	str	r3, [r2, #0]
 8008710:	e00b      	b.n	800872a <HAL_RCC_OscConfig+0x112>
 8008712:	4a6e      	ldr	r2, [pc, #440]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008714:	4b6d      	ldr	r3, [pc, #436]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008716:	681b      	ldr	r3, [r3, #0]
 8008718:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800871c:	6013      	str	r3, [r2, #0]
 800871e:	4a6b      	ldr	r2, [pc, #428]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008720:	4b6a      	ldr	r3, [pc, #424]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008722:	681b      	ldr	r3, [r3, #0]
 8008724:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008728:	6013      	str	r3, [r2, #0]
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800872a:	687b      	ldr	r3, [r7, #4]
 800872c:	685b      	ldr	r3, [r3, #4]
 800872e:	2b00      	cmp	r3, #0
 8008730:	d015      	beq.n	800875e <HAL_RCC_OscConfig+0x146>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008732:	f7f8 ff47 	bl	80015c4 <HAL_GetTick>
 8008736:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8008738:	e00a      	b.n	8008750 <HAL_RCC_OscConfig+0x138>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800873a:	f7f8 ff43 	bl	80015c4 <HAL_GetTick>
 800873e:	4602      	mov	r2, r0
 8008740:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008742:	1ad3      	subs	r3, r2, r3
 8008744:	f241 3288 	movw	r2, #5000	; 0x1388
 8008748:	4293      	cmp	r3, r2
 800874a:	d901      	bls.n	8008750 <HAL_RCC_OscConfig+0x138>
          {
            return HAL_TIMEOUT;
 800874c:	2303      	movs	r3, #3
 800874e:	e232      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8008750:	4b5e      	ldr	r3, [pc, #376]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008752:	681b      	ldr	r3, [r3, #0]
 8008754:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008758:	2b00      	cmp	r3, #0
 800875a:	d0ee      	beq.n	800873a <HAL_RCC_OscConfig+0x122>
 800875c:	e014      	b.n	8008788 <HAL_RCC_OscConfig+0x170>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800875e:	f7f8 ff31 	bl	80015c4 <HAL_GetTick>
 8008762:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8008764:	e00a      	b.n	800877c <HAL_RCC_OscConfig+0x164>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8008766:	f7f8 ff2d 	bl	80015c4 <HAL_GetTick>
 800876a:	4602      	mov	r2, r0
 800876c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800876e:	1ad3      	subs	r3, r2, r3
 8008770:	f241 3288 	movw	r2, #5000	; 0x1388
 8008774:	4293      	cmp	r3, r2
 8008776:	d901      	bls.n	800877c <HAL_RCC_OscConfig+0x164>
          {
            return HAL_TIMEOUT;
 8008778:	2303      	movs	r3, #3
 800877a:	e21c      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800877c:	4b53      	ldr	r3, [pc, #332]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 800877e:	681b      	ldr	r3, [r3, #0]
 8008780:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008784:	2b00      	cmp	r3, #0
 8008786:	d1ee      	bne.n	8008766 <HAL_RCC_OscConfig+0x14e>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8008788:	687b      	ldr	r3, [r7, #4]
 800878a:	681b      	ldr	r3, [r3, #0]
 800878c:	f003 0302 	and.w	r3, r3, #2
 8008790:	2b00      	cmp	r3, #0
 8008792:	d07d      	beq.n	8008890 <HAL_RCC_OscConfig+0x278>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8008794:	4b4d      	ldr	r3, [pc, #308]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008796:	689b      	ldr	r3, [r3, #8]
 8008798:	f003 030c 	and.w	r3, r3, #12
 800879c:	2b00      	cmp	r3, #0
 800879e:	d00b      	beq.n	80087b8 <HAL_RCC_OscConfig+0x1a0>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80087a0:	4b4a      	ldr	r3, [pc, #296]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80087a2:	689b      	ldr	r3, [r3, #8]
 80087a4:	f003 030c 	and.w	r3, r3, #12
 80087a8:	2b08      	cmp	r3, #8
 80087aa:	d126      	bne.n	80087fa <HAL_RCC_OscConfig+0x1e2>
 80087ac:	4b47      	ldr	r3, [pc, #284]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80087ae:	685b      	ldr	r3, [r3, #4]
 80087b0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80087b4:	2b00      	cmp	r3, #0
 80087b6:	d120      	bne.n	80087fa <HAL_RCC_OscConfig+0x1e2>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80087b8:	4b44      	ldr	r3, [pc, #272]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80087ba:	681b      	ldr	r3, [r3, #0]
 80087bc:	f003 0302 	and.w	r3, r3, #2
 80087c0:	2b00      	cmp	r3, #0
 80087c2:	d005      	beq.n	80087d0 <HAL_RCC_OscConfig+0x1b8>
 80087c4:	687b      	ldr	r3, [r7, #4]
 80087c6:	68db      	ldr	r3, [r3, #12]
 80087c8:	2b01      	cmp	r3, #1
 80087ca:	d001      	beq.n	80087d0 <HAL_RCC_OscConfig+0x1b8>
      {
        return HAL_ERROR;
 80087cc:	2301      	movs	r3, #1
 80087ce:	e1f2      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80087d0:	483e      	ldr	r0, [pc, #248]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80087d2:	4b3e      	ldr	r3, [pc, #248]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80087d4:	681b      	ldr	r3, [r3, #0]
 80087d6:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 80087da:	687b      	ldr	r3, [r7, #4]
 80087dc:	6919      	ldr	r1, [r3, #16]
 80087de:	23f8      	movs	r3, #248	; 0xf8
 80087e0:	633b      	str	r3, [r7, #48]	; 0x30
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80087e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80087e4:	fa93 f3a3 	rbit	r3, r3
 80087e8:	62fb      	str	r3, [r7, #44]	; 0x2c
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 80087ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80087ec:	fab3 f383 	clz	r3, r3
 80087f0:	fa01 f303 	lsl.w	r3, r1, r3
 80087f4:	4313      	orrs	r3, r2
 80087f6:	6003      	str	r3, [r0, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80087f8:	e04a      	b.n	8008890 <HAL_RCC_OscConfig+0x278>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80087fa:	687b      	ldr	r3, [r7, #4]
 80087fc:	68db      	ldr	r3, [r3, #12]
 80087fe:	2b00      	cmp	r3, #0
 8008800:	d02d      	beq.n	800885e <HAL_RCC_OscConfig+0x246>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8008802:	4a32      	ldr	r2, [pc, #200]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008804:	4b31      	ldr	r3, [pc, #196]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008806:	681b      	ldr	r3, [r3, #0]
 8008808:	f043 0301 	orr.w	r3, r3, #1
 800880c:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800880e:	f7f8 fed9 	bl	80015c4 <HAL_GetTick>
 8008812:	6378      	str	r0, [r7, #52]	; 0x34

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8008814:	e008      	b.n	8008828 <HAL_RCC_OscConfig+0x210>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8008816:	f7f8 fed5 	bl	80015c4 <HAL_GetTick>
 800881a:	4602      	mov	r2, r0
 800881c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800881e:	1ad3      	subs	r3, r2, r3
 8008820:	2b64      	cmp	r3, #100	; 0x64
 8008822:	d901      	bls.n	8008828 <HAL_RCC_OscConfig+0x210>
          {
            return HAL_TIMEOUT;
 8008824:	2303      	movs	r3, #3
 8008826:	e1c6      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8008828:	4b28      	ldr	r3, [pc, #160]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 800882a:	681b      	ldr	r3, [r3, #0]
 800882c:	f003 0302 	and.w	r3, r3, #2
 8008830:	2b00      	cmp	r3, #0
 8008832:	d0f0      	beq.n	8008816 <HAL_RCC_OscConfig+0x1fe>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8008834:	4825      	ldr	r0, [pc, #148]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008836:	4b25      	ldr	r3, [pc, #148]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008838:	681b      	ldr	r3, [r3, #0]
 800883a:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800883e:	687b      	ldr	r3, [r7, #4]
 8008840:	6919      	ldr	r1, [r3, #16]
 8008842:	23f8      	movs	r3, #248	; 0xf8
 8008844:	62bb      	str	r3, [r7, #40]	; 0x28
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008846:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008848:	fa93 f3a3 	rbit	r3, r3
 800884c:	627b      	str	r3, [r7, #36]	; 0x24
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800884e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008850:	fab3 f383 	clz	r3, r3
 8008854:	fa01 f303 	lsl.w	r3, r1, r3
 8008858:	4313      	orrs	r3, r2
 800885a:	6003      	str	r3, [r0, #0]
 800885c:	e018      	b.n	8008890 <HAL_RCC_OscConfig+0x278>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800885e:	4a1b      	ldr	r2, [pc, #108]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008860:	4b1a      	ldr	r3, [pc, #104]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008862:	681b      	ldr	r3, [r3, #0]
 8008864:	f023 0301 	bic.w	r3, r3, #1
 8008868:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800886a:	f7f8 feab 	bl	80015c4 <HAL_GetTick>
 800886e:	6378      	str	r0, [r7, #52]	; 0x34
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8008870:	e008      	b.n	8008884 <HAL_RCC_OscConfig+0x26c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8008872:	f7f8 fea7 	bl	80015c4 <HAL_GetTick>
 8008876:	4602      	mov	r2, r0
 8008878:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800887a:	1ad3      	subs	r3, r2, r3
 800887c:	2b64      	cmp	r3, #100	; 0x64
 800887e:	d901      	bls.n	8008884 <HAL_RCC_OscConfig+0x26c>
          {
            return HAL_TIMEOUT;
 8008880:	2303      	movs	r3, #3
 8008882:	e198      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8008884:	4b11      	ldr	r3, [pc, #68]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 8008886:	681b      	ldr	r3, [r3, #0]
 8008888:	f003 0302 	and.w	r3, r3, #2
 800888c:	2b00      	cmp	r3, #0
 800888e:	d1f0      	bne.n	8008872 <HAL_RCC_OscConfig+0x25a>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8008890:	687b      	ldr	r3, [r7, #4]
 8008892:	681b      	ldr	r3, [r3, #0]
 8008894:	f003 0308 	and.w	r3, r3, #8
 8008898:	2b00      	cmp	r3, #0
 800889a:	d039      	beq.n	8008910 <HAL_RCC_OscConfig+0x2f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800889c:	687b      	ldr	r3, [r7, #4]
 800889e:	695b      	ldr	r3, [r3, #20]
 80088a0:	2b00      	cmp	r3, #0
 80088a2:	d01c      	beq.n	80088de <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80088a4:	4a09      	ldr	r2, [pc, #36]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80088a6:	4b09      	ldr	r3, [pc, #36]	; (80088cc <HAL_RCC_OscConfig+0x2b4>)
 80088a8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80088aa:	f043 0301 	orr.w	r3, r3, #1
 80088ae:	6753      	str	r3, [r2, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80088b0:	f7f8 fe88 	bl	80015c4 <HAL_GetTick>
 80088b4:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80088b6:	e00b      	b.n	80088d0 <HAL_RCC_OscConfig+0x2b8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80088b8:	f7f8 fe84 	bl	80015c4 <HAL_GetTick>
 80088bc:	4602      	mov	r2, r0
 80088be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80088c0:	1ad3      	subs	r3, r2, r3
 80088c2:	2b64      	cmp	r3, #100	; 0x64
 80088c4:	d904      	bls.n	80088d0 <HAL_RCC_OscConfig+0x2b8>
        {
          return HAL_TIMEOUT;
 80088c6:	2303      	movs	r3, #3
 80088c8:	e175      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
 80088ca:	bf00      	nop
 80088cc:	40023800 	.word	0x40023800
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80088d0:	4ba8      	ldr	r3, [pc, #672]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80088d2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80088d4:	f003 0302 	and.w	r3, r3, #2
 80088d8:	2b00      	cmp	r3, #0
 80088da:	d0ed      	beq.n	80088b8 <HAL_RCC_OscConfig+0x2a0>
 80088dc:	e018      	b.n	8008910 <HAL_RCC_OscConfig+0x2f8>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80088de:	4aa5      	ldr	r2, [pc, #660]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80088e0:	4ba4      	ldr	r3, [pc, #656]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80088e2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80088e4:	f023 0301 	bic.w	r3, r3, #1
 80088e8:	6753      	str	r3, [r2, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80088ea:	f7f8 fe6b 	bl	80015c4 <HAL_GetTick>
 80088ee:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80088f0:	e008      	b.n	8008904 <HAL_RCC_OscConfig+0x2ec>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80088f2:	f7f8 fe67 	bl	80015c4 <HAL_GetTick>
 80088f6:	4602      	mov	r2, r0
 80088f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80088fa:	1ad3      	subs	r3, r2, r3
 80088fc:	2b64      	cmp	r3, #100	; 0x64
 80088fe:	d901      	bls.n	8008904 <HAL_RCC_OscConfig+0x2ec>
        {
          return HAL_TIMEOUT;
 8008900:	2303      	movs	r3, #3
 8008902:	e158      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8008904:	4b9b      	ldr	r3, [pc, #620]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008906:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008908:	f003 0302 	and.w	r3, r3, #2
 800890c:	2b00      	cmp	r3, #0
 800890e:	d1f0      	bne.n	80088f2 <HAL_RCC_OscConfig+0x2da>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8008910:	687b      	ldr	r3, [r7, #4]
 8008912:	681b      	ldr	r3, [r3, #0]
 8008914:	f003 0304 	and.w	r3, r3, #4
 8008918:	2b00      	cmp	r3, #0
 800891a:	f000 80af 	beq.w	8008a7c <HAL_RCC_OscConfig+0x464>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800891e:	4a95      	ldr	r2, [pc, #596]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008920:	4b94      	ldr	r3, [pc, #592]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008922:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008924:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8008928:	6413      	str	r3, [r2, #64]	; 0x40
 800892a:	4b92      	ldr	r3, [pc, #584]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 800892c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800892e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8008932:	60bb      	str	r3, [r7, #8]
 8008934:	68bb      	ldr	r3, [r7, #8]
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8008936:	4a90      	ldr	r2, [pc, #576]	; (8008b78 <HAL_RCC_OscConfig+0x560>)
 8008938:	4b8f      	ldr	r3, [pc, #572]	; (8008b78 <HAL_RCC_OscConfig+0x560>)
 800893a:	681b      	ldr	r3, [r3, #0]
 800893c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008940:	6013      	str	r3, [r2, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8008942:	f7f8 fe3f 	bl	80015c4 <HAL_GetTick>
 8008946:	6378      	str	r0, [r7, #52]	; 0x34
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8008948:	e008      	b.n	800895c <HAL_RCC_OscConfig+0x344>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800894a:	f7f8 fe3b 	bl	80015c4 <HAL_GetTick>
 800894e:	4602      	mov	r2, r0
 8008950:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008952:	1ad3      	subs	r3, r2, r3
 8008954:	2b64      	cmp	r3, #100	; 0x64
 8008956:	d901      	bls.n	800895c <HAL_RCC_OscConfig+0x344>
      {
        return HAL_TIMEOUT;
 8008958:	2303      	movs	r3, #3
 800895a:	e12c      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
    PWR->CR1 |= PWR_CR1_DBP;
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800895c:	4b86      	ldr	r3, [pc, #536]	; (8008b78 <HAL_RCC_OscConfig+0x560>)
 800895e:	681b      	ldr	r3, [r3, #0]
 8008960:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8008964:	2b00      	cmp	r3, #0
 8008966:	d0f0      	beq.n	800894a <HAL_RCC_OscConfig+0x332>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8008968:	4a82      	ldr	r2, [pc, #520]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 800896a:	4b82      	ldr	r3, [pc, #520]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 800896c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800896e:	f023 0301 	bic.w	r3, r3, #1
 8008972:	6713      	str	r3, [r2, #112]	; 0x70
 8008974:	4a7f      	ldr	r2, [pc, #508]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008976:	4b7f      	ldr	r3, [pc, #508]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008978:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800897a:	f023 0304 	bic.w	r3, r3, #4
 800897e:	6713      	str	r3, [r2, #112]	; 0x70
 8008980:	4a7c      	ldr	r2, [pc, #496]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008982:	4b7c      	ldr	r3, [pc, #496]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008984:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008986:	f023 0301 	bic.w	r3, r3, #1
 800898a:	6713      	str	r3, [r2, #112]	; 0x70
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800898c:	f7f8 fe1a 	bl	80015c4 <HAL_GetTick>
 8008990:	6378      	str	r0, [r7, #52]	; 0x34
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8008992:	e00a      	b.n	80089aa <HAL_RCC_OscConfig+0x392>
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8008994:	f7f8 fe16 	bl	80015c4 <HAL_GetTick>
 8008998:	4602      	mov	r2, r0
 800899a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800899c:	1ad3      	subs	r3, r2, r3
 800899e:	f241 3288 	movw	r2, #5000	; 0x1388
 80089a2:	4293      	cmp	r3, r2
 80089a4:	d901      	bls.n	80089aa <HAL_RCC_OscConfig+0x392>
      {
        return HAL_TIMEOUT;
 80089a6:	2303      	movs	r3, #3
 80089a8:	e105      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80089aa:	4b72      	ldr	r3, [pc, #456]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089ac:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80089ae:	f003 0302 	and.w	r3, r3, #2
 80089b2:	2b00      	cmp	r3, #0
 80089b4:	d1ee      	bne.n	8008994 <HAL_RCC_OscConfig+0x37c>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80089b6:	4a6f      	ldr	r2, [pc, #444]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089b8:	4b6e      	ldr	r3, [pc, #440]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089ba:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80089bc:	f023 0301 	bic.w	r3, r3, #1
 80089c0:	6713      	str	r3, [r2, #112]	; 0x70
 80089c2:	687b      	ldr	r3, [r7, #4]
 80089c4:	689b      	ldr	r3, [r3, #8]
 80089c6:	2b01      	cmp	r3, #1
 80089c8:	d10c      	bne.n	80089e4 <HAL_RCC_OscConfig+0x3cc>
 80089ca:	4a6a      	ldr	r2, [pc, #424]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089cc:	4b69      	ldr	r3, [pc, #420]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80089d0:	f023 0304 	bic.w	r3, r3, #4
 80089d4:	6713      	str	r3, [r2, #112]	; 0x70
 80089d6:	4a67      	ldr	r2, [pc, #412]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089d8:	4b66      	ldr	r3, [pc, #408]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80089dc:	f043 0301 	orr.w	r3, r3, #1
 80089e0:	6713      	str	r3, [r2, #112]	; 0x70
 80089e2:	e01c      	b.n	8008a1e <HAL_RCC_OscConfig+0x406>
 80089e4:	687b      	ldr	r3, [r7, #4]
 80089e6:	689b      	ldr	r3, [r3, #8]
 80089e8:	2b05      	cmp	r3, #5
 80089ea:	d10c      	bne.n	8008a06 <HAL_RCC_OscConfig+0x3ee>
 80089ec:	4a61      	ldr	r2, [pc, #388]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089ee:	4b61      	ldr	r3, [pc, #388]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80089f2:	f043 0304 	orr.w	r3, r3, #4
 80089f6:	6713      	str	r3, [r2, #112]	; 0x70
 80089f8:	4a5e      	ldr	r2, [pc, #376]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089fa:	4b5e      	ldr	r3, [pc, #376]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 80089fc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80089fe:	f043 0301 	orr.w	r3, r3, #1
 8008a02:	6713      	str	r3, [r2, #112]	; 0x70
 8008a04:	e00b      	b.n	8008a1e <HAL_RCC_OscConfig+0x406>
 8008a06:	4a5b      	ldr	r2, [pc, #364]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008a08:	4b5a      	ldr	r3, [pc, #360]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008a0a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008a0c:	f023 0304 	bic.w	r3, r3, #4
 8008a10:	6713      	str	r3, [r2, #112]	; 0x70
 8008a12:	4a58      	ldr	r2, [pc, #352]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008a14:	4b57      	ldr	r3, [pc, #348]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008a16:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008a18:	f023 0301 	bic.w	r3, r3, #1
 8008a1c:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8008a1e:	687b      	ldr	r3, [r7, #4]
 8008a20:	689b      	ldr	r3, [r3, #8]
 8008a22:	2b00      	cmp	r3, #0
 8008a24:	d015      	beq.n	8008a52 <HAL_RCC_OscConfig+0x43a>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008a26:	f7f8 fdcd 	bl	80015c4 <HAL_GetTick>
 8008a2a:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8008a2c:	e00a      	b.n	8008a44 <HAL_RCC_OscConfig+0x42c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8008a2e:	f7f8 fdc9 	bl	80015c4 <HAL_GetTick>
 8008a32:	4602      	mov	r2, r0
 8008a34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008a36:	1ad3      	subs	r3, r2, r3
 8008a38:	f241 3288 	movw	r2, #5000	; 0x1388
 8008a3c:	4293      	cmp	r3, r2
 8008a3e:	d901      	bls.n	8008a44 <HAL_RCC_OscConfig+0x42c>
        {
          return HAL_TIMEOUT;
 8008a40:	2303      	movs	r3, #3
 8008a42:	e0b8      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8008a44:	4b4b      	ldr	r3, [pc, #300]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008a46:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008a48:	f003 0302 	and.w	r3, r3, #2
 8008a4c:	2b00      	cmp	r3, #0
 8008a4e:	d0ee      	beq.n	8008a2e <HAL_RCC_OscConfig+0x416>
 8008a50:	e014      	b.n	8008a7c <HAL_RCC_OscConfig+0x464>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008a52:	f7f8 fdb7 	bl	80015c4 <HAL_GetTick>
 8008a56:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8008a58:	e00a      	b.n	8008a70 <HAL_RCC_OscConfig+0x458>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8008a5a:	f7f8 fdb3 	bl	80015c4 <HAL_GetTick>
 8008a5e:	4602      	mov	r2, r0
 8008a60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008a62:	1ad3      	subs	r3, r2, r3
 8008a64:	f241 3288 	movw	r2, #5000	; 0x1388
 8008a68:	4293      	cmp	r3, r2
 8008a6a:	d901      	bls.n	8008a70 <HAL_RCC_OscConfig+0x458>
        {
          return HAL_TIMEOUT;
 8008a6c:	2303      	movs	r3, #3
 8008a6e:	e0a2      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8008a70:	4b40      	ldr	r3, [pc, #256]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008a72:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008a74:	f003 0302 	and.w	r3, r3, #2
 8008a78:	2b00      	cmp	r3, #0
 8008a7a:	d1ee      	bne.n	8008a5a <HAL_RCC_OscConfig+0x442>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8008a7c:	687b      	ldr	r3, [r7, #4]
 8008a7e:	699b      	ldr	r3, [r3, #24]
 8008a80:	2b00      	cmp	r3, #0
 8008a82:	f000 8097 	beq.w	8008bb4 <HAL_RCC_OscConfig+0x59c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8008a86:	4b3b      	ldr	r3, [pc, #236]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008a88:	689b      	ldr	r3, [r3, #8]
 8008a8a:	f003 030c 	and.w	r3, r3, #12
 8008a8e:	2b08      	cmp	r3, #8
 8008a90:	f000 808e 	beq.w	8008bb0 <HAL_RCC_OscConfig+0x598>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8008a94:	687b      	ldr	r3, [r7, #4]
 8008a96:	699b      	ldr	r3, [r3, #24]
 8008a98:	2b02      	cmp	r3, #2
 8008a9a:	d16f      	bne.n	8008b7c <HAL_RCC_OscConfig+0x564>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8008a9c:	4a35      	ldr	r2, [pc, #212]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008a9e:	4b35      	ldr	r3, [pc, #212]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008aa0:	681b      	ldr	r3, [r3, #0]
 8008aa2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8008aa6:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008aa8:	f7f8 fd8c 	bl	80015c4 <HAL_GetTick>
 8008aac:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8008aae:	e008      	b.n	8008ac2 <HAL_RCC_OscConfig+0x4aa>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8008ab0:	f7f8 fd88 	bl	80015c4 <HAL_GetTick>
 8008ab4:	4602      	mov	r2, r0
 8008ab6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008ab8:	1ad3      	subs	r3, r2, r3
 8008aba:	2b64      	cmp	r3, #100	; 0x64
 8008abc:	d901      	bls.n	8008ac2 <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 8008abe:	2303      	movs	r3, #3
 8008ac0:	e079      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8008ac2:	4b2c      	ldr	r3, [pc, #176]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008ac4:	681b      	ldr	r3, [r3, #0]
 8008ac6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8008aca:	2b00      	cmp	r3, #0
 8008acc:	d1f0      	bne.n	8008ab0 <HAL_RCC_OscConfig+0x498>
            return HAL_TIMEOUT;
          }
        }
        
        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8008ace:	4829      	ldr	r0, [pc, #164]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008ad0:	687b      	ldr	r3, [r7, #4]
 8008ad2:	6a1a      	ldr	r2, [r3, #32]
 8008ad4:	687b      	ldr	r3, [r7, #4]
 8008ad6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8008ad8:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8008adc:	623b      	str	r3, [r7, #32]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008ade:	6a3b      	ldr	r3, [r7, #32]
 8008ae0:	fa93 f3a3 	rbit	r3, r3
 8008ae4:	61fb      	str	r3, [r7, #28]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008ae6:	69fb      	ldr	r3, [r7, #28]
 8008ae8:	fab3 f383 	clz	r3, r3
 8008aec:	fa01 f303 	lsl.w	r3, r1, r3
 8008af0:	431a      	orrs	r2, r3
 8008af2:	687b      	ldr	r3, [r7, #4]
 8008af4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008af6:	085b      	lsrs	r3, r3, #1
 8008af8:	1e59      	subs	r1, r3, #1
 8008afa:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8008afe:	61bb      	str	r3, [r7, #24]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008b00:	69bb      	ldr	r3, [r7, #24]
 8008b02:	fa93 f3a3 	rbit	r3, r3
 8008b06:	617b      	str	r3, [r7, #20]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008b08:	697b      	ldr	r3, [r7, #20]
 8008b0a:	fab3 f383 	clz	r3, r3
 8008b0e:	fa01 f303 	lsl.w	r3, r1, r3
 8008b12:	431a      	orrs	r2, r3
 8008b14:	687b      	ldr	r3, [r7, #4]
 8008b16:	69db      	ldr	r3, [r3, #28]
 8008b18:	431a      	orrs	r2, r3
 8008b1a:	687b      	ldr	r3, [r7, #4]
 8008b1c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8008b1e:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8008b22:	613b      	str	r3, [r7, #16]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008b24:	693b      	ldr	r3, [r7, #16]
 8008b26:	fa93 f3a3 	rbit	r3, r3
 8008b2a:	60fb      	str	r3, [r7, #12]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008b2c:	68fb      	ldr	r3, [r7, #12]
 8008b2e:	fab3 f383 	clz	r3, r3
 8008b32:	fa01 f303 	lsl.w	r3, r1, r3
 8008b36:	4313      	orrs	r3, r2
 8008b38:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8008b3c:	6043      	str	r3, [r0, #4]
                             RCC_OscInitStruct->PLL.PLLM,
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8008b3e:	4a0d      	ldr	r2, [pc, #52]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008b40:	4b0c      	ldr	r3, [pc, #48]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008b42:	681b      	ldr	r3, [r3, #0]
 8008b44:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008b48:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008b4a:	f7f8 fd3b 	bl	80015c4 <HAL_GetTick>
 8008b4e:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8008b50:	e008      	b.n	8008b64 <HAL_RCC_OscConfig+0x54c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8008b52:	f7f8 fd37 	bl	80015c4 <HAL_GetTick>
 8008b56:	4602      	mov	r2, r0
 8008b58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008b5a:	1ad3      	subs	r3, r2, r3
 8008b5c:	2b64      	cmp	r3, #100	; 0x64
 8008b5e:	d901      	bls.n	8008b64 <HAL_RCC_OscConfig+0x54c>
          {
            return HAL_TIMEOUT;
 8008b60:	2303      	movs	r3, #3
 8008b62:	e028      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8008b64:	4b03      	ldr	r3, [pc, #12]	; (8008b74 <HAL_RCC_OscConfig+0x55c>)
 8008b66:	681b      	ldr	r3, [r3, #0]
 8008b68:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8008b6c:	2b00      	cmp	r3, #0
 8008b6e:	d0f0      	beq.n	8008b52 <HAL_RCC_OscConfig+0x53a>
 8008b70:	e020      	b.n	8008bb4 <HAL_RCC_OscConfig+0x59c>
 8008b72:	bf00      	nop
 8008b74:	40023800 	.word	0x40023800
 8008b78:	40007000 	.word	0x40007000
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8008b7c:	4a10      	ldr	r2, [pc, #64]	; (8008bc0 <HAL_RCC_OscConfig+0x5a8>)
 8008b7e:	4b10      	ldr	r3, [pc, #64]	; (8008bc0 <HAL_RCC_OscConfig+0x5a8>)
 8008b80:	681b      	ldr	r3, [r3, #0]
 8008b82:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8008b86:	6013      	str	r3, [r2, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008b88:	f7f8 fd1c 	bl	80015c4 <HAL_GetTick>
 8008b8c:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8008b8e:	e008      	b.n	8008ba2 <HAL_RCC_OscConfig+0x58a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8008b90:	f7f8 fd18 	bl	80015c4 <HAL_GetTick>
 8008b94:	4602      	mov	r2, r0
 8008b96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008b98:	1ad3      	subs	r3, r2, r3
 8008b9a:	2b64      	cmp	r3, #100	; 0x64
 8008b9c:	d901      	bls.n	8008ba2 <HAL_RCC_OscConfig+0x58a>
          {
            return HAL_TIMEOUT;
 8008b9e:	2303      	movs	r3, #3
 8008ba0:	e009      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8008ba2:	4b07      	ldr	r3, [pc, #28]	; (8008bc0 <HAL_RCC_OscConfig+0x5a8>)
 8008ba4:	681b      	ldr	r3, [r3, #0]
 8008ba6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8008baa:	2b00      	cmp	r3, #0
 8008bac:	d1f0      	bne.n	8008b90 <HAL_RCC_OscConfig+0x578>
 8008bae:	e001      	b.n	8008bb4 <HAL_RCC_OscConfig+0x59c>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 8008bb0:	2301      	movs	r3, #1
 8008bb2:	e000      	b.n	8008bb6 <HAL_RCC_OscConfig+0x59e>
    }
  }
  return HAL_OK;
 8008bb4:	2300      	movs	r3, #0
}
 8008bb6:	4618      	mov	r0, r3
 8008bb8:	3738      	adds	r7, #56	; 0x38
 8008bba:	46bd      	mov	sp, r7
 8008bbc:	bd80      	pop	{r7, pc}
 8008bbe:	bf00      	nop
 8008bc0:	40023800 	.word	0x40023800

08008bc4 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8008bc4:	b580      	push	{r7, lr}
 8008bc6:	b084      	sub	sp, #16
 8008bc8:	af00      	add	r7, sp, #0
 8008bca:	6078      	str	r0, [r7, #4]
 8008bcc:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 8008bce:	2300      	movs	r3, #0
 8008bd0:	60fb      	str	r3, [r7, #12]
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
     must be correctly programmed according to the frequency of the CPU clock 
     (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8008bd2:	4b97      	ldr	r3, [pc, #604]	; (8008e30 <HAL_RCC_ClockConfig+0x26c>)
 8008bd4:	681b      	ldr	r3, [r3, #0]
 8008bd6:	f003 020f 	and.w	r2, r3, #15
 8008bda:	683b      	ldr	r3, [r7, #0]
 8008bdc:	429a      	cmp	r2, r3
 8008bde:	f080 8094 	bcs.w	8008d0a <HAL_RCC_ClockConfig+0x146>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008be2:	4993      	ldr	r1, [pc, #588]	; (8008e30 <HAL_RCC_ClockConfig+0x26c>)
 8008be4:	4b92      	ldr	r3, [pc, #584]	; (8008e30 <HAL_RCC_ClockConfig+0x26c>)
 8008be6:	681b      	ldr	r3, [r3, #0]
 8008be8:	f023 020f 	bic.w	r2, r3, #15
 8008bec:	683b      	ldr	r3, [r7, #0]
 8008bee:	4313      	orrs	r3, r2
 8008bf0:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8008bf2:	4b8f      	ldr	r3, [pc, #572]	; (8008e30 <HAL_RCC_ClockConfig+0x26c>)
 8008bf4:	681b      	ldr	r3, [r3, #0]
 8008bf6:	f003 020f 	and.w	r2, r3, #15
 8008bfa:	683b      	ldr	r3, [r7, #0]
 8008bfc:	429a      	cmp	r2, r3
 8008bfe:	d001      	beq.n	8008c04 <HAL_RCC_ClockConfig+0x40>
    {
      return HAL_ERROR;
 8008c00:	2301      	movs	r3, #1
 8008c02:	e13c      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8008c04:	687b      	ldr	r3, [r7, #4]
 8008c06:	681b      	ldr	r3, [r3, #0]
 8008c08:	f003 0302 	and.w	r3, r3, #2
 8008c0c:	2b00      	cmp	r3, #0
 8008c0e:	d008      	beq.n	8008c22 <HAL_RCC_ClockConfig+0x5e>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8008c10:	4988      	ldr	r1, [pc, #544]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008c12:	4b88      	ldr	r3, [pc, #544]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008c14:	689b      	ldr	r3, [r3, #8]
 8008c16:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8008c1a:	687b      	ldr	r3, [r7, #4]
 8008c1c:	689b      	ldr	r3, [r3, #8]
 8008c1e:	4313      	orrs	r3, r2
 8008c20:	608b      	str	r3, [r1, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8008c22:	687b      	ldr	r3, [r7, #4]
 8008c24:	681b      	ldr	r3, [r3, #0]
 8008c26:	f003 0301 	and.w	r3, r3, #1
 8008c2a:	2b00      	cmp	r3, #0
 8008c2c:	f000 8104 	beq.w	8008e38 <HAL_RCC_ClockConfig+0x274>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008c30:	687b      	ldr	r3, [r7, #4]
 8008c32:	685b      	ldr	r3, [r3, #4]
 8008c34:	2b01      	cmp	r3, #1
 8008c36:	d107      	bne.n	8008c48 <HAL_RCC_ClockConfig+0x84>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8008c38:	4b7e      	ldr	r3, [pc, #504]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008c3a:	681b      	ldr	r3, [r3, #0]
 8008c3c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008c40:	2b00      	cmp	r3, #0
 8008c42:	d115      	bne.n	8008c70 <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 8008c44:	2301      	movs	r3, #1
 8008c46:	e11a      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008c48:	687b      	ldr	r3, [r7, #4]
 8008c4a:	685b      	ldr	r3, [r3, #4]
 8008c4c:	2b02      	cmp	r3, #2
 8008c4e:	d107      	bne.n	8008c60 <HAL_RCC_ClockConfig+0x9c>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8008c50:	4b78      	ldr	r3, [pc, #480]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008c52:	681b      	ldr	r3, [r3, #0]
 8008c54:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8008c58:	2b00      	cmp	r3, #0
 8008c5a:	d109      	bne.n	8008c70 <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 8008c5c:	2301      	movs	r3, #1
 8008c5e:	e10e      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8008c60:	4b74      	ldr	r3, [pc, #464]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008c62:	681b      	ldr	r3, [r3, #0]
 8008c64:	f003 0302 	and.w	r3, r3, #2
 8008c68:	2b00      	cmp	r3, #0
 8008c6a:	d101      	bne.n	8008c70 <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 8008c6c:	2301      	movs	r3, #1
 8008c6e:	e106      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8008c70:	4970      	ldr	r1, [pc, #448]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008c72:	4b70      	ldr	r3, [pc, #448]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008c74:	689b      	ldr	r3, [r3, #8]
 8008c76:	f023 0203 	bic.w	r2, r3, #3
 8008c7a:	687b      	ldr	r3, [r7, #4]
 8008c7c:	685b      	ldr	r3, [r3, #4]
 8008c7e:	4313      	orrs	r3, r2
 8008c80:	608b      	str	r3, [r1, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008c82:	f7f8 fc9f 	bl	80015c4 <HAL_GetTick>
 8008c86:	60f8      	str	r0, [r7, #12]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008c88:	687b      	ldr	r3, [r7, #4]
 8008c8a:	685b      	ldr	r3, [r3, #4]
 8008c8c:	2b01      	cmp	r3, #1
 8008c8e:	d112      	bne.n	8008cb6 <HAL_RCC_ClockConfig+0xf2>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8008c90:	e00a      	b.n	8008ca8 <HAL_RCC_ClockConfig+0xe4>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008c92:	f7f8 fc97 	bl	80015c4 <HAL_GetTick>
 8008c96:	4602      	mov	r2, r0
 8008c98:	68fb      	ldr	r3, [r7, #12]
 8008c9a:	1ad3      	subs	r3, r2, r3
 8008c9c:	f241 3288 	movw	r2, #5000	; 0x1388
 8008ca0:	4293      	cmp	r3, r2
 8008ca2:	d901      	bls.n	8008ca8 <HAL_RCC_ClockConfig+0xe4>
          {
            return HAL_TIMEOUT;
 8008ca4:	2303      	movs	r3, #3
 8008ca6:	e0ea      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8008ca8:	4b62      	ldr	r3, [pc, #392]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008caa:	689b      	ldr	r3, [r3, #8]
 8008cac:	f003 030c 	and.w	r3, r3, #12
 8008cb0:	2b04      	cmp	r3, #4
 8008cb2:	d1ee      	bne.n	8008c92 <HAL_RCC_ClockConfig+0xce>
 8008cb4:	e0c0      	b.n	8008e38 <HAL_RCC_ClockConfig+0x274>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008cb6:	687b      	ldr	r3, [r7, #4]
 8008cb8:	685b      	ldr	r3, [r3, #4]
 8008cba:	2b02      	cmp	r3, #2
 8008cbc:	d112      	bne.n	8008ce4 <HAL_RCC_ClockConfig+0x120>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8008cbe:	e00a      	b.n	8008cd6 <HAL_RCC_ClockConfig+0x112>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008cc0:	f7f8 fc80 	bl	80015c4 <HAL_GetTick>
 8008cc4:	4602      	mov	r2, r0
 8008cc6:	68fb      	ldr	r3, [r7, #12]
 8008cc8:	1ad3      	subs	r3, r2, r3
 8008cca:	f241 3288 	movw	r2, #5000	; 0x1388
 8008cce:	4293      	cmp	r3, r2
 8008cd0:	d901      	bls.n	8008cd6 <HAL_RCC_ClockConfig+0x112>
          {
            return HAL_TIMEOUT;
 8008cd2:	2303      	movs	r3, #3
 8008cd4:	e0d3      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8008cd6:	4b57      	ldr	r3, [pc, #348]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008cd8:	689b      	ldr	r3, [r3, #8]
 8008cda:	f003 030c 	and.w	r3, r3, #12
 8008cde:	2b08      	cmp	r3, #8
 8008ce0:	d1ee      	bne.n	8008cc0 <HAL_RCC_ClockConfig+0xfc>
 8008ce2:	e0a9      	b.n	8008e38 <HAL_RCC_ClockConfig+0x274>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8008ce4:	e00a      	b.n	8008cfc <HAL_RCC_ClockConfig+0x138>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008ce6:	f7f8 fc6d 	bl	80015c4 <HAL_GetTick>
 8008cea:	4602      	mov	r2, r0
 8008cec:	68fb      	ldr	r3, [r7, #12]
 8008cee:	1ad3      	subs	r3, r2, r3
 8008cf0:	f241 3288 	movw	r2, #5000	; 0x1388
 8008cf4:	4293      	cmp	r3, r2
 8008cf6:	d901      	bls.n	8008cfc <HAL_RCC_ClockConfig+0x138>
          {
            return HAL_TIMEOUT;
 8008cf8:	2303      	movs	r3, #3
 8008cfa:	e0c0      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8008cfc:	4b4d      	ldr	r3, [pc, #308]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008cfe:	689b      	ldr	r3, [r3, #8]
 8008d00:	f003 030c 	and.w	r3, r3, #12
 8008d04:	2b00      	cmp	r3, #0
 8008d06:	d1ee      	bne.n	8008ce6 <HAL_RCC_ClockConfig+0x122>
 8008d08:	e096      	b.n	8008e38 <HAL_RCC_ClockConfig+0x274>
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8008d0a:	687b      	ldr	r3, [r7, #4]
 8008d0c:	681b      	ldr	r3, [r3, #0]
 8008d0e:	f003 0302 	and.w	r3, r3, #2
 8008d12:	2b00      	cmp	r3, #0
 8008d14:	d008      	beq.n	8008d28 <HAL_RCC_ClockConfig+0x164>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8008d16:	4947      	ldr	r1, [pc, #284]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008d18:	4b46      	ldr	r3, [pc, #280]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008d1a:	689b      	ldr	r3, [r3, #8]
 8008d1c:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8008d20:	687b      	ldr	r3, [r7, #4]
 8008d22:	689b      	ldr	r3, [r3, #8]
 8008d24:	4313      	orrs	r3, r2
 8008d26:	608b      	str	r3, [r1, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	681b      	ldr	r3, [r3, #0]
 8008d2c:	f003 0301 	and.w	r3, r3, #1
 8008d30:	2b00      	cmp	r3, #0
 8008d32:	d06b      	beq.n	8008e0c <HAL_RCC_ClockConfig+0x248>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008d34:	687b      	ldr	r3, [r7, #4]
 8008d36:	685b      	ldr	r3, [r3, #4]
 8008d38:	2b01      	cmp	r3, #1
 8008d3a:	d107      	bne.n	8008d4c <HAL_RCC_ClockConfig+0x188>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8008d3c:	4b3d      	ldr	r3, [pc, #244]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008d3e:	681b      	ldr	r3, [r3, #0]
 8008d40:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008d44:	2b00      	cmp	r3, #0
 8008d46:	d115      	bne.n	8008d74 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 8008d48:	2301      	movs	r3, #1
 8008d4a:	e098      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008d4c:	687b      	ldr	r3, [r7, #4]
 8008d4e:	685b      	ldr	r3, [r3, #4]
 8008d50:	2b02      	cmp	r3, #2
 8008d52:	d107      	bne.n	8008d64 <HAL_RCC_ClockConfig+0x1a0>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8008d54:	4b37      	ldr	r3, [pc, #220]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008d56:	681b      	ldr	r3, [r3, #0]
 8008d58:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8008d5c:	2b00      	cmp	r3, #0
 8008d5e:	d109      	bne.n	8008d74 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 8008d60:	2301      	movs	r3, #1
 8008d62:	e08c      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8008d64:	4b33      	ldr	r3, [pc, #204]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008d66:	681b      	ldr	r3, [r3, #0]
 8008d68:	f003 0302 	and.w	r3, r3, #2
 8008d6c:	2b00      	cmp	r3, #0
 8008d6e:	d101      	bne.n	8008d74 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 8008d70:	2301      	movs	r3, #1
 8008d72:	e084      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8008d74:	492f      	ldr	r1, [pc, #188]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008d76:	4b2f      	ldr	r3, [pc, #188]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008d78:	689b      	ldr	r3, [r3, #8]
 8008d7a:	f023 0203 	bic.w	r2, r3, #3
 8008d7e:	687b      	ldr	r3, [r7, #4]
 8008d80:	685b      	ldr	r3, [r3, #4]
 8008d82:	4313      	orrs	r3, r2
 8008d84:	608b      	str	r3, [r1, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008d86:	f7f8 fc1d 	bl	80015c4 <HAL_GetTick>
 8008d8a:	60f8      	str	r0, [r7, #12]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008d8c:	687b      	ldr	r3, [r7, #4]
 8008d8e:	685b      	ldr	r3, [r3, #4]
 8008d90:	2b01      	cmp	r3, #1
 8008d92:	d112      	bne.n	8008dba <HAL_RCC_ClockConfig+0x1f6>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8008d94:	e00a      	b.n	8008dac <HAL_RCC_ClockConfig+0x1e8>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008d96:	f7f8 fc15 	bl	80015c4 <HAL_GetTick>
 8008d9a:	4602      	mov	r2, r0
 8008d9c:	68fb      	ldr	r3, [r7, #12]
 8008d9e:	1ad3      	subs	r3, r2, r3
 8008da0:	f241 3288 	movw	r2, #5000	; 0x1388
 8008da4:	4293      	cmp	r3, r2
 8008da6:	d901      	bls.n	8008dac <HAL_RCC_ClockConfig+0x1e8>
          {
            return HAL_TIMEOUT;
 8008da8:	2303      	movs	r3, #3
 8008daa:	e068      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8008dac:	4b21      	ldr	r3, [pc, #132]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008dae:	689b      	ldr	r3, [r3, #8]
 8008db0:	f003 030c 	and.w	r3, r3, #12
 8008db4:	2b04      	cmp	r3, #4
 8008db6:	d1ee      	bne.n	8008d96 <HAL_RCC_ClockConfig+0x1d2>
 8008db8:	e028      	b.n	8008e0c <HAL_RCC_ClockConfig+0x248>
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008dba:	687b      	ldr	r3, [r7, #4]
 8008dbc:	685b      	ldr	r3, [r3, #4]
 8008dbe:	2b02      	cmp	r3, #2
 8008dc0:	d112      	bne.n	8008de8 <HAL_RCC_ClockConfig+0x224>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8008dc2:	e00a      	b.n	8008dda <HAL_RCC_ClockConfig+0x216>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008dc4:	f7f8 fbfe 	bl	80015c4 <HAL_GetTick>
 8008dc8:	4602      	mov	r2, r0
 8008dca:	68fb      	ldr	r3, [r7, #12]
 8008dcc:	1ad3      	subs	r3, r2, r3
 8008dce:	f241 3288 	movw	r2, #5000	; 0x1388
 8008dd2:	4293      	cmp	r3, r2
 8008dd4:	d901      	bls.n	8008dda <HAL_RCC_ClockConfig+0x216>
          {
            return HAL_TIMEOUT;
 8008dd6:	2303      	movs	r3, #3
 8008dd8:	e051      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8008dda:	4b16      	ldr	r3, [pc, #88]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008ddc:	689b      	ldr	r3, [r3, #8]
 8008dde:	f003 030c 	and.w	r3, r3, #12
 8008de2:	2b08      	cmp	r3, #8
 8008de4:	d1ee      	bne.n	8008dc4 <HAL_RCC_ClockConfig+0x200>
 8008de6:	e011      	b.n	8008e0c <HAL_RCC_ClockConfig+0x248>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8008de8:	e00a      	b.n	8008e00 <HAL_RCC_ClockConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008dea:	f7f8 fbeb 	bl	80015c4 <HAL_GetTick>
 8008dee:	4602      	mov	r2, r0
 8008df0:	68fb      	ldr	r3, [r7, #12]
 8008df2:	1ad3      	subs	r3, r2, r3
 8008df4:	f241 3288 	movw	r2, #5000	; 0x1388
 8008df8:	4293      	cmp	r3, r2
 8008dfa:	d901      	bls.n	8008e00 <HAL_RCC_ClockConfig+0x23c>
          {
            return HAL_TIMEOUT;
 8008dfc:	2303      	movs	r3, #3
 8008dfe:	e03e      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8008e00:	4b0c      	ldr	r3, [pc, #48]	; (8008e34 <HAL_RCC_ClockConfig+0x270>)
 8008e02:	689b      	ldr	r3, [r3, #8]
 8008e04:	f003 030c 	and.w	r3, r3, #12
 8008e08:	2b00      	cmp	r3, #0
 8008e0a:	d1ee      	bne.n	8008dea <HAL_RCC_ClockConfig+0x226>
        }
      }
    }
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008e0c:	4908      	ldr	r1, [pc, #32]	; (8008e30 <HAL_RCC_ClockConfig+0x26c>)
 8008e0e:	4b08      	ldr	r3, [pc, #32]	; (8008e30 <HAL_RCC_ClockConfig+0x26c>)
 8008e10:	681b      	ldr	r3, [r3, #0]
 8008e12:	f023 020f 	bic.w	r2, r3, #15
 8008e16:	683b      	ldr	r3, [r7, #0]
 8008e18:	4313      	orrs	r3, r2
 8008e1a:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8008e1c:	4b04      	ldr	r3, [pc, #16]	; (8008e30 <HAL_RCC_ClockConfig+0x26c>)
 8008e1e:	681b      	ldr	r3, [r3, #0]
 8008e20:	f003 020f 	and.w	r2, r3, #15
 8008e24:	683b      	ldr	r3, [r7, #0]
 8008e26:	429a      	cmp	r2, r3
 8008e28:	d006      	beq.n	8008e38 <HAL_RCC_ClockConfig+0x274>
    {
      return HAL_ERROR;
 8008e2a:	2301      	movs	r3, #1
 8008e2c:	e027      	b.n	8008e7e <HAL_RCC_ClockConfig+0x2ba>
 8008e2e:	bf00      	nop
 8008e30:	40023c00 	.word	0x40023c00
 8008e34:	40023800 	.word	0x40023800
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8008e38:	687b      	ldr	r3, [r7, #4]
 8008e3a:	681b      	ldr	r3, [r3, #0]
 8008e3c:	f003 0304 	and.w	r3, r3, #4
 8008e40:	2b00      	cmp	r3, #0
 8008e42:	d008      	beq.n	8008e56 <HAL_RCC_ClockConfig+0x292>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8008e44:	4910      	ldr	r1, [pc, #64]	; (8008e88 <HAL_RCC_ClockConfig+0x2c4>)
 8008e46:	4b10      	ldr	r3, [pc, #64]	; (8008e88 <HAL_RCC_ClockConfig+0x2c4>)
 8008e48:	689b      	ldr	r3, [r3, #8]
 8008e4a:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8008e4e:	687b      	ldr	r3, [r7, #4]
 8008e50:	68db      	ldr	r3, [r3, #12]
 8008e52:	4313      	orrs	r3, r2
 8008e54:	608b      	str	r3, [r1, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8008e56:	687b      	ldr	r3, [r7, #4]
 8008e58:	681b      	ldr	r3, [r3, #0]
 8008e5a:	f003 0308 	and.w	r3, r3, #8
 8008e5e:	2b00      	cmp	r3, #0
 8008e60:	d009      	beq.n	8008e76 <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8008e62:	4909      	ldr	r1, [pc, #36]	; (8008e88 <HAL_RCC_ClockConfig+0x2c4>)
 8008e64:	4b08      	ldr	r3, [pc, #32]	; (8008e88 <HAL_RCC_ClockConfig+0x2c4>)
 8008e66:	689b      	ldr	r3, [r3, #8]
 8008e68:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8008e6c:	687b      	ldr	r3, [r7, #4]
 8008e6e:	691b      	ldr	r3, [r3, #16]
 8008e70:	00db      	lsls	r3, r3, #3
 8008e72:	4313      	orrs	r3, r2
 8008e74:	608b      	str	r3, [r1, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8008e76:	200f      	movs	r0, #15
 8008e78:	f004 fc14 	bl	800d6a4 <HAL_InitTick>
  
  return HAL_OK;
 8008e7c:	2300      	movs	r3, #0
}
 8008e7e:	4618      	mov	r0, r3
 8008e80:	3710      	adds	r7, #16
 8008e82:	46bd      	mov	sp, r7
 8008e84:	bd80      	pop	{r7, pc}
 8008e86:	bf00      	nop
 8008e88:	40023800 	.word	0x40023800

08008e8c <HAL_RCC_GetSysClockFreq>:
  *         
  *               
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8008e8c:	b480      	push	{r7}
 8008e8e:	b08b      	sub	sp, #44	; 0x2c
 8008e90:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
 8008e92:	2300      	movs	r3, #0
 8008e94:	61fb      	str	r3, [r7, #28]
 8008e96:	2300      	movs	r3, #0
 8008e98:	627b      	str	r3, [r7, #36]	; 0x24
 8008e9a:	2300      	movs	r3, #0
 8008e9c:	61bb      	str	r3, [r7, #24]
  uint32_t sysclockfreq = 0;
 8008e9e:	2300      	movs	r3, #0
 8008ea0:	623b      	str	r3, [r7, #32]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8008ea2:	4b36      	ldr	r3, [pc, #216]	; (8008f7c <HAL_RCC_GetSysClockFreq+0xf0>)
 8008ea4:	689b      	ldr	r3, [r3, #8]
 8008ea6:	f003 030c 	and.w	r3, r3, #12
 8008eaa:	2b04      	cmp	r3, #4
 8008eac:	d006      	beq.n	8008ebc <HAL_RCC_GetSysClockFreq+0x30>
 8008eae:	2b08      	cmp	r3, #8
 8008eb0:	d007      	beq.n	8008ec2 <HAL_RCC_GetSysClockFreq+0x36>
 8008eb2:	2b00      	cmp	r3, #0
 8008eb4:	d158      	bne.n	8008f68 <HAL_RCC_GetSysClockFreq+0xdc>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8008eb6:	4b32      	ldr	r3, [pc, #200]	; (8008f80 <HAL_RCC_GetSysClockFreq+0xf4>)
 8008eb8:	623b      	str	r3, [r7, #32]
       break;
 8008eba:	e058      	b.n	8008f6e <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8008ebc:	4b31      	ldr	r3, [pc, #196]	; (8008f84 <HAL_RCC_GetSysClockFreq+0xf8>)
 8008ebe:	623b      	str	r3, [r7, #32]
      break;
 8008ec0:	e055      	b.n	8008f6e <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8008ec2:	4b2e      	ldr	r3, [pc, #184]	; (8008f7c <HAL_RCC_GetSysClockFreq+0xf0>)
 8008ec4:	685b      	ldr	r3, [r3, #4]
 8008ec6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008eca:	61fb      	str	r3, [r7, #28]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8008ecc:	4b2b      	ldr	r3, [pc, #172]	; (8008f7c <HAL_RCC_GetSysClockFreq+0xf0>)
 8008ece:	685b      	ldr	r3, [r3, #4]
 8008ed0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8008ed4:	2b00      	cmp	r3, #0
 8008ed6:	d017      	beq.n	8008f08 <HAL_RCC_GetSysClockFreq+0x7c>
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8008ed8:	4a2a      	ldr	r2, [pc, #168]	; (8008f84 <HAL_RCC_GetSysClockFreq+0xf8>)
 8008eda:	69fb      	ldr	r3, [r7, #28]
 8008edc:	fbb2 f2f3 	udiv	r2, r2, r3
 8008ee0:	4b26      	ldr	r3, [pc, #152]	; (8008f7c <HAL_RCC_GetSysClockFreq+0xf0>)
 8008ee2:	6859      	ldr	r1, [r3, #4]
 8008ee4:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8008ee8:	400b      	ands	r3, r1
 8008eea:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8008eee:	6179      	str	r1, [r7, #20]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008ef0:	6979      	ldr	r1, [r7, #20]
 8008ef2:	fa91 f1a1 	rbit	r1, r1
 8008ef6:	6139      	str	r1, [r7, #16]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008ef8:	6939      	ldr	r1, [r7, #16]
 8008efa:	fab1 f181 	clz	r1, r1
 8008efe:	40cb      	lsrs	r3, r1
 8008f00:	fb03 f302 	mul.w	r3, r3, r2
 8008f04:	627b      	str	r3, [r7, #36]	; 0x24
 8008f06:	e016      	b.n	8008f36 <HAL_RCC_GetSysClockFreq+0xaa>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8008f08:	4a1d      	ldr	r2, [pc, #116]	; (8008f80 <HAL_RCC_GetSysClockFreq+0xf4>)
 8008f0a:	69fb      	ldr	r3, [r7, #28]
 8008f0c:	fbb2 f2f3 	udiv	r2, r2, r3
 8008f10:	4b1a      	ldr	r3, [pc, #104]	; (8008f7c <HAL_RCC_GetSysClockFreq+0xf0>)
 8008f12:	6859      	ldr	r1, [r3, #4]
 8008f14:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8008f18:	400b      	ands	r3, r1
 8008f1a:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8008f1e:	60f9      	str	r1, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008f20:	68f9      	ldr	r1, [r7, #12]
 8008f22:	fa91 f1a1 	rbit	r1, r1
 8008f26:	60b9      	str	r1, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008f28:	68b9      	ldr	r1, [r7, #8]
 8008f2a:	fab1 f181 	clz	r1, r1
 8008f2e:	40cb      	lsrs	r3, r1
 8008f30:	fb03 f302 	mul.w	r3, r3, r2
 8008f34:	627b      	str	r3, [r7, #36]	; 0x24
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8008f36:	4b11      	ldr	r3, [pc, #68]	; (8008f7c <HAL_RCC_GetSysClockFreq+0xf0>)
 8008f38:	685b      	ldr	r3, [r3, #4]
 8008f3a:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 8008f3e:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8008f42:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008f44:	687b      	ldr	r3, [r7, #4]
 8008f46:	fa93 f3a3 	rbit	r3, r3
 8008f4a:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008f4c:	683b      	ldr	r3, [r7, #0]
 8008f4e:	fab3 f383 	clz	r3, r3
 8008f52:	fa22 f303 	lsr.w	r3, r2, r3
 8008f56:	3301      	adds	r3, #1
 8008f58:	005b      	lsls	r3, r3, #1
 8008f5a:	61bb      	str	r3, [r7, #24]
      
      sysclockfreq = pllvco/pllp;
 8008f5c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008f5e:	69bb      	ldr	r3, [r7, #24]
 8008f60:	fbb2 f3f3 	udiv	r3, r2, r3
 8008f64:	623b      	str	r3, [r7, #32]
      break;
 8008f66:	e002      	b.n	8008f6e <HAL_RCC_GetSysClockFreq+0xe2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8008f68:	4b05      	ldr	r3, [pc, #20]	; (8008f80 <HAL_RCC_GetSysClockFreq+0xf4>)
 8008f6a:	623b      	str	r3, [r7, #32]
      break;
 8008f6c:	bf00      	nop
    }
  }
  return sysclockfreq;
 8008f6e:	6a3b      	ldr	r3, [r7, #32]
}
 8008f70:	4618      	mov	r0, r3
 8008f72:	372c      	adds	r7, #44	; 0x2c
 8008f74:	46bd      	mov	sp, r7
 8008f76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f7a:	4770      	bx	lr
 8008f7c:	40023800 	.word	0x40023800
 8008f80:	00f42400 	.word	0x00f42400
 8008f84:	017d7840 	.word	0x017d7840

08008f88 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8008f88:	b580      	push	{r7, lr}
 8008f8a:	b082      	sub	sp, #8
 8008f8c:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8008f8e:	f7ff ff7d 	bl	8008e8c <HAL_RCC_GetSysClockFreq>
 8008f92:	4601      	mov	r1, r0
 8008f94:	4b0d      	ldr	r3, [pc, #52]	; (8008fcc <HAL_RCC_GetHCLKFreq+0x44>)
 8008f96:	689b      	ldr	r3, [r3, #8]
 8008f98:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8008f9c:	23f0      	movs	r3, #240	; 0xf0
 8008f9e:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008fa0:	687b      	ldr	r3, [r7, #4]
 8008fa2:	fa93 f3a3 	rbit	r3, r3
 8008fa6:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008fa8:	683b      	ldr	r3, [r7, #0]
 8008faa:	fab3 f383 	clz	r3, r3
 8008fae:	fa22 f303 	lsr.w	r3, r2, r3
 8008fb2:	4a07      	ldr	r2, [pc, #28]	; (8008fd0 <HAL_RCC_GetHCLKFreq+0x48>)
 8008fb4:	5cd3      	ldrb	r3, [r2, r3]
 8008fb6:	fa21 f303 	lsr.w	r3, r1, r3
 8008fba:	4a06      	ldr	r2, [pc, #24]	; (8008fd4 <HAL_RCC_GetHCLKFreq+0x4c>)
 8008fbc:	6013      	str	r3, [r2, #0]
  return SystemCoreClock;
 8008fbe:	4b05      	ldr	r3, [pc, #20]	; (8008fd4 <HAL_RCC_GetHCLKFreq+0x4c>)
 8008fc0:	681b      	ldr	r3, [r3, #0]
}
 8008fc2:	4618      	mov	r0, r3
 8008fc4:	3708      	adds	r7, #8
 8008fc6:	46bd      	mov	sp, r7
 8008fc8:	bd80      	pop	{r7, pc}
 8008fca:	bf00      	nop
 8008fcc:	40023800 	.word	0x40023800
 8008fd0:	080243d8 	.word	0x080243d8
 8008fd4:	20010000 	.word	0x20010000

08008fd8 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 8008fd8:	b580      	push	{r7, lr}
 8008fda:	b082      	sub	sp, #8
 8008fdc:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8008fde:	f7ff ffd3 	bl	8008f88 <HAL_RCC_GetHCLKFreq>
 8008fe2:	4601      	mov	r1, r0
 8008fe4:	4b0b      	ldr	r3, [pc, #44]	; (8009014 <HAL_RCC_GetPCLK1Freq+0x3c>)
 8008fe6:	689b      	ldr	r3, [r3, #8]
 8008fe8:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 8008fec:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8008ff0:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8008ff2:	687b      	ldr	r3, [r7, #4]
 8008ff4:	fa93 f3a3 	rbit	r3, r3
 8008ff8:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8008ffa:	683b      	ldr	r3, [r7, #0]
 8008ffc:	fab3 f383 	clz	r3, r3
 8009000:	fa22 f303 	lsr.w	r3, r2, r3
 8009004:	4a04      	ldr	r2, [pc, #16]	; (8009018 <HAL_RCC_GetPCLK1Freq+0x40>)
 8009006:	5cd3      	ldrb	r3, [r2, r3]
 8009008:	fa21 f303 	lsr.w	r3, r1, r3
}
 800900c:	4618      	mov	r0, r3
 800900e:	3708      	adds	r7, #8
 8009010:	46bd      	mov	sp, r7
 8009012:	bd80      	pop	{r7, pc}
 8009014:	40023800 	.word	0x40023800
 8009018:	080243d8 	.word	0x080243d8

0800901c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800901c:	b580      	push	{r7, lr}
 800901e:	b082      	sub	sp, #8
 8009020:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8009022:	f7ff ffb1 	bl	8008f88 <HAL_RCC_GetHCLKFreq>
 8009026:	4601      	mov	r1, r0
 8009028:	4b0b      	ldr	r3, [pc, #44]	; (8009058 <HAL_RCC_GetPCLK2Freq+0x3c>)
 800902a:	689b      	ldr	r3, [r3, #8]
 800902c:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
 8009030:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8009034:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8009036:	687b      	ldr	r3, [r7, #4]
 8009038:	fa93 f3a3 	rbit	r3, r3
 800903c:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800903e:	683b      	ldr	r3, [r7, #0]
 8009040:	fab3 f383 	clz	r3, r3
 8009044:	fa22 f303 	lsr.w	r3, r2, r3
 8009048:	4a04      	ldr	r2, [pc, #16]	; (800905c <HAL_RCC_GetPCLK2Freq+0x40>)
 800904a:	5cd3      	ldrb	r3, [r2, r3]
 800904c:	fa21 f303 	lsr.w	r3, r1, r3
} 
 8009050:	4618      	mov	r0, r3
 8009052:	3708      	adds	r7, #8
 8009054:	46bd      	mov	sp, r7
 8009056:	bd80      	pop	{r7, pc}
 8009058:	40023800 	.word	0x40023800
 800905c:	080243d8 	.word	0x080243d8

08009060 <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing: Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
 8009060:	b580      	push	{r7, lr}
 8009062:	b082      	sub	sp, #8
 8009064:	af00      	add	r7, sp, #0
 8009066:	6078      	str	r0, [r7, #4]
 8009068:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 800906a:	687b      	ldr	r3, [r7, #4]
 800906c:	2b00      	cmp	r3, #0
 800906e:	d101      	bne.n	8009074 <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
 8009070:	2301      	movs	r3, #1
 8009072:	e026      	b.n	80090c2 <HAL_SDRAM_Init+0x62>
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 8009074:	687b      	ldr	r3, [r7, #4]
 8009076:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800907a:	b2db      	uxtb	r3, r3
 800907c:	2b00      	cmp	r3, #0
 800907e:	d106      	bne.n	800908e <HAL_SDRAM_Init+0x2e>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 8009080:	687b      	ldr	r3, [r7, #4]
 8009082:	2200      	movs	r2, #0
 8009084:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 8009088:	6878      	ldr	r0, [r7, #4]
 800908a:	f000 f81f 	bl	80090cc <HAL_SDRAM_MspInit>
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800908e:	687b      	ldr	r3, [r7, #4]
 8009090:	2202      	movs	r2, #2
 8009092:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 8009096:	687b      	ldr	r3, [r7, #4]
 8009098:	681a      	ldr	r2, [r3, #0]
 800909a:	687b      	ldr	r3, [r7, #4]
 800909c:	3304      	adds	r3, #4
 800909e:	4610      	mov	r0, r2
 80090a0:	4619      	mov	r1, r3
 80090a2:	f001 fe01 	bl	800aca8 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 80090a6:	687b      	ldr	r3, [r7, #4]
 80090a8:	681a      	ldr	r2, [r3, #0]
 80090aa:	687b      	ldr	r3, [r7, #4]
 80090ac:	685b      	ldr	r3, [r3, #4]
 80090ae:	4610      	mov	r0, r2
 80090b0:	6839      	ldr	r1, [r7, #0]
 80090b2:	461a      	mov	r2, r3
 80090b4:	f001 fe6a 	bl	800ad8c <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 80090b8:	687b      	ldr	r3, [r7, #4]
 80090ba:	2201      	movs	r2, #1
 80090bc:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;
 80090c0:	2300      	movs	r3, #0
}
 80090c2:	4618      	mov	r0, r3
 80090c4:	3708      	adds	r7, #8
 80090c6:	46bd      	mov	sp, r7
 80090c8:	bd80      	pop	{r7, pc}
 80090ca:	bf00      	nop

080090cc <HAL_SDRAM_MspInit>:
  * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */
__weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
{
 80090cc:	b480      	push	{r7}
 80090ce:	b083      	sub	sp, #12
 80090d0:	af00      	add	r7, sp, #0
 80090d2:	6078      	str	r0, [r7, #4]
  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */ 
}
 80090d4:	370c      	adds	r7, #12
 80090d6:	46bd      	mov	sp, r7
 80090d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80090dc:	4770      	bx	lr
 80090de:	bf00      	nop

080090e0 <HAL_SDRAM_SendCommand>:
  * @param  Command: SDRAM command structure
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 80090e0:	b580      	push	{r7, lr}
 80090e2:	b084      	sub	sp, #16
 80090e4:	af00      	add	r7, sp, #0
 80090e6:	60f8      	str	r0, [r7, #12]
 80090e8:	60b9      	str	r1, [r7, #8]
 80090ea:	607a      	str	r2, [r7, #4]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80090ec:	68fb      	ldr	r3, [r7, #12]
 80090ee:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80090f2:	b2db      	uxtb	r3, r3
 80090f4:	2b02      	cmp	r3, #2
 80090f6:	d101      	bne.n	80090fc <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
 80090f8:	2302      	movs	r3, #2
 80090fa:	e018      	b.n	800912e <HAL_SDRAM_SendCommand+0x4e>
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80090fc:	68fb      	ldr	r3, [r7, #12]
 80090fe:	2202      	movs	r2, #2
 8009100:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8009104:	68fb      	ldr	r3, [r7, #12]
 8009106:	681b      	ldr	r3, [r3, #0]
 8009108:	4618      	mov	r0, r3
 800910a:	68b9      	ldr	r1, [r7, #8]
 800910c:	687a      	ldr	r2, [r7, #4]
 800910e:	f001 febb 	bl	800ae88 <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8009112:	68bb      	ldr	r3, [r7, #8]
 8009114:	681b      	ldr	r3, [r3, #0]
 8009116:	2b02      	cmp	r3, #2
 8009118:	d104      	bne.n	8009124 <HAL_SDRAM_SendCommand+0x44>
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800911a:	68fb      	ldr	r3, [r7, #12]
 800911c:	2205      	movs	r2, #5
 800911e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8009122:	e003      	b.n	800912c <HAL_SDRAM_SendCommand+0x4c>
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
 8009124:	68fb      	ldr	r3, [r7, #12]
 8009126:	2201      	movs	r2, #1
 8009128:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  }
  
  return HAL_OK;  
 800912c:	2300      	movs	r3, #0
}
 800912e:	4618      	mov	r0, r3
 8009130:	3710      	adds	r7, #16
 8009132:	46bd      	mov	sp, r7
 8009134:	bd80      	pop	{r7, pc}
 8009136:	bf00      	nop

08009138 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate: The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 8009138:	b580      	push	{r7, lr}
 800913a:	b082      	sub	sp, #8
 800913c:	af00      	add	r7, sp, #0
 800913e:	6078      	str	r0, [r7, #4]
 8009140:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8009142:	687b      	ldr	r3, [r7, #4]
 8009144:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8009148:	b2db      	uxtb	r3, r3
 800914a:	2b02      	cmp	r3, #2
 800914c:	d101      	bne.n	8009152 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
 800914e:	2302      	movs	r3, #2
 8009150:	e00e      	b.n	8009170 <HAL_SDRAM_ProgramRefreshRate+0x38>
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8009152:	687b      	ldr	r3, [r7, #4]
 8009154:	2202      	movs	r2, #2
 8009156:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 800915a:	687b      	ldr	r3, [r7, #4]
 800915c:	681b      	ldr	r3, [r3, #0]
 800915e:	4618      	mov	r0, r3
 8009160:	6839      	ldr	r1, [r7, #0]
 8009162:	f001 fecf 	bl	800af04 <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8009166:	687b      	ldr	r3, [r7, #4]
 8009168:	2201      	movs	r2, #1
 800916a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;   
 800916e:	2300      	movs	r3, #0
}
 8009170:	4618      	mov	r0, r3
 8009172:	3708      	adds	r7, #8
 8009174:	46bd      	mov	sp, r7
 8009176:	bd80      	pop	{r7, pc}

08009178 <HAL_TIM_Base_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
{  
 8009178:	b580      	push	{r7, lr}
 800917a:	b082      	sub	sp, #8
 800917c:	af00      	add	r7, sp, #0
 800917e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
 8009180:	687b      	ldr	r3, [r7, #4]
 8009182:	2202      	movs	r2, #2
 8009184:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
   
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 8009188:	687b      	ldr	r3, [r7, #4]
 800918a:	681b      	ldr	r3, [r3, #0]
 800918c:	6a1a      	ldr	r2, [r3, #32]
 800918e:	f241 1311 	movw	r3, #4369	; 0x1111
 8009192:	4013      	ands	r3, r2
 8009194:	2b00      	cmp	r3, #0
 8009196:	d10f      	bne.n	80091b8 <HAL_TIM_Base_DeInit+0x40>
 8009198:	687b      	ldr	r3, [r7, #4]
 800919a:	681b      	ldr	r3, [r3, #0]
 800919c:	6a1a      	ldr	r2, [r3, #32]
 800919e:	f240 4344 	movw	r3, #1092	; 0x444
 80091a2:	4013      	ands	r3, r2
 80091a4:	2b00      	cmp	r3, #0
 80091a6:	d107      	bne.n	80091b8 <HAL_TIM_Base_DeInit+0x40>
 80091a8:	687b      	ldr	r3, [r7, #4]
 80091aa:	681b      	ldr	r3, [r3, #0]
 80091ac:	687a      	ldr	r2, [r7, #4]
 80091ae:	6812      	ldr	r2, [r2, #0]
 80091b0:	6812      	ldr	r2, [r2, #0]
 80091b2:	f022 0201 	bic.w	r2, r2, #1
 80091b6:	601a      	str	r2, [r3, #0]
    
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Base_MspDeInit(htim);
 80091b8:	6878      	ldr	r0, [r7, #4]
 80091ba:	f000 f80d 	bl	80091d8 <HAL_TIM_Base_MspDeInit>
  
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET; 
 80091be:	687b      	ldr	r3, [r7, #4]
 80091c0:	2200      	movs	r2, #0
 80091c2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Release Lock */
  __HAL_UNLOCK(htim);
 80091c6:	687b      	ldr	r3, [r7, #4]
 80091c8:	2200      	movs	r2, #0
 80091ca:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 80091ce:	2300      	movs	r3, #0
}
 80091d0:	4618      	mov	r0, r3
 80091d2:	3708      	adds	r7, #8
 80091d4:	46bd      	mov	sp, r7
 80091d6:	bd80      	pop	{r7, pc}

080091d8 <HAL_TIM_Base_MspDeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
{
 80091d8:	b480      	push	{r7}
 80091da:	b083      	sub	sp, #12
 80091dc:	af00      	add	r7, sp, #0
 80091de:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspDeInit could be implemented in the user file
   */
}
 80091e0:	370c      	adds	r7, #12
 80091e2:	46bd      	mov	sp, r7
 80091e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091e8:	4770      	bx	lr
 80091ea:	bf00      	nop

080091ec <HAL_TIM_PWM_Init>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 80091ec:	b580      	push	{r7, lr}
 80091ee:	b082      	sub	sp, #8
 80091f0:	af00      	add	r7, sp, #0
 80091f2:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if(htim == NULL)
 80091f4:	687b      	ldr	r3, [r7, #4]
 80091f6:	2b00      	cmp	r3, #0
 80091f8:	d101      	bne.n	80091fe <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 80091fa:	2301      	movs	r3, #1
 80091fc:	e01d      	b.n	800923a <HAL_TIM_PWM_Init+0x4e>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 80091fe:	687b      	ldr	r3, [r7, #4]
 8009200:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8009204:	b2db      	uxtb	r3, r3
 8009206:	2b00      	cmp	r3, #0
 8009208:	d106      	bne.n	8009218 <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;  
 800920a:	687b      	ldr	r3, [r7, #4]
 800920c:	2200      	movs	r2, #0
 800920e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 8009212:	6878      	ldr	r0, [r7, #4]
 8009214:	f005 fd60 	bl	800ecd8 <HAL_TIM_PWM_MspInit>
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;  
 8009218:	687b      	ldr	r3, [r7, #4]
 800921a:	2202      	movs	r2, #2
 800921c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Init the base time for the PWM */  
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 8009220:	687b      	ldr	r3, [r7, #4]
 8009222:	681a      	ldr	r2, [r3, #0]
 8009224:	687b      	ldr	r3, [r7, #4]
 8009226:	3304      	adds	r3, #4
 8009228:	4610      	mov	r0, r2
 800922a:	4619      	mov	r1, r3
 800922c:	f000 faea 	bl	8009804 <TIM_Base_SetConfig>
   
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 8009230:	687b      	ldr	r3, [r7, #4]
 8009232:	2201      	movs	r2, #1
 8009234:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 8009238:	2300      	movs	r3, #0
}  
 800923a:	4618      	mov	r0, r3
 800923c:	3708      	adds	r7, #8
 800923e:	46bd      	mov	sp, r7
 8009240:	bd80      	pop	{r7, pc}
 8009242:	bf00      	nop

08009244 <HAL_TIM_PWM_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
{
 8009244:	b580      	push	{r7, lr}
 8009246:	b082      	sub	sp, #8
 8009248:	af00      	add	r7, sp, #0
 800924a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  htim->State = HAL_TIM_STATE_BUSY;
 800924c:	687b      	ldr	r3, [r7, #4]
 800924e:	2202      	movs	r2, #2
 8009250:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 8009254:	687b      	ldr	r3, [r7, #4]
 8009256:	681b      	ldr	r3, [r3, #0]
 8009258:	6a1a      	ldr	r2, [r3, #32]
 800925a:	f241 1311 	movw	r3, #4369	; 0x1111
 800925e:	4013      	ands	r3, r2
 8009260:	2b00      	cmp	r3, #0
 8009262:	d10f      	bne.n	8009284 <HAL_TIM_PWM_DeInit+0x40>
 8009264:	687b      	ldr	r3, [r7, #4]
 8009266:	681b      	ldr	r3, [r3, #0]
 8009268:	6a1a      	ldr	r2, [r3, #32]
 800926a:	f240 4344 	movw	r3, #1092	; 0x444
 800926e:	4013      	ands	r3, r2
 8009270:	2b00      	cmp	r3, #0
 8009272:	d107      	bne.n	8009284 <HAL_TIM_PWM_DeInit+0x40>
 8009274:	687b      	ldr	r3, [r7, #4]
 8009276:	681b      	ldr	r3, [r3, #0]
 8009278:	687a      	ldr	r2, [r7, #4]
 800927a:	6812      	ldr	r2, [r2, #0]
 800927c:	6812      	ldr	r2, [r2, #0]
 800927e:	f022 0201 	bic.w	r2, r2, #1
 8009282:	601a      	str	r2, [r3, #0]
    
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_PWM_MspDeInit(htim);
 8009284:	6878      	ldr	r0, [r7, #4]
 8009286:	f005 fdc9 	bl	800ee1c <HAL_TIM_PWM_MspDeInit>
    
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET; 
 800928a:	687b      	ldr	r3, [r7, #4]
 800928c:	2200      	movs	r2, #0
 800928e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Release Lock */
  __HAL_UNLOCK(htim);
 8009292:	687b      	ldr	r3, [r7, #4]
 8009294:	2200      	movs	r2, #0
 8009296:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 800929a:	2300      	movs	r3, #0
}
 800929c:	4618      	mov	r0, r3
 800929e:	3708      	adds	r7, #8
 80092a0:	46bd      	mov	sp, r7
 80092a2:	bd80      	pop	{r7, pc}

080092a4 <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 80092a4:	b580      	push	{r7, lr}
 80092a6:	b082      	sub	sp, #8
 80092a8:	af00      	add	r7, sp, #0
 80092aa:	6078      	str	r0, [r7, #4]
 80092ac:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 80092ae:	687b      	ldr	r3, [r7, #4]
 80092b0:	681b      	ldr	r3, [r3, #0]
 80092b2:	4618      	mov	r0, r3
 80092b4:	6839      	ldr	r1, [r7, #0]
 80092b6:	2201      	movs	r2, #1
 80092b8:	f000 fd14 	bl	8009ce4 <TIM_CCxChannelCmd>
  
  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
 80092bc:	687b      	ldr	r3, [r7, #4]
 80092be:	681b      	ldr	r3, [r3, #0]
 80092c0:	4a10      	ldr	r2, [pc, #64]	; (8009304 <HAL_TIM_PWM_Start+0x60>)
 80092c2:	4293      	cmp	r3, r2
 80092c4:	d004      	beq.n	80092d0 <HAL_TIM_PWM_Start+0x2c>
 80092c6:	687b      	ldr	r3, [r7, #4]
 80092c8:	681b      	ldr	r3, [r3, #0]
 80092ca:	4a0f      	ldr	r2, [pc, #60]	; (8009308 <HAL_TIM_PWM_Start+0x64>)
 80092cc:	4293      	cmp	r3, r2
 80092ce:	d101      	bne.n	80092d4 <HAL_TIM_PWM_Start+0x30>
 80092d0:	2301      	movs	r3, #1
 80092d2:	e000      	b.n	80092d6 <HAL_TIM_PWM_Start+0x32>
 80092d4:	2300      	movs	r3, #0
 80092d6:	2b00      	cmp	r3, #0
 80092d8:	d007      	beq.n	80092ea <HAL_TIM_PWM_Start+0x46>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 80092da:	687b      	ldr	r3, [r7, #4]
 80092dc:	681b      	ldr	r3, [r3, #0]
 80092de:	687a      	ldr	r2, [r7, #4]
 80092e0:	6812      	ldr	r2, [r2, #0]
 80092e2:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80092e4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80092e8:	645a      	str	r2, [r3, #68]	; 0x44
  }
    
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 80092ea:	687b      	ldr	r3, [r7, #4]
 80092ec:	681b      	ldr	r3, [r3, #0]
 80092ee:	687a      	ldr	r2, [r7, #4]
 80092f0:	6812      	ldr	r2, [r2, #0]
 80092f2:	6812      	ldr	r2, [r2, #0]
 80092f4:	f042 0201 	orr.w	r2, r2, #1
 80092f8:	601a      	str	r2, [r3, #0]
  
  /* Return function status */
  return HAL_OK;
 80092fa:	2300      	movs	r3, #0
} 
 80092fc:	4618      	mov	r0, r3
 80092fe:	3708      	adds	r7, #8
 8009300:	46bd      	mov	sp, r7
 8009302:	bd80      	pop	{r7, pc}
 8009304:	40010000 	.word	0x40010000
 8009308:	40010400 	.word	0x40010400

0800930c <HAL_TIM_IC_Init>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
{
 800930c:	b580      	push	{r7, lr}
 800930e:	b082      	sub	sp, #8
 8009310:	af00      	add	r7, sp, #0
 8009312:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if(htim == NULL)
 8009314:	687b      	ldr	r3, [r7, #4]
 8009316:	2b00      	cmp	r3, #0
 8009318:	d101      	bne.n	800931e <HAL_TIM_IC_Init+0x12>
  {
    return HAL_ERROR;
 800931a:	2301      	movs	r3, #1
 800931c:	e01d      	b.n	800935a <HAL_TIM_IC_Init+0x4e>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 

  if(htim->State == HAL_TIM_STATE_RESET)
 800931e:	687b      	ldr	r3, [r7, #4]
 8009320:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8009324:	b2db      	uxtb	r3, r3
 8009326:	2b00      	cmp	r3, #0
 8009328:	d106      	bne.n	8009338 <HAL_TIM_IC_Init+0x2c>
  { 
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;   
 800932a:	687b      	ldr	r3, [r7, #4]
 800932c:	2200      	movs	r2, #0
 800932e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_IC_MspInit(htim);
 8009332:	6878      	ldr	r0, [r7, #4]
 8009334:	f000 f816 	bl	8009364 <HAL_TIM_IC_MspInit>
  }
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;   
 8009338:	687b      	ldr	r3, [r7, #4]
 800933a:	2202      	movs	r2, #2
 800933c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Init the base time for the input capture */  
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 8009340:	687b      	ldr	r3, [r7, #4]
 8009342:	681a      	ldr	r2, [r3, #0]
 8009344:	687b      	ldr	r3, [r7, #4]
 8009346:	3304      	adds	r3, #4
 8009348:	4610      	mov	r0, r2
 800934a:	4619      	mov	r1, r3
 800934c:	f000 fa5a 	bl	8009804 <TIM_Base_SetConfig>
   
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 8009350:	687b      	ldr	r3, [r7, #4]
 8009352:	2201      	movs	r2, #1
 8009354:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 8009358:	2300      	movs	r3, #0
}
 800935a:	4618      	mov	r0, r3
 800935c:	3708      	adds	r7, #8
 800935e:	46bd      	mov	sp, r7
 8009360:	bd80      	pop	{r7, pc}
 8009362:	bf00      	nop

08009364 <HAL_TIM_IC_MspInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
{
 8009364:	b480      	push	{r7}
 8009366:	b083      	sub	sp, #12
 8009368:	af00      	add	r7, sp, #0
 800936a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspInit could be implemented in the user file
   */
}
 800936c:	370c      	adds	r7, #12
 800936e:	46bd      	mov	sp, r7
 8009370:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009374:	4770      	bx	lr
 8009376:	bf00      	nop

08009378 <HAL_TIM_Encoder_Init>:
  *                the configuration information for TIM module.
  * @param  sConfig: TIM Encoder Interface configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
{
 8009378:	b580      	push	{r7, lr}
 800937a:	b086      	sub	sp, #24
 800937c:	af00      	add	r7, sp, #0
 800937e:	6078      	str	r0, [r7, #4]
 8009380:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr = 0;
 8009382:	2300      	movs	r3, #0
 8009384:	617b      	str	r3, [r7, #20]
  uint32_t tmpccmr1 = 0;
 8009386:	2300      	movs	r3, #0
 8009388:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800938a:	2300      	movs	r3, #0
 800938c:	60fb      	str	r3, [r7, #12]
  
  /* Check the TIM handle allocation */
  if(htim == NULL)
 800938e:	687b      	ldr	r3, [r7, #4]
 8009390:	2b00      	cmp	r3, #0
 8009392:	d101      	bne.n	8009398 <HAL_TIM_Encoder_Init+0x20>
  {
    return HAL_ERROR;
 8009394:	2301      	movs	r3, #1
 8009396:	e07b      	b.n	8009490 <HAL_TIM_Encoder_Init+0x118>
  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));

  if(htim->State == HAL_TIM_STATE_RESET)
 8009398:	687b      	ldr	r3, [r7, #4]
 800939a:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800939e:	b2db      	uxtb	r3, r3
 80093a0:	2b00      	cmp	r3, #0
 80093a2:	d106      	bne.n	80093b2 <HAL_TIM_Encoder_Init+0x3a>
  { 
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;  
 80093a4:	687b      	ldr	r3, [r7, #4]
 80093a6:	2200      	movs	r2, #0
 80093a8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_Encoder_MspInit(htim);
 80093ac:	6878      	ldr	r0, [r7, #4]
 80093ae:	f005 f8cd 	bl	800e54c <HAL_TIM_Encoder_MspInit>
  }
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;   
 80093b2:	687b      	ldr	r3, [r7, #4]
 80093b4:	2202      	movs	r2, #2
 80093b6:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  /* Reset the SMS bits */
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 80093ba:	687b      	ldr	r3, [r7, #4]
 80093bc:	681a      	ldr	r2, [r3, #0]
 80093be:	687b      	ldr	r3, [r7, #4]
 80093c0:	681b      	ldr	r3, [r3, #0]
 80093c2:	6899      	ldr	r1, [r3, #8]
 80093c4:	4b34      	ldr	r3, [pc, #208]	; (8009498 <HAL_TIM_Encoder_Init+0x120>)
 80093c6:	400b      	ands	r3, r1
 80093c8:	6093      	str	r3, [r2, #8]
  
  /* Configure the Time base in the Encoder Mode */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);  
 80093ca:	687b      	ldr	r3, [r7, #4]
 80093cc:	681a      	ldr	r2, [r3, #0]
 80093ce:	687b      	ldr	r3, [r7, #4]
 80093d0:	3304      	adds	r3, #4
 80093d2:	4610      	mov	r0, r2
 80093d4:	4619      	mov	r1, r3
 80093d6:	f000 fa15 	bl	8009804 <TIM_Base_SetConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 80093da:	687b      	ldr	r3, [r7, #4]
 80093dc:	681b      	ldr	r3, [r3, #0]
 80093de:	689b      	ldr	r3, [r3, #8]
 80093e0:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = htim->Instance->CCMR1;
 80093e2:	687b      	ldr	r3, [r7, #4]
 80093e4:	681b      	ldr	r3, [r3, #0]
 80093e6:	699b      	ldr	r3, [r3, #24]
 80093e8:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCER register value */
  tmpccer = htim->Instance->CCER;
 80093ea:	687b      	ldr	r3, [r7, #4]
 80093ec:	681b      	ldr	r3, [r3, #0]
 80093ee:	6a1b      	ldr	r3, [r3, #32]
 80093f0:	60fb      	str	r3, [r7, #12]

  /* Set the encoder Mode */
  tmpsmcr |= sConfig->EncoderMode;
 80093f2:	683b      	ldr	r3, [r7, #0]
 80093f4:	681b      	ldr	r3, [r3, #0]
 80093f6:	697a      	ldr	r2, [r7, #20]
 80093f8:	4313      	orrs	r3, r2
 80093fa:	617b      	str	r3, [r7, #20]

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 80093fc:	693a      	ldr	r2, [r7, #16]
 80093fe:	4b27      	ldr	r3, [pc, #156]	; (800949c <HAL_TIM_Encoder_Init+0x124>)
 8009400:	4013      	ands	r3, r2
 8009402:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
 8009404:	683b      	ldr	r3, [r7, #0]
 8009406:	689a      	ldr	r2, [r3, #8]
 8009408:	683b      	ldr	r3, [r7, #0]
 800940a:	699b      	ldr	r3, [r3, #24]
 800940c:	021b      	lsls	r3, r3, #8
 800940e:	4313      	orrs	r3, r2
 8009410:	693a      	ldr	r2, [r7, #16]
 8009412:	4313      	orrs	r3, r2
 8009414:	613b      	str	r3, [r7, #16]
  
  /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
  tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
 8009416:	693a      	ldr	r2, [r7, #16]
 8009418:	4b21      	ldr	r3, [pc, #132]	; (80094a0 <HAL_TIM_Encoder_Init+0x128>)
 800941a:	4013      	ands	r3, r2
 800941c:	613b      	str	r3, [r7, #16]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 800941e:	693a      	ldr	r2, [r7, #16]
 8009420:	4b20      	ldr	r3, [pc, #128]	; (80094a4 <HAL_TIM_Encoder_Init+0x12c>)
 8009422:	4013      	ands	r3, r2
 8009424:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
 8009426:	683b      	ldr	r3, [r7, #0]
 8009428:	68da      	ldr	r2, [r3, #12]
 800942a:	683b      	ldr	r3, [r7, #0]
 800942c:	69db      	ldr	r3, [r3, #28]
 800942e:	021b      	lsls	r3, r3, #8
 8009430:	4313      	orrs	r3, r2
 8009432:	693a      	ldr	r2, [r7, #16]
 8009434:	4313      	orrs	r3, r2
 8009436:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
 8009438:	683b      	ldr	r3, [r7, #0]
 800943a:	691b      	ldr	r3, [r3, #16]
 800943c:	011a      	lsls	r2, r3, #4
 800943e:	683b      	ldr	r3, [r7, #0]
 8009440:	6a1b      	ldr	r3, [r3, #32]
 8009442:	031b      	lsls	r3, r3, #12
 8009444:	4313      	orrs	r3, r2
 8009446:	693a      	ldr	r2, [r7, #16]
 8009448:	4313      	orrs	r3, r2
 800944a:	613b      	str	r3, [r7, #16]

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
 800944c:	68fb      	ldr	r3, [r7, #12]
 800944e:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 8009452:	60fb      	str	r3, [r7, #12]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
 8009454:	68fb      	ldr	r3, [r7, #12]
 8009456:	f023 0388 	bic.w	r3, r3, #136	; 0x88
 800945a:	60fb      	str	r3, [r7, #12]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
 800945c:	683b      	ldr	r3, [r7, #0]
 800945e:	685a      	ldr	r2, [r3, #4]
 8009460:	683b      	ldr	r3, [r7, #0]
 8009462:	695b      	ldr	r3, [r3, #20]
 8009464:	011b      	lsls	r3, r3, #4
 8009466:	4313      	orrs	r3, r2
 8009468:	68fa      	ldr	r2, [r7, #12]
 800946a:	4313      	orrs	r3, r2
 800946c:	60fb      	str	r3, [r7, #12]
  
  /* Write to TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 800946e:	687b      	ldr	r3, [r7, #4]
 8009470:	681b      	ldr	r3, [r3, #0]
 8009472:	697a      	ldr	r2, [r7, #20]
 8009474:	609a      	str	r2, [r3, #8]

  /* Write to TIMx CCMR1 */
  htim->Instance->CCMR1 = tmpccmr1;
 8009476:	687b      	ldr	r3, [r7, #4]
 8009478:	681b      	ldr	r3, [r3, #0]
 800947a:	693a      	ldr	r2, [r7, #16]
 800947c:	619a      	str	r2, [r3, #24]

  /* Write to TIMx CCER */
  htim->Instance->CCER = tmpccer;
 800947e:	687b      	ldr	r3, [r7, #4]
 8009480:	681b      	ldr	r3, [r3, #0]
 8009482:	68fa      	ldr	r2, [r7, #12]
 8009484:	621a      	str	r2, [r3, #32]
  
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 8009486:	687b      	ldr	r3, [r7, #4]
 8009488:	2201      	movs	r2, #1
 800948a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 800948e:	2300      	movs	r3, #0
}
 8009490:	4618      	mov	r0, r3
 8009492:	3718      	adds	r7, #24
 8009494:	46bd      	mov	sp, r7
 8009496:	bd80      	pop	{r7, pc}
 8009498:	fffefff8 	.word	0xfffefff8
 800949c:	fffffcfc 	.word	0xfffffcfc
 80094a0:	fffff3f3 	.word	0xfffff3f3
 80094a4:	ffff0f0f 	.word	0xffff0f0f

080094a8 <HAL_TIM_Encoder_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
{
 80094a8:	b580      	push	{r7, lr}
 80094aa:	b082      	sub	sp, #8
 80094ac:	af00      	add	r7, sp, #0
 80094ae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  htim->State = HAL_TIM_STATE_BUSY;
 80094b0:	687b      	ldr	r3, [r7, #4]
 80094b2:	2202      	movs	r2, #2
 80094b4:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 80094b8:	687b      	ldr	r3, [r7, #4]
 80094ba:	681b      	ldr	r3, [r3, #0]
 80094bc:	6a1a      	ldr	r2, [r3, #32]
 80094be:	f241 1311 	movw	r3, #4369	; 0x1111
 80094c2:	4013      	ands	r3, r2
 80094c4:	2b00      	cmp	r3, #0
 80094c6:	d10f      	bne.n	80094e8 <HAL_TIM_Encoder_DeInit+0x40>
 80094c8:	687b      	ldr	r3, [r7, #4]
 80094ca:	681b      	ldr	r3, [r3, #0]
 80094cc:	6a1a      	ldr	r2, [r3, #32]
 80094ce:	f240 4344 	movw	r3, #1092	; 0x444
 80094d2:	4013      	ands	r3, r2
 80094d4:	2b00      	cmp	r3, #0
 80094d6:	d107      	bne.n	80094e8 <HAL_TIM_Encoder_DeInit+0x40>
 80094d8:	687b      	ldr	r3, [r7, #4]
 80094da:	681b      	ldr	r3, [r3, #0]
 80094dc:	687a      	ldr	r2, [r7, #4]
 80094de:	6812      	ldr	r2, [r2, #0]
 80094e0:	6812      	ldr	r2, [r2, #0]
 80094e2:	f022 0201 	bic.w	r2, r2, #1
 80094e6:	601a      	str	r2, [r3, #0]
  
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Encoder_MspDeInit(htim);
 80094e8:	6878      	ldr	r0, [r7, #4]
 80094ea:	f005 f86d 	bl	800e5c8 <HAL_TIM_Encoder_MspDeInit>
    
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET;
 80094ee:	687b      	ldr	r3, [r7, #4]
 80094f0:	2200      	movs	r2, #0
 80094f2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 
  /* Release Lock */
  __HAL_UNLOCK(htim);
 80094f6:	687b      	ldr	r3, [r7, #4]
 80094f8:	2200      	movs	r2, #0
 80094fa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 80094fe:	2300      	movs	r3, #0
}
 8009500:	4618      	mov	r0, r3
 8009502:	3708      	adds	r7, #8
 8009504:	46bd      	mov	sp, r7
 8009506:	bd80      	pop	{r7, pc}

08009508 <HAL_TIM_Encoder_Start>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 8009508:	b580      	push	{r7, lr}
 800950a:	b082      	sub	sp, #8
 800950c:	af00      	add	r7, sp, #0
 800950e:	6078      	str	r0, [r7, #4]
 8009510:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
  
  /* Enable the encoder interface channels */
  switch (Channel)
 8009512:	683b      	ldr	r3, [r7, #0]
 8009514:	2b00      	cmp	r3, #0
 8009516:	d002      	beq.n	800951e <HAL_TIM_Encoder_Start+0x16>
 8009518:	2b04      	cmp	r3, #4
 800951a:	d008      	beq.n	800952e <HAL_TIM_Encoder_Start+0x26>
 800951c:	e00f      	b.n	800953e <HAL_TIM_Encoder_Start+0x36>
  {
    case TIM_CHANNEL_1:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800951e:	687b      	ldr	r3, [r7, #4]
 8009520:	681b      	ldr	r3, [r3, #0]
 8009522:	4618      	mov	r0, r3
 8009524:	2100      	movs	r1, #0
 8009526:	2201      	movs	r2, #1
 8009528:	f000 fbdc 	bl	8009ce4 <TIM_CCxChannelCmd>
      break; 
 800952c:	e016      	b.n	800955c <HAL_TIM_Encoder_Start+0x54>
    }
    case TIM_CHANNEL_2:
    { 
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
 800952e:	687b      	ldr	r3, [r7, #4]
 8009530:	681b      	ldr	r3, [r3, #0]
 8009532:	4618      	mov	r0, r3
 8009534:	2104      	movs	r1, #4
 8009536:	2201      	movs	r2, #1
 8009538:	f000 fbd4 	bl	8009ce4 <TIM_CCxChannelCmd>
      break;
 800953c:	e00e      	b.n	800955c <HAL_TIM_Encoder_Start+0x54>
    }  
    default :
    {
     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800953e:	687b      	ldr	r3, [r7, #4]
 8009540:	681b      	ldr	r3, [r3, #0]
 8009542:	4618      	mov	r0, r3
 8009544:	2100      	movs	r1, #0
 8009546:	2201      	movs	r2, #1
 8009548:	f000 fbcc 	bl	8009ce4 <TIM_CCxChannelCmd>
     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 800954c:	687b      	ldr	r3, [r7, #4]
 800954e:	681b      	ldr	r3, [r3, #0]
 8009550:	4618      	mov	r0, r3
 8009552:	2104      	movs	r1, #4
 8009554:	2201      	movs	r2, #1
 8009556:	f000 fbc5 	bl	8009ce4 <TIM_CCxChannelCmd>
     break; 
 800955a:	bf00      	nop
    }
  }  
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 800955c:	687b      	ldr	r3, [r7, #4]
 800955e:	681b      	ldr	r3, [r3, #0]
 8009560:	687a      	ldr	r2, [r7, #4]
 8009562:	6812      	ldr	r2, [r2, #0]
 8009564:	6812      	ldr	r2, [r2, #0]
 8009566:	f042 0201 	orr.w	r2, r2, #1
 800956a:	601a      	str	r2, [r3, #0]
  
  /* Return function status */
  return HAL_OK;
 800956c:	2300      	movs	r3, #0
}
 800956e:	4618      	mov	r0, r3
 8009570:	3708      	adds	r7, #8
 8009572:	46bd      	mov	sp, r7
 8009574:	bd80      	pop	{r7, pc}
 8009576:	bf00      	nop

08009578 <HAL_TIM_IRQHandler>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 8009578:	b580      	push	{r7, lr}
 800957a:	b082      	sub	sp, #8
 800957c:	af00      	add	r7, sp, #0
 800957e:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8009580:	687b      	ldr	r3, [r7, #4]
 8009582:	681b      	ldr	r3, [r3, #0]
 8009584:	691b      	ldr	r3, [r3, #16]
 8009586:	f003 0302 	and.w	r3, r3, #2
 800958a:	2b00      	cmp	r3, #0
 800958c:	d022      	beq.n	80095d4 <HAL_TIM_IRQHandler+0x5c>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 800958e:	687b      	ldr	r3, [r7, #4]
 8009590:	681b      	ldr	r3, [r3, #0]
 8009592:	68db      	ldr	r3, [r3, #12]
 8009594:	f003 0302 	and.w	r3, r3, #2
 8009598:	2b00      	cmp	r3, #0
 800959a:	d01b      	beq.n	80095d4 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800959c:	687b      	ldr	r3, [r7, #4]
 800959e:	681b      	ldr	r3, [r3, #0]
 80095a0:	f06f 0202 	mvn.w	r2, #2
 80095a4:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80095a6:	687b      	ldr	r3, [r7, #4]
 80095a8:	2201      	movs	r2, #1
 80095aa:	761a      	strb	r2, [r3, #24]
        
        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 80095ac:	687b      	ldr	r3, [r7, #4]
 80095ae:	681b      	ldr	r3, [r3, #0]
 80095b0:	699b      	ldr	r3, [r3, #24]
 80095b2:	f003 0303 	and.w	r3, r3, #3
 80095b6:	2b00      	cmp	r3, #0
 80095b8:	d003      	beq.n	80095c2 <HAL_TIM_IRQHandler+0x4a>
        {
          HAL_TIM_IC_CaptureCallback(htim);
 80095ba:	6878      	ldr	r0, [r7, #4]
 80095bc:	f000 f904 	bl	80097c8 <HAL_TIM_IC_CaptureCallback>
 80095c0:	e005      	b.n	80095ce <HAL_TIM_IRQHandler+0x56>
        }
        /* Output compare event */
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80095c2:	6878      	ldr	r0, [r7, #4]
 80095c4:	f000 f8f6 	bl	80097b4 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80095c8:	6878      	ldr	r0, [r7, #4]
 80095ca:	f000 f907 	bl	80097dc <HAL_TIM_PWM_PulseFinishedCallback>
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80095ce:	687b      	ldr	r3, [r7, #4]
 80095d0:	2200      	movs	r2, #0
 80095d2:	761a      	strb	r2, [r3, #24]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 80095d4:	687b      	ldr	r3, [r7, #4]
 80095d6:	681b      	ldr	r3, [r3, #0]
 80095d8:	691b      	ldr	r3, [r3, #16]
 80095da:	f003 0304 	and.w	r3, r3, #4
 80095de:	2b00      	cmp	r3, #0
 80095e0:	d022      	beq.n	8009628 <HAL_TIM_IRQHandler+0xb0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 80095e2:	687b      	ldr	r3, [r7, #4]
 80095e4:	681b      	ldr	r3, [r3, #0]
 80095e6:	68db      	ldr	r3, [r3, #12]
 80095e8:	f003 0304 	and.w	r3, r3, #4
 80095ec:	2b00      	cmp	r3, #0
 80095ee:	d01b      	beq.n	8009628 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 80095f0:	687b      	ldr	r3, [r7, #4]
 80095f2:	681b      	ldr	r3, [r3, #0]
 80095f4:	f06f 0204 	mvn.w	r2, #4
 80095f8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80095fa:	687b      	ldr	r3, [r7, #4]
 80095fc:	2202      	movs	r2, #2
 80095fe:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 8009600:	687b      	ldr	r3, [r7, #4]
 8009602:	681b      	ldr	r3, [r3, #0]
 8009604:	699b      	ldr	r3, [r3, #24]
 8009606:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800960a:	2b00      	cmp	r3, #0
 800960c:	d003      	beq.n	8009616 <HAL_TIM_IRQHandler+0x9e>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 800960e:	6878      	ldr	r0, [r7, #4]
 8009610:	f000 f8da 	bl	80097c8 <HAL_TIM_IC_CaptureCallback>
 8009614:	e005      	b.n	8009622 <HAL_TIM_IRQHandler+0xaa>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009616:	6878      	ldr	r0, [r7, #4]
 8009618:	f000 f8cc 	bl	80097b4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800961c:	6878      	ldr	r0, [r7, #4]
 800961e:	f000 f8dd 	bl	80097dc <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009622:	687b      	ldr	r3, [r7, #4]
 8009624:	2200      	movs	r2, #0
 8009626:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8009628:	687b      	ldr	r3, [r7, #4]
 800962a:	681b      	ldr	r3, [r3, #0]
 800962c:	691b      	ldr	r3, [r3, #16]
 800962e:	f003 0308 	and.w	r3, r3, #8
 8009632:	2b00      	cmp	r3, #0
 8009634:	d022      	beq.n	800967c <HAL_TIM_IRQHandler+0x104>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 8009636:	687b      	ldr	r3, [r7, #4]
 8009638:	681b      	ldr	r3, [r3, #0]
 800963a:	68db      	ldr	r3, [r3, #12]
 800963c:	f003 0308 	and.w	r3, r3, #8
 8009640:	2b00      	cmp	r3, #0
 8009642:	d01b      	beq.n	800967c <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8009644:	687b      	ldr	r3, [r7, #4]
 8009646:	681b      	ldr	r3, [r3, #0]
 8009648:	f06f 0208 	mvn.w	r2, #8
 800964c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800964e:	687b      	ldr	r3, [r7, #4]
 8009650:	2204      	movs	r2, #4
 8009652:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 8009654:	687b      	ldr	r3, [r7, #4]
 8009656:	681b      	ldr	r3, [r3, #0]
 8009658:	69db      	ldr	r3, [r3, #28]
 800965a:	f003 0303 	and.w	r3, r3, #3
 800965e:	2b00      	cmp	r3, #0
 8009660:	d003      	beq.n	800966a <HAL_TIM_IRQHandler+0xf2>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8009662:	6878      	ldr	r0, [r7, #4]
 8009664:	f000 f8b0 	bl	80097c8 <HAL_TIM_IC_CaptureCallback>
 8009668:	e005      	b.n	8009676 <HAL_TIM_IRQHandler+0xfe>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800966a:	6878      	ldr	r0, [r7, #4]
 800966c:	f000 f8a2 	bl	80097b4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
 8009670:	6878      	ldr	r0, [r7, #4]
 8009672:	f000 f8b3 	bl	80097dc <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009676:	687b      	ldr	r3, [r7, #4]
 8009678:	2200      	movs	r2, #0
 800967a:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800967c:	687b      	ldr	r3, [r7, #4]
 800967e:	681b      	ldr	r3, [r3, #0]
 8009680:	691b      	ldr	r3, [r3, #16]
 8009682:	f003 0310 	and.w	r3, r3, #16
 8009686:	2b00      	cmp	r3, #0
 8009688:	d022      	beq.n	80096d0 <HAL_TIM_IRQHandler+0x158>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 800968a:	687b      	ldr	r3, [r7, #4]
 800968c:	681b      	ldr	r3, [r3, #0]
 800968e:	68db      	ldr	r3, [r3, #12]
 8009690:	f003 0310 	and.w	r3, r3, #16
 8009694:	2b00      	cmp	r3, #0
 8009696:	d01b      	beq.n	80096d0 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8009698:	687b      	ldr	r3, [r7, #4]
 800969a:	681b      	ldr	r3, [r3, #0]
 800969c:	f06f 0210 	mvn.w	r2, #16
 80096a0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80096a2:	687b      	ldr	r3, [r7, #4]
 80096a4:	2208      	movs	r2, #8
 80096a6:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 80096a8:	687b      	ldr	r3, [r7, #4]
 80096aa:	681b      	ldr	r3, [r3, #0]
 80096ac:	69db      	ldr	r3, [r3, #28]
 80096ae:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80096b2:	2b00      	cmp	r3, #0
 80096b4:	d003      	beq.n	80096be <HAL_TIM_IRQHandler+0x146>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 80096b6:	6878      	ldr	r0, [r7, #4]
 80096b8:	f000 f886 	bl	80097c8 <HAL_TIM_IC_CaptureCallback>
 80096bc:	e005      	b.n	80096ca <HAL_TIM_IRQHandler+0x152>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80096be:	6878      	ldr	r0, [r7, #4]
 80096c0:	f000 f878 	bl	80097b4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80096c4:	6878      	ldr	r0, [r7, #4]
 80096c6:	f000 f889 	bl	80097dc <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80096ca:	687b      	ldr	r3, [r7, #4]
 80096cc:	2200      	movs	r2, #0
 80096ce:	761a      	strb	r2, [r3, #24]
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 80096d0:	687b      	ldr	r3, [r7, #4]
 80096d2:	681b      	ldr	r3, [r3, #0]
 80096d4:	691b      	ldr	r3, [r3, #16]
 80096d6:	f003 0301 	and.w	r3, r3, #1
 80096da:	2b00      	cmp	r3, #0
 80096dc:	d00e      	beq.n	80096fc <HAL_TIM_IRQHandler+0x184>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 80096de:	687b      	ldr	r3, [r7, #4]
 80096e0:	681b      	ldr	r3, [r3, #0]
 80096e2:	68db      	ldr	r3, [r3, #12]
 80096e4:	f003 0301 	and.w	r3, r3, #1
 80096e8:	2b00      	cmp	r3, #0
 80096ea:	d007      	beq.n	80096fc <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 80096ec:	687b      	ldr	r3, [r7, #4]
 80096ee:	681b      	ldr	r3, [r3, #0]
 80096f0:	f06f 0201 	mvn.w	r2, #1
 80096f4:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 80096f6:	6878      	ldr	r0, [r7, #4]
 80096f8:	f004 fede 	bl	800e4b8 <HAL_TIM_PeriodElapsedCallback>
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 80096fc:	687b      	ldr	r3, [r7, #4]
 80096fe:	681b      	ldr	r3, [r3, #0]
 8009700:	691b      	ldr	r3, [r3, #16]
 8009702:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009706:	2b00      	cmp	r3, #0
 8009708:	d00e      	beq.n	8009728 <HAL_TIM_IRQHandler+0x1b0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 800970a:	687b      	ldr	r3, [r7, #4]
 800970c:	681b      	ldr	r3, [r3, #0]
 800970e:	68db      	ldr	r3, [r3, #12]
 8009710:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009714:	2b00      	cmp	r3, #0
 8009716:	d007      	beq.n	8009728 <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8009718:	687b      	ldr	r3, [r7, #4]
 800971a:	681b      	ldr	r3, [r3, #0]
 800971c:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8009720:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8009722:	6878      	ldr	r0, [r7, #4]
 8009724:	f005 fa30 	bl	800eb88 <HAL_TIMEx_BreakCallback>
    }
  }
  
    /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8009728:	687b      	ldr	r3, [r7, #4]
 800972a:	681b      	ldr	r3, [r3, #0]
 800972c:	691b      	ldr	r3, [r3, #16]
 800972e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8009732:	2b00      	cmp	r3, #0
 8009734:	d00e      	beq.n	8009754 <HAL_TIM_IRQHandler+0x1dc>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8009736:	687b      	ldr	r3, [r7, #4]
 8009738:	681b      	ldr	r3, [r3, #0]
 800973a:	68db      	ldr	r3, [r3, #12]
 800973c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009740:	2b00      	cmp	r3, #0
 8009742:	d007      	beq.n	8009754 <HAL_TIM_IRQHandler+0x1dc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8009744:	687b      	ldr	r3, [r7, #4]
 8009746:	681b      	ldr	r3, [r3, #0]
 8009748:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800974c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800974e:	6878      	ldr	r0, [r7, #4]
 8009750:	f005 fa1a 	bl	800eb88 <HAL_TIMEx_BreakCallback>
    }
  }

  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8009754:	687b      	ldr	r3, [r7, #4]
 8009756:	681b      	ldr	r3, [r3, #0]
 8009758:	691b      	ldr	r3, [r3, #16]
 800975a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800975e:	2b00      	cmp	r3, #0
 8009760:	d00e      	beq.n	8009780 <HAL_TIM_IRQHandler+0x208>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 8009762:	687b      	ldr	r3, [r7, #4]
 8009764:	681b      	ldr	r3, [r3, #0]
 8009766:	68db      	ldr	r3, [r3, #12]
 8009768:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800976c:	2b00      	cmp	r3, #0
 800976e:	d007      	beq.n	8009780 <HAL_TIM_IRQHandler+0x208>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8009770:	687b      	ldr	r3, [r7, #4]
 8009772:	681b      	ldr	r3, [r3, #0]
 8009774:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8009778:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800977a:	6878      	ldr	r0, [r7, #4]
 800977c:	f000 f838 	bl	80097f0 <HAL_TIM_TriggerCallback>
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8009780:	687b      	ldr	r3, [r7, #4]
 8009782:	681b      	ldr	r3, [r3, #0]
 8009784:	691b      	ldr	r3, [r3, #16]
 8009786:	f003 0320 	and.w	r3, r3, #32
 800978a:	2b00      	cmp	r3, #0
 800978c:	d00e      	beq.n	80097ac <HAL_TIM_IRQHandler+0x234>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 800978e:	687b      	ldr	r3, [r7, #4]
 8009790:	681b      	ldr	r3, [r3, #0]
 8009792:	68db      	ldr	r3, [r3, #12]
 8009794:	f003 0320 	and.w	r3, r3, #32
 8009798:	2b00      	cmp	r3, #0
 800979a:	d007      	beq.n	80097ac <HAL_TIM_IRQHandler+0x234>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800979c:	687b      	ldr	r3, [r7, #4]
 800979e:	681b      	ldr	r3, [r3, #0]
 80097a0:	f06f 0220 	mvn.w	r2, #32
 80097a4:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutationCallback(htim);
 80097a6:	6878      	ldr	r0, [r7, #4]
 80097a8:	f000 fc8c 	bl	800a0c4 <HAL_TIMEx_CommutationCallback>
    }
  }
}
 80097ac:	3708      	adds	r7, #8
 80097ae:	46bd      	mov	sp, r7
 80097b0:	bd80      	pop	{r7, pc}
 80097b2:	bf00      	nop

080097b4 <HAL_TIM_OC_DelayElapsedCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 80097b4:	b480      	push	{r7}
 80097b6:	b083      	sub	sp, #12
 80097b8:	af00      	add	r7, sp, #0
 80097ba:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 80097bc:	370c      	adds	r7, #12
 80097be:	46bd      	mov	sp, r7
 80097c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097c4:	4770      	bx	lr
 80097c6:	bf00      	nop

080097c8 <HAL_TIM_IC_CaptureCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 80097c8:	b480      	push	{r7}
 80097ca:	b083      	sub	sp, #12
 80097cc:	af00      	add	r7, sp, #0
 80097ce:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 80097d0:	370c      	adds	r7, #12
 80097d2:	46bd      	mov	sp, r7
 80097d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097d8:	4770      	bx	lr
 80097da:	bf00      	nop

080097dc <HAL_TIM_PWM_PulseFinishedCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 80097dc:	b480      	push	{r7}
 80097de:	b083      	sub	sp, #12
 80097e0:	af00      	add	r7, sp, #0
 80097e2:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 80097e4:	370c      	adds	r7, #12
 80097e6:	46bd      	mov	sp, r7
 80097e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097ec:	4770      	bx	lr
 80097ee:	bf00      	nop

080097f0 <HAL_TIM_TriggerCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 80097f0:	b480      	push	{r7}
 80097f2:	b083      	sub	sp, #12
 80097f4:	af00      	add	r7, sp, #0
 80097f6:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 80097f8:	370c      	adds	r7, #12
 80097fa:	46bd      	mov	sp, r7
 80097fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009800:	4770      	bx	lr
 8009802:	bf00      	nop

08009804 <TIM_Base_SetConfig>:
  * @param  TIMx: TIM peripheral
  * @param  Structure: pointer on TIM Time Base required parameters  
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8009804:	b480      	push	{r7}
 8009806:	b085      	sub	sp, #20
 8009808:	af00      	add	r7, sp, #0
 800980a:	6078      	str	r0, [r7, #4]
 800980c:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1 = 0;
 800980e:	2300      	movs	r3, #0
 8009810:	60fb      	str	r3, [r7, #12]
  tmpcr1 = TIMx->CR1;
 8009812:	687b      	ldr	r3, [r7, #4]
 8009814:	681b      	ldr	r3, [r3, #0]
 8009816:	60fb      	str	r3, [r7, #12]
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 8009818:	687b      	ldr	r3, [r7, #4]
 800981a:	4a43      	ldr	r2, [pc, #268]	; (8009928 <TIM_Base_SetConfig+0x124>)
 800981c:	4293      	cmp	r3, r2
 800981e:	d013      	beq.n	8009848 <TIM_Base_SetConfig+0x44>
 8009820:	687b      	ldr	r3, [r7, #4]
 8009822:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8009826:	d00f      	beq.n	8009848 <TIM_Base_SetConfig+0x44>
 8009828:	687b      	ldr	r3, [r7, #4]
 800982a:	4a40      	ldr	r2, [pc, #256]	; (800992c <TIM_Base_SetConfig+0x128>)
 800982c:	4293      	cmp	r3, r2
 800982e:	d00b      	beq.n	8009848 <TIM_Base_SetConfig+0x44>
 8009830:	687b      	ldr	r3, [r7, #4]
 8009832:	4a3f      	ldr	r2, [pc, #252]	; (8009930 <TIM_Base_SetConfig+0x12c>)
 8009834:	4293      	cmp	r3, r2
 8009836:	d007      	beq.n	8009848 <TIM_Base_SetConfig+0x44>
 8009838:	687b      	ldr	r3, [r7, #4]
 800983a:	4a3e      	ldr	r2, [pc, #248]	; (8009934 <TIM_Base_SetConfig+0x130>)
 800983c:	4293      	cmp	r3, r2
 800983e:	d003      	beq.n	8009848 <TIM_Base_SetConfig+0x44>
 8009840:	687b      	ldr	r3, [r7, #4]
 8009842:	4a3d      	ldr	r2, [pc, #244]	; (8009938 <TIM_Base_SetConfig+0x134>)
 8009844:	4293      	cmp	r3, r2
 8009846:	d101      	bne.n	800984c <TIM_Base_SetConfig+0x48>
 8009848:	2301      	movs	r3, #1
 800984a:	e000      	b.n	800984e <TIM_Base_SetConfig+0x4a>
 800984c:	2300      	movs	r3, #0
 800984e:	2b00      	cmp	r3, #0
 8009850:	d008      	beq.n	8009864 <TIM_Base_SetConfig+0x60>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8009852:	68fb      	ldr	r3, [r7, #12]
 8009854:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009858:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800985a:	683b      	ldr	r3, [r7, #0]
 800985c:	685b      	ldr	r3, [r3, #4]
 800985e:	68fa      	ldr	r2, [r7, #12]
 8009860:	4313      	orrs	r3, r2
 8009862:	60fb      	str	r3, [r7, #12]
  }
 
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 8009864:	687b      	ldr	r3, [r7, #4]
 8009866:	4a30      	ldr	r2, [pc, #192]	; (8009928 <TIM_Base_SetConfig+0x124>)
 8009868:	4293      	cmp	r3, r2
 800986a:	d02b      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 800986c:	687b      	ldr	r3, [r7, #4]
 800986e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8009872:	d027      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 8009874:	687b      	ldr	r3, [r7, #4]
 8009876:	4a2d      	ldr	r2, [pc, #180]	; (800992c <TIM_Base_SetConfig+0x128>)
 8009878:	4293      	cmp	r3, r2
 800987a:	d023      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 800987c:	687b      	ldr	r3, [r7, #4]
 800987e:	4a2c      	ldr	r2, [pc, #176]	; (8009930 <TIM_Base_SetConfig+0x12c>)
 8009880:	4293      	cmp	r3, r2
 8009882:	d01f      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 8009884:	687b      	ldr	r3, [r7, #4]
 8009886:	4a2b      	ldr	r2, [pc, #172]	; (8009934 <TIM_Base_SetConfig+0x130>)
 8009888:	4293      	cmp	r3, r2
 800988a:	d01b      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 800988c:	687b      	ldr	r3, [r7, #4]
 800988e:	4a2a      	ldr	r2, [pc, #168]	; (8009938 <TIM_Base_SetConfig+0x134>)
 8009890:	4293      	cmp	r3, r2
 8009892:	d017      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 8009894:	687b      	ldr	r3, [r7, #4]
 8009896:	4a29      	ldr	r2, [pc, #164]	; (800993c <TIM_Base_SetConfig+0x138>)
 8009898:	4293      	cmp	r3, r2
 800989a:	d013      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 800989c:	687b      	ldr	r3, [r7, #4]
 800989e:	4a28      	ldr	r2, [pc, #160]	; (8009940 <TIM_Base_SetConfig+0x13c>)
 80098a0:	4293      	cmp	r3, r2
 80098a2:	d00f      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 80098a4:	687b      	ldr	r3, [r7, #4]
 80098a6:	4a27      	ldr	r2, [pc, #156]	; (8009944 <TIM_Base_SetConfig+0x140>)
 80098a8:	4293      	cmp	r3, r2
 80098aa:	d00b      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 80098ac:	687b      	ldr	r3, [r7, #4]
 80098ae:	4a26      	ldr	r2, [pc, #152]	; (8009948 <TIM_Base_SetConfig+0x144>)
 80098b0:	4293      	cmp	r3, r2
 80098b2:	d007      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 80098b4:	687b      	ldr	r3, [r7, #4]
 80098b6:	4a25      	ldr	r2, [pc, #148]	; (800994c <TIM_Base_SetConfig+0x148>)
 80098b8:	4293      	cmp	r3, r2
 80098ba:	d003      	beq.n	80098c4 <TIM_Base_SetConfig+0xc0>
 80098bc:	687b      	ldr	r3, [r7, #4]
 80098be:	4a24      	ldr	r2, [pc, #144]	; (8009950 <TIM_Base_SetConfig+0x14c>)
 80098c0:	4293      	cmp	r3, r2
 80098c2:	d101      	bne.n	80098c8 <TIM_Base_SetConfig+0xc4>
 80098c4:	2301      	movs	r3, #1
 80098c6:	e000      	b.n	80098ca <TIM_Base_SetConfig+0xc6>
 80098c8:	2300      	movs	r3, #0
 80098ca:	2b00      	cmp	r3, #0
 80098cc:	d008      	beq.n	80098e0 <TIM_Base_SetConfig+0xdc>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80098ce:	68fb      	ldr	r3, [r7, #12]
 80098d0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80098d4:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80098d6:	683b      	ldr	r3, [r7, #0]
 80098d8:	68db      	ldr	r3, [r3, #12]
 80098da:	68fa      	ldr	r2, [r7, #12]
 80098dc:	4313      	orrs	r3, r2
 80098de:	60fb      	str	r3, [r7, #12]
  }

  TIMx->CR1 = tmpcr1;
 80098e0:	687b      	ldr	r3, [r7, #4]
 80098e2:	68fa      	ldr	r2, [r7, #12]
 80098e4:	601a      	str	r2, [r3, #0]

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80098e6:	683b      	ldr	r3, [r7, #0]
 80098e8:	689a      	ldr	r2, [r3, #8]
 80098ea:	687b      	ldr	r3, [r7, #4]
 80098ec:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80098ee:	683b      	ldr	r3, [r7, #0]
 80098f0:	681a      	ldr	r2, [r3, #0]
 80098f2:	687b      	ldr	r3, [r7, #4]
 80098f4:	629a      	str	r2, [r3, #40]	; 0x28
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 80098f6:	687b      	ldr	r3, [r7, #4]
 80098f8:	4a0b      	ldr	r2, [pc, #44]	; (8009928 <TIM_Base_SetConfig+0x124>)
 80098fa:	4293      	cmp	r3, r2
 80098fc:	d003      	beq.n	8009906 <TIM_Base_SetConfig+0x102>
 80098fe:	687b      	ldr	r3, [r7, #4]
 8009900:	4a0d      	ldr	r2, [pc, #52]	; (8009938 <TIM_Base_SetConfig+0x134>)
 8009902:	4293      	cmp	r3, r2
 8009904:	d101      	bne.n	800990a <TIM_Base_SetConfig+0x106>
 8009906:	2301      	movs	r3, #1
 8009908:	e000      	b.n	800990c <TIM_Base_SetConfig+0x108>
 800990a:	2300      	movs	r3, #0
 800990c:	2b00      	cmp	r3, #0
 800990e:	d003      	beq.n	8009918 <TIM_Base_SetConfig+0x114>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8009910:	683b      	ldr	r3, [r7, #0]
 8009912:	691a      	ldr	r2, [r3, #16]
 8009914:	687b      	ldr	r3, [r7, #4]
 8009916:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8009918:	687b      	ldr	r3, [r7, #4]
 800991a:	2201      	movs	r2, #1
 800991c:	615a      	str	r2, [r3, #20]
}
 800991e:	3714      	adds	r7, #20
 8009920:	46bd      	mov	sp, r7
 8009922:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009926:	4770      	bx	lr
 8009928:	40010000 	.word	0x40010000
 800992c:	40000400 	.word	0x40000400
 8009930:	40000800 	.word	0x40000800
 8009934:	40000c00 	.word	0x40000c00
 8009938:	40010400 	.word	0x40010400
 800993c:	40014000 	.word	0x40014000
 8009940:	40014400 	.word	0x40014400
 8009944:	40014800 	.word	0x40014800
 8009948:	40001800 	.word	0x40001800
 800994c:	40001c00 	.word	0x40001c00
 8009950:	40002000 	.word	0x40002000

08009954 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8009954:	b480      	push	{r7}
 8009956:	b087      	sub	sp, #28
 8009958:	af00      	add	r7, sp, #0
 800995a:	6078      	str	r0, [r7, #4]
 800995c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800995e:	2300      	movs	r3, #0
 8009960:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 8009962:	2300      	movs	r3, #0
 8009964:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;  
 8009966:	2300      	movs	r3, #0
 8009968:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800996a:	687b      	ldr	r3, [r7, #4]
 800996c:	6a1b      	ldr	r3, [r3, #32]
 800996e:	f023 0201 	bic.w	r2, r3, #1
 8009972:	687b      	ldr	r3, [r7, #4]
 8009974:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8009976:	687b      	ldr	r3, [r7, #4]
 8009978:	6a1b      	ldr	r3, [r3, #32]
 800997a:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800997c:	687b      	ldr	r3, [r7, #4]
 800997e:	685b      	ldr	r3, [r3, #4]
 8009980:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8009982:	687b      	ldr	r3, [r7, #4]
 8009984:	699b      	ldr	r3, [r3, #24]
 8009986:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 8009988:	68fa      	ldr	r2, [r7, #12]
 800998a:	4b29      	ldr	r3, [pc, #164]	; (8009a30 <TIM_OC1_SetConfig+0xdc>)
 800998c:	4013      	ands	r3, r2
 800998e:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8009990:	68fb      	ldr	r3, [r7, #12]
 8009992:	f023 0303 	bic.w	r3, r3, #3
 8009996:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8009998:	683b      	ldr	r3, [r7, #0]
 800999a:	681b      	ldr	r3, [r3, #0]
 800999c:	68fa      	ldr	r2, [r7, #12]
 800999e:	4313      	orrs	r3, r2
 80099a0:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 80099a2:	697b      	ldr	r3, [r7, #20]
 80099a4:	f023 0302 	bic.w	r3, r3, #2
 80099a8:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80099aa:	683b      	ldr	r3, [r7, #0]
 80099ac:	689b      	ldr	r3, [r3, #8]
 80099ae:	697a      	ldr	r2, [r7, #20]
 80099b0:	4313      	orrs	r3, r2
 80099b2:	617b      	str	r3, [r7, #20]

    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 80099b4:	687b      	ldr	r3, [r7, #4]
 80099b6:	4a1f      	ldr	r2, [pc, #124]	; (8009a34 <TIM_OC1_SetConfig+0xe0>)
 80099b8:	4293      	cmp	r3, r2
 80099ba:	d003      	beq.n	80099c4 <TIM_OC1_SetConfig+0x70>
 80099bc:	687b      	ldr	r3, [r7, #4]
 80099be:	4a1e      	ldr	r2, [pc, #120]	; (8009a38 <TIM_OC1_SetConfig+0xe4>)
 80099c0:	4293      	cmp	r3, r2
 80099c2:	d101      	bne.n	80099c8 <TIM_OC1_SetConfig+0x74>
 80099c4:	2301      	movs	r3, #1
 80099c6:	e000      	b.n	80099ca <TIM_OC1_SetConfig+0x76>
 80099c8:	2300      	movs	r3, #0
 80099ca:	2b00      	cmp	r3, #0
 80099cc:	d01e      	beq.n	8009a0c <TIM_OC1_SetConfig+0xb8>
  {   
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 80099ce:	697b      	ldr	r3, [r7, #20]
 80099d0:	f023 0308 	bic.w	r3, r3, #8
 80099d4:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 80099d6:	683b      	ldr	r3, [r7, #0]
 80099d8:	68db      	ldr	r3, [r3, #12]
 80099da:	697a      	ldr	r2, [r7, #20]
 80099dc:	4313      	orrs	r3, r2
 80099de:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 80099e0:	697b      	ldr	r3, [r7, #20]
 80099e2:	f023 0304 	bic.w	r3, r3, #4
 80099e6:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 80099e8:	693b      	ldr	r3, [r7, #16]
 80099ea:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80099ee:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 80099f0:	693b      	ldr	r3, [r7, #16]
 80099f2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80099f6:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 80099f8:	683b      	ldr	r3, [r7, #0]
 80099fa:	695b      	ldr	r3, [r3, #20]
 80099fc:	693a      	ldr	r2, [r7, #16]
 80099fe:	4313      	orrs	r3, r2
 8009a00:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8009a02:	683b      	ldr	r3, [r7, #0]
 8009a04:	699b      	ldr	r3, [r3, #24]
 8009a06:	693a      	ldr	r2, [r7, #16]
 8009a08:	4313      	orrs	r3, r2
 8009a0a:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8009a0c:	687b      	ldr	r3, [r7, #4]
 8009a0e:	693a      	ldr	r2, [r7, #16]
 8009a10:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8009a12:	687b      	ldr	r3, [r7, #4]
 8009a14:	68fa      	ldr	r2, [r7, #12]
 8009a16:	619a      	str	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8009a18:	683b      	ldr	r3, [r7, #0]
 8009a1a:	685a      	ldr	r2, [r3, #4]
 8009a1c:	687b      	ldr	r3, [r7, #4]
 8009a1e:	635a      	str	r2, [r3, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 8009a20:	687b      	ldr	r3, [r7, #4]
 8009a22:	697a      	ldr	r2, [r7, #20]
 8009a24:	621a      	str	r2, [r3, #32]
} 
 8009a26:	371c      	adds	r7, #28
 8009a28:	46bd      	mov	sp, r7
 8009a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a2e:	4770      	bx	lr
 8009a30:	fffeff8f 	.word	0xfffeff8f
 8009a34:	40010000 	.word	0x40010000
 8009a38:	40010400 	.word	0x40010400

08009a3c <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8009a3c:	b480      	push	{r7}
 8009a3e:	b087      	sub	sp, #28
 8009a40:	af00      	add	r7, sp, #0
 8009a42:	6078      	str	r0, [r7, #4]
 8009a44:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 8009a46:	2300      	movs	r3, #0
 8009a48:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 8009a4a:	2300      	movs	r3, #0
 8009a4c:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;
 8009a4e:	2300      	movs	r3, #0
 8009a50:	613b      	str	r3, [r7, #16]
   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8009a52:	687b      	ldr	r3, [r7, #4]
 8009a54:	6a1b      	ldr	r3, [r3, #32]
 8009a56:	f023 0210 	bic.w	r2, r3, #16
 8009a5a:	687b      	ldr	r3, [r7, #4]
 8009a5c:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 8009a5e:	687b      	ldr	r3, [r7, #4]
 8009a60:	6a1b      	ldr	r3, [r3, #32]
 8009a62:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8009a64:	687b      	ldr	r3, [r7, #4]
 8009a66:	685b      	ldr	r3, [r3, #4]
 8009a68:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8009a6a:	687b      	ldr	r3, [r7, #4]
 8009a6c:	699b      	ldr	r3, [r3, #24]
 8009a6e:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 8009a70:	68fa      	ldr	r2, [r7, #12]
 8009a72:	4b2c      	ldr	r3, [pc, #176]	; (8009b24 <TIM_OC2_SetConfig+0xe8>)
 8009a74:	4013      	ands	r3, r2
 8009a76:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8009a78:	68fb      	ldr	r3, [r7, #12]
 8009a7a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8009a7e:	60fb      	str	r3, [r7, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8009a80:	683b      	ldr	r3, [r7, #0]
 8009a82:	681b      	ldr	r3, [r3, #0]
 8009a84:	021b      	lsls	r3, r3, #8
 8009a86:	68fa      	ldr	r2, [r7, #12]
 8009a88:	4313      	orrs	r3, r2
 8009a8a:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 8009a8c:	697b      	ldr	r3, [r7, #20]
 8009a8e:	f023 0320 	bic.w	r3, r3, #32
 8009a92:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 8009a94:	683b      	ldr	r3, [r7, #0]
 8009a96:	689b      	ldr	r3, [r3, #8]
 8009a98:	011b      	lsls	r3, r3, #4
 8009a9a:	697a      	ldr	r2, [r7, #20]
 8009a9c:	4313      	orrs	r3, r2
 8009a9e:	617b      	str	r3, [r7, #20]
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8009aa0:	687b      	ldr	r3, [r7, #4]
 8009aa2:	4a21      	ldr	r2, [pc, #132]	; (8009b28 <TIM_OC2_SetConfig+0xec>)
 8009aa4:	4293      	cmp	r3, r2
 8009aa6:	d003      	beq.n	8009ab0 <TIM_OC2_SetConfig+0x74>
 8009aa8:	687b      	ldr	r3, [r7, #4]
 8009aaa:	4a20      	ldr	r2, [pc, #128]	; (8009b2c <TIM_OC2_SetConfig+0xf0>)
 8009aac:	4293      	cmp	r3, r2
 8009aae:	d101      	bne.n	8009ab4 <TIM_OC2_SetConfig+0x78>
 8009ab0:	2301      	movs	r3, #1
 8009ab2:	e000      	b.n	8009ab6 <TIM_OC2_SetConfig+0x7a>
 8009ab4:	2300      	movs	r3, #0
 8009ab6:	2b00      	cmp	r3, #0
 8009ab8:	d021      	beq.n	8009afe <TIM_OC2_SetConfig+0xc2>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8009aba:	697b      	ldr	r3, [r7, #20]
 8009abc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009ac0:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 8009ac2:	683b      	ldr	r3, [r7, #0]
 8009ac4:	68db      	ldr	r3, [r3, #12]
 8009ac6:	011b      	lsls	r3, r3, #4
 8009ac8:	697a      	ldr	r2, [r7, #20]
 8009aca:	4313      	orrs	r3, r2
 8009acc:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8009ace:	697b      	ldr	r3, [r7, #20]
 8009ad0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009ad4:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 8009ad6:	693b      	ldr	r3, [r7, #16]
 8009ad8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009adc:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8009ade:	693b      	ldr	r3, [r7, #16]
 8009ae0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8009ae4:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 8009ae6:	683b      	ldr	r3, [r7, #0]
 8009ae8:	695b      	ldr	r3, [r3, #20]
 8009aea:	009b      	lsls	r3, r3, #2
 8009aec:	693a      	ldr	r2, [r7, #16]
 8009aee:	4313      	orrs	r3, r2
 8009af0:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
 8009af2:	683b      	ldr	r3, [r7, #0]
 8009af4:	699b      	ldr	r3, [r3, #24]
 8009af6:	009b      	lsls	r3, r3, #2
 8009af8:	693a      	ldr	r2, [r7, #16]
 8009afa:	4313      	orrs	r3, r2
 8009afc:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8009afe:	687b      	ldr	r3, [r7, #4]
 8009b00:	693a      	ldr	r2, [r7, #16]
 8009b02:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8009b04:	687b      	ldr	r3, [r7, #4]
 8009b06:	68fa      	ldr	r2, [r7, #12]
 8009b08:	619a      	str	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8009b0a:	683b      	ldr	r3, [r7, #0]
 8009b0c:	685a      	ldr	r2, [r3, #4]
 8009b0e:	687b      	ldr	r3, [r7, #4]
 8009b10:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8009b12:	687b      	ldr	r3, [r7, #4]
 8009b14:	697a      	ldr	r2, [r7, #20]
 8009b16:	621a      	str	r2, [r3, #32]
}
 8009b18:	371c      	adds	r7, #28
 8009b1a:	46bd      	mov	sp, r7
 8009b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b20:	4770      	bx	lr
 8009b22:	bf00      	nop
 8009b24:	feff8fff 	.word	0xfeff8fff
 8009b28:	40010000 	.word	0x40010000
 8009b2c:	40010400 	.word	0x40010400

08009b30 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8009b30:	b480      	push	{r7}
 8009b32:	b087      	sub	sp, #28
 8009b34:	af00      	add	r7, sp, #0
 8009b36:	6078      	str	r0, [r7, #4]
 8009b38:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 8009b3a:	2300      	movs	r3, #0
 8009b3c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 8009b3e:	2300      	movs	r3, #0
 8009b40:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;   
 8009b42:	2300      	movs	r3, #0
 8009b44:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8009b46:	687b      	ldr	r3, [r7, #4]
 8009b48:	6a1b      	ldr	r3, [r3, #32]
 8009b4a:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8009b4e:	687b      	ldr	r3, [r7, #4]
 8009b50:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8009b52:	687b      	ldr	r3, [r7, #4]
 8009b54:	6a1b      	ldr	r3, [r3, #32]
 8009b56:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8009b58:	687b      	ldr	r3, [r7, #4]
 8009b5a:	685b      	ldr	r3, [r3, #4]
 8009b5c:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8009b5e:	687b      	ldr	r3, [r7, #4]
 8009b60:	69db      	ldr	r3, [r3, #28]
 8009b62:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 8009b64:	68fa      	ldr	r2, [r7, #12]
 8009b66:	4b2b      	ldr	r3, [pc, #172]	; (8009c14 <TIM_OC3_SetConfig+0xe4>)
 8009b68:	4013      	ands	r3, r2
 8009b6a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
 8009b6c:	68fb      	ldr	r3, [r7, #12]
 8009b6e:	f023 0303 	bic.w	r3, r3, #3
 8009b72:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8009b74:	683b      	ldr	r3, [r7, #0]
 8009b76:	681b      	ldr	r3, [r3, #0]
 8009b78:	68fa      	ldr	r2, [r7, #12]
 8009b7a:	4313      	orrs	r3, r2
 8009b7c:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8009b7e:	697b      	ldr	r3, [r7, #20]
 8009b80:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8009b84:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 8009b86:	683b      	ldr	r3, [r7, #0]
 8009b88:	689b      	ldr	r3, [r3, #8]
 8009b8a:	021b      	lsls	r3, r3, #8
 8009b8c:	697a      	ldr	r2, [r7, #20]
 8009b8e:	4313      	orrs	r3, r2
 8009b90:	617b      	str	r3, [r7, #20]
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8009b92:	687b      	ldr	r3, [r7, #4]
 8009b94:	4a20      	ldr	r2, [pc, #128]	; (8009c18 <TIM_OC3_SetConfig+0xe8>)
 8009b96:	4293      	cmp	r3, r2
 8009b98:	d003      	beq.n	8009ba2 <TIM_OC3_SetConfig+0x72>
 8009b9a:	687b      	ldr	r3, [r7, #4]
 8009b9c:	4a1f      	ldr	r2, [pc, #124]	; (8009c1c <TIM_OC3_SetConfig+0xec>)
 8009b9e:	4293      	cmp	r3, r2
 8009ba0:	d101      	bne.n	8009ba6 <TIM_OC3_SetConfig+0x76>
 8009ba2:	2301      	movs	r3, #1
 8009ba4:	e000      	b.n	8009ba8 <TIM_OC3_SetConfig+0x78>
 8009ba6:	2300      	movs	r3, #0
 8009ba8:	2b00      	cmp	r3, #0
 8009baa:	d021      	beq.n	8009bf0 <TIM_OC3_SetConfig+0xc0>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8009bac:	697b      	ldr	r3, [r7, #20]
 8009bae:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8009bb2:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 8009bb4:	683b      	ldr	r3, [r7, #0]
 8009bb6:	68db      	ldr	r3, [r3, #12]
 8009bb8:	021b      	lsls	r3, r3, #8
 8009bba:	697a      	ldr	r2, [r7, #20]
 8009bbc:	4313      	orrs	r3, r2
 8009bbe:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8009bc0:	697b      	ldr	r3, [r7, #20]
 8009bc2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009bc6:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 8009bc8:	693b      	ldr	r3, [r7, #16]
 8009bca:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8009bce:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8009bd0:	693b      	ldr	r3, [r7, #16]
 8009bd2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009bd6:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 8009bd8:	683b      	ldr	r3, [r7, #0]
 8009bda:	695b      	ldr	r3, [r3, #20]
 8009bdc:	011b      	lsls	r3, r3, #4
 8009bde:	693a      	ldr	r2, [r7, #16]
 8009be0:	4313      	orrs	r3, r2
 8009be2:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
 8009be4:	683b      	ldr	r3, [r7, #0]
 8009be6:	699b      	ldr	r3, [r3, #24]
 8009be8:	011b      	lsls	r3, r3, #4
 8009bea:	693a      	ldr	r2, [r7, #16]
 8009bec:	4313      	orrs	r3, r2
 8009bee:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8009bf0:	687b      	ldr	r3, [r7, #4]
 8009bf2:	693a      	ldr	r2, [r7, #16]
 8009bf4:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8009bf6:	687b      	ldr	r3, [r7, #4]
 8009bf8:	68fa      	ldr	r2, [r7, #12]
 8009bfa:	61da      	str	r2, [r3, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8009bfc:	683b      	ldr	r3, [r7, #0]
 8009bfe:	685a      	ldr	r2, [r3, #4]
 8009c00:	687b      	ldr	r3, [r7, #4]
 8009c02:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8009c04:	687b      	ldr	r3, [r7, #4]
 8009c06:	697a      	ldr	r2, [r7, #20]
 8009c08:	621a      	str	r2, [r3, #32]
}
 8009c0a:	371c      	adds	r7, #28
 8009c0c:	46bd      	mov	sp, r7
 8009c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c12:	4770      	bx	lr
 8009c14:	fffeff8f 	.word	0xfffeff8f
 8009c18:	40010000 	.word	0x40010000
 8009c1c:	40010400 	.word	0x40010400

08009c20 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8009c20:	b480      	push	{r7}
 8009c22:	b087      	sub	sp, #28
 8009c24:	af00      	add	r7, sp, #0
 8009c26:	6078      	str	r0, [r7, #4]
 8009c28:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 8009c2a:	2300      	movs	r3, #0
 8009c2c:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 8009c2e:	2300      	movs	r3, #0
 8009c30:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0;
 8009c32:	2300      	movs	r3, #0
 8009c34:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8009c36:	687b      	ldr	r3, [r7, #4]
 8009c38:	6a1b      	ldr	r3, [r3, #32]
 8009c3a:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8009c3e:	687b      	ldr	r3, [r7, #4]
 8009c40:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8009c42:	687b      	ldr	r3, [r7, #4]
 8009c44:	6a1b      	ldr	r3, [r3, #32]
 8009c46:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8009c48:	687b      	ldr	r3, [r7, #4]
 8009c4a:	685b      	ldr	r3, [r3, #4]
 8009c4c:	617b      	str	r3, [r7, #20]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8009c4e:	687b      	ldr	r3, [r7, #4]
 8009c50:	69db      	ldr	r3, [r3, #28]
 8009c52:	613b      	str	r3, [r7, #16]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 8009c54:	693a      	ldr	r2, [r7, #16]
 8009c56:	4b20      	ldr	r3, [pc, #128]	; (8009cd8 <TIM_OC4_SetConfig+0xb8>)
 8009c58:	4013      	ands	r3, r2
 8009c5a:	613b      	str	r3, [r7, #16]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8009c5c:	693b      	ldr	r3, [r7, #16]
 8009c5e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8009c62:	613b      	str	r3, [r7, #16]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8009c64:	683b      	ldr	r3, [r7, #0]
 8009c66:	681b      	ldr	r3, [r3, #0]
 8009c68:	021b      	lsls	r3, r3, #8
 8009c6a:	693a      	ldr	r2, [r7, #16]
 8009c6c:	4313      	orrs	r3, r2
 8009c6e:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8009c70:	68fb      	ldr	r3, [r7, #12]
 8009c72:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009c76:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 8009c78:	683b      	ldr	r3, [r7, #0]
 8009c7a:	689b      	ldr	r3, [r3, #8]
 8009c7c:	031b      	lsls	r3, r3, #12
 8009c7e:	68fa      	ldr	r2, [r7, #12]
 8009c80:	4313      	orrs	r3, r2
 8009c82:	60fb      	str	r3, [r7, #12]
   
  /*if((TIMx == TIM1) || (TIMx == TIM8))*/
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8009c84:	687b      	ldr	r3, [r7, #4]
 8009c86:	4a15      	ldr	r2, [pc, #84]	; (8009cdc <TIM_OC4_SetConfig+0xbc>)
 8009c88:	4293      	cmp	r3, r2
 8009c8a:	d003      	beq.n	8009c94 <TIM_OC4_SetConfig+0x74>
 8009c8c:	687b      	ldr	r3, [r7, #4]
 8009c8e:	4a14      	ldr	r2, [pc, #80]	; (8009ce0 <TIM_OC4_SetConfig+0xc0>)
 8009c90:	4293      	cmp	r3, r2
 8009c92:	d101      	bne.n	8009c98 <TIM_OC4_SetConfig+0x78>
 8009c94:	2301      	movs	r3, #1
 8009c96:	e000      	b.n	8009c9a <TIM_OC4_SetConfig+0x7a>
 8009c98:	2300      	movs	r3, #0
 8009c9a:	2b00      	cmp	r3, #0
 8009c9c:	d009      	beq.n	8009cb2 <TIM_OC4_SetConfig+0x92>
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8009c9e:	697b      	ldr	r3, [r7, #20]
 8009ca0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8009ca4:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 8009ca6:	683b      	ldr	r3, [r7, #0]
 8009ca8:	695b      	ldr	r3, [r3, #20]
 8009caa:	019b      	lsls	r3, r3, #6
 8009cac:	697a      	ldr	r2, [r7, #20]
 8009cae:	4313      	orrs	r3, r2
 8009cb0:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8009cb2:	687b      	ldr	r3, [r7, #4]
 8009cb4:	697a      	ldr	r2, [r7, #20]
 8009cb6:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 8009cb8:	687b      	ldr	r3, [r7, #4]
 8009cba:	693a      	ldr	r2, [r7, #16]
 8009cbc:	61da      	str	r2, [r3, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8009cbe:	683b      	ldr	r3, [r7, #0]
 8009cc0:	685a      	ldr	r2, [r3, #4]
 8009cc2:	687b      	ldr	r3, [r7, #4]
 8009cc4:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8009cc6:	687b      	ldr	r3, [r7, #4]
 8009cc8:	68fa      	ldr	r2, [r7, #12]
 8009cca:	621a      	str	r2, [r3, #32]
}
 8009ccc:	371c      	adds	r7, #28
 8009cce:	46bd      	mov	sp, r7
 8009cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009cd4:	4770      	bx	lr
 8009cd6:	bf00      	nop
 8009cd8:	feff8fff 	.word	0xfeff8fff
 8009cdc:	40010000 	.word	0x40010000
 8009ce0:	40010400 	.word	0x40010400

08009ce4 <TIM_CCxChannelCmd>:
  * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8009ce4:	b480      	push	{r7}
 8009ce6:	b087      	sub	sp, #28
 8009ce8:	af00      	add	r7, sp, #0
 8009cea:	60f8      	str	r0, [r7, #12]
 8009cec:	60b9      	str	r1, [r7, #8]
 8009cee:	607a      	str	r2, [r7, #4]
  uint32_t tmp = 0;
 8009cf0:	2300      	movs	r3, #0
 8009cf2:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 8009cf4:	68bb      	ldr	r3, [r7, #8]
 8009cf6:	2201      	movs	r2, #1
 8009cf8:	fa02 f303 	lsl.w	r3, r2, r3
 8009cfc:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8009cfe:	68fb      	ldr	r3, [r7, #12]
 8009d00:	6a1a      	ldr	r2, [r3, #32]
 8009d02:	697b      	ldr	r3, [r7, #20]
 8009d04:	43db      	mvns	r3, r3
 8009d06:	401a      	ands	r2, r3
 8009d08:	68fb      	ldr	r3, [r7, #12]
 8009d0a:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
 8009d0c:	68fb      	ldr	r3, [r7, #12]
 8009d0e:	6a1a      	ldr	r2, [r3, #32]
 8009d10:	68bb      	ldr	r3, [r7, #8]
 8009d12:	6879      	ldr	r1, [r7, #4]
 8009d14:	fa01 f303 	lsl.w	r3, r1, r3
 8009d18:	431a      	orrs	r2, r3
 8009d1a:	68fb      	ldr	r3, [r7, #12]
 8009d1c:	621a      	str	r2, [r3, #32]
}
 8009d1e:	371c      	adds	r7, #28
 8009d20:	46bd      	mov	sp, r7
 8009d22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d26:	4770      	bx	lr

08009d28 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, 
                                            TIM_OC_InitTypeDef* sConfig, 
                                            uint32_t Channel)
{
 8009d28:	b580      	push	{r7, lr}
 8009d2a:	b084      	sub	sp, #16
 8009d2c:	af00      	add	r7, sp, #0
 8009d2e:	60f8      	str	r0, [r7, #12]
 8009d30:	60b9      	str	r1, [r7, #8]
 8009d32:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
  assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
  assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
  
  /* Check input state */
  __HAL_LOCK(htim);
 8009d34:	68fb      	ldr	r3, [r7, #12]
 8009d36:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8009d3a:	2b01      	cmp	r3, #1
 8009d3c:	d101      	bne.n	8009d42 <HAL_TIM_PWM_ConfigChannel+0x1a>
 8009d3e:	2302      	movs	r3, #2
 8009d40:	e105      	b.n	8009f4e <HAL_TIM_PWM_ConfigChannel+0x226>
 8009d42:	68fb      	ldr	r3, [r7, #12]
 8009d44:	2201      	movs	r2, #1
 8009d46:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  htim->State = HAL_TIM_STATE_BUSY;
 8009d4a:	68fb      	ldr	r3, [r7, #12]
 8009d4c:	2202      	movs	r2, #2
 8009d4e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  switch (Channel)
 8009d52:	687b      	ldr	r3, [r7, #4]
 8009d54:	2b14      	cmp	r3, #20
 8009d56:	f200 80f0 	bhi.w	8009f3a <HAL_TIM_PWM_ConfigChannel+0x212>
 8009d5a:	a201      	add	r2, pc, #4	; (adr r2, 8009d60 <HAL_TIM_PWM_ConfigChannel+0x38>)
 8009d5c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009d60:	08009db5 	.word	0x08009db5
 8009d64:	08009f3b 	.word	0x08009f3b
 8009d68:	08009f3b 	.word	0x08009f3b
 8009d6c:	08009f3b 	.word	0x08009f3b
 8009d70:	08009df5 	.word	0x08009df5
 8009d74:	08009f3b 	.word	0x08009f3b
 8009d78:	08009f3b 	.word	0x08009f3b
 8009d7c:	08009f3b 	.word	0x08009f3b
 8009d80:	08009e37 	.word	0x08009e37
 8009d84:	08009f3b 	.word	0x08009f3b
 8009d88:	08009f3b 	.word	0x08009f3b
 8009d8c:	08009f3b 	.word	0x08009f3b
 8009d90:	08009e77 	.word	0x08009e77
 8009d94:	08009f3b 	.word	0x08009f3b
 8009d98:	08009f3b 	.word	0x08009f3b
 8009d9c:	08009f3b 	.word	0x08009f3b
 8009da0:	08009eb9 	.word	0x08009eb9
 8009da4:	08009f3b 	.word	0x08009f3b
 8009da8:	08009f3b 	.word	0x08009f3b
 8009dac:	08009f3b 	.word	0x08009f3b
 8009db0:	08009ef9 	.word	0x08009ef9
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8009db4:	68fb      	ldr	r3, [r7, #12]
 8009db6:	681b      	ldr	r3, [r3, #0]
 8009db8:	4618      	mov	r0, r3
 8009dba:	68b9      	ldr	r1, [r7, #8]
 8009dbc:	f7ff fdca 	bl	8009954 <TIM_OC1_SetConfig>
      
      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8009dc0:	68fb      	ldr	r3, [r7, #12]
 8009dc2:	681b      	ldr	r3, [r3, #0]
 8009dc4:	68fa      	ldr	r2, [r7, #12]
 8009dc6:	6812      	ldr	r2, [r2, #0]
 8009dc8:	6992      	ldr	r2, [r2, #24]
 8009dca:	f042 0208 	orr.w	r2, r2, #8
 8009dce:	619a      	str	r2, [r3, #24]
      
      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8009dd0:	68fb      	ldr	r3, [r7, #12]
 8009dd2:	681b      	ldr	r3, [r3, #0]
 8009dd4:	68fa      	ldr	r2, [r7, #12]
 8009dd6:	6812      	ldr	r2, [r2, #0]
 8009dd8:	6992      	ldr	r2, [r2, #24]
 8009dda:	f022 0204 	bic.w	r2, r2, #4
 8009dde:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8009de0:	68fb      	ldr	r3, [r7, #12]
 8009de2:	681b      	ldr	r3, [r3, #0]
 8009de4:	68fa      	ldr	r2, [r7, #12]
 8009de6:	6812      	ldr	r2, [r2, #0]
 8009de8:	6991      	ldr	r1, [r2, #24]
 8009dea:	68ba      	ldr	r2, [r7, #8]
 8009dec:	6912      	ldr	r2, [r2, #16]
 8009dee:	430a      	orrs	r2, r1
 8009df0:	619a      	str	r2, [r3, #24]
    }
    break;
 8009df2:	e0a3      	b.n	8009f3c <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8009df4:	68fb      	ldr	r3, [r7, #12]
 8009df6:	681b      	ldr	r3, [r3, #0]
 8009df8:	4618      	mov	r0, r3
 8009dfa:	68b9      	ldr	r1, [r7, #8]
 8009dfc:	f7ff fe1e 	bl	8009a3c <TIM_OC2_SetConfig>
      
      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8009e00:	68fb      	ldr	r3, [r7, #12]
 8009e02:	681b      	ldr	r3, [r3, #0]
 8009e04:	68fa      	ldr	r2, [r7, #12]
 8009e06:	6812      	ldr	r2, [r2, #0]
 8009e08:	6992      	ldr	r2, [r2, #24]
 8009e0a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8009e0e:	619a      	str	r2, [r3, #24]
      
      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8009e10:	68fb      	ldr	r3, [r7, #12]
 8009e12:	681b      	ldr	r3, [r3, #0]
 8009e14:	68fa      	ldr	r2, [r7, #12]
 8009e16:	6812      	ldr	r2, [r2, #0]
 8009e18:	6992      	ldr	r2, [r2, #24]
 8009e1a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009e1e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 8009e20:	68fb      	ldr	r3, [r7, #12]
 8009e22:	681b      	ldr	r3, [r3, #0]
 8009e24:	68fa      	ldr	r2, [r7, #12]
 8009e26:	6812      	ldr	r2, [r2, #0]
 8009e28:	6991      	ldr	r1, [r2, #24]
 8009e2a:	68ba      	ldr	r2, [r7, #8]
 8009e2c:	6912      	ldr	r2, [r2, #16]
 8009e2e:	0212      	lsls	r2, r2, #8
 8009e30:	430a      	orrs	r2, r1
 8009e32:	619a      	str	r2, [r3, #24]
    }
    break;
 8009e34:	e082      	b.n	8009f3c <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8009e36:	68fb      	ldr	r3, [r7, #12]
 8009e38:	681b      	ldr	r3, [r3, #0]
 8009e3a:	4618      	mov	r0, r3
 8009e3c:	68b9      	ldr	r1, [r7, #8]
 8009e3e:	f7ff fe77 	bl	8009b30 <TIM_OC3_SetConfig>
      
      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8009e42:	68fb      	ldr	r3, [r7, #12]
 8009e44:	681b      	ldr	r3, [r3, #0]
 8009e46:	68fa      	ldr	r2, [r7, #12]
 8009e48:	6812      	ldr	r2, [r2, #0]
 8009e4a:	69d2      	ldr	r2, [r2, #28]
 8009e4c:	f042 0208 	orr.w	r2, r2, #8
 8009e50:	61da      	str	r2, [r3, #28]
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8009e52:	68fb      	ldr	r3, [r7, #12]
 8009e54:	681b      	ldr	r3, [r3, #0]
 8009e56:	68fa      	ldr	r2, [r7, #12]
 8009e58:	6812      	ldr	r2, [r2, #0]
 8009e5a:	69d2      	ldr	r2, [r2, #28]
 8009e5c:	f022 0204 	bic.w	r2, r2, #4
 8009e60:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;  
 8009e62:	68fb      	ldr	r3, [r7, #12]
 8009e64:	681b      	ldr	r3, [r3, #0]
 8009e66:	68fa      	ldr	r2, [r7, #12]
 8009e68:	6812      	ldr	r2, [r2, #0]
 8009e6a:	69d1      	ldr	r1, [r2, #28]
 8009e6c:	68ba      	ldr	r2, [r7, #8]
 8009e6e:	6912      	ldr	r2, [r2, #16]
 8009e70:	430a      	orrs	r2, r1
 8009e72:	61da      	str	r2, [r3, #28]
    }
    break;
 8009e74:	e062      	b.n	8009f3c <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8009e76:	68fb      	ldr	r3, [r7, #12]
 8009e78:	681b      	ldr	r3, [r3, #0]
 8009e7a:	4618      	mov	r0, r3
 8009e7c:	68b9      	ldr	r1, [r7, #8]
 8009e7e:	f7ff fecf 	bl	8009c20 <TIM_OC4_SetConfig>
      
      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8009e82:	68fb      	ldr	r3, [r7, #12]
 8009e84:	681b      	ldr	r3, [r3, #0]
 8009e86:	68fa      	ldr	r2, [r7, #12]
 8009e88:	6812      	ldr	r2, [r2, #0]
 8009e8a:	69d2      	ldr	r2, [r2, #28]
 8009e8c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8009e90:	61da      	str	r2, [r3, #28]
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8009e92:	68fb      	ldr	r3, [r7, #12]
 8009e94:	681b      	ldr	r3, [r3, #0]
 8009e96:	68fa      	ldr	r2, [r7, #12]
 8009e98:	6812      	ldr	r2, [r2, #0]
 8009e9a:	69d2      	ldr	r2, [r2, #28]
 8009e9c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009ea0:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
 8009ea2:	68fb      	ldr	r3, [r7, #12]
 8009ea4:	681b      	ldr	r3, [r3, #0]
 8009ea6:	68fa      	ldr	r2, [r7, #12]
 8009ea8:	6812      	ldr	r2, [r2, #0]
 8009eaa:	69d1      	ldr	r1, [r2, #28]
 8009eac:	68ba      	ldr	r2, [r7, #8]
 8009eae:	6912      	ldr	r2, [r2, #16]
 8009eb0:	0212      	lsls	r2, r2, #8
 8009eb2:	430a      	orrs	r2, r1
 8009eb4:	61da      	str	r2, [r3, #28]
    }
    break;
 8009eb6:	e041      	b.n	8009f3c <HAL_TIM_PWM_ConfigChannel+0x214>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance)); 
      
     /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8009eb8:	68fb      	ldr	r3, [r7, #12]
 8009eba:	681b      	ldr	r3, [r3, #0]
 8009ebc:	4618      	mov	r0, r3
 8009ebe:	68b9      	ldr	r1, [r7, #8]
 8009ec0:	f000 f90a 	bl	800a0d8 <TIM_OC5_SetConfig>
      
      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8009ec4:	68fb      	ldr	r3, [r7, #12]
 8009ec6:	681b      	ldr	r3, [r3, #0]
 8009ec8:	68fa      	ldr	r2, [r7, #12]
 8009eca:	6812      	ldr	r2, [r2, #0]
 8009ecc:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8009ece:	f042 0208 	orr.w	r2, r2, #8
 8009ed2:	655a      	str	r2, [r3, #84]	; 0x54
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8009ed4:	68fb      	ldr	r3, [r7, #12]
 8009ed6:	681b      	ldr	r3, [r3, #0]
 8009ed8:	68fa      	ldr	r2, [r7, #12]
 8009eda:	6812      	ldr	r2, [r2, #0]
 8009edc:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8009ede:	f022 0204 	bic.w	r2, r2, #4
 8009ee2:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;  
 8009ee4:	68fb      	ldr	r3, [r7, #12]
 8009ee6:	681b      	ldr	r3, [r3, #0]
 8009ee8:	68fa      	ldr	r2, [r7, #12]
 8009eea:	6812      	ldr	r2, [r2, #0]
 8009eec:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8009eee:	68ba      	ldr	r2, [r7, #8]
 8009ef0:	6912      	ldr	r2, [r2, #16]
 8009ef2:	430a      	orrs	r2, r1
 8009ef4:	655a      	str	r2, [r3, #84]	; 0x54
    }
    break;
 8009ef6:	e021      	b.n	8009f3c <HAL_TIM_PWM_ConfigChannel+0x214>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance)); 
      
     /* Configure the Channel 5 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8009ef8:	68fb      	ldr	r3, [r7, #12]
 8009efa:	681b      	ldr	r3, [r3, #0]
 8009efc:	4618      	mov	r0, r3
 8009efe:	68b9      	ldr	r1, [r7, #8]
 8009f00:	f000 f942 	bl	800a188 <TIM_OC6_SetConfig>
      
      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8009f04:	68fb      	ldr	r3, [r7, #12]
 8009f06:	681b      	ldr	r3, [r3, #0]
 8009f08:	68fa      	ldr	r2, [r7, #12]
 8009f0a:	6812      	ldr	r2, [r2, #0]
 8009f0c:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8009f0e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8009f12:	655a      	str	r2, [r3, #84]	; 0x54
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8009f14:	68fb      	ldr	r3, [r7, #12]
 8009f16:	681b      	ldr	r3, [r3, #0]
 8009f18:	68fa      	ldr	r2, [r7, #12]
 8009f1a:	6812      	ldr	r2, [r2, #0]
 8009f1c:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8009f1e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009f22:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;  
 8009f24:	68fb      	ldr	r3, [r7, #12]
 8009f26:	681b      	ldr	r3, [r3, #0]
 8009f28:	68fa      	ldr	r2, [r7, #12]
 8009f2a:	6812      	ldr	r2, [r2, #0]
 8009f2c:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8009f2e:	68ba      	ldr	r2, [r7, #8]
 8009f30:	6912      	ldr	r2, [r2, #16]
 8009f32:	0212      	lsls	r2, r2, #8
 8009f34:	430a      	orrs	r2, r1
 8009f36:	655a      	str	r2, [r3, #84]	; 0x54
    }
    break;
 8009f38:	e000      	b.n	8009f3c <HAL_TIM_PWM_ConfigChannel+0x214>
    
    default:
    break;    
 8009f3a:	bf00      	nop
  }
  
  htim->State = HAL_TIM_STATE_READY;
 8009f3c:	68fb      	ldr	r3, [r7, #12]
 8009f3e:	2201      	movs	r2, #1
 8009f40:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  __HAL_UNLOCK(htim);
 8009f44:	68fb      	ldr	r3, [r7, #12]
 8009f46:	2200      	movs	r2, #0
 8009f48:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 8009f4c:	2300      	movs	r3, #0
}
 8009f4e:	4618      	mov	r0, r3
 8009f50:	3710      	adds	r7, #16
 8009f52:	46bd      	mov	sp, r7
 8009f54:	bd80      	pop	{r7, pc}
 8009f56:	bf00      	nop

08009f58 <HAL_TIMEx_MasterConfigSynchronization>:
  *         contains the selected trigger output (TRGO) and the Master/Slave 
  *         mode. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
{
 8009f58:	b480      	push	{r7}
 8009f5a:	b085      	sub	sp, #20
 8009f5c:	af00      	add	r7, sp, #0
 8009f5e:	6078      	str	r0, [r7, #4]
 8009f60:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
  
  /* Check input state */
  __HAL_LOCK(htim);
 8009f62:	687b      	ldr	r3, [r7, #4]
 8009f64:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8009f68:	2b01      	cmp	r3, #1
 8009f6a:	d101      	bne.n	8009f70 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 8009f6c:	2302      	movs	r3, #2
 8009f6e:	e03d      	b.n	8009fec <HAL_TIMEx_MasterConfigSynchronization+0x94>
 8009f70:	687b      	ldr	r3, [r7, #4]
 8009f72:	2201      	movs	r2, #1
 8009f74:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

 /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8009f78:	687b      	ldr	r3, [r7, #4]
 8009f7a:	681b      	ldr	r3, [r3, #0]
 8009f7c:	685b      	ldr	r3, [r3, #4]
 8009f7e:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8009f80:	687b      	ldr	r3, [r7, #4]
 8009f82:	681b      	ldr	r3, [r3, #0]
 8009f84:	689b      	ldr	r3, [r3, #8]
 8009f86:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8009f88:	687b      	ldr	r3, [r7, #4]
 8009f8a:	681b      	ldr	r3, [r3, #0]
 8009f8c:	4a1a      	ldr	r2, [pc, #104]	; (8009ff8 <HAL_TIMEx_MasterConfigSynchronization+0xa0>)
 8009f8e:	4293      	cmp	r3, r2
 8009f90:	d004      	beq.n	8009f9c <HAL_TIMEx_MasterConfigSynchronization+0x44>
 8009f92:	687b      	ldr	r3, [r7, #4]
 8009f94:	681b      	ldr	r3, [r3, #0]
 8009f96:	4a19      	ldr	r2, [pc, #100]	; (8009ffc <HAL_TIMEx_MasterConfigSynchronization+0xa4>)
 8009f98:	4293      	cmp	r3, r2
 8009f9a:	d108      	bne.n	8009fae <HAL_TIMEx_MasterConfigSynchronization+0x56>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
    
    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 8009f9c:	68fb      	ldr	r3, [r7, #12]
 8009f9e:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8009fa2:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8009fa4:	683b      	ldr	r3, [r7, #0]
 8009fa6:	685b      	ldr	r3, [r3, #4]
 8009fa8:	68fa      	ldr	r2, [r7, #12]
 8009faa:	4313      	orrs	r3, r2
 8009fac:	60fb      	str	r3, [r7, #12]
  }
  
  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8009fae:	68fb      	ldr	r3, [r7, #12]
 8009fb0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009fb4:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8009fb6:	683b      	ldr	r3, [r7, #0]
 8009fb8:	681b      	ldr	r3, [r3, #0]
 8009fba:	68fa      	ldr	r2, [r7, #12]
 8009fbc:	4313      	orrs	r3, r2
 8009fbe:	60fb      	str	r3, [r7, #12]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 8009fc0:	68bb      	ldr	r3, [r7, #8]
 8009fc2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009fc6:	60bb      	str	r3, [r7, #8]
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8009fc8:	683b      	ldr	r3, [r7, #0]
 8009fca:	689b      	ldr	r3, [r3, #8]
 8009fcc:	68ba      	ldr	r2, [r7, #8]
 8009fce:	4313      	orrs	r3, r2
 8009fd0:	60bb      	str	r3, [r7, #8]
  
  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8009fd2:	687b      	ldr	r3, [r7, #4]
 8009fd4:	681b      	ldr	r3, [r3, #0]
 8009fd6:	68fa      	ldr	r2, [r7, #12]
 8009fd8:	605a      	str	r2, [r3, #4]
  
  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 8009fda:	687b      	ldr	r3, [r7, #4]
 8009fdc:	681b      	ldr	r3, [r3, #0]
 8009fde:	68ba      	ldr	r2, [r7, #8]
 8009fe0:	609a      	str	r2, [r3, #8]

  __HAL_UNLOCK(htim);
 8009fe2:	687b      	ldr	r3, [r7, #4]
 8009fe4:	2200      	movs	r2, #0
 8009fe6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 8009fea:	2300      	movs	r3, #0
} 
 8009fec:	4618      	mov	r0, r3
 8009fee:	3714      	adds	r7, #20
 8009ff0:	46bd      	mov	sp, r7
 8009ff2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ff6:	4770      	bx	lr
 8009ff8:	40010000 	.word	0x40010000
 8009ffc:	40010400 	.word	0x40010400

0800a000 <HAL_TIMEx_ConfigBreakDeadTime>:
  *         contains the BDTR Register configuration  information for the TIM peripheral. 
  * @retval HAL status
  */    
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, 
                                              TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
{
 800a000:	b480      	push	{r7}
 800a002:	b085      	sub	sp, #20
 800a004:	af00      	add	r7, sp, #0
 800a006:	6078      	str	r0, [r7, #4]
 800a008:	6039      	str	r1, [r7, #0]
  uint32_t tmpbdtr = 0;
 800a00a:	2300      	movs	r3, #0
 800a00c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
  assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
  
  /* Check input state */
  __HAL_LOCK(htim);
 800a00e:	687b      	ldr	r3, [r7, #4]
 800a010:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800a014:	2b01      	cmp	r3, #1
 800a016:	d101      	bne.n	800a01c <HAL_TIMEx_ConfigBreakDeadTime+0x1c>
 800a018:	2302      	movs	r3, #2
 800a01a:	e04d      	b.n	800a0b8 <HAL_TIMEx_ConfigBreakDeadTime+0xb8>
 800a01c:	687b      	ldr	r3, [r7, #4]
 800a01e:	2201      	movs	r2, #1
 800a020:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  htim->State = HAL_TIM_STATE_BUSY;
 800a024:	687b      	ldr	r3, [r7, #4]
 800a026:	2202      	movs	r2, #2
 800a028:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
    
  /* Clear the BDTR bits */
  tmpbdtr &= ~(TIM_BDTR_DTG | TIM_BDTR_LOCK |  TIM_BDTR_OSSI | 
 800a02c:	68fb      	ldr	r3, [r7, #12]
 800a02e:	f003 437c 	and.w	r3, r3, #4227858432	; 0xfc000000
 800a032:	60fb      	str	r3, [r7, #12]
               TIM_BDTR_OSSR | TIM_BDTR_BKE | TIM_BDTR_BKP | 
               TIM_BDTR_AOE | TIM_BDTR_MOE | TIM_BDTR_BKF |
               TIM_BDTR_BK2F | TIM_BDTR_BK2E | TIM_BDTR_BK2P);

  /* Set the BDTR bits */
  tmpbdtr |= sBreakDeadTimeConfig->DeadTime;
 800a034:	683b      	ldr	r3, [r7, #0]
 800a036:	68db      	ldr	r3, [r3, #12]
 800a038:	68fa      	ldr	r2, [r7, #12]
 800a03a:	4313      	orrs	r3, r2
 800a03c:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->LockLevel;
 800a03e:	683b      	ldr	r3, [r7, #0]
 800a040:	689b      	ldr	r3, [r3, #8]
 800a042:	68fa      	ldr	r2, [r7, #12]
 800a044:	4313      	orrs	r3, r2
 800a046:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->OffStateIDLEMode;
 800a048:	683b      	ldr	r3, [r7, #0]
 800a04a:	685b      	ldr	r3, [r3, #4]
 800a04c:	68fa      	ldr	r2, [r7, #12]
 800a04e:	4313      	orrs	r3, r2
 800a050:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->OffStateRunMode;
 800a052:	683b      	ldr	r3, [r7, #0]
 800a054:	681b      	ldr	r3, [r3, #0]
 800a056:	68fa      	ldr	r2, [r7, #12]
 800a058:	4313      	orrs	r3, r2
 800a05a:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->BreakState;
 800a05c:	683b      	ldr	r3, [r7, #0]
 800a05e:	691b      	ldr	r3, [r3, #16]
 800a060:	68fa      	ldr	r2, [r7, #12]
 800a062:	4313      	orrs	r3, r2
 800a064:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->BreakPolarity;
 800a066:	683b      	ldr	r3, [r7, #0]
 800a068:	695b      	ldr	r3, [r3, #20]
 800a06a:	68fa      	ldr	r2, [r7, #12]
 800a06c:	4313      	orrs	r3, r2
 800a06e:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->AutomaticOutput;
 800a070:	683b      	ldr	r3, [r7, #0]
 800a072:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a074:	68fa      	ldr	r2, [r7, #12]
 800a076:	4313      	orrs	r3, r2
 800a078:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= (sBreakDeadTimeConfig->BreakFilter << BDTR_BKF_SHIFT);
 800a07a:	683b      	ldr	r3, [r7, #0]
 800a07c:	699b      	ldr	r3, [r3, #24]
 800a07e:	041b      	lsls	r3, r3, #16
 800a080:	68fa      	ldr	r2, [r7, #12]
 800a082:	4313      	orrs	r3, r2
 800a084:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT);
 800a086:	683b      	ldr	r3, [r7, #0]
 800a088:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a08a:	051b      	lsls	r3, r3, #20
 800a08c:	68fa      	ldr	r2, [r7, #12]
 800a08e:	4313      	orrs	r3, r2
 800a090:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->Break2State;
 800a092:	683b      	ldr	r3, [r7, #0]
 800a094:	69db      	ldr	r3, [r3, #28]
 800a096:	68fa      	ldr	r2, [r7, #12]
 800a098:	4313      	orrs	r3, r2
 800a09a:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->Break2Polarity;
 800a09c:	683b      	ldr	r3, [r7, #0]
 800a09e:	6a1b      	ldr	r3, [r3, #32]
 800a0a0:	68fa      	ldr	r2, [r7, #12]
 800a0a2:	4313      	orrs	r3, r2
 800a0a4:	60fb      	str	r3, [r7, #12]
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 800a0a6:	687b      	ldr	r3, [r7, #4]
 800a0a8:	681b      	ldr	r3, [r3, #0]
 800a0aa:	68fa      	ldr	r2, [r7, #12]
 800a0ac:	645a      	str	r2, [r3, #68]	; 0x44
  
  __HAL_UNLOCK(htim);
 800a0ae:	687b      	ldr	r3, [r7, #4]
 800a0b0:	2200      	movs	r2, #0
 800a0b2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 800a0b6:	2300      	movs	r3, #0
}
 800a0b8:	4618      	mov	r0, r3
 800a0ba:	3714      	adds	r7, #20
 800a0bc:	46bd      	mov	sp, r7
 800a0be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0c2:	4770      	bx	lr

0800a0c4 <HAL_TIMEx_CommutationCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
{
 800a0c4:	b480      	push	{r7}
 800a0c6:	b083      	sub	sp, #12
 800a0c8:	af00      	add	r7, sp, #0
 800a0ca:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutationCallback could be implemented in the user file
   */
}
 800a0cc:	370c      	adds	r7, #12
 800a0ce:	46bd      	mov	sp, r7
 800a0d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0d4:	4770      	bx	lr
 800a0d6:	bf00      	nop

0800a0d8 <TIM_OC5_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800a0d8:	b480      	push	{r7}
 800a0da:	b087      	sub	sp, #28
 800a0dc:	af00      	add	r7, sp, #0
 800a0de:	6078      	str	r0, [r7, #4]
 800a0e0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800a0e2:	2300      	movs	r3, #0
 800a0e4:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800a0e6:	2300      	movs	r3, #0
 800a0e8:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0; 
 800a0ea:	2300      	movs	r3, #0
 800a0ec:	617b      	str	r3, [r7, #20]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800a0ee:	687b      	ldr	r3, [r7, #4]
 800a0f0:	6a1b      	ldr	r3, [r3, #32]
 800a0f2:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 800a0f6:	687b      	ldr	r3, [r7, #4]
 800a0f8:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800a0fa:	687b      	ldr	r3, [r7, #4]
 800a0fc:	6a1b      	ldr	r3, [r3, #32]
 800a0fe:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2; 
 800a100:	687b      	ldr	r3, [r7, #4]
 800a102:	685b      	ldr	r3, [r3, #4]
 800a104:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800a106:	687b      	ldr	r3, [r7, #4]
 800a108:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a10a:	613b      	str	r3, [r7, #16]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 800a10c:	693a      	ldr	r2, [r7, #16]
 800a10e:	4b1b      	ldr	r3, [pc, #108]	; (800a17c <TIM_OC5_SetConfig+0xa4>)
 800a110:	4013      	ands	r3, r2
 800a112:	613b      	str	r3, [r7, #16]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800a114:	683b      	ldr	r3, [r7, #0]
 800a116:	681b      	ldr	r3, [r3, #0]
 800a118:	693a      	ldr	r2, [r7, #16]
 800a11a:	4313      	orrs	r3, r2
 800a11c:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 800a11e:	68fb      	ldr	r3, [r7, #12]
 800a120:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800a124:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);
 800a126:	683b      	ldr	r3, [r7, #0]
 800a128:	689b      	ldr	r3, [r3, #8]
 800a12a:	041b      	lsls	r3, r3, #16
 800a12c:	68fa      	ldr	r2, [r7, #12]
 800a12e:	4313      	orrs	r3, r2
 800a130:	60fb      	str	r3, [r7, #12]

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800a132:	687b      	ldr	r3, [r7, #4]
 800a134:	4a12      	ldr	r2, [pc, #72]	; (800a180 <TIM_OC5_SetConfig+0xa8>)
 800a136:	4293      	cmp	r3, r2
 800a138:	d003      	beq.n	800a142 <TIM_OC5_SetConfig+0x6a>
 800a13a:	687b      	ldr	r3, [r7, #4]
 800a13c:	4a11      	ldr	r2, [pc, #68]	; (800a184 <TIM_OC5_SetConfig+0xac>)
 800a13e:	4293      	cmp	r3, r2
 800a140:	d109      	bne.n	800a156 <TIM_OC5_SetConfig+0x7e>
  {   
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 800a142:	697b      	ldr	r3, [r7, #20]
 800a144:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800a148:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
 800a14a:	683b      	ldr	r3, [r7, #0]
 800a14c:	695b      	ldr	r3, [r3, #20]
 800a14e:	021b      	lsls	r3, r3, #8
 800a150:	697a      	ldr	r2, [r7, #20]
 800a152:	4313      	orrs	r3, r2
 800a154:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800a156:	687b      	ldr	r3, [r7, #4]
 800a158:	697a      	ldr	r2, [r7, #20]
 800a15a:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800a15c:	687b      	ldr	r3, [r7, #4]
 800a15e:	693a      	ldr	r2, [r7, #16]
 800a160:	655a      	str	r2, [r3, #84]	; 0x54
  
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800a162:	683b      	ldr	r3, [r7, #0]
 800a164:	685a      	ldr	r2, [r3, #4]
 800a166:	687b      	ldr	r3, [r7, #4]
 800a168:	659a      	str	r2, [r3, #88]	; 0x58
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800a16a:	687b      	ldr	r3, [r7, #4]
 800a16c:	68fa      	ldr	r2, [r7, #12]
 800a16e:	621a      	str	r2, [r3, #32]
}
 800a170:	371c      	adds	r7, #28
 800a172:	46bd      	mov	sp, r7
 800a174:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a178:	4770      	bx	lr
 800a17a:	bf00      	nop
 800a17c:	fffeff8f 	.word	0xfffeff8f
 800a180:	40010000 	.word	0x40010000
 800a184:	40010400 	.word	0x40010400

0800a188 <TIM_OC6_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800a188:	b480      	push	{r7}
 800a18a:	b087      	sub	sp, #28
 800a18c:	af00      	add	r7, sp, #0
 800a18e:	6078      	str	r0, [r7, #4]
 800a190:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800a192:	2300      	movs	r3, #0
 800a194:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800a196:	2300      	movs	r3, #0
 800a198:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0; 
 800a19a:	2300      	movs	r3, #0
 800a19c:	617b      	str	r3, [r7, #20]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800a19e:	687b      	ldr	r3, [r7, #4]
 800a1a0:	6a1b      	ldr	r3, [r3, #32]
 800a1a2:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 800a1a6:	687b      	ldr	r3, [r7, #4]
 800a1a8:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800a1aa:	687b      	ldr	r3, [r7, #4]
 800a1ac:	6a1b      	ldr	r3, [r3, #32]
 800a1ae:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2; 
 800a1b0:	687b      	ldr	r3, [r7, #4]
 800a1b2:	685b      	ldr	r3, [r3, #4]
 800a1b4:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800a1b6:	687b      	ldr	r3, [r7, #4]
 800a1b8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a1ba:	613b      	str	r3, [r7, #16]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800a1bc:	693a      	ldr	r2, [r7, #16]
 800a1be:	4b1b      	ldr	r3, [pc, #108]	; (800a22c <TIM_OC6_SetConfig+0xa4>)
 800a1c0:	4013      	ands	r3, r2
 800a1c2:	613b      	str	r3, [r7, #16]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800a1c4:	683b      	ldr	r3, [r7, #0]
 800a1c6:	681b      	ldr	r3, [r3, #0]
 800a1c8:	021b      	lsls	r3, r3, #8
 800a1ca:	693a      	ldr	r2, [r7, #16]
 800a1cc:	4313      	orrs	r3, r2
 800a1ce:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800a1d0:	68fb      	ldr	r3, [r7, #12]
 800a1d2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800a1d6:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);
 800a1d8:	683b      	ldr	r3, [r7, #0]
 800a1da:	689b      	ldr	r3, [r3, #8]
 800a1dc:	051b      	lsls	r3, r3, #20
 800a1de:	68fa      	ldr	r2, [r7, #12]
 800a1e0:	4313      	orrs	r3, r2
 800a1e2:	60fb      	str	r3, [r7, #12]

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800a1e4:	687b      	ldr	r3, [r7, #4]
 800a1e6:	4a12      	ldr	r2, [pc, #72]	; (800a230 <TIM_OC6_SetConfig+0xa8>)
 800a1e8:	4293      	cmp	r3, r2
 800a1ea:	d003      	beq.n	800a1f4 <TIM_OC6_SetConfig+0x6c>
 800a1ec:	687b      	ldr	r3, [r7, #4]
 800a1ee:	4a11      	ldr	r2, [pc, #68]	; (800a234 <TIM_OC6_SetConfig+0xac>)
 800a1f0:	4293      	cmp	r3, r2
 800a1f2:	d109      	bne.n	800a208 <TIM_OC6_SetConfig+0x80>
  {   
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 800a1f4:	697b      	ldr	r3, [r7, #20]
 800a1f6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800a1fa:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
 800a1fc:	683b      	ldr	r3, [r7, #0]
 800a1fe:	695b      	ldr	r3, [r3, #20]
 800a200:	029b      	lsls	r3, r3, #10
 800a202:	697a      	ldr	r2, [r7, #20]
 800a204:	4313      	orrs	r3, r2
 800a206:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800a208:	687b      	ldr	r3, [r7, #4]
 800a20a:	697a      	ldr	r2, [r7, #20]
 800a20c:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800a20e:	687b      	ldr	r3, [r7, #4]
 800a210:	693a      	ldr	r2, [r7, #16]
 800a212:	655a      	str	r2, [r3, #84]	; 0x54
  
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 800a214:	683b      	ldr	r3, [r7, #0]
 800a216:	685a      	ldr	r2, [r3, #4]
 800a218:	687b      	ldr	r3, [r7, #4]
 800a21a:	65da      	str	r2, [r3, #92]	; 0x5c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800a21c:	687b      	ldr	r3, [r7, #4]
 800a21e:	68fa      	ldr	r2, [r7, #12]
 800a220:	621a      	str	r2, [r3, #32]
} 
 800a222:	371c      	adds	r7, #28
 800a224:	46bd      	mov	sp, r7
 800a226:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a22a:	4770      	bx	lr
 800a22c:	feff8fff 	.word	0xfeff8fff
 800a230:	40010000 	.word	0x40010000
 800a234:	40010400 	.word	0x40010400

0800a238 <HAL_UART_Init>:
  *         parameters in the UART_InitTypeDef and creates the associated handle .
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800a238:	b580      	push	{r7, lr}
 800a23a:	b082      	sub	sp, #8
 800a23c:	af00      	add	r7, sp, #0
 800a23e:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if(huart == NULL)
 800a240:	687b      	ldr	r3, [r7, #4]
 800a242:	2b00      	cmp	r3, #0
 800a244:	d101      	bne.n	800a24a <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800a246:	2301      	movs	r3, #1
 800a248:	e043      	b.n	800a2d2 <HAL_UART_Init+0x9a>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  
  if(huart->State == HAL_UART_STATE_RESET)
 800a24a:	687b      	ldr	r3, [r7, #4]
 800a24c:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800a250:	b2db      	uxtb	r3, r3
 800a252:	2b00      	cmp	r3, #0
 800a254:	d106      	bne.n	800a264 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800a256:	687b      	ldr	r3, [r7, #4]
 800a258:	2200      	movs	r2, #0
 800a25a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800a25e:	6878      	ldr	r0, [r7, #4]
 800a260:	f005 f9e2 	bl	800f628 <HAL_UART_MspInit>
  }

  huart->State = HAL_UART_STATE_BUSY;
 800a264:	687b      	ldr	r3, [r7, #4]
 800a266:	2202      	movs	r2, #2
 800a268:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800a26c:	687b      	ldr	r3, [r7, #4]
 800a26e:	681b      	ldr	r3, [r3, #0]
 800a270:	687a      	ldr	r2, [r7, #4]
 800a272:	6812      	ldr	r2, [r2, #0]
 800a274:	6812      	ldr	r2, [r2, #0]
 800a276:	f022 0201 	bic.w	r2, r2, #1
 800a27a:	601a      	str	r2, [r3, #0]
  
  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800a27c:	6878      	ldr	r0, [r7, #4]
 800a27e:	f000 f9e9 	bl	800a654 <UART_SetConfig>
 800a282:	4603      	mov	r3, r0
 800a284:	2b01      	cmp	r3, #1
 800a286:	d101      	bne.n	800a28c <HAL_UART_Init+0x54>
  {
    return HAL_ERROR;
 800a288:	2301      	movs	r3, #1
 800a28a:	e022      	b.n	800a2d2 <HAL_UART_Init+0x9a>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800a28c:	687b      	ldr	r3, [r7, #4]
 800a28e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a290:	2b00      	cmp	r3, #0
 800a292:	d002      	beq.n	800a29a <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 800a294:	6878      	ldr	r0, [r7, #4]
 800a296:	f000 fc29 	bl	800aaec <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
 800a29a:	687b      	ldr	r3, [r7, #4]
 800a29c:	681b      	ldr	r3, [r3, #0]
 800a29e:	687a      	ldr	r2, [r7, #4]
 800a2a0:	6812      	ldr	r2, [r2, #0]
 800a2a2:	6852      	ldr	r2, [r2, #4]
 800a2a4:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800a2a8:	605a      	str	r2, [r3, #4]
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 800a2aa:	687b      	ldr	r3, [r7, #4]
 800a2ac:	681b      	ldr	r3, [r3, #0]
 800a2ae:	687a      	ldr	r2, [r7, #4]
 800a2b0:	6812      	ldr	r2, [r2, #0]
 800a2b2:	6892      	ldr	r2, [r2, #8]
 800a2b4:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800a2b8:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 800a2ba:	687b      	ldr	r3, [r7, #4]
 800a2bc:	681b      	ldr	r3, [r3, #0]
 800a2be:	687a      	ldr	r2, [r7, #4]
 800a2c0:	6812      	ldr	r2, [r2, #0]
 800a2c2:	6812      	ldr	r2, [r2, #0]
 800a2c4:	f042 0201 	orr.w	r2, r2, #1
 800a2c8:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->State to Ready */
  return (UART_CheckIdleState(huart));
 800a2ca:	6878      	ldr	r0, [r7, #4]
 800a2cc:	f000 fcb0 	bl	800ac30 <UART_CheckIdleState>
 800a2d0:	4603      	mov	r3, r0
}
 800a2d2:	4618      	mov	r0, r3
 800a2d4:	3708      	adds	r7, #8
 800a2d6:	46bd      	mov	sp, r7
 800a2d8:	bd80      	pop	{r7, pc}
 800a2da:	bf00      	nop

0800a2dc <HAL_UART_DeInit>:
  * @brief DeInitializes the UART peripheral 
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
 800a2dc:	b580      	push	{r7, lr}
 800a2de:	b082      	sub	sp, #8
 800a2e0:	af00      	add	r7, sp, #0
 800a2e2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if(huart == NULL)
 800a2e4:	687b      	ldr	r3, [r7, #4]
 800a2e6:	2b00      	cmp	r3, #0
 800a2e8:	d101      	bne.n	800a2ee <HAL_UART_DeInit+0x12>
  {
    return HAL_ERROR;
 800a2ea:	2301      	movs	r3, #1
 800a2ec:	e026      	b.n	800a33c <HAL_UART_DeInit+0x60>
  }
  
  /* Check the parameters */
  assert_param(IS_UART_INSTANCE(huart->Instance));

  huart->State = HAL_UART_STATE_BUSY;
 800a2ee:	687b      	ldr	r3, [r7, #4]
 800a2f0:	2202      	movs	r2, #2
 800a2f2:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  
  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800a2f6:	687b      	ldr	r3, [r7, #4]
 800a2f8:	681b      	ldr	r3, [r3, #0]
 800a2fa:	687a      	ldr	r2, [r7, #4]
 800a2fc:	6812      	ldr	r2, [r2, #0]
 800a2fe:	6812      	ldr	r2, [r2, #0]
 800a300:	f022 0201 	bic.w	r2, r2, #1
 800a304:	601a      	str	r2, [r3, #0]
  
  huart->Instance->CR1 = 0x0;
 800a306:	687b      	ldr	r3, [r7, #4]
 800a308:	681b      	ldr	r3, [r3, #0]
 800a30a:	2200      	movs	r2, #0
 800a30c:	601a      	str	r2, [r3, #0]
  huart->Instance->CR2 = 0x0;
 800a30e:	687b      	ldr	r3, [r7, #4]
 800a310:	681b      	ldr	r3, [r3, #0]
 800a312:	2200      	movs	r2, #0
 800a314:	605a      	str	r2, [r3, #4]
  huart->Instance->CR3 = 0x0;
 800a316:	687b      	ldr	r3, [r7, #4]
 800a318:	681b      	ldr	r3, [r3, #0]
 800a31a:	2200      	movs	r2, #0
 800a31c:	609a      	str	r2, [r3, #8]
  
  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);
 800a31e:	6878      	ldr	r0, [r7, #4]
 800a320:	f005 fa2e 	bl	800f780 <HAL_UART_MspDeInit>

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a324:	687b      	ldr	r3, [r7, #4]
 800a326:	2200      	movs	r2, #0
 800a328:	66da      	str	r2, [r3, #108]	; 0x6c
  huart->State = HAL_UART_STATE_RESET;
 800a32a:	687b      	ldr	r3, [r7, #4]
 800a32c:	2200      	movs	r2, #0
 800a32e:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  
  /* Process Unlock */
  __HAL_UNLOCK(huart);
 800a332:	687b      	ldr	r3, [r7, #4]
 800a334:	2200      	movs	r2, #0
 800a336:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  
  return HAL_OK;
 800a33a:	2300      	movs	r3, #0
}
 800a33c:	4618      	mov	r0, r3
 800a33e:	3708      	adds	r7, #8
 800a340:	46bd      	mov	sp, r7
 800a342:	bd80      	pop	{r7, pc}

0800a344 <HAL_UART_Receive_DMA>:
  * @note   When the UART parity is enabled (PCE = 1), the received data contain 
  *         the parity bit (MSB position)     
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800a344:	b590      	push	{r4, r7, lr}
 800a346:	b087      	sub	sp, #28
 800a348:	af00      	add	r7, sp, #0
 800a34a:	60f8      	str	r0, [r7, #12]
 800a34c:	60b9      	str	r1, [r7, #8]
 800a34e:	4613      	mov	r3, r2
 800a350:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;
  
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 800a352:	68fb      	ldr	r3, [r7, #12]
 800a354:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800a358:	b2db      	uxtb	r3, r3
 800a35a:	2b01      	cmp	r3, #1
 800a35c:	d005      	beq.n	800a36a <HAL_UART_Receive_DMA+0x26>
 800a35e:	68fb      	ldr	r3, [r7, #12]
 800a360:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800a364:	b2db      	uxtb	r3, r3
 800a366:	2b12      	cmp	r3, #18
 800a368:	d155      	bne.n	800a416 <HAL_UART_Receive_DMA+0xd2>
  {
    if((pData == NULL ) || (Size == 0)) 
 800a36a:	68bb      	ldr	r3, [r7, #8]
 800a36c:	2b00      	cmp	r3, #0
 800a36e:	d002      	beq.n	800a376 <HAL_UART_Receive_DMA+0x32>
 800a370:	88fb      	ldrh	r3, [r7, #6]
 800a372:	2b00      	cmp	r3, #0
 800a374:	d101      	bne.n	800a37a <HAL_UART_Receive_DMA+0x36>
    {
      return HAL_ERROR;
 800a376:	2301      	movs	r3, #1
 800a378:	e04e      	b.n	800a418 <HAL_UART_Receive_DMA+0xd4>
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 800a37a:	68fb      	ldr	r3, [r7, #12]
 800a37c:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 800a380:	2b01      	cmp	r3, #1
 800a382:	d101      	bne.n	800a388 <HAL_UART_Receive_DMA+0x44>
 800a384:	2302      	movs	r3, #2
 800a386:	e047      	b.n	800a418 <HAL_UART_Receive_DMA+0xd4>
 800a388:	68fb      	ldr	r3, [r7, #12]
 800a38a:	2201      	movs	r2, #1
 800a38c:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
    
    huart->pRxBuffPtr = pData;
 800a390:	68ba      	ldr	r2, [r7, #8]
 800a392:	68fb      	ldr	r3, [r7, #12]
 800a394:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferSize = Size;
 800a396:	68fb      	ldr	r3, [r7, #12]
 800a398:	88fa      	ldrh	r2, [r7, #6]
 800a39a:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a39e:	68fb      	ldr	r3, [r7, #12]
 800a3a0:	2200      	movs	r2, #0
 800a3a2:	66da      	str	r2, [r3, #108]	; 0x6c
    /* Check if a transmit process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX) 
 800a3a4:	68fb      	ldr	r3, [r7, #12]
 800a3a6:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800a3aa:	b2db      	uxtb	r3, r3
 800a3ac:	2b12      	cmp	r3, #18
 800a3ae:	d104      	bne.n	800a3ba <HAL_UART_Receive_DMA+0x76>
    {
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 800a3b0:	68fb      	ldr	r3, [r7, #12]
 800a3b2:	2232      	movs	r2, #50	; 0x32
 800a3b4:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
 800a3b8:	e003      	b.n	800a3c2 <HAL_UART_Receive_DMA+0x7e>
    }
    else
    {
      huart->State = HAL_UART_STATE_BUSY_RX;
 800a3ba:	68fb      	ldr	r3, [r7, #12]
 800a3bc:	2222      	movs	r2, #34	; 0x22
 800a3be:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    }
    
    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 800a3c2:	68fb      	ldr	r3, [r7, #12]
 800a3c4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800a3c6:	4a16      	ldr	r2, [pc, #88]	; (800a420 <HAL_UART_Receive_DMA+0xdc>)
 800a3c8:	63da      	str	r2, [r3, #60]	; 0x3c
    
    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 800a3ca:	68fb      	ldr	r3, [r7, #12]
 800a3cc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800a3ce:	4a15      	ldr	r2, [pc, #84]	; (800a424 <HAL_UART_Receive_DMA+0xe0>)
 800a3d0:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 800a3d2:	68fb      	ldr	r3, [r7, #12]
 800a3d4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800a3d6:	4a14      	ldr	r2, [pc, #80]	; (800a428 <HAL_UART_Receive_DMA+0xe4>)
 800a3d8:	649a      	str	r2, [r3, #72]	; 0x48

    /* Enable the DMA channel */
    tmp = (uint32_t*)&pData;
 800a3da:	f107 0308 	add.w	r3, r7, #8
 800a3de:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
 800a3e0:	68fb      	ldr	r3, [r7, #12]
 800a3e2:	6e59      	ldr	r1, [r3, #100]	; 0x64
 800a3e4:	68fb      	ldr	r3, [r7, #12]
 800a3e6:	681b      	ldr	r3, [r3, #0]
 800a3e8:	3324      	adds	r3, #36	; 0x24
 800a3ea:	461c      	mov	r4, r3
 800a3ec:	697b      	ldr	r3, [r7, #20]
 800a3ee:	681a      	ldr	r2, [r3, #0]
 800a3f0:	88fb      	ldrh	r3, [r7, #6]
 800a3f2:	4608      	mov	r0, r1
 800a3f4:	4621      	mov	r1, r4
 800a3f6:	f7fa fc1d 	bl	8004c34 <HAL_DMA_Start_IT>

    /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
     huart->Instance->CR3 |= USART_CR3_DMAR;
 800a3fa:	68fb      	ldr	r3, [r7, #12]
 800a3fc:	681b      	ldr	r3, [r3, #0]
 800a3fe:	68fa      	ldr	r2, [r7, #12]
 800a400:	6812      	ldr	r2, [r2, #0]
 800a402:	6892      	ldr	r2, [r2, #8]
 800a404:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a408:	609a      	str	r2, [r3, #8]
    
     /* Process Unlocked */
     __HAL_UNLOCK(huart);
 800a40a:	68fb      	ldr	r3, [r7, #12]
 800a40c:	2200      	movs	r2, #0
 800a40e:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
     
    return HAL_OK;
 800a412:	2300      	movs	r3, #0
 800a414:	e000      	b.n	800a418 <HAL_UART_Receive_DMA+0xd4>
  }
  else
  {
    return HAL_BUSY; 
 800a416:	2302      	movs	r3, #2
  }
}
 800a418:	4618      	mov	r0, r3
 800a41a:	371c      	adds	r7, #28
 800a41c:	46bd      	mov	sp, r7
 800a41e:	bd90      	pop	{r4, r7, pc}
 800a420:	0800a55d 	.word	0x0800a55d
 800a424:	0800a5bd 	.word	0x0800a5bd
 800a428:	0800a5d9 	.word	0x0800a5d9

0800a42c <UART_WaitOnFlagUntilTimeout>:
  * @param  Status: The new Flag status (SET or RESET).
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
 800a42c:	b580      	push	{r7, lr}
 800a42e:	b086      	sub	sp, #24
 800a430:	af00      	add	r7, sp, #0
 800a432:	60f8      	str	r0, [r7, #12]
 800a434:	60b9      	str	r1, [r7, #8]
 800a436:	603b      	str	r3, [r7, #0]
 800a438:	4613      	mov	r3, r2
 800a43a:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart = HAL_GetTick();
 800a43c:	f7f7 f8c2 	bl	80015c4 <HAL_GetTick>
 800a440:	6178      	str	r0, [r7, #20]
  
  /* Wait until flag is set */
  if(Status == RESET)
 800a442:	79fb      	ldrb	r3, [r7, #7]
 800a444:	2b00      	cmp	r3, #0
 800a446:	d142      	bne.n	800a4ce <UART_WaitOnFlagUntilTimeout+0xa2>
  {    
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
 800a448:	e038      	b.n	800a4bc <UART_WaitOnFlagUntilTimeout+0x90>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800a44a:	683b      	ldr	r3, [r7, #0]
 800a44c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800a450:	d034      	beq.n	800a4bc <UART_WaitOnFlagUntilTimeout+0x90>
      {
        if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
 800a452:	683b      	ldr	r3, [r7, #0]
 800a454:	2b00      	cmp	r3, #0
 800a456:	d007      	beq.n	800a468 <UART_WaitOnFlagUntilTimeout+0x3c>
 800a458:	f7f7 f8b4 	bl	80015c4 <HAL_GetTick>
 800a45c:	4602      	mov	r2, r0
 800a45e:	697b      	ldr	r3, [r7, #20]
 800a460:	1ad2      	subs	r2, r2, r3
 800a462:	683b      	ldr	r3, [r7, #0]
 800a464:	429a      	cmp	r2, r3
 800a466:	d329      	bcc.n	800a4bc <UART_WaitOnFlagUntilTimeout+0x90>
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 800a468:	68fb      	ldr	r3, [r7, #12]
 800a46a:	681b      	ldr	r3, [r3, #0]
 800a46c:	68fa      	ldr	r2, [r7, #12]
 800a46e:	6812      	ldr	r2, [r2, #0]
 800a470:	6812      	ldr	r2, [r2, #0]
 800a472:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a476:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 800a478:	68fb      	ldr	r3, [r7, #12]
 800a47a:	681b      	ldr	r3, [r3, #0]
 800a47c:	68fa      	ldr	r2, [r7, #12]
 800a47e:	6812      	ldr	r2, [r2, #0]
 800a480:	6812      	ldr	r2, [r2, #0]
 800a482:	f022 0220 	bic.w	r2, r2, #32
 800a486:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 800a488:	68fb      	ldr	r3, [r7, #12]
 800a48a:	681b      	ldr	r3, [r3, #0]
 800a48c:	68fa      	ldr	r2, [r7, #12]
 800a48e:	6812      	ldr	r2, [r2, #0]
 800a490:	6812      	ldr	r2, [r2, #0]
 800a492:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800a496:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 800a498:	68fb      	ldr	r3, [r7, #12]
 800a49a:	681b      	ldr	r3, [r3, #0]
 800a49c:	68fa      	ldr	r2, [r7, #12]
 800a49e:	6812      	ldr	r2, [r2, #0]
 800a4a0:	6892      	ldr	r2, [r2, #8]
 800a4a2:	f022 0201 	bic.w	r2, r2, #1
 800a4a6:	609a      	str	r2, [r3, #8]
          
          huart->State= HAL_UART_STATE_READY;
 800a4a8:	68fb      	ldr	r3, [r7, #12]
 800a4aa:	2201      	movs	r2, #1
 800a4ac:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
          
          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800a4b0:	68fb      	ldr	r3, [r7, #12]
 800a4b2:	2200      	movs	r2, #0
 800a4b4:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
          
          return HAL_TIMEOUT;
 800a4b8:	2303      	movs	r3, #3
 800a4ba:	e04b      	b.n	800a554 <UART_WaitOnFlagUntilTimeout+0x128>
  uint32_t tickstart = HAL_GetTick();
  
  /* Wait until flag is set */
  if(Status == RESET)
  {    
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
 800a4bc:	68fb      	ldr	r3, [r7, #12]
 800a4be:	681b      	ldr	r3, [r3, #0]
 800a4c0:	69da      	ldr	r2, [r3, #28]
 800a4c2:	68bb      	ldr	r3, [r7, #8]
 800a4c4:	401a      	ands	r2, r3
 800a4c6:	68bb      	ldr	r3, [r7, #8]
 800a4c8:	429a      	cmp	r2, r3
 800a4ca:	d1be      	bne.n	800a44a <UART_WaitOnFlagUntilTimeout+0x1e>
 800a4cc:	e041      	b.n	800a552 <UART_WaitOnFlagUntilTimeout+0x126>
      }
    }
  }
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
 800a4ce:	e038      	b.n	800a542 <UART_WaitOnFlagUntilTimeout+0x116>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800a4d0:	683b      	ldr	r3, [r7, #0]
 800a4d2:	f1b3 3fff 	cmp.w	r3, #4294967295
 800a4d6:	d034      	beq.n	800a542 <UART_WaitOnFlagUntilTimeout+0x116>
      {
        if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
 800a4d8:	683b      	ldr	r3, [r7, #0]
 800a4da:	2b00      	cmp	r3, #0
 800a4dc:	d007      	beq.n	800a4ee <UART_WaitOnFlagUntilTimeout+0xc2>
 800a4de:	f7f7 f871 	bl	80015c4 <HAL_GetTick>
 800a4e2:	4602      	mov	r2, r0
 800a4e4:	697b      	ldr	r3, [r7, #20]
 800a4e6:	1ad2      	subs	r2, r2, r3
 800a4e8:	683b      	ldr	r3, [r7, #0]
 800a4ea:	429a      	cmp	r2, r3
 800a4ec:	d329      	bcc.n	800a542 <UART_WaitOnFlagUntilTimeout+0x116>
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 800a4ee:	68fb      	ldr	r3, [r7, #12]
 800a4f0:	681b      	ldr	r3, [r3, #0]
 800a4f2:	68fa      	ldr	r2, [r7, #12]
 800a4f4:	6812      	ldr	r2, [r2, #0]
 800a4f6:	6812      	ldr	r2, [r2, #0]
 800a4f8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a4fc:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 800a4fe:	68fb      	ldr	r3, [r7, #12]
 800a500:	681b      	ldr	r3, [r3, #0]
 800a502:	68fa      	ldr	r2, [r7, #12]
 800a504:	6812      	ldr	r2, [r2, #0]
 800a506:	6812      	ldr	r2, [r2, #0]
 800a508:	f022 0220 	bic.w	r2, r2, #32
 800a50c:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 800a50e:	68fb      	ldr	r3, [r7, #12]
 800a510:	681b      	ldr	r3, [r3, #0]
 800a512:	68fa      	ldr	r2, [r7, #12]
 800a514:	6812      	ldr	r2, [r2, #0]
 800a516:	6812      	ldr	r2, [r2, #0]
 800a518:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800a51c:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 800a51e:	68fb      	ldr	r3, [r7, #12]
 800a520:	681b      	ldr	r3, [r3, #0]
 800a522:	68fa      	ldr	r2, [r7, #12]
 800a524:	6812      	ldr	r2, [r2, #0]
 800a526:	6892      	ldr	r2, [r2, #8]
 800a528:	f022 0201 	bic.w	r2, r2, #1
 800a52c:	609a      	str	r2, [r3, #8]
          
          huart->State= HAL_UART_STATE_READY;
 800a52e:	68fb      	ldr	r3, [r7, #12]
 800a530:	2201      	movs	r2, #1
 800a532:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
          
          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800a536:	68fb      	ldr	r3, [r7, #12]
 800a538:	2200      	movs	r2, #0
 800a53a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
          
          return HAL_TIMEOUT;
 800a53e:	2303      	movs	r3, #3
 800a540:	e008      	b.n	800a554 <UART_WaitOnFlagUntilTimeout+0x128>
      }
    }
  }
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
 800a542:	68fb      	ldr	r3, [r7, #12]
 800a544:	681b      	ldr	r3, [r3, #0]
 800a546:	69da      	ldr	r2, [r3, #28]
 800a548:	68bb      	ldr	r3, [r7, #8]
 800a54a:	401a      	ands	r2, r3
 800a54c:	68bb      	ldr	r3, [r7, #8]
 800a54e:	429a      	cmp	r2, r3
 800a550:	d0be      	beq.n	800a4d0 <UART_WaitOnFlagUntilTimeout+0xa4>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;      
 800a552:	2300      	movs	r3, #0
}
 800a554:	4618      	mov	r0, r3
 800a556:	3718      	adds	r7, #24
 800a558:	46bd      	mov	sp, r7
 800a55a:	bd80      	pop	{r7, pc}

0800a55c <UART_DMAReceiveCplt>:
  * @brief DMA UART receive process complete callback 
  * @param hdma: DMA handle
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
{
 800a55c:	b580      	push	{r7, lr}
 800a55e:	b084      	sub	sp, #16
 800a560:	af00      	add	r7, sp, #0
 800a562:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800a564:	687b      	ldr	r3, [r7, #4]
 800a566:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a568:	60fb      	str	r3, [r7, #12]
  
  /* DMA Normal mode */
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800a56a:	687b      	ldr	r3, [r7, #4]
 800a56c:	681b      	ldr	r3, [r3, #0]
 800a56e:	681b      	ldr	r3, [r3, #0]
 800a570:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800a574:	2b00      	cmp	r3, #0
 800a576:	d11a      	bne.n	800a5ae <UART_DMAReceiveCplt+0x52>
  { 
    huart->RxXferCount = 0;
 800a578:	68fb      	ldr	r3, [r7, #12]
 800a57a:	2200      	movs	r2, #0
 800a57c:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
    
    /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
    in the UART CR3 register */
    huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
 800a580:	68fb      	ldr	r3, [r7, #12]
 800a582:	681b      	ldr	r3, [r3, #0]
 800a584:	68fa      	ldr	r2, [r7, #12]
 800a586:	6812      	ldr	r2, [r2, #0]
 800a588:	6892      	ldr	r2, [r2, #8]
 800a58a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a58e:	609a      	str	r2, [r3, #8]
    
    /* Check if a transmit Process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 800a590:	68fb      	ldr	r3, [r7, #12]
 800a592:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800a596:	b2db      	uxtb	r3, r3
 800a598:	2b32      	cmp	r3, #50	; 0x32
 800a59a:	d104      	bne.n	800a5a6 <UART_DMAReceiveCplt+0x4a>
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
 800a59c:	68fb      	ldr	r3, [r7, #12]
 800a59e:	2212      	movs	r2, #18
 800a5a0:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
 800a5a4:	e003      	b.n	800a5ae <UART_DMAReceiveCplt+0x52>
    }
    else
    {
      huart->State = HAL_UART_STATE_READY;
 800a5a6:	68fb      	ldr	r3, [r7, #12]
 800a5a8:	2201      	movs	r2, #1
 800a5aa:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    }
  }
  HAL_UART_RxCpltCallback(huart);
 800a5ae:	68f8      	ldr	r0, [r7, #12]
 800a5b0:	f000 f832 	bl	800a618 <HAL_UART_RxCpltCallback>
}
 800a5b4:	3710      	adds	r7, #16
 800a5b6:	46bd      	mov	sp, r7
 800a5b8:	bd80      	pop	{r7, pc}
 800a5ba:	bf00      	nop

0800a5bc <UART_DMARxHalfCplt>:
  * @brief DMA UART receive process half complete callback 
  * @param hdma : DMA handle
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800a5bc:	b580      	push	{r7, lr}
 800a5be:	b084      	sub	sp, #16
 800a5c0:	af00      	add	r7, sp, #0
 800a5c2:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 800a5c4:	687b      	ldr	r3, [r7, #4]
 800a5c6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a5c8:	60fb      	str	r3, [r7, #12]

  HAL_UART_RxHalfCpltCallback(huart); 
 800a5ca:	68f8      	ldr	r0, [r7, #12]
 800a5cc:	f000 f82e 	bl	800a62c <HAL_UART_RxHalfCpltCallback>
}
 800a5d0:	3710      	adds	r7, #16
 800a5d2:	46bd      	mov	sp, r7
 800a5d4:	bd80      	pop	{r7, pc}
 800a5d6:	bf00      	nop

0800a5d8 <UART_DMAError>:
  * @brief DMA UART communication error callback 
  * @param hdma: DMA handle
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)   
{
 800a5d8:	b580      	push	{r7, lr}
 800a5da:	b084      	sub	sp, #16
 800a5dc:	af00      	add	r7, sp, #0
 800a5de:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800a5e0:	687b      	ldr	r3, [r7, #4]
 800a5e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a5e4:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0;
 800a5e6:	68fb      	ldr	r3, [r7, #12]
 800a5e8:	2200      	movs	r2, #0
 800a5ea:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
  huart->TxXferCount = 0;
 800a5ee:	68fb      	ldr	r3, [r7, #12]
 800a5f0:	2200      	movs	r2, #0
 800a5f2:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
  huart->State= HAL_UART_STATE_READY;
 800a5f6:	68fb      	ldr	r3, [r7, #12]
 800a5f8:	2201      	movs	r2, #1
 800a5fa:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 800a5fe:	68fb      	ldr	r3, [r7, #12]
 800a600:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a602:	f043 0210 	orr.w	r2, r3, #16
 800a606:	68fb      	ldr	r3, [r7, #12]
 800a608:	66da      	str	r2, [r3, #108]	; 0x6c
  HAL_UART_ErrorCallback(huart);
 800a60a:	68f8      	ldr	r0, [r7, #12]
 800a60c:	f000 f818 	bl	800a640 <HAL_UART_ErrorCallback>
}
 800a610:	3710      	adds	r7, #16
 800a612:	46bd      	mov	sp, r7
 800a614:	bd80      	pop	{r7, pc}
 800a616:	bf00      	nop

0800a618 <HAL_UART_RxCpltCallback>:
  * @brief Rx Transfer completed callbacks
  * @param huart: uart handle
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 800a618:	b480      	push	{r7}
 800a61a:	b083      	sub	sp, #12
 800a61c:	af00      	add	r7, sp, #0
 800a61e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_RxCpltCallback can be implemented in the user file
   */
}
 800a620:	370c      	adds	r7, #12
 800a622:	46bd      	mov	sp, r7
 800a624:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a628:	4770      	bx	lr
 800a62a:	bf00      	nop

0800a62c <HAL_UART_RxHalfCpltCallback>:
  * @brief  Rx Half Transfer completed callbacks.
  * @param  huart: UART handle
  * @retval None
  */
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 800a62c:	b480      	push	{r7}
 800a62e:	b083      	sub	sp, #12
 800a630:	af00      	add	r7, sp, #0
 800a632:	6078      	str	r0, [r7, #4]
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   */
}
 800a634:	370c      	adds	r7, #12
 800a636:	46bd      	mov	sp, r7
 800a638:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a63c:	4770      	bx	lr
 800a63e:	bf00      	nop

0800a640 <HAL_UART_ErrorCallback>:
  * @brief UART error callbacks
  * @param huart: uart handle
  * @retval None
  */
 __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 800a640:	b480      	push	{r7}
 800a642:	b083      	sub	sp, #12
 800a644:	af00      	add	r7, sp, #0
 800a646:	6078      	str	r0, [r7, #4]
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file
   */ 
}
 800a648:	370c      	adds	r7, #12
 800a64a:	46bd      	mov	sp, r7
 800a64c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a650:	4770      	bx	lr
 800a652:	bf00      	nop

0800a654 <UART_SetConfig>:
  * @brief Configure the UART peripheral 
  * @param huart: uart handle
  * @retval None
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800a654:	b590      	push	{r4, r7, lr}
 800a656:	b087      	sub	sp, #28
 800a658:	af00      	add	r7, sp, #0
 800a65a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg                     = 0x00000000;
 800a65c:	2300      	movs	r3, #0
 800a65e:	60fb      	str	r3, [r7, #12]
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 800a660:	2310      	movs	r3, #16
 800a662:	75fb      	strb	r3, [r7, #23]
  uint16_t brrtemp                    = 0x0000;
 800a664:	2300      	movs	r3, #0
 800a666:	817b      	strh	r3, [r7, #10]
  uint16_t usartdiv                   = 0x0000;
 800a668:	2300      	movs	r3, #0
 800a66a:	82bb      	strh	r3, [r7, #20]
  HAL_StatusTypeDef ret               = HAL_OK;  
 800a66c:	2300      	movs	r3, #0
 800a66e:	74fb      	strb	r3, [r7, #19]
   *  the UART Word Length, Parity, Mode and oversampling: 
   *  set the M bits according to huart->Init.WordLength value 
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800a670:	687b      	ldr	r3, [r7, #4]
 800a672:	689a      	ldr	r2, [r3, #8]
 800a674:	687b      	ldr	r3, [r7, #4]
 800a676:	691b      	ldr	r3, [r3, #16]
 800a678:	431a      	orrs	r2, r3
 800a67a:	687b      	ldr	r3, [r7, #4]
 800a67c:	695b      	ldr	r3, [r3, #20]
 800a67e:	431a      	orrs	r2, r3
 800a680:	687b      	ldr	r3, [r7, #4]
 800a682:	69db      	ldr	r3, [r3, #28]
 800a684:	4313      	orrs	r3, r2
 800a686:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800a688:	687b      	ldr	r3, [r7, #4]
 800a68a:	681a      	ldr	r2, [r3, #0]
 800a68c:	687b      	ldr	r3, [r7, #4]
 800a68e:	681b      	ldr	r3, [r3, #0]
 800a690:	6819      	ldr	r1, [r3, #0]
 800a692:	4bac      	ldr	r3, [pc, #688]	; (800a944 <UART_SetConfig+0x2f0>)
 800a694:	400b      	ands	r3, r1
 800a696:	68f9      	ldr	r1, [r7, #12]
 800a698:	430b      	orrs	r3, r1
 800a69a:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800a69c:	687b      	ldr	r3, [r7, #4]
 800a69e:	681b      	ldr	r3, [r3, #0]
 800a6a0:	687a      	ldr	r2, [r7, #4]
 800a6a2:	6812      	ldr	r2, [r2, #0]
 800a6a4:	6852      	ldr	r2, [r2, #4]
 800a6a6:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 800a6aa:	687a      	ldr	r2, [r7, #4]
 800a6ac:	68d2      	ldr	r2, [r2, #12]
 800a6ae:	430a      	orrs	r2, r1
 800a6b0:	605a      	str	r2, [r3, #4]
  /* Configure 
   * - UART HardWare Flow Control: set CTSE and RTSE bits according 
   *   to huart->Init.HwFlowCtl value 
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 800a6b2:	687b      	ldr	r3, [r7, #4]
 800a6b4:	699a      	ldr	r2, [r3, #24]
 800a6b6:	687b      	ldr	r3, [r7, #4]
 800a6b8:	6a1b      	ldr	r3, [r3, #32]
 800a6ba:	4313      	orrs	r3, r2
 800a6bc:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 800a6be:	687b      	ldr	r3, [r7, #4]
 800a6c0:	681b      	ldr	r3, [r3, #0]
 800a6c2:	687a      	ldr	r2, [r7, #4]
 800a6c4:	6812      	ldr	r2, [r2, #0]
 800a6c6:	6892      	ldr	r2, [r2, #8]
 800a6c8:	f422 6130 	bic.w	r1, r2, #2816	; 0xb00
 800a6cc:	68fa      	ldr	r2, [r7, #12]
 800a6ce:	430a      	orrs	r2, r1
 800a6d0:	609a      	str	r2, [r3, #8]
  
  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a6d2:	687b      	ldr	r3, [r7, #4]
 800a6d4:	681b      	ldr	r3, [r3, #0]
 800a6d6:	4a9c      	ldr	r2, [pc, #624]	; (800a948 <UART_SetConfig+0x2f4>)
 800a6d8:	4293      	cmp	r3, r2
 800a6da:	d11e      	bne.n	800a71a <UART_SetConfig+0xc6>
 800a6dc:	4b9b      	ldr	r3, [pc, #620]	; (800a94c <UART_SetConfig+0x2f8>)
 800a6de:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a6e2:	f003 0303 	and.w	r3, r3, #3
 800a6e6:	2b03      	cmp	r3, #3
 800a6e8:	d815      	bhi.n	800a716 <UART_SetConfig+0xc2>
 800a6ea:	a201      	add	r2, pc, #4	; (adr r2, 800a6f0 <UART_SetConfig+0x9c>)
 800a6ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a6f0:	0800a701 	.word	0x0800a701
 800a6f4:	0800a70d 	.word	0x0800a70d
 800a6f8:	0800a707 	.word	0x0800a707
 800a6fc:	0800a713 	.word	0x0800a713
 800a700:	2301      	movs	r3, #1
 800a702:	75fb      	strb	r3, [r7, #23]
 800a704:	e007      	b.n	800a716 <UART_SetConfig+0xc2>
 800a706:	2302      	movs	r3, #2
 800a708:	75fb      	strb	r3, [r7, #23]
 800a70a:	e004      	b.n	800a716 <UART_SetConfig+0xc2>
 800a70c:	2304      	movs	r3, #4
 800a70e:	75fb      	strb	r3, [r7, #23]
 800a710:	e001      	b.n	800a716 <UART_SetConfig+0xc2>
 800a712:	2308      	movs	r3, #8
 800a714:	75fb      	strb	r3, [r7, #23]
 800a716:	bf00      	nop
 800a718:	e12b      	b.n	800a972 <UART_SetConfig+0x31e>
 800a71a:	687b      	ldr	r3, [r7, #4]
 800a71c:	681b      	ldr	r3, [r3, #0]
 800a71e:	4a8c      	ldr	r2, [pc, #560]	; (800a950 <UART_SetConfig+0x2fc>)
 800a720:	4293      	cmp	r3, r2
 800a722:	d130      	bne.n	800a786 <UART_SetConfig+0x132>
 800a724:	4b89      	ldr	r3, [pc, #548]	; (800a94c <UART_SetConfig+0x2f8>)
 800a726:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a72a:	f003 030c 	and.w	r3, r3, #12
 800a72e:	2b0c      	cmp	r3, #12
 800a730:	d827      	bhi.n	800a782 <UART_SetConfig+0x12e>
 800a732:	a201      	add	r2, pc, #4	; (adr r2, 800a738 <UART_SetConfig+0xe4>)
 800a734:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a738:	0800a76d 	.word	0x0800a76d
 800a73c:	0800a783 	.word	0x0800a783
 800a740:	0800a783 	.word	0x0800a783
 800a744:	0800a783 	.word	0x0800a783
 800a748:	0800a779 	.word	0x0800a779
 800a74c:	0800a783 	.word	0x0800a783
 800a750:	0800a783 	.word	0x0800a783
 800a754:	0800a783 	.word	0x0800a783
 800a758:	0800a773 	.word	0x0800a773
 800a75c:	0800a783 	.word	0x0800a783
 800a760:	0800a783 	.word	0x0800a783
 800a764:	0800a783 	.word	0x0800a783
 800a768:	0800a77f 	.word	0x0800a77f
 800a76c:	2300      	movs	r3, #0
 800a76e:	75fb      	strb	r3, [r7, #23]
 800a770:	e007      	b.n	800a782 <UART_SetConfig+0x12e>
 800a772:	2302      	movs	r3, #2
 800a774:	75fb      	strb	r3, [r7, #23]
 800a776:	e004      	b.n	800a782 <UART_SetConfig+0x12e>
 800a778:	2304      	movs	r3, #4
 800a77a:	75fb      	strb	r3, [r7, #23]
 800a77c:	e001      	b.n	800a782 <UART_SetConfig+0x12e>
 800a77e:	2308      	movs	r3, #8
 800a780:	75fb      	strb	r3, [r7, #23]
 800a782:	bf00      	nop
 800a784:	e0f5      	b.n	800a972 <UART_SetConfig+0x31e>
 800a786:	687b      	ldr	r3, [r7, #4]
 800a788:	681b      	ldr	r3, [r3, #0]
 800a78a:	4a72      	ldr	r2, [pc, #456]	; (800a954 <UART_SetConfig+0x300>)
 800a78c:	4293      	cmp	r3, r2
 800a78e:	d11d      	bne.n	800a7cc <UART_SetConfig+0x178>
 800a790:	4b6e      	ldr	r3, [pc, #440]	; (800a94c <UART_SetConfig+0x2f8>)
 800a792:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a796:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800a79a:	2b10      	cmp	r3, #16
 800a79c:	d00f      	beq.n	800a7be <UART_SetConfig+0x16a>
 800a79e:	2b10      	cmp	r3, #16
 800a7a0:	d802      	bhi.n	800a7a8 <UART_SetConfig+0x154>
 800a7a2:	2b00      	cmp	r3, #0
 800a7a4:	d005      	beq.n	800a7b2 <UART_SetConfig+0x15e>
 800a7a6:	e00f      	b.n	800a7c8 <UART_SetConfig+0x174>
 800a7a8:	2b20      	cmp	r3, #32
 800a7aa:	d005      	beq.n	800a7b8 <UART_SetConfig+0x164>
 800a7ac:	2b30      	cmp	r3, #48	; 0x30
 800a7ae:	d009      	beq.n	800a7c4 <UART_SetConfig+0x170>
 800a7b0:	e00a      	b.n	800a7c8 <UART_SetConfig+0x174>
 800a7b2:	2300      	movs	r3, #0
 800a7b4:	75fb      	strb	r3, [r7, #23]
 800a7b6:	e007      	b.n	800a7c8 <UART_SetConfig+0x174>
 800a7b8:	2302      	movs	r3, #2
 800a7ba:	75fb      	strb	r3, [r7, #23]
 800a7bc:	e004      	b.n	800a7c8 <UART_SetConfig+0x174>
 800a7be:	2304      	movs	r3, #4
 800a7c0:	75fb      	strb	r3, [r7, #23]
 800a7c2:	e001      	b.n	800a7c8 <UART_SetConfig+0x174>
 800a7c4:	2308      	movs	r3, #8
 800a7c6:	75fb      	strb	r3, [r7, #23]
 800a7c8:	bf00      	nop
 800a7ca:	e0d2      	b.n	800a972 <UART_SetConfig+0x31e>
 800a7cc:	687b      	ldr	r3, [r7, #4]
 800a7ce:	681b      	ldr	r3, [r3, #0]
 800a7d0:	4a61      	ldr	r2, [pc, #388]	; (800a958 <UART_SetConfig+0x304>)
 800a7d2:	4293      	cmp	r3, r2
 800a7d4:	d11d      	bne.n	800a812 <UART_SetConfig+0x1be>
 800a7d6:	4b5d      	ldr	r3, [pc, #372]	; (800a94c <UART_SetConfig+0x2f8>)
 800a7d8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a7dc:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800a7e0:	2b40      	cmp	r3, #64	; 0x40
 800a7e2:	d00f      	beq.n	800a804 <UART_SetConfig+0x1b0>
 800a7e4:	2b40      	cmp	r3, #64	; 0x40
 800a7e6:	d802      	bhi.n	800a7ee <UART_SetConfig+0x19a>
 800a7e8:	2b00      	cmp	r3, #0
 800a7ea:	d005      	beq.n	800a7f8 <UART_SetConfig+0x1a4>
 800a7ec:	e00f      	b.n	800a80e <UART_SetConfig+0x1ba>
 800a7ee:	2b80      	cmp	r3, #128	; 0x80
 800a7f0:	d005      	beq.n	800a7fe <UART_SetConfig+0x1aa>
 800a7f2:	2bc0      	cmp	r3, #192	; 0xc0
 800a7f4:	d009      	beq.n	800a80a <UART_SetConfig+0x1b6>
 800a7f6:	e00a      	b.n	800a80e <UART_SetConfig+0x1ba>
 800a7f8:	2300      	movs	r3, #0
 800a7fa:	75fb      	strb	r3, [r7, #23]
 800a7fc:	e007      	b.n	800a80e <UART_SetConfig+0x1ba>
 800a7fe:	2302      	movs	r3, #2
 800a800:	75fb      	strb	r3, [r7, #23]
 800a802:	e004      	b.n	800a80e <UART_SetConfig+0x1ba>
 800a804:	2304      	movs	r3, #4
 800a806:	75fb      	strb	r3, [r7, #23]
 800a808:	e001      	b.n	800a80e <UART_SetConfig+0x1ba>
 800a80a:	2308      	movs	r3, #8
 800a80c:	75fb      	strb	r3, [r7, #23]
 800a80e:	bf00      	nop
 800a810:	e0af      	b.n	800a972 <UART_SetConfig+0x31e>
 800a812:	687b      	ldr	r3, [r7, #4]
 800a814:	681b      	ldr	r3, [r3, #0]
 800a816:	4a51      	ldr	r2, [pc, #324]	; (800a95c <UART_SetConfig+0x308>)
 800a818:	4293      	cmp	r3, r2
 800a81a:	d121      	bne.n	800a860 <UART_SetConfig+0x20c>
 800a81c:	4b4b      	ldr	r3, [pc, #300]	; (800a94c <UART_SetConfig+0x2f8>)
 800a81e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a822:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800a826:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a82a:	d012      	beq.n	800a852 <UART_SetConfig+0x1fe>
 800a82c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a830:	d802      	bhi.n	800a838 <UART_SetConfig+0x1e4>
 800a832:	2b00      	cmp	r3, #0
 800a834:	d007      	beq.n	800a846 <UART_SetConfig+0x1f2>
 800a836:	e011      	b.n	800a85c <UART_SetConfig+0x208>
 800a838:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a83c:	d006      	beq.n	800a84c <UART_SetConfig+0x1f8>
 800a83e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800a842:	d009      	beq.n	800a858 <UART_SetConfig+0x204>
 800a844:	e00a      	b.n	800a85c <UART_SetConfig+0x208>
 800a846:	2300      	movs	r3, #0
 800a848:	75fb      	strb	r3, [r7, #23]
 800a84a:	e007      	b.n	800a85c <UART_SetConfig+0x208>
 800a84c:	2302      	movs	r3, #2
 800a84e:	75fb      	strb	r3, [r7, #23]
 800a850:	e004      	b.n	800a85c <UART_SetConfig+0x208>
 800a852:	2304      	movs	r3, #4
 800a854:	75fb      	strb	r3, [r7, #23]
 800a856:	e001      	b.n	800a85c <UART_SetConfig+0x208>
 800a858:	2308      	movs	r3, #8
 800a85a:	75fb      	strb	r3, [r7, #23]
 800a85c:	bf00      	nop
 800a85e:	e088      	b.n	800a972 <UART_SetConfig+0x31e>
 800a860:	687b      	ldr	r3, [r7, #4]
 800a862:	681b      	ldr	r3, [r3, #0]
 800a864:	4a3e      	ldr	r2, [pc, #248]	; (800a960 <UART_SetConfig+0x30c>)
 800a866:	4293      	cmp	r3, r2
 800a868:	d121      	bne.n	800a8ae <UART_SetConfig+0x25a>
 800a86a:	4b38      	ldr	r3, [pc, #224]	; (800a94c <UART_SetConfig+0x2f8>)
 800a86c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a870:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800a874:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800a878:	d012      	beq.n	800a8a0 <UART_SetConfig+0x24c>
 800a87a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800a87e:	d802      	bhi.n	800a886 <UART_SetConfig+0x232>
 800a880:	2b00      	cmp	r3, #0
 800a882:	d007      	beq.n	800a894 <UART_SetConfig+0x240>
 800a884:	e011      	b.n	800a8aa <UART_SetConfig+0x256>
 800a886:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800a88a:	d006      	beq.n	800a89a <UART_SetConfig+0x246>
 800a88c:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800a890:	d009      	beq.n	800a8a6 <UART_SetConfig+0x252>
 800a892:	e00a      	b.n	800a8aa <UART_SetConfig+0x256>
 800a894:	2301      	movs	r3, #1
 800a896:	75fb      	strb	r3, [r7, #23]
 800a898:	e007      	b.n	800a8aa <UART_SetConfig+0x256>
 800a89a:	2302      	movs	r3, #2
 800a89c:	75fb      	strb	r3, [r7, #23]
 800a89e:	e004      	b.n	800a8aa <UART_SetConfig+0x256>
 800a8a0:	2304      	movs	r3, #4
 800a8a2:	75fb      	strb	r3, [r7, #23]
 800a8a4:	e001      	b.n	800a8aa <UART_SetConfig+0x256>
 800a8a6:	2308      	movs	r3, #8
 800a8a8:	75fb      	strb	r3, [r7, #23]
 800a8aa:	bf00      	nop
 800a8ac:	e061      	b.n	800a972 <UART_SetConfig+0x31e>
 800a8ae:	687b      	ldr	r3, [r7, #4]
 800a8b0:	681b      	ldr	r3, [r3, #0]
 800a8b2:	4a2c      	ldr	r2, [pc, #176]	; (800a964 <UART_SetConfig+0x310>)
 800a8b4:	4293      	cmp	r3, r2
 800a8b6:	d121      	bne.n	800a8fc <UART_SetConfig+0x2a8>
 800a8b8:	4b24      	ldr	r3, [pc, #144]	; (800a94c <UART_SetConfig+0x2f8>)
 800a8ba:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a8be:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800a8c2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a8c6:	d012      	beq.n	800a8ee <UART_SetConfig+0x29a>
 800a8c8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a8cc:	d802      	bhi.n	800a8d4 <UART_SetConfig+0x280>
 800a8ce:	2b00      	cmp	r3, #0
 800a8d0:	d007      	beq.n	800a8e2 <UART_SetConfig+0x28e>
 800a8d2:	e011      	b.n	800a8f8 <UART_SetConfig+0x2a4>
 800a8d4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a8d8:	d006      	beq.n	800a8e8 <UART_SetConfig+0x294>
 800a8da:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800a8de:	d009      	beq.n	800a8f4 <UART_SetConfig+0x2a0>
 800a8e0:	e00a      	b.n	800a8f8 <UART_SetConfig+0x2a4>
 800a8e2:	2300      	movs	r3, #0
 800a8e4:	75fb      	strb	r3, [r7, #23]
 800a8e6:	e007      	b.n	800a8f8 <UART_SetConfig+0x2a4>
 800a8e8:	2302      	movs	r3, #2
 800a8ea:	75fb      	strb	r3, [r7, #23]
 800a8ec:	e004      	b.n	800a8f8 <UART_SetConfig+0x2a4>
 800a8ee:	2304      	movs	r3, #4
 800a8f0:	75fb      	strb	r3, [r7, #23]
 800a8f2:	e001      	b.n	800a8f8 <UART_SetConfig+0x2a4>
 800a8f4:	2308      	movs	r3, #8
 800a8f6:	75fb      	strb	r3, [r7, #23]
 800a8f8:	bf00      	nop
 800a8fa:	e03a      	b.n	800a972 <UART_SetConfig+0x31e>
 800a8fc:	687b      	ldr	r3, [r7, #4]
 800a8fe:	681b      	ldr	r3, [r3, #0]
 800a900:	4a19      	ldr	r2, [pc, #100]	; (800a968 <UART_SetConfig+0x314>)
 800a902:	4293      	cmp	r3, r2
 800a904:	d135      	bne.n	800a972 <UART_SetConfig+0x31e>
 800a906:	4b11      	ldr	r3, [pc, #68]	; (800a94c <UART_SetConfig+0x2f8>)
 800a908:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a90c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800a910:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800a914:	d012      	beq.n	800a93c <UART_SetConfig+0x2e8>
 800a916:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800a91a:	d802      	bhi.n	800a922 <UART_SetConfig+0x2ce>
 800a91c:	2b00      	cmp	r3, #0
 800a91e:	d007      	beq.n	800a930 <UART_SetConfig+0x2dc>
 800a920:	e026      	b.n	800a970 <UART_SetConfig+0x31c>
 800a922:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800a926:	d006      	beq.n	800a936 <UART_SetConfig+0x2e2>
 800a928:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800a92c:	d01e      	beq.n	800a96c <UART_SetConfig+0x318>
 800a92e:	e01f      	b.n	800a970 <UART_SetConfig+0x31c>
 800a930:	2300      	movs	r3, #0
 800a932:	75fb      	strb	r3, [r7, #23]
 800a934:	e01c      	b.n	800a970 <UART_SetConfig+0x31c>
 800a936:	2302      	movs	r3, #2
 800a938:	75fb      	strb	r3, [r7, #23]
 800a93a:	e019      	b.n	800a970 <UART_SetConfig+0x31c>
 800a93c:	2304      	movs	r3, #4
 800a93e:	75fb      	strb	r3, [r7, #23]
 800a940:	e016      	b.n	800a970 <UART_SetConfig+0x31c>
 800a942:	bf00      	nop
 800a944:	efff69f3 	.word	0xefff69f3
 800a948:	40011000 	.word	0x40011000
 800a94c:	40023800 	.word	0x40023800
 800a950:	40004400 	.word	0x40004400
 800a954:	40004800 	.word	0x40004800
 800a958:	40004c00 	.word	0x40004c00
 800a95c:	40005000 	.word	0x40005000
 800a960:	40011400 	.word	0x40011400
 800a964:	40007800 	.word	0x40007800
 800a968:	40007c00 	.word	0x40007c00
 800a96c:	2308      	movs	r3, #8
 800a96e:	75fb      	strb	r3, [r7, #23]
 800a970:	bf00      	nop

  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a972:	687b      	ldr	r3, [r7, #4]
 800a974:	69db      	ldr	r3, [r3, #28]
 800a976:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800a97a:	d158      	bne.n	800aa2e <UART_SetConfig+0x3da>
  { 
    switch (clocksource)
 800a97c:	7dfb      	ldrb	r3, [r7, #23]
 800a97e:	2b08      	cmp	r3, #8
 800a980:	d841      	bhi.n	800aa06 <UART_SetConfig+0x3b2>
 800a982:	a201      	add	r2, pc, #4	; (adr r2, 800a988 <UART_SetConfig+0x334>)
 800a984:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a988:	0800a9ad 	.word	0x0800a9ad
 800a98c:	0800a9c1 	.word	0x0800a9c1
 800a990:	0800a9d5 	.word	0x0800a9d5
 800a994:	0800aa07 	.word	0x0800aa07
 800a998:	0800a9e3 	.word	0x0800a9e3
 800a99c:	0800aa07 	.word	0x0800aa07
 800a9a0:	0800aa07 	.word	0x0800aa07
 800a9a4:	0800aa07 	.word	0x0800aa07
 800a9a8:	0800a9f7 	.word	0x0800a9f7
    {
    case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800a9ac:	f7fe fb14 	bl	8008fd8 <HAL_RCC_GetPCLK1Freq>
 800a9b0:	4603      	mov	r3, r0
 800a9b2:	005a      	lsls	r2, r3, #1
 800a9b4:	687b      	ldr	r3, [r7, #4]
 800a9b6:	685b      	ldr	r3, [r3, #4]
 800a9b8:	fbb2 f3f3 	udiv	r3, r2, r3
 800a9bc:	82bb      	strh	r3, [r7, #20]
      break;
 800a9be:	e025      	b.n	800aa0c <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800a9c0:	f7fe fb2c 	bl	800901c <HAL_RCC_GetPCLK2Freq>
 800a9c4:	4603      	mov	r3, r0
 800a9c6:	005a      	lsls	r2, r3, #1
 800a9c8:	687b      	ldr	r3, [r7, #4]
 800a9ca:	685b      	ldr	r3, [r3, #4]
 800a9cc:	fbb2 f3f3 	udiv	r3, r2, r3
 800a9d0:	82bb      	strh	r3, [r7, #20]
      break;
 800a9d2:	e01b      	b.n	800aa0c <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_HSI:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate)); 
 800a9d4:	687b      	ldr	r3, [r7, #4]
 800a9d6:	685b      	ldr	r3, [r3, #4]
 800a9d8:	4a42      	ldr	r2, [pc, #264]	; (800aae4 <UART_SetConfig+0x490>)
 800a9da:	fbb2 f3f3 	udiv	r3, r2, r3
 800a9de:	82bb      	strh	r3, [r7, #20]
      break;
 800a9e0:	e014      	b.n	800aa0c <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800a9e2:	f7fe fa53 	bl	8008e8c <HAL_RCC_GetSysClockFreq>
 800a9e6:	4603      	mov	r3, r0
 800a9e8:	005a      	lsls	r2, r3, #1
 800a9ea:	687b      	ldr	r3, [r7, #4]
 800a9ec:	685b      	ldr	r3, [r3, #4]
 800a9ee:	fbb2 f3f3 	udiv	r3, r2, r3
 800a9f2:	82bb      	strh	r3, [r7, #20]
      break;
 800a9f4:	e00a      	b.n	800aa0c <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate)); 
 800a9f6:	687b      	ldr	r3, [r7, #4]
 800a9f8:	685b      	ldr	r3, [r3, #4]
 800a9fa:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800a9fe:	fbb2 f3f3 	udiv	r3, r2, r3
 800aa02:	82bb      	strh	r3, [r7, #20]
      break;
 800aa04:	e002      	b.n	800aa0c <UART_SetConfig+0x3b8>
      case UART_CLOCKSOURCE_UNDEFINED:                
    default:
        ret = HAL_ERROR; 
 800aa06:	2301      	movs	r3, #1
 800aa08:	74fb      	strb	r3, [r7, #19]
      break;
 800aa0a:	bf00      	nop
    }
    
    brrtemp = usartdiv & 0xFFF0;
 800aa0c:	8abb      	ldrh	r3, [r7, #20]
 800aa0e:	f023 030f 	bic.w	r3, r3, #15
 800aa12:	817b      	strh	r3, [r7, #10]
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 800aa14:	8abb      	ldrh	r3, [r7, #20]
 800aa16:	f003 030f 	and.w	r3, r3, #15
 800aa1a:	105b      	asrs	r3, r3, #1
 800aa1c:	b29a      	uxth	r2, r3
 800aa1e:	897b      	ldrh	r3, [r7, #10]
 800aa20:	4313      	orrs	r3, r2
 800aa22:	817b      	strh	r3, [r7, #10]
    huart->Instance->BRR = brrtemp;
 800aa24:	687b      	ldr	r3, [r7, #4]
 800aa26:	681b      	ldr	r3, [r3, #0]
 800aa28:	897a      	ldrh	r2, [r7, #10]
 800aa2a:	60da      	str	r2, [r3, #12]
 800aa2c:	e054      	b.n	800aad8 <UART_SetConfig+0x484>
  }
  else
  {
    switch (clocksource)
 800aa2e:	7dfb      	ldrb	r3, [r7, #23]
 800aa30:	2b08      	cmp	r3, #8
 800aa32:	d84e      	bhi.n	800aad2 <UART_SetConfig+0x47e>
 800aa34:	a201      	add	r2, pc, #4	; (adr r2, 800aa3c <UART_SetConfig+0x3e8>)
 800aa36:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800aa3a:	bf00      	nop
 800aa3c:	0800aa61 	.word	0x0800aa61
 800aa40:	0800aa79 	.word	0x0800aa79
 800aa44:	0800aa91 	.word	0x0800aa91
 800aa48:	0800aad3 	.word	0x0800aad3
 800aa4c:	0800aaa5 	.word	0x0800aaa5
 800aa50:	0800aad3 	.word	0x0800aad3
 800aa54:	0800aad3 	.word	0x0800aad3
 800aa58:	0800aad3 	.word	0x0800aad3
 800aa5c:	0800aabd 	.word	0x0800aabd
    {
    case UART_CLOCKSOURCE_PCLK1: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800aa60:	687b      	ldr	r3, [r7, #4]
 800aa62:	681c      	ldr	r4, [r3, #0]
 800aa64:	f7fe fab8 	bl	8008fd8 <HAL_RCC_GetPCLK1Freq>
 800aa68:	4602      	mov	r2, r0
 800aa6a:	687b      	ldr	r3, [r7, #4]
 800aa6c:	685b      	ldr	r3, [r3, #4]
 800aa6e:	fbb2 f3f3 	udiv	r3, r2, r3
 800aa72:	b29b      	uxth	r3, r3
 800aa74:	60e3      	str	r3, [r4, #12]
      break;
 800aa76:	e02f      	b.n	800aad8 <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_PCLK2: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800aa78:	687b      	ldr	r3, [r7, #4]
 800aa7a:	681c      	ldr	r4, [r3, #0]
 800aa7c:	f7fe face 	bl	800901c <HAL_RCC_GetPCLK2Freq>
 800aa80:	4602      	mov	r2, r0
 800aa82:	687b      	ldr	r3, [r7, #4]
 800aa84:	685b      	ldr	r3, [r3, #4]
 800aa86:	fbb2 f3f3 	udiv	r3, r2, r3
 800aa8a:	b29b      	uxth	r3, r3
 800aa8c:	60e3      	str	r3, [r4, #12]
      break;
 800aa8e:	e023      	b.n	800aad8 <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_HSI: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate)); 
 800aa90:	687b      	ldr	r3, [r7, #4]
 800aa92:	681b      	ldr	r3, [r3, #0]
 800aa94:	687a      	ldr	r2, [r7, #4]
 800aa96:	6852      	ldr	r2, [r2, #4]
 800aa98:	4913      	ldr	r1, [pc, #76]	; (800aae8 <UART_SetConfig+0x494>)
 800aa9a:	fbb1 f2f2 	udiv	r2, r1, r2
 800aa9e:	b292      	uxth	r2, r2
 800aaa0:	60da      	str	r2, [r3, #12]
      break; 
 800aaa2:	e019      	b.n	800aad8 <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_SYSCLK:  
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800aaa4:	687b      	ldr	r3, [r7, #4]
 800aaa6:	681c      	ldr	r4, [r3, #0]
 800aaa8:	f7fe f9f0 	bl	8008e8c <HAL_RCC_GetSysClockFreq>
 800aaac:	4602      	mov	r2, r0
 800aaae:	687b      	ldr	r3, [r7, #4]
 800aab0:	685b      	ldr	r3, [r3, #4]
 800aab2:	fbb2 f3f3 	udiv	r3, r2, r3
 800aab6:	b29b      	uxth	r3, r3
 800aab8:	60e3      	str	r3, [r4, #12]
      break;  
 800aaba:	e00d      	b.n	800aad8 <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate)); 
 800aabc:	687b      	ldr	r3, [r7, #4]
 800aabe:	681b      	ldr	r3, [r3, #0]
 800aac0:	687a      	ldr	r2, [r7, #4]
 800aac2:	6852      	ldr	r2, [r2, #4]
 800aac4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800aac8:	fbb1 f2f2 	udiv	r2, r1, r2
 800aacc:	b292      	uxth	r2, r2
 800aace:	60da      	str	r2, [r3, #12]
      break;
 800aad0:	e002      	b.n	800aad8 <UART_SetConfig+0x484>
      case UART_CLOCKSOURCE_UNDEFINED:                
    default:
        ret = HAL_ERROR; 
 800aad2:	2301      	movs	r3, #1
 800aad4:	74fb      	strb	r3, [r7, #19]
      break;
 800aad6:	bf00      	nop
    }
  }

  return ret;   
 800aad8:	7cfb      	ldrb	r3, [r7, #19]

}
 800aada:	4618      	mov	r0, r3
 800aadc:	371c      	adds	r7, #28
 800aade:	46bd      	mov	sp, r7
 800aae0:	bd90      	pop	{r4, r7, pc}
 800aae2:	bf00      	nop
 800aae4:	01e84800 	.word	0x01e84800
 800aae8:	00f42400 	.word	0x00f42400

0800aaec <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features 
  * @param huart: uart handle  
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800aaec:	b480      	push	{r7}
 800aaee:	b083      	sub	sp, #12
 800aaf0:	af00      	add	r7, sp, #0
 800aaf2:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */ 
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
  
  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800aaf4:	687b      	ldr	r3, [r7, #4]
 800aaf6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aaf8:	f003 0301 	and.w	r3, r3, #1
 800aafc:	2b00      	cmp	r3, #0
 800aafe:	d00a      	beq.n	800ab16 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800ab00:	687b      	ldr	r3, [r7, #4]
 800ab02:	681b      	ldr	r3, [r3, #0]
 800ab04:	687a      	ldr	r2, [r7, #4]
 800ab06:	6812      	ldr	r2, [r2, #0]
 800ab08:	6852      	ldr	r2, [r2, #4]
 800ab0a:	f422 3100 	bic.w	r1, r2, #131072	; 0x20000
 800ab0e:	687a      	ldr	r2, [r7, #4]
 800ab10:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800ab12:	430a      	orrs	r2, r1
 800ab14:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800ab16:	687b      	ldr	r3, [r7, #4]
 800ab18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ab1a:	f003 0302 	and.w	r3, r3, #2
 800ab1e:	2b00      	cmp	r3, #0
 800ab20:	d00a      	beq.n	800ab38 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800ab22:	687b      	ldr	r3, [r7, #4]
 800ab24:	681b      	ldr	r3, [r3, #0]
 800ab26:	687a      	ldr	r2, [r7, #4]
 800ab28:	6812      	ldr	r2, [r2, #0]
 800ab2a:	6852      	ldr	r2, [r2, #4]
 800ab2c:	f422 3180 	bic.w	r1, r2, #65536	; 0x10000
 800ab30:	687a      	ldr	r2, [r7, #4]
 800ab32:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800ab34:	430a      	orrs	r2, r1
 800ab36:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800ab38:	687b      	ldr	r3, [r7, #4]
 800ab3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ab3c:	f003 0304 	and.w	r3, r3, #4
 800ab40:	2b00      	cmp	r3, #0
 800ab42:	d00a      	beq.n	800ab5a <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800ab44:	687b      	ldr	r3, [r7, #4]
 800ab46:	681b      	ldr	r3, [r3, #0]
 800ab48:	687a      	ldr	r2, [r7, #4]
 800ab4a:	6812      	ldr	r2, [r2, #0]
 800ab4c:	6852      	ldr	r2, [r2, #4]
 800ab4e:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
 800ab52:	687a      	ldr	r2, [r7, #4]
 800ab54:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800ab56:	430a      	orrs	r2, r1
 800ab58:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800ab5a:	687b      	ldr	r3, [r7, #4]
 800ab5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ab5e:	f003 0308 	and.w	r3, r3, #8
 800ab62:	2b00      	cmp	r3, #0
 800ab64:	d00a      	beq.n	800ab7c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800ab66:	687b      	ldr	r3, [r7, #4]
 800ab68:	681b      	ldr	r3, [r3, #0]
 800ab6a:	687a      	ldr	r2, [r7, #4]
 800ab6c:	6812      	ldr	r2, [r2, #0]
 800ab6e:	6852      	ldr	r2, [r2, #4]
 800ab70:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
 800ab74:	687a      	ldr	r2, [r7, #4]
 800ab76:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800ab78:	430a      	orrs	r2, r1
 800ab7a:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800ab7c:	687b      	ldr	r3, [r7, #4]
 800ab7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ab80:	f003 0310 	and.w	r3, r3, #16
 800ab84:	2b00      	cmp	r3, #0
 800ab86:	d00a      	beq.n	800ab9e <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));  
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800ab88:	687b      	ldr	r3, [r7, #4]
 800ab8a:	681b      	ldr	r3, [r3, #0]
 800ab8c:	687a      	ldr	r2, [r7, #4]
 800ab8e:	6812      	ldr	r2, [r2, #0]
 800ab90:	6892      	ldr	r2, [r2, #8]
 800ab92:	f422 5180 	bic.w	r1, r2, #4096	; 0x1000
 800ab96:	687a      	ldr	r2, [r7, #4]
 800ab98:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800ab9a:	430a      	orrs	r2, r1
 800ab9c:	609a      	str	r2, [r3, #8]
  }
  
  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800ab9e:	687b      	ldr	r3, [r7, #4]
 800aba0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aba2:	f003 0320 	and.w	r3, r3, #32
 800aba6:	2b00      	cmp	r3, #0
 800aba8:	d00a      	beq.n	800abc0 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));   
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800abaa:	687b      	ldr	r3, [r7, #4]
 800abac:	681b      	ldr	r3, [r3, #0]
 800abae:	687a      	ldr	r2, [r7, #4]
 800abb0:	6812      	ldr	r2, [r2, #0]
 800abb2:	6892      	ldr	r2, [r2, #8]
 800abb4:	f422 5100 	bic.w	r1, r2, #8192	; 0x2000
 800abb8:	687a      	ldr	r2, [r7, #4]
 800abba:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 800abbc:	430a      	orrs	r2, r1
 800abbe:	609a      	str	r2, [r3, #8]
  }
  
  /* if required, configure auto Baud rate detection scheme */              
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800abc0:	687b      	ldr	r3, [r7, #4]
 800abc2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800abc4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800abc8:	2b00      	cmp	r3, #0
 800abca:	d01a      	beq.n	800ac02 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800abcc:	687b      	ldr	r3, [r7, #4]
 800abce:	681b      	ldr	r3, [r3, #0]
 800abd0:	687a      	ldr	r2, [r7, #4]
 800abd2:	6812      	ldr	r2, [r2, #0]
 800abd4:	6852      	ldr	r2, [r2, #4]
 800abd6:	f422 1180 	bic.w	r1, r2, #1048576	; 0x100000
 800abda:	687a      	ldr	r2, [r7, #4]
 800abdc:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800abde:	430a      	orrs	r2, r1
 800abe0:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800abe2:	687b      	ldr	r3, [r7, #4]
 800abe4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800abe6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800abea:	d10a      	bne.n	800ac02 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800abec:	687b      	ldr	r3, [r7, #4]
 800abee:	681b      	ldr	r3, [r3, #0]
 800abf0:	687a      	ldr	r2, [r7, #4]
 800abf2:	6812      	ldr	r2, [r2, #0]
 800abf4:	6852      	ldr	r2, [r2, #4]
 800abf6:	f422 01c0 	bic.w	r1, r2, #6291456	; 0x600000
 800abfa:	687a      	ldr	r2, [r7, #4]
 800abfc:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800abfe:	430a      	orrs	r2, r1
 800ac00:	605a      	str	r2, [r3, #4]
    }
  }
  
  /* if required, configure MSB first on communication line */  
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800ac02:	687b      	ldr	r3, [r7, #4]
 800ac04:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ac06:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ac0a:	2b00      	cmp	r3, #0
 800ac0c:	d00a      	beq.n	800ac24 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));   
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800ac0e:	687b      	ldr	r3, [r7, #4]
 800ac10:	681b      	ldr	r3, [r3, #0]
 800ac12:	687a      	ldr	r2, [r7, #4]
 800ac14:	6812      	ldr	r2, [r2, #0]
 800ac16:	6852      	ldr	r2, [r2, #4]
 800ac18:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
 800ac1c:	687a      	ldr	r2, [r7, #4]
 800ac1e:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800ac20:	430a      	orrs	r2, r1
 800ac22:	605a      	str	r2, [r3, #4]
  }
}
 800ac24:	370c      	adds	r7, #12
 800ac26:	46bd      	mov	sp, r7
 800ac28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ac2c:	4770      	bx	lr
 800ac2e:	bf00      	nop

0800ac30 <UART_CheckIdleState>:
  * @brief Check the UART Idle State
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800ac30:	b580      	push	{r7, lr}
 800ac32:	b082      	sub	sp, #8
 800ac34:	af00      	add	r7, sp, #0
 800ac36:	6078      	str	r0, [r7, #4]
  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ac38:	687b      	ldr	r3, [r7, #4]
 800ac3a:	2200      	movs	r2, #0
 800ac3c:	66da      	str	r2, [r3, #108]	; 0x6c
  
  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800ac3e:	687b      	ldr	r3, [r7, #4]
 800ac40:	681b      	ldr	r3, [r3, #0]
 800ac42:	681b      	ldr	r3, [r3, #0]
 800ac44:	f003 0308 	and.w	r3, r3, #8
 800ac48:	2b00      	cmp	r3, #0
 800ac4a:	d00c      	beq.n	800ac66 <UART_CheckIdleState+0x36>
  {
    /* Wait until TEACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
 800ac4c:	6878      	ldr	r0, [r7, #4]
 800ac4e:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800ac52:	2200      	movs	r2, #0
 800ac54:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800ac58:	f7ff fbe8 	bl	800a42c <UART_WaitOnFlagUntilTimeout>
 800ac5c:	4603      	mov	r3, r0
 800ac5e:	2b00      	cmp	r3, #0
 800ac60:	d001      	beq.n	800ac66 <UART_CheckIdleState+0x36>
    {
      /* Timeout Occurred */
      return HAL_TIMEOUT;
 800ac62:	2303      	movs	r3, #3
 800ac64:	e01c      	b.n	800aca0 <UART_CheckIdleState+0x70>
    }
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800ac66:	687b      	ldr	r3, [r7, #4]
 800ac68:	681b      	ldr	r3, [r3, #0]
 800ac6a:	681b      	ldr	r3, [r3, #0]
 800ac6c:	f003 0304 	and.w	r3, r3, #4
 800ac70:	2b00      	cmp	r3, #0
 800ac72:	d00c      	beq.n	800ac8e <UART_CheckIdleState+0x5e>
  {
    /* Wait until REACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET,  HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
 800ac74:	6878      	ldr	r0, [r7, #4]
 800ac76:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800ac7a:	2200      	movs	r2, #0
 800ac7c:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800ac80:	f7ff fbd4 	bl	800a42c <UART_WaitOnFlagUntilTimeout>
 800ac84:	4603      	mov	r3, r0
 800ac86:	2b00      	cmp	r3, #0
 800ac88:	d001      	beq.n	800ac8e <UART_CheckIdleState+0x5e>
    { 
      /* Timeout Occurred */
      return HAL_TIMEOUT;
 800ac8a:	2303      	movs	r3, #3
 800ac8c:	e008      	b.n	800aca0 <UART_CheckIdleState+0x70>
    }
  }
  
  /* Initialize the UART State */
  huart->State= HAL_UART_STATE_READY;
 800ac8e:	687b      	ldr	r3, [r7, #4]
 800ac90:	2201      	movs	r2, #1
 800ac92:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    
  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800ac96:	687b      	ldr	r3, [r7, #4]
 800ac98:	2200      	movs	r2, #0
 800ac9a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  
  return HAL_OK;
 800ac9e:	2300      	movs	r3, #0
}
 800aca0:	4618      	mov	r0, r3
 800aca2:	3708      	adds	r7, #8
 800aca4:	46bd      	mov	sp, r7
 800aca6:	bd80      	pop	{r7, pc}

0800aca8 <FMC_SDRAM_Init>:
  * @param  Device: Pointer to SDRAM device instance
  * @param  Init: Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 800aca8:	b480      	push	{r7}
 800acaa:	b085      	sub	sp, #20
 800acac:	af00      	add	r7, sp, #0
 800acae:	6078      	str	r0, [r7, #4]
 800acb0:	6039      	str	r1, [r7, #0]
  uint32_t tmpr1 = 0;
 800acb2:	2300      	movs	r3, #0
 800acb4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpr2 = 0;
 800acb6:	2300      	movs	r3, #0
 800acb8:	60bb      	str	r3, [r7, #8]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 800acba:	683b      	ldr	r3, [r7, #0]
 800acbc:	681b      	ldr	r3, [r3, #0]
 800acbe:	2b01      	cmp	r3, #1
 800acc0:	d027      	beq.n	800ad12 <FMC_SDRAM_Init+0x6a>
  { 
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 800acc2:	687b      	ldr	r3, [r7, #4]
 800acc4:	681b      	ldr	r3, [r3, #0]
 800acc6:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800acc8:	68fa      	ldr	r2, [r7, #12]
 800acca:	4b2f      	ldr	r3, [pc, #188]	; (800ad88 <FMC_SDRAM_Init+0xe0>)
 800accc:	4013      	ands	r3, r2
 800acce:	60fb      	str	r3, [r7, #12]
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800acd0:	683b      	ldr	r3, [r7, #0]
 800acd2:	685a      	ldr	r2, [r3, #4]
                        Init->RowBitsNumber      |\
 800acd4:	683b      	ldr	r3, [r7, #0]
 800acd6:	689b      	ldr	r3, [r3, #8]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800acd8:	431a      	orrs	r2, r3
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
 800acda:	683b      	ldr	r3, [r7, #0]
 800acdc:	68db      	ldr	r3, [r3, #12]
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
 800acde:	431a      	orrs	r2, r3
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
 800ace0:	683b      	ldr	r3, [r7, #0]
 800ace2:	691b      	ldr	r3, [r3, #16]
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
 800ace4:	431a      	orrs	r2, r3
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
 800ace6:	683b      	ldr	r3, [r7, #0]
 800ace8:	695b      	ldr	r3, [r3, #20]
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
 800acea:	431a      	orrs	r2, r3
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
 800acec:	683b      	ldr	r3, [r7, #0]
 800acee:	699b      	ldr	r3, [r3, #24]

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
 800acf0:	431a      	orrs	r2, r3
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
 800acf2:	683b      	ldr	r3, [r7, #0]
 800acf4:	69db      	ldr	r3, [r3, #28]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
 800acf6:	431a      	orrs	r2, r3
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
 800acf8:	683b      	ldr	r3, [r7, #0]
 800acfa:	6a1b      	ldr	r3, [r3, #32]
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
 800acfc:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
 800acfe:	683b      	ldr	r3, [r7, #0]
 800ad00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800ad02:	4313      	orrs	r3, r2
 800ad04:	68fa      	ldr	r2, [r7, #12]
 800ad06:	4313      	orrs	r3, r2
 800ad08:	60fb      	str	r3, [r7, #12]
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 800ad0a:	687b      	ldr	r3, [r7, #4]
 800ad0c:	68fa      	ldr	r2, [r7, #12]
 800ad0e:	601a      	str	r2, [r3, #0]
 800ad10:	e032      	b.n	800ad78 <FMC_SDRAM_Init+0xd0>
  }
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 800ad12:	687b      	ldr	r3, [r7, #4]
 800ad14:	681b      	ldr	r3, [r3, #0]
 800ad16:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800ad18:	68fa      	ldr	r2, [r7, #12]
 800ad1a:	4b1b      	ldr	r3, [pc, #108]	; (800ad88 <FMC_SDRAM_Init+0xe0>)
 800ad1c:	4013      	ands	r3, r2
 800ad1e:	60fb      	str	r3, [r7, #12]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800ad20:	683b      	ldr	r3, [r7, #0]
 800ad22:	69da      	ldr	r2, [r3, #28]
                        Init->ReadBurst          |\
 800ad24:	683b      	ldr	r3, [r7, #0]
 800ad26:	6a1b      	ldr	r3, [r3, #32]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800ad28:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);  
 800ad2a:	683b      	ldr	r3, [r7, #0]
 800ad2c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800ad2e:	4313      	orrs	r3, r2
 800ad30:	68fa      	ldr	r2, [r7, #12]
 800ad32:	4313      	orrs	r3, r2
 800ad34:	60fb      	str	r3, [r7, #12]
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);  
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 800ad36:	687b      	ldr	r3, [r7, #4]
 800ad38:	685b      	ldr	r3, [r3, #4]
 800ad3a:	60bb      	str	r3, [r7, #8]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800ad3c:	68ba      	ldr	r2, [r7, #8]
 800ad3e:	4b12      	ldr	r3, [pc, #72]	; (800ad88 <FMC_SDRAM_Init+0xe0>)
 800ad40:	4013      	ands	r3, r2
 800ad42:	60bb      	str	r3, [r7, #8]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800ad44:	683b      	ldr	r3, [r7, #0]
 800ad46:	685a      	ldr	r2, [r3, #4]
                       Init->RowBitsNumber      |\
 800ad48:	683b      	ldr	r3, [r7, #0]
 800ad4a:	689b      	ldr	r3, [r3, #8]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800ad4c:	431a      	orrs	r2, r3
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
 800ad4e:	683b      	ldr	r3, [r7, #0]
 800ad50:	68db      	ldr	r3, [r3, #12]
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
 800ad52:	431a      	orrs	r2, r3
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
 800ad54:	683b      	ldr	r3, [r7, #0]
 800ad56:	691b      	ldr	r3, [r3, #16]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
 800ad58:	431a      	orrs	r2, r3
                       Init->InternalBankNumber |\
                       Init->CASLatency         |\
 800ad5a:	683b      	ldr	r3, [r7, #0]
 800ad5c:	695b      	ldr	r3, [r3, #20]
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
 800ad5e:	431a      	orrs	r2, r3
                       Init->CASLatency         |\
                       Init->WriteProtection);
 800ad60:	683b      	ldr	r3, [r7, #0]
 800ad62:	699b      	ldr	r3, [r3, #24]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800ad64:	4313      	orrs	r3, r2
 800ad66:	68ba      	ldr	r2, [r7, #8]
 800ad68:	4313      	orrs	r3, r2
 800ad6a:	60bb      	str	r3, [r7, #8]
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
                       Init->CASLatency         |\
                       Init->WriteProtection);

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 800ad6c:	687b      	ldr	r3, [r7, #4]
 800ad6e:	68fa      	ldr	r2, [r7, #12]
 800ad70:	601a      	str	r2, [r3, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 800ad72:	687b      	ldr	r3, [r7, #4]
 800ad74:	68ba      	ldr	r2, [r7, #8]
 800ad76:	605a      	str	r2, [r3, #4]
  }  
  
  return HAL_OK;
 800ad78:	2300      	movs	r3, #0
}
 800ad7a:	4618      	mov	r0, r3
 800ad7c:	3714      	adds	r7, #20
 800ad7e:	46bd      	mov	sp, r7
 800ad80:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ad84:	4770      	bx	lr
 800ad86:	bf00      	nop
 800ad88:	ffff8000 	.word	0xffff8000

0800ad8c <FMC_SDRAM_Timing_Init>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Bank: SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800ad8c:	b480      	push	{r7}
 800ad8e:	b087      	sub	sp, #28
 800ad90:	af00      	add	r7, sp, #0
 800ad92:	60f8      	str	r0, [r7, #12]
 800ad94:	60b9      	str	r1, [r7, #8]
 800ad96:	607a      	str	r2, [r7, #4]
  uint32_t tmpr1 = 0;
 800ad98:	2300      	movs	r3, #0
 800ad9a:	617b      	str	r3, [r7, #20]
  uint32_t tmpr2 = 0;
 800ad9c:	2300      	movs	r3, #0
 800ad9e:	613b      	str	r3, [r7, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 800ada0:	687b      	ldr	r3, [r7, #4]
 800ada2:	2b01      	cmp	r3, #1
 800ada4:	d02e      	beq.n	800ae04 <FMC_SDRAM_Timing_Init+0x78>
  { 
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 800ada6:	68fb      	ldr	r3, [r7, #12]
 800ada8:	689b      	ldr	r3, [r3, #8]
 800adaa:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800adac:	697b      	ldr	r3, [r7, #20]
 800adae:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800adb2:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800adb4:	68bb      	ldr	r3, [r7, #8]
 800adb6:	681b      	ldr	r3, [r3, #0]
 800adb8:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800adba:	68bb      	ldr	r3, [r7, #8]
 800adbc:	685b      	ldr	r3, [r3, #4]
 800adbe:	3b01      	subs	r3, #1
 800adc0:	011b      	lsls	r3, r3, #4
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800adc2:	431a      	orrs	r2, r3
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800adc4:	68bb      	ldr	r3, [r7, #8]
 800adc6:	689b      	ldr	r3, [r3, #8]
 800adc8:	3b01      	subs	r3, #1
 800adca:	021b      	lsls	r3, r3, #8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800adcc:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 800adce:	68bb      	ldr	r3, [r7, #8]
 800add0:	68db      	ldr	r3, [r3, #12]
 800add2:	3b01      	subs	r3, #1
 800add4:	031b      	lsls	r3, r3, #12
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800add6:	431a      	orrs	r2, r3
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 800add8:	68bb      	ldr	r3, [r7, #8]
 800adda:	691b      	ldr	r3, [r3, #16]
 800addc:	3b01      	subs	r3, #1
 800adde:	041b      	lsls	r3, r3, #16
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 800ade0:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
 800ade2:	68bb      	ldr	r3, [r7, #8]
 800ade4:	695b      	ldr	r3, [r3, #20]
 800ade6:	3b01      	subs	r3, #1
 800ade8:	051b      	lsls	r3, r3, #20
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 800adea:	431a      	orrs	r2, r3
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
 800adec:	68bb      	ldr	r3, [r7, #8]
 800adee:	699b      	ldr	r3, [r3, #24]
 800adf0:	3b01      	subs	r3, #1
 800adf2:	061b      	lsls	r3, r3, #24
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800adf4:	4313      	orrs	r3, r2
 800adf6:	697a      	ldr	r2, [r7, #20]
 800adf8:	4313      	orrs	r3, r2
 800adfa:	617b      	str	r3, [r7, #20]
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 800adfc:	68fb      	ldr	r3, [r7, #12]
 800adfe:	697a      	ldr	r2, [r7, #20]
 800ae00:	609a      	str	r2, [r3, #8]
 800ae02:	e039      	b.n	800ae78 <FMC_SDRAM_Timing_Init+0xec>
  }
  else /* FMC_Bank2_SDRAM */
  {  
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK2];
 800ae04:	68fb      	ldr	r3, [r7, #12]
 800ae06:	68db      	ldr	r3, [r3, #12]
 800ae08:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800ae0a:	697b      	ldr	r3, [r7, #20]
 800ae0c:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800ae10:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800ae12:	68bb      	ldr	r3, [r7, #8]
 800ae14:	681b      	ldr	r3, [r3, #0]
 800ae16:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800ae18:	68bb      	ldr	r3, [r7, #8]
 800ae1a:	685b      	ldr	r3, [r3, #4]
 800ae1c:	3b01      	subs	r3, #1
 800ae1e:	011b      	lsls	r3, r3, #4
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800ae20:	431a      	orrs	r2, r3
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800ae22:	68bb      	ldr	r3, [r7, #8]
 800ae24:	689b      	ldr	r3, [r3, #8]
 800ae26:	3b01      	subs	r3, #1
 800ae28:	021b      	lsls	r3, r3, #8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800ae2a:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 800ae2c:	68bb      	ldr	r3, [r7, #8]
 800ae2e:	691b      	ldr	r3, [r3, #16]
 800ae30:	3b01      	subs	r3, #1
 800ae32:	041b      	lsls	r3, r3, #16
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800ae34:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RCDDelay)-1) << 24));   
 800ae36:	68bb      	ldr	r3, [r7, #8]
 800ae38:	699b      	ldr	r3, [r3, #24]
 800ae3a:	3b01      	subs	r3, #1
 800ae3c:	061b      	lsls	r3, r3, #24
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800ae3e:	4313      	orrs	r3, r2
 800ae40:	697a      	ldr	r2, [r7, #20]
 800ae42:	4313      	orrs	r3, r2
 800ae44:	617b      	str	r3, [r7, #20]
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RCDDelay)-1) << 24));   
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK1];
 800ae46:	68fb      	ldr	r3, [r7, #12]
 800ae48:	689b      	ldr	r3, [r3, #8]
 800ae4a:	613b      	str	r3, [r7, #16]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800ae4c:	693b      	ldr	r3, [r7, #16]
 800ae4e:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800ae52:	613b      	str	r3, [r7, #16]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    tmpr2 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 800ae54:	68bb      	ldr	r3, [r7, #8]
 800ae56:	68db      	ldr	r3, [r3, #12]
 800ae58:	3b01      	subs	r3, #1
 800ae5a:	031a      	lsls	r2, r3, #12
                        (((Timing->RPDelay)-1) << 20)); 
 800ae5c:	68bb      	ldr	r3, [r7, #8]
 800ae5e:	695b      	ldr	r3, [r3, #20]
 800ae60:	3b01      	subs	r3, #1
 800ae62:	051b      	lsls	r3, r3, #20
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    tmpr2 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 800ae64:	4313      	orrs	r3, r2
 800ae66:	693a      	ldr	r2, [r7, #16]
 800ae68:	4313      	orrs	r3, r2
 800ae6a:	613b      	str	r3, [r7, #16]
                        (((Timing->RPDelay)-1) << 20)); 

    Device->SDTR[FMC_SDRAM_BANK2] = tmpr1;
 800ae6c:	68fb      	ldr	r3, [r7, #12]
 800ae6e:	697a      	ldr	r2, [r7, #20]
 800ae70:	60da      	str	r2, [r3, #12]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr2;
 800ae72:	68fb      	ldr	r3, [r7, #12]
 800ae74:	693a      	ldr	r2, [r7, #16]
 800ae76:	609a      	str	r2, [r3, #8]
  }   
  
  return HAL_OK;
 800ae78:	2300      	movs	r3, #0
}
 800ae7a:	4618      	mov	r0, r3
 800ae7c:	371c      	adds	r7, #28
 800ae7e:	46bd      	mov	sp, r7
 800ae80:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae84:	4770      	bx	lr
 800ae86:	bf00      	nop

0800ae88 <FMC_SDRAM_SendCommand>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Timeout: Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800ae88:	b580      	push	{r7, lr}
 800ae8a:	b086      	sub	sp, #24
 800ae8c:	af00      	add	r7, sp, #0
 800ae8e:	60f8      	str	r0, [r7, #12]
 800ae90:	60b9      	str	r1, [r7, #8]
 800ae92:	607a      	str	r2, [r7, #4]
  __IO uint32_t tmpr = 0;
 800ae94:	2300      	movs	r3, #0
 800ae96:	613b      	str	r3, [r7, #16]
  uint32_t tickstart = 0;
 800ae98:	2300      	movs	r3, #0
 800ae9a:	617b      	str	r3, [r7, #20]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800ae9c:	68bb      	ldr	r3, [r7, #8]
 800ae9e:	681a      	ldr	r2, [r3, #0]
                    (Command->CommandTarget)                |\
 800aea0:	68bb      	ldr	r3, [r7, #8]
 800aea2:	685b      	ldr	r3, [r3, #4]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800aea4:	431a      	orrs	r2, r3
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 800aea6:	68bb      	ldr	r3, [r7, #8]
 800aea8:	689b      	ldr	r3, [r3, #8]
 800aeaa:	3b01      	subs	r3, #1
 800aeac:	015b      	lsls	r3, r3, #5
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
                    (Command->CommandTarget)                |\
 800aeae:	431a      	orrs	r2, r3
                    (((Command->AutoRefreshNumber)-1) << 5) |\
                    ((Command->ModeRegisterDefinition) << 9)
 800aeb0:	68bb      	ldr	r3, [r7, #8]
 800aeb2:	68db      	ldr	r3, [r3, #12]
 800aeb4:	025b      	lsls	r3, r3, #9
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800aeb6:	4313      	orrs	r3, r2
 800aeb8:	613b      	str	r3, [r7, #16]
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
                    ((Command->ModeRegisterDefinition) << 9)
                    );
    
  Device->SDCMR = tmpr;
 800aeba:	693a      	ldr	r2, [r7, #16]
 800aebc:	68fb      	ldr	r3, [r7, #12]
 800aebe:	611a      	str	r2, [r3, #16]

  /* Get tick */ 
  tickstart = HAL_GetTick();
 800aec0:	f7f6 fb80 	bl	80015c4 <HAL_GetTick>
 800aec4:	6178      	str	r0, [r7, #20]

  /* wait until command is send */
  while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
 800aec6:	bf00      	nop
 800aec8:	68fb      	ldr	r3, [r7, #12]
 800aeca:	699b      	ldr	r3, [r3, #24]
 800aecc:	f003 0320 	and.w	r3, r3, #32
 800aed0:	2b00      	cmp	r3, #0
 800aed2:	d012      	beq.n	800aefa <FMC_SDRAM_SendCommand+0x72>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 800aed4:	687b      	ldr	r3, [r7, #4]
 800aed6:	f1b3 3fff 	cmp.w	r3, #4294967295
 800aeda:	d00c      	beq.n	800aef6 <FMC_SDRAM_SendCommand+0x6e>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800aedc:	687b      	ldr	r3, [r7, #4]
 800aede:	2b00      	cmp	r3, #0
 800aee0:	d007      	beq.n	800aef2 <FMC_SDRAM_SendCommand+0x6a>
 800aee2:	f7f6 fb6f 	bl	80015c4 <HAL_GetTick>
 800aee6:	4602      	mov	r2, r0
 800aee8:	697b      	ldr	r3, [r7, #20]
 800aeea:	1ad2      	subs	r2, r2, r3
 800aeec:	687b      	ldr	r3, [r7, #4]
 800aeee:	429a      	cmp	r2, r3
 800aef0:	d901      	bls.n	800aef6 <FMC_SDRAM_SendCommand+0x6e>
      {
        return HAL_TIMEOUT;
 800aef2:	2303      	movs	r3, #3
 800aef4:	e002      	b.n	800aefc <FMC_SDRAM_SendCommand+0x74>
      }
    }     
    
    return HAL_ERROR;
 800aef6:	2301      	movs	r3, #1
 800aef8:	e000      	b.n	800aefc <FMC_SDRAM_SendCommand+0x74>
  }
  
  return HAL_OK;  
 800aefa:	2300      	movs	r3, #0
}
 800aefc:	4618      	mov	r0, r3
 800aefe:	3718      	adds	r7, #24
 800af00:	46bd      	mov	sp, r7
 800af02:	bd80      	pop	{r7, pc}

0800af04 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device: Pointer to SDRAM device instance  
  * @param  RefreshRate: The SDRAM refresh rate value.       
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 800af04:	b480      	push	{r7}
 800af06:	b083      	sub	sp, #12
 800af08:	af00      	add	r7, sp, #0
 800af0a:	6078      	str	r0, [r7, #4]
 800af0c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
 800af0e:	687b      	ldr	r3, [r7, #4]
 800af10:	695a      	ldr	r2, [r3, #20]
 800af12:	683b      	ldr	r3, [r7, #0]
 800af14:	005b      	lsls	r3, r3, #1
 800af16:	431a      	orrs	r2, r3
 800af18:	687b      	ldr	r3, [r7, #4]
 800af1a:	615a      	str	r2, [r3, #20]
  
  return HAL_OK;   
 800af1c:	2300      	movs	r3, #0
}
 800af1e:	4618      	mov	r0, r3
 800af20:	370c      	adds	r7, #12
 800af22:	46bd      	mov	sp, r7
 800af24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af28:	4770      	bx	lr
 800af2a:	bf00      	nop

0800af2c <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800af2c:	b480      	push	{r7}
 800af2e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800af30:	4a15      	ldr	r2, [pc, #84]	; (800af88 <SystemInit+0x5c>)
 800af32:	4b15      	ldr	r3, [pc, #84]	; (800af88 <SystemInit+0x5c>)
 800af34:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800af38:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800af3c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800af40:	4a12      	ldr	r2, [pc, #72]	; (800af8c <SystemInit+0x60>)
 800af42:	4b12      	ldr	r3, [pc, #72]	; (800af8c <SystemInit+0x60>)
 800af44:	681b      	ldr	r3, [r3, #0]
 800af46:	f043 0301 	orr.w	r3, r3, #1
 800af4a:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800af4c:	4b0f      	ldr	r3, [pc, #60]	; (800af8c <SystemInit+0x60>)
 800af4e:	2200      	movs	r2, #0
 800af50:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800af52:	490e      	ldr	r1, [pc, #56]	; (800af8c <SystemInit+0x60>)
 800af54:	4b0d      	ldr	r3, [pc, #52]	; (800af8c <SystemInit+0x60>)
 800af56:	681a      	ldr	r2, [r3, #0]
 800af58:	4b0d      	ldr	r3, [pc, #52]	; (800af90 <SystemInit+0x64>)
 800af5a:	4013      	ands	r3, r2
 800af5c:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800af5e:	4b0b      	ldr	r3, [pc, #44]	; (800af8c <SystemInit+0x60>)
 800af60:	4a0c      	ldr	r2, [pc, #48]	; (800af94 <SystemInit+0x68>)
 800af62:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800af64:	4a09      	ldr	r2, [pc, #36]	; (800af8c <SystemInit+0x60>)
 800af66:	4b09      	ldr	r3, [pc, #36]	; (800af8c <SystemInit+0x60>)
 800af68:	681b      	ldr	r3, [r3, #0]
 800af6a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800af6e:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800af70:	4b06      	ldr	r3, [pc, #24]	; (800af8c <SystemInit+0x60>)
 800af72:	2200      	movs	r2, #0
 800af74:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800af76:	4b04      	ldr	r3, [pc, #16]	; (800af88 <SystemInit+0x5c>)
 800af78:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800af7c:	609a      	str	r2, [r3, #8]
#endif
}
 800af7e:	46bd      	mov	sp, r7
 800af80:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af84:	4770      	bx	lr
 800af86:	bf00      	nop
 800af88:	e000ed00 	.word	0xe000ed00
 800af8c:	40023800 	.word	0x40023800
 800af90:	fef6ffff 	.word	0xfef6ffff
 800af94:	24003010 	.word	0x24003010

0800af98 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 800af98:	f8df d034 	ldr.w	sp, [pc, #52]	; 800afd0 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800af9c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800af9e:	e003      	b.n	800afa8 <LoopCopyDataInit>

0800afa0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800afa0:	4b0c      	ldr	r3, [pc, #48]	; (800afd4 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800afa2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800afa4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800afa6:	3104      	adds	r1, #4

0800afa8 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800afa8:	480b      	ldr	r0, [pc, #44]	; (800afd8 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800afaa:	4b0c      	ldr	r3, [pc, #48]	; (800afdc <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800afac:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800afae:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800afb0:	d3f6      	bcc.n	800afa0 <CopyDataInit>
  ldr  r2, =_sbss
 800afb2:	4a0b      	ldr	r2, [pc, #44]	; (800afe0 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800afb4:	e002      	b.n	800afbc <LoopFillZerobss>

0800afb6 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800afb6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800afb8:	f842 3b04 	str.w	r3, [r2], #4

0800afbc <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800afbc:	4b09      	ldr	r3, [pc, #36]	; (800afe4 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800afbe:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800afc0:	d3f9      	bcc.n	800afb6 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800afc2:	f7ff ffb3 	bl	800af2c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800afc6:	f00a ff33 	bl	8015e30 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800afca:	f005 fa25 	bl	8010418 <main>
  bx  lr    
 800afce:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 800afd0:	200107ac 	.word	0x200107ac
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800afd4:	08026060 	.word	0x08026060
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800afd8:	20010000 	.word	0x20010000
  ldr  r3, =_edata
 800afdc:	200105ac 	.word	0x200105ac
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 800afe0:	200107ac 	.word	0x200107ac
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800afe4:	20012afc 	.word	0x20012afc

0800afe8 <CAN2_RX0_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800afe8:	e7fe      	b.n	800afe8 <CAN2_RX0_IRQHandler>
	...

0800afec <j1939_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
static __inline void j1939_list_insert_before(struct list_node *l, struct list_node *n)
{
 800afec:	b480      	push	{r7}
 800afee:	b083      	sub	sp, #12
 800aff0:	af00      	add	r7, sp, #0
 800aff2:	6078      	str	r0, [r7, #4]
 800aff4:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 800aff6:	687b      	ldr	r3, [r7, #4]
 800aff8:	685b      	ldr	r3, [r3, #4]
 800affa:	683a      	ldr	r2, [r7, #0]
 800affc:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 800affe:	687b      	ldr	r3, [r7, #4]
 800b000:	685a      	ldr	r2, [r3, #4]
 800b002:	683b      	ldr	r3, [r7, #0]
 800b004:	605a      	str	r2, [r3, #4]

    l->prev = n;
 800b006:	687b      	ldr	r3, [r7, #4]
 800b008:	683a      	ldr	r2, [r7, #0]
 800b00a:	605a      	str	r2, [r3, #4]
    n->next = l;
 800b00c:	683b      	ldr	r3, [r7, #0]
 800b00e:	687a      	ldr	r2, [r7, #4]
 800b010:	601a      	str	r2, [r3, #0]
}
 800b012:	370c      	adds	r7, #12
 800b014:	46bd      	mov	sp, r7
 800b016:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b01a:	4770      	bx	lr

0800b01c <list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
static __inline void list_init(struct list_node *l)
{
 800b01c:	b480      	push	{r7}
 800b01e:	b083      	sub	sp, #12
 800b020:	af00      	add	r7, sp, #0
 800b022:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 800b024:	687b      	ldr	r3, [r7, #4]
 800b026:	687a      	ldr	r2, [r7, #4]
 800b028:	605a      	str	r2, [r3, #4]
 800b02a:	687b      	ldr	r3, [r7, #4]
 800b02c:	685a      	ldr	r2, [r3, #4]
 800b02e:	687b      	ldr	r3, [r7, #4]
 800b030:	601a      	str	r2, [r3, #0]
}
 800b032:	370c      	adds	r7, #12
 800b034:	46bd      	mov	sp, r7
 800b036:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b03a:	4770      	bx	lr

0800b03c <inttoch>:
struct CA_list calist;

#define Q_MAX_MSG 10;


char inttoch(int val) {
 800b03c:	b480      	push	{r7}
 800b03e:	b083      	sub	sp, #12
 800b040:	af00      	add	r7, sp, #0
 800b042:	6078      	str	r0, [r7, #4]
  if (val<10) return (char)('0'+val);
 800b044:	687b      	ldr	r3, [r7, #4]
 800b046:	2b09      	cmp	r3, #9
 800b048:	dc04      	bgt.n	800b054 <inttoch+0x18>
 800b04a:	687b      	ldr	r3, [r7, #4]
 800b04c:	b2db      	uxtb	r3, r3
 800b04e:	3330      	adds	r3, #48	; 0x30
 800b050:	b2db      	uxtb	r3, r3
 800b052:	e003      	b.n	800b05c <inttoch+0x20>
  return (char)('A'+val-10);
 800b054:	687b      	ldr	r3, [r7, #4]
 800b056:	b2db      	uxtb	r3, r3
 800b058:	3337      	adds	r3, #55	; 0x37
 800b05a:	b2db      	uxtb	r3, r3
}
 800b05c:	4618      	mov	r0, r3
 800b05e:	370c      	adds	r7, #12
 800b060:	46bd      	mov	sp, r7
 800b062:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b066:	4770      	bx	lr

0800b068 <inttostring>:

void inttostring(int vals,char *str,unsigned int base)
{
 800b068:	b590      	push	{r4, r7, lr}
 800b06a:	b089      	sub	sp, #36	; 0x24
 800b06c:	af00      	add	r7, sp, #0
 800b06e:	60f8      	str	r0, [r7, #12]
 800b070:	60b9      	str	r1, [r7, #8]
 800b072:	607a      	str	r2, [r7, #4]
	unsigned int val;
	if (vals<0) {
 800b074:	68fb      	ldr	r3, [r7, #12]
 800b076:	2b00      	cmp	r3, #0
 800b078:	da08      	bge.n	800b08c <inttostring+0x24>
	  *(str++)='-';
 800b07a:	68bb      	ldr	r3, [r7, #8]
 800b07c:	1c5a      	adds	r2, r3, #1
 800b07e:	60ba      	str	r2, [r7, #8]
 800b080:	222d      	movs	r2, #45	; 0x2d
 800b082:	701a      	strb	r2, [r3, #0]
	  val = (unsigned int)(-vals);
 800b084:	68fb      	ldr	r3, [r7, #12]
 800b086:	425b      	negs	r3, r3
 800b088:	61fb      	str	r3, [r7, #28]
 800b08a:	e001      	b.n	800b090 <inttostring+0x28>
	} else {
	  val = (unsigned int)vals;
 800b08c:	68fb      	ldr	r3, [r7, #12]
 800b08e:	61fb      	str	r3, [r7, #28]
	}
	unsigned int d = 1;
 800b090:	2301      	movs	r3, #1
 800b092:	61bb      	str	r3, [r7, #24]
	while (d*base <= val) d*=base;
 800b094:	e004      	b.n	800b0a0 <inttostring+0x38>
 800b096:	69bb      	ldr	r3, [r7, #24]
 800b098:	687a      	ldr	r2, [r7, #4]
 800b09a:	fb02 f303 	mul.w	r3, r2, r3
 800b09e:	61bb      	str	r3, [r7, #24]
 800b0a0:	69bb      	ldr	r3, [r7, #24]
 800b0a2:	687a      	ldr	r2, [r7, #4]
 800b0a4:	fb02 f203 	mul.w	r2, r2, r3
 800b0a8:	69fb      	ldr	r3, [r7, #28]
 800b0aa:	429a      	cmp	r2, r3
 800b0ac:	d9f3      	bls.n	800b096 <inttostring+0x2e>
	while (d > 1) {
 800b0ae:	e019      	b.n	800b0e4 <inttostring+0x7c>
	  unsigned int v = (unsigned int)(val / d);
 800b0b0:	69fa      	ldr	r2, [r7, #28]
 800b0b2:	69bb      	ldr	r3, [r7, #24]
 800b0b4:	fbb2 f3f3 	udiv	r3, r2, r3
 800b0b8:	617b      	str	r3, [r7, #20]
	  val -= v*d;
 800b0ba:	697b      	ldr	r3, [r7, #20]
 800b0bc:	69ba      	ldr	r2, [r7, #24]
 800b0be:	fb02 f303 	mul.w	r3, r2, r3
 800b0c2:	69fa      	ldr	r2, [r7, #28]
 800b0c4:	1ad3      	subs	r3, r2, r3
 800b0c6:	61fb      	str	r3, [r7, #28]
	  *(str++) = inttoch((int)v);
 800b0c8:	68bc      	ldr	r4, [r7, #8]
 800b0ca:	1c63      	adds	r3, r4, #1
 800b0cc:	60bb      	str	r3, [r7, #8]
 800b0ce:	697b      	ldr	r3, [r7, #20]
 800b0d0:	4618      	mov	r0, r3
 800b0d2:	f7ff ffb3 	bl	800b03c <inttoch>
 800b0d6:	4603      	mov	r3, r0
 800b0d8:	7023      	strb	r3, [r4, #0]
	  d /= base;
 800b0da:	69ba      	ldr	r2, [r7, #24]
 800b0dc:	687b      	ldr	r3, [r7, #4]
 800b0de:	fbb2 f3f3 	udiv	r3, r2, r3
 800b0e2:	61bb      	str	r3, [r7, #24]
	} else {
	  val = (unsigned int)vals;
	}
	unsigned int d = 1;
	while (d*base <= val) d*=base;
	while (d > 1) {
 800b0e4:	69bb      	ldr	r3, [r7, #24]
 800b0e6:	2b01      	cmp	r3, #1
 800b0e8:	d8e2      	bhi.n	800b0b0 <inttostring+0x48>
	  unsigned int v = (unsigned int)(val / d);
	  val -= v*d;
	  *(str++) = inttoch((int)v);
	  d /= base;
	}
	*(str++)=inttoch((int)val);
 800b0ea:	68bc      	ldr	r4, [r7, #8]
 800b0ec:	1c63      	adds	r3, r4, #1
 800b0ee:	60bb      	str	r3, [r7, #8]
 800b0f0:	69fb      	ldr	r3, [r7, #28]
 800b0f2:	4618      	mov	r0, r3
 800b0f4:	f7ff ffa2 	bl	800b03c <inttoch>
 800b0f8:	4603      	mov	r3, r0
 800b0fa:	7023      	strb	r3, [r4, #0]
	*(str++)=0;
 800b0fc:	68bb      	ldr	r3, [r7, #8]
 800b0fe:	1c5a      	adds	r2, r3, #1
 800b100:	60ba      	str	r2, [r7, #8]
 800b102:	2200      	movs	r2, #0
 800b104:	701a      	strb	r2, [r3, #0]

}
 800b106:	3724      	adds	r7, #36	; 0x24
 800b108:	46bd      	mov	sp, r7
 800b10a:	bd90      	pop	{r4, r7, pc}

0800b10c <J1939_CA_register>:

unsigned char J1939_CA_register(CA_Msg_t ca_msg)
{
 800b10c:	b580      	push	{r7, lr}
 800b10e:	b08a      	sub	sp, #40	; 0x28
 800b110:	af00      	add	r7, sp, #0
 800b112:	6078      	str	r0, [r7, #4]
	unsigned char result = RC_SUCCESS;
 800b114:	2300      	movs	r3, #0
 800b116:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	struct CA_node * canode;
	struct os_messageQ_def queue_def;
	char str1[5];
	
	if((CA_FindAddress(&calist,ca_msg)) != 254)
 800b11a:	4841      	ldr	r0, [pc, #260]	; (800b220 <J1939_CA_register+0x114>)
 800b11c:	6879      	ldr	r1, [r7, #4]
 800b11e:	f001 faf5 	bl	800c70c <CA_FindAddress>
 800b122:	4603      	mov	r3, r0
 800b124:	2bfe      	cmp	r3, #254	; 0xfe
 800b126:	d001      	beq.n	800b12c <J1939_CA_register+0x20>
		return RC_ERROR;
 800b128:	2301      	movs	r3, #1
 800b12a:	e075      	b.n	800b218 <J1939_CA_register+0x10c>
	
	inttostring(ca_msg->CAname->FunInstance,str1,10);
 800b12c:	687b      	ldr	r3, [r7, #4]
 800b12e:	681b      	ldr	r3, [r3, #0]
 800b130:	791b      	ldrb	r3, [r3, #4]
 800b132:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800b136:	b2db      	uxtb	r3, r3
 800b138:	461a      	mov	r2, r3
 800b13a:	f107 0308 	add.w	r3, r7, #8
 800b13e:	4610      	mov	r0, r2
 800b140:	4619      	mov	r1, r3
 800b142:	220a      	movs	r2, #10
 800b144:	f7ff ff90 	bl	800b068 <inttostring>
	strcat(str1,"tx");
 800b148:	f107 0308 	add.w	r3, r7, #8
 800b14c:	4618      	mov	r0, r3
 800b14e:	f014 fc83 	bl	801fa58 <strlen>
 800b152:	4603      	mov	r3, r0
 800b154:	461a      	mov	r2, r3
 800b156:	f107 0308 	add.w	r3, r7, #8
 800b15a:	4413      	add	r3, r2
 800b15c:	4a31      	ldr	r2, [pc, #196]	; (800b224 <J1939_CA_register+0x118>)
 800b15e:	8811      	ldrh	r1, [r2, #0]
 800b160:	7892      	ldrb	r2, [r2, #2]
 800b162:	8019      	strh	r1, [r3, #0]
 800b164:	709a      	strb	r2, [r3, #2]
	queue_def.name = str1;
 800b166:	f107 0308 	add.w	r3, r7, #8
 800b16a:	613b      	str	r3, [r7, #16]
	rt_kprintf("%s\r\n",queue_def.name );
 800b16c:	693b      	ldr	r3, [r7, #16]
 800b16e:	482e      	ldr	r0, [pc, #184]	; (800b228 <J1939_CA_register+0x11c>)
 800b170:	4619      	mov	r1, r3
 800b172:	f008 fd7d 	bl	8013c70 <rt_kprintf>
	queue_def.msg_size = sizeof(struct q_Message);
 800b176:	2306      	movs	r3, #6
 800b178:	61bb      	str	r3, [r7, #24]
	queue_def.max_msgs = Q_MAX_MSG;
 800b17a:	230a      	movs	r3, #10
 800b17c:	617b      	str	r3, [r7, #20]
	queue_def.flag = IPC_FLAG_FIFO;
 800b17e:	2300      	movs	r3, #0
 800b180:	773b      	strb	r3, [r7, #28]
	ca_msg->txq = osMessageCreate(&queue_def,NULL);
 800b182:	f107 0310 	add.w	r3, r7, #16
 800b186:	4618      	mov	r0, r3
 800b188:	2100      	movs	r1, #0
 800b18a:	f00a feb1 	bl	8015ef0 <osMessageCreate>
 800b18e:	4602      	mov	r2, r0
 800b190:	687b      	ldr	r3, [r7, #4]
 800b192:	65da      	str	r2, [r3, #92]	; 0x5c
	
	inttostring(ca_msg->CAname->FunInstance,str1,10);
 800b194:	687b      	ldr	r3, [r7, #4]
 800b196:	681b      	ldr	r3, [r3, #0]
 800b198:	791b      	ldrb	r3, [r3, #4]
 800b19a:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800b19e:	b2db      	uxtb	r3, r3
 800b1a0:	461a      	mov	r2, r3
 800b1a2:	f107 0308 	add.w	r3, r7, #8
 800b1a6:	4610      	mov	r0, r2
 800b1a8:	4619      	mov	r1, r3
 800b1aa:	220a      	movs	r2, #10
 800b1ac:	f7ff ff5c 	bl	800b068 <inttostring>
	strcat(str1,"rx");
 800b1b0:	f107 0308 	add.w	r3, r7, #8
 800b1b4:	4618      	mov	r0, r3
 800b1b6:	f014 fc4f 	bl	801fa58 <strlen>
 800b1ba:	4603      	mov	r3, r0
 800b1bc:	461a      	mov	r2, r3
 800b1be:	f107 0308 	add.w	r3, r7, #8
 800b1c2:	4413      	add	r3, r2
 800b1c4:	4a19      	ldr	r2, [pc, #100]	; (800b22c <J1939_CA_register+0x120>)
 800b1c6:	8811      	ldrh	r1, [r2, #0]
 800b1c8:	7892      	ldrb	r2, [r2, #2]
 800b1ca:	8019      	strh	r1, [r3, #0]
 800b1cc:	709a      	strb	r2, [r3, #2]
	queue_def.name = str1;
 800b1ce:	f107 0308 	add.w	r3, r7, #8
 800b1d2:	613b      	str	r3, [r7, #16]
	queue_def.msg_size = sizeof(struct rx_Message);
 800b1d4:	230c      	movs	r3, #12
 800b1d6:	61bb      	str	r3, [r7, #24]
	queue_def.max_msgs = Q_MAX_MSG;
 800b1d8:	230a      	movs	r3, #10
 800b1da:	617b      	str	r3, [r7, #20]
	queue_def.flag = IPC_FLAG_FIFO;
 800b1dc:	2300      	movs	r3, #0
 800b1de:	773b      	strb	r3, [r7, #28]
	ca_msg->rxq = osMessageCreate(&queue_def,NULL);
 800b1e0:	f107 0310 	add.w	r3, r7, #16
 800b1e4:	4618      	mov	r0, r3
 800b1e6:	2100      	movs	r1, #0
 800b1e8:	f00a fe82 	bl	8015ef0 <osMessageCreate>
 800b1ec:	4602      	mov	r2, r0
 800b1ee:	687b      	ldr	r3, [r7, #4]
 800b1f0:	661a      	str	r2, [r3, #96]	; 0x60

	canode = (struct CA_node * )malloc(sizeof(struct CA_node));
 800b1f2:	200c      	movs	r0, #12
 800b1f4:	f013 ff8e 	bl	801f114 <malloc>
 800b1f8:	4603      	mov	r3, r0
 800b1fa:	623b      	str	r3, [r7, #32]
	canode->ca_msg = ca_msg;
 800b1fc:	6a3b      	ldr	r3, [r7, #32]
 800b1fe:	687a      	ldr	r2, [r7, #4]
 800b200:	601a      	str	r2, [r3, #0]
	j1939_list_insert_before(&(calist.head),&(canode->node));
 800b202:	6a3b      	ldr	r3, [r7, #32]
 800b204:	3304      	adds	r3, #4
 800b206:	480a      	ldr	r0, [pc, #40]	; (800b230 <J1939_CA_register+0x124>)
 800b208:	4619      	mov	r1, r3
 800b20a:	f7ff feef 	bl	800afec <j1939_list_insert_before>

	initAddr(ca_msg);
 800b20e:	6878      	ldr	r0, [r7, #4]
 800b210:	f001 fc2e 	bl	800ca70 <initAddr>
	return result;
 800b214:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 800b218:	4618      	mov	r0, r3
 800b21a:	3728      	adds	r7, #40	; 0x28
 800b21c:	46bd      	mov	sp, r7
 800b21e:	bd80      	pop	{r7, pc}
 800b220:	20012218 	.word	0x20012218
 800b224:	080225b0 	.word	0x080225b0
 800b228:	080225b4 	.word	0x080225b4
 800b22c:	080225bc 	.word	0x080225bc
 800b230:	2001221c 	.word	0x2001221c

0800b234 <sendData>:

unsigned char sendData(CA_Msg_t CA_msg, unsigned char *data)
{
 800b234:	b580      	push	{r7, lr}
 800b236:	b08e      	sub	sp, #56	; 0x38
 800b238:	af00      	add	r7, sp, #0
 800b23a:	6078      	str	r0, [r7, #4]
 800b23c:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 800b23e:	2300      	movs	r3, #0
 800b240:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	osEvent event;
	struct J1939_msg j1939_msg;
	unsigned short i;
	q_Message_t qmsg;

	j1939_msg.DataPage = 0;
 800b244:	7b3b      	ldrb	r3, [r7, #12]
 800b246:	f36f 03c3 	bfc	r3, #3, #1
 800b24a:	733b      	strb	r3, [r7, #12]
	j1939_msg.edp = 0;
 800b24c:	7b3b      	ldrb	r3, [r7, #12]
 800b24e:	f36f 1304 	bfc	r3, #4, #1
 800b252:	733b      	strb	r3, [r7, #12]
	j1939_msg.PDUFormat = J1939_PF_DT;
 800b254:	23eb      	movs	r3, #235	; 0xeb
 800b256:	737b      	strb	r3, [r7, #13]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	else
		j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	#endif
	
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 800b258:	687b      	ldr	r3, [r7, #4]
 800b25a:	799b      	ldrb	r3, [r3, #6]
 800b25c:	73bb      	strb	r3, [r7, #14]
	j1939_msg.DataLength = 8;
 800b25e:	7c3b      	ldrb	r3, [r7, #16]
 800b260:	2208      	movs	r2, #8
 800b262:	f362 0303 	bfi	r3, r2, #0, #4
 800b266:	743b      	strb	r3, [r7, #16]
	j1939_msg.Priority = 7;
 800b268:	7b3b      	ldrb	r3, [r7, #12]
 800b26a:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 800b26e:	733b      	strb	r3, [r7, #12]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 800b270:	687b      	ldr	r3, [r7, #4]
 800b272:	79db      	ldrb	r3, [r3, #7]
 800b274:	73fb      	strb	r3, [r7, #15]
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
 800b276:	687b      	ldr	r3, [r7, #4]
 800b278:	8b1b      	ldrh	r3, [r3, #24]
 800b27a:	86fb      	strh	r3, [r7, #54]	; 0x36
 800b27c:	e040      	b.n	800b300 <sendData+0xcc>
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
 800b27e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800b280:	b2db      	uxtb	r3, r3
 800b282:	747b      	strb	r3, [r7, #17]
		for(j = 1; j<8;j++)
 800b284:	2301      	movs	r3, #1
 800b286:	86bb      	strh	r3, [r7, #52]	; 0x34
 800b288:	e026      	b.n	800b2d8 <sendData+0xa4>
		{
			unsigned short k;
			k = (i-1)*7+j-1;
 800b28a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800b28c:	3b01      	subs	r3, #1
 800b28e:	b29b      	uxth	r3, r3
 800b290:	461a      	mov	r2, r3
 800b292:	00d2      	lsls	r2, r2, #3
 800b294:	1ad3      	subs	r3, r2, r3
 800b296:	b29a      	uxth	r2, r3
 800b298:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800b29a:	4413      	add	r3, r2
 800b29c:	b29b      	uxth	r3, r3
 800b29e:	3b01      	subs	r3, #1
 800b2a0:	857b      	strh	r3, [r7, #42]	; 0x2a
			if(k < (CA_msg->sendbytes+3))
 800b2a2:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 800b2a4:	687b      	ldr	r3, [r7, #4]
 800b2a6:	8a9b      	ldrh	r3, [r3, #20]
 800b2a8:	3303      	adds	r3, #3
 800b2aa:	429a      	cmp	r2, r3
 800b2ac:	da0a      	bge.n	800b2c4 <sendData+0x90>
				j1939_msg.Data[j] = data[k];
 800b2ae:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800b2b0:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 800b2b2:	6839      	ldr	r1, [r7, #0]
 800b2b4:	440a      	add	r2, r1
 800b2b6:	7812      	ldrb	r2, [r2, #0]
 800b2b8:	f107 0138 	add.w	r1, r7, #56	; 0x38
 800b2bc:	440b      	add	r3, r1
 800b2be:	f803 2c27 	strb.w	r2, [r3, #-39]
 800b2c2:	e006      	b.n	800b2d2 <sendData+0x9e>
			else
				j1939_msg.Data[j] = 0xff;
 800b2c4:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800b2c6:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800b2ca:	4413      	add	r3, r2
 800b2cc:	22ff      	movs	r2, #255	; 0xff
 800b2ce:	f803 2c27 	strb.w	r2, [r3, #-39]
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
		for(j = 1; j<8;j++)
 800b2d2:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800b2d4:	3301      	adds	r3, #1
 800b2d6:	86bb      	strh	r3, [r7, #52]	; 0x34
 800b2d8:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800b2da:	2b07      	cmp	r3, #7
 800b2dc:	d9d5      	bls.n	800b28a <sendData+0x56>
				j1939_msg.Data[j] = data[k];
			else
				j1939_msg.Data[j] = 0xff;
		}
		
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
 800b2de:	f107 030c 	add.w	r3, r7, #12
 800b2e2:	4618      	mov	r0, r3
 800b2e4:	f001 fbd6 	bl	800ca94 <writeCan>
 800b2e8:	4603      	mov	r3, r0
 800b2ea:	2b00      	cmp	r3, #0
 800b2ec:	d005      	beq.n	800b2fa <sendData+0xc6>
		{
			return result = RC_CANNOTTRANSMIT;
 800b2ee:	230a      	movs	r3, #10
 800b2f0:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800b2f4:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800b2f8:	e049      	b.n	800b38e <sendData+0x15a>
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	j1939_msg.DataLength = 8;
	j1939_msg.Priority = 7;
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
 800b2fa:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800b2fc:	3301      	adds	r3, #1
 800b2fe:	86fb      	strh	r3, [r7, #54]	; 0x36
 800b300:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800b302:	687b      	ldr	r3, [r7, #4]
 800b304:	8b5b      	ldrh	r3, [r3, #26]
 800b306:	4619      	mov	r1, r3
 800b308:	687b      	ldr	r3, [r7, #4]
 800b30a:	8b1b      	ldrh	r3, [r3, #24]
 800b30c:	440b      	add	r3, r1
 800b30e:	429a      	cmp	r2, r3
 800b310:	dbb5      	blt.n	800b27e <sendData+0x4a>
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
		{
			return result = RC_CANNOTTRANSMIT;
		}
	}
	if(i > CA_msg->cm.sendpackets)
 800b312:	687b      	ldr	r3, [r7, #4]
 800b314:	8adb      	ldrh	r3, [r3, #22]
 800b316:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800b318:	429a      	cmp	r2, r3
 800b31a:	d904      	bls.n	800b326 <sendData+0xf2>
	{
		CA_msg->cm.sendcomp = 1;
 800b31c:	687b      	ldr	r3, [r7, #4]
 800b31e:	2201      	movs	r2, #1
 800b320:	775a      	strb	r2, [r3, #29]
		//rt_kprintf("sendData success\r\n");
		return RC_SUCCESS;
 800b322:	2300      	movs	r3, #0
 800b324:	e033      	b.n	800b38e <sendData+0x15a>
	}
	CA_msg->cm.t3.value = T3TIMEOUT;
 800b326:	687b      	ldr	r3, [r7, #4]
 800b328:	f240 42e2 	movw	r2, #1250	; 0x4e2
 800b32c:	85da      	strh	r2, [r3, #46]	; 0x2e
	CA_msg->cm.t3.en = 1;
 800b32e:	687b      	ldr	r3, [r7, #4]
 800b330:	2201      	movs	r2, #1
 800b332:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	CA_msg->cm.t3.release = 0;
 800b336:	687b      	ldr	r3, [r7, #4]
 800b338:	2200      	movs	r2, #0
 800b33a:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	event = osMessageGet(CA_msg->txq,WAITFOREVER);
 800b33e:	687b      	ldr	r3, [r7, #4]
 800b340:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800b342:	f107 021c 	add.w	r2, r7, #28
 800b346:	4610      	mov	r0, r2
 800b348:	4619      	mov	r1, r3
 800b34a:	f04f 32ff 	mov.w	r2, #4294967295
 800b34e:	f00a fdfb 	bl	8015f48 <osMessageGet>
	qmsg = event.value.p;
 800b352:	6a3b      	ldr	r3, [r7, #32]
 800b354:	62fb      	str	r3, [r7, #44]	; 0x2c
	if(qmsg->timeout == 0)
 800b356:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b358:	889b      	ldrh	r3, [r3, #4]
 800b35a:	2b00      	cmp	r3, #0
 800b35c:	d112      	bne.n	800b384 <sendData+0x150>
	{
	
		CA_msg->cm.nextnum = qmsg->nextnum;
 800b35e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b360:	881a      	ldrh	r2, [r3, #0]
 800b362:	687b      	ldr	r3, [r7, #4]
 800b364:	831a      	strh	r2, [r3, #24]
		CA_msg->cm.sendnum = qmsg->sendnum;
 800b366:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b368:	885a      	ldrh	r2, [r3, #2]
 800b36a:	687b      	ldr	r3, [r7, #4]
 800b36c:	835a      	strh	r2, [r3, #26]
		if(CA_msg->cm.nextnum != 0)
 800b36e:	687b      	ldr	r3, [r7, #4]
 800b370:	8b1b      	ldrh	r3, [r3, #24]
 800b372:	2b00      	cmp	r3, #0
 800b374:	d000      	beq.n	800b378 <sendData+0x144>
			goto sendmsg;
 800b376:	e77e      	b.n	800b276 <sendData+0x42>
		else
			return result = RC_SUCCESS;
 800b378:	2300      	movs	r3, #0
 800b37a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800b37e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800b382:	e004      	b.n	800b38e <sendData+0x15a>
	}
	else
		return result = RC_TIMEOUT;
 800b384:	230b      	movs	r3, #11
 800b386:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800b38a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
	
}
 800b38e:	4618      	mov	r0, r3
 800b390:	3738      	adds	r7, #56	; 0x38
 800b392:	46bd      	mov	sp, r7
 800b394:	bd80      	pop	{r7, pc}
 800b396:	bf00      	nop

0800b398 <sendBAM>:


unsigned char sendBAM(CA_Msg_t CA_msg, unsigned char *data)
{
 800b398:	b580      	push	{r7, lr}
 800b39a:	b088      	sub	sp, #32
 800b39c:	af00      	add	r7, sp, #0
 800b39e:	6078      	str	r0, [r7, #4]
 800b3a0:	6039      	str	r1, [r7, #0]
	
	unsigned char result = RC_SUCCESS;
 800b3a2:	2300      	movs	r3, #0
 800b3a4:	76fb      	strb	r3, [r7, #27]
	struct J1939_msg j1939_msg;
	unsigned char i;

	j1939_msg.Data[0] = J1939_BAM_CONTROL_BYTE;
 800b3a6:	2320      	movs	r3, #32
 800b3a8:	737b      	strb	r3, [r7, #13]
	j1939_msg.Data[1] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)%256;
 800b3aa:	687b      	ldr	r3, [r7, #4]
 800b3ac:	8a9b      	ldrh	r3, [r3, #20]
 800b3ae:	3303      	adds	r3, #3
 800b3b0:	687a      	ldr	r2, [r7, #4]
 800b3b2:	8ad2      	ldrh	r2, [r2, #22]
 800b3b4:	441a      	add	r2, r3
 800b3b6:	4b5b      	ldr	r3, [pc, #364]	; (800b524 <sendBAM+0x18c>)
 800b3b8:	4013      	ands	r3, r2
 800b3ba:	2b00      	cmp	r3, #0
 800b3bc:	da03      	bge.n	800b3c6 <sendBAM+0x2e>
 800b3be:	3b01      	subs	r3, #1
 800b3c0:	f063 03ff 	orn	r3, r3, #255	; 0xff
 800b3c4:	3301      	adds	r3, #1
 800b3c6:	b2db      	uxtb	r3, r3
 800b3c8:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Data[2] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)/256;
 800b3ca:	687b      	ldr	r3, [r7, #4]
 800b3cc:	8a9b      	ldrh	r3, [r3, #20]
 800b3ce:	3303      	adds	r3, #3
 800b3d0:	687a      	ldr	r2, [r7, #4]
 800b3d2:	8ad2      	ldrh	r2, [r2, #22]
 800b3d4:	4413      	add	r3, r2
 800b3d6:	2b00      	cmp	r3, #0
 800b3d8:	da00      	bge.n	800b3dc <sendBAM+0x44>
 800b3da:	33ff      	adds	r3, #255	; 0xff
 800b3dc:	121b      	asrs	r3, r3, #8
 800b3de:	b2db      	uxtb	r3, r3
 800b3e0:	73fb      	strb	r3, [r7, #15]
	j1939_msg.Data[3] = CA_msg->cm.sendpackets;
 800b3e2:	687b      	ldr	r3, [r7, #4]
 800b3e4:	8adb      	ldrh	r3, [r3, #22]
 800b3e6:	b2db      	uxtb	r3, r3
 800b3e8:	743b      	strb	r3, [r7, #16]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 800b3ea:	23ff      	movs	r3, #255	; 0xff
 800b3ec:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 800b3ee:	687b      	ldr	r3, [r7, #4]
 800b3f0:	799b      	ldrb	r3, [r3, #6]
 800b3f2:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 800b3f4:	687b      	ldr	r3, [r7, #4]
 800b3f6:	795b      	ldrb	r3, [r3, #5]
 800b3f8:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 800b3fa:	687b      	ldr	r3, [r7, #4]
 800b3fc:	791b      	ldrb	r3, [r3, #4]
 800b3fe:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800b402:	b2db      	uxtb	r3, r3
 800b404:	753b      	strb	r3, [r7, #20]
	j1939_msg.DataLength = 8;
 800b406:	7b3b      	ldrb	r3, [r7, #12]
 800b408:	2208      	movs	r2, #8
 800b40a:	f362 0303 	bfi	r3, r2, #0, #4
 800b40e:	733b      	strb	r3, [r7, #12]
	j1939_msg.DataPage = 0;
 800b410:	7a3b      	ldrb	r3, [r7, #8]
 800b412:	f36f 03c3 	bfc	r3, #3, #1
 800b416:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 800b418:	7a3b      	ldrb	r3, [r7, #8]
 800b41a:	f36f 1304 	bfc	r3, #4, #1
 800b41e:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 800b420:	23ec      	movs	r3, #236	; 0xec
 800b422:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 800b424:	23ff      	movs	r3, #255	; 0xff
 800b426:	72bb      	strb	r3, [r7, #10]
	j1939_msg.Priority = 7;
 800b428:	7a3b      	ldrb	r3, [r7, #8]
 800b42a:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 800b42e:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 800b430:	687b      	ldr	r3, [r7, #4]
 800b432:	79db      	ldrb	r3, [r3, #7]
 800b434:	72fb      	strb	r3, [r7, #11]
	if(writeCan(&j1939_msg)!= RC_SUCCESS)
 800b436:	f107 0308 	add.w	r3, r7, #8
 800b43a:	4618      	mov	r0, r3
 800b43c:	f001 fb2a 	bl	800ca94 <writeCan>
 800b440:	4603      	mov	r3, r0
 800b442:	2b00      	cmp	r3, #0
 800b444:	d001      	beq.n	800b44a <sendBAM+0xb2>
		return RC_ERROR;
 800b446:	2301      	movs	r3, #1
 800b448:	e067      	b.n	800b51a <sendBAM+0x182>
	
	j1939_msg.DataPage = 0;
 800b44a:	7a3b      	ldrb	r3, [r7, #8]
 800b44c:	f36f 03c3 	bfc	r3, #3, #1
 800b450:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 800b452:	7a3b      	ldrb	r3, [r7, #8]
 800b454:	f36f 1304 	bfc	r3, #4, #1
 800b458:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_DT;
 800b45a:	23eb      	movs	r3, #235	; 0xeb
 800b45c:	727b      	strb	r3, [r7, #9]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	else
		j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	#endif
	
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 800b45e:	23ff      	movs	r3, #255	; 0xff
 800b460:	72bb      	strb	r3, [r7, #10]
	j1939_msg.DataLength = 8;
 800b462:	7b3b      	ldrb	r3, [r7, #12]
 800b464:	2208      	movs	r2, #8
 800b466:	f362 0303 	bfi	r3, r2, #0, #4
 800b46a:	733b      	strb	r3, [r7, #12]
	j1939_msg.Priority = 7;
 800b46c:	7a3b      	ldrb	r3, [r7, #8]
 800b46e:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 800b472:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 800b474:	687b      	ldr	r3, [r7, #4]
 800b476:	79db      	ldrb	r3, [r3, #7]
 800b478:	72fb      	strb	r3, [r7, #11]
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
 800b47a:	2301      	movs	r3, #1
 800b47c:	77fb      	strb	r3, [r7, #31]
 800b47e:	e040      	b.n	800b502 <sendBAM+0x16a>
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
 800b480:	7ffb      	ldrb	r3, [r7, #31]
 800b482:	737b      	strb	r3, [r7, #13]
		for(j = 1; j<8;j++)
 800b484:	2301      	movs	r3, #1
 800b486:	83bb      	strh	r3, [r7, #28]
 800b488:	e026      	b.n	800b4d8 <sendBAM+0x140>
		{
			unsigned short k;
			k = (i-1)*7+j-1;
 800b48a:	7ffb      	ldrb	r3, [r7, #31]
 800b48c:	3b01      	subs	r3, #1
 800b48e:	b29b      	uxth	r3, r3
 800b490:	461a      	mov	r2, r3
 800b492:	00d2      	lsls	r2, r2, #3
 800b494:	1ad3      	subs	r3, r2, r3
 800b496:	b29a      	uxth	r2, r3
 800b498:	8bbb      	ldrh	r3, [r7, #28]
 800b49a:	4413      	add	r3, r2
 800b49c:	b29b      	uxth	r3, r3
 800b49e:	3b01      	subs	r3, #1
 800b4a0:	833b      	strh	r3, [r7, #24]
			if(k < (CA_msg->sendbytes+3))
 800b4a2:	8b3a      	ldrh	r2, [r7, #24]
 800b4a4:	687b      	ldr	r3, [r7, #4]
 800b4a6:	8a9b      	ldrh	r3, [r3, #20]
 800b4a8:	3303      	adds	r3, #3
 800b4aa:	429a      	cmp	r2, r3
 800b4ac:	da0a      	bge.n	800b4c4 <sendBAM+0x12c>
				j1939_msg.Data[j] = data[k];
 800b4ae:	8bbb      	ldrh	r3, [r7, #28]
 800b4b0:	8b3a      	ldrh	r2, [r7, #24]
 800b4b2:	6839      	ldr	r1, [r7, #0]
 800b4b4:	440a      	add	r2, r1
 800b4b6:	7812      	ldrb	r2, [r2, #0]
 800b4b8:	f107 0120 	add.w	r1, r7, #32
 800b4bc:	440b      	add	r3, r1
 800b4be:	f803 2c13 	strb.w	r2, [r3, #-19]
 800b4c2:	e006      	b.n	800b4d2 <sendBAM+0x13a>
			else
				j1939_msg.Data[j] = 0xff;
 800b4c4:	8bbb      	ldrh	r3, [r7, #28]
 800b4c6:	f107 0220 	add.w	r2, r7, #32
 800b4ca:	4413      	add	r3, r2
 800b4cc:	22ff      	movs	r2, #255	; 0xff
 800b4ce:	f803 2c13 	strb.w	r2, [r3, #-19]
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
		for(j = 1; j<8;j++)
 800b4d2:	8bbb      	ldrh	r3, [r7, #28]
 800b4d4:	3301      	adds	r3, #1
 800b4d6:	83bb      	strh	r3, [r7, #28]
 800b4d8:	8bbb      	ldrh	r3, [r7, #28]
 800b4da:	2b07      	cmp	r3, #7
 800b4dc:	d9d5      	bls.n	800b48a <sendBAM+0xf2>
			if(k < (CA_msg->sendbytes+3))
				j1939_msg.Data[j] = data[k];
			else
				j1939_msg.Data[j] = 0xff;
		}
		osDelay(BAMDTTIME);
 800b4de:	2037      	movs	r0, #55	; 0x37
 800b4e0:	f00a fcac 	bl	8015e3c <osDelay>
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
 800b4e4:	f107 0308 	add.w	r3, r7, #8
 800b4e8:	4618      	mov	r0, r3
 800b4ea:	f001 fad3 	bl	800ca94 <writeCan>
 800b4ee:	4603      	mov	r3, r0
 800b4f0:	2b00      	cmp	r3, #0
 800b4f2:	d003      	beq.n	800b4fc <sendBAM+0x164>
		{


			return result = RC_CANNOTTRANSMIT;
 800b4f4:	230a      	movs	r3, #10
 800b4f6:	76fb      	strb	r3, [r7, #27]
 800b4f8:	7efb      	ldrb	r3, [r7, #27]
 800b4fa:	e00e      	b.n	800b51a <sendBAM+0x182>
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg.DataLength = 8;
	j1939_msg.Priority = 7;
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
 800b4fc:	7ffb      	ldrb	r3, [r7, #31]
 800b4fe:	3301      	adds	r3, #1
 800b500:	77fb      	strb	r3, [r7, #31]
 800b502:	7ffb      	ldrb	r3, [r7, #31]
 800b504:	b29a      	uxth	r2, r3
 800b506:	687b      	ldr	r3, [r7, #4]
 800b508:	8adb      	ldrh	r3, [r3, #22]
 800b50a:	429a      	cmp	r2, r3
 800b50c:	d802      	bhi.n	800b514 <sendBAM+0x17c>
 800b50e:	7ffb      	ldrb	r3, [r7, #31]
 800b510:	2b00      	cmp	r3, #0
 800b512:	d1b5      	bne.n	800b480 <sendBAM+0xe8>

			return result = RC_CANNOTTRANSMIT;
		}
	}
	
	return result = RC_SUCCESS;
 800b514:	2300      	movs	r3, #0
 800b516:	76fb      	strb	r3, [r7, #27]
 800b518:	7efb      	ldrb	r3, [r7, #27]
}
 800b51a:	4618      	mov	r0, r3
 800b51c:	3720      	adds	r7, #32
 800b51e:	46bd      	mov	sp, r7
 800b520:	bd80      	pop	{r7, pc}
 800b522:	bf00      	nop
 800b524:	800000ff 	.word	0x800000ff

0800b528 <sendRTS>:

unsigned char sendRTS(CA_Msg_t CA_msg)
{
 800b528:	b580      	push	{r7, lr}
 800b52a:	b08c      	sub	sp, #48	; 0x30
 800b52c:	af00      	add	r7, sp, #0
 800b52e:	6078      	str	r0, [r7, #4]
	q_Message_t qmsg;
	unsigned char result = RC_SUCCESS;
 800b530:	2300      	movs	r3, #0
 800b532:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	osEvent event;
	struct J1939_msg j1939_msg;
	j1939_msg.Data[0] = J1939_RTS_CONTROL_BYTE;
 800b536:	2310      	movs	r3, #16
 800b538:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[1] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)%256;
 800b53a:	687b      	ldr	r3, [r7, #4]
 800b53c:	8a9b      	ldrh	r3, [r3, #20]
 800b53e:	3303      	adds	r3, #3
 800b540:	687a      	ldr	r2, [r7, #4]
 800b542:	8ad2      	ldrh	r2, [r2, #22]
 800b544:	441a      	add	r2, r3
 800b546:	4b42      	ldr	r3, [pc, #264]	; (800b650 <sendRTS+0x128>)
 800b548:	4013      	ands	r3, r2
 800b54a:	2b00      	cmp	r3, #0
 800b54c:	da03      	bge.n	800b556 <sendRTS+0x2e>
 800b54e:	3b01      	subs	r3, #1
 800b550:	f063 03ff 	orn	r3, r3, #255	; 0xff
 800b554:	3301      	adds	r3, #1
 800b556:	b2db      	uxtb	r3, r3
 800b558:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[2] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)/256;
 800b55a:	687b      	ldr	r3, [r7, #4]
 800b55c:	8a9b      	ldrh	r3, [r3, #20]
 800b55e:	3303      	adds	r3, #3
 800b560:	687a      	ldr	r2, [r7, #4]
 800b562:	8ad2      	ldrh	r2, [r2, #22]
 800b564:	4413      	add	r3, r2
 800b566:	2b00      	cmp	r3, #0
 800b568:	da00      	bge.n	800b56c <sendRTS+0x44>
 800b56a:	33ff      	adds	r3, #255	; 0xff
 800b56c:	121b      	asrs	r3, r3, #8
 800b56e:	b2db      	uxtb	r3, r3
 800b570:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[3] = CA_msg->cm.sendpackets;
 800b572:	687b      	ldr	r3, [r7, #4]
 800b574:	8adb      	ldrh	r3, [r3, #22]
 800b576:	b2db      	uxtb	r3, r3
 800b578:	753b      	strb	r3, [r7, #20]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 800b57a:	23ff      	movs	r3, #255	; 0xff
 800b57c:	757b      	strb	r3, [r7, #21]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 800b57e:	687b      	ldr	r3, [r7, #4]
 800b580:	799b      	ldrb	r3, [r3, #6]
 800b582:	75bb      	strb	r3, [r7, #22]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 800b584:	687b      	ldr	r3, [r7, #4]
 800b586:	795b      	ldrb	r3, [r3, #5]
 800b588:	75fb      	strb	r3, [r7, #23]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 800b58a:	687b      	ldr	r3, [r7, #4]
 800b58c:	791b      	ldrb	r3, [r3, #4]
 800b58e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800b592:	b2db      	uxtb	r3, r3
 800b594:	763b      	strb	r3, [r7, #24]
	j1939_msg.DataLength = 8;
 800b596:	7c3b      	ldrb	r3, [r7, #16]
 800b598:	2208      	movs	r2, #8
 800b59a:	f362 0303 	bfi	r3, r2, #0, #4
 800b59e:	743b      	strb	r3, [r7, #16]
	j1939_msg.DataPage = 0;
 800b5a0:	7b3b      	ldrb	r3, [r7, #12]
 800b5a2:	f36f 03c3 	bfc	r3, #3, #1
 800b5a6:	733b      	strb	r3, [r7, #12]
	j1939_msg.edp = 0;
 800b5a8:	7b3b      	ldrb	r3, [r7, #12]
 800b5aa:	f36f 1304 	bfc	r3, #4, #1
 800b5ae:	733b      	strb	r3, [r7, #12]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 800b5b0:	23ec      	movs	r3, #236	; 0xec
 800b5b2:	737b      	strb	r3, [r7, #13]
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 800b5b4:	687b      	ldr	r3, [r7, #4]
 800b5b6:	799b      	ldrb	r3, [r3, #6]
 800b5b8:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Priority = 7;
 800b5ba:	7b3b      	ldrb	r3, [r7, #12]
 800b5bc:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 800b5c0:	733b      	strb	r3, [r7, #12]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 800b5c2:	687b      	ldr	r3, [r7, #4]
 800b5c4:	79db      	ldrb	r3, [r3, #7]
 800b5c6:	73fb      	strb	r3, [r7, #15]
	if(writeCan(&j1939_msg)== RC_SUCCESS)
 800b5c8:	f107 030c 	add.w	r3, r7, #12
 800b5cc:	4618      	mov	r0, r3
 800b5ce:	f001 fa61 	bl	800ca94 <writeCan>
 800b5d2:	4603      	mov	r3, r0
 800b5d4:	2b00      	cmp	r3, #0
 800b5d6:	d132      	bne.n	800b63e <sendRTS+0x116>
	{

		CA_msg->cm.t3.value = T3TIMEOUT;
 800b5d8:	687b      	ldr	r3, [r7, #4]
 800b5da:	f240 42e2 	movw	r2, #1250	; 0x4e2
 800b5de:	85da      	strh	r2, [r3, #46]	; 0x2e
		CA_msg->cm.t3.en = 1;
 800b5e0:	687b      	ldr	r3, [r7, #4]
 800b5e2:	2201      	movs	r2, #1
 800b5e4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		CA_msg->cm.t3.release = 0;
 800b5e8:	687b      	ldr	r3, [r7, #4]
 800b5ea:	2200      	movs	r2, #0
 800b5ec:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
		event = osMessageGet(CA_msg->txq,WAITFOREVER);
 800b5f0:	687b      	ldr	r3, [r7, #4]
 800b5f2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800b5f4:	f107 021c 	add.w	r2, r7, #28
 800b5f8:	4610      	mov	r0, r2
 800b5fa:	4619      	mov	r1, r3
 800b5fc:	f04f 32ff 	mov.w	r2, #4294967295
 800b600:	f00a fca2 	bl	8015f48 <osMessageGet>
		qmsg = (q_Message_t)event.value.p;
 800b604:	6a3b      	ldr	r3, [r7, #32]
 800b606:	62bb      	str	r3, [r7, #40]	; 0x28
		if(qmsg->timeout == 0)
 800b608:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b60a:	889b      	ldrh	r3, [r3, #4]
 800b60c:	2b00      	cmp	r3, #0
 800b60e:	d110      	bne.n	800b632 <sendRTS+0x10a>
		{
			CA_msg->cm.nextnum = qmsg->nextnum;
 800b610:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b612:	881a      	ldrh	r2, [r3, #0]
 800b614:	687b      	ldr	r3, [r7, #4]
 800b616:	831a      	strh	r2, [r3, #24]
			CA_msg->cm.sendnum = qmsg->sendnum;
 800b618:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b61a:	885a      	ldrh	r2, [r3, #2]
 800b61c:	687b      	ldr	r3, [r7, #4]
 800b61e:	835a      	strh	r2, [r3, #26]
			CA_msg->cm.cm_lock = 1;
 800b620:	687b      	ldr	r3, [r7, #4]
 800b622:	2201      	movs	r2, #1
 800b624:	771a      	strb	r2, [r3, #28]
			return result = RC_SUCCESS;
 800b626:	2300      	movs	r3, #0
 800b628:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800b62c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800b630:	e00a      	b.n	800b648 <sendRTS+0x120>
		}
		else
		{
			return result = RC_TIMEOUT;
 800b632:	230b      	movs	r3, #11
 800b634:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800b638:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800b63c:	e004      	b.n	800b648 <sendRTS+0x120>
		}
	}
	else
		return result = RC_CANNOTTRANSMIT;
 800b63e:	230a      	movs	r3, #10
 800b640:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800b644:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 800b648:	4618      	mov	r0, r3
 800b64a:	3730      	adds	r7, #48	; 0x30
 800b64c:	46bd      	mov	sp, r7
 800b64e:	bd80      	pop	{r7, pc}
 800b650:	800000ff 	.word	0x800000ff

0800b654 <sendAbort>:

unsigned char sendAbort(CA_Msg_t CA_msg,unsigned char reason)
{
 800b654:	b580      	push	{r7, lr}
 800b656:	b088      	sub	sp, #32
 800b658:	af00      	add	r7, sp, #0
 800b65a:	6078      	str	r0, [r7, #4]
 800b65c:	460b      	mov	r3, r1
 800b65e:	70fb      	strb	r3, [r7, #3]
	unsigned char result = RC_SUCCESS;
 800b660:	2300      	movs	r3, #0
 800b662:	77fb      	strb	r3, [r7, #31]
	struct J1939_msg j1939_msg;
	struct J1939_CM *tempCm;

	
	j1939_msg.Data[0] = J1939_CONNABORT_CONTROL_BYTE;
 800b664:	23ff      	movs	r3, #255	; 0xff
 800b666:	737b      	strb	r3, [r7, #13]
	j1939_msg.Data[1] = reason;
 800b668:	78fb      	ldrb	r3, [r7, #3]
 800b66a:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Data[2] = 0xff;
 800b66c:	23ff      	movs	r3, #255	; 0xff
 800b66e:	73fb      	strb	r3, [r7, #15]
	j1939_msg.Data[3] = 0xff;
 800b670:	23ff      	movs	r3, #255	; 0xff
 800b672:	743b      	strb	r3, [r7, #16]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 800b674:	23ff      	movs	r3, #255	; 0xff
 800b676:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 800b678:	687b      	ldr	r3, [r7, #4]
 800b67a:	799b      	ldrb	r3, [r3, #6]
 800b67c:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 800b67e:	687b      	ldr	r3, [r7, #4]
 800b680:	795b      	ldrb	r3, [r3, #5]
 800b682:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 800b684:	687b      	ldr	r3, [r7, #4]
 800b686:	791b      	ldrb	r3, [r3, #4]
 800b688:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800b68c:	b2db      	uxtb	r3, r3
 800b68e:	753b      	strb	r3, [r7, #20]
	j1939_msg.DataLength = 8;
 800b690:	7b3b      	ldrb	r3, [r7, #12]
 800b692:	2208      	movs	r2, #8
 800b694:	f362 0303 	bfi	r3, r2, #0, #4
 800b698:	733b      	strb	r3, [r7, #12]
	j1939_msg.DataPage = 0;
 800b69a:	7a3b      	ldrb	r3, [r7, #8]
 800b69c:	f36f 03c3 	bfc	r3, #3, #1
 800b6a0:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 800b6a2:	7a3b      	ldrb	r3, [r7, #8]
 800b6a4:	f36f 1304 	bfc	r3, #4, #1
 800b6a8:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 800b6aa:	23ec      	movs	r3, #236	; 0xec
 800b6ac:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 800b6ae:	687b      	ldr	r3, [r7, #4]
 800b6b0:	799b      	ldrb	r3, [r3, #6]
 800b6b2:	72bb      	strb	r3, [r7, #10]
	j1939_msg.Priority = 7;
 800b6b4:	7a3b      	ldrb	r3, [r7, #8]
 800b6b6:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 800b6ba:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 800b6bc:	687b      	ldr	r3, [r7, #4]
 800b6be:	79db      	ldrb	r3, [r3, #7]
 800b6c0:	72fb      	strb	r3, [r7, #11]
	CA_msg->cm.cm_lock = 0;
 800b6c2:	687b      	ldr	r3, [r7, #4]
 800b6c4:	2200      	movs	r2, #0
 800b6c6:	771a      	strb	r2, [r3, #28]
	
	if(writeCan(&j1939_msg)!= RC_SUCCESS)
 800b6c8:	f107 0308 	add.w	r3, r7, #8
 800b6cc:	4618      	mov	r0, r3
 800b6ce:	f001 f9e1 	bl	800ca94 <writeCan>
 800b6d2:	4603      	mov	r3, r0
 800b6d4:	2b00      	cmp	r3, #0
 800b6d6:	d017      	beq.n	800b708 <sendAbort+0xb4>
	{
		
		if(CA_msg->rcvdata != NULL)
 800b6d8:	687b      	ldr	r3, [r7, #4]
 800b6da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b6dc:	2b00      	cmp	r3, #0
 800b6de:	d007      	beq.n	800b6f0 <sendAbort+0x9c>
		{
			free(CA_msg->rcvdata);
 800b6e0:	687b      	ldr	r3, [r7, #4]
 800b6e2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b6e4:	4618      	mov	r0, r3
 800b6e6:	f013 fd1d 	bl	801f124 <free>
			CA_msg -> rcvdata = NULL;
 800b6ea:	687b      	ldr	r3, [r7, #4]
 800b6ec:	2200      	movs	r2, #0
 800b6ee:	655a      	str	r2, [r3, #84]	; 0x54
		}
		tempCm = &(CA_msg->cm);
 800b6f0:	687b      	ldr	r3, [r7, #4]
 800b6f2:	3316      	adds	r3, #22
 800b6f4:	61bb      	str	r3, [r7, #24]
		memset(tempCm,0,sizeof(struct J1939_CM));
 800b6f6:	69b8      	ldr	r0, [r7, #24]
 800b6f8:	2100      	movs	r1, #0
 800b6fa:	222a      	movs	r2, #42	; 0x2a
 800b6fc:	f013 fd1a 	bl	801f134 <memset>
		return result = RC_CANNOTTRANSMIT;
 800b700:	230a      	movs	r3, #10
 800b702:	77fb      	strb	r3, [r7, #31]
 800b704:	7ffb      	ldrb	r3, [r7, #31]
 800b706:	e016      	b.n	800b736 <sendAbort+0xe2>
	}
	else 
	{
		if(CA_msg->rcvdata != NULL)
 800b708:	687b      	ldr	r3, [r7, #4]
 800b70a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b70c:	2b00      	cmp	r3, #0
 800b70e:	d007      	beq.n	800b720 <sendAbort+0xcc>
		{
			free(CA_msg->rcvdata);
 800b710:	687b      	ldr	r3, [r7, #4]
 800b712:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b714:	4618      	mov	r0, r3
 800b716:	f013 fd05 	bl	801f124 <free>
			CA_msg->rcvdata = NULL;
 800b71a:	687b      	ldr	r3, [r7, #4]
 800b71c:	2200      	movs	r2, #0
 800b71e:	655a      	str	r2, [r3, #84]	; 0x54
		}
		tempCm = &(CA_msg->cm);
 800b720:	687b      	ldr	r3, [r7, #4]
 800b722:	3316      	adds	r3, #22
 800b724:	61bb      	str	r3, [r7, #24]
		memset(tempCm,0,sizeof(struct J1939_CM));
 800b726:	69b8      	ldr	r0, [r7, #24]
 800b728:	2100      	movs	r1, #0
 800b72a:	222a      	movs	r2, #42	; 0x2a
 800b72c:	f013 fd02 	bl	801f134 <memset>

		return result = RC_SUCCESS;
 800b730:	2300      	movs	r3, #0
 800b732:	77fb      	strb	r3, [r7, #31]
 800b734:	7ffb      	ldrb	r3, [r7, #31]
	}
}
 800b736:	4618      	mov	r0, r3
 800b738:	3720      	adds	r7, #32
 800b73a:	46bd      	mov	sp, r7
 800b73c:	bd80      	pop	{r7, pc}
 800b73e:	bf00      	nop

0800b740 <sendMessage>:

unsigned char sendMessage(CA_Msg_t CA_msg, unsigned char *data)
{
 800b740:	b580      	push	{r7, lr}
 800b742:	b08a      	sub	sp, #40	; 0x28
 800b744:	af00      	add	r7, sp, #0
 800b746:	6078      	str	r0, [r7, #4]
 800b748:	6039      	str	r1, [r7, #0]
	unsigned char i;
	struct J1939_msg j1939_msg;
	unsigned char sa;
	unsigned char result;
	if((sa = CA_FindAddress(&calist,CA_msg)) == 254)
 800b74a:	4892      	ldr	r0, [pc, #584]	; (800b994 <sendMessage+0x254>)
 800b74c:	6879      	ldr	r1, [r7, #4]
 800b74e:	f000 ffdd 	bl	800c70c <CA_FindAddress>
 800b752:	4603      	mov	r3, r0
 800b754:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800b758:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800b75c:	2bfe      	cmp	r3, #254	; 0xfe
 800b75e:	d101      	bne.n	800b764 <sendMessage+0x24>
		return RC_ERROR;
 800b760:	2301      	movs	r3, #1
 800b762:	e112      	b.n	800b98a <sendMessage+0x24a>
	if (CA_msg->sendbytes <= 8)
 800b764:	687b      	ldr	r3, [r7, #4]
 800b766:	8a9b      	ldrh	r3, [r3, #20]
 800b768:	2b08      	cmp	r3, #8
 800b76a:	d850      	bhi.n	800b80e <sendMessage+0xce>
	{
		j1939_msg.DataLength = CA_msg->sendbytes;
 800b76c:	687b      	ldr	r3, [r7, #4]
 800b76e:	8a9b      	ldrh	r3, [r3, #20]
 800b770:	b2db      	uxtb	r3, r3
 800b772:	f003 030f 	and.w	r3, r3, #15
 800b776:	b2da      	uxtb	r2, r3
 800b778:	7c3b      	ldrb	r3, [r7, #16]
 800b77a:	f362 0303 	bfi	r3, r2, #0, #4
 800b77e:	743b      	strb	r3, [r7, #16]
		j1939_msg.DataPage = CA_msg->msg.DataPage;
 800b780:	687b      	ldr	r3, [r7, #4]
 800b782:	791b      	ldrb	r3, [r3, #4]
 800b784:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800b788:	b2da      	uxtb	r2, r3
 800b78a:	7b3b      	ldrb	r3, [r7, #12]
 800b78c:	f362 03c3 	bfi	r3, r2, #3, #1
 800b790:	733b      	strb	r3, [r7, #12]
		j1939_msg.edp = CA_msg->msg.edp;
 800b792:	687b      	ldr	r3, [r7, #4]
 800b794:	791b      	ldrb	r3, [r3, #4]
 800b796:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800b79a:	b2da      	uxtb	r2, r3
 800b79c:	7b3b      	ldrb	r3, [r7, #12]
 800b79e:	f362 1304 	bfi	r3, r2, #4, #1
 800b7a2:	733b      	strb	r3, [r7, #12]
		j1939_msg.PDUFormat = CA_msg->msg.PDUFormat;
 800b7a4:	687b      	ldr	r3, [r7, #4]
 800b7a6:	795b      	ldrb	r3, [r3, #5]
 800b7a8:	737b      	strb	r3, [r7, #13]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 800b7aa:	687b      	ldr	r3, [r7, #4]
 800b7ac:	799b      	ldrb	r3, [r3, #6]
 800b7ae:	73bb      	strb	r3, [r7, #14]
		j1939_msg.Priority = CA_msg->msg.Priority;
 800b7b0:	687b      	ldr	r3, [r7, #4]
 800b7b2:	791b      	ldrb	r3, [r3, #4]
 800b7b4:	f3c3 1342 	ubfx	r3, r3, #5, #3
 800b7b8:	b2da      	uxtb	r2, r3
 800b7ba:	7b3b      	ldrb	r3, [r7, #12]
 800b7bc:	f362 1347 	bfi	r3, r2, #5, #3
 800b7c0:	733b      	strb	r3, [r7, #12]
		j1939_msg.SourceAddress = sa;
 800b7c2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800b7c6:	73fb      	strb	r3, [r7, #15]
		for (i = 0;i < CA_msg->sendbytes;i++)
 800b7c8:	2300      	movs	r3, #0
 800b7ca:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800b7ce:	e010      	b.n	800b7f2 <sendMessage+0xb2>
			j1939_msg.Data[i] = data[i];
 800b7d0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800b7d4:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800b7d8:	6839      	ldr	r1, [r7, #0]
 800b7da:	440a      	add	r2, r1
 800b7dc:	7812      	ldrb	r2, [r2, #0]
 800b7de:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800b7e2:	440b      	add	r3, r1
 800b7e4:	f803 2c17 	strb.w	r2, [r3, #-23]
		j1939_msg.edp = CA_msg->msg.edp;
		j1939_msg.PDUFormat = CA_msg->msg.PDUFormat;
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
		j1939_msg.Priority = CA_msg->msg.Priority;
		j1939_msg.SourceAddress = sa;
		for (i = 0;i < CA_msg->sendbytes;i++)
 800b7e8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800b7ec:	3301      	adds	r3, #1
 800b7ee:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800b7f2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800b7f6:	b29a      	uxth	r2, r3
 800b7f8:	687b      	ldr	r3, [r7, #4]
 800b7fa:	8a9b      	ldrh	r3, [r3, #20]
 800b7fc:	429a      	cmp	r2, r3
 800b7fe:	d3e7      	bcc.n	800b7d0 <sendMessage+0x90>
			j1939_msg.Data[i] = data[i];
		return writeCan(&j1939_msg);
 800b800:	f107 030c 	add.w	r3, r7, #12
 800b804:	4618      	mov	r0, r3
 800b806:	f001 f945 	bl	800ca94 <writeCan>
 800b80a:	4603      	mov	r3, r0
 800b80c:	e0bd      	b.n	800b98a <sendMessage+0x24a>
	else
	{
		unsigned char *tmp;
		unsigned short j,k;
		
		j = ceil(((double)CA_msg->sendbytes + 3)/7);
 800b80e:	687b      	ldr	r3, [r7, #4]
 800b810:	8a9b      	ldrh	r3, [r3, #20]
 800b812:	4618      	mov	r0, r3
 800b814:	f7f5 f8b6 	bl	8000984 <__aeabi_ui2d>
 800b818:	4602      	mov	r2, r0
 800b81a:	460b      	mov	r3, r1
 800b81c:	4610      	mov	r0, r2
 800b81e:	4619      	mov	r1, r3
 800b820:	f04f 0200 	mov.w	r2, #0
 800b824:	4b5c      	ldr	r3, [pc, #368]	; (800b998 <sendMessage+0x258>)
 800b826:	f7f4 ff71 	bl	800070c <__adddf3>
 800b82a:	4602      	mov	r2, r0
 800b82c:	460b      	mov	r3, r1
 800b82e:	4610      	mov	r0, r2
 800b830:	4619      	mov	r1, r3
 800b832:	f04f 0200 	mov.w	r2, #0
 800b836:	4b59      	ldr	r3, [pc, #356]	; (800b99c <sendMessage+0x25c>)
 800b838:	f7f5 fa44 	bl	8000cc4 <__aeabi_ddiv>
 800b83c:	4602      	mov	r2, r0
 800b83e:	460b      	mov	r3, r1
 800b840:	ec43 2b17 	vmov	d7, r2, r3
 800b844:	eeb0 0a47 	vmov.f32	s0, s14
 800b848:	eef0 0a67 	vmov.f32	s1, s15
 800b84c:	f016 fe24 	bl	8022498 <ceil>
 800b850:	ec53 2b10 	vmov	r2, r3, d0
 800b854:	4610      	mov	r0, r2
 800b856:	4619      	mov	r1, r3
 800b858:	f7f5 fba4 	bl	8000fa4 <__aeabi_d2uiz>
 800b85c:	4603      	mov	r3, r0
 800b85e:	843b      	strh	r3, [r7, #32]
		CA_msg->cm.sendpackets = j;
 800b860:	687b      	ldr	r3, [r7, #4]
 800b862:	8c3a      	ldrh	r2, [r7, #32]
 800b864:	82da      	strh	r2, [r3, #22]
		tmp = (unsigned char *)malloc((CA_msg->sendbytes+3) * sizeof(char));
 800b866:	687b      	ldr	r3, [r7, #4]
 800b868:	8a9b      	ldrh	r3, [r3, #20]
 800b86a:	3303      	adds	r3, #3
 800b86c:	4618      	mov	r0, r3
 800b86e:	f013 fc51 	bl	801f114 <malloc>
 800b872:	4603      	mov	r3, r0
 800b874:	61fb      	str	r3, [r7, #28]
		for(k=0;k < (CA_msg->sendbytes);k++)
 800b876:	2300      	movs	r3, #0
 800b878:	84bb      	strh	r3, [r7, #36]	; 0x24
 800b87a:	e00a      	b.n	800b892 <sendMessage+0x152>
		{
				tmp[k] = data[k];
 800b87c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b87e:	69fa      	ldr	r2, [r7, #28]
 800b880:	4413      	add	r3, r2
 800b882:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800b884:	6839      	ldr	r1, [r7, #0]
 800b886:	440a      	add	r2, r1
 800b888:	7812      	ldrb	r2, [r2, #0]
 800b88a:	701a      	strb	r2, [r3, #0]
		unsigned short j,k;
		
		j = ceil(((double)CA_msg->sendbytes + 3)/7);
		CA_msg->cm.sendpackets = j;
		tmp = (unsigned char *)malloc((CA_msg->sendbytes+3) * sizeof(char));
		for(k=0;k < (CA_msg->sendbytes);k++)
 800b88c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b88e:	3301      	adds	r3, #1
 800b890:	84bb      	strh	r3, [r7, #36]	; 0x24
 800b892:	687b      	ldr	r3, [r7, #4]
 800b894:	8a9b      	ldrh	r3, [r3, #20]
 800b896:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800b898:	429a      	cmp	r2, r3
 800b89a:	d3ef      	bcc.n	800b87c <sendMessage+0x13c>
		{
				tmp[k] = data[k];
		}
		tmp[k] = CA_msg->msg.PDUSpecific;
 800b89c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b89e:	69fa      	ldr	r2, [r7, #28]
 800b8a0:	4413      	add	r3, r2
 800b8a2:	687a      	ldr	r2, [r7, #4]
 800b8a4:	7992      	ldrb	r2, [r2, #6]
 800b8a6:	701a      	strb	r2, [r3, #0]
		tmp[k+1] = CA_msg->msg.PDUFormat;
 800b8a8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b8aa:	3301      	adds	r3, #1
 800b8ac:	69fa      	ldr	r2, [r7, #28]
 800b8ae:	4413      	add	r3, r2
 800b8b0:	687a      	ldr	r2, [r7, #4]
 800b8b2:	7952      	ldrb	r2, [r2, #5]
 800b8b4:	701a      	strb	r2, [r3, #0]
		tmp[k+2] = CA_msg->msg.DataPage;
 800b8b6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b8b8:	3302      	adds	r3, #2
 800b8ba:	69fa      	ldr	r2, [r7, #28]
 800b8bc:	4413      	add	r3, r2
 800b8be:	687a      	ldr	r2, [r7, #4]
 800b8c0:	7912      	ldrb	r2, [r2, #4]
 800b8c2:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 800b8c6:	b2d2      	uxtb	r2, r2
 800b8c8:	701a      	strb	r2, [r3, #0]
		CA_msg->msg.SourceAddress = sa;
 800b8ca:	687b      	ldr	r3, [r7, #4]
 800b8cc:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800b8d0:	71da      	strb	r2, [r3, #7]
		if(CA_msg->msg.PDUSpecific== J1939_GLOBAL_ADDRESS)
 800b8d2:	687b      	ldr	r3, [r7, #4]
 800b8d4:	799b      	ldrb	r3, [r3, #6]
 800b8d6:	2bff      	cmp	r3, #255	; 0xff
 800b8d8:	d107      	bne.n	800b8ea <sendMessage+0x1aa>
			result = sendBAM(CA_msg,tmp);
 800b8da:	6878      	ldr	r0, [r7, #4]
 800b8dc:	69f9      	ldr	r1, [r7, #28]
 800b8de:	f7ff fd5b 	bl	800b398 <sendBAM>
 800b8e2:	4603      	mov	r3, r0
 800b8e4:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 800b8e8:	e045      	b.n	800b976 <sendMessage+0x236>
		else
		{
			
			result = sendRTS(CA_msg);
 800b8ea:	6878      	ldr	r0, [r7, #4]
 800b8ec:	f7ff fe1c 	bl	800b528 <sendRTS>
 800b8f0:	4603      	mov	r3, r0
 800b8f2:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
			if(result == RC_SUCCESS)
 800b8f6:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800b8fa:	2b00      	cmp	r3, #0
 800b8fc:	d119      	bne.n	800b932 <sendMessage+0x1f2>
			{
				result = sendData(CA_msg, tmp);
 800b8fe:	6878      	ldr	r0, [r7, #4]
 800b900:	69f9      	ldr	r1, [r7, #28]
 800b902:	f7ff fc97 	bl	800b234 <sendData>
 800b906:	4603      	mov	r3, r0
 800b908:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
				if(result != RC_SUCCESS )
 800b90c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800b910:	2b00      	cmp	r3, #0
 800b912:	d003      	beq.n	800b91c <sendMessage+0x1dc>
					sendAbort(CA_msg, 0);
 800b914:	6878      	ldr	r0, [r7, #4]
 800b916:	2100      	movs	r1, #0
 800b918:	f7ff fe9c 	bl	800b654 <sendAbort>
				if(tmp != NULL)
 800b91c:	69fb      	ldr	r3, [r7, #28]
 800b91e:	2b00      	cmp	r3, #0
 800b920:	d004      	beq.n	800b92c <sendMessage+0x1ec>
				{
					free(tmp);
 800b922:	69f8      	ldr	r0, [r7, #28]
 800b924:	f013 fbfe 	bl	801f124 <free>
					tmp = NULL;
 800b928:	2300      	movs	r3, #0
 800b92a:	61fb      	str	r3, [r7, #28]
				}
				return result;
 800b92c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800b930:	e02b      	b.n	800b98a <sendMessage+0x24a>
			}
			else if(result == RC_TIMEOUT)
 800b932:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800b936:	2b0b      	cmp	r3, #11
 800b938:	d10e      	bne.n	800b958 <sendMessage+0x218>
			{
				if(tmp != NULL)
 800b93a:	69fb      	ldr	r3, [r7, #28]
 800b93c:	2b00      	cmp	r3, #0
 800b93e:	d004      	beq.n	800b94a <sendMessage+0x20a>
				{
					free(tmp);
 800b940:	69f8      	ldr	r0, [r7, #28]
 800b942:	f013 fbef 	bl	801f124 <free>
					tmp = NULL;
 800b946:	2300      	movs	r3, #0
 800b948:	61fb      	str	r3, [r7, #28]
				}
				sendAbort(CA_msg,0);
 800b94a:	6878      	ldr	r0, [r7, #4]
 800b94c:	2100      	movs	r1, #0
 800b94e:	f7ff fe81 	bl	800b654 <sendAbort>
				return result;
 800b952:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800b956:	e018      	b.n	800b98a <sendMessage+0x24a>
			}
			else if(result == RC_CANNOTTRANSMIT)
 800b958:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800b95c:	2b0a      	cmp	r3, #10
 800b95e:	d10a      	bne.n	800b976 <sendMessage+0x236>
			{
				if(tmp != NULL)
 800b960:	69fb      	ldr	r3, [r7, #28]
 800b962:	2b00      	cmp	r3, #0
 800b964:	d004      	beq.n	800b970 <sendMessage+0x230>
				{
					free(tmp);
 800b966:	69f8      	ldr	r0, [r7, #28]
 800b968:	f013 fbdc 	bl	801f124 <free>
					tmp = NULL;
 800b96c:	2300      	movs	r3, #0
 800b96e:	61fb      	str	r3, [r7, #28]
				}
				return result;
 800b970:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800b974:	e009      	b.n	800b98a <sendMessage+0x24a>
			}
		}

		if(tmp != NULL)
 800b976:	69fb      	ldr	r3, [r7, #28]
 800b978:	2b00      	cmp	r3, #0
 800b97a:	d004      	beq.n	800b986 <sendMessage+0x246>
		{
			free(tmp);
 800b97c:	69f8      	ldr	r0, [r7, #28]
 800b97e:	f013 fbd1 	bl	801f124 <free>
			tmp = NULL;
 800b982:	2300      	movs	r3, #0
 800b984:	61fb      	str	r3, [r7, #28]
		}
	}
	return result;
 800b986:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
}
 800b98a:	4618      	mov	r0, r3
 800b98c:	3728      	adds	r7, #40	; 0x28
 800b98e:	46bd      	mov	sp, r7
 800b990:	bd80      	pop	{r7, pc}
 800b992:	bf00      	nop
 800b994:	20012218 	.word	0x20012218
 800b998:	40080000 	.word	0x40080000
 800b99c:	401c0000 	.word	0x401c0000

0800b9a0 <checkRes>:


unsigned char checkRes()
{
 800b9a0:	b480      	push	{r7}
 800b9a2:	af00      	add	r7, sp, #0
	return RC_SUCCESS;
 800b9a4:	2300      	movs	r3, #0
}
 800b9a6:	4618      	mov	r0, r3
 800b9a8:	46bd      	mov	sp, r7
 800b9aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9ae:	4770      	bx	lr

0800b9b0 <sendCTS>:

unsigned char sendCTS(J1939_msg_t j1939_msg,CA_Msg_t CA_msg,unsigned int startnum,unsigned int num)
{
 800b9b0:	b580      	push	{r7, lr}
 800b9b2:	b08a      	sub	sp, #40	; 0x28
 800b9b4:	af00      	add	r7, sp, #0
 800b9b6:	60f8      	str	r0, [r7, #12]
 800b9b8:	60b9      	str	r1, [r7, #8]
 800b9ba:	607a      	str	r2, [r7, #4]
 800b9bc:	603b      	str	r3, [r7, #0]
	struct J1939_msg temp_msg;
	unsigned char result;
	temp_msg.DataLength = j1939_msg->DataLength;
 800b9be:	68fb      	ldr	r3, [r7, #12]
 800b9c0:	791b      	ldrb	r3, [r3, #4]
 800b9c2:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800b9c6:	b2da      	uxtb	r2, r3
 800b9c8:	7e3b      	ldrb	r3, [r7, #24]
 800b9ca:	f362 0303 	bfi	r3, r2, #0, #4
 800b9ce:	763b      	strb	r3, [r7, #24]
	temp_msg.DataPage = j1939_msg->DataPage;
 800b9d0:	68fb      	ldr	r3, [r7, #12]
 800b9d2:	781b      	ldrb	r3, [r3, #0]
 800b9d4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800b9d8:	b2da      	uxtb	r2, r3
 800b9da:	7d3b      	ldrb	r3, [r7, #20]
 800b9dc:	f362 03c3 	bfi	r3, r2, #3, #1
 800b9e0:	753b      	strb	r3, [r7, #20]
	temp_msg.edp = j1939_msg->edp;
 800b9e2:	68fb      	ldr	r3, [r7, #12]
 800b9e4:	781b      	ldrb	r3, [r3, #0]
 800b9e6:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800b9ea:	b2da      	uxtb	r2, r3
 800b9ec:	7d3b      	ldrb	r3, [r7, #20]
 800b9ee:	f362 1304 	bfi	r3, r2, #4, #1
 800b9f2:	753b      	strb	r3, [r7, #20]
	temp_msg.PDUFormat = j1939_msg->PDUFormat;
 800b9f4:	68fb      	ldr	r3, [r7, #12]
 800b9f6:	785b      	ldrb	r3, [r3, #1]
 800b9f8:	757b      	strb	r3, [r7, #21]
	temp_msg.PDUSpecific = j1939_msg->SourceAddress;
 800b9fa:	68fb      	ldr	r3, [r7, #12]
 800b9fc:	78db      	ldrb	r3, [r3, #3]
 800b9fe:	75bb      	strb	r3, [r7, #22]
	temp_msg.Priority = j1939_msg->Priority;
 800ba00:	68fb      	ldr	r3, [r7, #12]
 800ba02:	781b      	ldrb	r3, [r3, #0]
 800ba04:	f3c3 1342 	ubfx	r3, r3, #5, #3
 800ba08:	b2da      	uxtb	r2, r3
 800ba0a:	7d3b      	ldrb	r3, [r7, #20]
 800ba0c:	f362 1347 	bfi	r3, r2, #5, #3
 800ba10:	753b      	strb	r3, [r7, #20]
	temp_msg.SourceAddress = j1939_msg->PDUSpecific;
 800ba12:	68fb      	ldr	r3, [r7, #12]
 800ba14:	789b      	ldrb	r3, [r3, #2]
 800ba16:	75fb      	strb	r3, [r7, #23]
	temp_msg.Data[0] = J1939_CTS_CONTROL_BYTE;
 800ba18:	2311      	movs	r3, #17
 800ba1a:	767b      	strb	r3, [r7, #25]
	if(j1939_msg->Data[4] < j1939_msg->Data[3])
		temp_msg.Data[1] = j1939_msg->Data[4];
	else
		temp_msg.Data[1] = j1939_msg->Data[3];
#endif
	temp_msg.Data[1] = num;
 800ba1c:	683b      	ldr	r3, [r7, #0]
 800ba1e:	b2db      	uxtb	r3, r3
 800ba20:	76bb      	strb	r3, [r7, #26]
	temp_msg.Data[2] = startnum;
 800ba22:	687b      	ldr	r3, [r7, #4]
 800ba24:	b2db      	uxtb	r3, r3
 800ba26:	76fb      	strb	r3, [r7, #27]
	temp_msg.Data[3] = 0xff;
 800ba28:	23ff      	movs	r3, #255	; 0xff
 800ba2a:	773b      	strb	r3, [r7, #28]
	temp_msg.Data[4] = 0xff;
 800ba2c:	23ff      	movs	r3, #255	; 0xff
 800ba2e:	777b      	strb	r3, [r7, #29]
	temp_msg.Data[5] = CA_msg->cm.DTPS;
 800ba30:	68bb      	ldr	r3, [r7, #8]
 800ba32:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800ba36:	77bb      	strb	r3, [r7, #30]
	temp_msg.Data[6] = CA_msg->cm.DTPF;
 800ba38:	68bb      	ldr	r3, [r7, #8]
 800ba3a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800ba3e:	77fb      	strb	r3, [r7, #31]
	temp_msg.Data[7] = CA_msg->cm.DTDP;
 800ba40:	68bb      	ldr	r3, [r7, #8]
 800ba42:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 800ba46:	f887 3020 	strb.w	r3, [r7, #32]
	
	if(writeCan(&temp_msg) == RC_SUCCESS)
 800ba4a:	f107 0314 	add.w	r3, r7, #20
 800ba4e:	4618      	mov	r0, r3
 800ba50:	f001 f820 	bl	800ca94 <writeCan>
 800ba54:	4603      	mov	r3, r0
 800ba56:	2b00      	cmp	r3, #0
 800ba58:	d111      	bne.n	800ba7e <sendCTS+0xce>
	{
		CA_msg->cm.t2.en = 1;
 800ba5a:	68bb      	ldr	r3, [r7, #8]
 800ba5c:	2201      	movs	r2, #1
 800ba5e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
		CA_msg->cm.t2.release = 0;
 800ba62:	68bb      	ldr	r3, [r7, #8]
 800ba64:	2200      	movs	r2, #0
 800ba66:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
		CA_msg->cm.t2.value = T2TIMEOUT;
 800ba6a:	68bb      	ldr	r3, [r7, #8]
 800ba6c:	f240 42e2 	movw	r2, #1250	; 0x4e2
 800ba70:	855a      	strh	r2, [r3, #42]	; 0x2a
		return result = RC_SUCCESS;
 800ba72:	2300      	movs	r3, #0
 800ba74:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800ba78:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800ba7c:	e004      	b.n	800ba88 <sendCTS+0xd8>
	}
	else
		return result = RC_CANNOTTRANSMIT;
 800ba7e:	230a      	movs	r3, #10
 800ba80:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800ba84:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 800ba88:	4618      	mov	r0, r3
 800ba8a:	3728      	adds	r7, #40	; 0x28
 800ba8c:	46bd      	mov	sp, r7
 800ba8e:	bd80      	pop	{r7, pc}

0800ba90 <response_RTS>:

unsigned char response_RTS(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 800ba90:	b580      	push	{r7, lr}
 800ba92:	b084      	sub	sp, #16
 800ba94:	af00      	add	r7, sp, #0
 800ba96:	6078      	str	r0, [r7, #4]
 800ba98:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 800ba9a:	2300      	movs	r3, #0
 800ba9c:	73fb      	strb	r3, [r7, #15]
	
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 800ba9e:	687b      	ldr	r3, [r7, #4]
 800baa0:	789b      	ldrb	r3, [r3, #2]
 800baa2:	2bff      	cmp	r3, #255	; 0xff
 800baa4:	d103      	bne.n	800baae <response_RTS+0x1e>
		return result = RC_ERROR;
 800baa6:	2301      	movs	r3, #1
 800baa8:	73fb      	strb	r3, [r7, #15]
 800baaa:	7bfb      	ldrb	r3, [r7, #15]
 800baac:	e04f      	b.n	800bb4e <response_RTS+0xbe>
	if(checkRes() == RC_SUCCESS && CA_msg->cm.cm_lock == 0)
 800baae:	f7ff ff77 	bl	800b9a0 <checkRes>
 800bab2:	4603      	mov	r3, r0
 800bab4:	2b00      	cmp	r3, #0
 800bab6:	d147      	bne.n	800bb48 <response_RTS+0xb8>
 800bab8:	683b      	ldr	r3, [r7, #0]
 800baba:	7f1b      	ldrb	r3, [r3, #28]
 800babc:	2b00      	cmp	r3, #0
 800babe:	d143      	bne.n	800bb48 <response_RTS+0xb8>
	{
		rt_kprintf("receive rts packets = %d\r\n", j1939_msg->Data[3]);
 800bac0:	687b      	ldr	r3, [r7, #4]
 800bac2:	7a1b      	ldrb	r3, [r3, #8]
 800bac4:	4824      	ldr	r0, [pc, #144]	; (800bb58 <response_RTS+0xc8>)
 800bac6:	4619      	mov	r1, r3
 800bac8:	f008 f8d2 	bl	8013c70 <rt_kprintf>
		CA_msg->cm.rcvpackets = j1939_msg->Data[3];
 800bacc:	687b      	ldr	r3, [r7, #4]
 800bace:	7a1b      	ldrb	r3, [r3, #8]
 800bad0:	b29a      	uxth	r2, r3
 800bad2:	683b      	ldr	r3, [r7, #0]
 800bad4:	86da      	strh	r2, [r3, #54]	; 0x36
		CA_msg->cm.rcvbytes = j1939_msg->Data[2]*256+j1939_msg->Data[1];
 800bad6:	687b      	ldr	r3, [r7, #4]
 800bad8:	79db      	ldrb	r3, [r3, #7]
 800bada:	b29b      	uxth	r3, r3
 800badc:	021b      	lsls	r3, r3, #8
 800bade:	b29a      	uxth	r2, r3
 800bae0:	687b      	ldr	r3, [r7, #4]
 800bae2:	799b      	ldrb	r3, [r3, #6]
 800bae4:	b29b      	uxth	r3, r3
 800bae6:	4413      	add	r3, r2
 800bae8:	b29a      	uxth	r2, r3
 800baea:	683b      	ldr	r3, [r7, #0]
 800baec:	871a      	strh	r2, [r3, #56]	; 0x38
		CA_msg->rcvdata = (unsigned char *)malloc(7 * CA_msg->cm.rcvpackets);
 800baee:	683b      	ldr	r3, [r7, #0]
 800baf0:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800baf2:	461a      	mov	r2, r3
 800baf4:	4613      	mov	r3, r2
 800baf6:	00db      	lsls	r3, r3, #3
 800baf8:	1a9b      	subs	r3, r3, r2
 800bafa:	4618      	mov	r0, r3
 800bafc:	f013 fb0a 	bl	801f114 <malloc>
 800bb00:	4603      	mov	r3, r0
 800bb02:	461a      	mov	r2, r3
 800bb04:	683b      	ldr	r3, [r7, #0]
 800bb06:	655a      	str	r2, [r3, #84]	; 0x54
		CA_msg->cm.DTDP = j1939_msg->DataPage;
 800bb08:	687b      	ldr	r3, [r7, #4]
 800bb0a:	781b      	ldrb	r3, [r3, #0]
 800bb0c:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800bb10:	b2db      	uxtb	r3, r3
 800bb12:	461a      	mov	r2, r3
 800bb14:	683b      	ldr	r3, [r7, #0]
 800bb16:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
		CA_msg->cm.DTPF = j1939_msg->PDUFormat;
 800bb1a:	687b      	ldr	r3, [r7, #4]
 800bb1c:	785a      	ldrb	r2, [r3, #1]
 800bb1e:	683b      	ldr	r3, [r7, #0]
 800bb20:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
		CA_msg->cm.DTPS = j1939_msg->PDUSpecific;
 800bb24:	687b      	ldr	r3, [r7, #4]
 800bb26:	789a      	ldrb	r2, [r3, #2]
 800bb28:	683b      	ldr	r3, [r7, #0]
 800bb2a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
				sendCTS(j1939_msg,CA_msg,1,j1939_msg->Data[3] );
			else 
				sendCTS(j1939_msg,CA_msg,1,8);
		#endif 
		
		sendCTS(j1939_msg,CA_msg,1,1);
 800bb2e:	6878      	ldr	r0, [r7, #4]
 800bb30:	6839      	ldr	r1, [r7, #0]
 800bb32:	2201      	movs	r2, #1
 800bb34:	2301      	movs	r3, #1
 800bb36:	f7ff ff3b 	bl	800b9b0 <sendCTS>
		CA_msg->cm.cm_lock = 1;
 800bb3a:	683b      	ldr	r3, [r7, #0]
 800bb3c:	2201      	movs	r2, #1
 800bb3e:	771a      	strb	r2, [r3, #28]
		return result = RC_SUCCESS;
 800bb40:	2300      	movs	r3, #0
 800bb42:	73fb      	strb	r3, [r7, #15]
 800bb44:	7bfb      	ldrb	r3, [r7, #15]
 800bb46:	e002      	b.n	800bb4e <response_RTS+0xbe>
	}
	return result = RC_ERROR;
 800bb48:	2301      	movs	r3, #1
 800bb4a:	73fb      	strb	r3, [r7, #15]
 800bb4c:	7bfb      	ldrb	r3, [r7, #15]
}
 800bb4e:	4618      	mov	r0, r3
 800bb50:	3710      	adds	r7, #16
 800bb52:	46bd      	mov	sp, r7
 800bb54:	bd80      	pop	{r7, pc}
 800bb56:	bf00      	nop
 800bb58:	080225c0 	.word	0x080225c0

0800bb5c <response_CTS>:


unsigned char response_CTS(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 800bb5c:	b580      	push	{r7, lr}
 800bb5e:	b084      	sub	sp, #16
 800bb60:	af00      	add	r7, sp, #0
 800bb62:	6078      	str	r0, [r7, #4]
 800bb64:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 800bb66:	2300      	movs	r3, #0
 800bb68:	73fb      	strb	r3, [r7, #15]
	static struct q_Message q_msg;
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 800bb6a:	687b      	ldr	r3, [r7, #4]
 800bb6c:	789b      	ldrb	r3, [r3, #2]
 800bb6e:	2bff      	cmp	r3, #255	; 0xff
 800bb70:	d103      	bne.n	800bb7a <response_CTS+0x1e>
		return result = RC_ERROR;
 800bb72:	2301      	movs	r3, #1
 800bb74:	73fb      	strb	r3, [r7, #15]
 800bb76:	7bfb      	ldrb	r3, [r7, #15]
 800bb78:	e045      	b.n	800bc06 <response_CTS+0xaa>
	if(CA_msg->cm.t3.en == 0 && CA_msg->cm.t4.en == 0)
 800bb7a:	683b      	ldr	r3, [r7, #0]
 800bb7c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800bb80:	2b00      	cmp	r3, #0
 800bb82:	d108      	bne.n	800bb96 <response_CTS+0x3a>
 800bb84:	683b      	ldr	r3, [r7, #0]
 800bb86:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800bb8a:	2b00      	cmp	r3, #0
 800bb8c:	d103      	bne.n	800bb96 <response_CTS+0x3a>
		return result = RC_ERROR;
 800bb8e:	2301      	movs	r3, #1
 800bb90:	73fb      	strb	r3, [r7, #15]
 800bb92:	7bfb      	ldrb	r3, [r7, #15]
 800bb94:	e037      	b.n	800bc06 <response_CTS+0xaa>
	CA_msg->cm.t3.release = 1;
 800bb96:	683b      	ldr	r3, [r7, #0]
 800bb98:	2201      	movs	r2, #1
 800bb9a:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	CA_msg->cm.t4.release = 1;
 800bb9e:	683b      	ldr	r3, [r7, #0]
 800bba0:	2201      	movs	r2, #1
 800bba2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
	if(j1939_msg->Data[1] == 0 && j1939_msg->Data[2] == 255)
 800bba6:	687b      	ldr	r3, [r7, #4]
 800bba8:	799b      	ldrb	r3, [r3, #6]
 800bbaa:	2b00      	cmp	r3, #0
 800bbac:	d113      	bne.n	800bbd6 <response_CTS+0x7a>
 800bbae:	687b      	ldr	r3, [r7, #4]
 800bbb0:	79db      	ldrb	r3, [r3, #7]
 800bbb2:	2bff      	cmp	r3, #255	; 0xff
 800bbb4:	d10f      	bne.n	800bbd6 <response_CTS+0x7a>
	{
		CA_msg->cm.t4.en = 1;
 800bbb6:	683b      	ldr	r3, [r7, #0]
 800bbb8:	2201      	movs	r2, #1
 800bbba:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
		CA_msg->cm.t4.release = 0;
 800bbbe:	683b      	ldr	r3, [r7, #0]
 800bbc0:	2200      	movs	r2, #0
 800bbc2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
		CA_msg->cm.t4.value = 1050;
 800bbc6:	683b      	ldr	r3, [r7, #0]
 800bbc8:	f240 421a 	movw	r2, #1050	; 0x41a
 800bbcc:	865a      	strh	r2, [r3, #50]	; 0x32
		return result = RC_ERROR;
 800bbce:	2301      	movs	r3, #1
 800bbd0:	73fb      	strb	r3, [r7, #15]
 800bbd2:	7bfb      	ldrb	r3, [r7, #15]
 800bbd4:	e017      	b.n	800bc06 <response_CTS+0xaa>
	}
	else
	{
		q_msg.nextnum = j1939_msg->Data[2];
 800bbd6:	687b      	ldr	r3, [r7, #4]
 800bbd8:	79db      	ldrb	r3, [r3, #7]
 800bbda:	b29a      	uxth	r2, r3
 800bbdc:	4b0c      	ldr	r3, [pc, #48]	; (800bc10 <response_CTS+0xb4>)
 800bbde:	801a      	strh	r2, [r3, #0]
		q_msg.sendnum = j1939_msg->Data[1];
 800bbe0:	687b      	ldr	r3, [r7, #4]
 800bbe2:	799b      	ldrb	r3, [r3, #6]
 800bbe4:	b29a      	uxth	r2, r3
 800bbe6:	4b0a      	ldr	r3, [pc, #40]	; (800bc10 <response_CTS+0xb4>)
 800bbe8:	805a      	strh	r2, [r3, #2]
		q_msg.timeout = 0;
 800bbea:	4b09      	ldr	r3, [pc, #36]	; (800bc10 <response_CTS+0xb4>)
 800bbec:	2200      	movs	r2, #0
 800bbee:	809a      	strh	r2, [r3, #4]
		osMessagePut(CA_msg->txq,(unsigned long)&q_msg, 0);
 800bbf0:	683b      	ldr	r3, [r7, #0]
 800bbf2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800bbf4:	4a06      	ldr	r2, [pc, #24]	; (800bc10 <response_CTS+0xb4>)
 800bbf6:	4618      	mov	r0, r3
 800bbf8:	4611      	mov	r1, r2
 800bbfa:	2200      	movs	r2, #0
 800bbfc:	f00a f98c 	bl	8015f18 <osMessagePut>
		return result = RC_SUCCESS;
 800bc00:	2300      	movs	r3, #0
 800bc02:	73fb      	strb	r3, [r7, #15]
 800bc04:	7bfb      	ldrb	r3, [r7, #15]
	}
}
 800bc06:	4618      	mov	r0, r3
 800bc08:	3710      	adds	r7, #16
 800bc0a:	46bd      	mov	sp, r7
 800bc0c:	bd80      	pop	{r7, pc}
 800bc0e:	bf00      	nop
 800bc10:	200107b0 	.word	0x200107b0

0800bc14 <sendEndofMsgACK>:
unsigned char sendEndofMsgACK(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 800bc14:	b580      	push	{r7, lr}
 800bc16:	b088      	sub	sp, #32
 800bc18:	af00      	add	r7, sp, #0
 800bc1a:	6078      	str	r0, [r7, #4]
 800bc1c:	6039      	str	r1, [r7, #0]
	struct J1939_msg temp_j1939;
	struct J1939_CM *tempCm;
	
	temp_j1939.DataLength = 8;
 800bc1e:	7c3b      	ldrb	r3, [r7, #16]
 800bc20:	2208      	movs	r2, #8
 800bc22:	f362 0303 	bfi	r3, r2, #0, #4
 800bc26:	743b      	strb	r3, [r7, #16]
	temp_j1939.DataPage = 0;
 800bc28:	7b3b      	ldrb	r3, [r7, #12]
 800bc2a:	f36f 03c3 	bfc	r3, #3, #1
 800bc2e:	733b      	strb	r3, [r7, #12]
	temp_j1939.edp = 0;
 800bc30:	7b3b      	ldrb	r3, [r7, #12]
 800bc32:	f36f 1304 	bfc	r3, #4, #1
 800bc36:	733b      	strb	r3, [r7, #12]
	temp_j1939.PDUFormat = J1939_PF_TP_CM;
 800bc38:	23ec      	movs	r3, #236	; 0xec
 800bc3a:	737b      	strb	r3, [r7, #13]
	temp_j1939.PDUSpecific = j1939_msg->SourceAddress;
 800bc3c:	687b      	ldr	r3, [r7, #4]
 800bc3e:	78db      	ldrb	r3, [r3, #3]
 800bc40:	73bb      	strb	r3, [r7, #14]
	temp_j1939.Priority = 7;
 800bc42:	7b3b      	ldrb	r3, [r7, #12]
 800bc44:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 800bc48:	733b      	strb	r3, [r7, #12]
	temp_j1939.SourceAddress = j1939_msg->PDUSpecific;
 800bc4a:	687b      	ldr	r3, [r7, #4]
 800bc4c:	789b      	ldrb	r3, [r3, #2]
 800bc4e:	73fb      	strb	r3, [r7, #15]
	temp_j1939.Data[0] = J1939_EOMACK_CONTROL_BYTE;
 800bc50:	2313      	movs	r3, #19
 800bc52:	747b      	strb	r3, [r7, #17]
	temp_j1939.Data[1] = CA_msg->cm.rcvbytes % 256;
 800bc54:	683b      	ldr	r3, [r7, #0]
 800bc56:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800bc58:	b2db      	uxtb	r3, r3
 800bc5a:	74bb      	strb	r3, [r7, #18]
	temp_j1939.Data[2] = CA_msg->cm.rcvbytes / 256;
 800bc5c:	683b      	ldr	r3, [r7, #0]
 800bc5e:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800bc60:	0a1b      	lsrs	r3, r3, #8
 800bc62:	b29b      	uxth	r3, r3
 800bc64:	b2db      	uxtb	r3, r3
 800bc66:	74fb      	strb	r3, [r7, #19]
	temp_j1939.Data[3] = CA_msg->cm.rcvpackets;
 800bc68:	683b      	ldr	r3, [r7, #0]
 800bc6a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800bc6c:	b2db      	uxtb	r3, r3
 800bc6e:	753b      	strb	r3, [r7, #20]
	temp_j1939.Data[4] = 0xff;
 800bc70:	23ff      	movs	r3, #255	; 0xff
 800bc72:	757b      	strb	r3, [r7, #21]
	temp_j1939.Data[5] = j1939_msg->Data[5];
 800bc74:	687b      	ldr	r3, [r7, #4]
 800bc76:	7a9b      	ldrb	r3, [r3, #10]
 800bc78:	75bb      	strb	r3, [r7, #22]
	temp_j1939.Data[6] = j1939_msg->Data[6];
 800bc7a:	687b      	ldr	r3, [r7, #4]
 800bc7c:	7adb      	ldrb	r3, [r3, #11]
 800bc7e:	75fb      	strb	r3, [r7, #23]
	temp_j1939.Data[7] = j1939_msg->Data[7];
 800bc80:	687b      	ldr	r3, [r7, #4]
 800bc82:	7b1b      	ldrb	r3, [r3, #12]
 800bc84:	763b      	strb	r3, [r7, #24]
	CA_msg->cm.cm_lock = 0;
 800bc86:	683b      	ldr	r3, [r7, #0]
 800bc88:	2200      	movs	r2, #0
 800bc8a:	771a      	strb	r2, [r3, #28]
	if(CA_msg->rcvdata != NULL)
 800bc8c:	683b      	ldr	r3, [r7, #0]
 800bc8e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800bc90:	2b00      	cmp	r3, #0
 800bc92:	d007      	beq.n	800bca4 <sendEndofMsgACK+0x90>
	{
		free(CA_msg->rcvdata);
 800bc94:	683b      	ldr	r3, [r7, #0]
 800bc96:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800bc98:	4618      	mov	r0, r3
 800bc9a:	f013 fa43 	bl	801f124 <free>
		CA_msg->rcvdata = NULL;
 800bc9e:	683b      	ldr	r3, [r7, #0]
 800bca0:	2200      	movs	r2, #0
 800bca2:	655a      	str	r2, [r3, #84]	; 0x54
	}
	tempCm = &(CA_msg->cm);
 800bca4:	683b      	ldr	r3, [r7, #0]
 800bca6:	3316      	adds	r3, #22
 800bca8:	61fb      	str	r3, [r7, #28]
	memset(tempCm,0,sizeof(struct J1939_CM));
 800bcaa:	69f8      	ldr	r0, [r7, #28]
 800bcac:	2100      	movs	r1, #0
 800bcae:	222a      	movs	r2, #42	; 0x2a
 800bcb0:	f013 fa40 	bl	801f134 <memset>
	return writeCan(&temp_j1939);
 800bcb4:	f107 030c 	add.w	r3, r7, #12
 800bcb8:	4618      	mov	r0, r3
 800bcba:	f000 feeb 	bl	800ca94 <writeCan>
 800bcbe:	4603      	mov	r3, r0
}
 800bcc0:	4618      	mov	r0, r3
 800bcc2:	3720      	adds	r7, #32
 800bcc4:	46bd      	mov	sp, r7
 800bcc6:	bd80      	pop	{r7, pc}

0800bcc8 <receiveData>:

void receiveData(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 800bcc8:	b580      	push	{r7, lr}
 800bcca:	b084      	sub	sp, #16
 800bccc:	af00      	add	r7, sp, #0
 800bcce:	6078      	str	r0, [r7, #4]
 800bcd0:	6039      	str	r1, [r7, #0]
	unsigned char i;
	static struct rx_Message rxmsg,bamrxmsg;
	unsigned short j;
	if((j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS) )
 800bcd2:	687b      	ldr	r3, [r7, #4]
 800bcd4:	789b      	ldrb	r3, [r3, #2]
 800bcd6:	2bff      	cmp	r3, #255	; 0xff
 800bcd8:	f040 8092 	bne.w	800be00 <receiveData+0x138>
	{
		if((CA_msg->bam.cm_lock == 1) && (CA_msg->bamrcvdata != NULL))
 800bcdc:	683b      	ldr	r3, [r7, #0]
 800bcde:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800bce2:	2b01      	cmp	r3, #1
 800bce4:	f040 8143 	bne.w	800bf6e <receiveData+0x2a6>
 800bce8:	683b      	ldr	r3, [r7, #0]
 800bcea:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800bcec:	2b00      	cmp	r3, #0
 800bcee:	f000 813e 	beq.w	800bf6e <receiveData+0x2a6>
		{
			CA_msg->bam.t1.en = 1;
 800bcf2:	683b      	ldr	r3, [r7, #0]
 800bcf4:	2201      	movs	r2, #1
 800bcf6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			CA_msg->bam.t1.release = 1;
 800bcfa:	683b      	ldr	r3, [r7, #0]
 800bcfc:	2201      	movs	r2, #1
 800bcfe:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			CA_msg->bam.t1.value = 0;
 800bd02:	683b      	ldr	r3, [r7, #0]
 800bd04:	2200      	movs	r2, #0
 800bd06:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42

				
			for(i=1;i<j1939_msg->DataLength;i++)
 800bd0a:	2301      	movs	r3, #1
 800bd0c:	73fb      	strb	r3, [r7, #15]
 800bd0e:	e013      	b.n	800bd38 <receiveData+0x70>
			{
				CA_msg->bamrcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
 800bd10:	683b      	ldr	r3, [r7, #0]
 800bd12:	6d99      	ldr	r1, [r3, #88]	; 0x58
 800bd14:	687b      	ldr	r3, [r7, #4]
 800bd16:	795b      	ldrb	r3, [r3, #5]
 800bd18:	1e5a      	subs	r2, r3, #1
 800bd1a:	4613      	mov	r3, r2
 800bd1c:	00db      	lsls	r3, r3, #3
 800bd1e:	1a9a      	subs	r2, r3, r2
 800bd20:	7bfb      	ldrb	r3, [r7, #15]
 800bd22:	4413      	add	r3, r2
 800bd24:	3b01      	subs	r3, #1
 800bd26:	440b      	add	r3, r1
 800bd28:	7bfa      	ldrb	r2, [r7, #15]
 800bd2a:	6879      	ldr	r1, [r7, #4]
 800bd2c:	440a      	add	r2, r1
 800bd2e:	7952      	ldrb	r2, [r2, #5]
 800bd30:	701a      	strb	r2, [r3, #0]
			CA_msg->bam.t1.en = 1;
			CA_msg->bam.t1.release = 1;
			CA_msg->bam.t1.value = 0;

				
			for(i=1;i<j1939_msg->DataLength;i++)
 800bd32:	7bfb      	ldrb	r3, [r7, #15]
 800bd34:	3301      	adds	r3, #1
 800bd36:	73fb      	strb	r3, [r7, #15]
 800bd38:	7bfb      	ldrb	r3, [r7, #15]
 800bd3a:	687a      	ldr	r2, [r7, #4]
 800bd3c:	7912      	ldrb	r2, [r2, #4]
 800bd3e:	f3c2 0203 	ubfx	r2, r2, #0, #4
 800bd42:	b2d2      	uxtb	r2, r2
 800bd44:	4293      	cmp	r3, r2
 800bd46:	dbe3      	blt.n	800bd10 <receiveData+0x48>
			{
				CA_msg->bamrcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
			}
			
			if(j1939_msg->Data[0] >= CA_msg->bam.rcvpackets)
 800bd48:	687b      	ldr	r3, [r7, #4]
 800bd4a:	795b      	ldrb	r3, [r3, #5]
 800bd4c:	b29a      	uxth	r2, r3
 800bd4e:	683b      	ldr	r3, [r7, #0]
 800bd50:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800bd54:	429a      	cmp	r2, r3
 800bd56:	d345      	bcc.n	800bde4 <receiveData+0x11c>
			{
				bamrxmsg.data = CA_msg->bamrcvdata;
 800bd58:	683b      	ldr	r3, [r7, #0]
 800bd5a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800bd5c:	4a85      	ldr	r2, [pc, #532]	; (800bf74 <receiveData+0x2ac>)
 800bd5e:	6013      	str	r3, [r2, #0]
				j = 7 * CA_msg->bam.rcvpackets - 1;
 800bd60:	683b      	ldr	r3, [r7, #0]
 800bd62:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800bd66:	461a      	mov	r2, r3
 800bd68:	00d2      	lsls	r2, r2, #3
 800bd6a:	1ad3      	subs	r3, r2, r3
 800bd6c:	b29b      	uxth	r3, r3
 800bd6e:	3b01      	subs	r3, #1
 800bd70:	81bb      	strh	r3, [r7, #12]
				while(bamrxmsg.data[j] == 0xff)
 800bd72:	e002      	b.n	800bd7a <receiveData+0xb2>
					j--;
 800bd74:	89bb      	ldrh	r3, [r7, #12]
 800bd76:	3b01      	subs	r3, #1
 800bd78:	81bb      	strh	r3, [r7, #12]
			
			if(j1939_msg->Data[0] >= CA_msg->bam.rcvpackets)
			{
				bamrxmsg.data = CA_msg->bamrcvdata;
				j = 7 * CA_msg->bam.rcvpackets - 1;
				while(bamrxmsg.data[j] == 0xff)
 800bd7a:	4b7e      	ldr	r3, [pc, #504]	; (800bf74 <receiveData+0x2ac>)
 800bd7c:	681a      	ldr	r2, [r3, #0]
 800bd7e:	89bb      	ldrh	r3, [r7, #12]
 800bd80:	4413      	add	r3, r2
 800bd82:	781b      	ldrb	r3, [r3, #0]
 800bd84:	2bff      	cmp	r3, #255	; 0xff
 800bd86:	d0f5      	beq.n	800bd74 <receiveData+0xac>
					j--;
				bamrxmsg.dp = bamrxmsg.data[j];
 800bd88:	4b7a      	ldr	r3, [pc, #488]	; (800bf74 <receiveData+0x2ac>)
 800bd8a:	681a      	ldr	r2, [r3, #0]
 800bd8c:	89bb      	ldrh	r3, [r7, #12]
 800bd8e:	4413      	add	r3, r2
 800bd90:	781a      	ldrb	r2, [r3, #0]
 800bd92:	4b78      	ldr	r3, [pc, #480]	; (800bf74 <receiveData+0x2ac>)
 800bd94:	721a      	strb	r2, [r3, #8]
				bamrxmsg.PF = bamrxmsg.data[j-1];
 800bd96:	4b77      	ldr	r3, [pc, #476]	; (800bf74 <receiveData+0x2ac>)
 800bd98:	681a      	ldr	r2, [r3, #0]
 800bd9a:	89bb      	ldrh	r3, [r7, #12]
 800bd9c:	3b01      	subs	r3, #1
 800bd9e:	4413      	add	r3, r2
 800bda0:	781a      	ldrb	r2, [r3, #0]
 800bda2:	4b74      	ldr	r3, [pc, #464]	; (800bf74 <receiveData+0x2ac>)
 800bda4:	71da      	strb	r2, [r3, #7]
				bamrxmsg.PS = bamrxmsg.data[j-2];
 800bda6:	4b73      	ldr	r3, [pc, #460]	; (800bf74 <receiveData+0x2ac>)
 800bda8:	681a      	ldr	r2, [r3, #0]
 800bdaa:	89bb      	ldrh	r3, [r7, #12]
 800bdac:	3b02      	subs	r3, #2
 800bdae:	4413      	add	r3, r2
 800bdb0:	781a      	ldrb	r2, [r3, #0]
 800bdb2:	4b70      	ldr	r3, [pc, #448]	; (800bf74 <receiveData+0x2ac>)
 800bdb4:	719a      	strb	r2, [r3, #6]
				bamrxmsg.size = j-2;
 800bdb6:	89bb      	ldrh	r3, [r7, #12]
 800bdb8:	3b02      	subs	r3, #2
 800bdba:	b29a      	uxth	r2, r3
 800bdbc:	4b6d      	ldr	r3, [pc, #436]	; (800bf74 <receiveData+0x2ac>)
 800bdbe:	809a      	strh	r2, [r3, #4]
				rt_kprintf("\nbam receive %d data:\r\n", bamrxmsg.size);
 800bdc0:	4b6c      	ldr	r3, [pc, #432]	; (800bf74 <receiveData+0x2ac>)
 800bdc2:	889b      	ldrh	r3, [r3, #4]
 800bdc4:	486c      	ldr	r0, [pc, #432]	; (800bf78 <receiveData+0x2b0>)
 800bdc6:	4619      	mov	r1, r3
 800bdc8:	f007 ff52 	bl	8013c70 <rt_kprintf>
				bamAbort(CA_msg);
 800bdcc:	6838      	ldr	r0, [r7, #0]
 800bdce:	f000 fa4b 	bl	800c268 <bamAbort>
				osMessagePut(CA_msg->rxq, (unsigned long)&bamrxmsg, 0);
 800bdd2:	683b      	ldr	r3, [r7, #0]
 800bdd4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800bdd6:	4a67      	ldr	r2, [pc, #412]	; (800bf74 <receiveData+0x2ac>)
 800bdd8:	4618      	mov	r0, r3
 800bdda:	4611      	mov	r1, r2
 800bddc:	2200      	movs	r2, #0
 800bdde:	f00a f89b 	bl	8015f18 <osMessagePut>
 800bde2:	e0c4      	b.n	800bf6e <receiveData+0x2a6>
				*/

			}
			else
			{
					CA_msg->bam.t1.en = 1;
 800bde4:	683b      	ldr	r3, [r7, #0]
 800bde6:	2201      	movs	r2, #1
 800bde8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
					CA_msg->bam.t1.release = 0;
 800bdec:	683b      	ldr	r3, [r7, #0]
 800bdee:	2200      	movs	r2, #0
 800bdf0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
					CA_msg->bam.t1.value = T1TIMEOUT;
 800bdf4:	683b      	ldr	r3, [r7, #0]
 800bdf6:	f240 22ee 	movw	r2, #750	; 0x2ee
 800bdfa:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
 800bdfe:	e0b6      	b.n	800bf6e <receiveData+0x2a6>
		}

	}
	else
	{
		if((CA_msg->cm.cm_lock == 1) &&  (CA_msg->rcvdata != NULL))
 800be00:	683b      	ldr	r3, [r7, #0]
 800be02:	7f1b      	ldrb	r3, [r3, #28]
 800be04:	2b01      	cmp	r3, #1
 800be06:	f040 80b2 	bne.w	800bf6e <receiveData+0x2a6>
 800be0a:	683b      	ldr	r3, [r7, #0]
 800be0c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800be0e:	2b00      	cmp	r3, #0
 800be10:	f000 80ad 	beq.w	800bf6e <receiveData+0x2a6>
		{
		
			CA_msg->cm.t1.en = 1;
 800be14:	683b      	ldr	r3, [r7, #0]
 800be16:	2201      	movs	r2, #1
 800be18:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
			CA_msg->cm.t1.release = 1;
 800be1c:	683b      	ldr	r3, [r7, #0]
 800be1e:	2201      	movs	r2, #1
 800be20:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
			CA_msg->cm.t1.value = 0;
 800be24:	683b      	ldr	r3, [r7, #0]
 800be26:	2200      	movs	r2, #0
 800be28:	84da      	strh	r2, [r3, #38]	; 0x26


			CA_msg->cm.t2.en = 1;
 800be2a:	683b      	ldr	r3, [r7, #0]
 800be2c:	2201      	movs	r2, #1
 800be2e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
			CA_msg->cm.t2.release = 1;
 800be32:	683b      	ldr	r3, [r7, #0]
 800be34:	2201      	movs	r2, #1
 800be36:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
			CA_msg->cm.t2.value = 0;
 800be3a:	683b      	ldr	r3, [r7, #0]
 800be3c:	2200      	movs	r2, #0
 800be3e:	855a      	strh	r2, [r3, #42]	; 0x2a



			for(i=1;i<j1939_msg->DataLength;i++)
 800be40:	2301      	movs	r3, #1
 800be42:	73fb      	strb	r3, [r7, #15]
 800be44:	e013      	b.n	800be6e <receiveData+0x1a6>
			{
				CA_msg->rcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
 800be46:	683b      	ldr	r3, [r7, #0]
 800be48:	6d59      	ldr	r1, [r3, #84]	; 0x54
 800be4a:	687b      	ldr	r3, [r7, #4]
 800be4c:	795b      	ldrb	r3, [r3, #5]
 800be4e:	1e5a      	subs	r2, r3, #1
 800be50:	4613      	mov	r3, r2
 800be52:	00db      	lsls	r3, r3, #3
 800be54:	1a9a      	subs	r2, r3, r2
 800be56:	7bfb      	ldrb	r3, [r7, #15]
 800be58:	4413      	add	r3, r2
 800be5a:	3b01      	subs	r3, #1
 800be5c:	440b      	add	r3, r1
 800be5e:	7bfa      	ldrb	r2, [r7, #15]
 800be60:	6879      	ldr	r1, [r7, #4]
 800be62:	440a      	add	r2, r1
 800be64:	7952      	ldrb	r2, [r2, #5]
 800be66:	701a      	strb	r2, [r3, #0]
			CA_msg->cm.t2.release = 1;
			CA_msg->cm.t2.value = 0;



			for(i=1;i<j1939_msg->DataLength;i++)
 800be68:	7bfb      	ldrb	r3, [r7, #15]
 800be6a:	3301      	adds	r3, #1
 800be6c:	73fb      	strb	r3, [r7, #15]
 800be6e:	7bfb      	ldrb	r3, [r7, #15]
 800be70:	687a      	ldr	r2, [r7, #4]
 800be72:	7912      	ldrb	r2, [r2, #4]
 800be74:	f3c2 0203 	ubfx	r2, r2, #0, #4
 800be78:	b2d2      	uxtb	r2, r2
 800be7a:	4293      	cmp	r3, r2
 800be7c:	dbe3      	blt.n	800be46 <receiveData+0x17e>
			{
				CA_msg->rcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
			}

			rt_kprintf("Data[0] = %d, rcvpackets = %d\r\n", j1939_msg->Data[0], CA_msg->cm.rcvpackets);
 800be7e:	687b      	ldr	r3, [r7, #4]
 800be80:	795b      	ldrb	r3, [r3, #5]
 800be82:	461a      	mov	r2, r3
 800be84:	683b      	ldr	r3, [r7, #0]
 800be86:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800be88:	483c      	ldr	r0, [pc, #240]	; (800bf7c <receiveData+0x2b4>)
 800be8a:	4611      	mov	r1, r2
 800be8c:	461a      	mov	r2, r3
 800be8e:	f007 feef 	bl	8013c70 <rt_kprintf>


			if(j1939_msg->Data[0] >= CA_msg->cm.rcvpackets)
 800be92:	687b      	ldr	r3, [r7, #4]
 800be94:	795b      	ldrb	r3, [r3, #5]
 800be96:	b29a      	uxth	r2, r3
 800be98:	683b      	ldr	r3, [r7, #0]
 800be9a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800be9c:	429a      	cmp	r2, r3
 800be9e:	d345      	bcc.n	800bf2c <receiveData+0x264>
			{
				rxmsg.data = CA_msg->rcvdata;
 800bea0:	683b      	ldr	r3, [r7, #0]
 800bea2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800bea4:	4a36      	ldr	r2, [pc, #216]	; (800bf80 <receiveData+0x2b8>)
 800bea6:	6013      	str	r3, [r2, #0]
				j = 7 * CA_msg->cm.rcvpackets - 1;
 800bea8:	683b      	ldr	r3, [r7, #0]
 800beaa:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800beac:	461a      	mov	r2, r3
 800beae:	00d2      	lsls	r2, r2, #3
 800beb0:	1ad3      	subs	r3, r2, r3
 800beb2:	b29b      	uxth	r3, r3
 800beb4:	3b01      	subs	r3, #1
 800beb6:	81bb      	strh	r3, [r7, #12]
				while(rxmsg.data[j] == 0xff)
 800beb8:	e002      	b.n	800bec0 <receiveData+0x1f8>
					j--;
 800beba:	89bb      	ldrh	r3, [r7, #12]
 800bebc:	3b01      	subs	r3, #1
 800bebe:	81bb      	strh	r3, [r7, #12]

			if(j1939_msg->Data[0] >= CA_msg->cm.rcvpackets)
			{
				rxmsg.data = CA_msg->rcvdata;
				j = 7 * CA_msg->cm.rcvpackets - 1;
				while(rxmsg.data[j] == 0xff)
 800bec0:	4b2f      	ldr	r3, [pc, #188]	; (800bf80 <receiveData+0x2b8>)
 800bec2:	681a      	ldr	r2, [r3, #0]
 800bec4:	89bb      	ldrh	r3, [r7, #12]
 800bec6:	4413      	add	r3, r2
 800bec8:	781b      	ldrb	r3, [r3, #0]
 800beca:	2bff      	cmp	r3, #255	; 0xff
 800becc:	d0f5      	beq.n	800beba <receiveData+0x1f2>
					j--;
				rxmsg.dp = rxmsg.data[j];
 800bece:	4b2c      	ldr	r3, [pc, #176]	; (800bf80 <receiveData+0x2b8>)
 800bed0:	681a      	ldr	r2, [r3, #0]
 800bed2:	89bb      	ldrh	r3, [r7, #12]
 800bed4:	4413      	add	r3, r2
 800bed6:	781a      	ldrb	r2, [r3, #0]
 800bed8:	4b29      	ldr	r3, [pc, #164]	; (800bf80 <receiveData+0x2b8>)
 800beda:	721a      	strb	r2, [r3, #8]
				rxmsg.PF = rxmsg.data[j-1];
 800bedc:	4b28      	ldr	r3, [pc, #160]	; (800bf80 <receiveData+0x2b8>)
 800bede:	681a      	ldr	r2, [r3, #0]
 800bee0:	89bb      	ldrh	r3, [r7, #12]
 800bee2:	3b01      	subs	r3, #1
 800bee4:	4413      	add	r3, r2
 800bee6:	781a      	ldrb	r2, [r3, #0]
 800bee8:	4b25      	ldr	r3, [pc, #148]	; (800bf80 <receiveData+0x2b8>)
 800beea:	71da      	strb	r2, [r3, #7]
				rxmsg.PS = rxmsg.data[j-2];
 800beec:	4b24      	ldr	r3, [pc, #144]	; (800bf80 <receiveData+0x2b8>)
 800beee:	681a      	ldr	r2, [r3, #0]
 800bef0:	89bb      	ldrh	r3, [r7, #12]
 800bef2:	3b02      	subs	r3, #2
 800bef4:	4413      	add	r3, r2
 800bef6:	781a      	ldrb	r2, [r3, #0]
 800bef8:	4b21      	ldr	r3, [pc, #132]	; (800bf80 <receiveData+0x2b8>)
 800befa:	719a      	strb	r2, [r3, #6]
				rxmsg.size = j-2;
 800befc:	89bb      	ldrh	r3, [r7, #12]
 800befe:	3b02      	subs	r3, #2
 800bf00:	b29a      	uxth	r2, r3
 800bf02:	4b1f      	ldr	r3, [pc, #124]	; (800bf80 <receiveData+0x2b8>)
 800bf04:	809a      	strh	r2, [r3, #4]
				rt_kprintf("\nDT receive %d data:\r\n", rxmsg.size);
 800bf06:	4b1e      	ldr	r3, [pc, #120]	; (800bf80 <receiveData+0x2b8>)
 800bf08:	889b      	ldrh	r3, [r3, #4]
 800bf0a:	481e      	ldr	r0, [pc, #120]	; (800bf84 <receiveData+0x2bc>)
 800bf0c:	4619      	mov	r1, r3
 800bf0e:	f007 feaf 	bl	8013c70 <rt_kprintf>
				osMessagePut(CA_msg->rxq, (unsigned long)&rxmsg, 0);
 800bf12:	683b      	ldr	r3, [r7, #0]
 800bf14:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800bf16:	4a1a      	ldr	r2, [pc, #104]	; (800bf80 <receiveData+0x2b8>)
 800bf18:	4618      	mov	r0, r3
 800bf1a:	4611      	mov	r1, r2
 800bf1c:	2200      	movs	r2, #0
 800bf1e:	f009 fffb 	bl	8015f18 <osMessagePut>
				
				//if(j1939_msg->PDUSpecific != J1939_GLOBAL_ADDRESS)
				//{
				sendEndofMsgACK(j1939_msg ,CA_msg);
 800bf22:	6878      	ldr	r0, [r7, #4]
 800bf24:	6839      	ldr	r1, [r7, #0]
 800bf26:	f7ff fe75 	bl	800bc14 <sendEndofMsgACK>
 800bf2a:	e020      	b.n	800bf6e <receiveData+0x2a6>
				//}
			}
			else 
			{
				j1939_msg->PDUFormat = J1939_PF_TP_CM;
 800bf2c:	687b      	ldr	r3, [r7, #4]
 800bf2e:	22ec      	movs	r2, #236	; 0xec
 800bf30:	705a      	strb	r2, [r3, #1]
				j1939_msg->Priority = 7;
 800bf32:	687a      	ldr	r2, [r7, #4]
 800bf34:	7813      	ldrb	r3, [r2, #0]
 800bf36:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 800bf3a:	7013      	strb	r3, [r2, #0]
				j1939_msg->DataPage = 0;
 800bf3c:	687a      	ldr	r2, [r7, #4]
 800bf3e:	7813      	ldrb	r3, [r2, #0]
 800bf40:	f36f 03c3 	bfc	r3, #3, #1
 800bf44:	7013      	strb	r3, [r2, #0]
				j1939_msg->edp = 0;
 800bf46:	687a      	ldr	r2, [r7, #4]
 800bf48:	7813      	ldrb	r3, [r2, #0]
 800bf4a:	f36f 1304 	bfc	r3, #4, #1
 800bf4e:	7013      	strb	r3, [r2, #0]
				j1939_msg->DataLength = 8;
 800bf50:	687a      	ldr	r2, [r7, #4]
 800bf52:	7913      	ldrb	r3, [r2, #4]
 800bf54:	2108      	movs	r1, #8
 800bf56:	f361 0303 	bfi	r3, r1, #0, #4
 800bf5a:	7113      	strb	r3, [r2, #4]
		
				sendCTS(j1939_msg,CA_msg,j1939_msg->Data[0]+1,1);
 800bf5c:	687b      	ldr	r3, [r7, #4]
 800bf5e:	795b      	ldrb	r3, [r3, #5]
 800bf60:	3301      	adds	r3, #1
 800bf62:	6878      	ldr	r0, [r7, #4]
 800bf64:	6839      	ldr	r1, [r7, #0]
 800bf66:	461a      	mov	r2, r3
 800bf68:	2301      	movs	r3, #1
 800bf6a:	f7ff fd21 	bl	800b9b0 <sendCTS>
			}
		}
		#endif
		}
	}
}
 800bf6e:	3710      	adds	r7, #16
 800bf70:	46bd      	mov	sp, r7
 800bf72:	bd80      	pop	{r7, pc}
 800bf74:	200107b8 	.word	0x200107b8
 800bf78:	080225dc 	.word	0x080225dc
 800bf7c:	080225f4 	.word	0x080225f4
 800bf80:	200107c4 	.word	0x200107c4
 800bf84:	08022614 	.word	0x08022614

0800bf88 <responseEndofMsgACK>:

void responseEndofMsgACK(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 800bf88:	b580      	push	{r7, lr}
 800bf8a:	b082      	sub	sp, #8
 800bf8c:	af00      	add	r7, sp, #0
 800bf8e:	6078      	str	r0, [r7, #4]
 800bf90:	6039      	str	r1, [r7, #0]
	//if(CA_msg->cm.sendcomp == 1)
	//{
		rt_kprintf("receive endOfMsgAck\r\n");
 800bf92:	4810      	ldr	r0, [pc, #64]	; (800bfd4 <responseEndofMsgACK+0x4c>)
 800bf94:	f007 fe6c 	bl	8013c70 <rt_kprintf>
		//osEnter_critical();
		if(CA_msg->rcvdata != NULL)
 800bf98:	683b      	ldr	r3, [r7, #0]
 800bf9a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800bf9c:	2b00      	cmp	r3, #0
 800bf9e:	d007      	beq.n	800bfb0 <responseEndofMsgACK+0x28>
		{
			free(CA_msg->rcvdata);
 800bfa0:	683b      	ldr	r3, [r7, #0]
 800bfa2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800bfa4:	4618      	mov	r0, r3
 800bfa6:	f013 f8bd 	bl	801f124 <free>
			CA_msg->rcvdata = NULL;
 800bfaa:	683b      	ldr	r3, [r7, #0]
 800bfac:	2200      	movs	r2, #0
 800bfae:	655a      	str	r2, [r3, #84]	; 0x54
		}
		//osExit_critical();
		CA_msg->cm.cm_lock = 0;
 800bfb0:	683b      	ldr	r3, [r7, #0]
 800bfb2:	2200      	movs	r2, #0
 800bfb4:	771a      	strb	r2, [r3, #28]
		CA_msg->cm.nextnum = 0;
 800bfb6:	683b      	ldr	r3, [r7, #0]
 800bfb8:	2200      	movs	r2, #0
 800bfba:	831a      	strh	r2, [r3, #24]
		CA_msg->cm.sendcomp = 0;
 800bfbc:	683b      	ldr	r3, [r7, #0]
 800bfbe:	2200      	movs	r2, #0
 800bfc0:	775a      	strb	r2, [r3, #29]
		CA_msg->cm.sendpackets = 0;
 800bfc2:	683b      	ldr	r3, [r7, #0]
 800bfc4:	2200      	movs	r2, #0
 800bfc6:	82da      	strh	r2, [r3, #22]
		CA_msg->sendbytes = 0;
 800bfc8:	683b      	ldr	r3, [r7, #0]
 800bfca:	2200      	movs	r2, #0
 800bfcc:	829a      	strh	r2, [r3, #20]
	//}
}
 800bfce:	3708      	adds	r7, #8
 800bfd0:	46bd      	mov	sp, r7
 800bfd2:	bd80      	pop	{r7, pc}
 800bfd4:	0802262c 	.word	0x0802262c

0800bfd8 <responseBAM>:
void responseBAM(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 800bfd8:	b580      	push	{r7, lr}
 800bfda:	b082      	sub	sp, #8
 800bfdc:	af00      	add	r7, sp, #0
 800bfde:	6078      	str	r0, [r7, #4]
 800bfe0:	6039      	str	r1, [r7, #0]
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 800bfe2:	687b      	ldr	r3, [r7, #4]
 800bfe4:	789b      	ldrb	r3, [r3, #2]
 800bfe6:	2bff      	cmp	r3, #255	; 0xff
 800bfe8:	d13e      	bne.n	800c068 <responseBAM+0x90>
	{
		rt_kprintf("receive bam\r\n");
 800bfea:	4821      	ldr	r0, [pc, #132]	; (800c070 <responseBAM+0x98>)
 800bfec:	f007 fe40 	bl	8013c70 <rt_kprintf>
		if(checkRes() == RC_SUCCESS && CA_msg->bam.cm_lock == 0)
 800bff0:	f7ff fcd6 	bl	800b9a0 <checkRes>
 800bff4:	4603      	mov	r3, r0
 800bff6:	2b00      	cmp	r3, #0
 800bff8:	d136      	bne.n	800c068 <responseBAM+0x90>
 800bffa:	683b      	ldr	r3, [r7, #0]
 800bffc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800c000:	2b00      	cmp	r3, #0
 800c002:	d131      	bne.n	800c068 <responseBAM+0x90>
		{
			CA_msg->bam.rcvpackets = j1939_msg->Data[3];
 800c004:	687b      	ldr	r3, [r7, #4]
 800c006:	7a1b      	ldrb	r3, [r3, #8]
 800c008:	b29a      	uxth	r2, r3
 800c00a:	683b      	ldr	r3, [r7, #0]
 800c00c:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
			CA_msg->bam.rcvbytes = j1939_msg->Data[2]*256+j1939_msg->Data[1];
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	79db      	ldrb	r3, [r3, #7]
 800c014:	b29b      	uxth	r3, r3
 800c016:	021b      	lsls	r3, r3, #8
 800c018:	b29a      	uxth	r2, r3
 800c01a:	687b      	ldr	r3, [r7, #4]
 800c01c:	799b      	ldrb	r3, [r3, #6]
 800c01e:	b29b      	uxth	r3, r3
 800c020:	4413      	add	r3, r2
 800c022:	b29a      	uxth	r2, r3
 800c024:	683b      	ldr	r3, [r7, #0]
 800c026:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
			CA_msg->bamrcvdata = (unsigned char *)malloc(7 * CA_msg->bam.rcvpackets );
 800c02a:	683b      	ldr	r3, [r7, #0]
 800c02c:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 800c030:	461a      	mov	r2, r3
 800c032:	4613      	mov	r3, r2
 800c034:	00db      	lsls	r3, r3, #3
 800c036:	1a9b      	subs	r3, r3, r2
 800c038:	4618      	mov	r0, r3
 800c03a:	f013 f86b 	bl	801f114 <malloc>
 800c03e:	4603      	mov	r3, r0
 800c040:	461a      	mov	r2, r3
 800c042:	683b      	ldr	r3, [r7, #0]
 800c044:	659a      	str	r2, [r3, #88]	; 0x58
			CA_msg->bam.cm_lock = 1;
 800c046:	683b      	ldr	r3, [r7, #0]
 800c048:	2201      	movs	r2, #1
 800c04a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
			CA_msg->bam.t1.en = 1;
 800c04e:	683b      	ldr	r3, [r7, #0]
 800c050:	2201      	movs	r2, #1
 800c052:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			CA_msg->bam.t1.release = 0;
 800c056:	683b      	ldr	r3, [r7, #0]
 800c058:	2200      	movs	r2, #0
 800c05a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			CA_msg->bam.t1.value = T1TIMEOUT;
 800c05e:	683b      	ldr	r3, [r7, #0]
 800c060:	f240 22ee 	movw	r2, #750	; 0x2ee
 800c064:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
		}
	}
}
 800c068:	3708      	adds	r7, #8
 800c06a:	46bd      	mov	sp, r7
 800c06c:	bd80      	pop	{r7, pc}
 800c06e:	bf00      	nop
 800c070:	08022644 	.word	0x08022644

0800c074 <responseAbort>:

unsigned char responseAbort(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 800c074:	b580      	push	{r7, lr}
 800c076:	b084      	sub	sp, #16
 800c078:	af00      	add	r7, sp, #0
 800c07a:	6078      	str	r0, [r7, #4]
 800c07c:	6039      	str	r1, [r7, #0]
	struct J1939_CM *tempCm;
	
	if(CA_msg->rcvdata != NULL)
 800c07e:	683b      	ldr	r3, [r7, #0]
 800c080:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c082:	2b00      	cmp	r3, #0
 800c084:	d007      	beq.n	800c096 <responseAbort+0x22>
	{
		free(CA_msg->rcvdata);
 800c086:	683b      	ldr	r3, [r7, #0]
 800c088:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c08a:	4618      	mov	r0, r3
 800c08c:	f013 f84a 	bl	801f124 <free>
		CA_msg->rcvdata = NULL;
 800c090:	683b      	ldr	r3, [r7, #0]
 800c092:	2200      	movs	r2, #0
 800c094:	655a      	str	r2, [r3, #84]	; 0x54
	}
	tempCm = &(CA_msg->cm);
 800c096:	683b      	ldr	r3, [r7, #0]
 800c098:	3316      	adds	r3, #22
 800c09a:	60fb      	str	r3, [r7, #12]
	memset(tempCm,0,sizeof(struct J1939_CM));
 800c09c:	68f8      	ldr	r0, [r7, #12]
 800c09e:	2100      	movs	r1, #0
 800c0a0:	222a      	movs	r2, #42	; 0x2a
 800c0a2:	f013 f847 	bl	801f134 <memset>
	
	return RC_SUCCESS;
 800c0a6:	2300      	movs	r3, #0
}
 800c0a8:	4618      	mov	r0, r3
 800c0aa:	3710      	adds	r7, #16
 800c0ac:	46bd      	mov	sp, r7
 800c0ae:	bd80      	pop	{r7, pc}

0800c0b0 <receiveMessage>:
void receiveMessage()
{
 800c0b0:	b580      	push	{r7, lr}
 800c0b2:	b084      	sub	sp, #16
 800c0b4:	af00      	add	r7, sp, #0
	static struct rx_Message rxmsg;
	struct CA_node *canode;
	list_node_t node;
	int i;

	while(readCan(&j1939_msg) == RC_SUCCESS)
 800c0b6:	e0c2      	b.n	800c23e <receiveMessage+0x18e>
	{
		if(j1939_msg.PDUFormat <240)
 800c0b8:	4b66      	ldr	r3, [pc, #408]	; (800c254 <receiveMessage+0x1a4>)
 800c0ba:	785b      	ldrb	r3, [r3, #1]
 800c0bc:	2bef      	cmp	r3, #239	; 0xef
 800c0be:	f200 809b 	bhi.w	800c1f8 <receiveMessage+0x148>
		{
			if (j1939_msg.PDUSpecific == J1939_GLOBAL_ADDRESS) 
 800c0c2:	4b64      	ldr	r3, [pc, #400]	; (800c254 <receiveMessage+0x1a4>)
 800c0c4:	789b      	ldrb	r3, [r3, #2]
 800c0c6:	2bff      	cmp	r3, #255	; 0xff
 800c0c8:	d10e      	bne.n	800c0e8 <receiveMessage+0x38>
			{
				node = calist.head.next;
 800c0ca:	4b63      	ldr	r3, [pc, #396]	; (800c258 <receiveMessage+0x1a8>)
 800c0cc:	685b      	ldr	r3, [r3, #4]
 800c0ce:	60bb      	str	r3, [r7, #8]
				if(node != &(calist.head))
 800c0d0:	68bb      	ldr	r3, [r7, #8]
 800c0d2:	4a62      	ldr	r2, [pc, #392]	; (800c25c <receiveMessage+0x1ac>)
 800c0d4:	4293      	cmp	r3, r2
 800c0d6:	d006      	beq.n	800c0e6 <receiveMessage+0x36>
				{
					canode = rt_list_entry(node, struct CA_node, node);
 800c0d8:	68bb      	ldr	r3, [r7, #8]
 800c0da:	3b04      	subs	r3, #4
 800c0dc:	607b      	str	r3, [r7, #4]
					CA_msg = canode->ca_msg;
 800c0de:	687b      	ldr	r3, [r7, #4]
 800c0e0:	681b      	ldr	r3, [r3, #0]
 800c0e2:	60fb      	str	r3, [r7, #12]
 800c0e4:	e00b      	b.n	800c0fe <receiveMessage+0x4e>
				}
				else 
					break;
 800c0e6:	e0b1      	b.n	800c24c <receiveMessage+0x19c>
			}
			else if ((CA_msg = Addr_FindCA(&calist,j1939_msg.PDUSpecific)) != NULL)
 800c0e8:	4b5a      	ldr	r3, [pc, #360]	; (800c254 <receiveMessage+0x1a4>)
 800c0ea:	789b      	ldrb	r3, [r3, #2]
 800c0ec:	485a      	ldr	r0, [pc, #360]	; (800c258 <receiveMessage+0x1a8>)
 800c0ee:	4619      	mov	r1, r3
 800c0f0:	f000 fb38 	bl	800c764 <Addr_FindCA>
 800c0f4:	60f8      	str	r0, [r7, #12]
 800c0f6:	68fb      	ldr	r3, [r7, #12]
 800c0f8:	2b00      	cmp	r3, #0
 800c0fa:	d100      	bne.n	800c0fe <receiveMessage+0x4e>
			{
			}
			else
				continue;
 800c0fc:	e09f      	b.n	800c23e <receiveMessage+0x18e>

			switch (j1939_msg.PDUFormat)
 800c0fe:	4b55      	ldr	r3, [pc, #340]	; (800c254 <receiveMessage+0x1a4>)
 800c100:	785b      	ldrb	r3, [r3, #1]
 800c102:	3bea      	subs	r3, #234	; 0xea
 800c104:	2b04      	cmp	r3, #4
 800c106:	d852      	bhi.n	800c1ae <receiveMessage+0xfe>
 800c108:	a201      	add	r2, pc, #4	; (adr r2, 800c110 <receiveMessage+0x60>)
 800c10a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c10e:	bf00      	nop
 800c110:	0800c183 	.word	0x0800c183
 800c114:	0800c179 	.word	0x0800c179
 800c118:	0800c125 	.word	0x0800c125
 800c11c:	0800c1af 	.word	0x0800c1af
 800c120:	0800c1a5 	.word	0x0800c1a5
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
 800c124:	4b4b      	ldr	r3, [pc, #300]	; (800c254 <receiveMessage+0x1a4>)
 800c126:	795b      	ldrb	r3, [r3, #5]
 800c128:	2b13      	cmp	r3, #19
 800c12a:	d015      	beq.n	800c158 <receiveMessage+0xa8>
 800c12c:	2b13      	cmp	r3, #19
 800c12e:	dc04      	bgt.n	800c13a <receiveMessage+0x8a>
 800c130:	2b10      	cmp	r3, #16
 800c132:	d007      	beq.n	800c144 <receiveMessage+0x94>
 800c134:	2b11      	cmp	r3, #17
 800c136:	d00a      	beq.n	800c14e <receiveMessage+0x9e>
							break;
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
							break;
						default:
							goto sendmsg;
 800c138:	e039      	b.n	800c1ae <receiveMessage+0xfe>
				continue;

			switch (j1939_msg.PDUFormat)
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
 800c13a:	2b20      	cmp	r3, #32
 800c13c:	d011      	beq.n	800c162 <receiveMessage+0xb2>
 800c13e:	2bff      	cmp	r3, #255	; 0xff
 800c140:	d014      	beq.n	800c16c <receiveMessage+0xbc>
							break;
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
							break;
						default:
							goto sendmsg;
 800c142:	e034      	b.n	800c1ae <receiveMessage+0xfe>
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
					{
						case J1939_RTS_CONTROL_BYTE:
							response_RTS(&j1939_msg,CA_msg);
 800c144:	4843      	ldr	r0, [pc, #268]	; (800c254 <receiveMessage+0x1a4>)
 800c146:	68f9      	ldr	r1, [r7, #12]
 800c148:	f7ff fca2 	bl	800ba90 <response_RTS>
							break;
 800c14c:	e013      	b.n	800c176 <receiveMessage+0xc6>
						case J1939_CTS_CONTROL_BYTE:
							response_CTS(&j1939_msg,CA_msg);
 800c14e:	4841      	ldr	r0, [pc, #260]	; (800c254 <receiveMessage+0x1a4>)
 800c150:	68f9      	ldr	r1, [r7, #12]
 800c152:	f7ff fd03 	bl	800bb5c <response_CTS>
							break;
 800c156:	e00e      	b.n	800c176 <receiveMessage+0xc6>
						case J1939_EOMACK_CONTROL_BYTE:
							responseEndofMsgACK(&j1939_msg,CA_msg);
 800c158:	483e      	ldr	r0, [pc, #248]	; (800c254 <receiveMessage+0x1a4>)
 800c15a:	68f9      	ldr	r1, [r7, #12]
 800c15c:	f7ff ff14 	bl	800bf88 <responseEndofMsgACK>
							break;
 800c160:	e009      	b.n	800c176 <receiveMessage+0xc6>
						case J1939_BAM_CONTROL_BYTE:
							responseBAM(&j1939_msg,CA_msg);
 800c162:	483c      	ldr	r0, [pc, #240]	; (800c254 <receiveMessage+0x1a4>)
 800c164:	68f9      	ldr	r1, [r7, #12]
 800c166:	f7ff ff37 	bl	800bfd8 <responseBAM>
							break;
 800c16a:	e004      	b.n	800c176 <receiveMessage+0xc6>
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
 800c16c:	4839      	ldr	r0, [pc, #228]	; (800c254 <receiveMessage+0x1a4>)
 800c16e:	68f9      	ldr	r1, [r7, #12]
 800c170:	f7ff ff80 	bl	800c074 <responseAbort>
							break;
 800c174:	bf00      	nop
						default:
							goto sendmsg;
					}
					break;
 800c176:	e03e      	b.n	800c1f6 <receiveMessage+0x146>
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
 800c178:	4836      	ldr	r0, [pc, #216]	; (800c254 <receiveMessage+0x1a4>)
 800c17a:	68f9      	ldr	r1, [r7, #12]
 800c17c:	f7ff fda4 	bl	800bcc8 <receiveData>
					break;
 800c180:	e039      	b.n	800c1f6 <receiveMessage+0x146>
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
 800c182:	4b34      	ldr	r3, [pc, #208]	; (800c254 <receiveMessage+0x1a4>)
 800c184:	795b      	ldrb	r3, [r3, #5]
 800c186:	2b00      	cmp	r3, #0
 800c188:	d111      	bne.n	800c1ae <receiveMessage+0xfe>
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
 800c18a:	4b32      	ldr	r3, [pc, #200]	; (800c254 <receiveMessage+0x1a4>)
 800c18c:	799b      	ldrb	r3, [r3, #6]
					break;
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
					break;
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
 800c18e:	2bee      	cmp	r3, #238	; 0xee
 800c190:	d10d      	bne.n	800c1ae <receiveMessage+0xfe>
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
						(j1939_msg.Data[2] == J1939_PGN2_REQ_ADDRESS_CLAIM))
 800c192:	4b30      	ldr	r3, [pc, #192]	; (800c254 <receiveMessage+0x1a4>)
 800c194:	79db      	ldrb	r3, [r3, #7]
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
					break;
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
 800c196:	2b00      	cmp	r3, #0
 800c198:	d109      	bne.n	800c1ae <receiveMessage+0xfe>
						(j1939_msg.Data[2] == J1939_PGN2_REQ_ADDRESS_CLAIM))
						J1939_RequestForAddressClaimHandling(&j1939_msg,CA_msg);
 800c19a:	482e      	ldr	r0, [pc, #184]	; (800c254 <receiveMessage+0x1a4>)
 800c19c:	68f9      	ldr	r1, [r7, #12]
 800c19e:	f000 fb0f 	bl	800c7c0 <J1939_RequestForAddressClaimHandling>
					else 
						goto sendmsg;
					break;
 800c1a2:	e028      	b.n	800c1f6 <receiveMessage+0x146>
				case J1939_PF_ADDRESS_CLAIMED:
					J1939_AddressClaimHandling( &j1939_msg,CA_msg );
 800c1a4:	482b      	ldr	r0, [pc, #172]	; (800c254 <receiveMessage+0x1a4>)
 800c1a6:	68f9      	ldr	r1, [r7, #12]
 800c1a8:	f000 fb80 	bl	800c8ac <J1939_AddressClaimHandling>
					break;
 800c1ac:	e023      	b.n	800c1f6 <receiveMessage+0x146>

				default:
	sendmsg:
				
				rxmsg.data = &j1939_msg.Data;
 800c1ae:	4b2c      	ldr	r3, [pc, #176]	; (800c260 <receiveMessage+0x1b0>)
 800c1b0:	4a2c      	ldr	r2, [pc, #176]	; (800c264 <receiveMessage+0x1b4>)
 800c1b2:	601a      	str	r2, [r3, #0]
				rxmsg.size = j1939_msg.DataLength;
 800c1b4:	4b27      	ldr	r3, [pc, #156]	; (800c254 <receiveMessage+0x1a4>)
 800c1b6:	791b      	ldrb	r3, [r3, #4]
 800c1b8:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800c1bc:	b2db      	uxtb	r3, r3
 800c1be:	b29a      	uxth	r2, r3
 800c1c0:	4b27      	ldr	r3, [pc, #156]	; (800c260 <receiveMessage+0x1b0>)
 800c1c2:	809a      	strh	r2, [r3, #4]
				rxmsg.dp = j1939_msg.DataPage;
 800c1c4:	4b23      	ldr	r3, [pc, #140]	; (800c254 <receiveMessage+0x1a4>)
 800c1c6:	781b      	ldrb	r3, [r3, #0]
 800c1c8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800c1cc:	b2db      	uxtb	r3, r3
 800c1ce:	461a      	mov	r2, r3
 800c1d0:	4b23      	ldr	r3, [pc, #140]	; (800c260 <receiveMessage+0x1b0>)
 800c1d2:	721a      	strb	r2, [r3, #8]
				rxmsg.PF = j1939_msg.PDUFormat;
 800c1d4:	4b1f      	ldr	r3, [pc, #124]	; (800c254 <receiveMessage+0x1a4>)
 800c1d6:	785a      	ldrb	r2, [r3, #1]
 800c1d8:	4b21      	ldr	r3, [pc, #132]	; (800c260 <receiveMessage+0x1b0>)
 800c1da:	71da      	strb	r2, [r3, #7]
				rxmsg.PS = j1939_msg.PDUSpecific;
 800c1dc:	4b1d      	ldr	r3, [pc, #116]	; (800c254 <receiveMessage+0x1a4>)
 800c1de:	789a      	ldrb	r2, [r3, #2]
 800c1e0:	4b1f      	ldr	r3, [pc, #124]	; (800c260 <receiveMessage+0x1b0>)
 800c1e2:	719a      	strb	r2, [r3, #6]
				
				osMessagePut(CA_msg->rxq, (unsigned long)&rxmsg, 0);
 800c1e4:	68fb      	ldr	r3, [r7, #12]
 800c1e6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800c1e8:	4a1d      	ldr	r2, [pc, #116]	; (800c260 <receiveMessage+0x1b0>)
 800c1ea:	4618      	mov	r0, r3
 800c1ec:	4611      	mov	r1, r2
 800c1ee:	2200      	movs	r2, #0
 800c1f0:	f009 fe92 	bl	8015f18 <osMessagePut>
				break;
 800c1f4:	bf00      	nop
 800c1f6:	e022      	b.n	800c23e <receiveMessage+0x18e>
			}
		}
		else 
		{
			rxmsg.data = &j1939_msg.Data;
 800c1f8:	4b19      	ldr	r3, [pc, #100]	; (800c260 <receiveMessage+0x1b0>)
 800c1fa:	4a1a      	ldr	r2, [pc, #104]	; (800c264 <receiveMessage+0x1b4>)
 800c1fc:	601a      	str	r2, [r3, #0]
			rxmsg.size = j1939_msg.DataLength;
 800c1fe:	4b15      	ldr	r3, [pc, #84]	; (800c254 <receiveMessage+0x1a4>)
 800c200:	791b      	ldrb	r3, [r3, #4]
 800c202:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800c206:	b2db      	uxtb	r3, r3
 800c208:	b29a      	uxth	r2, r3
 800c20a:	4b15      	ldr	r3, [pc, #84]	; (800c260 <receiveMessage+0x1b0>)
 800c20c:	809a      	strh	r2, [r3, #4]
			rxmsg.dp = j1939_msg.DataPage;
 800c20e:	4b11      	ldr	r3, [pc, #68]	; (800c254 <receiveMessage+0x1a4>)
 800c210:	781b      	ldrb	r3, [r3, #0]
 800c212:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800c216:	b2db      	uxtb	r3, r3
 800c218:	461a      	mov	r2, r3
 800c21a:	4b11      	ldr	r3, [pc, #68]	; (800c260 <receiveMessage+0x1b0>)
 800c21c:	721a      	strb	r2, [r3, #8]
			rxmsg.PF = j1939_msg.PDUFormat;
 800c21e:	4b0d      	ldr	r3, [pc, #52]	; (800c254 <receiveMessage+0x1a4>)
 800c220:	785a      	ldrb	r2, [r3, #1]
 800c222:	4b0f      	ldr	r3, [pc, #60]	; (800c260 <receiveMessage+0x1b0>)
 800c224:	71da      	strb	r2, [r3, #7]
			rxmsg.PS = j1939_msg.PDUSpecific;
 800c226:	4b0b      	ldr	r3, [pc, #44]	; (800c254 <receiveMessage+0x1a4>)
 800c228:	789a      	ldrb	r2, [r3, #2]
 800c22a:	4b0d      	ldr	r3, [pc, #52]	; (800c260 <receiveMessage+0x1b0>)
 800c22c:	719a      	strb	r2, [r3, #6]
			
			osMessagePut(CA_msg->rxq, (unsigned long)&rxmsg, 0);
 800c22e:	68fb      	ldr	r3, [r7, #12]
 800c230:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800c232:	4a0b      	ldr	r2, [pc, #44]	; (800c260 <receiveMessage+0x1b0>)
 800c234:	4618      	mov	r0, r3
 800c236:	4611      	mov	r1, r2
 800c238:	2200      	movs	r2, #0
 800c23a:	f009 fe6d 	bl	8015f18 <osMessagePut>
	static struct rx_Message rxmsg;
	struct CA_node *canode;
	list_node_t node;
	int i;

	while(readCan(&j1939_msg) == RC_SUCCESS)
 800c23e:	4805      	ldr	r0, [pc, #20]	; (800c254 <receiveMessage+0x1a4>)
 800c240:	f000 fc92 	bl	800cb68 <readCan>
 800c244:	4603      	mov	r3, r0
 800c246:	2b00      	cmp	r3, #0
 800c248:	f43f af36 	beq.w	800c0b8 <receiveMessage+0x8>
			rxmsg.PS = j1939_msg.PDUSpecific;
			
			osMessagePut(CA_msg->rxq, (unsigned long)&rxmsg, 0);
		}
	}
}
 800c24c:	3710      	adds	r7, #16
 800c24e:	46bd      	mov	sp, r7
 800c250:	bd80      	pop	{r7, pc}
 800c252:	bf00      	nop
 800c254:	200107d0 	.word	0x200107d0
 800c258:	20012218 	.word	0x20012218
 800c25c:	2001221c 	.word	0x2001221c
 800c260:	200107e0 	.word	0x200107e0
 800c264:	200107d5 	.word	0x200107d5

0800c268 <bamAbort>:

void bamAbort(CA_Msg_t CA_msg)
{
 800c268:	b580      	push	{r7, lr}
 800c26a:	b084      	sub	sp, #16
 800c26c:	af00      	add	r7, sp, #0
 800c26e:	6078      	str	r0, [r7, #4]
	struct J1939_BAM *tempbam;
	
	if(CA_msg->bamrcvdata != NULL)
 800c270:	687b      	ldr	r3, [r7, #4]
 800c272:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c274:	2b00      	cmp	r3, #0
 800c276:	d007      	beq.n	800c288 <bamAbort+0x20>
	{
		free(CA_msg->bamrcvdata);
 800c278:	687b      	ldr	r3, [r7, #4]
 800c27a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c27c:	4618      	mov	r0, r3
 800c27e:	f012 ff51 	bl	801f124 <free>
		CA_msg->bamrcvdata = NULL;
 800c282:	687b      	ldr	r3, [r7, #4]
 800c284:	2200      	movs	r2, #0
 800c286:	659a      	str	r2, [r3, #88]	; 0x58
	}
	tempbam = &(CA_msg->bam);
 800c288:	687b      	ldr	r3, [r7, #4]
 800c28a:	3340      	adds	r3, #64	; 0x40
 800c28c:	60fb      	str	r3, [r7, #12]
	memset(tempbam,0,sizeof(struct J1939_BAM));
 800c28e:	68f8      	ldr	r0, [r7, #12]
 800c290:	2100      	movs	r1, #0
 800c292:	220c      	movs	r2, #12
 800c294:	f012 ff4e 	bl	801f134 <memset>
}
 800c298:	3710      	adds	r7, #16
 800c29a:	46bd      	mov	sp, r7
 800c29c:	bd80      	pop	{r7, pc}
 800c29e:	bf00      	nop

0800c2a0 <timerJ1939func>:

static void timerJ1939func(void* parameter)
{
 800c2a0:	b580      	push	{r7, lr}
 800c2a2:	b086      	sub	sp, #24
 800c2a4:	af00      	add	r7, sp, #0
 800c2a6:	6078      	str	r0, [r7, #4]
	CA_Msg_t tmp_ca_msg;
	struct list_node *node;
	static struct q_Message q_msg;
	struct CA_node *canode;
	for(node = calist.head.next; node != &(calist.head); node = node->next)
 800c2a8:	4b93      	ldr	r3, [pc, #588]	; (800c4f8 <timerJ1939func+0x258>)
 800c2aa:	685b      	ldr	r3, [r3, #4]
 800c2ac:	617b      	str	r3, [r7, #20]
 800c2ae:	e1c5      	b.n	800c63c <timerJ1939func+0x39c>
	{
		canode = rt_list_entry(node, struct CA_node, node);
 800c2b0:	697b      	ldr	r3, [r7, #20]
 800c2b2:	3b04      	subs	r3, #4
 800c2b4:	613b      	str	r3, [r7, #16]
		tmp_ca_msg = canode->ca_msg;
 800c2b6:	693b      	ldr	r3, [r7, #16]
 800c2b8:	681b      	ldr	r3, [r3, #0]
 800c2ba:	60fb      	str	r3, [r7, #12]

		if((tmp_ca_msg->bam.t1.en) == 1)
 800c2bc:	68fb      	ldr	r3, [r7, #12]
 800c2be:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800c2c2:	2b01      	cmp	r3, #1
 800c2c4:	d12a      	bne.n	800c31c <timerJ1939func+0x7c>
		{
			if((tmp_ca_msg->bam.t1.release) == 1)
 800c2c6:	68fb      	ldr	r3, [r7, #12]
 800c2c8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800c2cc:	2b01      	cmp	r3, #1
 800c2ce:	d10c      	bne.n	800c2ea <timerJ1939func+0x4a>
			{
				tmp_ca_msg->bam.t1.en = 0;
 800c2d0:	68fb      	ldr	r3, [r7, #12]
 800c2d2:	2200      	movs	r2, #0
 800c2d4:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
				tmp_ca_msg->bam.t1.value = 0;
 800c2d8:	68fb      	ldr	r3, [r7, #12]
 800c2da:	2200      	movs	r2, #0
 800c2dc:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
				tmp_ca_msg->bam.t1.release = 0;
 800c2e0:	68fb      	ldr	r3, [r7, #12]
 800c2e2:	2200      	movs	r2, #0
 800c2e4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800c2e8:	e018      	b.n	800c31c <timerJ1939func+0x7c>
			}
			else
			{
				if((tmp_ca_msg->bam.t1.value)-- == 0)
 800c2ea:	68fb      	ldr	r3, [r7, #12]
 800c2ec:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 800c2f0:	1e5a      	subs	r2, r3, #1
 800c2f2:	b291      	uxth	r1, r2
 800c2f4:	68fa      	ldr	r2, [r7, #12]
 800c2f6:	f8a2 1042 	strh.w	r1, [r2, #66]	; 0x42
 800c2fa:	2b00      	cmp	r3, #0
 800c2fc:	d10e      	bne.n	800c31c <timerJ1939func+0x7c>
				{
					tmp_ca_msg->bam.t1.en = 0;
 800c2fe:	68fb      	ldr	r3, [r7, #12]
 800c300:	2200      	movs	r2, #0
 800c302:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
					tmp_ca_msg->bam.t1.value = 0;
 800c306:	68fb      	ldr	r3, [r7, #12]
 800c308:	2200      	movs	r2, #0
 800c30a:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
					tmp_ca_msg->bam.t1.release = 0;
 800c30e:	68fb      	ldr	r3, [r7, #12]
 800c310:	2200      	movs	r2, #0
 800c312:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					//sendAbort(tmp_ca_msg,0);

			bamAbort(tmp_ca_msg);
 800c316:	68f8      	ldr	r0, [r7, #12]
 800c318:	f7ff ffa6 	bl	800c268 <bamAbort>

				}
			}
		}

		if((tmp_ca_msg->cm.t1.en) == 1)
 800c31c:	68fb      	ldr	r3, [r7, #12]
 800c31e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800c322:	2b01      	cmp	r3, #1
 800c324:	d127      	bne.n	800c376 <timerJ1939func+0xd6>
		{
			if((tmp_ca_msg->cm.t1.release) == 1)
 800c326:	68fb      	ldr	r3, [r7, #12]
 800c328:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 800c32c:	2b01      	cmp	r3, #1
 800c32e:	d10b      	bne.n	800c348 <timerJ1939func+0xa8>
			{
				tmp_ca_msg->cm.t1.en = 0;
 800c330:	68fb      	ldr	r3, [r7, #12]
 800c332:	2200      	movs	r2, #0
 800c334:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
				tmp_ca_msg->cm.t1.value = 0;
 800c338:	68fb      	ldr	r3, [r7, #12]
 800c33a:	2200      	movs	r2, #0
 800c33c:	84da      	strh	r2, [r3, #38]	; 0x26
				tmp_ca_msg->cm.t1.release = 0;
 800c33e:	68fb      	ldr	r3, [r7, #12]
 800c340:	2200      	movs	r2, #0
 800c342:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 800c346:	e016      	b.n	800c376 <timerJ1939func+0xd6>
			}
			else
			{
				if((tmp_ca_msg->cm.t1.value)-- == 0)
 800c348:	68fb      	ldr	r3, [r7, #12]
 800c34a:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800c34c:	1e5a      	subs	r2, r3, #1
 800c34e:	b291      	uxth	r1, r2
 800c350:	68fa      	ldr	r2, [r7, #12]
 800c352:	84d1      	strh	r1, [r2, #38]	; 0x26
 800c354:	2b00      	cmp	r3, #0
 800c356:	d10e      	bne.n	800c376 <timerJ1939func+0xd6>
				{
					tmp_ca_msg->cm.t1.en = 0;
 800c358:	68fb      	ldr	r3, [r7, #12]
 800c35a:	2200      	movs	r2, #0
 800c35c:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					tmp_ca_msg->cm.t1.value = 0;
 800c360:	68fb      	ldr	r3, [r7, #12]
 800c362:	2200      	movs	r2, #0
 800c364:	84da      	strh	r2, [r3, #38]	; 0x26
					tmp_ca_msg->cm.t1.release = 0;
 800c366:	68fb      	ldr	r3, [r7, #12]
 800c368:	2200      	movs	r2, #0
 800c36a:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					sendAbort(tmp_ca_msg,0);
 800c36e:	68f8      	ldr	r0, [r7, #12]
 800c370:	2100      	movs	r1, #0
 800c372:	f7ff f96f 	bl	800b654 <sendAbort>
				}
			}
		}
		if((tmp_ca_msg->cm.t2.en) == 1)
 800c376:	68fb      	ldr	r3, [r7, #12]
 800c378:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800c37c:	2b01      	cmp	r3, #1
 800c37e:	d130      	bne.n	800c3e2 <timerJ1939func+0x142>
		{
			if((tmp_ca_msg->cm.t2.release) == 1)
 800c380:	68fb      	ldr	r3, [r7, #12]
 800c382:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 800c386:	2b01      	cmp	r3, #1
 800c388:	d10b      	bne.n	800c3a2 <timerJ1939func+0x102>
			{
				tmp_ca_msg->cm.t2.en = 0;
 800c38a:	68fb      	ldr	r3, [r7, #12]
 800c38c:	2200      	movs	r2, #0
 800c38e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
				tmp_ca_msg->cm.t2.value = 0;
 800c392:	68fb      	ldr	r3, [r7, #12]
 800c394:	2200      	movs	r2, #0
 800c396:	855a      	strh	r2, [r3, #42]	; 0x2a
				tmp_ca_msg->cm.t2.release = 0;
 800c398:	68fb      	ldr	r3, [r7, #12]
 800c39a:	2200      	movs	r2, #0
 800c39c:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
 800c3a0:	e01f      	b.n	800c3e2 <timerJ1939func+0x142>
			}
			else
			{
				if((tmp_ca_msg->cm.t2.value)-- == 0)
 800c3a2:	68fb      	ldr	r3, [r7, #12]
 800c3a4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800c3a6:	1e5a      	subs	r2, r3, #1
 800c3a8:	b291      	uxth	r1, r2
 800c3aa:	68fa      	ldr	r2, [r7, #12]
 800c3ac:	8551      	strh	r1, [r2, #42]	; 0x2a
 800c3ae:	2b00      	cmp	r3, #0
 800c3b0:	d117      	bne.n	800c3e2 <timerJ1939func+0x142>
				{
					q_msg.timeout = 1;
 800c3b2:	4b52      	ldr	r3, [pc, #328]	; (800c4fc <timerJ1939func+0x25c>)
 800c3b4:	2201      	movs	r2, #1
 800c3b6:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 800c3b8:	4b50      	ldr	r3, [pc, #320]	; (800c4fc <timerJ1939func+0x25c>)
 800c3ba:	2200      	movs	r2, #0
 800c3bc:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 800c3be:	4b4f      	ldr	r3, [pc, #316]	; (800c4fc <timerJ1939func+0x25c>)
 800c3c0:	2200      	movs	r2, #0
 800c3c2:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t2.en = 0;
 800c3c4:	68fb      	ldr	r3, [r7, #12]
 800c3c6:	2200      	movs	r2, #0
 800c3c8:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
					tmp_ca_msg->cm.t2.value = 0;
 800c3cc:	68fb      	ldr	r3, [r7, #12]
 800c3ce:	2200      	movs	r2, #0
 800c3d0:	855a      	strh	r2, [r3, #42]	; 0x2a
					tmp_ca_msg->cm.t2.release = 0;
 800c3d2:	68fb      	ldr	r3, [r7, #12]
 800c3d4:	2200      	movs	r2, #0
 800c3d6:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					sendAbort(tmp_ca_msg,0);
 800c3da:	68f8      	ldr	r0, [r7, #12]
 800c3dc:	2100      	movs	r1, #0
 800c3de:	f7ff f939 	bl	800b654 <sendAbort>
				}
			}
		}
		if((tmp_ca_msg->cm.t3.en) == 1)
 800c3e2:	68fb      	ldr	r3, [r7, #12]
 800c3e4:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800c3e8:	2b01      	cmp	r3, #1
 800c3ea:	d134      	bne.n	800c456 <timerJ1939func+0x1b6>
		{
			if((tmp_ca_msg->cm.t3.release) == 1)
 800c3ec:	68fb      	ldr	r3, [r7, #12]
 800c3ee:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 800c3f2:	2b01      	cmp	r3, #1
 800c3f4:	d10b      	bne.n	800c40e <timerJ1939func+0x16e>
			{
				tmp_ca_msg->cm.t3.en = 0;
 800c3f6:	68fb      	ldr	r3, [r7, #12]
 800c3f8:	2200      	movs	r2, #0
 800c3fa:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
				tmp_ca_msg->cm.t3.value = 0;
 800c3fe:	68fb      	ldr	r3, [r7, #12]
 800c400:	2200      	movs	r2, #0
 800c402:	85da      	strh	r2, [r3, #46]	; 0x2e
				tmp_ca_msg->cm.t3.release = 0;
 800c404:	68fb      	ldr	r3, [r7, #12]
 800c406:	2200      	movs	r2, #0
 800c408:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 800c40c:	e023      	b.n	800c456 <timerJ1939func+0x1b6>
			}
			else
			{
				if((tmp_ca_msg->cm.t3.value)-- == 0)
 800c40e:	68fb      	ldr	r3, [r7, #12]
 800c410:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 800c412:	1e5a      	subs	r2, r3, #1
 800c414:	b291      	uxth	r1, r2
 800c416:	68fa      	ldr	r2, [r7, #12]
 800c418:	85d1      	strh	r1, [r2, #46]	; 0x2e
 800c41a:	2b00      	cmp	r3, #0
 800c41c:	d11b      	bne.n	800c456 <timerJ1939func+0x1b6>
				{
					q_msg.timeout = 1;
 800c41e:	4b37      	ldr	r3, [pc, #220]	; (800c4fc <timerJ1939func+0x25c>)
 800c420:	2201      	movs	r2, #1
 800c422:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 800c424:	4b35      	ldr	r3, [pc, #212]	; (800c4fc <timerJ1939func+0x25c>)
 800c426:	2200      	movs	r2, #0
 800c428:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 800c42a:	4b34      	ldr	r3, [pc, #208]	; (800c4fc <timerJ1939func+0x25c>)
 800c42c:	2200      	movs	r2, #0
 800c42e:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t3.en = 0;
 800c430:	68fb      	ldr	r3, [r7, #12]
 800c432:	2200      	movs	r2, #0
 800c434:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
					tmp_ca_msg->cm.t3.value = 0;
 800c438:	68fb      	ldr	r3, [r7, #12]
 800c43a:	2200      	movs	r2, #0
 800c43c:	85da      	strh	r2, [r3, #46]	; 0x2e
					tmp_ca_msg->cm.t3.release = 0;
 800c43e:	68fb      	ldr	r3, [r7, #12]
 800c440:	2200      	movs	r2, #0
 800c442:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 800c446:	68fb      	ldr	r3, [r7, #12]
 800c448:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800c44a:	4a2c      	ldr	r2, [pc, #176]	; (800c4fc <timerJ1939func+0x25c>)
 800c44c:	4618      	mov	r0, r3
 800c44e:	4611      	mov	r1, r2
 800c450:	2200      	movs	r2, #0
 800c452:	f009 fd61 	bl	8015f18 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.t4.en) == 1)
 800c456:	68fb      	ldr	r3, [r7, #12]
 800c458:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800c45c:	2b01      	cmp	r3, #1
 800c45e:	d134      	bne.n	800c4ca <timerJ1939func+0x22a>
		{
			if((tmp_ca_msg->cm.t4.release) == 1)
 800c460:	68fb      	ldr	r3, [r7, #12]
 800c462:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 800c466:	2b01      	cmp	r3, #1
 800c468:	d10b      	bne.n	800c482 <timerJ1939func+0x1e2>
			{
				tmp_ca_msg->cm.t4.en = 0;
 800c46a:	68fb      	ldr	r3, [r7, #12]
 800c46c:	2200      	movs	r2, #0
 800c46e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
				tmp_ca_msg->cm.t4.value = 0;
 800c472:	68fb      	ldr	r3, [r7, #12]
 800c474:	2200      	movs	r2, #0
 800c476:	865a      	strh	r2, [r3, #50]	; 0x32
				tmp_ca_msg->cm.t4.release = 0;
 800c478:	68fb      	ldr	r3, [r7, #12]
 800c47a:	2200      	movs	r2, #0
 800c47c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800c480:	e023      	b.n	800c4ca <timerJ1939func+0x22a>
			}
			else
			{
				if((tmp_ca_msg->cm.t4.value)-- == 0)
 800c482:	68fb      	ldr	r3, [r7, #12]
 800c484:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800c486:	1e5a      	subs	r2, r3, #1
 800c488:	b291      	uxth	r1, r2
 800c48a:	68fa      	ldr	r2, [r7, #12]
 800c48c:	8651      	strh	r1, [r2, #50]	; 0x32
 800c48e:	2b00      	cmp	r3, #0
 800c490:	d11b      	bne.n	800c4ca <timerJ1939func+0x22a>
				{
					q_msg.timeout = 1;
 800c492:	4b1a      	ldr	r3, [pc, #104]	; (800c4fc <timerJ1939func+0x25c>)
 800c494:	2201      	movs	r2, #1
 800c496:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 800c498:	4b18      	ldr	r3, [pc, #96]	; (800c4fc <timerJ1939func+0x25c>)
 800c49a:	2200      	movs	r2, #0
 800c49c:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 800c49e:	4b17      	ldr	r3, [pc, #92]	; (800c4fc <timerJ1939func+0x25c>)
 800c4a0:	2200      	movs	r2, #0
 800c4a2:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t4.en = 0;
 800c4a4:	68fb      	ldr	r3, [r7, #12]
 800c4a6:	2200      	movs	r2, #0
 800c4a8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
					tmp_ca_msg->cm.t4.value = 0;
 800c4ac:	68fb      	ldr	r3, [r7, #12]
 800c4ae:	2200      	movs	r2, #0
 800c4b0:	865a      	strh	r2, [r3, #50]	; 0x32
					tmp_ca_msg->cm.t4.release = 0;
 800c4b2:	68fb      	ldr	r3, [r7, #12]
 800c4b4:	2200      	movs	r2, #0
 800c4b6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 800c4ba:	68fb      	ldr	r3, [r7, #12]
 800c4bc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800c4be:	4a0f      	ldr	r2, [pc, #60]	; (800c4fc <timerJ1939func+0x25c>)
 800c4c0:	4618      	mov	r0, r3
 800c4c2:	4611      	mov	r1, r2
 800c4c4:	2200      	movs	r2, #0
 800c4c6:	f009 fd27 	bl	8015f18 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.tr.en) == 1)
 800c4ca:	68fb      	ldr	r3, [r7, #12]
 800c4cc:	f893 3020 	ldrb.w	r3, [r3, #32]
 800c4d0:	2b01      	cmp	r3, #1
 800c4d2:	d139      	bne.n	800c548 <timerJ1939func+0x2a8>
		{
			if((tmp_ca_msg->cm.tr.release) == 1)
 800c4d4:	68fb      	ldr	r3, [r7, #12]
 800c4d6:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800c4da:	2b01      	cmp	r3, #1
 800c4dc:	d110      	bne.n	800c500 <timerJ1939func+0x260>
			{
				tmp_ca_msg->cm.tr.en = 0;
 800c4de:	68fb      	ldr	r3, [r7, #12]
 800c4e0:	2200      	movs	r2, #0
 800c4e2:	f883 2020 	strb.w	r2, [r3, #32]
				tmp_ca_msg->cm.tr.value = 0;
 800c4e6:	68fb      	ldr	r3, [r7, #12]
 800c4e8:	2200      	movs	r2, #0
 800c4ea:	83da      	strh	r2, [r3, #30]
				tmp_ca_msg->cm.tr.release = 0;
 800c4ec:	68fb      	ldr	r3, [r7, #12]
 800c4ee:	2200      	movs	r2, #0
 800c4f0:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 800c4f4:	e028      	b.n	800c548 <timerJ1939func+0x2a8>
 800c4f6:	bf00      	nop
 800c4f8:	20012218 	.word	0x20012218
 800c4fc:	200107ec 	.word	0x200107ec
			}
			else
			{
				if((tmp_ca_msg->cm.tr.value)-- == 0)
 800c500:	68fb      	ldr	r3, [r7, #12]
 800c502:	8bdb      	ldrh	r3, [r3, #30]
 800c504:	1e5a      	subs	r2, r3, #1
 800c506:	b291      	uxth	r1, r2
 800c508:	68fa      	ldr	r2, [r7, #12]
 800c50a:	83d1      	strh	r1, [r2, #30]
 800c50c:	2b00      	cmp	r3, #0
 800c50e:	d11b      	bne.n	800c548 <timerJ1939func+0x2a8>
				{
					q_msg.timeout = 1;
 800c510:	4b4e      	ldr	r3, [pc, #312]	; (800c64c <timerJ1939func+0x3ac>)
 800c512:	2201      	movs	r2, #1
 800c514:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 800c516:	4b4d      	ldr	r3, [pc, #308]	; (800c64c <timerJ1939func+0x3ac>)
 800c518:	2200      	movs	r2, #0
 800c51a:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 800c51c:	4b4b      	ldr	r3, [pc, #300]	; (800c64c <timerJ1939func+0x3ac>)
 800c51e:	2200      	movs	r2, #0
 800c520:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.tr.en = 0;
 800c522:	68fb      	ldr	r3, [r7, #12]
 800c524:	2200      	movs	r2, #0
 800c526:	f883 2020 	strb.w	r2, [r3, #32]
					tmp_ca_msg->cm.tr.value = 0;
 800c52a:	68fb      	ldr	r3, [r7, #12]
 800c52c:	2200      	movs	r2, #0
 800c52e:	83da      	strh	r2, [r3, #30]
					tmp_ca_msg->cm.tr.release = 0;
 800c530:	68fb      	ldr	r3, [r7, #12]
 800c532:	2200      	movs	r2, #0
 800c534:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg,0);
 800c538:	68fb      	ldr	r3, [r7, #12]
 800c53a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800c53c:	4a43      	ldr	r2, [pc, #268]	; (800c64c <timerJ1939func+0x3ac>)
 800c53e:	4618      	mov	r0, r3
 800c540:	4611      	mov	r1, r2
 800c542:	2200      	movs	r2, #0
 800c544:	f009 fce8 	bl	8015f18 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.th.en) == 1)
 800c548:	68fb      	ldr	r3, [r7, #12]
 800c54a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c54e:	2b01      	cmp	r3, #1
 800c550:	d134      	bne.n	800c5bc <timerJ1939func+0x31c>
		{
			if((tmp_ca_msg->cm.th.release) == 1)
 800c552:	68fb      	ldr	r3, [r7, #12]
 800c554:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 800c558:	2b01      	cmp	r3, #1
 800c55a:	d10b      	bne.n	800c574 <timerJ1939func+0x2d4>
			{
				tmp_ca_msg->cm.th.en = 0;
 800c55c:	68fb      	ldr	r3, [r7, #12]
 800c55e:	2200      	movs	r2, #0
 800c560:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
				tmp_ca_msg->cm.th.value = 0;
 800c564:	68fb      	ldr	r3, [r7, #12]
 800c566:	2200      	movs	r2, #0
 800c568:	845a      	strh	r2, [r3, #34]	; 0x22
				tmp_ca_msg->cm.th.release = 0;
 800c56a:	68fb      	ldr	r3, [r7, #12]
 800c56c:	2200      	movs	r2, #0
 800c56e:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 800c572:	e023      	b.n	800c5bc <timerJ1939func+0x31c>
			}
			else
			{
				if((tmp_ca_msg->cm.th.value)-- == 0)
 800c574:	68fb      	ldr	r3, [r7, #12]
 800c576:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800c578:	1e5a      	subs	r2, r3, #1
 800c57a:	b291      	uxth	r1, r2
 800c57c:	68fa      	ldr	r2, [r7, #12]
 800c57e:	8451      	strh	r1, [r2, #34]	; 0x22
 800c580:	2b00      	cmp	r3, #0
 800c582:	d11b      	bne.n	800c5bc <timerJ1939func+0x31c>
				{
					q_msg.timeout = 1;
 800c584:	4b31      	ldr	r3, [pc, #196]	; (800c64c <timerJ1939func+0x3ac>)
 800c586:	2201      	movs	r2, #1
 800c588:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 800c58a:	4b30      	ldr	r3, [pc, #192]	; (800c64c <timerJ1939func+0x3ac>)
 800c58c:	2200      	movs	r2, #0
 800c58e:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 800c590:	4b2e      	ldr	r3, [pc, #184]	; (800c64c <timerJ1939func+0x3ac>)
 800c592:	2200      	movs	r2, #0
 800c594:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.th.en = 0;
 800c596:	68fb      	ldr	r3, [r7, #12]
 800c598:	2200      	movs	r2, #0
 800c59a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
					tmp_ca_msg->cm.th.value = 0;
 800c59e:	68fb      	ldr	r3, [r7, #12]
 800c5a0:	2200      	movs	r2, #0
 800c5a2:	845a      	strh	r2, [r3, #34]	; 0x22
					tmp_ca_msg->cm.th.release = 0;
 800c5a4:	68fb      	ldr	r3, [r7, #12]
 800c5a6:	2200      	movs	r2, #0
 800c5a8:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 800c5ac:	68fb      	ldr	r3, [r7, #12]
 800c5ae:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800c5b0:	4a26      	ldr	r2, [pc, #152]	; (800c64c <timerJ1939func+0x3ac>)
 800c5b2:	4618      	mov	r0, r3
 800c5b4:	4611      	mov	r1, r2
 800c5b6:	2200      	movs	r2, #0
 800c5b8:	f009 fcae 	bl	8015f18 <osMessagePut>
				}
			}
		}
			#if 1
		if(tmp_ca_msg->nm.t250.en == 1)
 800c5bc:	68fb      	ldr	r3, [r7, #12]
 800c5be:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800c5c2:	2b01      	cmp	r3, #1
 800c5c4:	d137      	bne.n	800c636 <timerJ1939func+0x396>
		{
			if(tmp_ca_msg->nm.t250.release == 1)
 800c5c6:	68fb      	ldr	r3, [r7, #12]
 800c5c8:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800c5cc:	2b01      	cmp	r3, #1
 800c5ce:	d114      	bne.n	800c5fa <timerJ1939func+0x35a>
			{
				tmp_ca_msg->nm.cannotClaimAddr = 1;
 800c5d0:	68fb      	ldr	r3, [r7, #12]
 800c5d2:	2201      	movs	r2, #1
 800c5d4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
				tmp_ca_msg->nm.WaitingForAddressClaimContention = 0;
 800c5d8:	68fb      	ldr	r3, [r7, #12]
 800c5da:	2200      	movs	r2, #0
 800c5dc:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
				tmp_ca_msg->nm.t250.en = 0;
 800c5e0:	68fb      	ldr	r3, [r7, #12]
 800c5e2:	2200      	movs	r2, #0
 800c5e4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
				tmp_ca_msg->nm.t250.value = 0;
 800c5e8:	68fb      	ldr	r3, [r7, #12]
 800c5ea:	2200      	movs	r2, #0
 800c5ec:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
				tmp_ca_msg->nm.t250.release = 0;
 800c5f0:	68fb      	ldr	r3, [r7, #12]
 800c5f2:	2200      	movs	r2, #0
 800c5f4:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
 800c5f8:	e01d      	b.n	800c636 <timerJ1939func+0x396>
			}
			else
			{
				if(tmp_ca_msg->nm.t250.value-- == 0)
 800c5fa:	68fb      	ldr	r3, [r7, #12]
 800c5fc:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 800c600:	1e5a      	subs	r2, r3, #1
 800c602:	b291      	uxth	r1, r2
 800c604:	68fa      	ldr	r2, [r7, #12]
 800c606:	f8a2 104e 	strh.w	r1, [r2, #78]	; 0x4e
 800c60a:	2b00      	cmp	r3, #0
 800c60c:	d113      	bne.n	800c636 <timerJ1939func+0x396>
				{
					tmp_ca_msg->nm.cannotClaimAddr = 0;
 800c60e:	68fb      	ldr	r3, [r7, #12]
 800c610:	2200      	movs	r2, #0
 800c612:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
					tmp_ca_msg->nm.WaitingForAddressClaimContention = 0;
 800c616:	68fb      	ldr	r3, [r7, #12]
 800c618:	2200      	movs	r2, #0
 800c61a:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
					tmp_ca_msg->nm.t250.en = 0;
 800c61e:	68fb      	ldr	r3, [r7, #12]
 800c620:	2200      	movs	r2, #0
 800c622:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
					tmp_ca_msg->nm.t250.value = 0;
 800c626:	68fb      	ldr	r3, [r7, #12]
 800c628:	2200      	movs	r2, #0
 800c62a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
					tmp_ca_msg->nm.t250.release = 0;
 800c62e:	68fb      	ldr	r3, [r7, #12]
 800c630:	2200      	movs	r2, #0
 800c632:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
{
	CA_Msg_t tmp_ca_msg;
	struct list_node *node;
	static struct q_Message q_msg;
	struct CA_node *canode;
	for(node = calist.head.next; node != &(calist.head); node = node->next)
 800c636:	697b      	ldr	r3, [r7, #20]
 800c638:	681b      	ldr	r3, [r3, #0]
 800c63a:	617b      	str	r3, [r7, #20]
 800c63c:	697b      	ldr	r3, [r7, #20]
 800c63e:	4a04      	ldr	r2, [pc, #16]	; (800c650 <timerJ1939func+0x3b0>)
 800c640:	4293      	cmp	r3, r2
 800c642:	f47f ae35 	bne.w	800c2b0 <timerJ1939func+0x10>
				}
			}
		}
			#endif
	}
}
 800c646:	3718      	adds	r7, #24
 800c648:	46bd      	mov	sp, r7
 800c64a:	bd80      	pop	{r7, pc}
 800c64c:	200107ec 	.word	0x200107ec
 800c650:	2001221c 	.word	0x2001221c

0800c654 <initJ1939>:


 unsigned char initJ1939()
{
 800c654:	b580      	push	{r7, lr}
 800c656:	b088      	sub	sp, #32
 800c658:	af00      	add	r7, sp, #0
	unsigned char result = RC_SUCCESS;
 800c65a:	2300      	movs	r3, #0
 800c65c:	77fb      	strb	r3, [r7, #31]
	osTimerId timerid;
	struct os_timer_def timer_def;
	
	list_init(&(calist.head));
 800c65e:	4810      	ldr	r0, [pc, #64]	; (800c6a0 <initJ1939+0x4c>)
 800c660:	f7fe fcdc 	bl	800b01c <list_init>

	timer_def.flag = osTimerPeriodic;
 800c664:	2301      	movs	r3, #1
 800c666:	753b      	strb	r3, [r7, #20]
	timer_def.name = "J1939timer";
 800c668:	4b0e      	ldr	r3, [pc, #56]	; (800c6a4 <initJ1939+0x50>)
 800c66a:	607b      	str	r3, [r7, #4]
	timer_def.parameter = NULL;
 800c66c:	2300      	movs	r3, #0
 800c66e:	60fb      	str	r3, [r7, #12]
	timer_def.time = 1;
 800c670:	2301      	movs	r3, #1
 800c672:	613b      	str	r3, [r7, #16]
	timer_def.timeout = timerJ1939func;
 800c674:	4b0c      	ldr	r3, [pc, #48]	; (800c6a8 <initJ1939+0x54>)
 800c676:	60bb      	str	r3, [r7, #8]
	timerid = osTimerCreate(&timer_def, osTimerPeriodic, NULL);
 800c678:	1d3b      	adds	r3, r7, #4
 800c67a:	4618      	mov	r0, r3
 800c67c:	2101      	movs	r1, #1
 800c67e:	2200      	movs	r2, #0
 800c680:	f009 fbf2 	bl	8015e68 <osTimerCreate>
 800c684:	61b8      	str	r0, [r7, #24]
	if(timerid != NULL) 
 800c686:	69bb      	ldr	r3, [r7, #24]
 800c688:	2b00      	cmp	r3, #0
 800c68a:	d004      	beq.n	800c696 <initJ1939+0x42>
		osTimerStart(timerid,timer_def.time);
 800c68c:	693b      	ldr	r3, [r7, #16]
 800c68e:	69b8      	ldr	r0, [r7, #24]
 800c690:	4619      	mov	r1, r3
 800c692:	f009 fc0d 	bl	8015eb0 <osTimerStart>
	return result;
 800c696:	7ffb      	ldrb	r3, [r7, #31]
}
 800c698:	4618      	mov	r0, r3
 800c69a:	3720      	adds	r7, #32
 800c69c:	46bd      	mov	sp, r7
 800c69e:	bd80      	pop	{r7, pc}
 800c6a0:	2001221c 	.word	0x2001221c
 800c6a4:	08022654 	.word	0x08022654
 800c6a8:	0800c2a1 	.word	0x0800c2a1

0800c6ac <j1939strncmp>:

#include "SAEJ1939.h"

static signed char j1939strncmp(const char *cs, const char *ct, unsigned long count)
{
 800c6ac:	b480      	push	{r7}
 800c6ae:	b087      	sub	sp, #28
 800c6b0:	af00      	add	r7, sp, #0
 800c6b2:	60f8      	str	r0, [r7, #12]
 800c6b4:	60b9      	str	r1, [r7, #8]
 800c6b6:	607a      	str	r2, [r7, #4]
    signed char __res = 0;
 800c6b8:	2300      	movs	r3, #0
 800c6ba:	75fb      	strb	r3, [r7, #23]
	
	if((cs == NULL) || (ct == NULL))
 800c6bc:	68fb      	ldr	r3, [r7, #12]
 800c6be:	2b00      	cmp	r3, #0
 800c6c0:	d002      	beq.n	800c6c8 <j1939strncmp+0x1c>
 800c6c2:	68bb      	ldr	r3, [r7, #8]
 800c6c4:	2b00      	cmp	r3, #0
 800c6c6:	d101      	bne.n	800c6cc <j1939strncmp+0x20>
	{
		return 1;
 800c6c8:	2301      	movs	r3, #1
 800c6ca:	e017      	b.n	800c6fc <j1939strncmp+0x50>
	}
    while (count)
 800c6cc:	e012      	b.n	800c6f4 <j1939strncmp+0x48>
    {
        if ((__res = *cs++ - *ct++) != 0 )
 800c6ce:	68fb      	ldr	r3, [r7, #12]
 800c6d0:	1c5a      	adds	r2, r3, #1
 800c6d2:	60fa      	str	r2, [r7, #12]
 800c6d4:	781a      	ldrb	r2, [r3, #0]
 800c6d6:	68bb      	ldr	r3, [r7, #8]
 800c6d8:	1c59      	adds	r1, r3, #1
 800c6da:	60b9      	str	r1, [r7, #8]
 800c6dc:	781b      	ldrb	r3, [r3, #0]
 800c6de:	1ad3      	subs	r3, r2, r3
 800c6e0:	b2db      	uxtb	r3, r3
 800c6e2:	75fb      	strb	r3, [r7, #23]
 800c6e4:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800c6e8:	2b00      	cmp	r3, #0
 800c6ea:	d000      	beq.n	800c6ee <j1939strncmp+0x42>
            break;
 800c6ec:	e005      	b.n	800c6fa <j1939strncmp+0x4e>
        count --;
 800c6ee:	687b      	ldr	r3, [r7, #4]
 800c6f0:	3b01      	subs	r3, #1
 800c6f2:	607b      	str	r3, [r7, #4]
	
	if((cs == NULL) || (ct == NULL))
	{
		return 1;
	}
    while (count)
 800c6f4:	687b      	ldr	r3, [r7, #4]
 800c6f6:	2b00      	cmp	r3, #0
 800c6f8:	d1e9      	bne.n	800c6ce <j1939strncmp+0x22>
        if ((__res = *cs++ - *ct++) != 0 )
            break;
        count --;
    }

    return __res;
 800c6fa:	7dfb      	ldrb	r3, [r7, #23]
 800c6fc:	b25b      	sxtb	r3, r3
}
 800c6fe:	4618      	mov	r0, r3
 800c700:	371c      	adds	r7, #28
 800c702:	46bd      	mov	sp, r7
 800c704:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c708:	4770      	bx	lr
 800c70a:	bf00      	nop

0800c70c <CA_FindAddress>:

unsigned char CA_FindAddress(CA_list_t calist,CA_Msg_t ca_msg)
{
 800c70c:	b580      	push	{r7, lr}
 800c70e:	b086      	sub	sp, #24
 800c710:	af00      	add	r7, sp, #0
 800c712:	6078      	str	r0, [r7, #4]
 800c714:	6039      	str	r1, [r7, #0]
	list_node_t node;
	struct CA_node *canode;
	J1939_CAname_t CAname = ca_msg->CAname;
 800c716:	683b      	ldr	r3, [r7, #0]
 800c718:	681b      	ldr	r3, [r3, #0]
 800c71a:	613b      	str	r3, [r7, #16]
	CA_Msg_t tmp_ca_msg;
	
	for(node = calist->head.next; node != &(calist->head); node = node->next)
 800c71c:	687b      	ldr	r3, [r7, #4]
 800c71e:	685b      	ldr	r3, [r3, #4]
 800c720:	617b      	str	r3, [r7, #20]
 800c722:	e015      	b.n	800c750 <CA_FindAddress+0x44>
	{
		canode = rt_list_entry(node, struct CA_node, node);
 800c724:	697b      	ldr	r3, [r7, #20]
 800c726:	3b04      	subs	r3, #4
 800c728:	60fb      	str	r3, [r7, #12]
		tmp_ca_msg = canode->ca_msg;
 800c72a:	68fb      	ldr	r3, [r7, #12]
 800c72c:	681b      	ldr	r3, [r3, #0]
 800c72e:	60bb      	str	r3, [r7, #8]
		if(j1939strncmp((char *)CAname,(char *)tmp_ca_msg->CAname,sizeof(struct J1939_CAname)) == 0)
 800c730:	68bb      	ldr	r3, [r7, #8]
 800c732:	681b      	ldr	r3, [r3, #0]
 800c734:	6938      	ldr	r0, [r7, #16]
 800c736:	4619      	mov	r1, r3
 800c738:	2208      	movs	r2, #8
 800c73a:	f7ff ffb7 	bl	800c6ac <j1939strncmp>
 800c73e:	4603      	mov	r3, r0
 800c740:	2b00      	cmp	r3, #0
 800c742:	d102      	bne.n	800c74a <CA_FindAddress+0x3e>
		{
			return (tmp_ca_msg->msg.SourceAddress);
 800c744:	68bb      	ldr	r3, [r7, #8]
 800c746:	79db      	ldrb	r3, [r3, #7]
 800c748:	e008      	b.n	800c75c <CA_FindAddress+0x50>
	list_node_t node;
	struct CA_node *canode;
	J1939_CAname_t CAname = ca_msg->CAname;
	CA_Msg_t tmp_ca_msg;
	
	for(node = calist->head.next; node != &(calist->head); node = node->next)
 800c74a:	697b      	ldr	r3, [r7, #20]
 800c74c:	681b      	ldr	r3, [r3, #0]
 800c74e:	617b      	str	r3, [r7, #20]
 800c750:	687b      	ldr	r3, [r7, #4]
 800c752:	1d1a      	adds	r2, r3, #4
 800c754:	697b      	ldr	r3, [r7, #20]
 800c756:	429a      	cmp	r2, r3
 800c758:	d1e4      	bne.n	800c724 <CA_FindAddress+0x18>
		{
			return (tmp_ca_msg->msg.SourceAddress);
		}
	}
	
	return 254;
 800c75a:	23fe      	movs	r3, #254	; 0xfe
}
 800c75c:	4618      	mov	r0, r3
 800c75e:	3718      	adds	r7, #24
 800c760:	46bd      	mov	sp, r7
 800c762:	bd80      	pop	{r7, pc}

0800c764 <Addr_FindCA>:
CA_Msg_t Addr_FindCA(CA_list_t calist, unsigned char addr)
{
 800c764:	b480      	push	{r7}
 800c766:	b087      	sub	sp, #28
 800c768:	af00      	add	r7, sp, #0
 800c76a:	6078      	str	r0, [r7, #4]
 800c76c:	460b      	mov	r3, r1
 800c76e:	70fb      	strb	r3, [r7, #3]
	list_node_t node;
	struct CA_node *canode;
	CA_Msg_t tmp_ca_msg;

	for(node = calist->head.next; node != &(calist->head); node = node->next)
 800c770:	687b      	ldr	r3, [r7, #4]
 800c772:	685b      	ldr	r3, [r3, #4]
 800c774:	617b      	str	r3, [r7, #20]
 800c776:	e010      	b.n	800c79a <Addr_FindCA+0x36>
	{
		unsigned char i=0;
 800c778:	2300      	movs	r3, #0
 800c77a:	73fb      	strb	r3, [r7, #15]
		canode = rt_list_entry(node, struct CA_node, node);
 800c77c:	697b      	ldr	r3, [r7, #20]
 800c77e:	3b04      	subs	r3, #4
 800c780:	60bb      	str	r3, [r7, #8]
		tmp_ca_msg = canode->ca_msg;
 800c782:	68bb      	ldr	r3, [r7, #8]
 800c784:	681b      	ldr	r3, [r3, #0]
 800c786:	613b      	str	r3, [r7, #16]
		if(tmp_ca_msg->msg.SourceAddress == addr)
 800c788:	693b      	ldr	r3, [r7, #16]
 800c78a:	79db      	ldrb	r3, [r3, #7]
 800c78c:	78fa      	ldrb	r2, [r7, #3]
 800c78e:	429a      	cmp	r2, r3
 800c790:	d100      	bne.n	800c794 <Addr_FindCA+0x30>
			break;
 800c792:	e007      	b.n	800c7a4 <Addr_FindCA+0x40>
{
	list_node_t node;
	struct CA_node *canode;
	CA_Msg_t tmp_ca_msg;

	for(node = calist->head.next; node != &(calist->head); node = node->next)
 800c794:	697b      	ldr	r3, [r7, #20]
 800c796:	681b      	ldr	r3, [r3, #0]
 800c798:	617b      	str	r3, [r7, #20]
 800c79a:	687b      	ldr	r3, [r7, #4]
 800c79c:	1d1a      	adds	r2, r3, #4
 800c79e:	697b      	ldr	r3, [r7, #20]
 800c7a0:	429a      	cmp	r2, r3
 800c7a2:	d1e9      	bne.n	800c778 <Addr_FindCA+0x14>
		canode = rt_list_entry(node, struct CA_node, node);
		tmp_ca_msg = canode->ca_msg;
		if(tmp_ca_msg->msg.SourceAddress == addr)
			break;
	}
	if(node == &(calist->head) )
 800c7a4:	687b      	ldr	r3, [r7, #4]
 800c7a6:	1d1a      	adds	r2, r3, #4
 800c7a8:	697b      	ldr	r3, [r7, #20]
 800c7aa:	429a      	cmp	r2, r3
 800c7ac:	d101      	bne.n	800c7b2 <Addr_FindCA+0x4e>
		return NULL;
 800c7ae:	2300      	movs	r3, #0
 800c7b0:	e000      	b.n	800c7b4 <Addr_FindCA+0x50>
	else
		return tmp_ca_msg;
 800c7b2:	693b      	ldr	r3, [r7, #16]

}
 800c7b4:	4618      	mov	r0, r3
 800c7b6:	371c      	adds	r7, #28
 800c7b8:	46bd      	mov	sp, r7
 800c7ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7be:	4770      	bx	lr

0800c7c0 <J1939_RequestForAddressClaimHandling>:

unsigned char J1939_RequestForAddressClaimHandling( J1939_msg_t j1939_msg ,CA_Msg_t CA_msg )
{
 800c7c0:	b580      	push	{r7, lr}
 800c7c2:	b084      	sub	sp, #16
 800c7c4:	af00      	add	r7, sp, #0
 800c7c6:	6078      	str	r0, [r7, #4]
 800c7c8:	6039      	str	r1, [r7, #0]
	unsigned char i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 800c7ca:	683b      	ldr	r3, [r7, #0]
 800c7cc:	681b      	ldr	r3, [r3, #0]
 800c7ce:	60bb      	str	r3, [r7, #8]

	if (CA_msg->nm.cannotClaimAddr)
 800c7d0:	683b      	ldr	r3, [r7, #0]
 800c7d2:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 800c7d6:	2b00      	cmp	r3, #0
 800c7d8:	d003      	beq.n	800c7e2 <J1939_RequestForAddressClaimHandling+0x22>
		j1939_msg->SourceAddress = J1939_NULL_ADDRESS;	// Send Cannot Claim Address message
 800c7da:	687b      	ldr	r3, [r7, #4]
 800c7dc:	22fe      	movs	r2, #254	; 0xfe
 800c7de:	70da      	strb	r2, [r3, #3]
 800c7e0:	e003      	b.n	800c7ea <J1939_RequestForAddressClaimHandling+0x2a>
	else
		j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;		// Send Address Claim for current address
 800c7e2:	683b      	ldr	r3, [r7, #0]
 800c7e4:	79da      	ldrb	r2, [r3, #7]
 800c7e6:	687b      	ldr	r3, [r7, #4]
 800c7e8:	70da      	strb	r2, [r3, #3]

	j1939_msg->Priority = 6;
 800c7ea:	687a      	ldr	r2, [r7, #4]
 800c7ec:	7813      	ldrb	r3, [r2, #0]
 800c7ee:	2106      	movs	r1, #6
 800c7f0:	f361 1347 	bfi	r3, r1, #5, #3
 800c7f4:	7013      	strb	r3, [r2, #0]
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
 800c7f6:	687b      	ldr	r3, [r7, #4]
 800c7f8:	22ee      	movs	r2, #238	; 0xee
 800c7fa:	705a      	strb	r2, [r3, #1]
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
 800c7fc:	687b      	ldr	r3, [r7, #4]
 800c7fe:	22ff      	movs	r2, #255	; 0xff
 800c800:	709a      	strb	r2, [r3, #2]
	j1939_msg->DataLength = J1939_DATA_LENGTH;
 800c802:	687a      	ldr	r2, [r7, #4]
 800c804:	7913      	ldrb	r3, [r2, #4]
 800c806:	2108      	movs	r1, #8
 800c808:	f361 0303 	bfi	r3, r1, #0, #4
 800c80c:	7113      	strb	r3, [r2, #4]

	for (i=0; i<J1939_DATA_LENGTH; i++)
 800c80e:	2300      	movs	r3, #0
 800c810:	73fb      	strb	r3, [r7, #15]
 800c812:	e00b      	b.n	800c82c <J1939_RequestForAddressClaimHandling+0x6c>
		j1939_msg->Data[i] = CA_Name[i];
 800c814:	7bfb      	ldrb	r3, [r7, #15]
 800c816:	7bfa      	ldrb	r2, [r7, #15]
 800c818:	68b9      	ldr	r1, [r7, #8]
 800c81a:	440a      	add	r2, r1
 800c81c:	7811      	ldrb	r1, [r2, #0]
 800c81e:	687a      	ldr	r2, [r7, #4]
 800c820:	4413      	add	r3, r2
 800c822:	460a      	mov	r2, r1
 800c824:	715a      	strb	r2, [r3, #5]
	j1939_msg->Priority = 6;
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg->DataLength = J1939_DATA_LENGTH;

	for (i=0; i<J1939_DATA_LENGTH; i++)
 800c826:	7bfb      	ldrb	r3, [r7, #15]
 800c828:	3301      	adds	r3, #1
 800c82a:	73fb      	strb	r3, [r7, #15]
 800c82c:	7bfb      	ldrb	r3, [r7, #15]
 800c82e:	2b07      	cmp	r3, #7
 800c830:	d9f0      	bls.n	800c814 <J1939_RequestForAddressClaimHandling+0x54>
		j1939_msg->Data[i] = CA_Name[i];
	
	return writeCan(j1939_msg);
 800c832:	6878      	ldr	r0, [r7, #4]
 800c834:	f000 f92e 	bl	800ca94 <writeCan>
 800c838:	4603      	mov	r3, r0
}
 800c83a:	4618      	mov	r0, r3
 800c83c:	3710      	adds	r7, #16
 800c83e:	46bd      	mov	sp, r7
 800c840:	bd80      	pop	{r7, pc}
 800c842:	bf00      	nop

0800c844 <CompareName>:

signed char CompareName( unsigned char *OtherName,CA_Msg_t CA_msg  )
{
 800c844:	b480      	push	{r7}
 800c846:	b085      	sub	sp, #20
 800c848:	af00      	add	r7, sp, #0
 800c84a:	6078      	str	r0, [r7, #4]
 800c84c:	6039      	str	r1, [r7, #0]
	unsigned char	i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 800c84e:	683b      	ldr	r3, [r7, #0]
 800c850:	681b      	ldr	r3, [r3, #0]
 800c852:	60bb      	str	r3, [r7, #8]
	
	for (i = 0; (i<J1939_DATA_LENGTH) && (OtherName[i] == CA_Name[i]); i++);
 800c854:	2300      	movs	r3, #0
 800c856:	73fb      	strb	r3, [r7, #15]
 800c858:	e002      	b.n	800c860 <CompareName+0x1c>
 800c85a:	7bfb      	ldrb	r3, [r7, #15]
 800c85c:	3301      	adds	r3, #1
 800c85e:	73fb      	strb	r3, [r7, #15]
 800c860:	7bfb      	ldrb	r3, [r7, #15]
 800c862:	2b07      	cmp	r3, #7
 800c864:	d809      	bhi.n	800c87a <CompareName+0x36>
 800c866:	7bfb      	ldrb	r3, [r7, #15]
 800c868:	687a      	ldr	r2, [r7, #4]
 800c86a:	4413      	add	r3, r2
 800c86c:	781a      	ldrb	r2, [r3, #0]
 800c86e:	7bfb      	ldrb	r3, [r7, #15]
 800c870:	68b9      	ldr	r1, [r7, #8]
 800c872:	440b      	add	r3, r1
 800c874:	781b      	ldrb	r3, [r3, #0]
 800c876:	429a      	cmp	r2, r3
 800c878:	d0ef      	beq.n	800c85a <CompareName+0x16>

	if (i == J1939_DATA_LENGTH)
 800c87a:	7bfb      	ldrb	r3, [r7, #15]
 800c87c:	2b08      	cmp	r3, #8
 800c87e:	d101      	bne.n	800c884 <CompareName+0x40>
		return 0;
 800c880:	2300      	movs	r3, #0
 800c882:	e00c      	b.n	800c89e <CompareName+0x5a>
	else if (CA_Name[i] < OtherName[i] )
 800c884:	7bfb      	ldrb	r3, [r7, #15]
 800c886:	68ba      	ldr	r2, [r7, #8]
 800c888:	4413      	add	r3, r2
 800c88a:	781a      	ldrb	r2, [r3, #0]
 800c88c:	7bfb      	ldrb	r3, [r7, #15]
 800c88e:	6879      	ldr	r1, [r7, #4]
 800c890:	440b      	add	r3, r1
 800c892:	781b      	ldrb	r3, [r3, #0]
 800c894:	429a      	cmp	r2, r3
 800c896:	d201      	bcs.n	800c89c <CompareName+0x58>
		return -1;
 800c898:	23ff      	movs	r3, #255	; 0xff
 800c89a:	e000      	b.n	800c89e <CompareName+0x5a>
	else
		return 1;
 800c89c:	2301      	movs	r3, #1
 800c89e:	b25b      	sxtb	r3, r3
}
 800c8a0:	4618      	mov	r0, r3
 800c8a2:	3714      	adds	r7, #20
 800c8a4:	46bd      	mov	sp, r7
 800c8a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8aa:	4770      	bx	lr

0800c8ac <J1939_AddressClaimHandling>:

unsigned char J1939_AddressClaimHandling(  J1939_msg_t j1939_msg ,CA_Msg_t CA_msg  )
{
 800c8ac:	b580      	push	{r7, lr}
 800c8ae:	b084      	sub	sp, #16
 800c8b0:	af00      	add	r7, sp, #0
 800c8b2:	6078      	str	r0, [r7, #4]
 800c8b4:	6039      	str	r1, [r7, #0]

	unsigned char i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 800c8b6:	683b      	ldr	r3, [r7, #0]
 800c8b8:	681b      	ldr	r3, [r3, #0]
 800c8ba:	60bb      	str	r3, [r7, #8]
	
	j1939_msg->Priority = 6;
 800c8bc:	687a      	ldr	r2, [r7, #4]
 800c8be:	7813      	ldrb	r3, [r2, #0]
 800c8c0:	2106      	movs	r1, #6
 800c8c2:	f361 1347 	bfi	r3, r1, #5, #3
 800c8c6:	7013      	strb	r3, [r2, #0]
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;
 800c8c8:	687b      	ldr	r3, [r7, #4]
 800c8ca:	22ee      	movs	r2, #238	; 0xee
 800c8cc:	705a      	strb	r2, [r3, #1]
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
 800c8ce:	687b      	ldr	r3, [r7, #4]
 800c8d0:	22ff      	movs	r2, #255	; 0xff
 800c8d2:	709a      	strb	r2, [r3, #2]
	j1939_msg->DataLength = J1939_DATA_LENGTH;
 800c8d4:	687a      	ldr	r2, [r7, #4]
 800c8d6:	7913      	ldrb	r3, [r2, #4]
 800c8d8:	2108      	movs	r1, #8
 800c8da:	f361 0303 	bfi	r3, r1, #0, #4
 800c8de:	7113      	strb	r3, [r2, #4]


	//if (j1939_msg->SourceAddress != CA_msg->msg.SourceAddress)
	//	return RC_ERROR;

	if (CompareName( j1939_msg->Data,CA_msg ) != -1) // Our CA_Name is not less
 800c8e0:	687b      	ldr	r3, [r7, #4]
 800c8e2:	3305      	adds	r3, #5
 800c8e4:	4618      	mov	r0, r3
 800c8e6:	6839      	ldr	r1, [r7, #0]
 800c8e8:	f7ff ffac 	bl	800c844 <CompareName>
 800c8ec:	4603      	mov	r3, r0
 800c8ee:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c8f2:	d022      	beq.n	800c93a <J1939_AddressClaimHandling+0x8e>
	{

		for (i=0; i<J1939_DATA_LENGTH; i++)
 800c8f4:	2300      	movs	r3, #0
 800c8f6:	73fb      	strb	r3, [r7, #15]
 800c8f8:	e00b      	b.n	800c912 <J1939_AddressClaimHandling+0x66>
			j1939_msg->Data[i] = CA_Name[i];
 800c8fa:	7bfb      	ldrb	r3, [r7, #15]
 800c8fc:	7bfa      	ldrb	r2, [r7, #15]
 800c8fe:	68b9      	ldr	r1, [r7, #8]
 800c900:	440a      	add	r2, r1
 800c902:	7811      	ldrb	r1, [r2, #0]
 800c904:	687a      	ldr	r2, [r7, #4]
 800c906:	4413      	add	r3, r2
 800c908:	460a      	mov	r2, r1
 800c90a:	715a      	strb	r2, [r3, #5]
	//	return RC_ERROR;

	if (CompareName( j1939_msg->Data,CA_msg ) != -1) // Our CA_Name is not less
	{

		for (i=0; i<J1939_DATA_LENGTH; i++)
 800c90c:	7bfb      	ldrb	r3, [r7, #15]
 800c90e:	3301      	adds	r3, #1
 800c910:	73fb      	strb	r3, [r7, #15]
 800c912:	7bfb      	ldrb	r3, [r7, #15]
 800c914:	2b07      	cmp	r3, #7
 800c916:	d9f0      	bls.n	800c8fa <J1939_AddressClaimHandling+0x4e>
			j1939_msg->Data[i] = CA_Name[i];
		
		j1939_msg->SourceAddress = J1939_NULL_ADDRESS;
 800c918:	687b      	ldr	r3, [r7, #4]
 800c91a:	22fe      	movs	r2, #254	; 0xfe
 800c91c:	70da      	strb	r2, [r3, #3]
		if(writeCan(j1939_msg)== RC_SUCCESS)
 800c91e:	6878      	ldr	r0, [r7, #4]
 800c920:	f000 f8b8 	bl	800ca94 <writeCan>
 800c924:	4603      	mov	r3, r0
 800c926:	2b00      	cmp	r3, #0
 800c928:	d105      	bne.n	800c936 <J1939_AddressClaimHandling+0x8a>
		{
			CA_msg->nm.t250.release = 1;
 800c92a:	683b      	ldr	r3, [r7, #0]
 800c92c:	2201      	movs	r2, #1
 800c92e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
			return RC_SUCCESS;
 800c932:	2300      	movs	r3, #0
 800c934:	e042      	b.n	800c9bc <J1939_AddressClaimHandling+0x110>
		}
		else 
			return RC_CANNOTTRANSMIT;
 800c936:	230a      	movs	r3, #10
 800c938:	e040      	b.n	800c9bc <J1939_AddressClaimHandling+0x110>
	}
	
	for (i=0; i<J1939_DATA_LENGTH; i++)
 800c93a:	2300      	movs	r3, #0
 800c93c:	73fb      	strb	r3, [r7, #15]
 800c93e:	e00b      	b.n	800c958 <J1939_AddressClaimHandling+0xac>
		j1939_msg->Data[i] = CA_Name[i];
 800c940:	7bfb      	ldrb	r3, [r7, #15]
 800c942:	7bfa      	ldrb	r2, [r7, #15]
 800c944:	68b9      	ldr	r1, [r7, #8]
 800c946:	440a      	add	r2, r1
 800c948:	7811      	ldrb	r1, [r2, #0]
 800c94a:	687a      	ldr	r2, [r7, #4]
 800c94c:	4413      	add	r3, r2
 800c94e:	460a      	mov	r2, r1
 800c950:	715a      	strb	r2, [r3, #5]
		}
		else 
			return RC_CANNOTTRANSMIT;
	}
	
	for (i=0; i<J1939_DATA_LENGTH; i++)
 800c952:	7bfb      	ldrb	r3, [r7, #15]
 800c954:	3301      	adds	r3, #1
 800c956:	73fb      	strb	r3, [r7, #15]
 800c958:	7bfb      	ldrb	r3, [r7, #15]
 800c95a:	2b07      	cmp	r3, #7
 800c95c:	d9f0      	bls.n	800c940 <J1939_AddressClaimHandling+0x94>
		j1939_msg->Data[i] = CA_Name[i];

	j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;
 800c95e:	683b      	ldr	r3, [r7, #0]
 800c960:	79da      	ldrb	r2, [r3, #7]
 800c962:	687b      	ldr	r3, [r7, #4]
 800c964:	70da      	strb	r2, [r3, #3]
	
	if (writeCan(j1939_msg ) == RC_SUCCESS)
 800c966:	6878      	ldr	r0, [r7, #4]
 800c968:	f000 f894 	bl	800ca94 <writeCan>
 800c96c:	4603      	mov	r3, r0
 800c96e:	2b00      	cmp	r3, #0
 800c970:	d121      	bne.n	800c9b6 <J1939_AddressClaimHandling+0x10a>
	{
		if ((( CA_msg->msg.SourceAddress & 0x80) == 0) ||			// Addresses 0-127
 800c972:	683b      	ldr	r3, [r7, #0]
 800c974:	79db      	ldrb	r3, [r3, #7]
 800c976:	b2db      	uxtb	r3, r3
 800c978:	b25b      	sxtb	r3, r3
 800c97a:	2b00      	cmp	r3, #0
 800c97c:	da05      	bge.n	800c98a <J1939_AddressClaimHandling+0xde>
			(( CA_msg->msg.SourceAddress & 0xF8) == 0xF8))		// Addresses 248-253 (254,255 illegal)
 800c97e:	683b      	ldr	r3, [r7, #0]
 800c980:	79db      	ldrb	r3, [r3, #7]
 800c982:	f003 03f8 	and.w	r3, r3, #248	; 0xf8

	j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;
	
	if (writeCan(j1939_msg ) == RC_SUCCESS)
	{
		if ((( CA_msg->msg.SourceAddress & 0x80) == 0) ||			// Addresses 0-127
 800c986:	2bf8      	cmp	r3, #248	; 0xf8
 800c988:	d104      	bne.n	800c994 <J1939_AddressClaimHandling+0xe8>
			(( CA_msg->msg.SourceAddress & 0xF8) == 0xF8))		// Addresses 248-253 (254,255 illegal)
		{
			CA_msg->nm.cannotClaimAddr = 0;
 800c98a:	683b      	ldr	r3, [r7, #0]
 800c98c:	2200      	movs	r2, #0
 800c98e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800c992:	e012      	b.n	800c9ba <J1939_AddressClaimHandling+0x10e>
		}
		else
		{
			// We don't have a proprietary address, so we need to wait.
	 		CA_msg->nm.WaitingForAddressClaimContention = 1;
 800c994:	683b      	ldr	r3, [r7, #0]
 800c996:	2201      	movs	r2, #1
 800c998:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	 		//if (CA_msg->nm.WaitingForAddressClaimContention == 0)
	 		//{
			//	CA_msg->nm.cannotClaimAddr = 0;
	 		//}
			#if 1
			CA_msg->nm.t250.value = 250;
 800c99c:	683b      	ldr	r3, [r7, #0]
 800c99e:	22fa      	movs	r2, #250	; 0xfa
 800c9a0:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
			CA_msg->nm.t250.en = 1;
 800c9a4:	683b      	ldr	r3, [r7, #0]
 800c9a6:	2201      	movs	r2, #1
 800c9a8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
			CA_msg->nm.t250.release = 0;
 800c9ac:	683b      	ldr	r3, [r7, #0]
 800c9ae:	2200      	movs	r2, #0
 800c9b0:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
 800c9b4:	e001      	b.n	800c9ba <J1939_AddressClaimHandling+0x10e>
			#endif
		}
	}
	else 
		return RC_CANNOTTRANSMIT;
 800c9b6:	230a      	movs	r3, #10
 800c9b8:	e000      	b.n	800c9bc <J1939_AddressClaimHandling+0x110>
	return RC_SUCCESS;
 800c9ba:	2300      	movs	r3, #0
}
 800c9bc:	4618      	mov	r0, r3
 800c9be:	3710      	adds	r7, #16
 800c9c0:	46bd      	mov	sp, r7
 800c9c2:	bd80      	pop	{r7, pc}

0800c9c4 <sendAddrClaimed>:

unsigned char sendAddrClaimed(CA_Msg_t CA_msg)
{
 800c9c4:	b580      	push	{r7, lr}
 800c9c6:	b088      	sub	sp, #32
 800c9c8:	af00      	add	r7, sp, #0
 800c9ca:	6078      	str	r0, [r7, #4]
	struct J1939_msg j1939_msg;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 800c9cc:	687b      	ldr	r3, [r7, #4]
 800c9ce:	681b      	ldr	r3, [r3, #0]
 800c9d0:	61bb      	str	r3, [r7, #24]
	unsigned char i;
	
	CA_msg->nm.cannotClaimAddr = 1;
 800c9d2:	687b      	ldr	r3, [r7, #4]
 800c9d4:	2201      	movs	r2, #1
 800c9d6:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;		// Send Address Claim for current address
 800c9da:	687b      	ldr	r3, [r7, #4]
 800c9dc:	79db      	ldrb	r3, [r3, #7]
 800c9de:	72fb      	strb	r3, [r7, #11]
	j1939_msg.Priority = 6;
 800c9e0:	7a3b      	ldrb	r3, [r7, #8]
 800c9e2:	2206      	movs	r2, #6
 800c9e4:	f362 1347 	bfi	r3, r2, #5, #3
 800c9e8:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 800c9ea:	7a3b      	ldrb	r3, [r7, #8]
 800c9ec:	f36f 1304 	bfc	r3, #4, #1
 800c9f0:	723b      	strb	r3, [r7, #8]
	j1939_msg.DataPage = 0;
 800c9f2:	7a3b      	ldrb	r3, [r7, #8]
 800c9f4:	f36f 03c3 	bfc	r3, #3, #1
 800c9f8:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
 800c9fa:	23ee      	movs	r3, #238	; 0xee
 800c9fc:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 800c9fe:	23ff      	movs	r3, #255	; 0xff
 800ca00:	72bb      	strb	r3, [r7, #10]
	j1939_msg.DataLength = J1939_DATA_LENGTH;
 800ca02:	7b3b      	ldrb	r3, [r7, #12]
 800ca04:	2208      	movs	r2, #8
 800ca06:	f362 0303 	bfi	r3, r2, #0, #4
 800ca0a:	733b      	strb	r3, [r7, #12]

	for (i=0; i<J1939_DATA_LENGTH; i++)
 800ca0c:	2300      	movs	r3, #0
 800ca0e:	77fb      	strb	r3, [r7, #31]
 800ca10:	e00c      	b.n	800ca2c <sendAddrClaimed+0x68>
		j1939_msg.Data[i] = CA_Name[i];
 800ca12:	7ffb      	ldrb	r3, [r7, #31]
 800ca14:	7ffa      	ldrb	r2, [r7, #31]
 800ca16:	69b9      	ldr	r1, [r7, #24]
 800ca18:	440a      	add	r2, r1
 800ca1a:	7812      	ldrb	r2, [r2, #0]
 800ca1c:	f107 0120 	add.w	r1, r7, #32
 800ca20:	440b      	add	r3, r1
 800ca22:	f803 2c13 	strb.w	r2, [r3, #-19]
	j1939_msg.DataPage = 0;
	j1939_msg.PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg.DataLength = J1939_DATA_LENGTH;

	for (i=0; i<J1939_DATA_LENGTH; i++)
 800ca26:	7ffb      	ldrb	r3, [r7, #31]
 800ca28:	3301      	adds	r3, #1
 800ca2a:	77fb      	strb	r3, [r7, #31]
 800ca2c:	7ffb      	ldrb	r3, [r7, #31]
 800ca2e:	2b07      	cmp	r3, #7
 800ca30:	d9ef      	bls.n	800ca12 <sendAddrClaimed+0x4e>
		j1939_msg.Data[i] = CA_Name[i];
	
	if(writeCan(&j1939_msg)==RC_SUCCESS)
 800ca32:	f107 0308 	add.w	r3, r7, #8
 800ca36:	4618      	mov	r0, r3
 800ca38:	f000 f82c 	bl	800ca94 <writeCan>
 800ca3c:	4603      	mov	r3, r0
 800ca3e:	2b00      	cmp	r3, #0
 800ca40:	d111      	bne.n	800ca66 <sendAddrClaimed+0xa2>
	{
		// We don't have a proprietary address, so we need to wait.
		CA_msg->nm.WaitingForAddressClaimContention = 1;
 800ca42:	687b      	ldr	r3, [r7, #4]
 800ca44:	2201      	movs	r2, #1
 800ca46:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
		//if (CA_msg->nm.WaitingForAddressClaimContention == 0)
		//{
		//	CA_msg->nm.cannotClaimAddr = 0;
		//}
		#if 1
		CA_msg->nm.t250.value = 250;
 800ca4a:	687b      	ldr	r3, [r7, #4]
 800ca4c:	22fa      	movs	r2, #250	; 0xfa
 800ca4e:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
		CA_msg->nm.t250.en = 1;
 800ca52:	687b      	ldr	r3, [r7, #4]
 800ca54:	2201      	movs	r2, #1
 800ca56:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
		CA_msg->nm.t250.release = 0;
 800ca5a:	687b      	ldr	r3, [r7, #4]
 800ca5c:	2200      	movs	r2, #0
 800ca5e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
		#endif

		return RC_SUCCESS;
 800ca62:	2300      	movs	r3, #0
 800ca64:	e000      	b.n	800ca68 <sendAddrClaimed+0xa4>
	}
	return RC_CANNOTTRANSMIT;
 800ca66:	230a      	movs	r3, #10
}
 800ca68:	4618      	mov	r0, r3
 800ca6a:	3720      	adds	r7, #32
 800ca6c:	46bd      	mov	sp, r7
 800ca6e:	bd80      	pop	{r7, pc}

0800ca70 <initAddr>:


unsigned char initAddr(CA_Msg_t ca_msg)
{
 800ca70:	b580      	push	{r7, lr}
 800ca72:	b082      	sub	sp, #8
 800ca74:	af00      	add	r7, sp, #0
 800ca76:	6078      	str	r0, [r7, #4]
	if(ca_msg->msg.SourceAddress != 254)
 800ca78:	687b      	ldr	r3, [r7, #4]
 800ca7a:	79db      	ldrb	r3, [r3, #7]
 800ca7c:	2bfe      	cmp	r3, #254	; 0xfe
 800ca7e:	d004      	beq.n	800ca8a <initAddr+0x1a>
	{
		return sendAddrClaimed(ca_msg);
 800ca80:	6878      	ldr	r0, [r7, #4]
 800ca82:	f7ff ff9f 	bl	800c9c4 <sendAddrClaimed>
 800ca86:	4603      	mov	r3, r0
 800ca88:	e000      	b.n	800ca8c <initAddr+0x1c>
	}
	return RC_ERROR;
 800ca8a:	2301      	movs	r3, #1
}
 800ca8c:	4618      	mov	r0, r3
 800ca8e:	3708      	adds	r7, #8
 800ca90:	46bd      	mov	sp, r7
 800ca92:	bd80      	pop	{r7, pc}

0800ca94 <writeCan>:
#include "finsh.h"
#include <rtdevice.h>
#include "SAEJ1939.h"

unsigned char writeCan(J1939_msg_t j1939_msg)
{
 800ca94:	b580      	push	{r7, lr}
 800ca96:	b088      	sub	sp, #32
 800ca98:	af00      	add	r7, sp, #0
 800ca9a:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	device = rt_device_find("can1");
 800ca9c:	4831      	ldr	r0, [pc, #196]	; (800cb64 <writeCan+0xd0>)
 800ca9e:	f005 fa59 	bl	8011f54 <rt_device_find>
 800caa2:	61f8      	str	r0, [r7, #28]
	struct rt_can_msg tmpmsg;
	unsigned long tmp;
	
	if(device != NULL)
 800caa4:	69fb      	ldr	r3, [r7, #28]
 800caa6:	2b00      	cmp	r3, #0
 800caa8:	d057      	beq.n	800cb5a <writeCan+0xc6>
	{
		tmpmsg.data[7] = j1939_msg->Data[7];
 800caaa:	687b      	ldr	r3, [r7, #4]
 800caac:	7b1b      	ldrb	r3, [r3, #12]
 800caae:	75fb      	strb	r3, [r7, #23]
		tmpmsg.data[6] = j1939_msg->Data[6];
 800cab0:	687b      	ldr	r3, [r7, #4]
 800cab2:	7adb      	ldrb	r3, [r3, #11]
 800cab4:	75bb      	strb	r3, [r7, #22]
		tmpmsg.data[5] = j1939_msg->Data[5];
 800cab6:	687b      	ldr	r3, [r7, #4]
 800cab8:	7a9b      	ldrb	r3, [r3, #10]
 800caba:	757b      	strb	r3, [r7, #21]
		tmpmsg.data[4] = j1939_msg->Data[4];
 800cabc:	687b      	ldr	r3, [r7, #4]
 800cabe:	7a5b      	ldrb	r3, [r3, #9]
 800cac0:	753b      	strb	r3, [r7, #20]
		tmpmsg.data[3] = j1939_msg->Data[3];
 800cac2:	687b      	ldr	r3, [r7, #4]
 800cac4:	7a1b      	ldrb	r3, [r3, #8]
 800cac6:	74fb      	strb	r3, [r7, #19]
		tmpmsg.data[2] = j1939_msg->Data[2];
 800cac8:	687b      	ldr	r3, [r7, #4]
 800caca:	79db      	ldrb	r3, [r3, #7]
 800cacc:	74bb      	strb	r3, [r7, #18]
		tmpmsg.data[1] = j1939_msg->Data[1];
 800cace:	687b      	ldr	r3, [r7, #4]
 800cad0:	799b      	ldrb	r3, [r3, #6]
 800cad2:	747b      	strb	r3, [r7, #17]
		tmpmsg.data[0] = j1939_msg->Data[0];
 800cad4:	687b      	ldr	r3, [r7, #4]
 800cad6:	795b      	ldrb	r3, [r3, #5]
 800cad8:	743b      	strb	r3, [r7, #16]
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 800cada:	687b      	ldr	r3, [r7, #4]
 800cadc:	781b      	ldrb	r3, [r3, #0]
 800cade:	f3c3 1342 	ubfx	r3, r3, #5, #3
 800cae2:	b2db      	uxtb	r3, r3
 800cae4:	069a      	lsls	r2, r3, #26
				(unsigned long)(j1939_msg->edp)<<25				|  	\
 800cae6:	687b      	ldr	r3, [r7, #4]
 800cae8:	781b      	ldrb	r3, [r3, #0]
 800caea:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800caee:	b2db      	uxtb	r3, r3
 800caf0:	065b      	lsls	r3, r3, #25
		tmpmsg.data[4] = j1939_msg->Data[4];
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 800caf2:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
 800caf4:	687b      	ldr	r3, [r7, #4]
 800caf6:	781b      	ldrb	r3, [r3, #0]
 800caf8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800cafc:	b2db      	uxtb	r3, r3
 800cafe:	061b      	lsls	r3, r3, #24
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
 800cb00:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
 800cb02:	687b      	ldr	r3, [r7, #4]
 800cb04:	785b      	ldrb	r3, [r3, #1]
 800cb06:	041b      	lsls	r3, r3, #16
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
 800cb08:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
 800cb0a:	687b      	ldr	r3, [r7, #4]
 800cb0c:	789b      	ldrb	r3, [r3, #2]
 800cb0e:	021b      	lsls	r3, r3, #8
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
 800cb10:	4313      	orrs	r3, r2
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
				(unsigned long)(j1939_msg->SourceAddress);		
 800cb12:	687a      	ldr	r2, [r7, #4]
 800cb14:	78d2      	ldrb	r2, [r2, #3]
		tmpmsg.data[4] = j1939_msg->Data[4];
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 800cb16:	4313      	orrs	r3, r2
 800cb18:	61bb      	str	r3, [r7, #24]
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
				(unsigned long)(j1939_msg->SourceAddress);		
		tmpmsg.id = tmp;
 800cb1a:	69bb      	ldr	r3, [r7, #24]
 800cb1c:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 800cb20:	68bb      	ldr	r3, [r7, #8]
 800cb22:	f362 031c 	bfi	r3, r2, #0, #29
 800cb26:	60bb      	str	r3, [r7, #8]
		tmpmsg.ide = 1;
 800cb28:	7afb      	ldrb	r3, [r7, #11]
 800cb2a:	f043 0320 	orr.w	r3, r3, #32
 800cb2e:	72fb      	strb	r3, [r7, #11]
		tmpmsg.len = j1939_msg->DataLength;
 800cb30:	687b      	ldr	r3, [r7, #4]
 800cb32:	791b      	ldrb	r3, [r3, #4]
 800cb34:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800cb38:	b2db      	uxtb	r3, r3
 800cb3a:	733b      	strb	r3, [r7, #12]
		tmpmsg.rtr = 0;
 800cb3c:	7afb      	ldrb	r3, [r7, #11]
 800cb3e:	f36f 1386 	bfc	r3, #6, #1
 800cb42:	72fb      	strb	r3, [r7, #11]
		
		return rt_device_write(device, 0, &tmpmsg,1);
 800cb44:	f107 0308 	add.w	r3, r7, #8
 800cb48:	69f8      	ldr	r0, [r7, #28]
 800cb4a:	2100      	movs	r1, #0
 800cb4c:	461a      	mov	r2, r3
 800cb4e:	2301      	movs	r3, #1
 800cb50:	f005 fb22 	bl	8012198 <rt_device_write>
 800cb54:	4603      	mov	r3, r0
 800cb56:	b2db      	uxtb	r3, r3
 800cb58:	e000      	b.n	800cb5c <writeCan+0xc8>
	}
	return RC_ERROR;
 800cb5a:	2301      	movs	r3, #1
}
 800cb5c:	4618      	mov	r0, r3
 800cb5e:	3720      	adds	r7, #32
 800cb60:	46bd      	mov	sp, r7
 800cb62:	bd80      	pop	{r7, pc}
 800cb64:	08022660 	.word	0x08022660

0800cb68 <readCan>:

unsigned char readCan(J1939_msg_t j1939_msg)
{
 800cb68:	b580      	push	{r7, lr}
 800cb6a:	b08a      	sub	sp, #40	; 0x28
 800cb6c:	af00      	add	r7, sp, #0
 800cb6e:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	device = rt_device_find("can1");
 800cb70:	4841      	ldr	r0, [pc, #260]	; (800cc78 <readCan+0x110>)
 800cb72:	f005 f9ef 	bl	8011f54 <rt_device_find>
 800cb76:	6238      	str	r0, [r7, #32]
	struct rt_can_msg tmpmsg;
	unsigned char i,size;
	unsigned char result;
	
	if(device != NULL)
 800cb78:	6a3b      	ldr	r3, [r7, #32]
 800cb7a:	2b00      	cmp	r3, #0
 800cb7c:	d077      	beq.n	800cc6e <readCan+0x106>
	{
		size = rt_device_read(device,0,&tmpmsg,sizeof(struct rt_can_msg));
 800cb7e:	f107 030c 	add.w	r3, r7, #12
 800cb82:	6a38      	ldr	r0, [r7, #32]
 800cb84:	2100      	movs	r1, #0
 800cb86:	461a      	mov	r2, r3
 800cb88:	2310      	movs	r3, #16
 800cb8a:	f005 fad1 	bl	8012130 <rt_device_read>
 800cb8e:	4603      	mov	r3, r0
 800cb90:	77fb      	strb	r3, [r7, #31]
		if (size != 0)
 800cb92:	7ffb      	ldrb	r3, [r7, #31]
 800cb94:	2b00      	cmp	r3, #0
 800cb96:	d066      	beq.n	800cc66 <readCan+0xfe>
		{
			j1939_msg->Priority = tmpmsg.id >> 26;
 800cb98:	68fb      	ldr	r3, [r7, #12]
 800cb9a:	f3c3 031c 	ubfx	r3, r3, #0, #29
 800cb9e:	169b      	asrs	r3, r3, #26
 800cba0:	b2db      	uxtb	r3, r3
 800cba2:	f003 0307 	and.w	r3, r3, #7
 800cba6:	b2d9      	uxtb	r1, r3
 800cba8:	687a      	ldr	r2, [r7, #4]
 800cbaa:	7813      	ldrb	r3, [r2, #0]
 800cbac:	f361 1347 	bfi	r3, r1, #5, #3
 800cbb0:	7013      	strb	r3, [r2, #0]
			j1939_msg->edp = tmpmsg.id >> 25;
 800cbb2:	68fb      	ldr	r3, [r7, #12]
 800cbb4:	f3c3 031c 	ubfx	r3, r3, #0, #29
 800cbb8:	165b      	asrs	r3, r3, #25
 800cbba:	b2db      	uxtb	r3, r3
 800cbbc:	f003 0301 	and.w	r3, r3, #1
 800cbc0:	b2d9      	uxtb	r1, r3
 800cbc2:	687a      	ldr	r2, [r7, #4]
 800cbc4:	7813      	ldrb	r3, [r2, #0]
 800cbc6:	f361 1304 	bfi	r3, r1, #4, #1
 800cbca:	7013      	strb	r3, [r2, #0]
			j1939_msg->DataPage = tmpmsg.id >> 24;
 800cbcc:	68fb      	ldr	r3, [r7, #12]
 800cbce:	f3c3 031c 	ubfx	r3, r3, #0, #29
 800cbd2:	161b      	asrs	r3, r3, #24
 800cbd4:	b2db      	uxtb	r3, r3
 800cbd6:	f003 0301 	and.w	r3, r3, #1
 800cbda:	b2d9      	uxtb	r1, r3
 800cbdc:	687a      	ldr	r2, [r7, #4]
 800cbde:	7813      	ldrb	r3, [r2, #0]
 800cbe0:	f361 03c3 	bfi	r3, r1, #3, #1
 800cbe4:	7013      	strb	r3, [r2, #0]
			j1939_msg->PDUFormat = tmpmsg.id >> 16;
 800cbe6:	68fb      	ldr	r3, [r7, #12]
 800cbe8:	f3c3 031c 	ubfx	r3, r3, #0, #29
 800cbec:	141b      	asrs	r3, r3, #16
 800cbee:	b2da      	uxtb	r2, r3
 800cbf0:	687b      	ldr	r3, [r7, #4]
 800cbf2:	705a      	strb	r2, [r3, #1]
			j1939_msg->PDUSpecific = tmpmsg.id >> 8;
 800cbf4:	68fb      	ldr	r3, [r7, #12]
 800cbf6:	f3c3 031c 	ubfx	r3, r3, #0, #29
 800cbfa:	121b      	asrs	r3, r3, #8
 800cbfc:	b2da      	uxtb	r2, r3
 800cbfe:	687b      	ldr	r3, [r7, #4]
 800cc00:	709a      	strb	r2, [r3, #2]
			j1939_msg->SourceAddress = tmpmsg.id;
 800cc02:	68fb      	ldr	r3, [r7, #12]
 800cc04:	f3c3 031c 	ubfx	r3, r3, #0, #29
 800cc08:	b2da      	uxtb	r2, r3
 800cc0a:	687b      	ldr	r3, [r7, #4]
 800cc0c:	70da      	strb	r2, [r3, #3]
			j1939_msg->DataLength = tmpmsg.len;
 800cc0e:	7c3b      	ldrb	r3, [r7, #16]
 800cc10:	f003 030f 	and.w	r3, r3, #15
 800cc14:	b2d9      	uxtb	r1, r3
 800cc16:	687a      	ldr	r2, [r7, #4]
 800cc18:	7913      	ldrb	r3, [r2, #4]
 800cc1a:	f361 0303 	bfi	r3, r1, #0, #4
 800cc1e:	7113      	strb	r3, [r2, #4]
			for(i=0;i<j1939_msg->DataLength;i++)
 800cc20:	2300      	movs	r3, #0
 800cc22:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800cc26:	e011      	b.n	800cc4c <readCan+0xe4>
			{
				j1939_msg->Data[i] = tmpmsg.data[i];
 800cc28:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800cc2c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800cc30:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800cc34:	440a      	add	r2, r1
 800cc36:	f812 1c14 	ldrb.w	r1, [r2, #-20]
 800cc3a:	687a      	ldr	r2, [r7, #4]
 800cc3c:	4413      	add	r3, r2
 800cc3e:	460a      	mov	r2, r1
 800cc40:	715a      	strb	r2, [r3, #5]
			j1939_msg->DataPage = tmpmsg.id >> 24;
			j1939_msg->PDUFormat = tmpmsg.id >> 16;
			j1939_msg->PDUSpecific = tmpmsg.id >> 8;
			j1939_msg->SourceAddress = tmpmsg.id;
			j1939_msg->DataLength = tmpmsg.len;
			for(i=0;i<j1939_msg->DataLength;i++)
 800cc42:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800cc46:	3301      	adds	r3, #1
 800cc48:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800cc4c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800cc50:	687a      	ldr	r2, [r7, #4]
 800cc52:	7912      	ldrb	r2, [r2, #4]
 800cc54:	f3c2 0203 	ubfx	r2, r2, #0, #4
 800cc58:	b2d2      	uxtb	r2, r2
 800cc5a:	4293      	cmp	r3, r2
 800cc5c:	dbe4      	blt.n	800cc28 <readCan+0xc0>
			{
				j1939_msg->Data[i] = tmpmsg.data[i];
			}
			return result = RC_SUCCESS;
 800cc5e:	2300      	movs	r3, #0
 800cc60:	77bb      	strb	r3, [r7, #30]
 800cc62:	7fbb      	ldrb	r3, [r7, #30]
 800cc64:	e004      	b.n	800cc70 <readCan+0x108>
		}
		else
			return result = RC_QUEUEEMPTY;
 800cc66:	2309      	movs	r3, #9
 800cc68:	77bb      	strb	r3, [r7, #30]
 800cc6a:	7fbb      	ldrb	r3, [r7, #30]
 800cc6c:	e000      	b.n	800cc70 <readCan+0x108>
	}
	return RC_ERROR;
 800cc6e:	2301      	movs	r3, #1
}
 800cc70:	4618      	mov	r0, r3
 800cc72:	3728      	adds	r7, #40	; 0x28
 800cc74:	46bd      	mov	sp, r7
 800cc76:	bd80      	pop	{r7, pc}
 800cc78:	08022660 	.word	0x08022660

0800cc7c <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 800cc7c:	b480      	push	{r7}
 800cc7e:	b083      	sub	sp, #12
 800cc80:	af00      	add	r7, sp, #0
 800cc82:	6078      	str	r0, [r7, #4]
 800cc84:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 800cc86:	687b      	ldr	r3, [r7, #4]
 800cc88:	685b      	ldr	r3, [r3, #4]
 800cc8a:	683a      	ldr	r2, [r7, #0]
 800cc8c:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 800cc8e:	687b      	ldr	r3, [r7, #4]
 800cc90:	685a      	ldr	r2, [r3, #4]
 800cc92:	683b      	ldr	r3, [r7, #0]
 800cc94:	605a      	str	r2, [r3, #4]

    l->prev = n;
 800cc96:	687b      	ldr	r3, [r7, #4]
 800cc98:	683a      	ldr	r2, [r7, #0]
 800cc9a:	605a      	str	r2, [r3, #4]
    n->next = l;
 800cc9c:	683b      	ldr	r3, [r7, #0]
 800cc9e:	687a      	ldr	r2, [r7, #4]
 800cca0:	601a      	str	r2, [r3, #0]
}
 800cca2:	370c      	adds	r7, #12
 800cca4:	46bd      	mov	sp, r7
 800cca6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccaa:	4770      	bx	lr

0800ccac <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 800ccac:	b480      	push	{r7}
 800ccae:	b083      	sub	sp, #12
 800ccb0:	af00      	add	r7, sp, #0
 800ccb2:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 800ccb4:	687b      	ldr	r3, [r7, #4]
 800ccb6:	681b      	ldr	r3, [r3, #0]
 800ccb8:	687a      	ldr	r2, [r7, #4]
 800ccba:	6852      	ldr	r2, [r2, #4]
 800ccbc:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 800ccbe:	687b      	ldr	r3, [r7, #4]
 800ccc0:	685b      	ldr	r3, [r3, #4]
 800ccc2:	687a      	ldr	r2, [r7, #4]
 800ccc4:	6812      	ldr	r2, [r2, #0]
 800ccc6:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 800ccc8:	687b      	ldr	r3, [r7, #4]
 800ccca:	687a      	ldr	r2, [r7, #4]
 800cccc:	605a      	str	r2, [r3, #4]
 800ccce:	687b      	ldr	r3, [r7, #4]
 800ccd0:	685a      	ldr	r2, [r3, #4]
 800ccd2:	687b      	ldr	r3, [r7, #4]
 800ccd4:	601a      	str	r2, [r3, #0]
}
 800ccd6:	370c      	adds	r7, #12
 800ccd8:	46bd      	mov	sp, r7
 800ccda:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccde:	4770      	bx	lr

0800cce0 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 800cce0:	b480      	push	{r7}
 800cce2:	b083      	sub	sp, #12
 800cce4:	af00      	add	r7, sp, #0
 800cce6:	6078      	str	r0, [r7, #4]
    return l->next == l;
 800cce8:	687b      	ldr	r3, [r7, #4]
 800ccea:	681a      	ldr	r2, [r3, #0]
 800ccec:	687b      	ldr	r3, [r7, #4]
 800ccee:	429a      	cmp	r2, r3
 800ccf0:	bf0c      	ite	eq
 800ccf2:	2301      	moveq	r3, #1
 800ccf4:	2300      	movne	r3, #0
 800ccf6:	b2db      	uxtb	r3, r3
}
 800ccf8:	4618      	mov	r0, r3
 800ccfa:	370c      	adds	r7, #12
 800ccfc:	46bd      	mov	sp, r7
 800ccfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd02:	4770      	bx	lr

0800cd04 <HAL_CAN_TxCpltCallback>:

struct rt_can_device canDevice1;
stm32_canTypeDef can1;

void HAL_CAN_TxCpltCallback(CAN_HandleTypeDef* hcan)
{
 800cd04:	b580      	push	{r7, lr}
 800cd06:	b082      	sub	sp, #8
 800cd08:	af00      	add	r7, sp, #0
 800cd0a:	6078      	str	r0, [r7, #4]
	rt_kprintf("tx complete\r\n");
 800cd0c:	4802      	ldr	r0, [pc, #8]	; (800cd18 <HAL_CAN_TxCpltCallback+0x14>)
 800cd0e:	f006 ffaf 	bl	8013c70 <rt_kprintf>
}
 800cd12:	3708      	adds	r7, #8
 800cd14:	46bd      	mov	sp, r7
 800cd16:	bd80      	pop	{r7, pc}
 800cd18:	08022668 	.word	0x08022668

0800cd1c <CAN1_TX_IRQHandler>:

void CAN1_TX_IRQHandler(void)
{
 800cd1c:	b580      	push	{r7, lr}
 800cd1e:	b090      	sub	sp, #64	; 0x40
 800cd20:	af00      	add	r7, sp, #0
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
    rt_interrupt_enter();
 800cd22:	f006 f995 	bl	8013050 <rt_interrupt_enter>

	hcan.Instance = CAN1;
 800cd26:	4b05      	ldr	r3, [pc, #20]	; (800cd3c <CAN1_TX_IRQHandler+0x20>)
 800cd28:	603b      	str	r3, [r7, #0]
	HAL_CAN_IRQHandler(&hcan);
 800cd2a:	463b      	mov	r3, r7
 800cd2c:	4618      	mov	r0, r3
 800cd2e:	f7f6 f859 	bl	8002de4 <HAL_CAN_IRQHandler>

    /* leave interrupt */
    rt_interrupt_leave();
 800cd32:	f006 f9a3 	bl	801307c <rt_interrupt_leave>

}
 800cd36:	3740      	adds	r7, #64	; 0x40
 800cd38:	46bd      	mov	sp, r7
 800cd3a:	bd80      	pop	{r7, pc}
 800cd3c:	40006400 	.word	0x40006400

0800cd40 <HAL_CAN_RxCpltCallback>:

void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* hcan)
{
 800cd40:	b580      	push	{r7, lr}
 800cd42:	b084      	sub	sp, #16
 800cd44:	af00      	add	r7, sp, #0
 800cd46:	6078      	str	r0, [r7, #4]
	char i;
	rt_kprintf("rx data: ");
 800cd48:	480e      	ldr	r0, [pc, #56]	; (800cd84 <HAL_CAN_RxCpltCallback+0x44>)
 800cd4a:	f006 ff91 	bl	8013c70 <rt_kprintf>
	for(i = 0; i < hcan->pRxMsg->DLC; i++)
 800cd4e:	2300      	movs	r3, #0
 800cd50:	73fb      	strb	r3, [r7, #15]
 800cd52:	e00b      	b.n	800cd6c <HAL_CAN_RxCpltCallback+0x2c>
	{
		rt_kprintf("0x%x ", hcan->pRxMsg->Data[i]);
 800cd54:	687b      	ldr	r3, [r7, #4]
 800cd56:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800cd58:	7bfb      	ldrb	r3, [r7, #15]
 800cd5a:	4413      	add	r3, r2
 800cd5c:	7d1b      	ldrb	r3, [r3, #20]
 800cd5e:	480a      	ldr	r0, [pc, #40]	; (800cd88 <HAL_CAN_RxCpltCallback+0x48>)
 800cd60:	4619      	mov	r1, r3
 800cd62:	f006 ff85 	bl	8013c70 <rt_kprintf>

void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* hcan)
{
	char i;
	rt_kprintf("rx data: ");
	for(i = 0; i < hcan->pRxMsg->DLC; i++)
 800cd66:	7bfb      	ldrb	r3, [r7, #15]
 800cd68:	3301      	adds	r3, #1
 800cd6a:	73fb      	strb	r3, [r7, #15]
 800cd6c:	7bfa      	ldrb	r2, [r7, #15]
 800cd6e:	687b      	ldr	r3, [r7, #4]
 800cd70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cd72:	691b      	ldr	r3, [r3, #16]
 800cd74:	429a      	cmp	r2, r3
 800cd76:	d3ed      	bcc.n	800cd54 <HAL_CAN_RxCpltCallback+0x14>
	{
		rt_kprintf("0x%x ", hcan->pRxMsg->Data[i]);
	}
	rt_kprintf("\r\n");
 800cd78:	4804      	ldr	r0, [pc, #16]	; (800cd8c <HAL_CAN_RxCpltCallback+0x4c>)
 800cd7a:	f006 ff79 	bl	8013c70 <rt_kprintf>
	
}
 800cd7e:	3710      	adds	r7, #16
 800cd80:	46bd      	mov	sp, r7
 800cd82:	bd80      	pop	{r7, pc}
 800cd84:	08022678 	.word	0x08022678
 800cd88:	08022684 	.word	0x08022684
 800cd8c:	0802268c 	.word	0x0802268c

0800cd90 <CAN1_RX0_IRQHandler>:

void CAN1_RX0_IRQHandler(void)
{
 800cd90:	b580      	push	{r7, lr}
 800cd92:	b090      	sub	sp, #64	; 0x40
 800cd94:	af00      	add	r7, sp, #0
	
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
	
    rt_interrupt_enter();
 800cd96:	f006 f95b 	bl	8013050 <rt_interrupt_enter>
	hcan.Instance = CAN1;
 800cd9a:	4b05      	ldr	r3, [pc, #20]	; (800cdb0 <CAN1_RX0_IRQHandler+0x20>)
 800cd9c:	603b      	str	r3, [r7, #0]
	
	HAL_CAN_IRQHandler(&hcan);
 800cd9e:	463b      	mov	r3, r7
 800cda0:	4618      	mov	r0, r3
 800cda2:	f7f6 f81f 	bl	8002de4 <HAL_CAN_IRQHandler>

    /* leave interrupt */
    rt_interrupt_leave();
 800cda6:	f006 f969 	bl	801307c <rt_interrupt_leave>

}
 800cdaa:	3740      	adds	r7, #64	; 0x40
 800cdac:	46bd      	mov	sp, r7
 800cdae:	bd80      	pop	{r7, pc}
 800cdb0:	40006400 	.word	0x40006400

0800cdb4 <CAN1_RX1_IRQHandler>:

void CAN1_RX1_IRQHandler(void)
{
 800cdb4:	b580      	push	{r7, lr}
 800cdb6:	b090      	sub	sp, #64	; 0x40
 800cdb8:	af00      	add	r7, sp, #0
	
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
	rt_interrupt_enter();
 800cdba:	f006 f949 	bl	8013050 <rt_interrupt_enter>

	hcan.Instance = CAN1;
 800cdbe:	4b05      	ldr	r3, [pc, #20]	; (800cdd4 <CAN1_RX1_IRQHandler+0x20>)
 800cdc0:	603b      	str	r3, [r7, #0]
	HAL_CAN_IRQHandler(&hcan);
 800cdc2:	463b      	mov	r3, r7
 800cdc4:	4618      	mov	r0, r3
 800cdc6:	f7f6 f80d 	bl	8002de4 <HAL_CAN_IRQHandler>

	/* leave interrupt */
	rt_interrupt_leave();
 800cdca:	f006 f957 	bl	801307c <rt_interrupt_leave>

}
 800cdce:	3740      	adds	r7, #64	; 0x40
 800cdd0:	46bd      	mov	sp, r7
 800cdd2:	bd80      	pop	{r7, pc}
 800cdd4:	40006400 	.word	0x40006400

0800cdd8 <HAL_CAN_ErrorCallback>:

void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
{
 800cdd8:	b580      	push	{r7, lr}
 800cdda:	b082      	sub	sp, #8
 800cddc:	af00      	add	r7, sp, #0
 800cdde:	6078      	str	r0, [r7, #4]
	
	if((hcan->ErrorCode & HAL_CAN_ERROR_EWG) == HAL_CAN_ERROR_EWG)
 800cde0:	687b      	ldr	r3, [r7, #4]
 800cde2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cde4:	f003 0301 	and.w	r3, r3, #1
 800cde8:	2b00      	cmp	r3, #0
 800cdea:	d002      	beq.n	800cdf2 <HAL_CAN_ErrorCallback+0x1a>
		rt_kprintf("ewg error\r\n");
 800cdec:	4826      	ldr	r0, [pc, #152]	; (800ce88 <HAL_CAN_ErrorCallback+0xb0>)
 800cdee:	f006 ff3f 	bl	8013c70 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_EPV) == HAL_CAN_ERROR_EPV)
 800cdf2:	687b      	ldr	r3, [r7, #4]
 800cdf4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cdf6:	f003 0302 	and.w	r3, r3, #2
 800cdfa:	2b00      	cmp	r3, #0
 800cdfc:	d002      	beq.n	800ce04 <HAL_CAN_ErrorCallback+0x2c>
		rt_kprintf("epv error\r\n");
 800cdfe:	4823      	ldr	r0, [pc, #140]	; (800ce8c <HAL_CAN_ErrorCallback+0xb4>)
 800ce00:	f006 ff36 	bl	8013c70 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BOF) == HAL_CAN_ERROR_BOF)
 800ce04:	687b      	ldr	r3, [r7, #4]
 800ce06:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce08:	f003 0304 	and.w	r3, r3, #4
 800ce0c:	2b00      	cmp	r3, #0
 800ce0e:	d002      	beq.n	800ce16 <HAL_CAN_ErrorCallback+0x3e>
		rt_kprintf("bof error\r\n");
 800ce10:	481f      	ldr	r0, [pc, #124]	; (800ce90 <HAL_CAN_ErrorCallback+0xb8>)
 800ce12:	f006 ff2d 	bl	8013c70 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_STF) == HAL_CAN_ERROR_STF)
 800ce16:	687b      	ldr	r3, [r7, #4]
 800ce18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce1a:	f003 0308 	and.w	r3, r3, #8
 800ce1e:	2b00      	cmp	r3, #0
 800ce20:	d002      	beq.n	800ce28 <HAL_CAN_ErrorCallback+0x50>
		rt_kprintf("stf error\r\n");
 800ce22:	481c      	ldr	r0, [pc, #112]	; (800ce94 <HAL_CAN_ErrorCallback+0xbc>)
 800ce24:	f006 ff24 	bl	8013c70 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_FOR) == HAL_CAN_ERROR_FOR)
 800ce28:	687b      	ldr	r3, [r7, #4]
 800ce2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce2c:	f003 0310 	and.w	r3, r3, #16
 800ce30:	2b00      	cmp	r3, #0
 800ce32:	d002      	beq.n	800ce3a <HAL_CAN_ErrorCallback+0x62>
		rt_kprintf("for error\r\n");
 800ce34:	4818      	ldr	r0, [pc, #96]	; (800ce98 <HAL_CAN_ErrorCallback+0xc0>)
 800ce36:	f006 ff1b 	bl	8013c70 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_ACK) == HAL_CAN_ERROR_ACK)
 800ce3a:	687b      	ldr	r3, [r7, #4]
 800ce3c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce3e:	f003 0320 	and.w	r3, r3, #32
 800ce42:	2b00      	cmp	r3, #0
 800ce44:	d002      	beq.n	800ce4c <HAL_CAN_ErrorCallback+0x74>
		rt_kprintf("ack error\r\n");
 800ce46:	4815      	ldr	r0, [pc, #84]	; (800ce9c <HAL_CAN_ErrorCallback+0xc4>)
 800ce48:	f006 ff12 	bl	8013c70 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BR) == HAL_CAN_ERROR_BR)
 800ce4c:	687b      	ldr	r3, [r7, #4]
 800ce4e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce50:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ce54:	2b00      	cmp	r3, #0
 800ce56:	d002      	beq.n	800ce5e <HAL_CAN_ErrorCallback+0x86>
		rt_kprintf("br error\r\n");
 800ce58:	4811      	ldr	r0, [pc, #68]	; (800cea0 <HAL_CAN_ErrorCallback+0xc8>)
 800ce5a:	f006 ff09 	bl	8013c70 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BD) == HAL_CAN_ERROR_BD)
 800ce5e:	687b      	ldr	r3, [r7, #4]
 800ce60:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce62:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ce66:	2b00      	cmp	r3, #0
 800ce68:	d002      	beq.n	800ce70 <HAL_CAN_ErrorCallback+0x98>
		rt_kprintf("bd error\r\n");
 800ce6a:	480e      	ldr	r0, [pc, #56]	; (800cea4 <HAL_CAN_ErrorCallback+0xcc>)
 800ce6c:	f006 ff00 	bl	8013c70 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_CRC) == HAL_CAN_ERROR_CRC)
 800ce70:	687b      	ldr	r3, [r7, #4]
 800ce72:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce74:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ce78:	2b00      	cmp	r3, #0
 800ce7a:	d002      	beq.n	800ce82 <HAL_CAN_ErrorCallback+0xaa>
		rt_kprintf("crc error\r\n");
 800ce7c:	480a      	ldr	r0, [pc, #40]	; (800cea8 <HAL_CAN_ErrorCallback+0xd0>)
 800ce7e:	f006 fef7 	bl	8013c70 <rt_kprintf>
	
	//HAL_NVIC_DisableIRQ(CAN1_SCE_IRQn);
}
 800ce82:	3708      	adds	r7, #8
 800ce84:	46bd      	mov	sp, r7
 800ce86:	bd80      	pop	{r7, pc}
 800ce88:	08022690 	.word	0x08022690
 800ce8c:	0802269c 	.word	0x0802269c
 800ce90:	080226a8 	.word	0x080226a8
 800ce94:	080226b4 	.word	0x080226b4
 800ce98:	080226c0 	.word	0x080226c0
 800ce9c:	080226cc 	.word	0x080226cc
 800cea0:	080226d8 	.word	0x080226d8
 800cea4:	080226e4 	.word	0x080226e4
 800cea8:	080226f0 	.word	0x080226f0

0800ceac <CAN1_SCE_IRQHandler>:

void CAN1_SCE_IRQHandler(void)
{
 800ceac:	b580      	push	{r7, lr}
 800ceae:	b090      	sub	sp, #64	; 0x40
 800ceb0:	af00      	add	r7, sp, #0
	CAN_HandleTypeDef hcan;

	/* enter interrupt */
	rt_interrupt_enter();
 800ceb2:	f006 f8cd 	bl	8013050 <rt_interrupt_enter>

	HAL_CAN_IRQHandler(&hcan);
 800ceb6:	463b      	mov	r3, r7
 800ceb8:	4618      	mov	r0, r3
 800ceba:	f7f5 ff93 	bl	8002de4 <HAL_CAN_IRQHandler>

	/* leave interrupt */
	rt_interrupt_leave();
 800cebe:	f006 f8dd 	bl	801307c <rt_interrupt_leave>

}
 800cec2:	3740      	adds	r7, #64	; 0x40
 800cec4:	46bd      	mov	sp, r7
 800cec6:	bd80      	pop	{r7, pc}

0800cec8 <HAL_CAN_MspInit>:



void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
 800cec8:	b580      	push	{r7, lr}
 800ceca:	b08a      	sub	sp, #40	; 0x28
 800cecc:	af00      	add	r7, sp, #0
 800cece:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
	
	CAN1_CLK_ENABLE();
 800ced0:	4a2b      	ldr	r2, [pc, #172]	; (800cf80 <HAL_CAN_MspInit+0xb8>)
 800ced2:	4b2b      	ldr	r3, [pc, #172]	; (800cf80 <HAL_CAN_MspInit+0xb8>)
 800ced4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ced6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800ceda:	6413      	str	r3, [r2, #64]	; 0x40
 800cedc:	4b28      	ldr	r3, [pc, #160]	; (800cf80 <HAL_CAN_MspInit+0xb8>)
 800cede:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cee0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800cee4:	613b      	str	r3, [r7, #16]
 800cee6:	693b      	ldr	r3, [r7, #16]
	CAN1_GPIOB_CLK_ENABLE();
 800cee8:	4a25      	ldr	r2, [pc, #148]	; (800cf80 <HAL_CAN_MspInit+0xb8>)
 800ceea:	4b25      	ldr	r3, [pc, #148]	; (800cf80 <HAL_CAN_MspInit+0xb8>)
 800ceec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ceee:	f043 0302 	orr.w	r3, r3, #2
 800cef2:	6313      	str	r3, [r2, #48]	; 0x30
 800cef4:	4b22      	ldr	r3, [pc, #136]	; (800cf80 <HAL_CAN_MspInit+0xb8>)
 800cef6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cef8:	f003 0302 	and.w	r3, r3, #2
 800cefc:	60fb      	str	r3, [r7, #12]
 800cefe:	68fb      	ldr	r3, [r7, #12]

	GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 800cf00:	2309      	movs	r3, #9
 800cf02:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800cf04:	2302      	movs	r3, #2
 800cf06:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pin = CAN1_TX_PIN;
 800cf08:	f44f 7300 	mov.w	r3, #512	; 0x200
 800cf0c:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800cf0e:	2300      	movs	r3, #0
 800cf10:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800cf12:	2303      	movs	r3, #3
 800cf14:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(CAN1_TX_PORT, &GPIO_InitStruct);	
 800cf16:	f107 0314 	add.w	r3, r7, #20
 800cf1a:	481a      	ldr	r0, [pc, #104]	; (800cf84 <HAL_CAN_MspInit+0xbc>)
 800cf1c:	4619      	mov	r1, r3
 800cf1e:	f7fb f847 	bl	8007fb0 <HAL_GPIO_Init>
	
	GPIO_InitStruct.Pin = CAN1_RX_PIN;
 800cf22:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cf26:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 800cf28:	2301      	movs	r3, #1
 800cf2a:	61fb      	str	r3, [r7, #28]
	HAL_GPIO_Init(CAN1_RX_PORT, &GPIO_InitStruct);	
 800cf2c:	f107 0314 	add.w	r3, r7, #20
 800cf30:	4814      	ldr	r0, [pc, #80]	; (800cf84 <HAL_CAN_MspInit+0xbc>)
 800cf32:	4619      	mov	r1, r3
 800cf34:	f7fb f83c 	bl	8007fb0 <HAL_GPIO_Init>
	
	HAL_NVIC_SetPriority(CAN1_TX_IRQn,CAN1_TX_IRQ_PREEMPT,CAN1_TX_TRQ_SUB);
 800cf38:	2013      	movs	r0, #19
 800cf3a:	210f      	movs	r1, #15
 800cf3c:	2200      	movs	r2, #0
 800cf3e:	f7f6 fb53 	bl	80035e8 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_TX_IRQn);
 800cf42:	2013      	movs	r0, #19
 800cf44:	f7f6 fb6c 	bl	8003620 <HAL_NVIC_EnableIRQ>
	
	HAL_NVIC_SetPriority(CAN1_RX0_IRQn,CAN1_RX0_IRQ_PREEMPT,CAN1_RX0_TRQ_SUB);
 800cf48:	2014      	movs	r0, #20
 800cf4a:	210f      	movs	r1, #15
 800cf4c:	2200      	movs	r2, #0
 800cf4e:	f7f6 fb4b 	bl	80035e8 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn);
 800cf52:	2014      	movs	r0, #20
 800cf54:	f7f6 fb64 	bl	8003620 <HAL_NVIC_EnableIRQ>

	HAL_NVIC_SetPriority(CAN1_RX1_IRQn,CAN1_RX1_IRQ_PREEMPT,CAN1_RX1_TRQ_SUB);
 800cf58:	2015      	movs	r0, #21
 800cf5a:	210f      	movs	r1, #15
 800cf5c:	2200      	movs	r2, #0
 800cf5e:	f7f6 fb43 	bl	80035e8 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_RX1_IRQn);
 800cf62:	2015      	movs	r0, #21
 800cf64:	f7f6 fb5c 	bl	8003620 <HAL_NVIC_EnableIRQ>

	HAL_NVIC_SetPriority(CAN1_SCE_IRQn,CAN1_SCE_IRQ_PREEMPT,CAN1_SCE_IRQ_SUB);
 800cf68:	2016      	movs	r0, #22
 800cf6a:	210f      	movs	r1, #15
 800cf6c:	2200      	movs	r2, #0
 800cf6e:	f7f6 fb3b 	bl	80035e8 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_SCE_IRQn);
 800cf72:	2016      	movs	r0, #22
 800cf74:	f7f6 fb54 	bl	8003620 <HAL_NVIC_EnableIRQ>
}
 800cf78:	3728      	adds	r7, #40	; 0x28
 800cf7a:	46bd      	mov	sp, r7
 800cf7c:	bd80      	pop	{r7, pc}
 800cf7e:	bf00      	nop
 800cf80:	40023800 	.word	0x40023800
 800cf84:	40020400 	.word	0x40020400

0800cf88 <stm32_CANcontrol>:




rt_err_t stm32_CANcontrol(struct rt_can_device *can, int cmd, void *arg)
{
 800cf88:	b480      	push	{r7}
 800cf8a:	b087      	sub	sp, #28
 800cf8c:	af00      	add	r7, sp, #0
 800cf8e:	60f8      	str	r0, [r7, #12]
 800cf90:	60b9      	str	r1, [r7, #8]
 800cf92:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 800cf94:	68fb      	ldr	r3, [r7, #12]
 800cf96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cf98:	617b      	str	r3, [r7, #20]
	rt_err_t result = RT_EOK;
 800cf9a:	2300      	movs	r3, #0
 800cf9c:	613b      	str	r3, [r7, #16]
	switch(cmd)
 800cf9e:	68bb      	ldr	r3, [r7, #8]
 800cfa0:	2b10      	cmp	r3, #16
 800cfa2:	d00b      	beq.n	800cfbc <stm32_CANcontrol+0x34>
 800cfa4:	2b11      	cmp	r3, #17
 800cfa6:	d000      	beq.n	800cfaa <stm32_CANcontrol+0x22>
			break;
		case (RT_DEVICE_CTRL_SET_INT):
			__HAL_CAN_ENABLE_IT(&(stcan->hcan), CAN_IT_ERR);
			break;
		default:
			break;
 800cfa8:	e011      	b.n	800cfce <stm32_CANcontrol+0x46>
	stcan = (stm32_canTypeDef *)can->parent.user_data;
	rt_err_t result = RT_EOK;
	switch(cmd)
	{
		case (RT_DEVICE_CTRL_CLR_INT):
			__HAL_CAN_DISABLE_IT(&(stcan->hcan), CAN_IT_ERR);
 800cfaa:	697b      	ldr	r3, [r7, #20]
 800cfac:	681b      	ldr	r3, [r3, #0]
 800cfae:	697a      	ldr	r2, [r7, #20]
 800cfb0:	6812      	ldr	r2, [r2, #0]
 800cfb2:	6952      	ldr	r2, [r2, #20]
 800cfb4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800cfb8:	615a      	str	r2, [r3, #20]
			break;
 800cfba:	e008      	b.n	800cfce <stm32_CANcontrol+0x46>
		case (RT_DEVICE_CTRL_SET_INT):
			__HAL_CAN_ENABLE_IT(&(stcan->hcan), CAN_IT_ERR);
 800cfbc:	697b      	ldr	r3, [r7, #20]
 800cfbe:	681b      	ldr	r3, [r3, #0]
 800cfc0:	697a      	ldr	r2, [r7, #20]
 800cfc2:	6812      	ldr	r2, [r2, #0]
 800cfc4:	6952      	ldr	r2, [r2, #20]
 800cfc6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800cfca:	615a      	str	r2, [r3, #20]
			break;
 800cfcc:	bf00      	nop
		default:
			break;
	}	
	return result;
 800cfce:	693b      	ldr	r3, [r7, #16]
}
 800cfd0:	4618      	mov	r0, r3
 800cfd2:	371c      	adds	r7, #28
 800cfd4:	46bd      	mov	sp, r7
 800cfd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfda:	4770      	bx	lr

0800cfdc <stm32_CANsendmsg>:

int stm32_CANsendmsg(struct rt_can_device *can, const void *buf, rt_uint32_t boxno)
{
 800cfdc:	b580      	push	{r7, lr}
 800cfde:	b08a      	sub	sp, #40	; 0x28
 800cfe0:	af00      	add	r7, sp, #0
 800cfe2:	60f8      	str	r0, [r7, #12]
 800cfe4:	60b9      	str	r1, [r7, #8]
 800cfe6:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	struct rt_can_msg *tmpmsg = (struct rt_can_msg *)buf;
 800cfe8:	68bb      	ldr	r3, [r7, #8]
 800cfea:	623b      	str	r3, [r7, #32]
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 800cfec:	68fb      	ldr	r3, [r7, #12]
 800cfee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cff0:	61fb      	str	r3, [r7, #28]
	rt_err_t result = RT_EOK;
 800cff2:	2300      	movs	r3, #0
 800cff4:	61bb      	str	r3, [r7, #24]
	unsigned char i;
	unsigned char ecode;
	if((stcan->hcan.pTxMsg != NULL))
 800cff6:	69fb      	ldr	r3, [r7, #28]
 800cff8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cffa:	2b00      	cmp	r3, #0
 800cffc:	d053      	beq.n	800d0a6 <stm32_CANsendmsg+0xca>
	{
		//rt_kprintf(" TX malloc success\r\n");
		stcan->hcan.pTxMsg->ExtId =  tmpmsg->id;
 800cffe:	69fb      	ldr	r3, [r7, #28]
 800d000:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d002:	6a3a      	ldr	r2, [r7, #32]
 800d004:	6812      	ldr	r2, [r2, #0]
 800d006:	f3c2 021c 	ubfx	r2, r2, #0, #29
 800d00a:	605a      	str	r2, [r3, #4]
		if(tmpmsg->ide)
 800d00c:	6a3b      	ldr	r3, [r7, #32]
 800d00e:	78db      	ldrb	r3, [r3, #3]
 800d010:	f003 0320 	and.w	r3, r3, #32
 800d014:	b2db      	uxtb	r3, r3
 800d016:	2b00      	cmp	r3, #0
 800d018:	d004      	beq.n	800d024 <stm32_CANsendmsg+0x48>
			stcan->hcan.pTxMsg->IDE = CAN_ID_EXT;
 800d01a:	69fb      	ldr	r3, [r7, #28]
 800d01c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d01e:	2204      	movs	r2, #4
 800d020:	609a      	str	r2, [r3, #8]
 800d022:	e003      	b.n	800d02c <stm32_CANsendmsg+0x50>
		else
			stcan->hcan.pTxMsg->IDE = CAN_ID_STD;
 800d024:	69fb      	ldr	r3, [r7, #28]
 800d026:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d028:	2200      	movs	r2, #0
 800d02a:	609a      	str	r2, [r3, #8]
		if(tmpmsg->rtr)
 800d02c:	6a3b      	ldr	r3, [r7, #32]
 800d02e:	78db      	ldrb	r3, [r3, #3]
 800d030:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800d034:	b2db      	uxtb	r3, r3
 800d036:	2b00      	cmp	r3, #0
 800d038:	d004      	beq.n	800d044 <stm32_CANsendmsg+0x68>
			stcan->hcan.pTxMsg->RTR = CAN_RTR_REMOTE;
 800d03a:	69fb      	ldr	r3, [r7, #28]
 800d03c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d03e:	2202      	movs	r2, #2
 800d040:	60da      	str	r2, [r3, #12]
 800d042:	e003      	b.n	800d04c <stm32_CANsendmsg+0x70>
		else 
			stcan->hcan.pTxMsg->RTR = CAN_RTR_DATA;
 800d044:	69fb      	ldr	r3, [r7, #28]
 800d046:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d048:	2200      	movs	r2, #0
 800d04a:	60da      	str	r2, [r3, #12]
		stcan->hcan.pTxMsg->DLC = tmpmsg->len;
 800d04c:	69fb      	ldr	r3, [r7, #28]
 800d04e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d050:	6a3a      	ldr	r2, [r7, #32]
 800d052:	7912      	ldrb	r2, [r2, #4]
 800d054:	611a      	str	r2, [r3, #16]
		for(i=0;i<8;i++)
 800d056:	2300      	movs	r3, #0
 800d058:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800d05c:	e010      	b.n	800d080 <stm32_CANsendmsg+0xa4>
		{
			stcan->hcan.pTxMsg->Data[i] = tmpmsg->data[i];
 800d05e:	69fb      	ldr	r3, [r7, #28]
 800d060:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d062:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d066:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
 800d06a:	6a38      	ldr	r0, [r7, #32]
 800d06c:	4401      	add	r1, r0
 800d06e:	7a09      	ldrb	r1, [r1, #8]
 800d070:	4413      	add	r3, r2
 800d072:	460a      	mov	r2, r1
 800d074:	751a      	strb	r2, [r3, #20]
		if(tmpmsg->rtr)
			stcan->hcan.pTxMsg->RTR = CAN_RTR_REMOTE;
		else 
			stcan->hcan.pTxMsg->RTR = CAN_RTR_DATA;
		stcan->hcan.pTxMsg->DLC = tmpmsg->len;
		for(i=0;i<8;i++)
 800d076:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d07a:	3301      	adds	r3, #1
 800d07c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800d080:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800d084:	2b07      	cmp	r3, #7
 800d086:	d9ea      	bls.n	800d05e <stm32_CANsendmsg+0x82>
		{
			stcan->hcan.pTxMsg->Data[i] = tmpmsg->data[i];
		}
		if ((ecode = HAL_CAN_Transmit(&(stcan->hcan),100)) == HAL_OK)
 800d088:	69fb      	ldr	r3, [r7, #28]
 800d08a:	4618      	mov	r0, r3
 800d08c:	2164      	movs	r1, #100	; 0x64
 800d08e:	f7f5 fbf9 	bl	8002884 <HAL_CAN_Transmit>
 800d092:	4603      	mov	r3, r0
 800d094:	75fb      	strb	r3, [r7, #23]
 800d096:	7dfb      	ldrb	r3, [r7, #23]
 800d098:	2b00      	cmp	r3, #0
 800d09a:	d004      	beq.n	800d0a6 <stm32_CANsendmsg+0xca>
		{
			//rt_kprintf("CAN tx success %x\r\n", stcan->hcan.Instance->ESR);
		}
		else
		{
			rt_kprintf("CAN tx fail! %x\r\n", ecode);
 800d09c:	7dfb      	ldrb	r3, [r7, #23]
 800d09e:	4804      	ldr	r0, [pc, #16]	; (800d0b0 <stm32_CANsendmsg+0xd4>)
 800d0a0:	4619      	mov	r1, r3
 800d0a2:	f006 fde5 	bl	8013c70 <rt_kprintf>
		}
		//rt_free(hcan.pTxMsg);
	}
	return result;
 800d0a6:	69bb      	ldr	r3, [r7, #24]
}
 800d0a8:	4618      	mov	r0, r3
 800d0aa:	3728      	adds	r7, #40	; 0x28
 800d0ac:	46bd      	mov	sp, r7
 800d0ae:	bd80      	pop	{r7, pc}
 800d0b0:	080226fc 	.word	0x080226fc

0800d0b4 <stm32_CANrecvmsg>:
int stm32_CANrecvmsg(struct rt_can_device *can, void *buf, rt_uint32_t boxno)
{
 800d0b4:	b580      	push	{r7, lr}
 800d0b6:	b08e      	sub	sp, #56	; 0x38
 800d0b8:	af00      	add	r7, sp, #0
 800d0ba:	60f8      	str	r0, [r7, #12]
 800d0bc:	60b9      	str	r1, [r7, #8]
 800d0be:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 800d0c0:	68fb      	ldr	r3, [r7, #12]
 800d0c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d0c4:	633b      	str	r3, [r7, #48]	; 0x30
	rt_err_t result = RT_EOK;
 800d0c6:	2300      	movs	r3, #0
 800d0c8:	62fb      	str	r3, [r7, #44]	; 0x2c

	while((uint8_t)(stcan->hcan.Instance->RF0R&(uint32_t)0x03))
 800d0ca:	e0cf      	b.n	800d26c <stm32_CANrecvmsg+0x1b8>
	{
		if (HAL_CAN_Receive(&(stcan->hcan),CAN_FIFO0,0) == HAL_OK)
 800d0cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d0ce:	4618      	mov	r0, r3
 800d0d0:	2100      	movs	r1, #0
 800d0d2:	2200      	movs	r2, #0
 800d0d4:	f7f5 fd48 	bl	8002b68 <HAL_CAN_Receive>
 800d0d8:	4603      	mov	r3, r0
 800d0da:	2b00      	cmp	r3, #0
 800d0dc:	f040 80c6 	bne.w	800d26c <stm32_CANrecvmsg+0x1b8>
		{
			rt_kprintf("receive can\r\n");
 800d0e0:	4869      	ldr	r0, [pc, #420]	; (800d288 <stm32_CANrecvmsg+0x1d4>)
 800d0e2:	f006 fdc5 	bl	8013c70 <rt_kprintf>
			struct rt_can_msg tmpmsg;
			struct rt_can_rx_fifo *rx_fifo;
			struct rt_can_msg_list *listmsg = RT_NULL;
 800d0e6:	2300      	movs	r3, #0
 800d0e8:	637b      	str	r3, [r7, #52]	; 0x34
					rt_kprintf("0x%x ", stcan->hcan.pRxMsg->Data[i]);
				}
				rt_kprintf("\r\n");
			}
			#endif
			rx_fifo = (struct rt_can_rx_fifo *)can->can_rx;
 800d0ea:	68fb      	ldr	r3, [r7, #12]
 800d0ec:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800d0f0:	62bb      	str	r3, [r7, #40]	; 0x28
			RT_ASSERT(rx_fifo != RT_NULL);
 800d0f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d0f4:	2b00      	cmp	r3, #0
 800d0f6:	d104      	bne.n	800d102 <stm32_CANrecvmsg+0x4e>
 800d0f8:	4864      	ldr	r0, [pc, #400]	; (800d28c <stm32_CANrecvmsg+0x1d8>)
 800d0fa:	4965      	ldr	r1, [pc, #404]	; (800d290 <stm32_CANrecvmsg+0x1dc>)
 800d0fc:	22f3      	movs	r2, #243	; 0xf3
 800d0fe:	f006 fe31 	bl	8013d64 <rt_assert_handler>
	
			//no = event >> 8;
			//ch = can->ops->recvmsg(can, &tmpmsg, no);
			//if (ch == -1) break;
	
			tmpmsg.id = stcan->hcan.pRxMsg->ExtId;
 800d102:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d104:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d106:	685b      	ldr	r3, [r3, #4]
 800d108:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 800d10c:	693b      	ldr	r3, [r7, #16]
 800d10e:	f362 031c 	bfi	r3, r2, #0, #29
 800d112:	613b      	str	r3, [r7, #16]
			tmpmsg.ide = stcan->hcan.pRxMsg->IDE;
 800d114:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d116:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d118:	689b      	ldr	r3, [r3, #8]
 800d11a:	b2db      	uxtb	r3, r3
 800d11c:	f003 0301 	and.w	r3, r3, #1
 800d120:	b2da      	uxtb	r2, r3
 800d122:	7cfb      	ldrb	r3, [r7, #19]
 800d124:	f362 1345 	bfi	r3, r2, #5, #1
 800d128:	74fb      	strb	r3, [r7, #19]
			tmpmsg.rtr = stcan->hcan.pRxMsg->RTR;
 800d12a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d12c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d12e:	68db      	ldr	r3, [r3, #12]
 800d130:	b2db      	uxtb	r3, r3
 800d132:	f003 0301 	and.w	r3, r3, #1
 800d136:	b2da      	uxtb	r2, r3
 800d138:	7cfb      	ldrb	r3, [r7, #19]
 800d13a:	f362 1386 	bfi	r3, r2, #6, #1
 800d13e:	74fb      	strb	r3, [r7, #19]
			tmpmsg.len = stcan->hcan.pRxMsg->DLC;
 800d140:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d142:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d144:	691b      	ldr	r3, [r3, #16]
 800d146:	b2db      	uxtb	r3, r3
 800d148:	753b      	strb	r3, [r7, #20]
			tmpmsg.data[0] = stcan->hcan.pRxMsg->Data[0];
 800d14a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d14c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d14e:	7d1b      	ldrb	r3, [r3, #20]
 800d150:	763b      	strb	r3, [r7, #24]
			tmpmsg.data[1] = stcan->hcan.pRxMsg->Data[1];
 800d152:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d154:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d156:	7d5b      	ldrb	r3, [r3, #21]
 800d158:	767b      	strb	r3, [r7, #25]
			tmpmsg.data[2] = stcan->hcan.pRxMsg->Data[2];
 800d15a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d15c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d15e:	7d9b      	ldrb	r3, [r3, #22]
 800d160:	76bb      	strb	r3, [r7, #26]
			tmpmsg.data[3] = stcan->hcan.pRxMsg->Data[3];
 800d162:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d164:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d166:	7ddb      	ldrb	r3, [r3, #23]
 800d168:	76fb      	strb	r3, [r7, #27]
			tmpmsg.data[4] = stcan->hcan.pRxMsg->Data[4];
 800d16a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d16c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d16e:	7e1b      	ldrb	r3, [r3, #24]
 800d170:	773b      	strb	r3, [r7, #28]
			tmpmsg.data[5] = stcan->hcan.pRxMsg->Data[5];
 800d172:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d174:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d176:	7e5b      	ldrb	r3, [r3, #25]
 800d178:	777b      	strb	r3, [r7, #29]
			tmpmsg.data[6] = stcan->hcan.pRxMsg->Data[6];
 800d17a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d17c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d17e:	7e9b      	ldrb	r3, [r3, #26]
 800d180:	77bb      	strb	r3, [r7, #30]
			tmpmsg.data[7] = stcan->hcan.pRxMsg->Data[7];
 800d182:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d184:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d186:	7edb      	ldrb	r3, [r3, #27]
 800d188:	77fb      	strb	r3, [r7, #31]

			/* disable interrupt */
			level = rt_hw_interrupt_disable();
 800d18a:	f7f3 f81d 	bl	80001c8 <rt_hw_interrupt_disable>
 800d18e:	6278      	str	r0, [r7, #36]	; 0x24
			can->status.rcvpkg++;
 800d190:	68fb      	ldr	r3, [r7, #12]
 800d192:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800d194:	1c5a      	adds	r2, r3, #1
 800d196:	68fb      	ldr	r3, [r7, #12]
 800d198:	665a      	str	r2, [r3, #100]	; 0x64
			can->status.rcvchange = 1;
 800d19a:	68fb      	ldr	r3, [r7, #12]
 800d19c:	2201      	movs	r2, #1
 800d19e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
			if (!rt_list_isempty(&rx_fifo->freelist))
 800d1a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1a4:	3308      	adds	r3, #8
 800d1a6:	4618      	mov	r0, r3
 800d1a8:	f7ff fd9a 	bl	800cce0 <rt_list_isempty>
 800d1ac:	4603      	mov	r3, r0
 800d1ae:	2b00      	cmp	r3, #0
 800d1b0:	d116      	bne.n	800d1e0 <stm32_CANrecvmsg+0x12c>
			{
				listmsg = rt_list_entry(rx_fifo->freelist.next, struct rt_can_msg_list, list);
 800d1b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1b4:	689b      	ldr	r3, [r3, #8]
 800d1b6:	637b      	str	r3, [r7, #52]	; 0x34
				rt_list_remove(&listmsg->list);
 800d1b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d1ba:	4618      	mov	r0, r3
 800d1bc:	f7ff fd76 	bl	800ccac <rt_list_remove>
				RT_ASSERT(rx_fifo->freenumbers > 0);
 800d1c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1c2:	685b      	ldr	r3, [r3, #4]
 800d1c4:	2b00      	cmp	r3, #0
 800d1c6:	d105      	bne.n	800d1d4 <stm32_CANrecvmsg+0x120>
 800d1c8:	4832      	ldr	r0, [pc, #200]	; (800d294 <stm32_CANrecvmsg+0x1e0>)
 800d1ca:	4931      	ldr	r1, [pc, #196]	; (800d290 <stm32_CANrecvmsg+0x1dc>)
 800d1cc:	f44f 7288 	mov.w	r2, #272	; 0x110
 800d1d0:	f006 fdc8 	bl	8013d64 <rt_assert_handler>
				rx_fifo->freenumbers--;
 800d1d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1d6:	685b      	ldr	r3, [r3, #4]
 800d1d8:	1e5a      	subs	r2, r3, #1
 800d1da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1dc:	605a      	str	r2, [r3, #4]
 800d1de:	e013      	b.n	800d208 <stm32_CANrecvmsg+0x154>
			}
			else if (!rt_list_isempty(&rx_fifo->uselist))
 800d1e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1e2:	3310      	adds	r3, #16
 800d1e4:	4618      	mov	r0, r3
 800d1e6:	f7ff fd7b 	bl	800cce0 <rt_list_isempty>
 800d1ea:	4603      	mov	r3, r0
 800d1ec:	2b00      	cmp	r3, #0
 800d1ee:	d10b      	bne.n	800d208 <stm32_CANrecvmsg+0x154>
			{
				listmsg = rt_list_entry(rx_fifo->uselist.next, struct rt_can_msg_list, list);
 800d1f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1f2:	691b      	ldr	r3, [r3, #16]
 800d1f4:	637b      	str	r3, [r7, #52]	; 0x34
				can->status.dropedrcvpkg++;
 800d1f6:	68fb      	ldr	r3, [r7, #12]
 800d1f8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800d1fa:	1c5a      	adds	r2, r3, #1
 800d1fc:	68fb      	ldr	r3, [r7, #12]
 800d1fe:	669a      	str	r2, [r3, #104]	; 0x68
				rt_list_remove(&listmsg->list);
 800d200:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d202:	4618      	mov	r0, r3
 800d204:	f7ff fd52 	bl	800ccac <rt_list_remove>
			}
			/* enable interrupt */
			rt_hw_interrupt_enable(level);
 800d208:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800d20a:	f7f2 ffe1 	bl	80001d0 <rt_hw_interrupt_enable>
	
			if (listmsg != RT_NULL)
 800d20e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d210:	2b00      	cmp	r3, #0
 800d212:	d017      	beq.n	800d244 <stm32_CANrecvmsg+0x190>
			{
				rt_memcpy(&listmsg->data, &tmpmsg, sizeof(struct rt_can_msg));
 800d214:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d216:	f103 0208 	add.w	r2, r3, #8
 800d21a:	f107 0310 	add.w	r3, r7, #16
 800d21e:	4610      	mov	r0, r2
 800d220:	4619      	mov	r1, r3
 800d222:	2210      	movs	r2, #16
 800d224:	f005 ffc8 	bl	80131b8 <rt_memcpy>
				level = rt_hw_interrupt_disable();
 800d228:	f7f2 ffce 	bl	80001c8 <rt_hw_interrupt_disable>
 800d22c:	6278      	str	r0, [r7, #36]	; 0x24
				rt_list_insert_before(&rx_fifo->uselist, &listmsg->list);
 800d22e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d230:	f103 0210 	add.w	r2, r3, #16
 800d234:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d236:	4610      	mov	r0, r2
 800d238:	4619      	mov	r1, r3
 800d23a:	f7ff fd1f 	bl	800cc7c <rt_list_insert_before>
				rt_hw_interrupt_enable(level);
 800d23e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800d240:	f7f2 ffc6 	bl	80001d0 <rt_hw_interrupt_enable>
			}
			
			if (can->parent.rx_indicate != RT_NULL)
 800d244:	68fb      	ldr	r3, [r7, #12]
 800d246:	69db      	ldr	r3, [r3, #28]
 800d248:	2b00      	cmp	r3, #0
 800d24a:	d00f      	beq.n	800d26c <stm32_CANrecvmsg+0x1b8>
            {
                rt_size_t rx_length;

                level = rt_hw_interrupt_disable();
 800d24c:	f7f2 ffbc 	bl	80001c8 <rt_hw_interrupt_disable>
 800d250:	6278      	str	r0, [r7, #36]	; 0x24
                /* get rx length */
                rx_length = rx_fifo->freenumbers * sizeof(struct rt_can_msg);
 800d252:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d254:	685b      	ldr	r3, [r3, #4]
 800d256:	011b      	lsls	r3, r3, #4
 800d258:	623b      	str	r3, [r7, #32]
                rt_hw_interrupt_enable(level);
 800d25a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800d25c:	f7f2 ffb8 	bl	80001d0 <rt_hw_interrupt_enable>

                can->parent.rx_indicate(&can->parent, rx_length);
 800d260:	68fb      	ldr	r3, [r7, #12]
 800d262:	69db      	ldr	r3, [r3, #28]
 800d264:	68fa      	ldr	r2, [r7, #12]
 800d266:	4610      	mov	r0, r2
 800d268:	6a39      	ldr	r1, [r7, #32]
 800d26a:	4798      	blx	r3
{
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
	rt_err_t result = RT_EOK;

	while((uint8_t)(stcan->hcan.Instance->RF0R&(uint32_t)0x03))
 800d26c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d26e:	681b      	ldr	r3, [r3, #0]
 800d270:	68db      	ldr	r3, [r3, #12]
 800d272:	b2db      	uxtb	r3, r3
 800d274:	f003 0303 	and.w	r3, r3, #3
 800d278:	2b00      	cmp	r3, #0
 800d27a:	f47f af27 	bne.w	800d0cc <stm32_CANrecvmsg+0x18>
                can->parent.rx_indicate(&can->parent, rx_length);
            }

		}
	}
	return result;
 800d27e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800d280:	4618      	mov	r0, r3
 800d282:	3738      	adds	r7, #56	; 0x38
 800d284:	46bd      	mov	sp, r7
 800d286:	bd80      	pop	{r7, pc}
 800d288:	08022710 	.word	0x08022710
 800d28c:	08022720 	.word	0x08022720
 800d290:	080243f8 	.word	0x080243f8
 800d294:	08022734 	.word	0x08022734

0800d298 <timerCanrxfunc>:

static void timerCanrxfunc(void* parameter)
{
 800d298:	b580      	push	{r7, lr}
 800d29a:	b082      	sub	sp, #8
 800d29c:	af00      	add	r7, sp, #0
 800d29e:	6078      	str	r0, [r7, #4]
	stm32_CANrecvmsg(&canDevice1,NULL,0);
 800d2a0:	4803      	ldr	r0, [pc, #12]	; (800d2b0 <timerCanrxfunc+0x18>)
 800d2a2:	2100      	movs	r1, #0
 800d2a4:	2200      	movs	r2, #0
 800d2a6:	f7ff ff05 	bl	800d0b4 <stm32_CANrecvmsg>
}
 800d2aa:	3708      	adds	r7, #8
 800d2ac:	46bd      	mov	sp, r7
 800d2ae:	bd80      	pop	{r7, pc}
 800d2b0:	20012224 	.word	0x20012224

0800d2b4 <stm32_CANconfigure>:



rt_err_t stm32_CANconfigure(struct rt_can_device *can, struct can_configure *cfg)
{
 800d2b4:	b580      	push	{r7, lr}
 800d2b6:	b090      	sub	sp, #64	; 0x40
 800d2b8:	af02      	add	r7, sp, #8
 800d2ba:	6078      	str	r0, [r7, #4]
 800d2bc:	6039      	str	r1, [r7, #0]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 800d2be:	687b      	ldr	r3, [r7, #4]
 800d2c0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d2c2:	637b      	str	r3, [r7, #52]	; 0x34
	rt_err_t result = RT_EOK;
 800d2c4:	2300      	movs	r3, #0
 800d2c6:	633b      	str	r3, [r7, #48]	; 0x30
	static rt_timer_t timerCanrx;
	
	switch (cfg->baud_rate)
 800d2c8:	683b      	ldr	r3, [r7, #0]
 800d2ca:	681b      	ldr	r3, [r3, #0]
 800d2cc:	2bfa      	cmp	r3, #250	; 0xfa
 800d2ce:	f040 8086 	bne.w	800d3de <stm32_CANconfigure+0x12a>
	{
		case (250) :
			if(HAL_CAN_DeInit(&(stcan->hcan))!= HAL_OK)
 800d2d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d2d4:	4618      	mov	r0, r3
 800d2d6:	f7f5 faad 	bl	8002834 <HAL_CAN_DeInit>
 800d2da:	4603      	mov	r3, r0
 800d2dc:	2b00      	cmp	r3, #0
 800d2de:	d004      	beq.n	800d2ea <stm32_CANconfigure+0x36>
			{
				rt_kprintf("error deinit can\r\n");
 800d2e0:	4841      	ldr	r0, [pc, #260]	; (800d3e8 <stm32_CANconfigure+0x134>)
 800d2e2:	f006 fcc5 	bl	8013c70 <rt_kprintf>
				return RT_ERROR;
 800d2e6:	2301      	movs	r3, #1
 800d2e8:	e07a      	b.n	800d3e0 <stm32_CANconfigure+0x12c>
			}
			stcan->hcan.Init.ABOM = DISABLE;
 800d2ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d2ec:	2200      	movs	r2, #0
 800d2ee:	61da      	str	r2, [r3, #28]
			stcan->hcan.Init.AWUM = DISABLE;
 800d2f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d2f2:	2200      	movs	r2, #0
 800d2f4:	621a      	str	r2, [r3, #32]
			stcan->hcan.Init.BS1 = CAN_BS1_8TQ;
 800d2f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d2f8:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 800d2fc:	611a      	str	r2, [r3, #16]
			stcan->hcan.Init.BS2 = CAN_BS2_3TQ;
 800d2fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d300:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 800d304:	615a      	str	r2, [r3, #20]
			stcan->hcan.Init.Mode = CAN_MODE_NORMAL;
 800d306:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d308:	2200      	movs	r2, #0
 800d30a:	609a      	str	r2, [r3, #8]
			stcan->hcan.Init.NART = DISABLE;
 800d30c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d30e:	2200      	movs	r2, #0
 800d310:	625a      	str	r2, [r3, #36]	; 0x24
			stcan->hcan.Init.Prescaler = 16;
 800d312:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d314:	2210      	movs	r2, #16
 800d316:	605a      	str	r2, [r3, #4]
			stcan->hcan.Init.RFLM = ENABLE;
 800d318:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d31a:	2201      	movs	r2, #1
 800d31c:	629a      	str	r2, [r3, #40]	; 0x28
			stcan->hcan.Init.SJW = CAN_SJW_2TQ;
 800d31e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d320:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800d324:	60da      	str	r2, [r3, #12]
			stcan->hcan.Init.TTCM = DISABLE;
 800d326:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d328:	2200      	movs	r2, #0
 800d32a:	619a      	str	r2, [r3, #24]
			stcan->hcan.Init.TXFP = DISABLE;
 800d32c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d32e:	2200      	movs	r2, #0
 800d330:	62da      	str	r2, [r3, #44]	; 0x2c
			
			if(HAL_CAN_Init(&(stcan->hcan))!= HAL_OK)
 800d332:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d334:	4618      	mov	r0, r3
 800d336:	f7f5 f887 	bl	8002448 <HAL_CAN_Init>
 800d33a:	4603      	mov	r3, r0
 800d33c:	2b00      	cmp	r3, #0
 800d33e:	d004      	beq.n	800d34a <stm32_CANconfigure+0x96>
			{
				rt_kprintf("error init can\r\n");
 800d340:	482a      	ldr	r0, [pc, #168]	; (800d3ec <stm32_CANconfigure+0x138>)
 800d342:	f006 fc95 	bl	8013c70 <rt_kprintf>
				return RT_ERROR;
 800d346:	2301      	movs	r3, #1
 800d348:	e04a      	b.n	800d3e0 <stm32_CANconfigure+0x12c>
			}	
			
			CAN_FilterConfTypeDef sFilterConfig;
			sFilterConfig.BankNumber = 0;
 800d34a:	2300      	movs	r3, #0
 800d34c:	62fb      	str	r3, [r7, #44]	; 0x2c
			sFilterConfig.FilterActivation = ENABLE;
 800d34e:	2301      	movs	r3, #1
 800d350:	62bb      	str	r3, [r7, #40]	; 0x28
			sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
 800d352:	2300      	movs	r3, #0
 800d354:	61bb      	str	r3, [r7, #24]
			sFilterConfig.FilterIdHigh = 0x0000;
 800d356:	2300      	movs	r3, #0
 800d358:	60bb      	str	r3, [r7, #8]
			sFilterConfig.FilterIdLow = 0x0000;
 800d35a:	2300      	movs	r3, #0
 800d35c:	60fb      	str	r3, [r7, #12]
			sFilterConfig.FilterMaskIdHigh = 0x0000;
 800d35e:	2300      	movs	r3, #0
 800d360:	613b      	str	r3, [r7, #16]
			sFilterConfig.FilterMaskIdLow = 0x0000;
 800d362:	2300      	movs	r3, #0
 800d364:	617b      	str	r3, [r7, #20]
			sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
 800d366:	2300      	movs	r3, #0
 800d368:	623b      	str	r3, [r7, #32]
			sFilterConfig.FilterNumber = 0;
 800d36a:	2300      	movs	r3, #0
 800d36c:	61fb      	str	r3, [r7, #28]
			sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
 800d36e:	2301      	movs	r3, #1
 800d370:	627b      	str	r3, [r7, #36]	; 0x24
			HAL_CAN_ConfigFilter(&(stcan->hcan),&sFilterConfig);
 800d372:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d374:	f107 0308 	add.w	r3, r7, #8
 800d378:	4610      	mov	r0, r2
 800d37a:	4619      	mov	r1, r3
 800d37c:	f7f5 f98e 	bl	800269c <HAL_CAN_ConfigFilter>
			stcan->hcan.pTxMsg = (CanTxMsgTypeDef*)rt_malloc(sizeof(CanTxMsgTypeDef));
 800d380:	201c      	movs	r0, #28
 800d382:	f006 fe23 	bl	8013fcc <rt_malloc>
 800d386:	4602      	mov	r2, r0
 800d388:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d38a:	631a      	str	r2, [r3, #48]	; 0x30
			stcan->hcan.pRxMsg = (CanRxMsgTypeDef*)rt_malloc(sizeof(CanRxMsgTypeDef));
 800d38c:	2024      	movs	r0, #36	; 0x24
 800d38e:	f006 fe1d 	bl	8013fcc <rt_malloc>
 800d392:	4602      	mov	r2, r0
 800d394:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d396:	635a      	str	r2, [r3, #52]	; 0x34
			if(stcan->hcan.pTxMsg == NULL || stcan->hcan.pRxMsg == NULL)
 800d398:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d39a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d39c:	2b00      	cmp	r3, #0
 800d39e:	d003      	beq.n	800d3a8 <stm32_CANconfigure+0xf4>
 800d3a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3a2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d3a4:	2b00      	cmp	r3, #0
 800d3a6:	d104      	bne.n	800d3b2 <stm32_CANconfigure+0xfe>
			{
				rt_kprintf("malloc fail\r\n");
 800d3a8:	4811      	ldr	r0, [pc, #68]	; (800d3f0 <stm32_CANconfigure+0x13c>)
 800d3aa:	f006 fc61 	bl	8013c70 <rt_kprintf>
				return RT_ERROR;
 800d3ae:	2301      	movs	r3, #1
 800d3b0:	e016      	b.n	800d3e0 <stm32_CANconfigure+0x12c>
			}
			#if 1
			timerCanrx = rt_timer_create("timerCanrx",timerCanrxfunc,RT_NULL,20,RT_TIMER_FLAG_PERIODIC);
 800d3b2:	2302      	movs	r3, #2
 800d3b4:	9300      	str	r3, [sp, #0]
 800d3b6:	480f      	ldr	r0, [pc, #60]	; (800d3f4 <stm32_CANconfigure+0x140>)
 800d3b8:	490f      	ldr	r1, [pc, #60]	; (800d3f8 <stm32_CANconfigure+0x144>)
 800d3ba:	2200      	movs	r2, #0
 800d3bc:	2314      	movs	r3, #20
 800d3be:	f008 f8fb 	bl	80155b8 <rt_timer_create>
 800d3c2:	4602      	mov	r2, r0
 800d3c4:	4b0d      	ldr	r3, [pc, #52]	; (800d3fc <stm32_CANconfigure+0x148>)
 800d3c6:	601a      	str	r2, [r3, #0]
			if (timerCanrx != RT_NULL) rt_timer_start(timerCanrx);
 800d3c8:	4b0c      	ldr	r3, [pc, #48]	; (800d3fc <stm32_CANconfigure+0x148>)
 800d3ca:	681b      	ldr	r3, [r3, #0]
 800d3cc:	2b00      	cmp	r3, #0
 800d3ce:	d004      	beq.n	800d3da <stm32_CANconfigure+0x126>
 800d3d0:	4b0a      	ldr	r3, [pc, #40]	; (800d3fc <stm32_CANconfigure+0x148>)
 800d3d2:	681b      	ldr	r3, [r3, #0]
 800d3d4:	4618      	mov	r0, r3
 800d3d6:	f008 f90f 	bl	80155f8 <rt_timer_start>
			break;
		default:
			return RT_ERROR;
			break;
	}
	return result;
 800d3da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d3dc:	e000      	b.n	800d3e0 <stm32_CANconfigure+0x12c>
			//HAL_CAN_Receive_IT(&hcan,CAN_FIFO1);
			
			/* Enable Error Interrupt */
			break;
		default:
			return RT_ERROR;
 800d3de:	2301      	movs	r3, #1
			break;
	}
	return result;
}
 800d3e0:	4618      	mov	r0, r3
 800d3e2:	3738      	adds	r7, #56	; 0x38
 800d3e4:	46bd      	mov	sp, r7
 800d3e6:	bd80      	pop	{r7, pc}
 800d3e8:	08022750 	.word	0x08022750
 800d3ec:	08022764 	.word	0x08022764
 800d3f0:	08022778 	.word	0x08022778
 800d3f4:	08022788 	.word	0x08022788
 800d3f8:	0800d299 	.word	0x0800d299
 800d3fc:	200107f4 	.word	0x200107f4

0800d400 <Can_hw_init>:
	stm32_CANsendmsg,    
	stm32_CANrecvmsg,    
};

int Can_hw_init(void)
{
 800d400:	b5b0      	push	{r4, r5, r7, lr}
 800d402:	b086      	sub	sp, #24
 800d404:	af00      	add	r7, sp, #0
	stm32_canTypeDef *can;
    struct can_configure config = CAN1_CONFIG;
 800d406:	4b0f      	ldr	r3, [pc, #60]	; (800d444 <Can_hw_init+0x44>)
 800d408:	463c      	mov	r4, r7
 800d40a:	461d      	mov	r5, r3
 800d40c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800d40e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800d410:	682b      	ldr	r3, [r5, #0]
 800d412:	6023      	str	r3, [r4, #0]
	
	canDevice1.config = config;
 800d414:	4b0c      	ldr	r3, [pc, #48]	; (800d448 <Can_hw_init+0x48>)
 800d416:	f103 0444 	add.w	r4, r3, #68	; 0x44
 800d41a:	463d      	mov	r5, r7
 800d41c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800d41e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800d420:	682b      	ldr	r3, [r5, #0]
 800d422:	6023      	str	r3, [r4, #0]

	can = &can1;
 800d424:	4b09      	ldr	r3, [pc, #36]	; (800d44c <Can_hw_init+0x4c>)
 800d426:	617b      	str	r3, [r7, #20]
	can->hcan.Instance = CAN1;
 800d428:	697b      	ldr	r3, [r7, #20]
 800d42a:	4a09      	ldr	r2, [pc, #36]	; (800d450 <Can_hw_init+0x50>)
 800d42c:	601a      	str	r2, [r3, #0]

	rt_hw_can_register(&canDevice1,"can1",&stm32_can_ops,can);
 800d42e:	4806      	ldr	r0, [pc, #24]	; (800d448 <Can_hw_init+0x48>)
 800d430:	4908      	ldr	r1, [pc, #32]	; (800d454 <Can_hw_init+0x54>)
 800d432:	4a09      	ldr	r2, [pc, #36]	; (800d458 <Can_hw_init+0x58>)
 800d434:	697b      	ldr	r3, [r7, #20]
 800d436:	f00b f84b 	bl	80184d0 <rt_hw_can_register>
	//HAL_CAN_Receive_IT(&hcan,CAN_FIFO1);
	
	/* Enable Error Interrupt */
	__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_ERR);
	#endif
	return 0;
 800d43a:	2300      	movs	r3, #0
	
}
 800d43c:	4618      	mov	r0, r3
 800d43e:	3718      	adds	r7, #24
 800d440:	46bd      	mov	sp, r7
 800d442:	bdb0      	pop	{r4, r5, r7, pc}
 800d444:	0802279c 	.word	0x0802279c
 800d448:	20012224 	.word	0x20012224
 800d44c:	2001231c 	.word	0x2001231c
 800d450:	40006400 	.word	0x40006400
 800d454:	08022794 	.word	0x08022794
 800d458:	080243e8 	.word	0x080243e8

0800d45c <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800d45c:	b480      	push	{r7}
 800d45e:	b083      	sub	sp, #12
 800d460:	af00      	add	r7, sp, #0
 800d462:	4603      	mov	r3, r0
 800d464:	6039      	str	r1, [r7, #0]
 800d466:	71fb      	strb	r3, [r7, #7]
  if((int32_t)IRQn < 0) {
 800d468:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d46c:	2b00      	cmp	r3, #0
 800d46e:	da0b      	bge.n	800d488 <NVIC_SetPriority+0x2c>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d470:	490d      	ldr	r1, [pc, #52]	; (800d4a8 <NVIC_SetPriority+0x4c>)
 800d472:	79fb      	ldrb	r3, [r7, #7]
 800d474:	f003 030f 	and.w	r3, r3, #15
 800d478:	3b04      	subs	r3, #4
 800d47a:	683a      	ldr	r2, [r7, #0]
 800d47c:	b2d2      	uxtb	r2, r2
 800d47e:	0112      	lsls	r2, r2, #4
 800d480:	b2d2      	uxtb	r2, r2
 800d482:	440b      	add	r3, r1
 800d484:	761a      	strb	r2, [r3, #24]
 800d486:	e009      	b.n	800d49c <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d488:	4908      	ldr	r1, [pc, #32]	; (800d4ac <NVIC_SetPriority+0x50>)
 800d48a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d48e:	683a      	ldr	r2, [r7, #0]
 800d490:	b2d2      	uxtb	r2, r2
 800d492:	0112      	lsls	r2, r2, #4
 800d494:	b2d2      	uxtb	r2, r2
 800d496:	440b      	add	r3, r1
 800d498:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800d49c:	370c      	adds	r7, #12
 800d49e:	46bd      	mov	sp, r7
 800d4a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4a4:	4770      	bx	lr
 800d4a6:	bf00      	nop
 800d4a8:	e000ed00 	.word	0xe000ed00
 800d4ac:	e000e100 	.word	0xe000e100

0800d4b0 <SCB_EnableICache>:
/** \brief Enable I-Cache

    The function turns on I-Cache
  */
__STATIC_INLINE void SCB_EnableICache (void)
{
 800d4b0:	b480      	push	{r7}
 800d4b2:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800d4b4:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 800d4b8:	f3bf 8f6f 	isb	sy
  #if (__ICACHE_PRESENT == 1)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     // invalidate I-Cache
 800d4bc:	4b08      	ldr	r3, [pc, #32]	; (800d4e0 <SCB_EnableICache+0x30>)
 800d4be:	2200      	movs	r2, #0
 800d4c0:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  // enable I-Cache
 800d4c4:	4a06      	ldr	r2, [pc, #24]	; (800d4e0 <SCB_EnableICache+0x30>)
 800d4c6:	4b06      	ldr	r3, [pc, #24]	; (800d4e0 <SCB_EnableICache+0x30>)
 800d4c8:	695b      	ldr	r3, [r3, #20]
 800d4ca:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800d4ce:	6153      	str	r3, [r2, #20]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800d4d0:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 800d4d4:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  #endif
}
 800d4d8:	46bd      	mov	sp, r7
 800d4da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4de:	4770      	bx	lr
 800d4e0:	e000ed00 	.word	0xe000ed00

0800d4e4 <SCB_EnableDCache>:
/** \brief Enable D-Cache

    The function turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache (void)
{
 800d4e4:	b480      	push	{r7}
 800d4e6:	b089      	sub	sp, #36	; 0x24
 800d4e8:	af00      	add	r7, sp, #0
  #if (__DCACHE_PRESENT == 1)
    uint32_t ccsidr, sshift, wshift, sw;
    uint32_t sets, ways;

    SCB->CSSELR = (0UL << 1) | 0UL;         // Level 1 data cache
 800d4ea:	4b25      	ldr	r3, [pc, #148]	; (800d580 <SCB_EnableDCache+0x9c>)
 800d4ec:	2200      	movs	r2, #0
 800d4ee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    ccsidr  = SCB->CCSIDR;
 800d4f2:	4b23      	ldr	r3, [pc, #140]	; (800d580 <SCB_EnableDCache+0x9c>)
 800d4f4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800d4f8:	617b      	str	r3, [r7, #20]
    sets    = (uint32_t)(CCSIDR_SETS(ccsidr));
 800d4fa:	697a      	ldr	r2, [r7, #20]
 800d4fc:	4b21      	ldr	r3, [pc, #132]	; (800d584 <SCB_EnableDCache+0xa0>)
 800d4fe:	4013      	ands	r3, r2
 800d500:	0b5b      	lsrs	r3, r3, #13
 800d502:	61fb      	str	r3, [r7, #28]
    sshift  = (uint32_t)(CCSIDR_LSSHIFT(ccsidr) + 4UL);
 800d504:	697b      	ldr	r3, [r7, #20]
 800d506:	f003 0307 	and.w	r3, r3, #7
 800d50a:	3304      	adds	r3, #4
 800d50c:	613b      	str	r3, [r7, #16]
    ways    = (uint32_t)(CCSIDR_WAYS(ccsidr));
 800d50e:	697a      	ldr	r2, [r7, #20]
 800d510:	f641 73f8 	movw	r3, #8184	; 0x1ff8
 800d514:	4013      	ands	r3, r2
 800d516:	08db      	lsrs	r3, r3, #3
 800d518:	60fb      	str	r3, [r7, #12]
    wshift  = (uint32_t)((uint32_t)__CLZ(ways) & 0x1FUL);
 800d51a:	68fb      	ldr	r3, [r7, #12]
 800d51c:	fab3 f383 	clz	r3, r3
 800d520:	f003 031f 	and.w	r3, r3, #31
 800d524:	60bb      	str	r3, [r7, #8]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800d526:	f3bf 8f4f 	dsb	sy

    __DSB();

    do {                                   // invalidate D-Cache
         uint32_t tmpways = ways;
 800d52a:	68fb      	ldr	r3, [r7, #12]
 800d52c:	61bb      	str	r3, [r7, #24]
         do {
              sw = ((tmpways << wshift) | (sets << sshift));
 800d52e:	68bb      	ldr	r3, [r7, #8]
 800d530:	69ba      	ldr	r2, [r7, #24]
 800d532:	409a      	lsls	r2, r3
 800d534:	693b      	ldr	r3, [r7, #16]
 800d536:	69f9      	ldr	r1, [r7, #28]
 800d538:	fa01 f303 	lsl.w	r3, r1, r3
 800d53c:	4313      	orrs	r3, r2
 800d53e:	607b      	str	r3, [r7, #4]
              SCB->DCISW = sw;
 800d540:	4a0f      	ldr	r2, [pc, #60]	; (800d580 <SCB_EnableDCache+0x9c>)
 800d542:	687b      	ldr	r3, [r7, #4]
 800d544:	f8c2 3260 	str.w	r3, [r2, #608]	; 0x260
            } while(tmpways--);
 800d548:	69bb      	ldr	r3, [r7, #24]
 800d54a:	1e5a      	subs	r2, r3, #1
 800d54c:	61ba      	str	r2, [r7, #24]
 800d54e:	2b00      	cmp	r3, #0
 800d550:	d1ed      	bne.n	800d52e <SCB_EnableDCache+0x4a>
        } while(sets--);
 800d552:	69fb      	ldr	r3, [r7, #28]
 800d554:	1e5a      	subs	r2, r3, #1
 800d556:	61fa      	str	r2, [r7, #28]
 800d558:	2b00      	cmp	r3, #0
 800d55a:	d1e6      	bne.n	800d52a <SCB_EnableDCache+0x46>
 800d55c:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;   // enable D-Cache
 800d560:	4a07      	ldr	r2, [pc, #28]	; (800d580 <SCB_EnableDCache+0x9c>)
 800d562:	4b07      	ldr	r3, [pc, #28]	; (800d580 <SCB_EnableDCache+0x9c>)
 800d564:	695b      	ldr	r3, [r3, #20]
 800d566:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d56a:	6153      	str	r3, [r2, #20]
 800d56c:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 800d570:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
  #endif
}
 800d574:	3724      	adds	r7, #36	; 0x24
 800d576:	46bd      	mov	sp, r7
 800d578:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d57c:	4770      	bx	lr
 800d57e:	bf00      	nop
 800d580:	e000ed00 	.word	0xe000ed00
 800d584:	0fffe000 	.word	0x0fffe000

0800d588 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800d588:	b580      	push	{r7, lr}
 800d58a:	b082      	sub	sp, #8
 800d58c:	af00      	add	r7, sp, #0
 800d58e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 800d590:	687b      	ldr	r3, [r7, #4]
 800d592:	3b01      	subs	r3, #1
 800d594:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800d598:	d301      	bcc.n	800d59e <SysTick_Config+0x16>
 800d59a:	2301      	movs	r3, #1
 800d59c:	e00f      	b.n	800d5be <SysTick_Config+0x36>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800d59e:	4a0a      	ldr	r2, [pc, #40]	; (800d5c8 <SysTick_Config+0x40>)
 800d5a0:	687b      	ldr	r3, [r7, #4]
 800d5a2:	3b01      	subs	r3, #1
 800d5a4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800d5a6:	f04f 30ff 	mov.w	r0, #4294967295
 800d5aa:	210f      	movs	r1, #15
 800d5ac:	f7ff ff56 	bl	800d45c <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800d5b0:	4b05      	ldr	r3, [pc, #20]	; (800d5c8 <SysTick_Config+0x40>)
 800d5b2:	2200      	movs	r2, #0
 800d5b4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800d5b6:	4b04      	ldr	r3, [pc, #16]	; (800d5c8 <SysTick_Config+0x40>)
 800d5b8:	2207      	movs	r2, #7
 800d5ba:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800d5bc:	2300      	movs	r3, #0
}
 800d5be:	4618      	mov	r0, r3
 800d5c0:	3708      	adds	r7, #8
 800d5c2:	46bd      	mov	sp, r7
 800d5c4:	bd80      	pop	{r7, pc}
 800d5c6:	bf00      	nop
 800d5c8:	e000e010 	.word	0xe000e010

0800d5cc <SystemClock_Config>:
  *            Flash Latency(WS)              = 6
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
 800d5cc:	b580      	push	{r7, lr}
 800d5ce:	b092      	sub	sp, #72	; 0x48
 800d5d0:	af00      	add	r7, sp, #0
    RCC_ClkInitTypeDef RCC_ClkInitStruct;
    RCC_OscInitTypeDef RCC_OscInitStruct;
    HAL_StatusTypeDef ret = HAL_OK;
 800d5d2:	2300      	movs	r3, #0
 800d5d4:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

    /* Enable HSE Oscillator and activate PLL with HSE as source 
	PLLCLK= (HSE*N)/(M*P) */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800d5d8:	2301      	movs	r3, #1
 800d5da:	603b      	str	r3, [r7, #0]
    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800d5dc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800d5e0:	607b      	str	r3, [r7, #4]
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800d5e2:	2302      	movs	r3, #2
 800d5e4:	61bb      	str	r3, [r7, #24]
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800d5e6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800d5ea:	61fb      	str	r3, [r7, #28]
    RCC_OscInitStruct.PLL.PLLM = 25;
 800d5ec:	2319      	movs	r3, #25
 800d5ee:	623b      	str	r3, [r7, #32]
    RCC_OscInitStruct.PLL.PLLN = 400;
 800d5f0:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800d5f4:	627b      	str	r3, [r7, #36]	; 0x24
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800d5f6:	2302      	movs	r3, #2
 800d5f8:	62bb      	str	r3, [r7, #40]	; 0x28
    RCC_OscInitStruct.PLL.PLLQ = 8;
 800d5fa:	2308      	movs	r3, #8
 800d5fc:	62fb      	str	r3, [r7, #44]	; 0x2c
    
    ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 800d5fe:	463b      	mov	r3, r7
 800d600:	4618      	mov	r0, r3
 800d602:	f7fb f809 	bl	8008618 <HAL_RCC_OscConfig>
 800d606:	4603      	mov	r3, r0
 800d608:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if(ret != HAL_OK)
 800d60c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d610:	2b00      	cmp	r3, #0
 800d612:	d000      	beq.n	800d616 <SystemClock_Config+0x4a>
    {
        while(1) { ; }
 800d614:	e7fe      	b.n	800d614 <SystemClock_Config+0x48>
    }

    ret = HAL_PWREx_EnableOverDrive();
 800d616:	f7fa ffb1 	bl	800857c <HAL_PWREx_EnableOverDrive>
 800d61a:	4603      	mov	r3, r0
 800d61c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if (ret != HAL_OK)
 800d620:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d624:	2b00      	cmp	r3, #0
 800d626:	d000      	beq.n	800d62a <SystemClock_Config+0x5e>
    {
        while (1) { ; }
 800d628:	e7fe      	b.n	800d628 <SystemClock_Config+0x5c>
    /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
       clocks dividers 
       PCLK1  = 50MHz
       PCLK2 = 100MHz
       TIM1CLK = 100MHz */
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 800d62a:	230f      	movs	r3, #15
 800d62c:	633b      	str	r3, [r7, #48]	; 0x30
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800d62e:	2302      	movs	r3, #2
 800d630:	637b      	str	r3, [r7, #52]	; 0x34
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800d632:	2300      	movs	r3, #0
 800d634:	63bb      	str	r3, [r7, #56]	; 0x38
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800d636:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800d63a:	63fb      	str	r3, [r7, #60]	; 0x3c
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800d63c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d640:	643b      	str	r3, [r7, #64]	; 0x40
    ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);
 800d642:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800d646:	4618      	mov	r0, r3
 800d648:	2106      	movs	r1, #6
 800d64a:	f7fb fabb 	bl	8008bc4 <HAL_RCC_ClockConfig>
 800d64e:	4603      	mov	r3, r0
 800d650:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if (ret != HAL_OK)
 800d654:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d658:	2b00      	cmp	r3, #0
 800d65a:	d000      	beq.n	800d65e <SystemClock_Config+0x92>
    {
        while (1) { ; }
 800d65c:	e7fe      	b.n	800d65c <SystemClock_Config+0x90>
    }
}
 800d65e:	3748      	adds	r7, #72	; 0x48
 800d660:	46bd      	mov	sp, r7
 800d662:	bd80      	pop	{r7, pc}

0800d664 <CPU_CACHE_Enable>:
  * @brief  CPU L1-Cache enable.
  * @param  None
  * @retval None
  */
static void CPU_CACHE_Enable(void)
{
 800d664:	b580      	push	{r7, lr}
 800d666:	af00      	add	r7, sp, #0
    /* Enable branch prediction */
    SCB->CCR |= (1 << 18);
 800d668:	4a06      	ldr	r2, [pc, #24]	; (800d684 <CPU_CACHE_Enable+0x20>)
 800d66a:	4b06      	ldr	r3, [pc, #24]	; (800d684 <CPU_CACHE_Enable+0x20>)
 800d66c:	695b      	ldr	r3, [r3, #20]
 800d66e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800d672:	6153      	str	r3, [r2, #20]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800d674:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Enable I-Cache */
    SCB_EnableICache();
 800d678:	f7ff ff1a 	bl	800d4b0 <SCB_EnableICache>

    /* Enable D-Cache */
    SCB_EnableDCache();
 800d67c:	f7ff ff32 	bl	800d4e4 <SCB_EnableDCache>
}
 800d680:	bd80      	pop	{r7, pc}
 800d682:	bf00      	nop
 800d684:	e000ed00 	.word	0xe000ed00

0800d688 <SysTick_Handler>:
/**
 * This is the timer interrupt service routine.
 *
 */
void SysTick_Handler(void)
{
 800d688:	b580      	push	{r7, lr}
 800d68a:	af00      	add	r7, sp, #0
    /* enter interrupt */
    rt_interrupt_enter();
 800d68c:	f005 fce0 	bl	8013050 <rt_interrupt_enter>

    /* tick for HAL Library */
    HAL_IncTick();
 800d690:	f7f3 ff8a 	bl	80015a8 <HAL_IncTick>
	#ifdef USER_USING_MOTORCONTROL
	MC_SysTickHandler();
 800d694:	f003 ffe2 	bl	801165c <MC_SysTickHandler>
	#endif
    rt_tick_increase();
 800d698:	f004 fbb2 	bl	8011e00 <rt_tick_increase>
    /* leave interrupt */
    rt_interrupt_leave();
 800d69c:	f005 fcee 	bl	801307c <rt_interrupt_leave>
}
 800d6a0:	bd80      	pop	{r7, pc}
 800d6a2:	bf00      	nop

0800d6a4 <HAL_InitTick>:

/* re-implementat tick interface for STM32 HAL */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800d6a4:	b580      	push	{r7, lr}
 800d6a6:	b082      	sub	sp, #8
 800d6a8:	af00      	add	r7, sp, #0
 800d6aa:	6078      	str	r0, [r7, #4]
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/RT_TICK_PER_SECOND);
 800d6ac:	f7fb fc6c 	bl	8008f88 <HAL_RCC_GetHCLKFreq>
 800d6b0:	4602      	mov	r2, r0
 800d6b2:	4b09      	ldr	r3, [pc, #36]	; (800d6d8 <HAL_InitTick+0x34>)
 800d6b4:	fba3 2302 	umull	r2, r3, r3, r2
 800d6b8:	09db      	lsrs	r3, r3, #7
 800d6ba:	4618      	mov	r0, r3
 800d6bc:	f7f5 ffcc 	bl	8003658 <HAL_SYSTICK_Config>

    /*Configure the SysTick IRQ priority */
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 800d6c0:	f04f 30ff 	mov.w	r0, #4294967295
 800d6c4:	6879      	ldr	r1, [r7, #4]
 800d6c6:	2200      	movs	r2, #0
 800d6c8:	f7f5 ff8e 	bl	80035e8 <HAL_NVIC_SetPriority>

    /* Return function status */
    return HAL_OK;
 800d6cc:	2300      	movs	r3, #0
}
 800d6ce:	4618      	mov	r0, r3
 800d6d0:	3708      	adds	r7, #8
 800d6d2:	46bd      	mov	sp, r7
 800d6d4:	bd80      	pop	{r7, pc}
 800d6d6:	bf00      	nop
 800d6d8:	10624dd3 	.word	0x10624dd3

0800d6dc <rt_hw_board_init>:

/**
 * This function will initial STM32 board.
 */
void rt_hw_board_init()
{
 800d6dc:	b580      	push	{r7, lr}
 800d6de:	af00      	add	r7, sp, #0
    /* Configure the MPU attributes as Write Through */
    mpu_init();
 800d6e0:	f001 f82e 	bl	800e740 <mpu_init>

    /* Enable the CPU Cache */
    CPU_CACHE_Enable();
 800d6e4:	f7ff ffbe 	bl	800d664 <CPU_CACHE_Enable>
    - Configure the Flash ART accelerator on ITCM interface
    - Configure the Systick to generate an interrupt each 1 msec
    - Set NVIC Group Priority to 4
    - Global MSP (MCU Support Package) initialization
    */
    HAL_Init();
 800d6e8:	f7f3 ff48 	bl	800157c <HAL_Init>
    /* Configure the system clock @ 200 Mhz */
    SystemClock_Config();
 800d6ec:	f7ff ff6e 	bl	800d5cc <SystemClock_Config>
    /* init systick */
    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);
 800d6f0:	4b09      	ldr	r3, [pc, #36]	; (800d718 <rt_hw_board_init+0x3c>)
 800d6f2:	681b      	ldr	r3, [r3, #0]
 800d6f4:	4a09      	ldr	r2, [pc, #36]	; (800d71c <rt_hw_board_init+0x40>)
 800d6f6:	fba2 2303 	umull	r2, r3, r2, r3
 800d6fa:	09db      	lsrs	r3, r3, #7
 800d6fc:	4618      	mov	r0, r3
 800d6fe:	f7ff ff43 	bl	800d588 <SysTick_Config>
    /* set pend exception priority */
    NVIC_SetPriority(PendSV_IRQn, (1 << __NVIC_PRIO_BITS) - 1);
 800d702:	f06f 0001 	mvn.w	r0, #1
 800d706:	210f      	movs	r1, #15
 800d708:	f7ff fea8 	bl	800d45c <NVIC_SetPriority>

    rt_components_board_init();
 800d70c:	f004 fbca 	bl	8011ea4 <rt_components_board_init>

#ifdef RT_USING_CONSOLE
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
 800d710:	4803      	ldr	r0, [pc, #12]	; (800d720 <rt_hw_board_init+0x44>)
 800d712:	f006 fa7d 	bl	8013c10 <rt_console_set_device>
#endif
}
 800d716:	bd80      	pop	{r7, pc}
 800d718:	20010000 	.word	0x20010000
 800d71c:	10624dd3 	.word	0x10624dd3
 800d720:	080227b0 	.word	0x080227b0

0800d724 <QIEMW_ADC_init>:

QIEMW_ADC_HandleTypeDef Global_User_ADC;


void QIEMW_ADC_init(QIEMW_ADC_HandleTypeDef *QIEMW_ADC_Handle)
{
 800d724:	b480      	push	{r7}
 800d726:	b083      	sub	sp, #12
 800d728:	af00      	add	r7, sp, #0
 800d72a:	6078      	str	r0, [r7, #4]
	QIEMW_ADC_Handle->PhaseA.qI1_offset= 0;
 800d72c:	687b      	ldr	r3, [r7, #4]
 800d72e:	2200      	movs	r2, #0
 800d730:	809a      	strh	r2, [r3, #4]
	QIEMW_ADC_Handle->PhaseA.qI2_offset= 0;
 800d732:	687b      	ldr	r3, [r7, #4]
 800d734:	2200      	movs	r2, #0
 800d736:	811a      	strh	r2, [r3, #8]
	QIEMW_ADC_Handle->PhaseA.qV_offset= 0;
 800d738:	687b      	ldr	r3, [r7, #4]
 800d73a:	2200      	movs	r2, #0
 800d73c:	819a      	strh	r2, [r3, #12]
	QIEMW_ADC_Handle->PhaseB.qI1_offset = 0;
 800d73e:	687b      	ldr	r3, [r7, #4]
 800d740:	2200      	movs	r2, #0
 800d742:	825a      	strh	r2, [r3, #18]
	QIEMW_ADC_Handle->PhaseB.qI2_offset = 0;
 800d744:	687b      	ldr	r3, [r7, #4]
 800d746:	2200      	movs	r2, #0
 800d748:	82da      	strh	r2, [r3, #22]
	QIEMW_ADC_Handle->PhaseB.qV_offset = 0;
 800d74a:	687b      	ldr	r3, [r7, #4]
 800d74c:	2200      	movs	r2, #0
 800d74e:	835a      	strh	r2, [r3, #26]
	QIEMW_ADC_Handle->PhaseC.qI1_offset = 0;
 800d750:	687b      	ldr	r3, [r7, #4]
 800d752:	2200      	movs	r2, #0
 800d754:	841a      	strh	r2, [r3, #32]
	QIEMW_ADC_Handle->PhaseC.qI2_offset = 0;
 800d756:	687b      	ldr	r3, [r7, #4]
 800d758:	2200      	movs	r2, #0
 800d75a:	849a      	strh	r2, [r3, #36]	; 0x24
	QIEMW_ADC_Handle->PhaseC.qV_offset = 0;
 800d75c:	687b      	ldr	r3, [r7, #4]
 800d75e:	2200      	movs	r2, #0
 800d760:	851a      	strh	r2, [r3, #40]	; 0x28
	QIEMW_ADC_Handle->BUS.qV_offset = 0;
 800d762:	687b      	ldr	r3, [r7, #4]
 800d764:	2200      	movs	r2, #0
 800d766:	861a      	strh	r2, [r3, #48]	; 0x30
	QIEMW_ADC_Handle->BUS.qI_offset = 0;
 800d768:	687b      	ldr	r3, [r7, #4]
 800d76a:	2200      	movs	r2, #0
 800d76c:	859a      	strh	r2, [r3, #44]	; 0x2c
	QIEMW_ADC_Handle->UR.qV_offset = 0;
 800d76e:	687b      	ldr	r3, [r7, #4]
 800d770:	2200      	movs	r2, #0
 800d772:	87da      	strh	r2, [r3, #62]	; 0x3e
	QIEMW_ADC_Handle->US.qV_offset = 0;
 800d774:	687b      	ldr	r3, [r7, #4]
 800d776:	2200      	movs	r2, #0
 800d778:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
	QIEMW_ADC_Handle->UT.qV_offset = 0;
 800d77c:	687b      	ldr	r3, [r7, #4]
 800d77e:	2200      	movs	r2, #0
 800d780:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
	QIEMW_ADC_Handle->Temp.TEMP_offset = 0;
 800d784:	687b      	ldr	r3, [r7, #4]
 800d786:	2200      	movs	r2, #0
 800d788:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
	

	QIEMW_ADC_Handle->PhaseA.qI_value = 0;
 800d78c:	687b      	ldr	r3, [r7, #4]
 800d78e:	2200      	movs	r2, #0
 800d790:	805a      	strh	r2, [r3, #2]
	QIEMW_ADC_Handle->PhaseA.qI1_value = 0;
 800d792:	687b      	ldr	r3, [r7, #4]
 800d794:	2200      	movs	r2, #0
 800d796:	801a      	strh	r2, [r3, #0]
	QIEMW_ADC_Handle->PhaseA.qI2_value = 0;
 800d798:	687b      	ldr	r3, [r7, #4]
 800d79a:	2200      	movs	r2, #0
 800d79c:	80da      	strh	r2, [r3, #6]
	QIEMW_ADC_Handle->PhaseA.qV_value = 0;
 800d79e:	687b      	ldr	r3, [r7, #4]
 800d7a0:	2200      	movs	r2, #0
 800d7a2:	815a      	strh	r2, [r3, #10]
	QIEMW_ADC_Handle->PhaseB.qI_value = 0;
 800d7a4:	687b      	ldr	r3, [r7, #4]
 800d7a6:	2200      	movs	r2, #0
 800d7a8:	821a      	strh	r2, [r3, #16]
	QIEMW_ADC_Handle->PhaseB.qI1_value = 0;
 800d7aa:	687b      	ldr	r3, [r7, #4]
 800d7ac:	2200      	movs	r2, #0
 800d7ae:	81da      	strh	r2, [r3, #14]
	QIEMW_ADC_Handle->PhaseB.qI2_value = 0;
 800d7b0:	687b      	ldr	r3, [r7, #4]
 800d7b2:	2200      	movs	r2, #0
 800d7b4:	829a      	strh	r2, [r3, #20]
	QIEMW_ADC_Handle->PhaseB.qV_value = 0;
 800d7b6:	687b      	ldr	r3, [r7, #4]
 800d7b8:	2200      	movs	r2, #0
 800d7ba:	831a      	strh	r2, [r3, #24]
	QIEMW_ADC_Handle->PhaseC.qI1_value = 0;
 800d7bc:	687b      	ldr	r3, [r7, #4]
 800d7be:	2200      	movs	r2, #0
 800d7c0:	839a      	strh	r2, [r3, #28]
	QIEMW_ADC_Handle->PhaseC.qI2_value = 0;
 800d7c2:	687b      	ldr	r3, [r7, #4]
 800d7c4:	2200      	movs	r2, #0
 800d7c6:	845a      	strh	r2, [r3, #34]	; 0x22
	QIEMW_ADC_Handle->PhaseC.qI_value = 0;
 800d7c8:	687b      	ldr	r3, [r7, #4]
 800d7ca:	2200      	movs	r2, #0
 800d7cc:	83da      	strh	r2, [r3, #30]
	QIEMW_ADC_Handle->PhaseC.qV_value = 0;
 800d7ce:	687b      	ldr	r3, [r7, #4]
 800d7d0:	2200      	movs	r2, #0
 800d7d2:	84da      	strh	r2, [r3, #38]	; 0x26
	QIEMW_ADC_Handle->BUS.qV_value = 0;
 800d7d4:	687b      	ldr	r3, [r7, #4]
 800d7d6:	2200      	movs	r2, #0
 800d7d8:	85da      	strh	r2, [r3, #46]	; 0x2e
	QIEMW_ADC_Handle->BUS.qI_value = 0;
 800d7da:	687b      	ldr	r3, [r7, #4]
 800d7dc:	2200      	movs	r2, #0
 800d7de:	855a      	strh	r2, [r3, #42]	; 0x2a
	QIEMW_ADC_Handle->UR.qV_value = 0;
 800d7e0:	687b      	ldr	r3, [r7, #4]
 800d7e2:	2200      	movs	r2, #0
 800d7e4:	879a      	strh	r2, [r3, #60]	; 0x3c
	QIEMW_ADC_Handle->US.qV_value = 0;
 800d7e6:	687b      	ldr	r3, [r7, #4]
 800d7e8:	2200      	movs	r2, #0
 800d7ea:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
	QIEMW_ADC_Handle->UT.qV_value = 0;
 800d7ee:	687b      	ldr	r3, [r7, #4]
 800d7f0:	2200      	movs	r2, #0
 800d7f2:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
	QIEMW_ADC_Handle->Temp.TEMP_value = 0;
 800d7f6:	687b      	ldr	r3, [r7, #4]
 800d7f8:	2200      	movs	r2, #0
 800d7fa:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
}
 800d7fe:	370c      	adds	r7, #12
 800d800:	46bd      	mov	sp, r7
 800d802:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d806:	4770      	bx	lr

0800d808 <ADC_Calibration>:

void ADC_Calibration(ADC_HandleTypeDef* hadc,QIEMW_ADC_HandleTypeDef *QIEMW_ADC_Handle)
{
 800d808:	b580      	push	{r7, lr}
 800d80a:	b088      	sub	sp, #32
 800d80c:	af00      	add	r7, sp, #0
 800d80e:	6078      	str	r0, [r7, #4]
 800d810:	6039      	str	r1, [r7, #0]
	u8 bIndex;
	
	ADC_ChannelConfTypeDef sConfig;
	HAL_NVIC_DisableIRQ(ADC_IRQn);
 800d812:	2012      	movs	r0, #18
 800d814:	f7f5 ff12 	bl	800363c <HAL_NVIC_DisableIRQ>
	HAL_ADCEx_InjectedStop_IT(hadc);
 800d818:	6878      	ldr	r0, [r7, #4]
 800d81a:	f7f4 fbfd 	bl	8002018 <HAL_ADCEx_InjectedStop_IT>
	
	if(hadc->Instance == ADC1)
 800d81e:	687b      	ldr	r3, [r7, #4]
 800d820:	681b      	ldr	r3, [r3, #0]
 800d822:	4aab      	ldr	r2, [pc, #684]	; (800dad0 <ADC_Calibration+0x2c8>)
 800d824:	4293      	cmp	r3, r2
 800d826:	f040 80d2 	bne.w	800d9ce <ADC_Calibration+0x1c6>
	{
		
		sConfig.Channel = PHASE_C1_CURRENT_CHANNEL;
 800d82a:	2306      	movs	r3, #6
 800d82c:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800d82e:	2301      	movs	r3, #1
 800d830:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800d832:	2302      	movs	r3, #2
 800d834:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800d836:	f107 030c 	add.w	r3, r7, #12
 800d83a:	6878      	ldr	r0, [r7, #4]
 800d83c:	4619      	mov	r1, r3
 800d83e:	f7f4 f909 	bl	8001a54 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d842:	2310      	movs	r3, #16
 800d844:	77fb      	strb	r3, [r7, #31]
 800d846:	e021      	b.n	800d88c <ADC_Calibration+0x84>
		{
			HAL_ADC_Start(hadc);
 800d848:	6878      	ldr	r0, [r7, #4]
 800d84a:	f7f3 ff11 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800d84e:	bf00      	nop
 800d850:	687b      	ldr	r3, [r7, #4]
 800d852:	681b      	ldr	r3, [r3, #0]
 800d854:	681b      	ldr	r3, [r3, #0]
 800d856:	f003 0302 	and.w	r3, r3, #2
 800d85a:	2b00      	cmp	r3, #0
 800d85c:	d0f8      	beq.n	800d850 <ADC_Calibration+0x48>
			QIEMW_ADC_Handle->PhaseC.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800d85e:	6878      	ldr	r0, [r7, #4]
 800d860:	f7f4 f8cc 	bl	80019fc <HAL_ADC_GetValue>
 800d864:	4603      	mov	r3, r0
 800d866:	b29b      	uxth	r3, r3
 800d868:	091b      	lsrs	r3, r3, #4
 800d86a:	b29b      	uxth	r3, r3
 800d86c:	4619      	mov	r1, r3
 800d86e:	683b      	ldr	r3, [r7, #0]
 800d870:	8c1a      	ldrh	r2, [r3, #32]
 800d872:	b28b      	uxth	r3, r1
 800d874:	4413      	add	r3, r2
 800d876:	b29a      	uxth	r2, r3
 800d878:	683b      	ldr	r3, [r7, #0]
 800d87a:	841a      	strh	r2, [r3, #32]
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800d87c:	687b      	ldr	r3, [r7, #4]
 800d87e:	681b      	ldr	r3, [r3, #0]
 800d880:	f06f 0202 	mvn.w	r2, #2
 800d884:	601a      	str	r2, [r3, #0]
		
		sConfig.Channel = PHASE_C1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d886:	7ffb      	ldrb	r3, [r7, #31]
 800d888:	3b01      	subs	r3, #1
 800d88a:	77fb      	strb	r3, [r7, #31]
 800d88c:	7ffb      	ldrb	r3, [r7, #31]
 800d88e:	2b00      	cmp	r3, #0
 800d890:	d1da      	bne.n	800d848 <ADC_Calibration+0x40>
			HAL_ADC_Start(hadc);
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseC.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_C2_CURRENT_CHANNEL;
 800d892:	2309      	movs	r3, #9
 800d894:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800d896:	2301      	movs	r3, #1
 800d898:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800d89a:	2302      	movs	r3, #2
 800d89c:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800d89e:	f107 030c 	add.w	r3, r7, #12
 800d8a2:	6878      	ldr	r0, [r7, #4]
 800d8a4:	4619      	mov	r1, r3
 800d8a6:	f7f4 f8d5 	bl	8001a54 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d8aa:	2310      	movs	r3, #16
 800d8ac:	77fb      	strb	r3, [r7, #31]
 800d8ae:	e021      	b.n	800d8f4 <ADC_Calibration+0xec>
		{
			HAL_ADC_Start(hadc);
 800d8b0:	6878      	ldr	r0, [r7, #4]
 800d8b2:	f7f3 fedd 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800d8b6:	bf00      	nop
 800d8b8:	687b      	ldr	r3, [r7, #4]
 800d8ba:	681b      	ldr	r3, [r3, #0]
 800d8bc:	681b      	ldr	r3, [r3, #0]
 800d8be:	f003 0302 	and.w	r3, r3, #2
 800d8c2:	2b00      	cmp	r3, #0
 800d8c4:	d0f8      	beq.n	800d8b8 <ADC_Calibration+0xb0>
			QIEMW_ADC_Handle->PhaseC.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800d8c6:	6878      	ldr	r0, [r7, #4]
 800d8c8:	f7f4 f898 	bl	80019fc <HAL_ADC_GetValue>
 800d8cc:	4603      	mov	r3, r0
 800d8ce:	b29b      	uxth	r3, r3
 800d8d0:	091b      	lsrs	r3, r3, #4
 800d8d2:	b29b      	uxth	r3, r3
 800d8d4:	4619      	mov	r1, r3
 800d8d6:	683b      	ldr	r3, [r7, #0]
 800d8d8:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 800d8da:	b28b      	uxth	r3, r1
 800d8dc:	4413      	add	r3, r2
 800d8de:	b29a      	uxth	r2, r3
 800d8e0:	683b      	ldr	r3, [r7, #0]
 800d8e2:	849a      	strh	r2, [r3, #36]	; 0x24
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800d8e4:	687b      	ldr	r3, [r7, #4]
 800d8e6:	681b      	ldr	r3, [r3, #0]
 800d8e8:	f06f 0202 	mvn.w	r2, #2
 800d8ec:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_C2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d8ee:	7ffb      	ldrb	r3, [r7, #31]
 800d8f0:	3b01      	subs	r3, #1
 800d8f2:	77fb      	strb	r3, [r7, #31]
 800d8f4:	7ffb      	ldrb	r3, [r7, #31]
 800d8f6:	2b00      	cmp	r3, #0
 800d8f8:	d1da      	bne.n	800d8b0 <ADC_Calibration+0xa8>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseC.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_C_VOLTAGE_CHANNEL;
 800d8fa:	2305      	movs	r3, #5
 800d8fc:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800d8fe:	2301      	movs	r3, #1
 800d900:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800d902:	2302      	movs	r3, #2
 800d904:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800d906:	f107 030c 	add.w	r3, r7, #12
 800d90a:	6878      	ldr	r0, [r7, #4]
 800d90c:	4619      	mov	r1, r3
 800d90e:	f7f4 f8a1 	bl	8001a54 <HAL_ADC_ConfigChannel>
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d912:	2310      	movs	r3, #16
 800d914:	77fb      	strb	r3, [r7, #31]
 800d916:	e021      	b.n	800d95c <ADC_Calibration+0x154>
		{
			HAL_ADC_Start(hadc);
 800d918:	6878      	ldr	r0, [r7, #4]
 800d91a:	f7f3 fea9 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800d91e:	bf00      	nop
 800d920:	687b      	ldr	r3, [r7, #4]
 800d922:	681b      	ldr	r3, [r3, #0]
 800d924:	681b      	ldr	r3, [r3, #0]
 800d926:	f003 0302 	and.w	r3, r3, #2
 800d92a:	2b00      	cmp	r3, #0
 800d92c:	d0f8      	beq.n	800d920 <ADC_Calibration+0x118>
			QIEMW_ADC_Handle->PhaseC.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800d92e:	6878      	ldr	r0, [r7, #4]
 800d930:	f7f4 f864 	bl	80019fc <HAL_ADC_GetValue>
 800d934:	4603      	mov	r3, r0
 800d936:	b29b      	uxth	r3, r3
 800d938:	091b      	lsrs	r3, r3, #4
 800d93a:	b29b      	uxth	r3, r3
 800d93c:	4619      	mov	r1, r3
 800d93e:	683b      	ldr	r3, [r7, #0]
 800d940:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 800d942:	b28b      	uxth	r3, r1
 800d944:	4413      	add	r3, r2
 800d946:	b29a      	uxth	r2, r3
 800d948:	683b      	ldr	r3, [r7, #0]
 800d94a:	851a      	strh	r2, [r3, #40]	; 0x28
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800d94c:	687b      	ldr	r3, [r7, #4]
 800d94e:	681b      	ldr	r3, [r3, #0]
 800d950:	f06f 0202 	mvn.w	r2, #2
 800d954:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_C_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d956:	7ffb      	ldrb	r3, [r7, #31]
 800d958:	3b01      	subs	r3, #1
 800d95a:	77fb      	strb	r3, [r7, #31]
 800d95c:	7ffb      	ldrb	r3, [r7, #31]
 800d95e:	2b00      	cmp	r3, #0
 800d960:	d1da      	bne.n	800d918 <ADC_Calibration+0x110>
			QIEMW_ADC_Handle->PhaseC.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}

		sConfig.Channel = PHASE_TEMP_CHANNEL;
 800d962:	2308      	movs	r3, #8
 800d964:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800d966:	2301      	movs	r3, #1
 800d968:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800d96a:	2302      	movs	r3, #2
 800d96c:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800d96e:	f107 030c 	add.w	r3, r7, #12
 800d972:	6878      	ldr	r0, [r7, #4]
 800d974:	4619      	mov	r1, r3
 800d976:	f7f4 f86d 	bl	8001a54 <HAL_ADC_ConfigChannel>
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d97a:	2310      	movs	r3, #16
 800d97c:	77fb      	strb	r3, [r7, #31]
 800d97e:	e023      	b.n	800d9c8 <ADC_Calibration+0x1c0>
		{
			HAL_ADC_Start(hadc);
 800d980:	6878      	ldr	r0, [r7, #4]
 800d982:	f7f3 fe75 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800d986:	bf00      	nop
 800d988:	687b      	ldr	r3, [r7, #4]
 800d98a:	681b      	ldr	r3, [r3, #0]
 800d98c:	681b      	ldr	r3, [r3, #0]
 800d98e:	f003 0302 	and.w	r3, r3, #2
 800d992:	2b00      	cmp	r3, #0
 800d994:	d0f8      	beq.n	800d988 <ADC_Calibration+0x180>
			QIEMW_ADC_Handle->Temp.TEMP_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800d996:	6878      	ldr	r0, [r7, #4]
 800d998:	f7f4 f830 	bl	80019fc <HAL_ADC_GetValue>
 800d99c:	4603      	mov	r3, r0
 800d99e:	b29b      	uxth	r3, r3
 800d9a0:	091b      	lsrs	r3, r3, #4
 800d9a2:	b29b      	uxth	r3, r3
 800d9a4:	4619      	mov	r1, r3
 800d9a6:	683b      	ldr	r3, [r7, #0]
 800d9a8:	f8b3 205e 	ldrh.w	r2, [r3, #94]	; 0x5e
 800d9ac:	b28b      	uxth	r3, r1
 800d9ae:	4413      	add	r3, r2
 800d9b0:	b29a      	uxth	r2, r3
 800d9b2:	683b      	ldr	r3, [r7, #0]
 800d9b4:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800d9b8:	687b      	ldr	r3, [r7, #4]
 800d9ba:	681b      	ldr	r3, [r3, #0]
 800d9bc:	f06f 0202 	mvn.w	r2, #2
 800d9c0:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_TEMP_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d9c2:	7ffb      	ldrb	r3, [r7, #31]
 800d9c4:	3b01      	subs	r3, #1
 800d9c6:	77fb      	strb	r3, [r7, #31]
 800d9c8:	7ffb      	ldrb	r3, [r7, #31]
 800d9ca:	2b00      	cmp	r3, #0
 800d9cc:	d1d8      	bne.n	800d980 <ADC_Calibration+0x178>
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}

	if(hadc->Instance == ADC2)
 800d9ce:	687b      	ldr	r3, [r7, #4]
 800d9d0:	681b      	ldr	r3, [r3, #0]
 800d9d2:	4a40      	ldr	r2, [pc, #256]	; (800dad4 <ADC_Calibration+0x2cc>)
 800d9d4:	4293      	cmp	r3, r2
 800d9d6:	f040 80d8 	bne.w	800db8a <ADC_Calibration+0x382>
	{
		sConfig.Channel = PHASE_B1_CURRENT_CHANNEL;
 800d9da:	2303      	movs	r3, #3
 800d9dc:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800d9de:	2301      	movs	r3, #1
 800d9e0:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800d9e2:	2302      	movs	r3, #2
 800d9e4:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800d9e6:	f107 030c 	add.w	r3, r7, #12
 800d9ea:	6878      	ldr	r0, [r7, #4]
 800d9ec:	4619      	mov	r1, r3
 800d9ee:	f7f4 f831 	bl	8001a54 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800d9f2:	2310      	movs	r3, #16
 800d9f4:	77fb      	strb	r3, [r7, #31]
 800d9f6:	e021      	b.n	800da3c <ADC_Calibration+0x234>
		{
			HAL_ADC_Start(hadc);
 800d9f8:	6878      	ldr	r0, [r7, #4]
 800d9fa:	f7f3 fe39 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800d9fe:	bf00      	nop
 800da00:	687b      	ldr	r3, [r7, #4]
 800da02:	681b      	ldr	r3, [r3, #0]
 800da04:	681b      	ldr	r3, [r3, #0]
 800da06:	f003 0302 	and.w	r3, r3, #2
 800da0a:	2b00      	cmp	r3, #0
 800da0c:	d0f8      	beq.n	800da00 <ADC_Calibration+0x1f8>
			QIEMW_ADC_Handle->PhaseB.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800da0e:	6878      	ldr	r0, [r7, #4]
 800da10:	f7f3 fff4 	bl	80019fc <HAL_ADC_GetValue>
 800da14:	4603      	mov	r3, r0
 800da16:	b29b      	uxth	r3, r3
 800da18:	091b      	lsrs	r3, r3, #4
 800da1a:	b29b      	uxth	r3, r3
 800da1c:	4619      	mov	r1, r3
 800da1e:	683b      	ldr	r3, [r7, #0]
 800da20:	8a5a      	ldrh	r2, [r3, #18]
 800da22:	b28b      	uxth	r3, r1
 800da24:	4413      	add	r3, r2
 800da26:	b29a      	uxth	r2, r3
 800da28:	683b      	ldr	r3, [r7, #0]
 800da2a:	825a      	strh	r2, [r3, #18]
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800da2c:	687b      	ldr	r3, [r7, #4]
 800da2e:	681b      	ldr	r3, [r3, #0]
 800da30:	f06f 0202 	mvn.w	r2, #2
 800da34:	601a      	str	r2, [r3, #0]
	{
		sConfig.Channel = PHASE_B1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800da36:	7ffb      	ldrb	r3, [r7, #31]
 800da38:	3b01      	subs	r3, #1
 800da3a:	77fb      	strb	r3, [r7, #31]
 800da3c:	7ffb      	ldrb	r3, [r7, #31]
 800da3e:	2b00      	cmp	r3, #0
 800da40:	d1da      	bne.n	800d9f8 <ADC_Calibration+0x1f0>
			HAL_ADC_Start(hadc);
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseB.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		HAL_ADC_Stop(hadc);
 800da42:	6878      	ldr	r0, [r7, #4]
 800da44:	f7f3 fe92 	bl	800176c <HAL_ADC_Stop>
		
		sConfig.Channel = PHASE_B2_CURRENT_CHANNEL;
 800da48:	230c      	movs	r3, #12
 800da4a:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800da4c:	2301      	movs	r3, #1
 800da4e:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800da50:	2302      	movs	r3, #2
 800da52:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800da54:	f107 030c 	add.w	r3, r7, #12
 800da58:	6878      	ldr	r0, [r7, #4]
 800da5a:	4619      	mov	r1, r3
 800da5c:	f7f3 fffa 	bl	8001a54 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800da60:	2310      	movs	r3, #16
 800da62:	77fb      	strb	r3, [r7, #31]
 800da64:	e021      	b.n	800daaa <ADC_Calibration+0x2a2>
		{
			HAL_ADC_Start(hadc);
 800da66:	6878      	ldr	r0, [r7, #4]
 800da68:	f7f3 fe02 	bl	8001670 <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800da6c:	bf00      	nop
 800da6e:	687b      	ldr	r3, [r7, #4]
 800da70:	681b      	ldr	r3, [r3, #0]
 800da72:	681b      	ldr	r3, [r3, #0]
 800da74:	f003 0302 	and.w	r3, r3, #2
 800da78:	2b00      	cmp	r3, #0
 800da7a:	d0f8      	beq.n	800da6e <ADC_Calibration+0x266>
			
			QIEMW_ADC_Handle->PhaseB.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800da7c:	6878      	ldr	r0, [r7, #4]
 800da7e:	f7f3 ffbd 	bl	80019fc <HAL_ADC_GetValue>
 800da82:	4603      	mov	r3, r0
 800da84:	b29b      	uxth	r3, r3
 800da86:	091b      	lsrs	r3, r3, #4
 800da88:	b29b      	uxth	r3, r3
 800da8a:	4619      	mov	r1, r3
 800da8c:	683b      	ldr	r3, [r7, #0]
 800da8e:	8ada      	ldrh	r2, [r3, #22]
 800da90:	b28b      	uxth	r3, r1
 800da92:	4413      	add	r3, r2
 800da94:	b29a      	uxth	r2, r3
 800da96:	683b      	ldr	r3, [r7, #0]
 800da98:	82da      	strh	r2, [r3, #22]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800da9a:	687b      	ldr	r3, [r7, #4]
 800da9c:	681b      	ldr	r3, [r3, #0]
 800da9e:	f06f 0202 	mvn.w	r2, #2
 800daa2:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_B2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800daa4:	7ffb      	ldrb	r3, [r7, #31]
 800daa6:	3b01      	subs	r3, #1
 800daa8:	77fb      	strb	r3, [r7, #31]
 800daaa:	7ffb      	ldrb	r3, [r7, #31]
 800daac:	2b00      	cmp	r3, #0
 800daae:	d1da      	bne.n	800da66 <ADC_Calibration+0x25e>
			
			QIEMW_ADC_Handle->PhaseB.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_B_VOLTAGE_CHANNEL;
 800dab0:	2304      	movs	r3, #4
 800dab2:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800dab4:	2301      	movs	r3, #1
 800dab6:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800dab8:	2302      	movs	r3, #2
 800daba:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800dabc:	f107 030c 	add.w	r3, r7, #12
 800dac0:	6878      	ldr	r0, [r7, #4]
 800dac2:	4619      	mov	r1, r3
 800dac4:	f7f3 ffc6 	bl	8001a54 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dac8:	2310      	movs	r3, #16
 800daca:	77fb      	strb	r3, [r7, #31]
 800dacc:	e026      	b.n	800db1c <ADC_Calibration+0x314>
 800dace:	bf00      	nop
 800dad0:	40012000 	.word	0x40012000
 800dad4:	40012100 	.word	0x40012100
		{
			HAL_ADC_Start(hadc);
 800dad8:	6878      	ldr	r0, [r7, #4]
 800dada:	f7f3 fdc9 	bl	8001670 <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800dade:	bf00      	nop
 800dae0:	687b      	ldr	r3, [r7, #4]
 800dae2:	681b      	ldr	r3, [r3, #0]
 800dae4:	681b      	ldr	r3, [r3, #0]
 800dae6:	f003 0302 	and.w	r3, r3, #2
 800daea:	2b00      	cmp	r3, #0
 800daec:	d0f8      	beq.n	800dae0 <ADC_Calibration+0x2d8>
			
			QIEMW_ADC_Handle->PhaseB.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800daee:	6878      	ldr	r0, [r7, #4]
 800daf0:	f7f3 ff84 	bl	80019fc <HAL_ADC_GetValue>
 800daf4:	4603      	mov	r3, r0
 800daf6:	b29b      	uxth	r3, r3
 800daf8:	091b      	lsrs	r3, r3, #4
 800dafa:	b29b      	uxth	r3, r3
 800dafc:	4619      	mov	r1, r3
 800dafe:	683b      	ldr	r3, [r7, #0]
 800db00:	8b5a      	ldrh	r2, [r3, #26]
 800db02:	b28b      	uxth	r3, r1
 800db04:	4413      	add	r3, r2
 800db06:	b29a      	uxth	r2, r3
 800db08:	683b      	ldr	r3, [r7, #0]
 800db0a:	835a      	strh	r2, [r3, #26]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800db0c:	687b      	ldr	r3, [r7, #4]
 800db0e:	681b      	ldr	r3, [r3, #0]
 800db10:	f06f 0202 	mvn.w	r2, #2
 800db14:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_B_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800db16:	7ffb      	ldrb	r3, [r7, #31]
 800db18:	3b01      	subs	r3, #1
 800db1a:	77fb      	strb	r3, [r7, #31]
 800db1c:	7ffb      	ldrb	r3, [r7, #31]
 800db1e:	2b00      	cmp	r3, #0
 800db20:	d1da      	bne.n	800dad8 <ADC_Calibration+0x2d0>
			
			QIEMW_ADC_Handle->PhaseB.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_BUS_CURRENT_CHANNEL;
 800db22:	230a      	movs	r3, #10
 800db24:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800db26:	2301      	movs	r3, #1
 800db28:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800db2a:	2302      	movs	r3, #2
 800db2c:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800db2e:	f107 030c 	add.w	r3, r7, #12
 800db32:	6878      	ldr	r0, [r7, #4]
 800db34:	4619      	mov	r1, r3
 800db36:	f7f3 ff8d 	bl	8001a54 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800db3a:	2310      	movs	r3, #16
 800db3c:	77fb      	strb	r3, [r7, #31]
 800db3e:	e021      	b.n	800db84 <ADC_Calibration+0x37c>
		{
			HAL_ADC_Start(hadc);
 800db40:	6878      	ldr	r0, [r7, #4]
 800db42:	f7f3 fd95 	bl	8001670 <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800db46:	bf00      	nop
 800db48:	687b      	ldr	r3, [r7, #4]
 800db4a:	681b      	ldr	r3, [r3, #0]
 800db4c:	681b      	ldr	r3, [r3, #0]
 800db4e:	f003 0302 	and.w	r3, r3, #2
 800db52:	2b00      	cmp	r3, #0
 800db54:	d0f8      	beq.n	800db48 <ADC_Calibration+0x340>
			QIEMW_ADC_Handle->BUS.qI_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800db56:	6878      	ldr	r0, [r7, #4]
 800db58:	f7f3 ff50 	bl	80019fc <HAL_ADC_GetValue>
 800db5c:	4603      	mov	r3, r0
 800db5e:	b29b      	uxth	r3, r3
 800db60:	091b      	lsrs	r3, r3, #4
 800db62:	b29b      	uxth	r3, r3
 800db64:	4619      	mov	r1, r3
 800db66:	683b      	ldr	r3, [r7, #0]
 800db68:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800db6a:	b28b      	uxth	r3, r1
 800db6c:	4413      	add	r3, r2
 800db6e:	b29a      	uxth	r2, r3
 800db70:	683b      	ldr	r3, [r7, #0]
 800db72:	859a      	strh	r2, [r3, #44]	; 0x2c
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800db74:	687b      	ldr	r3, [r7, #4]
 800db76:	681b      	ldr	r3, [r3, #0]
 800db78:	f06f 0202 	mvn.w	r2, #2
 800db7c:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_BUS_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800db7e:	7ffb      	ldrb	r3, [r7, #31]
 800db80:	3b01      	subs	r3, #1
 800db82:	77fb      	strb	r3, [r7, #31]
 800db84:	7ffb      	ldrb	r3, [r7, #31]
 800db86:	2b00      	cmp	r3, #0
 800db88:	d1da      	bne.n	800db40 <ADC_Calibration+0x338>
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}

	if(hadc->Instance == ADC3)
 800db8a:	687b      	ldr	r3, [r7, #4]
 800db8c:	681b      	ldr	r3, [r3, #0]
 800db8e:	4a6b      	ldr	r2, [pc, #428]	; (800dd3c <ADC_Calibration+0x534>)
 800db90:	4293      	cmp	r3, r2
 800db92:	f040 80d0 	bne.w	800dd36 <ADC_Calibration+0x52e>
	{
		sConfig.Channel = PHASE_A1_CURRENT_CHANNEL;
 800db96:	2305      	movs	r3, #5
 800db98:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800db9a:	2301      	movs	r3, #1
 800db9c:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800db9e:	2302      	movs	r3, #2
 800dba0:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800dba2:	f107 030c 	add.w	r3, r7, #12
 800dba6:	6878      	ldr	r0, [r7, #4]
 800dba8:	4619      	mov	r1, r3
 800dbaa:	f7f3 ff53 	bl	8001a54 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dbae:	2310      	movs	r3, #16
 800dbb0:	77fb      	strb	r3, [r7, #31]
 800dbb2:	e021      	b.n	800dbf8 <ADC_Calibration+0x3f0>
		{
			HAL_ADC_Start(hadc);
 800dbb4:	6878      	ldr	r0, [r7, #4]
 800dbb6:	f7f3 fd5b 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800dbba:	bf00      	nop
 800dbbc:	687b      	ldr	r3, [r7, #4]
 800dbbe:	681b      	ldr	r3, [r3, #0]
 800dbc0:	681b      	ldr	r3, [r3, #0]
 800dbc2:	f003 0302 	and.w	r3, r3, #2
 800dbc6:	2b00      	cmp	r3, #0
 800dbc8:	d0f8      	beq.n	800dbbc <ADC_Calibration+0x3b4>
			QIEMW_ADC_Handle->PhaseA.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800dbca:	6878      	ldr	r0, [r7, #4]
 800dbcc:	f7f3 ff16 	bl	80019fc <HAL_ADC_GetValue>
 800dbd0:	4603      	mov	r3, r0
 800dbd2:	b29b      	uxth	r3, r3
 800dbd4:	091b      	lsrs	r3, r3, #4
 800dbd6:	b29b      	uxth	r3, r3
 800dbd8:	4619      	mov	r1, r3
 800dbda:	683b      	ldr	r3, [r7, #0]
 800dbdc:	889a      	ldrh	r2, [r3, #4]
 800dbde:	b28b      	uxth	r3, r1
 800dbe0:	4413      	add	r3, r2
 800dbe2:	b29a      	uxth	r2, r3
 800dbe4:	683b      	ldr	r3, [r7, #0]
 800dbe6:	809a      	strh	r2, [r3, #4]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800dbe8:	687b      	ldr	r3, [r7, #4]
 800dbea:	681b      	ldr	r3, [r3, #0]
 800dbec:	f06f 0202 	mvn.w	r2, #2
 800dbf0:	601a      	str	r2, [r3, #0]
	{
		sConfig.Channel = PHASE_A1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dbf2:	7ffb      	ldrb	r3, [r7, #31]
 800dbf4:	3b01      	subs	r3, #1
 800dbf6:	77fb      	strb	r3, [r7, #31]
 800dbf8:	7ffb      	ldrb	r3, [r7, #31]
 800dbfa:	2b00      	cmp	r3, #0
 800dbfc:	d1da      	bne.n	800dbb4 <ADC_Calibration+0x3ac>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_A2_CURRENT_CHANNEL;
 800dbfe:	2306      	movs	r3, #6
 800dc00:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800dc02:	2301      	movs	r3, #1
 800dc04:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800dc06:	2302      	movs	r3, #2
 800dc08:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800dc0a:	f107 030c 	add.w	r3, r7, #12
 800dc0e:	6878      	ldr	r0, [r7, #4]
 800dc10:	4619      	mov	r1, r3
 800dc12:	f7f3 ff1f 	bl	8001a54 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dc16:	2310      	movs	r3, #16
 800dc18:	77fb      	strb	r3, [r7, #31]
 800dc1a:	e021      	b.n	800dc60 <ADC_Calibration+0x458>
		{
			HAL_ADC_Start(hadc);
 800dc1c:	6878      	ldr	r0, [r7, #4]
 800dc1e:	f7f3 fd27 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800dc22:	bf00      	nop
 800dc24:	687b      	ldr	r3, [r7, #4]
 800dc26:	681b      	ldr	r3, [r3, #0]
 800dc28:	681b      	ldr	r3, [r3, #0]
 800dc2a:	f003 0302 	and.w	r3, r3, #2
 800dc2e:	2b00      	cmp	r3, #0
 800dc30:	d0f8      	beq.n	800dc24 <ADC_Calibration+0x41c>
			QIEMW_ADC_Handle->PhaseA.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800dc32:	6878      	ldr	r0, [r7, #4]
 800dc34:	f7f3 fee2 	bl	80019fc <HAL_ADC_GetValue>
 800dc38:	4603      	mov	r3, r0
 800dc3a:	b29b      	uxth	r3, r3
 800dc3c:	091b      	lsrs	r3, r3, #4
 800dc3e:	b29b      	uxth	r3, r3
 800dc40:	4619      	mov	r1, r3
 800dc42:	683b      	ldr	r3, [r7, #0]
 800dc44:	891a      	ldrh	r2, [r3, #8]
 800dc46:	b28b      	uxth	r3, r1
 800dc48:	4413      	add	r3, r2
 800dc4a:	b29a      	uxth	r2, r3
 800dc4c:	683b      	ldr	r3, [r7, #0]
 800dc4e:	811a      	strh	r2, [r3, #8]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800dc50:	687b      	ldr	r3, [r7, #4]
 800dc52:	681b      	ldr	r3, [r3, #0]
 800dc54:	f06f 0202 	mvn.w	r2, #2
 800dc58:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_A2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dc5a:	7ffb      	ldrb	r3, [r7, #31]
 800dc5c:	3b01      	subs	r3, #1
 800dc5e:	77fb      	strb	r3, [r7, #31]
 800dc60:	7ffb      	ldrb	r3, [r7, #31]
 800dc62:	2b00      	cmp	r3, #0
 800dc64:	d1da      	bne.n	800dc1c <ADC_Calibration+0x414>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_A_VOLTAGE_CHANNEL;
 800dc66:	2307      	movs	r3, #7
 800dc68:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800dc6a:	2301      	movs	r3, #1
 800dc6c:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800dc6e:	2302      	movs	r3, #2
 800dc70:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800dc72:	f107 030c 	add.w	r3, r7, #12
 800dc76:	6878      	ldr	r0, [r7, #4]
 800dc78:	4619      	mov	r1, r3
 800dc7a:	f7f3 feeb 	bl	8001a54 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dc7e:	2310      	movs	r3, #16
 800dc80:	77fb      	strb	r3, [r7, #31]
 800dc82:	e021      	b.n	800dcc8 <ADC_Calibration+0x4c0>
		{
			HAL_ADC_Start(hadc);
 800dc84:	6878      	ldr	r0, [r7, #4]
 800dc86:	f7f3 fcf3 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800dc8a:	bf00      	nop
 800dc8c:	687b      	ldr	r3, [r7, #4]
 800dc8e:	681b      	ldr	r3, [r3, #0]
 800dc90:	681b      	ldr	r3, [r3, #0]
 800dc92:	f003 0302 	and.w	r3, r3, #2
 800dc96:	2b00      	cmp	r3, #0
 800dc98:	d0f8      	beq.n	800dc8c <ADC_Calibration+0x484>
			QIEMW_ADC_Handle->PhaseA.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800dc9a:	6878      	ldr	r0, [r7, #4]
 800dc9c:	f7f3 feae 	bl	80019fc <HAL_ADC_GetValue>
 800dca0:	4603      	mov	r3, r0
 800dca2:	b29b      	uxth	r3, r3
 800dca4:	091b      	lsrs	r3, r3, #4
 800dca6:	b29b      	uxth	r3, r3
 800dca8:	4619      	mov	r1, r3
 800dcaa:	683b      	ldr	r3, [r7, #0]
 800dcac:	899a      	ldrh	r2, [r3, #12]
 800dcae:	b28b      	uxth	r3, r1
 800dcb0:	4413      	add	r3, r2
 800dcb2:	b29a      	uxth	r2, r3
 800dcb4:	683b      	ldr	r3, [r7, #0]
 800dcb6:	819a      	strh	r2, [r3, #12]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800dcb8:	687b      	ldr	r3, [r7, #4]
 800dcba:	681b      	ldr	r3, [r3, #0]
 800dcbc:	f06f 0202 	mvn.w	r2, #2
 800dcc0:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_A_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dcc2:	7ffb      	ldrb	r3, [r7, #31]
 800dcc4:	3b01      	subs	r3, #1
 800dcc6:	77fb      	strb	r3, [r7, #31]
 800dcc8:	7ffb      	ldrb	r3, [r7, #31]
 800dcca:	2b00      	cmp	r3, #0
 800dccc:	d1da      	bne.n	800dc84 <ADC_Calibration+0x47c>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_BUS_VOLTAGE_CHANNEL;
 800dcce:	2304      	movs	r3, #4
 800dcd0:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 800dcd2:	2301      	movs	r3, #1
 800dcd4:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 800dcd6:	2302      	movs	r3, #2
 800dcd8:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 800dcda:	f107 030c 	add.w	r3, r7, #12
 800dcde:	6878      	ldr	r0, [r7, #4]
 800dce0:	4619      	mov	r1, r3
 800dce2:	f7f3 feb7 	bl	8001a54 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dce6:	2310      	movs	r3, #16
 800dce8:	77fb      	strb	r3, [r7, #31]
 800dcea:	e021      	b.n	800dd30 <ADC_Calibration+0x528>
		{
			HAL_ADC_Start(hadc);
 800dcec:	6878      	ldr	r0, [r7, #4]
 800dcee:	f7f3 fcbf 	bl	8001670 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 800dcf2:	bf00      	nop
 800dcf4:	687b      	ldr	r3, [r7, #4]
 800dcf6:	681b      	ldr	r3, [r3, #0]
 800dcf8:	681b      	ldr	r3, [r3, #0]
 800dcfa:	f003 0302 	and.w	r3, r3, #2
 800dcfe:	2b00      	cmp	r3, #0
 800dd00:	d0f8      	beq.n	800dcf4 <ADC_Calibration+0x4ec>
			QIEMW_ADC_Handle->BUS.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 800dd02:	6878      	ldr	r0, [r7, #4]
 800dd04:	f7f3 fe7a 	bl	80019fc <HAL_ADC_GetValue>
 800dd08:	4603      	mov	r3, r0
 800dd0a:	b29b      	uxth	r3, r3
 800dd0c:	091b      	lsrs	r3, r3, #4
 800dd0e:	b29b      	uxth	r3, r3
 800dd10:	4619      	mov	r1, r3
 800dd12:	683b      	ldr	r3, [r7, #0]
 800dd14:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 800dd16:	b28b      	uxth	r3, r1
 800dd18:	4413      	add	r3, r2
 800dd1a:	b29a      	uxth	r2, r3
 800dd1c:	683b      	ldr	r3, [r7, #0]
 800dd1e:	861a      	strh	r2, [r3, #48]	; 0x30
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800dd20:	687b      	ldr	r3, [r7, #4]
 800dd22:	681b      	ldr	r3, [r3, #0]
 800dd24:	f06f 0202 	mvn.w	r2, #2
 800dd28:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_BUS_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 800dd2a:	7ffb      	ldrb	r3, [r7, #31]
 800dd2c:	3b01      	subs	r3, #1
 800dd2e:	77fb      	strb	r3, [r7, #31]
 800dd30:	7ffb      	ldrb	r3, [r7, #31]
 800dd32:	2b00      	cmp	r3, #0
 800dd34:	d1da      	bne.n	800dcec <ADC_Calibration+0x4e4>
			QIEMW_ADC_Handle->BUS.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}
}
 800dd36:	3720      	adds	r7, #32
 800dd38:	46bd      	mov	sp, r7
 800dd3a:	bd80      	pop	{r7, pc}
 800dd3c:	40012200 	.word	0x40012200

0800dd40 <HAL_ADCEx_InjectedConvCpltCallback>:
extern int usartTest;
extern rt_err_t myprintf(char *buf, uint8_t size);


void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 800dd40:	b580      	push	{r7, lr}
 800dd42:	b082      	sub	sp, #8
 800dd44:	af00      	add	r7, sp, #0
 800dd46:	6078      	str	r0, [r7, #4]
	hadc->Instance = ADC1;
 800dd48:	687b      	ldr	r3, [r7, #4]
 800dd4a:	4a57      	ldr	r2, [pc, #348]	; (800dea8 <HAL_ADCEx_InjectedConvCpltCallback+0x168>)
 800dd4c:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseC.qI1_value = (s16)(HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1));
 800dd4e:	6878      	ldr	r0, [r7, #4]
 800dd50:	2101      	movs	r1, #1
 800dd52:	f7f4 f989 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800dd56:	4603      	mov	r3, r0
 800dd58:	b29a      	uxth	r2, r3
 800dd5a:	4b54      	ldr	r3, [pc, #336]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800dd5c:	839a      	strh	r2, [r3, #28]
	Global_User_ADC.PhaseC.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 800dd5e:	6878      	ldr	r0, [r7, #4]
 800dd60:	2102      	movs	r1, #2
 800dd62:	f7f4 f981 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800dd66:	4603      	mov	r3, r0
 800dd68:	b29a      	uxth	r2, r3
 800dd6a:	4b50      	ldr	r3, [pc, #320]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800dd6c:	845a      	strh	r2, [r3, #34]	; 0x22
	Global_User_ADC.PhaseC.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 800dd6e:	6878      	ldr	r0, [r7, #4]
 800dd70:	2103      	movs	r1, #3
 800dd72:	f7f4 f979 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800dd76:	4603      	mov	r3, r0
 800dd78:	b29a      	uxth	r2, r3
 800dd7a:	4b4c      	ldr	r3, [pc, #304]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800dd7c:	84da      	strh	r2, [r3, #38]	; 0x26
	Global_User_ADC.Temp.TEMP_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 800dd7e:	6878      	ldr	r0, [r7, #4]
 800dd80:	2104      	movs	r1, #4
 800dd82:	f7f4 f971 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800dd86:	4603      	mov	r3, r0
 800dd88:	b29a      	uxth	r2, r3
 800dd8a:	4b48      	ldr	r3, [pc, #288]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800dd8c:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
	hadc->Instance = ADC2;
 800dd90:	687b      	ldr	r3, [r7, #4]
 800dd92:	4a47      	ldr	r2, [pc, #284]	; (800deb0 <HAL_ADCEx_InjectedConvCpltCallback+0x170>)
 800dd94:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseB.qI1_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1);
 800dd96:	6878      	ldr	r0, [r7, #4]
 800dd98:	2101      	movs	r1, #1
 800dd9a:	f7f4 f965 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800dd9e:	4603      	mov	r3, r0
 800dda0:	b29a      	uxth	r2, r3
 800dda2:	4b42      	ldr	r3, [pc, #264]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800dda4:	81da      	strh	r2, [r3, #14]
	Global_User_ADC.PhaseB.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 800dda6:	6878      	ldr	r0, [r7, #4]
 800dda8:	2102      	movs	r1, #2
 800ddaa:	f7f4 f95d 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800ddae:	4603      	mov	r3, r0
 800ddb0:	b29a      	uxth	r2, r3
 800ddb2:	4b3e      	ldr	r3, [pc, #248]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800ddb4:	829a      	strh	r2, [r3, #20]
	Global_User_ADC.PhaseB.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 800ddb6:	6878      	ldr	r0, [r7, #4]
 800ddb8:	2103      	movs	r1, #3
 800ddba:	f7f4 f955 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800ddbe:	4603      	mov	r3, r0
 800ddc0:	b29a      	uxth	r2, r3
 800ddc2:	4b3a      	ldr	r3, [pc, #232]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800ddc4:	831a      	strh	r2, [r3, #24]
	Global_User_ADC.BUS.qI_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 800ddc6:	6878      	ldr	r0, [r7, #4]
 800ddc8:	2104      	movs	r1, #4
 800ddca:	f7f4 f94d 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800ddce:	4603      	mov	r3, r0
 800ddd0:	b29a      	uxth	r2, r3
 800ddd2:	4b36      	ldr	r3, [pc, #216]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800ddd4:	855a      	strh	r2, [r3, #42]	; 0x2a
	hadc->Instance = ADC3;
 800ddd6:	687b      	ldr	r3, [r7, #4]
 800ddd8:	4a36      	ldr	r2, [pc, #216]	; (800deb4 <HAL_ADCEx_InjectedConvCpltCallback+0x174>)
 800ddda:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseA.qI1_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1);
 800dddc:	6878      	ldr	r0, [r7, #4]
 800ddde:	2101      	movs	r1, #1
 800dde0:	f7f4 f942 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800dde4:	4603      	mov	r3, r0
 800dde6:	b29a      	uxth	r2, r3
 800dde8:	4b30      	ldr	r3, [pc, #192]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800ddea:	801a      	strh	r2, [r3, #0]
	Global_User_ADC.PhaseA.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 800ddec:	6878      	ldr	r0, [r7, #4]
 800ddee:	2102      	movs	r1, #2
 800ddf0:	f7f4 f93a 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800ddf4:	4603      	mov	r3, r0
 800ddf6:	b29a      	uxth	r2, r3
 800ddf8:	4b2c      	ldr	r3, [pc, #176]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800ddfa:	80da      	strh	r2, [r3, #6]
	Global_User_ADC.PhaseA.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 800ddfc:	6878      	ldr	r0, [r7, #4]
 800ddfe:	2103      	movs	r1, #3
 800de00:	f7f4 f932 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800de04:	4603      	mov	r3, r0
 800de06:	b29a      	uxth	r2, r3
 800de08:	4b28      	ldr	r3, [pc, #160]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de0a:	815a      	strh	r2, [r3, #10]
	Global_User_ADC.BUS.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 800de0c:	6878      	ldr	r0, [r7, #4]
 800de0e:	2104      	movs	r1, #4
 800de10:	f7f4 f92a 	bl	8002068 <HAL_ADCEx_InjectedGetValue>
 800de14:	4603      	mov	r3, r0
 800de16:	b29a      	uxth	r2, r3
 800de18:	4b24      	ldr	r3, [pc, #144]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de1a:	85da      	strh	r2, [r3, #46]	; 0x2e

	Global_User_ADC.PhaseC.qI_value = (s16)(((s32)Global_User_ADC.PhaseC.qI1_value + (s32)Global_User_ADC.PhaseC.qI2_value) >> 1);
 800de1c:	4b23      	ldr	r3, [pc, #140]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de1e:	8b9b      	ldrh	r3, [r3, #28]
 800de20:	b21a      	sxth	r2, r3
 800de22:	4b22      	ldr	r3, [pc, #136]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de24:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800de26:	b21b      	sxth	r3, r3
 800de28:	4413      	add	r3, r2
 800de2a:	105b      	asrs	r3, r3, #1
 800de2c:	b29a      	uxth	r2, r3
 800de2e:	4b1f      	ldr	r3, [pc, #124]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de30:	83da      	strh	r2, [r3, #30]
	Global_User_ADC.PhaseB.qI_value = (s16)(((s32)Global_User_ADC.PhaseB.qI1_value + (s32)Global_User_ADC.PhaseB.qI2_value) >> 1);
 800de32:	4b1e      	ldr	r3, [pc, #120]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de34:	89db      	ldrh	r3, [r3, #14]
 800de36:	b21a      	sxth	r2, r3
 800de38:	4b1c      	ldr	r3, [pc, #112]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de3a:	8a9b      	ldrh	r3, [r3, #20]
 800de3c:	b21b      	sxth	r3, r3
 800de3e:	4413      	add	r3, r2
 800de40:	105b      	asrs	r3, r3, #1
 800de42:	b29a      	uxth	r2, r3
 800de44:	4b19      	ldr	r3, [pc, #100]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de46:	821a      	strh	r2, [r3, #16]
	Global_User_ADC.PhaseA.qI_value = (s16)(((s32)Global_User_ADC.PhaseA.qI1_value + (s32)Global_User_ADC.PhaseA.qI2_value) >> 1);
 800de48:	4b18      	ldr	r3, [pc, #96]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de4a:	881b      	ldrh	r3, [r3, #0]
 800de4c:	b21a      	sxth	r2, r3
 800de4e:	4b17      	ldr	r3, [pc, #92]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de50:	88db      	ldrh	r3, [r3, #6]
 800de52:	b21b      	sxth	r3, r3
 800de54:	4413      	add	r3, r2
 800de56:	105b      	asrs	r3, r3, #1
 800de58:	b29a      	uxth	r2, r3
 800de5a:	4b14      	ldr	r3, [pc, #80]	; (800deac <HAL_ADCEx_InjectedConvCpltCallback+0x16c>)
 800de5c:	805a      	strh	r2, [r3, #2]
	#ifdef RT_USING_STEMWIN
	ArrayDeal();
	#endif

    if (SVPWMEOCEvent())
 800de5e:	f003 ffb5 	bl	8011dcc <SVPWMEOCEvent>
 800de62:	4603      	mov	r3, r0
 800de64:	2b00      	cmp	r3, #0
 800de66:	d00b      	beq.n	800de80 <HAL_ADCEx_InjectedConvCpltCallback+0x140>
    {
      if ((State == START) || (State == RUN))
 800de68:	4b13      	ldr	r3, [pc, #76]	; (800deb8 <HAL_ADCEx_InjectedConvCpltCallback+0x178>)
 800de6a:	781b      	ldrb	r3, [r3, #0]
 800de6c:	b2db      	uxtb	r3, r3
 800de6e:	2b02      	cmp	r3, #2
 800de70:	d004      	beq.n	800de7c <HAL_ADCEx_InjectedConvCpltCallback+0x13c>
 800de72:	4b11      	ldr	r3, [pc, #68]	; (800deb8 <HAL_ADCEx_InjectedConvCpltCallback+0x178>)
 800de74:	781b      	ldrb	r3, [r3, #0]
 800de76:	b2db      	uxtb	r3, r3
 800de78:	2b03      	cmp	r3, #3
 800de7a:	d101      	bne.n	800de80 <HAL_ADCEx_InjectedConvCpltCallback+0x140>
      {
        /**********STARTS THE VECTOR CONTROL ************************/    
        IFOC_Model();
 800de7c:	f002 fe54 	bl	8010b28 <IFOC_Model>
        MCDAC_Update_Output();
      #endif
    }
#if 1
	static char i=0;
	i++;
 800de80:	4b0e      	ldr	r3, [pc, #56]	; (800debc <HAL_ADCEx_InjectedConvCpltCallback+0x17c>)
 800de82:	781b      	ldrb	r3, [r3, #0]
 800de84:	3301      	adds	r3, #1
 800de86:	b2da      	uxtb	r2, r3
 800de88:	4b0c      	ldr	r3, [pc, #48]	; (800debc <HAL_ADCEx_InjectedConvCpltCallback+0x17c>)
 800de8a:	701a      	strb	r2, [r3, #0]
	if(i>200)
 800de8c:	4b0b      	ldr	r3, [pc, #44]	; (800debc <HAL_ADCEx_InjectedConvCpltCallback+0x17c>)
 800de8e:	781b      	ldrb	r3, [r3, #0]
 800de90:	2bc8      	cmp	r3, #200	; 0xc8
 800de92:	d906      	bls.n	800dea2 <HAL_ADCEx_InjectedConvCpltCallback+0x162>
	{
		i = 0;
 800de94:	4b09      	ldr	r3, [pc, #36]	; (800debc <HAL_ADCEx_InjectedConvCpltCallback+0x17c>)
 800de96:	2200      	movs	r2, #0
 800de98:	701a      	strb	r2, [r3, #0]
		myprintf("123456789012\r\n", 15);
 800de9a:	4809      	ldr	r0, [pc, #36]	; (800dec0 <HAL_ADCEx_InjectedConvCpltCallback+0x180>)
 800de9c:	210f      	movs	r1, #15
 800de9e:	f002 fac5 	bl	801042c <myprintf>
	}
	#endif
	//__HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
}
 800dea2:	3708      	adds	r7, #8
 800dea4:	46bd      	mov	sp, r7
 800dea6:	bd80      	pop	{r7, pc}
 800dea8:	40012000 	.word	0x40012000
 800deac:	2001235c 	.word	0x2001235c
 800deb0:	40012100 	.word	0x40012100
 800deb4:	40012200 	.word	0x40012200
 800deb8:	20012528 	.word	0x20012528
 800debc:	200107f8 	.word	0x200107f8
 800dec0:	080227b8 	.word	0x080227b8

0800dec4 <ADC_IRQHandler>:



void ADC_IRQHandler(void)
{
 800dec4:	b580      	push	{r7, lr}
 800dec6:	b092      	sub	sp, #72	; 0x48
 800dec8:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC_handle;

    /* enter interrupt */
    rt_interrupt_enter();
 800deca:	f005 f8c1 	bl	8013050 <rt_interrupt_enter>
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_SET);
 800dece:	480a      	ldr	r0, [pc, #40]	; (800def8 <ADC_IRQHandler+0x34>)
 800ded0:	2108      	movs	r1, #8
 800ded2:	2201      	movs	r2, #1
 800ded4:	f7fa fb34 	bl	8008540 <HAL_GPIO_WritePin>

	ADC_handle.Instance = ADC1;
 800ded8:	4b08      	ldr	r3, [pc, #32]	; (800defc <ADC_IRQHandler+0x38>)
 800deda:	607b      	str	r3, [r7, #4]
	HAL_ADC_IRQHandler(&ADC_handle);
 800dedc:	1d3b      	adds	r3, r7, #4
 800dede:	4618      	mov	r0, r3
 800dee0:	f7f3 fc5c 	bl	800179c <HAL_ADC_IRQHandler>
	
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_RESET);
 800dee4:	4804      	ldr	r0, [pc, #16]	; (800def8 <ADC_IRQHandler+0x34>)
 800dee6:	2108      	movs	r1, #8
 800dee8:	2200      	movs	r2, #0
 800deea:	f7fa fb29 	bl	8008540 <HAL_GPIO_WritePin>

    /* leave interrupt */
    rt_interrupt_leave();
 800deee:	f005 f8c5 	bl	801307c <rt_interrupt_leave>
}
 800def2:	3748      	adds	r7, #72	; 0x48
 800def4:	46bd      	mov	sp, r7
 800def6:	bd80      	pop	{r7, pc}
 800def8:	40022000 	.word	0x40022000
 800defc:	40012000 	.word	0x40012000

0800df00 <HAL_ADC_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
	void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 800df00:	b580      	push	{r7, lr}
 800df02:	b090      	sub	sp, #64	; 0x40
 800df04:	af00      	add	r7, sp, #0
 800df06:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
    if (hadc->Instance == ADC1)
 800df08:	687b      	ldr	r3, [r7, #4]
 800df0a:	681b      	ldr	r3, [r3, #0]
 800df0c:	4a90      	ldr	r2, [pc, #576]	; (800e150 <HAL_ADC_MspInit+0x250>)
 800df0e:	4293      	cmp	r3, r2
 800df10:	d153      	bne.n	800dfba <HAL_ADC_MspInit+0xba>
    {
 		ADC1_CLK_ENABLE();
 800df12:	4a90      	ldr	r2, [pc, #576]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df14:	4b8f      	ldr	r3, [pc, #572]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800df18:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800df1c:	6453      	str	r3, [r2, #68]	; 0x44
 800df1e:	4b8d      	ldr	r3, [pc, #564]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df20:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800df22:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800df26:	62bb      	str	r3, [r7, #40]	; 0x28
 800df28:	6abb      	ldr	r3, [r7, #40]	; 0x28
		ADC_GPIOA_CLK_ENABLE();
 800df2a:	4a8a      	ldr	r2, [pc, #552]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df2c:	4b89      	ldr	r3, [pc, #548]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800df30:	f043 0301 	orr.w	r3, r3, #1
 800df34:	6313      	str	r3, [r2, #48]	; 0x30
 800df36:	4b87      	ldr	r3, [pc, #540]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800df3a:	f003 0301 	and.w	r3, r3, #1
 800df3e:	627b      	str	r3, [r7, #36]	; 0x24
 800df40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
		ADC_GPIOC_CLK_ENABLE();
 800df42:	4a84      	ldr	r2, [pc, #528]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df44:	4b83      	ldr	r3, [pc, #524]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800df48:	f043 0304 	orr.w	r3, r3, #4
 800df4c:	6313      	str	r3, [r2, #48]	; 0x30
 800df4e:	4b81      	ldr	r3, [pc, #516]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800df50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800df52:	f003 0304 	and.w	r3, r3, #4
 800df56:	623b      	str	r3, [r7, #32]
 800df58:	6a3b      	ldr	r3, [r7, #32]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800df5a:	2303      	movs	r3, #3
 800df5c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C1_CURRENT_PIN;
 800df5e:	2340      	movs	r3, #64	; 0x40
 800df60:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800df62:	2300      	movs	r3, #0
 800df64:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C1_CURRENT_PORT, &GPIO_InitStruct);		
 800df66:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800df6a:	487b      	ldr	r0, [pc, #492]	; (800e158 <HAL_ADC_MspInit+0x258>)
 800df6c:	4619      	mov	r1, r3
 800df6e:	f7fa f81f 	bl	8007fb0 <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800df72:	2303      	movs	r3, #3
 800df74:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C2_CURRENT_PIN;
 800df76:	2302      	movs	r3, #2
 800df78:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800df7a:	2300      	movs	r3, #0
 800df7c:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C2_CURRENT_PORT, &GPIO_InitStruct);		
 800df7e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800df82:	4876      	ldr	r0, [pc, #472]	; (800e15c <HAL_ADC_MspInit+0x25c>)
 800df84:	4619      	mov	r1, r3
 800df86:	f7fa f813 	bl	8007fb0 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800df8a:	2303      	movs	r3, #3
 800df8c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C_VOLTAGE_PIN;
 800df8e:	2320      	movs	r3, #32
 800df90:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800df92:	2300      	movs	r3, #0
 800df94:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C_VOLTAGE_PORT, &GPIO_InitStruct);		
 800df96:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800df9a:	486f      	ldr	r0, [pc, #444]	; (800e158 <HAL_ADC_MspInit+0x258>)
 800df9c:	4619      	mov	r1, r3
 800df9e:	f7fa f807 	bl	8007fb0 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800dfa2:	2303      	movs	r3, #3
 800dfa4:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_TEMP_PIN;
 800dfa6:	2301      	movs	r3, #1
 800dfa8:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800dfaa:	2300      	movs	r3, #0
 800dfac:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_TEMP_PORT, &GPIO_InitStruct);		
 800dfae:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800dfb2:	486a      	ldr	r0, [pc, #424]	; (800e15c <HAL_ADC_MspInit+0x25c>)
 800dfb4:	4619      	mov	r1, r3
 800dfb6:	f7f9 fffb 	bl	8007fb0 <HAL_GPIO_Init>
    }

	if (hadc->Instance == ADC2)
 800dfba:	687b      	ldr	r3, [r7, #4]
 800dfbc:	681b      	ldr	r3, [r3, #0]
 800dfbe:	4a68      	ldr	r2, [pc, #416]	; (800e160 <HAL_ADC_MspInit+0x260>)
 800dfc0:	4293      	cmp	r3, r2
 800dfc2:	d153      	bne.n	800e06c <HAL_ADC_MspInit+0x16c>
    {
 		ADC2_CLK_ENABLE();
 800dfc4:	4a63      	ldr	r2, [pc, #396]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800dfc6:	4b63      	ldr	r3, [pc, #396]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800dfc8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dfca:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800dfce:	6453      	str	r3, [r2, #68]	; 0x44
 800dfd0:	4b60      	ldr	r3, [pc, #384]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800dfd2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dfd4:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800dfd8:	61fb      	str	r3, [r7, #28]
 800dfda:	69fb      	ldr	r3, [r7, #28]
		ADC_GPIOA_CLK_ENABLE();
 800dfdc:	4a5d      	ldr	r2, [pc, #372]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800dfde:	4b5d      	ldr	r3, [pc, #372]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800dfe0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dfe2:	f043 0301 	orr.w	r3, r3, #1
 800dfe6:	6313      	str	r3, [r2, #48]	; 0x30
 800dfe8:	4b5a      	ldr	r3, [pc, #360]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800dfea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dfec:	f003 0301 	and.w	r3, r3, #1
 800dff0:	61bb      	str	r3, [r7, #24]
 800dff2:	69bb      	ldr	r3, [r7, #24]
		ADC_GPIOC_CLK_ENABLE();
 800dff4:	4a57      	ldr	r2, [pc, #348]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800dff6:	4b57      	ldr	r3, [pc, #348]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800dff8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dffa:	f043 0304 	orr.w	r3, r3, #4
 800dffe:	6313      	str	r3, [r2, #48]	; 0x30
 800e000:	4b54      	ldr	r3, [pc, #336]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e002:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e004:	f003 0304 	and.w	r3, r3, #4
 800e008:	617b      	str	r3, [r7, #20]
 800e00a:	697b      	ldr	r3, [r7, #20]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800e00c:	2303      	movs	r3, #3
 800e00e:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B1_CURRENT_PIN;
 800e010:	2308      	movs	r3, #8
 800e012:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e014:	2300      	movs	r3, #0
 800e016:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B1_CURRENT_PORT, &GPIO_InitStruct);		
 800e018:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e01c:	484e      	ldr	r0, [pc, #312]	; (800e158 <HAL_ADC_MspInit+0x258>)
 800e01e:	4619      	mov	r1, r3
 800e020:	f7f9 ffc6 	bl	8007fb0 <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800e024:	2303      	movs	r3, #3
 800e026:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B2_CURRENT_PIN;
 800e028:	2304      	movs	r3, #4
 800e02a:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e02c:	2300      	movs	r3, #0
 800e02e:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B2_CURRENT_PORT, &GPIO_InitStruct);		
 800e030:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e034:	484b      	ldr	r0, [pc, #300]	; (800e164 <HAL_ADC_MspInit+0x264>)
 800e036:	4619      	mov	r1, r3
 800e038:	f7f9 ffba 	bl	8007fb0 <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800e03c:	2303      	movs	r3, #3
 800e03e:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B_VOLTAGE_PIN;
 800e040:	2310      	movs	r3, #16
 800e042:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e044:	2300      	movs	r3, #0
 800e046:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B_VOLTAGE_PORT, &GPIO_InitStruct);	
 800e048:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e04c:	4842      	ldr	r0, [pc, #264]	; (800e158 <HAL_ADC_MspInit+0x258>)
 800e04e:	4619      	mov	r1, r3
 800e050:	f7f9 ffae 	bl	8007fb0 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800e054:	2303      	movs	r3, #3
 800e056:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_BUS_CURRENT_PIN;
 800e058:	2301      	movs	r3, #1
 800e05a:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e05c:	2300      	movs	r3, #0
 800e05e:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_BUS_CURRENT_PORT, &GPIO_InitStruct);		
 800e060:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e064:	483f      	ldr	r0, [pc, #252]	; (800e164 <HAL_ADC_MspInit+0x264>)
 800e066:	4619      	mov	r1, r3
 800e068:	f7f9 ffa2 	bl	8007fb0 <HAL_GPIO_Init>
    }

	
	if (hadc->Instance == ADC3)
 800e06c:	687b      	ldr	r3, [r7, #4]
 800e06e:	681b      	ldr	r3, [r3, #0]
 800e070:	4a3d      	ldr	r2, [pc, #244]	; (800e168 <HAL_ADC_MspInit+0x268>)
 800e072:	4293      	cmp	r3, r2
 800e074:	d155      	bne.n	800e122 <HAL_ADC_MspInit+0x222>
    {
 		ADC3_CLK_ENABLE();
 800e076:	4a37      	ldr	r2, [pc, #220]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e078:	4b36      	ldr	r3, [pc, #216]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e07a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e07c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800e080:	6453      	str	r3, [r2, #68]	; 0x44
 800e082:	4b34      	ldr	r3, [pc, #208]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e084:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e086:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800e08a:	613b      	str	r3, [r7, #16]
 800e08c:	693b      	ldr	r3, [r7, #16]
		ADC_GPIOA_CLK_ENABLE();
 800e08e:	4a31      	ldr	r2, [pc, #196]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e090:	4b30      	ldr	r3, [pc, #192]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e092:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e094:	f043 0301 	orr.w	r3, r3, #1
 800e098:	6313      	str	r3, [r2, #48]	; 0x30
 800e09a:	4b2e      	ldr	r3, [pc, #184]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e09c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e09e:	f003 0301 	and.w	r3, r3, #1
 800e0a2:	60fb      	str	r3, [r7, #12]
 800e0a4:	68fb      	ldr	r3, [r7, #12]
		ADC_GPIOF_CLK_ENABLE();
 800e0a6:	4a2b      	ldr	r2, [pc, #172]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e0a8:	4b2a      	ldr	r3, [pc, #168]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e0aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e0ac:	f043 0320 	orr.w	r3, r3, #32
 800e0b0:	6313      	str	r3, [r2, #48]	; 0x30
 800e0b2:	4b28      	ldr	r3, [pc, #160]	; (800e154 <HAL_ADC_MspInit+0x254>)
 800e0b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e0b6:	f003 0320 	and.w	r3, r3, #32
 800e0ba:	60bb      	str	r3, [r7, #8]
 800e0bc:	68bb      	ldr	r3, [r7, #8]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800e0be:	2303      	movs	r3, #3
 800e0c0:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A1_CURRENT_PIN;
 800e0c2:	2380      	movs	r3, #128	; 0x80
 800e0c4:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e0c6:	2300      	movs	r3, #0
 800e0c8:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A1_CURRENT_PORT, &GPIO_InitStruct);		
 800e0ca:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e0ce:	4827      	ldr	r0, [pc, #156]	; (800e16c <HAL_ADC_MspInit+0x26c>)
 800e0d0:	4619      	mov	r1, r3
 800e0d2:	f7f9 ff6d 	bl	8007fb0 <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800e0d6:	2303      	movs	r3, #3
 800e0d8:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A2_CURRENT_PIN;
 800e0da:	f44f 7380 	mov.w	r3, #256	; 0x100
 800e0de:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e0e0:	2300      	movs	r3, #0
 800e0e2:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A2_CURRENT_PORT, &GPIO_InitStruct);		
 800e0e4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e0e8:	4820      	ldr	r0, [pc, #128]	; (800e16c <HAL_ADC_MspInit+0x26c>)
 800e0ea:	4619      	mov	r1, r3
 800e0ec:	f7f9 ff60 	bl	8007fb0 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800e0f0:	2303      	movs	r3, #3
 800e0f2:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A_VOLTAGE_PIN;
 800e0f4:	f44f 7300 	mov.w	r3, #512	; 0x200
 800e0f8:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e0fa:	2300      	movs	r3, #0
 800e0fc:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A_VOLTAGE_PORT, &GPIO_InitStruct);		
 800e0fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e102:	481a      	ldr	r0, [pc, #104]	; (800e16c <HAL_ADC_MspInit+0x26c>)
 800e104:	4619      	mov	r1, r3
 800e106:	f7f9 ff53 	bl	8007fb0 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800e10a:	2303      	movs	r3, #3
 800e10c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_BUS_VOLTAGE_PIN;
 800e10e:	2340      	movs	r3, #64	; 0x40
 800e110:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e112:	2300      	movs	r3, #0
 800e114:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_BUS_VOLTAGE_PORT, &GPIO_InitStruct);		
 800e116:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e11a:	4814      	ldr	r0, [pc, #80]	; (800e16c <HAL_ADC_MspInit+0x26c>)
 800e11c:	4619      	mov	r1, r3
 800e11e:	f7f9 ff47 	bl	8007fb0 <HAL_GPIO_Init>
    }

	/*************************test pin************************/
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800e122:	2301      	movs	r3, #1
 800e124:	633b      	str	r3, [r7, #48]	; 0x30
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 800e126:	2308      	movs	r3, #8
 800e128:	62fb      	str	r3, [r7, #44]	; 0x2c
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 800e12a:	2301      	movs	r3, #1
 800e12c:	637b      	str	r3, [r7, #52]	; 0x34
	HAL_GPIO_Init(GPIOI, &GPIO_InitStruct); 	
 800e12e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e132:	480f      	ldr	r0, [pc, #60]	; (800e170 <HAL_ADC_MspInit+0x270>)
 800e134:	4619      	mov	r1, r3
 800e136:	f7f9 ff3b 	bl	8007fb0 <HAL_GPIO_Init>
	
	HAL_NVIC_SetPriority(ADC_IRQn,ADC_IRQ_PREEMPT,ADC_IRQ_SUB);
 800e13a:	2012      	movs	r0, #18
 800e13c:	2100      	movs	r1, #0
 800e13e:	2200      	movs	r2, #0
 800e140:	f7f5 fa52 	bl	80035e8 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(ADC_IRQn);
 800e144:	2012      	movs	r0, #18
 800e146:	f7f5 fa6b 	bl	8003620 <HAL_NVIC_EnableIRQ>
}
 800e14a:	3740      	adds	r7, #64	; 0x40
 800e14c:	46bd      	mov	sp, r7
 800e14e:	bd80      	pop	{r7, pc}
 800e150:	40012000 	.word	0x40012000
 800e154:	40023800 	.word	0x40023800
 800e158:	40020000 	.word	0x40020000
 800e15c:	40020400 	.word	0x40020400
 800e160:	40012100 	.word	0x40012100
 800e164:	40020800 	.word	0x40020800
 800e168:	40012200 	.word	0x40012200
 800e16c:	40021400 	.word	0x40021400
 800e170:	40022000 	.word	0x40022000

0800e174 <ADC_CalibrationAll>:



extern void ADC_CalibrationAll(void)
{
 800e174:	b580      	push	{r7, lr}
 800e176:	b0c0      	sub	sp, #256	; 0x100
 800e178:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC1_handle,ADC2_handle,ADC3_handle;
	ADC_InjectionConfTypeDef ADCConfigInjected;
	ADC_MultiModeTypeDef ADCMultiMode;

	QIEMW_ADC_init(&Global_User_ADC);
 800e17a:	4881      	ldr	r0, [pc, #516]	; (800e380 <ADC_CalibrationAll+0x20c>)
 800e17c:	f7ff fad2 	bl	800d724 <QIEMW_ADC_init>
	ADC1_handle.Instance = ADC1;
 800e180:	4b80      	ldr	r3, [pc, #512]	; (800e384 <ADC_CalibrationAll+0x210>)
 800e182:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
	ADC2_handle.Instance = ADC2;
 800e186:	4b80      	ldr	r3, [pc, #512]	; (800e388 <ADC_CalibrationAll+0x214>)
 800e188:	67bb      	str	r3, [r7, #120]	; 0x78
	ADC3_handle.Instance = ADC3;
 800e18a:	4b80      	ldr	r3, [pc, #512]	; (800e38c <ADC_CalibrationAll+0x218>)
 800e18c:	637b      	str	r3, [r7, #52]	; 0x34
	#if 1
	ADC_Calibration(&ADC1_handle,&Global_User_ADC);
 800e18e:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
 800e192:	4618      	mov	r0, r3
 800e194:	497a      	ldr	r1, [pc, #488]	; (800e380 <ADC_CalibrationAll+0x20c>)
 800e196:	f7ff fb37 	bl	800d808 <ADC_Calibration>
	ADC_Calibration(&ADC2_handle,&Global_User_ADC);
 800e19a:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800e19e:	4618      	mov	r0, r3
 800e1a0:	4977      	ldr	r1, [pc, #476]	; (800e380 <ADC_CalibrationAll+0x20c>)
 800e1a2:	f7ff fb31 	bl	800d808 <ADC_Calibration>
	ADC_Calibration(&ADC3_handle,&Global_User_ADC);
 800e1a6:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800e1aa:	4618      	mov	r0, r3
 800e1ac:	4974      	ldr	r1, [pc, #464]	; (800e380 <ADC_CalibrationAll+0x20c>)
 800e1ae:	f7ff fb2b 	bl	800d808 <ADC_Calibration>
	#endif
	
	ADCConfigInjected.AutoInjectedConv = DISABLE;
 800e1b2:	2300      	movs	r3, #0
 800e1b4:	627b      	str	r3, [r7, #36]	; 0x24
	ADCConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T8_TRGO2;
 800e1b6:	f44f 2320 	mov.w	r3, #655360	; 0xa0000
 800e1ba:	633b      	str	r3, [r7, #48]	; 0x30
	ADCConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING;
 800e1bc:	f44f 1340 	mov.w	r3, #3145728	; 0x300000
 800e1c0:	62fb      	str	r3, [r7, #44]	; 0x2c
	ADCConfigInjected.InjectedChannel = PHASE_C1_CURRENT_CHANNEL;
 800e1c2:	2306      	movs	r3, #6
 800e1c4:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 800e1c6:	2300      	movs	r3, #0
 800e1c8:	62bb      	str	r3, [r7, #40]	; 0x28
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e1ca:	2304      	movs	r3, #4
 800e1cc:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 800e1ce:	2301      	movs	r3, #1
 800e1d0:	617b      	str	r3, [r7, #20]
	ADCConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_28CYCLES;
 800e1d2:	2302      	movs	r3, #2
 800e1d4:	61bb      	str	r3, [r7, #24]
	#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI1_offset>>4;
	#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI1_offset;
	ADCConfigInjected.InjectedOffset = 0;
 800e1d6:	2300      	movs	r3, #0
 800e1d8:	61fb      	str	r3, [r7, #28]
	#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 800e1da:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 800e1de:	f107 0310 	add.w	r3, r7, #16
 800e1e2:	4610      	mov	r0, r2
 800e1e4:	4619      	mov	r1, r3
 800e1e6:	f7f3 ff77 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_C2_CURRENT_CHANNEL;
 800e1ea:	2309      	movs	r3, #9
 800e1ec:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e1ee:	2304      	movs	r3, #4
 800e1f0:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 800e1f2:	2302      	movs	r3, #2
 800e1f4:	617b      	str	r3, [r7, #20]
	
	#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI2_offset>>4;
	#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI2_offset;
	ADCConfigInjected.InjectedOffset = 0;
 800e1f6:	2300      	movs	r3, #0
 800e1f8:	61fb      	str	r3, [r7, #28]
	#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 800e1fa:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 800e1fe:	f107 0310 	add.w	r3, r7, #16
 800e202:	4610      	mov	r0, r2
 800e204:	4619      	mov	r1, r3
 800e206:	f7f3 ff67 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_C_VOLTAGE_CHANNEL;
 800e20a:	2305      	movs	r3, #5
 800e20c:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e20e:	2304      	movs	r3, #4
 800e210:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 800e212:	2303      	movs	r3, #3
 800e214:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qV_offset;
	ADCConfigInjected.InjectedOffset = 0;
 800e216:	2300      	movs	r3, #0
 800e218:	61fb      	str	r3, [r7, #28]

#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 800e21a:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 800e21e:	f107 0310 	add.w	r3, r7, #16
 800e222:	4610      	mov	r0, r2
 800e224:	4619      	mov	r1, r3
 800e226:	f7f3 ff57 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_TEMP_CHANNEL;
 800e22a:	2308      	movs	r3, #8
 800e22c:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e22e:	2304      	movs	r3, #4
 800e230:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 800e232:	2304      	movs	r3, #4
 800e234:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.Temp.TEMP_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.Temp.TEMP_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e236:	2300      	movs	r3, #0
 800e238:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 800e23a:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 800e23e:	f107 0310 	add.w	r3, r7, #16
 800e242:	4610      	mov	r0, r2
 800e244:	4619      	mov	r1, r3
 800e246:	f7f3 ff47 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>
	
	
	ADCConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_NONE;
 800e24a:	2300      	movs	r3, #0
 800e24c:	62fb      	str	r3, [r7, #44]	; 0x2c
	ADCConfigInjected.InjectedChannel = PHASE_B1_CURRENT_CHANNEL;
 800e24e:	2303      	movs	r3, #3
 800e250:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e252:	2304      	movs	r3, #4
 800e254:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 800e256:	2301      	movs	r3, #1
 800e258:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI1_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI1_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e25a:	2300      	movs	r3, #0
 800e25c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 800e25e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 800e262:	f107 0310 	add.w	r3, r7, #16
 800e266:	4610      	mov	r0, r2
 800e268:	4619      	mov	r1, r3
 800e26a:	f7f3 ff35 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_B2_CURRENT_CHANNEL;
 800e26e:	230c      	movs	r3, #12
 800e270:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e272:	2304      	movs	r3, #4
 800e274:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 800e276:	2302      	movs	r3, #2
 800e278:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI2_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI2_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e27a:	2300      	movs	r3, #0
 800e27c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 800e27e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 800e282:	f107 0310 	add.w	r3, r7, #16
 800e286:	4610      	mov	r0, r2
 800e288:	4619      	mov	r1, r3
 800e28a:	f7f3 ff25 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_B_VOLTAGE_CHANNEL;
 800e28e:	2304      	movs	r3, #4
 800e290:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e292:	2304      	movs	r3, #4
 800e294:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 800e296:	2303      	movs	r3, #3
 800e298:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e29a:	2300      	movs	r3, #0
 800e29c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 800e29e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 800e2a2:	f107 0310 	add.w	r3, r7, #16
 800e2a6:	4610      	mov	r0, r2
 800e2a8:	4619      	mov	r1, r3
 800e2aa:	f7f3 ff15 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>
	
	ADCConfigInjected.InjectedChannel = PHASE_BUS_CURRENT_CHANNEL;
 800e2ae:	230a      	movs	r3, #10
 800e2b0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e2b2:	2304      	movs	r3, #4
 800e2b4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 800e2b6:	2304      	movs	r3, #4
 800e2b8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qI_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qI_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e2ba:	2300      	movs	r3, #0
 800e2bc:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 800e2be:	f107 0278 	add.w	r2, r7, #120	; 0x78
 800e2c2:	f107 0310 	add.w	r3, r7, #16
 800e2c6:	4610      	mov	r0, r2
 800e2c8:	4619      	mov	r1, r3
 800e2ca:	f7f3 ff05 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A1_CURRENT_CHANNEL;
 800e2ce:	2305      	movs	r3, #5
 800e2d0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e2d2:	2304      	movs	r3, #4
 800e2d4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 800e2d6:	2301      	movs	r3, #1
 800e2d8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI1_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI1_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e2da:	2300      	movs	r3, #0
 800e2dc:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 800e2de:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800e2e2:	f107 0310 	add.w	r3, r7, #16
 800e2e6:	4610      	mov	r0, r2
 800e2e8:	4619      	mov	r1, r3
 800e2ea:	f7f3 fef5 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A2_CURRENT_CHANNEL;
 800e2ee:	2306      	movs	r3, #6
 800e2f0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e2f2:	2304      	movs	r3, #4
 800e2f4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 800e2f6:	2302      	movs	r3, #2
 800e2f8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI2_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI2_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e2fa:	2300      	movs	r3, #0
 800e2fc:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 800e2fe:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800e302:	f107 0310 	add.w	r3, r7, #16
 800e306:	4610      	mov	r0, r2
 800e308:	4619      	mov	r1, r3
 800e30a:	f7f3 fee5 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A_VOLTAGE_CHANNEL;
 800e30e:	2307      	movs	r3, #7
 800e310:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e312:	2304      	movs	r3, #4
 800e314:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 800e316:	2303      	movs	r3, #3
 800e318:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e31a:	2300      	movs	r3, #0
 800e31c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 800e31e:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800e322:	f107 0310 	add.w	r3, r7, #16
 800e326:	4610      	mov	r0, r2
 800e328:	4619      	mov	r1, r3
 800e32a:	f7f3 fed5 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>
	
	ADCConfigInjected.InjectedChannel = PHASE_BUS_VOLTAGE_CHANNEL;
 800e32e:	2304      	movs	r3, #4
 800e330:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 800e332:	2304      	movs	r3, #4
 800e334:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 800e336:	2304      	movs	r3, #4
 800e338:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 800e33a:	2300      	movs	r3, #0
 800e33c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 800e33e:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800e342:	f107 0310 	add.w	r3, r7, #16
 800e346:	4610      	mov	r0, r2
 800e348:	4619      	mov	r1, r3
 800e34a:	f7f3 fec5 	bl	80020d8 <HAL_ADCEx_InjectedConfigChannel>

	ADCMultiMode.DMAAccessMode = ADC_DMAACCESSMODE_DISABLED;
 800e34e:	2300      	movs	r3, #0
 800e350:	60bb      	str	r3, [r7, #8]
	ADCMultiMode.Mode = ADC_TRIPLEMODE_INJECSIMULT;
 800e352:	2315      	movs	r3, #21
 800e354:	607b      	str	r3, [r7, #4]
	ADCMultiMode.TwoSamplingDelay = ADC_TWOSAMPLINGDELAY_5CYCLES;
 800e356:	2300      	movs	r3, #0
 800e358:	60fb      	str	r3, [r7, #12]
	HAL_ADCEx_MultiModeConfigChannel(&ADC1_handle, &ADCMultiMode);
 800e35a:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 800e35e:	1d3b      	adds	r3, r7, #4
 800e360:	4610      	mov	r0, r2
 800e362:	4619      	mov	r1, r3
 800e364:	f7f4 f82c 	bl	80023c0 <HAL_ADCEx_MultiModeConfigChannel>
	HAL_NVIC_EnableIRQ(ADC_IRQn);
 800e368:	2012      	movs	r0, #18
 800e36a:	f7f5 f959 	bl	8003620 <HAL_NVIC_EnableIRQ>
	HAL_ADCEx_InjectedStart_IT(&ADC1_handle);
 800e36e:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
 800e372:	4618      	mov	r0, r3
 800e374:	f7f3 fd92 	bl	8001e9c <HAL_ADCEx_InjectedStart_IT>
}
 800e378:	f507 7780 	add.w	r7, r7, #256	; 0x100
 800e37c:	46bd      	mov	sp, r7
 800e37e:	bd80      	pop	{r7, pc}
 800e380:	2001235c 	.word	0x2001235c
 800e384:	40012000 	.word	0x40012000
 800e388:	40012100 	.word	0x40012100
 800e38c:	40012200 	.word	0x40012200

0800e390 <HAL_ADC_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
	void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
{
 800e390:	b480      	push	{r7}
 800e392:	b083      	sub	sp, #12
 800e394:	af00      	add	r7, sp, #0
 800e396:	6078      	str	r0, [r7, #4]
   
}
 800e398:	370c      	adds	r7, #12
 800e39a:	46bd      	mov	sp, r7
 800e39c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e3a0:	4770      	bx	lr
 800e3a2:	bf00      	nop

0800e3a4 <stm32_hw_ADC_init>:

extern int stm32_hw_ADC_init(void)
{
 800e3a4:	b580      	push	{r7, lr}
 800e3a6:	b0b4      	sub	sp, #208	; 0xd0
 800e3a8:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC1_handle,ADC2_handle,ADC3_handle;

	QIEMW_ADC_init(&Global_User_ADC);
 800e3aa:	483e      	ldr	r0, [pc, #248]	; (800e4a4 <stm32_hw_ADC_init+0x100>)
 800e3ac:	f7ff f9ba 	bl	800d724 <QIEMW_ADC_init>
	ADC1_handle.Instance = ADC1;
 800e3b0:	4b3d      	ldr	r3, [pc, #244]	; (800e4a8 <stm32_hw_ADC_init+0x104>)
 800e3b2:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	HAL_ADC_DeInit(&ADC1_handle);
 800e3b6:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 800e3ba:	4618      	mov	r0, r3
 800e3bc:	f7f3 f93c 	bl	8001638 <HAL_ADC_DeInit>
	ADC1_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 800e3c0:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800e3c4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
	ADC1_handle.Init.ContinuousConvMode = DISABLE;
 800e3c8:	2300      	movs	r3, #0
 800e3ca:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
	#ifdef DATAALIGN_LEFT
	ADC1_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
	#else
	ADC1_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800e3ce:	2300      	movs	r3, #0
 800e3d0:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
	#endif
	#if 1
	ADC1_handle.Init.DiscontinuousConvMode = DISABLE;
 800e3d4:	2300      	movs	r3, #0
 800e3d6:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
	ADC1_handle.Init.DMAContinuousRequests = DISABLE;
 800e3da:	2300      	movs	r3, #0
 800e3dc:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	ADC1_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 800e3e0:	2300      	movs	r3, #0
 800e3e2:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
	ADC1_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 800e3e6:	4b31      	ldr	r3, [pc, #196]	; (800e4ac <stm32_hw_ADC_init+0x108>)
 800e3e8:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
	ADC1_handle.Init.NbrOfConversion = 1;
 800e3ec:	2301      	movs	r3, #1
 800e3ee:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	ADC1_handle.Init.NbrOfDiscConversion = 0;
 800e3f2:	2300      	movs	r3, #0
 800e3f4:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
	#endif
	ADC1_handle.Init.Resolution = ADC_RESOLUTION_12B;
 800e3f8:	2300      	movs	r3, #0
 800e3fa:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
	ADC1_handle.Init.ScanConvMode = ENABLE;
 800e3fe:	2301      	movs	r3, #1
 800e400:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
	HAL_ADC_Init(&ADC1_handle);
 800e404:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 800e408:	4618      	mov	r0, r3
 800e40a:	f7f3 f8e7 	bl	80015dc <HAL_ADC_Init>
	
	ADC2_handle.Instance = ADC2;
 800e40e:	4b28      	ldr	r3, [pc, #160]	; (800e4b0 <stm32_hw_ADC_init+0x10c>)
 800e410:	64bb      	str	r3, [r7, #72]	; 0x48
	HAL_ADC_DeInit(&ADC2_handle);
 800e412:	f107 0348 	add.w	r3, r7, #72	; 0x48
 800e416:	4618      	mov	r0, r3
 800e418:	f7f3 f90e 	bl	8001638 <HAL_ADC_DeInit>

	
	ADC2_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 800e41c:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800e420:	64fb      	str	r3, [r7, #76]	; 0x4c
	ADC2_handle.Init.ContinuousConvMode = DISABLE;
 800e422:	2300      	movs	r3, #0
 800e424:	663b      	str	r3, [r7, #96]	; 0x60
	
#ifdef DATAALIGN_LEFT
	ADC2_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
#else
	ADC2_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800e426:	2300      	movs	r3, #0
 800e428:	657b      	str	r3, [r7, #84]	; 0x54
#endif
#if 1
	ADC2_handle.Init.DiscontinuousConvMode = DISABLE;
 800e42a:	2300      	movs	r3, #0
 800e42c:	66fb      	str	r3, [r7, #108]	; 0x6c
	ADC2_handle.Init.DMAContinuousRequests = DISABLE;
 800e42e:	2300      	movs	r3, #0
 800e430:	667b      	str	r3, [r7, #100]	; 0x64
	ADC2_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 800e432:	2300      	movs	r3, #0
 800e434:	65fb      	str	r3, [r7, #92]	; 0x5c
	ADC2_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 800e436:	4b1d      	ldr	r3, [pc, #116]	; (800e4ac <stm32_hw_ADC_init+0x108>)
 800e438:	677b      	str	r3, [r7, #116]	; 0x74
	ADC2_handle.Init.NbrOfConversion = 1;
 800e43a:	2301      	movs	r3, #1
 800e43c:	66bb      	str	r3, [r7, #104]	; 0x68
	ADC2_handle.Init.NbrOfDiscConversion = 0;
 800e43e:	2300      	movs	r3, #0
 800e440:	673b      	str	r3, [r7, #112]	; 0x70
	#endif
	ADC2_handle.Init.Resolution = ADC_RESOLUTION_12B;
 800e442:	2300      	movs	r3, #0
 800e444:	653b      	str	r3, [r7, #80]	; 0x50
	ADC2_handle.Init.ScanConvMode = ENABLE;
 800e446:	2301      	movs	r3, #1
 800e448:	65bb      	str	r3, [r7, #88]	; 0x58
	HAL_ADC_Init(&ADC2_handle);
 800e44a:	f107 0348 	add.w	r3, r7, #72	; 0x48
 800e44e:	4618      	mov	r0, r3
 800e450:	f7f3 f8c4 	bl	80015dc <HAL_ADC_Init>
	
	ADC3_handle.Instance = ADC3;
 800e454:	4b17      	ldr	r3, [pc, #92]	; (800e4b4 <stm32_hw_ADC_init+0x110>)
 800e456:	607b      	str	r3, [r7, #4]
	HAL_ADC_DeInit(&ADC3_handle);
 800e458:	1d3b      	adds	r3, r7, #4
 800e45a:	4618      	mov	r0, r3
 800e45c:	f7f3 f8ec 	bl	8001638 <HAL_ADC_DeInit>
	ADC3_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 800e460:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800e464:	60bb      	str	r3, [r7, #8]
	ADC3_handle.Init.ContinuousConvMode = DISABLE;
 800e466:	2300      	movs	r3, #0
 800e468:	61fb      	str	r3, [r7, #28]
	
#ifdef DATAALIGN_LEFT
	ADC3_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
#else
	ADC3_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800e46a:	2300      	movs	r3, #0
 800e46c:	613b      	str	r3, [r7, #16]
#endif
#if 1
	ADC3_handle.Init.DiscontinuousConvMode = DISABLE;
 800e46e:	2300      	movs	r3, #0
 800e470:	62bb      	str	r3, [r7, #40]	; 0x28
	ADC3_handle.Init.DMAContinuousRequests = DISABLE;
 800e472:	2300      	movs	r3, #0
 800e474:	623b      	str	r3, [r7, #32]
	ADC3_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 800e476:	2300      	movs	r3, #0
 800e478:	61bb      	str	r3, [r7, #24]
	ADC3_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 800e47a:	4b0c      	ldr	r3, [pc, #48]	; (800e4ac <stm32_hw_ADC_init+0x108>)
 800e47c:	633b      	str	r3, [r7, #48]	; 0x30
	ADC3_handle.Init.NbrOfConversion = 1;
 800e47e:	2301      	movs	r3, #1
 800e480:	627b      	str	r3, [r7, #36]	; 0x24
	ADC3_handle.Init.NbrOfDiscConversion = 0;
 800e482:	2300      	movs	r3, #0
 800e484:	62fb      	str	r3, [r7, #44]	; 0x2c
	#endif
	ADC3_handle.Init.Resolution = ADC_RESOLUTION_12B;
 800e486:	2300      	movs	r3, #0
 800e488:	60fb      	str	r3, [r7, #12]
	ADC3_handle.Init.ScanConvMode = ENABLE;
 800e48a:	2301      	movs	r3, #1
 800e48c:	617b      	str	r3, [r7, #20]
	HAL_ADC_Init(&ADC3_handle);
 800e48e:	1d3b      	adds	r3, r7, #4
 800e490:	4618      	mov	r0, r3
 800e492:	f7f3 f8a3 	bl	80015dc <HAL_ADC_Init>

	ADC_CalibrationAll();
 800e496:	f7ff fe6d 	bl	800e174 <ADC_CalibrationAll>
}
 800e49a:	4618      	mov	r0, r3
 800e49c:	37d0      	adds	r7, #208	; 0xd0
 800e49e:	46bd      	mov	sp, r7
 800e4a0:	bd80      	pop	{r7, pc}
 800e4a2:	bf00      	nop
 800e4a4:	2001235c 	.word	0x2001235c
 800e4a8:	40012000 	.word	0x40012000
 800e4ac:	0f000001 	.word	0x0f000001
 800e4b0:	40012100 	.word	0x40012100
 800e4b4:	40012200 	.word	0x40012200

0800e4b8 <HAL_TIM_PeriodElapsedCallback>:


#elif defined(TIMER5_HANDLES_ENCODER)

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 800e4b8:	b480      	push	{r7}
 800e4ba:	b083      	sub	sp, #12
 800e4bc:	af00      	add	r7, sp, #0
 800e4be:	6078      	str	r0, [r7, #4]
	if (hEncoder_Timer_Overflow != U16_MAX)	
 800e4c0:	4b09      	ldr	r3, [pc, #36]	; (800e4e8 <HAL_TIM_PeriodElapsedCallback+0x30>)
 800e4c2:	881b      	ldrh	r3, [r3, #0]
 800e4c4:	b29b      	uxth	r3, r3
 800e4c6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800e4ca:	4293      	cmp	r3, r2
 800e4cc:	d006      	beq.n	800e4dc <HAL_TIM_PeriodElapsedCallback+0x24>
	{
	   hEncoder_Timer_Overflow++;
 800e4ce:	4b06      	ldr	r3, [pc, #24]	; (800e4e8 <HAL_TIM_PeriodElapsedCallback+0x30>)
 800e4d0:	881b      	ldrh	r3, [r3, #0]
 800e4d2:	b29b      	uxth	r3, r3
 800e4d4:	3301      	adds	r3, #1
 800e4d6:	b29a      	uxth	r2, r3
 800e4d8:	4b03      	ldr	r3, [pc, #12]	; (800e4e8 <HAL_TIM_PeriodElapsedCallback+0x30>)
 800e4da:	801a      	strh	r2, [r3, #0]
	}
}
 800e4dc:	370c      	adds	r7, #12
 800e4de:	46bd      	mov	sp, r7
 800e4e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e4e4:	4770      	bx	lr
 800e4e6:	bf00      	nop
 800e4e8:	200107fa 	.word	0x200107fa

0800e4ec <TIM5_IRQHandler>:

void TIM5_IRQHandler(void)
{
 800e4ec:	b580      	push	{r7, lr}
 800e4ee:	b090      	sub	sp, #64	; 0x40
 800e4f0:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef htim; 
	
	rt_interrupt_enter();
 800e4f2:	f004 fdad 	bl	8013050 <rt_interrupt_enter>
	htim.Instance = TIM5;
 800e4f6:	4b05      	ldr	r3, [pc, #20]	; (800e50c <TIM5_IRQHandler+0x20>)
 800e4f8:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&htim);
 800e4fa:	1d3b      	adds	r3, r7, #4
 800e4fc:	4618      	mov	r0, r3
 800e4fe:	f7fb f83b 	bl	8009578 <HAL_TIM_IRQHandler>
	rt_interrupt_leave();
 800e502:	f004 fdbb 	bl	801307c <rt_interrupt_leave>
}
 800e506:	3740      	adds	r7, #64	; 0x40
 800e508:	46bd      	mov	sp, r7
 800e50a:	bd80      	pop	{r7, pc}
 800e50c:	40000c00 	.word	0x40000c00

0800e510 <GetCounterValue>:




extern u16 GetCounterValue(TIM_TypeDef *TIMx)
{
 800e510:	b480      	push	{r7}
 800e512:	b083      	sub	sp, #12
 800e514:	af00      	add	r7, sp, #0
 800e516:	6078      	str	r0, [r7, #4]
	return(TIMx->CNT);
 800e518:	687b      	ldr	r3, [r7, #4]
 800e51a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e51c:	b29b      	uxth	r3, r3
}
 800e51e:	4618      	mov	r0, r3
 800e520:	370c      	adds	r7, #12
 800e522:	46bd      	mov	sp, r7
 800e524:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e528:	4770      	bx	lr
 800e52a:	bf00      	nop

0800e52c <IsCounterUp>:

extern bool IsCounterUp(TIM_TypeDef *TIMx)
{
 800e52c:	b480      	push	{r7}
 800e52e:	b083      	sub	sp, #12
 800e530:	af00      	add	r7, sp, #0
 800e532:	6078      	str	r0, [r7, #4]
 	return((ENCODER_TIMER->CR1 & TIM_COUNTERMODE_UP) == TIM_COUNTERMODE_UP);
 800e534:	4b04      	ldr	r3, [pc, #16]	; (800e548 <IsCounterUp+0x1c>)
 800e536:	681b      	ldr	r3, [r3, #0]
 800e538:	2301      	movs	r3, #1
}
 800e53a:	4618      	mov	r0, r3
 800e53c:	370c      	adds	r7, #12
 800e53e:	46bd      	mov	sp, r7
 800e540:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e544:	4770      	bx	lr
 800e546:	bf00      	nop
 800e548:	40000c00 	.word	0x40000c00

0800e54c <HAL_TIM_Encoder_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
{
 800e54c:	b580      	push	{r7, lr}
 800e54e:	b08a      	sub	sp, #40	; 0x28
 800e550:	af00      	add	r7, sp, #0
 800e552:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_Init;

    /* Enable GPIO clock */
	TIM5_GPIOH_CLK_ENABLE();
 800e554:	4a19      	ldr	r2, [pc, #100]	; (800e5bc <HAL_TIM_Encoder_MspInit+0x70>)
 800e556:	4b19      	ldr	r3, [pc, #100]	; (800e5bc <HAL_TIM_Encoder_MspInit+0x70>)
 800e558:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e55a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e55e:	6313      	str	r3, [r2, #48]	; 0x30
 800e560:	4b16      	ldr	r3, [pc, #88]	; (800e5bc <HAL_TIM_Encoder_MspInit+0x70>)
 800e562:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e564:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e568:	613b      	str	r3, [r7, #16]
 800e56a:	693b      	ldr	r3, [r7, #16]
    /* Enable TIMx clock */
    TIM5_CLK_ENABLE();
 800e56c:	4a13      	ldr	r2, [pc, #76]	; (800e5bc <HAL_TIM_Encoder_MspInit+0x70>)
 800e56e:	4b13      	ldr	r3, [pc, #76]	; (800e5bc <HAL_TIM_Encoder_MspInit+0x70>)
 800e570:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e572:	f043 0308 	orr.w	r3, r3, #8
 800e576:	6413      	str	r3, [r2, #64]	; 0x40
 800e578:	4b10      	ldr	r3, [pc, #64]	; (800e5bc <HAL_TIM_Encoder_MspInit+0x70>)
 800e57a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e57c:	f003 0308 	and.w	r3, r3, #8
 800e580:	60fb      	str	r3, [r7, #12]
 800e582:	68fb      	ldr	r3, [r7, #12]

    /* GPIO pin configuration  */
 	GPIO_Init.Pin = QEP1_PIN;
 800e584:	2301      	movs	r3, #1
 800e586:	617b      	str	r3, [r7, #20]
	GPIO_Init.Mode = GPIO_MODE_AF_PP;
 800e588:	2302      	movs	r3, #2
 800e58a:	61bb      	str	r3, [r7, #24]
	GPIO_Init.Pull = GPIO_PULLUP;
 800e58c:	2301      	movs	r3, #1
 800e58e:	61fb      	str	r3, [r7, #28]
	GPIO_Init.Speed = GPIO_SPEED_HIGH;
 800e590:	2303      	movs	r3, #3
 800e592:	623b      	str	r3, [r7, #32]
	GPIO_Init.Alternate = QEP1_AF;
 800e594:	2302      	movs	r3, #2
 800e596:	627b      	str	r3, [r7, #36]	; 0x24
	HAL_GPIO_Init(QEP1_GPIO_PORT,&GPIO_Init);
 800e598:	f107 0314 	add.w	r3, r7, #20
 800e59c:	4808      	ldr	r0, [pc, #32]	; (800e5c0 <HAL_TIM_Encoder_MspInit+0x74>)
 800e59e:	4619      	mov	r1, r3
 800e5a0:	f7f9 fd06 	bl	8007fb0 <HAL_GPIO_Init>

	GPIO_Init.Pin = QEP2_PIN;
 800e5a4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800e5a8:	617b      	str	r3, [r7, #20]
	HAL_GPIO_Init(QEP2_GPIO_PORT,&GPIO_Init);
 800e5aa:	f107 0314 	add.w	r3, r7, #20
 800e5ae:	4805      	ldr	r0, [pc, #20]	; (800e5c4 <HAL_TIM_Encoder_MspInit+0x78>)
 800e5b0:	4619      	mov	r1, r3
 800e5b2:	f7f9 fcfd 	bl	8007fb0 <HAL_GPIO_Init>
}
 800e5b6:	3728      	adds	r7, #40	; 0x28
 800e5b8:	46bd      	mov	sp, r7
 800e5ba:	bd80      	pop	{r7, pc}
 800e5bc:	40023800 	.word	0x40023800
 800e5c0:	40020000 	.word	0x40020000
 800e5c4:	40021c00 	.word	0x40021c00

0800e5c8 <HAL_TIM_Encoder_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
{
 800e5c8:	b580      	push	{r7, lr}
 800e5ca:	b082      	sub	sp, #8
 800e5cc:	af00      	add	r7, sp, #0
 800e5ce:	6078      	str	r0, [r7, #4]
    /* Reset peripherals */
    TIM5_FORCE_RESET();
 800e5d0:	4a0f      	ldr	r2, [pc, #60]	; (800e610 <HAL_TIM_Encoder_MspDeInit+0x48>)
 800e5d2:	4b0f      	ldr	r3, [pc, #60]	; (800e610 <HAL_TIM_Encoder_MspDeInit+0x48>)
 800e5d4:	6a1b      	ldr	r3, [r3, #32]
 800e5d6:	f043 0308 	orr.w	r3, r3, #8
 800e5da:	6213      	str	r3, [r2, #32]
    TIM5_RELEASE_RESET();
 800e5dc:	4a0c      	ldr	r2, [pc, #48]	; (800e610 <HAL_TIM_Encoder_MspDeInit+0x48>)
 800e5de:	4b0c      	ldr	r3, [pc, #48]	; (800e610 <HAL_TIM_Encoder_MspDeInit+0x48>)
 800e5e0:	6a1b      	ldr	r3, [r3, #32]
 800e5e2:	f023 0308 	bic.w	r3, r3, #8
 800e5e6:	6213      	str	r3, [r2, #32]

    /* Disable peripherals and GPIO Clocks */
    HAL_GPIO_DeInit(QEP1_GPIO_PORT, QEP1_PIN);
 800e5e8:	480a      	ldr	r0, [pc, #40]	; (800e614 <HAL_TIM_Encoder_MspDeInit+0x4c>)
 800e5ea:	2101      	movs	r1, #1
 800e5ec:	f7f9 fe86 	bl	80082fc <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(QEP2_GPIO_PORT, QEP2_PIN);
 800e5f0:	4809      	ldr	r0, [pc, #36]	; (800e618 <HAL_TIM_Encoder_MspDeInit+0x50>)
 800e5f2:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800e5f6:	f7f9 fe81 	bl	80082fc <HAL_GPIO_DeInit>
	
	HAL_NVIC_SetPriority(TIM5_IRQn, TIM5_IRQ_PREEMPT,TIM5_IRQ_SUB);
 800e5fa:	2032      	movs	r0, #50	; 0x32
 800e5fc:	2101      	movs	r1, #1
 800e5fe:	2200      	movs	r2, #0
 800e600:	f7f4 fff2 	bl	80035e8 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(TIM5_IRQn);
 800e604:	2032      	movs	r0, #50	; 0x32
 800e606:	f7f5 f80b 	bl	8003620 <HAL_NVIC_EnableIRQ>
}
 800e60a:	3708      	adds	r7, #8
 800e60c:	46bd      	mov	sp, r7
 800e60e:	bd80      	pop	{r7, pc}
 800e610:	40023800 	.word	0x40023800
 800e614:	40020000 	.word	0x40020000
 800e618:	40021c00 	.word	0x40021c00

0800e61c <stm32_hw_QEP_init>:


#define POLENUM (5)
extern int stm32_hw_QEP_init(void)
{
 800e61c:	b580      	push	{r7, lr}
 800e61e:	b09a      	sub	sp, #104	; 0x68
 800e620:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef htim;  
	TIM_Encoder_InitTypeDef sConfig;
	
	htim.Instance = TIM5;
 800e622:	4b2e      	ldr	r3, [pc, #184]	; (800e6dc <stm32_hw_QEP_init+0xc0>)
 800e624:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_TIM_Base_DeInit(&htim);
 800e626:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e62a:	4618      	mov	r0, r3
 800e62c:	f7fa fda4 	bl	8009178 <HAL_TIM_Base_DeInit>
	HAL_TIM_Encoder_DeInit(&htim);
 800e630:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e634:	4618      	mov	r0, r3
 800e636:	f7fa ff37 	bl	80094a8 <HAL_TIM_Encoder_DeInit>
    TIM5_CLK_ENABLE();
 800e63a:	4a29      	ldr	r2, [pc, #164]	; (800e6e0 <stm32_hw_QEP_init+0xc4>)
 800e63c:	4b28      	ldr	r3, [pc, #160]	; (800e6e0 <stm32_hw_QEP_init+0xc4>)
 800e63e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e640:	f043 0308 	orr.w	r3, r3, #8
 800e644:	6413      	str	r3, [r2, #64]	; 0x40
 800e646:	4b26      	ldr	r3, [pc, #152]	; (800e6e0 <stm32_hw_QEP_init+0xc4>)
 800e648:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e64a:	f003 0308 	and.w	r3, r3, #8
 800e64e:	607b      	str	r3, [r7, #4]
 800e650:	687b      	ldr	r3, [r7, #4]
	HAL_TIM_Encoder_MspInit(&htim);
 800e652:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e656:	4618      	mov	r0, r3
 800e658:	f7ff ff78 	bl	800e54c <HAL_TIM_Encoder_MspInit>
	#if 1
	htim.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800e65c:	2300      	movs	r3, #0
 800e65e:	63fb      	str	r3, [r7, #60]	; 0x3c
	htim.Init.CounterMode = TIM_COUNTERMODE_UP;
 800e660:	2300      	movs	r3, #0
 800e662:	637b      	str	r3, [r7, #52]	; 0x34
	htim.Init.Period = (POLENUM*(4*ENCODER_PPR))-1;
 800e664:	f644 73ff 	movw	r3, #20479	; 0x4fff
 800e668:	63bb      	str	r3, [r7, #56]	; 0x38
	htim.Init.Prescaler = 0x0;
 800e66a:	2300      	movs	r3, #0
 800e66c:	633b      	str	r3, [r7, #48]	; 0x30
	HAL_TIM_IC_Init(&htim);	
 800e66e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e672:	4618      	mov	r0, r3
 800e674:	f7fa fe4a 	bl	800930c <HAL_TIM_IC_Init>
	
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 800e678:	2303      	movs	r3, #3
 800e67a:	60bb      	str	r3, [r7, #8]
	sConfig.IC1Filter = ICx_FILTER;
 800e67c:	2308      	movs	r3, #8
 800e67e:	61bb      	str	r3, [r7, #24]
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
 800e680:	2300      	movs	r3, #0
 800e682:	60fb      	str	r3, [r7, #12]
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
 800e684:	2300      	movs	r3, #0
 800e686:	617b      	str	r3, [r7, #20]
	sConfig.IC1Selection = TIM_CCMR1_CC1S_0;//????
 800e688:	2301      	movs	r3, #1
 800e68a:	613b      	str	r3, [r7, #16]
	sConfig.IC2Filter = ICx_FILTER;
 800e68c:	2308      	movs	r3, #8
 800e68e:	62bb      	str	r3, [r7, #40]	; 0x28
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
 800e690:	2300      	movs	r3, #0
 800e692:	61fb      	str	r3, [r7, #28]
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
 800e694:	2300      	movs	r3, #0
 800e696:	627b      	str	r3, [r7, #36]	; 0x24
	sConfig.IC2Selection = TIM_CCMR1_CC1S_0;
 800e698:	2301      	movs	r3, #1
 800e69a:	623b      	str	r3, [r7, #32]
	HAL_TIM_Encoder_Init(&htim,  &sConfig);
 800e69c:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800e6a0:	f107 0308 	add.w	r3, r7, #8
 800e6a4:	4610      	mov	r0, r2
 800e6a6:	4619      	mov	r1, r3
 800e6a8:	f7fa fe66 	bl	8009378 <HAL_TIM_Encoder_Init>
	#endif
	__HAL_TIM_ENABLE_IT(&htim, TIM_IT_UPDATE);
 800e6ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e6ae:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800e6b0:	68d2      	ldr	r2, [r2, #12]
 800e6b2:	f042 0201 	orr.w	r2, r2, #1
 800e6b6:	60da      	str	r2, [r3, #12]
	
	HAL_TIM_Encoder_Start(&htim, TIM_CHANNEL_1);
 800e6b8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e6bc:	4618      	mov	r0, r3
 800e6be:	2100      	movs	r1, #0
 800e6c0:	f7fa ff22 	bl	8009508 <HAL_TIM_Encoder_Start>
	HAL_TIM_Encoder_Start(&htim, TIM_CHANNEL_2);
 800e6c4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e6c8:	4618      	mov	r0, r3
 800e6ca:	2104      	movs	r1, #4
 800e6cc:	f7fa ff1c 	bl	8009508 <HAL_TIM_Encoder_Start>
	
    return 0;
 800e6d0:	2300      	movs	r3, #0
}
 800e6d2:	4618      	mov	r0, r3
 800e6d4:	3768      	adds	r7, #104	; 0x68
 800e6d6:	46bd      	mov	sp, r7
 800e6d8:	bd80      	pop	{r7, pc}
 800e6da:	bf00      	nop
 800e6dc:	40000c00 	.word	0x40000c00
 800e6e0:	40023800 	.word	0x40023800

0800e6e4 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Disable(void)
{
 800e6e4:	b480      	push	{r7}
 800e6e6:	af00      	add	r7, sp, #0
  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800e6e8:	4a07      	ldr	r2, [pc, #28]	; (800e708 <HAL_MPU_Disable+0x24>)
 800e6ea:	4b07      	ldr	r3, [pc, #28]	; (800e708 <HAL_MPU_Disable+0x24>)
 800e6ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e6ee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800e6f2:	6253      	str	r3, [r2, #36]	; 0x24
  
  /* Disable the MPU */
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 800e6f4:	4a05      	ldr	r2, [pc, #20]	; (800e70c <HAL_MPU_Disable+0x28>)
 800e6f6:	4b05      	ldr	r3, [pc, #20]	; (800e70c <HAL_MPU_Disable+0x28>)
 800e6f8:	685b      	ldr	r3, [r3, #4]
 800e6fa:	f023 0301 	bic.w	r3, r3, #1
 800e6fe:	6053      	str	r3, [r2, #4]
}
 800e700:	46bd      	mov	sp, r7
 800e702:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e706:	4770      	bx	lr
 800e708:	e000ed00 	.word	0xe000ed00
 800e70c:	e000ed90 	.word	0xe000ed90

0800e710 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Enable(uint32_t MPU_Control)
{
 800e710:	b480      	push	{r7}
 800e712:	b083      	sub	sp, #12
 800e714:	af00      	add	r7, sp, #0
 800e716:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL   = MPU_Control | MPU_CTRL_ENABLE_Msk;
 800e718:	4a07      	ldr	r2, [pc, #28]	; (800e738 <HAL_MPU_Enable+0x28>)
 800e71a:	687b      	ldr	r3, [r7, #4]
 800e71c:	f043 0301 	orr.w	r3, r3, #1
 800e720:	6053      	str	r3, [r2, #4]
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 800e722:	4a06      	ldr	r2, [pc, #24]	; (800e73c <HAL_MPU_Enable+0x2c>)
 800e724:	4b05      	ldr	r3, [pc, #20]	; (800e73c <HAL_MPU_Enable+0x2c>)
 800e726:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e728:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800e72c:	6253      	str	r3, [r2, #36]	; 0x24
}
 800e72e:	370c      	adds	r7, #12
 800e730:	46bd      	mov	sp, r7
 800e732:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e736:	4770      	bx	lr
 800e738:	e000ed90 	.word	0xe000ed90
 800e73c:	e000ed00 	.word	0xe000ed00

0800e740 <mpu_init>:

#include "drv_mpu.h"


void mpu_init(void)
{
 800e740:	b580      	push	{r7, lr}
 800e742:	b084      	sub	sp, #16
 800e744:	af00      	add	r7, sp, #0
  MPU_Region_InitTypeDef MPU_InitStruct;
  
  /* Disable the MPU */
  HAL_MPU_Disable();
 800e746:	f7ff ffcd 	bl	800e6e4 <HAL_MPU_Disable>

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 800e74a:	2301      	movs	r3, #1
 800e74c:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0x20010000;
 800e74e:	4b29      	ldr	r3, [pc, #164]	; (800e7f4 <mpu_init+0xb4>)
 800e750:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 800e752:	2311      	movs	r3, #17
 800e754:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 800e756:	2303      	movs	r3, #3
 800e758:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 800e75a:	2300      	movs	r3, #0
 800e75c:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 800e75e:	2301      	movs	r3, #1
 800e760:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 800e762:	2300      	movs	r3, #0
 800e764:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 800e766:	2300      	movs	r3, #0
 800e768:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 800e76a:	2300      	movs	r3, #0
 800e76c:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 800e76e:	2300      	movs	r3, #0
 800e770:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 800e772:	2300      	movs	r3, #0
 800e774:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 800e776:	463b      	mov	r3, r7
 800e778:	4618      	mov	r0, r3
 800e77a:	f7f4 ff79 	bl	8003670 <HAL_MPU_ConfigRegion>

  /* Configure the MPU attributes as WB for SDRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 800e77e:	2301      	movs	r3, #1
 800e780:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0xC0000000;
 800e782:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 800e786:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_8MB;
 800e788:	2316      	movs	r3, #22
 800e78a:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 800e78c:	2303      	movs	r3, #3
 800e78e:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 800e790:	2301      	movs	r3, #1
 800e792:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 800e794:	2301      	movs	r3, #1
 800e796:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 800e798:	2300      	movs	r3, #0
 800e79a:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER1;
 800e79c:	2301      	movs	r3, #1
 800e79e:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 800e7a0:	2300      	movs	r3, #0
 800e7a2:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 800e7a4:	2300      	movs	r3, #0
 800e7a6:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 800e7a8:	2300      	movs	r3, #0
 800e7aa:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 800e7ac:	463b      	mov	r3, r7
 800e7ae:	4618      	mov	r0, r3
 800e7b0:	f7f4 ff5e 	bl	8003670 <HAL_MPU_ConfigRegion>

  /* Configure the MPU attributes as none-cache for 1MB SDRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 800e7b4:	2301      	movs	r3, #1
 800e7b6:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0xC0100000;
 800e7b8:	4b0f      	ldr	r3, [pc, #60]	; (800e7f8 <mpu_init+0xb8>)
 800e7ba:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_1MB;
 800e7bc:	2313      	movs	r3, #19
 800e7be:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 800e7c0:	2303      	movs	r3, #3
 800e7c2:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 800e7c4:	2300      	movs	r3, #0
 800e7c6:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 800e7c8:	2300      	movs	r3, #0
 800e7ca:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 800e7cc:	2300      	movs	r3, #0
 800e7ce:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER2;
 800e7d0:	2302      	movs	r3, #2
 800e7d2:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 800e7d4:	2300      	movs	r3, #0
 800e7d6:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 800e7d8:	2300      	movs	r3, #0
 800e7da:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 800e7dc:	2300      	movs	r3, #0
 800e7de:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 800e7e0:	463b      	mov	r3, r7
 800e7e2:	4618      	mov	r0, r3
 800e7e4:	f7f4 ff44 	bl	8003670 <HAL_MPU_ConfigRegion>
    
  /* Enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 800e7e8:	2004      	movs	r0, #4
 800e7ea:	f7ff ff91 	bl	800e710 <HAL_MPU_Enable>
}
 800e7ee:	3710      	adds	r7, #16
 800e7f0:	46bd      	mov	sp, r7
 800e7f2:	bd80      	pop	{r7, pc}
 800e7f4:	20010000 	.word	0x20010000
 800e7f8:	c0100000 	.word	0xc0100000

0800e7fc <SDRAM_MspInit>:
  * @param  hsdram: SDRAM handle
  * @param  Params
  * @retval None
  */
static void SDRAM_MspInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
{  
 800e7fc:	b580      	push	{r7, lr}
 800e7fe:	b090      	sub	sp, #64	; 0x40
 800e800:	af00      	add	r7, sp, #0
 800e802:	6078      	str	r0, [r7, #4]
 800e804:	6039      	str	r1, [r7, #0]
  static DMA_HandleTypeDef dma_handle;
  GPIO_InitTypeDef gpio_init_structure;
  
  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
 800e806:	4a6f      	ldr	r2, [pc, #444]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e808:	4b6e      	ldr	r3, [pc, #440]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e80a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e80c:	f043 0301 	orr.w	r3, r3, #1
 800e810:	6393      	str	r3, [r2, #56]	; 0x38
 800e812:	4b6c      	ldr	r3, [pc, #432]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e814:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e816:	f003 0301 	and.w	r3, r3, #1
 800e81a:	62bb      	str	r3, [r7, #40]	; 0x28
 800e81c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  
  /* Enable chosen DMAx clock */
  SDRAM_DMA_CLK_ENABLE();
 800e81e:	4a69      	ldr	r2, [pc, #420]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e820:	4b68      	ldr	r3, [pc, #416]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e822:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e824:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800e828:	6313      	str	r3, [r2, #48]	; 0x30
 800e82a:	4b66      	ldr	r3, [pc, #408]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e82c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e82e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800e832:	627b      	str	r3, [r7, #36]	; 0x24
 800e834:	6a7b      	ldr	r3, [r7, #36]	; 0x24

  /* Enable GPIOs clock */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800e836:	4a63      	ldr	r2, [pc, #396]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e838:	4b62      	ldr	r3, [pc, #392]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e83a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e83c:	f043 0304 	orr.w	r3, r3, #4
 800e840:	6313      	str	r3, [r2, #48]	; 0x30
 800e842:	4b60      	ldr	r3, [pc, #384]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e844:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e846:	f003 0304 	and.w	r3, r3, #4
 800e84a:	623b      	str	r3, [r7, #32]
 800e84c:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800e84e:	4a5d      	ldr	r2, [pc, #372]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e850:	4b5c      	ldr	r3, [pc, #368]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e852:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e854:	f043 0308 	orr.w	r3, r3, #8
 800e858:	6313      	str	r3, [r2, #48]	; 0x30
 800e85a:	4b5a      	ldr	r3, [pc, #360]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e85c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e85e:	f003 0308 	and.w	r3, r3, #8
 800e862:	61fb      	str	r3, [r7, #28]
 800e864:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800e866:	4a57      	ldr	r2, [pc, #348]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e868:	4b56      	ldr	r3, [pc, #344]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e86a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e86c:	f043 0310 	orr.w	r3, r3, #16
 800e870:	6313      	str	r3, [r2, #48]	; 0x30
 800e872:	4b54      	ldr	r3, [pc, #336]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e874:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e876:	f003 0310 	and.w	r3, r3, #16
 800e87a:	61bb      	str	r3, [r7, #24]
 800e87c:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800e87e:	4a51      	ldr	r2, [pc, #324]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e880:	4b50      	ldr	r3, [pc, #320]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e882:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e884:	f043 0320 	orr.w	r3, r3, #32
 800e888:	6313      	str	r3, [r2, #48]	; 0x30
 800e88a:	4b4e      	ldr	r3, [pc, #312]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e88c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e88e:	f003 0320 	and.w	r3, r3, #32
 800e892:	617b      	str	r3, [r7, #20]
 800e894:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800e896:	4a4b      	ldr	r2, [pc, #300]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e898:	4b4a      	ldr	r3, [pc, #296]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e89a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e89c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e8a0:	6313      	str	r3, [r2, #48]	; 0x30
 800e8a2:	4b48      	ldr	r3, [pc, #288]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e8a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e8a6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e8aa:	613b      	str	r3, [r7, #16]
 800e8ac:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800e8ae:	4a45      	ldr	r2, [pc, #276]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e8b0:	4b44      	ldr	r3, [pc, #272]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e8b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e8b4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e8b8:	6313      	str	r3, [r2, #48]	; 0x30
 800e8ba:	4b42      	ldr	r3, [pc, #264]	; (800e9c4 <SDRAM_MspInit+0x1c8>)
 800e8bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e8be:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e8c2:	60fb      	str	r3, [r7, #12]
 800e8c4:	68fb      	ldr	r3, [r7, #12]
  
  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 800e8c6:	2302      	movs	r3, #2
 800e8c8:	633b      	str	r3, [r7, #48]	; 0x30
  gpio_init_structure.Pull      = GPIO_PULLUP;
 800e8ca:	2301      	movs	r3, #1
 800e8cc:	637b      	str	r3, [r7, #52]	; 0x34
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
 800e8ce:	2302      	movs	r3, #2
 800e8d0:	63bb      	str	r3, [r7, #56]	; 0x38
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
 800e8d2:	230c      	movs	r3, #12
 800e8d4:	63fb      	str	r3, [r7, #60]	; 0x3c
  
  /* GPIOC configuration */
  gpio_init_structure.Pin   = GPIO_PIN_3;
 800e8d6:	2308      	movs	r3, #8
 800e8d8:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 800e8da:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e8de:	483a      	ldr	r0, [pc, #232]	; (800e9c8 <SDRAM_MspInit+0x1cc>)
 800e8e0:	4619      	mov	r1, r3
 800e8e2:	f7f9 fb65 	bl	8007fb0 <HAL_GPIO_Init>

  /* GPIOD configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_8 | GPIO_PIN_9 |
 800e8e6:	f24c 730b 	movw	r3, #50955	; 0xc70b
 800e8ea:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 800e8ec:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e8f0:	4836      	ldr	r0, [pc, #216]	; (800e9cc <SDRAM_MspInit+0x1d0>)
 800e8f2:	4619      	mov	r1, r3
 800e8f4:	f7f9 fb5c 	bl	8007fb0 <HAL_GPIO_Init>

  /* GPIOE configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
 800e8f8:	f64f 7383 	movw	r3, #65411	; 0xff83
 800e8fc:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 800e8fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e902:	4833      	ldr	r0, [pc, #204]	; (800e9d0 <SDRAM_MspInit+0x1d4>)
 800e904:	4619      	mov	r1, r3
 800e906:	f7f9 fb53 	bl	8007fb0 <HAL_GPIO_Init>
  
  /* GPIOF configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
 800e90a:	f64f 033f 	movw	r3, #63551	; 0xf83f
 800e90e:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 800e910:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e914:	482f      	ldr	r0, [pc, #188]	; (800e9d4 <SDRAM_MspInit+0x1d8>)
 800e916:	4619      	mov	r1, r3
 800e918:	f7f9 fb4a 	bl	8007fb0 <HAL_GPIO_Init>
  
  /* GPIOG configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
 800e91c:	f248 1333 	movw	r3, #33075	; 0x8133
 800e920:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 800e922:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e926:	482c      	ldr	r0, [pc, #176]	; (800e9d8 <SDRAM_MspInit+0x1dc>)
 800e928:	4619      	mov	r1, r3
 800e92a:	f7f9 fb41 	bl	8007fb0 <HAL_GPIO_Init>

  /* GPIOH configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
 800e92e:	2328      	movs	r3, #40	; 0x28
 800e930:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 800e932:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e936:	4829      	ldr	r0, [pc, #164]	; (800e9dc <SDRAM_MspInit+0x1e0>)
 800e938:	4619      	mov	r1, r3
 800e93a:	f7f9 fb39 	bl	8007fb0 <HAL_GPIO_Init>
  
  /* Configure common DMA parameters */
  dma_handle.Init.Channel             = SDRAM_DMA_CHANNEL;
 800e93e:	4b28      	ldr	r3, [pc, #160]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e940:	2200      	movs	r2, #0
 800e942:	605a      	str	r2, [r3, #4]
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 800e944:	4b26      	ldr	r3, [pc, #152]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e946:	2280      	movs	r2, #128	; 0x80
 800e948:	609a      	str	r2, [r3, #8]
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
 800e94a:	4b25      	ldr	r3, [pc, #148]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e94c:	f44f 7200 	mov.w	r2, #512	; 0x200
 800e950:	60da      	str	r2, [r3, #12]
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
 800e952:	4b23      	ldr	r3, [pc, #140]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e954:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800e958:	611a      	str	r2, [r3, #16]
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800e95a:	4b21      	ldr	r3, [pc, #132]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e95c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800e960:	615a      	str	r2, [r3, #20]
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 800e962:	4b1f      	ldr	r3, [pc, #124]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e964:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800e968:	619a      	str	r2, [r3, #24]
  dma_handle.Init.Mode                = DMA_NORMAL;
 800e96a:	4b1d      	ldr	r3, [pc, #116]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e96c:	2200      	movs	r2, #0
 800e96e:	61da      	str	r2, [r3, #28]
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
 800e970:	4b1b      	ldr	r3, [pc, #108]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e972:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800e976:	621a      	str	r2, [r3, #32]
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
 800e978:	4b19      	ldr	r3, [pc, #100]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e97a:	2200      	movs	r2, #0
 800e97c:	625a      	str	r2, [r3, #36]	; 0x24
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 800e97e:	4b18      	ldr	r3, [pc, #96]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e980:	2203      	movs	r2, #3
 800e982:	629a      	str	r2, [r3, #40]	; 0x28
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
 800e984:	4b16      	ldr	r3, [pc, #88]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e986:	2200      	movs	r2, #0
 800e988:	62da      	str	r2, [r3, #44]	; 0x2c
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
 800e98a:	4b15      	ldr	r3, [pc, #84]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e98c:	2200      	movs	r2, #0
 800e98e:	631a      	str	r2, [r3, #48]	; 0x30
  
  dma_handle.Instance = SDRAM_DMA_STREAM;
 800e990:	4b13      	ldr	r3, [pc, #76]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e992:	4a14      	ldr	r2, [pc, #80]	; (800e9e4 <SDRAM_MspInit+0x1e8>)
 800e994:	601a      	str	r2, [r3, #0]
  
   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
 800e996:	687b      	ldr	r3, [r7, #4]
 800e998:	4a11      	ldr	r2, [pc, #68]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e99a:	631a      	str	r2, [r3, #48]	; 0x30
 800e99c:	4a10      	ldr	r2, [pc, #64]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e99e:	687b      	ldr	r3, [r7, #4]
 800e9a0:	6393      	str	r3, [r2, #56]	; 0x38
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_handle);
 800e9a2:	480f      	ldr	r0, [pc, #60]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e9a4:	f7f4 ff40 	bl	8003828 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_handle); 
 800e9a8:	480d      	ldr	r0, [pc, #52]	; (800e9e0 <SDRAM_MspInit+0x1e4>)
 800e9aa:	f7f4 fed1 	bl	8003750 <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMA_IRQn, SDRAM_DMA_IRQ_PREEMPT, SDRAM_DMA_IRQ_SUB);
 800e9ae:	2038      	movs	r0, #56	; 0x38
 800e9b0:	2105      	movs	r1, #5
 800e9b2:	2200      	movs	r2, #0
 800e9b4:	f7f4 fe18 	bl	80035e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMA_IRQn);
 800e9b8:	2038      	movs	r0, #56	; 0x38
 800e9ba:	f7f4 fe31 	bl	8003620 <HAL_NVIC_EnableIRQ>
}
 800e9be:	3740      	adds	r7, #64	; 0x40
 800e9c0:	46bd      	mov	sp, r7
 800e9c2:	bd80      	pop	{r7, pc}
 800e9c4:	40023800 	.word	0x40023800
 800e9c8:	40020800 	.word	0x40020800
 800e9cc:	40020c00 	.word	0x40020c00
 800e9d0:	40021000 	.word	0x40021000
 800e9d4:	40021400 	.word	0x40021400
 800e9d8:	40021800 	.word	0x40021800
 800e9dc:	40021c00 	.word	0x40021c00
 800e9e0:	2001085c 	.word	0x2001085c
 800e9e4:	40026410 	.word	0x40026410

0800e9e8 <SDRAM_InitializationSequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
static void SDRAM_InitializationSequence(uint32_t RefreshCount)
{
 800e9e8:	b580      	push	{r7, lr}
 800e9ea:	b084      	sub	sp, #16
 800e9ec:	af00      	add	r7, sp, #0
 800e9ee:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpmrd = 0;
 800e9f0:	2300      	movs	r3, #0
 800e9f2:	60fb      	str	r3, [r7, #12]
  
  /* Step 1: Configure a clock configuration enable command */
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 800e9f4:	4b2d      	ldr	r3, [pc, #180]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800e9f6:	2201      	movs	r2, #1
 800e9f8:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800e9fa:	4b2c      	ldr	r3, [pc, #176]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800e9fc:	2210      	movs	r2, #16
 800e9fe:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 800ea00:	4b2a      	ldr	r3, [pc, #168]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea02:	2201      	movs	r2, #1
 800ea04:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 800ea06:	4b29      	ldr	r3, [pc, #164]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea08:	2200      	movs	r2, #0
 800ea0a:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800ea0c:	4828      	ldr	r0, [pc, #160]	; (800eab0 <SDRAM_InitializationSequence+0xc8>)
 800ea0e:	4927      	ldr	r1, [pc, #156]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea10:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ea14:	f7fa fb64 	bl	80090e0 <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  // HAL_Delay(1);
	/* interrupt is not enable, just to delay some time. */
	for (tmpmrd = 0; tmpmrd < 0xfffff; tmpmrd ++)
 800ea18:	2300      	movs	r3, #0
 800ea1a:	60fb      	str	r3, [r7, #12]
 800ea1c:	e002      	b.n	800ea24 <SDRAM_InitializationSequence+0x3c>
 800ea1e:	68fb      	ldr	r3, [r7, #12]
 800ea20:	3301      	adds	r3, #1
 800ea22:	60fb      	str	r3, [r7, #12]
 800ea24:	68fb      	ldr	r3, [r7, #12]
 800ea26:	4a23      	ldr	r2, [pc, #140]	; (800eab4 <SDRAM_InitializationSequence+0xcc>)
 800ea28:	4293      	cmp	r3, r2
 800ea2a:	d9f8      	bls.n	800ea1e <SDRAM_InitializationSequence+0x36>
		;

  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
 800ea2c:	4b1f      	ldr	r3, [pc, #124]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea2e:	2202      	movs	r2, #2
 800ea30:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800ea32:	4b1e      	ldr	r3, [pc, #120]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea34:	2210      	movs	r2, #16
 800ea36:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 800ea38:	4b1c      	ldr	r3, [pc, #112]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea3a:	2201      	movs	r2, #1
 800ea3c:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 800ea3e:	4b1b      	ldr	r3, [pc, #108]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea40:	2200      	movs	r2, #0
 800ea42:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
 800ea44:	481a      	ldr	r0, [pc, #104]	; (800eab0 <SDRAM_InitializationSequence+0xc8>)
 800ea46:	4919      	ldr	r1, [pc, #100]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea48:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ea4c:	f7fa fb48 	bl	80090e0 <HAL_SDRAM_SendCommand>
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 800ea50:	4b16      	ldr	r3, [pc, #88]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea52:	2203      	movs	r2, #3
 800ea54:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800ea56:	4b15      	ldr	r3, [pc, #84]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea58:	2210      	movs	r2, #16
 800ea5a:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 8;
 800ea5c:	4b13      	ldr	r3, [pc, #76]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea5e:	2208      	movs	r2, #8
 800ea60:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 800ea62:	4b12      	ldr	r3, [pc, #72]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea64:	2200      	movs	r2, #0
 800ea66:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800ea68:	4811      	ldr	r0, [pc, #68]	; (800eab0 <SDRAM_InitializationSequence+0xc8>)
 800ea6a:	4910      	ldr	r1, [pc, #64]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea6c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ea70:	f7fa fb36 	bl	80090e0 <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
 800ea74:	f44f 7308 	mov.w	r3, #544	; 0x220
 800ea78:	60fb      	str	r3, [r7, #12]
                     SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
                     SDRAM_MODEREG_CAS_LATENCY_2           |\
                     SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
  
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
 800ea7a:	4b0c      	ldr	r3, [pc, #48]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea7c:	2204      	movs	r2, #4
 800ea7e:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800ea80:	4b0a      	ldr	r3, [pc, #40]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea82:	2210      	movs	r2, #16
 800ea84:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 800ea86:	4b09      	ldr	r3, [pc, #36]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea88:	2201      	movs	r2, #1
 800ea8a:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = tmpmrd;
 800ea8c:	68fb      	ldr	r3, [r7, #12]
 800ea8e:	4a07      	ldr	r2, [pc, #28]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea90:	60d3      	str	r3, [r2, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800ea92:	4807      	ldr	r0, [pc, #28]	; (800eab0 <SDRAM_InitializationSequence+0xc8>)
 800ea94:	4905      	ldr	r1, [pc, #20]	; (800eaac <SDRAM_InitializationSequence+0xc4>)
 800ea96:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ea9a:	f7fa fb21 	bl	80090e0 <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
 800ea9e:	4804      	ldr	r0, [pc, #16]	; (800eab0 <SDRAM_InitializationSequence+0xc8>)
 800eaa0:	6879      	ldr	r1, [r7, #4]
 800eaa2:	f7fa fb49 	bl	8009138 <HAL_SDRAM_ProgramRefreshRate>
}
 800eaa6:	3710      	adds	r7, #16
 800eaa8:	46bd      	mov	sp, r7
 800eaaa:	bd80      	pop	{r7, pc}
 800eaac:	2001084c 	.word	0x2001084c
 800eab0:	200107fc 	.word	0x200107fc
 800eab4:	000ffffe 	.word	0x000ffffe

0800eab8 <sdram_hw_init>:
/**
  * @brief  Initializes the SDRAM device.
  * @retval SDRAM status
  */
rt_err_t sdram_hw_init(void)
{ 
 800eab8:	b580      	push	{r7, lr}
 800eaba:	af00      	add	r7, sp, #0
  static uint8_t sdramstatus = RT_ERROR;
  /* SDRAM device configuration */
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 800eabc:	4b29      	ldr	r3, [pc, #164]	; (800eb64 <sdram_hw_init+0xac>)
 800eabe:	4a2a      	ldr	r2, [pc, #168]	; (800eb68 <sdram_hw_init+0xb0>)
 800eac0:	601a      	str	r2, [r3, #0]
    
  /* Timing configuration for 100Mhz as SD clock frequency (System clock is up to 200Mhz) */
  Timing.LoadToActiveDelay    = 2;
 800eac2:	4b2a      	ldr	r3, [pc, #168]	; (800eb6c <sdram_hw_init+0xb4>)
 800eac4:	2202      	movs	r2, #2
 800eac6:	601a      	str	r2, [r3, #0]
  Timing.ExitSelfRefreshDelay = 7;
 800eac8:	4b28      	ldr	r3, [pc, #160]	; (800eb6c <sdram_hw_init+0xb4>)
 800eaca:	2207      	movs	r2, #7
 800eacc:	605a      	str	r2, [r3, #4]
  Timing.SelfRefreshTime      = 4;
 800eace:	4b27      	ldr	r3, [pc, #156]	; (800eb6c <sdram_hw_init+0xb4>)
 800ead0:	2204      	movs	r2, #4
 800ead2:	609a      	str	r2, [r3, #8]
  Timing.RowCycleDelay        = 7;
 800ead4:	4b25      	ldr	r3, [pc, #148]	; (800eb6c <sdram_hw_init+0xb4>)
 800ead6:	2207      	movs	r2, #7
 800ead8:	60da      	str	r2, [r3, #12]
  Timing.WriteRecoveryTime    = 2;
 800eada:	4b24      	ldr	r3, [pc, #144]	; (800eb6c <sdram_hw_init+0xb4>)
 800eadc:	2202      	movs	r2, #2
 800eade:	611a      	str	r2, [r3, #16]
  Timing.RPDelay              = 2;
 800eae0:	4b22      	ldr	r3, [pc, #136]	; (800eb6c <sdram_hw_init+0xb4>)
 800eae2:	2202      	movs	r2, #2
 800eae4:	615a      	str	r2, [r3, #20]
  Timing.RCDDelay             = 2;
 800eae6:	4b21      	ldr	r3, [pc, #132]	; (800eb6c <sdram_hw_init+0xb4>)
 800eae8:	2202      	movs	r2, #2
 800eaea:	619a      	str	r2, [r3, #24]
  
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
 800eaec:	4b1d      	ldr	r3, [pc, #116]	; (800eb64 <sdram_hw_init+0xac>)
 800eaee:	2200      	movs	r2, #0
 800eaf0:	605a      	str	r2, [r3, #4]
  sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 800eaf2:	4b1c      	ldr	r3, [pc, #112]	; (800eb64 <sdram_hw_init+0xac>)
 800eaf4:	2200      	movs	r2, #0
 800eaf6:	609a      	str	r2, [r3, #8]
  sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
 800eaf8:	4b1a      	ldr	r3, [pc, #104]	; (800eb64 <sdram_hw_init+0xac>)
 800eafa:	2204      	movs	r2, #4
 800eafc:	60da      	str	r2, [r3, #12]
  sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
 800eafe:	4b19      	ldr	r3, [pc, #100]	; (800eb64 <sdram_hw_init+0xac>)
 800eb00:	2210      	movs	r2, #16
 800eb02:	611a      	str	r2, [r3, #16]
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 800eb04:	4b17      	ldr	r3, [pc, #92]	; (800eb64 <sdram_hw_init+0xac>)
 800eb06:	2240      	movs	r2, #64	; 0x40
 800eb08:	615a      	str	r2, [r3, #20]
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
 800eb0a:	4b16      	ldr	r3, [pc, #88]	; (800eb64 <sdram_hw_init+0xac>)
 800eb0c:	f44f 7280 	mov.w	r2, #256	; 0x100
 800eb10:	619a      	str	r2, [r3, #24]
  sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 800eb12:	4b14      	ldr	r3, [pc, #80]	; (800eb64 <sdram_hw_init+0xac>)
 800eb14:	2200      	movs	r2, #0
 800eb16:	61da      	str	r2, [r3, #28]
  sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 800eb18:	4b12      	ldr	r3, [pc, #72]	; (800eb64 <sdram_hw_init+0xac>)
 800eb1a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800eb1e:	621a      	str	r2, [r3, #32]
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
 800eb20:	4b10      	ldr	r3, [pc, #64]	; (800eb64 <sdram_hw_init+0xac>)
 800eb22:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800eb26:	625a      	str	r2, [r3, #36]	; 0x24
  sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
 800eb28:	4b0e      	ldr	r3, [pc, #56]	; (800eb64 <sdram_hw_init+0xac>)
 800eb2a:	2200      	movs	r2, #0
 800eb2c:	629a      	str	r2, [r3, #40]	; 0x28
  
  /* SDRAM controller initialization */

  SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 800eb2e:	480d      	ldr	r0, [pc, #52]	; (800eb64 <sdram_hw_init+0xac>)
 800eb30:	2100      	movs	r1, #0
 800eb32:	f7ff fe63 	bl	800e7fc <SDRAM_MspInit>

  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 800eb36:	480b      	ldr	r0, [pc, #44]	; (800eb64 <sdram_hw_init+0xac>)
 800eb38:	490c      	ldr	r1, [pc, #48]	; (800eb6c <sdram_hw_init+0xb4>)
 800eb3a:	f7fa fa91 	bl	8009060 <HAL_SDRAM_Init>
 800eb3e:	4603      	mov	r3, r0
 800eb40:	2b00      	cmp	r3, #0
 800eb42:	d003      	beq.n	800eb4c <sdram_hw_init+0x94>
  {
    sdramstatus = RT_ERROR;
 800eb44:	4b0a      	ldr	r3, [pc, #40]	; (800eb70 <sdram_hw_init+0xb8>)
 800eb46:	2201      	movs	r2, #1
 800eb48:	701a      	strb	r2, [r3, #0]
 800eb4a:	e002      	b.n	800eb52 <sdram_hw_init+0x9a>
  }
  else
  {
    sdramstatus = RT_EOK;
 800eb4c:	4b08      	ldr	r3, [pc, #32]	; (800eb70 <sdram_hw_init+0xb8>)
 800eb4e:	2200      	movs	r2, #0
 800eb50:	701a      	strb	r2, [r3, #0]
  }
  
  /* SDRAM initialization sequence */
  SDRAM_InitializationSequence(REFRESH_COUNT);
 800eb52:	f240 6003 	movw	r0, #1539	; 0x603
 800eb56:	f7ff ff47 	bl	800e9e8 <SDRAM_InitializationSequence>
  
  return sdramstatus;
 800eb5a:	4b05      	ldr	r3, [pc, #20]	; (800eb70 <sdram_hw_init+0xb8>)
 800eb5c:	781b      	ldrb	r3, [r3, #0]
}
 800eb5e:	4618      	mov	r0, r3
 800eb60:	bd80      	pop	{r7, pc}
 800eb62:	bf00      	nop
 800eb64:	200107fc 	.word	0x200107fc
 800eb68:	a0000140 	.word	0xa0000140
 800eb6c:	20010830 	.word	0x20010830
 800eb70:	20010004 	.word	0x20010004

0800eb74 <DMA2_Stream0_IRQHandler>:
/**
  * @brief  Handles SDRAM DMA transfer interrupt request.
  * @retval None
  */
void SDRAM_DMA_IRQHandler(void)
{
 800eb74:	b580      	push	{r7, lr}
 800eb76:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(sdramHandle.hdma); 
 800eb78:	4b02      	ldr	r3, [pc, #8]	; (800eb84 <DMA2_Stream0_IRQHandler+0x10>)
 800eb7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800eb7c:	4618      	mov	r0, r3
 800eb7e:	f7f6 f8b3 	bl	8004ce8 <HAL_DMA_IRQHandler>
}
 800eb82:	bd80      	pop	{r7, pc}
 800eb84:	200107fc 	.word	0x200107fc

0800eb88 <HAL_TIMEx_BreakCallback>:
#include "MC_Globals.h"

#define ENC_COUNTER_RESET   (u8) 0

void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 800eb88:	b580      	push	{r7, lr}
 800eb8a:	b082      	sub	sp, #8
 800eb8c:	af00      	add	r7, sp, #0
 800eb8e:	6078      	str	r0, [r7, #4]
	if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800eb90:	687b      	ldr	r3, [r7, #4]
 800eb92:	681b      	ldr	r3, [r3, #0]
 800eb94:	691b      	ldr	r3, [r3, #16]
 800eb96:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800eb9a:	2b00      	cmp	r3, #0
 800eb9c:	d007      	beq.n	800ebae <HAL_TIMEx_BreakCallback+0x26>
	{
		rt_kprintf(" BREAK1 is triggered\r\n");
 800eb9e:	480e      	ldr	r0, [pc, #56]	; (800ebd8 <HAL_TIMEx_BreakCallback+0x50>)
 800eba0:	f005 f866 	bl	8013c70 <rt_kprintf>
		  MCL_SetFault(OVER_CURRENT);
 800eba4:	f44f 7000 	mov.w	r0, #512	; 0x200
 800eba8:	f002 fa92 	bl	80110d0 <MCL_SetFault>
 800ebac:	e011      	b.n	800ebd2 <HAL_TIMEx_BreakCallback+0x4a>
	}
	else if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800ebae:	687b      	ldr	r3, [r7, #4]
 800ebb0:	681b      	ldr	r3, [r3, #0]
 800ebb2:	691b      	ldr	r3, [r3, #16]
 800ebb4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ebb8:	2b00      	cmp	r3, #0
 800ebba:	d007      	beq.n	800ebcc <HAL_TIMEx_BreakCallback+0x44>
	{
		rt_kprintf(" BREAK2 is triggered\r\n");
 800ebbc:	4807      	ldr	r0, [pc, #28]	; (800ebdc <HAL_TIMEx_BreakCallback+0x54>)
 800ebbe:	f005 f857 	bl	8013c70 <rt_kprintf>
		  MCL_SetFault(OVER_CURRENT);
 800ebc2:	f44f 7000 	mov.w	r0, #512	; 0x200
 800ebc6:	f002 fa83 	bl	80110d0 <MCL_SetFault>
 800ebca:	e002      	b.n	800ebd2 <HAL_TIMEx_BreakCallback+0x4a>
	}
	else 
	{
		rt_kprintf("TIM8 is triggered\r\n");
 800ebcc:	4804      	ldr	r0, [pc, #16]	; (800ebe0 <HAL_TIMEx_BreakCallback+0x58>)
 800ebce:	f005 f84f 	bl	8013c70 <rt_kprintf>
	}

}
 800ebd2:	3708      	adds	r7, #8
 800ebd4:	46bd      	mov	sp, r7
 800ebd6:	bd80      	pop	{r7, pc}
 800ebd8:	080227c8 	.word	0x080227c8
 800ebdc:	080227e0 	.word	0x080227e0
 800ebe0:	080227f8 	.word	0x080227f8

0800ebe4 <TIM8_BRK_TIM12_IRQHandler>:


void TIM8_BRK_TIM12_IRQHandler(void)
{
 800ebe4:	b580      	push	{r7, lr}
 800ebe6:	b090      	sub	sp, #64	; 0x40
 800ebe8:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef	 TimHandle;
	
	/* Set TIMx instance */
	
	/*enter interrupt */
	rt_interrupt_enter();
 800ebea:	f004 fa31 	bl	8013050 <rt_interrupt_enter>
	
	TimHandle.Instance = TIM8;
 800ebee:	4b05      	ldr	r3, [pc, #20]	; (800ec04 <TIM8_BRK_TIM12_IRQHandler+0x20>)
 800ebf0:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&TimHandle);
 800ebf2:	1d3b      	adds	r3, r7, #4
 800ebf4:	4618      	mov	r0, r3
 800ebf6:	f7fa fcbf 	bl	8009578 <HAL_TIM_IRQHandler>
		
    /* leave interrupt */
    rt_interrupt_leave();
 800ebfa:	f004 fa3f 	bl	801307c <rt_interrupt_leave>

}
 800ebfe:	3740      	adds	r7, #64	; 0x40
 800ec00:	46bd      	mov	sp, r7
 800ec02:	bd80      	pop	{r7, pc}
 800ec04:	40010400 	.word	0x40010400

0800ec08 <TIM8_UP_TIM13_IRQHandler>:

void TIM8_UP_TIM13_IRQHandler(void)
{
 800ec08:	b580      	push	{r7, lr}
 800ec0a:	b090      	sub	sp, #64	; 0x40
 800ec0c:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef	 TimHandle;
	rt_interrupt_enter();
 800ec0e:	f004 fa1f 	bl	8013050 <rt_interrupt_enter>
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_SET);
 800ec12:	480a      	ldr	r0, [pc, #40]	; (800ec3c <TIM8_UP_TIM13_IRQHandler+0x34>)
 800ec14:	2108      	movs	r1, #8
 800ec16:	2201      	movs	r2, #1
 800ec18:	f7f9 fc92 	bl	8008540 <HAL_GPIO_WritePin>
	TimHandle.Instance = TIM8;
 800ec1c:	4b08      	ldr	r3, [pc, #32]	; (800ec40 <TIM8_UP_TIM13_IRQHandler+0x38>)
 800ec1e:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&TimHandle);
 800ec20:	1d3b      	adds	r3, r7, #4
 800ec22:	4618      	mov	r0, r3
 800ec24:	f7fa fca8 	bl	8009578 <HAL_TIM_IRQHandler>
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_RESET);
 800ec28:	4804      	ldr	r0, [pc, #16]	; (800ec3c <TIM8_UP_TIM13_IRQHandler+0x34>)
 800ec2a:	2108      	movs	r1, #8
 800ec2c:	2200      	movs	r2, #0
 800ec2e:	f7f9 fc87 	bl	8008540 <HAL_GPIO_WritePin>
    /* leave interrupt */
    rt_interrupt_leave();
 800ec32:	f004 fa23 	bl	801307c <rt_interrupt_leave>
}
 800ec36:	3740      	adds	r7, #64	; 0x40
 800ec38:	46bd      	mov	sp, r7
 800ec3a:	bd80      	pop	{r7, pc}
 800ec3c:	40022000 	.word	0x40022000
 800ec40:	40010400 	.word	0x40010400

0800ec44 <SetDutyCycles>:
	TIMx->CNT = ENC_COUNTER_RESET;

}

extern void SetDutyCycles(TIM_TypeDef *TIMx, u16 hTimePhA, u16 hTimePhB, u16 hTimePhC)
{
 800ec44:	b480      	push	{r7}
 800ec46:	b085      	sub	sp, #20
 800ec48:	af00      	add	r7, sp, #0
 800ec4a:	60f8      	str	r0, [r7, #12]
 800ec4c:	4608      	mov	r0, r1
 800ec4e:	4611      	mov	r1, r2
 800ec50:	461a      	mov	r2, r3
 800ec52:	4603      	mov	r3, r0
 800ec54:	817b      	strh	r3, [r7, #10]
 800ec56:	460b      	mov	r3, r1
 800ec58:	813b      	strh	r3, [r7, #8]
 800ec5a:	4613      	mov	r3, r2
 800ec5c:	80fb      	strh	r3, [r7, #6]
	TIMx->CCR1 = hTimePhA;
 800ec5e:	897a      	ldrh	r2, [r7, #10]
 800ec60:	68fb      	ldr	r3, [r7, #12]
 800ec62:	635a      	str	r2, [r3, #52]	; 0x34
	TIMx->CCR2 = hTimePhB;
 800ec64:	893a      	ldrh	r2, [r7, #8]
 800ec66:	68fb      	ldr	r3, [r7, #12]
 800ec68:	639a      	str	r2, [r3, #56]	; 0x38
	TIMx->CCR3 = hTimePhC;
 800ec6a:	88fa      	ldrh	r2, [r7, #6]
 800ec6c:	68fb      	ldr	r3, [r7, #12]
 800ec6e:	63da      	str	r2, [r3, #60]	; 0x3c
}
 800ec70:	3714      	adds	r7, #20
 800ec72:	46bd      	mov	sp, r7
 800ec74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec78:	4770      	bx	lr
 800ec7a:	bf00      	nop

0800ec7c <PWMOutputsEnable>:


extern void PWMOutputsEnable(TIM_TypeDef *TIMx)
{
 800ec7c:	b580      	push	{r7, lr}
 800ec7e:	b082      	sub	sp, #8
 800ec80:	af00      	add	r7, sp, #0
 800ec82:	6078      	str	r0, [r7, #4]
	TIMx->BDTR |= TIM_BDTR_MOE;
 800ec84:	687b      	ldr	r3, [r7, #4]
 800ec86:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ec88:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 800ec8c:	687b      	ldr	r3, [r7, #4]
 800ec8e:	645a      	str	r2, [r3, #68]	; 0x44
	HAL_GPIO_WritePin(OCDRELEASE_PORT,OCDRELEASE_PIN,GPIO_PIN_SET);
 800ec90:	4808      	ldr	r0, [pc, #32]	; (800ecb4 <PWMOutputsEnable+0x38>)
 800ec92:	f44f 7180 	mov.w	r1, #256	; 0x100
 800ec96:	2201      	movs	r2, #1
 800ec98:	f7f9 fc52 	bl	8008540 <HAL_GPIO_WritePin>
	rt_thread_delay(20);
 800ec9c:	2014      	movs	r0, #20
 800ec9e:	f006 fa91 	bl	80151c4 <rt_thread_delay>
	HAL_GPIO_WritePin(OCDRELEASE_PORT,OCDRELEASE_PIN,GPIO_PIN_RESET);
 800eca2:	4804      	ldr	r0, [pc, #16]	; (800ecb4 <PWMOutputsEnable+0x38>)
 800eca4:	f44f 7180 	mov.w	r1, #256	; 0x100
 800eca8:	2200      	movs	r2, #0
 800ecaa:	f7f9 fc49 	bl	8008540 <HAL_GPIO_WritePin>
}
 800ecae:	3708      	adds	r7, #8
 800ecb0:	46bd      	mov	sp, r7
 800ecb2:	bd80      	pop	{r7, pc}
 800ecb4:	40020000 	.word	0x40020000

0800ecb8 <PWMOutputsDisable>:


extern void PWMOutputsDisable(TIM_TypeDef *TIMx)
{
 800ecb8:	b480      	push	{r7}
 800ecba:	b083      	sub	sp, #12
 800ecbc:	af00      	add	r7, sp, #0
 800ecbe:	6078      	str	r0, [r7, #4]
	TIMx->BDTR &= (~TIM_BDTR_MOE);
 800ecc0:	687b      	ldr	r3, [r7, #4]
 800ecc2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ecc4:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 800ecc8:	687b      	ldr	r3, [r7, #4]
 800ecca:	645a      	str	r2, [r3, #68]	; 0x44
}
 800eccc:	370c      	adds	r7, #12
 800ecce:	46bd      	mov	sp, r7
 800ecd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecd4:	4770      	bx	lr
 800ecd6:	bf00      	nop

0800ecd8 <HAL_TIM_PWM_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 800ecd8:	b580      	push	{r7, lr}
 800ecda:	b08e      	sub	sp, #56	; 0x38
 800ecdc:	af00      	add	r7, sp, #0
 800ecde:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_Init;
    if (htim->Instance == TIM8)
 800ece0:	687b      	ldr	r3, [r7, #4]
 800ece2:	681b      	ldr	r3, [r3, #0]
 800ece4:	4a47      	ldr	r2, [pc, #284]	; (800ee04 <HAL_TIM_PWM_MspInit+0x12c>)
 800ece6:	4293      	cmp	r3, r2
 800ece8:	f040 8089 	bne.w	800edfe <HAL_TIM_PWM_MspInit+0x126>
    {
        /* Enable GPIO clock */
        TIM8_GPIOA_CLK_ENABLE();
 800ecec:	4a46      	ldr	r2, [pc, #280]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ecee:	4b46      	ldr	r3, [pc, #280]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ecf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ecf2:	f043 0301 	orr.w	r3, r3, #1
 800ecf6:	6313      	str	r3, [r2, #48]	; 0x30
 800ecf8:	4b43      	ldr	r3, [pc, #268]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ecfa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ecfc:	f003 0301 	and.w	r3, r3, #1
 800ed00:	623b      	str	r3, [r7, #32]
 800ed02:	6a3b      	ldr	r3, [r7, #32]
        TIM8_GPIOB_CLK_ENABLE();
 800ed04:	4a40      	ldr	r2, [pc, #256]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed06:	4b40      	ldr	r3, [pc, #256]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ed0a:	f043 0302 	orr.w	r3, r3, #2
 800ed0e:	6313      	str	r3, [r2, #48]	; 0x30
 800ed10:	4b3d      	ldr	r3, [pc, #244]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ed14:	f003 0302 	and.w	r3, r3, #2
 800ed18:	61fb      	str	r3, [r7, #28]
 800ed1a:	69fb      	ldr	r3, [r7, #28]
		TIM8_GPIOC_CLK_ENABLE();
 800ed1c:	4a3a      	ldr	r2, [pc, #232]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed1e:	4b3a      	ldr	r3, [pc, #232]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ed22:	f043 0304 	orr.w	r3, r3, #4
 800ed26:	6313      	str	r3, [r2, #48]	; 0x30
 800ed28:	4b37      	ldr	r3, [pc, #220]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ed2c:	f003 0304 	and.w	r3, r3, #4
 800ed30:	61bb      	str	r3, [r7, #24]
 800ed32:	69bb      	ldr	r3, [r7, #24]
        TIM8_GPIOH_CLK_ENABLE();
 800ed34:	4a34      	ldr	r2, [pc, #208]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed36:	4b34      	ldr	r3, [pc, #208]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ed3a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ed3e:	6313      	str	r3, [r2, #48]	; 0x30
 800ed40:	4b31      	ldr	r3, [pc, #196]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ed44:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ed48:	617b      	str	r3, [r7, #20]
 800ed4a:	697b      	ldr	r3, [r7, #20]
		TIM8_GPIOI_CLK_ENABLE();
 800ed4c:	4a2e      	ldr	r2, [pc, #184]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed4e:	4b2e      	ldr	r3, [pc, #184]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ed52:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ed56:	6313      	str	r3, [r2, #48]	; 0x30
 800ed58:	4b2b      	ldr	r3, [pc, #172]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ed5c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ed60:	613b      	str	r3, [r7, #16]
 800ed62:	693b      	ldr	r3, [r7, #16]

        /* Enable TIMx clock */
        TIM8_CLK_ENABLE();
 800ed64:	4a28      	ldr	r2, [pc, #160]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed66:	4b28      	ldr	r3, [pc, #160]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed68:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ed6a:	f043 0302 	orr.w	r3, r3, #2
 800ed6e:	6453      	str	r3, [r2, #68]	; 0x44
 800ed70:	4b25      	ldr	r3, [pc, #148]	; (800ee08 <HAL_TIM_PWM_MspInit+0x130>)
 800ed72:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ed74:	f003 0302 	and.w	r3, r3, #2
 800ed78:	60fb      	str	r3, [r7, #12]
 800ed7a:	68fb      	ldr	r3, [r7, #12]

        /* GPIO pin configuration  */
	 	GPIO_Init.Pin = PWMWP_PIN | PWMVP_PIN | PWMBREAK_PIN;
 800ed7c:	f44f 7330 	mov.w	r3, #704	; 0x2c0
 800ed80:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_Init.Mode = GPIO_MODE_AF_PP;
 800ed82:	2302      	movs	r3, #2
 800ed84:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_Init.Pull = GPIO_PULLUP;
 800ed86:	2301      	movs	r3, #1
 800ed88:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_Init.Speed = GPIO_SPEED_LOW;
 800ed8a:	2300      	movs	r3, #0
 800ed8c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_Init.Alternate = PWMWP_AF;
 800ed8e:	2303      	movs	r3, #3
 800ed90:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PWMWP_GPIO_PORT,&GPIO_Init);
 800ed92:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800ed96:	481d      	ldr	r0, [pc, #116]	; (800ee0c <HAL_TIM_PWM_MspInit+0x134>)
 800ed98:	4619      	mov	r1, r3
 800ed9a:	f7f9 f909 	bl	8007fb0 <HAL_GPIO_Init>
		
	 	GPIO_Init.Pin = PWMUP_PIN;
 800ed9e:	2380      	movs	r3, #128	; 0x80
 800eda0:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(PWMUP_GPIO_PORT,&GPIO_Init);
 800eda2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800eda6:	481a      	ldr	r0, [pc, #104]	; (800ee10 <HAL_TIM_PWM_MspInit+0x138>)
 800eda8:	4619      	mov	r1, r3
 800edaa:	f7f9 f901 	bl	8007fb0 <HAL_GPIO_Init>

		GPIO_Init.Pin = PWMWN_PIN | PWMVN_PIN | PWMUN_PIN;
 800edae:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 800edb2:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(PWMWN_GPIO_PORT,&GPIO_Init);
 800edb4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800edb8:	4816      	ldr	r0, [pc, #88]	; (800ee14 <HAL_TIM_PWM_MspInit+0x13c>)
 800edba:	4619      	mov	r1, r3
 800edbc:	f7f9 f8f8 	bl	8007fb0 <HAL_GPIO_Init>

		GPIO_Init.Pin = FAULT1_PIN | FAULT2_PIN;
 800edc0:	2312      	movs	r3, #18
 800edc2:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(FAULT1_GPIO_PORT,&GPIO_Init);
 800edc4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800edc8:	4811      	ldr	r0, [pc, #68]	; (800ee10 <HAL_TIM_PWM_MspInit+0x138>)
 800edca:	4619      	mov	r1, r3
 800edcc:	f7f9 f8f0 	bl	8007fb0 <HAL_GPIO_Init>

		GPIO_Init.Pin = OCDRELEASE_PIN;
 800edd0:	f44f 7380 	mov.w	r3, #256	; 0x100
 800edd4:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_Init.Mode = GPIO_MODE_OUTPUT_PP;
 800edd6:	2301      	movs	r3, #1
 800edd8:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_Init.Pull = GPIO_PULLUP;
 800edda:	2301      	movs	r3, #1
 800eddc:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_Init.Speed = GPIO_SPEED_LOW;
 800edde:	2300      	movs	r3, #0
 800ede0:	633b      	str	r3, [r7, #48]	; 0x30
		HAL_GPIO_Init(OCDRELEASE_PORT,&GPIO_Init);
 800ede2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800ede6:	480c      	ldr	r0, [pc, #48]	; (800ee18 <HAL_TIM_PWM_MspInit+0x140>)
 800ede8:	4619      	mov	r1, r3
 800edea:	f7f9 f8e1 	bl	8007fb0 <HAL_GPIO_Init>
        /* NVIC for BRK */
        HAL_NVIC_SetPriority(TIM8_BRK_TIM12_IRQn, TIM8_BRK_TIM12_IRQ_PREEMPT, TIM8_BRK_TIM12_IRQ_SUB );
 800edee:	202b      	movs	r0, #43	; 0x2b
 800edf0:	2100      	movs	r1, #0
 800edf2:	2200      	movs	r2, #0
 800edf4:	f7f4 fbf8 	bl	80035e8 <HAL_NVIC_SetPriority>
        HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);
 800edf8:	202b      	movs	r0, #43	; 0x2b
 800edfa:	f7f4 fc11 	bl	8003620 <HAL_NVIC_EnableIRQ>
		#ifdef TIM8UPDATEITENABLE
		HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, TIM8_BRK_TIM12_IRQ_PREEMPT, TIM8_BRK_TIM12_IRQ_SUB );
        HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
		#endif
    }
}
 800edfe:	3738      	adds	r7, #56	; 0x38
 800ee00:	46bd      	mov	sp, r7
 800ee02:	bd80      	pop	{r7, pc}
 800ee04:	40010400 	.word	0x40010400
 800ee08:	40023800 	.word	0x40023800
 800ee0c:	40020800 	.word	0x40020800
 800ee10:	40022000 	.word	0x40022000
 800ee14:	40021c00 	.word	0x40021c00
 800ee18:	40020000 	.word	0x40020000

0800ee1c <HAL_TIM_PWM_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
{
 800ee1c:	b580      	push	{r7, lr}
 800ee1e:	b082      	sub	sp, #8
 800ee20:	af00      	add	r7, sp, #0
 800ee22:	6078      	str	r0, [r7, #4]
    if (htim->Instance == TIM8)
 800ee24:	687b      	ldr	r3, [r7, #4]
 800ee26:	681b      	ldr	r3, [r3, #0]
 800ee28:	4a11      	ldr	r2, [pc, #68]	; (800ee70 <HAL_TIM_PWM_MspDeInit+0x54>)
 800ee2a:	4293      	cmp	r3, r2
 800ee2c:	d11c      	bne.n	800ee68 <HAL_TIM_PWM_MspDeInit+0x4c>
    {
        /* Reset peripherals */
        TIM8_FORCE_RESET();
 800ee2e:	4a11      	ldr	r2, [pc, #68]	; (800ee74 <HAL_TIM_PWM_MspDeInit+0x58>)
 800ee30:	4b10      	ldr	r3, [pc, #64]	; (800ee74 <HAL_TIM_PWM_MspDeInit+0x58>)
 800ee32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ee34:	f043 0302 	orr.w	r3, r3, #2
 800ee38:	6253      	str	r3, [r2, #36]	; 0x24
        TIM8_RELEASE_RESET();
 800ee3a:	4a0e      	ldr	r2, [pc, #56]	; (800ee74 <HAL_TIM_PWM_MspDeInit+0x58>)
 800ee3c:	4b0d      	ldr	r3, [pc, #52]	; (800ee74 <HAL_TIM_PWM_MspDeInit+0x58>)
 800ee3e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ee40:	f023 0302 	bic.w	r3, r3, #2
 800ee44:	6253      	str	r3, [r2, #36]	; 0x24

        /* Disable peripherals and GPIO Clocks */
        HAL_GPIO_DeInit(PWMWP_GPIO_PORT, PWMWP_PIN | PWMVP_PIN | PWMUP_PIN | PWMBREAK_PIN);
 800ee46:	480c      	ldr	r0, [pc, #48]	; (800ee78 <HAL_TIM_PWM_MspDeInit+0x5c>)
 800ee48:	f44f 7130 	mov.w	r1, #704	; 0x2c0
 800ee4c:	f7f9 fa56 	bl	80082fc <HAL_GPIO_DeInit>
        HAL_GPIO_DeInit(PWMWN_GPIO_PORT, PWMWN_PIN | PWMVN_PIN | PWMUN_PIN);
 800ee50:	480a      	ldr	r0, [pc, #40]	; (800ee7c <HAL_TIM_PWM_MspDeInit+0x60>)
 800ee52:	f44f 4160 	mov.w	r1, #57344	; 0xe000
 800ee56:	f7f9 fa51 	bl	80082fc <HAL_GPIO_DeInit>
        HAL_GPIO_DeInit(FAULT1_GPIO_PORT, FAULT1_PIN | FAULT2_PIN);
 800ee5a:	4809      	ldr	r0, [pc, #36]	; (800ee80 <HAL_TIM_PWM_MspDeInit+0x64>)
 800ee5c:	2112      	movs	r1, #18
 800ee5e:	f7f9 fa4d 	bl	80082fc <HAL_GPIO_DeInit>
		
        HAL_NVIC_DisableIRQ(TIM8_BRK_TIM12_IRQn);
 800ee62:	202b      	movs	r0, #43	; 0x2b
 800ee64:	f7f4 fbea 	bl	800363c <HAL_NVIC_DisableIRQ>
		
		#ifdef TIM8UPDATEITENABLE
        HAL_NVIC_DisableIRQ(TIM8_UP_TIM13_IRQn);
		#endif
    }
}
 800ee68:	3708      	adds	r7, #8
 800ee6a:	46bd      	mov	sp, r7
 800ee6c:	bd80      	pop	{r7, pc}
 800ee6e:	bf00      	nop
 800ee70:	40010400 	.word	0x40010400
 800ee74:	40023800 	.word	0x40023800
 800ee78:	40020800 	.word	0x40020800
 800ee7c:	40021c00 	.word	0x40021c00
 800ee80:	40022000 	.word	0x40022000

0800ee84 <stm32_hw_tim8_init>:


extern int stm32_hw_tim8_init(void)
{
 800ee84:	b580      	push	{r7, lr}
 800ee86:	b0a6      	sub	sp, #152	; 0x98
 800ee88:	af00      	add	r7, sp, #0
	TIM_OC_InitTypeDef PwmConfig;
	TIM_BreakDeadTimeConfigTypeDef PwmBDTRconfig;
	TIM_MasterConfigTypeDef TIM8MasterConfig;
	char deadtime;
	/* Set TIMx instance */
	TimHandle.Instance = TIM8;
 800ee8a:	4b65      	ldr	r3, [pc, #404]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800ee8c:	65bb      	str	r3, [r7, #88]	; 0x58

	HAL_TIM_PWM_DeInit(&TimHandle);
 800ee8e:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800ee92:	4618      	mov	r0, r3
 800ee94:	f7fa f9d6 	bl	8009244 <HAL_TIM_PWM_DeInit>

	/* Initialize TIMx peripheral	*/
	TimHandle.Init.Period            = PWM_PERIOD;
 800ee98:	f44f 63f0 	mov.w	r3, #1920	; 0x780
 800ee9c:	667b      	str	r3, [r7, #100]	; 0x64
	TimHandle.Init.Prescaler         = PWM_PRSC;
 800ee9e:	2300      	movs	r3, #0
 800eea0:	65fb      	str	r3, [r7, #92]	; 0x5c
	TimHandle.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV2;
 800eea2:	f44f 7380 	mov.w	r3, #256	; 0x100
 800eea6:	66bb      	str	r3, [r7, #104]	; 0x68
	TimHandle.Init.CounterMode       = TIM_COUNTERMODE_CENTERALIGNED1;
 800eea8:	2320      	movs	r3, #32
 800eeaa:	663b      	str	r3, [r7, #96]	; 0x60
	TimHandle.Init.RepetitionCounter = REP_RATE;
 800eeac:	2309      	movs	r3, #9
 800eeae:	66fb      	str	r3, [r7, #108]	; 0x6c
	if (HAL_TIM_PWM_Init(&TimHandle) != HAL_OK)
 800eeb0:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800eeb4:	4618      	mov	r0, r3
 800eeb6:	f7fa f999 	bl	80091ec <HAL_TIM_PWM_Init>
	{
	  /* Initialization Error */
	  /*Error_Handler(); */
	}
	PwmConfig.OCMode = TIM_OCMODE_PWM1;
 800eeba:	2360      	movs	r3, #96	; 0x60
 800eebc:	63fb      	str	r3, [r7, #60]	; 0x3c
	PwmConfig.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 800eebe:	2300      	movs	r3, #0
 800eec0:	64bb      	str	r3, [r7, #72]	; 0x48
	PwmConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
 800eec2:	2300      	movs	r3, #0
 800eec4:	647b      	str	r3, [r7, #68]	; 0x44
	PwmConfig.OCIdleState = TIM_OCIDLESTATE_RESET;
 800eec6:	2300      	movs	r3, #0
 800eec8:	653b      	str	r3, [r7, #80]	; 0x50
	PwmConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 800eeca:	2300      	movs	r3, #0
 800eecc:	657b      	str	r3, [r7, #84]	; 0x54
	PwmConfig.Pulse = PWM_PERIOD/2;
 800eece:	f44f 7370 	mov.w	r3, #960	; 0x3c0
 800eed2:	643b      	str	r3, [r7, #64]	; 0x40
	PwmConfig.OCFastMode = TIM_OCFAST_DISABLE;
 800eed4:	2300      	movs	r3, #0
 800eed6:	64fb      	str	r3, [r7, #76]	; 0x4c
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_1);
 800eed8:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800eedc:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800eee0:	4610      	mov	r0, r2
 800eee2:	4619      	mov	r1, r3
 800eee4:	2200      	movs	r2, #0
 800eee6:	f7fa ff1f 	bl	8009d28 <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_2);
 800eeea:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800eeee:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800eef2:	4610      	mov	r0, r2
 800eef4:	4619      	mov	r1, r3
 800eef6:	2204      	movs	r2, #4
 800eef8:	f7fa ff16 	bl	8009d28 <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_3);
 800eefc:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800ef00:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800ef04:	4610      	mov	r0, r2
 800ef06:	4619      	mov	r1, r3
 800ef08:	2208      	movs	r2, #8
 800ef0a:	f7fa ff0d 	bl	8009d28 <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_3);
 800ef0e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800ef12:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800ef16:	4610      	mov	r0, r2
 800ef18:	4619      	mov	r1, r3
 800ef1a:	2208      	movs	r2, #8
 800ef1c:	f7fa ff04 	bl	8009d28 <HAL_TIM_PWM_ConfigChannel>

	TIM_OC1_SetConfig(TIM8,&PwmConfig);
 800ef20:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800ef24:	483e      	ldr	r0, [pc, #248]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800ef26:	4619      	mov	r1, r3
 800ef28:	f7fa fd14 	bl	8009954 <TIM_OC1_SetConfig>
	TIM_OC2_SetConfig(TIM8,&PwmConfig);
 800ef2c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800ef30:	483b      	ldr	r0, [pc, #236]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800ef32:	4619      	mov	r1, r3
 800ef34:	f7fa fd82 	bl	8009a3c <TIM_OC2_SetConfig>
	TIM_OC3_SetConfig(TIM8,&PwmConfig);
 800ef38:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800ef3c:	4838      	ldr	r0, [pc, #224]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800ef3e:	4619      	mov	r1, r3
 800ef40:	f7fa fdf6 	bl	8009b30 <TIM_OC3_SetConfig>
	TIM_OC4_SetConfig(TIM8,&PwmConfig);
 800ef44:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800ef48:	4835      	ldr	r0, [pc, #212]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800ef4a:	4619      	mov	r1, r3
 800ef4c:	f7fa fe68 	bl	8009c20 <TIM_OC4_SetConfig>

	if (DEADTIME1 < 128)
		deadtime = DEADTIME1;
	else if( DEADTIME2 <64)
		deadtime  = DEADTIME2 | 0x80;
 800ef50:	23a0      	movs	r3, #160	; 0xa0
 800ef52:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
	else if( DEADTIME3 < 32)
		deadtime = DEADTIME3 | 0xC0;
	else
		deadtime = DEADTIME4 | 0xE0;
	PwmBDTRconfig.DeadTime  = deadtime;
 800ef56:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 800ef5a:	61fb      	str	r3, [r7, #28]
	PwmBDTRconfig.LockLevel = TIM_LOCKLEVEL_1;
 800ef5c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ef60:	61bb      	str	r3, [r7, #24]
	PwmBDTRconfig.OffStateRunMode = TIM_OSSR_ENABLE;
 800ef62:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ef66:	613b      	str	r3, [r7, #16]
	PwmBDTRconfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 800ef68:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ef6c:	617b      	str	r3, [r7, #20]
	PwmBDTRconfig.Break2State = TIM_BREAK2_ENABLE;
 800ef6e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800ef72:	62fb      	str	r3, [r7, #44]	; 0x2c
	PwmBDTRconfig.Break2Polarity = TIM_BREAK2POLARITY_LOW;
 800ef74:	2300      	movs	r3, #0
 800ef76:	633b      	str	r3, [r7, #48]	; 0x30
	PwmBDTRconfig.Break2Filter = 0x0;
 800ef78:	2300      	movs	r3, #0
 800ef7a:	637b      	str	r3, [r7, #52]	; 0x34
	PwmBDTRconfig.BreakState = TIM_BREAK_ENABLE;
 800ef7c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ef80:	623b      	str	r3, [r7, #32]
	PwmBDTRconfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 800ef82:	2300      	movs	r3, #0
 800ef84:	63bb      	str	r3, [r7, #56]	; 0x38
	PwmBDTRconfig.BreakPolarity = TIM_BREAKPOLARITY_LOW;
 800ef86:	2300      	movs	r3, #0
 800ef88:	627b      	str	r3, [r7, #36]	; 0x24
	PwmBDTRconfig.BreakFilter = 0x0;
 800ef8a:	2300      	movs	r3, #0
 800ef8c:	62bb      	str	r3, [r7, #40]	; 0x28
	HAL_TIMEx_ConfigBreakDeadTime(&TimHandle,&PwmBDTRconfig);
 800ef8e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800ef92:	f107 0310 	add.w	r3, r7, #16
 800ef96:	4610      	mov	r0, r2
 800ef98:	4619      	mov	r1, r3
 800ef9a:	f7fb f831 	bl	800a000 <HAL_TIMEx_ConfigBreakDeadTime>

	TIM8MasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800ef9e:	2300      	movs	r3, #0
 800efa0:	607b      	str	r3, [r7, #4]
	TIM8MasterConfig.MasterOutputTrigger2 = TIM_TRGO2_UPDATE;
 800efa2:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800efa6:	60bb      	str	r3, [r7, #8]
	TIM8MasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_ENABLE;
 800efa8:	2380      	movs	r3, #128	; 0x80
 800efaa:	60fb      	str	r3, [r7, #12]
	HAL_TIMEx_MasterConfigSynchronization(&TimHandle,&TIM8MasterConfig);
 800efac:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800efb0:	1d3b      	adds	r3, r7, #4
 800efb2:	4610      	mov	r0, r2
 800efb4:	4619      	mov	r1, r3
 800efb6:	f7fa ffcf 	bl	8009f58 <HAL_TIMEx_MasterConfigSynchronization>
	
	TIM8->CCER |= TIM_CCER_CC3E | TIM_CCER_CC3NE | TIM_CCER_CC2E | \
 800efba:	4919      	ldr	r1, [pc, #100]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800efbc:	4b18      	ldr	r3, [pc, #96]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800efbe:	6a1a      	ldr	r2, [r3, #32]
 800efc0:	f241 5355 	movw	r3, #5461	; 0x1555
 800efc4:	4313      	orrs	r3, r2
 800efc6:	620b      	str	r3, [r1, #32]
					TIM_CCER_CC2NE | TIM_CCER_CC1E | TIM_CCER_CC1NE | TIM_CCER_CC4E;
	TIM8->BDTR |= TIM_BDTR_OSSI | TIM_BDTR_OSSR;
 800efc8:	4a15      	ldr	r2, [pc, #84]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800efca:	4b15      	ldr	r3, [pc, #84]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800efcc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800efce:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 800efd2:	6453      	str	r3, [r2, #68]	; 0x44

	
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_1);
 800efd4:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800efd8:	4618      	mov	r0, r3
 800efda:	2100      	movs	r1, #0
 800efdc:	f7fa f962 	bl	80092a4 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_2);
 800efe0:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800efe4:	4618      	mov	r0, r3
 800efe6:	2104      	movs	r1, #4
 800efe8:	f7fa f95c 	bl	80092a4 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_3);
 800efec:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800eff0:	4618      	mov	r0, r3
 800eff2:	2108      	movs	r1, #8
 800eff4:	f7fa f956 	bl	80092a4 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_4);
 800eff8:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800effc:	4618      	mov	r0, r3
 800effe:	210c      	movs	r1, #12
 800f000:	f7fa f950 	bl	80092a4 <HAL_TIM_PWM_Start>
	
	__HAL_TIM_ENABLE_IT(&TimHandle, TIM_IT_BREAK);
 800f004:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f006:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800f008:	68d2      	ldr	r2, [r2, #12]
 800f00a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800f00e:	60da      	str	r2, [r3, #12]
	#ifdef TIM8UPDATEITENABLE
	__HAL_TIM_ENABLE_IT(&TimHandle, TIM_IT_UPDATE);
	#endif
	PWMOutputsDisable(TIM8);
 800f010:	4803      	ldr	r0, [pc, #12]	; (800f020 <stm32_hw_tim8_init+0x19c>)
 800f012:	f7ff fe51 	bl	800ecb8 <PWMOutputsDisable>
    return 0;
 800f016:	2300      	movs	r3, #0
}
 800f018:	4618      	mov	r0, r3
 800f01a:	3798      	adds	r7, #152	; 0x98
 800f01c:	46bd      	mov	sp, r7
 800f01e:	bd80      	pop	{r7, pc}
 800f020:	40010400 	.word	0x40010400

0800f024 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800f024:	b480      	push	{r7}
 800f026:	b083      	sub	sp, #12
 800f028:	af00      	add	r7, sp, #0
 800f02a:	4603      	mov	r3, r0
 800f02c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800f02e:	4908      	ldr	r1, [pc, #32]	; (800f050 <NVIC_EnableIRQ+0x2c>)
 800f030:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f034:	095b      	lsrs	r3, r3, #5
 800f036:	79fa      	ldrb	r2, [r7, #7]
 800f038:	f002 021f 	and.w	r2, r2, #31
 800f03c:	2001      	movs	r0, #1
 800f03e:	fa00 f202 	lsl.w	r2, r0, r2
 800f042:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f046:	370c      	adds	r7, #12
 800f048:	46bd      	mov	sp, r7
 800f04a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f04e:	4770      	bx	lr
 800f050:	e000e100 	.word	0xe000e100

0800f054 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800f054:	b480      	push	{r7}
 800f056:	b083      	sub	sp, #12
 800f058:	af00      	add	r7, sp, #0
 800f05a:	4603      	mov	r3, r0
 800f05c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800f05e:	4909      	ldr	r1, [pc, #36]	; (800f084 <NVIC_DisableIRQ+0x30>)
 800f060:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f064:	095b      	lsrs	r3, r3, #5
 800f066:	79fa      	ldrb	r2, [r7, #7]
 800f068:	f002 021f 	and.w	r2, r2, #31
 800f06c:	2001      	movs	r0, #1
 800f06e:	fa00 f202 	lsl.w	r2, r0, r2
 800f072:	3320      	adds	r3, #32
 800f074:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f078:	370c      	adds	r7, #12
 800f07a:	46bd      	mov	sp, r7
 800f07c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f080:	4770      	bx	lr
 800f082:	bf00      	nop
 800f084:	e000e100 	.word	0xe000e100

0800f088 <stm32_configure>:
    UART_HandleTypeDef UartHandle;
    IRQn_Type irq;
};

static rt_err_t stm32_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
{
 800f088:	b580      	push	{r7, lr}
 800f08a:	b084      	sub	sp, #16
 800f08c:	af00      	add	r7, sp, #0
 800f08e:	6078      	str	r0, [r7, #4]
 800f090:	6039      	str	r1, [r7, #0]
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 800f092:	687b      	ldr	r3, [r7, #4]
 800f094:	2b00      	cmp	r3, #0
 800f096:	d104      	bne.n	800f0a2 <stm32_configure+0x1a>
 800f098:	487f      	ldr	r0, [pc, #508]	; (800f298 <stm32_configure+0x210>)
 800f09a:	4980      	ldr	r1, [pc, #512]	; (800f29c <stm32_configure+0x214>)
 800f09c:	224c      	movs	r2, #76	; 0x4c
 800f09e:	f004 fe61 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(cfg != RT_NULL);
 800f0a2:	683b      	ldr	r3, [r7, #0]
 800f0a4:	2b00      	cmp	r3, #0
 800f0a6:	d104      	bne.n	800f0b2 <stm32_configure+0x2a>
 800f0a8:	487d      	ldr	r0, [pc, #500]	; (800f2a0 <stm32_configure+0x218>)
 800f0aa:	497c      	ldr	r1, [pc, #496]	; (800f29c <stm32_configure+0x214>)
 800f0ac:	224d      	movs	r2, #77	; 0x4d
 800f0ae:	f004 fe59 	bl	8013d64 <rt_assert_handler>

    uart = (struct stm32_uart *)serial->parent.user_data;
 800f0b2:	687b      	ldr	r3, [r7, #4]
 800f0b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f0b6:	60fb      	str	r3, [r7, #12]
	if(uart->UartHandle.Instance == USART1)
 800f0b8:	68fb      	ldr	r3, [r7, #12]
 800f0ba:	681b      	ldr	r3, [r3, #0]
 800f0bc:	4a79      	ldr	r2, [pc, #484]	; (800f2a4 <stm32_configure+0x21c>)
 800f0be:	4293      	cmp	r3, r2
 800f0c0:	d16f      	bne.n	800f1a2 <stm32_configure+0x11a>
	{
	    uart->UartHandle.Init.BaudRate   = cfg->baud_rate;
 800f0c2:	683b      	ldr	r3, [r7, #0]
 800f0c4:	681a      	ldr	r2, [r3, #0]
 800f0c6:	68fb      	ldr	r3, [r7, #12]
 800f0c8:	605a      	str	r2, [r3, #4]
	    uart->UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 800f0ca:	68fb      	ldr	r3, [r7, #12]
 800f0cc:	2200      	movs	r2, #0
 800f0ce:	619a      	str	r2, [r3, #24]
	    uart->UartHandle.Init.Mode       = UART_MODE_TX_RX;
 800f0d0:	68fb      	ldr	r3, [r7, #12]
 800f0d2:	220c      	movs	r2, #12
 800f0d4:	615a      	str	r2, [r3, #20]
	    uart->UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800f0d6:	68fb      	ldr	r3, [r7, #12]
 800f0d8:	2200      	movs	r2, #0
 800f0da:	625a      	str	r2, [r3, #36]	; 0x24

	    switch (cfg->data_bits)
 800f0dc:	683b      	ldr	r3, [r7, #0]
 800f0de:	791b      	ldrb	r3, [r3, #4]
 800f0e0:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800f0e4:	b2db      	uxtb	r3, r3
 800f0e6:	2b08      	cmp	r3, #8
 800f0e8:	d008      	beq.n	800f0fc <stm32_configure+0x74>
 800f0ea:	2b09      	cmp	r3, #9
 800f0ec:	d00a      	beq.n	800f104 <stm32_configure+0x7c>
 800f0ee:	2b07      	cmp	r3, #7
 800f0f0:	d10d      	bne.n	800f10e <stm32_configure+0x86>
	    {
	    case DATA_BITS_7:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_7B;
 800f0f2:	68fb      	ldr	r3, [r7, #12]
 800f0f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800f0f8:	609a      	str	r2, [r3, #8]
	        break;
 800f0fa:	e00c      	b.n	800f116 <stm32_configure+0x8e>
	    case DATA_BITS_8:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800f0fc:	68fb      	ldr	r3, [r7, #12]
 800f0fe:	2200      	movs	r2, #0
 800f100:	609a      	str	r2, [r3, #8]
	        break;
 800f102:	e008      	b.n	800f116 <stm32_configure+0x8e>
	    case DATA_BITS_9:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_9B;
 800f104:	68fb      	ldr	r3, [r7, #12]
 800f106:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800f10a:	609a      	str	r2, [r3, #8]
	        break;
 800f10c:	e003      	b.n	800f116 <stm32_configure+0x8e>
	    default:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800f10e:	68fb      	ldr	r3, [r7, #12]
 800f110:	2200      	movs	r2, #0
 800f112:	609a      	str	r2, [r3, #8]
	        break;
 800f114:	bf00      	nop
	    }
	    switch (cfg->stop_bits)
 800f116:	683b      	ldr	r3, [r7, #0]
 800f118:	791b      	ldrb	r3, [r3, #4]
 800f11a:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800f11e:	b2db      	uxtb	r3, r3
 800f120:	2b00      	cmp	r3, #0
 800f122:	d002      	beq.n	800f12a <stm32_configure+0xa2>
 800f124:	2b01      	cmp	r3, #1
 800f126:	d004      	beq.n	800f132 <stm32_configure+0xaa>
 800f128:	e008      	b.n	800f13c <stm32_configure+0xb4>
	    {
	    case STOP_BITS_1:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 800f12a:	68fb      	ldr	r3, [r7, #12]
 800f12c:	2200      	movs	r2, #0
 800f12e:	60da      	str	r2, [r3, #12]
	        break;
 800f130:	e008      	b.n	800f144 <stm32_configure+0xbc>
	    case STOP_BITS_2:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_2;
 800f132:	68fb      	ldr	r3, [r7, #12]
 800f134:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800f138:	60da      	str	r2, [r3, #12]
	        break;
 800f13a:	e003      	b.n	800f144 <stm32_configure+0xbc>
	    default:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 800f13c:	68fb      	ldr	r3, [r7, #12]
 800f13e:	2200      	movs	r2, #0
 800f140:	60da      	str	r2, [r3, #12]
	        break;
 800f142:	bf00      	nop
	    }
	    switch (cfg->parity)
 800f144:	683b      	ldr	r3, [r7, #0]
 800f146:	791b      	ldrb	r3, [r3, #4]
 800f148:	f3c3 1381 	ubfx	r3, r3, #6, #2
 800f14c:	b2db      	uxtb	r3, r3
 800f14e:	2b01      	cmp	r3, #1
 800f150:	d007      	beq.n	800f162 <stm32_configure+0xda>
 800f152:	2b02      	cmp	r3, #2
 800f154:	d00a      	beq.n	800f16c <stm32_configure+0xe4>
 800f156:	2b00      	cmp	r3, #0
 800f158:	d10d      	bne.n	800f176 <stm32_configure+0xee>
	    {
	    case PARITY_NONE:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 800f15a:	68fb      	ldr	r3, [r7, #12]
 800f15c:	2200      	movs	r2, #0
 800f15e:	611a      	str	r2, [r3, #16]
	        break;
 800f160:	e00d      	b.n	800f17e <stm32_configure+0xf6>
	    case PARITY_ODD:
	        uart->UartHandle.Init.Parity     = UART_PARITY_ODD;
 800f162:	68fb      	ldr	r3, [r7, #12]
 800f164:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 800f168:	611a      	str	r2, [r3, #16]
	        break;
 800f16a:	e008      	b.n	800f17e <stm32_configure+0xf6>
	    case PARITY_EVEN:
	        uart->UartHandle.Init.Parity     = UART_PARITY_EVEN;
 800f16c:	68fb      	ldr	r3, [r7, #12]
 800f16e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800f172:	611a      	str	r2, [r3, #16]
	        break;
 800f174:	e003      	b.n	800f17e <stm32_configure+0xf6>
	    default:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 800f176:	68fb      	ldr	r3, [r7, #12]
 800f178:	2200      	movs	r2, #0
 800f17a:	611a      	str	r2, [r3, #16]
	        break;
 800f17c:	bf00      	nop
	    }
	    if (HAL_UART_DeInit(&uart->UartHandle) != HAL_OK)
 800f17e:	68fb      	ldr	r3, [r7, #12]
 800f180:	4618      	mov	r0, r3
 800f182:	f7fb f8ab 	bl	800a2dc <HAL_UART_DeInit>
 800f186:	4603      	mov	r3, r0
 800f188:	2b00      	cmp	r3, #0
 800f18a:	d001      	beq.n	800f190 <stm32_configure+0x108>
	    {
	        return RT_ERROR;
 800f18c:	2301      	movs	r3, #1
 800f18e:	e07e      	b.n	800f28e <stm32_configure+0x206>
	    }
	    if (HAL_UART_Init(&uart->UartHandle) != HAL_OK)
 800f190:	68fb      	ldr	r3, [r7, #12]
 800f192:	4618      	mov	r0, r3
 800f194:	f7fb f850 	bl	800a238 <HAL_UART_Init>
 800f198:	4603      	mov	r3, r0
 800f19a:	2b00      	cmp	r3, #0
 800f19c:	d001      	beq.n	800f1a2 <stm32_configure+0x11a>
	    {
	        return RT_ERROR;
 800f19e:	2301      	movs	r3, #1
 800f1a0:	e075      	b.n	800f28e <stm32_configure+0x206>
	    }
	}

	if(uart->UartHandle.Instance == USART3)
 800f1a2:	68fb      	ldr	r3, [r7, #12]
 800f1a4:	681b      	ldr	r3, [r3, #0]
 800f1a6:	4a40      	ldr	r2, [pc, #256]	; (800f2a8 <stm32_configure+0x220>)
 800f1a8:	4293      	cmp	r3, r2
 800f1aa:	d16f      	bne.n	800f28c <stm32_configure+0x204>
	{
	    uart->UartHandle.Init.BaudRate   = cfg->baud_rate;
 800f1ac:	683b      	ldr	r3, [r7, #0]
 800f1ae:	681a      	ldr	r2, [r3, #0]
 800f1b0:	68fb      	ldr	r3, [r7, #12]
 800f1b2:	605a      	str	r2, [r3, #4]
	    uart->UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 800f1b4:	68fb      	ldr	r3, [r7, #12]
 800f1b6:	2200      	movs	r2, #0
 800f1b8:	619a      	str	r2, [r3, #24]
	    uart->UartHandle.Init.Mode       = UART_MODE_TX_RX;
 800f1ba:	68fb      	ldr	r3, [r7, #12]
 800f1bc:	220c      	movs	r2, #12
 800f1be:	615a      	str	r2, [r3, #20]
	    uart->UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800f1c0:	68fb      	ldr	r3, [r7, #12]
 800f1c2:	2200      	movs	r2, #0
 800f1c4:	625a      	str	r2, [r3, #36]	; 0x24

	    switch (cfg->data_bits)
 800f1c6:	683b      	ldr	r3, [r7, #0]
 800f1c8:	791b      	ldrb	r3, [r3, #4]
 800f1ca:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800f1ce:	b2db      	uxtb	r3, r3
 800f1d0:	2b08      	cmp	r3, #8
 800f1d2:	d008      	beq.n	800f1e6 <stm32_configure+0x15e>
 800f1d4:	2b09      	cmp	r3, #9
 800f1d6:	d00a      	beq.n	800f1ee <stm32_configure+0x166>
 800f1d8:	2b07      	cmp	r3, #7
 800f1da:	d10d      	bne.n	800f1f8 <stm32_configure+0x170>
	    {
	    case DATA_BITS_7:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_7B;
 800f1dc:	68fb      	ldr	r3, [r7, #12]
 800f1de:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800f1e2:	609a      	str	r2, [r3, #8]
	        break;
 800f1e4:	e00c      	b.n	800f200 <stm32_configure+0x178>
	    case DATA_BITS_8:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800f1e6:	68fb      	ldr	r3, [r7, #12]
 800f1e8:	2200      	movs	r2, #0
 800f1ea:	609a      	str	r2, [r3, #8]
	        break;
 800f1ec:	e008      	b.n	800f200 <stm32_configure+0x178>
	    case DATA_BITS_9:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_9B;
 800f1ee:	68fb      	ldr	r3, [r7, #12]
 800f1f0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800f1f4:	609a      	str	r2, [r3, #8]
	        break;
 800f1f6:	e003      	b.n	800f200 <stm32_configure+0x178>
	    default:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800f1f8:	68fb      	ldr	r3, [r7, #12]
 800f1fa:	2200      	movs	r2, #0
 800f1fc:	609a      	str	r2, [r3, #8]
	        break;
 800f1fe:	bf00      	nop
	    }
	    switch (cfg->stop_bits)
 800f200:	683b      	ldr	r3, [r7, #0]
 800f202:	791b      	ldrb	r3, [r3, #4]
 800f204:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800f208:	b2db      	uxtb	r3, r3
 800f20a:	2b00      	cmp	r3, #0
 800f20c:	d002      	beq.n	800f214 <stm32_configure+0x18c>
 800f20e:	2b01      	cmp	r3, #1
 800f210:	d004      	beq.n	800f21c <stm32_configure+0x194>
 800f212:	e008      	b.n	800f226 <stm32_configure+0x19e>
	    {
	    case STOP_BITS_1:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 800f214:	68fb      	ldr	r3, [r7, #12]
 800f216:	2200      	movs	r2, #0
 800f218:	60da      	str	r2, [r3, #12]
	        break;
 800f21a:	e008      	b.n	800f22e <stm32_configure+0x1a6>
	    case STOP_BITS_2:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_2;
 800f21c:	68fb      	ldr	r3, [r7, #12]
 800f21e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800f222:	60da      	str	r2, [r3, #12]
	        break;
 800f224:	e003      	b.n	800f22e <stm32_configure+0x1a6>
	    default:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 800f226:	68fb      	ldr	r3, [r7, #12]
 800f228:	2200      	movs	r2, #0
 800f22a:	60da      	str	r2, [r3, #12]
	        break;
 800f22c:	bf00      	nop
	    }
	    switch (cfg->parity)
 800f22e:	683b      	ldr	r3, [r7, #0]
 800f230:	791b      	ldrb	r3, [r3, #4]
 800f232:	f3c3 1381 	ubfx	r3, r3, #6, #2
 800f236:	b2db      	uxtb	r3, r3
 800f238:	2b01      	cmp	r3, #1
 800f23a:	d007      	beq.n	800f24c <stm32_configure+0x1c4>
 800f23c:	2b02      	cmp	r3, #2
 800f23e:	d00a      	beq.n	800f256 <stm32_configure+0x1ce>
 800f240:	2b00      	cmp	r3, #0
 800f242:	d10d      	bne.n	800f260 <stm32_configure+0x1d8>
	    {
	    case PARITY_NONE:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 800f244:	68fb      	ldr	r3, [r7, #12]
 800f246:	2200      	movs	r2, #0
 800f248:	611a      	str	r2, [r3, #16]
	        break;
 800f24a:	e00d      	b.n	800f268 <stm32_configure+0x1e0>
	    case PARITY_ODD:
	        uart->UartHandle.Init.Parity     = UART_PARITY_ODD;
 800f24c:	68fb      	ldr	r3, [r7, #12]
 800f24e:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 800f252:	611a      	str	r2, [r3, #16]
	        break;
 800f254:	e008      	b.n	800f268 <stm32_configure+0x1e0>
	    case PARITY_EVEN:
	        uart->UartHandle.Init.Parity     = UART_PARITY_EVEN;
 800f256:	68fb      	ldr	r3, [r7, #12]
 800f258:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800f25c:	611a      	str	r2, [r3, #16]
	        break;
 800f25e:	e003      	b.n	800f268 <stm32_configure+0x1e0>
	    default:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 800f260:	68fb      	ldr	r3, [r7, #12]
 800f262:	2200      	movs	r2, #0
 800f264:	611a      	str	r2, [r3, #16]
	        break;
 800f266:	bf00      	nop
	    }
	    if (HAL_UART_DeInit(&uart->UartHandle) != HAL_OK)
 800f268:	68fb      	ldr	r3, [r7, #12]
 800f26a:	4618      	mov	r0, r3
 800f26c:	f7fb f836 	bl	800a2dc <HAL_UART_DeInit>
 800f270:	4603      	mov	r3, r0
 800f272:	2b00      	cmp	r3, #0
 800f274:	d001      	beq.n	800f27a <stm32_configure+0x1f2>
	    {
	        return RT_ERROR;
 800f276:	2301      	movs	r3, #1
 800f278:	e009      	b.n	800f28e <stm32_configure+0x206>
	    }
	    if (HAL_UART_Init(&uart->UartHandle) != HAL_OK)
 800f27a:	68fb      	ldr	r3, [r7, #12]
 800f27c:	4618      	mov	r0, r3
 800f27e:	f7fa ffdb 	bl	800a238 <HAL_UART_Init>
 800f282:	4603      	mov	r3, r0
 800f284:	2b00      	cmp	r3, #0
 800f286:	d001      	beq.n	800f28c <stm32_configure+0x204>
	    {
	        return RT_ERROR;
 800f288:	2301      	movs	r3, #1
 800f28a:	e000      	b.n	800f28e <stm32_configure+0x206>
	    }

	}
    return RT_EOK;
 800f28c:	2300      	movs	r3, #0
}
 800f28e:	4618      	mov	r0, r3
 800f290:	3710      	adds	r7, #16
 800f292:	46bd      	mov	sp, r7
 800f294:	bd80      	pop	{r7, pc}
 800f296:	bf00      	nop
 800f298:	0802280c 	.word	0x0802280c
 800f29c:	08024420 	.word	0x08024420
 800f2a0:	08022820 	.word	0x08022820
 800f2a4:	40011000 	.word	0x40011000
 800f2a8:	40004800 	.word	0x40004800

0800f2ac <stm32_control>:
{
	rt_hw_serial_isr(&serial3, RT_SERIAL_EVENT_RX_DMADONE | 0x100);
}

static rt_err_t stm32_control(struct rt_serial_device *serial, int cmd, void *arg)
{
 800f2ac:	b580      	push	{r7, lr}
 800f2ae:	b086      	sub	sp, #24
 800f2b0:	af00      	add	r7, sp, #0
 800f2b2:	60f8      	str	r0, [r7, #12]
 800f2b4:	60b9      	str	r1, [r7, #8]
 800f2b6:	607a      	str	r2, [r7, #4]
    struct stm32_uart *uart;
	static DMA_HandleTypeDef hdma_rx;

    RT_ASSERT(serial != RT_NULL);
 800f2b8:	68fb      	ldr	r3, [r7, #12]
 800f2ba:	2b00      	cmp	r3, #0
 800f2bc:	d104      	bne.n	800f2c8 <stm32_control+0x1c>
 800f2be:	4856      	ldr	r0, [pc, #344]	; (800f418 <stm32_control+0x16c>)
 800f2c0:	4956      	ldr	r1, [pc, #344]	; (800f41c <stm32_control+0x170>)
 800f2c2:	22d8      	movs	r2, #216	; 0xd8
 800f2c4:	f004 fd4e 	bl	8013d64 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 800f2c8:	68fb      	ldr	r3, [r7, #12]
 800f2ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f2cc:	617b      	str	r3, [r7, #20]

    switch (cmd)
 800f2ce:	68bb      	ldr	r3, [r7, #8]
 800f2d0:	2b11      	cmp	r3, #17
 800f2d2:	d004      	beq.n	800f2de <stm32_control+0x32>
 800f2d4:	2b14      	cmp	r3, #20
 800f2d6:	d022      	beq.n	800f31e <stm32_control+0x72>
 800f2d8:	2b10      	cmp	r3, #16
 800f2da:	d010      	beq.n	800f2fe <stm32_control+0x52>
 800f2dc:	e097      	b.n	800f40e <stm32_control+0x162>
    {
    case RT_DEVICE_CTRL_CLR_INT:
        /* disable rx irq */
        UART_DISABLE_IRQ(uart->irq);
 800f2de:	697b      	ldr	r3, [r7, #20]
 800f2e0:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 800f2e4:	b25b      	sxtb	r3, r3
 800f2e6:	4618      	mov	r0, r3
 800f2e8:	f7ff feb4 	bl	800f054 <NVIC_DisableIRQ>
        /* disable interrupt */
        __HAL_UART_DISABLE_IT(&uart->UartHandle, UART_IT_RXNE);
 800f2ec:	697b      	ldr	r3, [r7, #20]
 800f2ee:	681b      	ldr	r3, [r3, #0]
 800f2f0:	697a      	ldr	r2, [r7, #20]
 800f2f2:	6812      	ldr	r2, [r2, #0]
 800f2f4:	6812      	ldr	r2, [r2, #0]
 800f2f6:	f022 0220 	bic.w	r2, r2, #32
 800f2fa:	601a      	str	r2, [r3, #0]
        break;
 800f2fc:	e087      	b.n	800f40e <stm32_control+0x162>
    case RT_DEVICE_CTRL_SET_INT:
        /* enable rx irq */
        UART_ENABLE_IRQ(uart->irq);
 800f2fe:	697b      	ldr	r3, [r7, #20]
 800f300:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 800f304:	b25b      	sxtb	r3, r3
 800f306:	4618      	mov	r0, r3
 800f308:	f7ff fe8c 	bl	800f024 <NVIC_EnableIRQ>
        /* enable interrupt */
        __HAL_UART_ENABLE_IT(&uart->UartHandle, UART_IT_RXNE);
 800f30c:	697b      	ldr	r3, [r7, #20]
 800f30e:	681b      	ldr	r3, [r3, #0]
 800f310:	697a      	ldr	r2, [r7, #20]
 800f312:	6812      	ldr	r2, [r2, #0]
 800f314:	6812      	ldr	r2, [r2, #0]
 800f316:	f042 0220 	orr.w	r2, r2, #32
 800f31a:	601a      	str	r2, [r3, #0]
        break;
 800f31c:	e077      	b.n	800f40e <stm32_control+0x162>
    case RT_DEVICE_CTRL_SET_DMARX:

#if 1
		rt_kprintf("in the control\r\n");
 800f31e:	4840      	ldr	r0, [pc, #256]	; (800f420 <stm32_control+0x174>)
 800f320:	f004 fca6 	bl	8013c70 <rt_kprintf>
		__HAL_RCC_DMA1_CLK_ENABLE();
 800f324:	4a3f      	ldr	r2, [pc, #252]	; (800f424 <stm32_control+0x178>)
 800f326:	4b3f      	ldr	r3, [pc, #252]	; (800f424 <stm32_control+0x178>)
 800f328:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f32a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800f32e:	6313      	str	r3, [r2, #48]	; 0x30
 800f330:	4b3c      	ldr	r3, [pc, #240]	; (800f424 <stm32_control+0x178>)
 800f332:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f334:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800f338:	613b      	str	r3, [r7, #16]
 800f33a:	693b      	ldr	r3, [r7, #16]
		
		hdma_rx.Instance = DMA1_Stream1;
 800f33c:	4b3a      	ldr	r3, [pc, #232]	; (800f428 <stm32_control+0x17c>)
 800f33e:	4a3b      	ldr	r2, [pc, #236]	; (800f42c <stm32_control+0x180>)
 800f340:	601a      	str	r2, [r3, #0]
		uart->UartHandle.RxXferSize = 1;
 800f342:	697b      	ldr	r3, [r7, #20]
 800f344:	2201      	movs	r2, #1
 800f346:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
		uart->UartHandle.Instance->CR3 |= USART_CR3_DMAR;
 800f34a:	697b      	ldr	r3, [r7, #20]
 800f34c:	681b      	ldr	r3, [r3, #0]
 800f34e:	697a      	ldr	r2, [r7, #20]
 800f350:	6812      	ldr	r2, [r2, #0]
 800f352:	6892      	ldr	r2, [r2, #8]
 800f354:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800f358:	609a      	str	r2, [r3, #8]
		
		hdma_rx.Init.Channel = DMA_CHANNEL_4;
 800f35a:	4b33      	ldr	r3, [pc, #204]	; (800f428 <stm32_control+0x17c>)
 800f35c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800f360:	605a      	str	r2, [r3, #4]
		hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800f362:	4b31      	ldr	r3, [pc, #196]	; (800f428 <stm32_control+0x17c>)
 800f364:	2200      	movs	r2, #0
 800f366:	609a      	str	r2, [r3, #8]
		hdma_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 800f368:	4b2f      	ldr	r3, [pc, #188]	; (800f428 <stm32_control+0x17c>)
 800f36a:	2204      	movs	r2, #4
 800f36c:	625a      	str	r2, [r3, #36]	; 0x24
		hdma_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
 800f36e:	4b2e      	ldr	r3, [pc, #184]	; (800f428 <stm32_control+0x17c>)
 800f370:	2201      	movs	r2, #1
 800f372:	629a      	str	r2, [r3, #40]	; 0x28
		hdma_rx.Init.MemBurst = DMA_MBURST_SINGLE;
 800f374:	4b2c      	ldr	r3, [pc, #176]	; (800f428 <stm32_control+0x17c>)
 800f376:	2200      	movs	r2, #0
 800f378:	62da      	str	r2, [r3, #44]	; 0x2c
		hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800f37a:	4b2b      	ldr	r3, [pc, #172]	; (800f428 <stm32_control+0x17c>)
 800f37c:	2200      	movs	r2, #0
 800f37e:	619a      	str	r2, [r3, #24]
		hdma_rx.Init.MemInc = DMA_MINC_ENABLE;
 800f380:	4b29      	ldr	r3, [pc, #164]	; (800f428 <stm32_control+0x17c>)
 800f382:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800f386:	611a      	str	r2, [r3, #16]
		hdma_rx.Init.Mode = DMA_NORMAL;
 800f388:	4b27      	ldr	r3, [pc, #156]	; (800f428 <stm32_control+0x17c>)
 800f38a:	2200      	movs	r2, #0
 800f38c:	61da      	str	r2, [r3, #28]
		hdma_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
 800f38e:	4b26      	ldr	r3, [pc, #152]	; (800f428 <stm32_control+0x17c>)
 800f390:	2200      	movs	r2, #0
 800f392:	631a      	str	r2, [r3, #48]	; 0x30
		hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800f394:	4b24      	ldr	r3, [pc, #144]	; (800f428 <stm32_control+0x17c>)
 800f396:	2200      	movs	r2, #0
 800f398:	615a      	str	r2, [r3, #20]
		hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 800f39a:	4b23      	ldr	r3, [pc, #140]	; (800f428 <stm32_control+0x17c>)
 800f39c:	2200      	movs	r2, #0
 800f39e:	60da      	str	r2, [r3, #12]
		hdma_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
 800f3a0:	4b21      	ldr	r3, [pc, #132]	; (800f428 <stm32_control+0x17c>)
 800f3a2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800f3a6:	621a      	str	r2, [r3, #32]
		
		
		if (HAL_DMA_DeInit(&hdma_rx) != HAL_OK)
 800f3a8:	481f      	ldr	r0, [pc, #124]	; (800f428 <stm32_control+0x17c>)
 800f3aa:	f7f4 fa3d 	bl	8003828 <HAL_DMA_DeInit>
 800f3ae:	4603      	mov	r3, r0
 800f3b0:	2b00      	cmp	r3, #0
 800f3b2:	d001      	beq.n	800f3b8 <stm32_control+0x10c>
		{
			return RT_ERROR;
 800f3b4:	2301      	movs	r3, #1
 800f3b6:	e02b      	b.n	800f410 <stm32_control+0x164>
		}
		if (HAL_DMA_Init(&hdma_rx) != HAL_OK)
 800f3b8:	481b      	ldr	r0, [pc, #108]	; (800f428 <stm32_control+0x17c>)
 800f3ba:	f7f4 f9c9 	bl	8003750 <HAL_DMA_Init>
 800f3be:	4603      	mov	r3, r0
 800f3c0:	2b00      	cmp	r3, #0
 800f3c2:	d001      	beq.n	800f3c8 <stm32_control+0x11c>
		{
			return RT_ERROR;
 800f3c4:	2301      	movs	r3, #1
 800f3c6:	e023      	b.n	800f410 <stm32_control+0x164>
		}
		__HAL_LINKDMA(&uart->UartHandle, hdmarx, hdma_rx);
 800f3c8:	697b      	ldr	r3, [r7, #20]
 800f3ca:	4a17      	ldr	r2, [pc, #92]	; (800f428 <stm32_control+0x17c>)
 800f3cc:	665a      	str	r2, [r3, #100]	; 0x64
 800f3ce:	697b      	ldr	r3, [r7, #20]
 800f3d0:	4a15      	ldr	r2, [pc, #84]	; (800f428 <stm32_control+0x17c>)
 800f3d2:	6393      	str	r3, [r2, #56]	; 0x38
		uart->UartHandle.pRxBuffPtr = (uint8_t *)rt_malloc((uart->UartHandle.RxXferSize)*sizeof(uint8_t));
 800f3d4:	697b      	ldr	r3, [r7, #20]
 800f3d6:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 800f3da:	4618      	mov	r0, r3
 800f3dc:	f004 fdf6 	bl	8013fcc <rt_malloc>
 800f3e0:	4602      	mov	r2, r0
 800f3e2:	697b      	ldr	r3, [r7, #20]
 800f3e4:	655a      	str	r2, [r3, #84]	; 0x54
		  /* NVIC configuration for DMA transfer complete interrupt (USART6_RX) */
 		HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, DMA1STREAM1_IRQ_PREEMPT, DMA1STREAM1_IRQ_SUB);
 800f3e6:	200c      	movs	r0, #12
 800f3e8:	210f      	movs	r1, #15
 800f3ea:	2200      	movs	r2, #0
 800f3ec:	f7f4 f8fc 	bl	80035e8 <HAL_NVIC_SetPriority>
 		HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 800f3f0:	200c      	movs	r0, #12
 800f3f2:	f7f4 f915 	bl	8003620 <HAL_NVIC_EnableIRQ>
		HAL_UART_Receive_DMA(&uart->UartHandle,(uint8_t *)uart->UartHandle.pRxBuffPtr, uart->UartHandle.RxXferSize);
 800f3f6:	6979      	ldr	r1, [r7, #20]
 800f3f8:	697b      	ldr	r3, [r7, #20]
 800f3fa:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800f3fc:	697b      	ldr	r3, [r7, #20]
 800f3fe:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 800f402:	4608      	mov	r0, r1
 800f404:	4611      	mov	r1, r2
 800f406:	461a      	mov	r2, r3
 800f408:	f7fa ff9c 	bl	800a344 <HAL_UART_Receive_DMA>
#endif
		
	    break;
 800f40c:	bf00      	nop
    }

    return RT_EOK;
 800f40e:	2300      	movs	r3, #0
}
 800f410:	4618      	mov	r0, r3
 800f412:	3718      	adds	r7, #24
 800f414:	46bd      	mov	sp, r7
 800f416:	bd80      	pop	{r7, pc}
 800f418:	0802280c 	.word	0x0802280c
 800f41c:	08024430 	.word	0x08024430
 800f420:	08022830 	.word	0x08022830
 800f424:	40023800 	.word	0x40023800
 800f428:	20010994 	.word	0x20010994
 800f42c:	40026028 	.word	0x40026028

0800f430 <stm32_putc>:

static int stm32_putc(struct rt_serial_device *serial, char c)
{
 800f430:	b580      	push	{r7, lr}
 800f432:	b084      	sub	sp, #16
 800f434:	af00      	add	r7, sp, #0
 800f436:	6078      	str	r0, [r7, #4]
 800f438:	460b      	mov	r3, r1
 800f43a:	70fb      	strb	r3, [r7, #3]
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 800f43c:	687b      	ldr	r3, [r7, #4]
 800f43e:	2b00      	cmp	r3, #0
 800f440:	d105      	bne.n	800f44e <stm32_putc+0x1e>
 800f442:	480d      	ldr	r0, [pc, #52]	; (800f478 <stm32_putc+0x48>)
 800f444:	490d      	ldr	r1, [pc, #52]	; (800f47c <stm32_putc+0x4c>)
 800f446:	f240 121b 	movw	r2, #283	; 0x11b
 800f44a:	f004 fc8b 	bl	8013d64 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 800f44e:	687b      	ldr	r3, [r7, #4]
 800f450:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f452:	60fb      	str	r3, [r7, #12]

    while (!(uart->UartHandle.Instance->ISR & UART_FLAG_TXE));
 800f454:	bf00      	nop
 800f456:	68fb      	ldr	r3, [r7, #12]
 800f458:	681b      	ldr	r3, [r3, #0]
 800f45a:	69db      	ldr	r3, [r3, #28]
 800f45c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800f460:	2b00      	cmp	r3, #0
 800f462:	d0f8      	beq.n	800f456 <stm32_putc+0x26>
    uart->UartHandle.Instance->TDR = c;
 800f464:	68fb      	ldr	r3, [r7, #12]
 800f466:	681b      	ldr	r3, [r3, #0]
 800f468:	78fa      	ldrb	r2, [r7, #3]
 800f46a:	629a      	str	r2, [r3, #40]	; 0x28

    return 1;
 800f46c:	2301      	movs	r3, #1
}
 800f46e:	4618      	mov	r0, r3
 800f470:	3710      	adds	r7, #16
 800f472:	46bd      	mov	sp, r7
 800f474:	bd80      	pop	{r7, pc}
 800f476:	bf00      	nop
 800f478:	0802280c 	.word	0x0802280c
 800f47c:	08024440 	.word	0x08024440

0800f480 <stm32_getc>:
/*test code by he*/

extern int usartTest;

static int stm32_getc(struct rt_serial_device *serial)
{
 800f480:	b580      	push	{r7, lr}
 800f482:	b084      	sub	sp, #16
 800f484:	af00      	add	r7, sp, #0
 800f486:	6078      	str	r0, [r7, #4]
    int ch;
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 800f488:	687b      	ldr	r3, [r7, #4]
 800f48a:	2b00      	cmp	r3, #0
 800f48c:	d105      	bne.n	800f49a <stm32_getc+0x1a>
 800f48e:	480e      	ldr	r0, [pc, #56]	; (800f4c8 <stm32_getc+0x48>)
 800f490:	490e      	ldr	r1, [pc, #56]	; (800f4cc <stm32_getc+0x4c>)
 800f492:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800f496:	f004 fc65 	bl	8013d64 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 800f49a:	687b      	ldr	r3, [r7, #4]
 800f49c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f49e:	60bb      	str	r3, [r7, #8]

    ch = -1;
 800f4a0:	f04f 33ff 	mov.w	r3, #4294967295
 800f4a4:	60fb      	str	r3, [r7, #12]
    if (uart->UartHandle.Instance->ISR & UART_FLAG_RXNE)
 800f4a6:	68bb      	ldr	r3, [r7, #8]
 800f4a8:	681b      	ldr	r3, [r3, #0]
 800f4aa:	69db      	ldr	r3, [r3, #28]
 800f4ac:	f003 0320 	and.w	r3, r3, #32
 800f4b0:	2b00      	cmp	r3, #0
 800f4b2:	d004      	beq.n	800f4be <stm32_getc+0x3e>
    {
        ch = uart->UartHandle.Instance->RDR & 0xff;
 800f4b4:	68bb      	ldr	r3, [r7, #8]
 800f4b6:	681b      	ldr	r3, [r3, #0]
 800f4b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f4ba:	b2db      	uxtb	r3, r3
 800f4bc:	60fb      	str	r3, [r7, #12]
    }
	/*test code by he*/
		//usartTest++;
    return ch;
 800f4be:	68fb      	ldr	r3, [r7, #12]
}
 800f4c0:	4618      	mov	r0, r3
 800f4c2:	3710      	adds	r7, #16
 800f4c4:	46bd      	mov	sp, r7
 800f4c6:	bd80      	pop	{r7, pc}
 800f4c8:	0802280c 	.word	0x0802280c
 800f4cc:	0802444c 	.word	0x0802444c

0800f4d0 <stm32_dma_transmit>:

static rt_size_t stm32_dma_transmit(struct rt_serial_device *serial, const rt_uint8_t *buf, rt_size_t size, int direction)
{
 800f4d0:	b580      	push	{r7, lr}
 800f4d2:	b088      	sub	sp, #32
 800f4d4:	af00      	add	r7, sp, #0
 800f4d6:	60f8      	str	r0, [r7, #12]
 800f4d8:	60b9      	str	r1, [r7, #8]
 800f4da:	607a      	str	r2, [r7, #4]
 800f4dc:	603b      	str	r3, [r7, #0]
	static i=0;
	uint8_t                  *pRxPtr, *data;
	struct stm32_uart *uart;
	
    RT_ASSERT(serial != RT_NULL);
 800f4de:	68fb      	ldr	r3, [r7, #12]
 800f4e0:	2b00      	cmp	r3, #0
 800f4e2:	d105      	bne.n	800f4f0 <stm32_dma_transmit+0x20>
 800f4e4:	480d      	ldr	r0, [pc, #52]	; (800f51c <stm32_dma_transmit+0x4c>)
 800f4e6:	490e      	ldr	r1, [pc, #56]	; (800f520 <stm32_dma_transmit+0x50>)
 800f4e8:	f240 123f 	movw	r2, #319	; 0x13f
 800f4ec:	f004 fc3a 	bl	8013d64 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 800f4f0:	68fb      	ldr	r3, [r7, #12]
 800f4f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f4f4:	61fb      	str	r3, [r7, #28]
	if (direction == RT_SERIAL_DMA_RX)
 800f4f6:	683b      	ldr	r3, [r7, #0]
 800f4f8:	2b01      	cmp	r3, #1
 800f4fa:	d10b      	bne.n	800f514 <stm32_dma_transmit+0x44>
	{
		pRxPtr = uart->UartHandle.pRxBuffPtr;
 800f4fc:	69fb      	ldr	r3, [r7, #28]
 800f4fe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f500:	61bb      	str	r3, [r7, #24]
		data = buf;
 800f502:	68bb      	ldr	r3, [r7, #8]
 800f504:	617b      	str	r3, [r7, #20]
		*data = 0;
 800f506:	697b      	ldr	r3, [r7, #20]
 800f508:	2200      	movs	r2, #0
 800f50a:	701a      	strb	r2, [r3, #0]
			size--;
			if (i>=uart->UartHandle.RxXferSize)
			i = 0;
		}
		#endif
		*data = *pRxPtr;
 800f50c:	69bb      	ldr	r3, [r7, #24]
 800f50e:	781a      	ldrb	r2, [r3, #0]
 800f510:	697b      	ldr	r3, [r7, #20]
 800f512:	701a      	strb	r2, [r3, #0]
	}
}
 800f514:	4618      	mov	r0, r3
 800f516:	3720      	adds	r7, #32
 800f518:	46bd      	mov	sp, r7
 800f51a:	bd80      	pop	{r7, pc}
 800f51c:	0802280c 	.word	0x0802280c
 800f520:	08024458 	.word	0x08024458

0800f524 <USART1_IRQHandler>:




void USART1_IRQHandler(void)
{
 800f524:	b580      	push	{r7, lr}
 800f526:	b082      	sub	sp, #8
 800f528:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;

    uart = &uart1;
 800f52a:	4b11      	ldr	r3, [pc, #68]	; (800f570 <USART1_IRQHandler+0x4c>)
 800f52c:	607b      	str	r3, [r7, #4]

    /* enter interrupt */
    rt_interrupt_enter();
 800f52e:	f003 fd8f 	bl	8013050 <rt_interrupt_enter>

    /* UART in mode Receiver ---------------------------------------------------*/
    if ((__HAL_UART_GET_IT(&uart->UartHandle, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(&uart->UartHandle, UART_IT_RXNE) != RESET))
 800f532:	687b      	ldr	r3, [r7, #4]
 800f534:	681b      	ldr	r3, [r3, #0]
 800f536:	69db      	ldr	r3, [r3, #28]
 800f538:	f003 0320 	and.w	r3, r3, #32
 800f53c:	2b00      	cmp	r3, #0
 800f53e:	d012      	beq.n	800f566 <USART1_IRQHandler+0x42>
 800f540:	687b      	ldr	r3, [r7, #4]
 800f542:	681b      	ldr	r3, [r3, #0]
 800f544:	681b      	ldr	r3, [r3, #0]
 800f546:	f003 0320 	and.w	r3, r3, #32
 800f54a:	2b00      	cmp	r3, #0
 800f54c:	d00b      	beq.n	800f566 <USART1_IRQHandler+0x42>
    {
        rt_hw_serial_isr(&serial1, RT_SERIAL_EVENT_RX_IND);
 800f54e:	4809      	ldr	r0, [pc, #36]	; (800f574 <USART1_IRQHandler+0x50>)
 800f550:	2101      	movs	r1, #1
 800f552:	f008 f8c1 	bl	80176d8 <rt_hw_serial_isr>
        /* Clear RXNE interrupt flag */
        __HAL_UART_SEND_REQ(&uart->UartHandle, UART_RXDATA_FLUSH_REQUEST);
 800f556:	687b      	ldr	r3, [r7, #4]
 800f558:	681b      	ldr	r3, [r3, #0]
 800f55a:	687a      	ldr	r2, [r7, #4]
 800f55c:	6812      	ldr	r2, [r2, #0]
 800f55e:	6992      	ldr	r2, [r2, #24]
 800f560:	f042 0208 	orr.w	r2, r2, #8
 800f564:	619a      	str	r2, [r3, #24]
    }
    /* leave interrupt */
    rt_interrupt_leave();
 800f566:	f003 fd89 	bl	801307c <rt_interrupt_leave>
}
 800f56a:	3708      	adds	r7, #8
 800f56c:	46bd      	mov	sp, r7
 800f56e:	bd80      	pop	{r7, pc}
 800f570:	200108ac 	.word	0x200108ac
 800f574:	200123bc 	.word	0x200123bc

0800f578 <USART3_IRQHandler>:
#if defined(RT_USING_UART3)
/* UART1 device driver structure */


void USART3_IRQHandler(void)
{
 800f578:	b580      	push	{r7, lr}
 800f57a:	b082      	sub	sp, #8
 800f57c:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;
	static char i=0;
    uart = &uart3;
 800f57e:	4b16      	ldr	r3, [pc, #88]	; (800f5d8 <USART3_IRQHandler+0x60>)
 800f580:	607b      	str	r3, [r7, #4]

    /* enter interrupt */
    rt_interrupt_enter();
 800f582:	f003 fd65 	bl	8013050 <rt_interrupt_enter>
	usartTest = i++;
 800f586:	4b15      	ldr	r3, [pc, #84]	; (800f5dc <USART3_IRQHandler+0x64>)
 800f588:	781b      	ldrb	r3, [r3, #0]
 800f58a:	1c5a      	adds	r2, r3, #1
 800f58c:	b2d1      	uxtb	r1, r2
 800f58e:	4a13      	ldr	r2, [pc, #76]	; (800f5dc <USART3_IRQHandler+0x64>)
 800f590:	7011      	strb	r1, [r2, #0]
 800f592:	461a      	mov	r2, r3
 800f594:	4b12      	ldr	r3, [pc, #72]	; (800f5e0 <USART3_IRQHandler+0x68>)
 800f596:	601a      	str	r2, [r3, #0]
	
    /* UART in mode Receiver ---------------------------------------------------*/
    if ((__HAL_UART_GET_IT(&uart->UartHandle, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(&uart->UartHandle, UART_IT_RXNE) != RESET))
 800f598:	687b      	ldr	r3, [r7, #4]
 800f59a:	681b      	ldr	r3, [r3, #0]
 800f59c:	69db      	ldr	r3, [r3, #28]
 800f59e:	f003 0320 	and.w	r3, r3, #32
 800f5a2:	2b00      	cmp	r3, #0
 800f5a4:	d012      	beq.n	800f5cc <USART3_IRQHandler+0x54>
 800f5a6:	687b      	ldr	r3, [r7, #4]
 800f5a8:	681b      	ldr	r3, [r3, #0]
 800f5aa:	681b      	ldr	r3, [r3, #0]
 800f5ac:	f003 0320 	and.w	r3, r3, #32
 800f5b0:	2b00      	cmp	r3, #0
 800f5b2:	d00b      	beq.n	800f5cc <USART3_IRQHandler+0x54>
    {
        rt_hw_serial_isr(&serial3, RT_SERIAL_EVENT_RX_IND);
 800f5b4:	480b      	ldr	r0, [pc, #44]	; (800f5e4 <USART3_IRQHandler+0x6c>)
 800f5b6:	2101      	movs	r1, #1
 800f5b8:	f008 f88e 	bl	80176d8 <rt_hw_serial_isr>
        /* Clear RXNE interrupt flag */
        __HAL_UART_SEND_REQ(&uart->UartHandle, UART_RXDATA_FLUSH_REQUEST);
 800f5bc:	687b      	ldr	r3, [r7, #4]
 800f5be:	681b      	ldr	r3, [r3, #0]
 800f5c0:	687a      	ldr	r2, [r7, #4]
 800f5c2:	6812      	ldr	r2, [r2, #0]
 800f5c4:	6992      	ldr	r2, [r2, #24]
 800f5c6:	f042 0208 	orr.w	r2, r2, #8
 800f5ca:	619a      	str	r2, [r3, #24]
    }
	
    /* leave interrupt */
    rt_interrupt_leave();
 800f5cc:	f003 fd56 	bl	801307c <rt_interrupt_leave>
}
 800f5d0:	3708      	adds	r7, #8
 800f5d2:	46bd      	mov	sp, r7
 800f5d4:	bd80      	pop	{r7, pc}
 800f5d6:	bf00      	nop
 800f5d8:	20010920 	.word	0x20010920
 800f5dc:	200109e4 	.word	0x200109e4
 800f5e0:	200109ec 	.word	0x200109ec
 800f5e4:	20012410 	.word	0x20012410

0800f5e8 <DMA1_Stream1_IRQHandler>:
#endif /* RT_USING_UART3 */

void DMA1_Stream1_IRQHandler(void)
{
 800f5e8:	b580      	push	{r7, lr}
 800f5ea:	b082      	sub	sp, #8
 800f5ec:	af00      	add	r7, sp, #0
	
    struct stm32_uart *uart;
	
	/* enter interrupt */
    rt_interrupt_enter();
 800f5ee:	f003 fd2f 	bl	8013050 <rt_interrupt_enter>
	static char i=0;
    uart = &uart3;
 800f5f2:	4b0a      	ldr	r3, [pc, #40]	; (800f61c <DMA1_Stream1_IRQHandler+0x34>)
 800f5f4:	607b      	str	r3, [r7, #4]
	
	usartTest = i++;
 800f5f6:	4b0a      	ldr	r3, [pc, #40]	; (800f620 <DMA1_Stream1_IRQHandler+0x38>)
 800f5f8:	781b      	ldrb	r3, [r3, #0]
 800f5fa:	1c5a      	adds	r2, r3, #1
 800f5fc:	b2d1      	uxtb	r1, r2
 800f5fe:	4a08      	ldr	r2, [pc, #32]	; (800f620 <DMA1_Stream1_IRQHandler+0x38>)
 800f600:	7011      	strb	r1, [r2, #0]
 800f602:	461a      	mov	r2, r3
 800f604:	4b07      	ldr	r3, [pc, #28]	; (800f624 <DMA1_Stream1_IRQHandler+0x3c>)
 800f606:	601a      	str	r2, [r3, #0]
	HAL_DMA_IRQHandler((uart->UartHandle.hdmarx));
 800f608:	687b      	ldr	r3, [r7, #4]
 800f60a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800f60c:	4618      	mov	r0, r3
 800f60e:	f7f5 fb6b 	bl	8004ce8 <HAL_DMA_IRQHandler>
		
	/* leave interrupt */
	rt_interrupt_leave();
 800f612:	f003 fd33 	bl	801307c <rt_interrupt_leave>
}
 800f616:	3708      	adds	r7, #8
 800f618:	46bd      	mov	sp, r7
 800f61a:	bd80      	pop	{r7, pc}
 800f61c:	20010920 	.word	0x20010920
 800f620:	200109e5 	.word	0x200109e5
 800f624:	200109ec 	.word	0x200109ec

0800f628 <HAL_UART_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 800f628:	b580      	push	{r7, lr}
 800f62a:	b08e      	sub	sp, #56	; 0x38
 800f62c:	af00      	add	r7, sp, #0
 800f62e:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
    if (huart->Instance == USART1)
 800f630:	687b      	ldr	r3, [r7, #4]
 800f632:	681b      	ldr	r3, [r3, #0]
 800f634:	4a4d      	ldr	r2, [pc, #308]	; (800f76c <HAL_UART_MspInit+0x144>)
 800f636:	4293      	cmp	r3, r2
 800f638:	d147      	bne.n	800f6ca <HAL_UART_MspInit+0xa2>
    {
		/* Enable GPIO TX/RX clock */
        USART1_TX_GPIO_CLK_ENABLE();
 800f63a:	4a4d      	ldr	r2, [pc, #308]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f63c:	4b4c      	ldr	r3, [pc, #304]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f63e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f640:	f043 0301 	orr.w	r3, r3, #1
 800f644:	6313      	str	r3, [r2, #48]	; 0x30
 800f646:	4b4a      	ldr	r3, [pc, #296]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f648:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f64a:	f003 0301 	and.w	r3, r3, #1
 800f64e:	623b      	str	r3, [r7, #32]
 800f650:	6a3b      	ldr	r3, [r7, #32]
        USART1_RX_GPIO_CLK_ENABLE();
 800f652:	4a47      	ldr	r2, [pc, #284]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f654:	4b46      	ldr	r3, [pc, #280]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f656:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f658:	f043 0302 	orr.w	r3, r3, #2
 800f65c:	6313      	str	r3, [r2, #48]	; 0x30
 800f65e:	4b44      	ldr	r3, [pc, #272]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f660:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f662:	f003 0302 	and.w	r3, r3, #2
 800f666:	61fb      	str	r3, [r7, #28]
 800f668:	69fb      	ldr	r3, [r7, #28]
        /* Enable USARTx clock */
        USART1_CLK_ENABLE();
 800f66a:	4a41      	ldr	r2, [pc, #260]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f66c:	4b40      	ldr	r3, [pc, #256]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f66e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f670:	f043 0310 	orr.w	r3, r3, #16
 800f674:	6453      	str	r3, [r2, #68]	; 0x44
 800f676:	4b3e      	ldr	r3, [pc, #248]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f678:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f67a:	f003 0310 	and.w	r3, r3, #16
 800f67e:	61bb      	str	r3, [r7, #24]
 800f680:	69bb      	ldr	r3, [r7, #24]

        /* UART TX GPIO pin configuration  */
        GPIO_InitStruct.Pin       = USART1_TX_PIN;
 800f682:	f44f 7300 	mov.w	r3, #512	; 0x200
 800f686:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800f688:	2302      	movs	r3, #2
 800f68a:	62bb      	str	r3, [r7, #40]	; 0x28
        GPIO_InitStruct.Pull      = GPIO_PULLUP;
 800f68c:	2301      	movs	r3, #1
 800f68e:	62fb      	str	r3, [r7, #44]	; 0x2c
        GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 800f690:	2303      	movs	r3, #3
 800f692:	633b      	str	r3, [r7, #48]	; 0x30
        GPIO_InitStruct.Alternate = USART1_TX_AF;
 800f694:	2307      	movs	r3, #7
 800f696:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART1_TX_GPIO_PORT, &GPIO_InitStruct);
 800f698:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f69c:	4835      	ldr	r0, [pc, #212]	; (800f774 <HAL_UART_MspInit+0x14c>)
 800f69e:	4619      	mov	r1, r3
 800f6a0:	f7f8 fc86 	bl	8007fb0 <HAL_GPIO_Init>

        /* UART RX GPIO pin configuration  */
        GPIO_InitStruct.Pin = USART1_RX_PIN;
 800f6a4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800f6a8:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Alternate = USART1_RX_AF;
 800f6aa:	2307      	movs	r3, #7
 800f6ac:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART1_RX_GPIO_PORT, &GPIO_InitStruct);
 800f6ae:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f6b2:	4830      	ldr	r0, [pc, #192]	; (800f774 <HAL_UART_MspInit+0x14c>)
 800f6b4:	4619      	mov	r1, r3
 800f6b6:	f7f8 fc7b 	bl	8007fb0 <HAL_GPIO_Init>

        /* NVIC for USART */
        HAL_NVIC_SetPriority(USART1_IRQn, USART1_IRQ_PREEMPT ,USART1_TRQ_SUB);
 800f6ba:	2025      	movs	r0, #37	; 0x25
 800f6bc:	210f      	movs	r1, #15
 800f6be:	2200      	movs	r2, #0
 800f6c0:	f7f3 ff92 	bl	80035e8 <HAL_NVIC_SetPriority>
       HAL_NVIC_EnableIRQ(USART1_IRQn);
 800f6c4:	2025      	movs	r0, #37	; 0x25
 800f6c6:	f7f3 ffab 	bl	8003620 <HAL_NVIC_EnableIRQ>
	   //HAL_UART3_MspInit(huart);
    }
	
    if (huart->Instance == USART3)
 800f6ca:	687b      	ldr	r3, [r7, #4]
 800f6cc:	681b      	ldr	r3, [r3, #0]
 800f6ce:	4a2a      	ldr	r2, [pc, #168]	; (800f778 <HAL_UART_MspInit+0x150>)
 800f6d0:	4293      	cmp	r3, r2
 800f6d2:	d147      	bne.n	800f764 <HAL_UART_MspInit+0x13c>
    {
		/* Enable GPIO TX/RX clock */
        USART3_TX_GPIO_CLK_ENABLE();
 800f6d4:	4a26      	ldr	r2, [pc, #152]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f6d6:	4b26      	ldr	r3, [pc, #152]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f6d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f6da:	f043 0304 	orr.w	r3, r3, #4
 800f6de:	6313      	str	r3, [r2, #48]	; 0x30
 800f6e0:	4b23      	ldr	r3, [pc, #140]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f6e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f6e4:	f003 0304 	and.w	r3, r3, #4
 800f6e8:	617b      	str	r3, [r7, #20]
 800f6ea:	697b      	ldr	r3, [r7, #20]
        USART3_RX_GPIO_CLK_ENABLE();
 800f6ec:	4a20      	ldr	r2, [pc, #128]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f6ee:	4b20      	ldr	r3, [pc, #128]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f6f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f6f2:	f043 0304 	orr.w	r3, r3, #4
 800f6f6:	6313      	str	r3, [r2, #48]	; 0x30
 800f6f8:	4b1d      	ldr	r3, [pc, #116]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f6fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f6fc:	f003 0304 	and.w	r3, r3, #4
 800f700:	613b      	str	r3, [r7, #16]
 800f702:	693b      	ldr	r3, [r7, #16]
        /* Enable USARTx clock */
        USART3_CLK_ENABLE();
 800f704:	4a1a      	ldr	r2, [pc, #104]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f706:	4b1a      	ldr	r3, [pc, #104]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f708:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f70a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800f70e:	6413      	str	r3, [r2, #64]	; 0x40
 800f710:	4b17      	ldr	r3, [pc, #92]	; (800f770 <HAL_UART_MspInit+0x148>)
 800f712:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f714:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800f718:	60fb      	str	r3, [r7, #12]
 800f71a:	68fb      	ldr	r3, [r7, #12]

        /* UART TX GPIO pin configuration  */
        GPIO_InitStruct.Pin       = USART3_TX_PIN;
 800f71c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800f720:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800f722:	2302      	movs	r3, #2
 800f724:	62bb      	str	r3, [r7, #40]	; 0x28
        GPIO_InitStruct.Pull      = GPIO_PULLUP;
 800f726:	2301      	movs	r3, #1
 800f728:	62fb      	str	r3, [r7, #44]	; 0x2c
        GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 800f72a:	2303      	movs	r3, #3
 800f72c:	633b      	str	r3, [r7, #48]	; 0x30
        GPIO_InitStruct.Alternate = USART3_TX_AF;
 800f72e:	2307      	movs	r3, #7
 800f730:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART3_TX_GPIO_PORT, &GPIO_InitStruct);
 800f732:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f736:	4811      	ldr	r0, [pc, #68]	; (800f77c <HAL_UART_MspInit+0x154>)
 800f738:	4619      	mov	r1, r3
 800f73a:	f7f8 fc39 	bl	8007fb0 <HAL_GPIO_Init>

        /* UART RX GPIO pin configuration  */
        GPIO_InitStruct.Pin = USART3_RX_PIN;
 800f73e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800f742:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Alternate = USART3_RX_AF;
 800f744:	2307      	movs	r3, #7
 800f746:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART3_RX_GPIO_PORT, &GPIO_InitStruct);
 800f748:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f74c:	480b      	ldr	r0, [pc, #44]	; (800f77c <HAL_UART_MspInit+0x154>)
 800f74e:	4619      	mov	r1, r3
 800f750:	f7f8 fc2e 	bl	8007fb0 <HAL_GPIO_Init>

        /* NVIC for USART */
        HAL_NVIC_SetPriority(USART3_IRQn, USART3_IRQ_PREEMPT ,USART3_TRQ_SUB);
 800f754:	2027      	movs	r0, #39	; 0x27
 800f756:	210f      	movs	r1, #15
 800f758:	2200      	movs	r2, #0
 800f75a:	f7f3 ff45 	bl	80035e8 <HAL_NVIC_SetPriority>
      	HAL_NVIC_EnableIRQ(USART3_IRQn);
 800f75e:	2027      	movs	r0, #39	; 0x27
 800f760:	f7f3 ff5e 	bl	8003620 <HAL_NVIC_EnableIRQ>
    }
}
 800f764:	3738      	adds	r7, #56	; 0x38
 800f766:	46bd      	mov	sp, r7
 800f768:	bd80      	pop	{r7, pc}
 800f76a:	bf00      	nop
 800f76c:	40011000 	.word	0x40011000
 800f770:	40023800 	.word	0x40023800
 800f774:	40020000 	.word	0x40020000
 800f778:	40004800 	.word	0x40004800
 800f77c:	40020800 	.word	0x40020800

0800f780 <HAL_UART_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{
 800f780:	b580      	push	{r7, lr}
 800f782:	b082      	sub	sp, #8
 800f784:	af00      	add	r7, sp, #0
 800f786:	6078      	str	r0, [r7, #4]
    if (huart->Instance == USART1)
 800f788:	687b      	ldr	r3, [r7, #4]
 800f78a:	681b      	ldr	r3, [r3, #0]
 800f78c:	4a1e      	ldr	r2, [pc, #120]	; (800f808 <HAL_UART_MspDeInit+0x88>)
 800f78e:	4293      	cmp	r3, r2
 800f790:	d118      	bne.n	800f7c4 <HAL_UART_MspDeInit+0x44>
    {
        /* Reset peripherals */
        USART1_FORCE_RESET();
 800f792:	4a1e      	ldr	r2, [pc, #120]	; (800f80c <HAL_UART_MspDeInit+0x8c>)
 800f794:	4b1d      	ldr	r3, [pc, #116]	; (800f80c <HAL_UART_MspDeInit+0x8c>)
 800f796:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f798:	f043 0310 	orr.w	r3, r3, #16
 800f79c:	6253      	str	r3, [r2, #36]	; 0x24
        USART1_RELEASE_RESET();
 800f79e:	4a1b      	ldr	r2, [pc, #108]	; (800f80c <HAL_UART_MspDeInit+0x8c>)
 800f7a0:	4b1a      	ldr	r3, [pc, #104]	; (800f80c <HAL_UART_MspDeInit+0x8c>)
 800f7a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f7a4:	f023 0310 	bic.w	r3, r3, #16
 800f7a8:	6253      	str	r3, [r2, #36]	; 0x24

        /* Disable peripherals and GPIO Clocks */
        /* Configure UART Tx as alternate function  */
        HAL_GPIO_DeInit(USART1_TX_GPIO_PORT, USART1_TX_PIN);
 800f7aa:	4819      	ldr	r0, [pc, #100]	; (800f810 <HAL_UART_MspDeInit+0x90>)
 800f7ac:	f44f 7100 	mov.w	r1, #512	; 0x200
 800f7b0:	f7f8 fda4 	bl	80082fc <HAL_GPIO_DeInit>
        /* Configure UART Rx as alternate function  */
        HAL_GPIO_DeInit(USART1_RX_GPIO_PORT, USART1_RX_PIN);
 800f7b4:	4816      	ldr	r0, [pc, #88]	; (800f810 <HAL_UART_MspDeInit+0x90>)
 800f7b6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800f7ba:	f7f8 fd9f 	bl	80082fc <HAL_GPIO_DeInit>

        /* Disable the NVIC for UART */
        HAL_NVIC_DisableIRQ(USART1_IRQn);
 800f7be:	2025      	movs	r0, #37	; 0x25
 800f7c0:	f7f3 ff3c 	bl	800363c <HAL_NVIC_DisableIRQ>
    }
	//HAL_UART3_MspDeInit(huart);
	
    if (huart->Instance == USART3)
 800f7c4:	687b      	ldr	r3, [r7, #4]
 800f7c6:	681b      	ldr	r3, [r3, #0]
 800f7c8:	4a12      	ldr	r2, [pc, #72]	; (800f814 <HAL_UART_MspDeInit+0x94>)
 800f7ca:	4293      	cmp	r3, r2
 800f7cc:	d118      	bne.n	800f800 <HAL_UART_MspDeInit+0x80>
    {
        /* Reset peripherals */
        USART3_FORCE_RESET();
 800f7ce:	4a0f      	ldr	r2, [pc, #60]	; (800f80c <HAL_UART_MspDeInit+0x8c>)
 800f7d0:	4b0e      	ldr	r3, [pc, #56]	; (800f80c <HAL_UART_MspDeInit+0x8c>)
 800f7d2:	6a1b      	ldr	r3, [r3, #32]
 800f7d4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800f7d8:	6213      	str	r3, [r2, #32]
        USART3_RELEASE_RESET();
 800f7da:	4a0c      	ldr	r2, [pc, #48]	; (800f80c <HAL_UART_MspDeInit+0x8c>)
 800f7dc:	4b0b      	ldr	r3, [pc, #44]	; (800f80c <HAL_UART_MspDeInit+0x8c>)
 800f7de:	6a1b      	ldr	r3, [r3, #32]
 800f7e0:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800f7e4:	6213      	str	r3, [r2, #32]

        /* Disable peripherals and GPIO Clocks */
        /* Configure UART Tx as alternate function  */
        HAL_GPIO_DeInit(USART3_TX_GPIO_PORT, USART3_TX_PIN);
 800f7e6:	480c      	ldr	r0, [pc, #48]	; (800f818 <HAL_UART_MspDeInit+0x98>)
 800f7e8:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800f7ec:	f7f8 fd86 	bl	80082fc <HAL_GPIO_DeInit>
        /* Configure UART Rx as alternate function  */
        HAL_GPIO_DeInit(USART3_RX_GPIO_PORT, USART3_RX_PIN);
 800f7f0:	4809      	ldr	r0, [pc, #36]	; (800f818 <HAL_UART_MspDeInit+0x98>)
 800f7f2:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800f7f6:	f7f8 fd81 	bl	80082fc <HAL_GPIO_DeInit>

        /* Disable the NVIC for UART */
        HAL_NVIC_DisableIRQ(USART3_IRQn);
 800f7fa:	2027      	movs	r0, #39	; 0x27
 800f7fc:	f7f3 ff1e 	bl	800363c <HAL_NVIC_DisableIRQ>
    }
}
 800f800:	3708      	adds	r7, #8
 800f802:	46bd      	mov	sp, r7
 800f804:	bd80      	pop	{r7, pc}
 800f806:	bf00      	nop
 800f808:	40011000 	.word	0x40011000
 800f80c:	40023800 	.word	0x40023800
 800f810:	40020000 	.word	0x40020000
 800f814:	40004800 	.word	0x40004800
 800f818:	40020800 	.word	0x40020800

0800f81c <stm32_hw_usart_init>:

int stm32_hw_usart_init(void)
{
 800f81c:	b580      	push	{r7, lr}
 800f81e:	b086      	sub	sp, #24
 800f820:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;
    struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;
 800f822:	4a1f      	ldr	r2, [pc, #124]	; (800f8a0 <stm32_hw_usart_init+0x84>)
 800f824:	f107 030c 	add.w	r3, r7, #12
 800f828:	e892 0003 	ldmia.w	r2, {r0, r1}
 800f82c:	e883 0003 	stmia.w	r3, {r0, r1}

#ifdef RT_USING_UART1
    uart = &uart1;
 800f830:	4b1c      	ldr	r3, [pc, #112]	; (800f8a4 <stm32_hw_usart_init+0x88>)
 800f832:	617b      	str	r3, [r7, #20]
    uart->UartHandle.Instance = USART1;
 800f834:	697b      	ldr	r3, [r7, #20]
 800f836:	4a1c      	ldr	r2, [pc, #112]	; (800f8a8 <stm32_hw_usart_init+0x8c>)
 800f838:	601a      	str	r2, [r3, #0]

    serial1.ops    = &stm32_uart_ops;
 800f83a:	4b1c      	ldr	r3, [pc, #112]	; (800f8ac <stm32_hw_usart_init+0x90>)
 800f83c:	4a1c      	ldr	r2, [pc, #112]	; (800f8b0 <stm32_hw_usart_init+0x94>)
 800f83e:	641a      	str	r2, [r3, #64]	; 0x40
    serial1.config = config;
 800f840:	4b1a      	ldr	r3, [pc, #104]	; (800f8ac <stm32_hw_usart_init+0x90>)
 800f842:	3344      	adds	r3, #68	; 0x44
 800f844:	f107 020c 	add.w	r2, r7, #12
 800f848:	e892 0003 	ldmia.w	r2, {r0, r1}
 800f84c:	e883 0003 	stmia.w	r3, {r0, r1}

    /* register UART1 device */
    rt_hw_serial_register(&serial1, "uart1",
 800f850:	4816      	ldr	r0, [pc, #88]	; (800f8ac <stm32_hw_usart_init+0x90>)
 800f852:	4918      	ldr	r1, [pc, #96]	; (800f8b4 <stm32_hw_usart_init+0x98>)
 800f854:	f240 1203 	movw	r2, #259	; 0x103
 800f858:	697b      	ldr	r3, [r7, #20]
 800f85a:	f007 fef1 	bl	8017640 <rt_hw_serial_register>
                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
                          uart);
#endif /* RT_USING_UART1 */

#ifdef RT_USING_UART3
		uart = &uart3;
 800f85e:	4b16      	ldr	r3, [pc, #88]	; (800f8b8 <stm32_hw_usart_init+0x9c>)
 800f860:	617b      	str	r3, [r7, #20]
		uart->UartHandle.Instance = USART3;
 800f862:	697b      	ldr	r3, [r7, #20]
 800f864:	4a15      	ldr	r2, [pc, #84]	; (800f8bc <stm32_hw_usart_init+0xa0>)
 800f866:	601a      	str	r2, [r3, #0]
		struct serial_configure config_uart3 = RT_SERIAL_CONFIG_UART3;
 800f868:	4a15      	ldr	r2, [pc, #84]	; (800f8c0 <stm32_hw_usart_init+0xa4>)
 800f86a:	1d3b      	adds	r3, r7, #4
 800f86c:	e892 0003 	ldmia.w	r2, {r0, r1}
 800f870:	e883 0003 	stmia.w	r3, {r0, r1}
		
		serial3.ops    = &stm32_uart_ops;
 800f874:	4b13      	ldr	r3, [pc, #76]	; (800f8c4 <stm32_hw_usart_init+0xa8>)
 800f876:	4a0e      	ldr	r2, [pc, #56]	; (800f8b0 <stm32_hw_usart_init+0x94>)
 800f878:	641a      	str	r2, [r3, #64]	; 0x40
		serial3.config = config_uart3;
 800f87a:	4b12      	ldr	r3, [pc, #72]	; (800f8c4 <stm32_hw_usart_init+0xa8>)
 800f87c:	3344      	adds	r3, #68	; 0x44
 800f87e:	1d3a      	adds	r2, r7, #4
 800f880:	e892 0003 	ldmia.w	r2, {r0, r1}
 800f884:	e883 0003 	stmia.w	r3, {r0, r1}
	
		/* register UART1 device */
		rt_hw_serial_register(&serial3, "uart3",
 800f888:	480e      	ldr	r0, [pc, #56]	; (800f8c4 <stm32_hw_usart_init+0xa8>)
 800f88a:	490f      	ldr	r1, [pc, #60]	; (800f8c8 <stm32_hw_usart_init+0xac>)
 800f88c:	f240 1203 	movw	r2, #259	; 0x103
 800f890:	697b      	ldr	r3, [r7, #20]
 800f892:	f007 fed5 	bl	8017640 <rt_hw_serial_register>
							  RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
							  uart);
#endif /* RT_USING_UART3 */


    return 0;
 800f896:	2300      	movs	r3, #0
}
 800f898:	4618      	mov	r0, r3
 800f89a:	3718      	adds	r7, #24
 800f89c:	46bd      	mov	sp, r7
 800f89e:	bd80      	pop	{r7, pc}
 800f8a0:	08022854 	.word	0x08022854
 800f8a4:	200108ac 	.word	0x200108ac
 800f8a8:	40011000 	.word	0x40011000
 800f8ac:	200123bc 	.word	0x200123bc
 800f8b0:	0802440c 	.word	0x0802440c
 800f8b4:	08022844 	.word	0x08022844
 800f8b8:	20010920 	.word	0x20010920
 800f8bc:	40004800 	.word	0x40004800
 800f8c0:	0802285c 	.word	0x0802285c
 800f8c4:	20012410 	.word	0x20012410
 800f8c8:	0802284c 	.word	0x0802284c

0800f8cc <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 800f8cc:	b480      	push	{r7}
 800f8ce:	af00      	add	r7, sp, #0
}
 800f8d0:	46bd      	mov	sp, r7
 800f8d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f8d6:	4770      	bx	lr

0800f8d8 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800f8d8:	b480      	push	{r7}
 800f8da:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 800f8dc:	e7fe      	b.n	800f8dc <BusFault_Handler+0x4>
 800f8de:	bf00      	nop

0800f8e0 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 800f8e0:	b480      	push	{r7}
 800f8e2:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 800f8e4:	e7fe      	b.n	800f8e4 <UsageFault_Handler+0x4>
 800f8e6:	bf00      	nop

0800f8e8 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 800f8e8:	b480      	push	{r7}
 800f8ea:	af00      	add	r7, sp, #0
}
 800f8ec:	46bd      	mov	sp, r7
 800f8ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f8f2:	4770      	bx	lr

0800f8f4 <J1939_TxdTask_entry>:
unsigned char *data;

#if 1

void J1939_TxdTask_entry(void *parameter)
{
 800f8f4:	b580      	push	{r7, lr}
 800f8f6:	b084      	sub	sp, #16
 800f8f8:	af00      	add	r7, sp, #0
 800f8fa:	6078      	str	r0, [r7, #4]
    rt_thread_t tid;
	
	//ca_msg.CAname = &caname;
	//ca_msg.msg.SourceAddress = DEFAULTADDRCA1;
	
	if(ca_msg != NULL)
 800f8fc:	4b0d      	ldr	r3, [pc, #52]	; (800f934 <J1939_TxdTask_entry+0x40>)
 800f8fe:	681b      	ldr	r3, [r3, #0]
 800f900:	2b00      	cmp	r3, #0
 800f902:	d00d      	beq.n	800f920 <J1939_TxdTask_entry+0x2c>
	{
		if (sendMessage(ca_msg,data)== RC_ERROR)
 800f904:	4b0b      	ldr	r3, [pc, #44]	; (800f934 <J1939_TxdTask_entry+0x40>)
 800f906:	681a      	ldr	r2, [r3, #0]
 800f908:	4b0b      	ldr	r3, [pc, #44]	; (800f938 <J1939_TxdTask_entry+0x44>)
 800f90a:	681b      	ldr	r3, [r3, #0]
 800f90c:	4610      	mov	r0, r2
 800f90e:	4619      	mov	r1, r3
 800f910:	f7fb ff16 	bl	800b740 <sendMessage>
 800f914:	4603      	mov	r3, r0
 800f916:	2b01      	cmp	r3, #1
 800f918:	d102      	bne.n	800f920 <J1939_TxdTask_entry+0x2c>
			rt_kprintf("rc_error\r\n");
 800f91a:	4808      	ldr	r0, [pc, #32]	; (800f93c <J1939_TxdTask_entry+0x48>)
 800f91c:	f004 f9a8 	bl	8013c70 <rt_kprintf>
	}
	tid = rt_thread_self();
 800f920:	f005 fb30 	bl	8014f84 <rt_thread_self>
 800f924:	60f8      	str	r0, [r7, #12]
	rt_thread_delete(tid);
 800f926:	68f8      	ldr	r0, [r7, #12]
 800f928:	f005 fba8 	bl	801507c <rt_thread_delete>

}
 800f92c:	3710      	adds	r7, #16
 800f92e:	46bd      	mov	sp, r7
 800f930:	bd80      	pop	{r7, pc}
 800f932:	bf00      	nop
 800f934:	20012468 	.word	0x20012468
 800f938:	20012464 	.word	0x20012464
 800f93c:	08022864 	.word	0x08022864

0800f940 <CANtx>:

void CANtx(int argc,char**argv)
{
 800f940:	b590      	push	{r4, r7, lr}
 800f942:	b089      	sub	sp, #36	; 0x24
 800f944:	af02      	add	r7, sp, #8
 800f946:	6078      	str	r0, [r7, #4]
 800f948:	6039      	str	r1, [r7, #0]
		data[i] = 0x55;
	}
	sendMessage(&CA_msg,data);
	#endif
    rt_thread_t tid;
	unsigned int sendsize = atoi(argv[1]);
 800f94a:	683b      	ldr	r3, [r7, #0]
 800f94c:	3304      	adds	r3, #4
 800f94e:	681b      	ldr	r3, [r3, #0]
 800f950:	4618      	mov	r0, r3
 800f952:	f00f faa1 	bl	801ee98 <atoi>
 800f956:	4603      	mov	r3, r0
 800f958:	613b      	str	r3, [r7, #16]
	unsigned int i;
	if(data != NULL)
 800f95a:	4b36      	ldr	r3, [pc, #216]	; (800fa34 <CANtx+0xf4>)
 800f95c:	681b      	ldr	r3, [r3, #0]
 800f95e:	2b00      	cmp	r3, #0
 800f960:	d006      	beq.n	800f970 <CANtx+0x30>
		data = (unsigned char *)malloc(sendsize * sizeof(char));
 800f962:	6938      	ldr	r0, [r7, #16]
 800f964:	f00f fbd6 	bl	801f114 <malloc>
 800f968:	4603      	mov	r3, r0
 800f96a:	461a      	mov	r2, r3
 800f96c:	4b31      	ldr	r3, [pc, #196]	; (800fa34 <CANtx+0xf4>)
 800f96e:	601a      	str	r2, [r3, #0]

	ca_msg->sendbytes = sendsize;
 800f970:	4b31      	ldr	r3, [pc, #196]	; (800fa38 <CANtx+0xf8>)
 800f972:	681b      	ldr	r3, [r3, #0]
 800f974:	693a      	ldr	r2, [r7, #16]
 800f976:	b292      	uxth	r2, r2
 800f978:	829a      	strh	r2, [r3, #20]
	ca_msg->msg.DataPage = 0;
 800f97a:	4b2f      	ldr	r3, [pc, #188]	; (800fa38 <CANtx+0xf8>)
 800f97c:	681a      	ldr	r2, [r3, #0]
 800f97e:	7913      	ldrb	r3, [r2, #4]
 800f980:	f36f 03c3 	bfc	r3, #3, #1
 800f984:	7113      	strb	r3, [r2, #4]
	ca_msg->msg.edp =0;
 800f986:	4b2c      	ldr	r3, [pc, #176]	; (800fa38 <CANtx+0xf8>)
 800f988:	681a      	ldr	r2, [r3, #0]
 800f98a:	7913      	ldrb	r3, [r2, #4]
 800f98c:	f36f 1304 	bfc	r3, #4, #1
 800f990:	7113      	strb	r3, [r2, #4]
	ca_msg->msg.PDUFormat = atoi(argv[2]);
 800f992:	4b29      	ldr	r3, [pc, #164]	; (800fa38 <CANtx+0xf8>)
 800f994:	681c      	ldr	r4, [r3, #0]
 800f996:	683b      	ldr	r3, [r7, #0]
 800f998:	3308      	adds	r3, #8
 800f99a:	681b      	ldr	r3, [r3, #0]
 800f99c:	4618      	mov	r0, r3
 800f99e:	f00f fa7b 	bl	801ee98 <atoi>
 800f9a2:	4603      	mov	r3, r0
 800f9a4:	b2db      	uxtb	r3, r3
 800f9a6:	7163      	strb	r3, [r4, #5]
	ca_msg->msg.PDUSpecific = atoi(argv[3]);
 800f9a8:	4b23      	ldr	r3, [pc, #140]	; (800fa38 <CANtx+0xf8>)
 800f9aa:	681c      	ldr	r4, [r3, #0]
 800f9ac:	683b      	ldr	r3, [r7, #0]
 800f9ae:	330c      	adds	r3, #12
 800f9b0:	681b      	ldr	r3, [r3, #0]
 800f9b2:	4618      	mov	r0, r3
 800f9b4:	f00f fa70 	bl	801ee98 <atoi>
 800f9b8:	4603      	mov	r3, r0
 800f9ba:	b2db      	uxtb	r3, r3
 800f9bc:	71a3      	strb	r3, [r4, #6]
	ca_msg->msg.Priority = 6;
 800f9be:	4b1e      	ldr	r3, [pc, #120]	; (800fa38 <CANtx+0xf8>)
 800f9c0:	681a      	ldr	r2, [r3, #0]
 800f9c2:	7913      	ldrb	r3, [r2, #4]
 800f9c4:	2106      	movs	r1, #6
 800f9c6:	f361 1347 	bfi	r3, r1, #5, #3
 800f9ca:	7113      	strb	r3, [r2, #4]
	
	for(i=0;i<sendsize;i++)
 800f9cc:	2300      	movs	r3, #0
 800f9ce:	617b      	str	r3, [r7, #20]
 800f9d0:	e00b      	b.n	800f9ea <CANtx+0xaa>
		data[i] = i+1;
 800f9d2:	4b18      	ldr	r3, [pc, #96]	; (800fa34 <CANtx+0xf4>)
 800f9d4:	681a      	ldr	r2, [r3, #0]
 800f9d6:	697b      	ldr	r3, [r7, #20]
 800f9d8:	4413      	add	r3, r2
 800f9da:	697a      	ldr	r2, [r7, #20]
 800f9dc:	b2d2      	uxtb	r2, r2
 800f9de:	3201      	adds	r2, #1
 800f9e0:	b2d2      	uxtb	r2, r2
 800f9e2:	701a      	strb	r2, [r3, #0]
	ca_msg->msg.edp =0;
	ca_msg->msg.PDUFormat = atoi(argv[2]);
	ca_msg->msg.PDUSpecific = atoi(argv[3]);
	ca_msg->msg.Priority = 6;
	
	for(i=0;i<sendsize;i++)
 800f9e4:	697b      	ldr	r3, [r7, #20]
 800f9e6:	3301      	adds	r3, #1
 800f9e8:	617b      	str	r3, [r7, #20]
 800f9ea:	697a      	ldr	r2, [r7, #20]
 800f9ec:	693b      	ldr	r3, [r7, #16]
 800f9ee:	429a      	cmp	r2, r3
 800f9f0:	d3ef      	bcc.n	800f9d2 <CANtx+0x92>
		data[i] = i+1;

	tid = rt_thread_create("J1939txd",						
 800f9f2:	230a      	movs	r3, #10
 800f9f4:	9300      	str	r3, [sp, #0]
 800f9f6:	2314      	movs	r3, #20
 800f9f8:	9301      	str	r3, [sp, #4]
 800f9fa:	4810      	ldr	r0, [pc, #64]	; (800fa3c <CANtx+0xfc>)
 800f9fc:	4910      	ldr	r1, [pc, #64]	; (800fa40 <CANtx+0x100>)
 800f9fe:	2200      	movs	r2, #0
 800fa00:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800fa04:	f005 fb08 	bl	8015018 <rt_thread_create>
 800fa08:	60f8      	str	r0, [r7, #12]
                          J1939_TxdTask_entry, RT_NULL,
                           1024, J1939_TXDTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 800fa0a:	68fb      	ldr	r3, [r7, #12]
 800fa0c:	2b00      	cmp	r3, #0
 800fa0e:	d002      	beq.n	800fa16 <CANtx+0xd6>
 800fa10:	68f8      	ldr	r0, [r7, #12]
 800fa12:	f005 fac3 	bl	8014f9c <rt_thread_startup>
	if(data != NULL)
 800fa16:	4b07      	ldr	r3, [pc, #28]	; (800fa34 <CANtx+0xf4>)
 800fa18:	681b      	ldr	r3, [r3, #0]
 800fa1a:	2b00      	cmp	r3, #0
 800fa1c:	d007      	beq.n	800fa2e <CANtx+0xee>
	{
		free(data);
 800fa1e:	4b05      	ldr	r3, [pc, #20]	; (800fa34 <CANtx+0xf4>)
 800fa20:	681b      	ldr	r3, [r3, #0]
 800fa22:	4618      	mov	r0, r3
 800fa24:	f00f fb7e 	bl	801f124 <free>
		data = NULL;
 800fa28:	4b02      	ldr	r3, [pc, #8]	; (800fa34 <CANtx+0xf4>)
 800fa2a:	2200      	movs	r2, #0
 800fa2c:	601a      	str	r2, [r3, #0]
	}
}
 800fa2e:	371c      	adds	r7, #28
 800fa30:	46bd      	mov	sp, r7
 800fa32:	bd90      	pop	{r4, r7, pc}
 800fa34:	20012464 	.word	0x20012464
 800fa38:	20012468 	.word	0x20012468
 800fa3c:	08022870 	.word	0x08022870
 800fa40:	0800f8f5 	.word	0x0800f8f5

0800fa44 <USER_CanTask_entry>:
#endif



void USER_CanTask_entry(void *parameter)
{
 800fa44:	b580      	push	{r7, lr}
 800fa46:	b08a      	sub	sp, #40	; 0x28
 800fa48:	af00      	add	r7, sp, #0
 800fa4a:	6078      	str	r0, [r7, #4]
			rt_kprintf("\r\n");
		}
		rt_thread_delay(20);
	}
	#endif
	struct J1939_CAname caname = CA1;
 800fa4c:	4a3e      	ldr	r2, [pc, #248]	; (800fb48 <USER_CanTask_entry+0x104>)
 800fa4e:	f107 0314 	add.w	r3, r7, #20
 800fa52:	e892 0003 	ldmia.w	r2, {r0, r1}
 800fa56:	e883 0003 	stmia.w	r3, {r0, r1}
	rt_size_t size;
	
    osEvent event;
	struct rx_Message *rxmsg;
	
	device = rt_device_find("can1");
 800fa5a:	483c      	ldr	r0, [pc, #240]	; (800fb4c <USER_CanTask_entry+0x108>)
 800fa5c:	f002 fa7a 	bl	8011f54 <rt_device_find>
 800fa60:	6238      	str	r0, [r7, #32]
	
	if(device != RT_NULL)
 800fa62:	6a3b      	ldr	r3, [r7, #32]
 800fa64:	2b00      	cmp	r3, #0
 800fa66:	d00a      	beq.n	800fa7e <USER_CanTask_entry+0x3a>
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX) != RT_EOK)
 800fa68:	6a38      	ldr	r0, [r7, #32]
 800fa6a:	f240 1103 	movw	r1, #259	; 0x103
 800fa6e:	f002 faad 	bl	8011fcc <rt_device_open>
 800fa72:	4603      	mov	r3, r0
 800fa74:	2b00      	cmp	r3, #0
 800fa76:	d002      	beq.n	800fa7e <USER_CanTask_entry+0x3a>
		{
			rt_kprintf("open error\r\n");
 800fa78:	4835      	ldr	r0, [pc, #212]	; (800fb50 <USER_CanTask_entry+0x10c>)
 800fa7a:	f004 f8f9 	bl	8013c70 <rt_kprintf>
		}
	
	initJ1939();
 800fa7e:	f7fc fde9 	bl	800c654 <initJ1939>
	ca_msg = (CA_Msg_t)malloc(sizeof(struct CA_Msg));
 800fa82:	2064      	movs	r0, #100	; 0x64
 800fa84:	f00f fb46 	bl	801f114 <malloc>
 800fa88:	4603      	mov	r3, r0
 800fa8a:	461a      	mov	r2, r3
 800fa8c:	4b31      	ldr	r3, [pc, #196]	; (800fb54 <USER_CanTask_entry+0x110>)
 800fa8e:	601a      	str	r2, [r3, #0]
	if(ca_msg != NULL)
 800fa90:	4b30      	ldr	r3, [pc, #192]	; (800fb54 <USER_CanTask_entry+0x110>)
 800fa92:	681b      	ldr	r3, [r3, #0]
 800fa94:	2b00      	cmp	r3, #0
 800fa96:	d014      	beq.n	800fac2 <USER_CanTask_entry+0x7e>
	{
		
		memset(ca_msg,0,sizeof(struct CA_Msg));
 800fa98:	4b2e      	ldr	r3, [pc, #184]	; (800fb54 <USER_CanTask_entry+0x110>)
 800fa9a:	681b      	ldr	r3, [r3, #0]
 800fa9c:	4618      	mov	r0, r3
 800fa9e:	2100      	movs	r1, #0
 800faa0:	2264      	movs	r2, #100	; 0x64
 800faa2:	f00f fb47 	bl	801f134 <memset>
		ca_msg->CAname = &caname;
 800faa6:	4b2b      	ldr	r3, [pc, #172]	; (800fb54 <USER_CanTask_entry+0x110>)
 800faa8:	681b      	ldr	r3, [r3, #0]
 800faaa:	f107 0214 	add.w	r2, r7, #20
 800faae:	601a      	str	r2, [r3, #0]
		ca_msg->msg.SourceAddress = DEFAULTADDRCA1;
 800fab0:	4b28      	ldr	r3, [pc, #160]	; (800fb54 <USER_CanTask_entry+0x110>)
 800fab2:	681b      	ldr	r3, [r3, #0]
 800fab4:	2223      	movs	r2, #35	; 0x23
 800fab6:	71da      	strb	r2, [r3, #7]

		J1939_CA_register(ca_msg);
 800fab8:	4b26      	ldr	r3, [pc, #152]	; (800fb54 <USER_CanTask_entry+0x110>)
 800faba:	681b      	ldr	r3, [r3, #0]
 800fabc:	4618      	mov	r0, r3
 800fabe:	f7fb fb25 	bl	800b10c <J1939_CA_register>
		ca_msg->msg.PDUSpecific = 0x23;
		ca_msg->msg.Priority = 6;
		if (sendMessage(ca_msg,data)== RC_ERROR)
			rt_kprintf("rc_error\r\n");
		#endif
		event = osMessageGet(ca_msg->rxq, 20);
 800fac2:	4b24      	ldr	r3, [pc, #144]	; (800fb54 <USER_CanTask_entry+0x110>)
 800fac4:	681b      	ldr	r3, [r3, #0]
 800fac6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800fac8:	f107 0208 	add.w	r2, r7, #8
 800facc:	4610      	mov	r0, r2
 800face:	4619      	mov	r1, r3
 800fad0:	2214      	movs	r2, #20
 800fad2:	f006 fa39 	bl	8015f48 <osMessageGet>
		if(event.status == osEventMessage)
 800fad6:	68bb      	ldr	r3, [r7, #8]
 800fad8:	2b10      	cmp	r3, #16
 800fada:	d134      	bne.n	800fb46 <USER_CanTask_entry+0x102>
		{
			unsigned short i;

			rxmsg = event.value.p;
 800fadc:	68fb      	ldr	r3, [r7, #12]
 800fade:	61fb      	str	r3, [r7, #28]
			if(rxmsg == NULL)
 800fae0:	69fb      	ldr	r3, [r7, #28]
 800fae2:	2b00      	cmp	r3, #0
 800fae4:	d103      	bne.n	800faee <USER_CanTask_entry+0xaa>
			{
				rt_kprintf("val null\r\n");
 800fae6:	481c      	ldr	r0, [pc, #112]	; (800fb58 <USER_CanTask_entry+0x114>)
 800fae8:	f004 f8c2 	bl	8013c70 <rt_kprintf>
 800faec:	e02b      	b.n	800fb46 <USER_CanTask_entry+0x102>
			}
			else
			{
				rt_kprintf(" dp: %x\r\n", rxmsg->dp);
 800faee:	69fb      	ldr	r3, [r7, #28]
 800faf0:	7a1b      	ldrb	r3, [r3, #8]
 800faf2:	481a      	ldr	r0, [pc, #104]	; (800fb5c <USER_CanTask_entry+0x118>)
 800faf4:	4619      	mov	r1, r3
 800faf6:	f004 f8bb 	bl	8013c70 <rt_kprintf>
				rt_kprintf("pf: %x \r\n", rxmsg->PF);
 800fafa:	69fb      	ldr	r3, [r7, #28]
 800fafc:	79db      	ldrb	r3, [r3, #7]
 800fafe:	4818      	ldr	r0, [pc, #96]	; (800fb60 <USER_CanTask_entry+0x11c>)
 800fb00:	4619      	mov	r1, r3
 800fb02:	f004 f8b5 	bl	8013c70 <rt_kprintf>
				rt_kprintf("ps: %x \r\n", rxmsg->PS);
 800fb06:	69fb      	ldr	r3, [r7, #28]
 800fb08:	799b      	ldrb	r3, [r3, #6]
 800fb0a:	4816      	ldr	r0, [pc, #88]	; (800fb64 <USER_CanTask_entry+0x120>)
 800fb0c:	4619      	mov	r1, r3
 800fb0e:	f004 f8af 	bl	8013c70 <rt_kprintf>
				rt_kprintf("rcv data: ");
 800fb12:	4815      	ldr	r0, [pc, #84]	; (800fb68 <USER_CanTask_entry+0x124>)
 800fb14:	f004 f8ac 	bl	8013c70 <rt_kprintf>
				for(i = 0;i<rxmsg->size;i++)
 800fb18:	2300      	movs	r3, #0
 800fb1a:	84fb      	strh	r3, [r7, #38]	; 0x26
 800fb1c:	e00b      	b.n	800fb36 <USER_CanTask_entry+0xf2>
				{
					rt_kprintf("%x ", rxmsg->data[i]);
 800fb1e:	69fb      	ldr	r3, [r7, #28]
 800fb20:	681a      	ldr	r2, [r3, #0]
 800fb22:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800fb24:	4413      	add	r3, r2
 800fb26:	781b      	ldrb	r3, [r3, #0]
 800fb28:	4810      	ldr	r0, [pc, #64]	; (800fb6c <USER_CanTask_entry+0x128>)
 800fb2a:	4619      	mov	r1, r3
 800fb2c:	f004 f8a0 	bl	8013c70 <rt_kprintf>
			{
				rt_kprintf(" dp: %x\r\n", rxmsg->dp);
				rt_kprintf("pf: %x \r\n", rxmsg->PF);
				rt_kprintf("ps: %x \r\n", rxmsg->PS);
				rt_kprintf("rcv data: ");
				for(i = 0;i<rxmsg->size;i++)
 800fb30:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800fb32:	3301      	adds	r3, #1
 800fb34:	84fb      	strh	r3, [r7, #38]	; 0x26
 800fb36:	69fb      	ldr	r3, [r7, #28]
 800fb38:	889b      	ldrh	r3, [r3, #4]
 800fb3a:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800fb3c:	429a      	cmp	r2, r3
 800fb3e:	d3ee      	bcc.n	800fb1e <USER_CanTask_entry+0xda>
				{
					rt_kprintf("%x ", rxmsg->data[i]);
				}
				rt_kprintf("\r\n");
 800fb40:	480b      	ldr	r0, [pc, #44]	; (800fb70 <USER_CanTask_entry+0x12c>)
 800fb42:	f004 f895 	bl	8013c70 <rt_kprintf>
			}
		}
		//rt_thread_delay(20);
	}
 800fb46:	e7bc      	b.n	800fac2 <USER_CanTask_entry+0x7e>
 800fb48:	080228d8 	.word	0x080228d8
 800fb4c:	0802287c 	.word	0x0802287c
 800fb50:	08022884 	.word	0x08022884
 800fb54:	20012468 	.word	0x20012468
 800fb58:	08022894 	.word	0x08022894
 800fb5c:	080228a0 	.word	0x080228a0
 800fb60:	080228ac 	.word	0x080228ac
 800fb64:	080228b8 	.word	0x080228b8
 800fb68:	080228c4 	.word	0x080228c4
 800fb6c:	080228d0 	.word	0x080228d0
 800fb70:	080228d4 	.word	0x080228d4

0800fb74 <USER_CanTask_init>:
}


int USER_CanTask_init()
{
 800fb74:	b580      	push	{r7, lr}
 800fb76:	b084      	sub	sp, #16
 800fb78:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	
	tid = rt_thread_create("Can",						
 800fb7a:	2309      	movs	r3, #9
 800fb7c:	9300      	str	r3, [sp, #0]
 800fb7e:	2314      	movs	r3, #20
 800fb80:	9301      	str	r3, [sp, #4]
 800fb82:	4809      	ldr	r0, [pc, #36]	; (800fba8 <USER_CanTask_init+0x34>)
 800fb84:	4909      	ldr	r1, [pc, #36]	; (800fbac <USER_CanTask_init+0x38>)
 800fb86:	2200      	movs	r2, #0
 800fb88:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800fb8c:	f005 fa44 	bl	8015018 <rt_thread_create>
 800fb90:	6078      	str	r0, [r7, #4]
                           USER_CanTask_entry, RT_NULL,
                           2048, USER_CANTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 800fb92:	687b      	ldr	r3, [r7, #4]
 800fb94:	2b00      	cmp	r3, #0
 800fb96:	d002      	beq.n	800fb9e <USER_CanTask_init+0x2a>
 800fb98:	6878      	ldr	r0, [r7, #4]
 800fb9a:	f005 f9ff 	bl	8014f9c <rt_thread_startup>

    return 0;
 800fb9e:	2300      	movs	r3, #0
}
 800fba0:	4618      	mov	r0, r3
 800fba2:	3708      	adds	r7, #8
 800fba4:	46bd      	mov	sp, r7
 800fba6:	bd80      	pop	{r7, pc}
 800fba8:	080228e0 	.word	0x080228e0
 800fbac:	0800fa45 	.word	0x0800fa45

0800fbb0 <can_input>:
INIT_APP_EXPORT(USER_CanTask_init);

static rt_sem_t can_rx_sem;

static rt_err_t can_input(rt_device_t dev, rt_size_t size)
{
 800fbb0:	b580      	push	{r7, lr}
 800fbb2:	b082      	sub	sp, #8
 800fbb4:	af00      	add	r7, sp, #0
 800fbb6:	6078      	str	r0, [r7, #4]
 800fbb8:	6039      	str	r1, [r7, #0]
	rt_sem_release(can_rx_sem);
 800fbba:	4b05      	ldr	r3, [pc, #20]	; (800fbd0 <can_input+0x20>)
 800fbbc:	681b      	ldr	r3, [r3, #0]
 800fbbe:	4618      	mov	r0, r3
 800fbc0:	f002 fde6 	bl	8012790 <rt_sem_release>
	return RT_EOK;
 800fbc4:	2300      	movs	r3, #0
}
 800fbc6:	4618      	mov	r0, r3
 800fbc8:	3708      	adds	r7, #8
 800fbca:	46bd      	mov	sp, r7
 800fbcc:	bd80      	pop	{r7, pc}
 800fbce:	bf00      	nop
 800fbd0:	200109e8 	.word	0x200109e8

0800fbd4 <J1939_RcvTask_entry>:


void J1939_RcvTask_entry(void *parameter)
{
 800fbd4:	b580      	push	{r7, lr}
 800fbd6:	b084      	sub	sp, #16
 800fbd8:	af00      	add	r7, sp, #0
 800fbda:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	rt_err_t result;
	device = rt_device_find("can1");
 800fbdc:	480c      	ldr	r0, [pc, #48]	; (800fc10 <J1939_RcvTask_entry+0x3c>)
 800fbde:	f002 f9b9 	bl	8011f54 <rt_device_find>
 800fbe2:	60f8      	str	r0, [r7, #12]
	
	if ( device != RT_NULL )
 800fbe4:	68fb      	ldr	r3, [r7, #12]
 800fbe6:	2b00      	cmp	r3, #0
 800fbe8:	d003      	beq.n	800fbf2 <J1939_RcvTask_entry+0x1e>
	{
		rt_device_set_rx_indicate(device, can_input);
 800fbea:	68f8      	ldr	r0, [r7, #12]
 800fbec:	4909      	ldr	r1, [pc, #36]	; (800fc14 <J1939_RcvTask_entry+0x40>)
 800fbee:	f002 fb2d 	bl	801224c <rt_device_set_rx_indicate>
		#endif
	}

	while(1)
	{
		result = rt_sem_take(can_rx_sem, RT_WAITING_FOREVER);
 800fbf2:	4b09      	ldr	r3, [pc, #36]	; (800fc18 <J1939_RcvTask_entry+0x44>)
 800fbf4:	681b      	ldr	r3, [r3, #0]
 800fbf6:	4618      	mov	r0, r3
 800fbf8:	f04f 31ff 	mov.w	r1, #4294967295
 800fbfc:	f002 fd24 	bl	8012648 <rt_sem_take>
 800fc00:	60b8      	str	r0, [r7, #8]
		if (result == RT_EOK)
 800fc02:	68bb      	ldr	r3, [r7, #8]
 800fc04:	2b00      	cmp	r3, #0
 800fc06:	d101      	bne.n	800fc0c <J1939_RcvTask_entry+0x38>
		{
			receiveMessage();
 800fc08:	f7fc fa52 	bl	800c0b0 <receiveMessage>
		}
	}
 800fc0c:	e7f1      	b.n	800fbf2 <J1939_RcvTask_entry+0x1e>
 800fc0e:	bf00      	nop
 800fc10:	0802287c 	.word	0x0802287c
 800fc14:	0800fbb1 	.word	0x0800fbb1
 800fc18:	200109e8 	.word	0x200109e8

0800fc1c <J1939_RcvTask_init>:
}

int J1939_RcvTask_init()
{
 800fc1c:	b580      	push	{r7, lr}
 800fc1e:	b084      	sub	sp, #16
 800fc20:	af02      	add	r7, sp, #8
    rt_thread_t tid;

	
	if ((can_rx_sem = rt_sem_create("J1939rcv", 0, RT_IPC_FLAG_FIFO)) == RT_NULL)
 800fc22:	4813      	ldr	r0, [pc, #76]	; (800fc70 <J1939_RcvTask_init+0x54>)
 800fc24:	2100      	movs	r1, #0
 800fc26:	2200      	movs	r2, #0
 800fc28:	f002 fcd2 	bl	80125d0 <rt_sem_create>
 800fc2c:	4602      	mov	r2, r0
 800fc2e:	4b11      	ldr	r3, [pc, #68]	; (800fc74 <J1939_RcvTask_init+0x58>)
 800fc30:	601a      	str	r2, [r3, #0]
 800fc32:	4b10      	ldr	r3, [pc, #64]	; (800fc74 <J1939_RcvTask_init+0x58>)
 800fc34:	681b      	ldr	r3, [r3, #0]
 800fc36:	2b00      	cmp	r3, #0
 800fc38:	d102      	bne.n	800fc40 <J1939_RcvTask_init+0x24>
	{
		rt_kprintf("can_rx_sem create error\r\n");
 800fc3a:	480f      	ldr	r0, [pc, #60]	; (800fc78 <J1939_RcvTask_init+0x5c>)
 800fc3c:	f004 f818 	bl	8013c70 <rt_kprintf>
	}
	
	tid = rt_thread_create("J1939Rcv",						
 800fc40:	230a      	movs	r3, #10
 800fc42:	9300      	str	r3, [sp, #0]
 800fc44:	2314      	movs	r3, #20
 800fc46:	9301      	str	r3, [sp, #4]
 800fc48:	480c      	ldr	r0, [pc, #48]	; (800fc7c <J1939_RcvTask_init+0x60>)
 800fc4a:	490d      	ldr	r1, [pc, #52]	; (800fc80 <J1939_RcvTask_init+0x64>)
 800fc4c:	2200      	movs	r2, #0
 800fc4e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800fc52:	f005 f9e1 	bl	8015018 <rt_thread_create>
 800fc56:	6078      	str	r0, [r7, #4]
                          J1939_RcvTask_entry, RT_NULL,
                           1024, J1939_RCVTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 800fc58:	687b      	ldr	r3, [r7, #4]
 800fc5a:	2b00      	cmp	r3, #0
 800fc5c:	d002      	beq.n	800fc64 <J1939_RcvTask_init+0x48>
 800fc5e:	6878      	ldr	r0, [r7, #4]
 800fc60:	f005 f99c 	bl	8014f9c <rt_thread_startup>

    return 0;
 800fc64:	2300      	movs	r3, #0
}
 800fc66:	4618      	mov	r0, r3
 800fc68:	3708      	adds	r7, #8
 800fc6a:	46bd      	mov	sp, r7
 800fc6c:	bd80      	pop	{r7, pc}
 800fc6e:	bf00      	nop
 800fc70:	080228e4 	.word	0x080228e4
 800fc74:	200109e8 	.word	0x200109e8
 800fc78:	080228f0 	.word	0x080228f0
 800fc7c:	0802290c 	.word	0x0802290c
 800fc80:	0800fbd5 	.word	0x0800fbd5

0800fc84 <USER_MotorTask_entry>:
int usartTest=0;
extern rt_err_t myscanf(char *buf);


void USER_MotorTask_entry(void *parameter)
{
 800fc84:	b580      	push	{r7, lr}
 800fc86:	b088      	sub	sp, #32
 800fc88:	af00      	add	r7, sp, #0
 800fc8a:	6078      	str	r0, [r7, #4]
char rx_data[15],i;

#ifdef THREE_SHUNT  
	SVPWM_3ShuntInit();
#elif defined ICS_SENSORS
	SVPWM_IcsInit();
 800fc8c:	f001 ff66 	bl	8011b5c <SVPWM_IcsInit>

#if defined(TACHO)
	TAC_TachoTimerInit();
	TAC_InitTachoMeasure();  
#elif defined(ENCODER)
	ENC_Init();
 800fc90:	f001 fdca 	bl	8011828 <ENC_Init>
	
  
  //TB_Init();
  
  
  PID_Init(&PID_Torque_InitStructure, &PID_Flux_InitStructure, &PID_Speed_InitStructure);
 800fc94:	485d      	ldr	r0, [pc, #372]	; (800fe0c <USER_MotorTask_entry+0x188>)
 800fc96:	495e      	ldr	r1, [pc, #376]	; (800fe10 <USER_MotorTask_entry+0x18c>)
 800fc98:	4a5e      	ldr	r2, [pc, #376]	; (800fe14 <USER_MotorTask_entry+0x190>)
 800fc9a:	f001 fb71 	bl	8011380 <PID_Init>
  //DBGMCU_Config(DBGMCU_TIM1_STOP, ENABLE);
  
  
  // Init Bus voltage and Temperature arrays  
 
  MCL_Init_Arrays();
 800fc9e:	f001 f9f5 	bl	801108c <MCL_Init_Arrays>
    
 
  State = IDLE;
 800fca2:	4b5d      	ldr	r3, [pc, #372]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fca4:	2200      	movs	r2, #0
 800fca6:	701a      	strb	r2, [r3, #0]
  
  PWMOutputsEnable(TIM8);
 800fca8:	485c      	ldr	r0, [pc, #368]	; (800fe1c <USER_MotorTask_entry+0x198>)
 800fcaa:	f7fe ffe7 	bl	800ec7c <PWMOutputsEnable>
    //MCL_ChkPowerStage();    
    
    /*
    	* IDLE--INIT---START-----RUN-----BREAK-----STOP----WAITE----FAULT *
    	*/  
    if(myscanf(rx_data) == RT_EOK)
 800fcae:	f107 0308 	add.w	r3, r7, #8
 800fcb2:	4618      	mov	r0, r3
 800fcb4:	f000 fc8e 	bl	80105d4 <myscanf>
 800fcb8:	4603      	mov	r3, r0
 800fcba:	2b00      	cmp	r3, #0
 800fcbc:	d105      	bne.n	800fcca <USER_MotorTask_entry+0x46>
		rt_kprintf("%s\r\n", rx_data);
 800fcbe:	f107 0308 	add.w	r3, r7, #8
 800fcc2:	4857      	ldr	r0, [pc, #348]	; (800fe20 <USER_MotorTask_entry+0x19c>)
 800fcc4:	4619      	mov	r1, r3
 800fcc6:	f003 ffd3 	bl	8013c70 <rt_kprintf>
			rt_device_read (device, 0, &i[j], 13);
		}
	}
	rt_kprintf("i = %s\r\n", i);
	#endif
    switch (State)
 800fcca:	4b53      	ldr	r3, [pc, #332]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fccc:	781b      	ldrb	r3, [r3, #0]
 800fcce:	b2db      	uxtb	r3, r3
 800fcd0:	2b07      	cmp	r3, #7
 800fcd2:	f200 8098 	bhi.w	800fe06 <USER_MotorTask_entry+0x182>
 800fcd6:	a201      	add	r2, pc, #4	; (adr r2, 800fcdc <USER_MotorTask_entry+0x58>)
 800fcd8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fcdc:	0800fe07 	.word	0x0800fe07
 800fce0:	0800fcfd 	.word	0x0800fcfd
 800fce4:	0800fd11 	.word	0x0800fd11
 800fce8:	0800fda3 	.word	0x0800fda3
 800fcec:	0800fdb1 	.word	0x0800fdb1
 800fcf0:	0800fda9 	.word	0x0800fda9
 800fcf4:	0800fddb 	.word	0x0800fddb
 800fcf8:	0800fdef 	.word	0x0800fdef
    {
      case IDLE:     
        break;
        
      case INIT:
        MCL_Init();
 800fcfc:	f001 f988 	bl	8011010 <MCL_Init>
        TB_Set_StartUp_Timeout(STARTUP_TIMEOUT);
 800fd00:	f640 30b8 	movw	r0, #3000	; 0xbb8
 800fd04:	f001 fc84 	bl	8011610 <TB_Set_StartUp_Timeout>
        State = START;
 800fd08:	4b43      	ldr	r3, [pc, #268]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fd0a:	2202      	movs	r2, #2
 800fd0c:	701a      	strb	r2, [r3, #0]
        break;
 800fd0e:	e07b      	b.n	800fe08 <USER_MotorTask_entry+0x184>

            
#elif defined ENCODER          
          {
            s16 hMech_Speed_Hz;
            s16 hLocalSpeed_Reference = hSpeed_Reference;
 800fd10:	4b44      	ldr	r3, [pc, #272]	; (800fe24 <USER_MotorTask_entry+0x1a0>)
 800fd12:	881b      	ldrh	r3, [r3, #0]
 800fd14:	83fb      	strh	r3, [r7, #30]
            
            hMech_Speed_Hz = ENC_Get_Mechanical_Speed();
 800fd16:	f001 fe77 	bl	8011a08 <ENC_Get_Mechanical_Speed>
 800fd1a:	4603      	mov	r3, r0
 800fd1c:	83bb      	strh	r3, [r7, #28]
            if((wGlobal_Flags & CLOSED_LOOP) == CLOSED_LOOP)
 800fd1e:	4b42      	ldr	r3, [pc, #264]	; (800fe28 <USER_MotorTask_entry+0x1a4>)
 800fd20:	681b      	ldr	r3, [r3, #0]
 800fd22:	f003 0301 	and.w	r3, r3, #1
 800fd26:	2b00      	cmp	r3, #0
 800fd28:	d029      	beq.n	800fd7e <USER_MotorTask_entry+0xfa>
            {  
              u16 Abs_Freq;
              Abs_Freq = (hMech_Speed_Hz < 0 ? -hMech_Speed_Hz : hMech_Speed_Hz);
 800fd2a:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800fd2e:	2b00      	cmp	r3, #0
 800fd30:	bfb8      	it	lt
 800fd32:	425b      	neglt	r3, r3
 800fd34:	837b      	strh	r3, [r7, #26]
              
              if (Abs_Freq > ENCODER_CL_ENABLE)
 800fd36:	8b7b      	ldrh	r3, [r7, #26]
 800fd38:	2b01      	cmp	r3, #1
 800fd3a:	d916      	bls.n	800fd6a <USER_MotorTask_entry+0xe6>
              {              
                //It initializes Integral term of speed PID to avoid discontinuity
                //in torque reference
                PID_Speed_InitStructure.wIntegral =
                  (((s32)(hTorque_Reference)*128)-
 800fd3c:	4b3b      	ldr	r3, [pc, #236]	; (800fe2c <USER_MotorTask_entry+0x1a8>)
 800fd3e:	881b      	ldrh	r3, [r3, #0]
 800fd40:	b29b      	uxth	r3, r3
 800fd42:	b21b      	sxth	r3, r3
 800fd44:	01da      	lsls	r2, r3, #7
                   ((s32)(PID_Speed_InitStructure.hKp_Gain*8)*
 800fd46:	4b33      	ldr	r3, [pc, #204]	; (800fe14 <USER_MotorTask_entry+0x190>)
 800fd48:	881b      	ldrh	r3, [r3, #0]
 800fd4a:	b21b      	sxth	r3, r3
 800fd4c:	00db      	lsls	r3, r3, #3
 800fd4e:	f9b7 001c 	ldrsh.w	r0, [r7, #28]
 800fd52:	f9b7 101e 	ldrsh.w	r1, [r7, #30]
 800fd56:	1a41      	subs	r1, r0, r1
 800fd58:	fb01 f303 	mul.w	r3, r1, r3
              if (Abs_Freq > ENCODER_CL_ENABLE)
              {              
                //It initializes Integral term of speed PID to avoid discontinuity
                //in torque reference
                PID_Speed_InitStructure.wIntegral =
                  (((s32)(hTorque_Reference)*128)-
 800fd5c:	4413      	add	r3, r2
              
              if (Abs_Freq > ENCODER_CL_ENABLE)
              {              
                //It initializes Integral term of speed PID to avoid discontinuity
                //in torque reference
                PID_Speed_InitStructure.wIntegral =
 800fd5e:	4a2d      	ldr	r2, [pc, #180]	; (800fe14 <USER_MotorTask_entry+0x190>)
 800fd60:	6153      	str	r3, [r2, #20]
                  (((s32)(hTorque_Reference)*128)-
                   ((s32)(PID_Speed_InitStructure.hKp_Gain*8)*
                    (hLocalSpeed_Reference-hMech_Speed_Hz)));
                State = RUN; 
 800fd62:	4b2d      	ldr	r3, [pc, #180]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fd64:	2203      	movs	r2, #3
 800fd66:	701a      	strb	r2, [r3, #0]
 800fd68:	e008      	b.n	800fd7c <USER_MotorTask_entry+0xf8>
              }
              else if (TB_StartUp_Timeout_IsElapsed())
 800fd6a:	f001 fc67 	bl	801163c <TB_StartUp_Timeout_IsElapsed>
 800fd6e:	4603      	mov	r3, r0
 800fd70:	2b00      	cmp	r3, #0
 800fd72:	d003      	beq.n	800fd7c <USER_MotorTask_entry+0xf8>
              {
                //shutdown power
                
                MCL_SetFault(SPEED_FEEDBACK);
 800fd74:	2004      	movs	r0, #4
 800fd76:	f001 f9ab 	bl	80110d0 <MCL_SetFault>
 800fd7a:	e011      	b.n	800fda0 <USER_MotorTask_entry+0x11c>
 800fd7c:	e010      	b.n	800fda0 <USER_MotorTask_entry+0x11c>
                
              }
            }
            else //Torque mode loop
            { 
              if (hMech_Speed_Hz != 0)
 800fd7e:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800fd82:	2b00      	cmp	r3, #0
 800fd84:	d003      	beq.n	800fd8e <USER_MotorTask_entry+0x10a>
              {
                State = RUN; 
 800fd86:	4b24      	ldr	r3, [pc, #144]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fd88:	2203      	movs	r2, #3
 800fd8a:	701a      	strb	r2, [r3, #0]
 800fd8c:	e008      	b.n	800fda0 <USER_MotorTask_entry+0x11c>
              }
              else if (TB_StartUp_Timeout_IsElapsed())
 800fd8e:	f001 fc55 	bl	801163c <TB_StartUp_Timeout_IsElapsed>
 800fd92:	4603      	mov	r3, r0
 800fd94:	2b00      	cmp	r3, #0
 800fd96:	d003      	beq.n	800fda0 <USER_MotorTask_entry+0x11c>
              {
                //shutdown power
                
                MCL_SetFault(SPEED_FEEDBACK);
 800fd98:	2004      	movs	r0, #4
 800fd9a:	f001 f999 	bl	80110d0 <MCL_SetFault>
              }
            }
          }

#endif
        break;
 800fd9e:	e033      	b.n	800fe08 <USER_MotorTask_entry+0x184>
 800fda0:	e032      	b.n	800fe08 <USER_MotorTask_entry+0x184>
            if (TAC_IsTimedOut())
             
			
#elif defined ENCODER             

            if(ENC_ErrorOnFeedback() == TRUE)
 800fda2:	f001 fecf 	bl	8011b44 <ENC_ErrorOnFeedback>
            {  
              //MCL_SetFault(SPEED_FDBK_TIMED_OUT);
              
            }

            break;         
 800fda6:	e02f      	b.n	800fe08 <USER_MotorTask_entry+0x184>
            
      case BRAKE:    
          State = STOP;
 800fda8:	4b1b      	ldr	r3, [pc, #108]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fdaa:	2204      	movs	r2, #4
 800fdac:	701a      	strb	r2, [r3, #0]
        break;  
 800fdae:	e02b      	b.n	800fe08 <USER_MotorTask_entry+0x184>
      case STOP: 
          
          // shutdown power 
                    
          /* Main PWM Output Disable */
		  PWMOutputsDisable(TIM8);
 800fdb0:	481a      	ldr	r0, [pc, #104]	; (800fe1c <USER_MotorTask_entry+0x198>)
 800fdb2:	f7fe ff81 	bl	800ecb8 <PWMOutputsDisable>
#endif
#ifdef SINGLE_SHUNT          
          SVPWM_1ShuntAdvCurrentReading(DISABLE);
#endif 
          
          Stat_Volt_alfa_beta.qV_Component1 = Stat_Volt_alfa_beta.qV_Component2 = 0;
 800fdb6:	4b1e      	ldr	r3, [pc, #120]	; (800fe30 <USER_MotorTask_entry+0x1ac>)
 800fdb8:	2200      	movs	r2, #0
 800fdba:	805a      	strh	r2, [r3, #2]
 800fdbc:	4b1c      	ldr	r3, [pc, #112]	; (800fe30 <USER_MotorTask_entry+0x1ac>)
 800fdbe:	885a      	ldrh	r2, [r3, #2]
 800fdc0:	4b1b      	ldr	r3, [pc, #108]	; (800fe30 <USER_MotorTask_entry+0x1ac>)
 800fdc2:	801a      	strh	r2, [r3, #0]
          
#ifdef ICS_SENSORS
          SVPWM_IcsCalcDutyCycles(Stat_Volt_alfa_beta);
 800fdc4:	4b1a      	ldr	r3, [pc, #104]	; (800fe30 <USER_MotorTask_entry+0x1ac>)
 800fdc6:	681b      	ldr	r3, [r3, #0]
 800fdc8:	2200      	movs	r2, #0
 800fdca:	461a      	mov	r2, r3
 800fdcc:	4610      	mov	r0, r2
 800fdce:	f001 ff17 	bl	8011c00 <SVPWM_IcsCalcDutyCycles>
#elif defined THREE_SHUNT
          SVPWM_3ShuntCalcDutyCycles(Stat_Volt_alfa_beta);
#endif        
          State = WAIT;
 800fdd2:	4b11      	ldr	r3, [pc, #68]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fdd4:	2206      	movs	r2, #6
 800fdd6:	701a      	strb	r2, [r3, #0]
          
        
        break;
 800fdd8:	e016      	b.n	800fe08 <USER_MotorTask_entry+0x184>
        case WAIT:    // wait state

#ifdef TACHO
           if (TAC_GetRotorFreqInHz() == 0) 
#elif defined ENCODER
           if (ENC_Get_Mechanical_Speed() == 0)  
 800fdda:	f001 fe15 	bl	8011a08 <ENC_Get_Mechanical_Speed>
 800fdde:	4603      	mov	r3, r0
 800fde0:	2b00      	cmp	r3, #0
 800fde2:	d103      	bne.n	800fdec <USER_MotorTask_entry+0x168>
#endif          
            {
              State = IDLE;
 800fde4:	4b0c      	ldr	r3, [pc, #48]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fde6:	2200      	movs	r2, #0
 800fde8:	701a      	strb	r2, [r3, #0]
            }
          break; 
 800fdea:	e00d      	b.n	800fe08 <USER_MotorTask_entry+0x184>
 800fdec:	e00c      	b.n	800fe08 <USER_MotorTask_entry+0x184>
          
         case FAULT:   // Fault detected  
              
             if (MCL_ClearFault() == TRUE)
 800fdee:	f001 f995 	bl	801111c <MCL_ClearFault>
 800fdf2:	4603      	mov	r3, r0
 800fdf4:	2b01      	cmp	r3, #1
 800fdf6:	d105      	bne.n	800fe04 <USER_MotorTask_entry+0x180>
                  {
                    if(wGlobal_Flags & CLOSED_LOOP == CLOSED_LOOP)
 800fdf8:	4b0b      	ldr	r3, [pc, #44]	; (800fe28 <USER_MotorTask_entry+0x1a4>)
 800fdfa:	681b      	ldr	r3, [r3, #0]
                    }
                    else
                    {
                      //bMenu_index = CONTROL_MODE_MENU_6;
                    }   
                    State = IDLE;
 800fdfc:	4b06      	ldr	r3, [pc, #24]	; (800fe18 <USER_MotorTask_entry+0x194>)
 800fdfe:	2200      	movs	r2, #0
 800fe00:	701a      	strb	r2, [r3, #0]
                  }
              break;
 800fe02:	e001      	b.n	800fe08 <USER_MotorTask_entry+0x184>
 800fe04:	e000      	b.n	800fe08 <USER_MotorTask_entry+0x184>
           
           
     
        default:
          break;     
 800fe06:	bf00      	nop
    }
	
	//rt_thread_delay(SLEEPTIME(20));
  }
 800fe08:	e751      	b.n	800fcae <USER_MotorTask_entry+0x2a>
 800fe0a:	bf00      	nop
 800fe0c:	200124e8 	.word	0x200124e8
 800fe10:	20012544 	.word	0x20012544
 800fe14:	20012508 	.word	0x20012508
 800fe18:	20012528 	.word	0x20012528
 800fe1c:	40010400 	.word	0x40010400
 800fe20:	08022918 	.word	0x08022918
 800fe24:	20012540 	.word	0x20012540
 800fe28:	20010a08 	.word	0x20010a08
 800fe2c:	2001252a 	.word	0x2001252a
 800fe30:	20012534 	.word	0x20012534

0800fe34 <USER_Motor_Mspinit>:
}


void USER_Motor_Mspinit(void)
{
 800fe34:	b580      	push	{r7, lr}
 800fe36:	b088      	sub	sp, #32
 800fe38:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_Init;
    /* Enable GPIO clock */
	FAN_GPIOE_CLK_ENABLE();
 800fe3a:	4a30      	ldr	r2, [pc, #192]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe3c:	4b2f      	ldr	r3, [pc, #188]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fe40:	f043 0310 	orr.w	r3, r3, #16
 800fe44:	6313      	str	r3, [r2, #48]	; 0x30
 800fe46:	4b2d      	ldr	r3, [pc, #180]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fe4a:	f003 0310 	and.w	r3, r3, #16
 800fe4e:	60bb      	str	r3, [r7, #8]
 800fe50:	68bb      	ldr	r3, [r7, #8]

    /* GPIO pin configuration  */
 	GPIO_Init.Pin = FAN_PIN;
 800fe52:	2340      	movs	r3, #64	; 0x40
 800fe54:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = FAN_MODE;
 800fe56:	2301      	movs	r3, #1
 800fe58:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 800fe5a:	2301      	movs	r3, #1
 800fe5c:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 800fe5e:	2300      	movs	r3, #0
 800fe60:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(FAN_GPIO_PORT,&GPIO_Init);	
 800fe62:	f107 030c 	add.w	r3, r7, #12
 800fe66:	4826      	ldr	r0, [pc, #152]	; (800ff00 <USER_Motor_Mspinit+0xcc>)
 800fe68:	4619      	mov	r1, r3
 800fe6a:	f7f8 f8a1 	bl	8007fb0 <HAL_GPIO_Init>
	
	HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_SET);
 800fe6e:	4824      	ldr	r0, [pc, #144]	; (800ff00 <USER_Motor_Mspinit+0xcc>)
 800fe70:	2140      	movs	r1, #64	; 0x40
 800fe72:	2201      	movs	r2, #1
 800fe74:	f7f8 fb64 	bl	8008540 <HAL_GPIO_WritePin>

    /* Enable GPIO clock */
	TS0_GPIOE_CLK_ENABLE();
 800fe78:	4a20      	ldr	r2, [pc, #128]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe7a:	4b20      	ldr	r3, [pc, #128]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe7c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fe7e:	f043 0310 	orr.w	r3, r3, #16
 800fe82:	6313      	str	r3, [r2, #48]	; 0x30
 800fe84:	4b1d      	ldr	r3, [pc, #116]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fe88:	f003 0310 	and.w	r3, r3, #16
 800fe8c:	607b      	str	r3, [r7, #4]
 800fe8e:	687b      	ldr	r3, [r7, #4]
	TS1_GPIOE_CLK_ENABLE();
 800fe90:	4a1a      	ldr	r2, [pc, #104]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe92:	4b1a      	ldr	r3, [pc, #104]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fe96:	f043 0310 	orr.w	r3, r3, #16
 800fe9a:	6313      	str	r3, [r2, #48]	; 0x30
 800fe9c:	4b17      	ldr	r3, [pc, #92]	; (800fefc <USER_Motor_Mspinit+0xc8>)
 800fe9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fea0:	f003 0310 	and.w	r3, r3, #16
 800fea4:	603b      	str	r3, [r7, #0]
 800fea6:	683b      	ldr	r3, [r7, #0]
	
    /* GPIO pin configuration  */
 	GPIO_Init.Pin = TS0_PIN;
 800fea8:	2308      	movs	r3, #8
 800feaa:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = TS0_MODE;
 800feac:	2301      	movs	r3, #1
 800feae:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 800feb0:	2301      	movs	r3, #1
 800feb2:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 800feb4:	2300      	movs	r3, #0
 800feb6:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(TS0_GPIO_PORT,&GPIO_Init);
 800feb8:	f107 030c 	add.w	r3, r7, #12
 800febc:	4810      	ldr	r0, [pc, #64]	; (800ff00 <USER_Motor_Mspinit+0xcc>)
 800febe:	4619      	mov	r1, r3
 800fec0:	f7f8 f876 	bl	8007fb0 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN, GPIO_PIN_SET);
 800fec4:	480e      	ldr	r0, [pc, #56]	; (800ff00 <USER_Motor_Mspinit+0xcc>)
 800fec6:	2108      	movs	r1, #8
 800fec8:	2201      	movs	r2, #1
 800feca:	f7f8 fb39 	bl	8008540 <HAL_GPIO_WritePin>
	
	/* GPIO pin configuration  */
 	GPIO_Init.Pin = TS1_PIN;
 800fece:	2320      	movs	r3, #32
 800fed0:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = TS1_MODE;
 800fed2:	2301      	movs	r3, #1
 800fed4:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 800fed6:	2301      	movs	r3, #1
 800fed8:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 800feda:	2300      	movs	r3, #0
 800fedc:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(TS1_GPIO_PORT,&GPIO_Init);
 800fede:	f107 030c 	add.w	r3, r7, #12
 800fee2:	4807      	ldr	r0, [pc, #28]	; (800ff00 <USER_Motor_Mspinit+0xcc>)
 800fee4:	4619      	mov	r1, r3
 800fee6:	f7f8 f863 	bl	8007fb0 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN, GPIO_PIN_SET);
 800feea:	4805      	ldr	r0, [pc, #20]	; (800ff00 <USER_Motor_Mspinit+0xcc>)
 800feec:	2120      	movs	r1, #32
 800feee:	2201      	movs	r2, #1
 800fef0:	f7f8 fb26 	bl	8008540 <HAL_GPIO_WritePin>
}
 800fef4:	3720      	adds	r7, #32
 800fef6:	46bd      	mov	sp, r7
 800fef8:	bd80      	pop	{r7, pc}
 800fefa:	bf00      	nop
 800fefc:	40023800 	.word	0x40023800
 800ff00:	40021000 	.word	0x40021000

0800ff04 <USER_Motor_hwinit>:

int USER_Motor_hwinit(void)
{
 800ff04:	b580      	push	{r7, lr}
 800ff06:	af00      	add	r7, sp, #0
USER_Motor_Mspinit();
 800ff08:	f7ff ff94 	bl	800fe34 <USER_Motor_Mspinit>
return 0;
 800ff0c:	2300      	movs	r3, #0
}
 800ff0e:	4618      	mov	r0, r3
 800ff10:	bd80      	pop	{r7, pc}
 800ff12:	bf00      	nop

0800ff14 <TempSeltest>:

INIT_BOARD_EXPORT(USER_Motor_hwinit);


void TempSeltest(int argc,char **argv)
{
 800ff14:	b580      	push	{r7, lr}
 800ff16:	b082      	sub	sp, #8
 800ff18:	af00      	add	r7, sp, #0
 800ff1a:	6078      	str	r0, [r7, #4]
 800ff1c:	6039      	str	r1, [r7, #0]
	if(strcmp(argv[1],"0")==0){
 800ff1e:	683b      	ldr	r3, [r7, #0]
 800ff20:	3304      	adds	r3, #4
 800ff22:	681b      	ldr	r3, [r3, #0]
 800ff24:	4618      	mov	r0, r3
 800ff26:	492b      	ldr	r1, [pc, #172]	; (800ffd4 <TempSeltest+0xc0>)
 800ff28:	f7f0 fa7e 	bl	8000428 <strcmp>
 800ff2c:	4603      	mov	r3, r0
 800ff2e:	2b00      	cmp	r3, #0
 800ff30:	d10a      	bne.n	800ff48 <TempSeltest+0x34>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_RESET);
 800ff32:	4829      	ldr	r0, [pc, #164]	; (800ffd8 <TempSeltest+0xc4>)
 800ff34:	2108      	movs	r1, #8
 800ff36:	2200      	movs	r2, #0
 800ff38:	f7f8 fb02 	bl	8008540 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_RESET);
 800ff3c:	4826      	ldr	r0, [pc, #152]	; (800ffd8 <TempSeltest+0xc4>)
 800ff3e:	2120      	movs	r1, #32
 800ff40:	2200      	movs	r2, #0
 800ff42:	f7f8 fafd 	bl	8008540 <HAL_GPIO_WritePin>
 800ff46:	e041      	b.n	800ffcc <TempSeltest+0xb8>
	}else if (strcmp(argv[1],"1")==0){
 800ff48:	683b      	ldr	r3, [r7, #0]
 800ff4a:	3304      	adds	r3, #4
 800ff4c:	681b      	ldr	r3, [r3, #0]
 800ff4e:	4618      	mov	r0, r3
 800ff50:	4922      	ldr	r1, [pc, #136]	; (800ffdc <TempSeltest+0xc8>)
 800ff52:	f7f0 fa69 	bl	8000428 <strcmp>
 800ff56:	4603      	mov	r3, r0
 800ff58:	2b00      	cmp	r3, #0
 800ff5a:	d10a      	bne.n	800ff72 <TempSeltest+0x5e>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_SET);
 800ff5c:	481e      	ldr	r0, [pc, #120]	; (800ffd8 <TempSeltest+0xc4>)
 800ff5e:	2108      	movs	r1, #8
 800ff60:	2201      	movs	r2, #1
 800ff62:	f7f8 faed 	bl	8008540 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_RESET);
 800ff66:	481c      	ldr	r0, [pc, #112]	; (800ffd8 <TempSeltest+0xc4>)
 800ff68:	2120      	movs	r1, #32
 800ff6a:	2200      	movs	r2, #0
 800ff6c:	f7f8 fae8 	bl	8008540 <HAL_GPIO_WritePin>
 800ff70:	e02c      	b.n	800ffcc <TempSeltest+0xb8>
	}else if(strcmp(argv[1],"2")==0) {
 800ff72:	683b      	ldr	r3, [r7, #0]
 800ff74:	3304      	adds	r3, #4
 800ff76:	681b      	ldr	r3, [r3, #0]
 800ff78:	4618      	mov	r0, r3
 800ff7a:	4919      	ldr	r1, [pc, #100]	; (800ffe0 <TempSeltest+0xcc>)
 800ff7c:	f7f0 fa54 	bl	8000428 <strcmp>
 800ff80:	4603      	mov	r3, r0
 800ff82:	2b00      	cmp	r3, #0
 800ff84:	d10a      	bne.n	800ff9c <TempSeltest+0x88>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_RESET);
 800ff86:	4814      	ldr	r0, [pc, #80]	; (800ffd8 <TempSeltest+0xc4>)
 800ff88:	2108      	movs	r1, #8
 800ff8a:	2200      	movs	r2, #0
 800ff8c:	f7f8 fad8 	bl	8008540 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_SET);
 800ff90:	4811      	ldr	r0, [pc, #68]	; (800ffd8 <TempSeltest+0xc4>)
 800ff92:	2120      	movs	r1, #32
 800ff94:	2201      	movs	r2, #1
 800ff96:	f7f8 fad3 	bl	8008540 <HAL_GPIO_WritePin>
 800ff9a:	e017      	b.n	800ffcc <TempSeltest+0xb8>
	}else if(strcmp(argv[1],"3")==0) {
 800ff9c:	683b      	ldr	r3, [r7, #0]
 800ff9e:	3304      	adds	r3, #4
 800ffa0:	681b      	ldr	r3, [r3, #0]
 800ffa2:	4618      	mov	r0, r3
 800ffa4:	490f      	ldr	r1, [pc, #60]	; (800ffe4 <TempSeltest+0xd0>)
 800ffa6:	f7f0 fa3f 	bl	8000428 <strcmp>
 800ffaa:	4603      	mov	r3, r0
 800ffac:	2b00      	cmp	r3, #0
 800ffae:	d10a      	bne.n	800ffc6 <TempSeltest+0xb2>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_SET);
 800ffb0:	4809      	ldr	r0, [pc, #36]	; (800ffd8 <TempSeltest+0xc4>)
 800ffb2:	2108      	movs	r1, #8
 800ffb4:	2201      	movs	r2, #1
 800ffb6:	f7f8 fac3 	bl	8008540 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_SET);
 800ffba:	4807      	ldr	r0, [pc, #28]	; (800ffd8 <TempSeltest+0xc4>)
 800ffbc:	2120      	movs	r1, #32
 800ffbe:	2201      	movs	r2, #1
 800ffc0:	f7f8 fabe 	bl	8008540 <HAL_GPIO_WritePin>
 800ffc4:	e002      	b.n	800ffcc <TempSeltest+0xb8>
	}else{
		rt_kprintf("unknown parameter\r\n");
 800ffc6:	4808      	ldr	r0, [pc, #32]	; (800ffe8 <TempSeltest+0xd4>)
 800ffc8:	f003 fe52 	bl	8013c70 <rt_kprintf>
	}
}
 800ffcc:	3708      	adds	r7, #8
 800ffce:	46bd      	mov	sp, r7
 800ffd0:	bd80      	pop	{r7, pc}
 800ffd2:	bf00      	nop
 800ffd4:	08022920 	.word	0x08022920
 800ffd8:	40021000 	.word	0x40021000
 800ffdc:	08022924 	.word	0x08022924
 800ffe0:	08022928 	.word	0x08022928
 800ffe4:	0802292c 	.word	0x0802292c
 800ffe8:	08022930 	.word	0x08022930

0800ffec <FANtest>:
MSH_CMD_EXPORT_ALIAS(TempSeltest,TS,TS 0 or TS 1 or TS 2 or TS 3);


void FANtest(int argc,char**argv)
{
 800ffec:	b580      	push	{r7, lr}
 800ffee:	b082      	sub	sp, #8
 800fff0:	af00      	add	r7, sp, #0
 800fff2:	6078      	str	r0, [r7, #4]
 800fff4:	6039      	str	r1, [r7, #0]
	if (strcmp(argv[1], "on") == 0)
 800fff6:	683b      	ldr	r3, [r7, #0]
 800fff8:	3304      	adds	r3, #4
 800fffa:	681b      	ldr	r3, [r3, #0]
 800fffc:	4618      	mov	r0, r3
 800fffe:	4911      	ldr	r1, [pc, #68]	; (8010044 <FANtest+0x58>)
 8010000:	f7f0 fa12 	bl	8000428 <strcmp>
 8010004:	4603      	mov	r3, r0
 8010006:	2b00      	cmp	r3, #0
 8010008:	d105      	bne.n	8010016 <FANtest+0x2a>
		HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_RESET);
 801000a:	480f      	ldr	r0, [pc, #60]	; (8010048 <FANtest+0x5c>)
 801000c:	2140      	movs	r1, #64	; 0x40
 801000e:	2200      	movs	r2, #0
 8010010:	f7f8 fa96 	bl	8008540 <HAL_GPIO_WritePin>
 8010014:	e012      	b.n	801003c <FANtest+0x50>
	else if(strcmp(argv[1], "off") == 0)
 8010016:	683b      	ldr	r3, [r7, #0]
 8010018:	3304      	adds	r3, #4
 801001a:	681b      	ldr	r3, [r3, #0]
 801001c:	4618      	mov	r0, r3
 801001e:	490b      	ldr	r1, [pc, #44]	; (801004c <FANtest+0x60>)
 8010020:	f7f0 fa02 	bl	8000428 <strcmp>
 8010024:	4603      	mov	r3, r0
 8010026:	2b00      	cmp	r3, #0
 8010028:	d105      	bne.n	8010036 <FANtest+0x4a>
		HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_SET);
 801002a:	4807      	ldr	r0, [pc, #28]	; (8010048 <FANtest+0x5c>)
 801002c:	2140      	movs	r1, #64	; 0x40
 801002e:	2201      	movs	r2, #1
 8010030:	f7f8 fa86 	bl	8008540 <HAL_GPIO_WritePin>
 8010034:	e002      	b.n	801003c <FANtest+0x50>
	else
		rt_kprintf("unknown parameter\r\n");
 8010036:	4806      	ldr	r0, [pc, #24]	; (8010050 <FANtest+0x64>)
 8010038:	f003 fe1a 	bl	8013c70 <rt_kprintf>
}
 801003c:	3708      	adds	r7, #8
 801003e:	46bd      	mov	sp, r7
 8010040:	bd80      	pop	{r7, pc}
 8010042:	bf00      	nop
 8010044:	08022944 	.word	0x08022944
 8010048:	40021000 	.word	0x40021000
 801004c:	08022948 	.word	0x08022948
 8010050:	08022930 	.word	0x08022930

08010054 <ADCtest>:
MSH_CMD_EXPORT(FANtest,FANtest on or FANtest off);

void ADCtest(int argc,char**argv)
{
 8010054:	b580      	push	{r7, lr}
 8010056:	b082      	sub	sp, #8
 8010058:	af00      	add	r7, sp, #0
 801005a:	6078      	str	r0, [r7, #4]
 801005c:	6039      	str	r1, [r7, #0]
	rt_kprintf("temp= 0x%x \r\n", Global_User_ADC.Temp.TEMP_value);
 801005e:	4b50      	ldr	r3, [pc, #320]	; (80101a0 <ADCtest+0x14c>)
 8010060:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8010064:	b21b      	sxth	r3, r3
 8010066:	484f      	ldr	r0, [pc, #316]	; (80101a4 <ADCtest+0x150>)
 8010068:	4619      	mov	r1, r3
 801006a:	f003 fe01 	bl	8013c70 <rt_kprintf>
	rt_kprintf("BUS V= 0x%x \r\n", Global_User_ADC.BUS.qV_value);
 801006e:	4b4c      	ldr	r3, [pc, #304]	; (80101a0 <ADCtest+0x14c>)
 8010070:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 8010072:	b21b      	sxth	r3, r3
 8010074:	484c      	ldr	r0, [pc, #304]	; (80101a8 <ADCtest+0x154>)
 8010076:	4619      	mov	r1, r3
 8010078:	f003 fdfa 	bl	8013c70 <rt_kprintf>
	rt_kprintf("BUS I= 0x%x \r\n", Global_User_ADC.BUS.qI_value);
 801007c:	4b48      	ldr	r3, [pc, #288]	; (80101a0 <ADCtest+0x14c>)
 801007e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8010080:	b21b      	sxth	r3, r3
 8010082:	484a      	ldr	r0, [pc, #296]	; (80101ac <ADCtest+0x158>)
 8010084:	4619      	mov	r1, r3
 8010086:	f003 fdf3 	bl	8013c70 <rt_kprintf>
	rt_kprintf("VOLTAGE C= 0x%x \r\n", Global_User_ADC.PhaseC.qV_value);
 801008a:	4b45      	ldr	r3, [pc, #276]	; (80101a0 <ADCtest+0x14c>)
 801008c:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 801008e:	b21b      	sxth	r3, r3
 8010090:	4847      	ldr	r0, [pc, #284]	; (80101b0 <ADCtest+0x15c>)
 8010092:	4619      	mov	r1, r3
 8010094:	f003 fdec 	bl	8013c70 <rt_kprintf>
	rt_kprintf("VOLTAGE B= 0x%x \r\n", Global_User_ADC.PhaseB.qV_value);
 8010098:	4b41      	ldr	r3, [pc, #260]	; (80101a0 <ADCtest+0x14c>)
 801009a:	8b1b      	ldrh	r3, [r3, #24]
 801009c:	b21b      	sxth	r3, r3
 801009e:	4845      	ldr	r0, [pc, #276]	; (80101b4 <ADCtest+0x160>)
 80100a0:	4619      	mov	r1, r3
 80100a2:	f003 fde5 	bl	8013c70 <rt_kprintf>
	rt_kprintf("VOLTAGE A= 0x%x \r\n", Global_User_ADC.PhaseA.qV_value);
 80100a6:	4b3e      	ldr	r3, [pc, #248]	; (80101a0 <ADCtest+0x14c>)
 80100a8:	895b      	ldrh	r3, [r3, #10]
 80100aa:	b21b      	sxth	r3, r3
 80100ac:	4842      	ldr	r0, [pc, #264]	; (80101b8 <ADCtest+0x164>)
 80100ae:	4619      	mov	r1, r3
 80100b0:	f003 fdde 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current C2= 0x%x \r\n", Global_User_ADC.PhaseC.qI2_value);
 80100b4:	4b3a      	ldr	r3, [pc, #232]	; (80101a0 <ADCtest+0x14c>)
 80100b6:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80100b8:	b21b      	sxth	r3, r3
 80100ba:	4840      	ldr	r0, [pc, #256]	; (80101bc <ADCtest+0x168>)
 80100bc:	4619      	mov	r1, r3
 80100be:	f003 fdd7 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current C1= 0x%x \r\n", Global_User_ADC.PhaseC.qI1_value);
 80100c2:	4b37      	ldr	r3, [pc, #220]	; (80101a0 <ADCtest+0x14c>)
 80100c4:	8b9b      	ldrh	r3, [r3, #28]
 80100c6:	b21b      	sxth	r3, r3
 80100c8:	483d      	ldr	r0, [pc, #244]	; (80101c0 <ADCtest+0x16c>)
 80100ca:	4619      	mov	r1, r3
 80100cc:	f003 fdd0 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current B2= 0x%x \r\n", Global_User_ADC.PhaseB.qI2_value);
 80100d0:	4b33      	ldr	r3, [pc, #204]	; (80101a0 <ADCtest+0x14c>)
 80100d2:	8a9b      	ldrh	r3, [r3, #20]
 80100d4:	b21b      	sxth	r3, r3
 80100d6:	483b      	ldr	r0, [pc, #236]	; (80101c4 <ADCtest+0x170>)
 80100d8:	4619      	mov	r1, r3
 80100da:	f003 fdc9 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current B1= 0x%x \r\n", Global_User_ADC.PhaseB.qI1_value);
 80100de:	4b30      	ldr	r3, [pc, #192]	; (80101a0 <ADCtest+0x14c>)
 80100e0:	89db      	ldrh	r3, [r3, #14]
 80100e2:	b21b      	sxth	r3, r3
 80100e4:	4838      	ldr	r0, [pc, #224]	; (80101c8 <ADCtest+0x174>)
 80100e6:	4619      	mov	r1, r3
 80100e8:	f003 fdc2 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current A2= 0x%x \r\n", Global_User_ADC.PhaseA.qI2_value);
 80100ec:	4b2c      	ldr	r3, [pc, #176]	; (80101a0 <ADCtest+0x14c>)
 80100ee:	88db      	ldrh	r3, [r3, #6]
 80100f0:	b21b      	sxth	r3, r3
 80100f2:	4836      	ldr	r0, [pc, #216]	; (80101cc <ADCtest+0x178>)
 80100f4:	4619      	mov	r1, r3
 80100f6:	f003 fdbb 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current A1= 0x%x \r\n", Global_User_ADC.PhaseA.qI1_value);
 80100fa:	4b29      	ldr	r3, [pc, #164]	; (80101a0 <ADCtest+0x14c>)
 80100fc:	881b      	ldrh	r3, [r3, #0]
 80100fe:	b21b      	sxth	r3, r3
 8010100:	4833      	ldr	r0, [pc, #204]	; (80101d0 <ADCtest+0x17c>)
 8010102:	4619      	mov	r1, r3
 8010104:	f003 fdb4 	bl	8013c70 <rt_kprintf>

	
	rt_kprintf("temp offset= 0x%x \r\n", Global_User_ADC.Temp.TEMP_offset);
 8010108:	4b25      	ldr	r3, [pc, #148]	; (80101a0 <ADCtest+0x14c>)
 801010a:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 801010e:	4831      	ldr	r0, [pc, #196]	; (80101d4 <ADCtest+0x180>)
 8010110:	4619      	mov	r1, r3
 8010112:	f003 fdad 	bl	8013c70 <rt_kprintf>
	rt_kprintf("BUS V  offset= 0x%x \r\n", Global_User_ADC.BUS.qV_offset);
 8010116:	4b22      	ldr	r3, [pc, #136]	; (80101a0 <ADCtest+0x14c>)
 8010118:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801011a:	482f      	ldr	r0, [pc, #188]	; (80101d8 <ADCtest+0x184>)
 801011c:	4619      	mov	r1, r3
 801011e:	f003 fda7 	bl	8013c70 <rt_kprintf>
	rt_kprintf("BUS I offset= 0x%x \r\n", Global_User_ADC.BUS.qI_offset);
 8010122:	4b1f      	ldr	r3, [pc, #124]	; (80101a0 <ADCtest+0x14c>)
 8010124:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8010126:	482d      	ldr	r0, [pc, #180]	; (80101dc <ADCtest+0x188>)
 8010128:	4619      	mov	r1, r3
 801012a:	f003 fda1 	bl	8013c70 <rt_kprintf>
	rt_kprintf("VOLTAGE C offset= 0x%x \r\n", Global_User_ADC.PhaseC.qV_offset);
 801012e:	4b1c      	ldr	r3, [pc, #112]	; (80101a0 <ADCtest+0x14c>)
 8010130:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8010132:	482b      	ldr	r0, [pc, #172]	; (80101e0 <ADCtest+0x18c>)
 8010134:	4619      	mov	r1, r3
 8010136:	f003 fd9b 	bl	8013c70 <rt_kprintf>
	rt_kprintf("VOLTAGE B offset= 0x%x \r\n", Global_User_ADC.PhaseB.qV_offset);
 801013a:	4b19      	ldr	r3, [pc, #100]	; (80101a0 <ADCtest+0x14c>)
 801013c:	8b5b      	ldrh	r3, [r3, #26]
 801013e:	4829      	ldr	r0, [pc, #164]	; (80101e4 <ADCtest+0x190>)
 8010140:	4619      	mov	r1, r3
 8010142:	f003 fd95 	bl	8013c70 <rt_kprintf>
	rt_kprintf("VOLTAGE A offset= 0x%x \r\n", Global_User_ADC.PhaseA.qV_offset);
 8010146:	4b16      	ldr	r3, [pc, #88]	; (80101a0 <ADCtest+0x14c>)
 8010148:	899b      	ldrh	r3, [r3, #12]
 801014a:	4827      	ldr	r0, [pc, #156]	; (80101e8 <ADCtest+0x194>)
 801014c:	4619      	mov	r1, r3
 801014e:	f003 fd8f 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current C2 offset= 0x%x \r\n", Global_User_ADC.PhaseC.qI2_offset);
 8010152:	4b13      	ldr	r3, [pc, #76]	; (80101a0 <ADCtest+0x14c>)
 8010154:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8010156:	4825      	ldr	r0, [pc, #148]	; (80101ec <ADCtest+0x198>)
 8010158:	4619      	mov	r1, r3
 801015a:	f003 fd89 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current C1 offset= 0x%x \r\n", Global_User_ADC.PhaseC.qI1_offset);
 801015e:	4b10      	ldr	r3, [pc, #64]	; (80101a0 <ADCtest+0x14c>)
 8010160:	8c1b      	ldrh	r3, [r3, #32]
 8010162:	4823      	ldr	r0, [pc, #140]	; (80101f0 <ADCtest+0x19c>)
 8010164:	4619      	mov	r1, r3
 8010166:	f003 fd83 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current B2 offset= 0x%x \r\n", Global_User_ADC.PhaseB.qI2_offset);
 801016a:	4b0d      	ldr	r3, [pc, #52]	; (80101a0 <ADCtest+0x14c>)
 801016c:	8adb      	ldrh	r3, [r3, #22]
 801016e:	4821      	ldr	r0, [pc, #132]	; (80101f4 <ADCtest+0x1a0>)
 8010170:	4619      	mov	r1, r3
 8010172:	f003 fd7d 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current B1 offset= 0x%x \r\n", Global_User_ADC.PhaseB.qI1_offset);
 8010176:	4b0a      	ldr	r3, [pc, #40]	; (80101a0 <ADCtest+0x14c>)
 8010178:	8a5b      	ldrh	r3, [r3, #18]
 801017a:	481f      	ldr	r0, [pc, #124]	; (80101f8 <ADCtest+0x1a4>)
 801017c:	4619      	mov	r1, r3
 801017e:	f003 fd77 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current A2 offset= 0x%x \r\n", Global_User_ADC.PhaseA.qI2_offset);
 8010182:	4b07      	ldr	r3, [pc, #28]	; (80101a0 <ADCtest+0x14c>)
 8010184:	891b      	ldrh	r3, [r3, #8]
 8010186:	481d      	ldr	r0, [pc, #116]	; (80101fc <ADCtest+0x1a8>)
 8010188:	4619      	mov	r1, r3
 801018a:	f003 fd71 	bl	8013c70 <rt_kprintf>
	rt_kprintf("current A1 offset= 0x%x \r\n", Global_User_ADC.PhaseA.qI1_offset);
 801018e:	4b04      	ldr	r3, [pc, #16]	; (80101a0 <ADCtest+0x14c>)
 8010190:	889b      	ldrh	r3, [r3, #4]
 8010192:	481b      	ldr	r0, [pc, #108]	; (8010200 <ADCtest+0x1ac>)
 8010194:	4619      	mov	r1, r3
 8010196:	f003 fd6b 	bl	8013c70 <rt_kprintf>
}
 801019a:	3708      	adds	r7, #8
 801019c:	46bd      	mov	sp, r7
 801019e:	bd80      	pop	{r7, pc}
 80101a0:	2001235c 	.word	0x2001235c
 80101a4:	0802294c 	.word	0x0802294c
 80101a8:	0802295c 	.word	0x0802295c
 80101ac:	0802296c 	.word	0x0802296c
 80101b0:	0802297c 	.word	0x0802297c
 80101b4:	08022990 	.word	0x08022990
 80101b8:	080229a4 	.word	0x080229a4
 80101bc:	080229b8 	.word	0x080229b8
 80101c0:	080229cc 	.word	0x080229cc
 80101c4:	080229e0 	.word	0x080229e0
 80101c8:	080229f4 	.word	0x080229f4
 80101cc:	08022a08 	.word	0x08022a08
 80101d0:	08022a1c 	.word	0x08022a1c
 80101d4:	08022a30 	.word	0x08022a30
 80101d8:	08022a48 	.word	0x08022a48
 80101dc:	08022a60 	.word	0x08022a60
 80101e0:	08022a78 	.word	0x08022a78
 80101e4:	08022a94 	.word	0x08022a94
 80101e8:	08022ab0 	.word	0x08022ab0
 80101ec:	08022acc 	.word	0x08022acc
 80101f0:	08022ae8 	.word	0x08022ae8
 80101f4:	08022b04 	.word	0x08022b04
 80101f8:	08022b20 	.word	0x08022b20
 80101fc:	08022b3c 	.word	0x08022b3c
 8010200:	08022b58 	.word	0x08022b58

08010204 <PWMset>:
MSH_CMD_EXPORT(ADCtest,ADCtest print ADCValue);


void PWMset(int argc,char **argv)
{
 8010204:	b5b0      	push	{r4, r5, r7, lr}
 8010206:	b082      	sub	sp, #8
 8010208:	af00      	add	r7, sp, #0
 801020a:	6078      	str	r0, [r7, #4]
 801020c:	6039      	str	r1, [r7, #0]
		SetDutyCycles(TIM8, atoi(argv[1]), atoi(argv[2]), atoi(argv[3]));
 801020e:	683b      	ldr	r3, [r7, #0]
 8010210:	3304      	adds	r3, #4
 8010212:	681b      	ldr	r3, [r3, #0]
 8010214:	4618      	mov	r0, r3
 8010216:	f00e fe3f 	bl	801ee98 <atoi>
 801021a:	4603      	mov	r3, r0
 801021c:	b29d      	uxth	r5, r3
 801021e:	683b      	ldr	r3, [r7, #0]
 8010220:	3308      	adds	r3, #8
 8010222:	681b      	ldr	r3, [r3, #0]
 8010224:	4618      	mov	r0, r3
 8010226:	f00e fe37 	bl	801ee98 <atoi>
 801022a:	4603      	mov	r3, r0
 801022c:	b29c      	uxth	r4, r3
 801022e:	683b      	ldr	r3, [r7, #0]
 8010230:	330c      	adds	r3, #12
 8010232:	681b      	ldr	r3, [r3, #0]
 8010234:	4618      	mov	r0, r3
 8010236:	f00e fe2f 	bl	801ee98 <atoi>
 801023a:	4603      	mov	r3, r0
 801023c:	b29b      	uxth	r3, r3
 801023e:	4804      	ldr	r0, [pc, #16]	; (8010250 <PWMset+0x4c>)
 8010240:	4629      	mov	r1, r5
 8010242:	4622      	mov	r2, r4
 8010244:	f7fe fcfe 	bl	800ec44 <SetDutyCycles>
}
 8010248:	3708      	adds	r7, #8
 801024a:	46bd      	mov	sp, r7
 801024c:	bdb0      	pop	{r4, r5, r7, pc}
 801024e:	bf00      	nop
 8010250:	40010400 	.word	0x40010400

08010254 <PWMdis>:
MSH_CMD_EXPORT(PWMset,PWMset T1 T2 T3);


void PWMdis(int argc, char **argv)
{
 8010254:	b580      	push	{r7, lr}
 8010256:	b082      	sub	sp, #8
 8010258:	af00      	add	r7, sp, #0
 801025a:	6078      	str	r0, [r7, #4]
 801025c:	6039      	str	r1, [r7, #0]
	PWMOutputsDisable(TIM8);
 801025e:	4803      	ldr	r0, [pc, #12]	; (801026c <PWMdis+0x18>)
 8010260:	f7fe fd2a 	bl	800ecb8 <PWMOutputsDisable>

}
 8010264:	3708      	adds	r7, #8
 8010266:	46bd      	mov	sp, r7
 8010268:	bd80      	pop	{r7, pc}
 801026a:	bf00      	nop
 801026c:	40010400 	.word	0x40010400

08010270 <PWMen>:
MSH_CMD_EXPORT(PWMdis,PWMdisable);

void PWMen(int argc, char **argv)
{
 8010270:	b580      	push	{r7, lr}
 8010272:	b082      	sub	sp, #8
 8010274:	af00      	add	r7, sp, #0
 8010276:	6078      	str	r0, [r7, #4]
 8010278:	6039      	str	r1, [r7, #0]
	PWMOutputsEnable(TIM8);
 801027a:	4803      	ldr	r0, [pc, #12]	; (8010288 <PWMen+0x18>)
 801027c:	f7fe fcfe 	bl	800ec7c <PWMOutputsEnable>

}
 8010280:	3708      	adds	r7, #8
 8010282:	46bd      	mov	sp, r7
 8010284:	bd80      	pop	{r7, pc}
 8010286:	bf00      	nop
 8010288:	40010400 	.word	0x40010400

0801028c <MCctrl>:
MSH_CMD_EXPORT(PWMen,PWMenable);


void MCctrl(int argc,char**argv)
{
 801028c:	b580      	push	{r7, lr}
 801028e:	b082      	sub	sp, #8
 8010290:	af00      	add	r7, sp, #0
 8010292:	6078      	str	r0, [r7, #4]
 8010294:	6039      	str	r1, [r7, #0]
	if (strcmp(argv[1], "on") == 0)
 8010296:	683b      	ldr	r3, [r7, #0]
 8010298:	3304      	adds	r3, #4
 801029a:	681b      	ldr	r3, [r3, #0]
 801029c:	4618      	mov	r0, r3
 801029e:	4910      	ldr	r1, [pc, #64]	; (80102e0 <MCctrl+0x54>)
 80102a0:	f7f0 f8c2 	bl	8000428 <strcmp>
 80102a4:	4603      	mov	r3, r0
 80102a6:	2b00      	cmp	r3, #0
 80102a8:	d106      	bne.n	80102b8 <MCctrl+0x2c>
	{
		State = INIT;
 80102aa:	4b0e      	ldr	r3, [pc, #56]	; (80102e4 <MCctrl+0x58>)
 80102ac:	2201      	movs	r2, #1
 80102ae:	701a      	strb	r2, [r3, #0]
		rt_kprintf("Motor is started\r\n");
 80102b0:	480d      	ldr	r0, [pc, #52]	; (80102e8 <MCctrl+0x5c>)
 80102b2:	f003 fcdd 	bl	8013c70 <rt_kprintf>
 80102b6:	e00f      	b.n	80102d8 <MCctrl+0x4c>
	}
	else if(strcmp(argv[1], "off") == 0)
 80102b8:	683b      	ldr	r3, [r7, #0]
 80102ba:	3304      	adds	r3, #4
 80102bc:	681b      	ldr	r3, [r3, #0]
 80102be:	4618      	mov	r0, r3
 80102c0:	490a      	ldr	r1, [pc, #40]	; (80102ec <MCctrl+0x60>)
 80102c2:	f7f0 f8b1 	bl	8000428 <strcmp>
 80102c6:	4603      	mov	r3, r0
 80102c8:	2b00      	cmp	r3, #0
 80102ca:	d105      	bne.n	80102d8 <MCctrl+0x4c>
	{
		State = STOP;
 80102cc:	4b05      	ldr	r3, [pc, #20]	; (80102e4 <MCctrl+0x58>)
 80102ce:	2204      	movs	r2, #4
 80102d0:	701a      	strb	r2, [r3, #0]
		rt_kprintf("Motor is stopped\r\n");
 80102d2:	4807      	ldr	r0, [pc, #28]	; (80102f0 <MCctrl+0x64>)
 80102d4:	f003 fccc 	bl	8013c70 <rt_kprintf>
	}
}
 80102d8:	3708      	adds	r7, #8
 80102da:	46bd      	mov	sp, r7
 80102dc:	bd80      	pop	{r7, pc}
 80102de:	bf00      	nop
 80102e0:	08022944 	.word	0x08022944
 80102e4:	20012528 	.word	0x20012528
 80102e8:	08022b74 	.word	0x08022b74
 80102ec:	08022948 	.word	0x08022948
 80102f0:	08022b88 	.word	0x08022b88

080102f4 <QEPtest>:
MSH_CMD_EXPORT(MCctrl,MCctrl on or MCctrl off);

#ifdef ENCODER
void QEPtest(int argc,char**argv)
{
 80102f4:	b580      	push	{r7, lr}
 80102f6:	b082      	sub	sp, #8
 80102f8:	af00      	add	r7, sp, #0
 80102fa:	6078      	str	r0, [r7, #4]
 80102fc:	6039      	str	r1, [r7, #0]
	rt_kprintf("TIM5 CNT =%x\r\n",GetCounterValue(TIM5) );
 80102fe:	4805      	ldr	r0, [pc, #20]	; (8010314 <QEPtest+0x20>)
 8010300:	f7fe f906 	bl	800e510 <GetCounterValue>
 8010304:	4603      	mov	r3, r0
 8010306:	4804      	ldr	r0, [pc, #16]	; (8010318 <QEPtest+0x24>)
 8010308:	4619      	mov	r1, r3
 801030a:	f003 fcb1 	bl	8013c70 <rt_kprintf>
}
 801030e:	3708      	adds	r7, #8
 8010310:	46bd      	mov	sp, r7
 8010312:	bd80      	pop	{r7, pc}
 8010314:	40000c00 	.word	0x40000c00
 8010318:	08022b9c 	.word	0x08022b9c

0801031c <USER_MotorTask_init>:
MSH_CMD_EXPORT(QEPtest,QEPtest);
#endif

int USER_MotorTask_init()
{
 801031c:	b580      	push	{r7, lr}
 801031e:	b084      	sub	sp, #16
 8010320:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	
	tid = rt_thread_create("Motor",
 8010322:	230a      	movs	r3, #10
 8010324:	9300      	str	r3, [sp, #0]
 8010326:	2314      	movs	r3, #20
 8010328:	9301      	str	r3, [sp, #4]
 801032a:	4809      	ldr	r0, [pc, #36]	; (8010350 <USER_MotorTask_init+0x34>)
 801032c:	4909      	ldr	r1, [pc, #36]	; (8010354 <USER_MotorTask_init+0x38>)
 801032e:	2200      	movs	r2, #0
 8010330:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8010334:	f004 fe70 	bl	8015018 <rt_thread_create>
 8010338:	6078      	str	r0, [r7, #4]
                           USER_MotorTask_entry, RT_NULL,
                           1024, USER_MOTORTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 801033a:	687b      	ldr	r3, [r7, #4]
 801033c:	2b00      	cmp	r3, #0
 801033e:	d002      	beq.n	8010346 <USER_MotorTask_init+0x2a>
 8010340:	6878      	ldr	r0, [r7, #4]
 8010342:	f004 fe2b 	bl	8014f9c <rt_thread_startup>

    return 0;
 8010346:	2300      	movs	r3, #0
}
 8010348:	4618      	mov	r0, r3
 801034a:	3708      	adds	r7, #8
 801034c:	46bd      	mov	sp, r7
 801034e:	bd80      	pop	{r7, pc}
 8010350:	08022bac 	.word	0x08022bac
 8010354:	0800fc85 	.word	0x0800fc85

08010358 <rt_init_thread_entry>:

#include <rtthread.h>
#include <components.h>

void rt_init_thread_entry(void *parameter)
{
 8010358:	b580      	push	{r7, lr}
 801035a:	b082      	sub	sp, #8
 801035c:	af00      	add	r7, sp, #0
 801035e:	6078      	str	r0, [r7, #4]
    rt_components_init();
 8010360:	f001 fdb8 	bl	8011ed4 <rt_components_init>
}
 8010364:	3708      	adds	r7, #8
 8010366:	46bd      	mov	sp, r7
 8010368:	bd80      	pop	{r7, pc}
 801036a:	bf00      	nop

0801036c <rt_application_init>:

int rt_application_init()
{
 801036c:	b580      	push	{r7, lr}
 801036e:	b084      	sub	sp, #16
 8010370:	af02      	add	r7, sp, #8
    rt_thread_t tid;

    tid = rt_thread_create("init",
 8010372:	230a      	movs	r3, #10
 8010374:	9300      	str	r3, [sp, #0]
 8010376:	2314      	movs	r3, #20
 8010378:	9301      	str	r3, [sp, #4]
 801037a:	4809      	ldr	r0, [pc, #36]	; (80103a0 <rt_application_init+0x34>)
 801037c:	4909      	ldr	r1, [pc, #36]	; (80103a4 <rt_application_init+0x38>)
 801037e:	2200      	movs	r2, #0
 8010380:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8010384:	f004 fe48 	bl	8015018 <rt_thread_create>
 8010388:	6078      	str	r0, [r7, #4]
                           rt_init_thread_entry, RT_NULL,
                           2048, RT_THREAD_PRIORITY_MAX / 3, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 801038a:	687b      	ldr	r3, [r7, #4]
 801038c:	2b00      	cmp	r3, #0
 801038e:	d002      	beq.n	8010396 <rt_application_init+0x2a>
 8010390:	6878      	ldr	r0, [r7, #4]
 8010392:	f004 fe03 	bl	8014f9c <rt_thread_startup>

    return 0;
 8010396:	2300      	movs	r3, #0
}
 8010398:	4618      	mov	r0, r3
 801039a:	3708      	adds	r7, #8
 801039c:	46bd      	mov	sp, r7
 801039e:	bd80      	pop	{r7, pc}
 80103a0:	08022bb4 	.word	0x08022bb4
 80103a4:	08010359 	.word	0x08010359

080103a8 <sram_init>:

#ifdef RT_USING_EXT_SDRAM
struct rt_memheap system_heap;

void sram_init(void)
{
 80103a8:	b580      	push	{r7, lr}
 80103aa:	af00      	add	r7, sp, #0
    /* initialize the built-in SRAM as a memory heap */
    rt_memheap_init(&system_heap,
                    "system",
                    (void *)HEAP_BEGIN,
                    (rt_uint32_t)HEAP_END - (rt_uint32_t)HEAP_BEGIN);
 80103ac:	4a04      	ldr	r2, [pc, #16]	; (80103c0 <sram_init+0x18>)
struct rt_memheap system_heap;

void sram_init(void)
{
    /* initialize the built-in SRAM as a memory heap */
    rt_memheap_init(&system_heap,
 80103ae:	4b05      	ldr	r3, [pc, #20]	; (80103c4 <sram_init+0x1c>)
 80103b0:	1a9b      	subs	r3, r3, r2
 80103b2:	4805      	ldr	r0, [pc, #20]	; (80103c8 <sram_init+0x20>)
 80103b4:	4905      	ldr	r1, [pc, #20]	; (80103cc <sram_init+0x24>)
 80103b6:	4a02      	ldr	r2, [pc, #8]	; (80103c0 <sram_init+0x18>)
 80103b8:	f004 f8da 	bl	8014570 <rt_memheap_init>
                    "system",
                    (void *)HEAP_BEGIN,
                    (rt_uint32_t)HEAP_END - (rt_uint32_t)HEAP_BEGIN);
}
 80103bc:	bd80      	pop	{r7, pc}
 80103be:	bf00      	nop
 80103c0:	20012afc 	.word	0x20012afc
 80103c4:	20050000 	.word	0x20050000
 80103c8:	2001246c 	.word	0x2001246c
 80103cc:	08022bbc 	.word	0x08022bbc

080103d0 <rtthread_startup>:

/**
 * This function will startup RT-Thread RTOS.
 */
void rtthread_startup(void)
{
 80103d0:	b580      	push	{r7, lr}
 80103d2:	af00      	add	r7, sp, #0
    /* init board */
    rt_hw_board_init();
 80103d4:	f7fd f982 	bl	800d6dc <rt_hw_board_init>

    /* show version */
    rt_show_version();
 80103d8:	f003 f80a 	bl	80133f0 <rt_show_version>

    /* init tick */
    rt_system_tick_init();
 80103dc:	f001 fcfe 	bl	8011ddc <rt_system_tick_init>

    /* init kernel object */
    rt_system_object_init();
 80103e0:	f004 f99a 	bl	8014718 <rt_system_object_init>

    /* init timer system */
    rt_system_timer_init();
 80103e4:	f005 fb78 	bl	8015ad8 <rt_system_timer_init>

#ifdef RT_USING_EXT_SDRAM
    sdram_hw_init();
 80103e8:	f7fe fb66 	bl	800eab8 <sdram_hw_init>
    rt_system_heap_init((void*)EXT_SDRAM_BEGIN, (void*)EXT_SDRAM_END);
 80103ec:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
 80103f0:	4908      	ldr	r1, [pc, #32]	; (8010414 <rtthread_startup+0x44>)
 80103f2:	f003 fd5d 	bl	8013eb0 <rt_system_heap_init>
    sram_init();
 80103f6:	f7ff ffd7 	bl	80103a8 <sram_init>
#else
    rt_system_heap_init((void*)HEAP_BEGIN, (void*)HEAP_END);
#endif

    /* init scheduler system */
    rt_system_scheduler_init();
 80103fa:	f004 fb3f 	bl	8014a7c <rt_system_scheduler_init>

    /* init application */
    rt_application_init();
 80103fe:	f7ff ffb5 	bl	801036c <rt_application_init>

    /* init timer thread */
    rt_system_timer_thread_init();
 8010402:	f005 fb81 	bl	8015b08 <rt_system_timer_thread_init>

    /* init idle thread */
    rt_thread_idle_init();
 8010406:	f001 ffd5 	bl	80123b4 <rt_thread_idle_init>
    /* start scheduler */
    rt_system_scheduler_start();
 801040a:	f004 fb61 	bl	8014ad0 <rt_system_scheduler_start>

    /* never reach here */
    return ;
 801040e:	bf00      	nop
}
 8010410:	bd80      	pop	{r7, pc}
 8010412:	bf00      	nop
 8010414:	c0100000 	.word	0xc0100000

08010418 <main>:

int main(void)
{
 8010418:	b580      	push	{r7, lr}
 801041a:	af00      	add	r7, sp, #0
    /* disable interrupt first */
    rt_hw_interrupt_disable();
 801041c:	f7ef fed4 	bl	80001c8 <rt_hw_interrupt_disable>

    /* startup RT-Thread RTOS */
    rtthread_startup();
 8010420:	f7ff ffd6 	bl	80103d0 <rtthread_startup>

    return 0;
 8010424:	2300      	movs	r3, #0
}
 8010426:	4618      	mov	r0, r3
 8010428:	bd80      	pop	{r7, pc}
 801042a:	bf00      	nop

0801042c <myprintf>:
	char size;
};

static rt_mq_t rx_mq;
rt_err_t myprintf(char *buf, uint8_t size)
{
 801042c:	b580      	push	{r7, lr}
 801042e:	b086      	sub	sp, #24
 8010430:	af00      	add	r7, sp, #0
 8010432:	6078      	str	r0, [r7, #4]
 8010434:	460b      	mov	r3, r1
 8010436:	70fb      	strb	r3, [r7, #3]
	struct tx_msg txmsg;
	rt_err_t result = RT_EOK;
 8010438:	2300      	movs	r3, #0
 801043a:	617b      	str	r3, [r7, #20]
	
	if(tx_mq == RT_NULL || txfifo == RT_NULL || buf == RT_NULL)
 801043c:	4b22      	ldr	r3, [pc, #136]	; (80104c8 <myprintf+0x9c>)
 801043e:	681b      	ldr	r3, [r3, #0]
 8010440:	2b00      	cmp	r3, #0
 8010442:	d006      	beq.n	8010452 <myprintf+0x26>
 8010444:	4b21      	ldr	r3, [pc, #132]	; (80104cc <myprintf+0xa0>)
 8010446:	681b      	ldr	r3, [r3, #0]
 8010448:	2b00      	cmp	r3, #0
 801044a:	d002      	beq.n	8010452 <myprintf+0x26>
 801044c:	687b      	ldr	r3, [r7, #4]
 801044e:	2b00      	cmp	r3, #0
 8010450:	d103      	bne.n	801045a <myprintf+0x2e>
		return (result = RT_ERROR);
 8010452:	2301      	movs	r3, #1
 8010454:	617b      	str	r3, [r7, #20]
 8010456:	697b      	ldr	r3, [r7, #20]
 8010458:	e032      	b.n	80104c0 <myprintf+0x94>
	txmsg.size = size;
 801045a:	78fb      	ldrb	r3, [r7, #3]
 801045c:	613b      	str	r3, [r7, #16]
	txmsg.data = buf;
 801045e:	687b      	ldr	r3, [r7, #4]
 8010460:	60fb      	str	r3, [r7, #12]
	txfifo->txmsg[txfifo->index] = txmsg;
 8010462:	4b1a      	ldr	r3, [pc, #104]	; (80104cc <myprintf+0xa0>)
 8010464:	681b      	ldr	r3, [r3, #0]
 8010466:	681a      	ldr	r2, [r3, #0]
 8010468:	4b18      	ldr	r3, [pc, #96]	; (80104cc <myprintf+0xa0>)
 801046a:	681b      	ldr	r3, [r3, #0]
 801046c:	791b      	ldrb	r3, [r3, #4]
 801046e:	00db      	lsls	r3, r3, #3
 8010470:	4413      	add	r3, r2
 8010472:	461a      	mov	r2, r3
 8010474:	f107 030c 	add.w	r3, r7, #12
 8010478:	e893 0003 	ldmia.w	r3, {r0, r1}
 801047c:	e882 0003 	stmia.w	r2, {r0, r1}
	result = rt_mq_send(tx_mq,&(txfifo->txmsg[txfifo->index]),sizeof(struct tx_msg));
 8010480:	4b11      	ldr	r3, [pc, #68]	; (80104c8 <myprintf+0x9c>)
 8010482:	6819      	ldr	r1, [r3, #0]
 8010484:	4b11      	ldr	r3, [pc, #68]	; (80104cc <myprintf+0xa0>)
 8010486:	681b      	ldr	r3, [r3, #0]
 8010488:	681a      	ldr	r2, [r3, #0]
 801048a:	4b10      	ldr	r3, [pc, #64]	; (80104cc <myprintf+0xa0>)
 801048c:	681b      	ldr	r3, [r3, #0]
 801048e:	791b      	ldrb	r3, [r3, #4]
 8010490:	00db      	lsls	r3, r3, #3
 8010492:	4413      	add	r3, r2
 8010494:	4608      	mov	r0, r1
 8010496:	4619      	mov	r1, r3
 8010498:	2208      	movs	r2, #8
 801049a:	f002 fc23 	bl	8012ce4 <rt_mq_send>
 801049e:	6178      	str	r0, [r7, #20]
	txfifo->index++;
 80104a0:	4b0a      	ldr	r3, [pc, #40]	; (80104cc <myprintf+0xa0>)
 80104a2:	681b      	ldr	r3, [r3, #0]
 80104a4:	791a      	ldrb	r2, [r3, #4]
 80104a6:	3201      	adds	r2, #1
 80104a8:	b2d2      	uxtb	r2, r2
 80104aa:	711a      	strb	r2, [r3, #4]
	if(txfifo->index > UART3TXFIFOLENGTH)
 80104ac:	4b07      	ldr	r3, [pc, #28]	; (80104cc <myprintf+0xa0>)
 80104ae:	681b      	ldr	r3, [r3, #0]
 80104b0:	791b      	ldrb	r3, [r3, #4]
 80104b2:	2b03      	cmp	r3, #3
 80104b4:	d903      	bls.n	80104be <myprintf+0x92>
	{
		txfifo->index = 0;
 80104b6:	4b05      	ldr	r3, [pc, #20]	; (80104cc <myprintf+0xa0>)
 80104b8:	681b      	ldr	r3, [r3, #0]
 80104ba:	2200      	movs	r2, #0
 80104bc:	711a      	strb	r2, [r3, #4]
	}
	return result;
 80104be:	697b      	ldr	r3, [r7, #20]
}
 80104c0:	4618      	mov	r0, r3
 80104c2:	3718      	adds	r7, #24
 80104c4:	46bd      	mov	sp, r7
 80104c6:	bd80      	pop	{r7, pc}
 80104c8:	200109f0 	.word	0x200109f0
 80104cc:	200124d0 	.word	0x200124d0

080104d0 <USER_Usart3txTask_entry>:

void USER_Usart3txTask_entry(void *parameter)
{
 80104d0:	b580      	push	{r7, lr}
 80104d2:	b086      	sub	sp, #24
 80104d4:	af00      	add	r7, sp, #0
 80104d6:	6078      	str	r0, [r7, #4]
	
	rt_device_t device;
	device = rt_device_find("uart3");
 80104d8:	4813      	ldr	r0, [pc, #76]	; (8010528 <USER_Usart3txTask_entry+0x58>)
 80104da:	f001 fd3b 	bl	8011f54 <rt_device_find>
 80104de:	6178      	str	r0, [r7, #20]
	rt_err_t result = RT_EOK;
 80104e0:	2300      	movs	r3, #0
 80104e2:	613b      	str	r3, [r7, #16]
	
	struct tx_msg txmsg;
	if ( device != RT_NULL )
 80104e4:	697b      	ldr	r3, [r7, #20]
 80104e6:	2b00      	cmp	r3, #0
 80104e8:	d00a      	beq.n	8010500 <USER_Usart3txTask_entry+0x30>
	{
		
		
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX) != RT_EOK)
 80104ea:	6978      	ldr	r0, [r7, #20]
 80104ec:	f240 1103 	movw	r1, #259	; 0x103
 80104f0:	f001 fd6c 	bl	8011fcc <rt_device_open>
 80104f4:	4603      	mov	r3, r0
 80104f6:	2b00      	cmp	r3, #0
 80104f8:	d002      	beq.n	8010500 <USER_Usart3txTask_entry+0x30>
		{
			rt_kprintf("open error\r\n");
 80104fa:	480c      	ldr	r0, [pc, #48]	; (801052c <USER_Usart3txTask_entry+0x5c>)
 80104fc:	f003 fbb8 	bl	8013c70 <rt_kprintf>
		
	}
	
	while(1)
	{
		rt_mq_recv(tx_mq,&txmsg,sizeof(struct tx_msg),50);
 8010500:	4b0b      	ldr	r3, [pc, #44]	; (8010530 <USER_Usart3txTask_entry+0x60>)
 8010502:	681a      	ldr	r2, [r3, #0]
 8010504:	f107 0308 	add.w	r3, r7, #8
 8010508:	4610      	mov	r0, r2
 801050a:	4619      	mov	r1, r3
 801050c:	2208      	movs	r2, #8
 801050e:	2332      	movs	r3, #50	; 0x32
 8010510:	f002 fc82 	bl	8012e18 <rt_mq_recv>
		
		if (result == RT_EOK)
 8010514:	693b      	ldr	r3, [r7, #16]
 8010516:	2b00      	cmp	r3, #0
 8010518:	d105      	bne.n	8010526 <USER_Usart3txTask_entry+0x56>
		{
			rt_device_write(device, 0,txmsg.data,txmsg.size);
 801051a:	68ba      	ldr	r2, [r7, #8]
 801051c:	68fb      	ldr	r3, [r7, #12]
 801051e:	6978      	ldr	r0, [r7, #20]
 8010520:	2100      	movs	r1, #0
 8010522:	f001 fe39 	bl	8012198 <rt_device_write>
		}
	}
 8010526:	e7eb      	b.n	8010500 <USER_Usart3txTask_entry+0x30>
 8010528:	08022bc4 	.word	0x08022bc4
 801052c:	08022bcc 	.word	0x08022bcc
 8010530:	200109f0 	.word	0x200109f0

08010534 <USER_Usart3txTask_init>:
	
}


int USER_Usart3txTask_init()
{
 8010534:	b580      	push	{r7, lr}
 8010536:	b084      	sub	sp, #16
 8010538:	af02      	add	r7, sp, #8
    rt_thread_t tid;

	
	if ((tx_mq = rt_mq_create("usart3tx", sizeof(struct tx_msg),UART3TXFIFOLENGTH,RT_IPC_FLAG_FIFO)) == RT_NULL)
 801053a:	4821      	ldr	r0, [pc, #132]	; (80105c0 <USER_Usart3txTask_init+0x8c>)
 801053c:	2108      	movs	r1, #8
 801053e:	2203      	movs	r2, #3
 8010540:	2300      	movs	r3, #0
 8010542:	f002 fb11 	bl	8012b68 <rt_mq_create>
 8010546:	4602      	mov	r2, r0
 8010548:	4b1e      	ldr	r3, [pc, #120]	; (80105c4 <USER_Usart3txTask_init+0x90>)
 801054a:	601a      	str	r2, [r3, #0]
 801054c:	4b1d      	ldr	r3, [pc, #116]	; (80105c4 <USER_Usart3txTask_init+0x90>)
 801054e:	681b      	ldr	r3, [r3, #0]
 8010550:	2b00      	cmp	r3, #0
 8010552:	d102      	bne.n	801055a <USER_Usart3txTask_init+0x26>
	{
		rt_kprintf("sem create error\r\n");
 8010554:	481c      	ldr	r0, [pc, #112]	; (80105c8 <USER_Usart3txTask_init+0x94>)
 8010556:	f003 fb8b 	bl	8013c70 <rt_kprintf>
	}
	
	txfifo = (struct Txfifo *)rt_malloc(sizeof(struct Txfifo)+UART3TXFIFOLENGTH*sizeof(struct tx_msg));
 801055a:	2020      	movs	r0, #32
 801055c:	f003 fd36 	bl	8013fcc <rt_malloc>
 8010560:	4602      	mov	r2, r0
 8010562:	4b1a      	ldr	r3, [pc, #104]	; (80105cc <USER_Usart3txTask_init+0x98>)
 8010564:	601a      	str	r2, [r3, #0]
	if(txfifo != RT_NULL)
 8010566:	4b19      	ldr	r3, [pc, #100]	; (80105cc <USER_Usart3txTask_init+0x98>)
 8010568:	681b      	ldr	r3, [r3, #0]
 801056a:	2b00      	cmp	r3, #0
 801056c:	d011      	beq.n	8010592 <USER_Usart3txTask_init+0x5e>
	{
		txfifo->txmsg = (struct tx_msg *)(txfifo+1);
 801056e:	4b17      	ldr	r3, [pc, #92]	; (80105cc <USER_Usart3txTask_init+0x98>)
 8010570:	681b      	ldr	r3, [r3, #0]
 8010572:	4a16      	ldr	r2, [pc, #88]	; (80105cc <USER_Usart3txTask_init+0x98>)
 8010574:	6812      	ldr	r2, [r2, #0]
 8010576:	3208      	adds	r2, #8
 8010578:	601a      	str	r2, [r3, #0]
		rt_memset(txfifo->txmsg,0,UART3TXFIFOLENGTH*sizeof(struct tx_msg));
 801057a:	4b14      	ldr	r3, [pc, #80]	; (80105cc <USER_Usart3txTask_init+0x98>)
 801057c:	681b      	ldr	r3, [r3, #0]
 801057e:	681b      	ldr	r3, [r3, #0]
 8010580:	4618      	mov	r0, r3
 8010582:	2100      	movs	r1, #0
 8010584:	2218      	movs	r2, #24
 8010586:	f002 fdbb 	bl	8013100 <rt_memset>
		txfifo->index = 0;
 801058a:	4b10      	ldr	r3, [pc, #64]	; (80105cc <USER_Usart3txTask_init+0x98>)
 801058c:	681b      	ldr	r3, [r3, #0]
 801058e:	2200      	movs	r2, #0
 8010590:	711a      	strb	r2, [r3, #4]
	}
	
	tid = rt_thread_create("usart3tx",						
 8010592:	2309      	movs	r3, #9
 8010594:	9300      	str	r3, [sp, #0]
 8010596:	2314      	movs	r3, #20
 8010598:	9301      	str	r3, [sp, #4]
 801059a:	4809      	ldr	r0, [pc, #36]	; (80105c0 <USER_Usart3txTask_init+0x8c>)
 801059c:	490c      	ldr	r1, [pc, #48]	; (80105d0 <USER_Usart3txTask_init+0x9c>)
 801059e:	2200      	movs	r2, #0
 80105a0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80105a4:	f004 fd38 	bl	8015018 <rt_thread_create>
 80105a8:	6078      	str	r0, [r7, #4]
                           USER_Usart3txTask_entry, RT_NULL,
                           1024, USER_Usart3txTask_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 80105aa:	687b      	ldr	r3, [r7, #4]
 80105ac:	2b00      	cmp	r3, #0
 80105ae:	d002      	beq.n	80105b6 <USER_Usart3txTask_init+0x82>
 80105b0:	6878      	ldr	r0, [r7, #4]
 80105b2:	f004 fcf3 	bl	8014f9c <rt_thread_startup>

    return 0;
 80105b6:	2300      	movs	r3, #0
}
 80105b8:	4618      	mov	r0, r3
 80105ba:	3708      	adds	r7, #8
 80105bc:	46bd      	mov	sp, r7
 80105be:	bd80      	pop	{r7, pc}
 80105c0:	08022bdc 	.word	0x08022bdc
 80105c4:	200109f0 	.word	0x200109f0
 80105c8:	08022be8 	.word	0x08022be8
 80105cc:	200124d0 	.word	0x200124d0
 80105d0:	080104d1 	.word	0x080104d1

080105d4 <myscanf>:
INIT_APP_EXPORT(USER_Usart3txTask_init);


rt_err_t myscanf(char *buf)
{
 80105d4:	b580      	push	{r7, lr}
 80105d6:	b086      	sub	sp, #24
 80105d8:	af00      	add	r7, sp, #0
 80105da:	6078      	str	r0, [r7, #4]
	rt_err_t result = RT_EOK;
 80105dc:	2300      	movs	r3, #0
 80105de:	613b      	str	r3, [r7, #16]
	char i;
	struct rx_msg rx_msg;
	
	if(rx_mq == RT_NULL || buf ==  RT_NULL)
 80105e0:	4b1a      	ldr	r3, [pc, #104]	; (801064c <myscanf+0x78>)
 80105e2:	681b      	ldr	r3, [r3, #0]
 80105e4:	2b00      	cmp	r3, #0
 80105e6:	d002      	beq.n	80105ee <myscanf+0x1a>
 80105e8:	687b      	ldr	r3, [r7, #4]
 80105ea:	2b00      	cmp	r3, #0
 80105ec:	d103      	bne.n	80105f6 <myscanf+0x22>
		return (result = RT_ERROR);
 80105ee:	2301      	movs	r3, #1
 80105f0:	613b      	str	r3, [r7, #16]
 80105f2:	693b      	ldr	r3, [r7, #16]
 80105f4:	e025      	b.n	8010642 <myscanf+0x6e>
	result = rt_mq_recv(rx_mq,&rx_msg,sizeof(struct rx_msg),50);
 80105f6:	4b15      	ldr	r3, [pc, #84]	; (801064c <myscanf+0x78>)
 80105f8:	681a      	ldr	r2, [r3, #0]
 80105fa:	f107 0308 	add.w	r3, r7, #8
 80105fe:	4610      	mov	r0, r2
 8010600:	4619      	mov	r1, r3
 8010602:	2208      	movs	r2, #8
 8010604:	2332      	movs	r3, #50	; 0x32
 8010606:	f002 fc07 	bl	8012e18 <rt_mq_recv>
 801060a:	6138      	str	r0, [r7, #16]
	if(result == RT_EOK)
 801060c:	693b      	ldr	r3, [r7, #16]
 801060e:	2b00      	cmp	r3, #0
 8010610:	d116      	bne.n	8010640 <myscanf+0x6c>
	{
		for(i = 0;i<rx_msg.size;i++)
 8010612:	2300      	movs	r3, #0
 8010614:	75fb      	strb	r3, [r7, #23]
 8010616:	e00a      	b.n	801062e <myscanf+0x5a>
			buf[i] = rx_msg.data[i];
 8010618:	7dfb      	ldrb	r3, [r7, #23]
 801061a:	687a      	ldr	r2, [r7, #4]
 801061c:	4413      	add	r3, r2
 801061e:	68b9      	ldr	r1, [r7, #8]
 8010620:	7dfa      	ldrb	r2, [r7, #23]
 8010622:	440a      	add	r2, r1
 8010624:	7812      	ldrb	r2, [r2, #0]
 8010626:	701a      	strb	r2, [r3, #0]
	if(rx_mq == RT_NULL || buf ==  RT_NULL)
		return (result = RT_ERROR);
	result = rt_mq_recv(rx_mq,&rx_msg,sizeof(struct rx_msg),50);
	if(result == RT_EOK)
	{
		for(i = 0;i<rx_msg.size;i++)
 8010628:	7dfb      	ldrb	r3, [r7, #23]
 801062a:	3301      	adds	r3, #1
 801062c:	75fb      	strb	r3, [r7, #23]
 801062e:	7b3b      	ldrb	r3, [r7, #12]
 8010630:	7dfa      	ldrb	r2, [r7, #23]
 8010632:	429a      	cmp	r2, r3
 8010634:	d3f0      	bcc.n	8010618 <myscanf+0x44>
			buf[i] = rx_msg.data[i];
		buf[i] = '\0';
 8010636:	7dfb      	ldrb	r3, [r7, #23]
 8010638:	687a      	ldr	r2, [r7, #4]
 801063a:	4413      	add	r3, r2
 801063c:	2200      	movs	r2, #0
 801063e:	701a      	strb	r2, [r3, #0]
	}
	return result;
 8010640:	693b      	ldr	r3, [r7, #16]
}
 8010642:	4618      	mov	r0, r3
 8010644:	3718      	adds	r7, #24
 8010646:	46bd      	mov	sp, r7
 8010648:	bd80      	pop	{r7, pc}
 801064a:	bf00      	nop
 801064c:	200109fc 	.word	0x200109fc

08010650 <uart_input>:
static rt_err_t uart_input(rt_device_t dev, rt_size_t size)
{
 8010650:	b580      	push	{r7, lr}
 8010652:	b082      	sub	sp, #8
 8010654:	af00      	add	r7, sp, #0
 8010656:	6078      	str	r0, [r7, #4]
 8010658:	6039      	str	r1, [r7, #0]
	rt_sem_release(rx_sem);
 801065a:	4b05      	ldr	r3, [pc, #20]	; (8010670 <uart_input+0x20>)
 801065c:	681b      	ldr	r3, [r3, #0]
 801065e:	4618      	mov	r0, r3
 8010660:	f002 f896 	bl	8012790 <rt_sem_release>
	return RT_EOK;
 8010664:	2300      	movs	r3, #0
}
 8010666:	4618      	mov	r0, r3
 8010668:	3708      	adds	r7, #8
 801066a:	46bd      	mov	sp, r7
 801066c:	bd80      	pop	{r7, pc}
 801066e:	bf00      	nop
 8010670:	200109f8 	.word	0x200109f8

08010674 <USER_Usart3rxTask_entry>:

void USER_Usart3rxTask_entry(void *parameter)
{
 8010674:	b580      	push	{r7, lr}
 8010676:	b08c      	sub	sp, #48	; 0x30
 8010678:	af00      	add	r7, sp, #0
 801067a:	6078      	str	r0, [r7, #4]

	rt_device_t device;
	rt_err_t result = RT_EOK;
 801067c:	2300      	movs	r3, #0
 801067e:	62fb      	str	r3, [r7, #44]	; 0x2c
	static char i = 0;
	char rcvdata[RCVLENTH];
	struct rx_msg rx_msg;
	
	
	device = rt_device_find("uart3");
 8010680:	482b      	ldr	r0, [pc, #172]	; (8010730 <USER_Usart3rxTask_entry+0xbc>)
 8010682:	f001 fc67 	bl	8011f54 <rt_device_find>
 8010686:	62b8      	str	r0, [r7, #40]	; 0x28
	
	if ( device != RT_NULL )
 8010688:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801068a:	2b00      	cmp	r3, #0
 801068c:	d00e      	beq.n	80106ac <USER_Usart3rxTask_entry+0x38>
	{
		rt_device_set_rx_indicate(device, uart_input);
 801068e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010690:	4928      	ldr	r1, [pc, #160]	; (8010734 <USER_Usart3rxTask_entry+0xc0>)
 8010692:	f001 fddb 	bl	801224c <rt_device_set_rx_indicate>
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX ) != RT_EOK)
 8010696:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010698:	f240 1103 	movw	r1, #259	; 0x103
 801069c:	f001 fc96 	bl	8011fcc <rt_device_open>
 80106a0:	4603      	mov	r3, r0
 80106a2:	2b00      	cmp	r3, #0
 80106a4:	d002      	beq.n	80106ac <USER_Usart3rxTask_entry+0x38>
		{
			rt_kprintf("open error\r\n");
 80106a6:	4824      	ldr	r0, [pc, #144]	; (8010738 <USER_Usart3rxTask_entry+0xc4>)
 80106a8:	f003 fae2 	bl	8013c70 <rt_kprintf>
	}
	while(1)
	{
		//struct rx_msg msg;
		//rt_device_write(device, 0,buf,130);
		result = rt_sem_take(rx_sem, RT_WAITING_FOREVER);
 80106ac:	4b23      	ldr	r3, [pc, #140]	; (801073c <USER_Usart3rxTask_entry+0xc8>)
 80106ae:	681b      	ldr	r3, [r3, #0]
 80106b0:	4618      	mov	r0, r3
 80106b2:	f04f 31ff 	mov.w	r1, #4294967295
 80106b6:	f001 ffc7 	bl	8012648 <rt_sem_take>
 80106ba:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (result == RT_EOK)
 80106bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80106be:	2b00      	cmp	r3, #0
 80106c0:	d134      	bne.n	801072c <USER_Usart3rxTask_entry+0xb8>
		{
			rt_uint32_t rx_length;
			rx_length = rt_device_read(device, 0, &ch,1);
 80106c2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80106c4:	2100      	movs	r1, #0
 80106c6:	4a1e      	ldr	r2, [pc, #120]	; (8010740 <USER_Usart3rxTask_entry+0xcc>)
 80106c8:	2301      	movs	r3, #1
 80106ca:	f001 fd31 	bl	8012130 <rt_device_read>
 80106ce:	6278      	str	r0, [r7, #36]	; 0x24
			if(rx_length != 0)
 80106d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80106d2:	2b00      	cmp	r3, #0
 80106d4:	d02a      	beq.n	801072c <USER_Usart3rxTask_entry+0xb8>
			{
				rcvdata[i++] = ch;
 80106d6:	4b1b      	ldr	r3, [pc, #108]	; (8010744 <USER_Usart3rxTask_entry+0xd0>)
 80106d8:	781b      	ldrb	r3, [r3, #0]
 80106da:	1c5a      	adds	r2, r3, #1
 80106dc:	b2d1      	uxtb	r1, r2
 80106de:	4a19      	ldr	r2, [pc, #100]	; (8010744 <USER_Usart3rxTask_entry+0xd0>)
 80106e0:	7011      	strb	r1, [r2, #0]
 80106e2:	4619      	mov	r1, r3
 80106e4:	4b16      	ldr	r3, [pc, #88]	; (8010740 <USER_Usart3rxTask_entry+0xcc>)
 80106e6:	781a      	ldrb	r2, [r3, #0]
 80106e8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80106ec:	440b      	add	r3, r1
 80106ee:	f803 2c1c 	strb.w	r2, [r3, #-28]
				if(ch == 0x0d)
 80106f2:	4b13      	ldr	r3, [pc, #76]	; (8010740 <USER_Usart3rxTask_entry+0xcc>)
 80106f4:	781b      	ldrb	r3, [r3, #0]
 80106f6:	2b0d      	cmp	r3, #13
 80106f8:	d111      	bne.n	801071e <USER_Usart3rxTask_entry+0xaa>
				{
					rx_msg.size = i;
 80106fa:	4b12      	ldr	r3, [pc, #72]	; (8010744 <USER_Usart3rxTask_entry+0xd0>)
 80106fc:	781b      	ldrb	r3, [r3, #0]
 80106fe:	743b      	strb	r3, [r7, #16]
					i = 0;
 8010700:	4b10      	ldr	r3, [pc, #64]	; (8010744 <USER_Usart3rxTask_entry+0xd0>)
 8010702:	2200      	movs	r2, #0
 8010704:	701a      	strb	r2, [r3, #0]
					rx_msg.data = rcvdata;
 8010706:	f107 0314 	add.w	r3, r7, #20
 801070a:	60fb      	str	r3, [r7, #12]
					rt_mq_send(rx_mq,&rx_msg,sizeof(struct rx_msg));
 801070c:	4b0e      	ldr	r3, [pc, #56]	; (8010748 <USER_Usart3rxTask_entry+0xd4>)
 801070e:	681a      	ldr	r2, [r3, #0]
 8010710:	f107 030c 	add.w	r3, r7, #12
 8010714:	4610      	mov	r0, r2
 8010716:	4619      	mov	r1, r3
 8010718:	2208      	movs	r2, #8
 801071a:	f002 fae3 	bl	8012ce4 <rt_mq_send>
				}
				
				if(i >= RCVLENTH)
 801071e:	4b09      	ldr	r3, [pc, #36]	; (8010744 <USER_Usart3rxTask_entry+0xd0>)
 8010720:	781b      	ldrb	r3, [r3, #0]
 8010722:	2b0d      	cmp	r3, #13
 8010724:	d902      	bls.n	801072c <USER_Usart3rxTask_entry+0xb8>
					i = 0;
 8010726:	4b07      	ldr	r3, [pc, #28]	; (8010744 <USER_Usart3rxTask_entry+0xd0>)
 8010728:	2200      	movs	r2, #0
 801072a:	701a      	strb	r2, [r3, #0]
			}
		}
	}
 801072c:	e7be      	b.n	80106ac <USER_Usart3rxTask_entry+0x38>
 801072e:	bf00      	nop
 8010730:	08022bc4 	.word	0x08022bc4
 8010734:	08010651 	.word	0x08010651
 8010738:	08022bcc 	.word	0x08022bcc
 801073c:	200109f8 	.word	0x200109f8
 8010740:	200109f4 	.word	0x200109f4
 8010744:	20010a00 	.word	0x20010a00
 8010748:	200109fc 	.word	0x200109fc

0801074c <USER_Usart3rxTask_init>:




int USER_Usart3rxTask_init()
{
 801074c:	b580      	push	{r7, lr}
 801074e:	b084      	sub	sp, #16
 8010750:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	rt_device_t device;

	if ((rx_sem = rt_sem_create("usart3rcv", 0, RT_IPC_FLAG_FIFO)) == RT_NULL)
 8010752:	481b      	ldr	r0, [pc, #108]	; (80107c0 <USER_Usart3rxTask_init+0x74>)
 8010754:	2100      	movs	r1, #0
 8010756:	2200      	movs	r2, #0
 8010758:	f001 ff3a 	bl	80125d0 <rt_sem_create>
 801075c:	4602      	mov	r2, r0
 801075e:	4b19      	ldr	r3, [pc, #100]	; (80107c4 <USER_Usart3rxTask_init+0x78>)
 8010760:	601a      	str	r2, [r3, #0]
 8010762:	4b18      	ldr	r3, [pc, #96]	; (80107c4 <USER_Usart3rxTask_init+0x78>)
 8010764:	681b      	ldr	r3, [r3, #0]
 8010766:	2b00      	cmp	r3, #0
 8010768:	d102      	bne.n	8010770 <USER_Usart3rxTask_init+0x24>
	{
		rt_kprintf("sem create error\r\n");
 801076a:	4817      	ldr	r0, [pc, #92]	; (80107c8 <USER_Usart3rxTask_init+0x7c>)
 801076c:	f003 fa80 	bl	8013c70 <rt_kprintf>
	}
	if ((rx_mq = rt_mq_create("usart3rxmq", sizeof(struct rx_msg),RXMQSIZE,RT_IPC_FLAG_FIFO)) == RT_NULL)
 8010770:	4816      	ldr	r0, [pc, #88]	; (80107cc <USER_Usart3rxTask_init+0x80>)
 8010772:	2108      	movs	r1, #8
 8010774:	2203      	movs	r2, #3
 8010776:	2300      	movs	r3, #0
 8010778:	f002 f9f6 	bl	8012b68 <rt_mq_create>
 801077c:	4602      	mov	r2, r0
 801077e:	4b14      	ldr	r3, [pc, #80]	; (80107d0 <USER_Usart3rxTask_init+0x84>)
 8010780:	601a      	str	r2, [r3, #0]
 8010782:	4b13      	ldr	r3, [pc, #76]	; (80107d0 <USER_Usart3rxTask_init+0x84>)
 8010784:	681b      	ldr	r3, [r3, #0]
 8010786:	2b00      	cmp	r3, #0
 8010788:	d102      	bne.n	8010790 <USER_Usart3rxTask_init+0x44>
	{
		rt_kprintf("rx_mq create error\r\n");
 801078a:	4812      	ldr	r0, [pc, #72]	; (80107d4 <USER_Usart3rxTask_init+0x88>)
 801078c:	f003 fa70 	bl	8013c70 <rt_kprintf>
	}
	
	tid = rt_thread_create("usart3rx",						
 8010790:	2309      	movs	r3, #9
 8010792:	9300      	str	r3, [sp, #0]
 8010794:	2314      	movs	r3, #20
 8010796:	9301      	str	r3, [sp, #4]
 8010798:	480f      	ldr	r0, [pc, #60]	; (80107d8 <USER_Usart3rxTask_init+0x8c>)
 801079a:	4910      	ldr	r1, [pc, #64]	; (80107dc <USER_Usart3rxTask_init+0x90>)
 801079c:	2200      	movs	r2, #0
 801079e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80107a2:	f004 fc39 	bl	8015018 <rt_thread_create>
 80107a6:	6078      	str	r0, [r7, #4]
                           USER_Usart3rxTask_entry, RT_NULL,
                           1024, USER_Usart3rxTask_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 80107a8:	687b      	ldr	r3, [r7, #4]
 80107aa:	2b00      	cmp	r3, #0
 80107ac:	d002      	beq.n	80107b4 <USER_Usart3rxTask_init+0x68>
 80107ae:	6878      	ldr	r0, [r7, #4]
 80107b0:	f004 fbf4 	bl	8014f9c <rt_thread_startup>

    return 0;
 80107b4:	2300      	movs	r3, #0
}
 80107b6:	4618      	mov	r0, r3
 80107b8:	3708      	adds	r7, #8
 80107ba:	46bd      	mov	sp, r7
 80107bc:	bd80      	pop	{r7, pc}
 80107be:	bf00      	nop
 80107c0:	08022bfc 	.word	0x08022bfc
 80107c4:	200109f8 	.word	0x200109f8
 80107c8:	08022be8 	.word	0x08022be8
 80107cc:	08022c08 	.word	0x08022c08
 80107d0:	200109fc 	.word	0x200109fc
 80107d4:	08022c14 	.word	0x08022c14
 80107d8:	08022c2c 	.word	0x08022c2c
 80107dc:	08010675 	.word	0x08010675

080107e0 <Clarke>:
* Output         : Stat_Curr_alfa_beta
* Return         : none.
*******************************************************************************/

Curr_Components Clarke(Curr_Components Curr_Input)
{
 80107e0:	b480      	push	{r7}
 80107e2:	b089      	sub	sp, #36	; 0x24
 80107e4:	af00      	add	r7, sp, #0
 80107e6:	6078      	str	r0, [r7, #4]
  s32 qIb_divSQRT3_tmp ;
  
  s16 qIa_divSQRT3;
  s16 qIb_divSQRT3 ;

  Curr_Output.qI_Component1= Curr_Input.qI_Component1;
 80107e8:	88bb      	ldrh	r3, [r7, #4]
 80107ea:	81bb      	strh	r3, [r7, #12]
  
  qIa_divSQRT3_tmp = divSQRT_3 * Curr_Input.qI_Component1; 
 80107ec:	88bb      	ldrh	r3, [r7, #4]
 80107ee:	b21b      	sxth	r3, r3
 80107f0:	f644 12e6 	movw	r2, #18918	; 0x49e6
 80107f4:	fb02 f303 	mul.w	r3, r2, r3
 80107f8:	61fb      	str	r3, [r7, #28]
  qIa_divSQRT3_tmp /=32768;   
 80107fa:	69fb      	ldr	r3, [r7, #28]
 80107fc:	2b00      	cmp	r3, #0
 80107fe:	da03      	bge.n	8010808 <Clarke+0x28>
 8010800:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8010804:	441a      	add	r2, r3
 8010806:	4613      	mov	r3, r2
 8010808:	13db      	asrs	r3, r3, #15
 801080a:	61fb      	str	r3, [r7, #28]
  
  qIb_divSQRT3_tmp = divSQRT_3 * Curr_Input.qI_Component2;
 801080c:	88fb      	ldrh	r3, [r7, #6]
 801080e:	b21b      	sxth	r3, r3
 8010810:	f644 12e6 	movw	r2, #18918	; 0x49e6
 8010814:	fb02 f303 	mul.w	r3, r2, r3
 8010818:	61bb      	str	r3, [r7, #24]
  qIb_divSQRT3_tmp /=32768;
 801081a:	69bb      	ldr	r3, [r7, #24]
 801081c:	2b00      	cmp	r3, #0
 801081e:	da03      	bge.n	8010828 <Clarke+0x48>
 8010820:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8010824:	441a      	add	r2, r3
 8010826:	4613      	mov	r3, r2
 8010828:	13db      	asrs	r3, r3, #15
 801082a:	61bb      	str	r3, [r7, #24]
  
  qIa_divSQRT3=((s16)(qIa_divSQRT3_tmp));		
 801082c:	69fb      	ldr	r3, [r7, #28]
 801082e:	82fb      	strh	r3, [r7, #22]
  		
  qIb_divSQRT3=((s16)(qIb_divSQRT3_tmp));
 8010830:	69bb      	ldr	r3, [r7, #24]
 8010832:	82bb      	strh	r3, [r7, #20]
  
  Curr_Output.qI_Component2=(-(qIa_divSQRT3)-(qIb_divSQRT3)-(qIb_divSQRT3));
 8010834:	8afb      	ldrh	r3, [r7, #22]
 8010836:	425b      	negs	r3, r3
 8010838:	b29a      	uxth	r2, r3
 801083a:	8abb      	ldrh	r3, [r7, #20]
 801083c:	1ad3      	subs	r3, r2, r3
 801083e:	b29a      	uxth	r2, r3
 8010840:	8abb      	ldrh	r3, [r7, #20]
 8010842:	1ad3      	subs	r3, r2, r3
 8010844:	b29b      	uxth	r3, r3
 8010846:	b29b      	uxth	r3, r3
 8010848:	81fb      	strh	r3, [r7, #14]
  
  return(Curr_Output);  
 801084a:	68fb      	ldr	r3, [r7, #12]
 801084c:	613b      	str	r3, [r7, #16]
 801084e:	2300      	movs	r3, #0
 8010850:	8a3a      	ldrh	r2, [r7, #16]
 8010852:	f362 030f 	bfi	r3, r2, #0, #16
 8010856:	8a7a      	ldrh	r2, [r7, #18]
 8010858:	f362 431f 	bfi	r3, r2, #16, #16
}
 801085c:	4618      	mov	r0, r3
 801085e:	3724      	adds	r7, #36	; 0x24
 8010860:	46bd      	mov	sp, r7
 8010862:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010866:	4770      	bx	lr

08010868 <Park>:
* Input          : Stat_Curr_alfa_beta
* Output         : Stat_Curr_q_d.
* Return         : none.
*******************************************************************************/
Curr_Components Park(Curr_Components Curr_Input, s16 Theta)
{
 8010868:	b480      	push	{r7}
 801086a:	b08d      	sub	sp, #52	; 0x34
 801086c:	af00      	add	r7, sp, #0
 801086e:	6078      	str	r0, [r7, #4]
 8010870:	460b      	mov	r3, r1
 8010872:	807b      	strh	r3, [r7, #2]
  s16 qId_1, qId_2;  
  s16 qIq_1, qIq_2;

  u8 bIndex_Sin, bIndex_Cos;
  
  bIndex_Sin=(u8)(Theta/256);
 8010874:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8010878:	2b00      	cmp	r3, #0
 801087a:	da00      	bge.n	801087e <Park+0x16>
 801087c:	33ff      	adds	r3, #255	; 0xff
 801087e:	121b      	asrs	r3, r3, #8
 8010880:	b29b      	uxth	r3, r3
 8010882:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  
  bIndex_Cos =(u8)(Theta/256)+OFFSET;
 8010886:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801088a:	2b00      	cmp	r3, #0
 801088c:	da00      	bge.n	8010890 <Park+0x28>
 801088e:	33ff      	adds	r3, #255	; 0xff
 8010890:	121b      	asrs	r3, r3, #8
 8010892:	b29b      	uxth	r3, r3
 8010894:	b2db      	uxtb	r3, r3
 8010896:	3340      	adds	r3, #64	; 0x40
 8010898:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
          
  hSin_Theta = hSin_Cos_Table[bIndex_Sin];
 801089c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80108a0:	4a39      	ldr	r2, [pc, #228]	; (8010988 <Park+0x120>)
 80108a2:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 80108a6:	4b39      	ldr	r3, [pc, #228]	; (801098c <Park+0x124>)
 80108a8:	801a      	strh	r2, [r3, #0]
      
  hCos_Theta = hSin_Cos_Table[bIndex_Cos];
 80108aa:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80108ae:	4a36      	ldr	r2, [pc, #216]	; (8010988 <Park+0x120>)
 80108b0:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 80108b4:	4b36      	ldr	r3, [pc, #216]	; (8010990 <Park+0x128>)
 80108b6:	801a      	strh	r2, [r3, #0]
  
  // Iq
  qIq_tmp_1 = hCos_Theta * Curr_Input.qI_Component1; 
 80108b8:	4b35      	ldr	r3, [pc, #212]	; (8010990 <Park+0x128>)
 80108ba:	881b      	ldrh	r3, [r3, #0]
 80108bc:	b21b      	sxth	r3, r3
 80108be:	88ba      	ldrh	r2, [r7, #4]
 80108c0:	b212      	sxth	r2, r2
 80108c2:	fb02 f303 	mul.w	r3, r2, r3
 80108c6:	62bb      	str	r3, [r7, #40]	; 0x28
  qIq_tmp_1 /=32768; 
 80108c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80108ca:	2b00      	cmp	r3, #0
 80108cc:	da03      	bge.n	80108d6 <Park+0x6e>
 80108ce:	f647 72ff 	movw	r2, #32767	; 0x7fff
 80108d2:	441a      	add	r2, r3
 80108d4:	4613      	mov	r3, r2
 80108d6:	13db      	asrs	r3, r3, #15
 80108d8:	62bb      	str	r3, [r7, #40]	; 0x28

  qIq_tmp_2 = hSin_Theta * Curr_Input.qI_Component2; 
 80108da:	4b2c      	ldr	r3, [pc, #176]	; (801098c <Park+0x124>)
 80108dc:	881b      	ldrh	r3, [r3, #0]
 80108de:	b21b      	sxth	r3, r3
 80108e0:	88fa      	ldrh	r2, [r7, #6]
 80108e2:	b212      	sxth	r2, r2
 80108e4:	fb02 f303 	mul.w	r3, r2, r3
 80108e8:	627b      	str	r3, [r7, #36]	; 0x24
  qIq_tmp_2 /=32768; 
 80108ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80108ec:	2b00      	cmp	r3, #0
 80108ee:	da03      	bge.n	80108f8 <Park+0x90>
 80108f0:	f647 72ff 	movw	r2, #32767	; 0x7fff
 80108f4:	441a      	add	r2, r3
 80108f6:	4613      	mov	r3, r2
 80108f8:	13db      	asrs	r3, r3, #15
 80108fa:	627b      	str	r3, [r7, #36]	; 0x24

  
  qIq_1 = (s16)(qIq_tmp_1);		
 80108fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80108fe:	847b      	strh	r3, [r7, #34]	; 0x22
  
  qIq_2 = (s16)(qIq_tmp_2);					
 8010900:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010902:	843b      	strh	r3, [r7, #32]
				   
  Curr_Output.qI_Component1 = ((qIq_1)-(qIq_2));	
 8010904:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8010906:	8c3b      	ldrh	r3, [r7, #32]
 8010908:	1ad3      	subs	r3, r2, r3
 801090a:	b29b      	uxth	r3, r3
 801090c:	b29b      	uxth	r3, r3
 801090e:	81bb      	strh	r3, [r7, #12]
     
  // Id
  qId_tmp_1 = hSin_Theta * Curr_Input.qI_Component1; 
 8010910:	4b1e      	ldr	r3, [pc, #120]	; (801098c <Park+0x124>)
 8010912:	881b      	ldrh	r3, [r3, #0]
 8010914:	b21b      	sxth	r3, r3
 8010916:	88ba      	ldrh	r2, [r7, #4]
 8010918:	b212      	sxth	r2, r2
 801091a:	fb02 f303 	mul.w	r3, r2, r3
 801091e:	61fb      	str	r3, [r7, #28]
  qId_tmp_1 /=32768;     
 8010920:	69fb      	ldr	r3, [r7, #28]
 8010922:	2b00      	cmp	r3, #0
 8010924:	da03      	bge.n	801092e <Park+0xc6>
 8010926:	f647 72ff 	movw	r2, #32767	; 0x7fff
 801092a:	441a      	add	r2, r3
 801092c:	4613      	mov	r3, r2
 801092e:	13db      	asrs	r3, r3, #15
 8010930:	61fb      	str	r3, [r7, #28]
  
  qId_tmp_2 = hCos_Theta * Curr_Input.qI_Component2; 
 8010932:	4b17      	ldr	r3, [pc, #92]	; (8010990 <Park+0x128>)
 8010934:	881b      	ldrh	r3, [r3, #0]
 8010936:	b21b      	sxth	r3, r3
 8010938:	88fa      	ldrh	r2, [r7, #6]
 801093a:	b212      	sxth	r2, r2
 801093c:	fb02 f303 	mul.w	r3, r2, r3
 8010940:	61bb      	str	r3, [r7, #24]
  qId_tmp_2 /=32768;  		
 8010942:	69bb      	ldr	r3, [r7, #24]
 8010944:	2b00      	cmp	r3, #0
 8010946:	da03      	bge.n	8010950 <Park+0xe8>
 8010948:	f647 72ff 	movw	r2, #32767	; 0x7fff
 801094c:	441a      	add	r2, r3
 801094e:	4613      	mov	r3, r2
 8010950:	13db      	asrs	r3, r3, #15
 8010952:	61bb      	str	r3, [r7, #24]
  
  qId_1 = ((s16)(qId_tmp_1));
 8010954:	69fb      	ldr	r3, [r7, #28]
 8010956:	82fb      	strh	r3, [r7, #22]
  
  qId_2 = ((s16)(qId_tmp_2));
 8010958:	69bb      	ldr	r3, [r7, #24]
 801095a:	82bb      	strh	r3, [r7, #20]

  Curr_Output.qI_Component2 = ((qId_1)+(qId_2));	  //Id component in Q1.15 Format   
 801095c:	8afa      	ldrh	r2, [r7, #22]
 801095e:	8abb      	ldrh	r3, [r7, #20]
 8010960:	4413      	add	r3, r2
 8010962:	b29b      	uxth	r3, r3
 8010964:	b29b      	uxth	r3, r3
 8010966:	81fb      	strh	r3, [r7, #14]

  return (Curr_Output);
 8010968:	68fb      	ldr	r3, [r7, #12]
 801096a:	613b      	str	r3, [r7, #16]
 801096c:	2300      	movs	r3, #0
 801096e:	8a3a      	ldrh	r2, [r7, #16]
 8010970:	f362 030f 	bfi	r3, r2, #0, #16
 8010974:	8a7a      	ldrh	r2, [r7, #18]
 8010976:	f362 431f 	bfi	r3, r2, #16, #16
  
}
 801097a:	4618      	mov	r0, r3
 801097c:	3734      	adds	r7, #52	; 0x34
 801097e:	46bd      	mov	sp, r7
 8010980:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010984:	4770      	bx	lr
 8010986:	bf00      	nop
 8010988:	0802462c 	.word	0x0802462c
 801098c:	20010a02 	.word	0x20010a02
 8010990:	20010a04 	.word	0x20010a04

08010994 <RevPark_Circle_Limitation>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void RevPark_Circle_Limitation(void)
{
 8010994:	b480      	push	{r7}
 8010996:	b083      	sub	sp, #12
 8010998:	af00      	add	r7, sp, #0
s32 temp;
             
temp = Stat_Volt_q_d.qV_Component1 * Stat_Volt_q_d.qV_Component1 
 801099a:	4b27      	ldr	r3, [pc, #156]	; (8010a38 <RevPark_Circle_Limitation+0xa4>)
 801099c:	881b      	ldrh	r3, [r3, #0]
 801099e:	b21b      	sxth	r3, r3
 80109a0:	4a25      	ldr	r2, [pc, #148]	; (8010a38 <RevPark_Circle_Limitation+0xa4>)
 80109a2:	8812      	ldrh	r2, [r2, #0]
 80109a4:	b212      	sxth	r2, r2
 80109a6:	fb02 f203 	mul.w	r2, r2, r3
             + Stat_Volt_q_d.qV_Component2 * Stat_Volt_q_d.qV_Component2;  // min value 0, max value 2*32767*32767
 80109aa:	4b23      	ldr	r3, [pc, #140]	; (8010a38 <RevPark_Circle_Limitation+0xa4>)
 80109ac:	885b      	ldrh	r3, [r3, #2]
 80109ae:	b21b      	sxth	r3, r3
 80109b0:	4921      	ldr	r1, [pc, #132]	; (8010a38 <RevPark_Circle_Limitation+0xa4>)
 80109b2:	8849      	ldrh	r1, [r1, #2]
 80109b4:	b209      	sxth	r1, r1
 80109b6:	fb01 f303 	mul.w	r3, r1, r3
*******************************************************************************/
void RevPark_Circle_Limitation(void)
{
s32 temp;
             
temp = Stat_Volt_q_d.qV_Component1 * Stat_Volt_q_d.qV_Component1 
 80109ba:	4413      	add	r3, r2
 80109bc:	607b      	str	r3, [r7, #4]
             + Stat_Volt_q_d.qV_Component2 * Stat_Volt_q_d.qV_Component2;  // min value 0, max value 2*32767*32767

MI2 = temp;
 80109be:	4a1f      	ldr	r2, [pc, #124]	; (8010a3c <RevPark_Circle_Limitation+0xa8>)
 80109c0:	687b      	ldr	r3, [r7, #4]
 80109c2:	6013      	str	r3, [r2, #0]

if ( temp > (u32)(( MAX_MODULE * MAX_MODULE) ) ) // (Vd^2+Vq^2) > MAX_MODULE^2 ?
 80109c4:	687b      	ldr	r3, [r7, #4]
 80109c6:	4a1e      	ldr	r2, [pc, #120]	; (8010a40 <RevPark_Circle_Limitation+0xac>)
 80109c8:	4293      	cmp	r3, r2
 80109ca:	d930      	bls.n	8010a2e <RevPark_Circle_Limitation+0x9a>
   {
   u16 index;
              
   temp /= (u32)(512*32768);  // min value START_INDEX, max value 127
 80109cc:	687b      	ldr	r3, [r7, #4]
 80109ce:	0e1b      	lsrs	r3, r3, #24
 80109d0:	607b      	str	r3, [r7, #4]
   temp -= START_INDEX ;      // min value 0, max value 127 - START_INDEX
 80109d2:	687b      	ldr	r3, [r7, #4]
 80109d4:	3b3c      	subs	r3, #60	; 0x3c
 80109d6:	607b      	str	r3, [r7, #4]
   index = circle_limit_table[(u8)temp];
 80109d8:	687b      	ldr	r3, [r7, #4]
 80109da:	b2db      	uxtb	r3, r3
 80109dc:	461a      	mov	r2, r3
 80109de:	4b19      	ldr	r3, [pc, #100]	; (8010a44 <RevPark_Circle_Limitation+0xb0>)
 80109e0:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80109e4:	807b      	strh	r3, [r7, #2]
              
   temp = (s16)Stat_Volt_q_d.qV_Component1 * (u16)(index); 
 80109e6:	4b14      	ldr	r3, [pc, #80]	; (8010a38 <RevPark_Circle_Limitation+0xa4>)
 80109e8:	881b      	ldrh	r3, [r3, #0]
 80109ea:	b21b      	sxth	r3, r3
 80109ec:	887a      	ldrh	r2, [r7, #2]
 80109ee:	fb02 f303 	mul.w	r3, r2, r3
 80109f2:	607b      	str	r3, [r7, #4]
   Stat_Volt_q_d.qV_Component1 = (s16)(temp/32768);  
 80109f4:	687b      	ldr	r3, [r7, #4]
 80109f6:	2b00      	cmp	r3, #0
 80109f8:	da03      	bge.n	8010a02 <RevPark_Circle_Limitation+0x6e>
 80109fa:	f647 72ff 	movw	r2, #32767	; 0x7fff
 80109fe:	441a      	add	r2, r3
 8010a00:	4613      	mov	r3, r2
 8010a02:	13db      	asrs	r3, r3, #15
 8010a04:	b29a      	uxth	r2, r3
 8010a06:	4b0c      	ldr	r3, [pc, #48]	; (8010a38 <RevPark_Circle_Limitation+0xa4>)
 8010a08:	801a      	strh	r2, [r3, #0]
              
   temp = (s16)Stat_Volt_q_d.qV_Component2 * (u16)(index); 
 8010a0a:	4b0b      	ldr	r3, [pc, #44]	; (8010a38 <RevPark_Circle_Limitation+0xa4>)
 8010a0c:	885b      	ldrh	r3, [r3, #2]
 8010a0e:	b21b      	sxth	r3, r3
 8010a10:	887a      	ldrh	r2, [r7, #2]
 8010a12:	fb02 f303 	mul.w	r3, r2, r3
 8010a16:	607b      	str	r3, [r7, #4]
   Stat_Volt_q_d.qV_Component2 = (s16)(temp/32768);  
 8010a18:	687b      	ldr	r3, [r7, #4]
 8010a1a:	2b00      	cmp	r3, #0
 8010a1c:	da03      	bge.n	8010a26 <RevPark_Circle_Limitation+0x92>
 8010a1e:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8010a22:	441a      	add	r2, r3
 8010a24:	4613      	mov	r3, r2
 8010a26:	13db      	asrs	r3, r3, #15
 8010a28:	b29a      	uxth	r2, r3
 8010a2a:	4b03      	ldr	r3, [pc, #12]	; (8010a38 <RevPark_Circle_Limitation+0xa4>)
 8010a2c:	805a      	strh	r2, [r3, #2]
   }

} 
 8010a2e:	370c      	adds	r7, #12
 8010a30:	46bd      	mov	sp, r7
 8010a32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010a36:	4770      	bx	lr
 8010a38:	200124dc 	.word	0x200124dc
 8010a3c:	200124d4 	.word	0x200124d4
 8010a40:	3c35cdf1 	.word	0x3c35cdf1
 8010a44:	080245a4 	.word	0x080245a4

08010a48 <Rev_Park>:
* Input          : Stat_Volt_q_d.
* Output         : Stat_Volt_a_b
* Return         : none.
*******************************************************************************/
Volt_Components Rev_Park(Volt_Components Volt_Input)
{ 	
 8010a48:	b480      	push	{r7}
 8010a4a:	b08b      	sub	sp, #44	; 0x2c
 8010a4c:	af00      	add	r7, sp, #0
 8010a4e:	6078      	str	r0, [r7, #4]
  s32 qValpha_tmp1,qValpha_tmp2,qVbeta_tmp1,qVbeta_tmp2;
  s16 qValpha_1,qValpha_2,qVbeta_1,qVbeta_2;
  Volt_Components Volt_Output;
  
  qValpha_tmp1 = hCos_Theta * Volt_Input.qV_Component1;
 8010a50:	4b33      	ldr	r3, [pc, #204]	; (8010b20 <Rev_Park+0xd8>)
 8010a52:	881b      	ldrh	r3, [r3, #0]
 8010a54:	b21b      	sxth	r3, r3
 8010a56:	88ba      	ldrh	r2, [r7, #4]
 8010a58:	b212      	sxth	r2, r2
 8010a5a:	fb02 f303 	mul.w	r3, r2, r3
 8010a5e:	627b      	str	r3, [r7, #36]	; 0x24
  qValpha_tmp1 /= 32768;
 8010a60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a62:	2b00      	cmp	r3, #0
 8010a64:	da03      	bge.n	8010a6e <Rev_Park+0x26>
 8010a66:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8010a6a:	441a      	add	r2, r3
 8010a6c:	4613      	mov	r3, r2
 8010a6e:	13db      	asrs	r3, r3, #15
 8010a70:	627b      	str	r3, [r7, #36]	; 0x24

  qValpha_tmp2 = hSin_Theta * Volt_Input.qV_Component2;
 8010a72:	4b2c      	ldr	r3, [pc, #176]	; (8010b24 <Rev_Park+0xdc>)
 8010a74:	881b      	ldrh	r3, [r3, #0]
 8010a76:	b21b      	sxth	r3, r3
 8010a78:	88fa      	ldrh	r2, [r7, #6]
 8010a7a:	b212      	sxth	r2, r2
 8010a7c:	fb02 f303 	mul.w	r3, r2, r3
 8010a80:	623b      	str	r3, [r7, #32]
  qValpha_tmp2 /= 32768;
 8010a82:	6a3b      	ldr	r3, [r7, #32]
 8010a84:	2b00      	cmp	r3, #0
 8010a86:	da03      	bge.n	8010a90 <Rev_Park+0x48>
 8010a88:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8010a8c:	441a      	add	r2, r3
 8010a8e:	4613      	mov	r3, r2
 8010a90:	13db      	asrs	r3, r3, #15
 8010a92:	623b      	str	r3, [r7, #32]
		
  qValpha_1 = (s16)(qValpha_tmp1);		
 8010a94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a96:	83fb      	strh	r3, [r7, #30]
  qValpha_2 = (s16)(qValpha_tmp2);			
 8010a98:	6a3b      	ldr	r3, [r7, #32]
 8010a9a:	83bb      	strh	r3, [r7, #28]

  Volt_Output.qV_Component1 = ((qValpha_1)+(qValpha_2));
 8010a9c:	8bfa      	ldrh	r2, [r7, #30]
 8010a9e:	8bbb      	ldrh	r3, [r7, #28]
 8010aa0:	4413      	add	r3, r2
 8010aa2:	b29b      	uxth	r3, r3
 8010aa4:	b29b      	uxth	r3, r3
 8010aa6:	813b      	strh	r3, [r7, #8]
 
  qVbeta_tmp1 = Volt_Input.qV_Component1 * hSin_Theta;
 8010aa8:	88bb      	ldrh	r3, [r7, #4]
 8010aaa:	b21b      	sxth	r3, r3
 8010aac:	4a1d      	ldr	r2, [pc, #116]	; (8010b24 <Rev_Park+0xdc>)
 8010aae:	8812      	ldrh	r2, [r2, #0]
 8010ab0:	b212      	sxth	r2, r2
 8010ab2:	fb02 f303 	mul.w	r3, r2, r3
 8010ab6:	61bb      	str	r3, [r7, #24]
  qVbeta_tmp1 /= 32768;
 8010ab8:	69bb      	ldr	r3, [r7, #24]
 8010aba:	2b00      	cmp	r3, #0
 8010abc:	da03      	bge.n	8010ac6 <Rev_Park+0x7e>
 8010abe:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8010ac2:	441a      	add	r2, r3
 8010ac4:	4613      	mov	r3, r2
 8010ac6:	13db      	asrs	r3, r3, #15
 8010ac8:	61bb      	str	r3, [r7, #24]

  qVbeta_tmp2 = Volt_Input.qV_Component2 * hCos_Theta;
 8010aca:	88fb      	ldrh	r3, [r7, #6]
 8010acc:	b21b      	sxth	r3, r3
 8010ace:	4a14      	ldr	r2, [pc, #80]	; (8010b20 <Rev_Park+0xd8>)
 8010ad0:	8812      	ldrh	r2, [r2, #0]
 8010ad2:	b212      	sxth	r2, r2
 8010ad4:	fb02 f303 	mul.w	r3, r2, r3
 8010ad8:	617b      	str	r3, [r7, #20]
  qVbeta_tmp2 /= 32768;
 8010ada:	697b      	ldr	r3, [r7, #20]
 8010adc:	2b00      	cmp	r3, #0
 8010ade:	da03      	bge.n	8010ae8 <Rev_Park+0xa0>
 8010ae0:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8010ae4:	441a      	add	r2, r3
 8010ae6:	4613      	mov	r3, r2
 8010ae8:	13db      	asrs	r3, r3, #15
 8010aea:	617b      	str	r3, [r7, #20]

  qVbeta_1 = (s16)(qVbeta_tmp1);				
 8010aec:	69bb      	ldr	r3, [r7, #24]
 8010aee:	827b      	strh	r3, [r7, #18]
  qVbeta_2 = (s16)(qVbeta_tmp2);
 8010af0:	697b      	ldr	r3, [r7, #20]
 8010af2:	823b      	strh	r3, [r7, #16]
   				
  Volt_Output.qV_Component2 = -(qVbeta_1)+(qVbeta_2);
 8010af4:	8a3a      	ldrh	r2, [r7, #16]
 8010af6:	8a7b      	ldrh	r3, [r7, #18]
 8010af8:	1ad3      	subs	r3, r2, r3
 8010afa:	b29b      	uxth	r3, r3
 8010afc:	b29b      	uxth	r3, r3
 8010afe:	817b      	strh	r3, [r7, #10]
 
  return(Volt_Output);
 8010b00:	68bb      	ldr	r3, [r7, #8]
 8010b02:	60fb      	str	r3, [r7, #12]
 8010b04:	2300      	movs	r3, #0
 8010b06:	89ba      	ldrh	r2, [r7, #12]
 8010b08:	f362 030f 	bfi	r3, r2, #0, #16
 8010b0c:	89fa      	ldrh	r2, [r7, #14]
 8010b0e:	f362 431f 	bfi	r3, r2, #16, #16
}
 8010b12:	4618      	mov	r0, r3
 8010b14:	372c      	adds	r7, #44	; 0x2c
 8010b16:	46bd      	mov	sp, r7
 8010b18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010b1c:	4770      	bx	lr
 8010b1e:	bf00      	nop
 8010b20:	20010a04 	.word	0x20010a04
 8010b24:	20010a02 	.word	0x20010a02

08010b28 <IFOC_Model>:
* Output        : None.
* Return        : None.
*******************************************************************************/

void IFOC_Model(void)
{
 8010b28:	b590      	push	{r4, r7, lr}
 8010b2a:	b083      	sub	sp, #12
 8010b2c:	af00      	add	r7, sp, #0
  s16 hIm;                             // Im = (Rotor Flux)/Lm  
      
  //GPIOC->ODR ^= 0x40;  // Toggle PC6
  
  /*loads stator currents Ias and Ibs, read by ICS or shunt resistors*/
  Stat_Curr_a_b = GET_PHASE_CURRENTS(); 
 8010b2e:	f001 f825 	bl	8011b7c <SVPWM_IcsGetPhaseCurrentValues>
 8010b32:	4602      	mov	r2, r0
 8010b34:	4b45      	ldr	r3, [pc, #276]	; (8010c4c <IFOC_Model+0x124>)
 8010b36:	4611      	mov	r1, r2
 8010b38:	8019      	strh	r1, [r3, #0]
 8010b3a:	f3c2 420f 	ubfx	r2, r2, #16, #16
 8010b3e:	805a      	strh	r2, [r3, #2]
  
  
   /*Performs the Clarke transformation,
  i.e. transforms stator currents Ias and Ibs into currents Ialpha and Ibeta*/
  Stat_Curr_alfa_beta= Clarke(Stat_Curr_a_b);
 8010b40:	4b42      	ldr	r3, [pc, #264]	; (8010c4c <IFOC_Model+0x124>)
 8010b42:	681b      	ldr	r3, [r3, #0]
 8010b44:	2200      	movs	r2, #0
 8010b46:	461a      	mov	r2, r3
 8010b48:	4610      	mov	r0, r2
 8010b4a:	f7ff fe49 	bl	80107e0 <Clarke>
 8010b4e:	4602      	mov	r2, r0
 8010b50:	4b3f      	ldr	r3, [pc, #252]	; (8010c50 <IFOC_Model+0x128>)
 8010b52:	4611      	mov	r1, r2
 8010b54:	8019      	strh	r1, [r3, #0]
 8010b56:	f3c2 420f 	ubfx	r2, r2, #16, #16
 8010b5a:	805a      	strh	r2, [r3, #2]
  
  /*Performs the Park transformation,
  i.e transforms stator currents Ialpha and Ibeta into Iqs and Ids on a 
  reference frame synchronous with the rotor flux*/
  Stat_Curr_q_d= Park(Stat_Curr_alfa_beta,(s16)(hRotFlx_Theta));  
 8010b5c:	4b3d      	ldr	r3, [pc, #244]	; (8010c54 <IFOC_Model+0x12c>)
 8010b5e:	881a      	ldrh	r2, [r3, #0]
 8010b60:	4b3b      	ldr	r3, [pc, #236]	; (8010c50 <IFOC_Model+0x128>)
 8010b62:	b212      	sxth	r2, r2
 8010b64:	681b      	ldr	r3, [r3, #0]
 8010b66:	2100      	movs	r1, #0
 8010b68:	4619      	mov	r1, r3
 8010b6a:	4608      	mov	r0, r1
 8010b6c:	4611      	mov	r1, r2
 8010b6e:	f7ff fe7b 	bl	8010868 <Park>
 8010b72:	4602      	mov	r2, r0
 8010b74:	4b38      	ldr	r3, [pc, #224]	; (8010c58 <IFOC_Model+0x130>)
 8010b76:	4611      	mov	r1, r2
 8010b78:	8019      	strh	r1, [r3, #0]
 8010b7a:	f3c2 420f 	ubfx	r2, r2, #16, #16
 8010b7e:	805a      	strh	r2, [r3, #2]
  
  /*** use read currents to calculate the Rotor flux slip frequency **/
 
  /*given Ids, computes Im [1.15], i.e. (Rotor flux)/Lm */
  hIm = CalcIm(Stat_Curr_q_d.qI_Component2);   
 8010b80:	4b35      	ldr	r3, [pc, #212]	; (8010c58 <IFOC_Model+0x130>)
 8010b82:	885b      	ldrh	r3, [r3, #2]
 8010b84:	b21b      	sxth	r3, r3
 8010b86:	4618      	mov	r0, r3
 8010b88:	f000 f914 	bl	8010db4 <CalcIm>
 8010b8c:	4603      	mov	r3, r0
 8010b8e:	80fb      	strh	r3, [r7, #6]
  
  /*given Iqs and Im, computes hRotFlx_SlipFreq [1.15],
  i.e. the Rotor flux slip frequency*/
  wRotFlx_SlipFreq = CalcRotFlxSlipFreq(Stat_Curr_q_d.qI_Component1,hIm); 
 8010b90:	4b31      	ldr	r3, [pc, #196]	; (8010c58 <IFOC_Model+0x130>)
 8010b92:	881b      	ldrh	r3, [r3, #0]
 8010b94:	b21a      	sxth	r2, r3
 8010b96:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8010b9a:	4610      	mov	r0, r2
 8010b9c:	4619      	mov	r1, r3
 8010b9e:	f000 f94b 	bl	8010e38 <CalcRotFlxSlipFreq>
 8010ba2:	6038      	str	r0, [r7, #0]
  
#if defined (ENCODER)
  
  wRotFlx_SlipTheta += wRotFlx_SlipFreq ;
 8010ba4:	4b2d      	ldr	r3, [pc, #180]	; (8010c5c <IFOC_Model+0x134>)
 8010ba6:	681a      	ldr	r2, [r3, #0]
 8010ba8:	683b      	ldr	r3, [r7, #0]
 8010baa:	4413      	add	r3, r2
 8010bac:	4a2b      	ldr	r2, [pc, #172]	; (8010c5c <IFOC_Model+0x134>)
 8010bae:	6013      	str	r3, [r2, #0]
  hRotFlx_Theta = (s16)(wRotFlx_SlipTheta/65536) + ENC_Get_Electrical_Angle() ;
 8010bb0:	4b2a      	ldr	r3, [pc, #168]	; (8010c5c <IFOC_Model+0x134>)
 8010bb2:	681b      	ldr	r3, [r3, #0]
 8010bb4:	2b00      	cmp	r3, #0
 8010bb6:	da03      	bge.n	8010bc0 <IFOC_Model+0x98>
 8010bb8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010bbc:	441a      	add	r2, r3
 8010bbe:	4613      	mov	r3, r2
 8010bc0:	141b      	asrs	r3, r3, #16
 8010bc2:	b29c      	uxth	r4, r3
 8010bc4:	f000 fe36 	bl	8011834 <ENC_Get_Electrical_Angle>
 8010bc8:	4603      	mov	r3, r0
 8010bca:	b29b      	uxth	r3, r3
 8010bcc:	4423      	add	r3, r4
 8010bce:	b29b      	uxth	r3, r3
 8010bd0:	b29a      	uxth	r2, r3
 8010bd2:	4b20      	ldr	r3, [pc, #128]	; (8010c54 <IFOC_Model+0x12c>)
 8010bd4:	801a      	strh	r2, [r3, #0]
    hRotFlx_Theta += (s16)(wRotFlx_SlipFreq/65536) + TAC_GetRotorFreq();
  }
#endif    

  /*loads the Torque Regulator output reference voltage Vqs*/
  Stat_Volt_q_d.qV_Component1 = PID_Regulator(hTorque_Reference, 
 8010bd6:	4b22      	ldr	r3, [pc, #136]	; (8010c60 <IFOC_Model+0x138>)
 8010bd8:	881b      	ldrh	r3, [r3, #0]
 8010bda:	b29a      	uxth	r2, r3
 8010bdc:	4b1e      	ldr	r3, [pc, #120]	; (8010c58 <IFOC_Model+0x130>)
 8010bde:	881b      	ldrh	r3, [r3, #0]
 8010be0:	b212      	sxth	r2, r2
 8010be2:	b21b      	sxth	r3, r3
 8010be4:	4610      	mov	r0, r2
 8010be6:	4619      	mov	r1, r3
 8010be8:	4a1e      	ldr	r2, [pc, #120]	; (8010c64 <IFOC_Model+0x13c>)
 8010bea:	f000 fc71 	bl	80114d0 <PID_Regulator>
 8010bee:	4603      	mov	r3, r0
 8010bf0:	461a      	mov	r2, r3
 8010bf2:	4b1d      	ldr	r3, [pc, #116]	; (8010c68 <IFOC_Model+0x140>)
 8010bf4:	801a      	strh	r2, [r3, #0]
  						Stat_Curr_q_d.qI_Component1, &PID_Torque_InitStructure);

  
  /*loads the Flux Regulator output reference voltage Vds*/
  Stat_Volt_q_d.qV_Component2 = PID_Regulator(hFlux_Reference, 
 8010bf6:	4b1d      	ldr	r3, [pc, #116]	; (8010c6c <IFOC_Model+0x144>)
 8010bf8:	881b      	ldrh	r3, [r3, #0]
 8010bfa:	b29a      	uxth	r2, r3
 8010bfc:	4b16      	ldr	r3, [pc, #88]	; (8010c58 <IFOC_Model+0x130>)
 8010bfe:	885b      	ldrh	r3, [r3, #2]
 8010c00:	b212      	sxth	r2, r2
 8010c02:	b21b      	sxth	r3, r3
 8010c04:	4610      	mov	r0, r2
 8010c06:	4619      	mov	r1, r3
 8010c08:	4a19      	ldr	r2, [pc, #100]	; (8010c70 <IFOC_Model+0x148>)
 8010c0a:	f000 fc61 	bl	80114d0 <PID_Regulator>
 8010c0e:	4603      	mov	r3, r0
 8010c10:	461a      	mov	r2, r3
 8010c12:	4b15      	ldr	r3, [pc, #84]	; (8010c68 <IFOC_Model+0x140>)
 8010c14:	805a      	strh	r2, [r3, #2]
                          Stat_Curr_q_d.qI_Component2, &PID_Flux_InitStructure);  
  
  RevPark_Circle_Limitation();
 8010c16:	f7ff febd 	bl	8010994 <RevPark_Circle_Limitation>
  
  /*Performs the Reverse Park transformation,
  i.e transforms stator voltages Vqs and Vds into Valpha and Vbeta on a 
  stationary reference frame*/
  
  Stat_Volt_alfa_beta = Rev_Park(Stat_Volt_q_d);
 8010c1a:	4b13      	ldr	r3, [pc, #76]	; (8010c68 <IFOC_Model+0x140>)
 8010c1c:	681b      	ldr	r3, [r3, #0]
 8010c1e:	2200      	movs	r2, #0
 8010c20:	461a      	mov	r2, r3
 8010c22:	4610      	mov	r0, r2
 8010c24:	f7ff ff10 	bl	8010a48 <Rev_Park>
 8010c28:	4602      	mov	r2, r0
 8010c2a:	4b12      	ldr	r3, [pc, #72]	; (8010c74 <IFOC_Model+0x14c>)
 8010c2c:	4611      	mov	r1, r2
 8010c2e:	8019      	strh	r1, [r3, #0]
 8010c30:	f3c2 420f 	ubfx	r2, r2, #16, #16
 8010c34:	805a      	strh	r2, [r3, #2]
  
  /*Valpha and Vbeta finally drive the power stage*/ 
  CALC_SVPWM(Stat_Volt_alfa_beta);
 8010c36:	4b0f      	ldr	r3, [pc, #60]	; (8010c74 <IFOC_Model+0x14c>)
 8010c38:	681b      	ldr	r3, [r3, #0]
 8010c3a:	2200      	movs	r2, #0
 8010c3c:	461a      	mov	r2, r3
 8010c3e:	4610      	mov	r0, r2
 8010c40:	f000 ffde 	bl	8011c00 <SVPWM_IcsCalcDutyCycles>
}
 8010c44:	370c      	adds	r7, #12
 8010c46:	46bd      	mov	sp, r7
 8010c48:	bd90      	pop	{r4, r7, pc}
 8010c4a:	bf00      	nop
 8010c4c:	20012530 	.word	0x20012530
 8010c50:	200124e4 	.word	0x200124e4
 8010c54:	20010a0c 	.word	0x20010a0c
 8010c58:	20012538 	.word	0x20012538
 8010c5c:	20010a10 	.word	0x20010a10
 8010c60:	2001252a 	.word	0x2001252a
 8010c64:	200124e8 	.word	0x200124e8
 8010c68:	200124dc 	.word	0x200124dc
 8010c6c:	200124e0 	.word	0x200124e0
 8010c70:	20012544 	.word	0x20012544
 8010c74:	20012534 	.word	0x20012534

08010c78 <IFOC_CalcFluxTorqueRef>:
* Output          : None.
* Return          : None.
*******************************************************************************/

void IFOC_CalcFluxTorqueRef(void)
{
 8010c78:	b580      	push	{r7, lr}
 8010c7a:	b086      	sub	sp, #24
 8010c7c:	af00      	add	r7, sp, #0
  s16 hTempA;
  s16 hTempB;
  s16 hwe;  //stator generated frequency (pulses/pwm period)
  s16 hTorqueRefMax;
  
  hTempA = hSpeed_Reference;
 8010c7e:	4b45      	ldr	r3, [pc, #276]	; (8010d94 <IFOC_CalcFluxTorqueRef+0x11c>)
 8010c80:	881b      	ldrh	r3, [r3, #0]
 8010c82:	b29b      	uxth	r3, r3
 8010c84:	807b      	strh	r3, [r7, #2]
  
  hTempB = PID_Regulator(hTempA, hRot_Freq_Hz, &PID_Speed_InitStructure);
 8010c86:	887a      	ldrh	r2, [r7, #2]
 8010c88:	4b43      	ldr	r3, [pc, #268]	; (8010d98 <IFOC_CalcFluxTorqueRef+0x120>)
 8010c8a:	881b      	ldrh	r3, [r3, #0]
 8010c8c:	b29b      	uxth	r3, r3
 8010c8e:	b212      	sxth	r2, r2
 8010c90:	b21b      	sxth	r3, r3
 8010c92:	4610      	mov	r0, r2
 8010c94:	4619      	mov	r1, r3
 8010c96:	4a41      	ldr	r2, [pc, #260]	; (8010d9c <IFOC_CalcFluxTorqueRef+0x124>)
 8010c98:	f000 fc1a 	bl	80114d0 <PID_Regulator>
 8010c9c:	4603      	mov	r3, r0
 8010c9e:	827b      	strh	r3, [r7, #18]
      
  div_q31_q15_q15(K_RAD_HZ_HI,K_RAD_HZ_LOW,hFlux_Reference,&hTempA);
 8010ca0:	4b3f      	ldr	r3, [pc, #252]	; (8010da0 <IFOC_CalcFluxTorqueRef+0x128>)
 8010ca2:	881b      	ldrh	r3, [r3, #0]
 8010ca4:	b29b      	uxth	r3, r3
 8010ca6:	b21a      	sxth	r2, r3
 8010ca8:	1cbb      	adds	r3, r7, #2
 8010caa:	201d      	movs	r0, #29
 8010cac:	f644 6173 	movw	r1, #20083	; 0x4e73
 8010cb0:	f000 f906 	bl	8010ec0 <div_q31_q15_q15>
    
  mul_q15_q15_q31(hTempB,hTempA,&wRotFlxSlipFreq);
 8010cb4:	887b      	ldrh	r3, [r7, #2]
 8010cb6:	f9b7 1012 	ldrsh.w	r1, [r7, #18]
 8010cba:	b21a      	sxth	r2, r3
 8010cbc:	1d3b      	adds	r3, r7, #4
 8010cbe:	4608      	mov	r0, r1
 8010cc0:	4611      	mov	r1, r2
 8010cc2:	461a      	mov	r2, r3
 8010cc4:	f000 f982 	bl	8010fcc <mul_q15_q15_q31>
    
  hwe = (s16)(wRotFlxSlipFreq/65536 + hRot_Freq_Hz); //u16 to have absolute value of we
 8010cc8:	687b      	ldr	r3, [r7, #4]
 8010cca:	2b00      	cmp	r3, #0
 8010ccc:	da03      	bge.n	8010cd6 <IFOC_CalcFluxTorqueRef+0x5e>
 8010cce:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010cd2:	441a      	add	r2, r3
 8010cd4:	4613      	mov	r3, r2
 8010cd6:	141b      	asrs	r3, r3, #16
 8010cd8:	b29a      	uxth	r2, r3
 8010cda:	4b2f      	ldr	r3, [pc, #188]	; (8010d98 <IFOC_CalcFluxTorqueRef+0x120>)
 8010cdc:	881b      	ldrh	r3, [r3, #0]
 8010cde:	b29b      	uxth	r3, r3
 8010ce0:	b29b      	uxth	r3, r3
 8010ce2:	4413      	add	r3, r2
 8010ce4:	b29b      	uxth	r3, r3
 8010ce6:	82fb      	strh	r3, [r7, #22]
    
  hwe = (hwe < 0 ? -hwe : hwe);
 8010ce8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8010cec:	2b00      	cmp	r3, #0
 8010cee:	bfb8      	it	lt
 8010cf0:	425b      	neglt	r3, r3
 8010cf2:	82fb      	strh	r3, [r7, #22]
    
  if (hwe > RATED_FREQ)
 8010cf4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8010cf8:	f240 52c6 	movw	r2, #1478	; 0x5c6
 8010cfc:	4293      	cmp	r3, r2
 8010cfe:	dd24      	ble.n	8010d4a <IFOC_CalcFluxTorqueRef+0xd2>
  {
    u8 bspeed_index;
      
    s32 wtempindex;
      
    if (hwe > MAX_FREQ)
 8010d00:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8010d04:	f241 7218 	movw	r2, #5912	; 0x1718
 8010d08:	4293      	cmp	r3, r2
 8010d0a:	dd02      	ble.n	8010d12 <IFOC_CalcFluxTorqueRef+0x9a>
    {
      hwe = MAX_FREQ;
 8010d0c:	f241 7318 	movw	r3, #5912	; 0x1718
 8010d10:	82fb      	strh	r3, [r7, #22]
    }
      
    wtempindex = (hwe - RATED_FREQ) * 255; 
 8010d12:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8010d16:	f2a3 52c6 	subw	r2, r3, #1478	; 0x5c6
 8010d1a:	4613      	mov	r3, r2
 8010d1c:	021b      	lsls	r3, r3, #8
 8010d1e:	1a9b      	subs	r3, r3, r2
 8010d20:	60fb      	str	r3, [r7, #12]
      
    bspeed_index = (u8)(wtempindex / MAX_FREQ_INCR); 
 8010d22:	68fb      	ldr	r3, [r7, #12]
 8010d24:	4a1f      	ldr	r2, [pc, #124]	; (8010da4 <IFOC_CalcFluxTorqueRef+0x12c>)
 8010d26:	fb82 1203 	smull	r1, r2, r2, r3
 8010d2a:	1252      	asrs	r2, r2, #9
 8010d2c:	17db      	asrs	r3, r3, #31
 8010d2e:	1ad3      	subs	r3, r2, r3
 8010d30:	72fb      	strb	r3, [r7, #11]
      
    hFlux_Reference = hflux_reference[bspeed_index];
 8010d32:	7afb      	ldrb	r3, [r7, #11]
 8010d34:	4a1c      	ldr	r2, [pc, #112]	; (8010da8 <IFOC_CalcFluxTorqueRef+0x130>)
 8010d36:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 8010d3a:	4b19      	ldr	r3, [pc, #100]	; (8010da0 <IFOC_CalcFluxTorqueRef+0x128>)
 8010d3c:	801a      	strh	r2, [r3, #0]
      
    hTorqueRefMax = htorque_reference[bspeed_index];
 8010d3e:	7afb      	ldrb	r3, [r7, #11]
 8010d40:	4a1a      	ldr	r2, [pc, #104]	; (8010dac <IFOC_CalcFluxTorqueRef+0x134>)
 8010d42:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8010d46:	82bb      	strh	r3, [r7, #20]
 8010d48:	e006      	b.n	8010d58 <IFOC_CalcFluxTorqueRef+0xe0>
              
  }
  else
  {
    hFlux_Reference = hflux_reference[0];
 8010d4a:	f242 4206 	movw	r2, #9222	; 0x2406
 8010d4e:	4b14      	ldr	r3, [pc, #80]	; (8010da0 <IFOC_CalcFluxTorqueRef+0x128>)
 8010d50:	801a      	strh	r2, [r3, #0]
      
    hTorqueRefMax = htorque_reference[0];
 8010d52:	f644 43fb 	movw	r3, #19707	; 0x4cfb
 8010d56:	82bb      	strh	r3, [r7, #20]
  }
    
  if (hTempB > hTorqueRefMax)
 8010d58:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8010d5c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8010d60:	429a      	cmp	r2, r3
 8010d62:	dd03      	ble.n	8010d6c <IFOC_CalcFluxTorqueRef+0xf4>
  {
    hTorque_Reference = hTorqueRefMax;
 8010d64:	4a12      	ldr	r2, [pc, #72]	; (8010db0 <IFOC_CalcFluxTorqueRef+0x138>)
 8010d66:	8abb      	ldrh	r3, [r7, #20]
 8010d68:	8013      	strh	r3, [r2, #0]
 8010d6a:	e010      	b.n	8010d8e <IFOC_CalcFluxTorqueRef+0x116>
  }
  else  if ( hTempB < -hTorqueRefMax)
 8010d6c:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8010d70:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8010d74:	425b      	negs	r3, r3
 8010d76:	429a      	cmp	r2, r3
 8010d78:	da06      	bge.n	8010d88 <IFOC_CalcFluxTorqueRef+0x110>
        {
          hTorque_Reference = -hTorqueRefMax;
 8010d7a:	8abb      	ldrh	r3, [r7, #20]
 8010d7c:	425b      	negs	r3, r3
 8010d7e:	b29b      	uxth	r3, r3
 8010d80:	b29a      	uxth	r2, r3
 8010d82:	4b0b      	ldr	r3, [pc, #44]	; (8010db0 <IFOC_CalcFluxTorqueRef+0x138>)
 8010d84:	801a      	strh	r2, [r3, #0]
 8010d86:	e002      	b.n	8010d8e <IFOC_CalcFluxTorqueRef+0x116>
        }
        else
        {
          hTorque_Reference = hTempB;
 8010d88:	4a09      	ldr	r2, [pc, #36]	; (8010db0 <IFOC_CalcFluxTorqueRef+0x138>)
 8010d8a:	8a7b      	ldrh	r3, [r7, #18]
 8010d8c:	8013      	strh	r3, [r2, #0]
        }
  
  
}
 8010d8e:	3718      	adds	r7, #24
 8010d90:	46bd      	mov	sp, r7
 8010d92:	bd80      	pop	{r7, pc}
 8010d94:	20012540 	.word	0x20012540
 8010d98:	2001253e 	.word	0x2001253e
 8010d9c:	20012508 	.word	0x20012508
 8010da0:	200124e0 	.word	0x200124e0
 8010da4:	1d8f87e9 	.word	0x1d8f87e9
 8010da8:	0802482c 	.word	0x0802482c
 8010dac:	08024a2c 	.word	0x08024a2c
 8010db0:	2001252a 	.word	0x2001252a

08010db4 <CalcIm>:
* Input          : Stator current Ids (on the Rotor Flux rotating frame).
* Output         : None.
* Return         : Rotor Flux divided by Lm (Magnetizing inductance). 
*******************************************************************************/
s16 CalcIm(s16 hId_input)
{
 8010db4:	b580      	push	{r7, lr}
 8010db6:	b086      	sub	sp, #24
 8010db8:	af00      	add	r7, sp, #0
 8010dba:	4603      	mov	r3, r0
 8010dbc:	80fb      	strh	r3, [r7, #6]
  s32 wTemp1;
  s32 wTemp2;
  s16 hIm;
  
  hIm = ((s16)(wIm / 65536));
 8010dbe:	4b1d      	ldr	r3, [pc, #116]	; (8010e34 <CalcIm+0x80>)
 8010dc0:	681b      	ldr	r3, [r3, #0]
 8010dc2:	2b00      	cmp	r3, #0
 8010dc4:	da03      	bge.n	8010dce <CalcIm+0x1a>
 8010dc6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010dca:	441a      	add	r2, r3
 8010dcc:	4613      	mov	r3, r2
 8010dce:	141b      	asrs	r3, r3, #16
 8010dd0:	82fb      	strh	r3, [r7, #22]
  
  mul_q15_q15_q31(qK_EULER,hId_input,&wTemp1);
 8010dd2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8010dd6:	f107 0310 	add.w	r3, r7, #16
 8010dda:	2078      	movs	r0, #120	; 0x78
 8010ddc:	4611      	mov	r1, r2
 8010dde:	461a      	mov	r2, r3
 8010de0:	f000 f8f4 	bl	8010fcc <mul_q15_q15_q31>
  mul_q15_q15_q31(qK_EULER,hIm,&wTemp2);
 8010de4:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8010de8:	f107 030c 	add.w	r3, r7, #12
 8010dec:	2078      	movs	r0, #120	; 0x78
 8010dee:	4611      	mov	r1, r2
 8010df0:	461a      	mov	r2, r3
 8010df2:	f000 f8eb 	bl	8010fcc <mul_q15_q15_q31>
  wTemp1 -= wTemp2;
 8010df6:	693a      	ldr	r2, [r7, #16]
 8010df8:	68fb      	ldr	r3, [r7, #12]
 8010dfa:	1ad3      	subs	r3, r2, r3
 8010dfc:	613b      	str	r3, [r7, #16]
  
  wTemp1 /= EUL_SENS;
 8010dfe:	693b      	ldr	r3, [r7, #16]
 8010e00:	0fda      	lsrs	r2, r3, #31
 8010e02:	4413      	add	r3, r2
 8010e04:	105b      	asrs	r3, r3, #1
 8010e06:	613b      	str	r3, [r7, #16]
  wIm += wTemp1;
 8010e08:	4b0a      	ldr	r3, [pc, #40]	; (8010e34 <CalcIm+0x80>)
 8010e0a:	681a      	ldr	r2, [r3, #0]
 8010e0c:	693b      	ldr	r3, [r7, #16]
 8010e0e:	4413      	add	r3, r2
 8010e10:	4a08      	ldr	r2, [pc, #32]	; (8010e34 <CalcIm+0x80>)
 8010e12:	6013      	str	r3, [r2, #0]
 
  hIm = ((s16)(wIm / 65536));
 8010e14:	4b07      	ldr	r3, [pc, #28]	; (8010e34 <CalcIm+0x80>)
 8010e16:	681b      	ldr	r3, [r3, #0]
 8010e18:	2b00      	cmp	r3, #0
 8010e1a:	da03      	bge.n	8010e24 <CalcIm+0x70>
 8010e1c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010e20:	441a      	add	r2, r3
 8010e22:	4613      	mov	r3, r2
 8010e24:	141b      	asrs	r3, r3, #16
 8010e26:	82fb      	strh	r3, [r7, #22]
  return (hIm);
 8010e28:	8afb      	ldrh	r3, [r7, #22]
 8010e2a:	b21b      	sxth	r3, r3
    
}
 8010e2c:	4618      	mov	r0, r3
 8010e2e:	3718      	adds	r7, #24
 8010e30:	46bd      	mov	sp, r7
 8010e32:	bd80      	pop	{r7, pc}
 8010e34:	20010008 	.word	0x20010008

08010e38 <CalcRotFlxSlipFreq>:
* Output         : None.
* Return         : Rotor Flux slip frequency,
*                  i.e Rotor Flux frequency - Rotor electrical frequency.
*******************************************************************************/
s32 CalcRotFlxSlipFreq(s16 hIq_input,s16 hIm_input)
{
 8010e38:	b580      	push	{r7, lr}
 8010e3a:	b084      	sub	sp, #16
 8010e3c:	af00      	add	r7, sp, #0
 8010e3e:	4603      	mov	r3, r0
 8010e40:	460a      	mov	r2, r1
 8010e42:	80fb      	strh	r3, [r7, #6]
 8010e44:	4613      	mov	r3, r2
 8010e46:	80bb      	strh	r3, [r7, #4]
  s32 wTempA;
  s16 hTemp1;
    
  div_q31_q15_q15(K_RAD_PULSE_HI,K_RAD_PULSE_LOW,hIm_input,&hTemp1);
 8010e48:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 8010e4c:	f107 030a 	add.w	r3, r7, #10
 8010e50:	2013      	movs	r0, #19
 8010e52:	f243 41ce 	movw	r1, #13518	; 0x34ce
 8010e56:	f000 f833 	bl	8010ec0 <div_q31_q15_q15>
  
  mul_q15_q15_q31(hIq_input,hTemp1,&wTempA);
 8010e5a:	897b      	ldrh	r3, [r7, #10]
 8010e5c:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 8010e60:	b21a      	sxth	r2, r3
 8010e62:	f107 030c 	add.w	r3, r7, #12
 8010e66:	4608      	mov	r0, r1
 8010e68:	4611      	mov	r1, r2
 8010e6a:	461a      	mov	r2, r3
 8010e6c:	f000 f8ae 	bl	8010fcc <mul_q15_q15_q31>

  return (wTempA);
 8010e70:	68fb      	ldr	r3, [r7, #12]
}
 8010e72:	4618      	mov	r0, r3
 8010e74:	3710      	adds	r7, #16
 8010e76:	46bd      	mov	sp, r7
 8010e78:	bd80      	pop	{r7, pc}
 8010e7a:	bf00      	nop

08010e7c <IFOC_Init>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void IFOC_Init(void)
{
 8010e7c:	b580      	push	{r7, lr}
 8010e7e:	af00      	add	r7, sp, #0
  wIm = ((K_RAD_PULSE_HI + 1)*65536);
 8010e80:	4b0b      	ldr	r3, [pc, #44]	; (8010eb0 <IFOC_Init+0x34>)
 8010e82:	f44f 12a0 	mov.w	r2, #1310720	; 0x140000
 8010e86:	601a      	str	r2, [r3, #0]
  hRotFlx_Theta = 0;        // Rotor flux angle
 8010e88:	4b0a      	ldr	r3, [pc, #40]	; (8010eb4 <IFOC_Init+0x38>)
 8010e8a:	2200      	movs	r2, #0
 8010e8c:	801a      	strh	r2, [r3, #0]
#if defined (ENCODER)
  wRotFlx_SlipTheta = 0;  // Rotor flux slip angle
 8010e8e:	4b0a      	ldr	r3, [pc, #40]	; (8010eb8 <IFOC_Init+0x3c>)
 8010e90:	2200      	movs	r2, #0
 8010e92:	601a      	str	r2, [r3, #0]
#endif
  
  //It applies 50% duty cycle on the output
  Stat_Volt_alfa_beta.qV_Component1=0;
 8010e94:	4b09      	ldr	r3, [pc, #36]	; (8010ebc <IFOC_Init+0x40>)
 8010e96:	2200      	movs	r2, #0
 8010e98:	801a      	strh	r2, [r3, #0]
  Stat_Volt_alfa_beta.qV_Component2=0;
 8010e9a:	4b08      	ldr	r3, [pc, #32]	; (8010ebc <IFOC_Init+0x40>)
 8010e9c:	2200      	movs	r2, #0
 8010e9e:	805a      	strh	r2, [r3, #2]
  CALC_SVPWM(Stat_Volt_alfa_beta);
 8010ea0:	4b06      	ldr	r3, [pc, #24]	; (8010ebc <IFOC_Init+0x40>)
 8010ea2:	681b      	ldr	r3, [r3, #0]
 8010ea4:	2200      	movs	r2, #0
 8010ea6:	461a      	mov	r2, r3
 8010ea8:	4610      	mov	r0, r2
 8010eaa:	f000 fea9 	bl	8011c00 <SVPWM_IcsCalcDutyCycles>
}
 8010eae:	bd80      	pop	{r7, pc}
 8010eb0:	20010008 	.word	0x20010008
 8010eb4:	20010a0c 	.word	0x20010a0c
 8010eb8:	20010a10 	.word	0x20010a10
 8010ebc:	20012534 	.word	0x20012534

08010ec0 <div_q31_q15_q15>:
*                  Operand 2 (divisor)
* Output         : Op1 / Op2, q1.15 format
* Return         : none.
*******************************************************************************/
void div_q31_q15_q15(s16 LeftOpMsb, u16 LeftOpLsb, s16 RightOp, s16 *Output)
{
 8010ec0:	b480      	push	{r7}
 8010ec2:	b08d      	sub	sp, #52	; 0x34
 8010ec4:	af00      	add	r7, sp, #0
 8010ec6:	607b      	str	r3, [r7, #4]
 8010ec8:	4603      	mov	r3, r0
 8010eca:	81fb      	strh	r3, [r7, #14]
 8010ecc:	460b      	mov	r3, r1
 8010ece:	81bb      	strh	r3, [r7, #12]
 8010ed0:	4613      	mov	r3, r2
 8010ed2:	817b      	strh	r3, [r7, #10]
 long temp1, temp2;
 short nb_bits, i, CS, test;

//aux1 = (s32)LeftOpMsb<<16;  /* creating a long to provide*/
 
  aux1 = (s32)(LeftOpMsb*65536);  /* creating a long to provide*/
 8010ed4:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8010ed8:	041b      	lsls	r3, r3, #16
 8010eda:	62fb      	str	r3, [r7, #44]	; 0x2c
 
 
 
 aux1 += (unsigned)LeftOpLsb; /* a 32 bits dividende */
 8010edc:	89ba      	ldrh	r2, [r7, #12]
 8010ede:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010ee0:	4413      	add	r3, r2
 8010ee2:	62fb      	str	r3, [r7, #44]	; 0x2c

 if( RightOp==0 )
 8010ee4:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8010ee8:	2b00      	cmp	r3, #0
 8010eea:	d10e      	bne.n	8010f0a <div_q31_q15_q15+0x4a>
 {
   if( aux1<0 )
 8010eec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010eee:	2b00      	cmp	r3, #0
 8010ef0:	da03      	bge.n	8010efa <div_q31_q15_q15+0x3a>
   {
     *Output = 0x8000;
 8010ef2:	687b      	ldr	r3, [r7, #4]
 8010ef4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8010ef8:	801a      	strh	r2, [r3, #0]
   }
   if( aux1>=0 )
 8010efa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010efc:	2b00      	cmp	r3, #0
 8010efe:	db5f      	blt.n	8010fc0 <div_q31_q15_q15+0x100>
   {
     *Output = 0x7fff;
 8010f00:	687b      	ldr	r3, [r7, #4]
 8010f02:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8010f06:	801a      	strh	r2, [r3, #0]
 8010f08:	e05a      	b.n	8010fc0 <div_q31_q15_q15+0x100>
 }
 else
 {
  
   
   aux2 = (s32)RightOp*65536;    /* divisor  */
 8010f0a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8010f0e:	041b      	lsls	r3, r3, #16
 8010f10:	623b      	str	r3, [r7, #32]
   
   
   temp1 = aux1&0x80000000;
 8010f12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f14:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8010f18:	61fb      	str	r3, [r7, #28]
   temp2 = aux2&0x80000000;
 8010f1a:	6a3b      	ldr	r3, [r7, #32]
 8010f1c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8010f20:	61bb      	str	r3, [r7, #24]

   if (temp1==temp2)
 8010f22:	69fa      	ldr	r2, [r7, #28]
 8010f24:	69bb      	ldr	r3, [r7, #24]
 8010f26:	429a      	cmp	r2, r3
 8010f28:	d104      	bne.n	8010f34 <div_q31_q15_q15+0x74>
   {
     CS=0;		
 8010f2a:	2300      	movs	r3, #0
 8010f2c:	853b      	strh	r3, [r7, #40]	; 0x28
     test=0;
 8010f2e:	2300      	movs	r3, #0
 8010f30:	84fb      	strh	r3, [r7, #38]	; 0x26
 8010f32:	e003      	b.n	8010f3c <div_q31_q15_q15+0x7c>
   }
   else
   {
     CS=1;	/* CS=1 for different signs */
 8010f34:	2301      	movs	r3, #1
 8010f36:	853b      	strh	r3, [r7, #40]	; 0x28
     test=1;
 8010f38:	2301      	movs	r3, #1
 8010f3a:	84fb      	strh	r3, [r7, #38]	; 0x26
   }

   aux1 = aux1*2;
 8010f3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f3e:	005b      	lsls	r3, r3, #1
 8010f40:	62fb      	str	r3, [r7, #44]	; 0x2c
   
   aux1 += test;
 8010f42:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8010f46:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010f48:	4413      	add	r3, r2
 8010f4a:	62fb      	str	r3, [r7, #44]	; 0x2c

   nb_bits=15;
 8010f4c:	230f      	movs	r3, #15
 8010f4e:	82fb      	strh	r3, [r7, #22]

   for (i=0; i<nb_bits; i++)
 8010f50:	2300      	movs	r3, #0
 8010f52:	857b      	strh	r3, [r7, #42]	; 0x2a
 8010f54:	e02a      	b.n	8010fac <div_q31_q15_q15+0xec>
   {
     if (CS==1)
 8010f56:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8010f5a:	2b01      	cmp	r3, #1
 8010f5c:	d104      	bne.n	8010f68 <div_q31_q15_q15+0xa8>
     {      
       aux1 += aux2;
 8010f5e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010f60:	6a3b      	ldr	r3, [r7, #32]
 8010f62:	4413      	add	r3, r2
 8010f64:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010f66:	e003      	b.n	8010f70 <div_q31_q15_q15+0xb0>
     }
     else
     {      
       aux1 -= aux2;
 8010f68:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010f6a:	6a3b      	ldr	r3, [r7, #32]
 8010f6c:	1ad3      	subs	r3, r2, r3
 8010f6e:	62fb      	str	r3, [r7, #44]	; 0x2c
     }

     temp1 = aux1&0x80000000;
 8010f70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f72:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8010f76:	61fb      	str	r3, [r7, #28]
     /*     temp2 = aux2&0x80000000;  */    /* temp2 has not been modified  */
     if ( temp1==temp2 )
 8010f78:	69fa      	ldr	r2, [r7, #28]
 8010f7a:	69bb      	ldr	r3, [r7, #24]
 8010f7c:	429a      	cmp	r2, r3
 8010f7e:	d104      	bne.n	8010f8a <div_q31_q15_q15+0xca>
     {
       CS=0;
 8010f80:	2300      	movs	r3, #0
 8010f82:	853b      	strh	r3, [r7, #40]	; 0x28
       test=1;	// shift !CS into partial remainder
 8010f84:	2301      	movs	r3, #1
 8010f86:	84fb      	strh	r3, [r7, #38]	; 0x26
 8010f88:	e003      	b.n	8010f92 <div_q31_q15_q15+0xd2>
     }
     else
     {
       CS=1;
 8010f8a:	2301      	movs	r3, #1
 8010f8c:	853b      	strh	r3, [r7, #40]	; 0x28
       test=0;
 8010f8e:	2300      	movs	r3, #0
 8010f90:	84fb      	strh	r3, [r7, #38]	; 0x26
     }
     
     aux1 = (aux1*2);
 8010f92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f94:	005b      	lsls	r3, r3, #1
 8010f96:	62fb      	str	r3, [r7, #44]	; 0x2c
     aux1 += test;
 8010f98:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8010f9c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010f9e:	4413      	add	r3, r2
 8010fa0:	62fb      	str	r3, [r7, #44]	; 0x2c
   
   aux1 += test;

   nb_bits=15;

   for (i=0; i<nb_bits; i++)
 8010fa2:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8010fa4:	b29b      	uxth	r3, r3
 8010fa6:	3301      	adds	r3, #1
 8010fa8:	b29b      	uxth	r3, r3
 8010faa:	857b      	strh	r3, [r7, #42]	; 0x2a
 8010fac:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 8010fb0:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8010fb4:	429a      	cmp	r2, r3
 8010fb6:	dbce      	blt.n	8010f56 <div_q31_q15_q15+0x96>
     
     aux1 = (aux1*2);
     aux1 += test;
   }

   *Output = (s16)aux1;
 8010fb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010fba:	b29a      	uxth	r2, r3
 8010fbc:	687b      	ldr	r3, [r7, #4]
 8010fbe:	801a      	strh	r2, [r3, #0]
 }	
}
 8010fc0:	3734      	adds	r7, #52	; 0x34
 8010fc2:	46bd      	mov	sp, r7
 8010fc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fc8:	4770      	bx	lr
 8010fca:	bf00      	nop

08010fcc <mul_q15_q15_q31>:
* Input          : Operand 1 (factor), Operand 2 (factor)
* Output         : Op1 * Op2, q1.31 format
* Return         : none.
*******************************************************************************/                 
void mul_q15_q15_q31(s16 Op1, s16 Op2, s32 *Out)
{
 8010fcc:	b480      	push	{r7}
 8010fce:	b085      	sub	sp, #20
 8010fd0:	af00      	add	r7, sp, #0
 8010fd2:	4603      	mov	r3, r0
 8010fd4:	603a      	str	r2, [r7, #0]
 8010fd6:	80fb      	strh	r3, [r7, #6]
 8010fd8:	460b      	mov	r3, r1
 8010fda:	80bb      	strh	r3, [r7, #4]
  s32 temp;
 
  temp = Op1 * Op2;
 8010fdc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8010fe0:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 8010fe4:	fb02 f303 	mul.w	r3, r2, r3
 8010fe8:	60fb      	str	r3, [r7, #12]
  
  if (temp==0x40000000)   /* Overflow (-1*-1) */
 8010fea:	68fb      	ldr	r3, [r7, #12]
 8010fec:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8010ff0:	d103      	bne.n	8010ffa <mul_q15_q15_q31+0x2e>
  {
    temp=0x7fffffff;
 8010ff2:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8010ff6:	60fb      	str	r3, [r7, #12]
 8010ff8:	e002      	b.n	8011000 <mul_q15_q15_q31+0x34>
  }
  else
  {       
     temp = temp * 2;       /* One bit left shift to remove redondant sign bit */       
 8010ffa:	68fb      	ldr	r3, [r7, #12]
 8010ffc:	005b      	lsls	r3, r3, #1
 8010ffe:	60fb      	str	r3, [r7, #12]
  }  
  *Out=temp;
 8011000:	683b      	ldr	r3, [r7, #0]
 8011002:	68fa      	ldr	r2, [r7, #12]
 8011004:	601a      	str	r2, [r3, #0]
}
 8011006:	3714      	adds	r7, #20
 8011008:	46bd      	mov	sp, r7
 801100a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801100e:	4770      	bx	lr

08011010 <MCL_Init>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void MCL_Init(void)
{
 8011010:	b580      	push	{r7, lr}
 8011012:	af00      	add	r7, sp, #0

// reset PID's integral values
    MCL_Reset_PID_IntegralTerms();
 8011014:	f000 f99e 	bl	8011354 <MCL_Reset_PID_IntegralTerms>
    
#ifdef ENCODER
    ENC_Clear_Speed_Buffer();
 8011018:	f000 fc28 	bl	801186c <ENC_Clear_Speed_Buffer>
#elif defined TACHO
    TAC_InitTachoMeasure();  
#endif   
    
    IFOC_Init();
 801101c:	f7ff ff2e 	bl	8010e7c <IFOC_Init>
 
//It generates for 2 msec a 50% duty cycle on the three phases to load Boot 
//capacitance of high side drivers
    TB_Set_StartUp_Timeout(4);    
 8011020:	2004      	movs	r0, #4
 8011022:	f000 faf5 	bl	8011610 <TB_Set_StartUp_Timeout>
    
    /* Main PWM Output Enable */
	PWMOutputsEnable(TIM8);
 8011026:	4813      	ldr	r0, [pc, #76]	; (8011074 <MCL_Init+0x64>)
 8011028:	f7fd fe28 	bl	800ec7c <PWMOutputsEnable>
    while(!TB_StartUp_Timeout_IsElapsed())
 801102c:	bf00      	nop
 801102e:	f000 fb05 	bl	801163c <TB_StartUp_Timeout_IsElapsed>
 8011032:	4603      	mov	r3, r0
 8011034:	2b00      	cmp	r3, #0
 8011036:	d0fa      	beq.n	801102e <MCL_Init+0x1e>
    {
    }
        
    if ((wGlobal_Flags & CLOSED_LOOP) != CLOSED_LOOP) 
 8011038:	4b0f      	ldr	r3, [pc, #60]	; (8011078 <MCL_Init+0x68>)
 801103a:	681b      	ldr	r3, [r3, #0]
 801103c:	f003 0301 	and.w	r3, r3, #1
 8011040:	2b00      	cmp	r3, #0
 8011042:	d111      	bne.n	8011068 <MCL_Init+0x58>
      {
        wOL_Start_up_Torque_Ref = hTorque_Reference*16;
 8011044:	4b0d      	ldr	r3, [pc, #52]	; (801107c <MCL_Init+0x6c>)
 8011046:	881b      	ldrh	r3, [r3, #0]
 8011048:	b29b      	uxth	r3, r3
 801104a:	b21b      	sxth	r3, r3
 801104c:	011b      	lsls	r3, r3, #4
 801104e:	4a0c      	ldr	r2, [pc, #48]	; (8011080 <MCL_Init+0x70>)
 8011050:	6013      	str	r3, [r2, #0]
        hOL_Start_up_Torque_Increment = (s16)(wOL_Start_up_Torque_Ref/(2*STARTUP_RAMP_DURATION));
 8011052:	4b0b      	ldr	r3, [pc, #44]	; (8011080 <MCL_Init+0x70>)
 8011054:	681b      	ldr	r3, [r3, #0]
 8011056:	4a0b      	ldr	r2, [pc, #44]	; (8011084 <MCL_Init+0x74>)
 8011058:	fb82 1203 	smull	r1, r2, r2, r3
 801105c:	1192      	asrs	r2, r2, #6
 801105e:	17db      	asrs	r3, r3, #31
 8011060:	1ad3      	subs	r3, r2, r3
 8011062:	b29a      	uxth	r2, r3
 8011064:	4b08      	ldr	r3, [pc, #32]	; (8011088 <MCL_Init+0x78>)
 8011066:	801a      	strh	r2, [r3, #0]
      }
                      
    hTorque_Reference=0;    
 8011068:	4b04      	ldr	r3, [pc, #16]	; (801107c <MCL_Init+0x6c>)
 801106a:	2200      	movs	r2, #0
 801106c:	801a      	strh	r2, [r3, #0]
      
#ifdef THREE_SHUNT                    
    SVPWM_3ShuntCurrentReadingCalibration();
#elif defined ICS_SENSORS
    SVPWM_IcsCurrentReadingCalibration();
 801106e:	f000 fd7f 	bl	8011b70 <SVPWM_IcsCurrentReadingCalibration>
#endif 
#ifdef SINGLE_SHUNT    
    // Enable the Adv Current Reading during Run state
    SVPWM_1ShuntAdvCurrentReading(ENABLE);
#endif  
}
 8011072:	bd80      	pop	{r7, pc}
 8011074:	40010400 	.word	0x40010400
 8011078:	20010a08 	.word	0x20010a08
 801107c:	2001252a 	.word	0x2001252a
 8011080:	200124d8 	.word	0x200124d8
 8011084:	51eb851f 	.word	0x51eb851f
 8011088:	2001253c 	.word	0x2001253c

0801108c <MCL_Init_Arrays>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void MCL_Init_Arrays(void)
{ 
 801108c:	b480      	push	{r7}
 801108e:	b083      	sub	sp, #12
 8011090:	af00      	add	r7, sp, #0
  u32 i;

  for(i= AV_ARRAY_SIZE; i > 0; i--)
 8011092:	2310      	movs	r3, #16
 8011094:	607b      	str	r3, [r7, #4]
 8011096:	e00f      	b.n	80110b8 <MCL_Init_Arrays+0x2c>
  {
    hTemp_av_array[i-1] = TEMP_ARRAY_INIT;
 8011098:	687b      	ldr	r3, [r7, #4]
 801109a:	3b01      	subs	r3, #1
 801109c:	4a0a      	ldr	r2, [pc, #40]	; (80110c8 <MCL_Init_Arrays+0x3c>)
 801109e:	2100      	movs	r1, #0
 80110a0:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    hBusV_av_array[i-1] = VOLT_ARRAY_INIT;   
 80110a4:	687b      	ldr	r3, [r7, #4]
 80110a6:	3b01      	subs	r3, #1
 80110a8:	4a08      	ldr	r2, [pc, #32]	; (80110cc <MCL_Init_Arrays+0x40>)
 80110aa:	f643 11df 	movw	r1, #14815	; 0x39df
 80110ae:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
*******************************************************************************/
void MCL_Init_Arrays(void)
{ 
  u32 i;

  for(i= AV_ARRAY_SIZE; i > 0; i--)
 80110b2:	687b      	ldr	r3, [r7, #4]
 80110b4:	3b01      	subs	r3, #1
 80110b6:	607b      	str	r3, [r7, #4]
 80110b8:	687b      	ldr	r3, [r7, #4]
 80110ba:	2b00      	cmp	r3, #0
 80110bc:	d1ec      	bne.n	8011098 <MCL_Init_Arrays+0xc>
  {
    hTemp_av_array[i-1] = TEMP_ARRAY_INIT;
    hBusV_av_array[i-1] = VOLT_ARRAY_INIT;   
  }
}
 80110be:	370c      	adds	r7, #12
 80110c0:	46bd      	mov	sp, r7
 80110c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110c6:	4770      	bx	lr
 80110c8:	20010a3c 	.word	0x20010a3c
 80110cc:	20010a1c 	.word	0x20010a1c

080110d0 <MCL_SetFault>:
* Input          : Fault type
* Output         : None
* Return         : None
*******************************************************************************/
void MCL_SetFault(u16 hFault_type)
{
 80110d0:	b580      	push	{r7, lr}
 80110d2:	b082      	sub	sp, #8
 80110d4:	af00      	add	r7, sp, #0
 80110d6:	4603      	mov	r3, r0
 80110d8:	80fb      	strh	r3, [r7, #6]
  TB_Set_Delay_500us(FAULT_STATE_MIN_PERMANENCY); 
 80110da:	f44f 7016 	mov.w	r0, #600	; 0x258
 80110de:	f000 fa75 	bl	80115cc <TB_Set_Delay_500us>
  /* Main PWM Output Enable */
  
  rt_kprintf("error:error code 0x%x\r\n", hFault_type);
 80110e2:	88fb      	ldrh	r3, [r7, #6]
 80110e4:	4809      	ldr	r0, [pc, #36]	; (801110c <MCL_SetFault+0x3c>)
 80110e6:	4619      	mov	r1, r3
 80110e8:	f002 fdc2 	bl	8013c70 <rt_kprintf>
  PWMOutputsDisable(TIM8);
 80110ec:	4808      	ldr	r0, [pc, #32]	; (8011110 <MCL_SetFault+0x40>)
 80110ee:	f7fd fde3 	bl	800ecb8 <PWMOutputsDisable>
  wGlobal_Flags |= hFault_type;
 80110f2:	88fa      	ldrh	r2, [r7, #6]
 80110f4:	4b07      	ldr	r3, [pc, #28]	; (8011114 <MCL_SetFault+0x44>)
 80110f6:	681b      	ldr	r3, [r3, #0]
 80110f8:	4313      	orrs	r3, r2
 80110fa:	4a06      	ldr	r2, [pc, #24]	; (8011114 <MCL_SetFault+0x44>)
 80110fc:	6013      	str	r3, [r2, #0]
  State = FAULT;
 80110fe:	4b06      	ldr	r3, [pc, #24]	; (8011118 <MCL_SetFault+0x48>)
 8011100:	2207      	movs	r2, #7
 8011102:	701a      	strb	r2, [r3, #0]
  SVPWM_3ShuntAdvCurrentReading(DISABLE);
#endif
#ifdef SINGLE_SHUNT
  SVPWM_1ShuntAdvCurrentReading(DISABLE);
#endif
}
 8011104:	3708      	adds	r7, #8
 8011106:	46bd      	mov	sp, r7
 8011108:	bd80      	pop	{r7, pc}
 801110a:	bf00      	nop
 801110c:	08022c38 	.word	0x08022c38
 8011110:	40010400 	.word	0x40010400
 8011114:	20010a08 	.word	0x20010a08
 8011118:	20012528 	.word	0x20012528

0801111c <MCL_ClearFault>:
* Input          : Fault type
* Output         : None
* Return         : None
*******************************************************************************/
bool MCL_ClearFault(void)
{     
 801111c:	b580      	push	{r7, lr}
 801111e:	af00      	add	r7, sp, #0
  if (TB_Delay_IsElapsed())
 8011120:	f000 fa64 	bl	80115ec <TB_Delay_IsElapsed>
 8011124:	4603      	mov	r3, r0
 8011126:	2b00      	cmp	r3, #0
 8011128:	d064      	beq.n	80111f4 <MCL_ClearFault+0xd8>
  {   
    if ((wGlobal_Flags & OVERHEAT) == OVERHEAT)   
 801112a:	4b33      	ldr	r3, [pc, #204]	; (80111f8 <MCL_ClearFault+0xdc>)
 801112c:	681b      	ldr	r3, [r3, #0]
 801112e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8011132:	2b00      	cmp	r3, #0
 8011134:	d00a      	beq.n	801114c <MCL_ClearFault+0x30>
    {               
      if(MCL_Chk_OverTemp()== FALSE)
 8011136:	f000 f863 	bl	8011200 <MCL_Chk_OverTemp>
 801113a:	4603      	mov	r3, r0
 801113c:	2b00      	cmp	r3, #0
 801113e:	d105      	bne.n	801114c <MCL_ClearFault+0x30>
      {
        wGlobal_Flags &= ~OVERHEAT;
 8011140:	4b2d      	ldr	r3, [pc, #180]	; (80111f8 <MCL_ClearFault+0xdc>)
 8011142:	681b      	ldr	r3, [r3, #0]
 8011144:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8011148:	4a2b      	ldr	r2, [pc, #172]	; (80111f8 <MCL_ClearFault+0xdc>)
 801114a:	6013      	str	r3, [r2, #0]
      }     
    }
    
    if ((wGlobal_Flags & OVER_VOLTAGE) == OVER_VOLTAGE)   
 801114c:	4b2a      	ldr	r3, [pc, #168]	; (80111f8 <MCL_ClearFault+0xdc>)
 801114e:	681b      	ldr	r3, [r3, #0]
 8011150:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8011154:	2b00      	cmp	r3, #0
 8011156:	d00a      	beq.n	801116e <MCL_ClearFault+0x52>
    {            
        if(MCL_Chk_BusVolt()== NO_FAULT)
 8011158:	f000 f8ac 	bl	80112b4 <MCL_Chk_BusVolt>
 801115c:	4603      	mov	r3, r0
 801115e:	2b00      	cmp	r3, #0
 8011160:	d105      	bne.n	801116e <MCL_ClearFault+0x52>
        {
          wGlobal_Flags &= ~OVER_VOLTAGE;
 8011162:	4b25      	ldr	r3, [pc, #148]	; (80111f8 <MCL_ClearFault+0xdc>)
 8011164:	681b      	ldr	r3, [r3, #0]
 8011166:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801116a:	4a23      	ldr	r2, [pc, #140]	; (80111f8 <MCL_ClearFault+0xdc>)
 801116c:	6013      	str	r3, [r2, #0]
        } 
    }
    
     if ((wGlobal_Flags & UNDER_VOLTAGE) == UNDER_VOLTAGE)   
 801116e:	4b22      	ldr	r3, [pc, #136]	; (80111f8 <MCL_ClearFault+0xdc>)
 8011170:	681b      	ldr	r3, [r3, #0]
 8011172:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8011176:	2b00      	cmp	r3, #0
 8011178:	d00a      	beq.n	8011190 <MCL_ClearFault+0x74>
    {            
        if(MCL_Chk_BusVolt()== NO_FAULT)
 801117a:	f000 f89b 	bl	80112b4 <MCL_Chk_BusVolt>
 801117e:	4603      	mov	r3, r0
 8011180:	2b00      	cmp	r3, #0
 8011182:	d105      	bne.n	8011190 <MCL_ClearFault+0x74>
        {
          wGlobal_Flags &= ~UNDER_VOLTAGE;
 8011184:	4b1c      	ldr	r3, [pc, #112]	; (80111f8 <MCL_ClearFault+0xdc>)
 8011186:	681b      	ldr	r3, [r3, #0]
 8011188:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801118c:	4a1a      	ldr	r2, [pc, #104]	; (80111f8 <MCL_ClearFault+0xdc>)
 801118e:	6013      	str	r3, [r2, #0]
        } 
    }
    
    if ((wGlobal_Flags & OVER_CURRENT) == OVER_CURRENT)
 8011190:	4b19      	ldr	r3, [pc, #100]	; (80111f8 <MCL_ClearFault+0xdc>)
 8011192:	681b      	ldr	r3, [r3, #0]
 8011194:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8011198:	2b00      	cmp	r3, #0
 801119a:	d013      	beq.n	80111c4 <MCL_ClearFault+0xa8>
    {
      // high level detected on emergency pin?              
      //It checks for a low level on Break Input before re-enable PWM 
      //peripheral
      if ((HAL_GPIO_ReadPin(FAULT1_GPIO_PORT, FAULT1_PIN))&&(HAL_GPIO_ReadPin(FAULT2_GPIO_PORT, FAULT2_PIN)))
 801119c:	4817      	ldr	r0, [pc, #92]	; (80111fc <MCL_ClearFault+0xe0>)
 801119e:	2110      	movs	r1, #16
 80111a0:	f7f7 f9b6 	bl	8008510 <HAL_GPIO_ReadPin>
 80111a4:	4603      	mov	r3, r0
 80111a6:	2b00      	cmp	r3, #0
 80111a8:	d00c      	beq.n	80111c4 <MCL_ClearFault+0xa8>
 80111aa:	4814      	ldr	r0, [pc, #80]	; (80111fc <MCL_ClearFault+0xe0>)
 80111ac:	2102      	movs	r1, #2
 80111ae:	f7f7 f9af 	bl	8008510 <HAL_GPIO_ReadPin>
 80111b2:	4603      	mov	r3, r0
 80111b4:	2b00      	cmp	r3, #0
 80111b6:	d005      	beq.n	80111c4 <MCL_ClearFault+0xa8>
      {            
        wGlobal_Flags &= ~OVER_CURRENT;
 80111b8:	4b0f      	ldr	r3, [pc, #60]	; (80111f8 <MCL_ClearFault+0xdc>)
 80111ba:	681b      	ldr	r3, [r3, #0]
 80111bc:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80111c0:	4a0d      	ldr	r2, [pc, #52]	; (80111f8 <MCL_ClearFault+0xdc>)
 80111c2:	6013      	str	r3, [r2, #0]
      }
    }
  
    if ((wGlobal_Flags & SPEED_FEEDBACK) == SPEED_FEEDBACK )
 80111c4:	4b0c      	ldr	r3, [pc, #48]	; (80111f8 <MCL_ClearFault+0xdc>)
 80111c6:	681b      	ldr	r3, [r3, #0]
 80111c8:	f003 0304 	and.w	r3, r3, #4
 80111cc:	2b00      	cmp	r3, #0
 80111ce:	d005      	beq.n	80111dc <MCL_ClearFault+0xc0>
    {
        wGlobal_Flags &= ~SPEED_FEEDBACK;
 80111d0:	4b09      	ldr	r3, [pc, #36]	; (80111f8 <MCL_ClearFault+0xdc>)
 80111d2:	681b      	ldr	r3, [r3, #0]
 80111d4:	f023 0304 	bic.w	r3, r3, #4
 80111d8:	4a07      	ldr	r2, [pc, #28]	; (80111f8 <MCL_ClearFault+0xdc>)
 80111da:	6013      	str	r3, [r2, #0]
    } 
  
      
    if ( (wGlobal_Flags & SPEED_FDBK_TIMED_OUT) == SPEED_FDBK_TIMED_OUT)
 80111dc:	4b06      	ldr	r3, [pc, #24]	; (80111f8 <MCL_ClearFault+0xdc>)
 80111de:	681b      	ldr	r3, [r3, #0]
 80111e0:	f003 0308 	and.w	r3, r3, #8
 80111e4:	2b00      	cmp	r3, #0
 80111e6:	d005      	beq.n	80111f4 <MCL_ClearFault+0xd8>
    {
#ifdef TACHO       
        TAC_ClrTimeOut(); 
#endif         
        wGlobal_Flags &= ~SPEED_FDBK_TIMED_OUT;
 80111e8:	4b03      	ldr	r3, [pc, #12]	; (80111f8 <MCL_ClearFault+0xdc>)
 80111ea:	681b      	ldr	r3, [r3, #0]
 80111ec:	f023 0308 	bic.w	r3, r3, #8
 80111f0:	4a01      	ldr	r2, [pc, #4]	; (80111f8 <MCL_ClearFault+0xdc>)
 80111f2:	6013      	str	r3, [r2, #0]
  else 
  {
    return(FALSE);
  }
  #endif
}
 80111f4:	4618      	mov	r0, r3
 80111f6:	bd80      	pop	{r7, pc}
 80111f8:	20010a08 	.word	0x20010a08
 80111fc:	40022000 	.word	0x40022000

08011200 <MCL_Chk_OverTemp>:
* Input          : None
* Output         : Boolean
* Return         : None
*******************************************************************************/
bool MCL_Chk_OverTemp(void)
{
 8011200:	b480      	push	{r7}
 8011202:	b083      	sub	sp, #12
 8011204:	af00      	add	r7, sp, #0
  u32 i;
  static u8 bIndex=0;
  u32 wAux = 0;
 8011206:	2300      	movs	r3, #0
 8011208:	603b      	str	r3, [r7, #0]
  
  hTemp_av_array[bIndex] = Global_User_ADC.Temp.TEMP_value;
 801120a:	4b25      	ldr	r3, [pc, #148]	; (80112a0 <MCL_Chk_OverTemp+0xa0>)
 801120c:	781b      	ldrb	r3, [r3, #0]
 801120e:	461a      	mov	r2, r3
 8011210:	4b24      	ldr	r3, [pc, #144]	; (80112a4 <MCL_Chk_OverTemp+0xa4>)
 8011212:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8011216:	b299      	uxth	r1, r3
 8011218:	4b23      	ldr	r3, [pc, #140]	; (80112a8 <MCL_Chk_OverTemp+0xa8>)
 801121a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  bIndex++;
 801121e:	4b20      	ldr	r3, [pc, #128]	; (80112a0 <MCL_Chk_OverTemp+0xa0>)
 8011220:	781b      	ldrb	r3, [r3, #0]
 8011222:	3301      	adds	r3, #1
 8011224:	b2da      	uxtb	r2, r3
 8011226:	4b1e      	ldr	r3, [pc, #120]	; (80112a0 <MCL_Chk_OverTemp+0xa0>)
 8011228:	701a      	strb	r2, [r3, #0]
  
  if (bIndex == AV_ARRAY_SIZE)
 801122a:	4b1d      	ldr	r3, [pc, #116]	; (80112a0 <MCL_Chk_OverTemp+0xa0>)
 801122c:	781b      	ldrb	r3, [r3, #0]
 801122e:	2b10      	cmp	r3, #16
 8011230:	d102      	bne.n	8011238 <MCL_Chk_OverTemp+0x38>
  {
    bIndex = 0;
 8011232:	4b1b      	ldr	r3, [pc, #108]	; (80112a0 <MCL_Chk_OverTemp+0xa0>)
 8011234:	2200      	movs	r2, #0
 8011236:	701a      	strb	r2, [r3, #0]
  }
        
  for(i= AV_ARRAY_SIZE; i>0; i--)
 8011238:	2310      	movs	r3, #16
 801123a:	607b      	str	r3, [r7, #4]
 801123c:	e00b      	b.n	8011256 <MCL_Chk_OverTemp+0x56>
  {
    wAux += hTemp_av_array[i-1];
 801123e:	687b      	ldr	r3, [r7, #4]
 8011240:	3b01      	subs	r3, #1
 8011242:	4a19      	ldr	r2, [pc, #100]	; (80112a8 <MCL_Chk_OverTemp+0xa8>)
 8011244:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8011248:	461a      	mov	r2, r3
 801124a:	683b      	ldr	r3, [r7, #0]
 801124c:	4413      	add	r3, r2
 801124e:	603b      	str	r3, [r7, #0]
  if (bIndex == AV_ARRAY_SIZE)
  {
    bIndex = 0;
  }
        
  for(i= AV_ARRAY_SIZE; i>0; i--)
 8011250:	687b      	ldr	r3, [r7, #4]
 8011252:	3b01      	subs	r3, #1
 8011254:	607b      	str	r3, [r7, #4]
 8011256:	687b      	ldr	r3, [r7, #4]
 8011258:	2b00      	cmp	r3, #0
 801125a:	d1f0      	bne.n	801123e <MCL_Chk_OverTemp+0x3e>
  {
    wAux += hTemp_av_array[i-1];
  }
  wAux >>= AV_BIT_NUM;    
 801125c:	683b      	ldr	r3, [r7, #0]
 801125e:	091b      	lsrs	r3, r3, #4
 8011260:	603b      	str	r3, [r7, #0]
  
  w_Temp_Average = wAux;
 8011262:	4a12      	ldr	r2, [pc, #72]	; (80112ac <MCL_Chk_OverTemp+0xac>)
 8011264:	683b      	ldr	r3, [r7, #0]
 8011266:	6013      	str	r3, [r2, #0]
  
  if (wAux >= NTC_THRESHOLD)    
 8011268:	683b      	ldr	r3, [r7, #0]
 801126a:	f5b3 5f48 	cmp.w	r3, #12800	; 0x3200
 801126e:	d301      	bcc.n	8011274 <MCL_Chk_OverTemp+0x74>
  {
    return(TRUE);
 8011270:	2301      	movs	r3, #1
 8011272:	e00e      	b.n	8011292 <MCL_Chk_OverTemp+0x92>
  }
  else if (wAux >= (NTC_THRESHOLD - NTC_HYSTERESIS) ) 
 8011274:	683b      	ldr	r3, [r7, #0]
 8011276:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
 801127a:	d309      	bcc.n	8011290 <MCL_Chk_OverTemp+0x90>
    {
    if ((wGlobal_Flags & OVERHEAT) == OVERHEAT)
 801127c:	4b0c      	ldr	r3, [pc, #48]	; (80112b0 <MCL_Chk_OverTemp+0xb0>)
 801127e:	681b      	ldr	r3, [r3, #0]
 8011280:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8011284:	2b00      	cmp	r3, #0
 8011286:	d001      	beq.n	801128c <MCL_Chk_OverTemp+0x8c>
      {
        return(TRUE);        
 8011288:	2301      	movs	r3, #1
 801128a:	e002      	b.n	8011292 <MCL_Chk_OverTemp+0x92>
      }
    else
      {
        return(FALSE);
 801128c:	2300      	movs	r3, #0
 801128e:	e000      	b.n	8011292 <MCL_Chk_OverTemp+0x92>
      }
    }
  else 
    {
      return(FALSE);
 8011290:	2300      	movs	r3, #0
    }
}
 8011292:	4618      	mov	r0, r3
 8011294:	370c      	adds	r7, #12
 8011296:	46bd      	mov	sp, r7
 8011298:	f85d 7b04 	ldr.w	r7, [sp], #4
 801129c:	4770      	bx	lr
 801129e:	bf00      	nop
 80112a0:	20010a5c 	.word	0x20010a5c
 80112a4:	2001235c 	.word	0x2001235c
 80112a8:	20010a3c 	.word	0x20010a3c
 80112ac:	20010a18 	.word	0x20010a18
 80112b0:	20010a08 	.word	0x20010a08

080112b4 <MCL_Chk_BusVolt>:
* Input          : None
* Output         : Boolean
* Return         : None
*******************************************************************************/
BusV_t MCL_Chk_BusVolt(void)
{
 80112b4:	b480      	push	{r7}
 80112b6:	b083      	sub	sp, #12
 80112b8:	af00      	add	r7, sp, #0
  u32 i;
  static u8 bIndex=0;
  u32 wAux = 0;
 80112ba:	2300      	movs	r3, #0
 80112bc:	603b      	str	r3, [r7, #0]
  
  hBusV_av_array[bIndex] = Global_User_ADC.BUS.qV_value;
 80112be:	4b21      	ldr	r3, [pc, #132]	; (8011344 <MCL_Chk_BusVolt+0x90>)
 80112c0:	781b      	ldrb	r3, [r3, #0]
 80112c2:	461a      	mov	r2, r3
 80112c4:	4b20      	ldr	r3, [pc, #128]	; (8011348 <MCL_Chk_BusVolt+0x94>)
 80112c6:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 80112c8:	b299      	uxth	r1, r3
 80112ca:	4b20      	ldr	r3, [pc, #128]	; (801134c <MCL_Chk_BusVolt+0x98>)
 80112cc:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  bIndex++;
 80112d0:	4b1c      	ldr	r3, [pc, #112]	; (8011344 <MCL_Chk_BusVolt+0x90>)
 80112d2:	781b      	ldrb	r3, [r3, #0]
 80112d4:	3301      	adds	r3, #1
 80112d6:	b2da      	uxtb	r2, r3
 80112d8:	4b1a      	ldr	r3, [pc, #104]	; (8011344 <MCL_Chk_BusVolt+0x90>)
 80112da:	701a      	strb	r2, [r3, #0]
  
  if (bIndex == AV_ARRAY_SIZE)
 80112dc:	4b19      	ldr	r3, [pc, #100]	; (8011344 <MCL_Chk_BusVolt+0x90>)
 80112de:	781b      	ldrb	r3, [r3, #0]
 80112e0:	2b10      	cmp	r3, #16
 80112e2:	d102      	bne.n	80112ea <MCL_Chk_BusVolt+0x36>
  {
    bIndex = 0;
 80112e4:	4b17      	ldr	r3, [pc, #92]	; (8011344 <MCL_Chk_BusVolt+0x90>)
 80112e6:	2200      	movs	r2, #0
 80112e8:	701a      	strb	r2, [r3, #0]
  }
    
  for(i= AV_ARRAY_SIZE; i > 0; i--)
 80112ea:	2310      	movs	r3, #16
 80112ec:	607b      	str	r3, [r7, #4]
 80112ee:	e00b      	b.n	8011308 <MCL_Chk_BusVolt+0x54>
  {
    wAux += hBusV_av_array[i-1];
 80112f0:	687b      	ldr	r3, [r7, #4]
 80112f2:	3b01      	subs	r3, #1
 80112f4:	4a15      	ldr	r2, [pc, #84]	; (801134c <MCL_Chk_BusVolt+0x98>)
 80112f6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80112fa:	461a      	mov	r2, r3
 80112fc:	683b      	ldr	r3, [r7, #0]
 80112fe:	4413      	add	r3, r2
 8011300:	603b      	str	r3, [r7, #0]
  if (bIndex == AV_ARRAY_SIZE)
  {
    bIndex = 0;
  }
    
  for(i= AV_ARRAY_SIZE; i > 0; i--)
 8011302:	687b      	ldr	r3, [r7, #4]
 8011304:	3b01      	subs	r3, #1
 8011306:	607b      	str	r3, [r7, #4]
 8011308:	687b      	ldr	r3, [r7, #4]
 801130a:	2b00      	cmp	r3, #0
 801130c:	d1f0      	bne.n	80112f0 <MCL_Chk_BusVolt+0x3c>
  {
    wAux += hBusV_av_array[i-1];
  }
  wAux >>= AV_BIT_NUM;
 801130e:	683b      	ldr	r3, [r7, #0]
 8011310:	091b      	lsrs	r3, r3, #4
 8011312:	603b      	str	r3, [r7, #0]
  
  w_BusV_Average = wAux; 
 8011314:	4a0e      	ldr	r2, [pc, #56]	; (8011350 <MCL_Chk_BusVolt+0x9c>)
 8011316:	683b      	ldr	r3, [r7, #0]
 8011318:	6013      	str	r3, [r2, #0]
    
  if (wAux > OVERVOLTAGE_THRESHOLD)    
 801131a:	683b      	ldr	r3, [r7, #0]
 801131c:	f646 7254 	movw	r2, #28500	; 0x6f54
 8011320:	4293      	cmp	r3, r2
 8011322:	d901      	bls.n	8011328 <MCL_Chk_BusVolt+0x74>
  {
    return((BusV_t)(OVER_VOLT));
 8011324:	2301      	movs	r3, #1
 8011326:	e007      	b.n	8011338 <MCL_Chk_BusVolt+0x84>
  }
  else 
      if (wAux < UNDERVOLTAGE_THRESHOLD)    
 8011328:	683b      	ldr	r3, [r7, #0]
 801132a:	f240 4269 	movw	r2, #1129	; 0x469
 801132e:	4293      	cmp	r3, r2
 8011330:	d801      	bhi.n	8011336 <MCL_Chk_BusVolt+0x82>
      {
        return((BusV_t)(UNDER_VOLT));
 8011332:	2302      	movs	r3, #2
 8011334:	e000      	b.n	8011338 <MCL_Chk_BusVolt+0x84>
      }
      else 
      {
        return(NO_FAULT);
 8011336:	2300      	movs	r3, #0
      }
}
 8011338:	4618      	mov	r0, r3
 801133a:	370c      	adds	r7, #12
 801133c:	46bd      	mov	sp, r7
 801133e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011342:	4770      	bx	lr
 8011344:	20010a5d 	.word	0x20010a5d
 8011348:	2001235c 	.word	0x2001235c
 801134c:	20010a1c 	.word	0x20010a1c
 8011350:	20010a14 	.word	0x20010a14

08011354 <MCL_Reset_PID_IntegralTerms>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void MCL_Reset_PID_IntegralTerms(void)
{
 8011354:	b480      	push	{r7}
 8011356:	af00      	add	r7, sp, #0
  PID_Speed_InitStructure.wIntegral=0;
 8011358:	4b06      	ldr	r3, [pc, #24]	; (8011374 <MCL_Reset_PID_IntegralTerms+0x20>)
 801135a:	2200      	movs	r2, #0
 801135c:	615a      	str	r2, [r3, #20]
  PID_Torque_InitStructure.wIntegral=0;
 801135e:	4b06      	ldr	r3, [pc, #24]	; (8011378 <MCL_Reset_PID_IntegralTerms+0x24>)
 8011360:	2200      	movs	r2, #0
 8011362:	615a      	str	r2, [r3, #20]
  PID_Flux_InitStructure.wIntegral = 0;
 8011364:	4b05      	ldr	r3, [pc, #20]	; (801137c <MCL_Reset_PID_IntegralTerms+0x28>)
 8011366:	2200      	movs	r2, #0
 8011368:	615a      	str	r2, [r3, #20]
}
 801136a:	46bd      	mov	sp, r7
 801136c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011370:	4770      	bx	lr
 8011372:	bf00      	nop
 8011374:	20012508 	.word	0x20012508
 8011378:	200124e8 	.word	0x200124e8
 801137c:	20012544 	.word	0x20012544

08011380 <PID_Init>:
* Output         : None
* Return         : None
*******************************************************************************/
void PID_Init (PID_Struct_t *PID_Torque, PID_Struct_t *PID_Flux, 
                                                        PID_Struct_t *PID_Speed)
{
 8011380:	b480      	push	{r7}
 8011382:	b085      	sub	sp, #20
 8011384:	af00      	add	r7, sp, #0
 8011386:	60f8      	str	r0, [r7, #12]
 8011388:	60b9      	str	r1, [r7, #8]
 801138a:	607a      	str	r2, [r7, #4]
  hTorque_Reference = PID_TORQUE_REFERENCE;
 801138c:	4b4a      	ldr	r3, [pc, #296]	; (80114b8 <PID_Init+0x138>)
 801138e:	227f      	movs	r2, #127	; 0x7f
 8011390:	801a      	strh	r2, [r3, #0]

  PID_Torque->hKp_Gain    = PID_TORQUE_KP_DEFAULT;
 8011392:	68fb      	ldr	r3, [r7, #12]
 8011394:	f642 62e0 	movw	r2, #12000	; 0x2ee0
 8011398:	801a      	strh	r2, [r3, #0]
  PID_Torque->hKp_Divisor = TF_KPDIV;  
 801139a:	68fb      	ldr	r3, [r7, #12]
 801139c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80113a0:	805a      	strh	r2, [r3, #2]

  PID_Torque->hKi_Gain = PID_TORQUE_KI_DEFAULT;
 80113a2:	68fb      	ldr	r3, [r7, #12]
 80113a4:	2296      	movs	r2, #150	; 0x96
 80113a6:	809a      	strh	r2, [r3, #4]
  PID_Torque->hKi_Divisor = TF_KIDIV;
 80113a8:	68fb      	ldr	r3, [r7, #12]
 80113aa:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80113ae:	80da      	strh	r2, [r3, #6]
  
  PID_Torque->hKd_Gain = PID_TORQUE_KD_DEFAULT;
 80113b0:	68fb      	ldr	r3, [r7, #12]
 80113b2:	2200      	movs	r2, #0
 80113b4:	831a      	strh	r2, [r3, #24]
  PID_Torque->hKd_Divisor = TF_KDDIV;
 80113b6:	68fb      	ldr	r3, [r7, #12]
 80113b8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80113bc:	835a      	strh	r2, [r3, #26]
  PID_Torque->wPreviousError = 0;
 80113be:	68fb      	ldr	r3, [r7, #12]
 80113c0:	2200      	movs	r2, #0
 80113c2:	61da      	str	r2, [r3, #28]
  
  PID_Torque->hLower_Limit_Output=S16_MIN;   //Lower Limit for Output limitation
 80113c4:	68fb      	ldr	r3, [r7, #12]
 80113c6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80113ca:	811a      	strh	r2, [r3, #8]
  PID_Torque->hUpper_Limit_Output= S16_MAX;   //Upper Limit for Output limitation
 80113cc:	68fb      	ldr	r3, [r7, #12]
 80113ce:	f647 72ff 	movw	r2, #32767	; 0x7fff
 80113d2:	815a      	strh	r2, [r3, #10]
  PID_Torque->wLower_Limit_Integral = S16_MIN * TF_KIDIV;
 80113d4:	68fb      	ldr	r3, [r7, #12]
 80113d6:	f04f 4278 	mov.w	r2, #4160749568	; 0xf8000000
 80113da:	60da      	str	r2, [r3, #12]
  PID_Torque->wUpper_Limit_Integral = S16_MAX * TF_KIDIV;
 80113dc:	68fb      	ldr	r3, [r7, #12]
 80113de:	4a37      	ldr	r2, [pc, #220]	; (80114bc <PID_Init+0x13c>)
 80113e0:	611a      	str	r2, [r3, #16]
  PID_Torque->wIntegral = 0;
 80113e2:	68fb      	ldr	r3, [r7, #12]
 80113e4:	2200      	movs	r2, #0
 80113e6:	615a      	str	r2, [r3, #20]

  /**************************************************/
  /************PID Flux Regulator members*************/
  /**************************************************/

  PID_Flux->wIntegral = 0;  // reset integral value 
 80113e8:	68bb      	ldr	r3, [r7, #8]
 80113ea:	2200      	movs	r2, #0
 80113ec:	615a      	str	r2, [r3, #20]

  hFlux_Reference = PID_FLUX_REFERENCE;
 80113ee:	4b34      	ldr	r3, [pc, #208]	; (80114c0 <PID_Init+0x140>)
 80113f0:	f242 4206 	movw	r2, #9222	; 0x2406
 80113f4:	801a      	strh	r2, [r3, #0]

  PID_Flux->hKp_Gain    = PID_FLUX_KP_DEFAULT;
 80113f6:	68bb      	ldr	r3, [r7, #8]
 80113f8:	f642 62e0 	movw	r2, #12000	; 0x2ee0
 80113fc:	801a      	strh	r2, [r3, #0]
  PID_Flux->hKp_Divisor = TF_KPDIV;  
 80113fe:	68bb      	ldr	r3, [r7, #8]
 8011400:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8011404:	805a      	strh	r2, [r3, #2]

  PID_Flux->hKi_Gain = PID_FLUX_KI_DEFAULT;
 8011406:	68bb      	ldr	r3, [r7, #8]
 8011408:	2296      	movs	r2, #150	; 0x96
 801140a:	809a      	strh	r2, [r3, #4]
  PID_Flux->hKi_Divisor = TF_KIDIV;
 801140c:	68bb      	ldr	r3, [r7, #8]
 801140e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8011412:	80da      	strh	r2, [r3, #6]
  
  PID_Flux->hKd_Gain = PID_FLUX_KD_DEFAULT;
 8011414:	68bb      	ldr	r3, [r7, #8]
 8011416:	2200      	movs	r2, #0
 8011418:	831a      	strh	r2, [r3, #24]
  PID_Flux->hKd_Divisor = TF_KDDIV;
 801141a:	68bb      	ldr	r3, [r7, #8]
 801141c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8011420:	835a      	strh	r2, [r3, #26]
  PID_Flux->wPreviousError = 0;
 8011422:	68bb      	ldr	r3, [r7, #8]
 8011424:	2200      	movs	r2, #0
 8011426:	61da      	str	r2, [r3, #28]
  
  PID_Flux->hLower_Limit_Output=S16_MIN;   //Lower Limit for Output limitation
 8011428:	68bb      	ldr	r3, [r7, #8]
 801142a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 801142e:	811a      	strh	r2, [r3, #8]
  PID_Flux->hUpper_Limit_Output= S16_MAX;   //Upper Limit for Output limitation
 8011430:	68bb      	ldr	r3, [r7, #8]
 8011432:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8011436:	815a      	strh	r2, [r3, #10]
  PID_Flux->wLower_Limit_Integral = S16_MIN * TF_KIDIV;
 8011438:	68bb      	ldr	r3, [r7, #8]
 801143a:	f04f 4278 	mov.w	r2, #4160749568	; 0xf8000000
 801143e:	60da      	str	r2, [r3, #12]
  PID_Flux->wUpper_Limit_Integral = S16_MAX * TF_KIDIV;
 8011440:	68bb      	ldr	r3, [r7, #8]
 8011442:	4a1e      	ldr	r2, [pc, #120]	; (80114bc <PID_Init+0x13c>)
 8011444:	611a      	str	r2, [r3, #16]
  PID_Flux->wIntegral = 0;
 8011446:	68bb      	ldr	r3, [r7, #8]
 8011448:	2200      	movs	r2, #0
 801144a:	615a      	str	r2, [r3, #20]
  /**************************************************/
  /************PID Speed Regulator members*************/
  /**************************************************/


  PID_Speed->wIntegral = 0;  // reset integral value 
 801144c:	687b      	ldr	r3, [r7, #4]
 801144e:	2200      	movs	r2, #0
 8011450:	615a      	str	r2, [r3, #20]

  hSpeed_Reference = PID_SPEED_REFERENCE;
 8011452:	4b1c      	ldr	r3, [pc, #112]	; (80114c4 <PID_Init+0x144>)
 8011454:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8011458:	801a      	strh	r2, [r3, #0]

  PID_Speed->hKp_Gain    = PID_SPEED_KP_DEFAULT;
 801145a:	687b      	ldr	r3, [r7, #4]
 801145c:	f241 7270 	movw	r2, #6000	; 0x1770
 8011460:	801a      	strh	r2, [r3, #0]
  PID_Speed->hKp_Divisor = SP_KPDIV;  
 8011462:	687b      	ldr	r3, [r7, #4]
 8011464:	2210      	movs	r2, #16
 8011466:	805a      	strh	r2, [r3, #2]

  PID_Speed->hKi_Gain = PID_SPEED_KI_DEFAULT;
 8011468:	687b      	ldr	r3, [r7, #4]
 801146a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 801146e:	809a      	strh	r2, [r3, #4]
  PID_Speed->hKi_Divisor = SP_KIDIV;
 8011470:	687b      	ldr	r3, [r7, #4]
 8011472:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011476:	80da      	strh	r2, [r3, #6]
  
  PID_Speed->hKd_Gain = PID_SPEED_KD_DEFAULT;
 8011478:	687b      	ldr	r3, [r7, #4]
 801147a:	220a      	movs	r2, #10
 801147c:	831a      	strh	r2, [r3, #24]
  PID_Speed->hKd_Divisor = SP_KDDIV;
 801147e:	687b      	ldr	r3, [r7, #4]
 8011480:	2210      	movs	r2, #16
 8011482:	835a      	strh	r2, [r3, #26]
  PID_Speed->wPreviousError = 0;
 8011484:	687b      	ldr	r3, [r7, #4]
 8011486:	2200      	movs	r2, #0
 8011488:	61da      	str	r2, [r3, #28]
  
  PID_Speed->hLower_Limit_Output= -NOMINAL_TORQUE;   //Lower Limit for Output limitation
 801148a:	687b      	ldr	r3, [r7, #4]
 801148c:	f24b 3205 	movw	r2, #45829	; 0xb305
 8011490:	811a      	strh	r2, [r3, #8]
  PID_Speed->hUpper_Limit_Output= NOMINAL_TORQUE;   //Upper Limit for Output limitation
 8011492:	687b      	ldr	r3, [r7, #4]
 8011494:	f644 42fb 	movw	r2, #19707	; 0x4cfb
 8011498:	815a      	strh	r2, [r3, #10]
  PID_Speed->wLower_Limit_Integral = -NOMINAL_TORQUE * SP_KIDIV;
 801149a:	687b      	ldr	r3, [r7, #4]
 801149c:	4a0a      	ldr	r2, [pc, #40]	; (80114c8 <PID_Init+0x148>)
 801149e:	60da      	str	r2, [r3, #12]
  PID_Speed->wUpper_Limit_Integral = NOMINAL_TORQUE * SP_KIDIV;
 80114a0:	687b      	ldr	r3, [r7, #4]
 80114a2:	4a0a      	ldr	r2, [pc, #40]	; (80114cc <PID_Init+0x14c>)
 80114a4:	611a      	str	r2, [r3, #16]
  PID_Speed->wIntegral = 0;
 80114a6:	687b      	ldr	r3, [r7, #4]
 80114a8:	2200      	movs	r2, #0
 80114aa:	615a      	str	r2, [r3, #20]
  /**************************************************/
  /**********END PID Speed Regulator members*********/
  /**************************************************/

}
 80114ac:	3714      	adds	r7, #20
 80114ae:	46bd      	mov	sp, r7
 80114b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80114b4:	4770      	bx	lr
 80114b6:	bf00      	nop
 80114b8:	2001252a 	.word	0x2001252a
 80114bc:	07fff000 	.word	0x07fff000
 80114c0:	200124e0 	.word	0x200124e0
 80114c4:	20012540 	.word	0x20012540
 80114c8:	ffb30500 	.word	0xffb30500
 80114cc:	004cfb00 	.word	0x004cfb00

080114d0 <PID_Regulator>:
                   Speed in s16 format
* Output         : s16
* Return         : None
*******************************************************************************/
s16 PID_Regulator(s16 hReference, s16 hPresentFeedback, PID_Struct_t *PID_Struct)
{
 80114d0:	b480      	push	{r7}
 80114d2:	b08b      	sub	sp, #44	; 0x2c
 80114d4:	af00      	add	r7, sp, #0
 80114d6:	4603      	mov	r3, r0
 80114d8:	603a      	str	r2, [r7, #0]
 80114da:	80fb      	strh	r3, [r7, #6]
 80114dc:	460b      	mov	r3, r1
 80114de:	80bb      	strh	r3, [r7, #4]
  s64 dwAux; 
#ifdef DIFFERENTIAL_TERM_ENABLED    
  s32 wDifferential_Term;
#endif    
  // error computation
  wError= (s32)(hReference - hPresentFeedback);
 80114e0:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 80114e4:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 80114e8:	1ad3      	subs	r3, r2, r3
 80114ea:	627b      	str	r3, [r7, #36]	; 0x24
 
  // Proportional term computation
  wProportional_Term = PID_Struct->hKp_Gain * wError;
 80114ec:	683b      	ldr	r3, [r7, #0]
 80114ee:	881b      	ldrh	r3, [r3, #0]
 80114f0:	b21b      	sxth	r3, r3
 80114f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80114f4:	fb02 f303 	mul.w	r3, r2, r3
 80114f8:	623b      	str	r3, [r7, #32]

  // Integral term computation
  if (PID_Struct->hKi_Gain == 0)
 80114fa:	683b      	ldr	r3, [r7, #0]
 80114fc:	889b      	ldrh	r3, [r3, #4]
 80114fe:	2b00      	cmp	r3, #0
 8011500:	d103      	bne.n	801150a <PID_Regulator+0x3a>
  {
    PID_Struct->wIntegral = 0;
 8011502:	683b      	ldr	r3, [r7, #0]
 8011504:	2200      	movs	r2, #0
 8011506:	615a      	str	r2, [r3, #20]
 8011508:	e037      	b.n	801157a <PID_Regulator+0xaa>
  }
  else
  { 
    wIntegral_Term = PID_Struct->hKi_Gain * wError;
 801150a:	683b      	ldr	r3, [r7, #0]
 801150c:	889b      	ldrh	r3, [r3, #4]
 801150e:	b21b      	sxth	r3, r3
 8011510:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011512:	fb02 f303 	mul.w	r3, r2, r3
 8011516:	61fb      	str	r3, [r7, #28]
    dwAux = PID_Struct->wIntegral + (s64)(wIntegral_Term);
 8011518:	683b      	ldr	r3, [r7, #0]
 801151a:	695b      	ldr	r3, [r3, #20]
 801151c:	4618      	mov	r0, r3
 801151e:	ea4f 71e0 	mov.w	r1, r0, asr #31
 8011522:	69fb      	ldr	r3, [r7, #28]
 8011524:	461a      	mov	r2, r3
 8011526:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801152a:	1812      	adds	r2, r2, r0
 801152c:	eb43 0301 	adc.w	r3, r3, r1
 8011530:	e9c7 2304 	strd	r2, r3, [r7, #16]
    
    if (dwAux > PID_Struct->wUpper_Limit_Integral)
 8011534:	683b      	ldr	r3, [r7, #0]
 8011536:	691b      	ldr	r3, [r3, #16]
 8011538:	4618      	mov	r0, r3
 801153a:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801153e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8011542:	4290      	cmp	r0, r2
 8011544:	eb71 0303 	sbcs.w	r3, r1, r3
 8011548:	da04      	bge.n	8011554 <PID_Regulator+0x84>
    {
      PID_Struct->wIntegral = PID_Struct->wUpper_Limit_Integral;
 801154a:	683b      	ldr	r3, [r7, #0]
 801154c:	691a      	ldr	r2, [r3, #16]
 801154e:	683b      	ldr	r3, [r7, #0]
 8011550:	615a      	str	r2, [r3, #20]
 8011552:	e012      	b.n	801157a <PID_Regulator+0xaa>
    }
    else if (dwAux < PID_Struct->wLower_Limit_Integral)
 8011554:	683b      	ldr	r3, [r7, #0]
 8011556:	68db      	ldr	r3, [r3, #12]
 8011558:	461a      	mov	r2, r3
 801155a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801155e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8011562:	4290      	cmp	r0, r2
 8011564:	eb71 0303 	sbcs.w	r3, r1, r3
 8011568:	da04      	bge.n	8011574 <PID_Regulator+0xa4>
          { 
            PID_Struct->wIntegral = PID_Struct->wLower_Limit_Integral;
 801156a:	683b      	ldr	r3, [r7, #0]
 801156c:	68da      	ldr	r2, [r3, #12]
 801156e:	683b      	ldr	r3, [r7, #0]
 8011570:	615a      	str	r2, [r3, #20]
 8011572:	e002      	b.n	801157a <PID_Regulator+0xaa>
          }
          else
          {
           PID_Struct->wIntegral = (s32)(dwAux);
 8011574:	693a      	ldr	r2, [r7, #16]
 8011576:	683b      	ldr	r3, [r7, #0]
 8011578:	615a      	str	r2, [r3, #20]
  houtput_32 = (wProportional_Term/PID_Struct->hKp_Divisor+ 
                PID_Struct->wIntegral/PID_Struct->hKi_Divisor + 
                wDifferential_Term/PID_Struct->hKd_Divisor); 

#else  
  houtput_32 = (wProportional_Term/PID_Struct->hKp_Divisor+ 
 801157a:	683b      	ldr	r3, [r7, #0]
 801157c:	885b      	ldrh	r3, [r3, #2]
 801157e:	461a      	mov	r2, r3
 8011580:	6a3b      	ldr	r3, [r7, #32]
 8011582:	fb93 f2f2 	sdiv	r2, r3, r2
                PID_Struct->wIntegral/PID_Struct->hKi_Divisor);
 8011586:	683b      	ldr	r3, [r7, #0]
 8011588:	695b      	ldr	r3, [r3, #20]
 801158a:	6839      	ldr	r1, [r7, #0]
 801158c:	88c9      	ldrh	r1, [r1, #6]
 801158e:	fb93 f3f1 	sdiv	r3, r3, r1
  houtput_32 = (wProportional_Term/PID_Struct->hKp_Divisor+ 
                PID_Struct->wIntegral/PID_Struct->hKi_Divisor + 
                wDifferential_Term/PID_Struct->hKd_Divisor); 

#else  
  houtput_32 = (wProportional_Term/PID_Struct->hKp_Divisor+ 
 8011592:	4413      	add	r3, r2
 8011594:	60fb      	str	r3, [r7, #12]
                PID_Struct->wIntegral/PID_Struct->hKi_Divisor);
#endif
  
    if (houtput_32 >= PID_Struct->hUpper_Limit_Output)
 8011596:	683b      	ldr	r3, [r7, #0]
 8011598:	895b      	ldrh	r3, [r3, #10]
 801159a:	b21a      	sxth	r2, r3
 801159c:	68fb      	ldr	r3, [r7, #12]
 801159e:	429a      	cmp	r2, r3
 80115a0:	dc02      	bgt.n	80115a8 <PID_Regulator+0xd8>
      {
      return(PID_Struct->hUpper_Limit_Output);		  			 	
 80115a2:	683b      	ldr	r3, [r7, #0]
 80115a4:	895b      	ldrh	r3, [r3, #10]
 80115a6:	e00a      	b.n	80115be <PID_Regulator+0xee>
      }
    else if (houtput_32 < PID_Struct->hLower_Limit_Output)
 80115a8:	683b      	ldr	r3, [r7, #0]
 80115aa:	891b      	ldrh	r3, [r3, #8]
 80115ac:	b21a      	sxth	r2, r3
 80115ae:	68fb      	ldr	r3, [r7, #12]
 80115b0:	429a      	cmp	r2, r3
 80115b2:	dd02      	ble.n	80115ba <PID_Regulator+0xea>
      {
      return(PID_Struct->hLower_Limit_Output);
 80115b4:	683b      	ldr	r3, [r7, #0]
 80115b6:	891b      	ldrh	r3, [r3, #8]
 80115b8:	e001      	b.n	80115be <PID_Regulator+0xee>
      }
    else 
      {
        return((s16)(houtput_32)); 		
 80115ba:	68fb      	ldr	r3, [r7, #12]
 80115bc:	b29b      	uxth	r3, r3
 80115be:	b21b      	sxth	r3, r3
      }
}		   
 80115c0:	4618      	mov	r0, r3
 80115c2:	372c      	adds	r7, #44	; 0x2c
 80115c4:	46bd      	mov	sp, r7
 80115c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80115ca:	4770      	bx	lr

080115cc <TB_Set_Delay_500us>:
* Input          : Time out value
* Output         : None
* Return         : None
*******************************************************************************/
void TB_Set_Delay_500us(u16 hDelay)
{
 80115cc:	b480      	push	{r7}
 80115ce:	b083      	sub	sp, #12
 80115d0:	af00      	add	r7, sp, #0
 80115d2:	4603      	mov	r3, r0
 80115d4:	80fb      	strh	r3, [r7, #6]
  hTimebase_500us = hDelay;
 80115d6:	4a04      	ldr	r2, [pc, #16]	; (80115e8 <TB_Set_Delay_500us+0x1c>)
 80115d8:	88fb      	ldrh	r3, [r7, #6]
 80115da:	8013      	strh	r3, [r2, #0]
}  
 80115dc:	370c      	adds	r7, #12
 80115de:	46bd      	mov	sp, r7
 80115e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80115e4:	4770      	bx	lr
 80115e6:	bf00      	nop
 80115e8:	20010a60 	.word	0x20010a60

080115ec <TB_Delay_IsElapsed>:
* Input          : None
* Output         : True if delay is elapsed, false otherwise 
* Return         : None
*******************************************************************************/
bool TB_Delay_IsElapsed(void)
{
 80115ec:	b480      	push	{r7}
 80115ee:	af00      	add	r7, sp, #0
 if (hTimebase_500us == 0)
 80115f0:	4b06      	ldr	r3, [pc, #24]	; (801160c <TB_Delay_IsElapsed+0x20>)
 80115f2:	881b      	ldrh	r3, [r3, #0]
 80115f4:	b29b      	uxth	r3, r3
 80115f6:	2b00      	cmp	r3, #0
 80115f8:	d101      	bne.n	80115fe <TB_Delay_IsElapsed+0x12>
 {
   return (TRUE);
 80115fa:	2301      	movs	r3, #1
 80115fc:	e000      	b.n	8011600 <TB_Delay_IsElapsed+0x14>
 }
 else 
 {
   return (FALSE);
 80115fe:	2300      	movs	r3, #0
 }
}  
 8011600:	4618      	mov	r0, r3
 8011602:	46bd      	mov	sp, r7
 8011604:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011608:	4770      	bx	lr
 801160a:	bf00      	nop
 801160c:	20010a60 	.word	0x20010a60

08011610 <TB_Set_StartUp_Timeout>:
* Input          : Time out value
* Output         : None
* Return         : None
*******************************************************************************/
void TB_Set_StartUp_Timeout(u16 hTimeout)
{
 8011610:	b480      	push	{r7}
 8011612:	b083      	sub	sp, #12
 8011614:	af00      	add	r7, sp, #0
 8011616:	4603      	mov	r3, r0
 8011618:	80fb      	strh	r3, [r7, #6]
  hStart_Up_TimeLeft_500us = 2*hTimeout; 
 801161a:	88fb      	ldrh	r3, [r7, #6]
 801161c:	005b      	lsls	r3, r3, #1
 801161e:	b29a      	uxth	r2, r3
 8011620:	4b04      	ldr	r3, [pc, #16]	; (8011634 <TB_Set_StartUp_Timeout+0x24>)
 8011622:	801a      	strh	r2, [r3, #0]
  wOL_Start_up_Torque = 0;
 8011624:	4b04      	ldr	r3, [pc, #16]	; (8011638 <TB_Set_StartUp_Timeout+0x28>)
 8011626:	2200      	movs	r2, #0
 8011628:	601a      	str	r2, [r3, #0]
}  
 801162a:	370c      	adds	r7, #12
 801162c:	46bd      	mov	sp, r7
 801162e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011632:	4770      	bx	lr
 8011634:	20010a5e 	.word	0x20010a5e
 8011638:	20010a68 	.word	0x20010a68

0801163c <TB_StartUp_Timeout_IsElapsed>:
* Input          : None
* Output         : True if start up time out is elapsed, false otherwise 
* Return         : None
*******************************************************************************/
bool TB_StartUp_Timeout_IsElapsed(void)
{
 801163c:	b480      	push	{r7}
 801163e:	af00      	add	r7, sp, #0
 if (hStart_Up_TimeLeft_500us == 0)
 8011640:	4b05      	ldr	r3, [pc, #20]	; (8011658 <TB_StartUp_Timeout_IsElapsed+0x1c>)
 8011642:	881b      	ldrh	r3, [r3, #0]
 8011644:	2b00      	cmp	r3, #0
 8011646:	d101      	bne.n	801164c <TB_StartUp_Timeout_IsElapsed+0x10>
 {
   return (TRUE);
 8011648:	2301      	movs	r3, #1
 801164a:	e000      	b.n	801164e <TB_StartUp_Timeout_IsElapsed+0x12>
 }
 else 
 {
   return (FALSE);
 801164c:	2300      	movs	r3, #0
 }
} 
 801164e:	4618      	mov	r0, r3
 8011650:	46bd      	mov	sp, r7
 8011652:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011656:	4770      	bx	lr
 8011658:	20010a5e 	.word	0x20010a5e

0801165c <MC_SysTickHandler>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
extern void MC_SysTickHandler(void)
{
 801165c:	b580      	push	{r7, lr}
 801165e:	b082      	sub	sp, #8
 8011660:	af00      	add	r7, sp, #0
  
  if (hTimebase_500us != 0)  
 8011662:	4b63      	ldr	r3, [pc, #396]	; (80117f0 <MC_SysTickHandler+0x194>)
 8011664:	881b      	ldrh	r3, [r3, #0]
 8011666:	b29b      	uxth	r3, r3
 8011668:	2b00      	cmp	r3, #0
 801166a:	d006      	beq.n	801167a <MC_SysTickHandler+0x1e>
  {
    hTimebase_500us --;
 801166c:	4b60      	ldr	r3, [pc, #384]	; (80117f0 <MC_SysTickHandler+0x194>)
 801166e:	881b      	ldrh	r3, [r3, #0]
 8011670:	b29b      	uxth	r3, r3
 8011672:	3b01      	subs	r3, #1
 8011674:	b29a      	uxth	r2, r3
 8011676:	4b5e      	ldr	r3, [pc, #376]	; (80117f0 <MC_SysTickHandler+0x194>)
 8011678:	801a      	strh	r2, [r3, #0]
  }
  
  if (hTimebase_display_500us != 0)  
 801167a:	4b5e      	ldr	r3, [pc, #376]	; (80117f4 <MC_SysTickHandler+0x198>)
 801167c:	881b      	ldrh	r3, [r3, #0]
 801167e:	b29b      	uxth	r3, r3
 8011680:	2b00      	cmp	r3, #0
 8011682:	d006      	beq.n	8011692 <MC_SysTickHandler+0x36>
  {
    hTimebase_display_500us --;
 8011684:	4b5b      	ldr	r3, [pc, #364]	; (80117f4 <MC_SysTickHandler+0x198>)
 8011686:	881b      	ldrh	r3, [r3, #0]
 8011688:	b29b      	uxth	r3, r3
 801168a:	3b01      	subs	r3, #1
 801168c:	b29a      	uxth	r2, r3
 801168e:	4b59      	ldr	r3, [pc, #356]	; (80117f4 <MC_SysTickHandler+0x198>)
 8011690:	801a      	strh	r2, [r3, #0]
  }
  
  if (hKey_debounce_500us != 0)  
 8011692:	4b59      	ldr	r3, [pc, #356]	; (80117f8 <MC_SysTickHandler+0x19c>)
 8011694:	881b      	ldrh	r3, [r3, #0]
 8011696:	b29b      	uxth	r3, r3
 8011698:	2b00      	cmp	r3, #0
 801169a:	d006      	beq.n	80116aa <MC_SysTickHandler+0x4e>
  {
    hKey_debounce_500us --;
 801169c:	4b56      	ldr	r3, [pc, #344]	; (80117f8 <MC_SysTickHandler+0x19c>)
 801169e:	881b      	ldrh	r3, [r3, #0]
 80116a0:	b29b      	uxth	r3, r3
 80116a2:	3b01      	subs	r3, #1
 80116a4:	b29a      	uxth	r2, r3
 80116a6:	4b54      	ldr	r3, [pc, #336]	; (80117f8 <MC_SysTickHandler+0x19c>)
 80116a8:	801a      	strh	r2, [r3, #0]
  }

  if (hStart_Up_TimeLeft_500us !=0)
 80116aa:	4b54      	ldr	r3, [pc, #336]	; (80117fc <MC_SysTickHandler+0x1a0>)
 80116ac:	881b      	ldrh	r3, [r3, #0]
 80116ae:	2b00      	cmp	r3, #0
 80116b0:	d068      	beq.n	8011784 <MC_SysTickHandler+0x128>
  { 
    u16 hStart_up_Timebase_500us;
    
    //Start up ramp torque implementation
    hStart_Up_TimeLeft_500us --;
 80116b2:	4b52      	ldr	r3, [pc, #328]	; (80117fc <MC_SysTickHandler+0x1a0>)
 80116b4:	881b      	ldrh	r3, [r3, #0]
 80116b6:	3b01      	subs	r3, #1
 80116b8:	b29a      	uxth	r2, r3
 80116ba:	4b50      	ldr	r3, [pc, #320]	; (80117fc <MC_SysTickHandler+0x1a0>)
 80116bc:	801a      	strh	r2, [r3, #0]
    hStart_up_Timebase_500us = (u16)(STARTUP_TIMEOUT*2 - hStart_Up_TimeLeft_500us);
 80116be:	4b4f      	ldr	r3, [pc, #316]	; (80117fc <MC_SysTickHandler+0x1a0>)
 80116c0:	881a      	ldrh	r2, [r3, #0]
 80116c2:	f241 7370 	movw	r3, #6000	; 0x1770
 80116c6:	1a9b      	subs	r3, r3, r2
 80116c8:	80fb      	strh	r3, [r7, #6]
    
    if (hStart_up_Timebase_500us <= 2*STARTUP_RAMP_DURATION)
 80116ca:	88fb      	ldrh	r3, [r7, #6]
 80116cc:	2bc8      	cmp	r3, #200	; 0xc8
 80116ce:	d83d      	bhi.n	801174c <MC_SysTickHandler+0xf0>
      { // if in speed closed loop
        if ((wGlobal_Flags & CLOSED_LOOP) == CLOSED_LOOP)
 80116d0:	4b4b      	ldr	r3, [pc, #300]	; (8011800 <MC_SysTickHandler+0x1a4>)
 80116d2:	681b      	ldr	r3, [r3, #0]
 80116d4:	f003 0301 	and.w	r3, r3, #1
 80116d8:	2b00      	cmp	r3, #0
 80116da:	d025      	beq.n	8011728 <MC_SysTickHandler+0xcc>
        {
          if (State == START)
 80116dc:	4b49      	ldr	r3, [pc, #292]	; (8011804 <MC_SysTickHandler+0x1a8>)
 80116de:	781b      	ldrb	r3, [r3, #0]
 80116e0:	b2db      	uxtb	r3, r3
 80116e2:	2b02      	cmp	r3, #2
 80116e4:	d14e      	bne.n	8011784 <MC_SysTickHandler+0x128>
          {
            wOL_Start_up_Torque += CL_STARTUP_TORQUE_INCREMENT;           
 80116e6:	4b48      	ldr	r3, [pc, #288]	; (8011808 <MC_SysTickHandler+0x1ac>)
 80116e8:	681b      	ldr	r3, [r3, #0]
 80116ea:	f503 63c5 	add.w	r3, r3, #1576	; 0x628
 80116ee:	4a46      	ldr	r2, [pc, #280]	; (8011808 <MC_SysTickHandler+0x1ac>)
 80116f0:	6013      	str	r3, [r2, #0]
            if(hSpeed_Reference>=0)
 80116f2:	4b46      	ldr	r3, [pc, #280]	; (801180c <MC_SysTickHandler+0x1b0>)
 80116f4:	881b      	ldrh	r3, [r3, #0]
 80116f6:	b29b      	uxth	r3, r3
 80116f8:	b21b      	sxth	r3, r3
 80116fa:	2b00      	cmp	r3, #0
 80116fc:	db09      	blt.n	8011712 <MC_SysTickHandler+0xb6>
            {
              hTorque_Reference = (s16) (wOL_Start_up_Torque/16);
 80116fe:	4b42      	ldr	r3, [pc, #264]	; (8011808 <MC_SysTickHandler+0x1ac>)
 8011700:	681b      	ldr	r3, [r3, #0]
 8011702:	2b00      	cmp	r3, #0
 8011704:	da00      	bge.n	8011708 <MC_SysTickHandler+0xac>
 8011706:	330f      	adds	r3, #15
 8011708:	111b      	asrs	r3, r3, #4
 801170a:	b29a      	uxth	r2, r3
 801170c:	4b40      	ldr	r3, [pc, #256]	; (8011810 <MC_SysTickHandler+0x1b4>)
 801170e:	801a      	strh	r2, [r3, #0]
 8011710:	e038      	b.n	8011784 <MC_SysTickHandler+0x128>
            }
            else
            {
              hTorque_Reference = (s16)(-wOL_Start_up_Torque/16);
 8011712:	4b3d      	ldr	r3, [pc, #244]	; (8011808 <MC_SysTickHandler+0x1ac>)
 8011714:	681b      	ldr	r3, [r3, #0]
 8011716:	425b      	negs	r3, r3
 8011718:	2b00      	cmp	r3, #0
 801171a:	da00      	bge.n	801171e <MC_SysTickHandler+0xc2>
 801171c:	330f      	adds	r3, #15
 801171e:	111b      	asrs	r3, r3, #4
 8011720:	b29a      	uxth	r2, r3
 8011722:	4b3b      	ldr	r3, [pc, #236]	; (8011810 <MC_SysTickHandler+0x1b4>)
 8011724:	801a      	strh	r2, [r3, #0]
 8011726:	e02d      	b.n	8011784 <MC_SysTickHandler+0x128>
            }
          }  
        }
        else //speed open loop
        {
          wOL_Start_up_Torque += hOL_Start_up_Torque_Increment;
 8011728:	4b3a      	ldr	r3, [pc, #232]	; (8011814 <MC_SysTickHandler+0x1b8>)
 801172a:	881b      	ldrh	r3, [r3, #0]
 801172c:	b21a      	sxth	r2, r3
 801172e:	4b36      	ldr	r3, [pc, #216]	; (8011808 <MC_SysTickHandler+0x1ac>)
 8011730:	681b      	ldr	r3, [r3, #0]
 8011732:	4413      	add	r3, r2
 8011734:	4a34      	ldr	r2, [pc, #208]	; (8011808 <MC_SysTickHandler+0x1ac>)
 8011736:	6013      	str	r3, [r2, #0]
          hTorque_Reference = (s16)(wOL_Start_up_Torque/16);
 8011738:	4b33      	ldr	r3, [pc, #204]	; (8011808 <MC_SysTickHandler+0x1ac>)
 801173a:	681b      	ldr	r3, [r3, #0]
 801173c:	2b00      	cmp	r3, #0
 801173e:	da00      	bge.n	8011742 <MC_SysTickHandler+0xe6>
 8011740:	330f      	adds	r3, #15
 8011742:	111b      	asrs	r3, r3, #4
 8011744:	b29a      	uxth	r2, r3
 8011746:	4b32      	ldr	r3, [pc, #200]	; (8011810 <MC_SysTickHandler+0x1b4>)
 8011748:	801a      	strh	r2, [r3, #0]
 801174a:	e01b      	b.n	8011784 <MC_SysTickHandler+0x128>
        }
        
      }
    else // 2*STARTUP_RAMP_DURATION < hStart_up_Timebase_500us < STARTUP_TIMEOUT
    {
      if ((wGlobal_Flags & CLOSED_LOOP) == CLOSED_LOOP)
 801174c:	4b2c      	ldr	r3, [pc, #176]	; (8011800 <MC_SysTickHandler+0x1a4>)
 801174e:	681b      	ldr	r3, [r3, #0]
 8011750:	f003 0301 	and.w	r3, r3, #1
 8011754:	2b00      	cmp	r3, #0
 8011756:	d009      	beq.n	801176c <MC_SysTickHandler+0x110>
      {
        if (State == START)
 8011758:	4b2a      	ldr	r3, [pc, #168]	; (8011804 <MC_SysTickHandler+0x1a8>)
 801175a:	781b      	ldrb	r3, [r3, #0]
 801175c:	b2db      	uxtb	r3, r3
 801175e:	2b02      	cmp	r3, #2
 8011760:	d110      	bne.n	8011784 <MC_SysTickHandler+0x128>
        {
          hTorque_Reference = STARTUP_FINAL_TORQUE;
 8011762:	4b2b      	ldr	r3, [pc, #172]	; (8011810 <MC_SysTickHandler+0x1b4>)
 8011764:	f644 42fb 	movw	r2, #19707	; 0x4cfb
 8011768:	801a      	strh	r2, [r3, #0]
 801176a:	e00b      	b.n	8011784 <MC_SysTickHandler+0x128>
        }  
      }
      else //speed open loop
      { // Torque command must be equal to the value set by the user at the end 
        // of the ramp, then it is adjustable by joystick
       if (hStart_up_Timebase_500us == (2*STARTUP_RAMP_DURATION +1))
 801176c:	88fb      	ldrh	r3, [r7, #6]
 801176e:	2bc9      	cmp	r3, #201	; 0xc9
 8011770:	d108      	bne.n	8011784 <MC_SysTickHandler+0x128>
       {
         hTorque_Reference = (s16)(wOL_Start_up_Torque_Ref/16);
 8011772:	4b29      	ldr	r3, [pc, #164]	; (8011818 <MC_SysTickHandler+0x1bc>)
 8011774:	681b      	ldr	r3, [r3, #0]
 8011776:	2b00      	cmp	r3, #0
 8011778:	da00      	bge.n	801177c <MC_SysTickHandler+0x120>
 801177a:	330f      	adds	r3, #15
 801177c:	111b      	asrs	r3, r3, #4
 801177e:	b29a      	uxth	r2, r3
 8011780:	4b23      	ldr	r3, [pc, #140]	; (8011810 <MC_SysTickHandler+0x1b4>)
 8011782:	801a      	strh	r2, [r3, #0]
      }
    }
  }
  
#ifdef ENCODER
  if (hSpeedMeas_Timebase_500us !=0)
 8011784:	4b25      	ldr	r3, [pc, #148]	; (801181c <MC_SysTickHandler+0x1c0>)
 8011786:	881b      	ldrh	r3, [r3, #0]
 8011788:	2b00      	cmp	r3, #0
 801178a:	d006      	beq.n	801179a <MC_SysTickHandler+0x13e>
  {
    hSpeedMeas_Timebase_500us--;
 801178c:	4b23      	ldr	r3, [pc, #140]	; (801181c <MC_SysTickHandler+0x1c0>)
 801178e:	881b      	ldrh	r3, [r3, #0]
 8011790:	3b01      	subs	r3, #1
 8011792:	b29a      	uxth	r2, r3
 8011794:	4b21      	ldr	r3, [pc, #132]	; (801181c <MC_SysTickHandler+0x1c0>)
 8011796:	801a      	strh	r2, [r3, #0]
 8011798:	e004      	b.n	80117a4 <MC_SysTickHandler+0x148>
  }
  else
  {
    hSpeedMeas_Timebase_500us = SPEED_SAMPLING_TIME;
 801179a:	4b20      	ldr	r3, [pc, #128]	; (801181c <MC_SysTickHandler+0x1c0>)
 801179c:	2203      	movs	r2, #3
 801179e:	801a      	strh	r2, [r3, #0]
    //ENC_Calc_Average_Speed must be called ONLY every SPEED_MEAS_TIMEBASE ms
    ENC_Calc_Average_Speed();   
 80117a0:	f000 f93e 	bl	8011a20 <ENC_Calc_Average_Speed>
  }
#endif


  if (bPID_Speed_Sampling_Time_500us != 0 )  
 80117a4:	4b1e      	ldr	r3, [pc, #120]	; (8011820 <MC_SysTickHandler+0x1c4>)
 80117a6:	781b      	ldrb	r3, [r3, #0]
 80117a8:	b2db      	uxtb	r3, r3
 80117aa:	2b00      	cmp	r3, #0
 80117ac:	d007      	beq.n	80117be <MC_SysTickHandler+0x162>
  {
    bPID_Speed_Sampling_Time_500us --;
 80117ae:	4b1c      	ldr	r3, [pc, #112]	; (8011820 <MC_SysTickHandler+0x1c4>)
 80117b0:	781b      	ldrb	r3, [r3, #0]
 80117b2:	b2db      	uxtb	r3, r3
 80117b4:	3b01      	subs	r3, #1
 80117b6:	b2da      	uxtb	r2, r3
 80117b8:	4b19      	ldr	r3, [pc, #100]	; (8011820 <MC_SysTickHandler+0x1c4>)
 80117ba:	701a      	strb	r2, [r3, #0]
 80117bc:	e015      	b.n	80117ea <MC_SysTickHandler+0x18e>
  }
  else
  {    
#if defined (ENCODER)
    hRot_Freq_Hz = ENC_Get_Mechanical_Speed();
 80117be:	f000 f923 	bl	8011a08 <ENC_Get_Mechanical_Speed>
 80117c2:	4603      	mov	r3, r0
 80117c4:	461a      	mov	r2, r3
 80117c6:	4b17      	ldr	r3, [pc, #92]	; (8011824 <MC_SysTickHandler+0x1c8>)
 80117c8:	801a      	strh	r2, [r3, #0]
#elif defined (TACHO)
    hRot_Freq_Hz = TAC_GetRotorFreqInHz();   //computes hRot_Freq [1.15], i.e the rotor mechanical frequency
#endif
    
    //bPID_Speed_Sampling_Time_500us = PID_SPEED_SAMPLING_TIME;  
    if(State == RUN)
 80117ca:	4b0e      	ldr	r3, [pc, #56]	; (8011804 <MC_SysTickHandler+0x1a8>)
 80117cc:	781b      	ldrb	r3, [r3, #0]
 80117ce:	b2db      	uxtb	r3, r3
 80117d0:	2b03      	cmp	r3, #3
 80117d2:	d10a      	bne.n	80117ea <MC_SysTickHandler+0x18e>
    {
        if ((wGlobal_Flags & CLOSED_LOOP) == CLOSED_LOOP)
 80117d4:	4b0a      	ldr	r3, [pc, #40]	; (8011800 <MC_SysTickHandler+0x1a4>)
 80117d6:	681b      	ldr	r3, [r3, #0]
 80117d8:	f003 0301 	and.w	r3, r3, #1
 80117dc:	2b00      	cmp	r3, #0
 80117de:	d004      	beq.n	80117ea <MC_SysTickHandler+0x18e>
        {
          bPID_Speed_Sampling_Time_500us = PID_SPEED_SAMPLING_TIME;  
 80117e0:	4b0f      	ldr	r3, [pc, #60]	; (8011820 <MC_SysTickHandler+0x1c4>)
 80117e2:	2203      	movs	r2, #3
 80117e4:	701a      	strb	r2, [r3, #0]
          IFOC_CalcFluxTorqueRef();
 80117e6:	f7ff fa47 	bl	8010c78 <IFOC_CalcFluxTorqueRef>
        }
     }
   }
}
 80117ea:	3708      	adds	r7, #8
 80117ec:	46bd      	mov	sp, r7
 80117ee:	bd80      	pop	{r7, pc}
 80117f0:	20010a60 	.word	0x20010a60
 80117f4:	20010a62 	.word	0x20010a62
 80117f8:	20010a64 	.word	0x20010a64
 80117fc:	20010a5e 	.word	0x20010a5e
 8011800:	20010a08 	.word	0x20010a08
 8011804:	20012528 	.word	0x20012528
 8011808:	20010a68 	.word	0x20010a68
 801180c:	20012540 	.word	0x20012540
 8011810:	2001252a 	.word	0x2001252a
 8011814:	2001253c 	.word	0x2001253c
 8011818:	200124d8 	.word	0x200124d8
 801181c:	2001000e 	.word	0x2001000e
 8011820:	2001000c 	.word	0x2001000c
 8011824:	2001253e 	.word	0x2001253e

08011828 <ENC_Init>:
* Output         : None
* Return         : None
*******************************************************************************/

void ENC_Init(void)
{
 8011828:	b580      	push	{r7, lr}
 801182a:	af00      	add	r7, sp, #0
	stm32_hw_QEP_init();
 801182c:	f7fc fef6 	bl	800e61c <stm32_hw_QEP_init>
}
 8011830:	bd80      	pop	{r7, pc}
 8011832:	bf00      	nop

08011834 <ENC_Get_Electrical_Angle>:
*                                          S16_MIN-> -180 degrees
*                  Mechanical angle can be derived calling this function and 
*                  dividing by POLE_PAIR_NUM
*******************************************************************************/
s16 ENC_Get_Electrical_Angle(void)
{
 8011834:	b580      	push	{r7, lr}
 8011836:	b082      	sub	sp, #8
 8011838:	af00      	add	r7, sp, #0
  s32 temp;
  
  temp = (s32)(GetCounterValue(ENCODER_TIMER)) * (s32)(U32_MAX / (4*ENCODER_PPR));         
 801183a:	480b      	ldr	r0, [pc, #44]	; (8011868 <ENC_Get_Electrical_Angle+0x34>)
 801183c:	f7fc fe68 	bl	800e510 <GetCounterValue>
 8011840:	4603      	mov	r3, r0
 8011842:	461a      	mov	r2, r3
 8011844:	4613      	mov	r3, r2
 8011846:	051b      	lsls	r3, r3, #20
 8011848:	1a9b      	subs	r3, r3, r2
 801184a:	607b      	str	r3, [r7, #4]
  temp *= POLE_PAIR_NUM;
  return((s16)(temp/65536)); // s16 result
 801184c:	687b      	ldr	r3, [r7, #4]
 801184e:	2b00      	cmp	r3, #0
 8011850:	da03      	bge.n	801185a <ENC_Get_Electrical_Angle+0x26>
 8011852:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8011856:	441a      	add	r2, r3
 8011858:	4613      	mov	r3, r2
 801185a:	141b      	asrs	r3, r3, #16
 801185c:	b29b      	uxth	r3, r3
 801185e:	b21b      	sxth	r3, r3
}
 8011860:	4618      	mov	r0, r3
 8011862:	3708      	adds	r7, #8
 8011864:	46bd      	mov	sp, r7
 8011866:	bd80      	pop	{r7, pc}
 8011868:	40000c00 	.word	0x40000c00

0801186c <ENC_Clear_Speed_Buffer>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void ENC_Clear_Speed_Buffer(void)
{   
 801186c:	b480      	push	{r7}
 801186e:	b083      	sub	sp, #12
 8011870:	af00      	add	r7, sp, #0
  u32 i;

  for (i=0;i<SPEED_BUFFER_SIZE;i++)
 8011872:	2300      	movs	r3, #0
 8011874:	607b      	str	r3, [r7, #4]
 8011876:	e007      	b.n	8011888 <ENC_Clear_Speed_Buffer+0x1c>
  {
    hSpeed_Buffer[i] = 0;
 8011878:	4a09      	ldr	r2, [pc, #36]	; (80118a0 <ENC_Clear_Speed_Buffer+0x34>)
 801187a:	687b      	ldr	r3, [r7, #4]
 801187c:	2100      	movs	r1, #0
 801187e:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
*******************************************************************************/
void ENC_Clear_Speed_Buffer(void)
{   
  u32 i;

  for (i=0;i<SPEED_BUFFER_SIZE;i++)
 8011882:	687b      	ldr	r3, [r7, #4]
 8011884:	3301      	adds	r3, #1
 8011886:	607b      	str	r3, [r7, #4]
 8011888:	687b      	ldr	r3, [r7, #4]
 801188a:	2b07      	cmp	r3, #7
 801188c:	d9f4      	bls.n	8011878 <ENC_Clear_Speed_Buffer+0xc>
  {
    hSpeed_Buffer[i] = 0;
  }
  bIs_First_Measurement = TRUE;
 801188e:	4b05      	ldr	r3, [pc, #20]	; (80118a4 <ENC_Clear_Speed_Buffer+0x38>)
 8011890:	2201      	movs	r2, #1
 8011892:	701a      	strb	r2, [r3, #0]
}
 8011894:	370c      	adds	r7, #12
 8011896:	46bd      	mov	sp, r7
 8011898:	f85d 7b04 	ldr.w	r7, [sp], #4
 801189c:	4770      	bx	lr
 801189e:	bf00      	nop
 80118a0:	20010a70 	.word	0x20010a70
 80118a4:	20010010 	.word	0x20010010

080118a8 <ENC_Calc_Rot_Speed>:
                   speed of the motor (NOT the electrical frequency)
                   Mechanical frequency is equal to electrical frequency/(number 
                   of pair poles).
*******************************************************************************/
s16 ENC_Calc_Rot_Speed(void)
{   
 80118a8:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 80118ac:	b086      	sub	sp, #24
 80118ae:	af00      	add	r7, sp, #0
  u16 hEnc_Timer_Overflow_sample_one, hEnc_Timer_Overflow_sample_two;
  u16 hCurrent_angle_sample_one, hCurrent_angle_sample_two;
  signed long long temp;
  s16 haux;
  
  if (!bIs_First_Measurement)
 80118b0:	4b51      	ldr	r3, [pc, #324]	; (80119f8 <ENC_Calc_Rot_Speed+0x150>)
 80118b2:	781b      	ldrb	r3, [r3, #0]
 80118b4:	2b00      	cmp	r3, #0
 80118b6:	d177      	bne.n	80119a8 <ENC_Calc_Rot_Speed+0x100>
  {
    // 1st reading of overflow counter 
    hEnc_Timer_Overflow_sample_one = hEncoder_Timer_Overflow; 
 80118b8:	4b50      	ldr	r3, [pc, #320]	; (80119fc <ENC_Calc_Rot_Speed+0x154>)
 80118ba:	881b      	ldrh	r3, [r3, #0]
 80118bc:	827b      	strh	r3, [r7, #18]
    // 1st reading of encoder timer counter
    hCurrent_angle_sample_one = GetCounterValue(ENCODER_TIMER);  
 80118be:	4850      	ldr	r0, [pc, #320]	; (8011a00 <ENC_Calc_Rot_Speed+0x158>)
 80118c0:	f7fc fe26 	bl	800e510 <GetCounterValue>
 80118c4:	4603      	mov	r3, r0
 80118c6:	823b      	strh	r3, [r7, #16]
    // 2nd reading of overflow counter
    hEnc_Timer_Overflow_sample_two = hEncoder_Timer_Overflow;  
 80118c8:	4b4c      	ldr	r3, [pc, #304]	; (80119fc <ENC_Calc_Rot_Speed+0x154>)
 80118ca:	881b      	ldrh	r3, [r3, #0]
 80118cc:	80bb      	strh	r3, [r7, #4]
    // 2nd reading of encoder timer counter
    hCurrent_angle_sample_two = GetCounterValue(ENCODER_TIMER);      
 80118ce:	484c      	ldr	r0, [pc, #304]	; (8011a00 <ENC_Calc_Rot_Speed+0x158>)
 80118d0:	f7fc fe1e 	bl	800e510 <GetCounterValue>
 80118d4:	4603      	mov	r3, r0
 80118d6:	807b      	strh	r3, [r7, #2]

    // Reset hEncoder_Timer_Overflow and read the counter value for the next
    // measurement
    hEncoder_Timer_Overflow = 0;
 80118d8:	4b48      	ldr	r3, [pc, #288]	; (80119fc <ENC_Calc_Rot_Speed+0x154>)
 80118da:	2200      	movs	r2, #0
 80118dc:	801a      	strh	r2, [r3, #0]
    haux = GetCounterValue(ENCODER_TIMER);   
 80118de:	4848      	ldr	r0, [pc, #288]	; (8011a00 <ENC_Calc_Rot_Speed+0x158>)
 80118e0:	f7fc fe16 	bl	800e510 <GetCounterValue>
 80118e4:	4603      	mov	r3, r0
 80118e6:	80fb      	strh	r3, [r7, #6]
    
    if (hEncoder_Timer_Overflow != 0) 
 80118e8:	4b44      	ldr	r3, [pc, #272]	; (80119fc <ENC_Calc_Rot_Speed+0x154>)
 80118ea:	881b      	ldrh	r3, [r3, #0]
 80118ec:	b29b      	uxth	r3, r3
 80118ee:	2b00      	cmp	r3, #0
 80118f0:	d007      	beq.n	8011902 <ENC_Calc_Rot_Speed+0x5a>
    {
      haux = GetCounterValue(ENCODER_TIMER); 
 80118f2:	4843      	ldr	r0, [pc, #268]	; (8011a00 <ENC_Calc_Rot_Speed+0x158>)
 80118f4:	f7fc fe0c 	bl	800e510 <GetCounterValue>
 80118f8:	4603      	mov	r3, r0
 80118fa:	80fb      	strh	r3, [r7, #6]
      hEncoder_Timer_Overflow = 0;            
 80118fc:	4b3f      	ldr	r3, [pc, #252]	; (80119fc <ENC_Calc_Rot_Speed+0x154>)
 80118fe:	2200      	movs	r2, #0
 8011900:	801a      	strh	r2, [r3, #0]
    }
     
    if (hEnc_Timer_Overflow_sample_one != hEnc_Timer_Overflow_sample_two)
 8011902:	8a7a      	ldrh	r2, [r7, #18]
 8011904:	88bb      	ldrh	r3, [r7, #4]
 8011906:	429a      	cmp	r2, r3
 8011908:	d003      	beq.n	8011912 <ENC_Calc_Rot_Speed+0x6a>
    { //Compare sample 1 & 2 and check if an overflow has been generated right 
      //after the reading of encoder timer. If yes, copy sample 2 result in 
      //sample 1 for next process 
      hCurrent_angle_sample_one = hCurrent_angle_sample_two;
 801190a:	887b      	ldrh	r3, [r7, #2]
 801190c:	823b      	strh	r3, [r7, #16]
      hEnc_Timer_Overflow_sample_one = hEnc_Timer_Overflow_sample_two;
 801190e:	88bb      	ldrh	r3, [r7, #4]
 8011910:	827b      	strh	r3, [r7, #18]
    }
    
    if ( !IsCounterUp(ENCODER_TIMER))  
 8011912:	483b      	ldr	r0, [pc, #236]	; (8011a00 <ENC_Calc_Rot_Speed+0x158>)
 8011914:	f7fc fe0a 	bl	800e52c <IsCounterUp>
 8011918:	4603      	mov	r3, r0
 801191a:	2b00      	cmp	r3, #0
 801191c:	d10c      	bne.n	8011938 <ENC_Calc_Rot_Speed+0x90>
    {// encoder timer down-counting
      wDelta_angle = (s32)(hCurrent_angle_sample_one - hPrevious_angle - 
 801191e:	8a3a      	ldrh	r2, [r7, #16]
 8011920:	4b38      	ldr	r3, [pc, #224]	; (8011a04 <ENC_Calc_Rot_Speed+0x15c>)
 8011922:	881b      	ldrh	r3, [r3, #0]
 8011924:	b21b      	sxth	r3, r3
 8011926:	1ad1      	subs	r1, r2, r3
                    (hEnc_Timer_Overflow_sample_one) * (4*ENCODER_PPR));
 8011928:	8a7a      	ldrh	r2, [r7, #18]
 801192a:	4613      	mov	r3, r2
 801192c:	051b      	lsls	r3, r3, #20
 801192e:	1a9b      	subs	r3, r3, r2
 8011930:	031b      	lsls	r3, r3, #12
      hEnc_Timer_Overflow_sample_one = hEnc_Timer_Overflow_sample_two;
    }
    
    if ( !IsCounterUp(ENCODER_TIMER))  
    {// encoder timer down-counting
      wDelta_angle = (s32)(hCurrent_angle_sample_one - hPrevious_angle - 
 8011932:	440b      	add	r3, r1
 8011934:	617b      	str	r3, [r7, #20]
 8011936:	e008      	b.n	801194a <ENC_Calc_Rot_Speed+0xa2>
                    (hEnc_Timer_Overflow_sample_one) * (4*ENCODER_PPR));
    }
    else  
    {//encoder timer up-counting
      wDelta_angle = (s32)(hCurrent_angle_sample_one - hPrevious_angle + 
 8011938:	8a3a      	ldrh	r2, [r7, #16]
 801193a:	4b32      	ldr	r3, [pc, #200]	; (8011a04 <ENC_Calc_Rot_Speed+0x15c>)
 801193c:	881b      	ldrh	r3, [r3, #0]
 801193e:	b21b      	sxth	r3, r3
 8011940:	1ad2      	subs	r2, r2, r3
                    (hEnc_Timer_Overflow_sample_one) * (4*ENCODER_PPR));
 8011942:	8a7b      	ldrh	r3, [r7, #18]
 8011944:	031b      	lsls	r3, r3, #12
      wDelta_angle = (s32)(hCurrent_angle_sample_one - hPrevious_angle - 
                    (hEnc_Timer_Overflow_sample_one) * (4*ENCODER_PPR));
    }
    else  
    {//encoder timer up-counting
      wDelta_angle = (s32)(hCurrent_angle_sample_one - hPrevious_angle + 
 8011946:	4413      	add	r3, r2
 8011948:	617b      	str	r3, [r7, #20]
                    (hEnc_Timer_Overflow_sample_one) * (4*ENCODER_PPR));
    }
    
    // speed computation as delta angle * 1/(speed sempling time)
    temp = (signed long long)(wDelta_angle * SPEED_SAMPLING_FREQ);                                                                
 801194a:	697b      	ldr	r3, [r7, #20]
 801194c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8011950:	fb02 f303 	mul.w	r3, r2, r3
 8011954:	461a      	mov	r2, r3
 8011956:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801195a:	e9c7 2302 	strd	r2, r3, [r7, #8]
    temp *= 10;  // 0.1 Hz resolution
 801195e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8011962:	1892      	adds	r2, r2, r2
 8011964:	eb43 0303 	adc.w	r3, r3, r3
 8011968:	ea4f 0983 	mov.w	r9, r3, lsl #2
 801196c:	ea49 7992 	orr.w	r9, r9, r2, lsr #30
 8011970:	ea4f 0882 	mov.w	r8, r2, lsl #2
 8011974:	eb12 0208 	adds.w	r2, r2, r8
 8011978:	eb43 0309 	adc.w	r3, r3, r9
 801197c:	e9c7 2302 	strd	r2, r3, [r7, #8]
    temp /= (4*ENCODER_PPR);
 8011980:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8011984:	2a00      	cmp	r2, #0
 8011986:	f173 0100 	sbcs.w	r1, r3, #0
 801198a:	da06      	bge.n	801199a <ENC_Calc_Rot_Speed+0xf2>
 801198c:	f640 70ff 	movw	r0, #4095	; 0xfff
 8011990:	f04f 0100 	mov.w	r1, #0
 8011994:	1812      	adds	r2, r2, r0
 8011996:	eb43 0301 	adc.w	r3, r3, r1
 801199a:	0b14      	lsrs	r4, r2, #12
 801199c:	ea44 5403 	orr.w	r4, r4, r3, lsl #20
 80119a0:	131d      	asrs	r5, r3, #12
 80119a2:	e9c7 4502 	strd	r4, r5, [r7, #8]
 80119a6:	e01d      	b.n	80119e4 <ENC_Calc_Rot_Speed+0x13c>
        
  } //is first measurement, discard it
  else
  {
    bIs_First_Measurement = FALSE;
 80119a8:	4b13      	ldr	r3, [pc, #76]	; (80119f8 <ENC_Calc_Rot_Speed+0x150>)
 80119aa:	2200      	movs	r2, #0
 80119ac:	701a      	strb	r2, [r3, #0]
    temp = 0;
 80119ae:	f04f 0200 	mov.w	r2, #0
 80119b2:	f04f 0300 	mov.w	r3, #0
 80119b6:	e9c7 2302 	strd	r2, r3, [r7, #8]
    hEncoder_Timer_Overflow = 0;
 80119ba:	4b10      	ldr	r3, [pc, #64]	; (80119fc <ENC_Calc_Rot_Speed+0x154>)
 80119bc:	2200      	movs	r2, #0
 80119be:	801a      	strh	r2, [r3, #0]
    haux = GetCounterValue(ENCODER_TIMER);       
 80119c0:	480f      	ldr	r0, [pc, #60]	; (8011a00 <ENC_Calc_Rot_Speed+0x158>)
 80119c2:	f7fc fda5 	bl	800e510 <GetCounterValue>
 80119c6:	4603      	mov	r3, r0
 80119c8:	80fb      	strh	r3, [r7, #6]
    // Check if Encoder_Timer_Overflow is still zero. In case an overflow IT 
    // occured it resets overflow counter and wPWM_Counter_Angular_Velocity
    if (hEncoder_Timer_Overflow != 0) 
 80119ca:	4b0c      	ldr	r3, [pc, #48]	; (80119fc <ENC_Calc_Rot_Speed+0x154>)
 80119cc:	881b      	ldrh	r3, [r3, #0]
 80119ce:	b29b      	uxth	r3, r3
 80119d0:	2b00      	cmp	r3, #0
 80119d2:	d007      	beq.n	80119e4 <ENC_Calc_Rot_Speed+0x13c>
    {
      haux = GetCounterValue(ENCODER_TIMER); 
 80119d4:	480a      	ldr	r0, [pc, #40]	; (8011a00 <ENC_Calc_Rot_Speed+0x158>)
 80119d6:	f7fc fd9b 	bl	800e510 <GetCounterValue>
 80119da:	4603      	mov	r3, r0
 80119dc:	80fb      	strh	r3, [r7, #6]
      hEncoder_Timer_Overflow = 0;            
 80119de:	4b07      	ldr	r3, [pc, #28]	; (80119fc <ENC_Calc_Rot_Speed+0x154>)
 80119e0:	2200      	movs	r2, #0
 80119e2:	801a      	strh	r2, [r3, #0]
    }
  }
  
  hPrevious_angle = haux;  
 80119e4:	4a07      	ldr	r2, [pc, #28]	; (8011a04 <ENC_Calc_Rot_Speed+0x15c>)
 80119e6:	88fb      	ldrh	r3, [r7, #6]
 80119e8:	8013      	strh	r3, [r2, #0]
 
  return((s16) temp);
 80119ea:	893b      	ldrh	r3, [r7, #8]
 80119ec:	b21b      	sxth	r3, r3
}
 80119ee:	4618      	mov	r0, r3
 80119f0:	3718      	adds	r7, #24
 80119f2:	46bd      	mov	sp, r7
 80119f4:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 80119f8:	20010010 	.word	0x20010010
 80119fc:	20010a84 	.word	0x20010a84
 8011a00:	40000c00 	.word	0x40000c00
 8011a04:	20010a6c 	.word	0x20010a6c

08011a08 <ENC_Get_Mechanical_Speed>:
* Output         : s16
* Return         : Return motor speed in 0.1 Hz resolution. This routine 
                   will return the average mechanical speed of the motor.
*******************************************************************************/
s16 ENC_Get_Mechanical_Speed(void)
{
 8011a08:	b480      	push	{r7}
 8011a0a:	af00      	add	r7, sp, #0
  return(hRot_Speed);
 8011a0c:	4b03      	ldr	r3, [pc, #12]	; (8011a1c <ENC_Get_Mechanical_Speed+0x14>)
 8011a0e:	881b      	ldrh	r3, [r3, #0]
 8011a10:	b21b      	sxth	r3, r3
}
 8011a12:	4618      	mov	r0, r3
 8011a14:	46bd      	mov	sp, r7
 8011a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a1a:	4770      	bx	lr
 8011a1c:	20010a80 	.word	0x20010a80

08011a20 <ENC_Calc_Average_Speed>:
* Output         : s16
* Return         : Return rotor speed in 0.1 Hz resolution. This routine 
                   will return the average mechanical speed of the motor.
*******************************************************************************/
void ENC_Calc_Average_Speed(void)
{   
 8011a20:	b580      	push	{r7, lr}
 8011a22:	b084      	sub	sp, #16
 8011a24:	af00      	add	r7, sp, #0
  s32 wtemp;
  u16 hAbstemp;
  u32 i;
  u8  static bError_counter;
  
  wtemp = ENC_Calc_Rot_Speed();
 8011a26:	f7ff ff3f 	bl	80118a8 <ENC_Calc_Rot_Speed>
 8011a2a:	4603      	mov	r3, r0
 8011a2c:	60fb      	str	r3, [r7, #12]
  hAbstemp = ( wtemp < 0 ? - wtemp :  wtemp);
 8011a2e:	68fb      	ldr	r3, [r7, #12]
 8011a30:	2b00      	cmp	r3, #0
 8011a32:	bfb8      	it	lt
 8011a34:	425b      	neglt	r3, r3
 8011a36:	80fb      	strh	r3, [r7, #6]

/* Checks for speed measurement errors when in RUN State and saturates if 
                                                                    necessary*/  
  if (State == RUN)
 8011a38:	4b3b      	ldr	r3, [pc, #236]	; (8011b28 <ENC_Calc_Average_Speed+0x108>)
 8011a3a:	781b      	ldrb	r3, [r3, #0]
 8011a3c:	b2db      	uxtb	r3, r3
 8011a3e:	2b03      	cmp	r3, #3
 8011a40:	d136      	bne.n	8011ab0 <ENC_Calc_Average_Speed+0x90>
  {    
    if(hAbstemp < MINIMUM_MECHANICAL_SPEED)
 8011a42:	88fb      	ldrh	r3, [r7, #6]
 8011a44:	2b00      	cmp	r3, #0
 8011a46:	d10f      	bne.n	8011a68 <ENC_Calc_Average_Speed+0x48>
    { 
      if (wtemp < 0)
 8011a48:	68fb      	ldr	r3, [r7, #12]
 8011a4a:	2b00      	cmp	r3, #0
 8011a4c:	da03      	bge.n	8011a56 <ENC_Calc_Average_Speed+0x36>
      {
        wtemp = -MINIMUM_MECHANICAL_SPEED;
 8011a4e:	f04f 33ff 	mov.w	r3, #4294967295
 8011a52:	60fb      	str	r3, [r7, #12]
 8011a54:	e001      	b.n	8011a5a <ENC_Calc_Average_Speed+0x3a>
      }
      else
      {
        wtemp = MINIMUM_MECHANICAL_SPEED;
 8011a56:	2301      	movs	r3, #1
 8011a58:	60fb      	str	r3, [r7, #12]
      }
      bError_counter++;
 8011a5a:	4b34      	ldr	r3, [pc, #208]	; (8011b2c <ENC_Calc_Average_Speed+0x10c>)
 8011a5c:	781b      	ldrb	r3, [r3, #0]
 8011a5e:	3301      	adds	r3, #1
 8011a60:	b2da      	uxtb	r2, r3
 8011a62:	4b32      	ldr	r3, [pc, #200]	; (8011b2c <ENC_Calc_Average_Speed+0x10c>)
 8011a64:	701a      	strb	r2, [r3, #0]
 8011a66:	e017      	b.n	8011a98 <ENC_Calc_Average_Speed+0x78>
    }
    else  if (hAbstemp > MAXIMUM_MECHANICAL_SPEED) 
 8011a68:	88fb      	ldrh	r3, [r7, #6]
 8011a6a:	f241 7270 	movw	r2, #6000	; 0x1770
 8011a6e:	4293      	cmp	r3, r2
 8011a70:	d90f      	bls.n	8011a92 <ENC_Calc_Average_Speed+0x72>
          {
            if (wtemp < 0)
 8011a72:	68fb      	ldr	r3, [r7, #12]
 8011a74:	2b00      	cmp	r3, #0
 8011a76:	da02      	bge.n	8011a7e <ENC_Calc_Average_Speed+0x5e>
            {
              wtemp = -MAXIMUM_MECHANICAL_SPEED;
 8011a78:	4b2d      	ldr	r3, [pc, #180]	; (8011b30 <ENC_Calc_Average_Speed+0x110>)
 8011a7a:	60fb      	str	r3, [r7, #12]
 8011a7c:	e002      	b.n	8011a84 <ENC_Calc_Average_Speed+0x64>
            }
            else
            {
              wtemp = MAXIMUM_MECHANICAL_SPEED;
 8011a7e:	f241 7370 	movw	r3, #6000	; 0x1770
 8011a82:	60fb      	str	r3, [r7, #12]
            }
            bError_counter++;
 8011a84:	4b29      	ldr	r3, [pc, #164]	; (8011b2c <ENC_Calc_Average_Speed+0x10c>)
 8011a86:	781b      	ldrb	r3, [r3, #0]
 8011a88:	3301      	adds	r3, #1
 8011a8a:	b2da      	uxtb	r2, r3
 8011a8c:	4b27      	ldr	r3, [pc, #156]	; (8011b2c <ENC_Calc_Average_Speed+0x10c>)
 8011a8e:	701a      	strb	r2, [r3, #0]
 8011a90:	e002      	b.n	8011a98 <ENC_Calc_Average_Speed+0x78>
          }
          else
          { 
            bError_counter = 0;
 8011a92:	4b26      	ldr	r3, [pc, #152]	; (8011b2c <ENC_Calc_Average_Speed+0x10c>)
 8011a94:	2200      	movs	r2, #0
 8011a96:	701a      	strb	r2, [r3, #0]
          }
  
    if (bError_counter >= MAXIMUM_ERROR_NUMBER)
 8011a98:	4b24      	ldr	r3, [pc, #144]	; (8011b2c <ENC_Calc_Average_Speed+0x10c>)
 8011a9a:	781b      	ldrb	r3, [r3, #0]
 8011a9c:	2b18      	cmp	r3, #24
 8011a9e:	d903      	bls.n	8011aa8 <ENC_Calc_Average_Speed+0x88>
    {
     bError_Speed_Measurement = TRUE;
 8011aa0:	4b24      	ldr	r3, [pc, #144]	; (8011b34 <ENC_Calc_Average_Speed+0x114>)
 8011aa2:	2201      	movs	r2, #1
 8011aa4:	701a      	strb	r2, [r3, #0]
 8011aa6:	e009      	b.n	8011abc <ENC_Calc_Average_Speed+0x9c>
    }
    else
    {
     bError_Speed_Measurement = FALSE;
 8011aa8:	4b22      	ldr	r3, [pc, #136]	; (8011b34 <ENC_Calc_Average_Speed+0x114>)
 8011aaa:	2200      	movs	r2, #0
 8011aac:	701a      	strb	r2, [r3, #0]
 8011aae:	e005      	b.n	8011abc <ENC_Calc_Average_Speed+0x9c>
    }
  }
  else
  {
    bError_Speed_Measurement = FALSE;
 8011ab0:	4b20      	ldr	r3, [pc, #128]	; (8011b34 <ENC_Calc_Average_Speed+0x114>)
 8011ab2:	2200      	movs	r2, #0
 8011ab4:	701a      	strb	r2, [r3, #0]
    bError_counter = 0;
 8011ab6:	4b1d      	ldr	r3, [pc, #116]	; (8011b2c <ENC_Calc_Average_Speed+0x10c>)
 8011ab8:	2200      	movs	r2, #0
 8011aba:	701a      	strb	r2, [r3, #0]
  }
  
/* Compute the average of the read speeds */
  
  hSpeed_Buffer[bSpeed_Buffer_Index] = (s16)wtemp;
 8011abc:	4b1e      	ldr	r3, [pc, #120]	; (8011b38 <ENC_Calc_Average_Speed+0x118>)
 8011abe:	781b      	ldrb	r3, [r3, #0]
 8011ac0:	461a      	mov	r2, r3
 8011ac2:	68fb      	ldr	r3, [r7, #12]
 8011ac4:	b299      	uxth	r1, r3
 8011ac6:	4b1d      	ldr	r3, [pc, #116]	; (8011b3c <ENC_Calc_Average_Speed+0x11c>)
 8011ac8:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  bSpeed_Buffer_Index++;
 8011acc:	4b1a      	ldr	r3, [pc, #104]	; (8011b38 <ENC_Calc_Average_Speed+0x118>)
 8011ace:	781b      	ldrb	r3, [r3, #0]
 8011ad0:	3301      	adds	r3, #1
 8011ad2:	b2da      	uxtb	r2, r3
 8011ad4:	4b18      	ldr	r3, [pc, #96]	; (8011b38 <ENC_Calc_Average_Speed+0x118>)
 8011ad6:	701a      	strb	r2, [r3, #0]
  
  if (bSpeed_Buffer_Index == SPEED_BUFFER_SIZE) 
 8011ad8:	4b17      	ldr	r3, [pc, #92]	; (8011b38 <ENC_Calc_Average_Speed+0x118>)
 8011ada:	781b      	ldrb	r3, [r3, #0]
 8011adc:	2b08      	cmp	r3, #8
 8011ade:	d102      	bne.n	8011ae6 <ENC_Calc_Average_Speed+0xc6>
  {
    bSpeed_Buffer_Index = 0;
 8011ae0:	4b15      	ldr	r3, [pc, #84]	; (8011b38 <ENC_Calc_Average_Speed+0x118>)
 8011ae2:	2200      	movs	r2, #0
 8011ae4:	701a      	strb	r2, [r3, #0]
  }

  wtemp=0;
 8011ae6:	2300      	movs	r3, #0
 8011ae8:	60fb      	str	r3, [r7, #12]

  for (i=0;i<SPEED_BUFFER_SIZE;i++)
 8011aea:	2300      	movs	r3, #0
 8011aec:	60bb      	str	r3, [r7, #8]
 8011aee:	e00a      	b.n	8011b06 <ENC_Calc_Average_Speed+0xe6>
    {
    wtemp += hSpeed_Buffer[i];
 8011af0:	4a12      	ldr	r2, [pc, #72]	; (8011b3c <ENC_Calc_Average_Speed+0x11c>)
 8011af2:	68bb      	ldr	r3, [r7, #8]
 8011af4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8011af8:	b21b      	sxth	r3, r3
 8011afa:	68fa      	ldr	r2, [r7, #12]
 8011afc:	4413      	add	r3, r2
 8011afe:	60fb      	str	r3, [r7, #12]
    bSpeed_Buffer_Index = 0;
  }

  wtemp=0;

  for (i=0;i<SPEED_BUFFER_SIZE;i++)
 8011b00:	68bb      	ldr	r3, [r7, #8]
 8011b02:	3301      	adds	r3, #1
 8011b04:	60bb      	str	r3, [r7, #8]
 8011b06:	68bb      	ldr	r3, [r7, #8]
 8011b08:	2b07      	cmp	r3, #7
 8011b0a:	d9f1      	bls.n	8011af0 <ENC_Calc_Average_Speed+0xd0>
    {
    wtemp += hSpeed_Buffer[i];
    }
  wtemp /= SPEED_BUFFER_SIZE;
 8011b0c:	68fb      	ldr	r3, [r7, #12]
 8011b0e:	2b00      	cmp	r3, #0
 8011b10:	da00      	bge.n	8011b14 <ENC_Calc_Average_Speed+0xf4>
 8011b12:	3307      	adds	r3, #7
 8011b14:	10db      	asrs	r3, r3, #3
 8011b16:	60fb      	str	r3, [r7, #12]
  
  hRot_Speed = ((s16)(wtemp));
 8011b18:	68fb      	ldr	r3, [r7, #12]
 8011b1a:	b29a      	uxth	r2, r3
 8011b1c:	4b08      	ldr	r3, [pc, #32]	; (8011b40 <ENC_Calc_Average_Speed+0x120>)
 8011b1e:	801a      	strh	r2, [r3, #0]
}
 8011b20:	3710      	adds	r7, #16
 8011b22:	46bd      	mov	sp, r7
 8011b24:	bd80      	pop	{r7, pc}
 8011b26:	bf00      	nop
 8011b28:	20012528 	.word	0x20012528
 8011b2c:	20010a87 	.word	0x20010a87
 8011b30:	ffffe890 	.word	0xffffe890
 8011b34:	20010a86 	.word	0x20010a86
 8011b38:	20010a82 	.word	0x20010a82
 8011b3c:	20010a70 	.word	0x20010a70
 8011b40:	20010a80 	.word	0x20010a80

08011b44 <ENC_ErrorOnFeedback>:
* Input          : None
* Output         : s16
* Return         : boolean variable
*******************************************************************************/
bool ENC_ErrorOnFeedback(void)
{
 8011b44:	b480      	push	{r7}
 8011b46:	af00      	add	r7, sp, #0
 return(bError_Speed_Measurement); 
 8011b48:	4b03      	ldr	r3, [pc, #12]	; (8011b58 <ENC_ErrorOnFeedback+0x14>)
 8011b4a:	781b      	ldrb	r3, [r3, #0]
}
 8011b4c:	4618      	mov	r0, r3
 8011b4e:	46bd      	mov	sp, r7
 8011b50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b54:	4770      	bx	lr
 8011b56:	bf00      	nop
 8011b58:	20010a86 	.word	0x20010a86

08011b5c <SVPWM_IcsInit>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void SVPWM_IcsInit(void)
{ 
 8011b5c:	b580      	push	{r7, lr}
 8011b5e:	af00      	add	r7, sp, #0
	
 	stm32_hw_tim8_init();
 8011b60:	f7fd f990 	bl	800ee84 <stm32_hw_tim8_init>
	stm32_hw_ADC_init();
 8011b64:	f7fc fc1e 	bl	800e3a4 <stm32_hw_ADC_init>
  	SVPWM_IcsCurrentReadingCalibration();
 8011b68:	f000 f802 	bl	8011b70 <SVPWM_IcsCurrentReadingCalibration>
} 
 8011b6c:	bd80      	pop	{r7, pc}
 8011b6e:	bf00      	nop

08011b70 <SVPWM_IcsCurrentReadingCalibration>:
* Output         : None
* Return         : None
*******************************************************************************/

void SVPWM_IcsCurrentReadingCalibration(void)
{
 8011b70:	b480      	push	{r7}
 8011b72:	af00      	add	r7, sp, #0
 	//ADC_CalibrationAll();
   
 
}
 8011b74:	46bd      	mov	sp, r7
 8011b76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b7a:	4770      	bx	lr

08011b7c <SVPWM_IcsGetPhaseCurrentValues>:
* Input          : None
* Output         : Stat_Curr_a_b
* Return         : None
*******************************************************************************/
Curr_Components SVPWM_IcsGetPhaseCurrentValues(void)
{
 8011b7c:	b480      	push	{r7}
 8011b7e:	b085      	sub	sp, #20
 8011b80:	af00      	add	r7, sp, #0
  Curr_Components Local_Stator_Currents;
  s32 wAux;

      
 // Ia = (hPhaseAOffset)-(PHASE_A_ADC_CHANNEL vale)  
  wAux = Global_User_ADC.PhaseA.qI_value;          
 8011b82:	4b1e      	ldr	r3, [pc, #120]	; (8011bfc <SVPWM_IcsGetPhaseCurrentValues+0x80>)
 8011b84:	885b      	ldrh	r3, [r3, #2]
 8011b86:	b21b      	sxth	r3, r3
 8011b88:	60fb      	str	r3, [r7, #12]
 //Saturation of Ia 
  if (wAux < S16_MIN)
 8011b8a:	68fb      	ldr	r3, [r7, #12]
 8011b8c:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8011b90:	da03      	bge.n	8011b9a <SVPWM_IcsGetPhaseCurrentValues+0x1e>
  {
    Local_Stator_Currents.qI_Component1= S16_MIN;
 8011b92:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8011b96:	80bb      	strh	r3, [r7, #4]
 8011b98:	e00a      	b.n	8011bb0 <SVPWM_IcsGetPhaseCurrentValues+0x34>
  }  
  else  if (wAux > S16_MAX)
 8011b9a:	68fb      	ldr	r3, [r7, #12]
 8011b9c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8011ba0:	db03      	blt.n	8011baa <SVPWM_IcsGetPhaseCurrentValues+0x2e>
        { 
          Local_Stator_Currents.qI_Component1= S16_MAX;
 8011ba2:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8011ba6:	80bb      	strh	r3, [r7, #4]
 8011ba8:	e002      	b.n	8011bb0 <SVPWM_IcsGetPhaseCurrentValues+0x34>
        }
        else
        {
          Local_Stator_Currents.qI_Component1= wAux;
 8011baa:	68fb      	ldr	r3, [r7, #12]
 8011bac:	b29b      	uxth	r3, r3
 8011bae:	80bb      	strh	r3, [r7, #4]
        }
                     
 // Ib = (hPhaseBOffset)-(PHASE_B_ADC_CHANNEL value)
  wAux = Global_User_ADC.PhaseB.qI_value;
 8011bb0:	4b12      	ldr	r3, [pc, #72]	; (8011bfc <SVPWM_IcsGetPhaseCurrentValues+0x80>)
 8011bb2:	8a1b      	ldrh	r3, [r3, #16]
 8011bb4:	b21b      	sxth	r3, r3
 8011bb6:	60fb      	str	r3, [r7, #12]
 // Saturation of Ib
  if (wAux < S16_MIN)
 8011bb8:	68fb      	ldr	r3, [r7, #12]
 8011bba:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8011bbe:	da03      	bge.n	8011bc8 <SVPWM_IcsGetPhaseCurrentValues+0x4c>
  {
    Local_Stator_Currents.qI_Component2= S16_MIN;
 8011bc0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8011bc4:	80fb      	strh	r3, [r7, #6]
 8011bc6:	e00a      	b.n	8011bde <SVPWM_IcsGetPhaseCurrentValues+0x62>
  }  
  else  if (wAux > S16_MAX)
 8011bc8:	68fb      	ldr	r3, [r7, #12]
 8011bca:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8011bce:	db03      	blt.n	8011bd8 <SVPWM_IcsGetPhaseCurrentValues+0x5c>
        { 
          Local_Stator_Currents.qI_Component2= S16_MAX;
 8011bd0:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8011bd4:	80fb      	strh	r3, [r7, #6]
 8011bd6:	e002      	b.n	8011bde <SVPWM_IcsGetPhaseCurrentValues+0x62>
        }
        else
        {
          Local_Stator_Currents.qI_Component2= wAux;
 8011bd8:	68fb      	ldr	r3, [r7, #12]
 8011bda:	b29b      	uxth	r3, r3
 8011bdc:	80fb      	strh	r3, [r7, #6]
        }
  
  return(Local_Stator_Currents); 
 8011bde:	687b      	ldr	r3, [r7, #4]
 8011be0:	60bb      	str	r3, [r7, #8]
 8011be2:	2300      	movs	r3, #0
 8011be4:	893a      	ldrh	r2, [r7, #8]
 8011be6:	f362 030f 	bfi	r3, r2, #0, #16
 8011bea:	897a      	ldrh	r2, [r7, #10]
 8011bec:	f362 431f 	bfi	r3, r2, #16, #16
}
 8011bf0:	4618      	mov	r0, r3
 8011bf2:	3714      	adds	r7, #20
 8011bf4:	46bd      	mov	sp, r7
 8011bf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011bfa:	4770      	bx	lr
 8011bfc:	2001235c 	.word	0x2001235c

08011c00 <SVPWM_IcsCalcDutyCycles>:
* Output         : None
* Return         : None
*******************************************************************************/

void SVPWM_IcsCalcDutyCycles (Volt_Components Stat_Volt_Input)
{
 8011c00:	b580      	push	{r7, lr}
 8011c02:	b08a      	sub	sp, #40	; 0x28
 8011c04:	af00      	add	r7, sp, #0
 8011c06:	6078      	str	r0, [r7, #4]
   u8 bSector;
   s32 wX, wY, wZ, wUAlpha, wUBeta;
   u16  hTimePhA=0, hTimePhB=0, hTimePhC=0;
 8011c08:	2300      	movs	r3, #0
 8011c0a:	84bb      	strh	r3, [r7, #36]	; 0x24
 8011c0c:	2300      	movs	r3, #0
 8011c0e:	847b      	strh	r3, [r7, #34]	; 0x22
 8011c10:	2300      	movs	r3, #0
 8011c12:	843b      	strh	r3, [r7, #32]
    
   wUAlpha = Stat_Volt_Input.qV_Component1 * T_SQRT3 ;
 8011c14:	88bb      	ldrh	r3, [r7, #4]
 8011c16:	b21b      	sxth	r3, r3
 8011c18:	f243 32f6 	movw	r2, #13302	; 0x33f6
 8011c1c:	fb02 f303 	mul.w	r3, r2, r3
 8011c20:	61fb      	str	r3, [r7, #28]
   wUBeta = -(Stat_Volt_Input.qV_Component2 * T);
 8011c22:	88fb      	ldrh	r3, [r7, #6]
 8011c24:	b21a      	sxth	r2, r3
 8011c26:	4613      	mov	r3, r2
 8011c28:	0112      	lsls	r2, r2, #4
 8011c2a:	1a9b      	subs	r3, r3, r2
 8011c2c:	025b      	lsls	r3, r3, #9
 8011c2e:	61bb      	str	r3, [r7, #24]

   wX = wUBeta;
 8011c30:	69bb      	ldr	r3, [r7, #24]
 8011c32:	617b      	str	r3, [r7, #20]
   wY = (wUBeta + wUAlpha)/2;
 8011c34:	69ba      	ldr	r2, [r7, #24]
 8011c36:	69fb      	ldr	r3, [r7, #28]
 8011c38:	4413      	add	r3, r2
 8011c3a:	0fda      	lsrs	r2, r3, #31
 8011c3c:	4413      	add	r3, r2
 8011c3e:	105b      	asrs	r3, r3, #1
 8011c40:	613b      	str	r3, [r7, #16]
   wZ = (wUBeta - wUAlpha)/2;
 8011c42:	69ba      	ldr	r2, [r7, #24]
 8011c44:	69fb      	ldr	r3, [r7, #28]
 8011c46:	1ad3      	subs	r3, r2, r3
 8011c48:	0fda      	lsrs	r2, r3, #31
 8011c4a:	4413      	add	r3, r2
 8011c4c:	105b      	asrs	r3, r3, #1
 8011c4e:	60fb      	str	r3, [r7, #12]

  // Sector calculation from wX, wY, wZ
   if (wY<0)
 8011c50:	693b      	ldr	r3, [r7, #16]
 8011c52:	2b00      	cmp	r3, #0
 8011c54:	da11      	bge.n	8011c7a <SVPWM_IcsCalcDutyCycles+0x7a>
   {
      if (wZ<0)
 8011c56:	68fb      	ldr	r3, [r7, #12]
 8011c58:	2b00      	cmp	r3, #0
 8011c5a:	da03      	bge.n	8011c64 <SVPWM_IcsCalcDutyCycles+0x64>
      {
        bSector = SECTOR_5;
 8011c5c:	2305      	movs	r3, #5
 8011c5e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011c62:	e01b      	b.n	8011c9c <SVPWM_IcsCalcDutyCycles+0x9c>
      }
      else // wZ >= 0
        if (wX<=0)
 8011c64:	697b      	ldr	r3, [r7, #20]
 8011c66:	2b00      	cmp	r3, #0
 8011c68:	dc03      	bgt.n	8011c72 <SVPWM_IcsCalcDutyCycles+0x72>
        {
          bSector = SECTOR_4;
 8011c6a:	2304      	movs	r3, #4
 8011c6c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011c70:	e014      	b.n	8011c9c <SVPWM_IcsCalcDutyCycles+0x9c>
        }
        else // wX > 0
        {
          bSector = SECTOR_3;
 8011c72:	2303      	movs	r3, #3
 8011c74:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011c78:	e010      	b.n	8011c9c <SVPWM_IcsCalcDutyCycles+0x9c>
        }
   }
   else // wY > 0
   {
     if (wZ>=0)
 8011c7a:	68fb      	ldr	r3, [r7, #12]
 8011c7c:	2b00      	cmp	r3, #0
 8011c7e:	db03      	blt.n	8011c88 <SVPWM_IcsCalcDutyCycles+0x88>
     {
       bSector = SECTOR_2;
 8011c80:	2302      	movs	r3, #2
 8011c82:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011c86:	e009      	b.n	8011c9c <SVPWM_IcsCalcDutyCycles+0x9c>
     }
     else // wZ < 0
       if (wX<=0)
 8011c88:	697b      	ldr	r3, [r7, #20]
 8011c8a:	2b00      	cmp	r3, #0
 8011c8c:	dc03      	bgt.n	8011c96 <SVPWM_IcsCalcDutyCycles+0x96>
       {  
         bSector = SECTOR_6;
 8011c8e:	2306      	movs	r3, #6
 8011c90:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011c94:	e002      	b.n	8011c9c <SVPWM_IcsCalcDutyCycles+0x9c>
       }
       else // wX > 0
       {
         bSector = SECTOR_1;
 8011c96:	2301      	movs	r3, #1
 8011c98:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
       }
    }
   
   /* Duty cycles computation */
  
  switch(bSector)
 8011c9c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011ca0:	3b01      	subs	r3, #1
 8011ca2:	2b05      	cmp	r3, #5
 8011ca4:	f200 8082 	bhi.w	8011dac <SVPWM_IcsCalcDutyCycles+0x1ac>
 8011ca8:	a201      	add	r2, pc, #4	; (adr r2, 8011cb0 <SVPWM_IcsCalcDutyCycles+0xb0>)
 8011caa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011cae:	bf00      	nop
 8011cb0:	08011cc9 	.word	0x08011cc9
 8011cb4:	08011d15 	.word	0x08011d15
 8011cb8:	08011d61 	.word	0x08011d61
 8011cbc:	08011cc9 	.word	0x08011cc9
 8011cc0:	08011d15 	.word	0x08011d15
 8011cc4:	08011d61 	.word	0x08011d61
  {  
    case SECTOR_1:
    case SECTOR_4:
                hTimePhA = (T/8) + ((((T + wX) - wZ)/2)/131072);
 8011cc8:	697b      	ldr	r3, [r7, #20]
 8011cca:	f503 52f0 	add.w	r2, r3, #7680	; 0x1e00
 8011cce:	68fb      	ldr	r3, [r7, #12]
 8011cd0:	1ad3      	subs	r3, r2, r3
 8011cd2:	2b00      	cmp	r3, #0
 8011cd4:	da02      	bge.n	8011cdc <SVPWM_IcsCalcDutyCycles+0xdc>
 8011cd6:	4a3a      	ldr	r2, [pc, #232]	; (8011dc0 <SVPWM_IcsCalcDutyCycles+0x1c0>)
 8011cd8:	441a      	add	r2, r3
 8011cda:	4613      	mov	r3, r2
 8011cdc:	149b      	asrs	r3, r3, #18
 8011cde:	b29b      	uxth	r3, r3
 8011ce0:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8011ce4:	84bb      	strh	r3, [r7, #36]	; 0x24
		hTimePhB = hTimePhA + wZ/131072;
 8011ce6:	68fb      	ldr	r3, [r7, #12]
 8011ce8:	2b00      	cmp	r3, #0
 8011cea:	da02      	bge.n	8011cf2 <SVPWM_IcsCalcDutyCycles+0xf2>
 8011cec:	4a35      	ldr	r2, [pc, #212]	; (8011dc4 <SVPWM_IcsCalcDutyCycles+0x1c4>)
 8011cee:	441a      	add	r2, r3
 8011cf0:	4613      	mov	r3, r2
 8011cf2:	145b      	asrs	r3, r3, #17
 8011cf4:	b29a      	uxth	r2, r3
 8011cf6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8011cf8:	4413      	add	r3, r2
 8011cfa:	847b      	strh	r3, [r7, #34]	; 0x22
		hTimePhC = hTimePhB - wX/131072;                                       
 8011cfc:	697b      	ldr	r3, [r7, #20]
 8011cfe:	2b00      	cmp	r3, #0
 8011d00:	da02      	bge.n	8011d08 <SVPWM_IcsCalcDutyCycles+0x108>
 8011d02:	4a30      	ldr	r2, [pc, #192]	; (8011dc4 <SVPWM_IcsCalcDutyCycles+0x1c4>)
 8011d04:	441a      	add	r2, r3
 8011d06:	4613      	mov	r3, r2
 8011d08:	145b      	asrs	r3, r3, #17
 8011d0a:	b29b      	uxth	r3, r3
 8011d0c:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8011d0e:	1ad3      	subs	r3, r2, r3
 8011d10:	843b      	strh	r3, [r7, #32]
                break;
 8011d12:	e04c      	b.n	8011dae <SVPWM_IcsCalcDutyCycles+0x1ae>
    case SECTOR_2:
    case SECTOR_5:  
                hTimePhA = (T/8) + ((((T + wY) - wZ)/2)/131072);
 8011d14:	693b      	ldr	r3, [r7, #16]
 8011d16:	f503 52f0 	add.w	r2, r3, #7680	; 0x1e00
 8011d1a:	68fb      	ldr	r3, [r7, #12]
 8011d1c:	1ad3      	subs	r3, r2, r3
 8011d1e:	2b00      	cmp	r3, #0
 8011d20:	da02      	bge.n	8011d28 <SVPWM_IcsCalcDutyCycles+0x128>
 8011d22:	4a27      	ldr	r2, [pc, #156]	; (8011dc0 <SVPWM_IcsCalcDutyCycles+0x1c0>)
 8011d24:	441a      	add	r2, r3
 8011d26:	4613      	mov	r3, r2
 8011d28:	149b      	asrs	r3, r3, #18
 8011d2a:	b29b      	uxth	r3, r3
 8011d2c:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8011d30:	84bb      	strh	r3, [r7, #36]	; 0x24
        	hTimePhB = hTimePhA + wZ/131072;
 8011d32:	68fb      	ldr	r3, [r7, #12]
 8011d34:	2b00      	cmp	r3, #0
 8011d36:	da02      	bge.n	8011d3e <SVPWM_IcsCalcDutyCycles+0x13e>
 8011d38:	4a22      	ldr	r2, [pc, #136]	; (8011dc4 <SVPWM_IcsCalcDutyCycles+0x1c4>)
 8011d3a:	441a      	add	r2, r3
 8011d3c:	4613      	mov	r3, r2
 8011d3e:	145b      	asrs	r3, r3, #17
 8011d40:	b29a      	uxth	r2, r3
 8011d42:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8011d44:	4413      	add	r3, r2
 8011d46:	847b      	strh	r3, [r7, #34]	; 0x22
		hTimePhC = hTimePhA - wY/131072;
 8011d48:	693b      	ldr	r3, [r7, #16]
 8011d4a:	2b00      	cmp	r3, #0
 8011d4c:	da02      	bge.n	8011d54 <SVPWM_IcsCalcDutyCycles+0x154>
 8011d4e:	4a1d      	ldr	r2, [pc, #116]	; (8011dc4 <SVPWM_IcsCalcDutyCycles+0x1c4>)
 8011d50:	441a      	add	r2, r3
 8011d52:	4613      	mov	r3, r2
 8011d54:	145b      	asrs	r3, r3, #17
 8011d56:	b29b      	uxth	r3, r3
 8011d58:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8011d5a:	1ad3      	subs	r3, r2, r3
 8011d5c:	843b      	strh	r3, [r7, #32]
                break;
 8011d5e:	e026      	b.n	8011dae <SVPWM_IcsCalcDutyCycles+0x1ae>

    case SECTOR_3:
    case SECTOR_6:
                hTimePhA = (T/8) + ((((T - wX) + wY)/2)/131072);
 8011d60:	697b      	ldr	r3, [r7, #20]
 8011d62:	f5c3 52f0 	rsb	r2, r3, #7680	; 0x1e00
 8011d66:	693b      	ldr	r3, [r7, #16]
 8011d68:	4413      	add	r3, r2
 8011d6a:	2b00      	cmp	r3, #0
 8011d6c:	da02      	bge.n	8011d74 <SVPWM_IcsCalcDutyCycles+0x174>
 8011d6e:	4a14      	ldr	r2, [pc, #80]	; (8011dc0 <SVPWM_IcsCalcDutyCycles+0x1c0>)
 8011d70:	441a      	add	r2, r3
 8011d72:	4613      	mov	r3, r2
 8011d74:	149b      	asrs	r3, r3, #18
 8011d76:	b29b      	uxth	r3, r3
 8011d78:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8011d7c:	84bb      	strh	r3, [r7, #36]	; 0x24
		hTimePhC = hTimePhA - wY/131072;
 8011d7e:	693b      	ldr	r3, [r7, #16]
 8011d80:	2b00      	cmp	r3, #0
 8011d82:	da02      	bge.n	8011d8a <SVPWM_IcsCalcDutyCycles+0x18a>
 8011d84:	4a0f      	ldr	r2, [pc, #60]	; (8011dc4 <SVPWM_IcsCalcDutyCycles+0x1c4>)
 8011d86:	441a      	add	r2, r3
 8011d88:	4613      	mov	r3, r2
 8011d8a:	145b      	asrs	r3, r3, #17
 8011d8c:	b29b      	uxth	r3, r3
 8011d8e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8011d90:	1ad3      	subs	r3, r2, r3
 8011d92:	843b      	strh	r3, [r7, #32]
		hTimePhB = hTimePhC + wX/131072;
 8011d94:	697b      	ldr	r3, [r7, #20]
 8011d96:	2b00      	cmp	r3, #0
 8011d98:	da02      	bge.n	8011da0 <SVPWM_IcsCalcDutyCycles+0x1a0>
 8011d9a:	4a0a      	ldr	r2, [pc, #40]	; (8011dc4 <SVPWM_IcsCalcDutyCycles+0x1c4>)
 8011d9c:	441a      	add	r2, r3
 8011d9e:	4613      	mov	r3, r2
 8011da0:	145b      	asrs	r3, r3, #17
 8011da2:	b29a      	uxth	r2, r3
 8011da4:	8c3b      	ldrh	r3, [r7, #32]
 8011da6:	4413      	add	r3, r2
 8011da8:	847b      	strh	r3, [r7, #34]	; 0x22
                break;
 8011daa:	e000      	b.n	8011dae <SVPWM_IcsCalcDutyCycles+0x1ae>
    default:
		break;
 8011dac:	bf00      	nop
   }
  
  /* Load compare registers values */
   SetDutyCycles(TIM8, hTimePhA, hTimePhB, hTimePhC);
 8011dae:	8cb9      	ldrh	r1, [r7, #36]	; 0x24
 8011db0:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8011db2:	8c3b      	ldrh	r3, [r7, #32]
 8011db4:	4804      	ldr	r0, [pc, #16]	; (8011dc8 <SVPWM_IcsCalcDutyCycles+0x1c8>)
 8011db6:	f7fc ff45 	bl	800ec44 <SetDutyCycles>
}
 8011dba:	3728      	adds	r7, #40	; 0x28
 8011dbc:	46bd      	mov	sp, r7
 8011dbe:	bd80      	pop	{r7, pc}
 8011dc0:	0003ffff 	.word	0x0003ffff
 8011dc4:	0001ffff 	.word	0x0001ffff
 8011dc8:	40010400 	.word	0x40010400

08011dcc <SVPWMEOCEvent>:
* Input           : None
* Output         : None
* Return         : None
*******************************************************************************/
u8 SVPWMEOCEvent(void)
{
 8011dcc:	b480      	push	{r7}
 8011dce:	af00      	add	r7, sp, #0
  return ((u8)(1));
 8011dd0:	2301      	movs	r3, #1
}
 8011dd2:	4618      	mov	r0, r3
 8011dd4:	46bd      	mov	sp, r7
 8011dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011dda:	4770      	bx	lr

08011ddc <rt_system_tick_init>:
 *
 * @deprecated since 1.1.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_tick_init(void)
{
 8011ddc:	b480      	push	{r7}
 8011dde:	af00      	add	r7, sp, #0
}
 8011de0:	46bd      	mov	sp, r7
 8011de2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011de6:	4770      	bx	lr

08011de8 <rt_tick_get>:
 * This function will return current tick from operating system startup
 *
 * @return current tick
 */
rt_tick_t rt_tick_get(void)
{
 8011de8:	b480      	push	{r7}
 8011dea:	af00      	add	r7, sp, #0
    /* return the global tick */
    return rt_tick;
 8011dec:	4b03      	ldr	r3, [pc, #12]	; (8011dfc <rt_tick_get+0x14>)
 8011dee:	681b      	ldr	r3, [r3, #0]
}
 8011df0:	4618      	mov	r0, r3
 8011df2:	46bd      	mov	sp, r7
 8011df4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011df8:	4770      	bx	lr
 8011dfa:	bf00      	nop
 8011dfc:	20010a88 	.word	0x20010a88

08011e00 <rt_tick_increase>:
/**
 * This function will notify kernel there is one tick passed. Normally,
 * this function is invoked by clock ISR.
 */
void rt_tick_increase(void)
{
 8011e00:	b580      	push	{r7, lr}
 8011e02:	b082      	sub	sp, #8
 8011e04:	af00      	add	r7, sp, #0
    struct rt_thread *thread;

    /* increase the global tick */
    ++ rt_tick;
 8011e06:	4b0e      	ldr	r3, [pc, #56]	; (8011e40 <rt_tick_increase+0x40>)
 8011e08:	681b      	ldr	r3, [r3, #0]
 8011e0a:	3301      	adds	r3, #1
 8011e0c:	4a0c      	ldr	r2, [pc, #48]	; (8011e40 <rt_tick_increase+0x40>)
 8011e0e:	6013      	str	r3, [r2, #0]

    /* check time slice */
    thread = rt_thread_self();
 8011e10:	f003 f8b8 	bl	8014f84 <rt_thread_self>
 8011e14:	6078      	str	r0, [r7, #4]

    -- thread->remaining_tick;
 8011e16:	687b      	ldr	r3, [r7, #4]
 8011e18:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011e1a:	1e5a      	subs	r2, r3, #1
 8011e1c:	687b      	ldr	r3, [r7, #4]
 8011e1e:	649a      	str	r2, [r3, #72]	; 0x48
    if (thread->remaining_tick == 0)
 8011e20:	687b      	ldr	r3, [r7, #4]
 8011e22:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011e24:	2b00      	cmp	r3, #0
 8011e26:	d105      	bne.n	8011e34 <rt_tick_increase+0x34>
    {
        /* change to initialized tick */
        thread->remaining_tick = thread->init_tick;
 8011e28:	687b      	ldr	r3, [r7, #4]
 8011e2a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8011e2c:	687b      	ldr	r3, [r7, #4]
 8011e2e:	649a      	str	r2, [r3, #72]	; 0x48

        /* yield */
        rt_thread_yield();
 8011e30:	f003 f954 	bl	80150dc <rt_thread_yield>
    }

    /* check timer */
    rt_timer_check();
 8011e34:	f003 fd68 	bl	8015908 <rt_timer_check>
}
 8011e38:	3708      	adds	r7, #8
 8011e3a:	46bd      	mov	sp, r7
 8011e3c:	bd80      	pop	{r7, pc}
 8011e3e:	bf00      	nop
 8011e40:	20010a88 	.word	0x20010a88

08011e44 <rt_tick_from_millisecond>:
 * @param ms the specified millisecond
 *
 * @return the calculated tick
 */
rt_tick_t rt_tick_from_millisecond(rt_uint32_t ms)
{
 8011e44:	b480      	push	{r7}
 8011e46:	b083      	sub	sp, #12
 8011e48:	af00      	add	r7, sp, #0
 8011e4a:	6078      	str	r0, [r7, #4]
    /* return the calculated tick */
    return (RT_TICK_PER_SECOND * ms + 999) / 1000;
 8011e4c:	687b      	ldr	r3, [r7, #4]
 8011e4e:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8011e52:	fb02 f303 	mul.w	r3, r2, r3
 8011e56:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8011e5a:	4a05      	ldr	r2, [pc, #20]	; (8011e70 <rt_tick_from_millisecond+0x2c>)
 8011e5c:	fba2 2303 	umull	r2, r3, r2, r3
 8011e60:	099b      	lsrs	r3, r3, #6
}
 8011e62:	4618      	mov	r0, r3
 8011e64:	370c      	adds	r7, #12
 8011e66:	46bd      	mov	sp, r7
 8011e68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e6c:	4770      	bx	lr
 8011e6e:	bf00      	nop
 8011e70:	10624dd3 	.word	0x10624dd3

08011e74 <rti_start>:
 * ...
 * INIT_APP_EXPORT(fn);
 * etc. 
 */
static int rti_start(void)
{
 8011e74:	b480      	push	{r7}
 8011e76:	af00      	add	r7, sp, #0
    return 0;
 8011e78:	2300      	movs	r3, #0
}
 8011e7a:	4618      	mov	r0, r3
 8011e7c:	46bd      	mov	sp, r7
 8011e7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e82:	4770      	bx	lr

08011e84 <rti_board_end>:
INIT_EXPORT(rti_start, "0");

static int rti_board_end(void)
{
 8011e84:	b480      	push	{r7}
 8011e86:	af00      	add	r7, sp, #0
    return 0;
 8011e88:	2300      	movs	r3, #0
}
 8011e8a:	4618      	mov	r0, r3
 8011e8c:	46bd      	mov	sp, r7
 8011e8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e92:	4770      	bx	lr

08011e94 <rti_end>:
INIT_EXPORT(rti_board_end, "1.end");

static int rti_end(void)
{
 8011e94:	b480      	push	{r7}
 8011e96:	af00      	add	r7, sp, #0
	return 0;
 8011e98:	2300      	movs	r3, #0
}
 8011e9a:	4618      	mov	r0, r3
 8011e9c:	46bd      	mov	sp, r7
 8011e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011ea2:	4770      	bx	lr

08011ea4 <rt_components_board_init>:

/**
 * RT-Thread Components Initialization for board
 */
void rt_components_board_init(void)
{
 8011ea4:	b580      	push	{r7, lr}
 8011ea6:	b082      	sub	sp, #8
 8011ea8:	af00      	add	r7, sp, #0
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
 8011eaa:	4b08      	ldr	r3, [pc, #32]	; (8011ecc <rt_components_board_init+0x28>)
 8011eac:	607b      	str	r3, [r7, #4]
 8011eae:	e005      	b.n	8011ebc <rt_components_board_init+0x18>
    {
        (*fn_ptr)();
 8011eb0:	687b      	ldr	r3, [r7, #4]
 8011eb2:	681b      	ldr	r3, [r3, #0]
 8011eb4:	4798      	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
 8011eb6:	687b      	ldr	r3, [r7, #4]
 8011eb8:	3304      	adds	r3, #4
 8011eba:	607b      	str	r3, [r7, #4]
 8011ebc:	687b      	ldr	r3, [r7, #4]
 8011ebe:	4a04      	ldr	r2, [pc, #16]	; (8011ed0 <rt_components_board_init+0x2c>)
 8011ec0:	4293      	cmp	r3, r2
 8011ec2:	d3f5      	bcc.n	8011eb0 <rt_components_board_init+0xc>
    {
        (*fn_ptr)();
    }
#endif
}
 8011ec4:	3708      	adds	r7, #8
 8011ec6:	46bd      	mov	sp, r7
 8011ec8:	bd80      	pop	{r7, pc}
 8011eca:	bf00      	nop
 8011ecc:	08026020 	.word	0x08026020
 8011ed0:	08026030 	.word	0x08026030

08011ed4 <rt_components_init>:

/**
 * RT-Thread Components Initialization
 */
void rt_components_init(void)
{
 8011ed4:	b580      	push	{r7, lr}
 8011ed6:	b082      	sub	sp, #8
 8011ed8:	af00      	add	r7, sp, #0
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
 8011eda:	4b08      	ldr	r3, [pc, #32]	; (8011efc <rt_components_init+0x28>)
 8011edc:	607b      	str	r3, [r7, #4]
 8011ede:	e005      	b.n	8011eec <rt_components_init+0x18>
    {
        (*fn_ptr)();
 8011ee0:	687b      	ldr	r3, [r7, #4]
 8011ee2:	681b      	ldr	r3, [r3, #0]
 8011ee4:	4798      	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
 8011ee6:	687b      	ldr	r3, [r7, #4]
 8011ee8:	3304      	adds	r3, #4
 8011eea:	607b      	str	r3, [r7, #4]
 8011eec:	687b      	ldr	r3, [r7, #4]
 8011eee:	4a04      	ldr	r2, [pc, #16]	; (8011f00 <rt_components_init+0x2c>)
 8011ef0:	4293      	cmp	r3, r2
 8011ef2:	d3f5      	bcc.n	8011ee0 <rt_components_init+0xc>
			}
		}
	}
#endif

}
 8011ef4:	3708      	adds	r7, #8
 8011ef6:	46bd      	mov	sp, r7
 8011ef8:	bd80      	pop	{r7, pc}
 8011efa:	bf00      	nop
 8011efc:	08026030 	.word	0x08026030
 8011f00:	08026054 	.word	0x08026054

08011f04 <rt_device_register>:
 * @return the error code, RT_EOK on initialization successfully.
 */
rt_err_t rt_device_register(rt_device_t dev,
                            const char *name,
                            rt_uint16_t flags)
{
 8011f04:	b580      	push	{r7, lr}
 8011f06:	b084      	sub	sp, #16
 8011f08:	af00      	add	r7, sp, #0
 8011f0a:	60f8      	str	r0, [r7, #12]
 8011f0c:	60b9      	str	r1, [r7, #8]
 8011f0e:	4613      	mov	r3, r2
 8011f10:	80fb      	strh	r3, [r7, #6]
    if (dev == RT_NULL)
 8011f12:	68fb      	ldr	r3, [r7, #12]
 8011f14:	2b00      	cmp	r3, #0
 8011f16:	d102      	bne.n	8011f1e <rt_device_register+0x1a>
        return -RT_ERROR;
 8011f18:	f04f 33ff 	mov.w	r3, #4294967295
 8011f1c:	e015      	b.n	8011f4a <rt_device_register+0x46>

    if (rt_device_find(name) != RT_NULL)
 8011f1e:	68b8      	ldr	r0, [r7, #8]
 8011f20:	f000 f818 	bl	8011f54 <rt_device_find>
 8011f24:	4603      	mov	r3, r0
 8011f26:	2b00      	cmp	r3, #0
 8011f28:	d002      	beq.n	8011f30 <rt_device_register+0x2c>
        return -RT_ERROR;
 8011f2a:	f04f 33ff 	mov.w	r3, #4294967295
 8011f2e:	e00c      	b.n	8011f4a <rt_device_register+0x46>

    rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
 8011f30:	68fb      	ldr	r3, [r7, #12]
 8011f32:	4618      	mov	r0, r3
 8011f34:	2108      	movs	r1, #8
 8011f36:	68ba      	ldr	r2, [r7, #8]
 8011f38:	f002 fbf4 	bl	8014724 <rt_object_init>
    dev->flag = flags;
 8011f3c:	68fb      	ldr	r3, [r7, #12]
 8011f3e:	88fa      	ldrh	r2, [r7, #6]
 8011f40:	82da      	strh	r2, [r3, #22]
    dev->ref_count = 0;
 8011f42:	68fb      	ldr	r3, [r7, #12]
 8011f44:	2200      	movs	r2, #0
 8011f46:	769a      	strb	r2, [r3, #26]

    return RT_EOK;
 8011f48:	2300      	movs	r3, #0
}
 8011f4a:	4618      	mov	r0, r3
 8011f4c:	3710      	adds	r7, #16
 8011f4e:	46bd      	mov	sp, r7
 8011f50:	bd80      	pop	{r7, pc}
 8011f52:	bf00      	nop

08011f54 <rt_device_find>:
 * @param name the device driver's name
 *
 * @return the registered device driver on successful, or RT_NULL on failure.
 */
rt_device_t rt_device_find(const char *name)
{
 8011f54:	b580      	push	{r7, lr}
 8011f56:	b086      	sub	sp, #24
 8011f58:	af00      	add	r7, sp, #0
 8011f5a:	6078      	str	r0, [r7, #4]
    struct rt_object_information *information;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
 8011f5c:	f003 f812 	bl	8014f84 <rt_thread_self>
 8011f60:	4603      	mov	r3, r0
 8011f62:	2b00      	cmp	r3, #0
 8011f64:	d001      	beq.n	8011f6a <rt_device_find+0x16>
        rt_enter_critical();
 8011f66:	f002 fe9d 	bl	8014ca4 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
 8011f6a:	4b17      	ldr	r3, [pc, #92]	; (8011fc8 <rt_device_find+0x74>)
 8011f6c:	613b      	str	r3, [r7, #16]
    for (node  = information->object_list.next;
 8011f6e:	693b      	ldr	r3, [r7, #16]
 8011f70:	685b      	ldr	r3, [r3, #4]
 8011f72:	617b      	str	r3, [r7, #20]
 8011f74:	e017      	b.n	8011fa6 <rt_device_find+0x52>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
 8011f76:	697b      	ldr	r3, [r7, #20]
 8011f78:	3b0c      	subs	r3, #12
 8011f7a:	60fb      	str	r3, [r7, #12]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
 8011f7c:	68fb      	ldr	r3, [r7, #12]
 8011f7e:	4618      	mov	r0, r3
 8011f80:	6879      	ldr	r1, [r7, #4]
 8011f82:	2208      	movs	r2, #8
 8011f84:	f001 f9f6 	bl	8013374 <rt_strncmp>
 8011f88:	4603      	mov	r3, r0
 8011f8a:	2b00      	cmp	r3, #0
 8011f8c:	d108      	bne.n	8011fa0 <rt_device_find+0x4c>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
 8011f8e:	f002 fff9 	bl	8014f84 <rt_thread_self>
 8011f92:	4603      	mov	r3, r0
 8011f94:	2b00      	cmp	r3, #0
 8011f96:	d001      	beq.n	8011f9c <rt_device_find+0x48>
                rt_exit_critical();
 8011f98:	f002 fe98 	bl	8014ccc <rt_exit_critical>

            return (rt_device_t)object;
 8011f9c:	68fb      	ldr	r3, [r7, #12]
 8011f9e:	e00f      	b.n	8011fc0 <rt_device_find+0x6c>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
 8011fa0:	697b      	ldr	r3, [r7, #20]
 8011fa2:	681b      	ldr	r3, [r3, #0]
 8011fa4:	617b      	str	r3, [r7, #20]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
 8011fa6:	693b      	ldr	r3, [r7, #16]
 8011fa8:	1d1a      	adds	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
 8011faa:	697b      	ldr	r3, [r7, #20]
 8011fac:	429a      	cmp	r2, r3
 8011fae:	d1e2      	bne.n	8011f76 <rt_device_find+0x22>
            return (rt_device_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
 8011fb0:	f002 ffe8 	bl	8014f84 <rt_thread_self>
 8011fb4:	4603      	mov	r3, r0
 8011fb6:	2b00      	cmp	r3, #0
 8011fb8:	d001      	beq.n	8011fbe <rt_device_find+0x6a>
        rt_exit_critical();
 8011fba:	f002 fe87 	bl	8014ccc <rt_exit_critical>

    /* not found */
    return RT_NULL;
 8011fbe:	2300      	movs	r3, #0
}
 8011fc0:	4618      	mov	r0, r3
 8011fc2:	3718      	adds	r7, #24
 8011fc4:	46bd      	mov	sp, r7
 8011fc6:	bd80      	pop	{r7, pc}
 8011fc8:	20010094 	.word	0x20010094

08011fcc <rt_device_open>:
 * @param oflag the flags for device open
 *
 * @return the result
 */
rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
{
 8011fcc:	b580      	push	{r7, lr}
 8011fce:	b084      	sub	sp, #16
 8011fd0:	af00      	add	r7, sp, #0
 8011fd2:	6078      	str	r0, [r7, #4]
 8011fd4:	460b      	mov	r3, r1
 8011fd6:	807b      	strh	r3, [r7, #2]
    rt_err_t result = RT_EOK;
 8011fd8:	2300      	movs	r3, #0
 8011fda:	60fb      	str	r3, [r7, #12]

    RT_ASSERT(dev != RT_NULL);
 8011fdc:	687b      	ldr	r3, [r7, #4]
 8011fde:	2b00      	cmp	r3, #0
 8011fe0:	d104      	bne.n	8011fec <rt_device_open+0x20>
 8011fe2:	4830      	ldr	r0, [pc, #192]	; (80120a4 <rt_device_open+0xd8>)
 8011fe4:	4930      	ldr	r1, [pc, #192]	; (80120a8 <rt_device_open+0xdc>)
 8011fe6:	22b6      	movs	r2, #182	; 0xb6
 8011fe8:	f001 febc 	bl	8013d64 <rt_assert_handler>

    /* if device is not initialized, initialize it. */
    if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
 8011fec:	687b      	ldr	r3, [r7, #4]
 8011fee:	8adb      	ldrh	r3, [r3, #22]
 8011ff0:	f003 0310 	and.w	r3, r3, #16
 8011ff4:	2b00      	cmp	r3, #0
 8011ff6:	d11a      	bne.n	801202e <rt_device_open+0x62>
    {
        if (dev->init != RT_NULL)
 8011ff8:	687b      	ldr	r3, [r7, #4]
 8011ffa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011ffc:	2b00      	cmp	r3, #0
 8011ffe:	d00f      	beq.n	8012020 <rt_device_open+0x54>
        {
            result = dev->init(dev);
 8012000:	687b      	ldr	r3, [r7, #4]
 8012002:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012004:	6878      	ldr	r0, [r7, #4]
 8012006:	4798      	blx	r3
 8012008:	60f8      	str	r0, [r7, #12]
            if (result != RT_EOK)
 801200a:	68fb      	ldr	r3, [r7, #12]
 801200c:	2b00      	cmp	r3, #0
 801200e:	d007      	beq.n	8012020 <rt_device_open+0x54>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
 8012010:	687b      	ldr	r3, [r7, #4]
        if (dev->init != RT_NULL)
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
 8012012:	4826      	ldr	r0, [pc, #152]	; (80120ac <rt_device_open+0xe0>)
 8012014:	4619      	mov	r1, r3
 8012016:	68fa      	ldr	r2, [r7, #12]
 8012018:	f001 fe2a 	bl	8013c70 <rt_kprintf>
                           dev->parent.name, result);

                return result;
 801201c:	68fb      	ldr	r3, [r7, #12]
 801201e:	e03d      	b.n	801209c <rt_device_open+0xd0>
            }
        }

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
 8012020:	687b      	ldr	r3, [r7, #4]
 8012022:	8adb      	ldrh	r3, [r3, #22]
 8012024:	f043 0310 	orr.w	r3, r3, #16
 8012028:	b29a      	uxth	r2, r3
 801202a:	687b      	ldr	r3, [r7, #4]
 801202c:	82da      	strh	r2, [r3, #22]
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
 801202e:	687b      	ldr	r3, [r7, #4]
 8012030:	8adb      	ldrh	r3, [r3, #22]
 8012032:	f003 0308 	and.w	r3, r3, #8
 8012036:	2b00      	cmp	r3, #0
 8012038:	d008      	beq.n	801204c <rt_device_open+0x80>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
 801203a:	687b      	ldr	r3, [r7, #4]
 801203c:	8b1b      	ldrh	r3, [r3, #24]
 801203e:	f003 0308 	and.w	r3, r3, #8

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
 8012042:	2b00      	cmp	r3, #0
 8012044:	d002      	beq.n	801204c <rt_device_open+0x80>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
    {
        return -RT_EBUSY;
 8012046:	f06f 0306 	mvn.w	r3, #6
 801204a:	e027      	b.n	801209c <rt_device_open+0xd0>
    }

    /* call device open interface */
    if (dev->open != RT_NULL)
 801204c:	687b      	ldr	r3, [r7, #4]
 801204e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012050:	2b00      	cmp	r3, #0
 8012052:	d006      	beq.n	8012062 <rt_device_open+0x96>
    {
        result = dev->open(dev, oflag);
 8012054:	687b      	ldr	r3, [r7, #4]
 8012056:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012058:	887a      	ldrh	r2, [r7, #2]
 801205a:	6878      	ldr	r0, [r7, #4]
 801205c:	4611      	mov	r1, r2
 801205e:	4798      	blx	r3
 8012060:	60f8      	str	r0, [r7, #12]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
 8012062:	68fb      	ldr	r3, [r7, #12]
 8012064:	2b00      	cmp	r3, #0
 8012066:	d003      	beq.n	8012070 <rt_device_open+0xa4>
 8012068:	68fb      	ldr	r3, [r7, #12]
 801206a:	f113 0f06 	cmn.w	r3, #6
 801206e:	d114      	bne.n	801209a <rt_device_open+0xce>
    {
        dev->open_flag = oflag | RT_DEVICE_OFLAG_OPEN;
 8012070:	887b      	ldrh	r3, [r7, #2]
 8012072:	f043 0308 	orr.w	r3, r3, #8
 8012076:	b29a      	uxth	r2, r3
 8012078:	687b      	ldr	r3, [r7, #4]
 801207a:	831a      	strh	r2, [r3, #24]

        dev->ref_count++;
 801207c:	687b      	ldr	r3, [r7, #4]
 801207e:	7e9b      	ldrb	r3, [r3, #26]
 8012080:	3301      	adds	r3, #1
 8012082:	b2da      	uxtb	r2, r3
 8012084:	687b      	ldr	r3, [r7, #4]
 8012086:	769a      	strb	r2, [r3, #26]
        /* don't let bad things happen silently. If you are bitten by this assert,
         * please set the ref_count to a bigger type. */
        RT_ASSERT(dev->ref_count != 0);
 8012088:	687b      	ldr	r3, [r7, #4]
 801208a:	7e9b      	ldrb	r3, [r3, #26]
 801208c:	2b00      	cmp	r3, #0
 801208e:	d104      	bne.n	801209a <rt_device_open+0xce>
 8012090:	4807      	ldr	r0, [pc, #28]	; (80120b0 <rt_device_open+0xe4>)
 8012092:	4905      	ldr	r1, [pc, #20]	; (80120a8 <rt_device_open+0xdc>)
 8012094:	22df      	movs	r2, #223	; 0xdf
 8012096:	f001 fe65 	bl	8013d64 <rt_assert_handler>
    }

    return result;
 801209a:	68fb      	ldr	r3, [r7, #12]
}
 801209c:	4618      	mov	r0, r3
 801209e:	3710      	adds	r7, #16
 80120a0:	46bd      	mov	sp, r7
 80120a2:	bd80      	pop	{r7, pc}
 80120a4:	08022c50 	.word	0x08022c50
 80120a8:	08024c2c 	.word	0x08024c2c
 80120ac:	08022c60 	.word	0x08022c60
 80120b0:	08022c98 	.word	0x08022c98

080120b4 <rt_device_close>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_close(rt_device_t dev)
{
 80120b4:	b580      	push	{r7, lr}
 80120b6:	b084      	sub	sp, #16
 80120b8:	af00      	add	r7, sp, #0
 80120ba:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 80120bc:	2300      	movs	r3, #0
 80120be:	60fb      	str	r3, [r7, #12]

    RT_ASSERT(dev != RT_NULL);
 80120c0:	687b      	ldr	r3, [r7, #4]
 80120c2:	2b00      	cmp	r3, #0
 80120c4:	d104      	bne.n	80120d0 <rt_device_close+0x1c>
 80120c6:	4818      	ldr	r0, [pc, #96]	; (8012128 <rt_device_close+0x74>)
 80120c8:	4918      	ldr	r1, [pc, #96]	; (801212c <rt_device_close+0x78>)
 80120ca:	22f1      	movs	r2, #241	; 0xf1
 80120cc:	f001 fe4a 	bl	8013d64 <rt_assert_handler>

    if (dev->ref_count == 0)
 80120d0:	687b      	ldr	r3, [r7, #4]
 80120d2:	7e9b      	ldrb	r3, [r3, #26]
 80120d4:	2b00      	cmp	r3, #0
 80120d6:	d102      	bne.n	80120de <rt_device_close+0x2a>
        return -RT_ERROR;
 80120d8:	f04f 33ff 	mov.w	r3, #4294967295
 80120dc:	e01f      	b.n	801211e <rt_device_close+0x6a>

    dev->ref_count--;
 80120de:	687b      	ldr	r3, [r7, #4]
 80120e0:	7e9b      	ldrb	r3, [r3, #26]
 80120e2:	3b01      	subs	r3, #1
 80120e4:	b2da      	uxtb	r2, r3
 80120e6:	687b      	ldr	r3, [r7, #4]
 80120e8:	769a      	strb	r2, [r3, #26]

    if (dev->ref_count != 0)
 80120ea:	687b      	ldr	r3, [r7, #4]
 80120ec:	7e9b      	ldrb	r3, [r3, #26]
 80120ee:	2b00      	cmp	r3, #0
 80120f0:	d001      	beq.n	80120f6 <rt_device_close+0x42>
        return RT_EOK;
 80120f2:	2300      	movs	r3, #0
 80120f4:	e013      	b.n	801211e <rt_device_close+0x6a>

    /* call device close interface */
    if (dev->close != RT_NULL)
 80120f6:	687b      	ldr	r3, [r7, #4]
 80120f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80120fa:	2b00      	cmp	r3, #0
 80120fc:	d004      	beq.n	8012108 <rt_device_close+0x54>
    {
        result = dev->close(dev);
 80120fe:	687b      	ldr	r3, [r7, #4]
 8012100:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012102:	6878      	ldr	r0, [r7, #4]
 8012104:	4798      	blx	r3
 8012106:	60f8      	str	r0, [r7, #12]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
 8012108:	68fb      	ldr	r3, [r7, #12]
 801210a:	2b00      	cmp	r3, #0
 801210c:	d003      	beq.n	8012116 <rt_device_close+0x62>
 801210e:	68fb      	ldr	r3, [r7, #12]
 8012110:	f113 0f06 	cmn.w	r3, #6
 8012114:	d102      	bne.n	801211c <rt_device_close+0x68>
        dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
 8012116:	687b      	ldr	r3, [r7, #4]
 8012118:	2200      	movs	r2, #0
 801211a:	831a      	strh	r2, [r3, #24]

    return result;
 801211c:	68fb      	ldr	r3, [r7, #12]
}
 801211e:	4618      	mov	r0, r3
 8012120:	3710      	adds	r7, #16
 8012122:	46bd      	mov	sp, r7
 8012124:	bd80      	pop	{r7, pc}
 8012126:	bf00      	nop
 8012128:	08022c50 	.word	0x08022c50
 801212c:	08024c3c 	.word	0x08024c3c

08012130 <rt_device_read>:
 */
rt_size_t rt_device_read(rt_device_t dev,
                         rt_off_t    pos,
                         void       *buffer,
                         rt_size_t   size)
{
 8012130:	b590      	push	{r4, r7, lr}
 8012132:	b085      	sub	sp, #20
 8012134:	af00      	add	r7, sp, #0
 8012136:	60f8      	str	r0, [r7, #12]
 8012138:	60b9      	str	r1, [r7, #8]
 801213a:	607a      	str	r2, [r7, #4]
 801213c:	603b      	str	r3, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 801213e:	68fb      	ldr	r3, [r7, #12]
 8012140:	2b00      	cmp	r3, #0
 8012142:	d105      	bne.n	8012150 <rt_device_read+0x20>
 8012144:	4812      	ldr	r0, [pc, #72]	; (8012190 <rt_device_read+0x60>)
 8012146:	4913      	ldr	r1, [pc, #76]	; (8012194 <rt_device_read+0x64>)
 8012148:	f44f 728d 	mov.w	r2, #282	; 0x11a
 801214c:	f001 fe0a 	bl	8013d64 <rt_assert_handler>

    if (dev->ref_count == 0)
 8012150:	68fb      	ldr	r3, [r7, #12]
 8012152:	7e9b      	ldrb	r3, [r3, #26]
 8012154:	2b00      	cmp	r3, #0
 8012156:	d105      	bne.n	8012164 <rt_device_read+0x34>
    {
        rt_set_errno(-RT_ERROR);
 8012158:	f04f 30ff 	mov.w	r0, #4294967295
 801215c:	f000 ffb0 	bl	80130c0 <rt_set_errno>
        return 0;
 8012160:	2300      	movs	r3, #0
 8012162:	e011      	b.n	8012188 <rt_device_read+0x58>
    }

    /* call device read interface */
    if (dev->read != RT_NULL)
 8012164:	68fb      	ldr	r3, [r7, #12]
 8012166:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012168:	2b00      	cmp	r3, #0
 801216a:	d008      	beq.n	801217e <rt_device_read+0x4e>
    {
        return dev->read(dev, pos, buffer, size);
 801216c:	68fb      	ldr	r3, [r7, #12]
 801216e:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8012170:	68f8      	ldr	r0, [r7, #12]
 8012172:	68b9      	ldr	r1, [r7, #8]
 8012174:	687a      	ldr	r2, [r7, #4]
 8012176:	683b      	ldr	r3, [r7, #0]
 8012178:	47a0      	blx	r4
 801217a:	4603      	mov	r3, r0
 801217c:	e004      	b.n	8012188 <rt_device_read+0x58>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
 801217e:	f06f 0005 	mvn.w	r0, #5
 8012182:	f000 ff9d 	bl	80130c0 <rt_set_errno>

    return 0;
 8012186:	2300      	movs	r3, #0
}
 8012188:	4618      	mov	r0, r3
 801218a:	3714      	adds	r7, #20
 801218c:	46bd      	mov	sp, r7
 801218e:	bd90      	pop	{r4, r7, pc}
 8012190:	08022c50 	.word	0x08022c50
 8012194:	08024c4c 	.word	0x08024c4c

08012198 <rt_device_write>:
 */
rt_size_t rt_device_write(rt_device_t dev,
                          rt_off_t    pos,
                          const void *buffer,
                          rt_size_t   size)
{
 8012198:	b590      	push	{r4, r7, lr}
 801219a:	b085      	sub	sp, #20
 801219c:	af00      	add	r7, sp, #0
 801219e:	60f8      	str	r0, [r7, #12]
 80121a0:	60b9      	str	r1, [r7, #8]
 80121a2:	607a      	str	r2, [r7, #4]
 80121a4:	603b      	str	r3, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 80121a6:	68fb      	ldr	r3, [r7, #12]
 80121a8:	2b00      	cmp	r3, #0
 80121aa:	d105      	bne.n	80121b8 <rt_device_write+0x20>
 80121ac:	4812      	ldr	r0, [pc, #72]	; (80121f8 <rt_device_write+0x60>)
 80121ae:	4913      	ldr	r1, [pc, #76]	; (80121fc <rt_device_write+0x64>)
 80121b0:	f44f 72a0 	mov.w	r2, #320	; 0x140
 80121b4:	f001 fdd6 	bl	8013d64 <rt_assert_handler>

    if (dev->ref_count == 0)
 80121b8:	68fb      	ldr	r3, [r7, #12]
 80121ba:	7e9b      	ldrb	r3, [r3, #26]
 80121bc:	2b00      	cmp	r3, #0
 80121be:	d105      	bne.n	80121cc <rt_device_write+0x34>
    {
        rt_set_errno(-RT_ERROR);
 80121c0:	f04f 30ff 	mov.w	r0, #4294967295
 80121c4:	f000 ff7c 	bl	80130c0 <rt_set_errno>
        return 0;
 80121c8:	2300      	movs	r3, #0
 80121ca:	e011      	b.n	80121f0 <rt_device_write+0x58>
    }

    /* call device write interface */
    if (dev->write != RT_NULL)
 80121cc:	68fb      	ldr	r3, [r7, #12]
 80121ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80121d0:	2b00      	cmp	r3, #0
 80121d2:	d008      	beq.n	80121e6 <rt_device_write+0x4e>
    {
        return dev->write(dev, pos, buffer, size);
 80121d4:	68fb      	ldr	r3, [r7, #12]
 80121d6:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 80121d8:	68f8      	ldr	r0, [r7, #12]
 80121da:	68b9      	ldr	r1, [r7, #8]
 80121dc:	687a      	ldr	r2, [r7, #4]
 80121de:	683b      	ldr	r3, [r7, #0]
 80121e0:	47a0      	blx	r4
 80121e2:	4603      	mov	r3, r0
 80121e4:	e004      	b.n	80121f0 <rt_device_write+0x58>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
 80121e6:	f06f 0005 	mvn.w	r0, #5
 80121ea:	f000 ff69 	bl	80130c0 <rt_set_errno>

    return 0;
 80121ee:	2300      	movs	r3, #0
}
 80121f0:	4618      	mov	r0, r3
 80121f2:	3714      	adds	r7, #20
 80121f4:	46bd      	mov	sp, r7
 80121f6:	bd90      	pop	{r4, r7, pc}
 80121f8:	08022c50 	.word	0x08022c50
 80121fc:	08024c5c 	.word	0x08024c5c

08012200 <rt_device_control>:
 * @param arg the argument of command
 *
 * @return the result
 */
rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
{
 8012200:	b580      	push	{r7, lr}
 8012202:	b084      	sub	sp, #16
 8012204:	af00      	add	r7, sp, #0
 8012206:	60f8      	str	r0, [r7, #12]
 8012208:	460b      	mov	r3, r1
 801220a:	607a      	str	r2, [r7, #4]
 801220c:	72fb      	strb	r3, [r7, #11]
    RT_ASSERT(dev != RT_NULL);
 801220e:	68fb      	ldr	r3, [r7, #12]
 8012210:	2b00      	cmp	r3, #0
 8012212:	d105      	bne.n	8012220 <rt_device_control+0x20>
 8012214:	480b      	ldr	r0, [pc, #44]	; (8012244 <rt_device_control+0x44>)
 8012216:	490c      	ldr	r1, [pc, #48]	; (8012248 <rt_device_control+0x48>)
 8012218:	f44f 72b0 	mov.w	r2, #352	; 0x160
 801221c:	f001 fda2 	bl	8013d64 <rt_assert_handler>

    /* call device write interface */
    if (dev->control != RT_NULL)
 8012220:	68fb      	ldr	r3, [r7, #12]
 8012222:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012224:	2b00      	cmp	r3, #0
 8012226:	d008      	beq.n	801223a <rt_device_control+0x3a>
    {
        return dev->control(dev, cmd, arg);
 8012228:	68fb      	ldr	r3, [r7, #12]
 801222a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801222c:	7afa      	ldrb	r2, [r7, #11]
 801222e:	68f8      	ldr	r0, [r7, #12]
 8012230:	4611      	mov	r1, r2
 8012232:	687a      	ldr	r2, [r7, #4]
 8012234:	4798      	blx	r3
 8012236:	4603      	mov	r3, r0
 8012238:	e000      	b.n	801223c <rt_device_control+0x3c>
    }

    return RT_EOK;
 801223a:	2300      	movs	r3, #0
}
 801223c:	4618      	mov	r0, r3
 801223e:	3710      	adds	r7, #16
 8012240:	46bd      	mov	sp, r7
 8012242:	bd80      	pop	{r7, pc}
 8012244:	08022c50 	.word	0x08022c50
 8012248:	08024c6c 	.word	0x08024c6c

0801224c <rt_device_set_rx_indicate>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_rx_indicate(rt_device_t dev,
                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
{
 801224c:	b580      	push	{r7, lr}
 801224e:	b082      	sub	sp, #8
 8012250:	af00      	add	r7, sp, #0
 8012252:	6078      	str	r0, [r7, #4]
 8012254:	6039      	str	r1, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 8012256:	687b      	ldr	r3, [r7, #4]
 8012258:	2b00      	cmp	r3, #0
 801225a:	d105      	bne.n	8012268 <rt_device_set_rx_indicate+0x1c>
 801225c:	4806      	ldr	r0, [pc, #24]	; (8012278 <rt_device_set_rx_indicate+0x2c>)
 801225e:	4907      	ldr	r1, [pc, #28]	; (801227c <rt_device_set_rx_indicate+0x30>)
 8012260:	f240 1279 	movw	r2, #377	; 0x179
 8012264:	f001 fd7e 	bl	8013d64 <rt_assert_handler>

    dev->rx_indicate = rx_ind;
 8012268:	687b      	ldr	r3, [r7, #4]
 801226a:	683a      	ldr	r2, [r7, #0]
 801226c:	61da      	str	r2, [r3, #28]

    return RT_EOK;
 801226e:	2300      	movs	r3, #0
}
 8012270:	4618      	mov	r0, r3
 8012272:	3708      	adds	r7, #8
 8012274:	46bd      	mov	sp, r7
 8012276:	bd80      	pop	{r7, pc}
 8012278:	08022c50 	.word	0x08022c50
 801227c:	08024c80 	.word	0x08024c80

08012280 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8012280:	b480      	push	{r7}
 8012282:	b083      	sub	sp, #12
 8012284:	af00      	add	r7, sp, #0
 8012286:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8012288:	687b      	ldr	r3, [r7, #4]
 801228a:	681b      	ldr	r3, [r3, #0]
 801228c:	687a      	ldr	r2, [r7, #4]
 801228e:	6852      	ldr	r2, [r2, #4]
 8012290:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8012292:	687b      	ldr	r3, [r7, #4]
 8012294:	685b      	ldr	r3, [r3, #4]
 8012296:	687a      	ldr	r2, [r7, #4]
 8012298:	6812      	ldr	r2, [r2, #0]
 801229a:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 801229c:	687b      	ldr	r3, [r7, #4]
 801229e:	687a      	ldr	r2, [r7, #4]
 80122a0:	605a      	str	r2, [r3, #4]
 80122a2:	687b      	ldr	r3, [r7, #4]
 80122a4:	685a      	ldr	r2, [r3, #4]
 80122a6:	687b      	ldr	r3, [r7, #4]
 80122a8:	601a      	str	r2, [r3, #0]
}
 80122aa:	370c      	adds	r7, #12
 80122ac:	46bd      	mov	sp, r7
 80122ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122b2:	4770      	bx	lr

080122b4 <_has_defunct_thread>:
}
#endif

/* Return whether there is defunctional thread to be deleted. */
rt_inline int _has_defunct_thread(void)
{
 80122b4:	b480      	push	{r7}
 80122b6:	b083      	sub	sp, #12
 80122b8:	af00      	add	r7, sp, #0
     * So the compiler has a good reason that the rt_thread_defunct list does
     * not change within rt_thread_idle_excute thus optimize the "while" loop
     * into a "if".
     *
     * So add the volatile qualifier here. */
    const volatile rt_list_t *l = (const volatile rt_list_t*)&rt_thread_defunct;
 80122ba:	4b08      	ldr	r3, [pc, #32]	; (80122dc <_has_defunct_thread+0x28>)
 80122bc:	607b      	str	r3, [r7, #4]

    return l->next != l;
 80122be:	687b      	ldr	r3, [r7, #4]
 80122c0:	681a      	ldr	r2, [r3, #0]
 80122c2:	687b      	ldr	r3, [r7, #4]
 80122c4:	429a      	cmp	r2, r3
 80122c6:	bf14      	ite	ne
 80122c8:	2301      	movne	r3, #1
 80122ca:	2300      	moveq	r3, #0
 80122cc:	b2db      	uxtb	r3, r3
}
 80122ce:	4618      	mov	r0, r3
 80122d0:	370c      	adds	r7, #12
 80122d2:	46bd      	mov	sp, r7
 80122d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122d8:	4770      	bx	lr
 80122da:	bf00      	nop
 80122dc:	20012684 	.word	0x20012684

080122e0 <rt_thread_idle_excute>:
 * @ingroup Thread
 *
 * This function will perform system background job when system idle.
 */
void rt_thread_idle_excute(void)
{
 80122e0:	b580      	push	{r7, lr}
 80122e2:	b084      	sub	sp, #16
 80122e4:	af00      	add	r7, sp, #0
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
 80122e6:	e045      	b.n	8012374 <rt_thread_idle_excute+0x94>
        rt_base_t lock;
        rt_thread_t thread;
#ifdef RT_USING_MODULE
        rt_module_t module = RT_NULL;
#endif
        RT_DEBUG_NOT_IN_INTERRUPT;
 80122e8:	f7ed ff6e 	bl	80001c8 <rt_hw_interrupt_disable>
 80122ec:	60f8      	str	r0, [r7, #12]
 80122ee:	f000 fedb 	bl	80130a8 <rt_interrupt_get_nest>
 80122f2:	4603      	mov	r3, r0
 80122f4:	2b00      	cmp	r3, #0
 80122f6:	d008      	beq.n	801230a <rt_thread_idle_excute+0x2a>
 80122f8:	4822      	ldr	r0, [pc, #136]	; (8012384 <rt_thread_idle_excute+0xa4>)
 80122fa:	4923      	ldr	r1, [pc, #140]	; (8012388 <rt_thread_idle_excute+0xa8>)
 80122fc:	f001 fcb8 	bl	8013c70 <rt_kprintf>
 8012300:	4822      	ldr	r0, [pc, #136]	; (801238c <rt_thread_idle_excute+0xac>)
 8012302:	4921      	ldr	r1, [pc, #132]	; (8012388 <rt_thread_idle_excute+0xa8>)
 8012304:	225e      	movs	r2, #94	; 0x5e
 8012306:	f001 fd2d 	bl	8013d64 <rt_assert_handler>
 801230a:	68f8      	ldr	r0, [r7, #12]
 801230c:	f7ed ff60 	bl	80001d0 <rt_hw_interrupt_enable>

        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
 8012310:	f7ed ff5a 	bl	80001c8 <rt_hw_interrupt_disable>
 8012314:	60b8      	str	r0, [r7, #8]

        /* re-check whether list is empty */
        if (_has_defunct_thread())
 8012316:	f7ff ffcd 	bl	80122b4 <_has_defunct_thread>
 801231a:	4603      	mov	r3, r0
 801231c:	2b00      	cmp	r3, #0
 801231e:	d01a      	beq.n	8012356 <rt_thread_idle_excute+0x76>
        {
            /* get defunct thread */
            thread = rt_list_entry(rt_thread_defunct.next,
 8012320:	4b1b      	ldr	r3, [pc, #108]	; (8012390 <rt_thread_idle_excute+0xb0>)
 8012322:	681b      	ldr	r3, [r3, #0]
 8012324:	3b14      	subs	r3, #20
 8012326:	607b      	str	r3, [r7, #4]
                /* detach module's main thread */
                module->module_thread = RT_NULL;
            }
#endif
            /* remove defunct thread */
            rt_list_remove(&(thread->tlist));
 8012328:	687b      	ldr	r3, [r7, #4]
 801232a:	3314      	adds	r3, #20
 801232c:	4618      	mov	r0, r3
 801232e:	f7ff ffa7 	bl	8012280 <rt_list_remove>
            /* invoke thread cleanup */
            if (thread->cleanup != RT_NULL)
 8012332:	687b      	ldr	r3, [r7, #4]
 8012334:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8012336:	2b00      	cmp	r3, #0
 8012338:	d003      	beq.n	8012342 <rt_thread_idle_excute+0x62>
                thread->cleanup(thread);
 801233a:	687b      	ldr	r3, [r7, #4]
 801233c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801233e:	6878      	ldr	r0, [r7, #4]
 8012340:	4798      	blx	r3

            /* if it's a system object, not delete it */
            if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
 8012342:	6878      	ldr	r0, [r7, #4]
 8012344:	f002 fae2 	bl	801490c <rt_object_is_systemobject>
 8012348:	4603      	mov	r3, r0
 801234a:	2b01      	cmp	r3, #1
 801234c:	d107      	bne.n	801235e <rt_thread_idle_excute+0x7e>
            {
                /* enable interrupt */
                rt_hw_interrupt_enable(lock);
 801234e:	68b8      	ldr	r0, [r7, #8]
 8012350:	f7ed ff3e 	bl	80001d0 <rt_hw_interrupt_enable>

                return;
 8012354:	e013      	b.n	801237e <rt_thread_idle_excute+0x9e>
            }
        }
        else
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(lock);
 8012356:	68b8      	ldr	r0, [r7, #8]
 8012358:	f7ed ff3a 	bl	80001d0 <rt_hw_interrupt_enable>

            /* may the defunct thread list is removed by others, just return */
            return;
 801235c:	e00f      	b.n	801237e <rt_thread_idle_excute+0x9e>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
 801235e:	68b8      	ldr	r0, [r7, #8]
 8012360:	f7ed ff36 	bl	80001d0 <rt_hw_interrupt_enable>
        if (thread->flags & RT_OBJECT_FLAG_MODULE)
            rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
        else
#endif
        /* release thread's stack */
        RT_KERNEL_FREE(thread->stack_addr);
 8012364:	687b      	ldr	r3, [r7, #4]
 8012366:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012368:	4618      	mov	r0, r3
 801236a:	f002 f839 	bl	80143e0 <rt_free>
        /* delete thread object */
        rt_object_delete((rt_object_t)thread);
 801236e:	6878      	ldr	r0, [r7, #4]
 8012370:	f002 fa92 	bl	8014898 <rt_object_delete>
 */
void rt_thread_idle_excute(void)
{
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
 8012374:	f7ff ff9e 	bl	80122b4 <_has_defunct_thread>
 8012378:	4603      	mov	r3, r0
 801237a:	2b00      	cmp	r3, #0
 801237c:	d1b4      	bne.n	80122e8 <rt_thread_idle_excute+0x8>
            if (module->nref == 0)
                rt_module_destroy(module);
        }
#endif
    }
}
 801237e:	3710      	adds	r7, #16
 8012380:	46bd      	mov	sp, r7
 8012382:	bd80      	pop	{r7, pc}
 8012384:	08022cac 	.word	0x08022cac
 8012388:	08024c9c 	.word	0x08024c9c
 801238c:	08022cd0 	.word	0x08022cd0
 8012390:	20012684 	.word	0x20012684

08012394 <rt_thread_idle_entry>:

static void rt_thread_idle_entry(void *parameter)
{
 8012394:	b580      	push	{r7, lr}
 8012396:	b082      	sub	sp, #8
 8012398:	af00      	add	r7, sp, #0
 801239a:	6078      	str	r0, [r7, #4]
    while (1)
    {
        #ifdef RT_USING_HOOK
        if (rt_thread_idle_hook != RT_NULL)
 801239c:	4b04      	ldr	r3, [pc, #16]	; (80123b0 <rt_thread_idle_entry+0x1c>)
 801239e:	681b      	ldr	r3, [r3, #0]
 80123a0:	2b00      	cmp	r3, #0
 80123a2:	d002      	beq.n	80123aa <rt_thread_idle_entry+0x16>
            rt_thread_idle_hook();
 80123a4:	4b02      	ldr	r3, [pc, #8]	; (80123b0 <rt_thread_idle_entry+0x1c>)
 80123a6:	681b      	ldr	r3, [r3, #0]
 80123a8:	4798      	blx	r3
        #endif

        rt_thread_idle_excute();
 80123aa:	f7ff ff99 	bl	80122e0 <rt_thread_idle_excute>
    }
 80123ae:	e7f5      	b.n	801239c <rt_thread_idle_entry+0x8>
 80123b0:	20010d0c 	.word	0x20010d0c

080123b4 <rt_thread_idle_init>:
 * This function will initialize idle thread, then start it.
 *
 * @note this function must be invoked when system init.
 */
void rt_thread_idle_init(void)
{
 80123b4:	b580      	push	{r7, lr}
 80123b6:	b084      	sub	sp, #16
 80123b8:	af04      	add	r7, sp, #16
    /* initialize thread */
    rt_thread_init(&idle,
 80123ba:	4b0a      	ldr	r3, [pc, #40]	; (80123e4 <rt_thread_idle_init+0x30>)
 80123bc:	9300      	str	r3, [sp, #0]
 80123be:	f44f 7300 	mov.w	r3, #512	; 0x200
 80123c2:	9301      	str	r3, [sp, #4]
 80123c4:	231f      	movs	r3, #31
 80123c6:	9302      	str	r3, [sp, #8]
 80123c8:	2320      	movs	r3, #32
 80123ca:	9303      	str	r3, [sp, #12]
 80123cc:	4806      	ldr	r0, [pc, #24]	; (80123e8 <rt_thread_idle_init+0x34>)
 80123ce:	4907      	ldr	r1, [pc, #28]	; (80123ec <rt_thread_idle_init+0x38>)
 80123d0:	4a07      	ldr	r2, [pc, #28]	; (80123f0 <rt_thread_idle_init+0x3c>)
 80123d2:	2300      	movs	r3, #0
 80123d4:	f002 fda0 	bl	8014f18 <rt_thread_init>
                   sizeof(rt_thread_stack),
                   RT_THREAD_PRIORITY_MAX - 1,
                   32);

    /* startup */
    rt_thread_startup(&idle);
 80123d8:	4803      	ldr	r0, [pc, #12]	; (80123e8 <rt_thread_idle_init+0x34>)
 80123da:	f002 fddf 	bl	8014f9c <rt_thread_startup>
}
 80123de:	46bd      	mov	sp, r7
 80123e0:	bd80      	pop	{r7, pc}
 80123e2:	bf00      	nop
 80123e4:	20010b0c 	.word	0x20010b0c
 80123e8:	20010a8c 	.word	0x20010a8c
 80123ec:	08022cd4 	.word	0x08022cd4
 80123f0:	08012395 	.word	0x08012395

080123f4 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 80123f4:	b480      	push	{r7}
 80123f6:	b083      	sub	sp, #12
 80123f8:	af00      	add	r7, sp, #0
 80123fa:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 80123fc:	687b      	ldr	r3, [r7, #4]
 80123fe:	687a      	ldr	r2, [r7, #4]
 8012400:	605a      	str	r2, [r3, #4]
 8012402:	687b      	ldr	r3, [r7, #4]
 8012404:	685a      	ldr	r2, [r3, #4]
 8012406:	687b      	ldr	r3, [r7, #4]
 8012408:	601a      	str	r2, [r3, #0]
}
 801240a:	370c      	adds	r7, #12
 801240c:	46bd      	mov	sp, r7
 801240e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012412:	4770      	bx	lr

08012414 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8012414:	b480      	push	{r7}
 8012416:	b083      	sub	sp, #12
 8012418:	af00      	add	r7, sp, #0
 801241a:	6078      	str	r0, [r7, #4]
 801241c:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 801241e:	687b      	ldr	r3, [r7, #4]
 8012420:	685b      	ldr	r3, [r3, #4]
 8012422:	683a      	ldr	r2, [r7, #0]
 8012424:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8012426:	687b      	ldr	r3, [r7, #4]
 8012428:	685a      	ldr	r2, [r3, #4]
 801242a:	683b      	ldr	r3, [r7, #0]
 801242c:	605a      	str	r2, [r3, #4]

    l->prev = n;
 801242e:	687b      	ldr	r3, [r7, #4]
 8012430:	683a      	ldr	r2, [r7, #0]
 8012432:	605a      	str	r2, [r3, #4]
    n->next = l;
 8012434:	683b      	ldr	r3, [r7, #0]
 8012436:	687a      	ldr	r2, [r7, #4]
 8012438:	601a      	str	r2, [r3, #0]
}
 801243a:	370c      	adds	r7, #12
 801243c:	46bd      	mov	sp, r7
 801243e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012442:	4770      	bx	lr

08012444 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8012444:	b480      	push	{r7}
 8012446:	b083      	sub	sp, #12
 8012448:	af00      	add	r7, sp, #0
 801244a:	6078      	str	r0, [r7, #4]
    return l->next == l;
 801244c:	687b      	ldr	r3, [r7, #4]
 801244e:	681a      	ldr	r2, [r3, #0]
 8012450:	687b      	ldr	r3, [r7, #4]
 8012452:	429a      	cmp	r2, r3
 8012454:	bf0c      	ite	eq
 8012456:	2301      	moveq	r3, #1
 8012458:	2300      	movne	r3, #0
 801245a:	b2db      	uxtb	r3, r3
}
 801245c:	4618      	mov	r0, r3
 801245e:	370c      	adds	r7, #12
 8012460:	46bd      	mov	sp, r7
 8012462:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012466:	4770      	bx	lr

08012468 <rt_ipc_object_init>:
 * @param ipc the IPC object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
{
 8012468:	b580      	push	{r7, lr}
 801246a:	b082      	sub	sp, #8
 801246c:	af00      	add	r7, sp, #0
 801246e:	6078      	str	r0, [r7, #4]
    /* init ipc object */
    rt_list_init(&(ipc->suspend_thread));
 8012470:	687b      	ldr	r3, [r7, #4]
 8012472:	3314      	adds	r3, #20
 8012474:	4618      	mov	r0, r3
 8012476:	f7ff ffbd 	bl	80123f4 <rt_list_init>

    return RT_EOK;
 801247a:	2300      	movs	r3, #0
}
 801247c:	4618      	mov	r0, r3
 801247e:	3708      	adds	r7, #8
 8012480:	46bd      	mov	sp, r7
 8012482:	bd80      	pop	{r7, pc}

08012484 <rt_ipc_list_suspend>:
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
                                       struct rt_thread *thread,
                                       rt_uint8_t        flag)
{
 8012484:	b580      	push	{r7, lr}
 8012486:	b086      	sub	sp, #24
 8012488:	af00      	add	r7, sp, #0
 801248a:	60f8      	str	r0, [r7, #12]
 801248c:	60b9      	str	r1, [r7, #8]
 801248e:	4613      	mov	r3, r2
 8012490:	71fb      	strb	r3, [r7, #7]
    /* suspend thread */
    rt_thread_suspend(thread);
 8012492:	68b8      	ldr	r0, [r7, #8]
 8012494:	f002 fefc 	bl	8015290 <rt_thread_suspend>

    switch (flag)
 8012498:	79fb      	ldrb	r3, [r7, #7]
 801249a:	2b00      	cmp	r3, #0
 801249c:	d002      	beq.n	80124a4 <rt_ipc_list_suspend+0x20>
 801249e:	2b01      	cmp	r3, #1
 80124a0:	d007      	beq.n	80124b2 <rt_ipc_list_suspend+0x2e>
 80124a2:	e032      	b.n	801250a <rt_ipc_list_suspend+0x86>
    {
    case RT_IPC_FLAG_FIFO:
        rt_list_insert_before(list, &(thread->tlist));
 80124a4:	68bb      	ldr	r3, [r7, #8]
 80124a6:	3314      	adds	r3, #20
 80124a8:	68f8      	ldr	r0, [r7, #12]
 80124aa:	4619      	mov	r1, r3
 80124ac:	f7ff ffb2 	bl	8012414 <rt_list_insert_before>
        break;
 80124b0:	e02b      	b.n	801250a <rt_ipc_list_suspend+0x86>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
 80124b2:	68fb      	ldr	r3, [r7, #12]
 80124b4:	681b      	ldr	r3, [r3, #0]
 80124b6:	617b      	str	r3, [r7, #20]
 80124b8:	e017      	b.n	80124ea <rt_ipc_list_suspend+0x66>
            {
                sthread = rt_list_entry(n, struct rt_thread, tlist);
 80124ba:	697b      	ldr	r3, [r7, #20]
 80124bc:	3b14      	subs	r3, #20
 80124be:	613b      	str	r3, [r7, #16]

                /* find out */
                if (thread->current_priority < sthread->current_priority)
 80124c0:	68bb      	ldr	r3, [r7, #8]
 80124c2:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 80124c6:	693b      	ldr	r3, [r7, #16]
 80124c8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80124cc:	429a      	cmp	r2, r3
 80124ce:	d209      	bcs.n	80124e4 <rt_ipc_list_suspend+0x60>
                {
                    /* insert this thread before the sthread */
                    rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
 80124d0:	693b      	ldr	r3, [r7, #16]
 80124d2:	f103 0214 	add.w	r2, r3, #20
 80124d6:	68bb      	ldr	r3, [r7, #8]
 80124d8:	3314      	adds	r3, #20
 80124da:	4610      	mov	r0, r2
 80124dc:	4619      	mov	r1, r3
 80124de:	f7ff ff99 	bl	8012414 <rt_list_insert_before>
                    break;
 80124e2:	e006      	b.n	80124f2 <rt_ipc_list_suspend+0x6e>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
 80124e4:	697b      	ldr	r3, [r7, #20]
 80124e6:	681b      	ldr	r3, [r3, #0]
 80124e8:	617b      	str	r3, [r7, #20]
 80124ea:	697a      	ldr	r2, [r7, #20]
 80124ec:	68fb      	ldr	r3, [r7, #12]
 80124ee:	429a      	cmp	r2, r3
 80124f0:	d1e3      	bne.n	80124ba <rt_ipc_list_suspend+0x36>

            /*
             * not found a suitable position,
             * append to the end of suspend_thread list
             */
            if (n == list)
 80124f2:	697a      	ldr	r2, [r7, #20]
 80124f4:	68fb      	ldr	r3, [r7, #12]
 80124f6:	429a      	cmp	r2, r3
 80124f8:	d106      	bne.n	8012508 <rt_ipc_list_suspend+0x84>
                rt_list_insert_before(list, &(thread->tlist));
 80124fa:	68bb      	ldr	r3, [r7, #8]
 80124fc:	3314      	adds	r3, #20
 80124fe:	68f8      	ldr	r0, [r7, #12]
 8012500:	4619      	mov	r1, r3
 8012502:	f7ff ff87 	bl	8012414 <rt_list_insert_before>
        }
        break;
 8012506:	e7ff      	b.n	8012508 <rt_ipc_list_suspend+0x84>
 8012508:	bf00      	nop
    }

    return RT_EOK;
 801250a:	2300      	movs	r3, #0
}
 801250c:	4618      	mov	r0, r3
 801250e:	3718      	adds	r7, #24
 8012510:	46bd      	mov	sp, r7
 8012512:	bd80      	pop	{r7, pc}

08012514 <rt_ipc_list_resume>:
 * @param list the thread list
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
{
 8012514:	b580      	push	{r7, lr}
 8012516:	b084      	sub	sp, #16
 8012518:	af00      	add	r7, sp, #0
 801251a:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;

    /* get thread entry */
    thread = rt_list_entry(list->next, struct rt_thread, tlist);
 801251c:	687b      	ldr	r3, [r7, #4]
 801251e:	681b      	ldr	r3, [r3, #0]
 8012520:	3b14      	subs	r3, #20
 8012522:	60fb      	str	r3, [r7, #12]

    RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));

    /* resume it */
    rt_thread_resume(thread);
 8012524:	68f8      	ldr	r0, [r7, #12]
 8012526:	f002 fee3 	bl	80152f0 <rt_thread_resume>

    return RT_EOK;
 801252a:	2300      	movs	r3, #0
}
 801252c:	4618      	mov	r0, r3
 801252e:	3710      	adds	r7, #16
 8012530:	46bd      	mov	sp, r7
 8012532:	bd80      	pop	{r7, pc}

08012534 <rt_ipc_list_resume_all>:
 * @param list of the threads to resume
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
{
 8012534:	b590      	push	{r4, r7, lr}
 8012536:	b085      	sub	sp, #20
 8012538:	af00      	add	r7, sp, #0
 801253a:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
 801253c:	e012      	b.n	8012564 <rt_ipc_list_resume_all+0x30>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 801253e:	f7ed fe43 	bl	80001c8 <rt_hw_interrupt_disable>
 8012542:	4603      	mov	r3, r0
 8012544:	461c      	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(list->next, struct rt_thread, tlist);
 8012546:	687b      	ldr	r3, [r7, #4]
 8012548:	681b      	ldr	r3, [r3, #0]
 801254a:	3b14      	subs	r3, #20
 801254c:	60fb      	str	r3, [r7, #12]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
 801254e:	68fb      	ldr	r3, [r7, #12]
 8012550:	f04f 32ff 	mov.w	r2, #4294967295
 8012554:	631a      	str	r2, [r3, #48]	; 0x30
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
 8012556:	68f8      	ldr	r0, [r7, #12]
 8012558:	f002 feca 	bl	80152f0 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 801255c:	4623      	mov	r3, r4
 801255e:	4618      	mov	r0, r3
 8012560:	f7ed fe36 	bl	80001d0 <rt_hw_interrupt_enable>
{
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
 8012564:	6878      	ldr	r0, [r7, #4]
 8012566:	f7ff ff6d 	bl	8012444 <rt_list_isempty>
 801256a:	4603      	mov	r3, r0
 801256c:	2b00      	cmp	r3, #0
 801256e:	d0e6      	beq.n	801253e <rt_ipc_list_resume_all+0xa>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    return RT_EOK;
 8012570:	2300      	movs	r3, #0
}
 8012572:	4618      	mov	r0, r3
 8012574:	3714      	adds	r7, #20
 8012576:	46bd      	mov	sp, r7
 8012578:	bd90      	pop	{r4, r7, pc}
 801257a:	bf00      	nop

0801257c <rt_sem_init>:
 */
rt_err_t rt_sem_init(rt_sem_t    sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
{
 801257c:	b580      	push	{r7, lr}
 801257e:	b084      	sub	sp, #16
 8012580:	af00      	add	r7, sp, #0
 8012582:	60f8      	str	r0, [r7, #12]
 8012584:	60b9      	str	r1, [r7, #8]
 8012586:	607a      	str	r2, [r7, #4]
 8012588:	70fb      	strb	r3, [r7, #3]
    RT_ASSERT(sem != RT_NULL);
 801258a:	68fb      	ldr	r3, [r7, #12]
 801258c:	2b00      	cmp	r3, #0
 801258e:	d104      	bne.n	801259a <rt_sem_init+0x1e>
 8012590:	480d      	ldr	r0, [pc, #52]	; (80125c8 <rt_sem_init+0x4c>)
 8012592:	490e      	ldr	r1, [pc, #56]	; (80125cc <rt_sem_init+0x50>)
 8012594:	22d8      	movs	r2, #216	; 0xd8
 8012596:	f001 fbe5 	bl	8013d64 <rt_assert_handler>

    /* init object */
    rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
 801259a:	68fb      	ldr	r3, [r7, #12]
 801259c:	4618      	mov	r0, r3
 801259e:	2101      	movs	r1, #1
 80125a0:	68ba      	ldr	r2, [r7, #8]
 80125a2:	f002 f8bf 	bl	8014724 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
 80125a6:	68fb      	ldr	r3, [r7, #12]
 80125a8:	4618      	mov	r0, r3
 80125aa:	f7ff ff5d 	bl	8012468 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
 80125ae:	687b      	ldr	r3, [r7, #4]
 80125b0:	b29a      	uxth	r2, r3
 80125b2:	68fb      	ldr	r3, [r7, #12]
 80125b4:	839a      	strh	r2, [r3, #28]

    /* set parent */
    sem->parent.parent.flag = flag;
 80125b6:	68fb      	ldr	r3, [r7, #12]
 80125b8:	78fa      	ldrb	r2, [r7, #3]
 80125ba:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 80125bc:	2300      	movs	r3, #0
}
 80125be:	4618      	mov	r0, r3
 80125c0:	3710      	adds	r7, #16
 80125c2:	46bd      	mov	sp, r7
 80125c4:	bd80      	pop	{r7, pc}
 80125c6:	bf00      	nop
 80125c8:	08022cdc 	.word	0x08022cdc
 80125cc:	08024cb4 	.word	0x08024cb4

080125d0 <rt_sem_create>:
 * @return the created semaphore, RT_NULL on error happen
 *
 * @see rt_sem_init
 */
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
{
 80125d0:	b580      	push	{r7, lr}
 80125d2:	b086      	sub	sp, #24
 80125d4:	af00      	add	r7, sp, #0
 80125d6:	60f8      	str	r0, [r7, #12]
 80125d8:	60b9      	str	r1, [r7, #8]
 80125da:	4613      	mov	r3, r2
 80125dc:	71fb      	strb	r3, [r7, #7]
    rt_sem_t sem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 80125de:	f7ed fdf3 	bl	80001c8 <rt_hw_interrupt_disable>
 80125e2:	6178      	str	r0, [r7, #20]
 80125e4:	f000 fd60 	bl	80130a8 <rt_interrupt_get_nest>
 80125e8:	4603      	mov	r3, r0
 80125ea:	2b00      	cmp	r3, #0
 80125ec:	d009      	beq.n	8012602 <rt_sem_create+0x32>
 80125ee:	4813      	ldr	r0, [pc, #76]	; (801263c <rt_sem_create+0x6c>)
 80125f0:	4913      	ldr	r1, [pc, #76]	; (8012640 <rt_sem_create+0x70>)
 80125f2:	f001 fb3d 	bl	8013c70 <rt_kprintf>
 80125f6:	4813      	ldr	r0, [pc, #76]	; (8012644 <rt_sem_create+0x74>)
 80125f8:	4911      	ldr	r1, [pc, #68]	; (8012640 <rt_sem_create+0x70>)
 80125fa:	f240 1211 	movw	r2, #273	; 0x111
 80125fe:	f001 fbb1 	bl	8013d64 <rt_assert_handler>
 8012602:	6978      	ldr	r0, [r7, #20]
 8012604:	f7ed fde4 	bl	80001d0 <rt_hw_interrupt_enable>

    /* allocate object */
    sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
 8012608:	2001      	movs	r0, #1
 801260a:	68f9      	ldr	r1, [r7, #12]
 801260c:	f002 f8e8 	bl	80147e0 <rt_object_allocate>
 8012610:	6138      	str	r0, [r7, #16]
    if (sem == RT_NULL)
 8012612:	693b      	ldr	r3, [r7, #16]
 8012614:	2b00      	cmp	r3, #0
 8012616:	d101      	bne.n	801261c <rt_sem_create+0x4c>
        return sem;
 8012618:	693b      	ldr	r3, [r7, #16]
 801261a:	e00b      	b.n	8012634 <rt_sem_create+0x64>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
 801261c:	693b      	ldr	r3, [r7, #16]
 801261e:	4618      	mov	r0, r3
 8012620:	f7ff ff22 	bl	8012468 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
 8012624:	68bb      	ldr	r3, [r7, #8]
 8012626:	b29a      	uxth	r2, r3
 8012628:	693b      	ldr	r3, [r7, #16]
 801262a:	839a      	strh	r2, [r3, #28]

    /* set parent */
    sem->parent.parent.flag = flag;
 801262c:	693b      	ldr	r3, [r7, #16]
 801262e:	79fa      	ldrb	r2, [r7, #7]
 8012630:	725a      	strb	r2, [r3, #9]

    return sem;
 8012632:	693b      	ldr	r3, [r7, #16]
}
 8012634:	4618      	mov	r0, r3
 8012636:	3718      	adds	r7, #24
 8012638:	46bd      	mov	sp, r7
 801263a:	bd80      	pop	{r7, pc}
 801263c:	08022cec 	.word	0x08022cec
 8012640:	08024cc0 	.word	0x08024cc0
 8012644:	08022d10 	.word	0x08022d10

08012648 <rt_sem_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
{
 8012648:	b590      	push	{r4, r7, lr}
 801264a:	b087      	sub	sp, #28
 801264c:	af00      	add	r7, sp, #0
 801264e:	6078      	str	r0, [r7, #4]
 8012650:	6039      	str	r1, [r7, #0]
    register rt_base_t temp;
    struct rt_thread *thread;

    RT_ASSERT(sem != RT_NULL);
 8012652:	687b      	ldr	r3, [r7, #4]
 8012654:	2b00      	cmp	r3, #0
 8012656:	d105      	bne.n	8012664 <rt_sem_take+0x1c>
 8012658:	4846      	ldr	r0, [pc, #280]	; (8012774 <rt_sem_take+0x12c>)
 801265a:	4947      	ldr	r1, [pc, #284]	; (8012778 <rt_sem_take+0x130>)
 801265c:	f240 124d 	movw	r2, #333	; 0x14d
 8012660:	f001 fb80 	bl	8013d64 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
 8012664:	4b45      	ldr	r3, [pc, #276]	; (801277c <rt_sem_take+0x134>)
 8012666:	681b      	ldr	r3, [r3, #0]
 8012668:	2b00      	cmp	r3, #0
 801266a:	d004      	beq.n	8012676 <rt_sem_take+0x2e>
 801266c:	4b43      	ldr	r3, [pc, #268]	; (801277c <rt_sem_take+0x134>)
 801266e:	681b      	ldr	r3, [r3, #0]
 8012670:	687a      	ldr	r2, [r7, #4]
 8012672:	4610      	mov	r0, r2
 8012674:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8012676:	f7ed fda7 	bl	80001c8 <rt_hw_interrupt_disable>
 801267a:	4604      	mov	r4, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (sem->value > 0)
 801267c:	687b      	ldr	r3, [r7, #4]
 801267e:	8b9b      	ldrh	r3, [r3, #28]
 8012680:	2b00      	cmp	r3, #0
 8012682:	d009      	beq.n	8012698 <rt_sem_take+0x50>
    {
        /* semaphore is available */
        sem->value --;
 8012684:	687b      	ldr	r3, [r7, #4]
 8012686:	8b9b      	ldrh	r3, [r3, #28]
 8012688:	3b01      	subs	r3, #1
 801268a:	b29a      	uxth	r2, r3
 801268c:	687b      	ldr	r3, [r7, #4]
 801268e:	839a      	strh	r2, [r3, #28]

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8012690:	4620      	mov	r0, r4
 8012692:	f7ed fd9d 	bl	80001d0 <rt_hw_interrupt_enable>
 8012696:	e05f      	b.n	8012758 <rt_sem_take+0x110>
    }
    else
    {
        /* no waiting, return with timeout */
        if (time == 0)
 8012698:	683b      	ldr	r3, [r7, #0]
 801269a:	2b00      	cmp	r3, #0
 801269c:	d105      	bne.n	80126aa <rt_sem_take+0x62>
        {
            rt_hw_interrupt_enable(temp);
 801269e:	4620      	mov	r0, r4
 80126a0:	f7ed fd96 	bl	80001d0 <rt_hw_interrupt_enable>

            return -RT_ETIMEOUT;
 80126a4:	f06f 0301 	mvn.w	r3, #1
 80126a8:	e060      	b.n	801276c <rt_sem_take+0x124>
        }
        else
        {
            /* current context checking */
            RT_DEBUG_IN_THREAD_CONTEXT;
 80126aa:	f7ed fd8d 	bl	80001c8 <rt_hw_interrupt_disable>
 80126ae:	6178      	str	r0, [r7, #20]
 80126b0:	f002 fc68 	bl	8014f84 <rt_thread_self>
 80126b4:	4603      	mov	r3, r0
 80126b6:	2b00      	cmp	r3, #0
 80126b8:	d109      	bne.n	80126ce <rt_sem_take+0x86>
 80126ba:	4831      	ldr	r0, [pc, #196]	; (8012780 <rt_sem_take+0x138>)
 80126bc:	492e      	ldr	r1, [pc, #184]	; (8012778 <rt_sem_take+0x130>)
 80126be:	f001 fad7 	bl	8013c70 <rt_kprintf>
 80126c2:	4830      	ldr	r0, [pc, #192]	; (8012784 <rt_sem_take+0x13c>)
 80126c4:	492c      	ldr	r1, [pc, #176]	; (8012778 <rt_sem_take+0x130>)
 80126c6:	f240 126d 	movw	r2, #365	; 0x16d
 80126ca:	f001 fb4b 	bl	8013d64 <rt_assert_handler>
 80126ce:	f7ed fd7b 	bl	80001c8 <rt_hw_interrupt_disable>
 80126d2:	6138      	str	r0, [r7, #16]
 80126d4:	f000 fce8 	bl	80130a8 <rt_interrupt_get_nest>
 80126d8:	4603      	mov	r3, r0
 80126da:	2b00      	cmp	r3, #0
 80126dc:	d009      	beq.n	80126f2 <rt_sem_take+0xaa>
 80126de:	482a      	ldr	r0, [pc, #168]	; (8012788 <rt_sem_take+0x140>)
 80126e0:	4925      	ldr	r1, [pc, #148]	; (8012778 <rt_sem_take+0x130>)
 80126e2:	f001 fac5 	bl	8013c70 <rt_kprintf>
 80126e6:	4827      	ldr	r0, [pc, #156]	; (8012784 <rt_sem_take+0x13c>)
 80126e8:	4923      	ldr	r1, [pc, #140]	; (8012778 <rt_sem_take+0x130>)
 80126ea:	f240 126d 	movw	r2, #365	; 0x16d
 80126ee:	f001 fb39 	bl	8013d64 <rt_assert_handler>
 80126f2:	6938      	ldr	r0, [r7, #16]
 80126f4:	f7ed fd6c 	bl	80001d0 <rt_hw_interrupt_enable>
 80126f8:	6978      	ldr	r0, [r7, #20]
 80126fa:	f7ed fd69 	bl	80001d0 <rt_hw_interrupt_enable>

            /* semaphore is unavailable, push to suspend list */
            /* get current thread */
            thread = rt_thread_self();
 80126fe:	f002 fc41 	bl	8014f84 <rt_thread_self>
 8012702:	60f8      	str	r0, [r7, #12]

            /* reset thread error number */
            thread->error = RT_EOK;
 8012704:	68fb      	ldr	r3, [r7, #12]
 8012706:	2200      	movs	r2, #0
 8012708:	631a      	str	r2, [r3, #48]	; 0x30

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
                                        thread->name));

            /* suspend thread */
            rt_ipc_list_suspend(&(sem->parent.suspend_thread),
 801270a:	687b      	ldr	r3, [r7, #4]
 801270c:	f103 0214 	add.w	r2, r3, #20
 8012710:	687b      	ldr	r3, [r7, #4]
 8012712:	7a5b      	ldrb	r3, [r3, #9]
 8012714:	4610      	mov	r0, r2
 8012716:	68f9      	ldr	r1, [r7, #12]
 8012718:	461a      	mov	r2, r3
 801271a:	f7ff feb3 	bl	8012484 <rt_ipc_list_suspend>
                                thread,
                                sem->parent.parent.flag);

            /* has waiting time, start thread timer */
            if (time > 0)
 801271e:	683b      	ldr	r3, [r7, #0]
 8012720:	2b00      	cmp	r3, #0
 8012722:	dd0d      	ble.n	8012740 <rt_sem_take+0xf8>
            {
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                            thread->name));

                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
 8012724:	68fb      	ldr	r3, [r7, #12]
 8012726:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 801272a:	463b      	mov	r3, r7
 801272c:	4610      	mov	r0, r2
 801272e:	2100      	movs	r1, #0
 8012730:	461a      	mov	r2, r3
 8012732:	f003 f8a7 	bl	8015884 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &time);
                rt_timer_start(&(thread->thread_timer));
 8012736:	68fb      	ldr	r3, [r7, #12]
 8012738:	334c      	adds	r3, #76	; 0x4c
 801273a:	4618      	mov	r0, r3
 801273c:	f002 ff5c 	bl	80155f8 <rt_timer_start>
            }

            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
 8012740:	4620      	mov	r0, r4
 8012742:	f7ed fd45 	bl	80001d0 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
 8012746:	f002 f9e1 	bl	8014b0c <rt_schedule>

            if (thread->error != RT_EOK)
 801274a:	68fb      	ldr	r3, [r7, #12]
 801274c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801274e:	2b00      	cmp	r3, #0
 8012750:	d002      	beq.n	8012758 <rt_sem_take+0x110>
            {
                return thread->error;
 8012752:	68fb      	ldr	r3, [r7, #12]
 8012754:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012756:	e009      	b.n	801276c <rt_sem_take+0x124>
            }
        }
    }

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
 8012758:	4b0c      	ldr	r3, [pc, #48]	; (801278c <rt_sem_take+0x144>)
 801275a:	681b      	ldr	r3, [r3, #0]
 801275c:	2b00      	cmp	r3, #0
 801275e:	d004      	beq.n	801276a <rt_sem_take+0x122>
 8012760:	4b0a      	ldr	r3, [pc, #40]	; (801278c <rt_sem_take+0x144>)
 8012762:	681b      	ldr	r3, [r3, #0]
 8012764:	687a      	ldr	r2, [r7, #4]
 8012766:	4610      	mov	r0, r2
 8012768:	4798      	blx	r3

    return RT_EOK;
 801276a:	2300      	movs	r3, #0
}
 801276c:	4618      	mov	r0, r3
 801276e:	371c      	adds	r7, #28
 8012770:	46bd      	mov	sp, r7
 8012772:	bd90      	pop	{r4, r7, pc}
 8012774:	08022cdc 	.word	0x08022cdc
 8012778:	08024cd0 	.word	0x08024cd0
 801277c:	20012574 	.word	0x20012574
 8012780:	08022d14 	.word	0x08022d14
 8012784:	08022d10 	.word	0x08022d10
 8012788:	08022cec 	.word	0x08022cec
 801278c:	20012570 	.word	0x20012570

08012790 <rt_sem_release>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_release(rt_sem_t sem)
{
 8012790:	b5b0      	push	{r4, r5, r7, lr}
 8012792:	b082      	sub	sp, #8
 8012794:	af00      	add	r7, sp, #0
 8012796:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    register rt_bool_t need_schedule;

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
 8012798:	4b16      	ldr	r3, [pc, #88]	; (80127f4 <rt_sem_release+0x64>)
 801279a:	681b      	ldr	r3, [r3, #0]
 801279c:	2b00      	cmp	r3, #0
 801279e:	d004      	beq.n	80127aa <rt_sem_release+0x1a>
 80127a0:	4b14      	ldr	r3, [pc, #80]	; (80127f4 <rt_sem_release+0x64>)
 80127a2:	681b      	ldr	r3, [r3, #0]
 80127a4:	687a      	ldr	r2, [r7, #4]
 80127a6:	4610      	mov	r0, r2
 80127a8:	4798      	blx	r3

    need_schedule = RT_FALSE;
 80127aa:	2400      	movs	r4, #0

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80127ac:	f7ed fd0c 	bl	80001c8 <rt_hw_interrupt_disable>
 80127b0:	4605      	mov	r5, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (!rt_list_isempty(&sem->parent.suspend_thread))
 80127b2:	687b      	ldr	r3, [r7, #4]
 80127b4:	3314      	adds	r3, #20
 80127b6:	4618      	mov	r0, r3
 80127b8:	f7ff fe44 	bl	8012444 <rt_list_isempty>
 80127bc:	4603      	mov	r3, r0
 80127be:	2b00      	cmp	r3, #0
 80127c0:	d106      	bne.n	80127d0 <rt_sem_release+0x40>
    {
        /* resume the suspended thread */
        rt_ipc_list_resume(&(sem->parent.suspend_thread));
 80127c2:	687b      	ldr	r3, [r7, #4]
 80127c4:	3314      	adds	r3, #20
 80127c6:	4618      	mov	r0, r3
 80127c8:	f7ff fea4 	bl	8012514 <rt_ipc_list_resume>
        need_schedule = RT_TRUE;
 80127cc:	2401      	movs	r4, #1
 80127ce:	e005      	b.n	80127dc <rt_sem_release+0x4c>
    }
    else
        sem->value ++; /* increase value */
 80127d0:	687b      	ldr	r3, [r7, #4]
 80127d2:	8b9b      	ldrh	r3, [r3, #28]
 80127d4:	3301      	adds	r3, #1
 80127d6:	b29a      	uxth	r2, r3
 80127d8:	687b      	ldr	r3, [r7, #4]
 80127da:	839a      	strh	r2, [r3, #28]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 80127dc:	4628      	mov	r0, r5
 80127de:	f7ed fcf7 	bl	80001d0 <rt_hw_interrupt_enable>

    /* resume a thread, re-schedule */
    if (need_schedule == RT_TRUE)
 80127e2:	2c01      	cmp	r4, #1
 80127e4:	d101      	bne.n	80127ea <rt_sem_release+0x5a>
        rt_schedule();
 80127e6:	f002 f991 	bl	8014b0c <rt_schedule>

    return RT_EOK;
 80127ea:	2300      	movs	r3, #0
}
 80127ec:	4618      	mov	r0, r3
 80127ee:	3708      	adds	r7, #8
 80127f0:	46bd      	mov	sp, r7
 80127f2:	bdb0      	pop	{r4, r5, r7, pc}
 80127f4:	2001256c 	.word	0x2001256c

080127f8 <rt_mutex_init>:
 * @param flag the flag of mutex
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
{
 80127f8:	b580      	push	{r7, lr}
 80127fa:	b084      	sub	sp, #16
 80127fc:	af00      	add	r7, sp, #0
 80127fe:	60f8      	str	r0, [r7, #12]
 8012800:	60b9      	str	r1, [r7, #8]
 8012802:	4613      	mov	r3, r2
 8012804:	71fb      	strb	r3, [r7, #7]
    RT_ASSERT(mutex != RT_NULL);
 8012806:	68fb      	ldr	r3, [r7, #12]
 8012808:	2b00      	cmp	r3, #0
 801280a:	d105      	bne.n	8012818 <rt_mutex_init+0x20>
 801280c:	4811      	ldr	r0, [pc, #68]	; (8012854 <rt_mutex_init+0x5c>)
 801280e:	4912      	ldr	r1, [pc, #72]	; (8012858 <rt_mutex_init+0x60>)
 8012810:	f240 220f 	movw	r2, #527	; 0x20f
 8012814:	f001 faa6 	bl	8013d64 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
 8012818:	68fb      	ldr	r3, [r7, #12]
 801281a:	4618      	mov	r0, r3
 801281c:	2102      	movs	r1, #2
 801281e:	68ba      	ldr	r2, [r7, #8]
 8012820:	f001 ff80 	bl	8014724 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
 8012824:	68fb      	ldr	r3, [r7, #12]
 8012826:	4618      	mov	r0, r3
 8012828:	f7ff fe1e 	bl	8012468 <rt_ipc_object_init>

    mutex->value = 1;
 801282c:	68fb      	ldr	r3, [r7, #12]
 801282e:	2201      	movs	r2, #1
 8012830:	839a      	strh	r2, [r3, #28]
    mutex->owner = RT_NULL;
 8012832:	68fb      	ldr	r3, [r7, #12]
 8012834:	2200      	movs	r2, #0
 8012836:	621a      	str	r2, [r3, #32]
    mutex->original_priority = 0xFF;
 8012838:	68fb      	ldr	r3, [r7, #12]
 801283a:	22ff      	movs	r2, #255	; 0xff
 801283c:	779a      	strb	r2, [r3, #30]
    mutex->hold  = 0;
 801283e:	68fb      	ldr	r3, [r7, #12]
 8012840:	2200      	movs	r2, #0
 8012842:	77da      	strb	r2, [r3, #31]

    /* set flag */
    mutex->parent.parent.flag = flag;
 8012844:	68fb      	ldr	r3, [r7, #12]
 8012846:	79fa      	ldrb	r2, [r7, #7]
 8012848:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 801284a:	2300      	movs	r3, #0
}
 801284c:	4618      	mov	r0, r3
 801284e:	3710      	adds	r7, #16
 8012850:	46bd      	mov	sp, r7
 8012852:	bd80      	pop	{r7, pc}
 8012854:	08022d4c 	.word	0x08022d4c
 8012858:	08024cdc 	.word	0x08024cdc

0801285c <rt_mutex_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
{
 801285c:	b590      	push	{r4, r7, lr}
 801285e:	b087      	sub	sp, #28
 8012860:	af00      	add	r7, sp, #0
 8012862:	6078      	str	r0, [r7, #4]
 8012864:	6039      	str	r1, [r7, #0]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* this function must not be used in interrupt even if time = 0 */
    RT_DEBUG_IN_THREAD_CONTEXT;
 8012866:	f7ed fcaf 	bl	80001c8 <rt_hw_interrupt_disable>
 801286a:	6178      	str	r0, [r7, #20]
 801286c:	f002 fb8a 	bl	8014f84 <rt_thread_self>
 8012870:	4603      	mov	r3, r0
 8012872:	2b00      	cmp	r3, #0
 8012874:	d109      	bne.n	801288a <rt_mutex_take+0x2e>
 8012876:	485e      	ldr	r0, [pc, #376]	; (80129f0 <rt_mutex_take+0x194>)
 8012878:	495e      	ldr	r1, [pc, #376]	; (80129f4 <rt_mutex_take+0x198>)
 801287a:	f001 f9f9 	bl	8013c70 <rt_kprintf>
 801287e:	485e      	ldr	r0, [pc, #376]	; (80129f8 <rt_mutex_take+0x19c>)
 8012880:	495c      	ldr	r1, [pc, #368]	; (80129f4 <rt_mutex_take+0x198>)
 8012882:	f44f 7222 	mov.w	r2, #648	; 0x288
 8012886:	f001 fa6d 	bl	8013d64 <rt_assert_handler>
 801288a:	f7ed fc9d 	bl	80001c8 <rt_hw_interrupt_disable>
 801288e:	6138      	str	r0, [r7, #16]
 8012890:	f000 fc0a 	bl	80130a8 <rt_interrupt_get_nest>
 8012894:	4603      	mov	r3, r0
 8012896:	2b00      	cmp	r3, #0
 8012898:	d009      	beq.n	80128ae <rt_mutex_take+0x52>
 801289a:	4858      	ldr	r0, [pc, #352]	; (80129fc <rt_mutex_take+0x1a0>)
 801289c:	4955      	ldr	r1, [pc, #340]	; (80129f4 <rt_mutex_take+0x198>)
 801289e:	f001 f9e7 	bl	8013c70 <rt_kprintf>
 80128a2:	4855      	ldr	r0, [pc, #340]	; (80129f8 <rt_mutex_take+0x19c>)
 80128a4:	4953      	ldr	r1, [pc, #332]	; (80129f4 <rt_mutex_take+0x198>)
 80128a6:	f44f 7222 	mov.w	r2, #648	; 0x288
 80128aa:	f001 fa5b 	bl	8013d64 <rt_assert_handler>
 80128ae:	6938      	ldr	r0, [r7, #16]
 80128b0:	f7ed fc8e 	bl	80001d0 <rt_hw_interrupt_enable>
 80128b4:	6978      	ldr	r0, [r7, #20]
 80128b6:	f7ed fc8b 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
 80128ba:	687b      	ldr	r3, [r7, #4]
 80128bc:	2b00      	cmp	r3, #0
 80128be:	d105      	bne.n	80128cc <rt_mutex_take+0x70>
 80128c0:	484f      	ldr	r0, [pc, #316]	; (8012a00 <rt_mutex_take+0x1a4>)
 80128c2:	494c      	ldr	r1, [pc, #304]	; (80129f4 <rt_mutex_take+0x198>)
 80128c4:	f240 228a 	movw	r2, #650	; 0x28a
 80128c8:	f001 fa4c 	bl	8013d64 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80128cc:	f7ed fc7c 	bl	80001c8 <rt_hw_interrupt_disable>
 80128d0:	4604      	mov	r4, r0

    /* get current thread */
    thread = rt_thread_self();
 80128d2:	f002 fb57 	bl	8014f84 <rt_thread_self>
 80128d6:	60f8      	str	r0, [r7, #12]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
 80128d8:	4b4a      	ldr	r3, [pc, #296]	; (8012a04 <rt_mutex_take+0x1a8>)
 80128da:	681b      	ldr	r3, [r3, #0]
 80128dc:	2b00      	cmp	r3, #0
 80128de:	d004      	beq.n	80128ea <rt_mutex_take+0x8e>
 80128e0:	4b48      	ldr	r3, [pc, #288]	; (8012a04 <rt_mutex_take+0x1a8>)
 80128e2:	681b      	ldr	r3, [r3, #0]
 80128e4:	687a      	ldr	r2, [r7, #4]
 80128e6:	4610      	mov	r0, r2
 80128e8:	4798      	blx	r3
    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    /* reset thread error */
    thread->error = RT_EOK;
 80128ea:	68fb      	ldr	r3, [r7, #12]
 80128ec:	2200      	movs	r2, #0
 80128ee:	631a      	str	r2, [r3, #48]	; 0x30

    if (mutex->owner == thread)
 80128f0:	687b      	ldr	r3, [r7, #4]
 80128f2:	6a1a      	ldr	r2, [r3, #32]
 80128f4:	68fb      	ldr	r3, [r7, #12]
 80128f6:	429a      	cmp	r2, r3
 80128f8:	d106      	bne.n	8012908 <rt_mutex_take+0xac>
    {
        /* it's the same thread */
        mutex->hold ++;
 80128fa:	687b      	ldr	r3, [r7, #4]
 80128fc:	7fdb      	ldrb	r3, [r3, #31]
 80128fe:	3301      	adds	r3, #1
 8012900:	b2da      	uxtb	r2, r3
 8012902:	687b      	ldr	r3, [r7, #4]
 8012904:	77da      	strb	r2, [r3, #31]
 8012906:	e061      	b.n	80129cc <rt_mutex_take+0x170>
    else
    {
        /* The value of mutex is 1 in initial status. Therefore, if the
         * value is great than 0, it indicates the mutex is avaible.
         */
        if (mutex->value > 0)
 8012908:	687b      	ldr	r3, [r7, #4]
 801290a:	8b9b      	ldrh	r3, [r3, #28]
 801290c:	2b00      	cmp	r3, #0
 801290e:	d014      	beq.n	801293a <rt_mutex_take+0xde>
        {
            /* mutex is available */
            mutex->value --;
 8012910:	687b      	ldr	r3, [r7, #4]
 8012912:	8b9b      	ldrh	r3, [r3, #28]
 8012914:	3b01      	subs	r3, #1
 8012916:	b29a      	uxth	r2, r3
 8012918:	687b      	ldr	r3, [r7, #4]
 801291a:	839a      	strh	r2, [r3, #28]

            /* set mutex owner and original priority */
            mutex->owner             = thread;
 801291c:	687b      	ldr	r3, [r7, #4]
 801291e:	68fa      	ldr	r2, [r7, #12]
 8012920:	621a      	str	r2, [r3, #32]
            mutex->original_priority = thread->current_priority;
 8012922:	68fb      	ldr	r3, [r7, #12]
 8012924:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8012928:	687b      	ldr	r3, [r7, #4]
 801292a:	779a      	strb	r2, [r3, #30]
            mutex->hold ++;
 801292c:	687b      	ldr	r3, [r7, #4]
 801292e:	7fdb      	ldrb	r3, [r3, #31]
 8012930:	3301      	adds	r3, #1
 8012932:	b2da      	uxtb	r2, r3
 8012934:	687b      	ldr	r3, [r7, #4]
 8012936:	77da      	strb	r2, [r3, #31]
 8012938:	e048      	b.n	80129cc <rt_mutex_take+0x170>
        }
        else
        {
            /* no waiting, return with timeout */
            if (time == 0)
 801293a:	683b      	ldr	r3, [r7, #0]
 801293c:	2b00      	cmp	r3, #0
 801293e:	d109      	bne.n	8012954 <rt_mutex_take+0xf8>
            {
                /* set error as timeout */
                thread->error = -RT_ETIMEOUT;
 8012940:	68fb      	ldr	r3, [r7, #12]
 8012942:	f06f 0201 	mvn.w	r2, #1
 8012946:	631a      	str	r2, [r3, #48]	; 0x30

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
 8012948:	4620      	mov	r0, r4
 801294a:	f7ed fc41 	bl	80001d0 <rt_hw_interrupt_enable>

                return -RT_ETIMEOUT;
 801294e:	f06f 0301 	mvn.w	r3, #1
 8012952:	e048      	b.n	80129e6 <rt_mutex_take+0x18a>
                /* mutex is unavailable, push to suspend list */
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
                                            thread->name));

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
 8012954:	68fb      	ldr	r3, [r7, #12]
 8012956:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 801295a:	687b      	ldr	r3, [r7, #4]
 801295c:	6a1b      	ldr	r3, [r3, #32]
 801295e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8012962:	429a      	cmp	r2, r3
 8012964:	d208      	bcs.n	8012978 <rt_mutex_take+0x11c>
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
 8012966:	687b      	ldr	r3, [r7, #4]
 8012968:	6a1a      	ldr	r2, [r3, #32]
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
 801296a:	68fb      	ldr	r3, [r7, #12]
 801296c:	3335      	adds	r3, #53	; 0x35

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
 801296e:	4610      	mov	r0, r2
 8012970:	2102      	movs	r1, #2
 8012972:	461a      	mov	r2, r3
 8012974:	f002 fc32 	bl	80151dc <rt_thread_control>
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
                }

                /* suspend current thread */
                rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
 8012978:	687b      	ldr	r3, [r7, #4]
 801297a:	f103 0214 	add.w	r2, r3, #20
 801297e:	687b      	ldr	r3, [r7, #4]
 8012980:	7a5b      	ldrb	r3, [r3, #9]
 8012982:	4610      	mov	r0, r2
 8012984:	68f9      	ldr	r1, [r7, #12]
 8012986:	461a      	mov	r2, r3
 8012988:	f7ff fd7c 	bl	8012484 <rt_ipc_list_suspend>
                                    thread,
                                    mutex->parent.parent.flag);

                /* has waiting time, start thread timer */
                if (time > 0)
 801298c:	683b      	ldr	r3, [r7, #0]
 801298e:	2b00      	cmp	r3, #0
 8012990:	dd0d      	ble.n	80129ae <rt_mutex_take+0x152>
                    RT_DEBUG_LOG(RT_DEBUG_IPC,
                                 ("mutex_take: start the timer of thread:%s\n",
                                  thread->name));

                    /* reset the timeout of thread timer and start it */
                    rt_timer_control(&(thread->thread_timer),
 8012992:	68fb      	ldr	r3, [r7, #12]
 8012994:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8012998:	463b      	mov	r3, r7
 801299a:	4610      	mov	r0, r2
 801299c:	2100      	movs	r1, #0
 801299e:	461a      	mov	r2, r3
 80129a0:	f002 ff70 	bl	8015884 <rt_timer_control>
                                     RT_TIMER_CTRL_SET_TIME,
                                     &time);
                    rt_timer_start(&(thread->thread_timer));
 80129a4:	68fb      	ldr	r3, [r7, #12]
 80129a6:	334c      	adds	r3, #76	; 0x4c
 80129a8:	4618      	mov	r0, r3
 80129aa:	f002 fe25 	bl	80155f8 <rt_timer_start>
                }

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
 80129ae:	4620      	mov	r0, r4
 80129b0:	f7ed fc0e 	bl	80001d0 <rt_hw_interrupt_enable>

                /* do schedule */
                rt_schedule();
 80129b4:	f002 f8aa 	bl	8014b0c <rt_schedule>

                if (thread->error != RT_EOK)
 80129b8:	68fb      	ldr	r3, [r7, #12]
 80129ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80129bc:	2b00      	cmp	r3, #0
 80129be:	d002      	beq.n	80129c6 <rt_mutex_take+0x16a>
                {
                    /* return error */
                    return thread->error;
 80129c0:	68fb      	ldr	r3, [r7, #12]
 80129c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80129c4:	e00f      	b.n	80129e6 <rt_mutex_take+0x18a>
                }
                else
                {
                    /* the mutex is taken successfully. */
                    /* disable interrupt */
                    temp = rt_hw_interrupt_disable();
 80129c6:	f7ed fbff 	bl	80001c8 <rt_hw_interrupt_disable>
 80129ca:	4604      	mov	r4, r0
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 80129cc:	4620      	mov	r0, r4
 80129ce:	f7ed fbff 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
 80129d2:	4b0d      	ldr	r3, [pc, #52]	; (8012a08 <rt_mutex_take+0x1ac>)
 80129d4:	681b      	ldr	r3, [r3, #0]
 80129d6:	2b00      	cmp	r3, #0
 80129d8:	d004      	beq.n	80129e4 <rt_mutex_take+0x188>
 80129da:	4b0b      	ldr	r3, [pc, #44]	; (8012a08 <rt_mutex_take+0x1ac>)
 80129dc:	681b      	ldr	r3, [r3, #0]
 80129de:	687a      	ldr	r2, [r7, #4]
 80129e0:	4610      	mov	r0, r2
 80129e2:	4798      	blx	r3

    return RT_EOK;
 80129e4:	2300      	movs	r3, #0
}
 80129e6:	4618      	mov	r0, r3
 80129e8:	371c      	adds	r7, #28
 80129ea:	46bd      	mov	sp, r7
 80129ec:	bd90      	pop	{r4, r7, pc}
 80129ee:	bf00      	nop
 80129f0:	08022d14 	.word	0x08022d14
 80129f4:	08024cec 	.word	0x08024cec
 80129f8:	08022d10 	.word	0x08022d10
 80129fc:	08022cec 	.word	0x08022cec
 8012a00:	08022d4c 	.word	0x08022d4c
 8012a04:	20012574 	.word	0x20012574
 8012a08:	20012570 	.word	0x20012570

08012a0c <rt_mutex_release>:
 * @param mutex the mutex object
 *
 * @return the error code
 */
rt_err_t rt_mutex_release(rt_mutex_t mutex)
{
 8012a0c:	b590      	push	{r4, r7, lr}
 8012a0e:	b087      	sub	sp, #28
 8012a10:	af00      	add	r7, sp, #0
 8012a12:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    struct rt_thread *thread;
    rt_bool_t need_schedule;

    need_schedule = RT_FALSE;
 8012a14:	2300      	movs	r3, #0
 8012a16:	617b      	str	r3, [r7, #20]

    /* only thread could release mutex because we need test the ownership */
    RT_DEBUG_IN_THREAD_CONTEXT;
 8012a18:	f7ed fbd6 	bl	80001c8 <rt_hw_interrupt_disable>
 8012a1c:	6138      	str	r0, [r7, #16]
 8012a1e:	f002 fab1 	bl	8014f84 <rt_thread_self>
 8012a22:	4603      	mov	r3, r0
 8012a24:	2b00      	cmp	r3, #0
 8012a26:	d109      	bne.n	8012a3c <rt_mutex_release+0x30>
 8012a28:	484a      	ldr	r0, [pc, #296]	; (8012b54 <rt_mutex_release+0x148>)
 8012a2a:	494b      	ldr	r1, [pc, #300]	; (8012b58 <rt_mutex_release+0x14c>)
 8012a2c:	f001 f920 	bl	8013c70 <rt_kprintf>
 8012a30:	484a      	ldr	r0, [pc, #296]	; (8012b5c <rt_mutex_release+0x150>)
 8012a32:	4949      	ldr	r1, [pc, #292]	; (8012b58 <rt_mutex_release+0x14c>)
 8012a34:	f240 320d 	movw	r2, #781	; 0x30d
 8012a38:	f001 f994 	bl	8013d64 <rt_assert_handler>
 8012a3c:	f7ed fbc4 	bl	80001c8 <rt_hw_interrupt_disable>
 8012a40:	60f8      	str	r0, [r7, #12]
 8012a42:	f000 fb31 	bl	80130a8 <rt_interrupt_get_nest>
 8012a46:	4603      	mov	r3, r0
 8012a48:	2b00      	cmp	r3, #0
 8012a4a:	d009      	beq.n	8012a60 <rt_mutex_release+0x54>
 8012a4c:	4844      	ldr	r0, [pc, #272]	; (8012b60 <rt_mutex_release+0x154>)
 8012a4e:	4942      	ldr	r1, [pc, #264]	; (8012b58 <rt_mutex_release+0x14c>)
 8012a50:	f001 f90e 	bl	8013c70 <rt_kprintf>
 8012a54:	4841      	ldr	r0, [pc, #260]	; (8012b5c <rt_mutex_release+0x150>)
 8012a56:	4940      	ldr	r1, [pc, #256]	; (8012b58 <rt_mutex_release+0x14c>)
 8012a58:	f240 320d 	movw	r2, #781	; 0x30d
 8012a5c:	f001 f982 	bl	8013d64 <rt_assert_handler>
 8012a60:	68f8      	ldr	r0, [r7, #12]
 8012a62:	f7ed fbb5 	bl	80001d0 <rt_hw_interrupt_enable>
 8012a66:	6938      	ldr	r0, [r7, #16]
 8012a68:	f7ed fbb2 	bl	80001d0 <rt_hw_interrupt_enable>

    /* get current thread */
    thread = rt_thread_self();
 8012a6c:	f002 fa8a 	bl	8014f84 <rt_thread_self>
 8012a70:	60b8      	str	r0, [r7, #8]

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8012a72:	f7ed fba9 	bl	80001c8 <rt_hw_interrupt_disable>
 8012a76:	4604      	mov	r4, r0

    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
 8012a78:	4b3a      	ldr	r3, [pc, #232]	; (8012b64 <rt_mutex_release+0x158>)
 8012a7a:	681b      	ldr	r3, [r3, #0]
 8012a7c:	2b00      	cmp	r3, #0
 8012a7e:	d004      	beq.n	8012a8a <rt_mutex_release+0x7e>
 8012a80:	4b38      	ldr	r3, [pc, #224]	; (8012b64 <rt_mutex_release+0x158>)
 8012a82:	681b      	ldr	r3, [r3, #0]
 8012a84:	687a      	ldr	r2, [r7, #4]
 8012a86:	4610      	mov	r0, r2
 8012a88:	4798      	blx	r3

    /* mutex only can be released by owner */
    if (thread != mutex->owner)
 8012a8a:	687b      	ldr	r3, [r7, #4]
 8012a8c:	6a1a      	ldr	r2, [r3, #32]
 8012a8e:	68bb      	ldr	r3, [r7, #8]
 8012a90:	429a      	cmp	r2, r3
 8012a92:	d009      	beq.n	8012aa8 <rt_mutex_release+0x9c>
    {
        thread->error = -RT_ERROR;
 8012a94:	68bb      	ldr	r3, [r7, #8]
 8012a96:	f04f 32ff 	mov.w	r2, #4294967295
 8012a9a:	631a      	str	r2, [r3, #48]	; 0x30

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8012a9c:	4620      	mov	r0, r4
 8012a9e:	f7ed fb97 	bl	80001d0 <rt_hw_interrupt_enable>

        return -RT_ERROR;
 8012aa2:	f04f 33ff 	mov.w	r3, #4294967295
 8012aa6:	e051      	b.n	8012b4c <rt_mutex_release+0x140>
    }

    /* decrease hold */
    mutex->hold --;
 8012aa8:	687b      	ldr	r3, [r7, #4]
 8012aaa:	7fdb      	ldrb	r3, [r3, #31]
 8012aac:	3b01      	subs	r3, #1
 8012aae:	b2da      	uxtb	r2, r3
 8012ab0:	687b      	ldr	r3, [r7, #4]
 8012ab2:	77da      	strb	r2, [r3, #31]
    /* if no hold */
    if (mutex->hold == 0)
 8012ab4:	687b      	ldr	r3, [r7, #4]
 8012ab6:	7fdb      	ldrb	r3, [r3, #31]
 8012ab8:	2b00      	cmp	r3, #0
 8012aba:	d13e      	bne.n	8012b3a <rt_mutex_release+0x12e>
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
 8012abc:	687b      	ldr	r3, [r7, #4]
 8012abe:	7f9a      	ldrb	r2, [r3, #30]
 8012ac0:	687b      	ldr	r3, [r7, #4]
 8012ac2:	6a1b      	ldr	r3, [r3, #32]
 8012ac4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8012ac8:	429a      	cmp	r2, r3
 8012aca:	d008      	beq.n	8012ade <rt_mutex_release+0xd2>
        {
            rt_thread_control(mutex->owner,
 8012acc:	687b      	ldr	r3, [r7, #4]
 8012ace:	6a1a      	ldr	r2, [r3, #32]
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
 8012ad0:	687b      	ldr	r3, [r7, #4]
 8012ad2:	331e      	adds	r3, #30
    if (mutex->hold == 0)
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
        {
            rt_thread_control(mutex->owner,
 8012ad4:	4610      	mov	r0, r2
 8012ad6:	2102      	movs	r1, #2
 8012ad8:	461a      	mov	r2, r3
 8012ada:	f002 fb7f 	bl	80151dc <rt_thread_control>
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
        }

        /* wakeup suspended thread */
        if (!rt_list_isempty(&mutex->parent.suspend_thread))
 8012ade:	687b      	ldr	r3, [r7, #4]
 8012ae0:	3314      	adds	r3, #20
 8012ae2:	4618      	mov	r0, r3
 8012ae4:	f7ff fcae 	bl	8012444 <rt_list_isempty>
 8012ae8:	4603      	mov	r3, r0
 8012aea:	2b00      	cmp	r3, #0
 8012aec:	d119      	bne.n	8012b22 <rt_mutex_release+0x116>
        {
            /* get suspended thread */
            thread = rt_list_entry(mutex->parent.suspend_thread.next,
 8012aee:	687b      	ldr	r3, [r7, #4]
 8012af0:	695b      	ldr	r3, [r3, #20]
 8012af2:	3b14      	subs	r3, #20
 8012af4:	60bb      	str	r3, [r7, #8]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
                                        thread->name));

            /* set new owner and priority */
            mutex->owner             = thread;
 8012af6:	687b      	ldr	r3, [r7, #4]
 8012af8:	68ba      	ldr	r2, [r7, #8]
 8012afa:	621a      	str	r2, [r3, #32]
            mutex->original_priority = thread->current_priority;
 8012afc:	68bb      	ldr	r3, [r7, #8]
 8012afe:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8012b02:	687b      	ldr	r3, [r7, #4]
 8012b04:	779a      	strb	r2, [r3, #30]
            mutex->hold ++;
 8012b06:	687b      	ldr	r3, [r7, #4]
 8012b08:	7fdb      	ldrb	r3, [r3, #31]
 8012b0a:	3301      	adds	r3, #1
 8012b0c:	b2da      	uxtb	r2, r3
 8012b0e:	687b      	ldr	r3, [r7, #4]
 8012b10:	77da      	strb	r2, [r3, #31]

            /* resume thread */
            rt_ipc_list_resume(&(mutex->parent.suspend_thread));
 8012b12:	687b      	ldr	r3, [r7, #4]
 8012b14:	3314      	adds	r3, #20
 8012b16:	4618      	mov	r0, r3
 8012b18:	f7ff fcfc 	bl	8012514 <rt_ipc_list_resume>

            need_schedule = RT_TRUE;
 8012b1c:	2301      	movs	r3, #1
 8012b1e:	617b      	str	r3, [r7, #20]
 8012b20:	e00b      	b.n	8012b3a <rt_mutex_release+0x12e>
        }
        else
        {
            /* increase value */
            mutex->value ++;
 8012b22:	687b      	ldr	r3, [r7, #4]
 8012b24:	8b9b      	ldrh	r3, [r3, #28]
 8012b26:	3301      	adds	r3, #1
 8012b28:	b29a      	uxth	r2, r3
 8012b2a:	687b      	ldr	r3, [r7, #4]
 8012b2c:	839a      	strh	r2, [r3, #28]

            /* clear owner */
            mutex->owner             = RT_NULL;
 8012b2e:	687b      	ldr	r3, [r7, #4]
 8012b30:	2200      	movs	r2, #0
 8012b32:	621a      	str	r2, [r3, #32]
            mutex->original_priority = 0xff;
 8012b34:	687b      	ldr	r3, [r7, #4]
 8012b36:	22ff      	movs	r2, #255	; 0xff
 8012b38:	779a      	strb	r2, [r3, #30]
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8012b3a:	4620      	mov	r0, r4
 8012b3c:	f7ed fb48 	bl	80001d0 <rt_hw_interrupt_enable>

    /* perform a schedule */
    if (need_schedule == RT_TRUE)
 8012b40:	697b      	ldr	r3, [r7, #20]
 8012b42:	2b01      	cmp	r3, #1
 8012b44:	d101      	bne.n	8012b4a <rt_mutex_release+0x13e>
        rt_schedule();
 8012b46:	f001 ffe1 	bl	8014b0c <rt_schedule>

    return RT_EOK;
 8012b4a:	2300      	movs	r3, #0
}
 8012b4c:	4618      	mov	r0, r3
 8012b4e:	371c      	adds	r7, #28
 8012b50:	46bd      	mov	sp, r7
 8012b52:	bd90      	pop	{r4, r7, pc}
 8012b54:	08022d14 	.word	0x08022d14
 8012b58:	08024cfc 	.word	0x08024cfc
 8012b5c:	08022d10 	.word	0x08022d10
 8012b60:	08022cec 	.word	0x08022cec
 8012b64:	2001256c 	.word	0x2001256c

08012b68 <rt_mq_create>:
 */
rt_mq_t rt_mq_create(const char *name,
                     rt_size_t   msg_size,
                     rt_size_t   max_msgs,
                     rt_uint8_t  flag)
{
 8012b68:	b590      	push	{r4, r7, lr}
 8012b6a:	b089      	sub	sp, #36	; 0x24
 8012b6c:	af00      	add	r7, sp, #0
 8012b6e:	60f8      	str	r0, [r7, #12]
 8012b70:	60b9      	str	r1, [r7, #8]
 8012b72:	607a      	str	r2, [r7, #4]
 8012b74:	70fb      	strb	r3, [r7, #3]
    struct rt_messagequeue *mq;
    struct rt_mq_message *head;
    register rt_base_t temp;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8012b76:	f7ed fb27 	bl	80001c8 <rt_hw_interrupt_disable>
 8012b7a:	61f8      	str	r0, [r7, #28]
 8012b7c:	f000 fa94 	bl	80130a8 <rt_interrupt_get_nest>
 8012b80:	4603      	mov	r3, r0
 8012b82:	2b00      	cmp	r3, #0
 8012b84:	d009      	beq.n	8012b9a <rt_mq_create+0x32>
 8012b86:	4835      	ldr	r0, [pc, #212]	; (8012c5c <rt_mq_create+0xf4>)
 8012b88:	4935      	ldr	r1, [pc, #212]	; (8012c60 <rt_mq_create+0xf8>)
 8012b8a:	f001 f871 	bl	8013c70 <rt_kprintf>
 8012b8e:	4835      	ldr	r0, [pc, #212]	; (8012c64 <rt_mq_create+0xfc>)
 8012b90:	4933      	ldr	r1, [pc, #204]	; (8012c60 <rt_mq_create+0xf8>)
 8012b92:	f240 7226 	movw	r2, #1830	; 0x726
 8012b96:	f001 f8e5 	bl	8013d64 <rt_assert_handler>
 8012b9a:	69f8      	ldr	r0, [r7, #28]
 8012b9c:	f7ed fb18 	bl	80001d0 <rt_hw_interrupt_enable>

    /* allocate object */
    mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
 8012ba0:	2005      	movs	r0, #5
 8012ba2:	68f9      	ldr	r1, [r7, #12]
 8012ba4:	f001 fe1c 	bl	80147e0 <rt_object_allocate>
 8012ba8:	61b8      	str	r0, [r7, #24]
    if (mq == RT_NULL)
 8012baa:	69bb      	ldr	r3, [r7, #24]
 8012bac:	2b00      	cmp	r3, #0
 8012bae:	d101      	bne.n	8012bb4 <rt_mq_create+0x4c>
        return mq;
 8012bb0:	69bb      	ldr	r3, [r7, #24]
 8012bb2:	e04e      	b.n	8012c52 <rt_mq_create+0xea>

    /* set parent */
    mq->parent.parent.flag = flag;
 8012bb4:	69bb      	ldr	r3, [r7, #24]
 8012bb6:	78fa      	ldrb	r2, [r7, #3]
 8012bb8:	725a      	strb	r2, [r3, #9]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
 8012bba:	69bb      	ldr	r3, [r7, #24]
 8012bbc:	4618      	mov	r0, r3
 8012bbe:	f7ff fc53 	bl	8012468 <rt_ipc_object_init>

    /* init message queue */

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
 8012bc2:	68bb      	ldr	r3, [r7, #8]
 8012bc4:	b29b      	uxth	r3, r3
 8012bc6:	3303      	adds	r3, #3
 8012bc8:	b29b      	uxth	r3, r3
 8012bca:	f023 0303 	bic.w	r3, r3, #3
 8012bce:	b29a      	uxth	r2, r3
 8012bd0:	69bb      	ldr	r3, [r7, #24]
 8012bd2:	841a      	strh	r2, [r3, #32]
    mq->max_msgs = max_msgs;
 8012bd4:	687b      	ldr	r3, [r7, #4]
 8012bd6:	b29a      	uxth	r2, r3
 8012bd8:	69bb      	ldr	r3, [r7, #24]
 8012bda:	845a      	strh	r2, [r3, #34]	; 0x22

    /* allocate message pool */
    mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
 8012bdc:	69bb      	ldr	r3, [r7, #24]
 8012bde:	8c1b      	ldrh	r3, [r3, #32]
 8012be0:	3304      	adds	r3, #4
 8012be2:	69ba      	ldr	r2, [r7, #24]
 8012be4:	8c52      	ldrh	r2, [r2, #34]	; 0x22
 8012be6:	fb02 f303 	mul.w	r3, r2, r3
 8012bea:	4618      	mov	r0, r3
 8012bec:	f001 f9ee 	bl	8013fcc <rt_malloc>
 8012bf0:	4602      	mov	r2, r0
 8012bf2:	69bb      	ldr	r3, [r7, #24]
 8012bf4:	61da      	str	r2, [r3, #28]
    if (mq->msg_pool == RT_NULL)
 8012bf6:	69bb      	ldr	r3, [r7, #24]
 8012bf8:	69db      	ldr	r3, [r3, #28]
 8012bfa:	2b00      	cmp	r3, #0
 8012bfc:	d104      	bne.n	8012c08 <rt_mq_create+0xa0>
    {
        rt_mq_delete(mq);
 8012bfe:	69b8      	ldr	r0, [r7, #24]
 8012c00:	f000 f832 	bl	8012c68 <rt_mq_delete>

        return RT_NULL;
 8012c04:	2300      	movs	r3, #0
 8012c06:	e024      	b.n	8012c52 <rt_mq_create+0xea>
    }

    /* init message list */
    mq->msg_queue_head = RT_NULL;
 8012c08:	69bb      	ldr	r3, [r7, #24]
 8012c0a:	2200      	movs	r2, #0
 8012c0c:	629a      	str	r2, [r3, #40]	; 0x28
    mq->msg_queue_tail = RT_NULL;
 8012c0e:	69bb      	ldr	r3, [r7, #24]
 8012c10:	2200      	movs	r2, #0
 8012c12:	62da      	str	r2, [r3, #44]	; 0x2c

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
 8012c14:	69bb      	ldr	r3, [r7, #24]
 8012c16:	2200      	movs	r2, #0
 8012c18:	631a      	str	r2, [r3, #48]	; 0x30
    for (temp = 0; temp < mq->max_msgs; temp ++)
 8012c1a:	2400      	movs	r4, #0
 8012c1c:	e011      	b.n	8012c42 <rt_mq_create+0xda>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
 8012c1e:	69bb      	ldr	r3, [r7, #24]
 8012c20:	69da      	ldr	r2, [r3, #28]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
 8012c22:	69bb      	ldr	r3, [r7, #24]
 8012c24:	8c1b      	ldrh	r3, [r3, #32]
 8012c26:	3304      	adds	r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
 8012c28:	4621      	mov	r1, r4
 8012c2a:	fb01 f303 	mul.w	r3, r1, r3
 8012c2e:	4413      	add	r3, r2
 8012c30:	617b      	str	r3, [r7, #20]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
 8012c32:	69bb      	ldr	r3, [r7, #24]
 8012c34:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8012c36:	697b      	ldr	r3, [r7, #20]
 8012c38:	601a      	str	r2, [r3, #0]
        mq->msg_queue_free = head;
 8012c3a:	69bb      	ldr	r3, [r7, #24]
 8012c3c:	697a      	ldr	r2, [r7, #20]
 8012c3e:	631a      	str	r2, [r3, #48]	; 0x30
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
 8012c40:	3401      	adds	r4, #1
 8012c42:	69bb      	ldr	r3, [r7, #24]
 8012c44:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8012c46:	42a3      	cmp	r3, r4
 8012c48:	dce9      	bgt.n	8012c1e <rt_mq_create+0xb6>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
 8012c4a:	69bb      	ldr	r3, [r7, #24]
 8012c4c:	2200      	movs	r2, #0
 8012c4e:	849a      	strh	r2, [r3, #36]	; 0x24

    return mq;
 8012c50:	69bb      	ldr	r3, [r7, #24]
}
 8012c52:	4618      	mov	r0, r3
 8012c54:	3724      	adds	r7, #36	; 0x24
 8012c56:	46bd      	mov	sp, r7
 8012c58:	bd90      	pop	{r4, r7, pc}
 8012c5a:	bf00      	nop
 8012c5c:	08022cec 	.word	0x08022cec
 8012c60:	08024d10 	.word	0x08024d10
 8012c64:	08022d10 	.word	0x08022d10

08012c68 <rt_mq_delete>:
 * @param mq the message queue object
 *
 * @return the error code
 */
rt_err_t rt_mq_delete(rt_mq_t mq)
{
 8012c68:	b580      	push	{r7, lr}
 8012c6a:	b084      	sub	sp, #16
 8012c6c:	af00      	add	r7, sp, #0
 8012c6e:	6078      	str	r0, [r7, #4]
    RT_DEBUG_NOT_IN_INTERRUPT;
 8012c70:	f7ed faaa 	bl	80001c8 <rt_hw_interrupt_disable>
 8012c74:	60f8      	str	r0, [r7, #12]
 8012c76:	f000 fa17 	bl	80130a8 <rt_interrupt_get_nest>
 8012c7a:	4603      	mov	r3, r0
 8012c7c:	2b00      	cmp	r3, #0
 8012c7e:	d009      	beq.n	8012c94 <rt_mq_delete+0x2c>
 8012c80:	4814      	ldr	r0, [pc, #80]	; (8012cd4 <rt_mq_delete+0x6c>)
 8012c82:	4915      	ldr	r1, [pc, #84]	; (8012cd8 <rt_mq_delete+0x70>)
 8012c84:	f000 fff4 	bl	8013c70 <rt_kprintf>
 8012c88:	4814      	ldr	r0, [pc, #80]	; (8012cdc <rt_mq_delete+0x74>)
 8012c8a:	4913      	ldr	r1, [pc, #76]	; (8012cd8 <rt_mq_delete+0x70>)
 8012c8c:	f44f 62ec 	mov.w	r2, #1888	; 0x760
 8012c90:	f001 f868 	bl	8013d64 <rt_assert_handler>
 8012c94:	68f8      	ldr	r0, [r7, #12]
 8012c96:	f7ed fa9b 	bl	80001d0 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
 8012c9a:	687b      	ldr	r3, [r7, #4]
 8012c9c:	2b00      	cmp	r3, #0
 8012c9e:	d105      	bne.n	8012cac <rt_mq_delete+0x44>
 8012ca0:	480f      	ldr	r0, [pc, #60]	; (8012ce0 <rt_mq_delete+0x78>)
 8012ca2:	490d      	ldr	r1, [pc, #52]	; (8012cd8 <rt_mq_delete+0x70>)
 8012ca4:	f240 7263 	movw	r2, #1891	; 0x763
 8012ca8:	f001 f85c 	bl	8013d64 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
 8012cac:	687b      	ldr	r3, [r7, #4]
 8012cae:	3314      	adds	r3, #20
 8012cb0:	4618      	mov	r0, r3
 8012cb2:	f7ff fc3f 	bl	8012534 <rt_ipc_list_resume_all>
        rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
    else
#endif

    /* free message queue pool */
    RT_KERNEL_FREE(mq->msg_pool);
 8012cb6:	687b      	ldr	r3, [r7, #4]
 8012cb8:	69db      	ldr	r3, [r3, #28]
 8012cba:	4618      	mov	r0, r3
 8012cbc:	f001 fb90 	bl	80143e0 <rt_free>

    /* delete message queue object */
    rt_object_delete(&(mq->parent.parent));
 8012cc0:	687b      	ldr	r3, [r7, #4]
 8012cc2:	4618      	mov	r0, r3
 8012cc4:	f001 fde8 	bl	8014898 <rt_object_delete>

    return RT_EOK;
 8012cc8:	2300      	movs	r3, #0
}
 8012cca:	4618      	mov	r0, r3
 8012ccc:	3710      	adds	r7, #16
 8012cce:	46bd      	mov	sp, r7
 8012cd0:	bd80      	pop	{r7, pc}
 8012cd2:	bf00      	nop
 8012cd4:	08022cec 	.word	0x08022cec
 8012cd8:	08024d20 	.word	0x08024d20
 8012cdc:	08022d10 	.word	0x08022d10
 8012ce0:	08022d84 	.word	0x08022d84

08012ce4 <rt_mq_send>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
{
 8012ce4:	b590      	push	{r4, r7, lr}
 8012ce6:	b087      	sub	sp, #28
 8012ce8:	af00      	add	r7, sp, #0
 8012cea:	60f8      	str	r0, [r7, #12]
 8012cec:	60b9      	str	r1, [r7, #8]
 8012cee:	607a      	str	r2, [r7, #4]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
 8012cf0:	68fb      	ldr	r3, [r7, #12]
 8012cf2:	2b00      	cmp	r3, #0
 8012cf4:	d105      	bne.n	8012d02 <rt_mq_send+0x1e>
 8012cf6:	4843      	ldr	r0, [pc, #268]	; (8012e04 <rt_mq_send+0x120>)
 8012cf8:	4943      	ldr	r1, [pc, #268]	; (8012e08 <rt_mq_send+0x124>)
 8012cfa:	f240 7289 	movw	r2, #1929	; 0x789
 8012cfe:	f001 f831 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
 8012d02:	68bb      	ldr	r3, [r7, #8]
 8012d04:	2b00      	cmp	r3, #0
 8012d06:	d105      	bne.n	8012d14 <rt_mq_send+0x30>
 8012d08:	4840      	ldr	r0, [pc, #256]	; (8012e0c <rt_mq_send+0x128>)
 8012d0a:	493f      	ldr	r1, [pc, #252]	; (8012e08 <rt_mq_send+0x124>)
 8012d0c:	f240 728a 	movw	r2, #1930	; 0x78a
 8012d10:	f001 f828 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(size != 0);
 8012d14:	687b      	ldr	r3, [r7, #4]
 8012d16:	2b00      	cmp	r3, #0
 8012d18:	d105      	bne.n	8012d26 <rt_mq_send+0x42>
 8012d1a:	483d      	ldr	r0, [pc, #244]	; (8012e10 <rt_mq_send+0x12c>)
 8012d1c:	493a      	ldr	r1, [pc, #232]	; (8012e08 <rt_mq_send+0x124>)
 8012d1e:	f240 728b 	movw	r2, #1931	; 0x78b
 8012d22:	f001 f81f 	bl	8013d64 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
 8012d26:	68fb      	ldr	r3, [r7, #12]
 8012d28:	8c1b      	ldrh	r3, [r3, #32]
 8012d2a:	461a      	mov	r2, r3
 8012d2c:	687b      	ldr	r3, [r7, #4]
 8012d2e:	429a      	cmp	r2, r3
 8012d30:	d202      	bcs.n	8012d38 <rt_mq_send+0x54>
        return -RT_ERROR;
 8012d32:	f04f 33ff 	mov.w	r3, #4294967295
 8012d36:	e061      	b.n	8012dfc <rt_mq_send+0x118>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
 8012d38:	4b36      	ldr	r3, [pc, #216]	; (8012e14 <rt_mq_send+0x130>)
 8012d3a:	681b      	ldr	r3, [r3, #0]
 8012d3c:	2b00      	cmp	r3, #0
 8012d3e:	d004      	beq.n	8012d4a <rt_mq_send+0x66>
 8012d40:	4b34      	ldr	r3, [pc, #208]	; (8012e14 <rt_mq_send+0x130>)
 8012d42:	681b      	ldr	r3, [r3, #0]
 8012d44:	68fa      	ldr	r2, [r7, #12]
 8012d46:	4610      	mov	r0, r2
 8012d48:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8012d4a:	f7ed fa3d 	bl	80001c8 <rt_hw_interrupt_disable>
 8012d4e:	4603      	mov	r3, r0
 8012d50:	461c      	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message*)mq->msg_queue_free;
 8012d52:	68fb      	ldr	r3, [r7, #12]
 8012d54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012d56:	617b      	str	r3, [r7, #20]
    /* message queue is full */
    if (msg == RT_NULL)
 8012d58:	697b      	ldr	r3, [r7, #20]
 8012d5a:	2b00      	cmp	r3, #0
 8012d5c:	d106      	bne.n	8012d6c <rt_mq_send+0x88>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8012d5e:	4623      	mov	r3, r4
 8012d60:	4618      	mov	r0, r3
 8012d62:	f7ed fa35 	bl	80001d0 <rt_hw_interrupt_enable>

        return -RT_EFULL;
 8012d66:	f06f 0302 	mvn.w	r3, #2
 8012d6a:	e047      	b.n	8012dfc <rt_mq_send+0x118>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
 8012d6c:	697b      	ldr	r3, [r7, #20]
 8012d6e:	681a      	ldr	r2, [r3, #0]
 8012d70:	68fb      	ldr	r3, [r7, #12]
 8012d72:	631a      	str	r2, [r3, #48]	; 0x30

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8012d74:	4623      	mov	r3, r4
 8012d76:	4618      	mov	r0, r3
 8012d78:	f7ed fa2a 	bl	80001d0 <rt_hw_interrupt_enable>

    /* the msg is the new tailer of list, the next shall be NULL */
    msg->next = RT_NULL;
 8012d7c:	697b      	ldr	r3, [r7, #20]
 8012d7e:	2200      	movs	r2, #0
 8012d80:	601a      	str	r2, [r3, #0]
    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
 8012d82:	697b      	ldr	r3, [r7, #20]
 8012d84:	3304      	adds	r3, #4
 8012d86:	4618      	mov	r0, r3
 8012d88:	68b9      	ldr	r1, [r7, #8]
 8012d8a:	687a      	ldr	r2, [r7, #4]
 8012d8c:	f000 fa14 	bl	80131b8 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8012d90:	f7ed fa1a 	bl	80001c8 <rt_hw_interrupt_disable>
 8012d94:	4603      	mov	r3, r0
 8012d96:	461c      	mov	r4, r3
    /* link msg to message queue */
    if (mq->msg_queue_tail != RT_NULL)
 8012d98:	68fb      	ldr	r3, [r7, #12]
 8012d9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012d9c:	2b00      	cmp	r3, #0
 8012d9e:	d003      	beq.n	8012da8 <rt_mq_send+0xc4>
    {
        /* if the tail exists, */
        ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
 8012da0:	68fb      	ldr	r3, [r7, #12]
 8012da2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012da4:	697a      	ldr	r2, [r7, #20]
 8012da6:	601a      	str	r2, [r3, #0]
    }

    /* set new tail */
    mq->msg_queue_tail = msg;
 8012da8:	68fb      	ldr	r3, [r7, #12]
 8012daa:	697a      	ldr	r2, [r7, #20]
 8012dac:	62da      	str	r2, [r3, #44]	; 0x2c
    /* if the head is empty, set head */
    if (mq->msg_queue_head == RT_NULL)
 8012dae:	68fb      	ldr	r3, [r7, #12]
 8012db0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012db2:	2b00      	cmp	r3, #0
 8012db4:	d102      	bne.n	8012dbc <rt_mq_send+0xd8>
        mq->msg_queue_head = msg;
 8012db6:	68fb      	ldr	r3, [r7, #12]
 8012db8:	697a      	ldr	r2, [r7, #20]
 8012dba:	629a      	str	r2, [r3, #40]	; 0x28

    /* increase message entry */
    mq->entry ++;
 8012dbc:	68fb      	ldr	r3, [r7, #12]
 8012dbe:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8012dc0:	3301      	adds	r3, #1
 8012dc2:	b29a      	uxth	r2, r3
 8012dc4:	68fb      	ldr	r3, [r7, #12]
 8012dc6:	849a      	strh	r2, [r3, #36]	; 0x24

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
 8012dc8:	68fb      	ldr	r3, [r7, #12]
 8012dca:	3314      	adds	r3, #20
 8012dcc:	4618      	mov	r0, r3
 8012dce:	f7ff fb39 	bl	8012444 <rt_list_isempty>
 8012dd2:	4603      	mov	r3, r0
 8012dd4:	2b00      	cmp	r3, #0
 8012dd6:	d10c      	bne.n	8012df2 <rt_mq_send+0x10e>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
 8012dd8:	68fb      	ldr	r3, [r7, #12]
 8012dda:	3314      	adds	r3, #20
 8012ddc:	4618      	mov	r0, r3
 8012dde:	f7ff fb99 	bl	8012514 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8012de2:	4623      	mov	r3, r4
 8012de4:	4618      	mov	r0, r3
 8012de6:	f7ed f9f3 	bl	80001d0 <rt_hw_interrupt_enable>

        rt_schedule();
 8012dea:	f001 fe8f 	bl	8014b0c <rt_schedule>

        return RT_EOK;
 8012dee:	2300      	movs	r3, #0
 8012df0:	e004      	b.n	8012dfc <rt_mq_send+0x118>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8012df2:	4623      	mov	r3, r4
 8012df4:	4618      	mov	r0, r3
 8012df6:	f7ed f9eb 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 8012dfa:	2300      	movs	r3, #0
}
 8012dfc:	4618      	mov	r0, r3
 8012dfe:	371c      	adds	r7, #28
 8012e00:	46bd      	mov	sp, r7
 8012e02:	bd90      	pop	{r4, r7, pc}
 8012e04:	08022d84 	.word	0x08022d84
 8012e08:	08024d30 	.word	0x08024d30
 8012e0c:	08022d94 	.word	0x08022d94
 8012e10:	08022da8 	.word	0x08022da8
 8012e14:	2001256c 	.word	0x2001256c

08012e18 <rt_mq_recv>:
 */
rt_err_t rt_mq_recv(rt_mq_t    mq,
                    void      *buffer,
                    rt_size_t  size,
                    rt_int32_t timeout)
{
 8012e18:	b590      	push	{r4, r7, lr}
 8012e1a:	b08b      	sub	sp, #44	; 0x2c
 8012e1c:	af00      	add	r7, sp, #0
 8012e1e:	60f8      	str	r0, [r7, #12]
 8012e20:	60b9      	str	r1, [r7, #8]
 8012e22:	607a      	str	r2, [r7, #4]
 8012e24:	603b      	str	r3, [r7, #0]
    struct rt_thread *thread;
    register rt_ubase_t temp;
    struct rt_mq_message *msg;
    rt_uint32_t tick_delta;

    RT_ASSERT(mq != RT_NULL);
 8012e26:	68fb      	ldr	r3, [r7, #12]
 8012e28:	2b00      	cmp	r3, #0
 8012e2a:	d105      	bne.n	8012e38 <rt_mq_recv+0x20>
 8012e2c:	487f      	ldr	r0, [pc, #508]	; (801302c <rt_mq_recv+0x214>)
 8012e2e:	4980      	ldr	r1, [pc, #512]	; (8013030 <rt_mq_recv+0x218>)
 8012e30:	f640 0239 	movw	r2, #2105	; 0x839
 8012e34:	f000 ff96 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
 8012e38:	68bb      	ldr	r3, [r7, #8]
 8012e3a:	2b00      	cmp	r3, #0
 8012e3c:	d105      	bne.n	8012e4a <rt_mq_recv+0x32>
 8012e3e:	487d      	ldr	r0, [pc, #500]	; (8013034 <rt_mq_recv+0x21c>)
 8012e40:	497b      	ldr	r1, [pc, #492]	; (8013030 <rt_mq_recv+0x218>)
 8012e42:	f640 023a 	movw	r2, #2106	; 0x83a
 8012e46:	f000 ff8d 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(size != 0);
 8012e4a:	687b      	ldr	r3, [r7, #4]
 8012e4c:	2b00      	cmp	r3, #0
 8012e4e:	d105      	bne.n	8012e5c <rt_mq_recv+0x44>
 8012e50:	4879      	ldr	r0, [pc, #484]	; (8013038 <rt_mq_recv+0x220>)
 8012e52:	4977      	ldr	r1, [pc, #476]	; (8013030 <rt_mq_recv+0x218>)
 8012e54:	f640 023b 	movw	r2, #2107	; 0x83b
 8012e58:	f000 ff84 	bl	8013d64 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
 8012e5c:	2300      	movs	r3, #0
 8012e5e:	627b      	str	r3, [r7, #36]	; 0x24
    /* get current thread */
    thread = rt_thread_self();
 8012e60:	f002 f890 	bl	8014f84 <rt_thread_self>
 8012e64:	6238      	str	r0, [r7, #32]
    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
 8012e66:	4b75      	ldr	r3, [pc, #468]	; (801303c <rt_mq_recv+0x224>)
 8012e68:	681b      	ldr	r3, [r3, #0]
 8012e6a:	2b00      	cmp	r3, #0
 8012e6c:	d004      	beq.n	8012e78 <rt_mq_recv+0x60>
 8012e6e:	4b73      	ldr	r3, [pc, #460]	; (801303c <rt_mq_recv+0x224>)
 8012e70:	681b      	ldr	r3, [r3, #0]
 8012e72:	68fa      	ldr	r2, [r7, #12]
 8012e74:	4610      	mov	r0, r2
 8012e76:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8012e78:	f7ed f9a6 	bl	80001c8 <rt_hw_interrupt_disable>
 8012e7c:	4603      	mov	r3, r0
 8012e7e:	461c      	mov	r4, r3

    /* for non-blocking call */
    if (mq->entry == 0 && timeout == 0)
 8012e80:	68fb      	ldr	r3, [r7, #12]
 8012e82:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8012e84:	2b00      	cmp	r3, #0
 8012e86:	d109      	bne.n	8012e9c <rt_mq_recv+0x84>
 8012e88:	683b      	ldr	r3, [r7, #0]
 8012e8a:	2b00      	cmp	r3, #0
 8012e8c:	d106      	bne.n	8012e9c <rt_mq_recv+0x84>
    {
        rt_hw_interrupt_enable(temp);
 8012e8e:	4623      	mov	r3, r4
 8012e90:	4618      	mov	r0, r3
 8012e92:	f7ed f99d 	bl	80001d0 <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
 8012e96:	f06f 0301 	mvn.w	r3, #1
 8012e9a:	e0c2      	b.n	8013022 <rt_mq_recv+0x20a>
    }

    /* message queue is empty */
    while (mq->entry == 0)
 8012e9c:	e07c      	b.n	8012f98 <rt_mq_recv+0x180>
    {
        RT_DEBUG_IN_THREAD_CONTEXT;
 8012e9e:	f7ed f993 	bl	80001c8 <rt_hw_interrupt_disable>
 8012ea2:	61f8      	str	r0, [r7, #28]
 8012ea4:	f002 f86e 	bl	8014f84 <rt_thread_self>
 8012ea8:	4603      	mov	r3, r0
 8012eaa:	2b00      	cmp	r3, #0
 8012eac:	d109      	bne.n	8012ec2 <rt_mq_recv+0xaa>
 8012eae:	4864      	ldr	r0, [pc, #400]	; (8013040 <rt_mq_recv+0x228>)
 8012eb0:	495f      	ldr	r1, [pc, #380]	; (8013030 <rt_mq_recv+0x218>)
 8012eb2:	f000 fedd 	bl	8013c70 <rt_kprintf>
 8012eb6:	4863      	ldr	r0, [pc, #396]	; (8013044 <rt_mq_recv+0x22c>)
 8012eb8:	495d      	ldr	r1, [pc, #372]	; (8013030 <rt_mq_recv+0x218>)
 8012eba:	f640 0251 	movw	r2, #2129	; 0x851
 8012ebe:	f000 ff51 	bl	8013d64 <rt_assert_handler>
 8012ec2:	f7ed f981 	bl	80001c8 <rt_hw_interrupt_disable>
 8012ec6:	61b8      	str	r0, [r7, #24]
 8012ec8:	f000 f8ee 	bl	80130a8 <rt_interrupt_get_nest>
 8012ecc:	4603      	mov	r3, r0
 8012ece:	2b00      	cmp	r3, #0
 8012ed0:	d009      	beq.n	8012ee6 <rt_mq_recv+0xce>
 8012ed2:	485d      	ldr	r0, [pc, #372]	; (8013048 <rt_mq_recv+0x230>)
 8012ed4:	4956      	ldr	r1, [pc, #344]	; (8013030 <rt_mq_recv+0x218>)
 8012ed6:	f000 fecb 	bl	8013c70 <rt_kprintf>
 8012eda:	485a      	ldr	r0, [pc, #360]	; (8013044 <rt_mq_recv+0x22c>)
 8012edc:	4954      	ldr	r1, [pc, #336]	; (8013030 <rt_mq_recv+0x218>)
 8012ede:	f640 0251 	movw	r2, #2129	; 0x851
 8012ee2:	f000 ff3f 	bl	8013d64 <rt_assert_handler>
 8012ee6:	69b8      	ldr	r0, [r7, #24]
 8012ee8:	f7ed f972 	bl	80001d0 <rt_hw_interrupt_enable>
 8012eec:	69f8      	ldr	r0, [r7, #28]
 8012eee:	f7ed f96f 	bl	80001d0 <rt_hw_interrupt_enable>

        /* reset error number in thread */
        thread->error = RT_EOK;
 8012ef2:	6a3b      	ldr	r3, [r7, #32]
 8012ef4:	2200      	movs	r2, #0
 8012ef6:	631a      	str	r2, [r3, #48]	; 0x30

        /* no waiting, return timeout */
        if (timeout == 0)
 8012ef8:	683b      	ldr	r3, [r7, #0]
 8012efa:	2b00      	cmp	r3, #0
 8012efc:	d10a      	bne.n	8012f14 <rt_mq_recv+0xfc>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
 8012efe:	4623      	mov	r3, r4
 8012f00:	4618      	mov	r0, r3
 8012f02:	f7ed f965 	bl	80001d0 <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
 8012f06:	6a3b      	ldr	r3, [r7, #32]
 8012f08:	f06f 0201 	mvn.w	r2, #1
 8012f0c:	631a      	str	r2, [r3, #48]	; 0x30

            return -RT_ETIMEOUT;
 8012f0e:	f06f 0301 	mvn.w	r3, #1
 8012f12:	e086      	b.n	8013022 <rt_mq_recv+0x20a>
        }

        /* suspend current thread */
        rt_ipc_list_suspend(&(mq->parent.suspend_thread),
 8012f14:	68fb      	ldr	r3, [r7, #12]
 8012f16:	f103 0214 	add.w	r2, r3, #20
 8012f1a:	68fb      	ldr	r3, [r7, #12]
 8012f1c:	7a5b      	ldrb	r3, [r3, #9]
 8012f1e:	4610      	mov	r0, r2
 8012f20:	6a39      	ldr	r1, [r7, #32]
 8012f22:	461a      	mov	r2, r3
 8012f24:	f7ff faae 	bl	8012484 <rt_ipc_list_suspend>
                            thread,
                            mq->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
 8012f28:	683b      	ldr	r3, [r7, #0]
 8012f2a:	2b00      	cmp	r3, #0
 8012f2c:	dd10      	ble.n	8012f50 <rt_mq_recv+0x138>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
 8012f2e:	f7fe ff5b 	bl	8011de8 <rt_tick_get>
 8012f32:	6278      	str	r0, [r7, #36]	; 0x24

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 8012f34:	6a3b      	ldr	r3, [r7, #32]
 8012f36:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8012f3a:	463b      	mov	r3, r7
 8012f3c:	4610      	mov	r0, r2
 8012f3e:	2100      	movs	r1, #0
 8012f40:	461a      	mov	r2, r3
 8012f42:	f002 fc9f 	bl	8015884 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 8012f46:	6a3b      	ldr	r3, [r7, #32]
 8012f48:	334c      	adds	r3, #76	; 0x4c
 8012f4a:	4618      	mov	r0, r3
 8012f4c:	f002 fb54 	bl	80155f8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8012f50:	4623      	mov	r3, r4
 8012f52:	4618      	mov	r0, r3
 8012f54:	f7ed f93c 	bl	80001d0 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
 8012f58:	f001 fdd8 	bl	8014b0c <rt_schedule>

        /* recv message */
        if (thread->error != RT_EOK)
 8012f5c:	6a3b      	ldr	r3, [r7, #32]
 8012f5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012f60:	2b00      	cmp	r3, #0
 8012f62:	d002      	beq.n	8012f6a <rt_mq_recv+0x152>
        {
            /* return error */
            return thread->error;
 8012f64:	6a3b      	ldr	r3, [r7, #32]
 8012f66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012f68:	e05b      	b.n	8013022 <rt_mq_recv+0x20a>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 8012f6a:	f7ed f92d 	bl	80001c8 <rt_hw_interrupt_disable>
 8012f6e:	4603      	mov	r3, r0
 8012f70:	461c      	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
 8012f72:	683b      	ldr	r3, [r7, #0]
 8012f74:	2b00      	cmp	r3, #0
 8012f76:	dd0f      	ble.n	8012f98 <rt_mq_recv+0x180>
        {
            tick_delta = rt_tick_get() - tick_delta;
 8012f78:	f7fe ff36 	bl	8011de8 <rt_tick_get>
 8012f7c:	4602      	mov	r2, r0
 8012f7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012f80:	1ad3      	subs	r3, r2, r3
 8012f82:	627b      	str	r3, [r7, #36]	; 0x24
            timeout -= tick_delta;
 8012f84:	683b      	ldr	r3, [r7, #0]
 8012f86:	461a      	mov	r2, r3
 8012f88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012f8a:	1ad3      	subs	r3, r2, r3
 8012f8c:	603b      	str	r3, [r7, #0]
            if (timeout < 0)
 8012f8e:	683b      	ldr	r3, [r7, #0]
 8012f90:	2b00      	cmp	r3, #0
 8012f92:	da01      	bge.n	8012f98 <rt_mq_recv+0x180>
                timeout = 0;
 8012f94:	2300      	movs	r3, #0
 8012f96:	603b      	str	r3, [r7, #0]

        return -RT_ETIMEOUT;
    }

    /* message queue is empty */
    while (mq->entry == 0)
 8012f98:	68fb      	ldr	r3, [r7, #12]
 8012f9a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8012f9c:	2b00      	cmp	r3, #0
 8012f9e:	f43f af7e 	beq.w	8012e9e <rt_mq_recv+0x86>
                timeout = 0;
        }
    }

    /* get message from queue */
    msg = (struct rt_mq_message *)mq->msg_queue_head;
 8012fa2:	68fb      	ldr	r3, [r7, #12]
 8012fa4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012fa6:	617b      	str	r3, [r7, #20]
	
    /* move message queue head */
    mq->msg_queue_head = msg->next;
 8012fa8:	697b      	ldr	r3, [r7, #20]
 8012faa:	681a      	ldr	r2, [r3, #0]
 8012fac:	68fb      	ldr	r3, [r7, #12]
 8012fae:	629a      	str	r2, [r3, #40]	; 0x28
    /* reach queue tail, set to NULL */
    if (mq->msg_queue_tail == msg)
 8012fb0:	68fb      	ldr	r3, [r7, #12]
 8012fb2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8012fb4:	697b      	ldr	r3, [r7, #20]
 8012fb6:	429a      	cmp	r2, r3
 8012fb8:	d102      	bne.n	8012fc0 <rt_mq_recv+0x1a8>
        mq->msg_queue_tail = RT_NULL;
 8012fba:	68fb      	ldr	r3, [r7, #12]
 8012fbc:	2200      	movs	r2, #0
 8012fbe:	62da      	str	r2, [r3, #44]	; 0x2c

    /* decrease message entry */
    mq->entry --;
 8012fc0:	68fb      	ldr	r3, [r7, #12]
 8012fc2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8012fc4:	3b01      	subs	r3, #1
 8012fc6:	b29a      	uxth	r2, r3
 8012fc8:	68fb      	ldr	r3, [r7, #12]
 8012fca:	849a      	strh	r2, [r3, #36]	; 0x24

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8012fcc:	4623      	mov	r3, r4
 8012fce:	4618      	mov	r0, r3
 8012fd0:	f7ed f8fe 	bl	80001d0 <rt_hw_interrupt_enable>

    /* copy message */
    rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
 8012fd4:	697b      	ldr	r3, [r7, #20]
 8012fd6:	1d1a      	adds	r2, r3, #4
 8012fd8:	68fb      	ldr	r3, [r7, #12]
 8012fda:	8c1b      	ldrh	r3, [r3, #32]
 8012fdc:	4619      	mov	r1, r3
 8012fde:	687b      	ldr	r3, [r7, #4]
 8012fe0:	428b      	cmp	r3, r1
 8012fe2:	bf28      	it	cs
 8012fe4:	460b      	movcs	r3, r1
 8012fe6:	68b8      	ldr	r0, [r7, #8]
 8012fe8:	4611      	mov	r1, r2
 8012fea:	461a      	mov	r2, r3
 8012fec:	f000 f8e4 	bl	80131b8 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8012ff0:	f7ed f8ea 	bl	80001c8 <rt_hw_interrupt_disable>
 8012ff4:	4603      	mov	r3, r0
 8012ff6:	461c      	mov	r4, r3
    /* put message to free list */
    msg->next = (struct rt_mq_message *)mq->msg_queue_free;
 8012ff8:	68fb      	ldr	r3, [r7, #12]
 8012ffa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8012ffc:	697b      	ldr	r3, [r7, #20]
 8012ffe:	601a      	str	r2, [r3, #0]
    mq->msg_queue_free = msg;
 8013000:	68fb      	ldr	r3, [r7, #12]
 8013002:	697a      	ldr	r2, [r7, #20]
 8013004:	631a      	str	r2, [r3, #48]	; 0x30
    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8013006:	4623      	mov	r3, r4
 8013008:	4618      	mov	r0, r3
 801300a:	f7ed f8e1 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
 801300e:	4b0f      	ldr	r3, [pc, #60]	; (801304c <rt_mq_recv+0x234>)
 8013010:	681b      	ldr	r3, [r3, #0]
 8013012:	2b00      	cmp	r3, #0
 8013014:	d004      	beq.n	8013020 <rt_mq_recv+0x208>
 8013016:	4b0d      	ldr	r3, [pc, #52]	; (801304c <rt_mq_recv+0x234>)
 8013018:	681b      	ldr	r3, [r3, #0]
 801301a:	68fa      	ldr	r2, [r7, #12]
 801301c:	4610      	mov	r0, r2
 801301e:	4798      	blx	r3

    return RT_EOK;
 8013020:	2300      	movs	r3, #0
}
 8013022:	4618      	mov	r0, r3
 8013024:	372c      	adds	r7, #44	; 0x2c
 8013026:	46bd      	mov	sp, r7
 8013028:	bd90      	pop	{r4, r7, pc}
 801302a:	bf00      	nop
 801302c:	08022d84 	.word	0x08022d84
 8013030:	08024d3c 	.word	0x08024d3c
 8013034:	08022d94 	.word	0x08022d94
 8013038:	08022da8 	.word	0x08022da8
 801303c:	20012574 	.word	0x20012574
 8013040:	08022d14 	.word	0x08022d14
 8013044:	08022d10 	.word	0x08022d10
 8013048:	08022cec 	.word	0x08022cec
 801304c:	20012570 	.word	0x20012570

08013050 <rt_interrupt_enter>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_leave
 */
void rt_interrupt_enter(void)
{
 8013050:	b580      	push	{r7, lr}
 8013052:	b082      	sub	sp, #8
 8013054:	af00      	add	r7, sp, #0
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq coming..., irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
 8013056:	f7ed f8b7 	bl	80001c8 <rt_hw_interrupt_disable>
 801305a:	6078      	str	r0, [r7, #4]
    rt_interrupt_nest ++;
 801305c:	4b06      	ldr	r3, [pc, #24]	; (8013078 <rt_interrupt_enter+0x28>)
 801305e:	781b      	ldrb	r3, [r3, #0]
 8013060:	b2db      	uxtb	r3, r3
 8013062:	3301      	adds	r3, #1
 8013064:	b2da      	uxtb	r2, r3
 8013066:	4b04      	ldr	r3, [pc, #16]	; (8013078 <rt_interrupt_enter+0x28>)
 8013068:	701a      	strb	r2, [r3, #0]
    rt_hw_interrupt_enable(level);
 801306a:	6878      	ldr	r0, [r7, #4]
 801306c:	f7ed f8b0 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8013070:	3708      	adds	r7, #8
 8013072:	46bd      	mov	sp, r7
 8013074:	bd80      	pop	{r7, pc}
 8013076:	bf00      	nop
 8013078:	20012564 	.word	0x20012564

0801307c <rt_interrupt_leave>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_enter
 */
void rt_interrupt_leave(void)
{
 801307c:	b580      	push	{r7, lr}
 801307e:	b082      	sub	sp, #8
 8013080:	af00      	add	r7, sp, #0
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq leave, irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
 8013082:	f7ed f8a1 	bl	80001c8 <rt_hw_interrupt_disable>
 8013086:	6078      	str	r0, [r7, #4]
    rt_interrupt_nest --;
 8013088:	4b06      	ldr	r3, [pc, #24]	; (80130a4 <rt_interrupt_leave+0x28>)
 801308a:	781b      	ldrb	r3, [r3, #0]
 801308c:	b2db      	uxtb	r3, r3
 801308e:	3b01      	subs	r3, #1
 8013090:	b2da      	uxtb	r2, r3
 8013092:	4b04      	ldr	r3, [pc, #16]	; (80130a4 <rt_interrupt_leave+0x28>)
 8013094:	701a      	strb	r2, [r3, #0]
    rt_hw_interrupt_enable(level);
 8013096:	6878      	ldr	r0, [r7, #4]
 8013098:	f7ed f89a 	bl	80001d0 <rt_hw_interrupt_enable>
}
 801309c:	3708      	adds	r7, #8
 801309e:	46bd      	mov	sp, r7
 80130a0:	bd80      	pop	{r7, pc}
 80130a2:	bf00      	nop
 80130a4:	20012564 	.word	0x20012564

080130a8 <rt_interrupt_get_nest>:
 * context is interrupt context.
 *
 * @return the number of nested interrupts.
 */
rt_uint8_t rt_interrupt_get_nest(void)
{
 80130a8:	b480      	push	{r7}
 80130aa:	af00      	add	r7, sp, #0
    return rt_interrupt_nest;
 80130ac:	4b03      	ldr	r3, [pc, #12]	; (80130bc <rt_interrupt_get_nest+0x14>)
 80130ae:	781b      	ldrb	r3, [r3, #0]
 80130b0:	b2db      	uxtb	r3, r3
}
 80130b2:	4618      	mov	r0, r3
 80130b4:	46bd      	mov	sp, r7
 80130b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80130ba:	4770      	bx	lr
 80130bc:	20012564 	.word	0x20012564

080130c0 <rt_set_errno>:
 * This function will set errno
 *
 * @param error the errno shall be set
 */
void rt_set_errno(rt_err_t error)
{
 80130c0:	b580      	push	{r7, lr}
 80130c2:	b084      	sub	sp, #16
 80130c4:	af00      	add	r7, sp, #0
 80130c6:	6078      	str	r0, [r7, #4]
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
 80130c8:	f7ff ffee 	bl	80130a8 <rt_interrupt_get_nest>
 80130cc:	4603      	mov	r3, r0
 80130ce:	2b00      	cmp	r3, #0
 80130d0:	d003      	beq.n	80130da <rt_set_errno+0x1a>
    {
        /* it's in interrupt context */
        _errno = error;
 80130d2:	4a0a      	ldr	r2, [pc, #40]	; (80130fc <rt_set_errno+0x3c>)
 80130d4:	687b      	ldr	r3, [r7, #4]
 80130d6:	6013      	str	r3, [r2, #0]

        return;
 80130d8:	e00c      	b.n	80130f4 <rt_set_errno+0x34>
    }

    tid = rt_thread_self();
 80130da:	f001 ff53 	bl	8014f84 <rt_thread_self>
 80130de:	60f8      	str	r0, [r7, #12]
    if (tid == RT_NULL)
 80130e0:	68fb      	ldr	r3, [r7, #12]
 80130e2:	2b00      	cmp	r3, #0
 80130e4:	d103      	bne.n	80130ee <rt_set_errno+0x2e>
    {
        _errno = error;
 80130e6:	4a05      	ldr	r2, [pc, #20]	; (80130fc <rt_set_errno+0x3c>)
 80130e8:	687b      	ldr	r3, [r7, #4]
 80130ea:	6013      	str	r3, [r2, #0]

        return;
 80130ec:	e002      	b.n	80130f4 <rt_set_errno+0x34>
    }

    tid->error = error;
 80130ee:	68fb      	ldr	r3, [r7, #12]
 80130f0:	687a      	ldr	r2, [r7, #4]
 80130f2:	631a      	str	r2, [r3, #48]	; 0x30
}
 80130f4:	3710      	adds	r7, #16
 80130f6:	46bd      	mov	sp, r7
 80130f8:	bd80      	pop	{r7, pc}
 80130fa:	bf00      	nop
 80130fc:	20010d10 	.word	0x20010d10

08013100 <rt_memset>:
 * @param count the copied length
 *
 * @return the address of source memory
 */
void *rt_memset(void *s, int c, rt_ubase_t count)
{
 8013100:	b480      	push	{r7}
 8013102:	b089      	sub	sp, #36	; 0x24
 8013104:	af00      	add	r7, sp, #0
 8013106:	60f8      	str	r0, [r7, #12]
 8013108:	60b9      	str	r1, [r7, #8]
 801310a:	607a      	str	r2, [r7, #4]
#define LBLOCKSIZE      (sizeof(rt_int32_t))
#define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
#define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)

    int i;
    char *m = (char *)s;
 801310c:	68fb      	ldr	r3, [r7, #12]
 801310e:	61fb      	str	r3, [r7, #28]
    rt_uint32_t buffer;
    rt_uint32_t *aligned_addr;
    rt_uint32_t d = c & 0xff;
 8013110:	68bb      	ldr	r3, [r7, #8]
 8013112:	b2db      	uxtb	r3, r3
 8013114:	617b      	str	r3, [r7, #20]

    if (!TOO_SMALL(count) && !UNALIGNED(s))
 8013116:	687b      	ldr	r3, [r7, #4]
 8013118:	2b03      	cmp	r3, #3
 801311a:	d939      	bls.n	8013190 <rt_memset+0x90>
 801311c:	68fb      	ldr	r3, [r7, #12]
 801311e:	f003 0303 	and.w	r3, r3, #3
 8013122:	2b00      	cmp	r3, #0
 8013124:	d134      	bne.n	8013190 <rt_memset+0x90>
    {
        /* If we get this far, we know that n is large and m is word-aligned. */
        aligned_addr = (rt_uint32_t *)s;
 8013126:	68fb      	ldr	r3, [r7, #12]
 8013128:	61bb      	str	r3, [r7, #24]
        /* Store D into each char sized location in BUFFER so that
         * we can set large blocks quickly.
         */
        if (LBLOCKSIZE == 4)
        {
            buffer = (d << 8) | d;
 801312a:	697b      	ldr	r3, [r7, #20]
 801312c:	021a      	lsls	r2, r3, #8
 801312e:	697b      	ldr	r3, [r7, #20]
 8013130:	4313      	orrs	r3, r2
 8013132:	613b      	str	r3, [r7, #16]
            buffer |= (buffer << 16);
 8013134:	693b      	ldr	r3, [r7, #16]
 8013136:	041b      	lsls	r3, r3, #16
 8013138:	693a      	ldr	r2, [r7, #16]
 801313a:	4313      	orrs	r3, r2
 801313c:	613b      	str	r3, [r7, #16]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
 801313e:	e016      	b.n	801316e <rt_memset+0x6e>
        {
            *aligned_addr++ = buffer;
 8013140:	69bb      	ldr	r3, [r7, #24]
 8013142:	1d1a      	adds	r2, r3, #4
 8013144:	61ba      	str	r2, [r7, #24]
 8013146:	693a      	ldr	r2, [r7, #16]
 8013148:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 801314a:	69bb      	ldr	r3, [r7, #24]
 801314c:	1d1a      	adds	r2, r3, #4
 801314e:	61ba      	str	r2, [r7, #24]
 8013150:	693a      	ldr	r2, [r7, #16]
 8013152:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 8013154:	69bb      	ldr	r3, [r7, #24]
 8013156:	1d1a      	adds	r2, r3, #4
 8013158:	61ba      	str	r2, [r7, #24]
 801315a:	693a      	ldr	r2, [r7, #16]
 801315c:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 801315e:	69bb      	ldr	r3, [r7, #24]
 8013160:	1d1a      	adds	r2, r3, #4
 8013162:	61ba      	str	r2, [r7, #24]
 8013164:	693a      	ldr	r2, [r7, #16]
 8013166:	601a      	str	r2, [r3, #0]
            count -= 4 * LBLOCKSIZE;
 8013168:	687b      	ldr	r3, [r7, #4]
 801316a:	3b10      	subs	r3, #16
 801316c:	607b      	str	r3, [r7, #4]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
 801316e:	687b      	ldr	r3, [r7, #4]
 8013170:	2b0f      	cmp	r3, #15
 8013172:	d8e5      	bhi.n	8013140 <rt_memset+0x40>
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
 8013174:	e007      	b.n	8013186 <rt_memset+0x86>
        {
            *aligned_addr++ = buffer;
 8013176:	69bb      	ldr	r3, [r7, #24]
 8013178:	1d1a      	adds	r2, r3, #4
 801317a:	61ba      	str	r2, [r7, #24]
 801317c:	693a      	ldr	r2, [r7, #16]
 801317e:	601a      	str	r2, [r3, #0]
            count -= LBLOCKSIZE;
 8013180:	687b      	ldr	r3, [r7, #4]
 8013182:	3b04      	subs	r3, #4
 8013184:	607b      	str	r3, [r7, #4]
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
 8013186:	687b      	ldr	r3, [r7, #4]
 8013188:	2b03      	cmp	r3, #3
 801318a:	d8f4      	bhi.n	8013176 <rt_memset+0x76>
            *aligned_addr++ = buffer;
            count -= LBLOCKSIZE;
        }

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
 801318c:	69bb      	ldr	r3, [r7, #24]
 801318e:	61fb      	str	r3, [r7, #28]
    }

    while (count--)
 8013190:	e005      	b.n	801319e <rt_memset+0x9e>
    {
        *m++ = (char)d;
 8013192:	69fb      	ldr	r3, [r7, #28]
 8013194:	1c5a      	adds	r2, r3, #1
 8013196:	61fa      	str	r2, [r7, #28]
 8013198:	697a      	ldr	r2, [r7, #20]
 801319a:	b2d2      	uxtb	r2, r2
 801319c:	701a      	strb	r2, [r3, #0]

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
    }

    while (count--)
 801319e:	687b      	ldr	r3, [r7, #4]
 80131a0:	1e5a      	subs	r2, r3, #1
 80131a2:	607a      	str	r2, [r7, #4]
 80131a4:	2b00      	cmp	r3, #0
 80131a6:	d1f4      	bne.n	8013192 <rt_memset+0x92>
    {
        *m++ = (char)d;
    }

    return s;
 80131a8:	68fb      	ldr	r3, [r7, #12]

#undef LBLOCKSIZE
#undef UNALIGNED
#undef TOO_SMALL
#endif
}
 80131aa:	4618      	mov	r0, r3
 80131ac:	3724      	adds	r7, #36	; 0x24
 80131ae:	46bd      	mov	sp, r7
 80131b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80131b4:	4770      	bx	lr
 80131b6:	bf00      	nop

080131b8 <rt_memcpy>:
 * @param count the copied length
 *
 * @return the address of destination memory
 */
void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
{
 80131b8:	b480      	push	{r7}
 80131ba:	b08b      	sub	sp, #44	; 0x2c
 80131bc:	af00      	add	r7, sp, #0
 80131be:	60f8      	str	r0, [r7, #12]
 80131c0:	60b9      	str	r1, [r7, #8]
 80131c2:	607a      	str	r2, [r7, #4]
                         ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
#define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
#define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)

    char *dst_ptr = (char *)dst;
 80131c4:	68fb      	ldr	r3, [r7, #12]
 80131c6:	627b      	str	r3, [r7, #36]	; 0x24
    char *src_ptr = (char *)src;
 80131c8:	68bb      	ldr	r3, [r7, #8]
 80131ca:	623b      	str	r3, [r7, #32]
    rt_int32_t *aligned_dst;
    rt_int32_t *aligned_src;
    int len = count;
 80131cc:	687b      	ldr	r3, [r7, #4]
 80131ce:	617b      	str	r3, [r7, #20]

    /* If the size is small, or either SRC or DST is unaligned,
    then punt into the byte copy loop.  This should be rare. */
    if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
 80131d0:	697b      	ldr	r3, [r7, #20]
 80131d2:	2b0f      	cmp	r3, #15
 80131d4:	d944      	bls.n	8013260 <rt_memcpy+0xa8>
 80131d6:	6a3a      	ldr	r2, [r7, #32]
 80131d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80131da:	4313      	orrs	r3, r2
 80131dc:	f003 0303 	and.w	r3, r3, #3
 80131e0:	2b00      	cmp	r3, #0
 80131e2:	d13d      	bne.n	8013260 <rt_memcpy+0xa8>
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
 80131e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80131e6:	61fb      	str	r3, [r7, #28]
        aligned_src = (rt_int32_t *)src_ptr;
 80131e8:	6a3b      	ldr	r3, [r7, #32]
 80131ea:	61bb      	str	r3, [r7, #24]

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
 80131ec:	e022      	b.n	8013234 <rt_memcpy+0x7c>
        {
            *aligned_dst++ = *aligned_src++;
 80131ee:	69fb      	ldr	r3, [r7, #28]
 80131f0:	1d1a      	adds	r2, r3, #4
 80131f2:	61fa      	str	r2, [r7, #28]
 80131f4:	69ba      	ldr	r2, [r7, #24]
 80131f6:	1d11      	adds	r1, r2, #4
 80131f8:	61b9      	str	r1, [r7, #24]
 80131fa:	6812      	ldr	r2, [r2, #0]
 80131fc:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 80131fe:	69fb      	ldr	r3, [r7, #28]
 8013200:	1d1a      	adds	r2, r3, #4
 8013202:	61fa      	str	r2, [r7, #28]
 8013204:	69ba      	ldr	r2, [r7, #24]
 8013206:	1d11      	adds	r1, r2, #4
 8013208:	61b9      	str	r1, [r7, #24]
 801320a:	6812      	ldr	r2, [r2, #0]
 801320c:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 801320e:	69fb      	ldr	r3, [r7, #28]
 8013210:	1d1a      	adds	r2, r3, #4
 8013212:	61fa      	str	r2, [r7, #28]
 8013214:	69ba      	ldr	r2, [r7, #24]
 8013216:	1d11      	adds	r1, r2, #4
 8013218:	61b9      	str	r1, [r7, #24]
 801321a:	6812      	ldr	r2, [r2, #0]
 801321c:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 801321e:	69fb      	ldr	r3, [r7, #28]
 8013220:	1d1a      	adds	r2, r3, #4
 8013222:	61fa      	str	r2, [r7, #28]
 8013224:	69ba      	ldr	r2, [r7, #24]
 8013226:	1d11      	adds	r1, r2, #4
 8013228:	61b9      	str	r1, [r7, #24]
 801322a:	6812      	ldr	r2, [r2, #0]
 801322c:	601a      	str	r2, [r3, #0]
            len -= BIGBLOCKSIZE;
 801322e:	697b      	ldr	r3, [r7, #20]
 8013230:	3b10      	subs	r3, #16
 8013232:	617b      	str	r3, [r7, #20]
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
        aligned_src = (rt_int32_t *)src_ptr;

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
 8013234:	697b      	ldr	r3, [r7, #20]
 8013236:	2b0f      	cmp	r3, #15
 8013238:	d8d9      	bhi.n	80131ee <rt_memcpy+0x36>
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
 801323a:	e00a      	b.n	8013252 <rt_memcpy+0x9a>
        {
            *aligned_dst++ = *aligned_src++;
 801323c:	69fb      	ldr	r3, [r7, #28]
 801323e:	1d1a      	adds	r2, r3, #4
 8013240:	61fa      	str	r2, [r7, #28]
 8013242:	69ba      	ldr	r2, [r7, #24]
 8013244:	1d11      	adds	r1, r2, #4
 8013246:	61b9      	str	r1, [r7, #24]
 8013248:	6812      	ldr	r2, [r2, #0]
 801324a:	601a      	str	r2, [r3, #0]
            len -= LITTLEBLOCKSIZE;
 801324c:	697b      	ldr	r3, [r7, #20]
 801324e:	3b04      	subs	r3, #4
 8013250:	617b      	str	r3, [r7, #20]
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
 8013252:	697b      	ldr	r3, [r7, #20]
 8013254:	2b03      	cmp	r3, #3
 8013256:	d8f1      	bhi.n	801323c <rt_memcpy+0x84>
            *aligned_dst++ = *aligned_src++;
            len -= LITTLEBLOCKSIZE;
        }

        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
 8013258:	69fb      	ldr	r3, [r7, #28]
 801325a:	627b      	str	r3, [r7, #36]	; 0x24
        src_ptr = (char *)aligned_src;
 801325c:	69bb      	ldr	r3, [r7, #24]
 801325e:	623b      	str	r3, [r7, #32]
    }

    while (len--)
 8013260:	e007      	b.n	8013272 <rt_memcpy+0xba>
        *dst_ptr++ = *src_ptr++;
 8013262:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013264:	1c5a      	adds	r2, r3, #1
 8013266:	627a      	str	r2, [r7, #36]	; 0x24
 8013268:	6a3a      	ldr	r2, [r7, #32]
 801326a:	1c51      	adds	r1, r2, #1
 801326c:	6239      	str	r1, [r7, #32]
 801326e:	7812      	ldrb	r2, [r2, #0]
 8013270:	701a      	strb	r2, [r3, #0]
        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
        src_ptr = (char *)aligned_src;
    }

    while (len--)
 8013272:	697b      	ldr	r3, [r7, #20]
 8013274:	1e5a      	subs	r2, r3, #1
 8013276:	617a      	str	r2, [r7, #20]
 8013278:	2b00      	cmp	r3, #0
 801327a:	d1f2      	bne.n	8013262 <rt_memcpy+0xaa>
        *dst_ptr++ = *src_ptr++;

    return dst;
 801327c:	68fb      	ldr	r3, [r7, #12]
#undef UNALIGNED
#undef BIGBLOCKSIZE
#undef LITTLEBLOCKSIZE
#undef TOO_SMALL
#endif
}
 801327e:	4618      	mov	r0, r3
 8013280:	372c      	adds	r7, #44	; 0x2c
 8013282:	46bd      	mov	sp, r7
 8013284:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013288:	4770      	bx	lr
 801328a:	bf00      	nop

0801328c <rt_memmove>:
 * @param n the copied length
 *
 * @return the address of destination memory
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
 801328c:	b480      	push	{r7}
 801328e:	b087      	sub	sp, #28
 8013290:	af00      	add	r7, sp, #0
 8013292:	60f8      	str	r0, [r7, #12]
 8013294:	60b9      	str	r1, [r7, #8]
 8013296:	607a      	str	r2, [r7, #4]
    char *tmp = (char *)dest, *s = (char *)src;
 8013298:	68fb      	ldr	r3, [r7, #12]
 801329a:	617b      	str	r3, [r7, #20]
 801329c:	68bb      	ldr	r3, [r7, #8]
 801329e:	613b      	str	r3, [r7, #16]

    if (s < tmp && tmp < s + n)
 80132a0:	693a      	ldr	r2, [r7, #16]
 80132a2:	697b      	ldr	r3, [r7, #20]
 80132a4:	429a      	cmp	r2, r3
 80132a6:	d21e      	bcs.n	80132e6 <rt_memmove+0x5a>
 80132a8:	693a      	ldr	r2, [r7, #16]
 80132aa:	687b      	ldr	r3, [r7, #4]
 80132ac:	441a      	add	r2, r3
 80132ae:	697b      	ldr	r3, [r7, #20]
 80132b0:	429a      	cmp	r2, r3
 80132b2:	d918      	bls.n	80132e6 <rt_memmove+0x5a>
    {
        tmp += n;
 80132b4:	697a      	ldr	r2, [r7, #20]
 80132b6:	687b      	ldr	r3, [r7, #4]
 80132b8:	4413      	add	r3, r2
 80132ba:	617b      	str	r3, [r7, #20]
        s += n;
 80132bc:	693a      	ldr	r2, [r7, #16]
 80132be:	687b      	ldr	r3, [r7, #4]
 80132c0:	4413      	add	r3, r2
 80132c2:	613b      	str	r3, [r7, #16]

        while (n--)
 80132c4:	e009      	b.n	80132da <rt_memmove+0x4e>
            *(--tmp) = *(--s);
 80132c6:	697b      	ldr	r3, [r7, #20]
 80132c8:	3b01      	subs	r3, #1
 80132ca:	617b      	str	r3, [r7, #20]
 80132cc:	693b      	ldr	r3, [r7, #16]
 80132ce:	3b01      	subs	r3, #1
 80132d0:	613b      	str	r3, [r7, #16]
 80132d2:	693b      	ldr	r3, [r7, #16]
 80132d4:	781a      	ldrb	r2, [r3, #0]
 80132d6:	697b      	ldr	r3, [r7, #20]
 80132d8:	701a      	strb	r2, [r3, #0]
    if (s < tmp && tmp < s + n)
    {
        tmp += n;
        s += n;

        while (n--)
 80132da:	687b      	ldr	r3, [r7, #4]
 80132dc:	1e5a      	subs	r2, r3, #1
 80132de:	607a      	str	r2, [r7, #4]
 80132e0:	2b00      	cmp	r3, #0
 80132e2:	d1f0      	bne.n	80132c6 <rt_memmove+0x3a>
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
    char *tmp = (char *)dest, *s = (char *)src;

    if (s < tmp && tmp < s + n)
 80132e4:	e00d      	b.n	8013302 <rt_memmove+0x76>
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
 80132e6:	e007      	b.n	80132f8 <rt_memmove+0x6c>
            *tmp++ = *s++;
 80132e8:	697b      	ldr	r3, [r7, #20]
 80132ea:	1c5a      	adds	r2, r3, #1
 80132ec:	617a      	str	r2, [r7, #20]
 80132ee:	693a      	ldr	r2, [r7, #16]
 80132f0:	1c51      	adds	r1, r2, #1
 80132f2:	6139      	str	r1, [r7, #16]
 80132f4:	7812      	ldrb	r2, [r2, #0]
 80132f6:	701a      	strb	r2, [r3, #0]
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
 80132f8:	687b      	ldr	r3, [r7, #4]
 80132fa:	1e5a      	subs	r2, r3, #1
 80132fc:	607a      	str	r2, [r7, #4]
 80132fe:	2b00      	cmp	r3, #0
 8013300:	d1f2      	bne.n	80132e8 <rt_memmove+0x5c>
            *tmp++ = *s++;
    }

    return dest;
 8013302:	68fb      	ldr	r3, [r7, #12]
}
 8013304:	4618      	mov	r0, r3
 8013306:	371c      	adds	r7, #28
 8013308:	46bd      	mov	sp, r7
 801330a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801330e:	4770      	bx	lr

08013310 <rt_strncpy>:
 * @param n the maximum copied length
 *
 * @return the result
 */
char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
 8013310:	b480      	push	{r7}
 8013312:	b087      	sub	sp, #28
 8013314:	af00      	add	r7, sp, #0
 8013316:	60f8      	str	r0, [r7, #12]
 8013318:	60b9      	str	r1, [r7, #8]
 801331a:	607a      	str	r2, [r7, #4]
    if (n != 0)
 801331c:	687b      	ldr	r3, [r7, #4]
 801331e:	2b00      	cmp	r3, #0
 8013320:	d021      	beq.n	8013366 <rt_strncpy+0x56>
    {
        char *d = dst;
 8013322:	68fb      	ldr	r3, [r7, #12]
 8013324:	617b      	str	r3, [r7, #20]
        const char *s = src;
 8013326:	68bb      	ldr	r3, [r7, #8]
 8013328:	613b      	str	r3, [r7, #16]

        do
        {
            if ((*d++ = *s++) == 0)
 801332a:	697b      	ldr	r3, [r7, #20]
 801332c:	1c5a      	adds	r2, r3, #1
 801332e:	617a      	str	r2, [r7, #20]
 8013330:	693a      	ldr	r2, [r7, #16]
 8013332:	1c51      	adds	r1, r2, #1
 8013334:	6139      	str	r1, [r7, #16]
 8013336:	7812      	ldrb	r2, [r2, #0]
 8013338:	701a      	strb	r2, [r3, #0]
 801333a:	781b      	ldrb	r3, [r3, #0]
 801333c:	2b00      	cmp	r3, #0
 801333e:	d10c      	bne.n	801335a <rt_strncpy+0x4a>
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
 8013340:	e004      	b.n	801334c <rt_strncpy+0x3c>
                    *d++ = 0;
 8013342:	697b      	ldr	r3, [r7, #20]
 8013344:	1c5a      	adds	r2, r3, #1
 8013346:	617a      	str	r2, [r7, #20]
 8013348:	2200      	movs	r2, #0
 801334a:	701a      	strb	r2, [r3, #0]
        do
        {
            if ((*d++ = *s++) == 0)
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
 801334c:	687b      	ldr	r3, [r7, #4]
 801334e:	3b01      	subs	r3, #1
 8013350:	607b      	str	r3, [r7, #4]
 8013352:	687b      	ldr	r3, [r7, #4]
 8013354:	2b00      	cmp	r3, #0
 8013356:	d1f4      	bne.n	8013342 <rt_strncpy+0x32>
                    *d++ = 0;
                break;
 8013358:	e005      	b.n	8013366 <rt_strncpy+0x56>
            }
        } while (--n != 0);
 801335a:	687b      	ldr	r3, [r7, #4]
 801335c:	3b01      	subs	r3, #1
 801335e:	607b      	str	r3, [r7, #4]
 8013360:	687b      	ldr	r3, [r7, #4]
 8013362:	2b00      	cmp	r3, #0
 8013364:	d1e1      	bne.n	801332a <rt_strncpy+0x1a>
    }

    return (dst);
 8013366:	68fb      	ldr	r3, [r7, #12]
}
 8013368:	4618      	mov	r0, r3
 801336a:	371c      	adds	r7, #28
 801336c:	46bd      	mov	sp, r7
 801336e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013372:	4770      	bx	lr

08013374 <rt_strncmp>:
 * @param count the maximum compare length
 *
 * @return the result
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
 8013374:	b490      	push	{r4, r7}
 8013376:	b084      	sub	sp, #16
 8013378:	af00      	add	r7, sp, #0
 801337a:	60f8      	str	r0, [r7, #12]
 801337c:	60b9      	str	r1, [r7, #8]
 801337e:	607a      	str	r2, [r7, #4]
    register signed char __res = 0;
 8013380:	2400      	movs	r4, #0

    while (count)
 8013382:	e013      	b.n	80133ac <rt_strncmp+0x38>
    {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
 8013384:	68fb      	ldr	r3, [r7, #12]
 8013386:	781a      	ldrb	r2, [r3, #0]
 8013388:	68bb      	ldr	r3, [r7, #8]
 801338a:	1c59      	adds	r1, r3, #1
 801338c:	60b9      	str	r1, [r7, #8]
 801338e:	781b      	ldrb	r3, [r3, #0]
 8013390:	1ad3      	subs	r3, r2, r3
 8013392:	b2db      	uxtb	r3, r3
 8013394:	b2dc      	uxtb	r4, r3
 8013396:	2c00      	cmp	r4, #0
 8013398:	d10b      	bne.n	80133b2 <rt_strncmp+0x3e>
 801339a:	68fb      	ldr	r3, [r7, #12]
 801339c:	1c5a      	adds	r2, r3, #1
 801339e:	60fa      	str	r2, [r7, #12]
 80133a0:	781b      	ldrb	r3, [r3, #0]
 80133a2:	2b00      	cmp	r3, #0
 80133a4:	d005      	beq.n	80133b2 <rt_strncmp+0x3e>
            break;
        count --;
 80133a6:	687b      	ldr	r3, [r7, #4]
 80133a8:	3b01      	subs	r3, #1
 80133aa:	607b      	str	r3, [r7, #4]
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
    register signed char __res = 0;

    while (count)
 80133ac:	687b      	ldr	r3, [r7, #4]
 80133ae:	2b00      	cmp	r3, #0
 80133b0:	d1e8      	bne.n	8013384 <rt_strncmp+0x10>
        if ((__res = *cs - *ct++) != 0 || !*cs++)
            break;
        count --;
    }

    return __res;
 80133b2:	b263      	sxtb	r3, r4
}
 80133b4:	4618      	mov	r0, r3
 80133b6:	3710      	adds	r7, #16
 80133b8:	46bd      	mov	sp, r7
 80133ba:	bc90      	pop	{r4, r7}
 80133bc:	4770      	bx	lr
 80133be:	bf00      	nop

080133c0 <rt_strlen>:
 * @param s the string
 *
 * @return the length of string
 */
rt_size_t rt_strlen(const char *s)
{
 80133c0:	b480      	push	{r7}
 80133c2:	b085      	sub	sp, #20
 80133c4:	af00      	add	r7, sp, #0
 80133c6:	6078      	str	r0, [r7, #4]
    const char *sc;

    for (sc = s; *sc != '\0'; ++sc) /* nothing */
 80133c8:	687b      	ldr	r3, [r7, #4]
 80133ca:	60fb      	str	r3, [r7, #12]
 80133cc:	e002      	b.n	80133d4 <rt_strlen+0x14>
 80133ce:	68fb      	ldr	r3, [r7, #12]
 80133d0:	3301      	adds	r3, #1
 80133d2:	60fb      	str	r3, [r7, #12]
 80133d4:	68fb      	ldr	r3, [r7, #12]
 80133d6:	781b      	ldrb	r3, [r3, #0]
 80133d8:	2b00      	cmp	r3, #0
 80133da:	d1f8      	bne.n	80133ce <rt_strlen+0xe>
        ;

    return sc - s;
 80133dc:	68fa      	ldr	r2, [r7, #12]
 80133de:	687b      	ldr	r3, [r7, #4]
 80133e0:	1ad3      	subs	r3, r2, r3
}
 80133e2:	4618      	mov	r0, r3
 80133e4:	3714      	adds	r7, #20
 80133e6:	46bd      	mov	sp, r7
 80133e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80133ec:	4770      	bx	lr
 80133ee:	bf00      	nop

080133f0 <rt_show_version>:

/**
 * This function will show the version of rt-thread rtos
 */
void rt_show_version(void)
{
 80133f0:	b580      	push	{r7, lr}
 80133f2:	b082      	sub	sp, #8
 80133f4:	af02      	add	r7, sp, #8
    rt_kprintf("\n \\ | /\n");
 80133f6:	4809      	ldr	r0, [pc, #36]	; (801341c <rt_show_version+0x2c>)
 80133f8:	f000 fc3a 	bl	8013c70 <rt_kprintf>
    rt_kprintf("- RT -     Thread Operating System\n");
 80133fc:	4808      	ldr	r0, [pc, #32]	; (8013420 <rt_show_version+0x30>)
 80133fe:	f000 fc37 	bl	8013c70 <rt_kprintf>
    rt_kprintf(" / | \\     %d.%d.%d build %s\n",
 8013402:	4b08      	ldr	r3, [pc, #32]	; (8013424 <rt_show_version+0x34>)
 8013404:	9300      	str	r3, [sp, #0]
 8013406:	4808      	ldr	r0, [pc, #32]	; (8013428 <rt_show_version+0x38>)
 8013408:	2102      	movs	r1, #2
 801340a:	2201      	movs	r2, #1
 801340c:	2300      	movs	r3, #0
 801340e:	f000 fc2f 	bl	8013c70 <rt_kprintf>
               RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
    rt_kprintf(" 2006 - 2015 Copyright by rt-thread team\n");
 8013412:	4806      	ldr	r0, [pc, #24]	; (801342c <rt_show_version+0x3c>)
 8013414:	f000 fc2c 	bl	8013c70 <rt_kprintf>
}
 8013418:	46bd      	mov	sp, r7
 801341a:	bd80      	pop	{r7, pc}
 801341c:	08022db4 	.word	0x08022db4
 8013420:	08022dc0 	.word	0x08022dc0
 8013424:	08022e04 	.word	0x08022e04
 8013428:	08022de4 	.word	0x08022de4
 801342c:	08022e10 	.word	0x08022e10

08013430 <divide>:

/* private function */
#define isdigit(c)  ((unsigned)((c) - '0') < 10)

rt_inline rt_int32_t divide(rt_int32_t *n, rt_int32_t base)
{
 8013430:	b480      	push	{r7}
 8013432:	b085      	sub	sp, #20
 8013434:	af00      	add	r7, sp, #0
 8013436:	6078      	str	r0, [r7, #4]
 8013438:	6039      	str	r1, [r7, #0]
    rt_int32_t res;

    /* optimized for processor which does not support divide instructions. */
    if (base == 10)
 801343a:	683b      	ldr	r3, [r7, #0]
 801343c:	2b0a      	cmp	r3, #10
 801343e:	d117      	bne.n	8013470 <divide+0x40>
    {
        res = ((rt_uint32_t)*n) % 10U;
 8013440:	687b      	ldr	r3, [r7, #4]
 8013442:	681b      	ldr	r3, [r3, #0]
 8013444:	4619      	mov	r1, r3
 8013446:	4b13      	ldr	r3, [pc, #76]	; (8013494 <divide+0x64>)
 8013448:	fba3 2301 	umull	r2, r3, r3, r1
 801344c:	08da      	lsrs	r2, r3, #3
 801344e:	4613      	mov	r3, r2
 8013450:	009b      	lsls	r3, r3, #2
 8013452:	4413      	add	r3, r2
 8013454:	005b      	lsls	r3, r3, #1
 8013456:	1aca      	subs	r2, r1, r3
 8013458:	60fa      	str	r2, [r7, #12]
        *n = ((rt_uint32_t)*n) / 10U;
 801345a:	687b      	ldr	r3, [r7, #4]
 801345c:	681b      	ldr	r3, [r3, #0]
 801345e:	461a      	mov	r2, r3
 8013460:	4b0c      	ldr	r3, [pc, #48]	; (8013494 <divide+0x64>)
 8013462:	fba3 2302 	umull	r2, r3, r3, r2
 8013466:	08db      	lsrs	r3, r3, #3
 8013468:	461a      	mov	r2, r3
 801346a:	687b      	ldr	r3, [r7, #4]
 801346c:	601a      	str	r2, [r3, #0]
 801346e:	e00a      	b.n	8013486 <divide+0x56>
    }
    else
    {
        res = ((rt_uint32_t)*n) % 16U;
 8013470:	687b      	ldr	r3, [r7, #4]
 8013472:	681b      	ldr	r3, [r3, #0]
 8013474:	f003 030f 	and.w	r3, r3, #15
 8013478:	60fb      	str	r3, [r7, #12]
        *n = ((rt_uint32_t)*n) / 16U;
 801347a:	687b      	ldr	r3, [r7, #4]
 801347c:	681b      	ldr	r3, [r3, #0]
 801347e:	091b      	lsrs	r3, r3, #4
 8013480:	461a      	mov	r2, r3
 8013482:	687b      	ldr	r3, [r7, #4]
 8013484:	601a      	str	r2, [r3, #0]
    }

    return res;
 8013486:	68fb      	ldr	r3, [r7, #12]
}
 8013488:	4618      	mov	r0, r3
 801348a:	3714      	adds	r7, #20
 801348c:	46bd      	mov	sp, r7
 801348e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013492:	4770      	bx	lr
 8013494:	cccccccd 	.word	0xcccccccd

08013498 <skip_atoi>:

rt_inline int skip_atoi(const char **s)
{
 8013498:	b490      	push	{r4, r7}
 801349a:	b082      	sub	sp, #8
 801349c:	af00      	add	r7, sp, #0
 801349e:	6078      	str	r0, [r7, #4]
    register int i=0;
 80134a0:	2400      	movs	r4, #0
    while (isdigit(**s))
 80134a2:	e00d      	b.n	80134c0 <skip_atoi+0x28>
        i = i * 10 + *((*s)++) - '0';
 80134a4:	4623      	mov	r3, r4
 80134a6:	009b      	lsls	r3, r3, #2
 80134a8:	4423      	add	r3, r4
 80134aa:	005b      	lsls	r3, r3, #1
 80134ac:	4618      	mov	r0, r3
 80134ae:	687b      	ldr	r3, [r7, #4]
 80134b0:	681b      	ldr	r3, [r3, #0]
 80134b2:	1c59      	adds	r1, r3, #1
 80134b4:	687a      	ldr	r2, [r7, #4]
 80134b6:	6011      	str	r1, [r2, #0]
 80134b8:	781b      	ldrb	r3, [r3, #0]
 80134ba:	4403      	add	r3, r0
 80134bc:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
}

rt_inline int skip_atoi(const char **s)
{
    register int i=0;
    while (isdigit(**s))
 80134c0:	687b      	ldr	r3, [r7, #4]
 80134c2:	681b      	ldr	r3, [r3, #0]
 80134c4:	781b      	ldrb	r3, [r3, #0]
 80134c6:	3b30      	subs	r3, #48	; 0x30
 80134c8:	2b09      	cmp	r3, #9
 80134ca:	d9eb      	bls.n	80134a4 <skip_atoi+0xc>
        i = i * 10 + *((*s)++) - '0';

    return i;
 80134cc:	4623      	mov	r3, r4
}
 80134ce:	4618      	mov	r0, r3
 80134d0:	3708      	adds	r7, #8
 80134d2:	46bd      	mov	sp, r7
 80134d4:	bc90      	pop	{r4, r7}
 80134d6:	4770      	bx	lr

080134d8 <print_number>:
                          long  num,
                          int   base,
                          int   s,
                          int   type)
#endif
{
 80134d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80134da:	b08d      	sub	sp, #52	; 0x34
 80134dc:	af00      	add	r7, sp, #0
 80134de:	60f8      	str	r0, [r7, #12]
 80134e0:	60b9      	str	r1, [r7, #8]
 80134e2:	607a      	str	r2, [r7, #4]
 80134e4:	603b      	str	r3, [r7, #0]
    static const char small_digits[] = "0123456789abcdef";
    static const char large_digits[] = "0123456789ABCDEF";
    register int i;
    register int size;

    size = s;
 80134e6:	6cbc      	ldr	r4, [r7, #72]	; 0x48

    digits = (type & LARGE) ? large_digits : small_digits;
 80134e8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80134ea:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80134ee:	2b00      	cmp	r3, #0
 80134f0:	d001      	beq.n	80134f6 <print_number+0x1e>
 80134f2:	4b6c      	ldr	r3, [pc, #432]	; (80136a4 <print_number+0x1cc>)
 80134f4:	e000      	b.n	80134f8 <print_number+0x20>
 80134f6:	4b6c      	ldr	r3, [pc, #432]	; (80136a8 <print_number+0x1d0>)
 80134f8:	62bb      	str	r3, [r7, #40]	; 0x28
    if (type & LEFT)
 80134fa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80134fc:	f003 0310 	and.w	r3, r3, #16
 8013500:	2b00      	cmp	r3, #0
 8013502:	d003      	beq.n	801350c <print_number+0x34>
        type &= ~ZEROPAD;
 8013504:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013506:	f023 0301 	bic.w	r3, r3, #1
 801350a:	653b      	str	r3, [r7, #80]	; 0x50

    c = (type & ZEROPAD) ? '0' : ' ';
 801350c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801350e:	f003 0301 	and.w	r3, r3, #1
 8013512:	2b00      	cmp	r3, #0
 8013514:	d001      	beq.n	801351a <print_number+0x42>
 8013516:	2330      	movs	r3, #48	; 0x30
 8013518:	e000      	b.n	801351c <print_number+0x44>
 801351a:	2320      	movs	r3, #32
 801351c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    /* get sign */
    sign = 0;
 8013520:	2300      	movs	r3, #0
 8013522:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    if (type & SIGN)
 8013526:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013528:	f003 0302 	and.w	r3, r3, #2
 801352c:	2b00      	cmp	r3, #0
 801352e:	d01a      	beq.n	8013566 <print_number+0x8e>
    {
        if (num < 0)
 8013530:	687b      	ldr	r3, [r7, #4]
 8013532:	2b00      	cmp	r3, #0
 8013534:	da06      	bge.n	8013544 <print_number+0x6c>
        {
            sign = '-';
 8013536:	232d      	movs	r3, #45	; 0x2d
 8013538:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            num = -num;
 801353c:	687b      	ldr	r3, [r7, #4]
 801353e:	425b      	negs	r3, r3
 8013540:	607b      	str	r3, [r7, #4]
 8013542:	e010      	b.n	8013566 <print_number+0x8e>
        }
        else if (type & PLUS)
 8013544:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013546:	f003 0304 	and.w	r3, r3, #4
 801354a:	2b00      	cmp	r3, #0
 801354c:	d003      	beq.n	8013556 <print_number+0x7e>
            sign = '+';
 801354e:	232b      	movs	r3, #43	; 0x2b
 8013550:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8013554:	e007      	b.n	8013566 <print_number+0x8e>
        else if (type & SPACE)
 8013556:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013558:	f003 0308 	and.w	r3, r3, #8
 801355c:	2b00      	cmp	r3, #0
 801355e:	d002      	beq.n	8013566 <print_number+0x8e>
            sign = ' ';
 8013560:	2320      	movs	r3, #32
 8013562:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        else if (base == 8)
            size--;
    }
#endif

    i = 0;
 8013566:	2500      	movs	r5, #0
    if (num == 0)
 8013568:	687b      	ldr	r3, [r7, #4]
 801356a:	2b00      	cmp	r3, #0
 801356c:	d108      	bne.n	8013580 <print_number+0xa8>
        tmp[i++]='0';
 801356e:	462b      	mov	r3, r5
 8013570:	1c5d      	adds	r5, r3, #1
 8013572:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8013576:	4413      	add	r3, r2
 8013578:	2230      	movs	r2, #48	; 0x30
 801357a:	f803 2c1c 	strb.w	r2, [r3, #-28]
 801357e:	e014      	b.n	80135aa <print_number+0xd2>
    else
    {
        while (num != 0)
 8013580:	e010      	b.n	80135a4 <print_number+0xcc>
            tmp[i++] = digits[divide(&num, base)];
 8013582:	462e      	mov	r6, r5
 8013584:	1c75      	adds	r5, r6, #1
 8013586:	1d3b      	adds	r3, r7, #4
 8013588:	4618      	mov	r0, r3
 801358a:	6839      	ldr	r1, [r7, #0]
 801358c:	f7ff ff50 	bl	8013430 <divide>
 8013590:	4603      	mov	r3, r0
 8013592:	461a      	mov	r2, r3
 8013594:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013596:	4413      	add	r3, r2
 8013598:	781a      	ldrb	r2, [r3, #0]
 801359a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801359e:	4433      	add	r3, r6
 80135a0:	f803 2c1c 	strb.w	r2, [r3, #-28]
    i = 0;
    if (num == 0)
        tmp[i++]='0';
    else
    {
        while (num != 0)
 80135a4:	687b      	ldr	r3, [r7, #4]
 80135a6:	2b00      	cmp	r3, #0
 80135a8:	d1eb      	bne.n	8013582 <print_number+0xaa>
            tmp[i++] = digits[divide(&num, base)];
    }

#ifdef RT_PRINTF_PRECISION
    if (i > precision)
 80135aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80135ac:	429d      	cmp	r5, r3
 80135ae:	dd00      	ble.n	80135b2 <print_number+0xda>
        precision = i;
 80135b0:	64fd      	str	r5, [r7, #76]	; 0x4c
    size -= precision;
 80135b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80135b4:	1ae4      	subs	r4, r4, r3
#else
    size -= i;
#endif

    if (!(type&(ZEROPAD | LEFT)))
 80135b6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80135b8:	f003 0311 	and.w	r3, r3, #17
 80135bc:	2b00      	cmp	r3, #0
 80135be:	d115      	bne.n	80135ec <print_number+0x114>
    {
        if ((sign)&&(size>0))
 80135c0:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80135c4:	2b00      	cmp	r3, #0
 80135c6:	d002      	beq.n	80135ce <print_number+0xf6>
 80135c8:	2c00      	cmp	r4, #0
 80135ca:	dd00      	ble.n	80135ce <print_number+0xf6>
            size--;
 80135cc:	3c01      	subs	r4, #1

        while (size-->0)
 80135ce:	e009      	b.n	80135e4 <print_number+0x10c>
        {
            if (buf <= end)
 80135d0:	68fa      	ldr	r2, [r7, #12]
 80135d2:	68bb      	ldr	r3, [r7, #8]
 80135d4:	429a      	cmp	r2, r3
 80135d6:	d802      	bhi.n	80135de <print_number+0x106>
                *buf = ' ';
 80135d8:	68fb      	ldr	r3, [r7, #12]
 80135da:	2220      	movs	r2, #32
 80135dc:	701a      	strb	r2, [r3, #0]
            ++ buf;
 80135de:	68fb      	ldr	r3, [r7, #12]
 80135e0:	3301      	adds	r3, #1
 80135e2:	60fb      	str	r3, [r7, #12]
    if (!(type&(ZEROPAD | LEFT)))
    {
        if ((sign)&&(size>0))
            size--;

        while (size-->0)
 80135e4:	4623      	mov	r3, r4
 80135e6:	1e5c      	subs	r4, r3, #1
 80135e8:	2b00      	cmp	r3, #0
 80135ea:	dcf1      	bgt.n	80135d0 <print_number+0xf8>
                *buf = ' ';
            ++ buf;
        }
    }

    if (sign)
 80135ec:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80135f0:	2b00      	cmp	r3, #0
 80135f2:	d00b      	beq.n	801360c <print_number+0x134>
    {
        if (buf <= end)
 80135f4:	68fa      	ldr	r2, [r7, #12]
 80135f6:	68bb      	ldr	r3, [r7, #8]
 80135f8:	429a      	cmp	r2, r3
 80135fa:	d804      	bhi.n	8013606 <print_number+0x12e>
        {
            *buf = sign;
 80135fc:	68fb      	ldr	r3, [r7, #12]
 80135fe:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 8013602:	701a      	strb	r2, [r3, #0]
            -- size;
 8013604:	3c01      	subs	r4, #1
        }
        ++ buf;
 8013606:	68fb      	ldr	r3, [r7, #12]
 8013608:	3301      	adds	r3, #1
 801360a:	60fb      	str	r3, [r7, #12]
        }
    }
#endif

    /* no align to the left */
    if (!(type & LEFT))
 801360c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801360e:	f003 0310 	and.w	r3, r3, #16
 8013612:	2b00      	cmp	r3, #0
 8013614:	d10f      	bne.n	8013636 <print_number+0x15e>
    {
        while (size-- > 0)
 8013616:	e00a      	b.n	801362e <print_number+0x156>
        {
            if (buf <= end)
 8013618:	68fa      	ldr	r2, [r7, #12]
 801361a:	68bb      	ldr	r3, [r7, #8]
 801361c:	429a      	cmp	r2, r3
 801361e:	d803      	bhi.n	8013628 <print_number+0x150>
                *buf = c;
 8013620:	68fb      	ldr	r3, [r7, #12]
 8013622:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8013626:	701a      	strb	r2, [r3, #0]
            ++ buf;
 8013628:	68fb      	ldr	r3, [r7, #12]
 801362a:	3301      	adds	r3, #1
 801362c:	60fb      	str	r3, [r7, #12]
#endif

    /* no align to the left */
    if (!(type & LEFT))
    {
        while (size-- > 0)
 801362e:	4623      	mov	r3, r4
 8013630:	1e5c      	subs	r4, r3, #1
 8013632:	2b00      	cmp	r3, #0
 8013634:	dcf0      	bgt.n	8013618 <print_number+0x140>
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
 8013636:	e009      	b.n	801364c <print_number+0x174>
    {
        if (buf <= end)
 8013638:	68fa      	ldr	r2, [r7, #12]
 801363a:	68bb      	ldr	r3, [r7, #8]
 801363c:	429a      	cmp	r2, r3
 801363e:	d802      	bhi.n	8013646 <print_number+0x16e>
            *buf = '0';
 8013640:	68fb      	ldr	r3, [r7, #12]
 8013642:	2230      	movs	r2, #48	; 0x30
 8013644:	701a      	strb	r2, [r3, #0]
        ++ buf;
 8013646:	68fb      	ldr	r3, [r7, #12]
 8013648:	3301      	adds	r3, #1
 801364a:	60fb      	str	r3, [r7, #12]
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
 801364c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801364e:	1e5a      	subs	r2, r3, #1
 8013650:	64fa      	str	r2, [r7, #76]	; 0x4c
 8013652:	42ab      	cmp	r3, r5
 8013654:	dcf0      	bgt.n	8013638 <print_number+0x160>
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
 8013656:	e00d      	b.n	8013674 <print_number+0x19c>
    {
        if (buf <= end)
 8013658:	68fa      	ldr	r2, [r7, #12]
 801365a:	68bb      	ldr	r3, [r7, #8]
 801365c:	429a      	cmp	r2, r3
 801365e:	d806      	bhi.n	801366e <print_number+0x196>
            *buf = tmp[i];
 8013660:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8013664:	442b      	add	r3, r5
 8013666:	f813 2c1c 	ldrb.w	r2, [r3, #-28]
 801366a:	68fb      	ldr	r3, [r7, #12]
 801366c:	701a      	strb	r2, [r3, #0]
        ++ buf;
 801366e:	68fb      	ldr	r3, [r7, #12]
 8013670:	3301      	adds	r3, #1
 8013672:	60fb      	str	r3, [r7, #12]
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
 8013674:	462b      	mov	r3, r5
 8013676:	1e5d      	subs	r5, r3, #1
 8013678:	2b00      	cmp	r3, #0
 801367a:	dced      	bgt.n	8013658 <print_number+0x180>
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
 801367c:	e009      	b.n	8013692 <print_number+0x1ba>
    {
        if (buf <= end)
 801367e:	68fa      	ldr	r2, [r7, #12]
 8013680:	68bb      	ldr	r3, [r7, #8]
 8013682:	429a      	cmp	r2, r3
 8013684:	d802      	bhi.n	801368c <print_number+0x1b4>
            *buf = ' ';
 8013686:	68fb      	ldr	r3, [r7, #12]
 8013688:	2220      	movs	r2, #32
 801368a:	701a      	strb	r2, [r3, #0]
        ++ buf;
 801368c:	68fb      	ldr	r3, [r7, #12]
 801368e:	3301      	adds	r3, #1
 8013690:	60fb      	str	r3, [r7, #12]
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
 8013692:	4623      	mov	r3, r4
 8013694:	1e5c      	subs	r4, r3, #1
 8013696:	2b00      	cmp	r3, #0
 8013698:	dcf1      	bgt.n	801367e <print_number+0x1a6>
        if (buf <= end)
            *buf = ' ';
        ++ buf;
    }

    return buf;
 801369a:	68fb      	ldr	r3, [r7, #12]
}
 801369c:	4618      	mov	r0, r3
 801369e:	3734      	adds	r7, #52	; 0x34
 80136a0:	46bd      	mov	sp, r7
 80136a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80136a4:	08024e48 	.word	0x08024e48
 80136a8:	08024e5c 	.word	0x08024e5c

080136ac <rt_vsnprintf>:

rt_int32_t rt_vsnprintf(char       *buf,
                        rt_size_t   size,
                        const char *fmt,
                        va_list     args)
{
 80136ac:	b5b0      	push	{r4, r5, r7, lr}
 80136ae:	b092      	sub	sp, #72	; 0x48
 80136b0:	af04      	add	r7, sp, #16
 80136b2:	60f8      	str	r0, [r7, #12]
 80136b4:	60b9      	str	r1, [r7, #8]
 80136b6:	607a      	str	r2, [r7, #4]
 80136b8:	603b      	str	r3, [r7, #0]

#ifdef RT_PRINTF_PRECISION
    int precision;      /* min. # of digits for integers and max for a string */
#endif

    str = buf;
 80136ba:	68fb      	ldr	r3, [r7, #12]
 80136bc:	62bb      	str	r3, [r7, #40]	; 0x28
    end = buf + size - 1;
 80136be:	68bb      	ldr	r3, [r7, #8]
 80136c0:	3b01      	subs	r3, #1
 80136c2:	68fa      	ldr	r2, [r7, #12]
 80136c4:	4413      	add	r3, r2
 80136c6:	627b      	str	r3, [r7, #36]	; 0x24

    /* Make sure end is always >= buf */
    if (end < buf)
 80136c8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80136ca:	68fb      	ldr	r3, [r7, #12]
 80136cc:	429a      	cmp	r2, r3
 80136ce:	d206      	bcs.n	80136de <rt_vsnprintf+0x32>
    {
        end  = ((char *)-1);
 80136d0:	f04f 33ff 	mov.w	r3, #4294967295
 80136d4:	627b      	str	r3, [r7, #36]	; 0x24
        size = end - buf;
 80136d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80136d8:	68fb      	ldr	r3, [r7, #12]
 80136da:	1ad3      	subs	r3, r2, r3
 80136dc:	60bb      	str	r3, [r7, #8]
    }

    for (; *fmt ; ++fmt)
 80136de:	e271      	b.n	8013bc4 <rt_vsnprintf+0x518>
    {
        if (*fmt != '%')
 80136e0:	687b      	ldr	r3, [r7, #4]
 80136e2:	781b      	ldrb	r3, [r3, #0]
 80136e4:	2b25      	cmp	r3, #37	; 0x25
 80136e6:	d00b      	beq.n	8013700 <rt_vsnprintf+0x54>
        {
            if (str <= end)
 80136e8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80136ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80136ec:	429a      	cmp	r2, r3
 80136ee:	d803      	bhi.n	80136f8 <rt_vsnprintf+0x4c>
                *str = *fmt;
 80136f0:	687b      	ldr	r3, [r7, #4]
 80136f2:	781a      	ldrb	r2, [r3, #0]
 80136f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80136f6:	701a      	strb	r2, [r3, #0]
            ++ str;
 80136f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80136fa:	3301      	adds	r3, #1
 80136fc:	62bb      	str	r3, [r7, #40]	; 0x28
            continue;
 80136fe:	e25e      	b.n	8013bbe <rt_vsnprintf+0x512>
        }

        /* process flags */
        flags = 0;
 8013700:	2300      	movs	r3, #0
 8013702:	77bb      	strb	r3, [r7, #30]

        while (1)
        {
            /* skips the first '%' also */
            ++ fmt;
 8013704:	687b      	ldr	r3, [r7, #4]
 8013706:	3301      	adds	r3, #1
 8013708:	607b      	str	r3, [r7, #4]
            if (*fmt == '-') flags |= LEFT;
 801370a:	687b      	ldr	r3, [r7, #4]
 801370c:	781b      	ldrb	r3, [r3, #0]
 801370e:	2b2d      	cmp	r3, #45	; 0x2d
 8013710:	d104      	bne.n	801371c <rt_vsnprintf+0x70>
 8013712:	7fbb      	ldrb	r3, [r7, #30]
 8013714:	f043 0310 	orr.w	r3, r3, #16
 8013718:	77bb      	strb	r3, [r7, #30]
 801371a:	e02d      	b.n	8013778 <rt_vsnprintf+0xcc>
            else if (*fmt == '+') flags |= PLUS;
 801371c:	687b      	ldr	r3, [r7, #4]
 801371e:	781b      	ldrb	r3, [r3, #0]
 8013720:	2b2b      	cmp	r3, #43	; 0x2b
 8013722:	d104      	bne.n	801372e <rt_vsnprintf+0x82>
 8013724:	7fbb      	ldrb	r3, [r7, #30]
 8013726:	f043 0304 	orr.w	r3, r3, #4
 801372a:	77bb      	strb	r3, [r7, #30]
 801372c:	e024      	b.n	8013778 <rt_vsnprintf+0xcc>
            else if (*fmt == ' ') flags |= SPACE;
 801372e:	687b      	ldr	r3, [r7, #4]
 8013730:	781b      	ldrb	r3, [r3, #0]
 8013732:	2b20      	cmp	r3, #32
 8013734:	d104      	bne.n	8013740 <rt_vsnprintf+0x94>
 8013736:	7fbb      	ldrb	r3, [r7, #30]
 8013738:	f043 0308 	orr.w	r3, r3, #8
 801373c:	77bb      	strb	r3, [r7, #30]
 801373e:	e01b      	b.n	8013778 <rt_vsnprintf+0xcc>
            else if (*fmt == '#') flags |= SPECIAL;
 8013740:	687b      	ldr	r3, [r7, #4]
 8013742:	781b      	ldrb	r3, [r3, #0]
 8013744:	2b23      	cmp	r3, #35	; 0x23
 8013746:	d104      	bne.n	8013752 <rt_vsnprintf+0xa6>
 8013748:	7fbb      	ldrb	r3, [r7, #30]
 801374a:	f043 0320 	orr.w	r3, r3, #32
 801374e:	77bb      	strb	r3, [r7, #30]
 8013750:	e012      	b.n	8013778 <rt_vsnprintf+0xcc>
            else if (*fmt == '0') flags |= ZEROPAD;
 8013752:	687b      	ldr	r3, [r7, #4]
 8013754:	781b      	ldrb	r3, [r3, #0]
 8013756:	2b30      	cmp	r3, #48	; 0x30
 8013758:	d104      	bne.n	8013764 <rt_vsnprintf+0xb8>
 801375a:	7fbb      	ldrb	r3, [r7, #30]
 801375c:	f043 0301 	orr.w	r3, r3, #1
 8013760:	77bb      	strb	r3, [r7, #30]
 8013762:	e009      	b.n	8013778 <rt_vsnprintf+0xcc>
            else break;
 8013764:	bf00      	nop
        }

        /* get field width */
        field_width = -1;
 8013766:	f04f 33ff 	mov.w	r3, #4294967295
 801376a:	61bb      	str	r3, [r7, #24]
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
 801376c:	687b      	ldr	r3, [r7, #4]
 801376e:	781b      	ldrb	r3, [r3, #0]
 8013770:	3b30      	subs	r3, #48	; 0x30
 8013772:	2b09      	cmp	r3, #9
 8013774:	d807      	bhi.n	8013786 <rt_vsnprintf+0xda>
 8013776:	e000      	b.n	801377a <rt_vsnprintf+0xce>
            else if (*fmt == '+') flags |= PLUS;
            else if (*fmt == ' ') flags |= SPACE;
            else if (*fmt == '#') flags |= SPECIAL;
            else if (*fmt == '0') flags |= ZEROPAD;
            else break;
        }
 8013778:	e7c4      	b.n	8013704 <rt_vsnprintf+0x58>

        /* get field width */
        field_width = -1;
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
 801377a:	1d3b      	adds	r3, r7, #4
 801377c:	4618      	mov	r0, r3
 801377e:	f7ff fe8b 	bl	8013498 <skip_atoi>
 8013782:	61b8      	str	r0, [r7, #24]
 8013784:	e015      	b.n	80137b2 <rt_vsnprintf+0x106>
        else if (*fmt == '*')
 8013786:	687b      	ldr	r3, [r7, #4]
 8013788:	781b      	ldrb	r3, [r3, #0]
 801378a:	2b2a      	cmp	r3, #42	; 0x2a
 801378c:	d111      	bne.n	80137b2 <rt_vsnprintf+0x106>
        {
            ++ fmt;
 801378e:	687b      	ldr	r3, [r7, #4]
 8013790:	3301      	adds	r3, #1
 8013792:	607b      	str	r3, [r7, #4]
            /* it's the next argument */
            field_width = va_arg(args, int);
 8013794:	683b      	ldr	r3, [r7, #0]
 8013796:	1d1a      	adds	r2, r3, #4
 8013798:	603a      	str	r2, [r7, #0]
 801379a:	681b      	ldr	r3, [r3, #0]
 801379c:	61bb      	str	r3, [r7, #24]
            if (field_width < 0)
 801379e:	69bb      	ldr	r3, [r7, #24]
 80137a0:	2b00      	cmp	r3, #0
 80137a2:	da06      	bge.n	80137b2 <rt_vsnprintf+0x106>
            {
                field_width = -field_width;
 80137a4:	69bb      	ldr	r3, [r7, #24]
 80137a6:	425b      	negs	r3, r3
 80137a8:	61bb      	str	r3, [r7, #24]
                flags |= LEFT;
 80137aa:	7fbb      	ldrb	r3, [r7, #30]
 80137ac:	f043 0310 	orr.w	r3, r3, #16
 80137b0:	77bb      	strb	r3, [r7, #30]
            }
        }

#ifdef RT_PRINTF_PRECISION
        /* get the precision */
        precision = -1;
 80137b2:	f04f 33ff 	mov.w	r3, #4294967295
 80137b6:	617b      	str	r3, [r7, #20]
        if (*fmt == '.')
 80137b8:	687b      	ldr	r3, [r7, #4]
 80137ba:	781b      	ldrb	r3, [r3, #0]
 80137bc:	2b2e      	cmp	r3, #46	; 0x2e
 80137be:	d11e      	bne.n	80137fe <rt_vsnprintf+0x152>
        {
            ++ fmt;
 80137c0:	687b      	ldr	r3, [r7, #4]
 80137c2:	3301      	adds	r3, #1
 80137c4:	607b      	str	r3, [r7, #4]
            if (isdigit(*fmt)) precision = skip_atoi(&fmt);
 80137c6:	687b      	ldr	r3, [r7, #4]
 80137c8:	781b      	ldrb	r3, [r3, #0]
 80137ca:	3b30      	subs	r3, #48	; 0x30
 80137cc:	2b09      	cmp	r3, #9
 80137ce:	d805      	bhi.n	80137dc <rt_vsnprintf+0x130>
 80137d0:	1d3b      	adds	r3, r7, #4
 80137d2:	4618      	mov	r0, r3
 80137d4:	f7ff fe60 	bl	8013498 <skip_atoi>
 80137d8:	6178      	str	r0, [r7, #20]
 80137da:	e00b      	b.n	80137f4 <rt_vsnprintf+0x148>
            else if (*fmt == '*')
 80137dc:	687b      	ldr	r3, [r7, #4]
 80137de:	781b      	ldrb	r3, [r3, #0]
 80137e0:	2b2a      	cmp	r3, #42	; 0x2a
 80137e2:	d107      	bne.n	80137f4 <rt_vsnprintf+0x148>
            {
                ++ fmt;
 80137e4:	687b      	ldr	r3, [r7, #4]
 80137e6:	3301      	adds	r3, #1
 80137e8:	607b      	str	r3, [r7, #4]
                /* it's the next argument */
                precision = va_arg(args, int);
 80137ea:	683b      	ldr	r3, [r7, #0]
 80137ec:	1d1a      	adds	r2, r3, #4
 80137ee:	603a      	str	r2, [r7, #0]
 80137f0:	681b      	ldr	r3, [r3, #0]
 80137f2:	617b      	str	r3, [r7, #20]
            }
            if (precision < 0) precision = 0;
 80137f4:	697b      	ldr	r3, [r7, #20]
 80137f6:	2b00      	cmp	r3, #0
 80137f8:	da01      	bge.n	80137fe <rt_vsnprintf+0x152>
 80137fa:	2300      	movs	r3, #0
 80137fc:	617b      	str	r3, [r7, #20]
        }
#endif
        /* get the conversion qualifier */
        qualifier = 0;
 80137fe:	2300      	movs	r3, #0
 8013800:	777b      	strb	r3, [r7, #29]
#ifdef RT_PRINTF_LONGLONG
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
#else
        if (*fmt == 'h' || *fmt == 'l')
 8013802:	687b      	ldr	r3, [r7, #4]
 8013804:	781b      	ldrb	r3, [r3, #0]
 8013806:	2b68      	cmp	r3, #104	; 0x68
 8013808:	d003      	beq.n	8013812 <rt_vsnprintf+0x166>
 801380a:	687b      	ldr	r3, [r7, #4]
 801380c:	781b      	ldrb	r3, [r3, #0]
 801380e:	2b6c      	cmp	r3, #108	; 0x6c
 8013810:	d105      	bne.n	801381e <rt_vsnprintf+0x172>
#endif
        {
            qualifier = *fmt;
 8013812:	687b      	ldr	r3, [r7, #4]
 8013814:	781b      	ldrb	r3, [r3, #0]
 8013816:	777b      	strb	r3, [r7, #29]
            ++ fmt;
 8013818:	687b      	ldr	r3, [r7, #4]
 801381a:	3301      	adds	r3, #1
 801381c:	607b      	str	r3, [r7, #4]
            }
#endif
        }

        /* the default base */
        base = 10;
 801381e:	230a      	movs	r3, #10
 8013820:	77fb      	strb	r3, [r7, #31]

        switch (*fmt)
 8013822:	687b      	ldr	r3, [r7, #4]
 8013824:	781b      	ldrb	r3, [r3, #0]
 8013826:	3b25      	subs	r3, #37	; 0x25
 8013828:	2b53      	cmp	r3, #83	; 0x53
 801382a:	f200 8171 	bhi.w	8013b10 <rt_vsnprintf+0x464>
 801382e:	a201      	add	r2, pc, #4	; (adr r2, 8013834 <rt_vsnprintf+0x188>)
 8013830:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013834:	08013add 	.word	0x08013add
 8013838:	08013b11 	.word	0x08013b11
 801383c:	08013b11 	.word	0x08013b11
 8013840:	08013b11 	.word	0x08013b11
 8013844:	08013b11 	.word	0x08013b11
 8013848:	08013b11 	.word	0x08013b11
 801384c:	08013b11 	.word	0x08013b11
 8013850:	08013b11 	.word	0x08013b11
 8013854:	08013b11 	.word	0x08013b11
 8013858:	08013b11 	.word	0x08013b11
 801385c:	08013b11 	.word	0x08013b11
 8013860:	08013b11 	.word	0x08013b11
 8013864:	08013b11 	.word	0x08013b11
 8013868:	08013b11 	.word	0x08013b11
 801386c:	08013b11 	.word	0x08013b11
 8013870:	08013b11 	.word	0x08013b11
 8013874:	08013b11 	.word	0x08013b11
 8013878:	08013b11 	.word	0x08013b11
 801387c:	08013b11 	.word	0x08013b11
 8013880:	08013b11 	.word	0x08013b11
 8013884:	08013b11 	.word	0x08013b11
 8013888:	08013b11 	.word	0x08013b11
 801388c:	08013b11 	.word	0x08013b11
 8013890:	08013b11 	.word	0x08013b11
 8013894:	08013b11 	.word	0x08013b11
 8013898:	08013b11 	.word	0x08013b11
 801389c:	08013b11 	.word	0x08013b11
 80138a0:	08013b11 	.word	0x08013b11
 80138a4:	08013b11 	.word	0x08013b11
 80138a8:	08013b11 	.word	0x08013b11
 80138ac:	08013b11 	.word	0x08013b11
 80138b0:	08013b11 	.word	0x08013b11
 80138b4:	08013b11 	.word	0x08013b11
 80138b8:	08013b11 	.word	0x08013b11
 80138bc:	08013b11 	.word	0x08013b11
 80138c0:	08013b11 	.word	0x08013b11
 80138c4:	08013b11 	.word	0x08013b11
 80138c8:	08013b11 	.word	0x08013b11
 80138cc:	08013b11 	.word	0x08013b11
 80138d0:	08013b11 	.word	0x08013b11
 80138d4:	08013b11 	.word	0x08013b11
 80138d8:	08013b11 	.word	0x08013b11
 80138dc:	08013b11 	.word	0x08013b11
 80138e0:	08013b11 	.word	0x08013b11
 80138e4:	08013b11 	.word	0x08013b11
 80138e8:	08013b11 	.word	0x08013b11
 80138ec:	08013b11 	.word	0x08013b11
 80138f0:	08013b11 	.word	0x08013b11
 80138f4:	08013b11 	.word	0x08013b11
 80138f8:	08013b11 	.word	0x08013b11
 80138fc:	08013b11 	.word	0x08013b11
 8013900:	08013af9 	.word	0x08013af9
 8013904:	08013b11 	.word	0x08013b11
 8013908:	08013b11 	.word	0x08013b11
 801390c:	08013b11 	.word	0x08013b11
 8013910:	08013b11 	.word	0x08013b11
 8013914:	08013b11 	.word	0x08013b11
 8013918:	08013b11 	.word	0x08013b11
 801391c:	08013b11 	.word	0x08013b11
 8013920:	08013b11 	.word	0x08013b11
 8013924:	08013b11 	.word	0x08013b11
 8013928:	08013b11 	.word	0x08013b11
 801392c:	08013985 	.word	0x08013985
 8013930:	08013b07 	.word	0x08013b07
 8013934:	08013b11 	.word	0x08013b11
 8013938:	08013b11 	.word	0x08013b11
 801393c:	08013b11 	.word	0x08013b11
 8013940:	08013b11 	.word	0x08013b11
 8013944:	08013b07 	.word	0x08013b07
 8013948:	08013b11 	.word	0x08013b11
 801394c:	08013b11 	.word	0x08013b11
 8013950:	08013b11 	.word	0x08013b11
 8013954:	08013b11 	.word	0x08013b11
 8013958:	08013b11 	.word	0x08013b11
 801395c:	08013af3 	.word	0x08013af3
 8013960:	08013aa3 	.word	0x08013aa3
 8013964:	08013b11 	.word	0x08013b11
 8013968:	08013b11 	.word	0x08013b11
 801396c:	080139f3 	.word	0x080139f3
 8013970:	08013b11 	.word	0x08013b11
 8013974:	08013b4d 	.word	0x08013b4d
 8013978:	08013b11 	.word	0x08013b11
 801397c:	08013b11 	.word	0x08013b11
 8013980:	08013b01 	.word	0x08013b01
        {
        case 'c':
            if (!(flags & LEFT))
 8013984:	7fbb      	ldrb	r3, [r7, #30]
 8013986:	f003 0310 	and.w	r3, r3, #16
 801398a:	2b00      	cmp	r3, #0
 801398c:	d110      	bne.n	80139b0 <rt_vsnprintf+0x304>
            {
                while (--field_width > 0)
 801398e:	e009      	b.n	80139a4 <rt_vsnprintf+0x2f8>
                {
                    if (str <= end) *str = ' ';
 8013990:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013992:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013994:	429a      	cmp	r2, r3
 8013996:	d802      	bhi.n	801399e <rt_vsnprintf+0x2f2>
 8013998:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801399a:	2220      	movs	r2, #32
 801399c:	701a      	strb	r2, [r3, #0]
                    ++ str;
 801399e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80139a0:	3301      	adds	r3, #1
 80139a2:	62bb      	str	r3, [r7, #40]	; 0x28
        switch (*fmt)
        {
        case 'c':
            if (!(flags & LEFT))
            {
                while (--field_width > 0)
 80139a4:	69bb      	ldr	r3, [r7, #24]
 80139a6:	3b01      	subs	r3, #1
 80139a8:	61bb      	str	r3, [r7, #24]
 80139aa:	69bb      	ldr	r3, [r7, #24]
 80139ac:	2b00      	cmp	r3, #0
 80139ae:	dcef      	bgt.n	8013990 <rt_vsnprintf+0x2e4>
                    ++ str;
                }
            }

            /* get character */
            c = (rt_uint8_t)va_arg(args, int);
 80139b0:	683b      	ldr	r3, [r7, #0]
 80139b2:	1d1a      	adds	r2, r3, #4
 80139b4:	603a      	str	r2, [r7, #0]
 80139b6:	681b      	ldr	r3, [r3, #0]
 80139b8:	74fb      	strb	r3, [r7, #19]
            if (str <= end) *str = c;
 80139ba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80139bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139be:	429a      	cmp	r2, r3
 80139c0:	d802      	bhi.n	80139c8 <rt_vsnprintf+0x31c>
 80139c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80139c4:	7cfa      	ldrb	r2, [r7, #19]
 80139c6:	701a      	strb	r2, [r3, #0]
            ++ str;
 80139c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80139ca:	3301      	adds	r3, #1
 80139cc:	62bb      	str	r3, [r7, #40]	; 0x28

            /* put width */
            while (--field_width > 0)
 80139ce:	e009      	b.n	80139e4 <rt_vsnprintf+0x338>
            {
                if (str <= end) *str = ' ';
 80139d0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80139d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139d4:	429a      	cmp	r2, r3
 80139d6:	d802      	bhi.n	80139de <rt_vsnprintf+0x332>
 80139d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80139da:	2220      	movs	r2, #32
 80139dc:	701a      	strb	r2, [r3, #0]
                ++ str;
 80139de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80139e0:	3301      	adds	r3, #1
 80139e2:	62bb      	str	r3, [r7, #40]	; 0x28
            c = (rt_uint8_t)va_arg(args, int);
            if (str <= end) *str = c;
            ++ str;

            /* put width */
            while (--field_width > 0)
 80139e4:	69bb      	ldr	r3, [r7, #24]
 80139e6:	3b01      	subs	r3, #1
 80139e8:	61bb      	str	r3, [r7, #24]
 80139ea:	69bb      	ldr	r3, [r7, #24]
 80139ec:	2b00      	cmp	r3, #0
 80139ee:	dcef      	bgt.n	80139d0 <rt_vsnprintf+0x324>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
 80139f0:	e0e5      	b.n	8013bbe <rt_vsnprintf+0x512>

        case 's':
            s = va_arg(args, char *);
 80139f2:	683b      	ldr	r3, [r7, #0]
 80139f4:	1d1a      	adds	r2, r3, #4
 80139f6:	603a      	str	r2, [r7, #0]
 80139f8:	681b      	ldr	r3, [r3, #0]
 80139fa:	623b      	str	r3, [r7, #32]
            if (!s) s = "(NULL)";
 80139fc:	6a3b      	ldr	r3, [r7, #32]
 80139fe:	2b00      	cmp	r3, #0
 8013a00:	d101      	bne.n	8013a06 <rt_vsnprintf+0x35a>
 8013a02:	4b7c      	ldr	r3, [pc, #496]	; (8013bf4 <rt_vsnprintf+0x548>)
 8013a04:	623b      	str	r3, [r7, #32]

            len = rt_strlen(s);
 8013a06:	6a38      	ldr	r0, [r7, #32]
 8013a08:	f7ff fcda 	bl	80133c0 <rt_strlen>
 8013a0c:	4603      	mov	r3, r0
 8013a0e:	62fb      	str	r3, [r7, #44]	; 0x2c
#ifdef RT_PRINTF_PRECISION
            if (precision > 0 && len > precision) len = precision;
 8013a10:	697b      	ldr	r3, [r7, #20]
 8013a12:	2b00      	cmp	r3, #0
 8013a14:	dd05      	ble.n	8013a22 <rt_vsnprintf+0x376>
 8013a16:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013a18:	697b      	ldr	r3, [r7, #20]
 8013a1a:	429a      	cmp	r2, r3
 8013a1c:	dd01      	ble.n	8013a22 <rt_vsnprintf+0x376>
 8013a1e:	697b      	ldr	r3, [r7, #20]
 8013a20:	62fb      	str	r3, [r7, #44]	; 0x2c
#endif

            if (!(flags & LEFT))
 8013a22:	7fbb      	ldrb	r3, [r7, #30]
 8013a24:	f003 0310 	and.w	r3, r3, #16
 8013a28:	2b00      	cmp	r3, #0
 8013a2a:	d110      	bne.n	8013a4e <rt_vsnprintf+0x3a2>
            {
                while (len < field_width--)
 8013a2c:	e009      	b.n	8013a42 <rt_vsnprintf+0x396>
                {
                    if (str <= end) *str = ' ';
 8013a2e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013a30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a32:	429a      	cmp	r2, r3
 8013a34:	d802      	bhi.n	8013a3c <rt_vsnprintf+0x390>
 8013a36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a38:	2220      	movs	r2, #32
 8013a3a:	701a      	strb	r2, [r3, #0]
                    ++ str;
 8013a3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a3e:	3301      	adds	r3, #1
 8013a40:	62bb      	str	r3, [r7, #40]	; 0x28
            if (precision > 0 && len > precision) len = precision;
#endif

            if (!(flags & LEFT))
            {
                while (len < field_width--)
 8013a42:	69bb      	ldr	r3, [r7, #24]
 8013a44:	1e5a      	subs	r2, r3, #1
 8013a46:	61ba      	str	r2, [r7, #24]
 8013a48:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013a4a:	4293      	cmp	r3, r2
 8013a4c:	dcef      	bgt.n	8013a2e <rt_vsnprintf+0x382>
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
 8013a4e:	2300      	movs	r3, #0
 8013a50:	633b      	str	r3, [r7, #48]	; 0x30
 8013a52:	e010      	b.n	8013a76 <rt_vsnprintf+0x3ca>
            {
                if (str <= end) *str = *s;
 8013a54:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013a56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a58:	429a      	cmp	r2, r3
 8013a5a:	d803      	bhi.n	8013a64 <rt_vsnprintf+0x3b8>
 8013a5c:	6a3b      	ldr	r3, [r7, #32]
 8013a5e:	781a      	ldrb	r2, [r3, #0]
 8013a60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a62:	701a      	strb	r2, [r3, #0]
                ++ str;
 8013a64:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a66:	3301      	adds	r3, #1
 8013a68:	62bb      	str	r3, [r7, #40]	; 0x28
                ++ s;
 8013a6a:	6a3b      	ldr	r3, [r7, #32]
 8013a6c:	3301      	adds	r3, #1
 8013a6e:	623b      	str	r3, [r7, #32]
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
 8013a70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013a72:	3301      	adds	r3, #1
 8013a74:	633b      	str	r3, [r7, #48]	; 0x30
 8013a76:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8013a78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013a7a:	429a      	cmp	r2, r3
 8013a7c:	dbea      	blt.n	8013a54 <rt_vsnprintf+0x3a8>
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
 8013a7e:	e009      	b.n	8013a94 <rt_vsnprintf+0x3e8>
            {
                if (str <= end) *str = ' ';
 8013a80:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013a82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a84:	429a      	cmp	r2, r3
 8013a86:	d802      	bhi.n	8013a8e <rt_vsnprintf+0x3e2>
 8013a88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a8a:	2220      	movs	r2, #32
 8013a8c:	701a      	strb	r2, [r3, #0]
                ++ str;
 8013a8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a90:	3301      	adds	r3, #1
 8013a92:	62bb      	str	r3, [r7, #40]	; 0x28
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
 8013a94:	69bb      	ldr	r3, [r7, #24]
 8013a96:	1e5a      	subs	r2, r3, #1
 8013a98:	61ba      	str	r2, [r7, #24]
 8013a9a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013a9c:	4293      	cmp	r3, r2
 8013a9e:	dcef      	bgt.n	8013a80 <rt_vsnprintf+0x3d4>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
 8013aa0:	e08d      	b.n	8013bbe <rt_vsnprintf+0x512>

        case 'p':
            if (field_width == -1)
 8013aa2:	69bb      	ldr	r3, [r7, #24]
 8013aa4:	f1b3 3fff 	cmp.w	r3, #4294967295
 8013aa8:	d105      	bne.n	8013ab6 <rt_vsnprintf+0x40a>
            {
                field_width = sizeof(void *) << 1;
 8013aaa:	2308      	movs	r3, #8
 8013aac:	61bb      	str	r3, [r7, #24]
                flags |= ZEROPAD;
 8013aae:	7fbb      	ldrb	r3, [r7, #30]
 8013ab0:	f043 0301 	orr.w	r3, r3, #1
 8013ab4:	77bb      	strb	r3, [r7, #30]
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
                               (long)va_arg(args, void *),
 8013ab6:	683b      	ldr	r3, [r7, #0]
 8013ab8:	1d1a      	adds	r2, r3, #4
 8013aba:	603a      	str	r2, [r7, #0]
 8013abc:	681b      	ldr	r3, [r3, #0]
            {
                field_width = sizeof(void *) << 1;
                flags |= ZEROPAD;
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
 8013abe:	461c      	mov	r4, r3
 8013ac0:	7fbb      	ldrb	r3, [r7, #30]
 8013ac2:	69ba      	ldr	r2, [r7, #24]
 8013ac4:	9200      	str	r2, [sp, #0]
 8013ac6:	697a      	ldr	r2, [r7, #20]
 8013ac8:	9201      	str	r2, [sp, #4]
 8013aca:	9302      	str	r3, [sp, #8]
 8013acc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8013ace:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8013ad0:	4622      	mov	r2, r4
 8013ad2:	2310      	movs	r3, #16
 8013ad4:	f7ff fd00 	bl	80134d8 <print_number>
 8013ad8:	62b8      	str	r0, [r7, #40]	; 0x28
#else
            str = print_number(str, end,
                               (long)va_arg(args, void *),
                               16, field_width, flags);
#endif
            continue;
 8013ada:	e070      	b.n	8013bbe <rt_vsnprintf+0x512>

        case '%':
            if (str <= end) *str = '%';
 8013adc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013ade:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013ae0:	429a      	cmp	r2, r3
 8013ae2:	d802      	bhi.n	8013aea <rt_vsnprintf+0x43e>
 8013ae4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013ae6:	2225      	movs	r2, #37	; 0x25
 8013ae8:	701a      	strb	r2, [r3, #0]
            ++ str;
 8013aea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013aec:	3301      	adds	r3, #1
 8013aee:	62bb      	str	r3, [r7, #40]	; 0x28
            continue;
 8013af0:	e065      	b.n	8013bbe <rt_vsnprintf+0x512>

            /* integer number formats - set up the flags and "break" */
        case 'o':
            base = 8;
 8013af2:	2308      	movs	r3, #8
 8013af4:	77fb      	strb	r3, [r7, #31]
            break;
 8013af6:	e02a      	b.n	8013b4e <rt_vsnprintf+0x4a2>

        case 'X':
            flags |= LARGE;
 8013af8:	7fbb      	ldrb	r3, [r7, #30]
 8013afa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8013afe:	77bb      	strb	r3, [r7, #30]
        case 'x':
            base = 16;
 8013b00:	2310      	movs	r3, #16
 8013b02:	77fb      	strb	r3, [r7, #31]
            break;
 8013b04:	e023      	b.n	8013b4e <rt_vsnprintf+0x4a2>

        case 'd':
        case 'i':
            flags |= SIGN;
 8013b06:	7fbb      	ldrb	r3, [r7, #30]
 8013b08:	f043 0302 	orr.w	r3, r3, #2
 8013b0c:	77bb      	strb	r3, [r7, #30]
        case 'u':
            break;
 8013b0e:	e01d      	b.n	8013b4c <rt_vsnprintf+0x4a0>

        default:
            if (str <= end) *str = '%';
 8013b10:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013b12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013b14:	429a      	cmp	r2, r3
 8013b16:	d802      	bhi.n	8013b1e <rt_vsnprintf+0x472>
 8013b18:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013b1a:	2225      	movs	r2, #37	; 0x25
 8013b1c:	701a      	strb	r2, [r3, #0]
            ++ str;
 8013b1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013b20:	3301      	adds	r3, #1
 8013b22:	62bb      	str	r3, [r7, #40]	; 0x28

            if (*fmt)
 8013b24:	687b      	ldr	r3, [r7, #4]
 8013b26:	781b      	ldrb	r3, [r3, #0]
 8013b28:	2b00      	cmp	r3, #0
 8013b2a:	d00b      	beq.n	8013b44 <rt_vsnprintf+0x498>
            {
                if (str <= end) *str = *fmt;
 8013b2c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013b2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013b30:	429a      	cmp	r2, r3
 8013b32:	d803      	bhi.n	8013b3c <rt_vsnprintf+0x490>
 8013b34:	687b      	ldr	r3, [r7, #4]
 8013b36:	781a      	ldrb	r2, [r3, #0]
 8013b38:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013b3a:	701a      	strb	r2, [r3, #0]
                ++ str;
 8013b3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013b3e:	3301      	adds	r3, #1
 8013b40:	62bb      	str	r3, [r7, #40]	; 0x28
            }
            else
            {
                -- fmt;
            }
            continue;
 8013b42:	e03c      	b.n	8013bbe <rt_vsnprintf+0x512>
                if (str <= end) *str = *fmt;
                ++ str;
            }
            else
            {
                -- fmt;
 8013b44:	687b      	ldr	r3, [r7, #4]
 8013b46:	3b01      	subs	r3, #1
 8013b48:	607b      	str	r3, [r7, #4]
            }
            continue;
 8013b4a:	e038      	b.n	8013bbe <rt_vsnprintf+0x512>

        case 'd':
        case 'i':
            flags |= SIGN;
        case 'u':
            break;
 8013b4c:	bf00      	nop

#ifdef RT_PRINTF_LONGLONG
        if (qualifier == 'L') num = va_arg(args, long long);
        else if (qualifier == 'l')
#else
        if (qualifier == 'l')
 8013b4e:	7f7b      	ldrb	r3, [r7, #29]
 8013b50:	2b6c      	cmp	r3, #108	; 0x6c
 8013b52:	d109      	bne.n	8013b68 <rt_vsnprintf+0x4bc>
#endif
        {
            num = va_arg(args, rt_uint32_t);
 8013b54:	683b      	ldr	r3, [r7, #0]
 8013b56:	1d1a      	adds	r2, r3, #4
 8013b58:	603a      	str	r2, [r7, #0]
 8013b5a:	681b      	ldr	r3, [r3, #0]
 8013b5c:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int32_t)num;
 8013b5e:	7fbb      	ldrb	r3, [r7, #30]
 8013b60:	f003 0302 	and.w	r3, r3, #2
 8013b64:	2b00      	cmp	r3, #0
 8013b66:	e01b      	b.n	8013ba0 <rt_vsnprintf+0x4f4>
        }
        else if (qualifier == 'h')
 8013b68:	7f7b      	ldrb	r3, [r7, #29]
 8013b6a:	2b68      	cmp	r3, #104	; 0x68
 8013b6c:	d10f      	bne.n	8013b8e <rt_vsnprintf+0x4e2>
        {
            num = (rt_uint16_t)va_arg(args, rt_int32_t);
 8013b6e:	683b      	ldr	r3, [r7, #0]
 8013b70:	1d1a      	adds	r2, r3, #4
 8013b72:	603a      	str	r2, [r7, #0]
 8013b74:	681b      	ldr	r3, [r3, #0]
 8013b76:	b29b      	uxth	r3, r3
 8013b78:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int16_t)num;
 8013b7a:	7fbb      	ldrb	r3, [r7, #30]
 8013b7c:	f003 0302 	and.w	r3, r3, #2
 8013b80:	2b00      	cmp	r3, #0
 8013b82:	d00d      	beq.n	8013ba0 <rt_vsnprintf+0x4f4>
 8013b84:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013b86:	b29b      	uxth	r3, r3
 8013b88:	b21b      	sxth	r3, r3
 8013b8a:	637b      	str	r3, [r7, #52]	; 0x34
 8013b8c:	e008      	b.n	8013ba0 <rt_vsnprintf+0x4f4>
        }
        else
        {
            num = va_arg(args, rt_uint32_t);
 8013b8e:	683b      	ldr	r3, [r7, #0]
 8013b90:	1d1a      	adds	r2, r3, #4
 8013b92:	603a      	str	r2, [r7, #0]
 8013b94:	681b      	ldr	r3, [r3, #0]
 8013b96:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int32_t)num;
 8013b98:	7fbb      	ldrb	r3, [r7, #30]
 8013b9a:	f003 0302 	and.w	r3, r3, #2
 8013b9e:	2b00      	cmp	r3, #0
        }
#ifdef RT_PRINTF_PRECISION
        str = print_number(str, end, num, base, field_width, precision, flags);
 8013ba0:	6b7d      	ldr	r5, [r7, #52]	; 0x34
 8013ba2:	7ffc      	ldrb	r4, [r7, #31]
 8013ba4:	7fbb      	ldrb	r3, [r7, #30]
 8013ba6:	69ba      	ldr	r2, [r7, #24]
 8013ba8:	9200      	str	r2, [sp, #0]
 8013baa:	697a      	ldr	r2, [r7, #20]
 8013bac:	9201      	str	r2, [sp, #4]
 8013bae:	9302      	str	r3, [sp, #8]
 8013bb0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8013bb2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8013bb4:	462a      	mov	r2, r5
 8013bb6:	4623      	mov	r3, r4
 8013bb8:	f7ff fc8e 	bl	80134d8 <print_number>
 8013bbc:	62b8      	str	r0, [r7, #40]	; 0x28
    {
        end  = ((char *)-1);
        size = end - buf;
    }

    for (; *fmt ; ++fmt)
 8013bbe:	687b      	ldr	r3, [r7, #4]
 8013bc0:	3301      	adds	r3, #1
 8013bc2:	607b      	str	r3, [r7, #4]
 8013bc4:	687b      	ldr	r3, [r7, #4]
 8013bc6:	781b      	ldrb	r3, [r3, #0]
 8013bc8:	2b00      	cmp	r3, #0
 8013bca:	f47f ad89 	bne.w	80136e0 <rt_vsnprintf+0x34>
#else
        str = print_number(str, end, num, base, field_width, flags);
#endif
    }

    if (str <= end) *str = '\0';
 8013bce:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013bd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013bd2:	429a      	cmp	r2, r3
 8013bd4:	d803      	bhi.n	8013bde <rt_vsnprintf+0x532>
 8013bd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013bd8:	2200      	movs	r2, #0
 8013bda:	701a      	strb	r2, [r3, #0]
 8013bdc:	e002      	b.n	8013be4 <rt_vsnprintf+0x538>
    else *end = '\0';
 8013bde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013be0:	2200      	movs	r2, #0
 8013be2:	701a      	strb	r2, [r3, #0]

    /* the trailing null byte doesn't count towards the total
    * ++str;
    */
    return str - buf;
 8013be4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013be6:	68fb      	ldr	r3, [r7, #12]
 8013be8:	1ad3      	subs	r3, r2, r3
}
 8013bea:	4618      	mov	r0, r3
 8013bec:	3738      	adds	r7, #56	; 0x38
 8013bee:	46bd      	mov	sp, r7
 8013bf0:	bdb0      	pop	{r4, r5, r7, pc}
 8013bf2:	bf00      	nop
 8013bf4:	08022e3c 	.word	0x08022e3c

08013bf8 <rt_console_get_device>:
 * This function returns the device using in console.
 *
 * @return the device using in console or RT_NULL
 */
rt_device_t rt_console_get_device(void)
{
 8013bf8:	b480      	push	{r7}
 8013bfa:	af00      	add	r7, sp, #0
    return _console_device;
 8013bfc:	4b03      	ldr	r3, [pc, #12]	; (8013c0c <rt_console_get_device+0x14>)
 8013bfe:	681b      	ldr	r3, [r3, #0]
}
 8013c00:	4618      	mov	r0, r3
 8013c02:	46bd      	mov	sp, r7
 8013c04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013c08:	4770      	bx	lr
 8013c0a:	bf00      	nop
 8013c0c:	20010d14 	.word	0x20010d14

08013c10 <rt_console_set_device>:
 * @param name the name of new console device
 *
 * @return the old console device handler
 */
rt_device_t rt_console_set_device(const char *name)
{
 8013c10:	b580      	push	{r7, lr}
 8013c12:	b084      	sub	sp, #16
 8013c14:	af00      	add	r7, sp, #0
 8013c16:	6078      	str	r0, [r7, #4]
    rt_device_t new, old;

    /* save old device */
    old = _console_device;
 8013c18:	4b0f      	ldr	r3, [pc, #60]	; (8013c58 <rt_console_set_device+0x48>)
 8013c1a:	681b      	ldr	r3, [r3, #0]
 8013c1c:	60fb      	str	r3, [r7, #12]

    /* find new console device */
    new = rt_device_find(name);
 8013c1e:	6878      	ldr	r0, [r7, #4]
 8013c20:	f7fe f998 	bl	8011f54 <rt_device_find>
 8013c24:	60b8      	str	r0, [r7, #8]
    if (new != RT_NULL)
 8013c26:	68bb      	ldr	r3, [r7, #8]
 8013c28:	2b00      	cmp	r3, #0
 8013c2a:	d00f      	beq.n	8013c4c <rt_console_set_device+0x3c>
    {
        if (_console_device != RT_NULL)
 8013c2c:	4b0a      	ldr	r3, [pc, #40]	; (8013c58 <rt_console_set_device+0x48>)
 8013c2e:	681b      	ldr	r3, [r3, #0]
 8013c30:	2b00      	cmp	r3, #0
 8013c32:	d004      	beq.n	8013c3e <rt_console_set_device+0x2e>
        {
            /* close old console device */
            rt_device_close(_console_device);
 8013c34:	4b08      	ldr	r3, [pc, #32]	; (8013c58 <rt_console_set_device+0x48>)
 8013c36:	681b      	ldr	r3, [r3, #0]
 8013c38:	4618      	mov	r0, r3
 8013c3a:	f7fe fa3b 	bl	80120b4 <rt_device_close>
        }

        /* set new console device */
        rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
 8013c3e:	68b8      	ldr	r0, [r7, #8]
 8013c40:	2143      	movs	r1, #67	; 0x43
 8013c42:	f7fe f9c3 	bl	8011fcc <rt_device_open>
        _console_device = new;
 8013c46:	4a04      	ldr	r2, [pc, #16]	; (8013c58 <rt_console_set_device+0x48>)
 8013c48:	68bb      	ldr	r3, [r7, #8]
 8013c4a:	6013      	str	r3, [r2, #0]
    }

    return old;
 8013c4c:	68fb      	ldr	r3, [r7, #12]
}
 8013c4e:	4618      	mov	r0, r3
 8013c50:	3710      	adds	r7, #16
 8013c52:	46bd      	mov	sp, r7
 8013c54:	bd80      	pop	{r7, pc}
 8013c56:	bf00      	nop
 8013c58:	20010d14 	.word	0x20010d14

08013c5c <rt_hw_console_output>:
RTM_EXPORT(rt_console_set_device);
#endif

WEAK void rt_hw_console_output(const char *str)
{
 8013c5c:	b480      	push	{r7}
 8013c5e:	b083      	sub	sp, #12
 8013c60:	af00      	add	r7, sp, #0
 8013c62:	6078      	str	r0, [r7, #4]
    /* empty console output */
}
 8013c64:	370c      	adds	r7, #12
 8013c66:	46bd      	mov	sp, r7
 8013c68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013c6c:	4770      	bx	lr
 8013c6e:	bf00      	nop

08013c70 <rt_kprintf>:
 * This function will print a formatted string on system console
 *
 * @param fmt the format
 */
void rt_kprintf(const char *fmt, ...)
{
 8013c70:	b40f      	push	{r0, r1, r2, r3}
 8013c72:	b580      	push	{r7, lr}
 8013c74:	b084      	sub	sp, #16
 8013c76:	af00      	add	r7, sp, #0
    va_list args;
    rt_size_t length;
    static char rt_log_buf[RT_CONSOLEBUF_SIZE];

    va_start(args, fmt);
 8013c78:	f107 031c 	add.w	r3, r7, #28
 8013c7c:	607b      	str	r3, [r7, #4]
    /* the return value of vsnprintf is the number of bytes that would be
     * written to buffer had if the size of the buffer been sufficiently
     * large excluding the terminating null byte. If the output string
     * would be larger than the rt_log_buf, we have to adjust the output
     * length. */
    length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
 8013c7e:	481a      	ldr	r0, [pc, #104]	; (8013ce8 <rt_kprintf+0x78>)
 8013c80:	217f      	movs	r1, #127	; 0x7f
 8013c82:	69ba      	ldr	r2, [r7, #24]
 8013c84:	687b      	ldr	r3, [r7, #4]
 8013c86:	f7ff fd11 	bl	80136ac <rt_vsnprintf>
 8013c8a:	4603      	mov	r3, r0
 8013c8c:	60fb      	str	r3, [r7, #12]
    if (length > RT_CONSOLEBUF_SIZE - 1)
 8013c8e:	68fb      	ldr	r3, [r7, #12]
 8013c90:	2b7f      	cmp	r3, #127	; 0x7f
 8013c92:	d901      	bls.n	8013c98 <rt_kprintf+0x28>
        length = RT_CONSOLEBUF_SIZE - 1;
 8013c94:	237f      	movs	r3, #127	; 0x7f
 8013c96:	60fb      	str	r3, [r7, #12]
#ifdef RT_USING_DEVICE
    if (_console_device == RT_NULL)
 8013c98:	4b14      	ldr	r3, [pc, #80]	; (8013cec <rt_kprintf+0x7c>)
 8013c9a:	681b      	ldr	r3, [r3, #0]
 8013c9c:	2b00      	cmp	r3, #0
 8013c9e:	d103      	bne.n	8013ca8 <rt_kprintf+0x38>
    {
        rt_hw_console_output(rt_log_buf);
 8013ca0:	4811      	ldr	r0, [pc, #68]	; (8013ce8 <rt_kprintf+0x78>)
 8013ca2:	f7ff ffdb 	bl	8013c5c <rt_hw_console_output>
 8013ca6:	e018      	b.n	8013cda <rt_kprintf+0x6a>
    }
    else
    {
        rt_uint16_t old_flag = _console_device->open_flag;
 8013ca8:	4b10      	ldr	r3, [pc, #64]	; (8013cec <rt_kprintf+0x7c>)
 8013caa:	681b      	ldr	r3, [r3, #0]
 8013cac:	8b1b      	ldrh	r3, [r3, #24]
 8013cae:	817b      	strh	r3, [r7, #10]

        _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
 8013cb0:	4b0e      	ldr	r3, [pc, #56]	; (8013cec <rt_kprintf+0x7c>)
 8013cb2:	681b      	ldr	r3, [r3, #0]
 8013cb4:	4a0d      	ldr	r2, [pc, #52]	; (8013cec <rt_kprintf+0x7c>)
 8013cb6:	6812      	ldr	r2, [r2, #0]
 8013cb8:	8b12      	ldrh	r2, [r2, #24]
 8013cba:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8013cbe:	b292      	uxth	r2, r2
 8013cc0:	831a      	strh	r2, [r3, #24]
        rt_device_write(_console_device, 0, rt_log_buf, length);
 8013cc2:	4b0a      	ldr	r3, [pc, #40]	; (8013cec <rt_kprintf+0x7c>)
 8013cc4:	681b      	ldr	r3, [r3, #0]
 8013cc6:	4618      	mov	r0, r3
 8013cc8:	2100      	movs	r1, #0
 8013cca:	4a07      	ldr	r2, [pc, #28]	; (8013ce8 <rt_kprintf+0x78>)
 8013ccc:	68fb      	ldr	r3, [r7, #12]
 8013cce:	f7fe fa63 	bl	8012198 <rt_device_write>
        _console_device->open_flag = old_flag;
 8013cd2:	4b06      	ldr	r3, [pc, #24]	; (8013cec <rt_kprintf+0x7c>)
 8013cd4:	681b      	ldr	r3, [r3, #0]
 8013cd6:	897a      	ldrh	r2, [r7, #10]
 8013cd8:	831a      	strh	r2, [r3, #24]
    }
#else
    rt_hw_console_output(rt_log_buf);
#endif
    va_end(args);
}
 8013cda:	3710      	adds	r7, #16
 8013cdc:	46bd      	mov	sp, r7
 8013cde:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8013ce2:	b004      	add	sp, #16
 8013ce4:	4770      	bx	lr
 8013ce6:	bf00      	nop
 8013ce8:	20010d18 	.word	0x20010d18
 8013cec:	20010d14 	.word	0x20010d14

08013cf0 <__rt_ffs>:
 *
 * @return return the index of the first bit set. If value is 0, then this function
 * shall return 0.
 */
int __rt_ffs(int value)
{
 8013cf0:	b480      	push	{r7}
 8013cf2:	b083      	sub	sp, #12
 8013cf4:	af00      	add	r7, sp, #0
 8013cf6:	6078      	str	r0, [r7, #4]
    if (value == 0) return 0;
 8013cf8:	687b      	ldr	r3, [r7, #4]
 8013cfa:	2b00      	cmp	r3, #0
 8013cfc:	d101      	bne.n	8013d02 <__rt_ffs+0x12>
 8013cfe:	2300      	movs	r3, #0
 8013d00:	e028      	b.n	8013d54 <__rt_ffs+0x64>

    if (value & 0xff)
 8013d02:	687b      	ldr	r3, [r7, #4]
 8013d04:	b2db      	uxtb	r3, r3
 8013d06:	2b00      	cmp	r3, #0
 8013d08:	d005      	beq.n	8013d16 <__rt_ffs+0x26>
        return __lowest_bit_bitmap[value & 0xff] + 1;
 8013d0a:	687b      	ldr	r3, [r7, #4]
 8013d0c:	b2db      	uxtb	r3, r3
 8013d0e:	4a14      	ldr	r2, [pc, #80]	; (8013d60 <__rt_ffs+0x70>)
 8013d10:	5cd3      	ldrb	r3, [r2, r3]
 8013d12:	3301      	adds	r3, #1
 8013d14:	e01e      	b.n	8013d54 <__rt_ffs+0x64>

    if (value & 0xff00)
 8013d16:	687b      	ldr	r3, [r7, #4]
 8013d18:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8013d1c:	2b00      	cmp	r3, #0
 8013d1e:	d007      	beq.n	8013d30 <__rt_ffs+0x40>
        return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
 8013d20:	687b      	ldr	r3, [r7, #4]
 8013d22:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8013d26:	121b      	asrs	r3, r3, #8
 8013d28:	4a0d      	ldr	r2, [pc, #52]	; (8013d60 <__rt_ffs+0x70>)
 8013d2a:	5cd3      	ldrb	r3, [r2, r3]
 8013d2c:	3309      	adds	r3, #9
 8013d2e:	e011      	b.n	8013d54 <__rt_ffs+0x64>

    if (value & 0xff0000)
 8013d30:	687b      	ldr	r3, [r7, #4]
 8013d32:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8013d36:	2b00      	cmp	r3, #0
 8013d38:	d007      	beq.n	8013d4a <__rt_ffs+0x5a>
        return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
 8013d3a:	687b      	ldr	r3, [r7, #4]
 8013d3c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8013d40:	141b      	asrs	r3, r3, #16
 8013d42:	4a07      	ldr	r2, [pc, #28]	; (8013d60 <__rt_ffs+0x70>)
 8013d44:	5cd3      	ldrb	r3, [r2, r3]
 8013d46:	3311      	adds	r3, #17
 8013d48:	e004      	b.n	8013d54 <__rt_ffs+0x64>

    return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
 8013d4a:	687b      	ldr	r3, [r7, #4]
 8013d4c:	0e1b      	lsrs	r3, r3, #24
 8013d4e:	4a04      	ldr	r2, [pc, #16]	; (8013d60 <__rt_ffs+0x70>)
 8013d50:	5cd3      	ldrb	r3, [r2, r3]
 8013d52:	3319      	adds	r3, #25
}
 8013d54:	4618      	mov	r0, r3
 8013d56:	370c      	adds	r7, #12
 8013d58:	46bd      	mov	sp, r7
 8013d5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013d5e:	4770      	bx	lr
 8013d60:	08024d48 	.word	0x08024d48

08013d64 <rt_assert_handler>:
 * @param ex the assertion condition string
 * @param func the function name when assertion.
 * @param line the file line number when assertion.
 */
void rt_assert_handler(const char* ex_string, const char* func, rt_size_t line)
{
 8013d64:	b580      	push	{r7, lr}
 8013d66:	b086      	sub	sp, #24
 8013d68:	af00      	add	r7, sp, #0
 8013d6a:	60f8      	str	r0, [r7, #12]
 8013d6c:	60b9      	str	r1, [r7, #8]
 8013d6e:	607a      	str	r2, [r7, #4]
    volatile char dummy = 0;
 8013d70:	2300      	movs	r3, #0
 8013d72:	75fb      	strb	r3, [r7, #23]

    if (rt_assert_hook == RT_NULL)
 8013d74:	4b0c      	ldr	r3, [pc, #48]	; (8013da8 <rt_assert_handler+0x44>)
 8013d76:	681b      	ldr	r3, [r3, #0]
 8013d78:	2b00      	cmp	r3, #0
 8013d7a:	d10b      	bne.n	8013d94 <rt_assert_handler+0x30>
			rt_schedule();
		}
		else
#endif
		{
	        rt_kprintf("(%s) assertion failed at function:%s, line number:%d \n", ex_string, func, line);
 8013d7c:	480b      	ldr	r0, [pc, #44]	; (8013dac <rt_assert_handler+0x48>)
 8013d7e:	68f9      	ldr	r1, [r7, #12]
 8013d80:	68ba      	ldr	r2, [r7, #8]
 8013d82:	687b      	ldr	r3, [r7, #4]
 8013d84:	f7ff ff74 	bl	8013c70 <rt_kprintf>
	        while (dummy == 0);
 8013d88:	bf00      	nop
 8013d8a:	7dfb      	ldrb	r3, [r7, #23]
 8013d8c:	b2db      	uxtb	r3, r3
 8013d8e:	2b00      	cmp	r3, #0
 8013d90:	d0fb      	beq.n	8013d8a <rt_assert_handler+0x26>
 8013d92:	e005      	b.n	8013da0 <rt_assert_handler+0x3c>
		}
    }
	else
	{
        rt_assert_hook(ex_string, func, line);
 8013d94:	4b04      	ldr	r3, [pc, #16]	; (8013da8 <rt_assert_handler+0x44>)
 8013d96:	681b      	ldr	r3, [r3, #0]
 8013d98:	68f8      	ldr	r0, [r7, #12]
 8013d9a:	68b9      	ldr	r1, [r7, #8]
 8013d9c:	687a      	ldr	r2, [r7, #4]
 8013d9e:	4798      	blx	r3
    }                                                                     
}
 8013da0:	3718      	adds	r7, #24
 8013da2:	46bd      	mov	sp, r7
 8013da4:	bd80      	pop	{r7, pc}
 8013da6:	bf00      	nop
 8013da8:	20012568 	.word	0x20012568
 8013dac:	08022e44 	.word	0x08022e44

08013db0 <plug_holes>:
#ifdef RT_MEM_STATS
static rt_size_t used_mem, max_mem;
#endif

static void plug_holes(struct heap_mem *mem)
{
 8013db0:	b580      	push	{r7, lr}
 8013db2:	b084      	sub	sp, #16
 8013db4:	af00      	add	r7, sp, #0
 8013db6:	6078      	str	r0, [r7, #4]
    struct heap_mem *nmem;
    struct heap_mem *pmem;

    RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
 8013db8:	4b36      	ldr	r3, [pc, #216]	; (8013e94 <plug_holes+0xe4>)
 8013dba:	681b      	ldr	r3, [r3, #0]
 8013dbc:	687a      	ldr	r2, [r7, #4]
 8013dbe:	429a      	cmp	r2, r3
 8013dc0:	d204      	bcs.n	8013dcc <plug_holes+0x1c>
 8013dc2:	4835      	ldr	r0, [pc, #212]	; (8013e98 <plug_holes+0xe8>)
 8013dc4:	4935      	ldr	r1, [pc, #212]	; (8013e9c <plug_holes+0xec>)
 8013dc6:	228d      	movs	r2, #141	; 0x8d
 8013dc8:	f7ff ffcc 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
 8013dcc:	4b34      	ldr	r3, [pc, #208]	; (8013ea0 <plug_holes+0xf0>)
 8013dce:	681b      	ldr	r3, [r3, #0]
 8013dd0:	687a      	ldr	r2, [r7, #4]
 8013dd2:	429a      	cmp	r2, r3
 8013dd4:	d304      	bcc.n	8013de0 <plug_holes+0x30>
 8013dd6:	4833      	ldr	r0, [pc, #204]	; (8013ea4 <plug_holes+0xf4>)
 8013dd8:	4930      	ldr	r1, [pc, #192]	; (8013e9c <plug_holes+0xec>)
 8013dda:	228e      	movs	r2, #142	; 0x8e
 8013ddc:	f7ff ffc2 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(mem->used == 0);
 8013de0:	687b      	ldr	r3, [r7, #4]
 8013de2:	885b      	ldrh	r3, [r3, #2]
 8013de4:	2b00      	cmp	r3, #0
 8013de6:	d004      	beq.n	8013df2 <plug_holes+0x42>
 8013de8:	482f      	ldr	r0, [pc, #188]	; (8013ea8 <plug_holes+0xf8>)
 8013dea:	492c      	ldr	r1, [pc, #176]	; (8013e9c <plug_holes+0xec>)
 8013dec:	228f      	movs	r2, #143	; 0x8f
 8013dee:	f7ff ffb9 	bl	8013d64 <rt_assert_handler>

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
 8013df2:	4b28      	ldr	r3, [pc, #160]	; (8013e94 <plug_holes+0xe4>)
 8013df4:	681a      	ldr	r2, [r3, #0]
 8013df6:	687b      	ldr	r3, [r7, #4]
 8013df8:	685b      	ldr	r3, [r3, #4]
 8013dfa:	4413      	add	r3, r2
 8013dfc:	60fb      	str	r3, [r7, #12]
    if (mem != nmem &&
 8013dfe:	687a      	ldr	r2, [r7, #4]
 8013e00:	68fb      	ldr	r3, [r7, #12]
 8013e02:	429a      	cmp	r2, r3
 8013e04:	d01e      	beq.n	8013e44 <plug_holes+0x94>
        nmem->used == 0 &&
 8013e06:	68fb      	ldr	r3, [r7, #12]
 8013e08:	885b      	ldrh	r3, [r3, #2]
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
 8013e0a:	2b00      	cmp	r3, #0
 8013e0c:	d11a      	bne.n	8013e44 <plug_holes+0x94>
        nmem->used == 0 &&
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
 8013e0e:	4b24      	ldr	r3, [pc, #144]	; (8013ea0 <plug_holes+0xf0>)
 8013e10:	681b      	ldr	r3, [r3, #0]
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
        nmem->used == 0 &&
 8013e12:	68fa      	ldr	r2, [r7, #12]
 8013e14:	429a      	cmp	r2, r3
 8013e16:	d015      	beq.n	8013e44 <plug_holes+0x94>
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
    {
        /* if mem->next is unused and not end of heap_ptr,
         * combine mem and mem->next
         */
        if (lfree == nmem)
 8013e18:	4b24      	ldr	r3, [pc, #144]	; (8013eac <plug_holes+0xfc>)
 8013e1a:	681a      	ldr	r2, [r3, #0]
 8013e1c:	68fb      	ldr	r3, [r7, #12]
 8013e1e:	429a      	cmp	r2, r3
 8013e20:	d102      	bne.n	8013e28 <plug_holes+0x78>
        {
            lfree = mem;
 8013e22:	4a22      	ldr	r2, [pc, #136]	; (8013eac <plug_holes+0xfc>)
 8013e24:	687b      	ldr	r3, [r7, #4]
 8013e26:	6013      	str	r3, [r2, #0]
        }
        mem->next = nmem->next;
 8013e28:	68fb      	ldr	r3, [r7, #12]
 8013e2a:	685a      	ldr	r2, [r3, #4]
 8013e2c:	687b      	ldr	r3, [r7, #4]
 8013e2e:	605a      	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
 8013e30:	4b18      	ldr	r3, [pc, #96]	; (8013e94 <plug_holes+0xe4>)
 8013e32:	681a      	ldr	r2, [r3, #0]
 8013e34:	68fb      	ldr	r3, [r7, #12]
 8013e36:	685b      	ldr	r3, [r3, #4]
 8013e38:	4413      	add	r3, r2
 8013e3a:	687a      	ldr	r2, [r7, #4]
 8013e3c:	4915      	ldr	r1, [pc, #84]	; (8013e94 <plug_holes+0xe4>)
 8013e3e:	6809      	ldr	r1, [r1, #0]
 8013e40:	1a52      	subs	r2, r2, r1
 8013e42:	609a      	str	r2, [r3, #8]
    }

    /* plug hole backward */
    pmem = (struct heap_mem *)&heap_ptr[mem->prev];
 8013e44:	4b13      	ldr	r3, [pc, #76]	; (8013e94 <plug_holes+0xe4>)
 8013e46:	681a      	ldr	r2, [r3, #0]
 8013e48:	687b      	ldr	r3, [r7, #4]
 8013e4a:	689b      	ldr	r3, [r3, #8]
 8013e4c:	4413      	add	r3, r2
 8013e4e:	60bb      	str	r3, [r7, #8]
    if (pmem != mem && pmem->used == 0)
 8013e50:	68ba      	ldr	r2, [r7, #8]
 8013e52:	687b      	ldr	r3, [r7, #4]
 8013e54:	429a      	cmp	r2, r3
 8013e56:	d019      	beq.n	8013e8c <plug_holes+0xdc>
 8013e58:	68bb      	ldr	r3, [r7, #8]
 8013e5a:	885b      	ldrh	r3, [r3, #2]
 8013e5c:	2b00      	cmp	r3, #0
 8013e5e:	d115      	bne.n	8013e8c <plug_holes+0xdc>
    {
        /* if mem->prev is unused, combine mem and mem->prev */
        if (lfree == mem)
 8013e60:	4b12      	ldr	r3, [pc, #72]	; (8013eac <plug_holes+0xfc>)
 8013e62:	681a      	ldr	r2, [r3, #0]
 8013e64:	687b      	ldr	r3, [r7, #4]
 8013e66:	429a      	cmp	r2, r3
 8013e68:	d102      	bne.n	8013e70 <plug_holes+0xc0>
        {
            lfree = pmem;
 8013e6a:	4a10      	ldr	r2, [pc, #64]	; (8013eac <plug_holes+0xfc>)
 8013e6c:	68bb      	ldr	r3, [r7, #8]
 8013e6e:	6013      	str	r3, [r2, #0]
        }
        pmem->next = mem->next;
 8013e70:	687b      	ldr	r3, [r7, #4]
 8013e72:	685a      	ldr	r2, [r3, #4]
 8013e74:	68bb      	ldr	r3, [r7, #8]
 8013e76:	605a      	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
 8013e78:	4b06      	ldr	r3, [pc, #24]	; (8013e94 <plug_holes+0xe4>)
 8013e7a:	681a      	ldr	r2, [r3, #0]
 8013e7c:	687b      	ldr	r3, [r7, #4]
 8013e7e:	685b      	ldr	r3, [r3, #4]
 8013e80:	4413      	add	r3, r2
 8013e82:	68ba      	ldr	r2, [r7, #8]
 8013e84:	4903      	ldr	r1, [pc, #12]	; (8013e94 <plug_holes+0xe4>)
 8013e86:	6809      	ldr	r1, [r1, #0]
 8013e88:	1a52      	subs	r2, r2, r1
 8013e8a:	609a      	str	r2, [r3, #8]
    }
}
 8013e8c:	3710      	adds	r7, #16
 8013e8e:	46bd      	mov	sp, r7
 8013e90:	bd80      	pop	{r7, pc}
 8013e92:	bf00      	nop
 8013e94:	20010da0 	.word	0x20010da0
 8013e98:	08022e7c 	.word	0x08022e7c
 8013e9c:	08024e9c 	.word	0x08024e9c
 8013ea0:	20010da4 	.word	0x20010da4
 8013ea4:	08022e9c 	.word	0x08022e9c
 8013ea8:	08022ec8 	.word	0x08022ec8
 8013eac:	20010da8 	.word	0x20010da8

08013eb0 <rt_system_heap_init>:
 *
 * @param begin_addr the beginning address of system heap memory.
 * @param end_addr the end address of system heap memory.
 */
void rt_system_heap_init(void *begin_addr, void *end_addr)
{
 8013eb0:	b580      	push	{r7, lr}
 8013eb2:	b086      	sub	sp, #24
 8013eb4:	af00      	add	r7, sp, #0
 8013eb6:	6078      	str	r0, [r7, #4]
 8013eb8:	6039      	str	r1, [r7, #0]
    struct heap_mem *mem;
    rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
 8013eba:	687b      	ldr	r3, [r7, #4]
 8013ebc:	3303      	adds	r3, #3
 8013ebe:	f023 0303 	bic.w	r3, r3, #3
 8013ec2:	617b      	str	r3, [r7, #20]
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
 8013ec4:	683b      	ldr	r3, [r7, #0]
 8013ec6:	f023 0303 	bic.w	r3, r3, #3
 8013eca:	613b      	str	r3, [r7, #16]

    RT_DEBUG_NOT_IN_INTERRUPT;
 8013ecc:	f7ec f97c 	bl	80001c8 <rt_hw_interrupt_disable>
 8013ed0:	60f8      	str	r0, [r7, #12]
 8013ed2:	f7ff f8e9 	bl	80130a8 <rt_interrupt_get_nest>
 8013ed6:	4603      	mov	r3, r0
 8013ed8:	2b00      	cmp	r3, #0
 8013eda:	d008      	beq.n	8013eee <rt_system_heap_init+0x3e>
 8013edc:	4831      	ldr	r0, [pc, #196]	; (8013fa4 <rt_system_heap_init+0xf4>)
 8013ede:	4932      	ldr	r1, [pc, #200]	; (8013fa8 <rt_system_heap_init+0xf8>)
 8013ee0:	f7ff fec6 	bl	8013c70 <rt_kprintf>
 8013ee4:	4831      	ldr	r0, [pc, #196]	; (8013fac <rt_system_heap_init+0xfc>)
 8013ee6:	4930      	ldr	r1, [pc, #192]	; (8013fa8 <rt_system_heap_init+0xf8>)
 8013ee8:	22be      	movs	r2, #190	; 0xbe
 8013eea:	f7ff ff3b 	bl	8013d64 <rt_assert_handler>
 8013eee:	68f8      	ldr	r0, [r7, #12]
 8013ef0:	f7ec f96e 	bl	80001d0 <rt_hw_interrupt_enable>

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
 8013ef4:	693b      	ldr	r3, [r7, #16]
 8013ef6:	2b18      	cmp	r3, #24
 8013ef8:	d948      	bls.n	8013f8c <rt_system_heap_init+0xdc>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
 8013efa:	693b      	ldr	r3, [r7, #16]
 8013efc:	f1a3 0218 	sub.w	r2, r3, #24
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
 8013f00:	697b      	ldr	r3, [r7, #20]
 8013f02:	429a      	cmp	r2, r3
 8013f04:	d342      	bcc.n	8013f8c <rt_system_heap_init+0xdc>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
    {
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
 8013f06:	693a      	ldr	r2, [r7, #16]
 8013f08:	697b      	ldr	r3, [r7, #20]
 8013f0a:	1ad3      	subs	r3, r2, r3
 8013f0c:	3b18      	subs	r3, #24
 8013f0e:	4a28      	ldr	r2, [pc, #160]	; (8013fb0 <rt_system_heap_init+0x100>)
 8013f10:	6013      	str	r3, [r2, #0]

        return;
    }

    /* point to begin address of heap */
    heap_ptr = (rt_uint8_t *)begin_align;
 8013f12:	697b      	ldr	r3, [r7, #20]
 8013f14:	4a27      	ldr	r2, [pc, #156]	; (8013fb4 <rt_system_heap_init+0x104>)
 8013f16:	6013      	str	r3, [r2, #0]

    RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
                                (rt_uint32_t)heap_ptr, mem_size_aligned));

    /* initialize the start of the heap */
    mem        = (struct heap_mem *)heap_ptr;
 8013f18:	4b26      	ldr	r3, [pc, #152]	; (8013fb4 <rt_system_heap_init+0x104>)
 8013f1a:	681b      	ldr	r3, [r3, #0]
 8013f1c:	60bb      	str	r3, [r7, #8]
    mem->magic = HEAP_MAGIC;
 8013f1e:	68bb      	ldr	r3, [r7, #8]
 8013f20:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 8013f24:	801a      	strh	r2, [r3, #0]
    mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 8013f26:	4b22      	ldr	r3, [pc, #136]	; (8013fb0 <rt_system_heap_init+0x100>)
 8013f28:	681b      	ldr	r3, [r3, #0]
 8013f2a:	f103 020c 	add.w	r2, r3, #12
 8013f2e:	68bb      	ldr	r3, [r7, #8]
 8013f30:	605a      	str	r2, [r3, #4]
    mem->prev  = 0;
 8013f32:	68bb      	ldr	r3, [r7, #8]
 8013f34:	2200      	movs	r2, #0
 8013f36:	609a      	str	r2, [r3, #8]
    mem->used  = 0;
 8013f38:	68bb      	ldr	r3, [r7, #8]
 8013f3a:	2200      	movs	r2, #0
 8013f3c:	805a      	strh	r2, [r3, #2]

    /* initialize the end of the heap */
    heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
 8013f3e:	4b1d      	ldr	r3, [pc, #116]	; (8013fb4 <rt_system_heap_init+0x104>)
 8013f40:	681a      	ldr	r2, [r3, #0]
 8013f42:	68bb      	ldr	r3, [r7, #8]
 8013f44:	685b      	ldr	r3, [r3, #4]
 8013f46:	4413      	add	r3, r2
 8013f48:	4a1b      	ldr	r2, [pc, #108]	; (8013fb8 <rt_system_heap_init+0x108>)
 8013f4a:	6013      	str	r3, [r2, #0]
    heap_end->magic = HEAP_MAGIC;
 8013f4c:	4b1a      	ldr	r3, [pc, #104]	; (8013fb8 <rt_system_heap_init+0x108>)
 8013f4e:	681b      	ldr	r3, [r3, #0]
 8013f50:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 8013f54:	801a      	strh	r2, [r3, #0]
    heap_end->used  = 1;
 8013f56:	4b18      	ldr	r3, [pc, #96]	; (8013fb8 <rt_system_heap_init+0x108>)
 8013f58:	681b      	ldr	r3, [r3, #0]
 8013f5a:	2201      	movs	r2, #1
 8013f5c:	805a      	strh	r2, [r3, #2]
    heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 8013f5e:	4b16      	ldr	r3, [pc, #88]	; (8013fb8 <rt_system_heap_init+0x108>)
 8013f60:	681b      	ldr	r3, [r3, #0]
 8013f62:	4a13      	ldr	r2, [pc, #76]	; (8013fb0 <rt_system_heap_init+0x100>)
 8013f64:	6812      	ldr	r2, [r2, #0]
 8013f66:	320c      	adds	r2, #12
 8013f68:	605a      	str	r2, [r3, #4]
    heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 8013f6a:	4b13      	ldr	r3, [pc, #76]	; (8013fb8 <rt_system_heap_init+0x108>)
 8013f6c:	681b      	ldr	r3, [r3, #0]
 8013f6e:	4a10      	ldr	r2, [pc, #64]	; (8013fb0 <rt_system_heap_init+0x100>)
 8013f70:	6812      	ldr	r2, [r2, #0]
 8013f72:	320c      	adds	r2, #12
 8013f74:	609a      	str	r2, [r3, #8]

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
 8013f76:	4811      	ldr	r0, [pc, #68]	; (8013fbc <rt_system_heap_init+0x10c>)
 8013f78:	4911      	ldr	r1, [pc, #68]	; (8013fc0 <rt_system_heap_init+0x110>)
 8013f7a:	2201      	movs	r2, #1
 8013f7c:	2300      	movs	r3, #0
 8013f7e:	f7fe fafd 	bl	801257c <rt_sem_init>

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
 8013f82:	4b0c      	ldr	r3, [pc, #48]	; (8013fb4 <rt_system_heap_init+0x104>)
 8013f84:	681b      	ldr	r3, [r3, #0]
 8013f86:	4a0f      	ldr	r2, [pc, #60]	; (8013fc4 <rt_system_heap_init+0x114>)
 8013f88:	6013      	str	r3, [r2, #0]
 8013f8a:	e007      	b.n	8013f9c <rt_system_heap_init+0xec>
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
    }
    else
    {
        rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
 8013f8c:	687a      	ldr	r2, [r7, #4]
 8013f8e:	683b      	ldr	r3, [r7, #0]
 8013f90:	480d      	ldr	r0, [pc, #52]	; (8013fc8 <rt_system_heap_init+0x118>)
 8013f92:	4611      	mov	r1, r2
 8013f94:	461a      	mov	r2, r3
 8013f96:	f7ff fe6b 	bl	8013c70 <rt_kprintf>
                   (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);

        return;
 8013f9a:	bf00      	nop

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
}
 8013f9c:	3718      	adds	r7, #24
 8013f9e:	46bd      	mov	sp, r7
 8013fa0:	bd80      	pop	{r7, pc}
 8013fa2:	bf00      	nop
 8013fa4:	08022ed8 	.word	0x08022ed8
 8013fa8:	08024ea8 	.word	0x08024ea8
 8013fac:	08022efc 	.word	0x08022efc
 8013fb0:	20010dcc 	.word	0x20010dcc
 8013fb4:	20010da0 	.word	0x20010da0
 8013fb8:	20010da4 	.word	0x20010da4
 8013fbc:	20010dac 	.word	0x20010dac
 8013fc0:	08022f3c 	.word	0x08022f3c
 8013fc4:	20010da8 	.word	0x20010da8
 8013fc8:	08022f00 	.word	0x08022f00

08013fcc <rt_malloc>:
 * @param size is the minimum size of the requested block in bytes.
 *
 * @return pointer to allocated memory or NULL if no free memory was found.
 */
void *rt_malloc(rt_size_t size)
{
 8013fcc:	b580      	push	{r7, lr}
 8013fce:	b088      	sub	sp, #32
 8013fd0:	af00      	add	r7, sp, #0
 8013fd2:	6078      	str	r0, [r7, #4]
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8013fd4:	f7ec f8f8 	bl	80001c8 <rt_hw_interrupt_disable>
 8013fd8:	61b8      	str	r0, [r7, #24]
 8013fda:	f7ff f865 	bl	80130a8 <rt_interrupt_get_nest>
 8013fde:	4603      	mov	r3, r0
 8013fe0:	2b00      	cmp	r3, #0
 8013fe2:	d008      	beq.n	8013ff6 <rt_malloc+0x2a>
 8013fe4:	488d      	ldr	r0, [pc, #564]	; (801421c <rt_malloc+0x250>)
 8013fe6:	498e      	ldr	r1, [pc, #568]	; (8014220 <rt_malloc+0x254>)
 8013fe8:	f7ff fe42 	bl	8013c70 <rt_kprintf>
 8013fec:	488d      	ldr	r0, [pc, #564]	; (8014224 <rt_malloc+0x258>)
 8013fee:	498c      	ldr	r1, [pc, #560]	; (8014220 <rt_malloc+0x254>)
 8013ff0:	22fb      	movs	r2, #251	; 0xfb
 8013ff2:	f7ff feb7 	bl	8013d64 <rt_assert_handler>
 8013ff6:	69b8      	ldr	r0, [r7, #24]
 8013ff8:	f7ec f8ea 	bl	80001d0 <rt_hw_interrupt_enable>

    if (size == 0)
 8013ffc:	687b      	ldr	r3, [r7, #4]
 8013ffe:	2b00      	cmp	r3, #0
 8014000:	d101      	bne.n	8014006 <rt_malloc+0x3a>
        return RT_NULL;
 8014002:	2300      	movs	r3, #0
 8014004:	e105      	b.n	8014212 <rt_malloc+0x246>
                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
    else
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));

    /* alignment size */
    size = RT_ALIGN(size, RT_ALIGN_SIZE);
 8014006:	687b      	ldr	r3, [r7, #4]
 8014008:	3303      	adds	r3, #3
 801400a:	f023 0303 	bic.w	r3, r3, #3
 801400e:	607b      	str	r3, [r7, #4]

    if (size > mem_size_aligned)
 8014010:	4b85      	ldr	r3, [pc, #532]	; (8014228 <rt_malloc+0x25c>)
 8014012:	681b      	ldr	r3, [r3, #0]
 8014014:	687a      	ldr	r2, [r7, #4]
 8014016:	429a      	cmp	r2, r3
 8014018:	d901      	bls.n	801401e <rt_malloc+0x52>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));

        return RT_NULL;
 801401a:	2300      	movs	r3, #0
 801401c:	e0f9      	b.n	8014212 <rt_malloc+0x246>
    }

    /* every data block must be at least MIN_SIZE_ALIGNED long */
    if (size < MIN_SIZE_ALIGNED)
 801401e:	687b      	ldr	r3, [r7, #4]
 8014020:	2b0b      	cmp	r3, #11
 8014022:	d801      	bhi.n	8014028 <rt_malloc+0x5c>
        size = MIN_SIZE_ALIGNED;
 8014024:	230c      	movs	r3, #12
 8014026:	607b      	str	r3, [r7, #4]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 8014028:	4880      	ldr	r0, [pc, #512]	; (801422c <rt_malloc+0x260>)
 801402a:	f04f 31ff 	mov.w	r1, #4294967295
 801402e:	f7fe fb0b 	bl	8012648 <rt_sem_take>

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
 8014032:	4b7f      	ldr	r3, [pc, #508]	; (8014230 <rt_malloc+0x264>)
 8014034:	681b      	ldr	r3, [r3, #0]
 8014036:	461a      	mov	r2, r3
 8014038:	4b7e      	ldr	r3, [pc, #504]	; (8014234 <rt_malloc+0x268>)
 801403a:	681b      	ldr	r3, [r3, #0]
 801403c:	1ad3      	subs	r3, r2, r3
 801403e:	61fb      	str	r3, [r7, #28]
 8014040:	e0db      	b.n	80141fa <rt_malloc+0x22e>
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
    {
        mem = (struct heap_mem *)&heap_ptr[ptr];
 8014042:	4b7c      	ldr	r3, [pc, #496]	; (8014234 <rt_malloc+0x268>)
 8014044:	681a      	ldr	r2, [r3, #0]
 8014046:	69fb      	ldr	r3, [r7, #28]
 8014048:	4413      	add	r3, r2
 801404a:	617b      	str	r3, [r7, #20]

        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
 801404c:	697b      	ldr	r3, [r7, #20]
 801404e:	885b      	ldrh	r3, [r3, #2]
 8014050:	2b00      	cmp	r3, #0
 8014052:	f040 80cc 	bne.w	80141ee <rt_malloc+0x222>
 8014056:	697b      	ldr	r3, [r7, #20]
 8014058:	685a      	ldr	r2, [r3, #4]
 801405a:	69fb      	ldr	r3, [r7, #28]
 801405c:	1ad3      	subs	r3, r2, r3
 801405e:	f1a3 020c 	sub.w	r2, r3, #12
 8014062:	687b      	ldr	r3, [r7, #4]
 8014064:	429a      	cmp	r2, r3
 8014066:	f0c0 80c2 	bcc.w	80141ee <rt_malloc+0x222>
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
 801406a:	697b      	ldr	r3, [r7, #20]
 801406c:	685a      	ldr	r2, [r3, #4]
 801406e:	69fb      	ldr	r3, [r7, #28]
 8014070:	1ad3      	subs	r3, r2, r3
 8014072:	f1a3 020c 	sub.w	r2, r3, #12
                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
 8014076:	687b      	ldr	r3, [r7, #4]
 8014078:	3318      	adds	r3, #24
        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
 801407a:	429a      	cmp	r2, r3
 801407c:	d339      	bcc.n	80140f2 <rt_malloc+0x126>
                 * struct heap_mem would fit in but no data between mem2 and mem2->next
                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
                 *       region that couldn't hold data, but when mem->next gets freed,
                 *       the 2 regions would be combined, resulting in more free memory
                 */
                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 801407e:	69fa      	ldr	r2, [r7, #28]
 8014080:	687b      	ldr	r3, [r7, #4]
 8014082:	4413      	add	r3, r2
 8014084:	330c      	adds	r3, #12
 8014086:	613b      	str	r3, [r7, #16]

                /* create mem2 struct */
                mem2       = (struct heap_mem *)&heap_ptr[ptr2];
 8014088:	4b6a      	ldr	r3, [pc, #424]	; (8014234 <rt_malloc+0x268>)
 801408a:	681a      	ldr	r2, [r3, #0]
 801408c:	693b      	ldr	r3, [r7, #16]
 801408e:	4413      	add	r3, r2
 8014090:	60fb      	str	r3, [r7, #12]
                mem2->used = 0;
 8014092:	68fb      	ldr	r3, [r7, #12]
 8014094:	2200      	movs	r2, #0
 8014096:	805a      	strh	r2, [r3, #2]
                mem2->next = mem->next;
 8014098:	697b      	ldr	r3, [r7, #20]
 801409a:	685a      	ldr	r2, [r3, #4]
 801409c:	68fb      	ldr	r3, [r7, #12]
 801409e:	605a      	str	r2, [r3, #4]
                mem2->prev = ptr;
 80140a0:	68fb      	ldr	r3, [r7, #12]
 80140a2:	69fa      	ldr	r2, [r7, #28]
 80140a4:	609a      	str	r2, [r3, #8]

                /* and insert it between mem and mem->next */
                mem->next = ptr2;
 80140a6:	697b      	ldr	r3, [r7, #20]
 80140a8:	693a      	ldr	r2, [r7, #16]
 80140aa:	605a      	str	r2, [r3, #4]
                mem->used = 1;
 80140ac:	697b      	ldr	r3, [r7, #20]
 80140ae:	2201      	movs	r2, #1
 80140b0:	805a      	strh	r2, [r3, #2]

                if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
 80140b2:	68fb      	ldr	r3, [r7, #12]
 80140b4:	685a      	ldr	r2, [r3, #4]
 80140b6:	4b5c      	ldr	r3, [pc, #368]	; (8014228 <rt_malloc+0x25c>)
 80140b8:	681b      	ldr	r3, [r3, #0]
 80140ba:	330c      	adds	r3, #12
 80140bc:	429a      	cmp	r2, r3
 80140be:	d006      	beq.n	80140ce <rt_malloc+0x102>
                {
                    ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
 80140c0:	4b5c      	ldr	r3, [pc, #368]	; (8014234 <rt_malloc+0x268>)
 80140c2:	681a      	ldr	r2, [r3, #0]
 80140c4:	68fb      	ldr	r3, [r7, #12]
 80140c6:	685b      	ldr	r3, [r3, #4]
 80140c8:	4413      	add	r3, r2
 80140ca:	693a      	ldr	r2, [r7, #16]
 80140cc:	609a      	str	r2, [r3, #8]
                }
#ifdef RT_MEM_STATS
                used_mem += (size + SIZEOF_STRUCT_MEM);
 80140ce:	4b5a      	ldr	r3, [pc, #360]	; (8014238 <rt_malloc+0x26c>)
 80140d0:	681a      	ldr	r2, [r3, #0]
 80140d2:	687b      	ldr	r3, [r7, #4]
 80140d4:	4413      	add	r3, r2
 80140d6:	330c      	adds	r3, #12
 80140d8:	4a57      	ldr	r2, [pc, #348]	; (8014238 <rt_malloc+0x26c>)
 80140da:	6013      	str	r3, [r2, #0]
                if (max_mem < used_mem)
 80140dc:	4b57      	ldr	r3, [pc, #348]	; (801423c <rt_malloc+0x270>)
 80140de:	681a      	ldr	r2, [r3, #0]
 80140e0:	4b55      	ldr	r3, [pc, #340]	; (8014238 <rt_malloc+0x26c>)
 80140e2:	681b      	ldr	r3, [r3, #0]
 80140e4:	429a      	cmp	r2, r3
 80140e6:	d21e      	bcs.n	8014126 <rt_malloc+0x15a>
                    max_mem = used_mem;
 80140e8:	4b53      	ldr	r3, [pc, #332]	; (8014238 <rt_malloc+0x26c>)
 80140ea:	681b      	ldr	r3, [r3, #0]
 80140ec:	4a53      	ldr	r2, [pc, #332]	; (801423c <rt_malloc+0x270>)
 80140ee:	6013      	str	r3, [r2, #0]
 80140f0:	e019      	b.n	8014126 <rt_malloc+0x15a>
                 * take care of this).
                 * -> near fit or excact fit: do not split, no mem2 creation
                 * also can't move mem->next directly behind mem, since mem->next
                 * will always be used at this point!
                 */
                mem->used = 1;
 80140f2:	697b      	ldr	r3, [r7, #20]
 80140f4:	2201      	movs	r2, #1
 80140f6:	805a      	strh	r2, [r3, #2]
#ifdef RT_MEM_STATS
                used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
 80140f8:	697b      	ldr	r3, [r7, #20]
 80140fa:	685b      	ldr	r3, [r3, #4]
 80140fc:	4a4d      	ldr	r2, [pc, #308]	; (8014234 <rt_malloc+0x268>)
 80140fe:	6812      	ldr	r2, [r2, #0]
 8014100:	4611      	mov	r1, r2
 8014102:	697a      	ldr	r2, [r7, #20]
 8014104:	1a8a      	subs	r2, r1, r2
 8014106:	441a      	add	r2, r3
 8014108:	4b4b      	ldr	r3, [pc, #300]	; (8014238 <rt_malloc+0x26c>)
 801410a:	681b      	ldr	r3, [r3, #0]
 801410c:	4413      	add	r3, r2
 801410e:	4a4a      	ldr	r2, [pc, #296]	; (8014238 <rt_malloc+0x26c>)
 8014110:	6013      	str	r3, [r2, #0]
                if (max_mem < used_mem)
 8014112:	4b4a      	ldr	r3, [pc, #296]	; (801423c <rt_malloc+0x270>)
 8014114:	681a      	ldr	r2, [r3, #0]
 8014116:	4b48      	ldr	r3, [pc, #288]	; (8014238 <rt_malloc+0x26c>)
 8014118:	681b      	ldr	r3, [r3, #0]
 801411a:	429a      	cmp	r2, r3
 801411c:	d203      	bcs.n	8014126 <rt_malloc+0x15a>
                    max_mem = used_mem;
 801411e:	4b46      	ldr	r3, [pc, #280]	; (8014238 <rt_malloc+0x26c>)
 8014120:	681b      	ldr	r3, [r3, #0]
 8014122:	4a46      	ldr	r2, [pc, #280]	; (801423c <rt_malloc+0x270>)
 8014124:	6013      	str	r3, [r2, #0]
#endif
            }
            /* set memory block magic */
            mem->magic = HEAP_MAGIC;
 8014126:	697b      	ldr	r3, [r7, #20]
 8014128:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 801412c:	801a      	strh	r2, [r3, #0]

            if (mem == lfree)
 801412e:	4b40      	ldr	r3, [pc, #256]	; (8014230 <rt_malloc+0x264>)
 8014130:	681b      	ldr	r3, [r3, #0]
 8014132:	697a      	ldr	r2, [r7, #20]
 8014134:	429a      	cmp	r2, r3
 8014136:	d124      	bne.n	8014182 <rt_malloc+0x1b6>
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
 8014138:	e007      	b.n	801414a <rt_malloc+0x17e>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];
 801413a:	4b3e      	ldr	r3, [pc, #248]	; (8014234 <rt_malloc+0x268>)
 801413c:	681a      	ldr	r2, [r3, #0]
 801413e:	4b3c      	ldr	r3, [pc, #240]	; (8014230 <rt_malloc+0x264>)
 8014140:	681b      	ldr	r3, [r3, #0]
 8014142:	685b      	ldr	r3, [r3, #4]
 8014144:	4413      	add	r3, r2
 8014146:	4a3a      	ldr	r2, [pc, #232]	; (8014230 <rt_malloc+0x264>)
 8014148:	6013      	str	r3, [r2, #0]
            mem->magic = HEAP_MAGIC;

            if (mem == lfree)
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
 801414a:	4b39      	ldr	r3, [pc, #228]	; (8014230 <rt_malloc+0x264>)
 801414c:	681b      	ldr	r3, [r3, #0]
 801414e:	885b      	ldrh	r3, [r3, #2]
 8014150:	2b00      	cmp	r3, #0
 8014152:	d005      	beq.n	8014160 <rt_malloc+0x194>
 8014154:	4b36      	ldr	r3, [pc, #216]	; (8014230 <rt_malloc+0x264>)
 8014156:	681a      	ldr	r2, [r3, #0]
 8014158:	4b39      	ldr	r3, [pc, #228]	; (8014240 <rt_malloc+0x274>)
 801415a:	681b      	ldr	r3, [r3, #0]
 801415c:	429a      	cmp	r2, r3
 801415e:	d1ec      	bne.n	801413a <rt_malloc+0x16e>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];

                RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
 8014160:	4b33      	ldr	r3, [pc, #204]	; (8014230 <rt_malloc+0x264>)
 8014162:	681a      	ldr	r2, [r3, #0]
 8014164:	4b36      	ldr	r3, [pc, #216]	; (8014240 <rt_malloc+0x274>)
 8014166:	681b      	ldr	r3, [r3, #0]
 8014168:	429a      	cmp	r2, r3
 801416a:	d00a      	beq.n	8014182 <rt_malloc+0x1b6>
 801416c:	4b30      	ldr	r3, [pc, #192]	; (8014230 <rt_malloc+0x264>)
 801416e:	681b      	ldr	r3, [r3, #0]
 8014170:	885b      	ldrh	r3, [r3, #2]
 8014172:	2b00      	cmp	r3, #0
 8014174:	d005      	beq.n	8014182 <rt_malloc+0x1b6>
 8014176:	4833      	ldr	r0, [pc, #204]	; (8014244 <rt_malloc+0x278>)
 8014178:	4929      	ldr	r1, [pc, #164]	; (8014220 <rt_malloc+0x254>)
 801417a:	f44f 72af 	mov.w	r2, #350	; 0x15e
 801417e:	f7ff fdf1 	bl	8013d64 <rt_assert_handler>
            }

            rt_sem_release(&heap_sem);
 8014182:	482a      	ldr	r0, [pc, #168]	; (801422c <rt_malloc+0x260>)
 8014184:	f7fe fb04 	bl	8012790 <rt_sem_release>
            RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
 8014188:	697a      	ldr	r2, [r7, #20]
 801418a:	687b      	ldr	r3, [r7, #4]
 801418c:	4413      	add	r3, r2
 801418e:	330c      	adds	r3, #12
 8014190:	4a2b      	ldr	r2, [pc, #172]	; (8014240 <rt_malloc+0x274>)
 8014192:	6812      	ldr	r2, [r2, #0]
 8014194:	4293      	cmp	r3, r2
 8014196:	d905      	bls.n	80141a4 <rt_malloc+0x1d8>
 8014198:	482b      	ldr	r0, [pc, #172]	; (8014248 <rt_malloc+0x27c>)
 801419a:	4921      	ldr	r1, [pc, #132]	; (8014220 <rt_malloc+0x254>)
 801419c:	f44f 72b1 	mov.w	r2, #354	; 0x162
 80141a0:	f7ff fde0 	bl	8013d64 <rt_assert_handler>
            RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
 80141a4:	697b      	ldr	r3, [r7, #20]
 80141a6:	330c      	adds	r3, #12
 80141a8:	f003 0303 	and.w	r3, r3, #3
 80141ac:	2b00      	cmp	r3, #0
 80141ae:	d005      	beq.n	80141bc <rt_malloc+0x1f0>
 80141b0:	4826      	ldr	r0, [pc, #152]	; (801424c <rt_malloc+0x280>)
 80141b2:	491b      	ldr	r1, [pc, #108]	; (8014220 <rt_malloc+0x254>)
 80141b4:	f240 1263 	movw	r2, #355	; 0x163
 80141b8:	f7ff fdd4 	bl	8013d64 <rt_assert_handler>
            RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
 80141bc:	697b      	ldr	r3, [r7, #20]
 80141be:	f003 0303 	and.w	r3, r3, #3
 80141c2:	2b00      	cmp	r3, #0
 80141c4:	d005      	beq.n	80141d2 <rt_malloc+0x206>
 80141c6:	4822      	ldr	r0, [pc, #136]	; (8014250 <rt_malloc+0x284>)
 80141c8:	4915      	ldr	r1, [pc, #84]	; (8014220 <rt_malloc+0x254>)
 80141ca:	f44f 72b2 	mov.w	r2, #356	; 0x164
 80141ce:	f7ff fdc9 	bl	8013d64 <rt_assert_handler>
            RT_DEBUG_LOG(RT_DEBUG_MEM,
                         ("allocate memory at 0x%x, size: %d\n",
                          (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
                          (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));

            RT_OBJECT_HOOK_CALL(rt_malloc_hook,
 80141d2:	4b20      	ldr	r3, [pc, #128]	; (8014254 <rt_malloc+0x288>)
 80141d4:	681b      	ldr	r3, [r3, #0]
 80141d6:	2b00      	cmp	r3, #0
 80141d8:	d006      	beq.n	80141e8 <rt_malloc+0x21c>
 80141da:	4b1e      	ldr	r3, [pc, #120]	; (8014254 <rt_malloc+0x288>)
 80141dc:	681b      	ldr	r3, [r3, #0]
 80141de:	697a      	ldr	r2, [r7, #20]
 80141e0:	320c      	adds	r2, #12
 80141e2:	4610      	mov	r0, r2
 80141e4:	6879      	ldr	r1, [r7, #4]
 80141e6:	4798      	blx	r3
                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));

            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
 80141e8:	697b      	ldr	r3, [r7, #20]
 80141ea:	330c      	adds	r3, #12
 80141ec:	e011      	b.n	8014212 <rt_malloc+0x246>
    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
 80141ee:	4b11      	ldr	r3, [pc, #68]	; (8014234 <rt_malloc+0x268>)
 80141f0:	681a      	ldr	r2, [r3, #0]
 80141f2:	69fb      	ldr	r3, [r7, #28]
 80141f4:	4413      	add	r3, r2
 80141f6:	685b      	ldr	r3, [r3, #4]
 80141f8:	61fb      	str	r3, [r7, #28]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
 80141fa:	4b0b      	ldr	r3, [pc, #44]	; (8014228 <rt_malloc+0x25c>)
 80141fc:	681a      	ldr	r2, [r3, #0]
 80141fe:	687b      	ldr	r3, [r7, #4]
 8014200:	1ad2      	subs	r2, r2, r3
        size = MIN_SIZE_ALIGNED;

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
 8014202:	69fb      	ldr	r3, [r7, #28]
 8014204:	429a      	cmp	r2, r3
 8014206:	f63f af1c 	bhi.w	8014042 <rt_malloc+0x76>
            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
        }
    }

    rt_sem_release(&heap_sem);
 801420a:	4808      	ldr	r0, [pc, #32]	; (801422c <rt_malloc+0x260>)
 801420c:	f7fe fac0 	bl	8012790 <rt_sem_release>

    return RT_NULL;
 8014210:	2300      	movs	r3, #0
}
 8014212:	4618      	mov	r0, r3
 8014214:	3720      	adds	r7, #32
 8014216:	46bd      	mov	sp, r7
 8014218:	bd80      	pop	{r7, pc}
 801421a:	bf00      	nop
 801421c:	08022ed8 	.word	0x08022ed8
 8014220:	08024ebc 	.word	0x08024ebc
 8014224:	08022efc 	.word	0x08022efc
 8014228:	20010dcc 	.word	0x20010dcc
 801422c:	20010dac 	.word	0x20010dac
 8014230:	20010da8 	.word	0x20010da8
 8014234:	20010da0 	.word	0x20010da0
 8014238:	20010dd0 	.word	0x20010dd0
 801423c:	20010dd4 	.word	0x20010dd4
 8014240:	20010da4 	.word	0x20010da4
 8014244:	08022f44 	.word	0x08022f44
 8014248:	08022f6c 	.word	0x08022f6c
 801424c:	08022fb4 	.word	0x08022fb4
 8014250:	08023000 	.word	0x08023000
 8014254:	20010d98 	.word	0x20010d98

08014258 <rt_realloc>:
 * @param newsize the required new size
 *
 * @return the changed memory block address
 */
void *rt_realloc(void *rmem, rt_size_t newsize)
{
 8014258:	b580      	push	{r7, lr}
 801425a:	b08a      	sub	sp, #40	; 0x28
 801425c:	af00      	add	r7, sp, #0
 801425e:	6078      	str	r0, [r7, #4]
 8014260:	6039      	str	r1, [r7, #0]
    rt_size_t size;
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;
    void *nmem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8014262:	f7eb ffb1 	bl	80001c8 <rt_hw_interrupt_disable>
 8014266:	6278      	str	r0, [r7, #36]	; 0x24
 8014268:	f7fe ff1e 	bl	80130a8 <rt_interrupt_get_nest>
 801426c:	4603      	mov	r3, r0
 801426e:	2b00      	cmp	r3, #0
 8014270:	d009      	beq.n	8014286 <rt_realloc+0x2e>
 8014272:	4853      	ldr	r0, [pc, #332]	; (80143c0 <rt_realloc+0x168>)
 8014274:	4953      	ldr	r1, [pc, #332]	; (80143c4 <rt_realloc+0x16c>)
 8014276:	f7ff fcfb 	bl	8013c70 <rt_kprintf>
 801427a:	4853      	ldr	r0, [pc, #332]	; (80143c8 <rt_realloc+0x170>)
 801427c:	4951      	ldr	r1, [pc, #324]	; (80143c4 <rt_realloc+0x16c>)
 801427e:	f44f 72c4 	mov.w	r2, #392	; 0x188
 8014282:	f7ff fd6f 	bl	8013d64 <rt_assert_handler>
 8014286:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8014288:	f7eb ffa2 	bl	80001d0 <rt_hw_interrupt_enable>

    /* alignment size */
    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
 801428c:	683b      	ldr	r3, [r7, #0]
 801428e:	3303      	adds	r3, #3
 8014290:	f023 0303 	bic.w	r3, r3, #3
 8014294:	603b      	str	r3, [r7, #0]
    if (newsize > mem_size_aligned)
 8014296:	4b4d      	ldr	r3, [pc, #308]	; (80143cc <rt_realloc+0x174>)
 8014298:	681b      	ldr	r3, [r3, #0]
 801429a:	683a      	ldr	r2, [r7, #0]
 801429c:	429a      	cmp	r2, r3
 801429e:	d901      	bls.n	80142a4 <rt_realloc+0x4c>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));

        return RT_NULL;
 80142a0:	2300      	movs	r3, #0
 80142a2:	e089      	b.n	80143b8 <rt_realloc+0x160>
    }

    /* allocate a new memory block */
    if (rmem == RT_NULL)
 80142a4:	687b      	ldr	r3, [r7, #4]
 80142a6:	2b00      	cmp	r3, #0
 80142a8:	d104      	bne.n	80142b4 <rt_realloc+0x5c>
        return rt_malloc(newsize);
 80142aa:	6838      	ldr	r0, [r7, #0]
 80142ac:	f7ff fe8e 	bl	8013fcc <rt_malloc>
 80142b0:	4603      	mov	r3, r0
 80142b2:	e081      	b.n	80143b8 <rt_realloc+0x160>

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 80142b4:	4846      	ldr	r0, [pc, #280]	; (80143d0 <rt_realloc+0x178>)
 80142b6:	f04f 31ff 	mov.w	r1, #4294967295
 80142ba:	f7fe f9c5 	bl	8012648 <rt_sem_take>

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 80142be:	4b45      	ldr	r3, [pc, #276]	; (80143d4 <rt_realloc+0x17c>)
 80142c0:	681b      	ldr	r3, [r3, #0]
 80142c2:	687a      	ldr	r2, [r7, #4]
 80142c4:	429a      	cmp	r2, r3
 80142c6:	d304      	bcc.n	80142d2 <rt_realloc+0x7a>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 80142c8:	4b43      	ldr	r3, [pc, #268]	; (80143d8 <rt_realloc+0x180>)
 80142ca:	681b      	ldr	r3, [r3, #0]
    if (rmem == RT_NULL)
        return rt_malloc(newsize);

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 80142cc:	687a      	ldr	r2, [r7, #4]
 80142ce:	429a      	cmp	r2, r3
 80142d0:	d304      	bcc.n	80142dc <rt_realloc+0x84>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        /* illegal memory */
        rt_sem_release(&heap_sem);
 80142d2:	483f      	ldr	r0, [pc, #252]	; (80143d0 <rt_realloc+0x178>)
 80142d4:	f7fe fa5c 	bl	8012790 <rt_sem_release>

        return rmem;
 80142d8:	687b      	ldr	r3, [r7, #4]
 80142da:	e06d      	b.n	80143b8 <rt_realloc+0x160>
    }

    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
 80142dc:	687b      	ldr	r3, [r7, #4]
 80142de:	3b0c      	subs	r3, #12
 80142e0:	623b      	str	r3, [r7, #32]

    ptr = (rt_uint8_t *)mem - heap_ptr;
 80142e2:	6a3b      	ldr	r3, [r7, #32]
 80142e4:	4a3b      	ldr	r2, [pc, #236]	; (80143d4 <rt_realloc+0x17c>)
 80142e6:	6812      	ldr	r2, [r2, #0]
 80142e8:	1a9b      	subs	r3, r3, r2
 80142ea:	61fb      	str	r3, [r7, #28]
    size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 80142ec:	6a3b      	ldr	r3, [r7, #32]
 80142ee:	685a      	ldr	r2, [r3, #4]
 80142f0:	69fb      	ldr	r3, [r7, #28]
 80142f2:	1ad3      	subs	r3, r2, r3
 80142f4:	3b0c      	subs	r3, #12
 80142f6:	61bb      	str	r3, [r7, #24]
    if (size == newsize)
 80142f8:	69ba      	ldr	r2, [r7, #24]
 80142fa:	683b      	ldr	r3, [r7, #0]
 80142fc:	429a      	cmp	r2, r3
 80142fe:	d104      	bne.n	801430a <rt_realloc+0xb2>
    {
        /* the size is the same as */
        rt_sem_release(&heap_sem);
 8014300:	4833      	ldr	r0, [pc, #204]	; (80143d0 <rt_realloc+0x178>)
 8014302:	f7fe fa45 	bl	8012790 <rt_sem_release>

        return rmem;
 8014306:	687b      	ldr	r3, [r7, #4]
 8014308:	e056      	b.n	80143b8 <rt_realloc+0x160>
    }

    if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
 801430a:	683b      	ldr	r3, [r7, #0]
 801430c:	f103 0218 	add.w	r2, r3, #24
 8014310:	69bb      	ldr	r3, [r7, #24]
 8014312:	429a      	cmp	r2, r3
 8014314:	d238      	bcs.n	8014388 <rt_realloc+0x130>
    {
        /* split memory block */
#ifdef RT_MEM_STATS
        used_mem -= (size - newsize);
 8014316:	683a      	ldr	r2, [r7, #0]
 8014318:	69bb      	ldr	r3, [r7, #24]
 801431a:	1ad2      	subs	r2, r2, r3
 801431c:	4b2f      	ldr	r3, [pc, #188]	; (80143dc <rt_realloc+0x184>)
 801431e:	681b      	ldr	r3, [r3, #0]
 8014320:	4413      	add	r3, r2
 8014322:	4a2e      	ldr	r2, [pc, #184]	; (80143dc <rt_realloc+0x184>)
 8014324:	6013      	str	r3, [r2, #0]
#endif

        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8014326:	69fa      	ldr	r2, [r7, #28]
 8014328:	683b      	ldr	r3, [r7, #0]
 801432a:	4413      	add	r3, r2
 801432c:	330c      	adds	r3, #12
 801432e:	617b      	str	r3, [r7, #20]
        mem2 = (struct heap_mem *)&heap_ptr[ptr2];
 8014330:	4b28      	ldr	r3, [pc, #160]	; (80143d4 <rt_realloc+0x17c>)
 8014332:	681a      	ldr	r2, [r3, #0]
 8014334:	697b      	ldr	r3, [r7, #20]
 8014336:	4413      	add	r3, r2
 8014338:	613b      	str	r3, [r7, #16]
        mem2->magic= HEAP_MAGIC;
 801433a:	693b      	ldr	r3, [r7, #16]
 801433c:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 8014340:	801a      	strh	r2, [r3, #0]
        mem2->used = 0;
 8014342:	693b      	ldr	r3, [r7, #16]
 8014344:	2200      	movs	r2, #0
 8014346:	805a      	strh	r2, [r3, #2]
        mem2->next = mem->next;
 8014348:	6a3b      	ldr	r3, [r7, #32]
 801434a:	685a      	ldr	r2, [r3, #4]
 801434c:	693b      	ldr	r3, [r7, #16]
 801434e:	605a      	str	r2, [r3, #4]
        mem2->prev = ptr;
 8014350:	693b      	ldr	r3, [r7, #16]
 8014352:	69fa      	ldr	r2, [r7, #28]
 8014354:	609a      	str	r2, [r3, #8]
        mem->next = ptr2;
 8014356:	6a3b      	ldr	r3, [r7, #32]
 8014358:	697a      	ldr	r2, [r7, #20]
 801435a:	605a      	str	r2, [r3, #4]
        if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
 801435c:	693b      	ldr	r3, [r7, #16]
 801435e:	685a      	ldr	r2, [r3, #4]
 8014360:	4b1a      	ldr	r3, [pc, #104]	; (80143cc <rt_realloc+0x174>)
 8014362:	681b      	ldr	r3, [r3, #0]
 8014364:	330c      	adds	r3, #12
 8014366:	429a      	cmp	r2, r3
 8014368:	d006      	beq.n	8014378 <rt_realloc+0x120>
        {
            ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
 801436a:	4b1a      	ldr	r3, [pc, #104]	; (80143d4 <rt_realloc+0x17c>)
 801436c:	681a      	ldr	r2, [r3, #0]
 801436e:	693b      	ldr	r3, [r7, #16]
 8014370:	685b      	ldr	r3, [r3, #4]
 8014372:	4413      	add	r3, r2
 8014374:	697a      	ldr	r2, [r7, #20]
 8014376:	609a      	str	r2, [r3, #8]
        }

        plug_holes(mem2);
 8014378:	6938      	ldr	r0, [r7, #16]
 801437a:	f7ff fd19 	bl	8013db0 <plug_holes>

        rt_sem_release(&heap_sem);
 801437e:	4814      	ldr	r0, [pc, #80]	; (80143d0 <rt_realloc+0x178>)
 8014380:	f7fe fa06 	bl	8012790 <rt_sem_release>

        return rmem;
 8014384:	687b      	ldr	r3, [r7, #4]
 8014386:	e017      	b.n	80143b8 <rt_realloc+0x160>
    }
    rt_sem_release(&heap_sem);
 8014388:	4811      	ldr	r0, [pc, #68]	; (80143d0 <rt_realloc+0x178>)
 801438a:	f7fe fa01 	bl	8012790 <rt_sem_release>

    /* expand memory */
    nmem = rt_malloc(newsize);
 801438e:	6838      	ldr	r0, [r7, #0]
 8014390:	f7ff fe1c 	bl	8013fcc <rt_malloc>
 8014394:	60f8      	str	r0, [r7, #12]
    if (nmem != RT_NULL) /* check memory */
 8014396:	68fb      	ldr	r3, [r7, #12]
 8014398:	2b00      	cmp	r3, #0
 801439a:	d00c      	beq.n	80143b6 <rt_realloc+0x15e>
    {
        rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
 801439c:	683a      	ldr	r2, [r7, #0]
 801439e:	69bb      	ldr	r3, [r7, #24]
 80143a0:	4293      	cmp	r3, r2
 80143a2:	bf28      	it	cs
 80143a4:	4613      	movcs	r3, r2
 80143a6:	68f8      	ldr	r0, [r7, #12]
 80143a8:	6879      	ldr	r1, [r7, #4]
 80143aa:	461a      	mov	r2, r3
 80143ac:	f7fe ff04 	bl	80131b8 <rt_memcpy>
        rt_free(rmem);
 80143b0:	6878      	ldr	r0, [r7, #4]
 80143b2:	f000 f815 	bl	80143e0 <rt_free>
    }

    return nmem;
 80143b6:	68fb      	ldr	r3, [r7, #12]
}
 80143b8:	4618      	mov	r0, r3
 80143ba:	3728      	adds	r7, #40	; 0x28
 80143bc:	46bd      	mov	sp, r7
 80143be:	bd80      	pop	{r7, pc}
 80143c0:	08022ed8 	.word	0x08022ed8
 80143c4:	08024ec8 	.word	0x08024ec8
 80143c8:	08022efc 	.word	0x08022efc
 80143cc:	20010dcc 	.word	0x20010dcc
 80143d0:	20010dac 	.word	0x20010dac
 80143d4:	20010da0 	.word	0x20010da0
 80143d8:	20010da4 	.word	0x20010da4
 80143dc:	20010dd0 	.word	0x20010dd0

080143e0 <rt_free>:
 * rt_malloc. The released memory block is taken back to system heap.
 *
 * @param rmem the address of memory which will be released
 */
void rt_free(void *rmem)
{
 80143e0:	b580      	push	{r7, lr}
 80143e2:	b084      	sub	sp, #16
 80143e4:	af00      	add	r7, sp, #0
 80143e6:	6078      	str	r0, [r7, #4]
    struct heap_mem *mem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 80143e8:	f7eb feee 	bl	80001c8 <rt_hw_interrupt_disable>
 80143ec:	60f8      	str	r0, [r7, #12]
 80143ee:	f7fe fe5b 	bl	80130a8 <rt_interrupt_get_nest>
 80143f2:	4603      	mov	r3, r0
 80143f4:	2b00      	cmp	r3, #0
 80143f6:	d009      	beq.n	801440c <rt_free+0x2c>
 80143f8:	483f      	ldr	r0, [pc, #252]	; (80144f8 <rt_free+0x118>)
 80143fa:	4940      	ldr	r1, [pc, #256]	; (80144fc <rt_free+0x11c>)
 80143fc:	f7ff fc38 	bl	8013c70 <rt_kprintf>
 8014400:	483f      	ldr	r0, [pc, #252]	; (8014500 <rt_free+0x120>)
 8014402:	493e      	ldr	r1, [pc, #248]	; (80144fc <rt_free+0x11c>)
 8014404:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
 8014408:	f7ff fcac 	bl	8013d64 <rt_assert_handler>
 801440c:	68f8      	ldr	r0, [r7, #12]
 801440e:	f7eb fedf 	bl	80001d0 <rt_hw_interrupt_enable>

    if (rmem == RT_NULL)
 8014412:	687b      	ldr	r3, [r7, #4]
 8014414:	2b00      	cmp	r3, #0
 8014416:	d100      	bne.n	801441a <rt_free+0x3a>
        return;
 8014418:	e06b      	b.n	80144f2 <rt_free+0x112>
    RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
 801441a:	687b      	ldr	r3, [r7, #4]
 801441c:	f003 0303 	and.w	r3, r3, #3
 8014420:	2b00      	cmp	r3, #0
 8014422:	d005      	beq.n	8014430 <rt_free+0x50>
 8014424:	4837      	ldr	r0, [pc, #220]	; (8014504 <rt_free+0x124>)
 8014426:	4935      	ldr	r1, [pc, #212]	; (80144fc <rt_free+0x11c>)
 8014428:	f44f 7200 	mov.w	r2, #512	; 0x200
 801442c:	f7ff fc9a 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
 8014430:	4b35      	ldr	r3, [pc, #212]	; (8014508 <rt_free+0x128>)
 8014432:	681b      	ldr	r3, [r3, #0]
 8014434:	687a      	ldr	r2, [r7, #4]
 8014436:	429a      	cmp	r2, r3
 8014438:	d304      	bcc.n	8014444 <rt_free+0x64>
 801443a:	4b34      	ldr	r3, [pc, #208]	; (801450c <rt_free+0x12c>)
 801443c:	681b      	ldr	r3, [r3, #0]
 801443e:	687a      	ldr	r2, [r7, #4]
 8014440:	429a      	cmp	r2, r3
 8014442:	d305      	bcc.n	8014450 <rt_free+0x70>
 8014444:	4832      	ldr	r0, [pc, #200]	; (8014510 <rt_free+0x130>)
 8014446:	492d      	ldr	r1, [pc, #180]	; (80144fc <rt_free+0x11c>)
 8014448:	f240 2202 	movw	r2, #514	; 0x202
 801444c:	f7ff fc8a 	bl	8013d64 <rt_assert_handler>
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
 8014450:	4b30      	ldr	r3, [pc, #192]	; (8014514 <rt_free+0x134>)
 8014452:	681b      	ldr	r3, [r3, #0]
 8014454:	2b00      	cmp	r3, #0
 8014456:	d003      	beq.n	8014460 <rt_free+0x80>
 8014458:	4b2e      	ldr	r3, [pc, #184]	; (8014514 <rt_free+0x134>)
 801445a:	681b      	ldr	r3, [r3, #0]
 801445c:	6878      	ldr	r0, [r7, #4]
 801445e:	4798      	blx	r3

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 8014460:	4b29      	ldr	r3, [pc, #164]	; (8014508 <rt_free+0x128>)
 8014462:	681b      	ldr	r3, [r3, #0]
 8014464:	687a      	ldr	r2, [r7, #4]
 8014466:	429a      	cmp	r2, r3
 8014468:	d304      	bcc.n	8014474 <rt_free+0x94>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 801446a:	4b28      	ldr	r3, [pc, #160]	; (801450c <rt_free+0x12c>)
 801446c:	681b      	ldr	r3, [r3, #0]
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 801446e:	687a      	ldr	r2, [r7, #4]
 8014470:	429a      	cmp	r2, r3
 8014472:	d300      	bcc.n	8014476 <rt_free+0x96>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));

        return;
 8014474:	e03d      	b.n	80144f2 <rt_free+0x112>
    }

    /* Get the corresponding struct heap_mem ... */
    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
 8014476:	687b      	ldr	r3, [r7, #4]
 8014478:	3b0c      	subs	r3, #12
 801447a:	60bb      	str	r3, [r7, #8]
                  (rt_uint32_t)rmem,
                  (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));


    /* protect the heap from concurrent access */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 801447c:	4826      	ldr	r0, [pc, #152]	; (8014518 <rt_free+0x138>)
 801447e:	f04f 31ff 	mov.w	r1, #4294967295
 8014482:	f7fe f8e1 	bl	8012648 <rt_sem_take>

    /* ... which has to be in a used state ... */
    RT_ASSERT(mem->used);
 8014486:	68bb      	ldr	r3, [r7, #8]
 8014488:	885b      	ldrh	r3, [r3, #2]
 801448a:	2b00      	cmp	r3, #0
 801448c:	d105      	bne.n	801449a <rt_free+0xba>
 801448e:	4823      	ldr	r0, [pc, #140]	; (801451c <rt_free+0x13c>)
 8014490:	491a      	ldr	r1, [pc, #104]	; (80144fc <rt_free+0x11c>)
 8014492:	f240 221b 	movw	r2, #539	; 0x21b
 8014496:	f7ff fc65 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(mem->magic == HEAP_MAGIC);
 801449a:	68bb      	ldr	r3, [r7, #8]
 801449c:	881b      	ldrh	r3, [r3, #0]
 801449e:	f5b3 5ff5 	cmp.w	r3, #7840	; 0x1ea0
 80144a2:	d005      	beq.n	80144b0 <rt_free+0xd0>
 80144a4:	481e      	ldr	r0, [pc, #120]	; (8014520 <rt_free+0x140>)
 80144a6:	4915      	ldr	r1, [pc, #84]	; (80144fc <rt_free+0x11c>)
 80144a8:	f44f 7207 	mov.w	r2, #540	; 0x21c
 80144ac:	f7ff fc5a 	bl	8013d64 <rt_assert_handler>
    /* ... and is now unused. */
    mem->used  = 0;
 80144b0:	68bb      	ldr	r3, [r7, #8]
 80144b2:	2200      	movs	r2, #0
 80144b4:	805a      	strh	r2, [r3, #2]
    mem->magic = 0;
 80144b6:	68bb      	ldr	r3, [r7, #8]
 80144b8:	2200      	movs	r2, #0
 80144ba:	801a      	strh	r2, [r3, #0]

    if (mem < lfree)
 80144bc:	4b19      	ldr	r3, [pc, #100]	; (8014524 <rt_free+0x144>)
 80144be:	681b      	ldr	r3, [r3, #0]
 80144c0:	68ba      	ldr	r2, [r7, #8]
 80144c2:	429a      	cmp	r2, r3
 80144c4:	d202      	bcs.n	80144cc <rt_free+0xec>
    {
        /* the newly freed struct is now the lowest */
        lfree = mem;
 80144c6:	4a17      	ldr	r2, [pc, #92]	; (8014524 <rt_free+0x144>)
 80144c8:	68bb      	ldr	r3, [r7, #8]
 80144ca:	6013      	str	r3, [r2, #0]
    }

#ifdef RT_MEM_STATS
    used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
 80144cc:	4b16      	ldr	r3, [pc, #88]	; (8014528 <rt_free+0x148>)
 80144ce:	681a      	ldr	r2, [r3, #0]
 80144d0:	68bb      	ldr	r3, [r7, #8]
 80144d2:	685b      	ldr	r3, [r3, #4]
 80144d4:	490c      	ldr	r1, [pc, #48]	; (8014508 <rt_free+0x128>)
 80144d6:	6809      	ldr	r1, [r1, #0]
 80144d8:	4608      	mov	r0, r1
 80144da:	68b9      	ldr	r1, [r7, #8]
 80144dc:	1a41      	subs	r1, r0, r1
 80144de:	440b      	add	r3, r1
 80144e0:	1ad3      	subs	r3, r2, r3
 80144e2:	4a11      	ldr	r2, [pc, #68]	; (8014528 <rt_free+0x148>)
 80144e4:	6013      	str	r3, [r2, #0]
#endif

    /* finally, see if prev or next are free also */
    plug_holes(mem);
 80144e6:	68b8      	ldr	r0, [r7, #8]
 80144e8:	f7ff fc62 	bl	8013db0 <plug_holes>
    rt_sem_release(&heap_sem);
 80144ec:	480a      	ldr	r0, [pc, #40]	; (8014518 <rt_free+0x138>)
 80144ee:	f7fe f94f 	bl	8012790 <rt_sem_release>
}
 80144f2:	3710      	adds	r7, #16
 80144f4:	46bd      	mov	sp, r7
 80144f6:	bd80      	pop	{r7, pc}
 80144f8:	08022ed8 	.word	0x08022ed8
 80144fc:	08024ed4 	.word	0x08024ed4
 8014500:	08022efc 	.word	0x08022efc
 8014504:	08023030 	.word	0x08023030
 8014508:	20010da0 	.word	0x20010da0
 801450c:	20010da4 	.word	0x20010da4
 8014510:	08023060 	.word	0x08023060
 8014514:	20010d9c 	.word	0x20010d9c
 8014518:	20010dac 	.word	0x20010dac
 801451c:	080230bc 	.word	0x080230bc
 8014520:	080230c8 	.word	0x080230c8
 8014524:	20010da8 	.word	0x20010da8
 8014528:	20010dd0 	.word	0x20010dd0

0801452c <list_mem>:

#ifdef RT_USING_FINSH
#include <finsh.h>

void list_mem(void)
{
 801452c:	b580      	push	{r7, lr}
 801452e:	af00      	add	r7, sp, #0
    rt_kprintf("total memory: %d\n", mem_size_aligned);
 8014530:	4b09      	ldr	r3, [pc, #36]	; (8014558 <list_mem+0x2c>)
 8014532:	681b      	ldr	r3, [r3, #0]
 8014534:	4809      	ldr	r0, [pc, #36]	; (801455c <list_mem+0x30>)
 8014536:	4619      	mov	r1, r3
 8014538:	f7ff fb9a 	bl	8013c70 <rt_kprintf>
    rt_kprintf("used memory : %d\n", used_mem);
 801453c:	4b08      	ldr	r3, [pc, #32]	; (8014560 <list_mem+0x34>)
 801453e:	681b      	ldr	r3, [r3, #0]
 8014540:	4808      	ldr	r0, [pc, #32]	; (8014564 <list_mem+0x38>)
 8014542:	4619      	mov	r1, r3
 8014544:	f7ff fb94 	bl	8013c70 <rt_kprintf>
    rt_kprintf("maximum allocated memory: %d\n", max_mem);
 8014548:	4b07      	ldr	r3, [pc, #28]	; (8014568 <list_mem+0x3c>)
 801454a:	681b      	ldr	r3, [r3, #0]
 801454c:	4807      	ldr	r0, [pc, #28]	; (801456c <list_mem+0x40>)
 801454e:	4619      	mov	r1, r3
 8014550:	f7ff fb8e 	bl	8013c70 <rt_kprintf>
}
 8014554:	bd80      	pop	{r7, pc}
 8014556:	bf00      	nop
 8014558:	20010dcc 	.word	0x20010dcc
 801455c:	080230e4 	.word	0x080230e4
 8014560:	20010dd0 	.word	0x20010dd0
 8014564:	080230f8 	.word	0x080230f8
 8014568:	20010dd4 	.word	0x20010dd4
 801456c:	0802310c 	.word	0x0802310c

08014570 <rt_memheap_init>:
 */
rt_err_t rt_memheap_init(struct rt_memheap *memheap,
                         const char        *name,
                         void              *start_addr,
                         rt_uint32_t        size)
{
 8014570:	b580      	push	{r7, lr}
 8014572:	b086      	sub	sp, #24
 8014574:	af00      	add	r7, sp, #0
 8014576:	60f8      	str	r0, [r7, #12]
 8014578:	60b9      	str	r1, [r7, #8]
 801457a:	607a      	str	r2, [r7, #4]
 801457c:	603b      	str	r3, [r7, #0]
    struct rt_memheap_item *item;

    RT_ASSERT(memheap != RT_NULL);
 801457e:	68fb      	ldr	r3, [r7, #12]
 8014580:	2b00      	cmp	r3, #0
 8014582:	d104      	bne.n	801458e <rt_memheap_init+0x1e>
 8014584:	4847      	ldr	r0, [pc, #284]	; (80146a4 <rt_memheap_init+0x134>)
 8014586:	4948      	ldr	r1, [pc, #288]	; (80146a8 <rt_memheap_init+0x138>)
 8014588:	2243      	movs	r2, #67	; 0x43
 801458a:	f7ff fbeb 	bl	8013d64 <rt_assert_handler>

    /* initialize pool object */
    rt_object_init(&(memheap->parent), RT_Object_Class_MemHeap, name);
 801458e:	68fb      	ldr	r3, [r7, #12]
 8014590:	4618      	mov	r0, r3
 8014592:	2106      	movs	r1, #6
 8014594:	68ba      	ldr	r2, [r7, #8]
 8014596:	f000 f8c5 	bl	8014724 <rt_object_init>

    memheap->start_addr     = start_addr;
 801459a:	68fb      	ldr	r3, [r7, #12]
 801459c:	687a      	ldr	r2, [r7, #4]
 801459e:	615a      	str	r2, [r3, #20]
    memheap->pool_size      = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
 80145a0:	683b      	ldr	r3, [r7, #0]
 80145a2:	f023 0203 	bic.w	r2, r3, #3
 80145a6:	68fb      	ldr	r3, [r7, #12]
 80145a8:	619a      	str	r2, [r3, #24]
    memheap->available_size = memheap->pool_size - (2 * RT_MEMHEAP_SIZE);
 80145aa:	68fb      	ldr	r3, [r7, #12]
 80145ac:	699b      	ldr	r3, [r3, #24]
 80145ae:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80145b2:	68fb      	ldr	r3, [r7, #12]
 80145b4:	61da      	str	r2, [r3, #28]
    memheap->max_used_size  = memheap->pool_size - memheap->available_size;
 80145b6:	68fb      	ldr	r3, [r7, #12]
 80145b8:	699a      	ldr	r2, [r3, #24]
 80145ba:	68fb      	ldr	r3, [r7, #12]
 80145bc:	69db      	ldr	r3, [r3, #28]
 80145be:	1ad2      	subs	r2, r2, r3
 80145c0:	68fb      	ldr	r3, [r7, #12]
 80145c2:	621a      	str	r2, [r3, #32]

    /* initialize the free list header */
    item            = &(memheap->free_header);
 80145c4:	68fb      	ldr	r3, [r7, #12]
 80145c6:	332c      	adds	r3, #44	; 0x2c
 80145c8:	617b      	str	r3, [r7, #20]
    item->magic     = RT_MEMHEAP_MAGIC;
 80145ca:	697b      	ldr	r3, [r7, #20]
 80145cc:	4a37      	ldr	r2, [pc, #220]	; (80146ac <rt_memheap_init+0x13c>)
 80145ce:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 80145d0:	697b      	ldr	r3, [r7, #20]
 80145d2:	68fa      	ldr	r2, [r7, #12]
 80145d4:	605a      	str	r2, [r3, #4]
    item->next      = RT_NULL;
 80145d6:	697b      	ldr	r3, [r7, #20]
 80145d8:	2200      	movs	r2, #0
 80145da:	609a      	str	r2, [r3, #8]
    item->prev      = RT_NULL;
 80145dc:	697b      	ldr	r3, [r7, #20]
 80145de:	2200      	movs	r2, #0
 80145e0:	60da      	str	r2, [r3, #12]
    item->next_free = item;
 80145e2:	697b      	ldr	r3, [r7, #20]
 80145e4:	697a      	ldr	r2, [r7, #20]
 80145e6:	611a      	str	r2, [r3, #16]
    item->prev_free = item;
 80145e8:	697b      	ldr	r3, [r7, #20]
 80145ea:	697a      	ldr	r2, [r7, #20]
 80145ec:	615a      	str	r2, [r3, #20]

    /* set the free list to free list header */
    memheap->free_list = item;
 80145ee:	68fb      	ldr	r3, [r7, #12]
 80145f0:	697a      	ldr	r2, [r7, #20]
 80145f2:	629a      	str	r2, [r3, #40]	; 0x28

    /* initialize the first big memory block */
    item            = (struct rt_memheap_item *)start_addr;
 80145f4:	687b      	ldr	r3, [r7, #4]
 80145f6:	617b      	str	r3, [r7, #20]
    item->magic     = RT_MEMHEAP_MAGIC;
 80145f8:	697b      	ldr	r3, [r7, #20]
 80145fa:	4a2c      	ldr	r2, [pc, #176]	; (80146ac <rt_memheap_init+0x13c>)
 80145fc:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 80145fe:	697b      	ldr	r3, [r7, #20]
 8014600:	68fa      	ldr	r2, [r7, #12]
 8014602:	605a      	str	r2, [r3, #4]
    item->next      = RT_NULL;
 8014604:	697b      	ldr	r3, [r7, #20]
 8014606:	2200      	movs	r2, #0
 8014608:	609a      	str	r2, [r3, #8]
    item->prev      = RT_NULL;
 801460a:	697b      	ldr	r3, [r7, #20]
 801460c:	2200      	movs	r2, #0
 801460e:	60da      	str	r2, [r3, #12]
    item->next_free = item;
 8014610:	697b      	ldr	r3, [r7, #20]
 8014612:	697a      	ldr	r2, [r7, #20]
 8014614:	611a      	str	r2, [r3, #16]
    item->prev_free = item;
 8014616:	697b      	ldr	r3, [r7, #20]
 8014618:	697a      	ldr	r2, [r7, #20]
 801461a:	615a      	str	r2, [r3, #20]

    item->next = (struct rt_memheap_item *)
        ((rt_uint8_t *)item + memheap->available_size + RT_MEMHEAP_SIZE);
 801461c:	68fb      	ldr	r3, [r7, #12]
 801461e:	69db      	ldr	r3, [r3, #28]
 8014620:	3318      	adds	r3, #24
    item->next      = RT_NULL;
    item->prev      = RT_NULL;
    item->next_free = item;
    item->prev_free = item;

    item->next = (struct rt_memheap_item *)
 8014622:	697a      	ldr	r2, [r7, #20]
 8014624:	441a      	add	r2, r3
 8014626:	697b      	ldr	r3, [r7, #20]
 8014628:	609a      	str	r2, [r3, #8]
        ((rt_uint8_t *)item + memheap->available_size + RT_MEMHEAP_SIZE);
    item->prev = item->next;
 801462a:	697b      	ldr	r3, [r7, #20]
 801462c:	689a      	ldr	r2, [r3, #8]
 801462e:	697b      	ldr	r3, [r7, #20]
 8014630:	60da      	str	r2, [r3, #12]

    /* block list header */
    memheap->block_list = item;
 8014632:	68fb      	ldr	r3, [r7, #12]
 8014634:	697a      	ldr	r2, [r7, #20]
 8014636:	625a      	str	r2, [r3, #36]	; 0x24

    /* place the big memory block to free list */
    item->next_free = memheap->free_list->next_free;
 8014638:	68fb      	ldr	r3, [r7, #12]
 801463a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801463c:	691a      	ldr	r2, [r3, #16]
 801463e:	697b      	ldr	r3, [r7, #20]
 8014640:	611a      	str	r2, [r3, #16]
    item->prev_free = memheap->free_list;
 8014642:	68fb      	ldr	r3, [r7, #12]
 8014644:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8014646:	697b      	ldr	r3, [r7, #20]
 8014648:	615a      	str	r2, [r3, #20]
    memheap->free_list->next_free->prev_free = item;
 801464a:	68fb      	ldr	r3, [r7, #12]
 801464c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801464e:	691b      	ldr	r3, [r3, #16]
 8014650:	697a      	ldr	r2, [r7, #20]
 8014652:	615a      	str	r2, [r3, #20]
    memheap->free_list->next_free            = item;
 8014654:	68fb      	ldr	r3, [r7, #12]
 8014656:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014658:	697a      	ldr	r2, [r7, #20]
 801465a:	611a      	str	r2, [r3, #16]

    /* move to the end of memory pool to build a small tailer block,
     * which prevents block merging
     */
    item = item->next;
 801465c:	697b      	ldr	r3, [r7, #20]
 801465e:	689b      	ldr	r3, [r3, #8]
 8014660:	617b      	str	r3, [r7, #20]
    /* it's a used memory block */
    item->magic     = RT_MEMHEAP_MAGIC | RT_MEMHEAP_USED;
 8014662:	697b      	ldr	r3, [r7, #20]
 8014664:	4a12      	ldr	r2, [pc, #72]	; (80146b0 <rt_memheap_init+0x140>)
 8014666:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 8014668:	697b      	ldr	r3, [r7, #20]
 801466a:	68fa      	ldr	r2, [r7, #12]
 801466c:	605a      	str	r2, [r3, #4]
    item->next      = (struct rt_memheap_item *)start_addr;
 801466e:	697b      	ldr	r3, [r7, #20]
 8014670:	687a      	ldr	r2, [r7, #4]
 8014672:	609a      	str	r2, [r3, #8]
    item->prev      = (struct rt_memheap_item *)start_addr;
 8014674:	697b      	ldr	r3, [r7, #20]
 8014676:	687a      	ldr	r2, [r7, #4]
 8014678:	60da      	str	r2, [r3, #12]
    /* not in free list */
    item->next_free = item->prev_free = RT_NULL;
 801467a:	697b      	ldr	r3, [r7, #20]
 801467c:	2200      	movs	r2, #0
 801467e:	615a      	str	r2, [r3, #20]
 8014680:	697b      	ldr	r3, [r7, #20]
 8014682:	695a      	ldr	r2, [r3, #20]
 8014684:	697b      	ldr	r3, [r7, #20]
 8014686:	611a      	str	r2, [r3, #16]

    /* initialize semaphore lock */
    rt_sem_init(&(memheap->lock), name, 1, RT_IPC_FLAG_FIFO);
 8014688:	68fb      	ldr	r3, [r7, #12]
 801468a:	3344      	adds	r3, #68	; 0x44
 801468c:	4618      	mov	r0, r3
 801468e:	68b9      	ldr	r1, [r7, #8]
 8014690:	2201      	movs	r2, #1
 8014692:	2300      	movs	r3, #0
 8014694:	f7fd ff72 	bl	801257c <rt_sem_init>

    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,
                 ("memory heap: start addr 0x%08x, size %d, free list header 0x%08x\n",
                  start_addr, size, &(memheap->free_header)));

    return RT_EOK;
 8014698:	2300      	movs	r3, #0
}
 801469a:	4618      	mov	r0, r3
 801469c:	3718      	adds	r7, #24
 801469e:	46bd      	mov	sp, r7
 80146a0:	bd80      	pop	{r7, pc}
 80146a2:	bf00      	nop
 80146a4:	0802312c 	.word	0x0802312c
 80146a8:	08024edc 	.word	0x08024edc
 80146ac:	1ea01ea0 	.word	0x1ea01ea0
 80146b0:	1ea01ea1 	.word	0x1ea01ea1

080146b4 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 80146b4:	b480      	push	{r7}
 80146b6:	b083      	sub	sp, #12
 80146b8:	af00      	add	r7, sp, #0
 80146ba:	6078      	str	r0, [r7, #4]
 80146bc:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 80146be:	687b      	ldr	r3, [r7, #4]
 80146c0:	681b      	ldr	r3, [r3, #0]
 80146c2:	683a      	ldr	r2, [r7, #0]
 80146c4:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 80146c6:	687b      	ldr	r3, [r7, #4]
 80146c8:	681a      	ldr	r2, [r3, #0]
 80146ca:	683b      	ldr	r3, [r7, #0]
 80146cc:	601a      	str	r2, [r3, #0]

    l->next = n;
 80146ce:	687b      	ldr	r3, [r7, #4]
 80146d0:	683a      	ldr	r2, [r7, #0]
 80146d2:	601a      	str	r2, [r3, #0]
    n->prev = l;
 80146d4:	683b      	ldr	r3, [r7, #0]
 80146d6:	687a      	ldr	r2, [r7, #4]
 80146d8:	605a      	str	r2, [r3, #4]
}
 80146da:	370c      	adds	r7, #12
 80146dc:	46bd      	mov	sp, r7
 80146de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80146e2:	4770      	bx	lr

080146e4 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 80146e4:	b480      	push	{r7}
 80146e6:	b083      	sub	sp, #12
 80146e8:	af00      	add	r7, sp, #0
 80146ea:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 80146ec:	687b      	ldr	r3, [r7, #4]
 80146ee:	681b      	ldr	r3, [r3, #0]
 80146f0:	687a      	ldr	r2, [r7, #4]
 80146f2:	6852      	ldr	r2, [r2, #4]
 80146f4:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 80146f6:	687b      	ldr	r3, [r7, #4]
 80146f8:	685b      	ldr	r3, [r3, #4]
 80146fa:	687a      	ldr	r2, [r7, #4]
 80146fc:	6812      	ldr	r2, [r2, #0]
 80146fe:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8014700:	687b      	ldr	r3, [r7, #4]
 8014702:	687a      	ldr	r2, [r7, #4]
 8014704:	605a      	str	r2, [r3, #4]
 8014706:	687b      	ldr	r3, [r7, #4]
 8014708:	685a      	ldr	r2, [r3, #4]
 801470a:	687b      	ldr	r3, [r7, #4]
 801470c:	601a      	str	r2, [r3, #0]
}
 801470e:	370c      	adds	r7, #12
 8014710:	46bd      	mov	sp, r7
 8014712:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014716:	4770      	bx	lr

08014718 <rt_system_object_init>:
 *
 * @deprecated since 0.3.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_object_init(void)
{
 8014718:	b480      	push	{r7}
 801471a:	af00      	add	r7, sp, #0
}
 801471c:	46bd      	mov	sp, r7
 801471e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014722:	4770      	bx	lr

08014724 <rt_object_init>:
 * @param name the object name. In system, the object's name must be unique.
 */
void rt_object_init(struct rt_object         *object,
                    enum rt_object_class_type type,
                    const char               *name)
{
 8014724:	b590      	push	{r4, r7, lr}
 8014726:	b087      	sub	sp, #28
 8014728:	af00      	add	r7, sp, #0
 801472a:	60f8      	str	r0, [r7, #12]
 801472c:	460b      	mov	r3, r1
 801472e:	607a      	str	r2, [r7, #4]
 8014730:	72fb      	strb	r3, [r7, #11]
    /* get module object information */
    information = (rt_module_self() != RT_NULL) ?
        &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
 8014732:	7afb      	ldrb	r3, [r7, #11]
 8014734:	011b      	lsls	r3, r3, #4
 8014736:	4a14      	ldr	r2, [pc, #80]	; (8014788 <rt_object_init+0x64>)
 8014738:	4413      	add	r3, r2
 801473a:	617b      	str	r3, [r7, #20]
#endif

    /* initialize object's parameters */

    /* set object type to static */
    object->type = type | RT_Object_Class_Static;
 801473c:	7afb      	ldrb	r3, [r7, #11]
 801473e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8014742:	b2da      	uxtb	r2, r3
 8014744:	68fb      	ldr	r3, [r7, #12]
 8014746:	721a      	strb	r2, [r3, #8]

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
 8014748:	68fb      	ldr	r3, [r7, #12]
 801474a:	4618      	mov	r0, r3
 801474c:	6879      	ldr	r1, [r7, #4]
 801474e:	2208      	movs	r2, #8
 8014750:	f7fe fdde 	bl	8013310 <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
 8014754:	4b0d      	ldr	r3, [pc, #52]	; (801478c <rt_object_init+0x68>)
 8014756:	681b      	ldr	r3, [r3, #0]
 8014758:	2b00      	cmp	r3, #0
 801475a:	d003      	beq.n	8014764 <rt_object_init+0x40>
 801475c:	4b0b      	ldr	r3, [pc, #44]	; (801478c <rt_object_init+0x68>)
 801475e:	681b      	ldr	r3, [r3, #0]
 8014760:	68f8      	ldr	r0, [r7, #12]
 8014762:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 8014764:	f7eb fd30 	bl	80001c8 <rt_hw_interrupt_disable>
 8014768:	4604      	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
 801476a:	697b      	ldr	r3, [r7, #20]
 801476c:	1d1a      	adds	r2, r3, #4
 801476e:	68fb      	ldr	r3, [r7, #12]
 8014770:	330c      	adds	r3, #12
 8014772:	4610      	mov	r0, r2
 8014774:	4619      	mov	r1, r3
 8014776:	f7ff ff9d 	bl	80146b4 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 801477a:	4620      	mov	r0, r4
 801477c:	f7eb fd28 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8014780:	371c      	adds	r7, #28
 8014782:	46bd      	mov	sp, r7
 8014784:	bd90      	pop	{r4, r7, pc}
 8014786:	bf00      	nop
 8014788:	20010014 	.word	0x20010014
 801478c:	20010dd8 	.word	0x20010dd8

08014790 <rt_object_detach>:
 * and the memory of static object is not freed.
 *
 * @param object the specified object to be detached.
 */
void rt_object_detach(rt_object_t object)
{
 8014790:	b590      	push	{r4, r7, lr}
 8014792:	b083      	sub	sp, #12
 8014794:	af00      	add	r7, sp, #0
 8014796:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
 8014798:	687b      	ldr	r3, [r7, #4]
 801479a:	2b00      	cmp	r3, #0
 801479c:	d104      	bne.n	80147a8 <rt_object_detach+0x18>
 801479e:	480d      	ldr	r0, [pc, #52]	; (80147d4 <rt_object_detach+0x44>)
 80147a0:	490d      	ldr	r1, [pc, #52]	; (80147d8 <rt_object_detach+0x48>)
 80147a2:	22fb      	movs	r2, #251	; 0xfb
 80147a4:	f7ff fade 	bl	8013d64 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
 80147a8:	4b0c      	ldr	r3, [pc, #48]	; (80147dc <rt_object_detach+0x4c>)
 80147aa:	681b      	ldr	r3, [r3, #0]
 80147ac:	2b00      	cmp	r3, #0
 80147ae:	d003      	beq.n	80147b8 <rt_object_detach+0x28>
 80147b0:	4b0a      	ldr	r3, [pc, #40]	; (80147dc <rt_object_detach+0x4c>)
 80147b2:	681b      	ldr	r3, [r3, #0]
 80147b4:	6878      	ldr	r0, [r7, #4]
 80147b6:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 80147b8:	f7eb fd06 	bl	80001c8 <rt_hw_interrupt_disable>
 80147bc:	4604      	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
 80147be:	687b      	ldr	r3, [r7, #4]
 80147c0:	330c      	adds	r3, #12
 80147c2:	4618      	mov	r0, r3
 80147c4:	f7ff ff8e 	bl	80146e4 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 80147c8:	4620      	mov	r0, r4
 80147ca:	f7eb fd01 	bl	80001d0 <rt_hw_interrupt_enable>
}
 80147ce:	370c      	adds	r7, #12
 80147d0:	46bd      	mov	sp, r7
 80147d2:	bd90      	pop	{r4, r7, pc}
 80147d4:	08023220 	.word	0x08023220
 80147d8:	08024eec 	.word	0x08024eec
 80147dc:	20010ddc 	.word	0x20010ddc

080147e0 <rt_object_allocate>:
 * @param name the object name. In system, the object's name must be unique.
 *
 * @return object
 */
rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
{
 80147e0:	b590      	push	{r4, r7, lr}
 80147e2:	b087      	sub	sp, #28
 80147e4:	af00      	add	r7, sp, #0
 80147e6:	4603      	mov	r3, r0
 80147e8:	6039      	str	r1, [r7, #0]
 80147ea:	71fb      	strb	r3, [r7, #7]
    struct rt_object *object;
    register rt_base_t temp;
    struct rt_object_information *information;

    RT_DEBUG_NOT_IN_INTERRUPT;
 80147ec:	f7eb fcec 	bl	80001c8 <rt_hw_interrupt_disable>
 80147f0:	6178      	str	r0, [r7, #20]
 80147f2:	f7fe fc59 	bl	80130a8 <rt_interrupt_get_nest>
 80147f6:	4603      	mov	r3, r0
 80147f8:	2b00      	cmp	r3, #0
 80147fa:	d009      	beq.n	8014810 <rt_object_allocate+0x30>
 80147fc:	4821      	ldr	r0, [pc, #132]	; (8014884 <rt_object_allocate+0xa4>)
 80147fe:	4922      	ldr	r1, [pc, #136]	; (8014888 <rt_object_allocate+0xa8>)
 8014800:	f7ff fa36 	bl	8013c70 <rt_kprintf>
 8014804:	4821      	ldr	r0, [pc, #132]	; (801488c <rt_object_allocate+0xac>)
 8014806:	4920      	ldr	r1, [pc, #128]	; (8014888 <rt_object_allocate+0xa8>)
 8014808:	f44f 728c 	mov.w	r2, #280	; 0x118
 801480c:	f7ff faaa 	bl	8013d64 <rt_assert_handler>
 8014810:	6978      	ldr	r0, [r7, #20]
 8014812:	f7eb fcdd 	bl	80001d0 <rt_hw_interrupt_enable>
     */
    information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
                  &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
 8014816:	79fb      	ldrb	r3, [r7, #7]
 8014818:	011b      	lsls	r3, r3, #4
 801481a:	4a1d      	ldr	r2, [pc, #116]	; (8014890 <rt_object_allocate+0xb0>)
 801481c:	4413      	add	r3, r2
 801481e:	613b      	str	r3, [r7, #16]
#endif

    object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
 8014820:	693b      	ldr	r3, [r7, #16]
 8014822:	68db      	ldr	r3, [r3, #12]
 8014824:	4618      	mov	r0, r3
 8014826:	f7ff fbd1 	bl	8013fcc <rt_malloc>
 801482a:	60f8      	str	r0, [r7, #12]
    if (object == RT_NULL)
 801482c:	68fb      	ldr	r3, [r7, #12]
 801482e:	2b00      	cmp	r3, #0
 8014830:	d101      	bne.n	8014836 <rt_object_allocate+0x56>
    {
        /* no memory can be allocated */
        return RT_NULL;
 8014832:	2300      	movs	r3, #0
 8014834:	e022      	b.n	801487c <rt_object_allocate+0x9c>
    }

    /* initialize object's parameters */

    /* set object type */
    object->type = type;
 8014836:	68fb      	ldr	r3, [r7, #12]
 8014838:	79fa      	ldrb	r2, [r7, #7]
 801483a:	721a      	strb	r2, [r3, #8]

    /* set object flag */
    object->flag = 0;
 801483c:	68fb      	ldr	r3, [r7, #12]
 801483e:	2200      	movs	r2, #0
 8014840:	725a      	strb	r2, [r3, #9]
    }
    object->module_id = (void *)rt_module_self();
#endif

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
 8014842:	68fb      	ldr	r3, [r7, #12]
 8014844:	4618      	mov	r0, r3
 8014846:	6839      	ldr	r1, [r7, #0]
 8014848:	2208      	movs	r2, #8
 801484a:	f7fe fd61 	bl	8013310 <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
 801484e:	4b11      	ldr	r3, [pc, #68]	; (8014894 <rt_object_allocate+0xb4>)
 8014850:	681b      	ldr	r3, [r3, #0]
 8014852:	2b00      	cmp	r3, #0
 8014854:	d003      	beq.n	801485e <rt_object_allocate+0x7e>
 8014856:	4b0f      	ldr	r3, [pc, #60]	; (8014894 <rt_object_allocate+0xb4>)
 8014858:	681b      	ldr	r3, [r3, #0]
 801485a:	68f8      	ldr	r0, [r7, #12]
 801485c:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 801485e:	f7eb fcb3 	bl	80001c8 <rt_hw_interrupt_disable>
 8014862:	4604      	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
 8014864:	693b      	ldr	r3, [r7, #16]
 8014866:	1d1a      	adds	r2, r3, #4
 8014868:	68fb      	ldr	r3, [r7, #12]
 801486a:	330c      	adds	r3, #12
 801486c:	4610      	mov	r0, r2
 801486e:	4619      	mov	r1, r3
 8014870:	f7ff ff20 	bl	80146b4 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 8014874:	4620      	mov	r0, r4
 8014876:	f7eb fcab 	bl	80001d0 <rt_hw_interrupt_enable>

    /* return object */
    return object;
 801487a:	68fb      	ldr	r3, [r7, #12]
}
 801487c:	4618      	mov	r0, r3
 801487e:	371c      	adds	r7, #28
 8014880:	46bd      	mov	sp, r7
 8014882:	bd90      	pop	{r4, r7, pc}
 8014884:	08023234 	.word	0x08023234
 8014888:	08024f00 	.word	0x08024f00
 801488c:	08023258 	.word	0x08023258
 8014890:	20010014 	.word	0x20010014
 8014894:	20010dd8 	.word	0x20010dd8

08014898 <rt_object_delete>:
 * This function will delete an object and release object memory.
 *
 * @param object the specified object to be deleted.
 */
void rt_object_delete(rt_object_t object)
{
 8014898:	b590      	push	{r4, r7, lr}
 801489a:	b083      	sub	sp, #12
 801489c:	af00      	add	r7, sp, #0
 801489e:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
 80148a0:	687b      	ldr	r3, [r7, #4]
 80148a2:	2b00      	cmp	r3, #0
 80148a4:	d105      	bne.n	80148b2 <rt_object_delete+0x1a>
 80148a6:	4815      	ldr	r0, [pc, #84]	; (80148fc <rt_object_delete+0x64>)
 80148a8:	4915      	ldr	r1, [pc, #84]	; (8014900 <rt_object_delete+0x68>)
 80148aa:	f240 1259 	movw	r2, #345	; 0x159
 80148ae:	f7ff fa59 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(!(object->type & RT_Object_Class_Static));
 80148b2:	687b      	ldr	r3, [r7, #4]
 80148b4:	7a1b      	ldrb	r3, [r3, #8]
 80148b6:	b2db      	uxtb	r3, r3
 80148b8:	b25b      	sxtb	r3, r3
 80148ba:	2b00      	cmp	r3, #0
 80148bc:	da05      	bge.n	80148ca <rt_object_delete+0x32>
 80148be:	4811      	ldr	r0, [pc, #68]	; (8014904 <rt_object_delete+0x6c>)
 80148c0:	490f      	ldr	r1, [pc, #60]	; (8014900 <rt_object_delete+0x68>)
 80148c2:	f44f 72ad 	mov.w	r2, #346	; 0x15a
 80148c6:	f7ff fa4d 	bl	8013d64 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
 80148ca:	4b0f      	ldr	r3, [pc, #60]	; (8014908 <rt_object_delete+0x70>)
 80148cc:	681b      	ldr	r3, [r3, #0]
 80148ce:	2b00      	cmp	r3, #0
 80148d0:	d003      	beq.n	80148da <rt_object_delete+0x42>
 80148d2:	4b0d      	ldr	r3, [pc, #52]	; (8014908 <rt_object_delete+0x70>)
 80148d4:	681b      	ldr	r3, [r3, #0]
 80148d6:	6878      	ldr	r0, [r7, #4]
 80148d8:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 80148da:	f7eb fc75 	bl	80001c8 <rt_hw_interrupt_disable>
 80148de:	4604      	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
 80148e0:	687b      	ldr	r3, [r7, #4]
 80148e2:	330c      	adds	r3, #12
 80148e4:	4618      	mov	r0, r3
 80148e6:	f7ff fefd 	bl	80146e4 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 80148ea:	4620      	mov	r0, r4
 80148ec:	f7eb fc70 	bl	80001d0 <rt_hw_interrupt_enable>
        rt_module_free((rt_module_t)object->module_id, object);
    else
#endif

    /* free the memory of object */
    RT_KERNEL_FREE(object);
 80148f0:	6878      	ldr	r0, [r7, #4]
 80148f2:	f7ff fd75 	bl	80143e0 <rt_free>
}
 80148f6:	370c      	adds	r7, #12
 80148f8:	46bd      	mov	sp, r7
 80148fa:	bd90      	pop	{r4, r7, pc}
 80148fc:	08023220 	.word	0x08023220
 8014900:	08024f14 	.word	0x08024f14
 8014904:	0802325c 	.word	0x0802325c
 8014908:	20010ddc 	.word	0x20010ddc

0801490c <rt_object_is_systemobject>:
 * @param object the specified object to be judged.
 *
 * @return RT_TRUE if a system object, RT_FALSE for others.
 */
rt_bool_t rt_object_is_systemobject(rt_object_t object)
{
 801490c:	b580      	push	{r7, lr}
 801490e:	b082      	sub	sp, #8
 8014910:	af00      	add	r7, sp, #0
 8014912:	6078      	str	r0, [r7, #4]
    /* object check */
    RT_ASSERT(object != RT_NULL);
 8014914:	687b      	ldr	r3, [r7, #4]
 8014916:	2b00      	cmp	r3, #0
 8014918:	d105      	bne.n	8014926 <rt_object_is_systemobject+0x1a>
 801491a:	4809      	ldr	r0, [pc, #36]	; (8014940 <rt_object_is_systemobject+0x34>)
 801491c:	4909      	ldr	r1, [pc, #36]	; (8014944 <rt_object_is_systemobject+0x38>)
 801491e:	f44f 72bf 	mov.w	r2, #382	; 0x17e
 8014922:	f7ff fa1f 	bl	8013d64 <rt_assert_handler>

    if (object->type & RT_Object_Class_Static)
 8014926:	687b      	ldr	r3, [r7, #4]
 8014928:	7a1b      	ldrb	r3, [r3, #8]
 801492a:	b2db      	uxtb	r3, r3
 801492c:	b25b      	sxtb	r3, r3
 801492e:	2b00      	cmp	r3, #0
 8014930:	da01      	bge.n	8014936 <rt_object_is_systemobject+0x2a>
        return RT_TRUE;
 8014932:	2301      	movs	r3, #1
 8014934:	e000      	b.n	8014938 <rt_object_is_systemobject+0x2c>

    return RT_FALSE;
 8014936:	2300      	movs	r3, #0
}
 8014938:	4618      	mov	r0, r3
 801493a:	3708      	adds	r7, #8
 801493c:	46bd      	mov	sp, r7
 801493e:	bd80      	pop	{r7, pc}
 8014940:	08023220 	.word	0x08023220
 8014944:	08024f28 	.word	0x08024f28

08014948 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8014948:	b480      	push	{r7}
 801494a:	b083      	sub	sp, #12
 801494c:	af00      	add	r7, sp, #0
 801494e:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8014950:	687b      	ldr	r3, [r7, #4]
 8014952:	687a      	ldr	r2, [r7, #4]
 8014954:	605a      	str	r2, [r3, #4]
 8014956:	687b      	ldr	r3, [r7, #4]
 8014958:	685a      	ldr	r2, [r3, #4]
 801495a:	687b      	ldr	r3, [r7, #4]
 801495c:	601a      	str	r2, [r3, #0]
}
 801495e:	370c      	adds	r7, #12
 8014960:	46bd      	mov	sp, r7
 8014962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014966:	4770      	bx	lr

08014968 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8014968:	b480      	push	{r7}
 801496a:	b083      	sub	sp, #12
 801496c:	af00      	add	r7, sp, #0
 801496e:	6078      	str	r0, [r7, #4]
 8014970:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 8014972:	687b      	ldr	r3, [r7, #4]
 8014974:	685b      	ldr	r3, [r3, #4]
 8014976:	683a      	ldr	r2, [r7, #0]
 8014978:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 801497a:	687b      	ldr	r3, [r7, #4]
 801497c:	685a      	ldr	r2, [r3, #4]
 801497e:	683b      	ldr	r3, [r7, #0]
 8014980:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8014982:	687b      	ldr	r3, [r7, #4]
 8014984:	683a      	ldr	r2, [r7, #0]
 8014986:	605a      	str	r2, [r3, #4]
    n->next = l;
 8014988:	683b      	ldr	r3, [r7, #0]
 801498a:	687a      	ldr	r2, [r7, #4]
 801498c:	601a      	str	r2, [r3, #0]
}
 801498e:	370c      	adds	r7, #12
 8014990:	46bd      	mov	sp, r7
 8014992:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014996:	4770      	bx	lr

08014998 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8014998:	b480      	push	{r7}
 801499a:	b083      	sub	sp, #12
 801499c:	af00      	add	r7, sp, #0
 801499e:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 80149a0:	687b      	ldr	r3, [r7, #4]
 80149a2:	681b      	ldr	r3, [r3, #0]
 80149a4:	687a      	ldr	r2, [r7, #4]
 80149a6:	6852      	ldr	r2, [r2, #4]
 80149a8:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 80149aa:	687b      	ldr	r3, [r7, #4]
 80149ac:	685b      	ldr	r3, [r3, #4]
 80149ae:	687a      	ldr	r2, [r7, #4]
 80149b0:	6812      	ldr	r2, [r2, #0]
 80149b2:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 80149b4:	687b      	ldr	r3, [r7, #4]
 80149b6:	687a      	ldr	r2, [r7, #4]
 80149b8:	605a      	str	r2, [r3, #4]
 80149ba:	687b      	ldr	r3, [r7, #4]
 80149bc:	685a      	ldr	r2, [r3, #4]
 80149be:	687b      	ldr	r3, [r7, #4]
 80149c0:	601a      	str	r2, [r3, #0]
}
 80149c2:	370c      	adds	r7, #12
 80149c4:	46bd      	mov	sp, r7
 80149c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80149ca:	4770      	bx	lr

080149cc <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 80149cc:	b480      	push	{r7}
 80149ce:	b083      	sub	sp, #12
 80149d0:	af00      	add	r7, sp, #0
 80149d2:	6078      	str	r0, [r7, #4]
    return l->next == l;
 80149d4:	687b      	ldr	r3, [r7, #4]
 80149d6:	681a      	ldr	r2, [r3, #0]
 80149d8:	687b      	ldr	r3, [r7, #4]
 80149da:	429a      	cmp	r2, r3
 80149dc:	bf0c      	ite	eq
 80149de:	2301      	moveq	r3, #1
 80149e0:	2300      	movne	r3, #0
 80149e2:	b2db      	uxtb	r3, r3
}
 80149e4:	4618      	mov	r0, r3
 80149e6:	370c      	adds	r7, #12
 80149e8:	46bd      	mov	sp, r7
 80149ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80149ee:	4770      	bx	lr

080149f0 <_rt_scheduler_stack_check>:
/*@}*/
#endif

#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
 80149f0:	b580      	push	{r7, lr}
 80149f2:	b084      	sub	sp, #16
 80149f4:	af00      	add	r7, sp, #0
 80149f6:	6078      	str	r0, [r7, #4]
    RT_ASSERT(thread != RT_NULL);
 80149f8:	687b      	ldr	r3, [r7, #4]
 80149fa:	2b00      	cmp	r3, #0
 80149fc:	d104      	bne.n	8014a08 <_rt_scheduler_stack_check+0x18>
 80149fe:	481b      	ldr	r0, [pc, #108]	; (8014a6c <_rt_scheduler_stack_check+0x7c>)
 8014a00:	491b      	ldr	r1, [pc, #108]	; (8014a70 <_rt_scheduler_stack_check+0x80>)
 8014a02:	225a      	movs	r2, #90	; 0x5a
 8014a04:	f7ff f9ae 	bl	8013d64 <rt_assert_handler>

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
 8014a08:	687b      	ldr	r3, [r7, #4]
 8014a0a:	69db      	ldr	r3, [r3, #28]
 8014a0c:	461a      	mov	r2, r3
 8014a0e:	687b      	ldr	r3, [r7, #4]
 8014a10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014a12:	429a      	cmp	r2, r3
 8014a14:	d90a      	bls.n	8014a2c <_rt_scheduler_stack_check+0x3c>
        (rt_uint32_t)thread->sp >
 8014a16:	687b      	ldr	r3, [r7, #4]
 8014a18:	69db      	ldr	r3, [r3, #28]
 8014a1a:	461a      	mov	r2, r3
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
 8014a1c:	687b      	ldr	r3, [r7, #4]
 8014a1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014a20:	4619      	mov	r1, r3
 8014a22:	687b      	ldr	r3, [r7, #4]
 8014a24:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8014a26:	440b      	add	r3, r1
#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
 8014a28:	429a      	cmp	r2, r3
 8014a2a:	d90e      	bls.n	8014a4a <_rt_scheduler_stack_check+0x5a>
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
        rt_uint32_t level;

        rt_kprintf("thread:%s stack overflow\n", thread->name);
 8014a2c:	687b      	ldr	r3, [r7, #4]
 8014a2e:	4811      	ldr	r0, [pc, #68]	; (8014a74 <_rt_scheduler_stack_check+0x84>)
 8014a30:	4619      	mov	r1, r3
 8014a32:	f7ff f91d 	bl	8013c70 <rt_kprintf>
        #ifdef RT_USING_FINSH
        {
            extern long list_thread(void);
            list_thread();
 8014a36:	f004 fc8b 	bl	8019350 <list_thread>
        }
        #endif
        level = rt_hw_interrupt_disable();
 8014a3a:	f7eb fbc5 	bl	80001c8 <rt_hw_interrupt_disable>
 8014a3e:	4603      	mov	r3, r0
 8014a40:	60fb      	str	r3, [r7, #12]
        while (level);
 8014a42:	68fb      	ldr	r3, [r7, #12]
 8014a44:	2b00      	cmp	r3, #0
 8014a46:	d1fc      	bne.n	8014a42 <_rt_scheduler_stack_check+0x52>
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
 8014a48:	e00c      	b.n	8014a64 <_rt_scheduler_stack_check+0x74>
        }
        #endif
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
 8014a4a:	687b      	ldr	r3, [r7, #4]
 8014a4c:	69db      	ldr	r3, [r3, #28]
 8014a4e:	461a      	mov	r2, r3
 8014a50:	687b      	ldr	r3, [r7, #4]
 8014a52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014a54:	3320      	adds	r3, #32
 8014a56:	429a      	cmp	r2, r3
 8014a58:	d804      	bhi.n	8014a64 <_rt_scheduler_stack_check+0x74>
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
                   thread->name);
 8014a5a:	687b      	ldr	r3, [r7, #4]
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
 8014a5c:	4806      	ldr	r0, [pc, #24]	; (8014a78 <_rt_scheduler_stack_check+0x88>)
 8014a5e:	4619      	mov	r1, r3
 8014a60:	f7ff f906 	bl	8013c70 <rt_kprintf>
                   thread->name);
    }
}
 8014a64:	3710      	adds	r7, #16
 8014a66:	46bd      	mov	sp, r7
 8014a68:	bd80      	pop	{r7, pc}
 8014a6a:	bf00      	nop
 8014a6c:	08023288 	.word	0x08023288
 8014a70:	08024f44 	.word	0x08024f44
 8014a74:	0802329c 	.word	0x0802329c
 8014a78:	080232b8 	.word	0x080232b8

08014a7c <rt_system_scheduler_init>:
/**
 * @ingroup SystemInit
 * This function will initialize the system scheduler
 */
void rt_system_scheduler_init(void)
{
 8014a7c:	b598      	push	{r3, r4, r7, lr}
 8014a7e:	af00      	add	r7, sp, #0
    register rt_base_t offset;

    rt_scheduler_lock_nest = 0;
 8014a80:	4b0d      	ldr	r3, [pc, #52]	; (8014ab8 <rt_system_scheduler_init+0x3c>)
 8014a82:	2200      	movs	r2, #0
 8014a84:	801a      	strh	r2, [r3, #0]

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
 8014a86:	2400      	movs	r4, #0
 8014a88:	e006      	b.n	8014a98 <rt_system_scheduler_init+0x1c>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
 8014a8a:	00e3      	lsls	r3, r4, #3
 8014a8c:	4a0b      	ldr	r2, [pc, #44]	; (8014abc <rt_system_scheduler_init+0x40>)
 8014a8e:	4413      	add	r3, r2
 8014a90:	4618      	mov	r0, r3
 8014a92:	f7ff ff59 	bl	8014948 <rt_list_init>
    rt_scheduler_lock_nest = 0;

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
 8014a96:	3401      	adds	r4, #1
 8014a98:	2c1f      	cmp	r4, #31
 8014a9a:	ddf6      	ble.n	8014a8a <rt_system_scheduler_init+0xe>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
    }

    rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
 8014a9c:	4b08      	ldr	r3, [pc, #32]	; (8014ac0 <rt_system_scheduler_init+0x44>)
 8014a9e:	221f      	movs	r2, #31
 8014aa0:	701a      	strb	r2, [r3, #0]
    rt_current_thread = RT_NULL;
 8014aa2:	4b08      	ldr	r3, [pc, #32]	; (8014ac4 <rt_system_scheduler_init+0x48>)
 8014aa4:	2200      	movs	r2, #0
 8014aa6:	601a      	str	r2, [r3, #0]

    /* initialize ready priority group */
    rt_thread_ready_priority_group = 0;
 8014aa8:	4b07      	ldr	r3, [pc, #28]	; (8014ac8 <rt_system_scheduler_init+0x4c>)
 8014aaa:	2200      	movs	r2, #0
 8014aac:	601a      	str	r2, [r3, #0]
    /* initialize ready table */
    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
#endif

    /* initialize thread defunct */
    rt_list_init(&rt_thread_defunct);
 8014aae:	4807      	ldr	r0, [pc, #28]	; (8014acc <rt_system_scheduler_init+0x50>)
 8014ab0:	f7ff ff4a 	bl	8014948 <rt_list_init>
}
 8014ab4:	bd98      	pop	{r3, r4, r7, pc}
 8014ab6:	bf00      	nop
 8014ab8:	20010de0 	.word	0x20010de0
 8014abc:	20012578 	.word	0x20012578
 8014ac0:	20012678 	.word	0x20012678
 8014ac4:	2001267c 	.word	0x2001267c
 8014ac8:	20012680 	.word	0x20012680
 8014acc:	20012684 	.word	0x20012684

08014ad0 <rt_system_scheduler_start>:
 * @ingroup SystemInit
 * This function will startup scheduler. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_system_scheduler_start(void)
{
 8014ad0:	b598      	push	{r3, r4, r7, lr}
 8014ad2:	af00      	add	r7, sp, #0
    register rt_ubase_t number;

    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#else
    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 8014ad4:	4b0a      	ldr	r3, [pc, #40]	; (8014b00 <rt_system_scheduler_start+0x30>)
 8014ad6:	681b      	ldr	r3, [r3, #0]
 8014ad8:	4618      	mov	r0, r3
 8014ada:	f7ff f909 	bl	8013cf0 <__rt_ffs>
 8014ade:	4603      	mov	r3, r0
 8014ae0:	3b01      	subs	r3, #1
 8014ae2:	461c      	mov	r4, r3
#endif

    /* get switch to thread */
    to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
 8014ae4:	4b07      	ldr	r3, [pc, #28]	; (8014b04 <rt_system_scheduler_start+0x34>)
 8014ae6:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 8014aea:	f1a3 0414 	sub.w	r4, r3, #20
                              struct rt_thread,
                              tlist);

    rt_current_thread = to_thread;
 8014aee:	4b06      	ldr	r3, [pc, #24]	; (8014b08 <rt_system_scheduler_start+0x38>)
 8014af0:	601c      	str	r4, [r3, #0]

    /* switch to new thread */
    rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
 8014af2:	f104 031c 	add.w	r3, r4, #28
 8014af6:	4618      	mov	r0, r3
 8014af8:	f7eb fbb2 	bl	8000260 <rt_hw_context_switch_to>

    /* never come back */
}
 8014afc:	bd98      	pop	{r3, r4, r7, pc}
 8014afe:	bf00      	nop
 8014b00:	20012680 	.word	0x20012680
 8014b04:	20012578 	.word	0x20012578
 8014b08:	2001267c 	.word	0x2001267c

08014b0c <rt_schedule>:
/**
 * This function will perform one schedule. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_schedule(void)
{
 8014b0c:	b590      	push	{r4, r7, lr}
 8014b0e:	b085      	sub	sp, #20
 8014b10:	af00      	add	r7, sp, #0
    rt_base_t level;
    struct rt_thread *to_thread;
    struct rt_thread *from_thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8014b12:	f7eb fb59 	bl	80001c8 <rt_hw_interrupt_disable>
 8014b16:	60f8      	str	r0, [r7, #12]

    /* check the scheduler is enabled or not */
    if (rt_scheduler_lock_nest == 0)
 8014b18:	4b24      	ldr	r3, [pc, #144]	; (8014bac <rt_schedule+0xa0>)
 8014b1a:	881b      	ldrh	r3, [r3, #0]
 8014b1c:	2b00      	cmp	r3, #0
 8014b1e:	d13e      	bne.n	8014b9e <rt_schedule+0x92>
    {
        register rt_ubase_t highest_ready_priority;

#if RT_THREAD_PRIORITY_MAX <= 32
        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 8014b20:	4b23      	ldr	r3, [pc, #140]	; (8014bb0 <rt_schedule+0xa4>)
 8014b22:	681b      	ldr	r3, [r3, #0]
 8014b24:	4618      	mov	r0, r3
 8014b26:	f7ff f8e3 	bl	8013cf0 <__rt_ffs>
 8014b2a:	4603      	mov	r3, r0
 8014b2c:	3b01      	subs	r3, #1
 8014b2e:	461c      	mov	r4, r3
        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#endif

        /* get switch to thread */
        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
 8014b30:	4b20      	ldr	r3, [pc, #128]	; (8014bb4 <rt_schedule+0xa8>)
 8014b32:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 8014b36:	3b14      	subs	r3, #20
 8014b38:	60bb      	str	r3, [r7, #8]
                                  struct rt_thread,
                                  tlist);

        /* if the destination thread is not the same as current thread */
        if (to_thread != rt_current_thread)
 8014b3a:	4b1f      	ldr	r3, [pc, #124]	; (8014bb8 <rt_schedule+0xac>)
 8014b3c:	681b      	ldr	r3, [r3, #0]
 8014b3e:	68ba      	ldr	r2, [r7, #8]
 8014b40:	429a      	cmp	r2, r3
 8014b42:	d02c      	beq.n	8014b9e <rt_schedule+0x92>
        {
            rt_current_priority = (rt_uint8_t)highest_ready_priority;
 8014b44:	b2e2      	uxtb	r2, r4
 8014b46:	4b1d      	ldr	r3, [pc, #116]	; (8014bbc <rt_schedule+0xb0>)
 8014b48:	701a      	strb	r2, [r3, #0]
            from_thread         = rt_current_thread;
 8014b4a:	4b1b      	ldr	r3, [pc, #108]	; (8014bb8 <rt_schedule+0xac>)
 8014b4c:	681b      	ldr	r3, [r3, #0]
 8014b4e:	607b      	str	r3, [r7, #4]
            rt_current_thread   = to_thread;
 8014b50:	4a19      	ldr	r2, [pc, #100]	; (8014bb8 <rt_schedule+0xac>)
 8014b52:	68bb      	ldr	r3, [r7, #8]
 8014b54:	6013      	str	r3, [r2, #0]

            RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
 8014b56:	4b1a      	ldr	r3, [pc, #104]	; (8014bc0 <rt_schedule+0xb4>)
 8014b58:	681b      	ldr	r3, [r3, #0]
 8014b5a:	2b00      	cmp	r3, #0
 8014b5c:	d004      	beq.n	8014b68 <rt_schedule+0x5c>
 8014b5e:	4b18      	ldr	r3, [pc, #96]	; (8014bc0 <rt_schedule+0xb4>)
 8014b60:	681b      	ldr	r3, [r3, #0]
 8014b62:	6878      	ldr	r0, [r7, #4]
 8014b64:	68b9      	ldr	r1, [r7, #8]
 8014b66:	4798      	blx	r3
                          rt_interrupt_nest, highest_ready_priority,
                          RT_NAME_MAX, to_thread->name, to_thread->sp,
                          RT_NAME_MAX, from_thread->name, from_thread->sp));

#ifdef RT_USING_OVERFLOW_CHECK
            _rt_scheduler_stack_check(to_thread);
 8014b68:	68b8      	ldr	r0, [r7, #8]
 8014b6a:	f7ff ff41 	bl	80149f0 <_rt_scheduler_stack_check>
#endif

            if (rt_interrupt_nest == 0)
 8014b6e:	4b15      	ldr	r3, [pc, #84]	; (8014bc4 <rt_schedule+0xb8>)
 8014b70:	781b      	ldrb	r3, [r3, #0]
 8014b72:	b2db      	uxtb	r3, r3
 8014b74:	2b00      	cmp	r3, #0
 8014b76:	d109      	bne.n	8014b8c <rt_schedule+0x80>
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
 8014b78:	687b      	ldr	r3, [r7, #4]
 8014b7a:	331c      	adds	r3, #28
 8014b7c:	461a      	mov	r2, r3
                                     (rt_uint32_t)&to_thread->sp);
 8014b7e:	68bb      	ldr	r3, [r7, #8]
 8014b80:	331c      	adds	r3, #28
            _rt_scheduler_stack_check(to_thread);
#endif

            if (rt_interrupt_nest == 0)
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
 8014b82:	4610      	mov	r0, r2
 8014b84:	4619      	mov	r1, r3
 8014b86:	f7eb fb26 	bl	80001d6 <rt_hw_context_switch>
 8014b8a:	e008      	b.n	8014b9e <rt_schedule+0x92>
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
 8014b8c:	687b      	ldr	r3, [r7, #4]
 8014b8e:	331c      	adds	r3, #28
 8014b90:	461a      	mov	r2, r3
                                               (rt_uint32_t)&to_thread->sp);
 8014b92:	68bb      	ldr	r3, [r7, #8]
 8014b94:	331c      	adds	r3, #28
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
 8014b96:	4610      	mov	r0, r2
 8014b98:	4619      	mov	r1, r3
 8014b9a:	f7eb fb1c 	bl	80001d6 <rt_hw_context_switch>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8014b9e:	68f8      	ldr	r0, [r7, #12]
 8014ba0:	f7eb fb16 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8014ba4:	3714      	adds	r7, #20
 8014ba6:	46bd      	mov	sp, r7
 8014ba8:	bd90      	pop	{r4, r7, pc}
 8014baa:	bf00      	nop
 8014bac:	20010de0 	.word	0x20010de0
 8014bb0:	20012680 	.word	0x20012680
 8014bb4:	20012578 	.word	0x20012578
 8014bb8:	2001267c 	.word	0x2001267c
 8014bbc:	20012678 	.word	0x20012678
 8014bc0:	20010de4 	.word	0x20010de4
 8014bc4:	20012564 	.word	0x20012564

08014bc8 <rt_schedule_insert_thread>:
 *
 * @param thread the thread to be inserted
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_insert_thread(struct rt_thread *thread)
{
 8014bc8:	b590      	push	{r4, r7, lr}
 8014bca:	b083      	sub	sp, #12
 8014bcc:	af00      	add	r7, sp, #0
 8014bce:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
 8014bd0:	687b      	ldr	r3, [r7, #4]
 8014bd2:	2b00      	cmp	r3, #0
 8014bd4:	d105      	bne.n	8014be2 <rt_schedule_insert_thread+0x1a>
 8014bd6:	4813      	ldr	r0, [pc, #76]	; (8014c24 <rt_schedule_insert_thread+0x5c>)
 8014bd8:	4913      	ldr	r1, [pc, #76]	; (8014c28 <rt_schedule_insert_thread+0x60>)
 8014bda:	f240 120f 	movw	r2, #271	; 0x10f
 8014bde:	f7ff f8c1 	bl	8013d64 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8014be2:	f7eb faf1 	bl	80001c8 <rt_hw_interrupt_disable>
 8014be6:	4604      	mov	r4, r0

    /* change stat */
    thread->stat = RT_THREAD_READY;
 8014be8:	687b      	ldr	r3, [r7, #4]
 8014bea:	2201      	movs	r2, #1
 8014bec:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* insert thread to ready list */
    rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
 8014bf0:	687b      	ldr	r3, [r7, #4]
 8014bf2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8014bf6:	00db      	lsls	r3, r3, #3
 8014bf8:	4a0c      	ldr	r2, [pc, #48]	; (8014c2c <rt_schedule_insert_thread+0x64>)
 8014bfa:	441a      	add	r2, r3
 8014bfc:	687b      	ldr	r3, [r7, #4]
 8014bfe:	3314      	adds	r3, #20
 8014c00:	4610      	mov	r0, r2
 8014c02:	4619      	mov	r1, r3
 8014c04:	f7ff feb0 	bl	8014968 <rt_list_insert_before>
#endif

#if RT_THREAD_PRIORITY_MAX > 32
    rt_thread_ready_table[thread->number] |= thread->high_mask;
#endif
    rt_thread_ready_priority_group |= thread->number_mask;
 8014c08:	687b      	ldr	r3, [r7, #4]
 8014c0a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014c0c:	4b08      	ldr	r3, [pc, #32]	; (8014c30 <rt_schedule_insert_thread+0x68>)
 8014c0e:	681b      	ldr	r3, [r3, #0]
 8014c10:	4313      	orrs	r3, r2
 8014c12:	4a07      	ldr	r2, [pc, #28]	; (8014c30 <rt_schedule_insert_thread+0x68>)
 8014c14:	6013      	str	r3, [r2, #0]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8014c16:	4620      	mov	r0, r4
 8014c18:	f7eb fada 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8014c1c:	370c      	adds	r7, #12
 8014c1e:	46bd      	mov	sp, r7
 8014c20:	bd90      	pop	{r4, r7, pc}
 8014c22:	bf00      	nop
 8014c24:	08023288 	.word	0x08023288
 8014c28:	08024f60 	.word	0x08024f60
 8014c2c:	20012578 	.word	0x20012578
 8014c30:	20012680 	.word	0x20012680

08014c34 <rt_schedule_remove_thread>:
 * @param thread the thread to be removed
 *
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_remove_thread(struct rt_thread *thread)
{
 8014c34:	b590      	push	{r4, r7, lr}
 8014c36:	b083      	sub	sp, #12
 8014c38:	af00      	add	r7, sp, #0
 8014c3a:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
 8014c3c:	687b      	ldr	r3, [r7, #4]
 8014c3e:	2b00      	cmp	r3, #0
 8014c40:	d105      	bne.n	8014c4e <rt_schedule_remove_thread+0x1a>
 8014c42:	4814      	ldr	r0, [pc, #80]	; (8014c94 <rt_schedule_remove_thread+0x60>)
 8014c44:	4914      	ldr	r1, [pc, #80]	; (8014c98 <rt_schedule_remove_thread+0x64>)
 8014c46:	f240 123d 	movw	r2, #317	; 0x13d
 8014c4a:	f7ff f88b 	bl	8013d64 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8014c4e:	f7eb fabb 	bl	80001c8 <rt_hw_interrupt_disable>
 8014c52:	4604      	mov	r4, r0
                  thread->number_mask,
                  thread->high_mask));
#endif

    /* remove thread from ready list */
    rt_list_remove(&(thread->tlist));
 8014c54:	687b      	ldr	r3, [r7, #4]
 8014c56:	3314      	adds	r3, #20
 8014c58:	4618      	mov	r0, r3
 8014c5a:	f7ff fe9d 	bl	8014998 <rt_list_remove>
    if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
 8014c5e:	687b      	ldr	r3, [r7, #4]
 8014c60:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8014c64:	00db      	lsls	r3, r3, #3
 8014c66:	4a0d      	ldr	r2, [pc, #52]	; (8014c9c <rt_schedule_remove_thread+0x68>)
 8014c68:	4413      	add	r3, r2
 8014c6a:	4618      	mov	r0, r3
 8014c6c:	f7ff feae 	bl	80149cc <rt_list_isempty>
 8014c70:	4603      	mov	r3, r0
 8014c72:	2b00      	cmp	r3, #0
 8014c74:	d007      	beq.n	8014c86 <rt_schedule_remove_thread+0x52>
        if (rt_thread_ready_table[thread->number] == 0)
        {
            rt_thread_ready_priority_group &= ~thread->number_mask;
        }
#else
        rt_thread_ready_priority_group &= ~thread->number_mask;
 8014c76:	687b      	ldr	r3, [r7, #4]
 8014c78:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014c7a:	43da      	mvns	r2, r3
 8014c7c:	4b08      	ldr	r3, [pc, #32]	; (8014ca0 <rt_schedule_remove_thread+0x6c>)
 8014c7e:	681b      	ldr	r3, [r3, #0]
 8014c80:	4013      	ands	r3, r2
 8014c82:	4a07      	ldr	r2, [pc, #28]	; (8014ca0 <rt_schedule_remove_thread+0x6c>)
 8014c84:	6013      	str	r3, [r2, #0]
#endif
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8014c86:	4620      	mov	r0, r4
 8014c88:	f7eb faa2 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8014c8c:	370c      	adds	r7, #12
 8014c8e:	46bd      	mov	sp, r7
 8014c90:	bd90      	pop	{r4, r7, pc}
 8014c92:	bf00      	nop
 8014c94:	08023288 	.word	0x08023288
 8014c98:	08024f7c 	.word	0x08024f7c
 8014c9c:	20012578 	.word	0x20012578
 8014ca0:	20012680 	.word	0x20012680

08014ca4 <rt_enter_critical>:

/**
 * This function will lock the thread scheduler.
 */
void rt_enter_critical(void)
{
 8014ca4:	b598      	push	{r3, r4, r7, lr}
 8014ca6:	af00      	add	r7, sp, #0
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8014ca8:	f7eb fa8e 	bl	80001c8 <rt_hw_interrupt_disable>
 8014cac:	4604      	mov	r4, r0

    /*
     * the maximal number of nest is RT_UINT16_MAX, which is big
     * enough and does not check here
     */
    rt_scheduler_lock_nest ++;
 8014cae:	4b06      	ldr	r3, [pc, #24]	; (8014cc8 <rt_enter_critical+0x24>)
 8014cb0:	881b      	ldrh	r3, [r3, #0]
 8014cb2:	b29b      	uxth	r3, r3
 8014cb4:	b29b      	uxth	r3, r3
 8014cb6:	3301      	adds	r3, #1
 8014cb8:	b29b      	uxth	r3, r3
 8014cba:	b29a      	uxth	r2, r3
 8014cbc:	4b02      	ldr	r3, [pc, #8]	; (8014cc8 <rt_enter_critical+0x24>)
 8014cbe:	801a      	strh	r2, [r3, #0]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8014cc0:	4620      	mov	r0, r4
 8014cc2:	f7eb fa85 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8014cc6:	bd98      	pop	{r3, r4, r7, pc}
 8014cc8:	20010de0 	.word	0x20010de0

08014ccc <rt_exit_critical>:

/**
 * This function will unlock the thread scheduler.
 */
void rt_exit_critical(void)
{
 8014ccc:	b598      	push	{r3, r4, r7, lr}
 8014cce:	af00      	add	r7, sp, #0
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8014cd0:	f7eb fa7a 	bl	80001c8 <rt_hw_interrupt_disable>
 8014cd4:	4604      	mov	r4, r0

    rt_scheduler_lock_nest --;
 8014cd6:	4b0d      	ldr	r3, [pc, #52]	; (8014d0c <rt_exit_critical+0x40>)
 8014cd8:	881b      	ldrh	r3, [r3, #0]
 8014cda:	b29b      	uxth	r3, r3
 8014cdc:	b29b      	uxth	r3, r3
 8014cde:	3b01      	subs	r3, #1
 8014ce0:	b29b      	uxth	r3, r3
 8014ce2:	b29a      	uxth	r2, r3
 8014ce4:	4b09      	ldr	r3, [pc, #36]	; (8014d0c <rt_exit_critical+0x40>)
 8014ce6:	801a      	strh	r2, [r3, #0]

    if (rt_scheduler_lock_nest <= 0)
 8014ce8:	4b08      	ldr	r3, [pc, #32]	; (8014d0c <rt_exit_critical+0x40>)
 8014cea:	881b      	ldrh	r3, [r3, #0]
 8014cec:	b21b      	sxth	r3, r3
 8014cee:	2b00      	cmp	r3, #0
 8014cf0:	dc08      	bgt.n	8014d04 <rt_exit_critical+0x38>
    {
        rt_scheduler_lock_nest = 0;
 8014cf2:	4b06      	ldr	r3, [pc, #24]	; (8014d0c <rt_exit_critical+0x40>)
 8014cf4:	2200      	movs	r2, #0
 8014cf6:	801a      	strh	r2, [r3, #0]
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8014cf8:	4620      	mov	r0, r4
 8014cfa:	f7eb fa69 	bl	80001d0 <rt_hw_interrupt_enable>

        rt_schedule();
 8014cfe:	f7ff ff05 	bl	8014b0c <rt_schedule>
 8014d02:	e002      	b.n	8014d0a <rt_exit_critical+0x3e>
    }
    else
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8014d04:	4620      	mov	r0, r4
 8014d06:	f7eb fa63 	bl	80001d0 <rt_hw_interrupt_enable>
    }
}
 8014d0a:	bd98      	pop	{r3, r4, r7, pc}
 8014d0c:	20010de0 	.word	0x20010de0

08014d10 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8014d10:	b480      	push	{r7}
 8014d12:	b083      	sub	sp, #12
 8014d14:	af00      	add	r7, sp, #0
 8014d16:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8014d18:	687b      	ldr	r3, [r7, #4]
 8014d1a:	687a      	ldr	r2, [r7, #4]
 8014d1c:	605a      	str	r2, [r3, #4]
 8014d1e:	687b      	ldr	r3, [r7, #4]
 8014d20:	685a      	ldr	r2, [r3, #4]
 8014d22:	687b      	ldr	r3, [r7, #4]
 8014d24:	601a      	str	r2, [r3, #0]
}
 8014d26:	370c      	adds	r7, #12
 8014d28:	46bd      	mov	sp, r7
 8014d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d2e:	4770      	bx	lr

08014d30 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 8014d30:	b480      	push	{r7}
 8014d32:	b083      	sub	sp, #12
 8014d34:	af00      	add	r7, sp, #0
 8014d36:	6078      	str	r0, [r7, #4]
 8014d38:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 8014d3a:	687b      	ldr	r3, [r7, #4]
 8014d3c:	681b      	ldr	r3, [r3, #0]
 8014d3e:	683a      	ldr	r2, [r7, #0]
 8014d40:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 8014d42:	687b      	ldr	r3, [r7, #4]
 8014d44:	681a      	ldr	r2, [r3, #0]
 8014d46:	683b      	ldr	r3, [r7, #0]
 8014d48:	601a      	str	r2, [r3, #0]

    l->next = n;
 8014d4a:	687b      	ldr	r3, [r7, #4]
 8014d4c:	683a      	ldr	r2, [r7, #0]
 8014d4e:	601a      	str	r2, [r3, #0]
    n->prev = l;
 8014d50:	683b      	ldr	r3, [r7, #0]
 8014d52:	687a      	ldr	r2, [r7, #4]
 8014d54:	605a      	str	r2, [r3, #4]
}
 8014d56:	370c      	adds	r7, #12
 8014d58:	46bd      	mov	sp, r7
 8014d5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d5e:	4770      	bx	lr

08014d60 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8014d60:	b480      	push	{r7}
 8014d62:	b083      	sub	sp, #12
 8014d64:	af00      	add	r7, sp, #0
 8014d66:	6078      	str	r0, [r7, #4]
 8014d68:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 8014d6a:	687b      	ldr	r3, [r7, #4]
 8014d6c:	685b      	ldr	r3, [r3, #4]
 8014d6e:	683a      	ldr	r2, [r7, #0]
 8014d70:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8014d72:	687b      	ldr	r3, [r7, #4]
 8014d74:	685a      	ldr	r2, [r3, #4]
 8014d76:	683b      	ldr	r3, [r7, #0]
 8014d78:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8014d7a:	687b      	ldr	r3, [r7, #4]
 8014d7c:	683a      	ldr	r2, [r7, #0]
 8014d7e:	605a      	str	r2, [r3, #4]
    n->next = l;
 8014d80:	683b      	ldr	r3, [r7, #0]
 8014d82:	687a      	ldr	r2, [r7, #4]
 8014d84:	601a      	str	r2, [r3, #0]
}
 8014d86:	370c      	adds	r7, #12
 8014d88:	46bd      	mov	sp, r7
 8014d8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d8e:	4770      	bx	lr

08014d90 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8014d90:	b480      	push	{r7}
 8014d92:	b083      	sub	sp, #12
 8014d94:	af00      	add	r7, sp, #0
 8014d96:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8014d98:	687b      	ldr	r3, [r7, #4]
 8014d9a:	681b      	ldr	r3, [r3, #0]
 8014d9c:	687a      	ldr	r2, [r7, #4]
 8014d9e:	6852      	ldr	r2, [r2, #4]
 8014da0:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8014da2:	687b      	ldr	r3, [r7, #4]
 8014da4:	685b      	ldr	r3, [r3, #4]
 8014da6:	687a      	ldr	r2, [r7, #4]
 8014da8:	6812      	ldr	r2, [r2, #0]
 8014daa:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8014dac:	687b      	ldr	r3, [r7, #4]
 8014dae:	687a      	ldr	r2, [r7, #4]
 8014db0:	605a      	str	r2, [r3, #4]
 8014db2:	687b      	ldr	r3, [r7, #4]
 8014db4:	685a      	ldr	r2, [r3, #4]
 8014db6:	687b      	ldr	r3, [r7, #4]
 8014db8:	601a      	str	r2, [r3, #0]
}
 8014dba:	370c      	adds	r7, #12
 8014dbc:	46bd      	mov	sp, r7
 8014dbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014dc2:	4770      	bx	lr

08014dc4 <rt_thread_exit>:
extern rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];
extern struct rt_thread *rt_current_thread;
extern rt_list_t rt_thread_defunct;

static void rt_thread_exit(void)
{
 8014dc4:	b590      	push	{r4, r7, lr}
 8014dc6:	b083      	sub	sp, #12
 8014dc8:	af00      	add	r7, sp, #0
    struct rt_thread *thread;
    register rt_base_t level;

    /* get current thread */
    thread = rt_current_thread;
 8014dca:	4b17      	ldr	r3, [pc, #92]	; (8014e28 <rt_thread_exit+0x64>)
 8014dcc:	681b      	ldr	r3, [r3, #0]
 8014dce:	607b      	str	r3, [r7, #4]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8014dd0:	f7eb f9fa 	bl	80001c8 <rt_hw_interrupt_disable>
 8014dd4:	4604      	mov	r4, r0

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
 8014dd6:	6878      	ldr	r0, [r7, #4]
 8014dd8:	f7ff ff2c 	bl	8014c34 <rt_schedule_remove_thread>
    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
 8014ddc:	687b      	ldr	r3, [r7, #4]
 8014dde:	2204      	movs	r2, #4
 8014de0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);
 8014de4:	687b      	ldr	r3, [r7, #4]
 8014de6:	334c      	adds	r3, #76	; 0x4c
 8014de8:	4618      	mov	r0, r3
 8014dea:	f000 fbc3 	bl	8015574 <rt_timer_detach>

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
 8014dee:	6878      	ldr	r0, [r7, #4]
 8014df0:	f7ff fd8c 	bl	801490c <rt_object_is_systemobject>
 8014df4:	4603      	mov	r3, r0
 8014df6:	2b01      	cmp	r3, #1
 8014df8:	d107      	bne.n	8014e0a <rt_thread_exit+0x46>
        thread->cleanup == RT_NULL)
 8014dfa:	687b      	ldr	r3, [r7, #4]
 8014dfc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    thread->stat = RT_THREAD_CLOSE;

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
 8014dfe:	2b00      	cmp	r3, #0
 8014e00:	d103      	bne.n	8014e0a <rt_thread_exit+0x46>
        thread->cleanup == RT_NULL)
    {
        rt_object_detach((rt_object_t)thread);
 8014e02:	6878      	ldr	r0, [r7, #4]
 8014e04:	f7ff fcc4 	bl	8014790 <rt_object_detach>
 8014e08:	e005      	b.n	8014e16 <rt_thread_exit+0x52>
    }
    else
    {
        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 8014e0a:	687b      	ldr	r3, [r7, #4]
 8014e0c:	3314      	adds	r3, #20
 8014e0e:	4807      	ldr	r0, [pc, #28]	; (8014e2c <rt_thread_exit+0x68>)
 8014e10:	4619      	mov	r1, r3
 8014e12:	f7ff ff8d 	bl	8014d30 <rt_list_insert_after>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8014e16:	4620      	mov	r0, r4
 8014e18:	f7eb f9da 	bl	80001d0 <rt_hw_interrupt_enable>

    /* switch to next task */
    rt_schedule();
 8014e1c:	f7ff fe76 	bl	8014b0c <rt_schedule>
}
 8014e20:	370c      	adds	r7, #12
 8014e22:	46bd      	mov	sp, r7
 8014e24:	bd90      	pop	{r4, r7, pc}
 8014e26:	bf00      	nop
 8014e28:	2001267c 	.word	0x2001267c
 8014e2c:	20012684 	.word	0x20012684

08014e30 <_rt_thread_init>:
                                void             *parameter,
                                void             *stack_start,
                                rt_uint32_t       stack_size,
                                rt_uint8_t        priority,
                                rt_uint32_t       tick)
{
 8014e30:	b580      	push	{r7, lr}
 8014e32:	b086      	sub	sp, #24
 8014e34:	af02      	add	r7, sp, #8
 8014e36:	60f8      	str	r0, [r7, #12]
 8014e38:	60b9      	str	r1, [r7, #8]
 8014e3a:	607a      	str	r2, [r7, #4]
 8014e3c:	603b      	str	r3, [r7, #0]
    /* init thread list */
    rt_list_init(&(thread->tlist));
 8014e3e:	68fb      	ldr	r3, [r7, #12]
 8014e40:	3314      	adds	r3, #20
 8014e42:	4618      	mov	r0, r3
 8014e44:	f7ff ff64 	bl	8014d10 <rt_list_init>

    thread->entry = (void *)entry;
 8014e48:	68fb      	ldr	r3, [r7, #12]
 8014e4a:	687a      	ldr	r2, [r7, #4]
 8014e4c:	621a      	str	r2, [r3, #32]
    thread->parameter = parameter;
 8014e4e:	68fb      	ldr	r3, [r7, #12]
 8014e50:	683a      	ldr	r2, [r7, #0]
 8014e52:	625a      	str	r2, [r3, #36]	; 0x24

    /* stack init */
    thread->stack_addr = stack_start;
 8014e54:	68fb      	ldr	r3, [r7, #12]
 8014e56:	69ba      	ldr	r2, [r7, #24]
 8014e58:	629a      	str	r2, [r3, #40]	; 0x28
    thread->stack_size = (rt_uint16_t)stack_size;
 8014e5a:	69fb      	ldr	r3, [r7, #28]
 8014e5c:	b29a      	uxth	r2, r3
 8014e5e:	68fb      	ldr	r3, [r7, #12]
 8014e60:	859a      	strh	r2, [r3, #44]	; 0x2c

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
 8014e62:	68fb      	ldr	r3, [r7, #12]
 8014e64:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8014e66:	68fb      	ldr	r3, [r7, #12]
 8014e68:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8014e6a:	4610      	mov	r0, r2
 8014e6c:	2123      	movs	r1, #35	; 0x23
 8014e6e:	461a      	mov	r2, r3
 8014e70:	f7fe f946 	bl	8013100 <rt_memset>
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
 8014e74:	68fb      	ldr	r3, [r7, #12]
 8014e76:	6a18      	ldr	r0, [r3, #32]
 8014e78:	68fb      	ldr	r3, [r7, #12]
 8014e7a:	6a59      	ldr	r1, [r3, #36]	; 0x24
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
 8014e7c:	68fb      	ldr	r3, [r7, #12]
 8014e7e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8014e80:	68fb      	ldr	r3, [r7, #12]
 8014e82:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8014e84:	3b04      	subs	r3, #4
 8014e86:	4413      	add	r3, r2
    thread->stack_addr = stack_start;
    thread->stack_size = (rt_uint16_t)stack_size;

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
 8014e88:	461a      	mov	r2, r3
 8014e8a:	4b1f      	ldr	r3, [pc, #124]	; (8014f08 <_rt_thread_init+0xd8>)
 8014e8c:	f000 fe6e 	bl	8015b6c <rt_hw_stack_init>
 8014e90:	4602      	mov	r2, r0
 8014e92:	68fb      	ldr	r3, [r7, #12]
 8014e94:	61da      	str	r2, [r3, #28]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
        (void *)rt_thread_exit);

    /* priority init */
    RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
 8014e96:	f897 3020 	ldrb.w	r3, [r7, #32]
 8014e9a:	2b1f      	cmp	r3, #31
 8014e9c:	d904      	bls.n	8014ea8 <_rt_thread_init+0x78>
 8014e9e:	481b      	ldr	r0, [pc, #108]	; (8014f0c <_rt_thread_init+0xdc>)
 8014ea0:	491b      	ldr	r1, [pc, #108]	; (8014f10 <_rt_thread_init+0xe0>)
 8014ea2:	226e      	movs	r2, #110	; 0x6e
 8014ea4:	f7fe ff5e 	bl	8013d64 <rt_assert_handler>
    thread->init_priority    = priority;
 8014ea8:	68fb      	ldr	r3, [r7, #12]
 8014eaa:	f897 2020 	ldrb.w	r2, [r7, #32]
 8014eae:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
    thread->current_priority = priority;
 8014eb2:	68fb      	ldr	r3, [r7, #12]
 8014eb4:	f897 2020 	ldrb.w	r2, [r7, #32]
 8014eb8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* tick init */
    thread->init_tick      = tick;
 8014ebc:	68fb      	ldr	r3, [r7, #12]
 8014ebe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014ec0:	645a      	str	r2, [r3, #68]	; 0x44
    thread->remaining_tick = tick;
 8014ec2:	68fb      	ldr	r3, [r7, #12]
 8014ec4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014ec6:	649a      	str	r2, [r3, #72]	; 0x48

    /* error and flags */
    thread->error = RT_EOK;
 8014ec8:	68fb      	ldr	r3, [r7, #12]
 8014eca:	2200      	movs	r2, #0
 8014ecc:	631a      	str	r2, [r3, #48]	; 0x30
    thread->stat  = RT_THREAD_INIT;
 8014ece:	68fb      	ldr	r3, [r7, #12]
 8014ed0:	2200      	movs	r2, #0
 8014ed2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
 8014ed6:	68fb      	ldr	r3, [r7, #12]
 8014ed8:	2200      	movs	r2, #0
 8014eda:	679a      	str	r2, [r3, #120]	; 0x78
    thread->user_data = 0;
 8014edc:	68fb      	ldr	r3, [r7, #12]
 8014ede:	2200      	movs	r2, #0
 8014ee0:	67da      	str	r2, [r3, #124]	; 0x7c

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
 8014ee2:	68fb      	ldr	r3, [r7, #12]
 8014ee4:	f103 014c 	add.w	r1, r3, #76	; 0x4c
                  thread->name,
 8014ee8:	68fa      	ldr	r2, [r7, #12]
    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
    thread->user_data = 0;

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
 8014eea:	2300      	movs	r3, #0
 8014eec:	9300      	str	r3, [sp, #0]
 8014eee:	2300      	movs	r3, #0
 8014ef0:	9301      	str	r3, [sp, #4]
 8014ef2:	4608      	mov	r0, r1
 8014ef4:	4611      	mov	r1, r2
 8014ef6:	4a07      	ldr	r2, [pc, #28]	; (8014f14 <_rt_thread_init+0xe4>)
 8014ef8:	68fb      	ldr	r3, [r7, #12]
 8014efa:	f000 fb17 	bl	801552c <rt_timer_init>
                  rt_thread_timeout,
                  thread,
                  0,
                  RT_TIMER_FLAG_ONE_SHOT);

    return RT_EOK;
 8014efe:	2300      	movs	r3, #0
}
 8014f00:	4618      	mov	r0, r3
 8014f02:	3710      	adds	r7, #16
 8014f04:	46bd      	mov	sp, r7
 8014f06:	bd80      	pop	{r7, pc}
 8014f08:	08014dc5 	.word	0x08014dc5
 8014f0c:	080232f0 	.word	0x080232f0
 8014f10:	08024f98 	.word	0x08024f98
 8014f14:	08015355 	.word	0x08015355

08014f18 <rt_thread_init>:
                        void             *parameter,
                        void             *stack_start,
                        rt_uint32_t       stack_size,
                        rt_uint8_t        priority,
                        rt_uint32_t       tick)
{
 8014f18:	b580      	push	{r7, lr}
 8014f1a:	b088      	sub	sp, #32
 8014f1c:	af04      	add	r7, sp, #16
 8014f1e:	60f8      	str	r0, [r7, #12]
 8014f20:	60b9      	str	r1, [r7, #8]
 8014f22:	607a      	str	r2, [r7, #4]
 8014f24:	603b      	str	r3, [r7, #0]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8014f26:	68fb      	ldr	r3, [r7, #12]
 8014f28:	2b00      	cmp	r3, #0
 8014f2a:	d104      	bne.n	8014f36 <rt_thread_init+0x1e>
 8014f2c:	4812      	ldr	r0, [pc, #72]	; (8014f78 <rt_thread_init+0x60>)
 8014f2e:	4913      	ldr	r1, [pc, #76]	; (8014f7c <rt_thread_init+0x64>)
 8014f30:	22a8      	movs	r2, #168	; 0xa8
 8014f32:	f7fe ff17 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(stack_start != RT_NULL);
 8014f36:	69bb      	ldr	r3, [r7, #24]
 8014f38:	2b00      	cmp	r3, #0
 8014f3a:	d104      	bne.n	8014f46 <rt_thread_init+0x2e>
 8014f3c:	4810      	ldr	r0, [pc, #64]	; (8014f80 <rt_thread_init+0x68>)
 8014f3e:	490f      	ldr	r1, [pc, #60]	; (8014f7c <rt_thread_init+0x64>)
 8014f40:	22a9      	movs	r2, #169	; 0xa9
 8014f42:	f7fe ff0f 	bl	8013d64 <rt_assert_handler>

    /* init thread object */
    rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
 8014f46:	68f8      	ldr	r0, [r7, #12]
 8014f48:	2100      	movs	r1, #0
 8014f4a:	68ba      	ldr	r2, [r7, #8]
 8014f4c:	f7ff fbea 	bl	8014724 <rt_object_init>

    return _rt_thread_init(thread,
 8014f50:	69bb      	ldr	r3, [r7, #24]
 8014f52:	9300      	str	r3, [sp, #0]
 8014f54:	69fb      	ldr	r3, [r7, #28]
 8014f56:	9301      	str	r3, [sp, #4]
 8014f58:	f897 3020 	ldrb.w	r3, [r7, #32]
 8014f5c:	9302      	str	r3, [sp, #8]
 8014f5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014f60:	9303      	str	r3, [sp, #12]
 8014f62:	68f8      	ldr	r0, [r7, #12]
 8014f64:	68b9      	ldr	r1, [r7, #8]
 8014f66:	687a      	ldr	r2, [r7, #4]
 8014f68:	683b      	ldr	r3, [r7, #0]
 8014f6a:	f7ff ff61 	bl	8014e30 <_rt_thread_init>
 8014f6e:	4603      	mov	r3, r0
                           parameter,
                           stack_start,
                           stack_size,
                           priority,
                           tick);
}
 8014f70:	4618      	mov	r0, r3
 8014f72:	3710      	adds	r7, #16
 8014f74:	46bd      	mov	sp, r7
 8014f76:	bd80      	pop	{r7, pc}
 8014f78:	08023314 	.word	0x08023314
 8014f7c:	08024fa8 	.word	0x08024fa8
 8014f80:	08023328 	.word	0x08023328

08014f84 <rt_thread_self>:
 * This function will return self thread object
 *
 * @return the self thread object
 */
rt_thread_t rt_thread_self(void)
{
 8014f84:	b480      	push	{r7}
 8014f86:	af00      	add	r7, sp, #0
    return rt_current_thread;
 8014f88:	4b03      	ldr	r3, [pc, #12]	; (8014f98 <rt_thread_self+0x14>)
 8014f8a:	681b      	ldr	r3, [r3, #0]
}
 8014f8c:	4618      	mov	r0, r3
 8014f8e:	46bd      	mov	sp, r7
 8014f90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f94:	4770      	bx	lr
 8014f96:	bf00      	nop
 8014f98:	2001267c 	.word	0x2001267c

08014f9c <rt_thread_startup>:
 * @param thread the thread to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_startup(rt_thread_t thread)
{
 8014f9c:	b580      	push	{r7, lr}
 8014f9e:	b082      	sub	sp, #8
 8014fa0:	af00      	add	r7, sp, #0
 8014fa2:	6078      	str	r0, [r7, #4]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8014fa4:	687b      	ldr	r3, [r7, #4]
 8014fa6:	2b00      	cmp	r3, #0
 8014fa8:	d104      	bne.n	8014fb4 <rt_thread_startup+0x18>
 8014faa:	4818      	ldr	r0, [pc, #96]	; (801500c <rt_thread_startup+0x70>)
 8014fac:	4918      	ldr	r1, [pc, #96]	; (8015010 <rt_thread_startup+0x74>)
 8014fae:	22ce      	movs	r2, #206	; 0xce
 8014fb0:	f7fe fed8 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_INIT);
 8014fb4:	687b      	ldr	r3, [r7, #4]
 8014fb6:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8014fba:	2b00      	cmp	r3, #0
 8014fbc:	d004      	beq.n	8014fc8 <rt_thread_startup+0x2c>
 8014fbe:	4815      	ldr	r0, [pc, #84]	; (8015014 <rt_thread_startup+0x78>)
 8014fc0:	4913      	ldr	r1, [pc, #76]	; (8015010 <rt_thread_startup+0x74>)
 8014fc2:	22cf      	movs	r2, #207	; 0xcf
 8014fc4:	f7fe fece 	bl	8013d64 <rt_assert_handler>

    /* set current priority to init priority */
    thread->current_priority = thread->init_priority;
 8014fc8:	687b      	ldr	r3, [r7, #4]
 8014fca:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 8014fce:	687b      	ldr	r3, [r7, #4]
 8014fd0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
    thread->number      = thread->current_priority >> 3;            /* 5bit */
    thread->number_mask = 1L << thread->number;
    thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
#else
    thread->number_mask = 1L << thread->current_priority;
 8014fd4:	687b      	ldr	r3, [r7, #4]
 8014fd6:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8014fda:	461a      	mov	r2, r3
 8014fdc:	2301      	movs	r3, #1
 8014fde:	4093      	lsls	r3, r2
 8014fe0:	461a      	mov	r2, r3
 8014fe2:	687b      	ldr	r3, [r7, #4]
 8014fe4:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
                                   thread->name, thread->init_priority));
    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
 8014fe6:	687b      	ldr	r3, [r7, #4]
 8014fe8:	2202      	movs	r2, #2
 8014fea:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    /* then resume it */
    rt_thread_resume(thread);
 8014fee:	6878      	ldr	r0, [r7, #4]
 8014ff0:	f000 f97e 	bl	80152f0 <rt_thread_resume>
    if (rt_thread_self() != RT_NULL)
 8014ff4:	f7ff ffc6 	bl	8014f84 <rt_thread_self>
 8014ff8:	4603      	mov	r3, r0
 8014ffa:	2b00      	cmp	r3, #0
 8014ffc:	d001      	beq.n	8015002 <rt_thread_startup+0x66>
    {
        /* do a scheduling */
        rt_schedule();
 8014ffe:	f7ff fd85 	bl	8014b0c <rt_schedule>
    }

    return RT_EOK;
 8015002:	2300      	movs	r3, #0
}
 8015004:	4618      	mov	r0, r3
 8015006:	3708      	adds	r7, #8
 8015008:	46bd      	mov	sp, r7
 801500a:	bd80      	pop	{r7, pc}
 801500c:	08023314 	.word	0x08023314
 8015010:	08024fb8 	.word	0x08024fb8
 8015014:	08023340 	.word	0x08023340

08015018 <rt_thread_create>:
                             void (*entry)(void *parameter),
                             void       *parameter,
                             rt_uint32_t stack_size,
                             rt_uint8_t  priority,
                             rt_uint32_t tick)
{
 8015018:	b580      	push	{r7, lr}
 801501a:	b08a      	sub	sp, #40	; 0x28
 801501c:	af04      	add	r7, sp, #16
 801501e:	60f8      	str	r0, [r7, #12]
 8015020:	60b9      	str	r1, [r7, #8]
 8015022:	607a      	str	r2, [r7, #4]
 8015024:	603b      	str	r3, [r7, #0]
    struct rt_thread *thread;
    void *stack_start;

    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
 8015026:	2000      	movs	r0, #0
 8015028:	68f9      	ldr	r1, [r7, #12]
 801502a:	f7ff fbd9 	bl	80147e0 <rt_object_allocate>
 801502e:	6178      	str	r0, [r7, #20]
                                                    name);
    if (thread == RT_NULL)
 8015030:	697b      	ldr	r3, [r7, #20]
 8015032:	2b00      	cmp	r3, #0
 8015034:	d101      	bne.n	801503a <rt_thread_create+0x22>
        return RT_NULL;
 8015036:	2300      	movs	r3, #0
 8015038:	e01b      	b.n	8015072 <rt_thread_create+0x5a>

    stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
 801503a:	6838      	ldr	r0, [r7, #0]
 801503c:	f7fe ffc6 	bl	8013fcc <rt_malloc>
 8015040:	6138      	str	r0, [r7, #16]
    if (stack_start == RT_NULL)
 8015042:	693b      	ldr	r3, [r7, #16]
 8015044:	2b00      	cmp	r3, #0
 8015046:	d104      	bne.n	8015052 <rt_thread_create+0x3a>
    {
        /* allocate stack failure */
        rt_object_delete((rt_object_t)thread);
 8015048:	6978      	ldr	r0, [r7, #20]
 801504a:	f7ff fc25 	bl	8014898 <rt_object_delete>

        return RT_NULL;
 801504e:	2300      	movs	r3, #0
 8015050:	e00f      	b.n	8015072 <rt_thread_create+0x5a>
    }

    _rt_thread_init(thread,
 8015052:	693b      	ldr	r3, [r7, #16]
 8015054:	9300      	str	r3, [sp, #0]
 8015056:	683b      	ldr	r3, [r7, #0]
 8015058:	9301      	str	r3, [sp, #4]
 801505a:	f897 3020 	ldrb.w	r3, [r7, #32]
 801505e:	9302      	str	r3, [sp, #8]
 8015060:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015062:	9303      	str	r3, [sp, #12]
 8015064:	6978      	ldr	r0, [r7, #20]
 8015066:	68f9      	ldr	r1, [r7, #12]
 8015068:	68ba      	ldr	r2, [r7, #8]
 801506a:	687b      	ldr	r3, [r7, #4]
 801506c:	f7ff fee0 	bl	8014e30 <_rt_thread_init>
                    stack_start,
                    stack_size,
                    priority,
                    tick);

    return thread;
 8015070:	697b      	ldr	r3, [r7, #20]
}
 8015072:	4618      	mov	r0, r3
 8015074:	3718      	adds	r7, #24
 8015076:	46bd      	mov	sp, r7
 8015078:	bd80      	pop	{r7, pc}
 801507a:	bf00      	nop

0801507c <rt_thread_delete>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_delete(rt_thread_t thread)
{
 801507c:	b580      	push	{r7, lr}
 801507e:	b084      	sub	sp, #16
 8015080:	af00      	add	r7, sp, #0
 8015082:	6078      	str	r0, [r7, #4]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8015084:	687b      	ldr	r3, [r7, #4]
 8015086:	2b00      	cmp	r3, #0
 8015088:	d105      	bne.n	8015096 <rt_thread_delete+0x1a>
 801508a:	4811      	ldr	r0, [pc, #68]	; (80150d0 <rt_thread_delete+0x54>)
 801508c:	4911      	ldr	r1, [pc, #68]	; (80150d4 <rt_thread_delete+0x58>)
 801508e:	f240 1259 	movw	r2, #345	; 0x159
 8015092:	f7fe fe67 	bl	8013d64 <rt_assert_handler>

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
 8015096:	6878      	ldr	r0, [r7, #4]
 8015098:	f7ff fdcc 	bl	8014c34 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
 801509c:	687b      	ldr	r3, [r7, #4]
 801509e:	334c      	adds	r3, #76	; 0x4c
 80150a0:	4618      	mov	r0, r3
 80150a2:	f000 fa67 	bl	8015574 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
 80150a6:	687b      	ldr	r3, [r7, #4]
 80150a8:	2204      	movs	r2, #4
 80150aa:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* disable interrupt */
    lock = rt_hw_interrupt_disable();
 80150ae:	f7eb f88b 	bl	80001c8 <rt_hw_interrupt_disable>
 80150b2:	60f8      	str	r0, [r7, #12]

    /* insert to defunct thread list */
    rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 80150b4:	687b      	ldr	r3, [r7, #4]
 80150b6:	3314      	adds	r3, #20
 80150b8:	4807      	ldr	r0, [pc, #28]	; (80150d8 <rt_thread_delete+0x5c>)
 80150ba:	4619      	mov	r1, r3
 80150bc:	f7ff fe38 	bl	8014d30 <rt_list_insert_after>

    /* enable interrupt */
    rt_hw_interrupt_enable(lock);
 80150c0:	68f8      	ldr	r0, [r7, #12]
 80150c2:	f7eb f885 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 80150c6:	2300      	movs	r3, #0
}
 80150c8:	4618      	mov	r0, r3
 80150ca:	3710      	adds	r7, #16
 80150cc:	46bd      	mov	sp, r7
 80150ce:	bd80      	pop	{r7, pc}
 80150d0:	08023314 	.word	0x08023314
 80150d4:	08024fcc 	.word	0x08024fcc
 80150d8:	20012684 	.word	0x20012684

080150dc <rt_thread_yield>:
 * is still in READY state.
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_yield(void)
{
 80150dc:	b590      	push	{r4, r7, lr}
 80150de:	b083      	sub	sp, #12
 80150e0:	af00      	add	r7, sp, #0
    register rt_base_t level;
    struct rt_thread *thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 80150e2:	f7eb f871 	bl	80001c8 <rt_hw_interrupt_disable>
 80150e6:	4604      	mov	r4, r0

    /* set to current thread */
    thread = rt_current_thread;
 80150e8:	4b16      	ldr	r3, [pc, #88]	; (8015144 <rt_thread_yield+0x68>)
 80150ea:	681b      	ldr	r3, [r3, #0]
 80150ec:	607b      	str	r3, [r7, #4]

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
 80150ee:	687b      	ldr	r3, [r7, #4]
 80150f0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80150f4:	2b01      	cmp	r3, #1
 80150f6:	d11d      	bne.n	8015134 <rt_thread_yield+0x58>
        thread->tlist.next != thread->tlist.prev)
 80150f8:	687b      	ldr	r3, [r7, #4]
 80150fa:	695a      	ldr	r2, [r3, #20]
 80150fc:	687b      	ldr	r3, [r7, #4]
 80150fe:	699b      	ldr	r3, [r3, #24]

    /* set to current thread */
    thread = rt_current_thread;

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
 8015100:	429a      	cmp	r2, r3
 8015102:	d017      	beq.n	8015134 <rt_thread_yield+0x58>
        thread->tlist.next != thread->tlist.prev)
    {
        /* remove thread from thread list */
        rt_list_remove(&(thread->tlist));
 8015104:	687b      	ldr	r3, [r7, #4]
 8015106:	3314      	adds	r3, #20
 8015108:	4618      	mov	r0, r3
 801510a:	f7ff fe41 	bl	8014d90 <rt_list_remove>

        /* put thread to end of ready queue */
        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
 801510e:	687b      	ldr	r3, [r7, #4]
 8015110:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8015114:	00db      	lsls	r3, r3, #3
 8015116:	4a0c      	ldr	r2, [pc, #48]	; (8015148 <rt_thread_yield+0x6c>)
 8015118:	441a      	add	r2, r3
 801511a:	687b      	ldr	r3, [r7, #4]
 801511c:	3314      	adds	r3, #20
 801511e:	4610      	mov	r0, r2
 8015120:	4619      	mov	r1, r3
 8015122:	f7ff fe1d 	bl	8014d60 <rt_list_insert_before>
                              &(thread->tlist));

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8015126:	4620      	mov	r0, r4
 8015128:	f7eb f852 	bl	80001d0 <rt_hw_interrupt_enable>

        rt_schedule();
 801512c:	f7ff fcee 	bl	8014b0c <rt_schedule>

        return RT_EOK;
 8015130:	2300      	movs	r3, #0
 8015132:	e003      	b.n	801513c <rt_thread_yield+0x60>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8015134:	4620      	mov	r0, r4
 8015136:	f7eb f84b 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 801513a:	2300      	movs	r3, #0
}
 801513c:	4618      	mov	r0, r3
 801513e:	370c      	adds	r7, #12
 8015140:	46bd      	mov	sp, r7
 8015142:	bd90      	pop	{r4, r7, pc}
 8015144:	2001267c 	.word	0x2001267c
 8015148:	20012578 	.word	0x20012578

0801514c <rt_thread_sleep>:
 * @param tick the sleep ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_sleep(rt_tick_t tick)
{
 801514c:	b590      	push	{r4, r7, lr}
 801514e:	b085      	sub	sp, #20
 8015150:	af00      	add	r7, sp, #0
 8015152:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8015154:	f7eb f838 	bl	80001c8 <rt_hw_interrupt_disable>
 8015158:	4604      	mov	r4, r0
    /* set to current thread */
    thread = rt_current_thread;
 801515a:	4b17      	ldr	r3, [pc, #92]	; (80151b8 <rt_thread_sleep+0x6c>)
 801515c:	681b      	ldr	r3, [r3, #0]
 801515e:	60fb      	str	r3, [r7, #12]
    RT_ASSERT(thread != RT_NULL);
 8015160:	68fb      	ldr	r3, [r7, #12]
 8015162:	2b00      	cmp	r3, #0
 8015164:	d105      	bne.n	8015172 <rt_thread_sleep+0x26>
 8015166:	4815      	ldr	r0, [pc, #84]	; (80151bc <rt_thread_sleep+0x70>)
 8015168:	4915      	ldr	r1, [pc, #84]	; (80151c0 <rt_thread_sleep+0x74>)
 801516a:	f44f 72d7 	mov.w	r2, #430	; 0x1ae
 801516e:	f7fe fdf9 	bl	8013d64 <rt_assert_handler>

    /* suspend thread */
    rt_thread_suspend(thread);
 8015172:	68f8      	ldr	r0, [r7, #12]
 8015174:	f000 f88c 	bl	8015290 <rt_thread_suspend>

    /* reset the timeout of thread timer and start it */
    rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
 8015178:	68fb      	ldr	r3, [r7, #12]
 801517a:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 801517e:	1d3b      	adds	r3, r7, #4
 8015180:	4610      	mov	r0, r2
 8015182:	2100      	movs	r1, #0
 8015184:	461a      	mov	r2, r3
 8015186:	f000 fb7d 	bl	8015884 <rt_timer_control>
    rt_timer_start(&(thread->thread_timer));
 801518a:	68fb      	ldr	r3, [r7, #12]
 801518c:	334c      	adds	r3, #76	; 0x4c
 801518e:	4618      	mov	r0, r3
 8015190:	f000 fa32 	bl	80155f8 <rt_timer_start>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8015194:	4620      	mov	r0, r4
 8015196:	f7eb f81b 	bl	80001d0 <rt_hw_interrupt_enable>
	
    rt_schedule();
 801519a:	f7ff fcb7 	bl	8014b0c <rt_schedule>

    /* clear error number of this thread to RT_EOK */
    if (thread->error == -RT_ETIMEOUT)
 801519e:	68fb      	ldr	r3, [r7, #12]
 80151a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80151a2:	f113 0f02 	cmn.w	r3, #2
 80151a6:	d102      	bne.n	80151ae <rt_thread_sleep+0x62>
        thread->error = RT_EOK;
 80151a8:	68fb      	ldr	r3, [r7, #12]
 80151aa:	2200      	movs	r2, #0
 80151ac:	631a      	str	r2, [r3, #48]	; 0x30

    return RT_EOK;
 80151ae:	2300      	movs	r3, #0
}
 80151b0:	4618      	mov	r0, r3
 80151b2:	3714      	adds	r7, #20
 80151b4:	46bd      	mov	sp, r7
 80151b6:	bd90      	pop	{r4, r7, pc}
 80151b8:	2001267c 	.word	0x2001267c
 80151bc:	08023314 	.word	0x08023314
 80151c0:	08024fe0 	.word	0x08024fe0

080151c4 <rt_thread_delay>:
 * @param tick the delay ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_delay(rt_tick_t tick)
{
 80151c4:	b580      	push	{r7, lr}
 80151c6:	b082      	sub	sp, #8
 80151c8:	af00      	add	r7, sp, #0
 80151ca:	6078      	str	r0, [r7, #4]
    return rt_thread_sleep(tick);
 80151cc:	6878      	ldr	r0, [r7, #4]
 80151ce:	f7ff ffbd 	bl	801514c <rt_thread_sleep>
 80151d2:	4603      	mov	r3, r0
}
 80151d4:	4618      	mov	r0, r3
 80151d6:	3708      	adds	r7, #8
 80151d8:	46bd      	mov	sp, r7
 80151da:	bd80      	pop	{r7, pc}

080151dc <rt_thread_control>:
 * @param arg the argument of control command
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
{
 80151dc:	b590      	push	{r4, r7, lr}
 80151de:	b085      	sub	sp, #20
 80151e0:	af00      	add	r7, sp, #0
 80151e2:	60f8      	str	r0, [r7, #12]
 80151e4:	460b      	mov	r3, r1
 80151e6:	607a      	str	r2, [r7, #4]
 80151e8:	72fb      	strb	r3, [r7, #11]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 80151ea:	68fb      	ldr	r3, [r7, #12]
 80151ec:	2b00      	cmp	r3, #0
 80151ee:	d105      	bne.n	80151fc <rt_thread_control+0x20>
 80151f0:	4825      	ldr	r0, [pc, #148]	; (8015288 <rt_thread_control+0xac>)
 80151f2:	4926      	ldr	r1, [pc, #152]	; (801528c <rt_thread_control+0xb0>)
 80151f4:	f240 12e1 	movw	r2, #481	; 0x1e1
 80151f8:	f7fe fdb4 	bl	8013d64 <rt_assert_handler>

    switch (cmd)
 80151fc:	7afb      	ldrb	r3, [r7, #11]
 80151fe:	2b01      	cmp	r3, #1
 8015200:	d038      	beq.n	8015274 <rt_thread_control+0x98>
 8015202:	2b02      	cmp	r3, #2
 8015204:	d002      	beq.n	801520c <rt_thread_control+0x30>
 8015206:	2b00      	cmp	r3, #0
 8015208:	d02f      	beq.n	801526a <rt_thread_control+0x8e>
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
#endif

    default:
        break;
 801520a:	e038      	b.n	801527e <rt_thread_control+0xa2>

    switch (cmd)
    {
    case RT_THREAD_CTRL_CHANGE_PRIORITY:
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 801520c:	f7ea ffdc 	bl	80001c8 <rt_hw_interrupt_disable>
 8015210:	4604      	mov	r4, r0

        /* for ready thread, change queue */
        if (thread->stat == RT_THREAD_READY)
 8015212:	68fb      	ldr	r3, [r7, #12]
 8015214:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8015218:	2b01      	cmp	r3, #1
 801521a:	d114      	bne.n	8015246 <rt_thread_control+0x6a>
        {
            /* remove thread from schedule queue first */
            rt_schedule_remove_thread(thread);
 801521c:	68f8      	ldr	r0, [r7, #12]
 801521e:	f7ff fd09 	bl	8014c34 <rt_schedule_remove_thread>

            /* change thread priority */
            thread->current_priority = *(rt_uint8_t *)arg;
 8015222:	687b      	ldr	r3, [r7, #4]
 8015224:	781a      	ldrb	r2, [r3, #0]
 8015226:	68fb      	ldr	r3, [r7, #12]
 8015228:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
 801522c:	68fb      	ldr	r3, [r7, #12]
 801522e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8015232:	461a      	mov	r2, r3
 8015234:	2301      	movs	r3, #1
 8015236:	4093      	lsls	r3, r2
 8015238:	461a      	mov	r2, r3
 801523a:	68fb      	ldr	r3, [r7, #12]
 801523c:	639a      	str	r2, [r3, #56]	; 0x38
#endif

            /* insert thread to schedule queue again */
            rt_schedule_insert_thread(thread);
 801523e:	68f8      	ldr	r0, [r7, #12]
 8015240:	f7ff fcc2 	bl	8014bc8 <rt_schedule_insert_thread>
 8015244:	e00d      	b.n	8015262 <rt_thread_control+0x86>
        }
        else
        {
            thread->current_priority = *(rt_uint8_t *)arg;
 8015246:	687b      	ldr	r3, [r7, #4]
 8015248:	781a      	ldrb	r2, [r3, #0]
 801524a:	68fb      	ldr	r3, [r7, #12]
 801524c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
 8015250:	68fb      	ldr	r3, [r7, #12]
 8015252:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8015256:	461a      	mov	r2, r3
 8015258:	2301      	movs	r3, #1
 801525a:	4093      	lsls	r3, r2
 801525c:	461a      	mov	r2, r3
 801525e:	68fb      	ldr	r3, [r7, #12]
 8015260:	639a      	str	r2, [r3, #56]	; 0x38
#endif
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8015262:	4620      	mov	r0, r4
 8015264:	f7ea ffb4 	bl	80001d0 <rt_hw_interrupt_enable>
        break;
 8015268:	e009      	b.n	801527e <rt_thread_control+0xa2>

    case RT_THREAD_CTRL_STARTUP:
        return rt_thread_startup(thread);
 801526a:	68f8      	ldr	r0, [r7, #12]
 801526c:	f7ff fe96 	bl	8014f9c <rt_thread_startup>
 8015270:	4603      	mov	r3, r0
 8015272:	e005      	b.n	8015280 <rt_thread_control+0xa4>

#ifdef RT_USING_HEAP
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
 8015274:	68f8      	ldr	r0, [r7, #12]
 8015276:	f7ff ff01 	bl	801507c <rt_thread_delete>
 801527a:	4603      	mov	r3, r0
 801527c:	e000      	b.n	8015280 <rt_thread_control+0xa4>

    default:
        break;
    }

    return RT_EOK;
 801527e:	2300      	movs	r3, #0
}
 8015280:	4618      	mov	r0, r3
 8015282:	3714      	adds	r7, #20
 8015284:	46bd      	mov	sp, r7
 8015286:	bd90      	pop	{r4, r7, pc}
 8015288:	08023314 	.word	0x08023314
 801528c:	08024ff0 	.word	0x08024ff0

08015290 <rt_thread_suspend>:
 *
 * @note if suspend self thread, after this function call, the
 * rt_schedule() must be invoked.
 */
rt_err_t rt_thread_suspend(rt_thread_t thread)
{
 8015290:	b590      	push	{r4, r7, lr}
 8015292:	b083      	sub	sp, #12
 8015294:	af00      	add	r7, sp, #0
 8015296:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8015298:	687b      	ldr	r3, [r7, #4]
 801529a:	2b00      	cmp	r3, #0
 801529c:	d105      	bne.n	80152aa <rt_thread_suspend+0x1a>
 801529e:	4812      	ldr	r0, [pc, #72]	; (80152e8 <rt_thread_suspend+0x58>)
 80152a0:	4912      	ldr	r1, [pc, #72]	; (80152ec <rt_thread_suspend+0x5c>)
 80152a2:	f240 222f 	movw	r2, #559	; 0x22f
 80152a6:	f7fe fd5d 	bl	8013d64 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_READY)
 80152aa:	687b      	ldr	r3, [r7, #4]
 80152ac:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80152b0:	2b01      	cmp	r3, #1
 80152b2:	d002      	beq.n	80152ba <rt_thread_suspend+0x2a>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
 80152b4:	f04f 33ff 	mov.w	r3, #4294967295
 80152b8:	e012      	b.n	80152e0 <rt_thread_suspend+0x50>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80152ba:	f7ea ff85 	bl	80001c8 <rt_hw_interrupt_disable>
 80152be:	4604      	mov	r4, r0

    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
 80152c0:	687b      	ldr	r3, [r7, #4]
 80152c2:	2202      	movs	r2, #2
 80152c4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    rt_schedule_remove_thread(thread);
 80152c8:	6878      	ldr	r0, [r7, #4]
 80152ca:	f7ff fcb3 	bl	8014c34 <rt_schedule_remove_thread>

    /* stop thread timer anyway */
    rt_timer_stop(&(thread->thread_timer));
 80152ce:	687b      	ldr	r3, [r7, #4]
 80152d0:	334c      	adds	r3, #76	; 0x4c
 80152d2:	4618      	mov	r0, r3
 80152d4:	f000 fa9c 	bl	8015810 <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 80152d8:	4620      	mov	r0, r4
 80152da:	f7ea ff79 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 80152de:	2300      	movs	r3, #0
}
 80152e0:	4618      	mov	r0, r3
 80152e2:	370c      	adds	r7, #12
 80152e4:	46bd      	mov	sp, r7
 80152e6:	bd90      	pop	{r4, r7, pc}
 80152e8:	08023314 	.word	0x08023314
 80152ec:	08025004 	.word	0x08025004

080152f0 <rt_thread_resume>:
 * @param thread the thread to be resumed
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_resume(rt_thread_t thread)
{
 80152f0:	b590      	push	{r4, r7, lr}
 80152f2:	b083      	sub	sp, #12
 80152f4:	af00      	add	r7, sp, #0
 80152f6:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 80152f8:	687b      	ldr	r3, [r7, #4]
 80152fa:	2b00      	cmp	r3, #0
 80152fc:	d105      	bne.n	801530a <rt_thread_resume+0x1a>
 80152fe:	4813      	ldr	r0, [pc, #76]	; (801534c <rt_thread_resume+0x5c>)
 8015300:	4913      	ldr	r1, [pc, #76]	; (8015350 <rt_thread_resume+0x60>)
 8015302:	f44f 7216 	mov.w	r2, #600	; 0x258
 8015306:	f7fe fd2d 	bl	8013d64 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_SUSPEND)
 801530a:	687b      	ldr	r3, [r7, #4]
 801530c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8015310:	2b02      	cmp	r3, #2
 8015312:	d002      	beq.n	801531a <rt_thread_resume+0x2a>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
 8015314:	f04f 33ff 	mov.w	r3, #4294967295
 8015318:	e013      	b.n	8015342 <rt_thread_resume+0x52>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 801531a:	f7ea ff55 	bl	80001c8 <rt_hw_interrupt_disable>
 801531e:	4604      	mov	r4, r0

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
 8015320:	687b      	ldr	r3, [r7, #4]
 8015322:	3314      	adds	r3, #20
 8015324:	4618      	mov	r0, r3
 8015326:	f7ff fd33 	bl	8014d90 <rt_list_remove>

    rt_timer_stop(&thread->thread_timer);
 801532a:	687b      	ldr	r3, [r7, #4]
 801532c:	334c      	adds	r3, #76	; 0x4c
 801532e:	4618      	mov	r0, r3
 8015330:	f000 fa6e 	bl	8015810 <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8015334:	4620      	mov	r0, r4
 8015336:	f7ea ff4b 	bl	80001d0 <rt_hw_interrupt_enable>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
 801533a:	6878      	ldr	r0, [r7, #4]
 801533c:	f7ff fc44 	bl	8014bc8 <rt_schedule_insert_thread>

    return RT_EOK;
 8015340:	2300      	movs	r3, #0
}
 8015342:	4618      	mov	r0, r3
 8015344:	370c      	adds	r7, #12
 8015346:	46bd      	mov	sp, r7
 8015348:	bd90      	pop	{r4, r7, pc}
 801534a:	bf00      	nop
 801534c:	08023314 	.word	0x08023314
 8015350:	08025018 	.word	0x08025018

08015354 <rt_thread_timeout>:
 * when thread is timeout to wait some resource.
 *
 * @param parameter the parameter of thread timeout function
 */
void rt_thread_timeout(void *parameter)
{
 8015354:	b580      	push	{r7, lr}
 8015356:	b084      	sub	sp, #16
 8015358:	af00      	add	r7, sp, #0
 801535a:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;

    thread = (struct rt_thread *)parameter;
 801535c:	687b      	ldr	r3, [r7, #4]
 801535e:	60fb      	str	r3, [r7, #12]

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8015360:	68fb      	ldr	r3, [r7, #12]
 8015362:	2b00      	cmp	r3, #0
 8015364:	d105      	bne.n	8015372 <rt_thread_timeout+0x1e>
 8015366:	4811      	ldr	r0, [pc, #68]	; (80153ac <rt_thread_timeout+0x58>)
 8015368:	4911      	ldr	r1, [pc, #68]	; (80153b0 <rt_thread_timeout+0x5c>)
 801536a:	f240 2283 	movw	r2, #643	; 0x283
 801536e:	f7fe fcf9 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
 8015372:	68fb      	ldr	r3, [r7, #12]
 8015374:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8015378:	2b02      	cmp	r3, #2
 801537a:	d005      	beq.n	8015388 <rt_thread_timeout+0x34>
 801537c:	480d      	ldr	r0, [pc, #52]	; (80153b4 <rt_thread_timeout+0x60>)
 801537e:	490c      	ldr	r1, [pc, #48]	; (80153b0 <rt_thread_timeout+0x5c>)
 8015380:	f44f 7221 	mov.w	r2, #644	; 0x284
 8015384:	f7fe fcee 	bl	8013d64 <rt_assert_handler>

    /* set error number */
    thread->error = -RT_ETIMEOUT;
 8015388:	68fb      	ldr	r3, [r7, #12]
 801538a:	f06f 0201 	mvn.w	r2, #1
 801538e:	631a      	str	r2, [r3, #48]	; 0x30

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
 8015390:	68fb      	ldr	r3, [r7, #12]
 8015392:	3314      	adds	r3, #20
 8015394:	4618      	mov	r0, r3
 8015396:	f7ff fcfb 	bl	8014d90 <rt_list_remove>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
 801539a:	68f8      	ldr	r0, [r7, #12]
 801539c:	f7ff fc14 	bl	8014bc8 <rt_schedule_insert_thread>

    /* do schedule */
    rt_schedule();
 80153a0:	f7ff fbb4 	bl	8014b0c <rt_schedule>
}
 80153a4:	3710      	adds	r7, #16
 80153a6:	46bd      	mov	sp, r7
 80153a8:	bd80      	pop	{r7, pc}
 80153aa:	bf00      	nop
 80153ac:	08023314 	.word	0x08023314
 80153b0:	0802502c 	.word	0x0802502c
 80153b4:	08023360 	.word	0x08023360

080153b8 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 80153b8:	b480      	push	{r7}
 80153ba:	b083      	sub	sp, #12
 80153bc:	af00      	add	r7, sp, #0
 80153be:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 80153c0:	687b      	ldr	r3, [r7, #4]
 80153c2:	687a      	ldr	r2, [r7, #4]
 80153c4:	605a      	str	r2, [r3, #4]
 80153c6:	687b      	ldr	r3, [r7, #4]
 80153c8:	685a      	ldr	r2, [r3, #4]
 80153ca:	687b      	ldr	r3, [r7, #4]
 80153cc:	601a      	str	r2, [r3, #0]
}
 80153ce:	370c      	adds	r7, #12
 80153d0:	46bd      	mov	sp, r7
 80153d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80153d6:	4770      	bx	lr

080153d8 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 80153d8:	b480      	push	{r7}
 80153da:	b083      	sub	sp, #12
 80153dc:	af00      	add	r7, sp, #0
 80153de:	6078      	str	r0, [r7, #4]
 80153e0:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 80153e2:	687b      	ldr	r3, [r7, #4]
 80153e4:	681b      	ldr	r3, [r3, #0]
 80153e6:	683a      	ldr	r2, [r7, #0]
 80153e8:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 80153ea:	687b      	ldr	r3, [r7, #4]
 80153ec:	681a      	ldr	r2, [r3, #0]
 80153ee:	683b      	ldr	r3, [r7, #0]
 80153f0:	601a      	str	r2, [r3, #0]

    l->next = n;
 80153f2:	687b      	ldr	r3, [r7, #4]
 80153f4:	683a      	ldr	r2, [r7, #0]
 80153f6:	601a      	str	r2, [r3, #0]
    n->prev = l;
 80153f8:	683b      	ldr	r3, [r7, #0]
 80153fa:	687a      	ldr	r2, [r7, #4]
 80153fc:	605a      	str	r2, [r3, #4]
}
 80153fe:	370c      	adds	r7, #12
 8015400:	46bd      	mov	sp, r7
 8015402:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015406:	4770      	bx	lr

08015408 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8015408:	b480      	push	{r7}
 801540a:	b083      	sub	sp, #12
 801540c:	af00      	add	r7, sp, #0
 801540e:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8015410:	687b      	ldr	r3, [r7, #4]
 8015412:	681b      	ldr	r3, [r3, #0]
 8015414:	687a      	ldr	r2, [r7, #4]
 8015416:	6852      	ldr	r2, [r2, #4]
 8015418:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 801541a:	687b      	ldr	r3, [r7, #4]
 801541c:	685b      	ldr	r3, [r3, #4]
 801541e:	687a      	ldr	r2, [r7, #4]
 8015420:	6812      	ldr	r2, [r2, #0]
 8015422:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8015424:	687b      	ldr	r3, [r7, #4]
 8015426:	687a      	ldr	r2, [r7, #4]
 8015428:	605a      	str	r2, [r3, #4]
 801542a:	687b      	ldr	r3, [r7, #4]
 801542c:	685a      	ldr	r2, [r3, #4]
 801542e:	687b      	ldr	r3, [r7, #4]
 8015430:	601a      	str	r2, [r3, #0]
}
 8015432:	370c      	adds	r7, #12
 8015434:	46bd      	mov	sp, r7
 8015436:	f85d 7b04 	ldr.w	r7, [sp], #4
 801543a:	4770      	bx	lr

0801543c <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 801543c:	b480      	push	{r7}
 801543e:	b083      	sub	sp, #12
 8015440:	af00      	add	r7, sp, #0
 8015442:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8015444:	687b      	ldr	r3, [r7, #4]
 8015446:	681a      	ldr	r2, [r3, #0]
 8015448:	687b      	ldr	r3, [r7, #4]
 801544a:	429a      	cmp	r2, r3
 801544c:	bf0c      	ite	eq
 801544e:	2301      	moveq	r3, #1
 8015450:	2300      	movne	r3, #0
 8015452:	b2db      	uxtb	r3, r3
}
 8015454:	4618      	mov	r0, r3
 8015456:	370c      	adds	r7, #12
 8015458:	46bd      	mov	sp, r7
 801545a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801545e:	4770      	bx	lr

08015460 <_rt_timer_init>:
static void _rt_timer_init(rt_timer_t timer,
                           void (*timeout)(void *parameter),
                           void      *parameter,
                           rt_tick_t  time,
                           rt_uint8_t flag)
{
 8015460:	b580      	push	{r7, lr}
 8015462:	b086      	sub	sp, #24
 8015464:	af00      	add	r7, sp, #0
 8015466:	60f8      	str	r0, [r7, #12]
 8015468:	60b9      	str	r1, [r7, #8]
 801546a:	607a      	str	r2, [r7, #4]
 801546c:	603b      	str	r3, [r7, #0]
    int i;

    /* set flag */
    timer->parent.flag  = flag;
 801546e:	68fb      	ldr	r3, [r7, #12]
 8015470:	f897 2020 	ldrb.w	r2, [r7, #32]
 8015474:	725a      	strb	r2, [r3, #9]

    /* set deactivated */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8015476:	68fb      	ldr	r3, [r7, #12]
 8015478:	7a5b      	ldrb	r3, [r3, #9]
 801547a:	f023 0301 	bic.w	r3, r3, #1
 801547e:	b2da      	uxtb	r2, r3
 8015480:	68fb      	ldr	r3, [r7, #12]
 8015482:	725a      	strb	r2, [r3, #9]

    timer->timeout_func = timeout;
 8015484:	68fb      	ldr	r3, [r7, #12]
 8015486:	68ba      	ldr	r2, [r7, #8]
 8015488:	61da      	str	r2, [r3, #28]
    timer->parameter    = parameter;
 801548a:	68fb      	ldr	r3, [r7, #12]
 801548c:	687a      	ldr	r2, [r7, #4]
 801548e:	621a      	str	r2, [r3, #32]

    timer->timeout_tick = 0;
 8015490:	68fb      	ldr	r3, [r7, #12]
 8015492:	2200      	movs	r2, #0
 8015494:	629a      	str	r2, [r3, #40]	; 0x28
    timer->init_tick    = time;
 8015496:	68fb      	ldr	r3, [r7, #12]
 8015498:	683a      	ldr	r2, [r7, #0]
 801549a:	625a      	str	r2, [r3, #36]	; 0x24

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 801549c:	2300      	movs	r3, #0
 801549e:	617b      	str	r3, [r7, #20]
 80154a0:	e00b      	b.n	80154ba <_rt_timer_init+0x5a>
    {
        rt_list_init(&(timer->row[i]));
 80154a2:	697b      	ldr	r3, [r7, #20]
 80154a4:	3302      	adds	r3, #2
 80154a6:	00db      	lsls	r3, r3, #3
 80154a8:	68fa      	ldr	r2, [r7, #12]
 80154aa:	4413      	add	r3, r2
 80154ac:	3304      	adds	r3, #4
 80154ae:	4618      	mov	r0, r3
 80154b0:	f7ff ff82 	bl	80153b8 <rt_list_init>

    timer->timeout_tick = 0;
    timer->init_tick    = time;

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 80154b4:	697b      	ldr	r3, [r7, #20]
 80154b6:	3301      	adds	r3, #1
 80154b8:	617b      	str	r3, [r7, #20]
 80154ba:	697b      	ldr	r3, [r7, #20]
 80154bc:	2b00      	cmp	r3, #0
 80154be:	ddf0      	ble.n	80154a2 <_rt_timer_init+0x42>
    {
        rt_list_init(&(timer->row[i]));
    }
}
 80154c0:	3718      	adds	r7, #24
 80154c2:	46bd      	mov	sp, r7
 80154c4:	bd80      	pop	{r7, pc}
 80154c6:	bf00      	nop

080154c8 <rt_timer_list_next_timeout>:

/* the fist timer always in the last row */
static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
{
 80154c8:	b580      	push	{r7, lr}
 80154ca:	b084      	sub	sp, #16
 80154cc:	af00      	add	r7, sp, #0
 80154ce:	6078      	str	r0, [r7, #4]
    struct rt_timer *timer;

    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
 80154d0:	6878      	ldr	r0, [r7, #4]
 80154d2:	f7ff ffb3 	bl	801543c <rt_list_isempty>
 80154d6:	4603      	mov	r3, r0
 80154d8:	2b00      	cmp	r3, #0
 80154da:	d002      	beq.n	80154e2 <rt_timer_list_next_timeout+0x1a>
        return RT_TICK_MAX;
 80154dc:	f04f 33ff 	mov.w	r3, #4294967295
 80154e0:	e005      	b.n	80154ee <rt_timer_list_next_timeout+0x26>

    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
 80154e2:	687b      	ldr	r3, [r7, #4]
 80154e4:	681b      	ldr	r3, [r3, #0]
 80154e6:	3b14      	subs	r3, #20
 80154e8:	60fb      	str	r3, [r7, #12]
                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);

    return timer->timeout_tick;
 80154ea:	68fb      	ldr	r3, [r7, #12]
 80154ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 80154ee:	4618      	mov	r0, r3
 80154f0:	3710      	adds	r7, #16
 80154f2:	46bd      	mov	sp, r7
 80154f4:	bd80      	pop	{r7, pc}
 80154f6:	bf00      	nop

080154f8 <_rt_timer_remove>:

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
 80154f8:	b580      	push	{r7, lr}
 80154fa:	b084      	sub	sp, #16
 80154fc:	af00      	add	r7, sp, #0
 80154fe:	6078      	str	r0, [r7, #4]
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 8015500:	2300      	movs	r3, #0
 8015502:	60fb      	str	r3, [r7, #12]
 8015504:	e00b      	b.n	801551e <_rt_timer_remove+0x26>
    {
        rt_list_remove(&timer->row[i]);
 8015506:	68fb      	ldr	r3, [r7, #12]
 8015508:	3302      	adds	r3, #2
 801550a:	00db      	lsls	r3, r3, #3
 801550c:	687a      	ldr	r2, [r7, #4]
 801550e:	4413      	add	r3, r2
 8015510:	3304      	adds	r3, #4
 8015512:	4618      	mov	r0, r3
 8015514:	f7ff ff78 	bl	8015408 <rt_list_remove>

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 8015518:	68fb      	ldr	r3, [r7, #12]
 801551a:	3301      	adds	r3, #1
 801551c:	60fb      	str	r3, [r7, #12]
 801551e:	68fb      	ldr	r3, [r7, #12]
 8015520:	2b00      	cmp	r3, #0
 8015522:	ddf0      	ble.n	8015506 <_rt_timer_remove+0xe>
    {
        rt_list_remove(&timer->row[i]);
    }
}
 8015524:	3710      	adds	r7, #16
 8015526:	46bd      	mov	sp, r7
 8015528:	bd80      	pop	{r7, pc}
 801552a:	bf00      	nop

0801552c <rt_timer_init>:
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
 801552c:	b580      	push	{r7, lr}
 801552e:	b086      	sub	sp, #24
 8015530:	af02      	add	r7, sp, #8
 8015532:	60f8      	str	r0, [r7, #12]
 8015534:	60b9      	str	r1, [r7, #8]
 8015536:	607a      	str	r2, [r7, #4]
 8015538:	603b      	str	r3, [r7, #0]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 801553a:	68fb      	ldr	r3, [r7, #12]
 801553c:	2b00      	cmp	r3, #0
 801553e:	d104      	bne.n	801554a <rt_timer_init+0x1e>
 8015540:	480a      	ldr	r0, [pc, #40]	; (801556c <rt_timer_init+0x40>)
 8015542:	490b      	ldr	r1, [pc, #44]	; (8015570 <rt_timer_init+0x44>)
 8015544:	22bc      	movs	r2, #188	; 0xbc
 8015546:	f7fe fc0d 	bl	8013d64 <rt_assert_handler>

    /* timer object initialization */
    rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
 801554a:	68f8      	ldr	r0, [r7, #12]
 801554c:	2109      	movs	r1, #9
 801554e:	68ba      	ldr	r2, [r7, #8]
 8015550:	f7ff f8e8 	bl	8014724 <rt_object_init>

    _rt_timer_init(timer, timeout, parameter, time, flag);
 8015554:	7f3b      	ldrb	r3, [r7, #28]
 8015556:	9300      	str	r3, [sp, #0]
 8015558:	68f8      	ldr	r0, [r7, #12]
 801555a:	6879      	ldr	r1, [r7, #4]
 801555c:	683a      	ldr	r2, [r7, #0]
 801555e:	69bb      	ldr	r3, [r7, #24]
 8015560:	f7ff ff7e 	bl	8015460 <_rt_timer_init>
}
 8015564:	3710      	adds	r7, #16
 8015566:	46bd      	mov	sp, r7
 8015568:	bd80      	pop	{r7, pc}
 801556a:	bf00      	nop
 801556c:	08023384 	.word	0x08023384
 8015570:	08025040 	.word	0x08025040

08015574 <rt_timer_detach>:
 * @param timer the static timer object
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
{
 8015574:	b590      	push	{r4, r7, lr}
 8015576:	b083      	sub	sp, #12
 8015578:	af00      	add	r7, sp, #0
 801557a:	6078      	str	r0, [r7, #4]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 801557c:	687b      	ldr	r3, [r7, #4]
 801557e:	2b00      	cmp	r3, #0
 8015580:	d104      	bne.n	801558c <rt_timer_detach+0x18>
 8015582:	480b      	ldr	r0, [pc, #44]	; (80155b0 <rt_timer_detach+0x3c>)
 8015584:	490b      	ldr	r1, [pc, #44]	; (80155b4 <rt_timer_detach+0x40>)
 8015586:	22d1      	movs	r2, #209	; 0xd1
 8015588:	f7fe fbec 	bl	8013d64 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 801558c:	f7ea fe1c 	bl	80001c8 <rt_hw_interrupt_disable>
 8015590:	4604      	mov	r4, r0

    _rt_timer_remove(timer);
 8015592:	6878      	ldr	r0, [r7, #4]
 8015594:	f7ff ffb0 	bl	80154f8 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8015598:	4620      	mov	r0, r4
 801559a:	f7ea fe19 	bl	80001d0 <rt_hw_interrupt_enable>

    rt_object_detach((rt_object_t)timer);
 801559e:	6878      	ldr	r0, [r7, #4]
 80155a0:	f7ff f8f6 	bl	8014790 <rt_object_detach>

    return -RT_EOK;
 80155a4:	2300      	movs	r3, #0
}
 80155a6:	4618      	mov	r0, r3
 80155a8:	370c      	adds	r7, #12
 80155aa:	46bd      	mov	sp, r7
 80155ac:	bd90      	pop	{r4, r7, pc}
 80155ae:	bf00      	nop
 80155b0:	08023384 	.word	0x08023384
 80155b4:	08025050 	.word	0x08025050

080155b8 <rt_timer_create>:
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
{
 80155b8:	b580      	push	{r7, lr}
 80155ba:	b088      	sub	sp, #32
 80155bc:	af02      	add	r7, sp, #8
 80155be:	60f8      	str	r0, [r7, #12]
 80155c0:	60b9      	str	r1, [r7, #8]
 80155c2:	607a      	str	r2, [r7, #4]
 80155c4:	603b      	str	r3, [r7, #0]
    struct rt_timer *timer;

    /* allocate a object */
    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
 80155c6:	2009      	movs	r0, #9
 80155c8:	68f9      	ldr	r1, [r7, #12]
 80155ca:	f7ff f909 	bl	80147e0 <rt_object_allocate>
 80155ce:	6178      	str	r0, [r7, #20]
    if (timer == RT_NULL)
 80155d0:	697b      	ldr	r3, [r7, #20]
 80155d2:	2b00      	cmp	r3, #0
 80155d4:	d101      	bne.n	80155da <rt_timer_create+0x22>
    {
        return RT_NULL;
 80155d6:	2300      	movs	r3, #0
 80155d8:	e009      	b.n	80155ee <rt_timer_create+0x36>
    }

    _rt_timer_init(timer, timeout, parameter, time, flag);
 80155da:	f897 3020 	ldrb.w	r3, [r7, #32]
 80155de:	9300      	str	r3, [sp, #0]
 80155e0:	6978      	ldr	r0, [r7, #20]
 80155e2:	68b9      	ldr	r1, [r7, #8]
 80155e4:	687a      	ldr	r2, [r7, #4]
 80155e6:	683b      	ldr	r3, [r7, #0]
 80155e8:	f7ff ff3a 	bl	8015460 <_rt_timer_init>

    return timer;
 80155ec:	697b      	ldr	r3, [r7, #20]
}
 80155ee:	4618      	mov	r0, r3
 80155f0:	3718      	adds	r7, #24
 80155f2:	46bd      	mov	sp, r7
 80155f4:	bd80      	pop	{r7, pc}
 80155f6:	bf00      	nop

080155f8 <rt_timer_start>:
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
{
 80155f8:	b590      	push	{r4, r7, lr}
 80155fa:	b089      	sub	sp, #36	; 0x24
 80155fc:	af00      	add	r7, sp, #0
 80155fe:	6078      	str	r0, [r7, #4]
    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
    unsigned int tst_nr;
    static unsigned int random_nr;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8015600:	687b      	ldr	r3, [r7, #4]
 8015602:	2b00      	cmp	r3, #0
 8015604:	d105      	bne.n	8015612 <rt_timer_start+0x1a>
 8015606:	4879      	ldr	r0, [pc, #484]	; (80157ec <rt_timer_start+0x1f4>)
 8015608:	4979      	ldr	r1, [pc, #484]	; (80157f0 <rt_timer_start+0x1f8>)
 801560a:	f44f 7298 	mov.w	r2, #304	; 0x130
 801560e:	f7fe fba9 	bl	8013d64 <rt_assert_handler>

	/* stop timer firstly */
	level = rt_hw_interrupt_disable();
 8015612:	f7ea fdd9 	bl	80001c8 <rt_hw_interrupt_disable>
 8015616:	4604      	mov	r4, r0
	/* remove timer from list */
    _rt_timer_remove(timer);
 8015618:	6878      	ldr	r0, [r7, #4]
 801561a:	f7ff ff6d 	bl	80154f8 <_rt_timer_remove>
    /* change status of timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 801561e:	687b      	ldr	r3, [r7, #4]
 8015620:	7a5b      	ldrb	r3, [r3, #9]
 8015622:	f023 0301 	bic.w	r3, r3, #1
 8015626:	b2da      	uxtb	r2, r3
 8015628:	687b      	ldr	r3, [r7, #4]
 801562a:	725a      	strb	r2, [r3, #9]
    rt_hw_interrupt_enable(level);
 801562c:	4620      	mov	r0, r4
 801562e:	f7ea fdcf 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
 8015632:	4b70      	ldr	r3, [pc, #448]	; (80157f4 <rt_timer_start+0x1fc>)
 8015634:	681b      	ldr	r3, [r3, #0]
 8015636:	2b00      	cmp	r3, #0
 8015638:	d004      	beq.n	8015644 <rt_timer_start+0x4c>
 801563a:	4b6e      	ldr	r3, [pc, #440]	; (80157f4 <rt_timer_start+0x1fc>)
 801563c:	681b      	ldr	r3, [r3, #0]
 801563e:	687a      	ldr	r2, [r7, #4]
 8015640:	4610      	mov	r0, r2
 8015642:	4798      	blx	r3

    /*
     * get timeout tick,
     * the max timeout tick shall not great than RT_TICK_MAX/2
     */
    RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
 8015644:	687b      	ldr	r3, [r7, #4]
 8015646:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015648:	4a6b      	ldr	r2, [pc, #428]	; (80157f8 <rt_timer_start+0x200>)
 801564a:	4293      	cmp	r3, r2
 801564c:	d905      	bls.n	801565a <rt_timer_start+0x62>
 801564e:	486b      	ldr	r0, [pc, #428]	; (80157fc <rt_timer_start+0x204>)
 8015650:	4967      	ldr	r1, [pc, #412]	; (80157f0 <rt_timer_start+0x1f8>)
 8015652:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8015656:	f7fe fb85 	bl	8013d64 <rt_assert_handler>
    timer->timeout_tick = rt_tick_get() + timer->init_tick;
 801565a:	f7fc fbc5 	bl	8011de8 <rt_tick_get>
 801565e:	4602      	mov	r2, r0
 8015660:	687b      	ldr	r3, [r7, #4]
 8015662:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015664:	441a      	add	r2, r3
 8015666:	687b      	ldr	r3, [r7, #4]
 8015668:	629a      	str	r2, [r3, #40]	; 0x28

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 801566a:	f7ea fdad 	bl	80001c8 <rt_hw_interrupt_disable>
 801566e:	4604      	mov	r4, r0

#ifdef RT_USING_TIMER_SOFT
    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
 8015670:	687b      	ldr	r3, [r7, #4]
 8015672:	7a5b      	ldrb	r3, [r3, #9]
 8015674:	f003 0304 	and.w	r3, r3, #4
 8015678:	2b00      	cmp	r3, #0
 801567a:	d002      	beq.n	8015682 <rt_timer_start+0x8a>
    {
        /* insert timer to soft timer list */
        timer_list = rt_soft_timer_list;
 801567c:	4b60      	ldr	r3, [pc, #384]	; (8015800 <rt_timer_start+0x208>)
 801567e:	61bb      	str	r3, [r7, #24]
 8015680:	e001      	b.n	8015686 <rt_timer_start+0x8e>
    }
    else
#endif
    {
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
 8015682:	4b60      	ldr	r3, [pc, #384]	; (8015804 <rt_timer_start+0x20c>)
 8015684:	61bb      	str	r3, [r7, #24]
    }

    row_head[0]  = &timer_list[0];
 8015686:	69bb      	ldr	r3, [r7, #24]
 8015688:	60bb      	str	r3, [r7, #8]
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 801568a:	2300      	movs	r3, #0
 801568c:	61fb      	str	r3, [r7, #28]
 801568e:	e054      	b.n	801573a <rt_timer_start+0x142>
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
 8015690:	e02e      	b.n	80156f0 <rt_timer_start+0xf8>
             row_head[row_lvl]  = row_head[row_lvl]->next)
        {
            struct rt_timer *t;
            rt_list_t *p = row_head[row_lvl]->next;
 8015692:	69fb      	ldr	r3, [r7, #28]
 8015694:	009b      	lsls	r3, r3, #2
 8015696:	f107 0220 	add.w	r2, r7, #32
 801569a:	4413      	add	r3, r2
 801569c:	f853 3c18 	ldr.w	r3, [r3, #-24]
 80156a0:	681b      	ldr	r3, [r3, #0]
 80156a2:	613b      	str	r3, [r7, #16]

            /* fix up the entry pointer */
            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
 80156a4:	69fb      	ldr	r3, [r7, #28]
 80156a6:	00db      	lsls	r3, r3, #3
 80156a8:	3314      	adds	r3, #20
 80156aa:	425b      	negs	r3, r3
 80156ac:	693a      	ldr	r2, [r7, #16]
 80156ae:	4413      	add	r3, r2
 80156b0:	60fb      	str	r3, [r7, #12]
            /* If we have two timers that timeout at the same time, it's
             * preferred that the timer inserted early get called early.
             * So insert the new timer to the end the the some-timeout timer
             * list.
             */
            if ((t->timeout_tick - timer->timeout_tick) == 0)
 80156b2:	68fb      	ldr	r3, [r7, #12]
 80156b4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80156b6:	687b      	ldr	r3, [r7, #4]
 80156b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80156ba:	429a      	cmp	r2, r3
 80156bc:	d100      	bne.n	80156c0 <rt_timer_start+0xc8>
            {
                continue;
 80156be:	e008      	b.n	80156d2 <rt_timer_start+0xda>
            }
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
 80156c0:	68fb      	ldr	r3, [r7, #12]
 80156c2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80156c4:	687b      	ldr	r3, [r7, #4]
 80156c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80156c8:	1ad3      	subs	r3, r2, r3
 80156ca:	4a4b      	ldr	r2, [pc, #300]	; (80157f8 <rt_timer_start+0x200>)
 80156cc:	4293      	cmp	r3, r2
 80156ce:	d800      	bhi.n	80156d2 <rt_timer_start+0xda>
            {
                break;
 80156d0:	e01c      	b.n	801570c <rt_timer_start+0x114>

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
             row_head[row_lvl]  = row_head[row_lvl]->next)
 80156d2:	69fb      	ldr	r3, [r7, #28]
 80156d4:	009b      	lsls	r3, r3, #2
 80156d6:	f107 0220 	add.w	r2, r7, #32
 80156da:	4413      	add	r3, r2
 80156dc:	f853 3c18 	ldr.w	r3, [r3, #-24]
 80156e0:	681a      	ldr	r2, [r3, #0]
 80156e2:	69fb      	ldr	r3, [r7, #28]
 80156e4:	009b      	lsls	r3, r3, #2
 80156e6:	f107 0120 	add.w	r1, r7, #32
 80156ea:	440b      	add	r3, r1
 80156ec:	f843 2c18 	str.w	r2, [r3, #-24]
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
 80156f0:	69fb      	ldr	r3, [r7, #28]
 80156f2:	009b      	lsls	r3, r3, #2
 80156f4:	f107 0220 	add.w	r2, r7, #32
 80156f8:	4413      	add	r3, r2
 80156fa:	f853 2c18 	ldr.w	r2, [r3, #-24]
 80156fe:	69fb      	ldr	r3, [r7, #28]
 8015700:	00db      	lsls	r3, r3, #3
 8015702:	69b9      	ldr	r1, [r7, #24]
 8015704:	440b      	add	r3, r1
 8015706:	685b      	ldr	r3, [r3, #4]
 8015708:	429a      	cmp	r2, r3
 801570a:	d1c2      	bne.n	8015692 <rt_timer_start+0x9a>
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
            {
                break;
            }
        }
        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
 801570c:	69fb      	ldr	r3, [r7, #28]
 801570e:	2b00      	cmp	r3, #0
 8015710:	d010      	beq.n	8015734 <rt_timer_start+0x13c>
            row_head[row_lvl+1] = row_head[row_lvl]+1;
 8015712:	69fb      	ldr	r3, [r7, #28]
 8015714:	1c59      	adds	r1, r3, #1
 8015716:	69fb      	ldr	r3, [r7, #28]
 8015718:	009b      	lsls	r3, r3, #2
 801571a:	f107 0220 	add.w	r2, r7, #32
 801571e:	4413      	add	r3, r2
 8015720:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8015724:	f103 0208 	add.w	r2, r3, #8
 8015728:	008b      	lsls	r3, r1, #2
 801572a:	f107 0120 	add.w	r1, r7, #32
 801572e:	440b      	add	r3, r1
 8015730:	f843 2c18 	str.w	r2, [r3, #-24]
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 8015734:	69fb      	ldr	r3, [r7, #28]
 8015736:	3301      	adds	r3, #1
 8015738:	61fb      	str	r3, [r7, #28]
 801573a:	69fb      	ldr	r3, [r7, #28]
 801573c:	2b00      	cmp	r3, #0
 801573e:	d0a7      	beq.n	8015690 <rt_timer_start+0x98>

    /* Interestingly, this super simple timer insert counter works very very
     * well on distributing the list height uniformly. By means of "very very
     * well", I mean it beats the randomness of timer->timeout_tick very easily
     * (actually, the timeout_tick is not random and easy to be attacked). */
    random_nr++;
 8015740:	4b31      	ldr	r3, [pc, #196]	; (8015808 <rt_timer_start+0x210>)
 8015742:	681b      	ldr	r3, [r3, #0]
 8015744:	3301      	adds	r3, #1
 8015746:	4a30      	ldr	r2, [pc, #192]	; (8015808 <rt_timer_start+0x210>)
 8015748:	6013      	str	r3, [r2, #0]
    tst_nr = random_nr;
 801574a:	4b2f      	ldr	r3, [pc, #188]	; (8015808 <rt_timer_start+0x210>)
 801574c:	681b      	ldr	r3, [r3, #0]
 801574e:	617b      	str	r3, [r7, #20]

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
 8015750:	68ba      	ldr	r2, [r7, #8]
 8015752:	687b      	ldr	r3, [r7, #4]
 8015754:	3314      	adds	r3, #20
 8015756:	4610      	mov	r0, r2
 8015758:	4619      	mov	r1, r3
 801575a:	f7ff fe3d 	bl	80153d8 <rt_list_insert_after>
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 801575e:	2302      	movs	r3, #2
 8015760:	61fb      	str	r3, [r7, #28]
 8015762:	e021      	b.n	80157a8 <rt_timer_start+0x1b0>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
 8015764:	697b      	ldr	r3, [r7, #20]
 8015766:	f003 0303 	and.w	r3, r3, #3
 801576a:	2b00      	cmp	r3, #0
 801576c:	d115      	bne.n	801579a <rt_timer_start+0x1a2>
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
 801576e:	69fb      	ldr	r3, [r7, #28]
 8015770:	f1c3 0301 	rsb	r3, r3, #1
 8015774:	009b      	lsls	r3, r3, #2
 8015776:	f107 0220 	add.w	r2, r7, #32
 801577a:	4413      	add	r3, r2
 801577c:	f853 1c18 	ldr.w	r1, [r3, #-24]
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
 8015780:	69fb      	ldr	r3, [r7, #28]
 8015782:	f1c3 0301 	rsb	r3, r3, #1
    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
 8015786:	3302      	adds	r3, #2
 8015788:	00db      	lsls	r3, r3, #3
 801578a:	687a      	ldr	r2, [r7, #4]
 801578c:	4413      	add	r3, r2
 801578e:	3304      	adds	r3, #4
 8015790:	4608      	mov	r0, r1
 8015792:	4619      	mov	r1, r3
 8015794:	f7ff fe20 	bl	80153d8 <rt_list_insert_after>
 8015798:	e000      	b.n	801579c <rt_timer_start+0x1a4>
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
        else
            break;
 801579a:	e008      	b.n	80157ae <rt_timer_start+0x1b6>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
 801579c:	697b      	ldr	r3, [r7, #20]
 801579e:	089b      	lsrs	r3, r3, #2
 80157a0:	617b      	str	r3, [r7, #20]
    random_nr++;
    tst_nr = random_nr;

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 80157a2:	69fb      	ldr	r3, [r7, #28]
 80157a4:	3301      	adds	r3, #1
 80157a6:	61fb      	str	r3, [r7, #28]
 80157a8:	69fb      	ldr	r3, [r7, #28]
 80157aa:	2b01      	cmp	r3, #1
 80157ac:	d9da      	bls.n	8015764 <rt_timer_start+0x16c>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
    }

    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
 80157ae:	687b      	ldr	r3, [r7, #4]
 80157b0:	7a5b      	ldrb	r3, [r3, #9]
 80157b2:	f043 0301 	orr.w	r3, r3, #1
 80157b6:	b2da      	uxtb	r2, r3
 80157b8:	687b      	ldr	r3, [r7, #4]
 80157ba:	725a      	strb	r2, [r3, #9]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 80157bc:	4620      	mov	r0, r4
 80157be:	f7ea fd07 	bl	80001d0 <rt_hw_interrupt_enable>

#ifdef RT_USING_TIMER_SOFT
    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
 80157c2:	687b      	ldr	r3, [r7, #4]
 80157c4:	7a5b      	ldrb	r3, [r3, #9]
 80157c6:	f003 0304 	and.w	r3, r3, #4
 80157ca:	2b00      	cmp	r3, #0
 80157cc:	d009      	beq.n	80157e2 <rt_timer_start+0x1ea>
    {
        /* check whether timer thread is ready */
        if (timer_thread.stat != RT_THREAD_READY)
 80157ce:	4b0f      	ldr	r3, [pc, #60]	; (801580c <rt_timer_start+0x214>)
 80157d0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80157d4:	2b01      	cmp	r3, #1
 80157d6:	d004      	beq.n	80157e2 <rt_timer_start+0x1ea>
        {
            /* resume timer thread to check soft timer */
            rt_thread_resume(&timer_thread);
 80157d8:	480c      	ldr	r0, [pc, #48]	; (801580c <rt_timer_start+0x214>)
 80157da:	f7ff fd89 	bl	80152f0 <rt_thread_resume>
            rt_schedule();
 80157de:	f7ff f995 	bl	8014b0c <rt_schedule>
        }
    }
#endif

    return -RT_EOK;
 80157e2:	2300      	movs	r3, #0
}
 80157e4:	4618      	mov	r0, r3
 80157e6:	3724      	adds	r7, #36	; 0x24
 80157e8:	46bd      	mov	sp, r7
 80157ea:	bd90      	pop	{r4, r7, pc}
 80157ec:	08023384 	.word	0x08023384
 80157f0:	08025060 	.word	0x08025060
 80157f4:	20012570 	.word	0x20012570
 80157f8:	7ffffffe 	.word	0x7ffffffe
 80157fc:	08023398 	.word	0x08023398
 8015800:	20010df0 	.word	0x20010df0
 8015804:	20010de8 	.word	0x20010de8
 8015808:	2001107c 	.word	0x2001107c
 801580c:	20010df8 	.word	0x20010df8

08015810 <rt_timer_stop>:
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
{
 8015810:	b590      	push	{r4, r7, lr}
 8015812:	b083      	sub	sp, #12
 8015814:	af00      	add	r7, sp, #0
 8015816:	6078      	str	r0, [r7, #4]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8015818:	687b      	ldr	r3, [r7, #4]
 801581a:	2b00      	cmp	r3, #0
 801581c:	d105      	bne.n	801582a <rt_timer_stop+0x1a>
 801581e:	4816      	ldr	r0, [pc, #88]	; (8015878 <rt_timer_stop+0x68>)
 8015820:	4916      	ldr	r1, [pc, #88]	; (801587c <rt_timer_stop+0x6c>)
 8015822:	f44f 72d4 	mov.w	r2, #424	; 0x1a8
 8015826:	f7fe fa9d 	bl	8013d64 <rt_assert_handler>
    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 801582a:	687b      	ldr	r3, [r7, #4]
 801582c:	7a5b      	ldrb	r3, [r3, #9]
 801582e:	f003 0301 	and.w	r3, r3, #1
 8015832:	2b00      	cmp	r3, #0
 8015834:	d102      	bne.n	801583c <rt_timer_stop+0x2c>
        return -RT_ERROR;
 8015836:	f04f 33ff 	mov.w	r3, #4294967295
 801583a:	e019      	b.n	8015870 <rt_timer_stop+0x60>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
 801583c:	4b10      	ldr	r3, [pc, #64]	; (8015880 <rt_timer_stop+0x70>)
 801583e:	681b      	ldr	r3, [r3, #0]
 8015840:	2b00      	cmp	r3, #0
 8015842:	d004      	beq.n	801584e <rt_timer_stop+0x3e>
 8015844:	4b0e      	ldr	r3, [pc, #56]	; (8015880 <rt_timer_stop+0x70>)
 8015846:	681b      	ldr	r3, [r3, #0]
 8015848:	687a      	ldr	r2, [r7, #4]
 801584a:	4610      	mov	r0, r2
 801584c:	4798      	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 801584e:	f7ea fcbb 	bl	80001c8 <rt_hw_interrupt_disable>
 8015852:	4604      	mov	r4, r0

    _rt_timer_remove(timer);
 8015854:	6878      	ldr	r0, [r7, #4]
 8015856:	f7ff fe4f 	bl	80154f8 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 801585a:	4620      	mov	r0, r4
 801585c:	f7ea fcb8 	bl	80001d0 <rt_hw_interrupt_enable>

    /* change stat */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8015860:	687b      	ldr	r3, [r7, #4]
 8015862:	7a5b      	ldrb	r3, [r3, #9]
 8015864:	f023 0301 	bic.w	r3, r3, #1
 8015868:	b2da      	uxtb	r2, r3
 801586a:	687b      	ldr	r3, [r7, #4]
 801586c:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 801586e:	2300      	movs	r3, #0
}
 8015870:	4618      	mov	r0, r3
 8015872:	370c      	adds	r7, #12
 8015874:	46bd      	mov	sp, r7
 8015876:	bd90      	pop	{r4, r7, pc}
 8015878:	08023384 	.word	0x08023384
 801587c:	08025070 	.word	0x08025070
 8015880:	2001256c 	.word	0x2001256c

08015884 <rt_timer_control>:
 * @param arg the argument
 *
 * @return RT_EOK
 */
rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
{
 8015884:	b580      	push	{r7, lr}
 8015886:	b084      	sub	sp, #16
 8015888:	af00      	add	r7, sp, #0
 801588a:	60f8      	str	r0, [r7, #12]
 801588c:	460b      	mov	r3, r1
 801588e:	607a      	str	r2, [r7, #4]
 8015890:	72fb      	strb	r3, [r7, #11]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8015892:	68fb      	ldr	r3, [r7, #12]
 8015894:	2b00      	cmp	r3, #0
 8015896:	d105      	bne.n	80158a4 <rt_timer_control+0x20>
 8015898:	4819      	ldr	r0, [pc, #100]	; (8015900 <rt_timer_control+0x7c>)
 801589a:	491a      	ldr	r1, [pc, #104]	; (8015904 <rt_timer_control+0x80>)
 801589c:	f240 12c9 	movw	r2, #457	; 0x1c9
 80158a0:	f7fe fa60 	bl	8013d64 <rt_assert_handler>

    switch (cmd)
 80158a4:	7afb      	ldrb	r3, [r7, #11]
 80158a6:	2b03      	cmp	r3, #3
 80158a8:	d824      	bhi.n	80158f4 <rt_timer_control+0x70>
 80158aa:	a201      	add	r2, pc, #4	; (adr r2, 80158b0 <rt_timer_control+0x2c>)
 80158ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80158b0:	080158cb 	.word	0x080158cb
 80158b4:	080158c1 	.word	0x080158c1
 80158b8:	080158d5 	.word	0x080158d5
 80158bc:	080158e5 	.word	0x080158e5
    {
    case RT_TIMER_CTRL_GET_TIME:
        *(rt_tick_t *)arg = timer->init_tick;
 80158c0:	68fb      	ldr	r3, [r7, #12]
 80158c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80158c4:	687b      	ldr	r3, [r7, #4]
 80158c6:	601a      	str	r2, [r3, #0]
        break;
 80158c8:	e014      	b.n	80158f4 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_TIME:
        timer->init_tick = *(rt_tick_t *)arg;
 80158ca:	687b      	ldr	r3, [r7, #4]
 80158cc:	681a      	ldr	r2, [r3, #0]
 80158ce:	68fb      	ldr	r3, [r7, #12]
 80158d0:	625a      	str	r2, [r3, #36]	; 0x24
        break;
 80158d2:	e00f      	b.n	80158f4 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_ONESHOT:
        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
 80158d4:	68fb      	ldr	r3, [r7, #12]
 80158d6:	7a5b      	ldrb	r3, [r3, #9]
 80158d8:	f023 0302 	bic.w	r3, r3, #2
 80158dc:	b2da      	uxtb	r2, r3
 80158de:	68fb      	ldr	r3, [r7, #12]
 80158e0:	725a      	strb	r2, [r3, #9]
        break;
 80158e2:	e007      	b.n	80158f4 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_PERIODIC:
        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
 80158e4:	68fb      	ldr	r3, [r7, #12]
 80158e6:	7a5b      	ldrb	r3, [r3, #9]
 80158e8:	f043 0302 	orr.w	r3, r3, #2
 80158ec:	b2da      	uxtb	r2, r3
 80158ee:	68fb      	ldr	r3, [r7, #12]
 80158f0:	725a      	strb	r2, [r3, #9]
        break;
 80158f2:	bf00      	nop
    }

    return RT_EOK;
 80158f4:	2300      	movs	r3, #0
}
 80158f6:	4618      	mov	r0, r3
 80158f8:	3710      	adds	r7, #16
 80158fa:	46bd      	mov	sp, r7
 80158fc:	bd80      	pop	{r7, pc}
 80158fe:	bf00      	nop
 8015900:	08023384 	.word	0x08023384
 8015904:	08025080 	.word	0x08025080

08015908 <rt_timer_check>:
 * corresponding timeout function will be invoked.
 *
 * @note this function shall be invoked in operating system timer interrupt.
 */
void rt_timer_check(void)
{
 8015908:	b590      	push	{r4, r7, lr}
 801590a:	b083      	sub	sp, #12
 801590c:	af00      	add	r7, sp, #0
    rt_tick_t current_tick;
    register rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));

    current_tick = rt_tick_get();
 801590e:	f7fc fa6b 	bl	8011de8 <rt_tick_get>
 8015912:	6078      	str	r0, [r7, #4]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8015914:	f7ea fc58 	bl	80001c8 <rt_hw_interrupt_disable>
 8015918:	4604      	mov	r4, r0

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
 801591a:	e03e      	b.n	801599a <rt_timer_check+0x92>
    {
        t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
 801591c:	4b25      	ldr	r3, [pc, #148]	; (80159b4 <rt_timer_check+0xac>)
 801591e:	681b      	ldr	r3, [r3, #0]
 8015920:	3b14      	subs	r3, #20
 8015922:	603b      	str	r3, [r7, #0]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
 8015924:	683b      	ldr	r3, [r7, #0]
 8015926:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015928:	687a      	ldr	r2, [r7, #4]
 801592a:	1ad3      	subs	r3, r2, r3
 801592c:	4a22      	ldr	r2, [pc, #136]	; (80159b8 <rt_timer_check+0xb0>)
 801592e:	4293      	cmp	r3, r2
 8015930:	d832      	bhi.n	8015998 <rt_timer_check+0x90>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
 8015932:	4b22      	ldr	r3, [pc, #136]	; (80159bc <rt_timer_check+0xb4>)
 8015934:	681b      	ldr	r3, [r3, #0]
 8015936:	2b00      	cmp	r3, #0
 8015938:	d003      	beq.n	8015942 <rt_timer_check+0x3a>
 801593a:	4b20      	ldr	r3, [pc, #128]	; (80159bc <rt_timer_check+0xb4>)
 801593c:	681b      	ldr	r3, [r3, #0]
 801593e:	6838      	ldr	r0, [r7, #0]
 8015940:	4798      	blx	r3

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
 8015942:	6838      	ldr	r0, [r7, #0]
 8015944:	f7ff fdd8 	bl	80154f8 <_rt_timer_remove>

            /* call timeout function */
            t->timeout_func(t->parameter);
 8015948:	683b      	ldr	r3, [r7, #0]
 801594a:	69db      	ldr	r3, [r3, #28]
 801594c:	683a      	ldr	r2, [r7, #0]
 801594e:	6a12      	ldr	r2, [r2, #32]
 8015950:	4610      	mov	r0, r2
 8015952:	4798      	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
 8015954:	f7fc fa48 	bl	8011de8 <rt_tick_get>
 8015958:	6078      	str	r0, [r7, #4]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 801595a:	683b      	ldr	r3, [r7, #0]
 801595c:	7a5b      	ldrb	r3, [r3, #9]
 801595e:	f003 0302 	and.w	r3, r3, #2
 8015962:	2b00      	cmp	r3, #0
 8015964:	d010      	beq.n	8015988 <rt_timer_check+0x80>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 8015966:	683b      	ldr	r3, [r7, #0]
 8015968:	7a5b      	ldrb	r3, [r3, #9]
 801596a:	f003 0301 	and.w	r3, r3, #1
            /* re-get tick */
            current_tick = rt_tick_get();

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 801596e:	2b00      	cmp	r3, #0
 8015970:	d00a      	beq.n	8015988 <rt_timer_check+0x80>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8015972:	683b      	ldr	r3, [r7, #0]
 8015974:	7a5b      	ldrb	r3, [r3, #9]
 8015976:	f023 0301 	bic.w	r3, r3, #1
 801597a:	b2da      	uxtb	r2, r3
 801597c:	683b      	ldr	r3, [r7, #0]
 801597e:	725a      	strb	r2, [r3, #9]
                rt_timer_start(t);
 8015980:	6838      	ldr	r0, [r7, #0]
 8015982:	f7ff fe39 	bl	80155f8 <rt_timer_start>
 8015986:	e006      	b.n	8015996 <rt_timer_check+0x8e>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8015988:	683b      	ldr	r3, [r7, #0]
 801598a:	7a5b      	ldrb	r3, [r3, #9]
 801598c:	f023 0301 	bic.w	r3, r3, #1
 8015990:	b2da      	uxtb	r2, r3
 8015992:	683b      	ldr	r3, [r7, #0]
 8015994:	725a      	strb	r2, [r3, #9]
 8015996:	e000      	b.n	801599a <rt_timer_check+0x92>
            }
        }
        else
            break;
 8015998:	e005      	b.n	80159a6 <rt_timer_check+0x9e>
    current_tick = rt_tick_get();

    /* disable interrupt */
    level = rt_hw_interrupt_disable();

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
 801599a:	4806      	ldr	r0, [pc, #24]	; (80159b4 <rt_timer_check+0xac>)
 801599c:	f7ff fd4e 	bl	801543c <rt_list_isempty>
 80159a0:	4603      	mov	r3, r0
 80159a2:	2b00      	cmp	r3, #0
 80159a4:	d0ba      	beq.n	801591c <rt_timer_check+0x14>
        else
            break;
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 80159a6:	4620      	mov	r0, r4
 80159a8:	f7ea fc12 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
}
 80159ac:	370c      	adds	r7, #12
 80159ae:	46bd      	mov	sp, r7
 80159b0:	bd90      	pop	{r4, r7, pc}
 80159b2:	bf00      	nop
 80159b4:	20010de8 	.word	0x20010de8
 80159b8:	7ffffffe 	.word	0x7ffffffe
 80159bc:	20011078 	.word	0x20011078

080159c0 <rt_soft_timer_check>:
/**
 * This function will check timer list, if a timeout event happens, the
 * corresponding timeout function will be invoked.
 */
void rt_soft_timer_check(void)
{
 80159c0:	b580      	push	{r7, lr}
 80159c2:	b084      	sub	sp, #16
 80159c4:	af00      	add	r7, sp, #0
    rt_list_t *n;
    struct rt_timer *t;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check enter\n"));

    current_tick = rt_tick_get();
 80159c6:	f7fc fa0f 	bl	8011de8 <rt_tick_get>
 80159ca:	60f8      	str	r0, [r7, #12]

	/* lock scheduler */
	rt_enter_critical();
 80159cc:	f7ff f96a 	bl	8014ca4 <rt_enter_critical>

    for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1].next;
 80159d0:	4b28      	ldr	r3, [pc, #160]	; (8015a74 <rt_soft_timer_check+0xb4>)
 80159d2:	681b      	ldr	r3, [r3, #0]
 80159d4:	60bb      	str	r3, [r7, #8]
 80159d6:	e044      	b.n	8015a62 <rt_soft_timer_check+0xa2>
         n != &(rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]);)
    {
        t = rt_list_entry(n, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL-1]);
 80159d8:	68bb      	ldr	r3, [r7, #8]
 80159da:	3b14      	subs	r3, #20
 80159dc:	607b      	str	r3, [r7, #4]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
 80159de:	687b      	ldr	r3, [r7, #4]
 80159e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80159e2:	68fa      	ldr	r2, [r7, #12]
 80159e4:	1ad3      	subs	r3, r2, r3
 80159e6:	4a24      	ldr	r2, [pc, #144]	; (8015a78 <rt_soft_timer_check+0xb8>)
 80159e8:	4293      	cmp	r3, r2
 80159ea:	d839      	bhi.n	8015a60 <rt_soft_timer_check+0xa0>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
 80159ec:	4b23      	ldr	r3, [pc, #140]	; (8015a7c <rt_soft_timer_check+0xbc>)
 80159ee:	681b      	ldr	r3, [r3, #0]
 80159f0:	2b00      	cmp	r3, #0
 80159f2:	d003      	beq.n	80159fc <rt_soft_timer_check+0x3c>
 80159f4:	4b21      	ldr	r3, [pc, #132]	; (8015a7c <rt_soft_timer_check+0xbc>)
 80159f6:	681b      	ldr	r3, [r3, #0]
 80159f8:	6878      	ldr	r0, [r7, #4]
 80159fa:	4798      	blx	r3

            /* move node to the next */
            n = n->next;
 80159fc:	68bb      	ldr	r3, [r7, #8]
 80159fe:	681b      	ldr	r3, [r3, #0]
 8015a00:	60bb      	str	r3, [r7, #8]

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
 8015a02:	6878      	ldr	r0, [r7, #4]
 8015a04:	f7ff fd78 	bl	80154f8 <_rt_timer_remove>

			/* not lock scheduler when performing timeout function */
			rt_exit_critical();
 8015a08:	f7ff f960 	bl	8014ccc <rt_exit_critical>
            /* call timeout function */
            t->timeout_func(t->parameter);
 8015a0c:	687b      	ldr	r3, [r7, #4]
 8015a0e:	69db      	ldr	r3, [r3, #28]
 8015a10:	687a      	ldr	r2, [r7, #4]
 8015a12:	6a12      	ldr	r2, [r2, #32]
 8015a14:	4610      	mov	r0, r2
 8015a16:	4798      	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
 8015a18:	f7fc f9e6 	bl	8011de8 <rt_tick_get>
 8015a1c:	60f8      	str	r0, [r7, #12]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

			/* lock scheduler */
			rt_enter_critical();
 8015a1e:	f7ff f941 	bl	8014ca4 <rt_enter_critical>

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 8015a22:	687b      	ldr	r3, [r7, #4]
 8015a24:	7a5b      	ldrb	r3, [r3, #9]
 8015a26:	f003 0302 	and.w	r3, r3, #2
 8015a2a:	2b00      	cmp	r3, #0
 8015a2c:	d010      	beq.n	8015a50 <rt_soft_timer_check+0x90>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 8015a2e:	687b      	ldr	r3, [r7, #4]
 8015a30:	7a5b      	ldrb	r3, [r3, #9]
 8015a32:	f003 0301 	and.w	r3, r3, #1
            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

			/* lock scheduler */
			rt_enter_critical();

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 8015a36:	2b00      	cmp	r3, #0
 8015a38:	d00a      	beq.n	8015a50 <rt_soft_timer_check+0x90>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8015a3a:	687b      	ldr	r3, [r7, #4]
 8015a3c:	7a5b      	ldrb	r3, [r3, #9]
 8015a3e:	f023 0301 	bic.w	r3, r3, #1
 8015a42:	b2da      	uxtb	r2, r3
 8015a44:	687b      	ldr	r3, [r7, #4]
 8015a46:	725a      	strb	r2, [r3, #9]
                rt_timer_start(t);
 8015a48:	6878      	ldr	r0, [r7, #4]
 8015a4a:	f7ff fdd5 	bl	80155f8 <rt_timer_start>
 8015a4e:	e006      	b.n	8015a5e <rt_soft_timer_check+0x9e>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8015a50:	687b      	ldr	r3, [r7, #4]
 8015a52:	7a5b      	ldrb	r3, [r3, #9]
 8015a54:	f023 0301 	bic.w	r3, r3, #1
 8015a58:	b2da      	uxtb	r2, r3
 8015a5a:	687b      	ldr	r3, [r7, #4]
 8015a5c:	725a      	strb	r2, [r3, #9]
 8015a5e:	e000      	b.n	8015a62 <rt_soft_timer_check+0xa2>
            }
        }
        else break; /* not check anymore */
 8015a60:	e003      	b.n	8015a6a <rt_soft_timer_check+0xaa>
    current_tick = rt_tick_get();

	/* lock scheduler */
	rt_enter_critical();

    for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1].next;
 8015a62:	68bb      	ldr	r3, [r7, #8]
 8015a64:	4a03      	ldr	r2, [pc, #12]	; (8015a74 <rt_soft_timer_check+0xb4>)
 8015a66:	4293      	cmp	r3, r2
 8015a68:	d1b6      	bne.n	80159d8 <rt_soft_timer_check+0x18>
        }
        else break; /* not check anymore */
    }

	/* unlock scheduler */
	rt_exit_critical();
 8015a6a:	f7ff f92f 	bl	8014ccc <rt_exit_critical>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check leave\n"));
}
 8015a6e:	3710      	adds	r7, #16
 8015a70:	46bd      	mov	sp, r7
 8015a72:	bd80      	pop	{r7, pc}
 8015a74:	20010df0 	.word	0x20010df0
 8015a78:	7ffffffe 	.word	0x7ffffffe
 8015a7c:	20011078 	.word	0x20011078

08015a80 <rt_thread_timer_entry>:

/* system timer thread entry */
static void rt_thread_timer_entry(void *parameter)
{
 8015a80:	b580      	push	{r7, lr}
 8015a82:	b084      	sub	sp, #16
 8015a84:	af00      	add	r7, sp, #0
 8015a86:	6078      	str	r0, [r7, #4]
    rt_tick_t next_timeout;

    while (1)
    {
        /* get the next timeout tick */
        next_timeout = rt_timer_list_next_timeout(rt_soft_timer_list);
 8015a88:	4811      	ldr	r0, [pc, #68]	; (8015ad0 <rt_thread_timer_entry+0x50>)
 8015a8a:	f7ff fd1d 	bl	80154c8 <rt_timer_list_next_timeout>
 8015a8e:	60f8      	str	r0, [r7, #12]
        if (next_timeout == RT_TICK_MAX)
 8015a90:	68fb      	ldr	r3, [r7, #12]
 8015a92:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015a96:	d108      	bne.n	8015aaa <rt_thread_timer_entry+0x2a>
        {
            /* no software timer exist, suspend self. */
            rt_thread_suspend(rt_thread_self());
 8015a98:	f7ff fa74 	bl	8014f84 <rt_thread_self>
 8015a9c:	4603      	mov	r3, r0
 8015a9e:	4618      	mov	r0, r3
 8015aa0:	f7ff fbf6 	bl	8015290 <rt_thread_suspend>
            rt_schedule();
 8015aa4:	f7ff f832 	bl	8014b0c <rt_schedule>
 8015aa8:	e00f      	b.n	8015aca <rt_thread_timer_entry+0x4a>
        else
        {
            rt_tick_t current_tick;

            /* get current tick */
            current_tick = rt_tick_get();
 8015aaa:	f7fc f99d 	bl	8011de8 <rt_tick_get>
 8015aae:	60b8      	str	r0, [r7, #8]

            if ((next_timeout - current_tick) < RT_TICK_MAX/2)
 8015ab0:	68fa      	ldr	r2, [r7, #12]
 8015ab2:	68bb      	ldr	r3, [r7, #8]
 8015ab4:	1ad3      	subs	r3, r2, r3
 8015ab6:	4a07      	ldr	r2, [pc, #28]	; (8015ad4 <rt_thread_timer_entry+0x54>)
 8015ab8:	4293      	cmp	r3, r2
 8015aba:	d806      	bhi.n	8015aca <rt_thread_timer_entry+0x4a>
            {
                /* get the delta timeout tick */
                next_timeout = next_timeout - current_tick;
 8015abc:	68fa      	ldr	r2, [r7, #12]
 8015abe:	68bb      	ldr	r3, [r7, #8]
 8015ac0:	1ad3      	subs	r3, r2, r3
 8015ac2:	60fb      	str	r3, [r7, #12]
                rt_thread_delay(next_timeout);
 8015ac4:	68f8      	ldr	r0, [r7, #12]
 8015ac6:	f7ff fb7d 	bl	80151c4 <rt_thread_delay>
            }
        }

        /* check software timer */
        rt_soft_timer_check();
 8015aca:	f7ff ff79 	bl	80159c0 <rt_soft_timer_check>
    }
 8015ace:	e7db      	b.n	8015a88 <rt_thread_timer_entry+0x8>
 8015ad0:	20010df0 	.word	0x20010df0
 8015ad4:	7ffffffe 	.word	0x7ffffffe

08015ad8 <rt_system_timer_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer
 */
void rt_system_timer_init(void)
{
 8015ad8:	b580      	push	{r7, lr}
 8015ada:	b082      	sub	sp, #8
 8015adc:	af00      	add	r7, sp, #0
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
 8015ade:	2300      	movs	r3, #0
 8015ae0:	607b      	str	r3, [r7, #4]
 8015ae2:	e009      	b.n	8015af8 <rt_system_timer_init+0x20>
    {
        rt_list_init(rt_timer_list+i);
 8015ae4:	687b      	ldr	r3, [r7, #4]
 8015ae6:	00db      	lsls	r3, r3, #3
 8015ae8:	4a06      	ldr	r2, [pc, #24]	; (8015b04 <rt_system_timer_init+0x2c>)
 8015aea:	4413      	add	r3, r2
 8015aec:	4618      	mov	r0, r3
 8015aee:	f7ff fc63 	bl	80153b8 <rt_list_init>
 */
void rt_system_timer_init(void)
{
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
 8015af2:	687b      	ldr	r3, [r7, #4]
 8015af4:	3301      	adds	r3, #1
 8015af6:	607b      	str	r3, [r7, #4]
 8015af8:	687b      	ldr	r3, [r7, #4]
 8015afa:	2b00      	cmp	r3, #0
 8015afc:	d0f2      	beq.n	8015ae4 <rt_system_timer_init+0xc>
    {
        rt_list_init(rt_timer_list+i);
    }
}
 8015afe:	3708      	adds	r7, #8
 8015b00:	46bd      	mov	sp, r7
 8015b02:	bd80      	pop	{r7, pc}
 8015b04:	20010de8 	.word	0x20010de8

08015b08 <rt_system_timer_thread_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer thread
 */
void rt_system_timer_thread_init(void)
{
 8015b08:	b580      	push	{r7, lr}
 8015b0a:	b086      	sub	sp, #24
 8015b0c:	af04      	add	r7, sp, #16
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
 8015b0e:	2300      	movs	r3, #0
 8015b10:	607b      	str	r3, [r7, #4]
 8015b12:	e009      	b.n	8015b28 <rt_system_timer_thread_init+0x20>
         i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
         i++)
    {
        rt_list_init(rt_soft_timer_list+i);
 8015b14:	687b      	ldr	r3, [r7, #4]
 8015b16:	00db      	lsls	r3, r3, #3
 8015b18:	4a0f      	ldr	r2, [pc, #60]	; (8015b58 <rt_system_timer_thread_init+0x50>)
 8015b1a:	4413      	add	r3, r2
 8015b1c:	4618      	mov	r0, r3
 8015b1e:	f7ff fc4b 	bl	80153b8 <rt_list_init>
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
         i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
         i++)
 8015b22:	687b      	ldr	r3, [r7, #4]
 8015b24:	3301      	adds	r3, #1
 8015b26:	607b      	str	r3, [r7, #4]
void rt_system_timer_thread_init(void)
{
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
 8015b28:	687b      	ldr	r3, [r7, #4]
 8015b2a:	2b00      	cmp	r3, #0
 8015b2c:	d0f2      	beq.n	8015b14 <rt_system_timer_thread_init+0xc>
    {
        rt_list_init(rt_soft_timer_list+i);
    }

    /* start software timer thread */
    rt_thread_init(&timer_thread,
 8015b2e:	4b0b      	ldr	r3, [pc, #44]	; (8015b5c <rt_system_timer_thread_init+0x54>)
 8015b30:	9300      	str	r3, [sp, #0]
 8015b32:	f44f 7300 	mov.w	r3, #512	; 0x200
 8015b36:	9301      	str	r3, [sp, #4]
 8015b38:	2304      	movs	r3, #4
 8015b3a:	9302      	str	r3, [sp, #8]
 8015b3c:	230a      	movs	r3, #10
 8015b3e:	9303      	str	r3, [sp, #12]
 8015b40:	4807      	ldr	r0, [pc, #28]	; (8015b60 <rt_system_timer_thread_init+0x58>)
 8015b42:	4908      	ldr	r1, [pc, #32]	; (8015b64 <rt_system_timer_thread_init+0x5c>)
 8015b44:	4a08      	ldr	r2, [pc, #32]	; (8015b68 <rt_system_timer_thread_init+0x60>)
 8015b46:	2300      	movs	r3, #0
 8015b48:	f7ff f9e6 	bl	8014f18 <rt_thread_init>
                   sizeof(timer_thread_stack),
                   RT_TIMER_THREAD_PRIO,
                   10);

    /* startup */
    rt_thread_startup(&timer_thread);
 8015b4c:	4804      	ldr	r0, [pc, #16]	; (8015b60 <rt_system_timer_thread_init+0x58>)
 8015b4e:	f7ff fa25 	bl	8014f9c <rt_thread_startup>
#endif
}
 8015b52:	3708      	adds	r7, #8
 8015b54:	46bd      	mov	sp, r7
 8015b56:	bd80      	pop	{r7, pc}
 8015b58:	20010df0 	.word	0x20010df0
 8015b5c:	20010e78 	.word	0x20010e78
 8015b60:	20010df8 	.word	0x20010df8
 8015b64:	080233bc 	.word	0x080233bc
 8015b68:	08015a81 	.word	0x08015a81

08015b6c <rt_hw_stack_init>:

rt_uint8_t *rt_hw_stack_init(void       *tentry,
                             void       *parameter,
                             rt_uint8_t *stack_addr,
                             void       *texit)
{
 8015b6c:	b480      	push	{r7}
 8015b6e:	b089      	sub	sp, #36	; 0x24
 8015b70:	af00      	add	r7, sp, #0
 8015b72:	60f8      	str	r0, [r7, #12]
 8015b74:	60b9      	str	r1, [r7, #8]
 8015b76:	607a      	str	r2, [r7, #4]
 8015b78:	603b      	str	r3, [r7, #0]
    struct stack_frame *stack_frame;
    rt_uint8_t         *stk;
    unsigned long       i;

    stk  = stack_addr + sizeof(rt_uint32_t);
 8015b7a:	687b      	ldr	r3, [r7, #4]
 8015b7c:	3304      	adds	r3, #4
 8015b7e:	61bb      	str	r3, [r7, #24]
    stk  = (rt_uint8_t *)RT_ALIGN_DOWN((rt_uint32_t)stk, 8);
 8015b80:	69bb      	ldr	r3, [r7, #24]
 8015b82:	f023 0307 	bic.w	r3, r3, #7
 8015b86:	61bb      	str	r3, [r7, #24]
    stk -= sizeof(struct stack_frame);
 8015b88:	69bb      	ldr	r3, [r7, #24]
 8015b8a:	3b44      	subs	r3, #68	; 0x44
 8015b8c:	61bb      	str	r3, [r7, #24]

    stack_frame = (struct stack_frame *)stk;
 8015b8e:	69bb      	ldr	r3, [r7, #24]
 8015b90:	617b      	str	r3, [r7, #20]

    /* init all register */
    for (i = 0; i < sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++)
 8015b92:	2300      	movs	r3, #0
 8015b94:	61fb      	str	r3, [r7, #28]
 8015b96:	e008      	b.n	8015baa <rt_hw_stack_init+0x3e>
    {
        ((rt_uint32_t *)stack_frame)[i] = 0xdeadbeef;
 8015b98:	69fb      	ldr	r3, [r7, #28]
 8015b9a:	009b      	lsls	r3, r3, #2
 8015b9c:	697a      	ldr	r2, [r7, #20]
 8015b9e:	4413      	add	r3, r2
 8015ba0:	4a15      	ldr	r2, [pc, #84]	; (8015bf8 <rt_hw_stack_init+0x8c>)
 8015ba2:	601a      	str	r2, [r3, #0]
    stk -= sizeof(struct stack_frame);

    stack_frame = (struct stack_frame *)stk;

    /* init all register */
    for (i = 0; i < sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++)
 8015ba4:	69fb      	ldr	r3, [r7, #28]
 8015ba6:	3301      	adds	r3, #1
 8015ba8:	61fb      	str	r3, [r7, #28]
 8015baa:	69fb      	ldr	r3, [r7, #28]
 8015bac:	2b10      	cmp	r3, #16
 8015bae:	d9f3      	bls.n	8015b98 <rt_hw_stack_init+0x2c>
    {
        ((rt_uint32_t *)stack_frame)[i] = 0xdeadbeef;
    }

    stack_frame->exception_stack_frame.r0  = (unsigned long)parameter; /* r0 : argument */
 8015bb0:	68ba      	ldr	r2, [r7, #8]
 8015bb2:	697b      	ldr	r3, [r7, #20]
 8015bb4:	625a      	str	r2, [r3, #36]	; 0x24
    stack_frame->exception_stack_frame.r1  = 0;                        /* r1 */
 8015bb6:	697b      	ldr	r3, [r7, #20]
 8015bb8:	2200      	movs	r2, #0
 8015bba:	629a      	str	r2, [r3, #40]	; 0x28
    stack_frame->exception_stack_frame.r2  = 0;                        /* r2 */
 8015bbc:	697b      	ldr	r3, [r7, #20]
 8015bbe:	2200      	movs	r2, #0
 8015bc0:	62da      	str	r2, [r3, #44]	; 0x2c
    stack_frame->exception_stack_frame.r3  = 0;                        /* r3 */
 8015bc2:	697b      	ldr	r3, [r7, #20]
 8015bc4:	2200      	movs	r2, #0
 8015bc6:	631a      	str	r2, [r3, #48]	; 0x30
    stack_frame->exception_stack_frame.r12 = 0;                        /* r12 */
 8015bc8:	697b      	ldr	r3, [r7, #20]
 8015bca:	2200      	movs	r2, #0
 8015bcc:	635a      	str	r2, [r3, #52]	; 0x34
    stack_frame->exception_stack_frame.lr  = (unsigned long)texit;     /* lr */
 8015bce:	683a      	ldr	r2, [r7, #0]
 8015bd0:	697b      	ldr	r3, [r7, #20]
 8015bd2:	639a      	str	r2, [r3, #56]	; 0x38
    stack_frame->exception_stack_frame.pc  = (unsigned long)tentry;    /* entry point, pc */
 8015bd4:	68fa      	ldr	r2, [r7, #12]
 8015bd6:	697b      	ldr	r3, [r7, #20]
 8015bd8:	63da      	str	r2, [r3, #60]	; 0x3c
    stack_frame->exception_stack_frame.psr = 0x01000000L;              /* PSR */
 8015bda:	697b      	ldr	r3, [r7, #20]
 8015bdc:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8015be0:	641a      	str	r2, [r3, #64]	; 0x40

#if USE_FPU
    stack_frame->flag = 0;
 8015be2:	697b      	ldr	r3, [r7, #20]
 8015be4:	2200      	movs	r2, #0
 8015be6:	601a      	str	r2, [r3, #0]
#endif /* USE_FPU */

    /* return task's current stack address */
    return stk;
 8015be8:	69bb      	ldr	r3, [r7, #24]
}
 8015bea:	4618      	mov	r0, r3
 8015bec:	3724      	adds	r7, #36	; 0x24
 8015bee:	46bd      	mov	sp, r7
 8015bf0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015bf4:	4770      	bx	lr
 8015bf6:	bf00      	nop
 8015bf8:	deadbeef 	.word	0xdeadbeef

08015bfc <rt_hw_hard_fault_exception>:
{
    rt_exception_hook = exception_handle;
}

void rt_hw_hard_fault_exception(struct exception_stack_frame *exception_stack)
{
 8015bfc:	b580      	push	{r7, lr}
 8015bfe:	b084      	sub	sp, #16
 8015c00:	af00      	add	r7, sp, #0
 8015c02:	6078      	str	r0, [r7, #4]
    extern long list_thread(void);

    if (rt_exception_hook != RT_NULL)
 8015c04:	4b24      	ldr	r3, [pc, #144]	; (8015c98 <rt_hw_hard_fault_exception+0x9c>)
 8015c06:	681b      	ldr	r3, [r3, #0]
 8015c08:	2b00      	cmp	r3, #0
 8015c0a:	d008      	beq.n	8015c1e <rt_hw_hard_fault_exception+0x22>
    {
        rt_err_t result;

        result = rt_exception_hook(exception_stack);
 8015c0c:	4b22      	ldr	r3, [pc, #136]	; (8015c98 <rt_hw_hard_fault_exception+0x9c>)
 8015c0e:	681b      	ldr	r3, [r3, #0]
 8015c10:	6878      	ldr	r0, [r7, #4]
 8015c12:	4798      	blx	r3
 8015c14:	60f8      	str	r0, [r7, #12]
        if (result == RT_EOK) return;
 8015c16:	68fb      	ldr	r3, [r7, #12]
 8015c18:	2b00      	cmp	r3, #0
 8015c1a:	d100      	bne.n	8015c1e <rt_hw_hard_fault_exception+0x22>
 8015c1c:	e039      	b.n	8015c92 <rt_hw_hard_fault_exception+0x96>
    }

    rt_kprintf("psr: 0x%08x\n", exception_stack->psr);
 8015c1e:	687b      	ldr	r3, [r7, #4]
 8015c20:	69db      	ldr	r3, [r3, #28]
 8015c22:	481e      	ldr	r0, [pc, #120]	; (8015c9c <rt_hw_hard_fault_exception+0xa0>)
 8015c24:	4619      	mov	r1, r3
 8015c26:	f7fe f823 	bl	8013c70 <rt_kprintf>
    rt_kprintf(" pc: 0x%08x\n", exception_stack->pc);
 8015c2a:	687b      	ldr	r3, [r7, #4]
 8015c2c:	699b      	ldr	r3, [r3, #24]
 8015c2e:	481c      	ldr	r0, [pc, #112]	; (8015ca0 <rt_hw_hard_fault_exception+0xa4>)
 8015c30:	4619      	mov	r1, r3
 8015c32:	f7fe f81d 	bl	8013c70 <rt_kprintf>
    rt_kprintf(" lr: 0x%08x\n", exception_stack->lr);
 8015c36:	687b      	ldr	r3, [r7, #4]
 8015c38:	695b      	ldr	r3, [r3, #20]
 8015c3a:	481a      	ldr	r0, [pc, #104]	; (8015ca4 <rt_hw_hard_fault_exception+0xa8>)
 8015c3c:	4619      	mov	r1, r3
 8015c3e:	f7fe f817 	bl	8013c70 <rt_kprintf>
    rt_kprintf("r12: 0x%08x\n", exception_stack->r12);
 8015c42:	687b      	ldr	r3, [r7, #4]
 8015c44:	691b      	ldr	r3, [r3, #16]
 8015c46:	4818      	ldr	r0, [pc, #96]	; (8015ca8 <rt_hw_hard_fault_exception+0xac>)
 8015c48:	4619      	mov	r1, r3
 8015c4a:	f7fe f811 	bl	8013c70 <rt_kprintf>
    rt_kprintf("r03: 0x%08x\n", exception_stack->r3);
 8015c4e:	687b      	ldr	r3, [r7, #4]
 8015c50:	68db      	ldr	r3, [r3, #12]
 8015c52:	4816      	ldr	r0, [pc, #88]	; (8015cac <rt_hw_hard_fault_exception+0xb0>)
 8015c54:	4619      	mov	r1, r3
 8015c56:	f7fe f80b 	bl	8013c70 <rt_kprintf>
    rt_kprintf("r02: 0x%08x\n", exception_stack->r2);
 8015c5a:	687b      	ldr	r3, [r7, #4]
 8015c5c:	689b      	ldr	r3, [r3, #8]
 8015c5e:	4814      	ldr	r0, [pc, #80]	; (8015cb0 <rt_hw_hard_fault_exception+0xb4>)
 8015c60:	4619      	mov	r1, r3
 8015c62:	f7fe f805 	bl	8013c70 <rt_kprintf>
    rt_kprintf("r01: 0x%08x\n", exception_stack->r1);
 8015c66:	687b      	ldr	r3, [r7, #4]
 8015c68:	685b      	ldr	r3, [r3, #4]
 8015c6a:	4812      	ldr	r0, [pc, #72]	; (8015cb4 <rt_hw_hard_fault_exception+0xb8>)
 8015c6c:	4619      	mov	r1, r3
 8015c6e:	f7fd ffff 	bl	8013c70 <rt_kprintf>
    rt_kprintf("r00: 0x%08x\n", exception_stack->r0);
 8015c72:	687b      	ldr	r3, [r7, #4]
 8015c74:	681b      	ldr	r3, [r3, #0]
 8015c76:	4810      	ldr	r0, [pc, #64]	; (8015cb8 <rt_hw_hard_fault_exception+0xbc>)
 8015c78:	4619      	mov	r1, r3
 8015c7a:	f7fd fff9 	bl	8013c70 <rt_kprintf>

    rt_kprintf("hard fault on thread: %s\n", rt_thread_self()->name);
 8015c7e:	f7ff f981 	bl	8014f84 <rt_thread_self>
 8015c82:	4603      	mov	r3, r0
 8015c84:	480d      	ldr	r0, [pc, #52]	; (8015cbc <rt_hw_hard_fault_exception+0xc0>)
 8015c86:	4619      	mov	r1, r3
 8015c88:	f7fd fff2 	bl	8013c70 <rt_kprintf>

#ifdef RT_USING_FINSH
    list_thread();
 8015c8c:	f003 fb60 	bl	8019350 <list_thread>
#endif

    while (1);
 8015c90:	e7fe      	b.n	8015c90 <rt_hw_hard_fault_exception+0x94>
}
 8015c92:	3710      	adds	r7, #16
 8015c94:	46bd      	mov	sp, r7
 8015c96:	bd80      	pop	{r7, pc}
 8015c98:	20011080 	.word	0x20011080
 8015c9c:	080233c4 	.word	0x080233c4
 8015ca0:	080233d4 	.word	0x080233d4
 8015ca4:	080233e4 	.word	0x080233e4
 8015ca8:	080233f4 	.word	0x080233f4
 8015cac:	08023404 	.word	0x08023404
 8015cb0:	08023414 	.word	0x08023414
 8015cb4:	08023424 	.word	0x08023424
 8015cb8:	08023434 	.word	0x08023434
 8015cbc:	08023444 	.word	0x08023444

08015cc0 <clock_time_system_init>:
#include <rtthread.h>
#include <pthread.h>

struct timeval _timevalue;
void clock_time_system_init()
{
 8015cc0:	b580      	push	{r7, lr}
 8015cc2:	b084      	sub	sp, #16
 8015cc4:	af00      	add	r7, sp, #0
    time_t time;
    rt_tick_t tick;
    rt_device_t device;

    time = 0;
 8015cc6:	2300      	movs	r3, #0
 8015cc8:	607b      	str	r3, [r7, #4]
    device = rt_device_find("rtc");
 8015cca:	4818      	ldr	r0, [pc, #96]	; (8015d2c <clock_time_system_init+0x6c>)
 8015ccc:	f7fc f942 	bl	8011f54 <rt_device_find>
 8015cd0:	60f8      	str	r0, [r7, #12]
    if (device != RT_NULL)
 8015cd2:	68fb      	ldr	r3, [r7, #12]
 8015cd4:	2b00      	cmp	r3, #0
 8015cd6:	d005      	beq.n	8015ce4 <clock_time_system_init+0x24>
    {
        /* get realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time);
 8015cd8:	1d3b      	adds	r3, r7, #4
 8015cda:	68f8      	ldr	r0, [r7, #12]
 8015cdc:	2110      	movs	r1, #16
 8015cde:	461a      	mov	r2, r3
 8015ce0:	f7fc fa8e 	bl	8012200 <rt_device_control>
    }

    /* get tick */
    tick = rt_tick_get();
 8015ce4:	f7fc f880 	bl	8011de8 <rt_tick_get>
 8015ce8:	60b8      	str	r0, [r7, #8]

    _timevalue.tv_usec = (tick%RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
 8015cea:	68ba      	ldr	r2, [r7, #8]
 8015cec:	4b10      	ldr	r3, [pc, #64]	; (8015d30 <clock_time_system_init+0x70>)
 8015cee:	fba3 1302 	umull	r1, r3, r3, r2
 8015cf2:	09db      	lsrs	r3, r3, #7
 8015cf4:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8015cf8:	fb01 f303 	mul.w	r3, r1, r3
 8015cfc:	1ad3      	subs	r3, r2, r3
 8015cfe:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8015d02:	fb02 f303 	mul.w	r3, r2, r3
 8015d06:	461a      	mov	r2, r3
 8015d08:	4b0a      	ldr	r3, [pc, #40]	; (8015d34 <clock_time_system_init+0x74>)
 8015d0a:	605a      	str	r2, [r3, #4]
    _timevalue.tv_sec = time - tick/RT_TICK_PER_SECOND - 1;
 8015d0c:	687b      	ldr	r3, [r7, #4]
 8015d0e:	4619      	mov	r1, r3
 8015d10:	68bb      	ldr	r3, [r7, #8]
 8015d12:	4a07      	ldr	r2, [pc, #28]	; (8015d30 <clock_time_system_init+0x70>)
 8015d14:	fba2 2303 	umull	r2, r3, r2, r3
 8015d18:	09db      	lsrs	r3, r3, #7
 8015d1a:	1acb      	subs	r3, r1, r3
 8015d1c:	3b01      	subs	r3, #1
 8015d1e:	461a      	mov	r2, r3
 8015d20:	4b04      	ldr	r3, [pc, #16]	; (8015d34 <clock_time_system_init+0x74>)
 8015d22:	601a      	str	r2, [r3, #0]
}
 8015d24:	3710      	adds	r7, #16
 8015d26:	46bd      	mov	sp, r7
 8015d28:	bd80      	pop	{r7, pc}
 8015d2a:	bf00      	nop
 8015d2c:	08023474 	.word	0x08023474
 8015d30:	10624dd3 	.word	0x10624dd3
 8015d34:	20012698 	.word	0x20012698

08015d38 <posix_mq_system_init>:
#include "pthread_internal.h"

static mqd_t posix_mq_list = RT_NULL;
static struct rt_semaphore posix_mq_lock;
void posix_mq_system_init()
{
 8015d38:	b580      	push	{r7, lr}
 8015d3a:	af00      	add	r7, sp, #0
    rt_sem_init(&posix_mq_lock, "pmq", 1, RT_IPC_FLAG_FIFO);
 8015d3c:	4803      	ldr	r0, [pc, #12]	; (8015d4c <posix_mq_system_init+0x14>)
 8015d3e:	4904      	ldr	r1, [pc, #16]	; (8015d50 <posix_mq_system_init+0x18>)
 8015d40:	2201      	movs	r2, #1
 8015d42:	2300      	movs	r3, #0
 8015d44:	f7fc fc1a 	bl	801257c <rt_sem_init>
}
 8015d48:	bd80      	pop	{r7, pc}
 8015d4a:	bf00      	nop
 8015d4c:	20011084 	.word	0x20011084
 8015d50:	08023488 	.word	0x08023488

08015d54 <pthread_system_init>:
#include <pthread.h>
#include <sched.h>
#include "pthread_internal.h"

int pthread_system_init(void)
{
 8015d54:	b580      	push	{r7, lr}
 8015d56:	af00      	add	r7, sp, #0
    /* initialize clock and time */
    clock_time_system_init();
 8015d58:	f7ff ffb2 	bl	8015cc0 <clock_time_system_init>

    /* initialize key area */
    pthread_key_system_init();
 8015d5c:	f000 f808 	bl	8015d70 <pthread_key_system_init>
    /* initialize posix mqueue */
    posix_mq_system_init();
 8015d60:	f7ff ffea 	bl	8015d38 <posix_mq_system_init>
    /* initialize posix semaphore */
    posix_sem_system_init();
 8015d64:	f000 f80e 	bl	8015d84 <posix_sem_system_init>

    return 0;
 8015d68:	2300      	movs	r3, #0
}
 8015d6a:	4618      	mov	r0, r3
 8015d6c:	bd80      	pop	{r7, pc}
 8015d6e:	bf00      	nop

08015d70 <pthread_key_system_init>:
#include "pthread_internal.h"

_pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

void pthread_key_system_init()
{
 8015d70:	b580      	push	{r7, lr}
 8015d72:	af00      	add	r7, sp, #0
    rt_memset(&_thread_keys[0], 0, sizeof(_thread_keys));
 8015d74:	4802      	ldr	r0, [pc, #8]	; (8015d80 <pthread_key_system_init+0x10>)
 8015d76:	2100      	movs	r1, #0
 8015d78:	2240      	movs	r2, #64	; 0x40
 8015d7a:	f7fd f9c1 	bl	8013100 <rt_memset>
}
 8015d7e:	bd80      	pop	{r7, pc}
 8015d80:	200126a0 	.word	0x200126a0

08015d84 <posix_sem_system_init>:
#include "pthread_internal.h"

static sem_t *posix_sem_list = RT_NULL;
static struct rt_semaphore posix_sem_lock;
void posix_sem_system_init()
{
 8015d84:	b580      	push	{r7, lr}
 8015d86:	af00      	add	r7, sp, #0
    rt_sem_init(&posix_sem_lock, "psem", 1, RT_IPC_FLAG_FIFO);
 8015d88:	4803      	ldr	r0, [pc, #12]	; (8015d98 <posix_sem_system_init+0x14>)
 8015d8a:	4904      	ldr	r1, [pc, #16]	; (8015d9c <posix_sem_system_init+0x18>)
 8015d8c:	2201      	movs	r2, #1
 8015d8e:	2300      	movs	r3, #0
 8015d90:	f7fc fbf4 	bl	801257c <rt_sem_init>
}
 8015d94:	bd80      	pop	{r7, pc}
 8015d96:	bf00      	nop
 8015d98:	200110a4 	.word	0x200110a4
 8015d9c:	0802348c 	.word	0x0802348c

08015da0 <libc_system_init>:
#endif

#endif

int libc_system_init(void)
{
 8015da0:	b580      	push	{r7, lr}
 8015da2:	af00      	add	r7, sp, #0
        fd = fd;
    }
#endif

    /* set PATH and HOME */
    putenv("PATH=/bin");
 8015da4:	4805      	ldr	r0, [pc, #20]	; (8015dbc <libc_system_init+0x1c>)
 8015da6:	f009 fcd5 	bl	801f754 <putenv>
    putenv("HOME=/home");
 8015daa:	4805      	ldr	r0, [pc, #20]	; (8015dc0 <libc_system_init+0x20>)
 8015dac:	f009 fcd2 	bl	801f754 <putenv>

#ifdef RT_USING_PTHREADS
    pthread_system_init();
 8015db0:	f7ff ffd0 	bl	8015d54 <pthread_system_init>
#endif

    return 0;
 8015db4:	2300      	movs	r3, #0
}
 8015db6:	4618      	mov	r0, r3
 8015db8:	bd80      	pop	{r7, pc}
 8015dba:	bf00      	nop
 8015dbc:	080234a0 	.word	0x080234a0
 8015dc0:	080234ac 	.word	0x080234ac

08015dc4 <_malloc_r>:
#endif

/* Memory routine */
void *
_malloc_r (struct _reent *ptr, size_t size)
{
 8015dc4:	b580      	push	{r7, lr}
 8015dc6:	b084      	sub	sp, #16
 8015dc8:	af00      	add	r7, sp, #0
 8015dca:	6078      	str	r0, [r7, #4]
 8015dcc:	6039      	str	r1, [r7, #0]
	void* result;

	result = (void*)rt_malloc (size);
 8015dce:	6838      	ldr	r0, [r7, #0]
 8015dd0:	f7fe f8fc 	bl	8013fcc <rt_malloc>
 8015dd4:	60f8      	str	r0, [r7, #12]
	if (result == RT_NULL)
 8015dd6:	68fb      	ldr	r3, [r7, #12]
 8015dd8:	2b00      	cmp	r3, #0
 8015dda:	d102      	bne.n	8015de2 <_malloc_r+0x1e>
	{
		ptr->_errno = ENOMEM;
 8015ddc:	687b      	ldr	r3, [r7, #4]
 8015dde:	220c      	movs	r2, #12
 8015de0:	601a      	str	r2, [r3, #0]
	}

	return result;
 8015de2:	68fb      	ldr	r3, [r7, #12]
}
 8015de4:	4618      	mov	r0, r3
 8015de6:	3710      	adds	r7, #16
 8015de8:	46bd      	mov	sp, r7
 8015dea:	bd80      	pop	{r7, pc}

08015dec <_realloc_r>:

void *
_realloc_r (struct _reent *ptr, void *old, size_t newlen)
{
 8015dec:	b580      	push	{r7, lr}
 8015dee:	b086      	sub	sp, #24
 8015df0:	af00      	add	r7, sp, #0
 8015df2:	60f8      	str	r0, [r7, #12]
 8015df4:	60b9      	str	r1, [r7, #8]
 8015df6:	607a      	str	r2, [r7, #4]
	void* result;

	result = (void*)rt_realloc (old, newlen);
 8015df8:	68b8      	ldr	r0, [r7, #8]
 8015dfa:	6879      	ldr	r1, [r7, #4]
 8015dfc:	f7fe fa2c 	bl	8014258 <rt_realloc>
 8015e00:	6178      	str	r0, [r7, #20]
	if (result == RT_NULL)
 8015e02:	697b      	ldr	r3, [r7, #20]
 8015e04:	2b00      	cmp	r3, #0
 8015e06:	d102      	bne.n	8015e0e <_realloc_r+0x22>
	{
		ptr->_errno = ENOMEM;
 8015e08:	68fb      	ldr	r3, [r7, #12]
 8015e0a:	220c      	movs	r2, #12
 8015e0c:	601a      	str	r2, [r3, #0]
	}

	return result;
 8015e0e:	697b      	ldr	r3, [r7, #20]
}
 8015e10:	4618      	mov	r0, r3
 8015e12:	3718      	adds	r7, #24
 8015e14:	46bd      	mov	sp, r7
 8015e16:	bd80      	pop	{r7, pc}

08015e18 <_free_r>:
	return result;
}

void 
_free_r (struct _reent *ptr, void *addr)
{
 8015e18:	b580      	push	{r7, lr}
 8015e1a:	b082      	sub	sp, #8
 8015e1c:	af00      	add	r7, sp, #0
 8015e1e:	6078      	str	r0, [r7, #4]
 8015e20:	6039      	str	r1, [r7, #0]
	rt_free (addr);
 8015e22:	6838      	ldr	r0, [r7, #0]
 8015e24:	f7fe fadc 	bl	80143e0 <rt_free>
}
 8015e28:	3708      	adds	r7, #8
 8015e2a:	46bd      	mov	sp, r7
 8015e2c:	bd80      	pop	{r7, pc}
 8015e2e:	bf00      	nop

08015e30 <__libc_init_array>:
    /* not support this call */
    return;
}

void __libc_init_array(void)
{
 8015e30:	b480      	push	{r7}
 8015e32:	af00      	add	r7, sp, #0
	/* we not use __libc init_aray to initialize C++ objects */
}
 8015e34:	46bd      	mov	sp, r7
 8015e36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015e3a:	4770      	bx	lr

08015e3c <osDelay>:

// Generic Wait API

/// Wait for Timeout (Time Delay)
osStatus osDelay(uint32_t millisec)
{
 8015e3c:	b580      	push	{r7, lr}
 8015e3e:	b084      	sub	sp, #16
 8015e40:	af00      	add	r7, sp, #0
 8015e42:	6078      	str	r0, [r7, #4]
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 8015e44:	6878      	ldr	r0, [r7, #4]
 8015e46:	f7fb fffd 	bl	8011e44 <rt_tick_from_millisecond>
 8015e4a:	60f8      	str	r0, [r7, #12]
    result = rt_thread_delay(ticks);
 8015e4c:	68f8      	ldr	r0, [r7, #12]
 8015e4e:	f7ff f9b9 	bl	80151c4 <rt_thread_delay>
 8015e52:	60b8      	str	r0, [r7, #8]

    if (result == RT_EOK)
 8015e54:	68bb      	ldr	r3, [r7, #8]
 8015e56:	2b00      	cmp	r3, #0
 8015e58:	d101      	bne.n	8015e5e <osDelay+0x22>
        return osOK;
 8015e5a:	2300      	movs	r3, #0
 8015e5c:	e000      	b.n	8015e60 <osDelay+0x24>
    else
        return osErrorOS;
 8015e5e:	23ff      	movs	r3, #255	; 0xff
}
 8015e60:	4618      	mov	r0, r3
 8015e62:	3710      	adds	r7, #16
 8015e64:	46bd      	mov	sp, r7
 8015e66:	bd80      	pop	{r7, pc}

08015e68 <osTimerCreate>:

// Timer Management Public API

/// Create timer
osTimerId osTimerCreate(osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 8015e68:	b590      	push	{r4, r7, lr}
 8015e6a:	b089      	sub	sp, #36	; 0x24
 8015e6c:	af02      	add	r7, sp, #8
 8015e6e:	60f8      	str	r0, [r7, #12]
 8015e70:	460b      	mov	r3, r1
 8015e72:	607a      	str	r2, [r7, #4]
 8015e74:	72fb      	strb	r3, [r7, #11]
    uint8_t flag = RT_TIMER_FLAG_SOFT_TIMER;
 8015e76:	2304      	movs	r3, #4
 8015e78:	75fb      	strb	r3, [r7, #23]

    if (type == osTimerPeriodic)
 8015e7a:	7afb      	ldrb	r3, [r7, #11]
 8015e7c:	2b01      	cmp	r3, #1
 8015e7e:	d103      	bne.n	8015e88 <osTimerCreate+0x20>
    {
        flag |= RT_TIMER_FLAG_PERIODIC;
 8015e80:	7dfb      	ldrb	r3, [r7, #23]
 8015e82:	f043 0302 	orr.w	r3, r3, #2
 8015e86:	75fb      	strb	r3, [r7, #23]
    }

    return rt_timer_create(timer_def->name, timer_def->timeout, argument, timer_def->time, flag);
 8015e88:	68fb      	ldr	r3, [r7, #12]
 8015e8a:	6819      	ldr	r1, [r3, #0]
 8015e8c:	68fb      	ldr	r3, [r7, #12]
 8015e8e:	685a      	ldr	r2, [r3, #4]
 8015e90:	68fb      	ldr	r3, [r7, #12]
 8015e92:	68dc      	ldr	r4, [r3, #12]
 8015e94:	7dfb      	ldrb	r3, [r7, #23]
 8015e96:	9300      	str	r3, [sp, #0]
 8015e98:	4608      	mov	r0, r1
 8015e9a:	4611      	mov	r1, r2
 8015e9c:	687a      	ldr	r2, [r7, #4]
 8015e9e:	4623      	mov	r3, r4
 8015ea0:	f7ff fb8a 	bl	80155b8 <rt_timer_create>
 8015ea4:	4603      	mov	r3, r0
}
 8015ea6:	4618      	mov	r0, r3
 8015ea8:	371c      	adds	r7, #28
 8015eaa:	46bd      	mov	sp, r7
 8015eac:	bd90      	pop	{r4, r7, pc}
 8015eae:	bf00      	nop

08015eb0 <osTimerStart>:

/// Start or restart timer
osStatus osTimerStart(osTimerId timer_id, uint32_t millisec)
{
 8015eb0:	b580      	push	{r7, lr}
 8015eb2:	b084      	sub	sp, #16
 8015eb4:	af00      	add	r7, sp, #0
 8015eb6:	6078      	str	r0, [r7, #4]
 8015eb8:	6039      	str	r1, [r7, #0]
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 8015eba:	6838      	ldr	r0, [r7, #0]
 8015ebc:	f7fb ffc2 	bl	8011e44 <rt_tick_from_millisecond>
 8015ec0:	4603      	mov	r3, r0
 8015ec2:	60bb      	str	r3, [r7, #8]
    rt_timer_control(timer_id, RT_TIMER_CTRL_SET_TIME, &ticks);
 8015ec4:	f107 0308 	add.w	r3, r7, #8
 8015ec8:	6878      	ldr	r0, [r7, #4]
 8015eca:	2100      	movs	r1, #0
 8015ecc:	461a      	mov	r2, r3
 8015ece:	f7ff fcd9 	bl	8015884 <rt_timer_control>
    result = rt_timer_start(timer_id);
 8015ed2:	6878      	ldr	r0, [r7, #4]
 8015ed4:	f7ff fb90 	bl	80155f8 <rt_timer_start>
 8015ed8:	60f8      	str	r0, [r7, #12]
    if (result == RT_EOK)
 8015eda:	68fb      	ldr	r3, [r7, #12]
 8015edc:	2b00      	cmp	r3, #0
 8015ede:	d101      	bne.n	8015ee4 <osTimerStart+0x34>
        return osOK;
 8015ee0:	2300      	movs	r3, #0
 8015ee2:	e000      	b.n	8015ee6 <osTimerStart+0x36>
    else
        return osErrorOS;
 8015ee4:	23ff      	movs	r3, #255	; 0xff
}
 8015ee6:	4618      	mov	r0, r3
 8015ee8:	3710      	adds	r7, #16
 8015eea:	46bd      	mov	sp, r7
 8015eec:	bd80      	pop	{r7, pc}
 8015eee:	bf00      	nop

08015ef0 <osMessageCreate>:

// Message Queue Management Public API

/// Create and Initialize Message Queue
osMessageQId osMessageCreate(osMessageQDef_t *queue_def, osThreadId thread_id)
{
 8015ef0:	b580      	push	{r7, lr}
 8015ef2:	b082      	sub	sp, #8
 8015ef4:	af00      	add	r7, sp, #0
 8015ef6:	6078      	str	r0, [r7, #4]
 8015ef8:	6039      	str	r1, [r7, #0]
    return rt_mq_create(queue_def->name, queue_def->msg_size, queue_def->max_msgs, queue_def->flag);
 8015efa:	687b      	ldr	r3, [r7, #4]
 8015efc:	6818      	ldr	r0, [r3, #0]
 8015efe:	687b      	ldr	r3, [r7, #4]
 8015f00:	6899      	ldr	r1, [r3, #8]
 8015f02:	687b      	ldr	r3, [r7, #4]
 8015f04:	685a      	ldr	r2, [r3, #4]
 8015f06:	687b      	ldr	r3, [r7, #4]
 8015f08:	7b1b      	ldrb	r3, [r3, #12]
 8015f0a:	f7fc fe2d 	bl	8012b68 <rt_mq_create>
 8015f0e:	4603      	mov	r3, r0
}
 8015f10:	4618      	mov	r0, r3
 8015f12:	3708      	adds	r7, #8
 8015f14:	46bd      	mov	sp, r7
 8015f16:	bd80      	pop	{r7, pc}

08015f18 <osMessagePut>:

/// Put a Message to a Queue
osStatus osMessagePut(osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 8015f18:	b580      	push	{r7, lr}
 8015f1a:	b086      	sub	sp, #24
 8015f1c:	af00      	add	r7, sp, #0
 8015f1e:	60f8      	str	r0, [r7, #12]
 8015f20:	60b9      	str	r1, [r7, #8]
 8015f22:	607a      	str	r2, [r7, #4]
    rt_err_t result;

    result = rt_mq_send(queue_id,&info, 4);
 8015f24:	f107 0308 	add.w	r3, r7, #8
 8015f28:	68f8      	ldr	r0, [r7, #12]
 8015f2a:	4619      	mov	r1, r3
 8015f2c:	2204      	movs	r2, #4
 8015f2e:	f7fc fed9 	bl	8012ce4 <rt_mq_send>
 8015f32:	6178      	str	r0, [r7, #20]

    if (result == RT_EOK)
 8015f34:	697b      	ldr	r3, [r7, #20]
 8015f36:	2b00      	cmp	r3, #0
 8015f38:	d101      	bne.n	8015f3e <osMessagePut+0x26>
        return osOK;
 8015f3a:	2300      	movs	r3, #0
 8015f3c:	e000      	b.n	8015f40 <osMessagePut+0x28>
    else
        return osErrorOS;
 8015f3e:	23ff      	movs	r3, #255	; 0xff
}
 8015f40:	4618      	mov	r0, r3
 8015f42:	3718      	adds	r7, #24
 8015f44:	46bd      	mov	sp, r7
 8015f46:	bd80      	pop	{r7, pc}

08015f48 <osMessageGet>:

/// Get a Message or Wait for a Message from a Queue
osEvent osMessageGet(osMessageQId queue_id, uint32_t millisec)
{
 8015f48:	b590      	push	{r4, r7, lr}
 8015f4a:	b08b      	sub	sp, #44	; 0x2c
 8015f4c:	af00      	add	r7, sp, #0
 8015f4e:	60f8      	str	r0, [r7, #12]
 8015f50:	60b9      	str	r1, [r7, #8]
 8015f52:	607a      	str	r2, [r7, #4]
    osEvent event;
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 8015f54:	6878      	ldr	r0, [r7, #4]
 8015f56:	f7fb ff75 	bl	8011e44 <rt_tick_from_millisecond>
 8015f5a:	6278      	str	r0, [r7, #36]	; 0x24
    result = rt_mq_recv(queue_id, &event.value, 4, ticks);
 8015f5c:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 8015f5e:	f107 0314 	add.w	r3, r7, #20
 8015f62:	3304      	adds	r3, #4
 8015f64:	68b8      	ldr	r0, [r7, #8]
 8015f66:	4619      	mov	r1, r3
 8015f68:	2204      	movs	r2, #4
 8015f6a:	4623      	mov	r3, r4
 8015f6c:	f7fc ff54 	bl	8012e18 <rt_mq_recv>
 8015f70:	6238      	str	r0, [r7, #32]

    if (result == RT_EOK)
 8015f72:	6a3b      	ldr	r3, [r7, #32]
 8015f74:	2b00      	cmp	r3, #0
 8015f76:	d102      	bne.n	8015f7e <osMessageGet+0x36>
    {
        event.status = osEventMessage;
 8015f78:	2310      	movs	r3, #16
 8015f7a:	617b      	str	r3, [r7, #20]
 8015f7c:	e001      	b.n	8015f82 <osMessageGet+0x3a>
    }
    else
    {
        event.status = osEventTimeout;
 8015f7e:	2340      	movs	r3, #64	; 0x40
 8015f80:	617b      	str	r3, [r7, #20]
    }

    return event;
 8015f82:	68fb      	ldr	r3, [r7, #12]
 8015f84:	461c      	mov	r4, r3
 8015f86:	f107 0314 	add.w	r3, r7, #20
 8015f8a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8015f8e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8015f92:	68f8      	ldr	r0, [r7, #12]
 8015f94:	372c      	adds	r7, #44	; 0x2c
 8015f96:	46bd      	mov	sp, r7
 8015f98:	bd90      	pop	{r4, r7, pc}
 8015f9a:	bf00      	nop

08015f9c <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8015f9c:	b480      	push	{r7}
 8015f9e:	b083      	sub	sp, #12
 8015fa0:	af00      	add	r7, sp, #0
 8015fa2:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8015fa4:	687b      	ldr	r3, [r7, #4]
 8015fa6:	687a      	ldr	r2, [r7, #4]
 8015fa8:	605a      	str	r2, [r3, #4]
 8015faa:	687b      	ldr	r3, [r7, #4]
 8015fac:	685a      	ldr	r2, [r3, #4]
 8015fae:	687b      	ldr	r3, [r7, #4]
 8015fb0:	601a      	str	r2, [r3, #0]
}
 8015fb2:	370c      	adds	r7, #12
 8015fb4:	46bd      	mov	sp, r7
 8015fb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015fba:	4770      	bx	lr

08015fbc <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8015fbc:	b480      	push	{r7}
 8015fbe:	b083      	sub	sp, #12
 8015fc0:	af00      	add	r7, sp, #0
 8015fc2:	6078      	str	r0, [r7, #4]
 8015fc4:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 8015fc6:	687b      	ldr	r3, [r7, #4]
 8015fc8:	685b      	ldr	r3, [r3, #4]
 8015fca:	683a      	ldr	r2, [r7, #0]
 8015fcc:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8015fce:	687b      	ldr	r3, [r7, #4]
 8015fd0:	685a      	ldr	r2, [r3, #4]
 8015fd2:	683b      	ldr	r3, [r7, #0]
 8015fd4:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8015fd6:	687b      	ldr	r3, [r7, #4]
 8015fd8:	683a      	ldr	r2, [r7, #0]
 8015fda:	605a      	str	r2, [r3, #4]
    n->next = l;
 8015fdc:	683b      	ldr	r3, [r7, #0]
 8015fde:	687a      	ldr	r2, [r7, #4]
 8015fe0:	601a      	str	r2, [r3, #0]
}
 8015fe2:	370c      	adds	r7, #12
 8015fe4:	46bd      	mov	sp, r7
 8015fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015fea:	4770      	bx	lr

08015fec <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8015fec:	b480      	push	{r7}
 8015fee:	b083      	sub	sp, #12
 8015ff0:	af00      	add	r7, sp, #0
 8015ff2:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8015ff4:	687b      	ldr	r3, [r7, #4]
 8015ff6:	681a      	ldr	r2, [r3, #0]
 8015ff8:	687b      	ldr	r3, [r7, #4]
 8015ffa:	429a      	cmp	r2, r3
 8015ffc:	bf0c      	ite	eq
 8015ffe:	2301      	moveq	r3, #1
 8016000:	2300      	movne	r3, #0
 8016002:	b2db      	uxtb	r3, r3
}
 8016004:	4618      	mov	r0, r3
 8016006:	370c      	adds	r7, #12
 8016008:	46bd      	mov	sp, r7
 801600a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801600e:	4770      	bx	lr

08016010 <rt_completion_init>:

#define RT_COMPLETED    1
#define RT_UNCOMPLETED  0

void rt_completion_init(struct rt_completion *completion)
{
 8016010:	b580      	push	{r7, lr}
 8016012:	b084      	sub	sp, #16
 8016014:	af00      	add	r7, sp, #0
 8016016:	6078      	str	r0, [r7, #4]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
 8016018:	687b      	ldr	r3, [r7, #4]
 801601a:	2b00      	cmp	r3, #0
 801601c:	d104      	bne.n	8016028 <rt_completion_init+0x18>
 801601e:	480b      	ldr	r0, [pc, #44]	; (801604c <rt_completion_init+0x3c>)
 8016020:	490b      	ldr	r1, [pc, #44]	; (8016050 <rt_completion_init+0x40>)
 8016022:	2223      	movs	r2, #35	; 0x23
 8016024:	f7fd fe9e 	bl	8013d64 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
 8016028:	f7ea f8ce 	bl	80001c8 <rt_hw_interrupt_disable>
 801602c:	60f8      	str	r0, [r7, #12]
    completion->flag = RT_UNCOMPLETED;
 801602e:	687b      	ldr	r3, [r7, #4]
 8016030:	2200      	movs	r2, #0
 8016032:	601a      	str	r2, [r3, #0]
    rt_list_init(&completion->suspended_list);
 8016034:	687b      	ldr	r3, [r7, #4]
 8016036:	3304      	adds	r3, #4
 8016038:	4618      	mov	r0, r3
 801603a:	f7ff ffaf 	bl	8015f9c <rt_list_init>
    rt_hw_interrupt_enable(level);
 801603e:	68f8      	ldr	r0, [r7, #12]
 8016040:	f7ea f8c6 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8016044:	3710      	adds	r7, #16
 8016046:	46bd      	mov	sp, r7
 8016048:	bd80      	pop	{r7, pc}
 801604a:	bf00      	nop
 801604c:	080234b8 	.word	0x080234b8
 8016050:	08025094 	.word	0x08025094

08016054 <rt_completion_wait>:
RTM_EXPORT(rt_completion_init);

rt_err_t rt_completion_wait(struct rt_completion *completion,
                            rt_int32_t            timeout)
{
 8016054:	b580      	push	{r7, lr}
 8016056:	b086      	sub	sp, #24
 8016058:	af00      	add	r7, sp, #0
 801605a:	6078      	str	r0, [r7, #4]
 801605c:	6039      	str	r1, [r7, #0]
    rt_err_t result;
    rt_base_t level;
    rt_thread_t thread;
    RT_ASSERT(completion != RT_NULL);
 801605e:	687b      	ldr	r3, [r7, #4]
 8016060:	2b00      	cmp	r3, #0
 8016062:	d104      	bne.n	801606e <rt_completion_wait+0x1a>
 8016064:	4836      	ldr	r0, [pc, #216]	; (8016140 <rt_completion_wait+0xec>)
 8016066:	4937      	ldr	r1, [pc, #220]	; (8016144 <rt_completion_wait+0xf0>)
 8016068:	2232      	movs	r2, #50	; 0x32
 801606a:	f7fd fe7b 	bl	8013d64 <rt_assert_handler>

    result = RT_EOK;
 801606e:	2300      	movs	r3, #0
 8016070:	617b      	str	r3, [r7, #20]
    thread = rt_thread_self();
 8016072:	f7fe ff87 	bl	8014f84 <rt_thread_self>
 8016076:	60f8      	str	r0, [r7, #12]

    level = rt_hw_interrupt_disable();
 8016078:	f7ea f8a6 	bl	80001c8 <rt_hw_interrupt_disable>
 801607c:	6138      	str	r0, [r7, #16]
    if (completion->flag != RT_COMPLETED)
 801607e:	687b      	ldr	r3, [r7, #4]
 8016080:	681b      	ldr	r3, [r3, #0]
 8016082:	2b01      	cmp	r3, #1
 8016084:	d051      	beq.n	801612a <rt_completion_wait+0xd6>
    {
        /* only one thread can suspend on complete */
        RT_ASSERT(rt_list_isempty(&(completion->suspended_list)));
 8016086:	687b      	ldr	r3, [r7, #4]
 8016088:	3304      	adds	r3, #4
 801608a:	4618      	mov	r0, r3
 801608c:	f7ff ffae 	bl	8015fec <rt_list_isempty>
 8016090:	4603      	mov	r3, r0
 8016092:	2b00      	cmp	r3, #0
 8016094:	d104      	bne.n	80160a0 <rt_completion_wait+0x4c>
 8016096:	482c      	ldr	r0, [pc, #176]	; (8016148 <rt_completion_wait+0xf4>)
 8016098:	492a      	ldr	r1, [pc, #168]	; (8016144 <rt_completion_wait+0xf0>)
 801609a:	223b      	movs	r2, #59	; 0x3b
 801609c:	f7fd fe62 	bl	8013d64 <rt_assert_handler>

        if (timeout == 0)
 80160a0:	683b      	ldr	r3, [r7, #0]
 80160a2:	2b00      	cmp	r3, #0
 80160a4:	d103      	bne.n	80160ae <rt_completion_wait+0x5a>
        {
            result = -RT_ETIMEOUT;
 80160a6:	f06f 0301 	mvn.w	r3, #1
 80160aa:	617b      	str	r3, [r7, #20]
            goto __exit;
 80160ac:	e040      	b.n	8016130 <rt_completion_wait+0xdc>
        }
        else
        {
            /* reset thread error number */
            thread->error = RT_EOK;
 80160ae:	68fb      	ldr	r3, [r7, #12]
 80160b0:	2200      	movs	r2, #0
 80160b2:	631a      	str	r2, [r3, #48]	; 0x30

            /* suspend thread */
            rt_thread_suspend(thread);
 80160b4:	68f8      	ldr	r0, [r7, #12]
 80160b6:	f7ff f8eb 	bl	8015290 <rt_thread_suspend>
            /* add to suspended list */
            rt_list_insert_before(&(completion->suspended_list),
 80160ba:	687b      	ldr	r3, [r7, #4]
 80160bc:	1d1a      	adds	r2, r3, #4
 80160be:	68fb      	ldr	r3, [r7, #12]
 80160c0:	3314      	adds	r3, #20
 80160c2:	4610      	mov	r0, r2
 80160c4:	4619      	mov	r1, r3
 80160c6:	f7ff ff79 	bl	8015fbc <rt_list_insert_before>
                                  &(thread->tlist));

            /* current context checking */
            RT_DEBUG_NOT_IN_INTERRUPT;
 80160ca:	f7ea f87d 	bl	80001c8 <rt_hw_interrupt_disable>
 80160ce:	60b8      	str	r0, [r7, #8]
 80160d0:	f7fc ffea 	bl	80130a8 <rt_interrupt_get_nest>
 80160d4:	4603      	mov	r3, r0
 80160d6:	2b00      	cmp	r3, #0
 80160d8:	d008      	beq.n	80160ec <rt_completion_wait+0x98>
 80160da:	481c      	ldr	r0, [pc, #112]	; (801614c <rt_completion_wait+0xf8>)
 80160dc:	4919      	ldr	r1, [pc, #100]	; (8016144 <rt_completion_wait+0xf0>)
 80160de:	f7fd fdc7 	bl	8013c70 <rt_kprintf>
 80160e2:	481b      	ldr	r0, [pc, #108]	; (8016150 <rt_completion_wait+0xfc>)
 80160e4:	4917      	ldr	r1, [pc, #92]	; (8016144 <rt_completion_wait+0xf0>)
 80160e6:	224e      	movs	r2, #78	; 0x4e
 80160e8:	f7fd fe3c 	bl	8013d64 <rt_assert_handler>
 80160ec:	68b8      	ldr	r0, [r7, #8]
 80160ee:	f7ea f86f 	bl	80001d0 <rt_hw_interrupt_enable>

            /* start timer */
            if (timeout > 0)
 80160f2:	683b      	ldr	r3, [r7, #0]
 80160f4:	2b00      	cmp	r3, #0
 80160f6:	dd0d      	ble.n	8016114 <rt_completion_wait+0xc0>
            {
                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
 80160f8:	68fb      	ldr	r3, [r7, #12]
 80160fa:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 80160fe:	463b      	mov	r3, r7
 8016100:	4610      	mov	r0, r2
 8016102:	2100      	movs	r1, #0
 8016104:	461a      	mov	r2, r3
 8016106:	f7ff fbbd 	bl	8015884 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &timeout);
                rt_timer_start(&(thread->thread_timer));
 801610a:	68fb      	ldr	r3, [r7, #12]
 801610c:	334c      	adds	r3, #76	; 0x4c
 801610e:	4618      	mov	r0, r3
 8016110:	f7ff fa72 	bl	80155f8 <rt_timer_start>
            }
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
 8016114:	6938      	ldr	r0, [r7, #16]
 8016116:	f7ea f85b 	bl	80001d0 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
 801611a:	f7fe fcf7 	bl	8014b0c <rt_schedule>

            /* thread is waked up */
            result = thread->error;
 801611e:	68fb      	ldr	r3, [r7, #12]
 8016120:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016122:	617b      	str	r3, [r7, #20]

            level = rt_hw_interrupt_disable();
 8016124:	f7ea f850 	bl	80001c8 <rt_hw_interrupt_disable>
 8016128:	6138      	str	r0, [r7, #16]
        }
    }
    /* clean completed flag */
    completion->flag = RT_UNCOMPLETED;
 801612a:	687b      	ldr	r3, [r7, #4]
 801612c:	2200      	movs	r2, #0
 801612e:	601a      	str	r2, [r3, #0]

__exit:
    rt_hw_interrupt_enable(level);
 8016130:	6938      	ldr	r0, [r7, #16]
 8016132:	f7ea f84d 	bl	80001d0 <rt_hw_interrupt_enable>

    return result;
 8016136:	697b      	ldr	r3, [r7, #20]
}
 8016138:	4618      	mov	r0, r3
 801613a:	3718      	adds	r7, #24
 801613c:	46bd      	mov	sp, r7
 801613e:	bd80      	pop	{r7, pc}
 8016140:	080234b8 	.word	0x080234b8
 8016144:	080250a8 	.word	0x080250a8
 8016148:	080234d0 	.word	0x080234d0
 801614c:	08023500 	.word	0x08023500
 8016150:	08023524 	.word	0x08023524

08016154 <rt_completion_done>:
RTM_EXPORT(rt_completion_wait);

void rt_completion_done(struct rt_completion *completion)
{
 8016154:	b580      	push	{r7, lr}
 8016156:	b084      	sub	sp, #16
 8016158:	af00      	add	r7, sp, #0
 801615a:	6078      	str	r0, [r7, #4]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
 801615c:	687b      	ldr	r3, [r7, #4]
 801615e:	2b00      	cmp	r3, #0
 8016160:	d104      	bne.n	801616c <rt_completion_done+0x18>
 8016162:	4815      	ldr	r0, [pc, #84]	; (80161b8 <rt_completion_done+0x64>)
 8016164:	4915      	ldr	r1, [pc, #84]	; (80161bc <rt_completion_done+0x68>)
 8016166:	2272      	movs	r2, #114	; 0x72
 8016168:	f7fd fdfc 	bl	8013d64 <rt_assert_handler>

    if (completion->flag == RT_COMPLETED)
 801616c:	687b      	ldr	r3, [r7, #4]
 801616e:	681b      	ldr	r3, [r3, #0]
 8016170:	2b01      	cmp	r3, #1
 8016172:	d100      	bne.n	8016176 <rt_completion_done+0x22>
        return;
 8016174:	e01d      	b.n	80161b2 <rt_completion_done+0x5e>

    level = rt_hw_interrupt_disable();
 8016176:	f7ea f827 	bl	80001c8 <rt_hw_interrupt_disable>
 801617a:	60f8      	str	r0, [r7, #12]
    completion->flag = RT_COMPLETED;
 801617c:	687b      	ldr	r3, [r7, #4]
 801617e:	2201      	movs	r2, #1
 8016180:	601a      	str	r2, [r3, #0]

    if (!rt_list_isempty(&(completion->suspended_list)))
 8016182:	687b      	ldr	r3, [r7, #4]
 8016184:	3304      	adds	r3, #4
 8016186:	4618      	mov	r0, r3
 8016188:	f7ff ff30 	bl	8015fec <rt_list_isempty>
 801618c:	4603      	mov	r3, r0
 801618e:	2b00      	cmp	r3, #0
 8016190:	d10c      	bne.n	80161ac <rt_completion_done+0x58>
    {
        /* there is one thread in suspended list */
        struct rt_thread *thread;

        /* get thread entry */
        thread = rt_list_entry(completion->suspended_list.next,
 8016192:	687b      	ldr	r3, [r7, #4]
 8016194:	685b      	ldr	r3, [r3, #4]
 8016196:	3b14      	subs	r3, #20
 8016198:	60bb      	str	r3, [r7, #8]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
 801619a:	68b8      	ldr	r0, [r7, #8]
 801619c:	f7ff f8a8 	bl	80152f0 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
 80161a0:	68f8      	ldr	r0, [r7, #12]
 80161a2:	f7ea f815 	bl	80001d0 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
 80161a6:	f7fe fcb1 	bl	8014b0c <rt_schedule>
 80161aa:	e002      	b.n	80161b2 <rt_completion_done+0x5e>
    }
    else
    {
        rt_hw_interrupt_enable(level);
 80161ac:	68f8      	ldr	r0, [r7, #12]
 80161ae:	f7ea f80f 	bl	80001d0 <rt_hw_interrupt_enable>
    }
}
 80161b2:	3710      	adds	r7, #16
 80161b4:	46bd      	mov	sp, r7
 80161b6:	bd80      	pop	{r7, pc}
 80161b8:	080234b8 	.word	0x080234b8
 80161bc:	080250bc 	.word	0x080250bc

080161c0 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 80161c0:	b480      	push	{r7}
 80161c2:	b083      	sub	sp, #12
 80161c4:	af00      	add	r7, sp, #0
 80161c6:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 80161c8:	687b      	ldr	r3, [r7, #4]
 80161ca:	687a      	ldr	r2, [r7, #4]
 80161cc:	605a      	str	r2, [r3, #4]
 80161ce:	687b      	ldr	r3, [r7, #4]
 80161d0:	685a      	ldr	r2, [r3, #4]
 80161d2:	687b      	ldr	r3, [r7, #4]
 80161d4:	601a      	str	r2, [r3, #0]
}
 80161d6:	370c      	adds	r7, #12
 80161d8:	46bd      	mov	sp, r7
 80161da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80161de:	4770      	bx	lr

080161e0 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 80161e0:	b480      	push	{r7}
 80161e2:	b083      	sub	sp, #12
 80161e4:	af00      	add	r7, sp, #0
 80161e6:	6078      	str	r0, [r7, #4]
 80161e8:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 80161ea:	687b      	ldr	r3, [r7, #4]
 80161ec:	685b      	ldr	r3, [r3, #4]
 80161ee:	683a      	ldr	r2, [r7, #0]
 80161f0:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 80161f2:	687b      	ldr	r3, [r7, #4]
 80161f4:	685a      	ldr	r2, [r3, #4]
 80161f6:	683b      	ldr	r3, [r7, #0]
 80161f8:	605a      	str	r2, [r3, #4]

    l->prev = n;
 80161fa:	687b      	ldr	r3, [r7, #4]
 80161fc:	683a      	ldr	r2, [r7, #0]
 80161fe:	605a      	str	r2, [r3, #4]
    n->next = l;
 8016200:	683b      	ldr	r3, [r7, #0]
 8016202:	687a      	ldr	r2, [r7, #4]
 8016204:	601a      	str	r2, [r3, #0]
}
 8016206:	370c      	adds	r7, #12
 8016208:	46bd      	mov	sp, r7
 801620a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801620e:	4770      	bx	lr

08016210 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8016210:	b480      	push	{r7}
 8016212:	b083      	sub	sp, #12
 8016214:	af00      	add	r7, sp, #0
 8016216:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8016218:	687b      	ldr	r3, [r7, #4]
 801621a:	681a      	ldr	r2, [r3, #0]
 801621c:	687b      	ldr	r3, [r7, #4]
 801621e:	429a      	cmp	r2, r3
 8016220:	bf0c      	ite	eq
 8016222:	2301      	moveq	r3, #1
 8016224:	2300      	movne	r3, #0
 8016226:	b2db      	uxtb	r3, r3
}
 8016228:	4618      	mov	r0, r3
 801622a:	370c      	adds	r7, #12
 801622c:	46bd      	mov	sp, r7
 801622e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016232:	4770      	bx	lr

08016234 <rt_data_queue_init>:
rt_err_t
rt_data_queue_init(struct rt_data_queue *queue,
                   rt_uint16_t size,
                   rt_uint16_t lwm,
                   void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
{
 8016234:	b580      	push	{r7, lr}
 8016236:	b084      	sub	sp, #16
 8016238:	af00      	add	r7, sp, #0
 801623a:	60f8      	str	r0, [r7, #12]
 801623c:	607b      	str	r3, [r7, #4]
 801623e:	460b      	mov	r3, r1
 8016240:	817b      	strh	r3, [r7, #10]
 8016242:	4613      	mov	r3, r2
 8016244:	813b      	strh	r3, [r7, #8]
    RT_ASSERT(queue != RT_NULL);
 8016246:	68fb      	ldr	r3, [r7, #12]
 8016248:	2b00      	cmp	r3, #0
 801624a:	d104      	bne.n	8016256 <rt_data_queue_init+0x22>
 801624c:	481a      	ldr	r0, [pc, #104]	; (80162b8 <rt_data_queue_init+0x84>)
 801624e:	491b      	ldr	r1, [pc, #108]	; (80162bc <rt_data_queue_init+0x88>)
 8016250:	2229      	movs	r2, #41	; 0x29
 8016252:	f7fd fd87 	bl	8013d64 <rt_assert_handler>

    queue->evt_notify = evt_notify;
 8016256:	68fb      	ldr	r3, [r7, #12]
 8016258:	687a      	ldr	r2, [r7, #4]
 801625a:	621a      	str	r2, [r3, #32]

    queue->size = size;
 801625c:	68fb      	ldr	r3, [r7, #12]
 801625e:	897a      	ldrh	r2, [r7, #10]
 8016260:	801a      	strh	r2, [r3, #0]
    queue->lwm = lwm;
 8016262:	68fb      	ldr	r3, [r7, #12]
 8016264:	893a      	ldrh	r2, [r7, #8]
 8016266:	805a      	strh	r2, [r3, #2]
    queue->waiting_lwm = RT_FALSE;
 8016268:	68fb      	ldr	r3, [r7, #12]
 801626a:	2200      	movs	r2, #0
 801626c:	605a      	str	r2, [r3, #4]

    queue->get_index = 0;
 801626e:	68fb      	ldr	r3, [r7, #12]
 8016270:	2200      	movs	r2, #0
 8016272:	811a      	strh	r2, [r3, #8]
    queue->put_index = 0;
 8016274:	68fb      	ldr	r3, [r7, #12]
 8016276:	2200      	movs	r2, #0
 8016278:	815a      	strh	r2, [r3, #10]

    rt_list_init(&(queue->suspended_push_list));
 801627a:	68fb      	ldr	r3, [r7, #12]
 801627c:	3310      	adds	r3, #16
 801627e:	4618      	mov	r0, r3
 8016280:	f7ff ff9e 	bl	80161c0 <rt_list_init>
    rt_list_init(&(queue->suspended_pop_list));
 8016284:	68fb      	ldr	r3, [r7, #12]
 8016286:	3318      	adds	r3, #24
 8016288:	4618      	mov	r0, r3
 801628a:	f7ff ff99 	bl	80161c0 <rt_list_init>

    queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
 801628e:	897b      	ldrh	r3, [r7, #10]
 8016290:	00db      	lsls	r3, r3, #3
 8016292:	4618      	mov	r0, r3
 8016294:	f7fd fe9a 	bl	8013fcc <rt_malloc>
 8016298:	4602      	mov	r2, r0
 801629a:	68fb      	ldr	r3, [r7, #12]
 801629c:	60da      	str	r2, [r3, #12]
    if (queue->queue == RT_NULL)
 801629e:	68fb      	ldr	r3, [r7, #12]
 80162a0:	68db      	ldr	r3, [r3, #12]
 80162a2:	2b00      	cmp	r3, #0
 80162a4:	d102      	bne.n	80162ac <rt_data_queue_init+0x78>
    {
        return -RT_ENOMEM;
 80162a6:	f06f 0304 	mvn.w	r3, #4
 80162aa:	e000      	b.n	80162ae <rt_data_queue_init+0x7a>
    }

    return RT_EOK;
 80162ac:	2300      	movs	r3, #0
}
 80162ae:	4618      	mov	r0, r3
 80162b0:	3710      	adds	r7, #16
 80162b2:	46bd      	mov	sp, r7
 80162b4:	bd80      	pop	{r7, pc}
 80162b6:	bf00      	nop
 80162b8:	08023528 	.word	0x08023528
 80162bc:	080250d0 	.word	0x080250d0

080162c0 <rt_data_queue_push>:

rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
                            const void *data_ptr,
                            rt_size_t data_size,
                            rt_int32_t timeout)
{
 80162c0:	b580      	push	{r7, lr}
 80162c2:	b08a      	sub	sp, #40	; 0x28
 80162c4:	af00      	add	r7, sp, #0
 80162c6:	60f8      	str	r0, [r7, #12]
 80162c8:	60b9      	str	r1, [r7, #8]
 80162ca:	607a      	str	r2, [r7, #4]
 80162cc:	603b      	str	r3, [r7, #0]
    rt_uint16_t mask;
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    
    RT_ASSERT(queue != RT_NULL);
 80162ce:	68fb      	ldr	r3, [r7, #12]
 80162d0:	2b00      	cmp	r3, #0
 80162d2:	d104      	bne.n	80162de <rt_data_queue_push+0x1e>
 80162d4:	4859      	ldr	r0, [pc, #356]	; (801643c <rt_data_queue_push+0x17c>)
 80162d6:	495a      	ldr	r1, [pc, #360]	; (8016440 <rt_data_queue_push+0x180>)
 80162d8:	224b      	movs	r2, #75	; 0x4b
 80162da:	f7fd fd43 	bl	8013d64 <rt_assert_handler>

    result = RT_EOK;
 80162de:	2300      	movs	r3, #0
 80162e0:	623b      	str	r3, [r7, #32]
    thread = rt_thread_self();
 80162e2:	f7fe fe4f 	bl	8014f84 <rt_thread_self>
 80162e6:	61f8      	str	r0, [r7, #28]
    mask = queue->size - 1;
 80162e8:	68fb      	ldr	r3, [r7, #12]
 80162ea:	881b      	ldrh	r3, [r3, #0]
 80162ec:	3b01      	subs	r3, #1
 80162ee:	837b      	strh	r3, [r7, #26]

    level = rt_hw_interrupt_disable();
 80162f0:	f7e9 ff6a 	bl	80001c8 <rt_hw_interrupt_disable>
 80162f4:	4603      	mov	r3, r0
 80162f6:	627b      	str	r3, [r7, #36]	; 0x24
    while (queue->put_index - queue->get_index == queue->size)
 80162f8:	e04e      	b.n	8016398 <rt_data_queue_push+0xd8>
    {
        queue->waiting_lwm = RT_TRUE;
 80162fa:	68fb      	ldr	r3, [r7, #12]
 80162fc:	2201      	movs	r2, #1
 80162fe:	605a      	str	r2, [r3, #4]

        /* queue is full */
        if (timeout == 0)
 8016300:	683b      	ldr	r3, [r7, #0]
 8016302:	2b00      	cmp	r3, #0
 8016304:	d103      	bne.n	801630e <rt_data_queue_push+0x4e>
        {
            result = -RT_ETIMEOUT;
 8016306:	f06f 0301 	mvn.w	r3, #1
 801630a:	623b      	str	r3, [r7, #32]

            goto __exit;
 801630c:	e081      	b.n	8016412 <rt_data_queue_push+0x152>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
 801630e:	f7e9 ff5b 	bl	80001c8 <rt_hw_interrupt_disable>
 8016312:	6178      	str	r0, [r7, #20]
 8016314:	f7fc fec8 	bl	80130a8 <rt_interrupt_get_nest>
 8016318:	4603      	mov	r3, r0
 801631a:	2b00      	cmp	r3, #0
 801631c:	d008      	beq.n	8016330 <rt_data_queue_push+0x70>
 801631e:	4849      	ldr	r0, [pc, #292]	; (8016444 <rt_data_queue_push+0x184>)
 8016320:	4947      	ldr	r1, [pc, #284]	; (8016440 <rt_data_queue_push+0x180>)
 8016322:	f7fd fca5 	bl	8013c70 <rt_kprintf>
 8016326:	4848      	ldr	r0, [pc, #288]	; (8016448 <rt_data_queue_push+0x188>)
 8016328:	4945      	ldr	r1, [pc, #276]	; (8016440 <rt_data_queue_push+0x180>)
 801632a:	225f      	movs	r2, #95	; 0x5f
 801632c:	f7fd fd1a 	bl	8013d64 <rt_assert_handler>
 8016330:	6978      	ldr	r0, [r7, #20]
 8016332:	f7e9 ff4d 	bl	80001d0 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
 8016336:	69fb      	ldr	r3, [r7, #28]
 8016338:	2200      	movs	r2, #0
 801633a:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* suspend thread on the push list */
        rt_thread_suspend(thread);
 801633c:	69f8      	ldr	r0, [r7, #28]
 801633e:	f7fe ffa7 	bl	8015290 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
 8016342:	68fb      	ldr	r3, [r7, #12]
 8016344:	f103 0210 	add.w	r2, r3, #16
 8016348:	69fb      	ldr	r3, [r7, #28]
 801634a:	3314      	adds	r3, #20
 801634c:	4610      	mov	r0, r2
 801634e:	4619      	mov	r1, r3
 8016350:	f7ff ff46 	bl	80161e0 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
 8016354:	683b      	ldr	r3, [r7, #0]
 8016356:	2b00      	cmp	r3, #0
 8016358:	dd0d      	ble.n	8016376 <rt_data_queue_push+0xb6>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 801635a:	69fb      	ldr	r3, [r7, #28]
 801635c:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8016360:	463b      	mov	r3, r7
 8016362:	4610      	mov	r0, r2
 8016364:	2100      	movs	r1, #0
 8016366:	461a      	mov	r2, r3
 8016368:	f7ff fa8c 	bl	8015884 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 801636c:	69fb      	ldr	r3, [r7, #28]
 801636e:	334c      	adds	r3, #76	; 0x4c
 8016370:	4618      	mov	r0, r3
 8016372:	f7ff f941 	bl	80155f8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8016376:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016378:	4618      	mov	r0, r3
 801637a:	f7e9 ff29 	bl	80001d0 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
 801637e:	f7fe fbc5 	bl	8014b0c <rt_schedule>

        /* thread is waked up */
        result = thread->error;
 8016382:	69fb      	ldr	r3, [r7, #28]
 8016384:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016386:	623b      	str	r3, [r7, #32]
        level = rt_hw_interrupt_disable();
 8016388:	f7e9 ff1e 	bl	80001c8 <rt_hw_interrupt_disable>
 801638c:	4603      	mov	r3, r0
 801638e:	627b      	str	r3, [r7, #36]	; 0x24
        if (result != RT_EOK) goto __exit;
 8016390:	6a3b      	ldr	r3, [r7, #32]
 8016392:	2b00      	cmp	r3, #0
 8016394:	d000      	beq.n	8016398 <rt_data_queue_push+0xd8>
 8016396:	e03c      	b.n	8016412 <rt_data_queue_push+0x152>
    result = RT_EOK;
    thread = rt_thread_self();
    mask = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->put_index - queue->get_index == queue->size)
 8016398:	68fb      	ldr	r3, [r7, #12]
 801639a:	895b      	ldrh	r3, [r3, #10]
 801639c:	461a      	mov	r2, r3
 801639e:	68fb      	ldr	r3, [r7, #12]
 80163a0:	891b      	ldrh	r3, [r3, #8]
 80163a2:	1ad3      	subs	r3, r2, r3
 80163a4:	68fa      	ldr	r2, [r7, #12]
 80163a6:	8812      	ldrh	r2, [r2, #0]
 80163a8:	4293      	cmp	r3, r2
 80163aa:	d0a6      	beq.n	80162fa <rt_data_queue_push+0x3a>
        result = thread->error;
        level = rt_hw_interrupt_disable();
        if (result != RT_EOK) goto __exit;
    }

    queue->queue[queue->put_index & mask].data_ptr  = data_ptr;
 80163ac:	68fb      	ldr	r3, [r7, #12]
 80163ae:	68da      	ldr	r2, [r3, #12]
 80163b0:	68fb      	ldr	r3, [r7, #12]
 80163b2:	8959      	ldrh	r1, [r3, #10]
 80163b4:	8b7b      	ldrh	r3, [r7, #26]
 80163b6:	400b      	ands	r3, r1
 80163b8:	b29b      	uxth	r3, r3
 80163ba:	00db      	lsls	r3, r3, #3
 80163bc:	4413      	add	r3, r2
 80163be:	68ba      	ldr	r2, [r7, #8]
 80163c0:	601a      	str	r2, [r3, #0]
    queue->queue[queue->put_index & mask].data_size = data_size;
 80163c2:	68fb      	ldr	r3, [r7, #12]
 80163c4:	68da      	ldr	r2, [r3, #12]
 80163c6:	68fb      	ldr	r3, [r7, #12]
 80163c8:	8959      	ldrh	r1, [r3, #10]
 80163ca:	8b7b      	ldrh	r3, [r7, #26]
 80163cc:	400b      	ands	r3, r1
 80163ce:	b29b      	uxth	r3, r3
 80163d0:	00db      	lsls	r3, r3, #3
 80163d2:	4413      	add	r3, r2
 80163d4:	687a      	ldr	r2, [r7, #4]
 80163d6:	605a      	str	r2, [r3, #4]
    queue->put_index += 1;
 80163d8:	68fb      	ldr	r3, [r7, #12]
 80163da:	895b      	ldrh	r3, [r3, #10]
 80163dc:	3301      	adds	r3, #1
 80163de:	b29a      	uxth	r2, r3
 80163e0:	68fb      	ldr	r3, [r7, #12]
 80163e2:	815a      	strh	r2, [r3, #10]

    if (!rt_list_isempty(&(queue->suspended_pop_list)))
 80163e4:	68fb      	ldr	r3, [r7, #12]
 80163e6:	3318      	adds	r3, #24
 80163e8:	4618      	mov	r0, r3
 80163ea:	f7ff ff11 	bl	8016210 <rt_list_isempty>
 80163ee:	4603      	mov	r3, r0
 80163f0:	2b00      	cmp	r3, #0
 80163f2:	d10e      	bne.n	8016412 <rt_data_queue_push+0x152>
    {
        /* there is at least one thread in suspended list */

        /* get thread entry */
        thread = rt_list_entry(queue->suspended_pop_list.next,
 80163f4:	68fb      	ldr	r3, [r7, #12]
 80163f6:	699b      	ldr	r3, [r3, #24]
 80163f8:	3b14      	subs	r3, #20
 80163fa:	61fb      	str	r3, [r7, #28]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
 80163fc:	69f8      	ldr	r0, [r7, #28]
 80163fe:	f7fe ff77 	bl	80152f0 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
 8016402:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016404:	4618      	mov	r0, r3
 8016406:	f7e9 fee3 	bl	80001d0 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
 801640a:	f7fe fb7f 	bl	8014b0c <rt_schedule>

        return result;
 801640e:	6a3b      	ldr	r3, [r7, #32]
 8016410:	e010      	b.n	8016434 <rt_data_queue_push+0x174>
    }

__exit:
    rt_hw_interrupt_enable(level);
 8016412:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016414:	4618      	mov	r0, r3
 8016416:	f7e9 fedb 	bl	80001d0 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
 801641a:	6a3b      	ldr	r3, [r7, #32]
 801641c:	2b00      	cmp	r3, #0
 801641e:	d108      	bne.n	8016432 <rt_data_queue_push+0x172>
 8016420:	68fb      	ldr	r3, [r7, #12]
 8016422:	6a1b      	ldr	r3, [r3, #32]
 8016424:	2b00      	cmp	r3, #0
 8016426:	d004      	beq.n	8016432 <rt_data_queue_push+0x172>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
 8016428:	68fb      	ldr	r3, [r7, #12]
 801642a:	6a1b      	ldr	r3, [r3, #32]
 801642c:	68f8      	ldr	r0, [r7, #12]
 801642e:	2102      	movs	r1, #2
 8016430:	4798      	blx	r3
    }

    return result;
 8016432:	6a3b      	ldr	r3, [r7, #32]
}
 8016434:	4618      	mov	r0, r3
 8016436:	3728      	adds	r7, #40	; 0x28
 8016438:	46bd      	mov	sp, r7
 801643a:	bd80      	pop	{r7, pc}
 801643c:	08023528 	.word	0x08023528
 8016440:	080250e4 	.word	0x080250e4
 8016444:	0802353c 	.word	0x0802353c
 8016448:	08023560 	.word	0x08023560

0801644c <rt_data_queue_pop>:

rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
                           const void** data_ptr,
                           rt_size_t *size, 
                           rt_int32_t timeout)
{
 801644c:	b580      	push	{r7, lr}
 801644e:	b08a      	sub	sp, #40	; 0x28
 8016450:	af00      	add	r7, sp, #0
 8016452:	60f8      	str	r0, [r7, #12]
 8016454:	60b9      	str	r1, [r7, #8]
 8016456:	607a      	str	r2, [r7, #4]
 8016458:	603b      	str	r3, [r7, #0]
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
 801645a:	68fb      	ldr	r3, [r7, #12]
 801645c:	2b00      	cmp	r3, #0
 801645e:	d104      	bne.n	801646a <rt_data_queue_pop+0x1e>
 8016460:	486c      	ldr	r0, [pc, #432]	; (8016614 <rt_data_queue_pop+0x1c8>)
 8016462:	496d      	ldr	r1, [pc, #436]	; (8016618 <rt_data_queue_pop+0x1cc>)
 8016464:	22a9      	movs	r2, #169	; 0xa9
 8016466:	f7fd fc7d 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(data_ptr != RT_NULL);
 801646a:	68bb      	ldr	r3, [r7, #8]
 801646c:	2b00      	cmp	r3, #0
 801646e:	d104      	bne.n	801647a <rt_data_queue_pop+0x2e>
 8016470:	486a      	ldr	r0, [pc, #424]	; (801661c <rt_data_queue_pop+0x1d0>)
 8016472:	4969      	ldr	r1, [pc, #420]	; (8016618 <rt_data_queue_pop+0x1cc>)
 8016474:	22aa      	movs	r2, #170	; 0xaa
 8016476:	f7fd fc75 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(size != RT_NULL);
 801647a:	687b      	ldr	r3, [r7, #4]
 801647c:	2b00      	cmp	r3, #0
 801647e:	d104      	bne.n	801648a <rt_data_queue_pop+0x3e>
 8016480:	4867      	ldr	r0, [pc, #412]	; (8016620 <rt_data_queue_pop+0x1d4>)
 8016482:	4965      	ldr	r1, [pc, #404]	; (8016618 <rt_data_queue_pop+0x1cc>)
 8016484:	22ab      	movs	r2, #171	; 0xab
 8016486:	f7fd fc6d 	bl	8013d64 <rt_assert_handler>

    result = RT_EOK;
 801648a:	2300      	movs	r3, #0
 801648c:	623b      	str	r3, [r7, #32]
    thread = rt_thread_self();
 801648e:	f7fe fd79 	bl	8014f84 <rt_thread_self>
 8016492:	61f8      	str	r0, [r7, #28]
    mask   = queue->size - 1;
 8016494:	68fb      	ldr	r3, [r7, #12]
 8016496:	881b      	ldrh	r3, [r3, #0]
 8016498:	3b01      	subs	r3, #1
 801649a:	837b      	strh	r3, [r7, #26]

    level = rt_hw_interrupt_disable();
 801649c:	f7e9 fe94 	bl	80001c8 <rt_hw_interrupt_disable>
 80164a0:	4603      	mov	r3, r0
 80164a2:	627b      	str	r3, [r7, #36]	; 0x24
    while (queue->get_index == queue->put_index)
 80164a4:	e04b      	b.n	801653e <rt_data_queue_pop+0xf2>
    {
        /* queue is empty */
        if (timeout == 0)
 80164a6:	683b      	ldr	r3, [r7, #0]
 80164a8:	2b00      	cmp	r3, #0
 80164aa:	d103      	bne.n	80164b4 <rt_data_queue_pop+0x68>
        {
            result = -RT_ETIMEOUT;
 80164ac:	f06f 0301 	mvn.w	r3, #1
 80164b0:	623b      	str	r3, [r7, #32]
            goto __exit;
 80164b2:	e099      	b.n	80165e8 <rt_data_queue_pop+0x19c>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
 80164b4:	f7e9 fe88 	bl	80001c8 <rt_hw_interrupt_disable>
 80164b8:	6178      	str	r0, [r7, #20]
 80164ba:	f7fc fdf5 	bl	80130a8 <rt_interrupt_get_nest>
 80164be:	4603      	mov	r3, r0
 80164c0:	2b00      	cmp	r3, #0
 80164c2:	d008      	beq.n	80164d6 <rt_data_queue_pop+0x8a>
 80164c4:	4857      	ldr	r0, [pc, #348]	; (8016624 <rt_data_queue_pop+0x1d8>)
 80164c6:	4954      	ldr	r1, [pc, #336]	; (8016618 <rt_data_queue_pop+0x1cc>)
 80164c8:	f7fd fbd2 	bl	8013c70 <rt_kprintf>
 80164cc:	4856      	ldr	r0, [pc, #344]	; (8016628 <rt_data_queue_pop+0x1dc>)
 80164ce:	4952      	ldr	r1, [pc, #328]	; (8016618 <rt_data_queue_pop+0x1cc>)
 80164d0:	22bc      	movs	r2, #188	; 0xbc
 80164d2:	f7fd fc47 	bl	8013d64 <rt_assert_handler>
 80164d6:	6978      	ldr	r0, [r7, #20]
 80164d8:	f7e9 fe7a 	bl	80001d0 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
 80164dc:	69fb      	ldr	r3, [r7, #28]
 80164de:	2200      	movs	r2, #0
 80164e0:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* suspend thread on the pop list */
        rt_thread_suspend(thread);
 80164e2:	69f8      	ldr	r0, [r7, #28]
 80164e4:	f7fe fed4 	bl	8015290 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
 80164e8:	68fb      	ldr	r3, [r7, #12]
 80164ea:	f103 0218 	add.w	r2, r3, #24
 80164ee:	69fb      	ldr	r3, [r7, #28]
 80164f0:	3314      	adds	r3, #20
 80164f2:	4610      	mov	r0, r2
 80164f4:	4619      	mov	r1, r3
 80164f6:	f7ff fe73 	bl	80161e0 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
 80164fa:	683b      	ldr	r3, [r7, #0]
 80164fc:	2b00      	cmp	r3, #0
 80164fe:	dd0d      	ble.n	801651c <rt_data_queue_pop+0xd0>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 8016500:	69fb      	ldr	r3, [r7, #28]
 8016502:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8016506:	463b      	mov	r3, r7
 8016508:	4610      	mov	r0, r2
 801650a:	2100      	movs	r1, #0
 801650c:	461a      	mov	r2, r3
 801650e:	f7ff f9b9 	bl	8015884 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 8016512:	69fb      	ldr	r3, [r7, #28]
 8016514:	334c      	adds	r3, #76	; 0x4c
 8016516:	4618      	mov	r0, r3
 8016518:	f7ff f86e 	bl	80155f8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 801651c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801651e:	4618      	mov	r0, r3
 8016520:	f7e9 fe56 	bl	80001d0 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
 8016524:	f7fe faf2 	bl	8014b0c <rt_schedule>

        /* thread is waked up */
        result = thread->error;
 8016528:	69fb      	ldr	r3, [r7, #28]
 801652a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801652c:	623b      	str	r3, [r7, #32]
        level  = rt_hw_interrupt_disable();
 801652e:	f7e9 fe4b 	bl	80001c8 <rt_hw_interrupt_disable>
 8016532:	4603      	mov	r3, r0
 8016534:	627b      	str	r3, [r7, #36]	; 0x24
        if (result != RT_EOK)
 8016536:	6a3b      	ldr	r3, [r7, #32]
 8016538:	2b00      	cmp	r3, #0
 801653a:	d000      	beq.n	801653e <rt_data_queue_pop+0xf2>
            goto __exit;
 801653c:	e054      	b.n	80165e8 <rt_data_queue_pop+0x19c>
    result = RT_EOK;
    thread = rt_thread_self();
    mask   = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->get_index == queue->put_index)
 801653e:	68fb      	ldr	r3, [r7, #12]
 8016540:	891a      	ldrh	r2, [r3, #8]
 8016542:	68fb      	ldr	r3, [r7, #12]
 8016544:	895b      	ldrh	r3, [r3, #10]
 8016546:	429a      	cmp	r2, r3
 8016548:	d0ad      	beq.n	80164a6 <rt_data_queue_pop+0x5a>
        level  = rt_hw_interrupt_disable();
        if (result != RT_EOK)
            goto __exit;
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
 801654a:	68fb      	ldr	r3, [r7, #12]
 801654c:	68da      	ldr	r2, [r3, #12]
 801654e:	68fb      	ldr	r3, [r7, #12]
 8016550:	8919      	ldrh	r1, [r3, #8]
 8016552:	8b7b      	ldrh	r3, [r7, #26]
 8016554:	400b      	ands	r3, r1
 8016556:	b29b      	uxth	r3, r3
 8016558:	00db      	lsls	r3, r3, #3
 801655a:	4413      	add	r3, r2
 801655c:	681a      	ldr	r2, [r3, #0]
 801655e:	68bb      	ldr	r3, [r7, #8]
 8016560:	601a      	str	r2, [r3, #0]
    *size     = queue->queue[queue->get_index & mask].data_size;
 8016562:	68fb      	ldr	r3, [r7, #12]
 8016564:	68da      	ldr	r2, [r3, #12]
 8016566:	68fb      	ldr	r3, [r7, #12]
 8016568:	8919      	ldrh	r1, [r3, #8]
 801656a:	8b7b      	ldrh	r3, [r7, #26]
 801656c:	400b      	ands	r3, r1
 801656e:	b29b      	uxth	r3, r3
 8016570:	00db      	lsls	r3, r3, #3
 8016572:	4413      	add	r3, r2
 8016574:	685a      	ldr	r2, [r3, #4]
 8016576:	687b      	ldr	r3, [r7, #4]
 8016578:	601a      	str	r2, [r3, #0]

    queue->get_index += 1;
 801657a:	68fb      	ldr	r3, [r7, #12]
 801657c:	891b      	ldrh	r3, [r3, #8]
 801657e:	3301      	adds	r3, #1
 8016580:	b29a      	uxth	r2, r3
 8016582:	68fb      	ldr	r3, [r7, #12]
 8016584:	811a      	strh	r2, [r3, #8]

    if ((queue->waiting_lwm == RT_TRUE) && 
 8016586:	68fb      	ldr	r3, [r7, #12]
 8016588:	685b      	ldr	r3, [r3, #4]
 801658a:	2b01      	cmp	r3, #1
 801658c:	d12c      	bne.n	80165e8 <rt_data_queue_pop+0x19c>
        (queue->put_index - queue->get_index) <= queue->lwm)
 801658e:	68fb      	ldr	r3, [r7, #12]
 8016590:	895b      	ldrh	r3, [r3, #10]
 8016592:	461a      	mov	r2, r3
 8016594:	68fb      	ldr	r3, [r7, #12]
 8016596:	891b      	ldrh	r3, [r3, #8]
 8016598:	1ad3      	subs	r3, r2, r3
 801659a:	68fa      	ldr	r2, [r7, #12]
 801659c:	8852      	ldrh	r2, [r2, #2]
    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
    *size     = queue->queue[queue->get_index & mask].data_size;

    queue->get_index += 1;

    if ((queue->waiting_lwm == RT_TRUE) && 
 801659e:	4293      	cmp	r3, r2
 80165a0:	dc22      	bgt.n	80165e8 <rt_data_queue_pop+0x19c>
        (queue->put_index - queue->get_index) <= queue->lwm)
    {
        queue->waiting_lwm = RT_FALSE;
 80165a2:	68fb      	ldr	r3, [r7, #12]
 80165a4:	2200      	movs	r2, #0
 80165a6:	605a      	str	r2, [r3, #4]

        /*
         * there is at least one thread in suspended list
         * and less than low water mark
         */
        if (!rt_list_isempty(&(queue->suspended_push_list)))
 80165a8:	68fb      	ldr	r3, [r7, #12]
 80165aa:	3310      	adds	r3, #16
 80165ac:	4618      	mov	r0, r3
 80165ae:	f7ff fe2f 	bl	8016210 <rt_list_isempty>
 80165b2:	4603      	mov	r3, r0
 80165b4:	2b00      	cmp	r3, #0
 80165b6:	d10c      	bne.n	80165d2 <rt_data_queue_pop+0x186>
        {
            /* get thread entry */
            thread = rt_list_entry(queue->suspended_push_list.next,
 80165b8:	68fb      	ldr	r3, [r7, #12]
 80165ba:	691b      	ldr	r3, [r3, #16]
 80165bc:	3b14      	subs	r3, #20
 80165be:	61fb      	str	r3, [r7, #28]
                                   struct rt_thread,
                                   tlist);

            /* resume it */
            rt_thread_resume(thread);
 80165c0:	69f8      	ldr	r0, [r7, #28]
 80165c2:	f7fe fe95 	bl	80152f0 <rt_thread_resume>
            rt_hw_interrupt_enable(level);
 80165c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80165c8:	4618      	mov	r0, r3
 80165ca:	f7e9 fe01 	bl	80001d0 <rt_hw_interrupt_enable>

            /* perform a schedule */
            rt_schedule();
 80165ce:	f7fe fa9d 	bl	8014b0c <rt_schedule>
        }

        if (queue->evt_notify != RT_NULL)
 80165d2:	68fb      	ldr	r3, [r7, #12]
 80165d4:	6a1b      	ldr	r3, [r3, #32]
 80165d6:	2b00      	cmp	r3, #0
 80165d8:	d004      	beq.n	80165e4 <rt_data_queue_pop+0x198>
            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
 80165da:	68fb      	ldr	r3, [r7, #12]
 80165dc:	6a1b      	ldr	r3, [r3, #32]
 80165de:	68f8      	ldr	r0, [r7, #12]
 80165e0:	2103      	movs	r1, #3
 80165e2:	4798      	blx	r3

        return result;
 80165e4:	6a3b      	ldr	r3, [r7, #32]
 80165e6:	e010      	b.n	801660a <rt_data_queue_pop+0x1be>
    }

__exit:
    rt_hw_interrupt_enable(level);
 80165e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80165ea:	4618      	mov	r0, r3
 80165ec:	f7e9 fdf0 	bl	80001d0 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
 80165f0:	6a3b      	ldr	r3, [r7, #32]
 80165f2:	2b00      	cmp	r3, #0
 80165f4:	d108      	bne.n	8016608 <rt_data_queue_pop+0x1bc>
 80165f6:	68fb      	ldr	r3, [r7, #12]
 80165f8:	6a1b      	ldr	r3, [r3, #32]
 80165fa:	2b00      	cmp	r3, #0
 80165fc:	d004      	beq.n	8016608 <rt_data_queue_pop+0x1bc>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
 80165fe:	68fb      	ldr	r3, [r7, #12]
 8016600:	6a1b      	ldr	r3, [r3, #32]
 8016602:	68f8      	ldr	r0, [r7, #12]
 8016604:	2101      	movs	r1, #1
 8016606:	4798      	blx	r3
    }

    return result;
 8016608:	6a3b      	ldr	r3, [r7, #32]
}
 801660a:	4618      	mov	r0, r3
 801660c:	3728      	adds	r7, #40	; 0x28
 801660e:	46bd      	mov	sp, r7
 8016610:	bd80      	pop	{r7, pc}
 8016612:	bf00      	nop
 8016614:	08023528 	.word	0x08023528
 8016618:	080250f8 	.word	0x080250f8
 801661c:	08023564 	.word	0x08023564
 8016620:	08023578 	.word	0x08023578
 8016624:	0802353c 	.word	0x0802353c
 8016628:	08023560 	.word	0x08023560

0801662c <rt_data_queue_peak>:
RTM_EXPORT(rt_data_queue_pop);

rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
                            const void** data_ptr,
                            rt_size_t *size)
{
 801662c:	b580      	push	{r7, lr}
 801662e:	b086      	sub	sp, #24
 8016630:	af00      	add	r7, sp, #0
 8016632:	60f8      	str	r0, [r7, #12]
 8016634:	60b9      	str	r1, [r7, #8]
 8016636:	607a      	str	r2, [r7, #4]
    rt_ubase_t  level;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
 8016638:	68fb      	ldr	r3, [r7, #12]
 801663a:	2b00      	cmp	r3, #0
 801663c:	d105      	bne.n	801664a <rt_data_queue_peak+0x1e>
 801663e:	481e      	ldr	r0, [pc, #120]	; (80166b8 <rt_data_queue_peak+0x8c>)
 8016640:	491e      	ldr	r1, [pc, #120]	; (80166bc <rt_data_queue_peak+0x90>)
 8016642:	f44f 7288 	mov.w	r2, #272	; 0x110
 8016646:	f7fd fb8d 	bl	8013d64 <rt_assert_handler>

    mask = queue->size - 1;
 801664a:	68fb      	ldr	r3, [r7, #12]
 801664c:	881b      	ldrh	r3, [r3, #0]
 801664e:	3b01      	subs	r3, #1
 8016650:	82fb      	strh	r3, [r7, #22]

    level = rt_hw_interrupt_disable();
 8016652:	f7e9 fdb9 	bl	80001c8 <rt_hw_interrupt_disable>
 8016656:	4603      	mov	r3, r0
 8016658:	613b      	str	r3, [r7, #16]

    if (queue->get_index == queue->put_index) 
 801665a:	68fb      	ldr	r3, [r7, #12]
 801665c:	891a      	ldrh	r2, [r3, #8]
 801665e:	68fb      	ldr	r3, [r7, #12]
 8016660:	895b      	ldrh	r3, [r3, #10]
 8016662:	429a      	cmp	r2, r3
 8016664:	d106      	bne.n	8016674 <rt_data_queue_peak+0x48>
    {
        rt_hw_interrupt_enable(level);
 8016666:	693b      	ldr	r3, [r7, #16]
 8016668:	4618      	mov	r0, r3
 801666a:	f7e9 fdb1 	bl	80001d0 <rt_hw_interrupt_enable>
        
        return -RT_EEMPTY;
 801666e:	f06f 0303 	mvn.w	r3, #3
 8016672:	e01c      	b.n	80166ae <rt_data_queue_peak+0x82>
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
 8016674:	68fb      	ldr	r3, [r7, #12]
 8016676:	68da      	ldr	r2, [r3, #12]
 8016678:	68fb      	ldr	r3, [r7, #12]
 801667a:	8919      	ldrh	r1, [r3, #8]
 801667c:	8afb      	ldrh	r3, [r7, #22]
 801667e:	400b      	ands	r3, r1
 8016680:	b29b      	uxth	r3, r3
 8016682:	00db      	lsls	r3, r3, #3
 8016684:	4413      	add	r3, r2
 8016686:	681a      	ldr	r2, [r3, #0]
 8016688:	68bb      	ldr	r3, [r7, #8]
 801668a:	601a      	str	r2, [r3, #0]
    *size     = queue->queue[queue->get_index & mask].data_size;
 801668c:	68fb      	ldr	r3, [r7, #12]
 801668e:	68da      	ldr	r2, [r3, #12]
 8016690:	68fb      	ldr	r3, [r7, #12]
 8016692:	8919      	ldrh	r1, [r3, #8]
 8016694:	8afb      	ldrh	r3, [r7, #22]
 8016696:	400b      	ands	r3, r1
 8016698:	b29b      	uxth	r3, r3
 801669a:	00db      	lsls	r3, r3, #3
 801669c:	4413      	add	r3, r2
 801669e:	685a      	ldr	r2, [r3, #4]
 80166a0:	687b      	ldr	r3, [r7, #4]
 80166a2:	601a      	str	r2, [r3, #0]

    rt_hw_interrupt_enable(level);
 80166a4:	693b      	ldr	r3, [r7, #16]
 80166a6:	4618      	mov	r0, r3
 80166a8:	f7e9 fd92 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 80166ac:	2300      	movs	r3, #0
}
 80166ae:	4618      	mov	r0, r3
 80166b0:	3718      	adds	r7, #24
 80166b2:	46bd      	mov	sp, r7
 80166b4:	bd80      	pop	{r7, pc}
 80166b6:	bf00      	nop
 80166b8:	08023528 	.word	0x08023528
 80166bc:	0802510c 	.word	0x0802510c

080166c0 <rt_i2c_core_init>:

    return (ret > 0) ? count : ret;
}

int rt_i2c_core_init(void)
{
 80166c0:	b480      	push	{r7}
 80166c2:	af00      	add	r7, sp, #0
    return 0;
 80166c4:	2300      	movs	r3, #0
}
 80166c6:	4618      	mov	r0, r3
 80166c8:	46bd      	mov	sp, r7
 80166ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80166ce:	4770      	bx	lr

080166d0 <rt_mtd_nand_read_id>:
};

rt_err_t rt_mtd_nand_register_device(const char* name, struct rt_mtd_nand_device* device);

rt_inline rt_uint32_t rt_mtd_nand_read_id(struct rt_mtd_nand_device* device)
{
 80166d0:	b580      	push	{r7, lr}
 80166d2:	b082      	sub	sp, #8
 80166d4:	af00      	add	r7, sp, #0
 80166d6:	6078      	str	r0, [r7, #4]
	return device->ops->read_id(device);
 80166d8:	687b      	ldr	r3, [r7, #4]
 80166da:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80166dc:	681b      	ldr	r3, [r3, #0]
 80166de:	6878      	ldr	r0, [r7, #4]
 80166e0:	4798      	blx	r3
 80166e2:	4603      	mov	r3, r0
}
 80166e4:	4618      	mov	r0, r3
 80166e6:	3708      	adds	r7, #8
 80166e8:	46bd      	mov	sp, r7
 80166ea:	bd80      	pop	{r7, pc}

080166ec <rt_mtd_nand_read>:
rt_inline rt_err_t rt_mtd_nand_read(
	struct rt_mtd_nand_device* device,
	rt_off_t page,
	rt_uint8_t* data, rt_uint32_t data_len,
	rt_uint8_t * spare, rt_uint32_t spare_len)
{
 80166ec:	b590      	push	{r4, r7, lr}
 80166ee:	b087      	sub	sp, #28
 80166f0:	af02      	add	r7, sp, #8
 80166f2:	60f8      	str	r0, [r7, #12]
 80166f4:	60b9      	str	r1, [r7, #8]
 80166f6:	607a      	str	r2, [r7, #4]
 80166f8:	603b      	str	r3, [r7, #0]
	return device->ops->read_page(device, page, data, data_len, spare, spare_len);
 80166fa:	68fb      	ldr	r3, [r7, #12]
 80166fc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80166fe:	685c      	ldr	r4, [r3, #4]
 8016700:	6a3b      	ldr	r3, [r7, #32]
 8016702:	9300      	str	r3, [sp, #0]
 8016704:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016706:	9301      	str	r3, [sp, #4]
 8016708:	68f8      	ldr	r0, [r7, #12]
 801670a:	68b9      	ldr	r1, [r7, #8]
 801670c:	687a      	ldr	r2, [r7, #4]
 801670e:	683b      	ldr	r3, [r7, #0]
 8016710:	47a0      	blx	r4
 8016712:	4603      	mov	r3, r0
}
 8016714:	4618      	mov	r0, r3
 8016716:	3714      	adds	r7, #20
 8016718:	46bd      	mov	sp, r7
 801671a:	bd90      	pop	{r4, r7, pc}

0801671c <rt_mtd_nand_write>:
rt_inline rt_err_t rt_mtd_nand_write(
	struct rt_mtd_nand_device* device,
	rt_off_t page,
	const rt_uint8_t* data, rt_uint32_t data_len,
	const rt_uint8_t * spare, rt_uint32_t spare_len)
{
 801671c:	b590      	push	{r4, r7, lr}
 801671e:	b087      	sub	sp, #28
 8016720:	af02      	add	r7, sp, #8
 8016722:	60f8      	str	r0, [r7, #12]
 8016724:	60b9      	str	r1, [r7, #8]
 8016726:	607a      	str	r2, [r7, #4]
 8016728:	603b      	str	r3, [r7, #0]
	return device->ops->write_page(device, page, data, data_len, spare, spare_len);
 801672a:	68fb      	ldr	r3, [r7, #12]
 801672c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801672e:	689c      	ldr	r4, [r3, #8]
 8016730:	6a3b      	ldr	r3, [r7, #32]
 8016732:	9300      	str	r3, [sp, #0]
 8016734:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016736:	9301      	str	r3, [sp, #4]
 8016738:	68f8      	ldr	r0, [r7, #12]
 801673a:	68b9      	ldr	r1, [r7, #8]
 801673c:	687a      	ldr	r2, [r7, #4]
 801673e:	683b      	ldr	r3, [r7, #0]
 8016740:	47a0      	blx	r4
 8016742:	4603      	mov	r3, r0
}
 8016744:	4618      	mov	r0, r3
 8016746:	3714      	adds	r7, #20
 8016748:	46bd      	mov	sp, r7
 801674a:	bd90      	pop	{r4, r7, pc}

0801674c <rt_mtd_nand_erase_block>:
{
	return device->ops->move_page(device, src_page, dst_page);
}

rt_inline rt_err_t rt_mtd_nand_erase_block(struct rt_mtd_nand_device* device, rt_uint32_t block)
{
 801674c:	b580      	push	{r7, lr}
 801674e:	b082      	sub	sp, #8
 8016750:	af00      	add	r7, sp, #0
 8016752:	6078      	str	r0, [r7, #4]
 8016754:	6039      	str	r1, [r7, #0]
	return device->ops->erase_block(device, block);
 8016756:	687b      	ldr	r3, [r7, #4]
 8016758:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801675a:	691b      	ldr	r3, [r3, #16]
 801675c:	6878      	ldr	r0, [r7, #4]
 801675e:	6839      	ldr	r1, [r7, #0]
 8016760:	4798      	blx	r3
 8016762:	4603      	mov	r3, r0
}
 8016764:	4618      	mov	r0, r3
 8016766:	3708      	adds	r7, #8
 8016768:	46bd      	mov	sp, r7
 801676a:	bd80      	pop	{r7, pc}

0801676c <mtd_dump_hex>:
#if defined(RT_MTD_NAND_DEBUG) && defined(RT_USING_FINSH)
#include <finsh.h>
#define __is_print(ch) ((unsigned int)((ch) - ' ') < 127u - ' ')

static void mtd_dump_hex(const rt_uint8_t *ptr, rt_size_t buflen)
{
 801676c:	b580      	push	{r7, lr}
 801676e:	b086      	sub	sp, #24
 8016770:	af00      	add	r7, sp, #0
 8016772:	6078      	str	r0, [r7, #4]
 8016774:	6039      	str	r1, [r7, #0]
	unsigned char *buf = (unsigned char*)ptr;
 8016776:	687b      	ldr	r3, [r7, #4]
 8016778:	60fb      	str	r3, [r7, #12]
	int i, j;
	for (i=0; i<buflen; i+=16) 
 801677a:	2300      	movs	r3, #0
 801677c:	617b      	str	r3, [r7, #20]
 801677e:	e052      	b.n	8016826 <mtd_dump_hex+0xba>
	{
		rt_kprintf("%06x: ", i);
 8016780:	482c      	ldr	r0, [pc, #176]	; (8016834 <mtd_dump_hex+0xc8>)
 8016782:	6979      	ldr	r1, [r7, #20]
 8016784:	f7fd fa74 	bl	8013c70 <rt_kprintf>
		for (j=0; j<16; j++)
 8016788:	2300      	movs	r3, #0
 801678a:	613b      	str	r3, [r7, #16]
 801678c:	e018      	b.n	80167c0 <mtd_dump_hex+0x54>
			if (i+j < buflen)
 801678e:	697a      	ldr	r2, [r7, #20]
 8016790:	693b      	ldr	r3, [r7, #16]
 8016792:	4413      	add	r3, r2
 8016794:	461a      	mov	r2, r3
 8016796:	683b      	ldr	r3, [r7, #0]
 8016798:	429a      	cmp	r2, r3
 801679a:	d20b      	bcs.n	80167b4 <mtd_dump_hex+0x48>
				rt_kprintf("%02x ", buf[i+j]);
 801679c:	697a      	ldr	r2, [r7, #20]
 801679e:	693b      	ldr	r3, [r7, #16]
 80167a0:	4413      	add	r3, r2
 80167a2:	461a      	mov	r2, r3
 80167a4:	68fb      	ldr	r3, [r7, #12]
 80167a6:	4413      	add	r3, r2
 80167a8:	781b      	ldrb	r3, [r3, #0]
 80167aa:	4823      	ldr	r0, [pc, #140]	; (8016838 <mtd_dump_hex+0xcc>)
 80167ac:	4619      	mov	r1, r3
 80167ae:	f7fd fa5f 	bl	8013c70 <rt_kprintf>
 80167b2:	e002      	b.n	80167ba <mtd_dump_hex+0x4e>
			else
				rt_kprintf("   ");
 80167b4:	4821      	ldr	r0, [pc, #132]	; (801683c <mtd_dump_hex+0xd0>)
 80167b6:	f7fd fa5b 	bl	8013c70 <rt_kprintf>
	unsigned char *buf = (unsigned char*)ptr;
	int i, j;
	for (i=0; i<buflen; i+=16) 
	{
		rt_kprintf("%06x: ", i);
		for (j=0; j<16; j++)
 80167ba:	693b      	ldr	r3, [r7, #16]
 80167bc:	3301      	adds	r3, #1
 80167be:	613b      	str	r3, [r7, #16]
 80167c0:	693b      	ldr	r3, [r7, #16]
 80167c2:	2b0f      	cmp	r3, #15
 80167c4:	dde3      	ble.n	801678e <mtd_dump_hex+0x22>
			if (i+j < buflen)
				rt_kprintf("%02x ", buf[i+j]);
			else
				rt_kprintf("   ");
		rt_kprintf(" ");
 80167c6:	481e      	ldr	r0, [pc, #120]	; (8016840 <mtd_dump_hex+0xd4>)
 80167c8:	f7fd fa52 	bl	8013c70 <rt_kprintf>
		for (j=0; j<16; j++)
 80167cc:	2300      	movs	r3, #0
 80167ce:	613b      	str	r3, [r7, #16]
 80167d0:	e020      	b.n	8016814 <mtd_dump_hex+0xa8>
			if (i+j < buflen)
 80167d2:	697a      	ldr	r2, [r7, #20]
 80167d4:	693b      	ldr	r3, [r7, #16]
 80167d6:	4413      	add	r3, r2
 80167d8:	461a      	mov	r2, r3
 80167da:	683b      	ldr	r3, [r7, #0]
 80167dc:	429a      	cmp	r2, r3
 80167de:	d216      	bcs.n	801680e <mtd_dump_hex+0xa2>
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
 80167e0:	697a      	ldr	r2, [r7, #20]
 80167e2:	693b      	ldr	r3, [r7, #16]
 80167e4:	4413      	add	r3, r2
 80167e6:	461a      	mov	r2, r3
 80167e8:	68fb      	ldr	r3, [r7, #12]
 80167ea:	4413      	add	r3, r2
 80167ec:	781b      	ldrb	r3, [r3, #0]
 80167ee:	3b20      	subs	r3, #32
 80167f0:	2b5e      	cmp	r3, #94	; 0x5e
 80167f2:	d807      	bhi.n	8016804 <mtd_dump_hex+0x98>
 80167f4:	697a      	ldr	r2, [r7, #20]
 80167f6:	693b      	ldr	r3, [r7, #16]
 80167f8:	4413      	add	r3, r2
 80167fa:	461a      	mov	r2, r3
 80167fc:	68fb      	ldr	r3, [r7, #12]
 80167fe:	4413      	add	r3, r2
 8016800:	781b      	ldrb	r3, [r3, #0]
 8016802:	e000      	b.n	8016806 <mtd_dump_hex+0x9a>
 8016804:	232e      	movs	r3, #46	; 0x2e
 8016806:	480f      	ldr	r0, [pc, #60]	; (8016844 <mtd_dump_hex+0xd8>)
 8016808:	4619      	mov	r1, r3
 801680a:	f7fd fa31 	bl	8013c70 <rt_kprintf>
			if (i+j < buflen)
				rt_kprintf("%02x ", buf[i+j]);
			else
				rt_kprintf("   ");
		rt_kprintf(" ");
		for (j=0; j<16; j++)
 801680e:	693b      	ldr	r3, [r7, #16]
 8016810:	3301      	adds	r3, #1
 8016812:	613b      	str	r3, [r7, #16]
 8016814:	693b      	ldr	r3, [r7, #16]
 8016816:	2b0f      	cmp	r3, #15
 8016818:	dddb      	ble.n	80167d2 <mtd_dump_hex+0x66>
			if (i+j < buflen)
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
		rt_kprintf("\n");
 801681a:	480b      	ldr	r0, [pc, #44]	; (8016848 <mtd_dump_hex+0xdc>)
 801681c:	f7fd fa28 	bl	8013c70 <rt_kprintf>

static void mtd_dump_hex(const rt_uint8_t *ptr, rt_size_t buflen)
{
	unsigned char *buf = (unsigned char*)ptr;
	int i, j;
	for (i=0; i<buflen; i+=16) 
 8016820:	697b      	ldr	r3, [r7, #20]
 8016822:	3310      	adds	r3, #16
 8016824:	617b      	str	r3, [r7, #20]
 8016826:	697a      	ldr	r2, [r7, #20]
 8016828:	683b      	ldr	r3, [r7, #0]
 801682a:	429a      	cmp	r2, r3
 801682c:	d3a8      	bcc.n	8016780 <mtd_dump_hex+0x14>
		for (j=0; j<16; j++)
			if (i+j < buflen)
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
		rt_kprintf("\n");
	}
}
 801682e:	3718      	adds	r7, #24
 8016830:	46bd      	mov	sp, r7
 8016832:	bd80      	pop	{r7, pc}
 8016834:	08023598 	.word	0x08023598
 8016838:	080235a0 	.word	0x080235a0
 801683c:	080235a8 	.word	0x080235a8
 8016840:	080235ac 	.word	0x080235ac
 8016844:	080235b0 	.word	0x080235b0
 8016848:	080235b4 	.word	0x080235b4

0801684c <mtd_nandid>:

int mtd_nandid(const char* name)
{
 801684c:	b580      	push	{r7, lr}
 801684e:	b084      	sub	sp, #16
 8016850:	af00      	add	r7, sp, #0
 8016852:	6078      	str	r0, [r7, #4]
	struct rt_mtd_nand_device *nand;
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8016854:	6878      	ldr	r0, [r7, #4]
 8016856:	f7fb fb7d 	bl	8011f54 <rt_device_find>
 801685a:	60f8      	str	r0, [r7, #12]
	if (nand == RT_NULL)
 801685c:	68fb      	ldr	r3, [r7, #12]
 801685e:	2b00      	cmp	r3, #0
 8016860:	d105      	bne.n	801686e <mtd_nandid+0x22>
	{
		rt_kprintf("no nand device found!\n");
 8016862:	4807      	ldr	r0, [pc, #28]	; (8016880 <mtd_nandid+0x34>)
 8016864:	f7fd fa04 	bl	8013c70 <rt_kprintf>
		return -RT_ERROR;
 8016868:	f04f 33ff 	mov.w	r3, #4294967295
 801686c:	e003      	b.n	8016876 <mtd_nandid+0x2a>
	}

	return rt_mtd_nand_read_id(nand);
 801686e:	68f8      	ldr	r0, [r7, #12]
 8016870:	f7ff ff2e 	bl	80166d0 <rt_mtd_nand_read_id>
 8016874:	4603      	mov	r3, r0
}
 8016876:	4618      	mov	r0, r3
 8016878:	3710      	adds	r7, #16
 801687a:	46bd      	mov	sp, r7
 801687c:	bd80      	pop	{r7, pc}
 801687e:	bf00      	nop
 8016880:	080235b8 	.word	0x080235b8

08016884 <mtd_nand_read>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nandid, nand_id, read ID - nandid(name));

int mtd_nand_read(const char* name, int block, int page)
{
 8016884:	b590      	push	{r4, r7, lr}
 8016886:	b08b      	sub	sp, #44	; 0x2c
 8016888:	af02      	add	r7, sp, #8
 801688a:	60f8      	str	r0, [r7, #12]
 801688c:	60b9      	str	r1, [r7, #8]
 801688e:	607a      	str	r2, [r7, #4]
	rt_err_t result;
	rt_uint8_t *page_ptr;
	rt_uint8_t *oob_ptr;
	struct rt_mtd_nand_device *nand;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8016890:	68f8      	ldr	r0, [r7, #12]
 8016892:	f7fb fb5f 	bl	8011f54 <rt_device_find>
 8016896:	61f8      	str	r0, [r7, #28]
	if (nand == RT_NULL)
 8016898:	69fb      	ldr	r3, [r7, #28]
 801689a:	2b00      	cmp	r3, #0
 801689c:	d105      	bne.n	80168aa <mtd_nand_read+0x26>
	{
		rt_kprintf("no nand device found!\n");
 801689e:	4831      	ldr	r0, [pc, #196]	; (8016964 <mtd_nand_read+0xe0>)
 80168a0:	f7fd f9e6 	bl	8013c70 <rt_kprintf>
		return -RT_ERROR;
 80168a4:	f04f 33ff 	mov.w	r3, #4294967295
 80168a8:	e058      	b.n	801695c <mtd_nand_read+0xd8>
	}

	page_ptr = rt_malloc(nand->page_size + nand->oob_size);
 80168aa:	69fb      	ldr	r3, [r7, #28]
 80168ac:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 80168b0:	461a      	mov	r2, r3
 80168b2:	69fb      	ldr	r3, [r7, #28]
 80168b4:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 80168b8:	4413      	add	r3, r2
 80168ba:	4618      	mov	r0, r3
 80168bc:	f7fd fb86 	bl	8013fcc <rt_malloc>
 80168c0:	61b8      	str	r0, [r7, #24]
	if (page_ptr == RT_NULL)
 80168c2:	69bb      	ldr	r3, [r7, #24]
 80168c4:	2b00      	cmp	r3, #0
 80168c6:	d105      	bne.n	80168d4 <mtd_nand_read+0x50>
	{
		rt_kprintf("out of memory!\n");
 80168c8:	4827      	ldr	r0, [pc, #156]	; (8016968 <mtd_nand_read+0xe4>)
 80168ca:	f7fd f9d1 	bl	8013c70 <rt_kprintf>
		return -RT_ENOMEM;
 80168ce:	f06f 0304 	mvn.w	r3, #4
 80168d2:	e043      	b.n	801695c <mtd_nand_read+0xd8>
	}

	oob_ptr = page_ptr + nand->page_size;
 80168d4:	69fb      	ldr	r3, [r7, #28]
 80168d6:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 80168da:	461a      	mov	r2, r3
 80168dc:	69bb      	ldr	r3, [r7, #24]
 80168de:	4413      	add	r3, r2
 80168e0:	617b      	str	r3, [r7, #20]
	rt_memset(page_ptr, 0xff, nand->page_size + nand->oob_size);
 80168e2:	69fb      	ldr	r3, [r7, #28]
 80168e4:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 80168e8:	461a      	mov	r2, r3
 80168ea:	69fb      	ldr	r3, [r7, #28]
 80168ec:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 80168f0:	4413      	add	r3, r2
 80168f2:	69b8      	ldr	r0, [r7, #24]
 80168f4:	21ff      	movs	r1, #255	; 0xff
 80168f6:	461a      	mov	r2, r3
 80168f8:	f7fc fc02 	bl	8013100 <rt_memset>

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 80168fc:	69fb      	ldr	r3, [r7, #28]
 80168fe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016900:	68ba      	ldr	r2, [r7, #8]
 8016902:	fb02 f203 	mul.w	r2, r2, r3
 8016906:	687b      	ldr	r3, [r7, #4]
 8016908:	4413      	add	r3, r2
 801690a:	607b      	str	r3, [r7, #4]
	result = rt_mtd_nand_read(nand, page, page_ptr, nand->page_size,
 801690c:	69fb      	ldr	r3, [r7, #28]
 801690e:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8016912:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 8016914:	69fb      	ldr	r3, [r7, #28]
 8016916:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
	oob_ptr = page_ptr + nand->page_size;
	rt_memset(page_ptr, 0xff, nand->page_size + nand->oob_size);

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	result = rt_mtd_nand_read(nand, page, page_ptr, nand->page_size,
 801691a:	461a      	mov	r2, r3
 801691c:	697b      	ldr	r3, [r7, #20]
 801691e:	9300      	str	r3, [sp, #0]
 8016920:	9201      	str	r2, [sp, #4]
 8016922:	69f8      	ldr	r0, [r7, #28]
 8016924:	6879      	ldr	r1, [r7, #4]
 8016926:	69ba      	ldr	r2, [r7, #24]
 8016928:	4623      	mov	r3, r4
 801692a:	f7ff fedf 	bl	80166ec <rt_mtd_nand_read>
 801692e:	6138      	str	r0, [r7, #16]
		oob_ptr, nand->oob_size);

	rt_kprintf("read page, rc=%d\n", result);
 8016930:	480e      	ldr	r0, [pc, #56]	; (801696c <mtd_nand_read+0xe8>)
 8016932:	6939      	ldr	r1, [r7, #16]
 8016934:	f7fd f99c 	bl	8013c70 <rt_kprintf>
	mtd_dump_hex(page_ptr, nand->page_size);
 8016938:	69fb      	ldr	r3, [r7, #28]
 801693a:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801693e:	69b8      	ldr	r0, [r7, #24]
 8016940:	4619      	mov	r1, r3
 8016942:	f7ff ff13 	bl	801676c <mtd_dump_hex>
	mtd_dump_hex(oob_ptr, nand->oob_size);
 8016946:	69fb      	ldr	r3, [r7, #28]
 8016948:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801694c:	6978      	ldr	r0, [r7, #20]
 801694e:	4619      	mov	r1, r3
 8016950:	f7ff ff0c 	bl	801676c <mtd_dump_hex>

	rt_free(page_ptr);
 8016954:	69b8      	ldr	r0, [r7, #24]
 8016956:	f7fd fd43 	bl	80143e0 <rt_free>
	return 0;
 801695a:	2300      	movs	r3, #0
}
 801695c:	4618      	mov	r0, r3
 801695e:	3724      	adds	r7, #36	; 0x24
 8016960:	46bd      	mov	sp, r7
 8016962:	bd90      	pop	{r4, r7, pc}
 8016964:	080235b8 	.word	0x080235b8
 8016968:	080235d0 	.word	0x080235d0
 801696c:	080235e0 	.word	0x080235e0

08016970 <mtd_nand_readoob>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_read, nand_read, read page in nand - nand_read(name, block, page));

int mtd_nand_readoob(const char* name, int block, int page)
{
 8016970:	b590      	push	{r4, r7, lr}
 8016972:	b089      	sub	sp, #36	; 0x24
 8016974:	af02      	add	r7, sp, #8
 8016976:	60f8      	str	r0, [r7, #12]
 8016978:	60b9      	str	r1, [r7, #8]
 801697a:	607a      	str	r2, [r7, #4]
	struct rt_mtd_nand_device *nand;
	rt_uint8_t *oob_ptr;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801697c:	68f8      	ldr	r0, [r7, #12]
 801697e:	f7fb fae9 	bl	8011f54 <rt_device_find>
 8016982:	6178      	str	r0, [r7, #20]
	if (nand == RT_NULL)
 8016984:	697b      	ldr	r3, [r7, #20]
 8016986:	2b00      	cmp	r3, #0
 8016988:	d105      	bne.n	8016996 <mtd_nand_readoob+0x26>
	{
		rt_kprintf("no nand device found!\n");
 801698a:	481f      	ldr	r0, [pc, #124]	; (8016a08 <mtd_nand_readoob+0x98>)
 801698c:	f7fd f970 	bl	8013c70 <rt_kprintf>
		return -RT_ERROR;
 8016990:	f04f 33ff 	mov.w	r3, #4294967295
 8016994:	e033      	b.n	80169fe <mtd_nand_readoob+0x8e>
	}

	oob_ptr = rt_malloc(nand->oob_size);
 8016996:	697b      	ldr	r3, [r7, #20]
 8016998:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801699c:	4618      	mov	r0, r3
 801699e:	f7fd fb15 	bl	8013fcc <rt_malloc>
 80169a2:	6138      	str	r0, [r7, #16]
	if (oob_ptr == RT_NULL)
 80169a4:	693b      	ldr	r3, [r7, #16]
 80169a6:	2b00      	cmp	r3, #0
 80169a8:	d105      	bne.n	80169b6 <mtd_nand_readoob+0x46>
	{
		rt_kprintf("out of memory!\n");
 80169aa:	4818      	ldr	r0, [pc, #96]	; (8016a0c <mtd_nand_readoob+0x9c>)
 80169ac:	f7fd f960 	bl	8013c70 <rt_kprintf>
		return -RT_ENOMEM;
 80169b0:	f06f 0304 	mvn.w	r3, #4
 80169b4:	e023      	b.n	80169fe <mtd_nand_readoob+0x8e>
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 80169b6:	697b      	ldr	r3, [r7, #20]
 80169b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80169ba:	68ba      	ldr	r2, [r7, #8]
 80169bc:	fb02 f203 	mul.w	r2, r2, r3
 80169c0:	687b      	ldr	r3, [r7, #4]
 80169c2:	4413      	add	r3, r2
 80169c4:	607b      	str	r3, [r7, #4]
	rt_mtd_nand_read(nand, page, RT_NULL, nand->page_size,
 80169c6:	697b      	ldr	r3, [r7, #20]
 80169c8:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 80169cc:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 80169ce:	697b      	ldr	r3, [r7, #20]
 80169d0:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
		return -RT_ENOMEM;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	rt_mtd_nand_read(nand, page, RT_NULL, nand->page_size,
 80169d4:	461a      	mov	r2, r3
 80169d6:	693b      	ldr	r3, [r7, #16]
 80169d8:	9300      	str	r3, [sp, #0]
 80169da:	9201      	str	r2, [sp, #4]
 80169dc:	6978      	ldr	r0, [r7, #20]
 80169de:	6879      	ldr	r1, [r7, #4]
 80169e0:	2200      	movs	r2, #0
 80169e2:	4623      	mov	r3, r4
 80169e4:	f7ff fe82 	bl	80166ec <rt_mtd_nand_read>
		oob_ptr, nand->oob_size);
	mtd_dump_hex(oob_ptr, nand->oob_size);
 80169e8:	697b      	ldr	r3, [r7, #20]
 80169ea:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 80169ee:	6938      	ldr	r0, [r7, #16]
 80169f0:	4619      	mov	r1, r3
 80169f2:	f7ff febb 	bl	801676c <mtd_dump_hex>

	rt_free(oob_ptr);
 80169f6:	6938      	ldr	r0, [r7, #16]
 80169f8:	f7fd fcf2 	bl	80143e0 <rt_free>
	return 0;
 80169fc:	2300      	movs	r3, #0
}
 80169fe:	4618      	mov	r0, r3
 8016a00:	371c      	adds	r7, #28
 8016a02:	46bd      	mov	sp, r7
 8016a04:	bd90      	pop	{r4, r7, pc}
 8016a06:	bf00      	nop
 8016a08:	080235b8 	.word	0x080235b8
 8016a0c:	080235d0 	.word	0x080235d0

08016a10 <mtd_nand_write>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_readoob, nand_readoob, read spare data in nand - nand_readoob(name, block, page));

int mtd_nand_write(const char* name, int block, int page)
{
 8016a10:	b590      	push	{r4, r7, lr}
 8016a12:	b08d      	sub	sp, #52	; 0x34
 8016a14:	af02      	add	r7, sp, #8
 8016a16:	60f8      	str	r0, [r7, #12]
 8016a18:	60b9      	str	r1, [r7, #8]
 8016a1a:	607a      	str	r2, [r7, #4]
	rt_uint8_t *page_ptr;
	rt_uint8_t *oob_ptr;
	rt_uint32_t index;
	struct rt_mtd_nand_device *nand;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8016a1c:	68f8      	ldr	r0, [r7, #12]
 8016a1e:	f7fb fa99 	bl	8011f54 <rt_device_find>
 8016a22:	6238      	str	r0, [r7, #32]
	if (nand == RT_NULL)
 8016a24:	6a3b      	ldr	r3, [r7, #32]
 8016a26:	2b00      	cmp	r3, #0
 8016a28:	d105      	bne.n	8016a36 <mtd_nand_write+0x26>
	{
		rt_kprintf("no nand device found!\n");
 8016a2a:	4838      	ldr	r0, [pc, #224]	; (8016b0c <mtd_nand_write+0xfc>)
 8016a2c:	f7fd f920 	bl	8013c70 <rt_kprintf>
		return -RT_ERROR;
 8016a30:	f04f 33ff 	mov.w	r3, #4294967295
 8016a34:	e066      	b.n	8016b04 <mtd_nand_write+0xf4>
	}

	page_ptr = rt_malloc(nand->page_size + nand->oob_size);
 8016a36:	6a3b      	ldr	r3, [r7, #32]
 8016a38:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8016a3c:	461a      	mov	r2, r3
 8016a3e:	6a3b      	ldr	r3, [r7, #32]
 8016a40:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8016a44:	4413      	add	r3, r2
 8016a46:	4618      	mov	r0, r3
 8016a48:	f7fd fac0 	bl	8013fcc <rt_malloc>
 8016a4c:	61f8      	str	r0, [r7, #28]
	if (page_ptr == RT_NULL)
 8016a4e:	69fb      	ldr	r3, [r7, #28]
 8016a50:	2b00      	cmp	r3, #0
 8016a52:	d105      	bne.n	8016a60 <mtd_nand_write+0x50>
	{
		rt_kprintf("out of memory!\n");
 8016a54:	482e      	ldr	r0, [pc, #184]	; (8016b10 <mtd_nand_write+0x100>)
 8016a56:	f7fd f90b 	bl	8013c70 <rt_kprintf>
		return -RT_ENOMEM;
 8016a5a:	f06f 0304 	mvn.w	r3, #4
 8016a5e:	e051      	b.n	8016b04 <mtd_nand_write+0xf4>
	}

	oob_ptr = page_ptr + nand->page_size;
 8016a60:	6a3b      	ldr	r3, [r7, #32]
 8016a62:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8016a66:	461a      	mov	r2, r3
 8016a68:	69fb      	ldr	r3, [r7, #28]
 8016a6a:	4413      	add	r3, r2
 8016a6c:	61bb      	str	r3, [r7, #24]
	/* prepare page data */
	for (index = 0; index < nand->page_size; index ++)
 8016a6e:	2300      	movs	r3, #0
 8016a70:	627b      	str	r3, [r7, #36]	; 0x24
 8016a72:	e008      	b.n	8016a86 <mtd_nand_write+0x76>
	{
		page_ptr[index] = index & 0xff;
 8016a74:	69fa      	ldr	r2, [r7, #28]
 8016a76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016a78:	4413      	add	r3, r2
 8016a7a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016a7c:	b2d2      	uxtb	r2, r2
 8016a7e:	701a      	strb	r2, [r3, #0]
		return -RT_ENOMEM;
	}

	oob_ptr = page_ptr + nand->page_size;
	/* prepare page data */
	for (index = 0; index < nand->page_size; index ++)
 8016a80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016a82:	3301      	adds	r3, #1
 8016a84:	627b      	str	r3, [r7, #36]	; 0x24
 8016a86:	6a3b      	ldr	r3, [r7, #32]
 8016a88:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8016a8c:	461a      	mov	r2, r3
 8016a8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016a90:	429a      	cmp	r2, r3
 8016a92:	d8ef      	bhi.n	8016a74 <mtd_nand_write+0x64>
	{
		page_ptr[index] = index & 0xff;
	}
	/* prepare oob data */
	for (index = 0; index < nand->oob_size; index ++)
 8016a94:	2300      	movs	r3, #0
 8016a96:	627b      	str	r3, [r7, #36]	; 0x24
 8016a98:	e008      	b.n	8016aac <mtd_nand_write+0x9c>
	{
		oob_ptr[index] = index & 0xff;
 8016a9a:	69ba      	ldr	r2, [r7, #24]
 8016a9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016a9e:	4413      	add	r3, r2
 8016aa0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016aa2:	b2d2      	uxtb	r2, r2
 8016aa4:	701a      	strb	r2, [r3, #0]
	for (index = 0; index < nand->page_size; index ++)
	{
		page_ptr[index] = index & 0xff;
	}
	/* prepare oob data */
	for (index = 0; index < nand->oob_size; index ++)
 8016aa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016aa8:	3301      	adds	r3, #1
 8016aaa:	627b      	str	r3, [r7, #36]	; 0x24
 8016aac:	6a3b      	ldr	r3, [r7, #32]
 8016aae:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8016ab2:	461a      	mov	r2, r3
 8016ab4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ab6:	429a      	cmp	r2, r3
 8016ab8:	d8ef      	bhi.n	8016a9a <mtd_nand_write+0x8a>
	{
		oob_ptr[index] = index & 0xff;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 8016aba:	6a3b      	ldr	r3, [r7, #32]
 8016abc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016abe:	68ba      	ldr	r2, [r7, #8]
 8016ac0:	fb02 f203 	mul.w	r2, r2, r3
 8016ac4:	687b      	ldr	r3, [r7, #4]
 8016ac6:	4413      	add	r3, r2
 8016ac8:	607b      	str	r3, [r7, #4]
	result = rt_mtd_nand_write(nand, page, page_ptr, nand->page_size,
 8016aca:	6a3b      	ldr	r3, [r7, #32]
 8016acc:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8016ad0:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 8016ad2:	6a3b      	ldr	r3, [r7, #32]
 8016ad4:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
		oob_ptr[index] = index & 0xff;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	result = rt_mtd_nand_write(nand, page, page_ptr, nand->page_size,
 8016ad8:	461a      	mov	r2, r3
 8016ada:	69bb      	ldr	r3, [r7, #24]
 8016adc:	9300      	str	r3, [sp, #0]
 8016ade:	9201      	str	r2, [sp, #4]
 8016ae0:	6a38      	ldr	r0, [r7, #32]
 8016ae2:	6879      	ldr	r1, [r7, #4]
 8016ae4:	69fa      	ldr	r2, [r7, #28]
 8016ae6:	4623      	mov	r3, r4
 8016ae8:	f7ff fe18 	bl	801671c <rt_mtd_nand_write>
 8016aec:	6178      	str	r0, [r7, #20]
		oob_ptr, nand->oob_size);
	if (result != RT_MTD_EOK)
 8016aee:	697b      	ldr	r3, [r7, #20]
 8016af0:	2b00      	cmp	r3, #0
 8016af2:	d003      	beq.n	8016afc <mtd_nand_write+0xec>
	{
		rt_kprintf("write page failed!, rc=%d\n", result);
 8016af4:	4807      	ldr	r0, [pc, #28]	; (8016b14 <mtd_nand_write+0x104>)
 8016af6:	6979      	ldr	r1, [r7, #20]
 8016af8:	f7fd f8ba 	bl	8013c70 <rt_kprintf>
	}

	rt_free(page_ptr);
 8016afc:	69f8      	ldr	r0, [r7, #28]
 8016afe:	f7fd fc6f 	bl	80143e0 <rt_free>
	return 0;
 8016b02:	2300      	movs	r3, #0
}
 8016b04:	4618      	mov	r0, r3
 8016b06:	372c      	adds	r7, #44	; 0x2c
 8016b08:	46bd      	mov	sp, r7
 8016b0a:	bd90      	pop	{r4, r7, pc}
 8016b0c:	080235b8 	.word	0x080235b8
 8016b10:	080235d0 	.word	0x080235d0
 8016b14:	080235f4 	.word	0x080235f4

08016b18 <mtd_nand_erase>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_write, nand_write, write dump data to nand - nand_write(name, block, page));

int mtd_nand_erase(const char* name, int block)
{
 8016b18:	b580      	push	{r7, lr}
 8016b1a:	b084      	sub	sp, #16
 8016b1c:	af00      	add	r7, sp, #0
 8016b1e:	6078      	str	r0, [r7, #4]
 8016b20:	6039      	str	r1, [r7, #0]
	struct rt_mtd_nand_device *nand;
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8016b22:	6878      	ldr	r0, [r7, #4]
 8016b24:	f7fb fa16 	bl	8011f54 <rt_device_find>
 8016b28:	60f8      	str	r0, [r7, #12]
	if (nand == RT_NULL)
 8016b2a:	68fb      	ldr	r3, [r7, #12]
 8016b2c:	2b00      	cmp	r3, #0
 8016b2e:	d105      	bne.n	8016b3c <mtd_nand_erase+0x24>
	{
		rt_kprintf("no nand device found!\n");
 8016b30:	4807      	ldr	r0, [pc, #28]	; (8016b50 <mtd_nand_erase+0x38>)
 8016b32:	f7fd f89d 	bl	8013c70 <rt_kprintf>
		return -RT_ERROR;
 8016b36:	f04f 33ff 	mov.w	r3, #4294967295
 8016b3a:	e005      	b.n	8016b48 <mtd_nand_erase+0x30>
	}

	return rt_mtd_nand_erase_block(nand, block);
 8016b3c:	683b      	ldr	r3, [r7, #0]
 8016b3e:	68f8      	ldr	r0, [r7, #12]
 8016b40:	4619      	mov	r1, r3
 8016b42:	f7ff fe03 	bl	801674c <rt_mtd_nand_erase_block>
 8016b46:	4603      	mov	r3, r0
}
 8016b48:	4618      	mov	r0, r3
 8016b4a:	3710      	adds	r7, #16
 8016b4c:	46bd      	mov	sp, r7
 8016b4e:	bd80      	pop	{r7, pc}
 8016b50:	080235b8 	.word	0x080235b8

08016b54 <mtd_nand_erase_all>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_erase, nand_erase, nand_erase(name, block));

int mtd_nand_erase_all(const char* name)
{
 8016b54:	b580      	push	{r7, lr}
 8016b56:	b084      	sub	sp, #16
 8016b58:	af00      	add	r7, sp, #0
 8016b5a:	6078      	str	r0, [r7, #4]
	rt_uint32_t index = 0;
 8016b5c:	2300      	movs	r3, #0
 8016b5e:	60fb      	str	r3, [r7, #12]
	struct rt_mtd_nand_device *nand;
	
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8016b60:	6878      	ldr	r0, [r7, #4]
 8016b62:	f7fb f9f7 	bl	8011f54 <rt_device_find>
 8016b66:	60b8      	str	r0, [r7, #8]
	if (nand == RT_NULL)
 8016b68:	68bb      	ldr	r3, [r7, #8]
 8016b6a:	2b00      	cmp	r3, #0
 8016b6c:	d105      	bne.n	8016b7a <mtd_nand_erase_all+0x26>
	{
		rt_kprintf("no nand device found!\n");
 8016b6e:	480e      	ldr	r0, [pc, #56]	; (8016ba8 <mtd_nand_erase_all+0x54>)
 8016b70:	f7fd f87e 	bl	8013c70 <rt_kprintf>
		return -RT_ERROR;
 8016b74:	f04f 33ff 	mov.w	r3, #4294967295
 8016b78:	e012      	b.n	8016ba0 <mtd_nand_erase_all+0x4c>
	}

	for (index = 0; index < (nand->block_end - nand->block_start); index ++)
 8016b7a:	2300      	movs	r3, #0
 8016b7c:	60fb      	str	r3, [r7, #12]
 8016b7e:	e006      	b.n	8016b8e <mtd_nand_erase_all+0x3a>
	{
		rt_mtd_nand_erase_block(nand, index);
 8016b80:	68b8      	ldr	r0, [r7, #8]
 8016b82:	68f9      	ldr	r1, [r7, #12]
 8016b84:	f7ff fde2 	bl	801674c <rt_mtd_nand_erase_block>
	{
		rt_kprintf("no nand device found!\n");
		return -RT_ERROR;
	}

	for (index = 0; index < (nand->block_end - nand->block_start); index ++)
 8016b88:	68fb      	ldr	r3, [r7, #12]
 8016b8a:	3301      	adds	r3, #1
 8016b8c:	60fb      	str	r3, [r7, #12]
 8016b8e:	68bb      	ldr	r3, [r7, #8]
 8016b90:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8016b92:	68bb      	ldr	r3, [r7, #8]
 8016b94:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8016b96:	1ad2      	subs	r2, r2, r3
 8016b98:	68fb      	ldr	r3, [r7, #12]
 8016b9a:	429a      	cmp	r2, r3
 8016b9c:	d8f0      	bhi.n	8016b80 <mtd_nand_erase_all+0x2c>
	{
		rt_mtd_nand_erase_block(nand, index);
	}
	
	return 0;
 8016b9e:	2300      	movs	r3, #0
}
 8016ba0:	4618      	mov	r0, r3
 8016ba2:	3710      	adds	r7, #16
 8016ba4:	46bd      	mov	sp, r7
 8016ba6:	bd80      	pop	{r7, pc}
 8016ba8:	080235b8 	.word	0x080235b8

08016bac <time>:
#pragma module_name = "?time"
time_t (__time32)(time_t *t) /* Only supports 32-bit timestamp */
#else
time_t time(time_t *t)
#endif
{
 8016bac:	b580      	push	{r7, lr}
 8016bae:	b084      	sub	sp, #16
 8016bb0:	af00      	add	r7, sp, #0
 8016bb2:	6078      	str	r0, [r7, #4]
    static rt_device_t device = RT_NULL;
    time_t time_now = 0;
 8016bb4:	2300      	movs	r3, #0
 8016bb6:	60fb      	str	r3, [r7, #12]

    /* optimization: find rtc device only first. */
    if (device == RT_NULL)
 8016bb8:	4b17      	ldr	r3, [pc, #92]	; (8016c18 <time+0x6c>)
 8016bba:	681b      	ldr	r3, [r3, #0]
 8016bbc:	2b00      	cmp	r3, #0
 8016bbe:	d105      	bne.n	8016bcc <time+0x20>
    {
        device = rt_device_find("rtc");
 8016bc0:	4816      	ldr	r0, [pc, #88]	; (8016c1c <time+0x70>)
 8016bc2:	f7fb f9c7 	bl	8011f54 <rt_device_find>
 8016bc6:	4602      	mov	r2, r0
 8016bc8:	4b13      	ldr	r3, [pc, #76]	; (8016c18 <time+0x6c>)
 8016bca:	601a      	str	r2, [r3, #0]
    }

    /* read timestamp from RTC device. */
    if (device != RT_NULL)
 8016bcc:	4b12      	ldr	r3, [pc, #72]	; (8016c18 <time+0x6c>)
 8016bce:	681b      	ldr	r3, [r3, #0]
 8016bd0:	2b00      	cmp	r3, #0
 8016bd2:	d016      	beq.n	8016c02 <time+0x56>
    {
        if (rt_device_open(device, 0) == RT_EOK)
 8016bd4:	4b10      	ldr	r3, [pc, #64]	; (8016c18 <time+0x6c>)
 8016bd6:	681b      	ldr	r3, [r3, #0]
 8016bd8:	4618      	mov	r0, r3
 8016bda:	2100      	movs	r1, #0
 8016bdc:	f7fb f9f6 	bl	8011fcc <rt_device_open>
 8016be0:	4603      	mov	r3, r0
 8016be2:	2b00      	cmp	r3, #0
 8016be4:	d10d      	bne.n	8016c02 <time+0x56>
        {
            rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time_now);
 8016be6:	4b0c      	ldr	r3, [pc, #48]	; (8016c18 <time+0x6c>)
 8016be8:	681a      	ldr	r2, [r3, #0]
 8016bea:	f107 030c 	add.w	r3, r7, #12
 8016bee:	4610      	mov	r0, r2
 8016bf0:	2110      	movs	r1, #16
 8016bf2:	461a      	mov	r2, r3
 8016bf4:	f7fb fb04 	bl	8012200 <rt_device_control>
            rt_device_close(device);
 8016bf8:	4b07      	ldr	r3, [pc, #28]	; (8016c18 <time+0x6c>)
 8016bfa:	681b      	ldr	r3, [r3, #0]
 8016bfc:	4618      	mov	r0, r3
 8016bfe:	f7fb fa59 	bl	80120b4 <rt_device_close>
        }
    }

    /* if t is not NULL, write timestamp to *t */
    if (t != RT_NULL)
 8016c02:	687b      	ldr	r3, [r7, #4]
 8016c04:	2b00      	cmp	r3, #0
 8016c06:	d002      	beq.n	8016c0e <time+0x62>
    {
        *t = time_now;
 8016c08:	68fa      	ldr	r2, [r7, #12]
 8016c0a:	687b      	ldr	r3, [r7, #4]
 8016c0c:	601a      	str	r2, [r3, #0]
    }

    return time_now;
 8016c0e:	68fb      	ldr	r3, [r7, #12]
}
 8016c10:	4618      	mov	r0, r3
 8016c12:	3710      	adds	r7, #16
 8016c14:	46bd      	mov	sp, r7
 8016c16:	bd80      	pop	{r7, pc}
 8016c18:	200110c4 	.word	0x200110c4
 8016c1c:	08023610 	.word	0x08023610

08016c20 <set_date>:
 * \param rt_uint32_t day   e.g: e.g: 31.
 * \return rt_err_t if set success, return RT_EOK.
 *
 */
rt_err_t set_date(rt_uint32_t year, rt_uint32_t month, rt_uint32_t day)
{
 8016c20:	b580      	push	{r7, lr}
 8016c22:	b092      	sub	sp, #72	; 0x48
 8016c24:	af00      	add	r7, sp, #0
 8016c26:	60f8      	str	r0, [r7, #12]
 8016c28:	60b9      	str	r1, [r7, #8]
 8016c2a:	607a      	str	r2, [r7, #4]
    time_t now;
    struct tm *p_tm;
    struct tm tm_new;
    rt_device_t device;
    rt_err_t ret = -RT_ERROR;
 8016c2c:	f04f 33ff 	mov.w	r3, #4294967295
 8016c30:	647b      	str	r3, [r7, #68]	; 0x44

    /* get current time */
    now = time(RT_NULL);
 8016c32:	2000      	movs	r0, #0
 8016c34:	f7ff ffba 	bl	8016bac <time>
 8016c38:	4603      	mov	r3, r0
 8016c3a:	63bb      	str	r3, [r7, #56]	; 0x38

    /* lock scheduler. */
    rt_enter_critical();
 8016c3c:	f7fe f832 	bl	8014ca4 <rt_enter_critical>
    /* converts calendar time time into local time. */
    p_tm = localtime(&now);
 8016c40:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8016c44:	4618      	mov	r0, r3
 8016c46:	f008 f933 	bl	801eeb0 <localtime>
 8016c4a:	6438      	str	r0, [r7, #64]	; 0x40
    /* copy the statically located variable */
    memcpy(&tm_new, p_tm, sizeof(struct tm));
 8016c4c:	f107 0314 	add.w	r3, r7, #20
 8016c50:	4618      	mov	r0, r3
 8016c52:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8016c54:	2224      	movs	r2, #36	; 0x24
 8016c56:	f7e9 fb41 	bl	80002dc <memcpy>
    /* unlock scheduler. */
    rt_exit_critical();
 8016c5a:	f7fe f837 	bl	8014ccc <rt_exit_critical>

    /* update date. */
    tm_new.tm_year = year - 1900;
 8016c5e:	68fb      	ldr	r3, [r7, #12]
 8016c60:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 8016c64:	62bb      	str	r3, [r7, #40]	; 0x28
    tm_new.tm_mon  = month - 1; /* tm_mon: 0~11 */
 8016c66:	68bb      	ldr	r3, [r7, #8]
 8016c68:	3b01      	subs	r3, #1
 8016c6a:	627b      	str	r3, [r7, #36]	; 0x24
    tm_new.tm_mday = day;
 8016c6c:	687b      	ldr	r3, [r7, #4]
 8016c6e:	623b      	str	r3, [r7, #32]

    /* converts the local time in time to calendar time. */
    now = mktime(&tm_new);
 8016c70:	f107 0314 	add.w	r3, r7, #20
 8016c74:	4618      	mov	r0, r3
 8016c76:	f008 fbb1 	bl	801f3dc <mktime>
 8016c7a:	4603      	mov	r3, r0
 8016c7c:	63bb      	str	r3, [r7, #56]	; 0x38

    device = rt_device_find("rtc");
 8016c7e:	480b      	ldr	r0, [pc, #44]	; (8016cac <set_date+0x8c>)
 8016c80:	f7fb f968 	bl	8011f54 <rt_device_find>
 8016c84:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (device == RT_NULL)
 8016c86:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c88:	2b00      	cmp	r3, #0
 8016c8a:	d102      	bne.n	8016c92 <set_date+0x72>
    {
        return -RT_ERROR;
 8016c8c:	f04f 33ff 	mov.w	r3, #4294967295
 8016c90:	e008      	b.n	8016ca4 <set_date+0x84>
    }

    /* update to RTC device. */
    ret = rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &now);
 8016c92:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8016c96:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016c98:	2111      	movs	r1, #17
 8016c9a:	461a      	mov	r2, r3
 8016c9c:	f7fb fab0 	bl	8012200 <rt_device_control>
 8016ca0:	6478      	str	r0, [r7, #68]	; 0x44

    return ret;
 8016ca2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8016ca4:	4618      	mov	r0, r3
 8016ca6:	3748      	adds	r7, #72	; 0x48
 8016ca8:	46bd      	mov	sp, r7
 8016caa:	bd80      	pop	{r7, pc}
 8016cac:	08023610 	.word	0x08023610

08016cb0 <set_time>:
 * \param rt_uint32_t second e.g: 0~59.
 * \return rt_err_t if set success, return RT_EOK.
 *
 */
rt_err_t set_time(rt_uint32_t hour, rt_uint32_t minute, rt_uint32_t second)
{
 8016cb0:	b580      	push	{r7, lr}
 8016cb2:	b092      	sub	sp, #72	; 0x48
 8016cb4:	af00      	add	r7, sp, #0
 8016cb6:	60f8      	str	r0, [r7, #12]
 8016cb8:	60b9      	str	r1, [r7, #8]
 8016cba:	607a      	str	r2, [r7, #4]
    time_t now;
    struct tm *p_tm;
    struct tm tm_new;
    rt_device_t device;
    rt_err_t ret = -RT_ERROR;
 8016cbc:	f04f 33ff 	mov.w	r3, #4294967295
 8016cc0:	647b      	str	r3, [r7, #68]	; 0x44

    /* get current time */
    now = time(RT_NULL);
 8016cc2:	2000      	movs	r0, #0
 8016cc4:	f7ff ff72 	bl	8016bac <time>
 8016cc8:	4603      	mov	r3, r0
 8016cca:	63bb      	str	r3, [r7, #56]	; 0x38

    /* lock scheduler. */
    rt_enter_critical();
 8016ccc:	f7fd ffea 	bl	8014ca4 <rt_enter_critical>
    /* converts calendar time time into local time. */
    p_tm = localtime(&now);
 8016cd0:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8016cd4:	4618      	mov	r0, r3
 8016cd6:	f008 f8eb 	bl	801eeb0 <localtime>
 8016cda:	6438      	str	r0, [r7, #64]	; 0x40
    /* copy the statically located variable */
    memcpy(&tm_new, p_tm, sizeof(struct tm));
 8016cdc:	f107 0314 	add.w	r3, r7, #20
 8016ce0:	4618      	mov	r0, r3
 8016ce2:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8016ce4:	2224      	movs	r2, #36	; 0x24
 8016ce6:	f7e9 faf9 	bl	80002dc <memcpy>
    /* unlock scheduler. */
    rt_exit_critical();
 8016cea:	f7fd ffef 	bl	8014ccc <rt_exit_critical>

    /* update time. */
    tm_new.tm_hour = hour;
 8016cee:	68fb      	ldr	r3, [r7, #12]
 8016cf0:	61fb      	str	r3, [r7, #28]
    tm_new.tm_min  = minute;
 8016cf2:	68bb      	ldr	r3, [r7, #8]
 8016cf4:	61bb      	str	r3, [r7, #24]
    tm_new.tm_sec  = second;
 8016cf6:	687b      	ldr	r3, [r7, #4]
 8016cf8:	617b      	str	r3, [r7, #20]

    /* converts the local time in time to calendar time. */
    now = mktime(&tm_new);
 8016cfa:	f107 0314 	add.w	r3, r7, #20
 8016cfe:	4618      	mov	r0, r3
 8016d00:	f008 fb6c 	bl	801f3dc <mktime>
 8016d04:	4603      	mov	r3, r0
 8016d06:	63bb      	str	r3, [r7, #56]	; 0x38

    device = rt_device_find("rtc");
 8016d08:	480b      	ldr	r0, [pc, #44]	; (8016d38 <set_time+0x88>)
 8016d0a:	f7fb f923 	bl	8011f54 <rt_device_find>
 8016d0e:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (device == RT_NULL)
 8016d10:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d12:	2b00      	cmp	r3, #0
 8016d14:	d102      	bne.n	8016d1c <set_time+0x6c>
    {
        return -RT_ERROR;
 8016d16:	f04f 33ff 	mov.w	r3, #4294967295
 8016d1a:	e008      	b.n	8016d2e <set_time+0x7e>
    }

    /* update to RTC device. */
    ret = rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &now);
 8016d1c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8016d20:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016d22:	2111      	movs	r1, #17
 8016d24:	461a      	mov	r2, r3
 8016d26:	f7fb fa6b 	bl	8012200 <rt_device_control>
 8016d2a:	6478      	str	r0, [r7, #68]	; 0x44

    return ret;
 8016d2c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8016d2e:	4618      	mov	r0, r3
 8016d30:	3748      	adds	r7, #72	; 0x48
 8016d32:	46bd      	mov	sp, r7
 8016d34:	bd80      	pop	{r7, pc}
 8016d36:	bf00      	nop
 8016d38:	08023610 	.word	0x08023610

08016d3c <list_date>:
#ifdef RT_USING_FINSH
#include <finsh.h>
#include <rtdevice.h>

void list_date(void)
{
 8016d3c:	b580      	push	{r7, lr}
 8016d3e:	b082      	sub	sp, #8
 8016d40:	af00      	add	r7, sp, #0
    time_t now;

    now = time(RT_NULL);
 8016d42:	2000      	movs	r0, #0
 8016d44:	f7ff ff32 	bl	8016bac <time>
 8016d48:	4603      	mov	r3, r0
 8016d4a:	607b      	str	r3, [r7, #4]
    rt_kprintf("%s\n", ctime(&now));
 8016d4c:	1d3b      	adds	r3, r7, #4
 8016d4e:	4618      	mov	r0, r3
 8016d50:	f008 f8a6 	bl	801eea0 <ctime>
 8016d54:	4603      	mov	r3, r0
 8016d56:	4803      	ldr	r0, [pc, #12]	; (8016d64 <list_date+0x28>)
 8016d58:	4619      	mov	r1, r3
 8016d5a:	f7fc ff89 	bl	8013c70 <rt_kprintf>
}
 8016d5e:	3708      	adds	r7, #8
 8016d60:	46bd      	mov	sp, r7
 8016d62:	bd80      	pop	{r7, pc}
 8016d64:	08023614 	.word	0x08023614

08016d68 <_serial_poll_rx>:

/*
 * Serial poll routines 
 */
rt_inline int _serial_poll_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 8016d68:	b580      	push	{r7, lr}
 8016d6a:	b086      	sub	sp, #24
 8016d6c:	af00      	add	r7, sp, #0
 8016d6e:	60f8      	str	r0, [r7, #12]
 8016d70:	60b9      	str	r1, [r7, #8]
 8016d72:	607a      	str	r2, [r7, #4]
    int ch;
    int size;
    
    RT_ASSERT(serial != RT_NULL);
 8016d74:	68fb      	ldr	r3, [r7, #12]
 8016d76:	2b00      	cmp	r3, #0
 8016d78:	d104      	bne.n	8016d84 <_serial_poll_rx+0x1c>
 8016d7a:	4813      	ldr	r0, [pc, #76]	; (8016dc8 <_serial_poll_rx+0x60>)
 8016d7c:	4913      	ldr	r1, [pc, #76]	; (8016dcc <_serial_poll_rx+0x64>)
 8016d7e:	222e      	movs	r2, #46	; 0x2e
 8016d80:	f7fc fff0 	bl	8013d64 <rt_assert_handler>
    size = length;
 8016d84:	687b      	ldr	r3, [r7, #4]
 8016d86:	617b      	str	r3, [r7, #20]

    while (length)
 8016d88:	e013      	b.n	8016db2 <_serial_poll_rx+0x4a>
    {
        ch = serial->ops->getc(serial);
 8016d8a:	68fb      	ldr	r3, [r7, #12]
 8016d8c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8016d8e:	68db      	ldr	r3, [r3, #12]
 8016d90:	68f8      	ldr	r0, [r7, #12]
 8016d92:	4798      	blx	r3
 8016d94:	6138      	str	r0, [r7, #16]
        *data = ch; 
 8016d96:	693b      	ldr	r3, [r7, #16]
 8016d98:	b2da      	uxtb	r2, r3
 8016d9a:	68bb      	ldr	r3, [r7, #8]
 8016d9c:	701a      	strb	r2, [r3, #0]
        data ++; length --;
 8016d9e:	68bb      	ldr	r3, [r7, #8]
 8016da0:	3301      	adds	r3, #1
 8016da2:	60bb      	str	r3, [r7, #8]
 8016da4:	687b      	ldr	r3, [r7, #4]
 8016da6:	3b01      	subs	r3, #1
 8016da8:	607b      	str	r3, [r7, #4]

        if (ch == '\n') break;
 8016daa:	693b      	ldr	r3, [r7, #16]
 8016dac:	2b0a      	cmp	r3, #10
 8016dae:	d100      	bne.n	8016db2 <_serial_poll_rx+0x4a>
 8016db0:	e002      	b.n	8016db8 <_serial_poll_rx+0x50>
    int size;
    
    RT_ASSERT(serial != RT_NULL);
    size = length;

    while (length)
 8016db2:	687b      	ldr	r3, [r7, #4]
 8016db4:	2b00      	cmp	r3, #0
 8016db6:	d1e8      	bne.n	8016d8a <_serial_poll_rx+0x22>
        data ++; length --;

        if (ch == '\n') break;
    }

    return size - length;
 8016db8:	697a      	ldr	r2, [r7, #20]
 8016dba:	687b      	ldr	r3, [r7, #4]
 8016dbc:	1ad3      	subs	r3, r2, r3
}
 8016dbe:	4618      	mov	r0, r3
 8016dc0:	3718      	adds	r7, #24
 8016dc2:	46bd      	mov	sp, r7
 8016dc4:	bd80      	pop	{r7, pc}
 8016dc6:	bf00      	nop
 8016dc8:	08023618 	.word	0x08023618
 8016dcc:	0802535c 	.word	0x0802535c

08016dd0 <_serial_poll_tx>:

rt_inline int _serial_poll_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 8016dd0:	b580      	push	{r7, lr}
 8016dd2:	b086      	sub	sp, #24
 8016dd4:	af00      	add	r7, sp, #0
 8016dd6:	60f8      	str	r0, [r7, #12]
 8016dd8:	60b9      	str	r1, [r7, #8]
 8016dda:	607a      	str	r2, [r7, #4]
    int size;
    RT_ASSERT(serial != RT_NULL);
 8016ddc:	68fb      	ldr	r3, [r7, #12]
 8016dde:	2b00      	cmp	r3, #0
 8016de0:	d104      	bne.n	8016dec <_serial_poll_tx+0x1c>
 8016de2:	4818      	ldr	r0, [pc, #96]	; (8016e44 <_serial_poll_tx+0x74>)
 8016de4:	4918      	ldr	r1, [pc, #96]	; (8016e48 <_serial_poll_tx+0x78>)
 8016de6:	2240      	movs	r2, #64	; 0x40
 8016de8:	f7fc ffbc 	bl	8013d64 <rt_assert_handler>

    size = length;
 8016dec:	687b      	ldr	r3, [r7, #4]
 8016dee:	617b      	str	r3, [r7, #20]
    while (length)
 8016df0:	e01d      	b.n	8016e2e <_serial_poll_tx+0x5e>
    {
        /*
         * to be polite with serial console add a line feed
         * to the carriage return character
         */
        if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
 8016df2:	68bb      	ldr	r3, [r7, #8]
 8016df4:	781b      	ldrb	r3, [r3, #0]
 8016df6:	2b0a      	cmp	r3, #10
 8016df8:	d10b      	bne.n	8016e12 <_serial_poll_tx+0x42>
 8016dfa:	68fb      	ldr	r3, [r7, #12]
 8016dfc:	8b1b      	ldrh	r3, [r3, #24]
 8016dfe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016e02:	2b00      	cmp	r3, #0
 8016e04:	d005      	beq.n	8016e12 <_serial_poll_tx+0x42>
        {
            serial->ops->putc(serial, '\r');
 8016e06:	68fb      	ldr	r3, [r7, #12]
 8016e08:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8016e0a:	689b      	ldr	r3, [r3, #8]
 8016e0c:	68f8      	ldr	r0, [r7, #12]
 8016e0e:	210d      	movs	r1, #13
 8016e10:	4798      	blx	r3
        }
    
        serial->ops->putc(serial, *data);
 8016e12:	68fb      	ldr	r3, [r7, #12]
 8016e14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8016e16:	689b      	ldr	r3, [r3, #8]
 8016e18:	68ba      	ldr	r2, [r7, #8]
 8016e1a:	7812      	ldrb	r2, [r2, #0]
 8016e1c:	68f8      	ldr	r0, [r7, #12]
 8016e1e:	4611      	mov	r1, r2
 8016e20:	4798      	blx	r3
    
        ++ data;
 8016e22:	68bb      	ldr	r3, [r7, #8]
 8016e24:	3301      	adds	r3, #1
 8016e26:	60bb      	str	r3, [r7, #8]
        -- length;
 8016e28:	687b      	ldr	r3, [r7, #4]
 8016e2a:	3b01      	subs	r3, #1
 8016e2c:	607b      	str	r3, [r7, #4]
{
    int size;
    RT_ASSERT(serial != RT_NULL);

    size = length;
    while (length)
 8016e2e:	687b      	ldr	r3, [r7, #4]
 8016e30:	2b00      	cmp	r3, #0
 8016e32:	d1de      	bne.n	8016df2 <_serial_poll_tx+0x22>
    
        ++ data;
        -- length;
    }

    return size - length;
 8016e34:	697a      	ldr	r2, [r7, #20]
 8016e36:	687b      	ldr	r3, [r7, #4]
 8016e38:	1ad3      	subs	r3, r2, r3
}
 8016e3a:	4618      	mov	r0, r3
 8016e3c:	3718      	adds	r7, #24
 8016e3e:	46bd      	mov	sp, r7
 8016e40:	bd80      	pop	{r7, pc}
 8016e42:	bf00      	nop
 8016e44:	08023618 	.word	0x08023618
 8016e48:	0802538c 	.word	0x0802538c

08016e4c <_serial_int_rx>:

/*
 * Serial interrupt routines
 */
rt_inline int _serial_int_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 8016e4c:	b580      	push	{r7, lr}
 8016e4e:	b088      	sub	sp, #32
 8016e50:	af00      	add	r7, sp, #0
 8016e52:	60f8      	str	r0, [r7, #12]
 8016e54:	60b9      	str	r1, [r7, #8]
 8016e56:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_serial_rx_fifo* rx_fifo;

    RT_ASSERT(serial != RT_NULL);
 8016e58:	68fb      	ldr	r3, [r7, #12]
 8016e5a:	2b00      	cmp	r3, #0
 8016e5c:	d104      	bne.n	8016e68 <_serial_int_rx+0x1c>
 8016e5e:	4828      	ldr	r0, [pc, #160]	; (8016f00 <_serial_int_rx+0xb4>)
 8016e60:	4928      	ldr	r1, [pc, #160]	; (8016f04 <_serial_int_rx+0xb8>)
 8016e62:	225f      	movs	r2, #95	; 0x5f
 8016e64:	f7fc ff7e 	bl	8013d64 <rt_assert_handler>
    size = length; 
 8016e68:	687b      	ldr	r3, [r7, #4]
 8016e6a:	61fb      	str	r3, [r7, #28]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
 8016e6c:	68fb      	ldr	r3, [r7, #12]
 8016e6e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8016e70:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_fifo != RT_NULL);
 8016e72:	69bb      	ldr	r3, [r7, #24]
 8016e74:	2b00      	cmp	r3, #0
 8016e76:	d104      	bne.n	8016e82 <_serial_int_rx+0x36>
 8016e78:	4823      	ldr	r0, [pc, #140]	; (8016f08 <_serial_int_rx+0xbc>)
 8016e7a:	4922      	ldr	r1, [pc, #136]	; (8016f04 <_serial_int_rx+0xb8>)
 8016e7c:	2263      	movs	r2, #99	; 0x63
 8016e7e:	f7fc ff71 	bl	8013d64 <rt_assert_handler>

    /* read from software FIFO */
    while (length)
 8016e82:	e033      	b.n	8016eec <_serial_int_rx+0xa0>
    {
        int ch;
        rt_base_t level;

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
 8016e84:	f7e9 f9a0 	bl	80001c8 <rt_hw_interrupt_disable>
 8016e88:	6178      	str	r0, [r7, #20]
        if (rx_fifo->get_index != rx_fifo->put_index)
 8016e8a:	69bb      	ldr	r3, [r7, #24]
 8016e8c:	88da      	ldrh	r2, [r3, #6]
 8016e8e:	69bb      	ldr	r3, [r7, #24]
 8016e90:	889b      	ldrh	r3, [r3, #4]
 8016e92:	429a      	cmp	r2, r3
 8016e94:	d019      	beq.n	8016eca <_serial_int_rx+0x7e>
        {
            ch = rx_fifo->buffer[rx_fifo->get_index];
 8016e96:	69bb      	ldr	r3, [r7, #24]
 8016e98:	681b      	ldr	r3, [r3, #0]
 8016e9a:	69ba      	ldr	r2, [r7, #24]
 8016e9c:	88d2      	ldrh	r2, [r2, #6]
 8016e9e:	4413      	add	r3, r2
 8016ea0:	781b      	ldrb	r3, [r3, #0]
 8016ea2:	613b      	str	r3, [r7, #16]
            rx_fifo->get_index += 1;
 8016ea4:	69bb      	ldr	r3, [r7, #24]
 8016ea6:	88db      	ldrh	r3, [r3, #6]
 8016ea8:	3301      	adds	r3, #1
 8016eaa:	b29a      	uxth	r2, r3
 8016eac:	69bb      	ldr	r3, [r7, #24]
 8016eae:	80da      	strh	r2, [r3, #6]
            if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
 8016eb0:	69bb      	ldr	r3, [r7, #24]
 8016eb2:	88da      	ldrh	r2, [r3, #6]
 8016eb4:	68fb      	ldr	r3, [r7, #12]
 8016eb6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016eb8:	f3c3 238f 	ubfx	r3, r3, #10, #16
 8016ebc:	b29b      	uxth	r3, r3
 8016ebe:	429a      	cmp	r2, r3
 8016ec0:	d307      	bcc.n	8016ed2 <_serial_int_rx+0x86>
 8016ec2:	69bb      	ldr	r3, [r7, #24]
 8016ec4:	2200      	movs	r2, #0
 8016ec6:	80da      	strh	r2, [r3, #6]
 8016ec8:	e003      	b.n	8016ed2 <_serial_int_rx+0x86>
        }
        else
        {
            /* no data, enable interrupt and break out */
            rt_hw_interrupt_enable(level);
 8016eca:	6978      	ldr	r0, [r7, #20]
 8016ecc:	f7e9 f980 	bl	80001d0 <rt_hw_interrupt_enable>
            break;
 8016ed0:	e00f      	b.n	8016ef2 <_serial_int_rx+0xa6>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8016ed2:	6978      	ldr	r0, [r7, #20]
 8016ed4:	f7e9 f97c 	bl	80001d0 <rt_hw_interrupt_enable>

        *data = ch & 0xff;
 8016ed8:	693b      	ldr	r3, [r7, #16]
 8016eda:	b2da      	uxtb	r2, r3
 8016edc:	68bb      	ldr	r3, [r7, #8]
 8016ede:	701a      	strb	r2, [r3, #0]
        data ++; length --;
 8016ee0:	68bb      	ldr	r3, [r7, #8]
 8016ee2:	3301      	adds	r3, #1
 8016ee4:	60bb      	str	r3, [r7, #8]
 8016ee6:	687b      	ldr	r3, [r7, #4]
 8016ee8:	3b01      	subs	r3, #1
 8016eea:	607b      	str	r3, [r7, #4]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (length)
 8016eec:	687b      	ldr	r3, [r7, #4]
 8016eee:	2b00      	cmp	r3, #0
 8016ef0:	d1c8      	bne.n	8016e84 <_serial_int_rx+0x38>

        *data = ch & 0xff;
        data ++; length --;
    }

    return size - length;
 8016ef2:	69fa      	ldr	r2, [r7, #28]
 8016ef4:	687b      	ldr	r3, [r7, #4]
 8016ef6:	1ad3      	subs	r3, r2, r3
}
 8016ef8:	4618      	mov	r0, r3
 8016efa:	3720      	adds	r7, #32
 8016efc:	46bd      	mov	sp, r7
 8016efe:	bd80      	pop	{r7, pc}
 8016f00:	08023618 	.word	0x08023618
 8016f04:	0802533c 	.word	0x0802533c
 8016f08:	0802362c 	.word	0x0802362c

08016f0c <_serial_int_tx>:

rt_inline int _serial_int_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 8016f0c:	b580      	push	{r7, lr}
 8016f0e:	b086      	sub	sp, #24
 8016f10:	af00      	add	r7, sp, #0
 8016f12:	60f8      	str	r0, [r7, #12]
 8016f14:	60b9      	str	r1, [r7, #8]
 8016f16:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_serial_tx_fifo *tx;
    
    RT_ASSERT(serial != RT_NULL);
 8016f18:	68fb      	ldr	r3, [r7, #12]
 8016f1a:	2b00      	cmp	r3, #0
 8016f1c:	d104      	bne.n	8016f28 <_serial_int_tx+0x1c>
 8016f1e:	481b      	ldr	r0, [pc, #108]	; (8016f8c <_serial_int_tx+0x80>)
 8016f20:	491b      	ldr	r1, [pc, #108]	; (8016f90 <_serial_int_tx+0x84>)
 8016f22:	2289      	movs	r2, #137	; 0x89
 8016f24:	f7fc ff1e 	bl	8013d64 <rt_assert_handler>

    size = length;
 8016f28:	687b      	ldr	r3, [r7, #4]
 8016f2a:	617b      	str	r3, [r7, #20]
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
 8016f2c:	68fb      	ldr	r3, [r7, #12]
 8016f2e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8016f30:	613b      	str	r3, [r7, #16]
    RT_ASSERT(tx != RT_NULL);
 8016f32:	693b      	ldr	r3, [r7, #16]
 8016f34:	2b00      	cmp	r3, #0
 8016f36:	d104      	bne.n	8016f42 <_serial_int_tx+0x36>
 8016f38:	4816      	ldr	r0, [pc, #88]	; (8016f94 <_serial_int_tx+0x88>)
 8016f3a:	4915      	ldr	r1, [pc, #84]	; (8016f90 <_serial_int_tx+0x84>)
 8016f3c:	228d      	movs	r2, #141	; 0x8d
 8016f3e:	f7fc ff11 	bl	8013d64 <rt_assert_handler>

    while (length)
 8016f42:	e018      	b.n	8016f76 <_serial_int_tx+0x6a>
    {
        if (serial->ops->putc(serial, *(char*)data) == -1)
 8016f44:	68fb      	ldr	r3, [r7, #12]
 8016f46:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8016f48:	689b      	ldr	r3, [r3, #8]
 8016f4a:	68ba      	ldr	r2, [r7, #8]
 8016f4c:	7812      	ldrb	r2, [r2, #0]
 8016f4e:	68f8      	ldr	r0, [r7, #12]
 8016f50:	4611      	mov	r1, r2
 8016f52:	4798      	blx	r3
 8016f54:	4603      	mov	r3, r0
 8016f56:	f1b3 3fff 	cmp.w	r3, #4294967295
 8016f5a:	d106      	bne.n	8016f6a <_serial_int_tx+0x5e>
        {
            rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
 8016f5c:	693b      	ldr	r3, [r7, #16]
 8016f5e:	4618      	mov	r0, r3
 8016f60:	f04f 31ff 	mov.w	r1, #4294967295
 8016f64:	f7ff f876 	bl	8016054 <rt_completion_wait>
            continue;
 8016f68:	e005      	b.n	8016f76 <_serial_int_tx+0x6a>
        }

        data ++; length --;
 8016f6a:	68bb      	ldr	r3, [r7, #8]
 8016f6c:	3301      	adds	r3, #1
 8016f6e:	60bb      	str	r3, [r7, #8]
 8016f70:	687b      	ldr	r3, [r7, #4]
 8016f72:	3b01      	subs	r3, #1
 8016f74:	607b      	str	r3, [r7, #4]

    size = length;
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
    RT_ASSERT(tx != RT_NULL);

    while (length)
 8016f76:	687b      	ldr	r3, [r7, #4]
 8016f78:	2b00      	cmp	r3, #0
 8016f7a:	d1e3      	bne.n	8016f44 <_serial_int_tx+0x38>
        }

        data ++; length --;
    }

    return size - length;
 8016f7c:	697a      	ldr	r2, [r7, #20]
 8016f7e:	687b      	ldr	r3, [r7, #4]
 8016f80:	1ad3      	subs	r3, r2, r3
}
 8016f82:	4618      	mov	r0, r3
 8016f84:	3718      	adds	r7, #24
 8016f86:	46bd      	mov	sp, r7
 8016f88:	bd80      	pop	{r7, pc}
 8016f8a:	bf00      	nop
 8016f8c:	08023618 	.word	0x08023618
 8016f90:	0802537c 	.word	0x0802537c
 8016f94:	08023640 	.word	0x08023640

08016f98 <_serial_dma_rx>:

/*
 * Serial DMA routines
 */
rt_inline int _serial_dma_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 8016f98:	b590      	push	{r4, r7, lr}
 8016f9a:	b089      	sub	sp, #36	; 0x24
 8016f9c:	af00      	add	r7, sp, #0
 8016f9e:	60f8      	str	r0, [r7, #12]
 8016fa0:	60b9      	str	r1, [r7, #8]
 8016fa2:	607a      	str	r2, [r7, #4]
    rt_base_t level;
    int result = RT_EOK;
 8016fa4:	2300      	movs	r3, #0
 8016fa6:	61fb      	str	r3, [r7, #28]
    struct rt_serial_rx_dma *rx_dma;

    RT_ASSERT((serial != RT_NULL) && (data != RT_NULL));
 8016fa8:	68fb      	ldr	r3, [r7, #12]
 8016faa:	2b00      	cmp	r3, #0
 8016fac:	d002      	beq.n	8016fb4 <_serial_dma_rx+0x1c>
 8016fae:	68bb      	ldr	r3, [r7, #8]
 8016fb0:	2b00      	cmp	r3, #0
 8016fb2:	d104      	bne.n	8016fbe <_serial_dma_rx+0x26>
 8016fb4:	4815      	ldr	r0, [pc, #84]	; (801700c <_serial_dma_rx+0x74>)
 8016fb6:	4916      	ldr	r1, [pc, #88]	; (8017010 <_serial_dma_rx+0x78>)
 8016fb8:	22a6      	movs	r2, #166	; 0xa6
 8016fba:	f7fc fed3 	bl	8013d64 <rt_assert_handler>
    rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
 8016fbe:	68fb      	ldr	r3, [r7, #12]
 8016fc0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8016fc2:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_dma != RT_NULL);
 8016fc4:	69bb      	ldr	r3, [r7, #24]
 8016fc6:	2b00      	cmp	r3, #0
 8016fc8:	d104      	bne.n	8016fd4 <_serial_dma_rx+0x3c>
 8016fca:	4812      	ldr	r0, [pc, #72]	; (8017014 <_serial_dma_rx+0x7c>)
 8016fcc:	4910      	ldr	r1, [pc, #64]	; (8017010 <_serial_dma_rx+0x78>)
 8016fce:	22a8      	movs	r2, #168	; 0xa8
 8016fd0:	f7fc fec8 	bl	8013d64 <rt_assert_handler>
    level = rt_hw_interrupt_disable();
 8016fd4:	f7e9 f8f8 	bl	80001c8 <rt_hw_interrupt_disable>
 8016fd8:	6178      	str	r0, [r7, #20]
    //if (rx_dma->activated != RT_TRUE)
    //{
        //rx_dma->activated = RT_TRUE;
        serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_RX);
 8016fda:	68fb      	ldr	r3, [r7, #12]
 8016fdc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8016fde:	691c      	ldr	r4, [r3, #16]
 8016fe0:	687b      	ldr	r3, [r7, #4]
 8016fe2:	68f8      	ldr	r0, [r7, #12]
 8016fe4:	68b9      	ldr	r1, [r7, #8]
 8016fe6:	461a      	mov	r2, r3
 8016fe8:	2301      	movs	r3, #1
 8016fea:	47a0      	blx	r4
    //}
    //else result = -RT_EBUSY;
    rt_hw_interrupt_enable(level);
 8016fec:	6978      	ldr	r0, [r7, #20]
 8016fee:	f7e9 f8ef 	bl	80001d0 <rt_hw_interrupt_enable>

    if (result == RT_EOK) return length;
 8016ff2:	69fb      	ldr	r3, [r7, #28]
 8016ff4:	2b00      	cmp	r3, #0
 8016ff6:	d101      	bne.n	8016ffc <_serial_dma_rx+0x64>
 8016ff8:	687b      	ldr	r3, [r7, #4]
 8016ffa:	e003      	b.n	8017004 <_serial_dma_rx+0x6c>

    rt_set_errno(result);
 8016ffc:	69f8      	ldr	r0, [r7, #28]
 8016ffe:	f7fc f85f 	bl	80130c0 <rt_set_errno>
    return 0;
 8017002:	2300      	movs	r3, #0
}
 8017004:	4618      	mov	r0, r3
 8017006:	3724      	adds	r7, #36	; 0x24
 8017008:	46bd      	mov	sp, r7
 801700a:	bd90      	pop	{r4, r7, pc}
 801700c:	08023650 	.word	0x08023650
 8017010:	0802534c 	.word	0x0802534c
 8017014:	0802367c 	.word	0x0802367c

08017018 <_serial_dma_tx>:

rt_inline int _serial_dma_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 8017018:	b590      	push	{r4, r7, lr}
 801701a:	b089      	sub	sp, #36	; 0x24
 801701c:	af00      	add	r7, sp, #0
 801701e:	60f8      	str	r0, [r7, #12]
 8017020:	60b9      	str	r1, [r7, #8]
 8017022:	607a      	str	r2, [r7, #4]
    rt_base_t level;
    rt_err_t result;
    struct rt_serial_tx_dma *tx_dma;

    tx_dma = (struct rt_serial_tx_dma*)(serial->serial_tx);
 8017024:	68fb      	ldr	r3, [r7, #12]
 8017026:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8017028:	61fb      	str	r3, [r7, #28]
    
    result = rt_data_queue_push(&(tx_dma->data_queue), data, length, RT_WAITING_FOREVER); 
 801702a:	69fb      	ldr	r3, [r7, #28]
 801702c:	1d1a      	adds	r2, r3, #4
 801702e:	687b      	ldr	r3, [r7, #4]
 8017030:	4610      	mov	r0, r2
 8017032:	68b9      	ldr	r1, [r7, #8]
 8017034:	461a      	mov	r2, r3
 8017036:	f04f 33ff 	mov.w	r3, #4294967295
 801703a:	f7ff f941 	bl	80162c0 <rt_data_queue_push>
 801703e:	61b8      	str	r0, [r7, #24]
    if (result == RT_EOK)
 8017040:	69bb      	ldr	r3, [r7, #24]
 8017042:	2b00      	cmp	r3, #0
 8017044:	d11b      	bne.n	801707e <_serial_dma_tx+0x66>
    {
        level = rt_hw_interrupt_disable();
 8017046:	f7e9 f8bf 	bl	80001c8 <rt_hw_interrupt_disable>
 801704a:	6178      	str	r0, [r7, #20]
        if (tx_dma->activated != RT_TRUE)
 801704c:	69fb      	ldr	r3, [r7, #28]
 801704e:	681b      	ldr	r3, [r3, #0]
 8017050:	2b01      	cmp	r3, #1
 8017052:	d00f      	beq.n	8017074 <_serial_dma_tx+0x5c>
        {
            tx_dma->activated = RT_TRUE;
 8017054:	69fb      	ldr	r3, [r7, #28]
 8017056:	2201      	movs	r2, #1
 8017058:	601a      	str	r2, [r3, #0]
            rt_hw_interrupt_enable(level);
 801705a:	6978      	ldr	r0, [r7, #20]
 801705c:	f7e9 f8b8 	bl	80001d0 <rt_hw_interrupt_enable>

            /* make a DMA transfer */
            serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_TX);
 8017060:	68fb      	ldr	r3, [r7, #12]
 8017062:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017064:	691c      	ldr	r4, [r3, #16]
 8017066:	687b      	ldr	r3, [r7, #4]
 8017068:	68f8      	ldr	r0, [r7, #12]
 801706a:	68b9      	ldr	r1, [r7, #8]
 801706c:	461a      	mov	r2, r3
 801706e:	2302      	movs	r3, #2
 8017070:	47a0      	blx	r4
 8017072:	e002      	b.n	801707a <_serial_dma_tx+0x62>
        }
        else
        {
            rt_hw_interrupt_enable(level);
 8017074:	6978      	ldr	r0, [r7, #20]
 8017076:	f7e9 f8ab 	bl	80001d0 <rt_hw_interrupt_enable>
        }

        return length;
 801707a:	687b      	ldr	r3, [r7, #4]
 801707c:	e003      	b.n	8017086 <_serial_dma_tx+0x6e>
    }
    else
    {
        rt_set_errno(result);
 801707e:	69b8      	ldr	r0, [r7, #24]
 8017080:	f7fc f81e 	bl	80130c0 <rt_set_errno>
        return 0;
 8017084:	2300      	movs	r3, #0
    }
}
 8017086:	4618      	mov	r0, r3
 8017088:	3724      	adds	r7, #36	; 0x24
 801708a:	46bd      	mov	sp, r7
 801708c:	bd90      	pop	{r4, r7, pc}
 801708e:	bf00      	nop

08017090 <rt_serial_init>:
/* RT-Thread Device Interface */
/*
 * This function initializes serial device.
 */
static rt_err_t rt_serial_init(struct rt_device *dev)
{
 8017090:	b580      	push	{r7, lr}
 8017092:	b084      	sub	sp, #16
 8017094:	af00      	add	r7, sp, #0
 8017096:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 8017098:	2300      	movs	r3, #0
 801709a:	60fb      	str	r3, [r7, #12]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801709c:	687b      	ldr	r3, [r7, #4]
 801709e:	2b00      	cmp	r3, #0
 80170a0:	d104      	bne.n	80170ac <rt_serial_init+0x1c>
 80170a2:	4812      	ldr	r0, [pc, #72]	; (80170ec <rt_serial_init+0x5c>)
 80170a4:	4912      	ldr	r1, [pc, #72]	; (80170f0 <rt_serial_init+0x60>)
 80170a6:	22e3      	movs	r2, #227	; 0xe3
 80170a8:	f7fc fe5c 	bl	8013d64 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 80170ac:	687b      	ldr	r3, [r7, #4]
 80170ae:	60bb      	str	r3, [r7, #8]

    /* initialize rx/tx */
    serial->serial_rx = RT_NULL;
 80170b0:	68bb      	ldr	r3, [r7, #8]
 80170b2:	2200      	movs	r2, #0
 80170b4:	64da      	str	r2, [r3, #76]	; 0x4c
    serial->serial_tx = RT_NULL;
 80170b6:	68bb      	ldr	r3, [r7, #8]
 80170b8:	2200      	movs	r2, #0
 80170ba:	651a      	str	r2, [r3, #80]	; 0x50

    /* apply configuration */
    if (serial->ops->configure)
 80170bc:	68bb      	ldr	r3, [r7, #8]
 80170be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80170c0:	681b      	ldr	r3, [r3, #0]
 80170c2:	2b00      	cmp	r3, #0
 80170c4:	d008      	beq.n	80170d8 <rt_serial_init+0x48>
        result = serial->ops->configure(serial, &serial->config);
 80170c6:	68bb      	ldr	r3, [r7, #8]
 80170c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80170ca:	681b      	ldr	r3, [r3, #0]
 80170cc:	68ba      	ldr	r2, [r7, #8]
 80170ce:	3244      	adds	r2, #68	; 0x44
 80170d0:	68b8      	ldr	r0, [r7, #8]
 80170d2:	4611      	mov	r1, r2
 80170d4:	4798      	blx	r3
 80170d6:	60f8      	str	r0, [r7, #12]
	rt_kprintf("%x\r\n", result);
 80170d8:	4806      	ldr	r0, [pc, #24]	; (80170f4 <rt_serial_init+0x64>)
 80170da:	68f9      	ldr	r1, [r7, #12]
 80170dc:	f7fc fdc8 	bl	8013c70 <rt_kprintf>
    return result;
 80170e0:	68fb      	ldr	r3, [r7, #12]
}
 80170e2:	4618      	mov	r0, r3
 80170e4:	3710      	adds	r7, #16
 80170e6:	46bd      	mov	sp, r7
 80170e8:	bd80      	pop	{r7, pc}
 80170ea:	bf00      	nop
 80170ec:	08023690 	.word	0x08023690
 80170f0:	080252fc 	.word	0x080252fc
 80170f4:	080236a0 	.word	0x080236a0

080170f8 <rt_serial_open>:

static rt_err_t rt_serial_open(struct rt_device *dev, rt_uint16_t oflag)
{
 80170f8:	b580      	push	{r7, lr}
 80170fa:	b088      	sub	sp, #32
 80170fc:	af00      	add	r7, sp, #0
 80170fe:	6078      	str	r0, [r7, #4]
 8017100:	460b      	mov	r3, r1
 8017102:	807b      	strh	r3, [r7, #2]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 8017104:	687b      	ldr	r3, [r7, #4]
 8017106:	2b00      	cmp	r3, #0
 8017108:	d104      	bne.n	8017114 <rt_serial_open+0x1c>
 801710a:	4889      	ldr	r0, [pc, #548]	; (8017330 <rt_serial_open+0x238>)
 801710c:	4989      	ldr	r1, [pc, #548]	; (8017334 <rt_serial_open+0x23c>)
 801710e:	22f5      	movs	r2, #245	; 0xf5
 8017110:	f7fc fe28 	bl	8013d64 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 8017114:	687b      	ldr	r3, [r7, #4]
 8017116:	61fb      	str	r3, [r7, #28]

    /* check device flag with the open flag */
    if ((oflag & RT_DEVICE_FLAG_DMA_RX) && !(dev->flag & RT_DEVICE_FLAG_DMA_RX)) 
 8017118:	887b      	ldrh	r3, [r7, #2]
 801711a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801711e:	2b00      	cmp	r3, #0
 8017120:	d008      	beq.n	8017134 <rt_serial_open+0x3c>
 8017122:	687b      	ldr	r3, [r7, #4]
 8017124:	8adb      	ldrh	r3, [r3, #22]
 8017126:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801712a:	2b00      	cmp	r3, #0
 801712c:	d102      	bne.n	8017134 <rt_serial_open+0x3c>
        return -RT_EIO;
 801712e:	f06f 0307 	mvn.w	r3, #7
 8017132:	e0f8      	b.n	8017326 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_DMA_TX) && !(dev->flag & RT_DEVICE_FLAG_DMA_TX))
 8017134:	887b      	ldrh	r3, [r7, #2]
 8017136:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801713a:	2b00      	cmp	r3, #0
 801713c:	d008      	beq.n	8017150 <rt_serial_open+0x58>
 801713e:	687b      	ldr	r3, [r7, #4]
 8017140:	8adb      	ldrh	r3, [r3, #22]
 8017142:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8017146:	2b00      	cmp	r3, #0
 8017148:	d102      	bne.n	8017150 <rt_serial_open+0x58>
        return -RT_EIO;
 801714a:	f06f 0307 	mvn.w	r3, #7
 801714e:	e0ea      	b.n	8017326 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_INT_RX) && !(dev->flag & RT_DEVICE_FLAG_INT_RX))
 8017150:	887b      	ldrh	r3, [r7, #2]
 8017152:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8017156:	2b00      	cmp	r3, #0
 8017158:	d008      	beq.n	801716c <rt_serial_open+0x74>
 801715a:	687b      	ldr	r3, [r7, #4]
 801715c:	8adb      	ldrh	r3, [r3, #22]
 801715e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8017162:	2b00      	cmp	r3, #0
 8017164:	d102      	bne.n	801716c <rt_serial_open+0x74>
        return -RT_EIO;
 8017166:	f06f 0307 	mvn.w	r3, #7
 801716a:	e0dc      	b.n	8017326 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_INT_TX) && !(dev->flag & RT_DEVICE_FLAG_INT_TX))
 801716c:	887b      	ldrh	r3, [r7, #2]
 801716e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8017172:	2b00      	cmp	r3, #0
 8017174:	d008      	beq.n	8017188 <rt_serial_open+0x90>
 8017176:	687b      	ldr	r3, [r7, #4]
 8017178:	8adb      	ldrh	r3, [r3, #22]
 801717a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801717e:	2b00      	cmp	r3, #0
 8017180:	d102      	bne.n	8017188 <rt_serial_open+0x90>
        return -RT_EIO;
 8017182:	f06f 0307 	mvn.w	r3, #7
 8017186:	e0ce      	b.n	8017326 <rt_serial_open+0x22e>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
 8017188:	887b      	ldrh	r3, [r7, #2]
 801718a:	b2db      	uxtb	r3, r3
 801718c:	b29a      	uxth	r2, r3
 801718e:	687b      	ldr	r3, [r7, #4]
 8017190:	831a      	strh	r2, [r3, #24]
    
    /* initialize the Rx/Tx structure according to open flag */
    if (serial->serial_rx == RT_NULL)
 8017192:	69fb      	ldr	r3, [r7, #28]
 8017194:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8017196:	2b00      	cmp	r3, #0
 8017198:	d16c      	bne.n	8017274 <rt_serial_open+0x17c>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_RX)
 801719a:	887b      	ldrh	r3, [r7, #2]
 801719c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80171a0:	2b00      	cmp	r3, #0
 80171a2:	d022      	beq.n	80171ea <rt_serial_open+0xf2>
        {
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*) rt_malloc (sizeof(struct rt_serial_rx_dma));
 80171a4:	2004      	movs	r0, #4
 80171a6:	f7fc ff11 	bl	8013fcc <rt_malloc>
 80171aa:	61b8      	str	r0, [r7, #24]
            RT_ASSERT(rx_dma != RT_NULL);
 80171ac:	69bb      	ldr	r3, [r7, #24]
 80171ae:	2b00      	cmp	r3, #0
 80171b0:	d105      	bne.n	80171be <rt_serial_open+0xc6>
 80171b2:	4861      	ldr	r0, [pc, #388]	; (8017338 <rt_serial_open+0x240>)
 80171b4:	495f      	ldr	r1, [pc, #380]	; (8017334 <rt_serial_open+0x23c>)
 80171b6:	f240 120d 	movw	r2, #269	; 0x10d
 80171ba:	f7fc fdd3 	bl	8013d64 <rt_assert_handler>
            rx_dma->activated = RT_FALSE;
 80171be:	69bb      	ldr	r3, [r7, #24]
 80171c0:	2200      	movs	r2, #0
 80171c2:	601a      	str	r2, [r3, #0]

            serial->serial_rx = rx_dma;
 80171c4:	69fb      	ldr	r3, [r7, #28]
 80171c6:	69ba      	ldr	r2, [r7, #24]
 80171c8:	64da      	str	r2, [r3, #76]	; 0x4c
            dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
 80171ca:	687b      	ldr	r3, [r7, #4]
 80171cc:	8b1b      	ldrh	r3, [r3, #24]
 80171ce:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80171d2:	b29a      	uxth	r2, r3
 80171d4:	687b      	ldr	r3, [r7, #4]
 80171d6:	831a      	strh	r2, [r3, #24]
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_DMARX, (void *)RT_DEVICE_FLAG_DMA_RX);
 80171d8:	69fb      	ldr	r3, [r7, #28]
 80171da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80171dc:	685b      	ldr	r3, [r3, #4]
 80171de:	69f8      	ldr	r0, [r7, #28]
 80171e0:	2114      	movs	r1, #20
 80171e2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80171e6:	4798      	blx	r3
 80171e8:	e044      	b.n	8017274 <rt_serial_open+0x17c>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
 80171ea:	887b      	ldrh	r3, [r7, #2]
 80171ec:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80171f0:	2b00      	cmp	r3, #0
 80171f2:	d03c      	beq.n	801726e <rt_serial_open+0x176>
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
                serial->config.bufsz);
 80171f4:	69fb      	ldr	r3, [r7, #28]
 80171f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80171f8:	f3c3 238f 	ubfx	r3, r3, #10, #16
 80171fc:	b29b      	uxth	r3, r3
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
 80171fe:	3308      	adds	r3, #8
 8017200:	4618      	mov	r0, r3
 8017202:	f7fc fee3 	bl	8013fcc <rt_malloc>
 8017206:	6178      	str	r0, [r7, #20]
                serial->config.bufsz);
            RT_ASSERT(rx_fifo != RT_NULL);
 8017208:	697b      	ldr	r3, [r7, #20]
 801720a:	2b00      	cmp	r3, #0
 801720c:	d105      	bne.n	801721a <rt_serial_open+0x122>
 801720e:	484b      	ldr	r0, [pc, #300]	; (801733c <rt_serial_open+0x244>)
 8017210:	4948      	ldr	r1, [pc, #288]	; (8017334 <rt_serial_open+0x23c>)
 8017212:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8017216:	f7fc fda5 	bl	8013d64 <rt_assert_handler>
            rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
 801721a:	697b      	ldr	r3, [r7, #20]
 801721c:	f103 0208 	add.w	r2, r3, #8
 8017220:	697b      	ldr	r3, [r7, #20]
 8017222:	601a      	str	r2, [r3, #0]
            rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
 8017224:	697b      	ldr	r3, [r7, #20]
 8017226:	681a      	ldr	r2, [r3, #0]
 8017228:	69fb      	ldr	r3, [r7, #28]
 801722a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801722c:	f3c3 238f 	ubfx	r3, r3, #10, #16
 8017230:	b29b      	uxth	r3, r3
 8017232:	4610      	mov	r0, r2
 8017234:	2100      	movs	r1, #0
 8017236:	461a      	mov	r2, r3
 8017238:	f7fb ff62 	bl	8013100 <rt_memset>
            rx_fifo->put_index = 0;
 801723c:	697b      	ldr	r3, [r7, #20]
 801723e:	2200      	movs	r2, #0
 8017240:	809a      	strh	r2, [r3, #4]
            rx_fifo->get_index = 0;
 8017242:	697b      	ldr	r3, [r7, #20]
 8017244:	2200      	movs	r2, #0
 8017246:	80da      	strh	r2, [r3, #6]

            serial->serial_rx = rx_fifo;
 8017248:	69fb      	ldr	r3, [r7, #28]
 801724a:	697a      	ldr	r2, [r7, #20]
 801724c:	64da      	str	r2, [r3, #76]	; 0x4c
            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
 801724e:	687b      	ldr	r3, [r7, #4]
 8017250:	8b1b      	ldrh	r3, [r3, #24]
 8017252:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8017256:	b29a      	uxth	r2, r3
 8017258:	687b      	ldr	r3, [r7, #4]
 801725a:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 801725c:	69fb      	ldr	r3, [r7, #28]
 801725e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017260:	685b      	ldr	r3, [r3, #4]
 8017262:	69f8      	ldr	r0, [r7, #28]
 8017264:	2110      	movs	r1, #16
 8017266:	f44f 7280 	mov.w	r2, #256	; 0x100
 801726a:	4798      	blx	r3
 801726c:	e002      	b.n	8017274 <rt_serial_open+0x17c>
        }
        else
        {
            serial->serial_rx = RT_NULL;
 801726e:	69fb      	ldr	r3, [r7, #28]
 8017270:	2200      	movs	r2, #0
 8017272:	64da      	str	r2, [r3, #76]	; 0x4c
        }
    }

    if (serial->serial_tx == RT_NULL)
 8017274:	69fb      	ldr	r3, [r7, #28]
 8017276:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8017278:	2b00      	cmp	r3, #0
 801727a:	d153      	bne.n	8017324 <rt_serial_open+0x22c>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_TX)
 801727c:	887b      	ldrh	r3, [r7, #2]
 801727e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8017282:	2b00      	cmp	r3, #0
 8017284:	d022      	beq.n	80172cc <rt_serial_open+0x1d4>
        {
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) rt_malloc (sizeof(struct rt_serial_tx_dma));
 8017286:	2028      	movs	r0, #40	; 0x28
 8017288:	f7fc fea0 	bl	8013fcc <rt_malloc>
 801728c:	6138      	str	r0, [r7, #16]
            RT_ASSERT(tx_dma != RT_NULL);
 801728e:	693b      	ldr	r3, [r7, #16]
 8017290:	2b00      	cmp	r3, #0
 8017292:	d105      	bne.n	80172a0 <rt_serial_open+0x1a8>
 8017294:	482a      	ldr	r0, [pc, #168]	; (8017340 <rt_serial_open+0x248>)
 8017296:	4927      	ldr	r1, [pc, #156]	; (8017334 <rt_serial_open+0x23c>)
 8017298:	f44f 7299 	mov.w	r2, #306	; 0x132
 801729c:	f7fc fd62 	bl	8013d64 <rt_assert_handler>
            tx_dma->activated = RT_FALSE;
 80172a0:	693b      	ldr	r3, [r7, #16]
 80172a2:	2200      	movs	r2, #0
 80172a4:	601a      	str	r2, [r3, #0]
            
            rt_data_queue_init(&(tx_dma->data_queue), 8, 4, RT_NULL);
 80172a6:	693b      	ldr	r3, [r7, #16]
 80172a8:	3304      	adds	r3, #4
 80172aa:	4618      	mov	r0, r3
 80172ac:	2108      	movs	r1, #8
 80172ae:	2204      	movs	r2, #4
 80172b0:	2300      	movs	r3, #0
 80172b2:	f7fe ffbf 	bl	8016234 <rt_data_queue_init>
            serial->serial_tx = tx_dma;
 80172b6:	69fb      	ldr	r3, [r7, #28]
 80172b8:	693a      	ldr	r2, [r7, #16]
 80172ba:	651a      	str	r2, [r3, #80]	; 0x50

            dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
 80172bc:	687b      	ldr	r3, [r7, #4]
 80172be:	8b1b      	ldrh	r3, [r3, #24]
 80172c0:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80172c4:	b29a      	uxth	r2, r3
 80172c6:	687b      	ldr	r3, [r7, #4]
 80172c8:	831a      	strh	r2, [r3, #24]
 80172ca:	e02b      	b.n	8017324 <rt_serial_open+0x22c>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_TX)
 80172cc:	887b      	ldrh	r3, [r7, #2]
 80172ce:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80172d2:	2b00      	cmp	r3, #0
 80172d4:	d023      	beq.n	801731e <rt_serial_open+0x226>
        {
            struct rt_serial_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*) rt_malloc(sizeof(struct rt_serial_tx_fifo));
 80172d6:	200c      	movs	r0, #12
 80172d8:	f7fc fe78 	bl	8013fcc <rt_malloc>
 80172dc:	60f8      	str	r0, [r7, #12]
            RT_ASSERT(tx_fifo != RT_NULL);
 80172de:	68fb      	ldr	r3, [r7, #12]
 80172e0:	2b00      	cmp	r3, #0
 80172e2:	d105      	bne.n	80172f0 <rt_serial_open+0x1f8>
 80172e4:	4817      	ldr	r0, [pc, #92]	; (8017344 <rt_serial_open+0x24c>)
 80172e6:	4913      	ldr	r1, [pc, #76]	; (8017334 <rt_serial_open+0x23c>)
 80172e8:	f240 123f 	movw	r2, #319	; 0x13f
 80172ec:	f7fc fd3a 	bl	8013d64 <rt_assert_handler>

            rt_completion_init(&(tx_fifo->completion));
 80172f0:	68fb      	ldr	r3, [r7, #12]
 80172f2:	4618      	mov	r0, r3
 80172f4:	f7fe fe8c 	bl	8016010 <rt_completion_init>
            serial->serial_tx = tx_fifo;
 80172f8:	69fb      	ldr	r3, [r7, #28]
 80172fa:	68fa      	ldr	r2, [r7, #12]
 80172fc:	651a      	str	r2, [r3, #80]	; 0x50

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
 80172fe:	687b      	ldr	r3, [r7, #4]
 8017300:	8b1b      	ldrh	r3, [r3, #24]
 8017302:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8017306:	b29a      	uxth	r2, r3
 8017308:	687b      	ldr	r3, [r7, #4]
 801730a:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801730c:	69fb      	ldr	r3, [r7, #28]
 801730e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017310:	685b      	ldr	r3, [r3, #4]
 8017312:	69f8      	ldr	r0, [r7, #28]
 8017314:	2110      	movs	r1, #16
 8017316:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801731a:	4798      	blx	r3
 801731c:	e002      	b.n	8017324 <rt_serial_open+0x22c>
        }
        else
        {
            serial->serial_tx = RT_NULL;
 801731e:	69fb      	ldr	r3, [r7, #28]
 8017320:	2200      	movs	r2, #0
 8017322:	651a      	str	r2, [r3, #80]	; 0x50
        }
    }

    return RT_EOK;
 8017324:	2300      	movs	r3, #0
}
 8017326:	4618      	mov	r0, r3
 8017328:	3720      	adds	r7, #32
 801732a:	46bd      	mov	sp, r7
 801732c:	bd80      	pop	{r7, pc}
 801732e:	bf00      	nop
 8017330:	08023690 	.word	0x08023690
 8017334:	0802530c 	.word	0x0802530c
 8017338:	0802367c 	.word	0x0802367c
 801733c:	0802362c 	.word	0x0802362c
 8017340:	080236a8 	.word	0x080236a8
 8017344:	080236bc 	.word	0x080236bc

08017348 <rt_serial_close>:

static rt_err_t rt_serial_close(struct rt_device *dev)
{
 8017348:	b580      	push	{r7, lr}
 801734a:	b088      	sub	sp, #32
 801734c:	af00      	add	r7, sp, #0
 801734e:	6078      	str	r0, [r7, #4]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 8017350:	687b      	ldr	r3, [r7, #4]
 8017352:	2b00      	cmp	r3, #0
 8017354:	d105      	bne.n	8017362 <rt_serial_close+0x1a>
 8017356:	4850      	ldr	r0, [pc, #320]	; (8017498 <rt_serial_close+0x150>)
 8017358:	4950      	ldr	r1, [pc, #320]	; (801749c <rt_serial_close+0x154>)
 801735a:	f240 1255 	movw	r2, #341	; 0x155
 801735e:	f7fc fd01 	bl	8013d64 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 8017362:	687b      	ldr	r3, [r7, #4]
 8017364:	61fb      	str	r3, [r7, #28]

    /* this device has more reference count */
    if (dev->ref_count > 1) return RT_EOK;
 8017366:	687b      	ldr	r3, [r7, #4]
 8017368:	7e9b      	ldrb	r3, [r3, #26]
 801736a:	2b01      	cmp	r3, #1
 801736c:	d901      	bls.n	8017372 <rt_serial_close+0x2a>
 801736e:	2300      	movs	r3, #0
 8017370:	e08e      	b.n	8017490 <rt_serial_close+0x148>
    
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 8017372:	687b      	ldr	r3, [r7, #4]
 8017374:	8b1b      	ldrh	r3, [r3, #24]
 8017376:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801737a:	2b00      	cmp	r3, #0
 801737c:	d021      	beq.n	80173c2 <rt_serial_close+0x7a>
    {
        struct rt_serial_rx_fifo* rx_fifo;

        rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
 801737e:	69fb      	ldr	r3, [r7, #28]
 8017380:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8017382:	61bb      	str	r3, [r7, #24]
        RT_ASSERT(rx_fifo != RT_NULL);
 8017384:	69bb      	ldr	r3, [r7, #24]
 8017386:	2b00      	cmp	r3, #0
 8017388:	d105      	bne.n	8017396 <rt_serial_close+0x4e>
 801738a:	4845      	ldr	r0, [pc, #276]	; (80174a0 <rt_serial_close+0x158>)
 801738c:	4943      	ldr	r1, [pc, #268]	; (801749c <rt_serial_close+0x154>)
 801738e:	f44f 72b0 	mov.w	r2, #352	; 0x160
 8017392:	f7fc fce7 	bl	8013d64 <rt_assert_handler>

        rt_free(rx_fifo);
 8017396:	69b8      	ldr	r0, [r7, #24]
 8017398:	f7fd f822 	bl	80143e0 <rt_free>
        serial->serial_rx = RT_NULL;
 801739c:	69fb      	ldr	r3, [r7, #28]
 801739e:	2200      	movs	r2, #0
 80173a0:	64da      	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
 80173a2:	687b      	ldr	r3, [r7, #4]
 80173a4:	8b1b      	ldrh	r3, [r3, #24]
 80173a6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80173aa:	b29a      	uxth	r2, r3
 80173ac:	687b      	ldr	r3, [r7, #4]
 80173ae:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
 80173b0:	69fb      	ldr	r3, [r7, #28]
 80173b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80173b4:	685b      	ldr	r3, [r3, #4]
 80173b6:	69f8      	ldr	r0, [r7, #28]
 80173b8:	2111      	movs	r1, #17
 80173ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80173be:	4798      	blx	r3
 80173c0:	e01e      	b.n	8017400 <rt_serial_close+0xb8>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
 80173c2:	687b      	ldr	r3, [r7, #4]
 80173c4:	8b1b      	ldrh	r3, [r3, #24]
 80173c6:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80173ca:	2b00      	cmp	r3, #0
 80173cc:	d018      	beq.n	8017400 <rt_serial_close+0xb8>
    {
        struct rt_serial_rx_dma* rx_dma;

        rx_dma = (struct rt_serial_rx_dma*)serial->serial_tx;
 80173ce:	69fb      	ldr	r3, [r7, #28]
 80173d0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80173d2:	617b      	str	r3, [r7, #20]
        RT_ASSERT(rx_dma != RT_NULL);
 80173d4:	697b      	ldr	r3, [r7, #20]
 80173d6:	2b00      	cmp	r3, #0
 80173d8:	d105      	bne.n	80173e6 <rt_serial_close+0x9e>
 80173da:	4832      	ldr	r0, [pc, #200]	; (80174a4 <rt_serial_close+0x15c>)
 80173dc:	492f      	ldr	r1, [pc, #188]	; (801749c <rt_serial_close+0x154>)
 80173de:	f240 126d 	movw	r2, #365	; 0x16d
 80173e2:	f7fc fcbf 	bl	8013d64 <rt_assert_handler>

        rt_free(rx_dma);
 80173e6:	6978      	ldr	r0, [r7, #20]
 80173e8:	f7fc fffa 	bl	80143e0 <rt_free>
        serial->serial_rx = RT_NULL;
 80173ec:	69fb      	ldr	r3, [r7, #28]
 80173ee:	2200      	movs	r2, #0
 80173f0:	64da      	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_RX;
 80173f2:	687b      	ldr	r3, [r7, #4]
 80173f4:	8b1b      	ldrh	r3, [r3, #24]
 80173f6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80173fa:	b29a      	uxth	r2, r3
 80173fc:	687b      	ldr	r3, [r7, #4]
 80173fe:	831a      	strh	r2, [r3, #24]
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 8017400:	687b      	ldr	r3, [r7, #4]
 8017402:	8b1b      	ldrh	r3, [r3, #24]
 8017404:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8017408:	2b00      	cmp	r3, #0
 801740a:	d021      	beq.n	8017450 <rt_serial_close+0x108>
    {
        struct rt_serial_tx_fifo* tx_fifo;

        tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_rx;
 801740c:	69fb      	ldr	r3, [r7, #28]
 801740e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8017410:	613b      	str	r3, [r7, #16]
        RT_ASSERT(tx_fifo != RT_NULL);
 8017412:	693b      	ldr	r3, [r7, #16]
 8017414:	2b00      	cmp	r3, #0
 8017416:	d105      	bne.n	8017424 <rt_serial_close+0xdc>
 8017418:	4823      	ldr	r0, [pc, #140]	; (80174a8 <rt_serial_close+0x160>)
 801741a:	4920      	ldr	r1, [pc, #128]	; (801749c <rt_serial_close+0x154>)
 801741c:	f240 1279 	movw	r2, #377	; 0x179
 8017420:	f7fc fca0 	bl	8013d64 <rt_assert_handler>

        rt_free(tx_fifo);
 8017424:	6938      	ldr	r0, [r7, #16]
 8017426:	f7fc ffdb 	bl	80143e0 <rt_free>
        serial->serial_tx = RT_NULL;
 801742a:	69fb      	ldr	r3, [r7, #28]
 801742c:	2200      	movs	r2, #0
 801742e:	651a      	str	r2, [r3, #80]	; 0x50
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
 8017430:	687b      	ldr	r3, [r7, #4]
 8017432:	8b1b      	ldrh	r3, [r3, #24]
 8017434:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8017438:	b29a      	uxth	r2, r3
 801743a:	687b      	ldr	r3, [r7, #4]
 801743c:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
 801743e:	69fb      	ldr	r3, [r7, #28]
 8017440:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017442:	685b      	ldr	r3, [r3, #4]
 8017444:	69f8      	ldr	r0, [r7, #28]
 8017446:	2111      	movs	r1, #17
 8017448:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801744c:	4798      	blx	r3
 801744e:	e01e      	b.n	801748e <rt_serial_close+0x146>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
 8017450:	687b      	ldr	r3, [r7, #4]
 8017452:	8b1b      	ldrh	r3, [r3, #24]
 8017454:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8017458:	2b00      	cmp	r3, #0
 801745a:	d018      	beq.n	801748e <rt_serial_close+0x146>
    {
        struct rt_serial_tx_dma* tx_dma;

        tx_dma = (struct rt_serial_tx_dma*)serial->serial_tx;
 801745c:	69fb      	ldr	r3, [r7, #28]
 801745e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8017460:	60fb      	str	r3, [r7, #12]
        RT_ASSERT(tx_dma != RT_NULL);
 8017462:	68fb      	ldr	r3, [r7, #12]
 8017464:	2b00      	cmp	r3, #0
 8017466:	d105      	bne.n	8017474 <rt_serial_close+0x12c>
 8017468:	4810      	ldr	r0, [pc, #64]	; (80174ac <rt_serial_close+0x164>)
 801746a:	490c      	ldr	r1, [pc, #48]	; (801749c <rt_serial_close+0x154>)
 801746c:	f44f 72c3 	mov.w	r2, #390	; 0x186
 8017470:	f7fc fc78 	bl	8013d64 <rt_assert_handler>

        rt_free(tx_dma);
 8017474:	68f8      	ldr	r0, [r7, #12]
 8017476:	f7fc ffb3 	bl	80143e0 <rt_free>
        serial->serial_tx = RT_NULL;
 801747a:	69fb      	ldr	r3, [r7, #28]
 801747c:	2200      	movs	r2, #0
 801747e:	651a      	str	r2, [r3, #80]	; 0x50
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_TX;
 8017480:	687b      	ldr	r3, [r7, #4]
 8017482:	8b1b      	ldrh	r3, [r3, #24]
 8017484:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8017488:	b29a      	uxth	r2, r3
 801748a:	687b      	ldr	r3, [r7, #4]
 801748c:	831a      	strh	r2, [r3, #24]
    }

    return RT_EOK;
 801748e:	2300      	movs	r3, #0
}
 8017490:	4618      	mov	r0, r3
 8017492:	3720      	adds	r7, #32
 8017494:	46bd      	mov	sp, r7
 8017496:	bd80      	pop	{r7, pc}
 8017498:	08023690 	.word	0x08023690
 801749c:	0802531c 	.word	0x0802531c
 80174a0:	0802362c 	.word	0x0802362c
 80174a4:	0802367c 	.word	0x0802367c
 80174a8:	080236bc 	.word	0x080236bc
 80174ac:	080236a8 	.word	0x080236a8

080174b0 <rt_serial_read>:

static rt_size_t rt_serial_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)
{
 80174b0:	b580      	push	{r7, lr}
 80174b2:	b086      	sub	sp, #24
 80174b4:	af00      	add	r7, sp, #0
 80174b6:	60f8      	str	r0, [r7, #12]
 80174b8:	60b9      	str	r1, [r7, #8]
 80174ba:	607a      	str	r2, [r7, #4]
 80174bc:	603b      	str	r3, [r7, #0]
    struct rt_serial_device *serial;
	//rt_kprintf("&x\r\n",dev->open_flag);

    RT_ASSERT(dev != RT_NULL);
 80174be:	68fb      	ldr	r3, [r7, #12]
 80174c0:	2b00      	cmp	r3, #0
 80174c2:	d105      	bne.n	80174d0 <rt_serial_read+0x20>
 80174c4:	4819      	ldr	r0, [pc, #100]	; (801752c <rt_serial_read+0x7c>)
 80174c6:	491a      	ldr	r1, [pc, #104]	; (8017530 <rt_serial_read+0x80>)
 80174c8:	f44f 72cc 	mov.w	r2, #408	; 0x198
 80174cc:	f7fc fc4a 	bl	8013d64 <rt_assert_handler>
    if (size == 0) return 0;
 80174d0:	683b      	ldr	r3, [r7, #0]
 80174d2:	2b00      	cmp	r3, #0
 80174d4:	d101      	bne.n	80174da <rt_serial_read+0x2a>
 80174d6:	2300      	movs	r3, #0
 80174d8:	e024      	b.n	8017524 <rt_serial_read+0x74>

    serial = (struct rt_serial_device *)dev;
 80174da:	68fb      	ldr	r3, [r7, #12]
 80174dc:	617b      	str	r3, [r7, #20]
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 80174de:	68fb      	ldr	r3, [r7, #12]
 80174e0:	8b1b      	ldrh	r3, [r3, #24]
 80174e2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80174e6:	2b00      	cmp	r3, #0
 80174e8:	d007      	beq.n	80174fa <rt_serial_read+0x4a>
    {
        return _serial_int_rx(serial, buffer, size);
 80174ea:	683b      	ldr	r3, [r7, #0]
 80174ec:	6978      	ldr	r0, [r7, #20]
 80174ee:	6879      	ldr	r1, [r7, #4]
 80174f0:	461a      	mov	r2, r3
 80174f2:	f7ff fcab 	bl	8016e4c <_serial_int_rx>
 80174f6:	4603      	mov	r3, r0
 80174f8:	e014      	b.n	8017524 <rt_serial_read+0x74>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
 80174fa:	68fb      	ldr	r3, [r7, #12]
 80174fc:	8b1b      	ldrh	r3, [r3, #24]
 80174fe:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8017502:	2b00      	cmp	r3, #0
 8017504:	d007      	beq.n	8017516 <rt_serial_read+0x66>
    {
        return _serial_dma_rx(serial, buffer, size);
 8017506:	683b      	ldr	r3, [r7, #0]
 8017508:	6978      	ldr	r0, [r7, #20]
 801750a:	6879      	ldr	r1, [r7, #4]
 801750c:	461a      	mov	r2, r3
 801750e:	f7ff fd43 	bl	8016f98 <_serial_dma_rx>
 8017512:	4603      	mov	r3, r0
 8017514:	e006      	b.n	8017524 <rt_serial_read+0x74>
    }

    return _serial_poll_rx(serial, buffer, size);
 8017516:	683b      	ldr	r3, [r7, #0]
 8017518:	6978      	ldr	r0, [r7, #20]
 801751a:	6879      	ldr	r1, [r7, #4]
 801751c:	461a      	mov	r2, r3
 801751e:	f7ff fc23 	bl	8016d68 <_serial_poll_rx>
 8017522:	4603      	mov	r3, r0
}
 8017524:	4618      	mov	r0, r3
 8017526:	3718      	adds	r7, #24
 8017528:	46bd      	mov	sp, r7
 801752a:	bd80      	pop	{r7, pc}
 801752c:	08023690 	.word	0x08023690
 8017530:	0802532c 	.word	0x0802532c

08017534 <rt_serial_write>:

static rt_size_t rt_serial_write(struct rt_device *dev,
                                 rt_off_t          pos,
                                 const void       *buffer,
                                 rt_size_t         size)
{
 8017534:	b580      	push	{r7, lr}
 8017536:	b086      	sub	sp, #24
 8017538:	af00      	add	r7, sp, #0
 801753a:	60f8      	str	r0, [r7, #12]
 801753c:	60b9      	str	r1, [r7, #8]
 801753e:	607a      	str	r2, [r7, #4]
 8017540:	603b      	str	r3, [r7, #0]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 8017542:	68fb      	ldr	r3, [r7, #12]
 8017544:	2b00      	cmp	r3, #0
 8017546:	d105      	bne.n	8017554 <rt_serial_write+0x20>
 8017548:	4819      	ldr	r0, [pc, #100]	; (80175b0 <rt_serial_write+0x7c>)
 801754a:	491a      	ldr	r1, [pc, #104]	; (80175b4 <rt_serial_write+0x80>)
 801754c:	f240 12af 	movw	r2, #431	; 0x1af
 8017550:	f7fc fc08 	bl	8013d64 <rt_assert_handler>
    if (size == 0) return 0;
 8017554:	683b      	ldr	r3, [r7, #0]
 8017556:	2b00      	cmp	r3, #0
 8017558:	d101      	bne.n	801755e <rt_serial_write+0x2a>
 801755a:	2300      	movs	r3, #0
 801755c:	e024      	b.n	80175a8 <rt_serial_write+0x74>

    serial = (struct rt_serial_device *)dev;
 801755e:	68fb      	ldr	r3, [r7, #12]
 8017560:	617b      	str	r3, [r7, #20]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 8017562:	68fb      	ldr	r3, [r7, #12]
 8017564:	8b1b      	ldrh	r3, [r3, #24]
 8017566:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801756a:	2b00      	cmp	r3, #0
 801756c:	d007      	beq.n	801757e <rt_serial_write+0x4a>
    {
        return _serial_int_tx(serial, buffer, size);
 801756e:	683b      	ldr	r3, [r7, #0]
 8017570:	6978      	ldr	r0, [r7, #20]
 8017572:	6879      	ldr	r1, [r7, #4]
 8017574:	461a      	mov	r2, r3
 8017576:	f7ff fcc9 	bl	8016f0c <_serial_int_tx>
 801757a:	4603      	mov	r3, r0
 801757c:	e014      	b.n	80175a8 <rt_serial_write+0x74>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
 801757e:	68fb      	ldr	r3, [r7, #12]
 8017580:	8b1b      	ldrh	r3, [r3, #24]
 8017582:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8017586:	2b00      	cmp	r3, #0
 8017588:	d007      	beq.n	801759a <rt_serial_write+0x66>
    {
        return _serial_dma_tx(serial, buffer, size);
 801758a:	683b      	ldr	r3, [r7, #0]
 801758c:	6978      	ldr	r0, [r7, #20]
 801758e:	6879      	ldr	r1, [r7, #4]
 8017590:	461a      	mov	r2, r3
 8017592:	f7ff fd41 	bl	8017018 <_serial_dma_tx>
 8017596:	4603      	mov	r3, r0
 8017598:	e006      	b.n	80175a8 <rt_serial_write+0x74>
    }
    else
    {
        return _serial_poll_tx(serial, buffer, size);
 801759a:	683b      	ldr	r3, [r7, #0]
 801759c:	6978      	ldr	r0, [r7, #20]
 801759e:	6879      	ldr	r1, [r7, #4]
 80175a0:	461a      	mov	r2, r3
 80175a2:	f7ff fc15 	bl	8016dd0 <_serial_poll_tx>
 80175a6:	4603      	mov	r3, r0
    }
}
 80175a8:	4618      	mov	r0, r3
 80175aa:	3718      	adds	r7, #24
 80175ac:	46bd      	mov	sp, r7
 80175ae:	bd80      	pop	{r7, pc}
 80175b0:	08023690 	.word	0x08023690
 80175b4:	0802536c 	.word	0x0802536c

080175b8 <rt_serial_control>:

static rt_err_t rt_serial_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
 80175b8:	b580      	push	{r7, lr}
 80175ba:	b086      	sub	sp, #24
 80175bc:	af00      	add	r7, sp, #0
 80175be:	60f8      	str	r0, [r7, #12]
 80175c0:	460b      	mov	r3, r1
 80175c2:	607a      	str	r2, [r7, #4]
 80175c4:	72fb      	strb	r3, [r7, #11]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 80175c6:	68fb      	ldr	r3, [r7, #12]
 80175c8:	2b00      	cmp	r3, #0
 80175ca:	d105      	bne.n	80175d8 <rt_serial_control+0x20>
 80175cc:	481a      	ldr	r0, [pc, #104]	; (8017638 <rt_serial_control+0x80>)
 80175ce:	491b      	ldr	r1, [pc, #108]	; (801763c <rt_serial_control+0x84>)
 80175d0:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 80175d4:	f7fc fbc6 	bl	8013d64 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 80175d8:	68fb      	ldr	r3, [r7, #12]
 80175da:	617b      	str	r3, [r7, #20]

    switch (cmd)
 80175dc:	7afb      	ldrb	r3, [r7, #11]
 80175de:	2b02      	cmp	r3, #2
 80175e0:	d004      	beq.n	80175ec <rt_serial_control+0x34>
 80175e2:	2b03      	cmp	r3, #3
 80175e4:	d012      	beq.n	801760c <rt_serial_control+0x54>
 80175e6:	2b01      	cmp	r3, #1
 80175e8:	d008      	beq.n	80175fc <rt_serial_control+0x44>
 80175ea:	e016      	b.n	801761a <rt_serial_control+0x62>
    {
        case RT_DEVICE_CTRL_SUSPEND:
            /* suspend device */
            dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
 80175ec:	68fb      	ldr	r3, [r7, #12]
 80175ee:	8adb      	ldrh	r3, [r3, #22]
 80175f0:	f043 0320 	orr.w	r3, r3, #32
 80175f4:	b29a      	uxth	r2, r3
 80175f6:	68fb      	ldr	r3, [r7, #12]
 80175f8:	82da      	strh	r2, [r3, #22]
            break;
 80175fa:	e017      	b.n	801762c <rt_serial_control+0x74>

        case RT_DEVICE_CTRL_RESUME:
            /* resume device */
            dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
 80175fc:	68fb      	ldr	r3, [r7, #12]
 80175fe:	8adb      	ldrh	r3, [r3, #22]
 8017600:	f023 0320 	bic.w	r3, r3, #32
 8017604:	b29a      	uxth	r2, r3
 8017606:	68fb      	ldr	r3, [r7, #12]
 8017608:	82da      	strh	r2, [r3, #22]
            break;
 801760a:	e00f      	b.n	801762c <rt_serial_control+0x74>

        case RT_DEVICE_CTRL_CONFIG:
            /* configure device */
            serial->ops->configure(serial, (struct serial_configure *)args);
 801760c:	697b      	ldr	r3, [r7, #20]
 801760e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017610:	681b      	ldr	r3, [r3, #0]
 8017612:	6978      	ldr	r0, [r7, #20]
 8017614:	6879      	ldr	r1, [r7, #4]
 8017616:	4798      	blx	r3
            break;
 8017618:	e008      	b.n	801762c <rt_serial_control+0x74>

        default :
            /* control device */
            serial->ops->control(serial, cmd, args);
 801761a:	697b      	ldr	r3, [r7, #20]
 801761c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801761e:	685b      	ldr	r3, [r3, #4]
 8017620:	7afa      	ldrb	r2, [r7, #11]
 8017622:	6978      	ldr	r0, [r7, #20]
 8017624:	4611      	mov	r1, r2
 8017626:	687a      	ldr	r2, [r7, #4]
 8017628:	4798      	blx	r3
            break;
 801762a:	bf00      	nop
    }

    return RT_EOK;
 801762c:	2300      	movs	r3, #0
}
 801762e:	4618      	mov	r0, r3
 8017630:	3718      	adds	r7, #24
 8017632:	46bd      	mov	sp, r7
 8017634:	bd80      	pop	{r7, pc}
 8017636:	bf00      	nop
 8017638:	08023690 	.word	0x08023690
 801763c:	0802539c 	.word	0x0802539c

08017640 <rt_hw_serial_register>:
 */
rt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
 8017640:	b580      	push	{r7, lr}
 8017642:	b086      	sub	sp, #24
 8017644:	af00      	add	r7, sp, #0
 8017646:	60f8      	str	r0, [r7, #12]
 8017648:	60b9      	str	r1, [r7, #8]
 801764a:	607a      	str	r2, [r7, #4]
 801764c:	603b      	str	r3, [r7, #0]
    struct rt_device *device;
    RT_ASSERT(serial != RT_NULL);
 801764e:	68fb      	ldr	r3, [r7, #12]
 8017650:	2b00      	cmp	r3, #0
 8017652:	d105      	bne.n	8017660 <rt_hw_serial_register+0x20>
 8017654:	4818      	ldr	r0, [pc, #96]	; (80176b8 <rt_hw_serial_register+0x78>)
 8017656:	4919      	ldr	r1, [pc, #100]	; (80176bc <rt_hw_serial_register+0x7c>)
 8017658:	f44f 72f7 	mov.w	r2, #494	; 0x1ee
 801765c:	f7fc fb82 	bl	8013d64 <rt_assert_handler>

    device = &(serial->parent);
 8017660:	68fb      	ldr	r3, [r7, #12]
 8017662:	617b      	str	r3, [r7, #20]

    device->type        = RT_Device_Class_Char;
 8017664:	697b      	ldr	r3, [r7, #20]
 8017666:	2200      	movs	r2, #0
 8017668:	751a      	strb	r2, [r3, #20]
    device->rx_indicate = RT_NULL;
 801766a:	697b      	ldr	r3, [r7, #20]
 801766c:	2200      	movs	r2, #0
 801766e:	61da      	str	r2, [r3, #28]
    device->tx_complete = RT_NULL;
 8017670:	697b      	ldr	r3, [r7, #20]
 8017672:	2200      	movs	r2, #0
 8017674:	621a      	str	r2, [r3, #32]

    device->init        = rt_serial_init;
 8017676:	697b      	ldr	r3, [r7, #20]
 8017678:	4a11      	ldr	r2, [pc, #68]	; (80176c0 <rt_hw_serial_register+0x80>)
 801767a:	625a      	str	r2, [r3, #36]	; 0x24
    device->open        = rt_serial_open;
 801767c:	697b      	ldr	r3, [r7, #20]
 801767e:	4a11      	ldr	r2, [pc, #68]	; (80176c4 <rt_hw_serial_register+0x84>)
 8017680:	629a      	str	r2, [r3, #40]	; 0x28
    device->close       = rt_serial_close;
 8017682:	697b      	ldr	r3, [r7, #20]
 8017684:	4a10      	ldr	r2, [pc, #64]	; (80176c8 <rt_hw_serial_register+0x88>)
 8017686:	62da      	str	r2, [r3, #44]	; 0x2c
    device->read        = rt_serial_read;
 8017688:	697b      	ldr	r3, [r7, #20]
 801768a:	4a10      	ldr	r2, [pc, #64]	; (80176cc <rt_hw_serial_register+0x8c>)
 801768c:	631a      	str	r2, [r3, #48]	; 0x30
    device->write       = rt_serial_write;
 801768e:	697b      	ldr	r3, [r7, #20]
 8017690:	4a0f      	ldr	r2, [pc, #60]	; (80176d0 <rt_hw_serial_register+0x90>)
 8017692:	635a      	str	r2, [r3, #52]	; 0x34
    device->control     = rt_serial_control;
 8017694:	697b      	ldr	r3, [r7, #20]
 8017696:	4a0f      	ldr	r2, [pc, #60]	; (80176d4 <rt_hw_serial_register+0x94>)
 8017698:	639a      	str	r2, [r3, #56]	; 0x38
    device->user_data   = data;
 801769a:	697b      	ldr	r3, [r7, #20]
 801769c:	683a      	ldr	r2, [r7, #0]
 801769e:	63da      	str	r2, [r3, #60]	; 0x3c

    /* register a character device */
    return rt_device_register(device, name, flag);
 80176a0:	687b      	ldr	r3, [r7, #4]
 80176a2:	b29b      	uxth	r3, r3
 80176a4:	6978      	ldr	r0, [r7, #20]
 80176a6:	68b9      	ldr	r1, [r7, #8]
 80176a8:	461a      	mov	r2, r3
 80176aa:	f7fa fc2b 	bl	8011f04 <rt_device_register>
 80176ae:	4603      	mov	r3, r0
}
 80176b0:	4618      	mov	r0, r3
 80176b2:	3718      	adds	r7, #24
 80176b4:	46bd      	mov	sp, r7
 80176b6:	bd80      	pop	{r7, pc}
 80176b8:	08023618 	.word	0x08023618
 80176bc:	080253b0 	.word	0x080253b0
 80176c0:	08017091 	.word	0x08017091
 80176c4:	080170f9 	.word	0x080170f9
 80176c8:	08017349 	.word	0x08017349
 80176cc:	080174b1 	.word	0x080174b1
 80176d0:	08017535 	.word	0x08017535
 80176d4:	080175b9 	.word	0x080175b9

080176d8 <rt_hw_serial_isr>:

/* ISR for serial interrupt */
void rt_hw_serial_isr(struct rt_serial_device *serial, int event)
{
 80176d8:	b590      	push	{r4, r7, lr}
 80176da:	b08f      	sub	sp, #60	; 0x3c
 80176dc:	af00      	add	r7, sp, #0
 80176de:	6078      	str	r0, [r7, #4]
 80176e0:	6039      	str	r1, [r7, #0]
    switch (event & 0xff)
 80176e2:	683b      	ldr	r3, [r7, #0]
 80176e4:	b2db      	uxtb	r3, r3
 80176e6:	3b01      	subs	r3, #1
 80176e8:	2b03      	cmp	r3, #3
 80176ea:	f200 80ec 	bhi.w	80178c6 <rt_hw_serial_isr+0x1ee>
 80176ee:	a201      	add	r2, pc, #4	; (adr r2, 80176f4 <rt_hw_serial_isr+0x1c>)
 80176f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80176f4:	08017705 	.word	0x08017705
 80176f8:	0801781f 	.word	0x0801781f
 80176fc:	080178a5 	.word	0x080178a5
 8017700:	0801782f 	.word	0x0801782f
    {
        case RT_SERIAL_EVENT_RX_IND:
        {
            int ch = -1;
 8017704:	f04f 33ff 	mov.w	r3, #4294967295
 8017708:	637b      	str	r3, [r7, #52]	; 0x34
            rt_base_t level;
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
 801770a:	687b      	ldr	r3, [r7, #4]
 801770c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801770e:	633b      	str	r3, [r7, #48]	; 0x30
            RT_ASSERT(rx_fifo != RT_NULL);
 8017710:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017712:	2b00      	cmp	r3, #0
 8017714:	d105      	bne.n	8017722 <rt_hw_serial_isr+0x4a>
 8017716:	486d      	ldr	r0, [pc, #436]	; (80178cc <rt_hw_serial_isr+0x1f4>)
 8017718:	496d      	ldr	r1, [pc, #436]	; (80178d0 <rt_hw_serial_isr+0x1f8>)
 801771a:	f240 220e 	movw	r2, #526	; 0x20e
 801771e:	f7fc fb21 	bl	8013d64 <rt_assert_handler>
            
            /* interrupt mode receive */
            RT_ASSERT(serial->parent.open_flag & RT_DEVICE_FLAG_INT_RX);
 8017722:	687b      	ldr	r3, [r7, #4]
 8017724:	8b1b      	ldrh	r3, [r3, #24]
 8017726:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801772a:	2b00      	cmp	r3, #0
 801772c:	d105      	bne.n	801773a <rt_hw_serial_isr+0x62>
 801772e:	4869      	ldr	r0, [pc, #420]	; (80178d4 <rt_hw_serial_isr+0x1fc>)
 8017730:	4967      	ldr	r1, [pc, #412]	; (80178d0 <rt_hw_serial_isr+0x1f8>)
 8017732:	f240 2211 	movw	r2, #529	; 0x211
 8017736:	f7fc fb15 	bl	8013d64 <rt_assert_handler>
            
            while (1)
            {
                ch = serial->ops->getc(serial);
 801773a:	687b      	ldr	r3, [r7, #4]
 801773c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801773e:	68db      	ldr	r3, [r3, #12]
 8017740:	6878      	ldr	r0, [r7, #4]
 8017742:	4798      	blx	r3
 8017744:	6378      	str	r0, [r7, #52]	; 0x34
                if (ch == -1) break;
 8017746:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017748:	f1b3 3fff 	cmp.w	r3, #4294967295
 801774c:	d105      	bne.n	801775a <rt_hw_serial_isr+0x82>
 801774e:	bf00      	nop
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
            }
            
            /* invoke callback */
            if (serial->parent.rx_indicate != RT_NULL)
 8017750:	687b      	ldr	r3, [r7, #4]
 8017752:	69db      	ldr	r3, [r3, #28]
 8017754:	2b00      	cmp	r3, #0
 8017756:	d061      	beq.n	801781c <rt_hw_serial_isr+0x144>
 8017758:	e038      	b.n	80177cc <rt_hw_serial_isr+0xf4>
            {
                ch = serial->ops->getc(serial);
                if (ch == -1) break;
                
                /* disable interrupt */
                level = rt_hw_interrupt_disable();
 801775a:	f7e8 fd35 	bl	80001c8 <rt_hw_interrupt_disable>
 801775e:	62f8      	str	r0, [r7, #44]	; 0x2c
                
                rx_fifo->buffer[rx_fifo->put_index] = ch;
 8017760:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017762:	681b      	ldr	r3, [r3, #0]
 8017764:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8017766:	8892      	ldrh	r2, [r2, #4]
 8017768:	4413      	add	r3, r2
 801776a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801776c:	b2d2      	uxtb	r2, r2
 801776e:	701a      	strb	r2, [r3, #0]
                rx_fifo->put_index += 1;
 8017770:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017772:	889b      	ldrh	r3, [r3, #4]
 8017774:	3301      	adds	r3, #1
 8017776:	b29a      	uxth	r2, r3
 8017778:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801777a:	809a      	strh	r2, [r3, #4]
                if (rx_fifo->put_index >= serial->config.bufsz) rx_fifo->put_index = 0;
 801777c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801777e:	889a      	ldrh	r2, [r3, #4]
 8017780:	687b      	ldr	r3, [r7, #4]
 8017782:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8017784:	f3c3 238f 	ubfx	r3, r3, #10, #16
 8017788:	b29b      	uxth	r3, r3
 801778a:	429a      	cmp	r2, r3
 801778c:	d302      	bcc.n	8017794 <rt_hw_serial_isr+0xbc>
 801778e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017790:	2200      	movs	r2, #0
 8017792:	809a      	strh	r2, [r3, #4]
                
                /* if the next position is read index, discard this 'read char' */
                if (rx_fifo->put_index == rx_fifo->get_index)
 8017794:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017796:	889a      	ldrh	r2, [r3, #4]
 8017798:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801779a:	88db      	ldrh	r3, [r3, #6]
 801779c:	429a      	cmp	r2, r3
 801779e:	d111      	bne.n	80177c4 <rt_hw_serial_isr+0xec>
                {
                    rx_fifo->get_index += 1;
 80177a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177a2:	88db      	ldrh	r3, [r3, #6]
 80177a4:	3301      	adds	r3, #1
 80177a6:	b29a      	uxth	r2, r3
 80177a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177aa:	80da      	strh	r2, [r3, #6]
                    if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
 80177ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177ae:	88da      	ldrh	r2, [r3, #6]
 80177b0:	687b      	ldr	r3, [r7, #4]
 80177b2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80177b4:	f3c3 238f 	ubfx	r3, r3, #10, #16
 80177b8:	b29b      	uxth	r3, r3
 80177ba:	429a      	cmp	r2, r3
 80177bc:	d302      	bcc.n	80177c4 <rt_hw_serial_isr+0xec>
 80177be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177c0:	2200      	movs	r2, #0
 80177c2:	80da      	strh	r2, [r3, #6]
                }
                
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
 80177c4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80177c6:	f7e8 fd03 	bl	80001d0 <rt_hw_interrupt_enable>
            }
 80177ca:	e7b6      	b.n	801773a <rt_hw_serial_isr+0x62>
            if (serial->parent.rx_indicate != RT_NULL)
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
 80177cc:	f7e8 fcfc 	bl	80001c8 <rt_hw_interrupt_disable>
 80177d0:	62f8      	str	r0, [r7, #44]	; 0x2c
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
 80177d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177d4:	889a      	ldrh	r2, [r3, #4]
 80177d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177d8:	88db      	ldrh	r3, [r3, #6]
 80177da:	429a      	cmp	r2, r3
 80177dc:	d306      	bcc.n	80177ec <rt_hw_serial_isr+0x114>
 80177de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177e0:	889b      	ldrh	r3, [r3, #4]
 80177e2:	461a      	mov	r2, r3
 80177e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177e6:	88db      	ldrh	r3, [r3, #6]
 80177e8:	1ad3      	subs	r3, r2, r3
 80177ea:	e00c      	b.n	8017806 <rt_hw_serial_isr+0x12e>
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
 80177ec:	687b      	ldr	r3, [r7, #4]
 80177ee:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80177f0:	f3c3 238f 	ubfx	r3, r3, #10, #16
 80177f4:	b29b      	uxth	r3, r3
 80177f6:	461a      	mov	r2, r3
 80177f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80177fa:	889b      	ldrh	r3, [r3, #4]
 80177fc:	4619      	mov	r1, r3
 80177fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017800:	88db      	ldrh	r3, [r3, #6]
 8017802:	1acb      	subs	r3, r1, r3
 8017804:	4413      	add	r3, r2
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
 8017806:	62bb      	str	r3, [r7, #40]	; 0x28
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
                rt_hw_interrupt_enable(level);
 8017808:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801780a:	f7e8 fce1 	bl	80001d0 <rt_hw_interrupt_enable>

                serial->parent.rx_indicate(&serial->parent, rx_length);
 801780e:	687b      	ldr	r3, [r7, #4]
 8017810:	69db      	ldr	r3, [r3, #28]
 8017812:	687a      	ldr	r2, [r7, #4]
 8017814:	4610      	mov	r0, r2
 8017816:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8017818:	4798      	blx	r3
            }
            break;
 801781a:	e054      	b.n	80178c6 <rt_hw_serial_isr+0x1ee>
 801781c:	e053      	b.n	80178c6 <rt_hw_serial_isr+0x1ee>
        }
        case RT_SERIAL_EVENT_TX_DONE:
        {
            struct rt_serial_tx_fifo* tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
 801781e:	687b      	ldr	r3, [r7, #4]
 8017820:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8017822:	627b      	str	r3, [r7, #36]	; 0x24
            rt_completion_done(&(tx_fifo->completion));
 8017824:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017826:	4618      	mov	r0, r3
 8017828:	f7fe fc94 	bl	8016154 <rt_completion_done>
            break;
 801782c:	e04b      	b.n	80178c6 <rt_hw_serial_isr+0x1ee>
            const void *data_ptr;
            rt_size_t data_size;
            const void *last_data_ptr;
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) serial->serial_tx;
 801782e:	687b      	ldr	r3, [r7, #4]
 8017830:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8017832:	623b      	str	r3, [r7, #32]
            
            rt_data_queue_pop(&(tx_dma->data_queue), &last_data_ptr, &data_size, 0);
 8017834:	6a3b      	ldr	r3, [r7, #32]
 8017836:	1d19      	adds	r1, r3, #4
 8017838:	f107 020c 	add.w	r2, r7, #12
 801783c:	f107 0310 	add.w	r3, r7, #16
 8017840:	4608      	mov	r0, r1
 8017842:	4611      	mov	r1, r2
 8017844:	461a      	mov	r2, r3
 8017846:	2300      	movs	r3, #0
 8017848:	f7fe fe00 	bl	801644c <rt_data_queue_pop>
            if (rt_data_queue_peak(&(tx_dma->data_queue), &data_ptr, &data_size) == RT_EOK)
 801784c:	6a3b      	ldr	r3, [r7, #32]
 801784e:	1d19      	adds	r1, r3, #4
 8017850:	f107 0214 	add.w	r2, r7, #20
 8017854:	f107 0310 	add.w	r3, r7, #16
 8017858:	4608      	mov	r0, r1
 801785a:	4611      	mov	r1, r2
 801785c:	461a      	mov	r2, r3
 801785e:	f7fe fee5 	bl	801662c <rt_data_queue_peak>
 8017862:	4603      	mov	r3, r0
 8017864:	2b00      	cmp	r3, #0
 8017866:	d10d      	bne.n	8017884 <rt_hw_serial_isr+0x1ac>
            {
                /* transmit next data node */
                tx_dma->activated = RT_TRUE;
 8017868:	6a3b      	ldr	r3, [r7, #32]
 801786a:	2201      	movs	r2, #1
 801786c:	601a      	str	r2, [r3, #0]
                serial->ops->dma_transmit(serial, data_ptr, data_size, RT_SERIAL_DMA_TX);
 801786e:	687b      	ldr	r3, [r7, #4]
 8017870:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017872:	691c      	ldr	r4, [r3, #16]
 8017874:	697a      	ldr	r2, [r7, #20]
 8017876:	693b      	ldr	r3, [r7, #16]
 8017878:	6878      	ldr	r0, [r7, #4]
 801787a:	4611      	mov	r1, r2
 801787c:	461a      	mov	r2, r3
 801787e:	2302      	movs	r3, #2
 8017880:	47a0      	blx	r4
 8017882:	e002      	b.n	801788a <rt_hw_serial_isr+0x1b2>
            }
            else
            {
                tx_dma->activated = RT_FALSE;
 8017884:	6a3b      	ldr	r3, [r7, #32]
 8017886:	2200      	movs	r2, #0
 8017888:	601a      	str	r2, [r3, #0]
            }
            
            /* invoke callback */
            if (serial->parent.tx_complete != RT_NULL)
 801788a:	687b      	ldr	r3, [r7, #4]
 801788c:	6a1b      	ldr	r3, [r3, #32]
 801788e:	2b00      	cmp	r3, #0
 8017890:	d006      	beq.n	80178a0 <rt_hw_serial_isr+0x1c8>
            {
                serial->parent.tx_complete(&serial->parent, (void*)last_data_ptr);
 8017892:	687b      	ldr	r3, [r7, #4]
 8017894:	6a1b      	ldr	r3, [r3, #32]
 8017896:	6879      	ldr	r1, [r7, #4]
 8017898:	68fa      	ldr	r2, [r7, #12]
 801789a:	4608      	mov	r0, r1
 801789c:	4611      	mov	r1, r2
 801789e:	4798      	blx	r3
            }
            break;
 80178a0:	bf00      	nop
 80178a2:	e010      	b.n	80178c6 <rt_hw_serial_isr+0x1ee>
        case RT_SERIAL_EVENT_RX_DMADONE:
        {
            int length;
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
 80178a4:	687b      	ldr	r3, [r7, #4]
 80178a6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80178a8:	61fb      	str	r3, [r7, #28]
            /* get DMA rx length */
            length = (event & (~0xff)) >> 8;
 80178aa:	683b      	ldr	r3, [r7, #0]
 80178ac:	121b      	asrs	r3, r3, #8
 80178ae:	61bb      	str	r3, [r7, #24]
            serial->parent.rx_indicate(&(serial->parent), length);
 80178b0:	687b      	ldr	r3, [r7, #4]
 80178b2:	69db      	ldr	r3, [r3, #28]
 80178b4:	6879      	ldr	r1, [r7, #4]
 80178b6:	69ba      	ldr	r2, [r7, #24]
 80178b8:	4608      	mov	r0, r1
 80178ba:	4611      	mov	r1, r2
 80178bc:	4798      	blx	r3
            rx_dma->activated = RT_FALSE;
 80178be:	69fb      	ldr	r3, [r7, #28]
 80178c0:	2200      	movs	r2, #0
 80178c2:	601a      	str	r2, [r3, #0]
            break;
 80178c4:	bf00      	nop
        }
    }
}
 80178c6:	373c      	adds	r7, #60	; 0x3c
 80178c8:	46bd      	mov	sp, r7
 80178ca:	bd90      	pop	{r4, r7, pc}
 80178cc:	0802362c 	.word	0x0802362c
 80178d0:	080253c8 	.word	0x080253c8
 80178d4:	080236d0 	.word	0x080236d0

080178d8 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 80178d8:	b480      	push	{r7}
 80178da:	b083      	sub	sp, #12
 80178dc:	af00      	add	r7, sp, #0
 80178de:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 80178e0:	687b      	ldr	r3, [r7, #4]
 80178e2:	687a      	ldr	r2, [r7, #4]
 80178e4:	605a      	str	r2, [r3, #4]
 80178e6:	687b      	ldr	r3, [r7, #4]
 80178e8:	685a      	ldr	r2, [r3, #4]
 80178ea:	687b      	ldr	r3, [r7, #4]
 80178ec:	601a      	str	r2, [r3, #0]
}
 80178ee:	370c      	adds	r7, #12
 80178f0:	46bd      	mov	sp, r7
 80178f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80178f6:	4770      	bx	lr

080178f8 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 80178f8:	b480      	push	{r7}
 80178fa:	b083      	sub	sp, #12
 80178fc:	af00      	add	r7, sp, #0
 80178fe:	6078      	str	r0, [r7, #4]
 8017900:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 8017902:	687b      	ldr	r3, [r7, #4]
 8017904:	681b      	ldr	r3, [r3, #0]
 8017906:	683a      	ldr	r2, [r7, #0]
 8017908:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 801790a:	687b      	ldr	r3, [r7, #4]
 801790c:	681a      	ldr	r2, [r3, #0]
 801790e:	683b      	ldr	r3, [r7, #0]
 8017910:	601a      	str	r2, [r3, #0]

    l->next = n;
 8017912:	687b      	ldr	r3, [r7, #4]
 8017914:	683a      	ldr	r2, [r7, #0]
 8017916:	601a      	str	r2, [r3, #0]
    n->prev = l;
 8017918:	683b      	ldr	r3, [r7, #0]
 801791a:	687a      	ldr	r2, [r7, #4]
 801791c:	605a      	str	r2, [r3, #4]
}
 801791e:	370c      	adds	r7, #12
 8017920:	46bd      	mov	sp, r7
 8017922:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017926:	4770      	bx	lr

08017928 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8017928:	b480      	push	{r7}
 801792a:	b083      	sub	sp, #12
 801792c:	af00      	add	r7, sp, #0
 801792e:	6078      	str	r0, [r7, #4]
 8017930:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 8017932:	687b      	ldr	r3, [r7, #4]
 8017934:	685b      	ldr	r3, [r3, #4]
 8017936:	683a      	ldr	r2, [r7, #0]
 8017938:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 801793a:	687b      	ldr	r3, [r7, #4]
 801793c:	685a      	ldr	r2, [r3, #4]
 801793e:	683b      	ldr	r3, [r7, #0]
 8017940:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8017942:	687b      	ldr	r3, [r7, #4]
 8017944:	683a      	ldr	r2, [r7, #0]
 8017946:	605a      	str	r2, [r3, #4]
    n->next = l;
 8017948:	683b      	ldr	r3, [r7, #0]
 801794a:	687a      	ldr	r2, [r7, #4]
 801794c:	601a      	str	r2, [r3, #0]
}
 801794e:	370c      	adds	r7, #12
 8017950:	46bd      	mov	sp, r7
 8017952:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017956:	4770      	bx	lr

08017958 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8017958:	b480      	push	{r7}
 801795a:	b083      	sub	sp, #12
 801795c:	af00      	add	r7, sp, #0
 801795e:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8017960:	687b      	ldr	r3, [r7, #4]
 8017962:	681b      	ldr	r3, [r3, #0]
 8017964:	687a      	ldr	r2, [r7, #4]
 8017966:	6852      	ldr	r2, [r2, #4]
 8017968:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 801796a:	687b      	ldr	r3, [r7, #4]
 801796c:	685b      	ldr	r3, [r3, #4]
 801796e:	687a      	ldr	r2, [r7, #4]
 8017970:	6812      	ldr	r2, [r2, #0]
 8017972:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8017974:	687b      	ldr	r3, [r7, #4]
 8017976:	687a      	ldr	r2, [r7, #4]
 8017978:	605a      	str	r2, [r3, #4]
 801797a:	687b      	ldr	r3, [r7, #4]
 801797c:	685a      	ldr	r2, [r3, #4]
 801797e:	687b      	ldr	r3, [r7, #4]
 8017980:	601a      	str	r2, [r3, #0]
}
 8017982:	370c      	adds	r7, #12
 8017984:	46bd      	mov	sp, r7
 8017986:	f85d 7b04 	ldr.w	r7, [sp], #4
 801798a:	4770      	bx	lr

0801798c <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 801798c:	b480      	push	{r7}
 801798e:	b083      	sub	sp, #12
 8017990:	af00      	add	r7, sp, #0
 8017992:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8017994:	687b      	ldr	r3, [r7, #4]
 8017996:	681a      	ldr	r2, [r3, #0]
 8017998:	687b      	ldr	r3, [r7, #4]
 801799a:	429a      	cmp	r2, r3
 801799c:	bf0c      	ite	eq
 801799e:	2301      	moveq	r3, #1
 80179a0:	2300      	movne	r3, #0
 80179a2:	b2db      	uxtb	r3, r3
}
 80179a4:	4618      	mov	r0, r3
 80179a6:	370c      	adds	r7, #12
 80179a8:	46bd      	mov	sp, r7
 80179aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179ae:	4770      	bx	lr

080179b0 <rt_can_init>:

#define CAN_LOCK(can)   rt_mutex_take(&(can->lock), RT_WAITING_FOREVER)
#define CAN_UNLOCK(can) rt_mutex_release(&(can->lock))

static rt_err_t rt_can_init(struct rt_device *dev)
{
 80179b0:	b580      	push	{r7, lr}
 80179b2:	b084      	sub	sp, #16
 80179b4:	af00      	add	r7, sp, #0
 80179b6:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 80179b8:	2300      	movs	r3, #0
 80179ba:	60fb      	str	r3, [r7, #12]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 80179bc:	687b      	ldr	r3, [r7, #4]
 80179be:	2b00      	cmp	r3, #0
 80179c0:	d104      	bne.n	80179cc <rt_can_init+0x1c>
 80179c2:	4811      	ldr	r0, [pc, #68]	; (8017a08 <rt_can_init+0x58>)
 80179c4:	4911      	ldr	r1, [pc, #68]	; (8017a0c <rt_can_init+0x5c>)
 80179c6:	2226      	movs	r2, #38	; 0x26
 80179c8:	f7fc f9cc 	bl	8013d64 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 80179cc:	687b      	ldr	r3, [r7, #4]
 80179ce:	60bb      	str	r3, [r7, #8]

    /* initialize rx/tx */
    can->can_rx = RT_NULL;
 80179d0:	68bb      	ldr	r3, [r7, #8]
 80179d2:	2200      	movs	r2, #0
 80179d4:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    can->can_tx = RT_NULL;
 80179d8:	68bb      	ldr	r3, [r7, #8]
 80179da:	2200      	movs	r2, #0
 80179dc:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

    /* apply configuration */
    if (can->ops->configure)
 80179e0:	68bb      	ldr	r3, [r7, #8]
 80179e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80179e4:	681b      	ldr	r3, [r3, #0]
 80179e6:	2b00      	cmp	r3, #0
 80179e8:	d008      	beq.n	80179fc <rt_can_init+0x4c>
        result = can->ops->configure(can, &can->config);
 80179ea:	68bb      	ldr	r3, [r7, #8]
 80179ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80179ee:	681b      	ldr	r3, [r3, #0]
 80179f0:	68ba      	ldr	r2, [r7, #8]
 80179f2:	3244      	adds	r2, #68	; 0x44
 80179f4:	68b8      	ldr	r0, [r7, #8]
 80179f6:	4611      	mov	r1, r2
 80179f8:	4798      	blx	r3
 80179fa:	60f8      	str	r0, [r7, #12]

    return result;
 80179fc:	68fb      	ldr	r3, [r7, #12]
}
 80179fe:	4618      	mov	r0, r3
 8017a00:	3710      	adds	r7, #16
 8017a02:	46bd      	mov	sp, r7
 8017a04:	bd80      	pop	{r7, pc}
 8017a06:	bf00      	nop
 8017a08:	08023704 	.word	0x08023704
 8017a0c:	08025404 	.word	0x08025404

08017a10 <_can_int_rx>:

/*
 * can interrupt routines
 */
rt_inline int _can_int_rx(struct rt_can_device *can, struct rt_can_msg *data, int msgs)
{
 8017a10:	b580      	push	{r7, lr}
 8017a12:	b088      	sub	sp, #32
 8017a14:	af00      	add	r7, sp, #0
 8017a16:	60f8      	str	r0, [r7, #12]
 8017a18:	60b9      	str	r1, [r7, #8]
 8017a1a:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_can_rx_fifo *rx_fifo;
    RT_ASSERT(can != RT_NULL);
 8017a1c:	68fb      	ldr	r3, [r7, #12]
 8017a1e:	2b00      	cmp	r3, #0
 8017a20:	d104      	bne.n	8017a2c <_can_int_rx+0x1c>
 8017a22:	4836      	ldr	r0, [pc, #216]	; (8017afc <_can_int_rx+0xec>)
 8017a24:	4936      	ldr	r1, [pc, #216]	; (8017b00 <_can_int_rx+0xf0>)
 8017a26:	223b      	movs	r2, #59	; 0x3b
 8017a28:	f7fc f99c 	bl	8013d64 <rt_assert_handler>
    size = msgs;
 8017a2c:	687b      	ldr	r3, [r7, #4]
 8017a2e:	61fb      	str	r3, [r7, #28]

    rx_fifo = (struct rt_can_rx_fifo *) can->can_rx;
 8017a30:	68fb      	ldr	r3, [r7, #12]
 8017a32:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8017a36:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_fifo != RT_NULL);
 8017a38:	69bb      	ldr	r3, [r7, #24]
 8017a3a:	2b00      	cmp	r3, #0
 8017a3c:	d104      	bne.n	8017a48 <_can_int_rx+0x38>
 8017a3e:	4831      	ldr	r0, [pc, #196]	; (8017b04 <_can_int_rx+0xf4>)
 8017a40:	492f      	ldr	r1, [pc, #188]	; (8017b00 <_can_int_rx+0xf0>)
 8017a42:	223f      	movs	r2, #63	; 0x3f
 8017a44:	f7fc f98e 	bl	8013d64 <rt_assert_handler>

    /* read from software FIFO */
    while (msgs)
 8017a48:	e04d      	b.n	8017ae6 <_can_int_rx+0xd6>
    {
        rt_base_t level;
#ifdef RT_CAN_USING_HDR
        rt_int32_t hdr;
#endif /*RT_CAN_USING_HDR*/
        struct rt_can_msg_list *listmsg = RT_NULL;
 8017a4a:	2300      	movs	r3, #0
 8017a4c:	617b      	str	r3, [r7, #20]

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
 8017a4e:	f7e8 fbbb 	bl	80001c8 <rt_hw_interrupt_disable>
 8017a52:	6138      	str	r0, [r7, #16]
            listmsg->owner = RT_NULL;
        }
        else if (hdr == -1)
#endif /*RT_CAN_USING_HDR*/
        {
            if (!rt_list_isempty(&rx_fifo->uselist))
 8017a54:	69bb      	ldr	r3, [r7, #24]
 8017a56:	3310      	adds	r3, #16
 8017a58:	4618      	mov	r0, r3
 8017a5a:	f7ff ff97 	bl	801798c <rt_list_isempty>
 8017a5e:	4603      	mov	r3, r0
 8017a60:	2b00      	cmp	r3, #0
 8017a62:	d10d      	bne.n	8017a80 <_can_int_rx+0x70>
            {
                listmsg = rt_list_entry(rx_fifo->uselist.next, struct rt_can_msg_list, list);
 8017a64:	69bb      	ldr	r3, [r7, #24]
 8017a66:	691b      	ldr	r3, [r3, #16]
 8017a68:	617b      	str	r3, [r7, #20]
                rt_list_remove(&listmsg->list);
 8017a6a:	697b      	ldr	r3, [r7, #20]
 8017a6c:	4618      	mov	r0, r3
 8017a6e:	f7ff ff73 	bl	8017958 <rt_list_remove>
                break;
            }
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8017a72:	6938      	ldr	r0, [r7, #16]
 8017a74:	f7e8 fbac 	bl	80001d0 <rt_hw_interrupt_enable>
        if (listmsg != RT_NULL)
 8017a78:	697b      	ldr	r3, [r7, #20]
 8017a7a:	2b00      	cmp	r3, #0
 8017a7c:	d02c      	beq.n	8017ad8 <_can_int_rx+0xc8>
 8017a7e:	e003      	b.n	8017a88 <_can_int_rx+0x78>
#endif /*RT_CAN_USING_HDR*/
            }
            else
            {
                /* no data, enable interrupt and break out */
                rt_hw_interrupt_enable(level);
 8017a80:	6938      	ldr	r0, [r7, #16]
 8017a82:	f7e8 fba5 	bl	80001d0 <rt_hw_interrupt_enable>
                break;
 8017a86:	e031      	b.n	8017aec <_can_int_rx+0xdc>

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
        if (listmsg != RT_NULL)
        {
            rt_memcpy(data, &listmsg->data, sizeof(struct rt_can_msg));
 8017a88:	697b      	ldr	r3, [r7, #20]
 8017a8a:	3308      	adds	r3, #8
 8017a8c:	68b8      	ldr	r0, [r7, #8]
 8017a8e:	4619      	mov	r1, r3
 8017a90:	2210      	movs	r2, #16
 8017a92:	f7fb fb91 	bl	80131b8 <rt_memcpy>

            level = rt_hw_interrupt_disable();
 8017a96:	f7e8 fb97 	bl	80001c8 <rt_hw_interrupt_disable>
 8017a9a:	6138      	str	r0, [r7, #16]
            rt_list_insert_before(&rx_fifo->freelist, &listmsg->list);
 8017a9c:	69bb      	ldr	r3, [r7, #24]
 8017a9e:	f103 0208 	add.w	r2, r3, #8
 8017aa2:	697b      	ldr	r3, [r7, #20]
 8017aa4:	4610      	mov	r0, r2
 8017aa6:	4619      	mov	r1, r3
 8017aa8:	f7ff ff3e 	bl	8017928 <rt_list_insert_before>
            rx_fifo->freenumbers++;
 8017aac:	69bb      	ldr	r3, [r7, #24]
 8017aae:	685b      	ldr	r3, [r3, #4]
 8017ab0:	1c5a      	adds	r2, r3, #1
 8017ab2:	69bb      	ldr	r3, [r7, #24]
 8017ab4:	605a      	str	r2, [r3, #4]
            RT_ASSERT(rx_fifo->freenumbers <= can->config.msgboxsz);
 8017ab6:	69bb      	ldr	r3, [r7, #24]
 8017ab8:	685a      	ldr	r2, [r3, #4]
 8017aba:	68fb      	ldr	r3, [r7, #12]
 8017abc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8017abe:	429a      	cmp	r2, r3
 8017ac0:	d904      	bls.n	8017acc <_can_int_rx+0xbc>
 8017ac2:	4811      	ldr	r0, [pc, #68]	; (8017b08 <_can_int_rx+0xf8>)
 8017ac4:	490e      	ldr	r1, [pc, #56]	; (8017b00 <_can_int_rx+0xf0>)
 8017ac6:	227b      	movs	r2, #123	; 0x7b
 8017ac8:	f7fc f94c 	bl	8013d64 <rt_assert_handler>
            rt_hw_interrupt_enable(level);
 8017acc:	6938      	ldr	r0, [r7, #16]
 8017ace:	f7e8 fb7f 	bl	80001d0 <rt_hw_interrupt_enable>

            listmsg = RT_NULL;
 8017ad2:	2300      	movs	r3, #0
 8017ad4:	617b      	str	r3, [r7, #20]
 8017ad6:	e000      	b.n	8017ada <_can_int_rx+0xca>
        }
        else
        {
            break;
 8017ad8:	e008      	b.n	8017aec <_can_int_rx+0xdc>
        }
        data ++;
 8017ada:	68bb      	ldr	r3, [r7, #8]
 8017adc:	3310      	adds	r3, #16
 8017ade:	60bb      	str	r3, [r7, #8]
        msgs -= sizeof(struct rt_can_msg);
 8017ae0:	687b      	ldr	r3, [r7, #4]
 8017ae2:	3b10      	subs	r3, #16
 8017ae4:	607b      	str	r3, [r7, #4]

    rx_fifo = (struct rt_can_rx_fifo *) can->can_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (msgs)
 8017ae6:	687b      	ldr	r3, [r7, #4]
 8017ae8:	2b00      	cmp	r3, #0
 8017aea:	d1ae      	bne.n	8017a4a <_can_int_rx+0x3a>
        }
        data ++;
        msgs -= sizeof(struct rt_can_msg);
    }

    return (size - msgs);
 8017aec:	69fa      	ldr	r2, [r7, #28]
 8017aee:	687b      	ldr	r3, [r7, #4]
 8017af0:	1ad3      	subs	r3, r2, r3
}
 8017af2:	4618      	mov	r0, r3
 8017af4:	3720      	adds	r7, #32
 8017af6:	46bd      	mov	sp, r7
 8017af8:	bd80      	pop	{r7, pc}
 8017afa:	bf00      	nop
 8017afc:	08023714 	.word	0x08023714
 8017b00:	08025438 	.word	0x08025438
 8017b04:	08023724 	.word	0x08023724
 8017b08:	08023738 	.word	0x08023738

08017b0c <_can_int_tx>:

rt_inline int _can_int_tx(struct rt_can_device *can, const struct rt_can_msg *data, int msgs)
{
 8017b0c:	b580      	push	{r7, lr}
 8017b0e:	b08a      	sub	sp, #40	; 0x28
 8017b10:	af00      	add	r7, sp, #0
 8017b12:	60f8      	str	r0, [r7, #12]
 8017b14:	60b9      	str	r1, [r7, #8]
 8017b16:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_can_tx_fifo *tx_fifo;

    RT_ASSERT(can != RT_NULL);
 8017b18:	68fb      	ldr	r3, [r7, #12]
 8017b1a:	2b00      	cmp	r3, #0
 8017b1c:	d104      	bne.n	8017b28 <_can_int_tx+0x1c>
 8017b1e:	485f      	ldr	r0, [pc, #380]	; (8017c9c <_can_int_tx+0x190>)
 8017b20:	495f      	ldr	r1, [pc, #380]	; (8017ca0 <_can_int_tx+0x194>)
 8017b22:	2290      	movs	r2, #144	; 0x90
 8017b24:	f7fc f91e 	bl	8013d64 <rt_assert_handler>

    size = msgs;
 8017b28:	687b      	ldr	r3, [r7, #4]
 8017b2a:	627b      	str	r3, [r7, #36]	; 0x24
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 8017b2c:	68fb      	ldr	r3, [r7, #12]
 8017b2e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8017b32:	623b      	str	r3, [r7, #32]
    RT_ASSERT(tx_fifo != RT_NULL);
 8017b34:	6a3b      	ldr	r3, [r7, #32]
 8017b36:	2b00      	cmp	r3, #0
 8017b38:	d104      	bne.n	8017b44 <_can_int_tx+0x38>
 8017b3a:	485a      	ldr	r0, [pc, #360]	; (8017ca4 <_can_int_tx+0x198>)
 8017b3c:	4958      	ldr	r1, [pc, #352]	; (8017ca0 <_can_int_tx+0x194>)
 8017b3e:	2294      	movs	r2, #148	; 0x94
 8017b40:	f7fc f910 	bl	8013d64 <rt_assert_handler>

    while (msgs)
 8017b44:	e09f      	b.n	8017c86 <_can_int_tx+0x17a>
    {
        rt_base_t level;
        rt_uint32_t no;
        rt_uint32_t result;
        struct rt_can_sndbxinx_list *tx_tosnd = RT_NULL;
 8017b46:	2300      	movs	r3, #0
 8017b48:	61fb      	str	r3, [r7, #28]

        level = rt_hw_interrupt_disable();
 8017b4a:	f7e8 fb3d 	bl	80001c8 <rt_hw_interrupt_disable>
 8017b4e:	61b8      	str	r0, [r7, #24]
        if (!rt_list_isempty(&tx_fifo->freelist))
 8017b50:	6a3b      	ldr	r3, [r7, #32]
 8017b52:	3310      	adds	r3, #16
 8017b54:	4618      	mov	r0, r3
 8017b56:	f7ff ff19 	bl	801798c <rt_list_isempty>
 8017b5a:	4603      	mov	r3, r0
 8017b5c:	2b00      	cmp	r3, #0
 8017b5e:	d128      	bne.n	8017bb2 <_can_int_tx+0xa6>
        {
            tx_tosnd = rt_list_entry(tx_fifo->freelist.next, struct rt_can_sndbxinx_list, list);
 8017b60:	6a3b      	ldr	r3, [r7, #32]
 8017b62:	691b      	ldr	r3, [r3, #16]
 8017b64:	61fb      	str	r3, [r7, #28]
            RT_ASSERT(tx_tosnd != RT_NULL);
 8017b66:	69fb      	ldr	r3, [r7, #28]
 8017b68:	2b00      	cmp	r3, #0
 8017b6a:	d104      	bne.n	8017b76 <_can_int_tx+0x6a>
 8017b6c:	484e      	ldr	r0, [pc, #312]	; (8017ca8 <_can_int_tx+0x19c>)
 8017b6e:	494c      	ldr	r1, [pc, #304]	; (8017ca0 <_can_int_tx+0x194>)
 8017b70:	22a1      	movs	r2, #161	; 0xa1
 8017b72:	f7fc f8f7 	bl	8013d64 <rt_assert_handler>
            rt_list_remove(&tx_tosnd->list);
 8017b76:	69fb      	ldr	r3, [r7, #28]
 8017b78:	4618      	mov	r0, r3
 8017b7a:	f7ff feed 	bl	8017958 <rt_list_remove>
            rt_hw_interrupt_enable(level);

            rt_completion_wait(&(tx_fifo->completion), RT_WAITING_FOREVER);
            continue;
        }
        rt_hw_interrupt_enable(level);
 8017b7e:	69b8      	ldr	r0, [r7, #24]
 8017b80:	f7e8 fb26 	bl	80001d0 <rt_hw_interrupt_enable>

        no = ((rt_uint32_t)tx_tosnd - (rt_uint32_t)tx_fifo->buffer) / sizeof(struct rt_can_sndbxinx_list);
 8017b84:	69fb      	ldr	r3, [r7, #28]
 8017b86:	6a3a      	ldr	r2, [r7, #32]
 8017b88:	6812      	ldr	r2, [r2, #0]
 8017b8a:	1a9b      	subs	r3, r3, r2
 8017b8c:	4a47      	ldr	r2, [pc, #284]	; (8017cac <_can_int_tx+0x1a0>)
 8017b8e:	fba2 2303 	umull	r2, r3, r2, r3
 8017b92:	091b      	lsrs	r3, r3, #4
 8017b94:	617b      	str	r3, [r7, #20]
        tx_tosnd->result = RT_CAN_SND_RESULT_WAIT;
 8017b96:	69fb      	ldr	r3, [r7, #28]
 8017b98:	2202      	movs	r2, #2
 8017b9a:	615a      	str	r2, [r3, #20]
        if (can->ops->sendmsg(can, data, no) != RT_EOK)
 8017b9c:	68fb      	ldr	r3, [r7, #12]
 8017b9e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017ba0:	689b      	ldr	r3, [r3, #8]
 8017ba2:	68f8      	ldr	r0, [r7, #12]
 8017ba4:	68b9      	ldr	r1, [r7, #8]
 8017ba6:	697a      	ldr	r2, [r7, #20]
 8017ba8:	4798      	blx	r3
 8017baa:	4603      	mov	r3, r0
 8017bac:	2b00      	cmp	r3, #0
 8017bae:	d01a      	beq.n	8017be6 <_can_int_tx+0xda>
 8017bb0:	e00a      	b.n	8017bc8 <_can_int_tx+0xbc>
            RT_ASSERT(tx_tosnd != RT_NULL);
            rt_list_remove(&tx_tosnd->list);
        }
        else
        {
            rt_hw_interrupt_enable(level);
 8017bb2:	69b8      	ldr	r0, [r7, #24]
 8017bb4:	f7e8 fb0c 	bl	80001d0 <rt_hw_interrupt_enable>

            rt_completion_wait(&(tx_fifo->completion), RT_WAITING_FOREVER);
 8017bb8:	6a3b      	ldr	r3, [r7, #32]
 8017bba:	3304      	adds	r3, #4
 8017bbc:	4618      	mov	r0, r3
 8017bbe:	f04f 31ff 	mov.w	r1, #4294967295
 8017bc2:	f7fe fa47 	bl	8016054 <rt_completion_wait>
            continue;
 8017bc6:	e05e      	b.n	8017c86 <_can_int_tx+0x17a>
        no = ((rt_uint32_t)tx_tosnd - (rt_uint32_t)tx_fifo->buffer) / sizeof(struct rt_can_sndbxinx_list);
        tx_tosnd->result = RT_CAN_SND_RESULT_WAIT;
        if (can->ops->sendmsg(can, data, no) != RT_EOK)
        {
            /* send failed. */
            level = rt_hw_interrupt_disable();
 8017bc8:	f7e8 fafe 	bl	80001c8 <rt_hw_interrupt_disable>
 8017bcc:	61b8      	str	r0, [r7, #24]
            rt_list_insert_after(&tx_fifo->freelist, &tx_tosnd->list);
 8017bce:	6a3b      	ldr	r3, [r7, #32]
 8017bd0:	f103 0210 	add.w	r2, r3, #16
 8017bd4:	69fb      	ldr	r3, [r7, #28]
 8017bd6:	4610      	mov	r0, r2
 8017bd8:	4619      	mov	r1, r3
 8017bda:	f7ff fe8d 	bl	80178f8 <rt_list_insert_after>
            rt_hw_interrupt_enable(level);
 8017bde:	69b8      	ldr	r0, [r7, #24]
 8017be0:	f7e8 faf6 	bl	80001d0 <rt_hw_interrupt_enable>
            continue;
 8017be4:	e04f      	b.n	8017c86 <_can_int_tx+0x17a>
        }

        can->status.sndchange = 1;
 8017be6:	68fb      	ldr	r3, [r7, #12]
 8017be8:	2201      	movs	r2, #1
 8017bea:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        rt_completion_wait(&(tx_tosnd->completion), RT_WAITING_FOREVER);
 8017bee:	69fb      	ldr	r3, [r7, #28]
 8017bf0:	3308      	adds	r3, #8
 8017bf2:	4618      	mov	r0, r3
 8017bf4:	f04f 31ff 	mov.w	r1, #4294967295
 8017bf8:	f7fe fa2c 	bl	8016054 <rt_completion_wait>

        level = rt_hw_interrupt_disable();
 8017bfc:	f7e8 fae4 	bl	80001c8 <rt_hw_interrupt_disable>
 8017c00:	61b8      	str	r0, [r7, #24]
        result = tx_tosnd->result;
 8017c02:	69fb      	ldr	r3, [r7, #28]
 8017c04:	695b      	ldr	r3, [r3, #20]
 8017c06:	613b      	str	r3, [r7, #16]
        if (!rt_list_isempty(&tx_tosnd->list))
 8017c08:	69fb      	ldr	r3, [r7, #28]
 8017c0a:	4618      	mov	r0, r3
 8017c0c:	f7ff febe 	bl	801798c <rt_list_isempty>
 8017c10:	4603      	mov	r3, r0
 8017c12:	2b00      	cmp	r3, #0
 8017c14:	d103      	bne.n	8017c1e <_can_int_tx+0x112>
        {
            rt_list_remove(&tx_tosnd->list);
 8017c16:	69fb      	ldr	r3, [r7, #28]
 8017c18:	4618      	mov	r0, r3
 8017c1a:	f7ff fe9d 	bl	8017958 <rt_list_remove>
        }
        rt_list_insert_before(&tx_fifo->freelist, &tx_tosnd->list);
 8017c1e:	6a3b      	ldr	r3, [r7, #32]
 8017c20:	f103 0210 	add.w	r2, r3, #16
 8017c24:	69fb      	ldr	r3, [r7, #28]
 8017c26:	4610      	mov	r0, r2
 8017c28:	4619      	mov	r1, r3
 8017c2a:	f7ff fe7d 	bl	8017928 <rt_list_insert_before>
        rt_completion_done(&(tx_fifo->completion));
 8017c2e:	6a3b      	ldr	r3, [r7, #32]
 8017c30:	3304      	adds	r3, #4
 8017c32:	4618      	mov	r0, r3
 8017c34:	f7fe fa8e 	bl	8016154 <rt_completion_done>
        rt_hw_interrupt_enable(level);
 8017c38:	69b8      	ldr	r0, [r7, #24]
 8017c3a:	f7e8 fac9 	bl	80001d0 <rt_hw_interrupt_enable>

        if (result == RT_CAN_SND_RESULT_OK)
 8017c3e:	693b      	ldr	r3, [r7, #16]
 8017c40:	2b00      	cmp	r3, #0
 8017c42:	d114      	bne.n	8017c6e <_can_int_tx+0x162>
        {
            level = rt_hw_interrupt_disable();
 8017c44:	f7e8 fac0 	bl	80001c8 <rt_hw_interrupt_disable>
 8017c48:	61b8      	str	r0, [r7, #24]
            can->status.sndpkg++;
 8017c4a:	68fb      	ldr	r3, [r7, #12]
 8017c4c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8017c4e:	1c5a      	adds	r2, r3, #1
 8017c50:	68fb      	ldr	r3, [r7, #12]
 8017c52:	66da      	str	r2, [r3, #108]	; 0x6c
            rt_hw_interrupt_enable(level);
 8017c54:	69b8      	ldr	r0, [r7, #24]
 8017c56:	f7e8 fabb 	bl	80001d0 <rt_hw_interrupt_enable>

            data ++;
 8017c5a:	68bb      	ldr	r3, [r7, #8]
 8017c5c:	3310      	adds	r3, #16
 8017c5e:	60bb      	str	r3, [r7, #8]
            msgs -= sizeof(struct rt_can_msg);
 8017c60:	687b      	ldr	r3, [r7, #4]
 8017c62:	3b10      	subs	r3, #16
 8017c64:	607b      	str	r3, [r7, #4]
            if (!msgs) break;
 8017c66:	687b      	ldr	r3, [r7, #4]
 8017c68:	2b00      	cmp	r3, #0
 8017c6a:	d10c      	bne.n	8017c86 <_can_int_tx+0x17a>
 8017c6c:	e00f      	b.n	8017c8e <_can_int_tx+0x182>
        }
        else
        {
            level = rt_hw_interrupt_disable();
 8017c6e:	f7e8 faab 	bl	80001c8 <rt_hw_interrupt_disable>
 8017c72:	61b8      	str	r0, [r7, #24]
            can->status.dropedsndpkg++;
 8017c74:	68fb      	ldr	r3, [r7, #12]
 8017c76:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017c78:	1c5a      	adds	r2, r3, #1
 8017c7a:	68fb      	ldr	r3, [r7, #12]
 8017c7c:	671a      	str	r2, [r3, #112]	; 0x70
            rt_hw_interrupt_enable(level);
 8017c7e:	69b8      	ldr	r0, [r7, #24]
 8017c80:	f7e8 faa6 	bl	80001d0 <rt_hw_interrupt_enable>
            break;
 8017c84:	e003      	b.n	8017c8e <_can_int_tx+0x182>

    size = msgs;
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
    RT_ASSERT(tx_fifo != RT_NULL);

    while (msgs)
 8017c86:	687b      	ldr	r3, [r7, #4]
 8017c88:	2b00      	cmp	r3, #0
 8017c8a:	f47f af5c 	bne.w	8017b46 <_can_int_tx+0x3a>
            rt_hw_interrupt_enable(level);
            break;
        }
    }

    return (size - msgs);
 8017c8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8017c90:	687b      	ldr	r3, [r7, #4]
 8017c92:	1ad3      	subs	r3, r2, r3
}
 8017c94:	4618      	mov	r0, r3
 8017c96:	3728      	adds	r7, #40	; 0x28
 8017c98:	46bd      	mov	sp, r7
 8017c9a:	bd80      	pop	{r7, pc}
 8017c9c:	08023714 	.word	0x08023714
 8017ca0:	08025468 	.word	0x08025468
 8017ca4:	08023768 	.word	0x08023768
 8017ca8:	0802377c 	.word	0x0802377c
 8017cac:	aaaaaaab 	.word	0xaaaaaaab

08017cb0 <_can_int_tx_priv>:

rt_inline int _can_int_tx_priv(struct rt_can_device *can, const struct rt_can_msg *data, int msgs)
{
 8017cb0:	b580      	push	{r7, lr}
 8017cb2:	b08a      	sub	sp, #40	; 0x28
 8017cb4:	af00      	add	r7, sp, #0
 8017cb6:	60f8      	str	r0, [r7, #12]
 8017cb8:	60b9      	str	r1, [r7, #8]
 8017cba:	607a      	str	r2, [r7, #4]
    int size;
    rt_base_t level;
    rt_uint32_t no, result;
    struct rt_can_tx_fifo *tx_fifo;

    RT_ASSERT(can != RT_NULL);
 8017cbc:	68fb      	ldr	r3, [r7, #12]
 8017cbe:	2b00      	cmp	r3, #0
 8017cc0:	d104      	bne.n	8017ccc <_can_int_tx_priv+0x1c>
 8017cc2:	4850      	ldr	r0, [pc, #320]	; (8017e04 <_can_int_tx_priv+0x154>)
 8017cc4:	4950      	ldr	r1, [pc, #320]	; (8017e08 <_can_int_tx_priv+0x158>)
 8017cc6:	22e2      	movs	r2, #226	; 0xe2
 8017cc8:	f7fc f84c 	bl	8013d64 <rt_assert_handler>

    size = msgs;
 8017ccc:	687b      	ldr	r3, [r7, #4]
 8017cce:	627b      	str	r3, [r7, #36]	; 0x24
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 8017cd0:	68fb      	ldr	r3, [r7, #12]
 8017cd2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8017cd6:	623b      	str	r3, [r7, #32]
    RT_ASSERT(tx_fifo != RT_NULL);
 8017cd8:	6a3b      	ldr	r3, [r7, #32]
 8017cda:	2b00      	cmp	r3, #0
 8017cdc:	d104      	bne.n	8017ce8 <_can_int_tx_priv+0x38>
 8017cde:	484b      	ldr	r0, [pc, #300]	; (8017e0c <_can_int_tx_priv+0x15c>)
 8017ce0:	4949      	ldr	r1, [pc, #292]	; (8017e08 <_can_int_tx_priv+0x158>)
 8017ce2:	22e6      	movs	r2, #230	; 0xe6
 8017ce4:	f7fc f83e 	bl	8013d64 <rt_assert_handler>

    while (msgs)
 8017ce8:	e080      	b.n	8017dec <_can_int_tx_priv+0x13c>
    {
        no = data->priv;
 8017cea:	68bb      	ldr	r3, [r7, #8]
 8017cec:	795b      	ldrb	r3, [r3, #5]
 8017cee:	61fb      	str	r3, [r7, #28]
        if (no >= can->config.sndboxnumber)
 8017cf0:	68fb      	ldr	r3, [r7, #12]
 8017cf2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8017cf4:	69fb      	ldr	r3, [r7, #28]
 8017cf6:	429a      	cmp	r2, r3
 8017cf8:	d800      	bhi.n	8017cfc <_can_int_tx_priv+0x4c>
        {
            break;
 8017cfa:	e07b      	b.n	8017df4 <_can_int_tx_priv+0x144>
        }

        level = rt_hw_interrupt_disable();
 8017cfc:	f7e8 fa64 	bl	80001c8 <rt_hw_interrupt_disable>
 8017d00:	61b8      	str	r0, [r7, #24]
        if ((tx_fifo->buffer[no].result != RT_CAN_SND_RESULT_OK))
 8017d02:	6a3b      	ldr	r3, [r7, #32]
 8017d04:	6819      	ldr	r1, [r3, #0]
 8017d06:	69fa      	ldr	r2, [r7, #28]
 8017d08:	4613      	mov	r3, r2
 8017d0a:	005b      	lsls	r3, r3, #1
 8017d0c:	4413      	add	r3, r2
 8017d0e:	00db      	lsls	r3, r3, #3
 8017d10:	440b      	add	r3, r1
 8017d12:	695b      	ldr	r3, [r3, #20]
 8017d14:	2b00      	cmp	r3, #0
 8017d16:	d011      	beq.n	8017d3c <_can_int_tx_priv+0x8c>
        {
            rt_hw_interrupt_enable(level);
 8017d18:	69b8      	ldr	r0, [r7, #24]
 8017d1a:	f7e8 fa59 	bl	80001d0 <rt_hw_interrupt_enable>

            rt_completion_wait(&(tx_fifo->buffer[no].completion), RT_WAITING_FOREVER);
 8017d1e:	6a3b      	ldr	r3, [r7, #32]
 8017d20:	6819      	ldr	r1, [r3, #0]
 8017d22:	69fa      	ldr	r2, [r7, #28]
 8017d24:	4613      	mov	r3, r2
 8017d26:	005b      	lsls	r3, r3, #1
 8017d28:	4413      	add	r3, r2
 8017d2a:	00db      	lsls	r3, r3, #3
 8017d2c:	440b      	add	r3, r1
 8017d2e:	3308      	adds	r3, #8
 8017d30:	4618      	mov	r0, r3
 8017d32:	f04f 31ff 	mov.w	r1, #4294967295
 8017d36:	f7fe f98d 	bl	8016054 <rt_completion_wait>
            continue;
 8017d3a:	e057      	b.n	8017dec <_can_int_tx_priv+0x13c>
        }
        tx_fifo->buffer[no].result = RT_CAN_SND_RESULT_WAIT;
 8017d3c:	6a3b      	ldr	r3, [r7, #32]
 8017d3e:	6819      	ldr	r1, [r3, #0]
 8017d40:	69fa      	ldr	r2, [r7, #28]
 8017d42:	4613      	mov	r3, r2
 8017d44:	005b      	lsls	r3, r3, #1
 8017d46:	4413      	add	r3, r2
 8017d48:	00db      	lsls	r3, r3, #3
 8017d4a:	440b      	add	r3, r1
 8017d4c:	2202      	movs	r2, #2
 8017d4e:	615a      	str	r2, [r3, #20]
        rt_hw_interrupt_enable(level);
 8017d50:	69b8      	ldr	r0, [r7, #24]
 8017d52:	f7e8 fa3d 	bl	80001d0 <rt_hw_interrupt_enable>

        if (can->ops->sendmsg(can, data, no) != RT_EOK)
 8017d56:	68fb      	ldr	r3, [r7, #12]
 8017d58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017d5a:	689b      	ldr	r3, [r3, #8]
 8017d5c:	68f8      	ldr	r0, [r7, #12]
 8017d5e:	68b9      	ldr	r1, [r7, #8]
 8017d60:	69fa      	ldr	r2, [r7, #28]
 8017d62:	4798      	blx	r3
 8017d64:	4603      	mov	r3, r0
 8017d66:	2b00      	cmp	r3, #0
 8017d68:	d000      	beq.n	8017d6c <_can_int_tx_priv+0xbc>
        {
            continue;
 8017d6a:	e03f      	b.n	8017dec <_can_int_tx_priv+0x13c>
        }
        can->status.sndchange = 1;
 8017d6c:	68fb      	ldr	r3, [r7, #12]
 8017d6e:	2201      	movs	r2, #1
 8017d70:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        rt_completion_wait(&(tx_fifo->buffer[no].completion), RT_WAITING_FOREVER);
 8017d74:	6a3b      	ldr	r3, [r7, #32]
 8017d76:	6819      	ldr	r1, [r3, #0]
 8017d78:	69fa      	ldr	r2, [r7, #28]
 8017d7a:	4613      	mov	r3, r2
 8017d7c:	005b      	lsls	r3, r3, #1
 8017d7e:	4413      	add	r3, r2
 8017d80:	00db      	lsls	r3, r3, #3
 8017d82:	440b      	add	r3, r1
 8017d84:	3308      	adds	r3, #8
 8017d86:	4618      	mov	r0, r3
 8017d88:	f04f 31ff 	mov.w	r1, #4294967295
 8017d8c:	f7fe f962 	bl	8016054 <rt_completion_wait>

        result = tx_fifo->buffer[no].result;
 8017d90:	6a3b      	ldr	r3, [r7, #32]
 8017d92:	6819      	ldr	r1, [r3, #0]
 8017d94:	69fa      	ldr	r2, [r7, #28]
 8017d96:	4613      	mov	r3, r2
 8017d98:	005b      	lsls	r3, r3, #1
 8017d9a:	4413      	add	r3, r2
 8017d9c:	00db      	lsls	r3, r3, #3
 8017d9e:	440b      	add	r3, r1
 8017da0:	695b      	ldr	r3, [r3, #20]
 8017da2:	617b      	str	r3, [r7, #20]
        if (result == RT_CAN_SND_RESULT_OK)
 8017da4:	697b      	ldr	r3, [r7, #20]
 8017da6:	2b00      	cmp	r3, #0
 8017da8:	d114      	bne.n	8017dd4 <_can_int_tx_priv+0x124>
        {
            level = rt_hw_interrupt_disable();
 8017daa:	f7e8 fa0d 	bl	80001c8 <rt_hw_interrupt_disable>
 8017dae:	61b8      	str	r0, [r7, #24]
            can->status.sndpkg++;
 8017db0:	68fb      	ldr	r3, [r7, #12]
 8017db2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8017db4:	1c5a      	adds	r2, r3, #1
 8017db6:	68fb      	ldr	r3, [r7, #12]
 8017db8:	66da      	str	r2, [r3, #108]	; 0x6c
            rt_hw_interrupt_enable(level);
 8017dba:	69b8      	ldr	r0, [r7, #24]
 8017dbc:	f7e8 fa08 	bl	80001d0 <rt_hw_interrupt_enable>
            data ++;
 8017dc0:	68bb      	ldr	r3, [r7, #8]
 8017dc2:	3310      	adds	r3, #16
 8017dc4:	60bb      	str	r3, [r7, #8]
            msgs -= sizeof(struct rt_can_msg);
 8017dc6:	687b      	ldr	r3, [r7, #4]
 8017dc8:	3b10      	subs	r3, #16
 8017dca:	607b      	str	r3, [r7, #4]
            if (!msgs) break;
 8017dcc:	687b      	ldr	r3, [r7, #4]
 8017dce:	2b00      	cmp	r3, #0
 8017dd0:	d10c      	bne.n	8017dec <_can_int_tx_priv+0x13c>
 8017dd2:	e00f      	b.n	8017df4 <_can_int_tx_priv+0x144>
        }
        else
        {
            level = rt_hw_interrupt_disable();
 8017dd4:	f7e8 f9f8 	bl	80001c8 <rt_hw_interrupt_disable>
 8017dd8:	61b8      	str	r0, [r7, #24]
            can->status.dropedsndpkg++;
 8017dda:	68fb      	ldr	r3, [r7, #12]
 8017ddc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017dde:	1c5a      	adds	r2, r3, #1
 8017de0:	68fb      	ldr	r3, [r7, #12]
 8017de2:	671a      	str	r2, [r3, #112]	; 0x70
            rt_hw_interrupt_enable(level);
 8017de4:	69b8      	ldr	r0, [r7, #24]
 8017de6:	f7e8 f9f3 	bl	80001d0 <rt_hw_interrupt_enable>
            break;
 8017dea:	e003      	b.n	8017df4 <_can_int_tx_priv+0x144>

    size = msgs;
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
    RT_ASSERT(tx_fifo != RT_NULL);

    while (msgs)
 8017dec:	687b      	ldr	r3, [r7, #4]
 8017dee:	2b00      	cmp	r3, #0
 8017df0:	f47f af7b 	bne.w	8017cea <_can_int_tx_priv+0x3a>
            rt_hw_interrupt_enable(level);
            break;
        }
    }

    return (size - msgs);
 8017df4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8017df6:	687b      	ldr	r3, [r7, #4]
 8017df8:	1ad3      	subs	r3, r2, r3
}
 8017dfa:	4618      	mov	r0, r3
 8017dfc:	3728      	adds	r7, #40	; 0x28
 8017dfe:	46bd      	mov	sp, r7
 8017e00:	bd80      	pop	{r7, pc}
 8017e02:	bf00      	nop
 8017e04:	08023714 	.word	0x08023714
 8017e08:	08025454 	.word	0x08025454
 8017e0c:	08023768 	.word	0x08023768

08017e10 <rt_can_open>:

static rt_err_t rt_can_open(struct rt_device *dev, rt_uint16_t oflag)
{
 8017e10:	b580      	push	{r7, lr}
 8017e12:	b088      	sub	sp, #32
 8017e14:	af00      	add	r7, sp, #0
 8017e16:	6078      	str	r0, [r7, #4]
 8017e18:	460b      	mov	r3, r1
 8017e1a:	807b      	strh	r3, [r7, #2]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 8017e1c:	687b      	ldr	r3, [r7, #4]
 8017e1e:	2b00      	cmp	r3, #0
 8017e20:	d105      	bne.n	8017e2e <rt_can_open+0x1e>
 8017e22:	4891      	ldr	r0, [pc, #580]	; (8018068 <rt_can_open+0x258>)
 8017e24:	4991      	ldr	r1, [pc, #580]	; (801806c <rt_can_open+0x25c>)
 8017e26:	f44f 728e 	mov.w	r2, #284	; 0x11c
 8017e2a:	f7fb ff9b 	bl	8013d64 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 8017e2e:	687b      	ldr	r3, [r7, #4]
 8017e30:	617b      	str	r3, [r7, #20]

    CAN_LOCK(can);
 8017e32:	697b      	ldr	r3, [r7, #20]
 8017e34:	33cc      	adds	r3, #204	; 0xcc
 8017e36:	4618      	mov	r0, r3
 8017e38:	f04f 31ff 	mov.w	r1, #4294967295
 8017e3c:	f7fa fd0e 	bl	801285c <rt_mutex_take>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
 8017e40:	887b      	ldrh	r3, [r7, #2]
 8017e42:	b2db      	uxtb	r3, r3
 8017e44:	b29a      	uxth	r2, r3
 8017e46:	687b      	ldr	r3, [r7, #4]
 8017e48:	831a      	strh	r2, [r3, #24]
    if (can->can_rx == RT_NULL)
 8017e4a:	697b      	ldr	r3, [r7, #20]
 8017e4c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8017e50:	2b00      	cmp	r3, #0
 8017e52:	d166      	bne.n	8017f22 <rt_can_open+0x112>
    {
        if (oflag & RT_DEVICE_FLAG_INT_RX)
 8017e54:	887b      	ldrh	r3, [r7, #2]
 8017e56:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8017e5a:	2b00      	cmp	r3, #0
 8017e5c:	d061      	beq.n	8017f22 <rt_can_open+0x112>
        {
            int i = 0;
 8017e5e:	2300      	movs	r3, #0
 8017e60:	61fb      	str	r3, [r7, #28]
            struct rt_can_rx_fifo *rx_fifo;

            rx_fifo = (struct rt_can_rx_fifo *) rt_malloc(sizeof(struct rt_can_rx_fifo) +
                      can->config.msgboxsz * sizeof(struct rt_can_msg_list));
 8017e62:	697b      	ldr	r3, [r7, #20]
 8017e64:	6c9b      	ldr	r3, [r3, #72]	; 0x48
        if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            int i = 0;
            struct rt_can_rx_fifo *rx_fifo;

            rx_fifo = (struct rt_can_rx_fifo *) rt_malloc(sizeof(struct rt_can_rx_fifo) +
 8017e66:	1c5a      	adds	r2, r3, #1
 8017e68:	4613      	mov	r3, r2
 8017e6a:	005b      	lsls	r3, r3, #1
 8017e6c:	4413      	add	r3, r2
 8017e6e:	00db      	lsls	r3, r3, #3
 8017e70:	4618      	mov	r0, r3
 8017e72:	f7fc f8ab 	bl	8013fcc <rt_malloc>
 8017e76:	6138      	str	r0, [r7, #16]
                      can->config.msgboxsz * sizeof(struct rt_can_msg_list));
            RT_ASSERT(rx_fifo != RT_NULL);
 8017e78:	693b      	ldr	r3, [r7, #16]
 8017e7a:	2b00      	cmp	r3, #0
 8017e7c:	d105      	bne.n	8017e8a <rt_can_open+0x7a>
 8017e7e:	487c      	ldr	r0, [pc, #496]	; (8018070 <rt_can_open+0x260>)
 8017e80:	497a      	ldr	r1, [pc, #488]	; (801806c <rt_can_open+0x25c>)
 8017e82:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8017e86:	f7fb ff6d 	bl	8013d64 <rt_assert_handler>

            rx_fifo->buffer = (struct rt_can_msg_list *)(rx_fifo + 1);
 8017e8a:	693b      	ldr	r3, [r7, #16]
 8017e8c:	f103 0218 	add.w	r2, r3, #24
 8017e90:	693b      	ldr	r3, [r7, #16]
 8017e92:	601a      	str	r2, [r3, #0]
            rt_memset(rx_fifo->buffer, 0, can->config.msgboxsz * sizeof(struct rt_can_msg_list));
 8017e94:	693b      	ldr	r3, [r7, #16]
 8017e96:	6819      	ldr	r1, [r3, #0]
 8017e98:	697b      	ldr	r3, [r7, #20]
 8017e9a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8017e9c:	4613      	mov	r3, r2
 8017e9e:	005b      	lsls	r3, r3, #1
 8017ea0:	4413      	add	r3, r2
 8017ea2:	00db      	lsls	r3, r3, #3
 8017ea4:	4608      	mov	r0, r1
 8017ea6:	2100      	movs	r1, #0
 8017ea8:	461a      	mov	r2, r3
 8017eaa:	f7fb f929 	bl	8013100 <rt_memset>
            rt_list_init(&rx_fifo->freelist);
 8017eae:	693b      	ldr	r3, [r7, #16]
 8017eb0:	3308      	adds	r3, #8
 8017eb2:	4618      	mov	r0, r3
 8017eb4:	f7ff fd10 	bl	80178d8 <rt_list_init>
            rt_list_init(&rx_fifo->uselist);
 8017eb8:	693b      	ldr	r3, [r7, #16]
 8017eba:	3310      	adds	r3, #16
 8017ebc:	4618      	mov	r0, r3
 8017ebe:	f7ff fd0b 	bl	80178d8 <rt_list_init>
            rx_fifo->freenumbers = can->config.msgboxsz;
 8017ec2:	697b      	ldr	r3, [r7, #20]
 8017ec4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8017ec6:	693b      	ldr	r3, [r7, #16]
 8017ec8:	605a      	str	r2, [r3, #4]
            for (i = 0;  i < can->config.msgboxsz; i++)
 8017eca:	2300      	movs	r3, #0
 8017ecc:	61fb      	str	r3, [r7, #28]
 8017ece:	e010      	b.n	8017ef2 <rt_can_open+0xe2>
            {
                rt_list_insert_before(&rx_fifo->freelist, &rx_fifo->buffer[i].list);
 8017ed0:	693b      	ldr	r3, [r7, #16]
 8017ed2:	f103 0008 	add.w	r0, r3, #8
 8017ed6:	693b      	ldr	r3, [r7, #16]
 8017ed8:	6819      	ldr	r1, [r3, #0]
 8017eda:	69fa      	ldr	r2, [r7, #28]
 8017edc:	4613      	mov	r3, r2
 8017ede:	005b      	lsls	r3, r3, #1
 8017ee0:	4413      	add	r3, r2
 8017ee2:	00db      	lsls	r3, r3, #3
 8017ee4:	440b      	add	r3, r1
 8017ee6:	4619      	mov	r1, r3
 8017ee8:	f7ff fd1e 	bl	8017928 <rt_list_insert_before>
            rx_fifo->buffer = (struct rt_can_msg_list *)(rx_fifo + 1);
            rt_memset(rx_fifo->buffer, 0, can->config.msgboxsz * sizeof(struct rt_can_msg_list));
            rt_list_init(&rx_fifo->freelist);
            rt_list_init(&rx_fifo->uselist);
            rx_fifo->freenumbers = can->config.msgboxsz;
            for (i = 0;  i < can->config.msgboxsz; i++)
 8017eec:	69fb      	ldr	r3, [r7, #28]
 8017eee:	3301      	adds	r3, #1
 8017ef0:	61fb      	str	r3, [r7, #28]
 8017ef2:	69fa      	ldr	r2, [r7, #28]
 8017ef4:	697b      	ldr	r3, [r7, #20]
 8017ef6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8017ef8:	429a      	cmp	r2, r3
 8017efa:	d3e9      	bcc.n	8017ed0 <rt_can_open+0xc0>
#ifdef RT_CAN_USING_HDR
                rt_list_init(&rx_fifo->buffer[i].hdrlist);
                rx_fifo->buffer[i].owner = RT_NULL;
#endif
            }
            can->can_rx = rx_fifo;
 8017efc:	697b      	ldr	r3, [r7, #20]
 8017efe:	693a      	ldr	r2, [r7, #16]
 8017f00:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0

            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
 8017f04:	687b      	ldr	r3, [r7, #4]
 8017f06:	8b1b      	ldrh	r3, [r3, #24]
 8017f08:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8017f0c:	b29a      	uxth	r2, r3
 8017f0e:	687b      	ldr	r3, [r7, #4]
 8017f10:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 8017f12:	697b      	ldr	r3, [r7, #20]
 8017f14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017f16:	685b      	ldr	r3, [r3, #4]
 8017f18:	6978      	ldr	r0, [r7, #20]
 8017f1a:	2110      	movs	r1, #16
 8017f1c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8017f20:	4798      	blx	r3

		//else
			//can->can_rx = RT_NULL;
    }

    if (can->can_tx == RT_NULL)
 8017f22:	697b      	ldr	r3, [r7, #20]
 8017f24:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8017f28:	2b00      	cmp	r3, #0
 8017f2a:	d17d      	bne.n	8018028 <rt_can_open+0x218>
    {
        if (oflag & RT_DEVICE_FLAG_INT_TX)
 8017f2c:	887b      	ldrh	r3, [r7, #2]
 8017f2e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8017f32:	2b00      	cmp	r3, #0
 8017f34:	d074      	beq.n	8018020 <rt_can_open+0x210>
        {
            int i = 0;
 8017f36:	2300      	movs	r3, #0
 8017f38:	61bb      	str	r3, [r7, #24]
            struct rt_can_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
 8017f3a:	697b      	ldr	r3, [r7, #20]
 8017f3c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
        if (oflag & RT_DEVICE_FLAG_INT_TX)
        {
            int i = 0;
            struct rt_can_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
 8017f3e:	1c5a      	adds	r2, r3, #1
 8017f40:	4613      	mov	r3, r2
 8017f42:	005b      	lsls	r3, r3, #1
 8017f44:	4413      	add	r3, r2
 8017f46:	00db      	lsls	r3, r3, #3
 8017f48:	4618      	mov	r0, r3
 8017f4a:	f7fc f83f 	bl	8013fcc <rt_malloc>
 8017f4e:	60f8      	str	r0, [r7, #12]
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            RT_ASSERT(tx_fifo != RT_NULL);
 8017f50:	68fb      	ldr	r3, [r7, #12]
 8017f52:	2b00      	cmp	r3, #0
 8017f54:	d105      	bne.n	8017f62 <rt_can_open+0x152>
 8017f56:	4847      	ldr	r0, [pc, #284]	; (8018074 <rt_can_open+0x264>)
 8017f58:	4944      	ldr	r1, [pc, #272]	; (801806c <rt_can_open+0x25c>)
 8017f5a:	f240 124f 	movw	r2, #335	; 0x14f
 8017f5e:	f7fb ff01 	bl	8013d64 <rt_assert_handler>

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
 8017f62:	68fb      	ldr	r3, [r7, #12]
 8017f64:	f103 0218 	add.w	r2, r3, #24
 8017f68:	68fb      	ldr	r3, [r7, #12]
 8017f6a:	601a      	str	r2, [r3, #0]
            rt_memset(tx_fifo->buffer, 0,
 8017f6c:	68fb      	ldr	r3, [r7, #12]
 8017f6e:	6819      	ldr	r1, [r3, #0]
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
 8017f70:	697b      	ldr	r3, [r7, #20]
 8017f72:	6cda      	ldr	r2, [r3, #76]	; 0x4c
            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            RT_ASSERT(tx_fifo != RT_NULL);

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
            rt_memset(tx_fifo->buffer, 0,
 8017f74:	4613      	mov	r3, r2
 8017f76:	005b      	lsls	r3, r3, #1
 8017f78:	4413      	add	r3, r2
 8017f7a:	00db      	lsls	r3, r3, #3
 8017f7c:	4608      	mov	r0, r1
 8017f7e:	2100      	movs	r1, #0
 8017f80:	461a      	mov	r2, r3
 8017f82:	f7fb f8bd 	bl	8013100 <rt_memset>
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            rt_list_init(&tx_fifo->freelist);
 8017f86:	68fb      	ldr	r3, [r7, #12]
 8017f88:	3310      	adds	r3, #16
 8017f8a:	4618      	mov	r0, r3
 8017f8c:	f7ff fca4 	bl	80178d8 <rt_list_init>
            for (i = 0;  i < can->config.sndboxnumber; i++)
 8017f90:	2300      	movs	r3, #0
 8017f92:	61bb      	str	r3, [r7, #24]
 8017f94:	e026      	b.n	8017fe4 <rt_can_open+0x1d4>
            {
                rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
 8017f96:	68fb      	ldr	r3, [r7, #12]
 8017f98:	f103 0010 	add.w	r0, r3, #16
 8017f9c:	68fb      	ldr	r3, [r7, #12]
 8017f9e:	6819      	ldr	r1, [r3, #0]
 8017fa0:	69ba      	ldr	r2, [r7, #24]
 8017fa2:	4613      	mov	r3, r2
 8017fa4:	005b      	lsls	r3, r3, #1
 8017fa6:	4413      	add	r3, r2
 8017fa8:	00db      	lsls	r3, r3, #3
 8017faa:	440b      	add	r3, r1
 8017fac:	4619      	mov	r1, r3
 8017fae:	f7ff fcbb 	bl	8017928 <rt_list_insert_before>
                rt_completion_init(&(tx_fifo->buffer[i].completion));
 8017fb2:	68fb      	ldr	r3, [r7, #12]
 8017fb4:	6819      	ldr	r1, [r3, #0]
 8017fb6:	69ba      	ldr	r2, [r7, #24]
 8017fb8:	4613      	mov	r3, r2
 8017fba:	005b      	lsls	r3, r3, #1
 8017fbc:	4413      	add	r3, r2
 8017fbe:	00db      	lsls	r3, r3, #3
 8017fc0:	440b      	add	r3, r1
 8017fc2:	3308      	adds	r3, #8
 8017fc4:	4618      	mov	r0, r3
 8017fc6:	f7fe f823 	bl	8016010 <rt_completion_init>
                tx_fifo->buffer[i].result = RT_CAN_SND_RESULT_OK;
 8017fca:	68fb      	ldr	r3, [r7, #12]
 8017fcc:	6819      	ldr	r1, [r3, #0]
 8017fce:	69ba      	ldr	r2, [r7, #24]
 8017fd0:	4613      	mov	r3, r2
 8017fd2:	005b      	lsls	r3, r3, #1
 8017fd4:	4413      	add	r3, r2
 8017fd6:	00db      	lsls	r3, r3, #3
 8017fd8:	440b      	add	r3, r1
 8017fda:	2200      	movs	r2, #0
 8017fdc:	615a      	str	r2, [r3, #20]

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
            rt_memset(tx_fifo->buffer, 0,
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            rt_list_init(&tx_fifo->freelist);
            for (i = 0;  i < can->config.sndboxnumber; i++)
 8017fde:	69bb      	ldr	r3, [r7, #24]
 8017fe0:	3301      	adds	r3, #1
 8017fe2:	61bb      	str	r3, [r7, #24]
 8017fe4:	69ba      	ldr	r2, [r7, #24]
 8017fe6:	697b      	ldr	r3, [r7, #20]
 8017fe8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8017fea:	429a      	cmp	r2, r3
 8017fec:	d3d3      	bcc.n	8017f96 <rt_can_open+0x186>
            {
                rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
                rt_completion_init(&(tx_fifo->buffer[i].completion));
                tx_fifo->buffer[i].result = RT_CAN_SND_RESULT_OK;
            }
            rt_completion_init(&(tx_fifo->completion));
 8017fee:	68fb      	ldr	r3, [r7, #12]
 8017ff0:	3304      	adds	r3, #4
 8017ff2:	4618      	mov	r0, r3
 8017ff4:	f7fe f80c 	bl	8016010 <rt_completion_init>
            can->can_tx = tx_fifo;
 8017ff8:	697b      	ldr	r3, [r7, #20]
 8017ffa:	68fa      	ldr	r2, [r7, #12]
 8017ffc:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
 8018000:	687b      	ldr	r3, [r7, #4]
 8018002:	8b1b      	ldrh	r3, [r3, #24]
 8018004:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8018008:	b29a      	uxth	r2, r3
 801800a:	687b      	ldr	r3, [r7, #4]
 801800c:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801800e:	697b      	ldr	r3, [r7, #20]
 8018010:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8018012:	685b      	ldr	r3, [r3, #4]
 8018014:	6978      	ldr	r0, [r7, #20]
 8018016:	2110      	movs	r1, #16
 8018018:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801801c:	4798      	blx	r3
 801801e:	e003      	b.n	8018028 <rt_can_open+0x218>
        }
		else 
			can->can_tx = RT_NULL;
 8018020:	697b      	ldr	r3, [r7, #20]
 8018022:	2200      	movs	r2, #0
 8018024:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    }

    can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_CAN_INT_ERR);
 8018028:	697b      	ldr	r3, [r7, #20]
 801802a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801802c:	685b      	ldr	r3, [r3, #4]
 801802e:	6978      	ldr	r0, [r7, #20]
 8018030:	2110      	movs	r1, #16
 8018032:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8018036:	4798      	blx	r3

        can->hdr = phdr;
    }
#endif

    if (!can->timerinitflag)
 8018038:	697b      	ldr	r3, [r7, #20]
 801803a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801803e:	2b00      	cmp	r3, #0
 8018040:	d108      	bne.n	8018054 <rt_can_open+0x244>
    {
        can->timerinitflag = 1;
 8018042:	697b      	ldr	r3, [r7, #20]
 8018044:	2201      	movs	r2, #1
 8018046:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

        rt_timer_start(&can->timer);
 801804a:	697b      	ldr	r3, [r7, #20]
 801804c:	3398      	adds	r3, #152	; 0x98
 801804e:	4618      	mov	r0, r3
 8018050:	f7fd fad2 	bl	80155f8 <rt_timer_start>
    }

    CAN_UNLOCK(can);
 8018054:	697b      	ldr	r3, [r7, #20]
 8018056:	33cc      	adds	r3, #204	; 0xcc
 8018058:	4618      	mov	r0, r3
 801805a:	f7fa fcd7 	bl	8012a0c <rt_mutex_release>

    return RT_EOK;
 801805e:	2300      	movs	r3, #0
}
 8018060:	4618      	mov	r0, r3
 8018062:	3720      	adds	r7, #32
 8018064:	46bd      	mov	sp, r7
 8018066:	bd80      	pop	{r7, pc}
 8018068:	08023704 	.word	0x08023704
 801806c:	08025410 	.word	0x08025410
 8018070:	08023724 	.word	0x08023724
 8018074:	08023768 	.word	0x08023768

08018078 <rt_can_close>:

static rt_err_t rt_can_close(struct rt_device *dev)
{
 8018078:	b580      	push	{r7, lr}
 801807a:	b086      	sub	sp, #24
 801807c:	af00      	add	r7, sp, #0
 801807e:	6078      	str	r0, [r7, #4]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 8018080:	687b      	ldr	r3, [r7, #4]
 8018082:	2b00      	cmp	r3, #0
 8018084:	d105      	bne.n	8018092 <rt_can_close+0x1a>
 8018086:	4846      	ldr	r0, [pc, #280]	; (80181a0 <rt_can_close+0x128>)
 8018088:	4946      	ldr	r1, [pc, #280]	; (80181a4 <rt_can_close+0x12c>)
 801808a:	f44f 72c5 	mov.w	r2, #394	; 0x18a
 801808e:	f7fb fe69 	bl	8013d64 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 8018092:	687b      	ldr	r3, [r7, #4]
 8018094:	617b      	str	r3, [r7, #20]

    CAN_LOCK(can);
 8018096:	697b      	ldr	r3, [r7, #20]
 8018098:	33cc      	adds	r3, #204	; 0xcc
 801809a:	4618      	mov	r0, r3
 801809c:	f04f 31ff 	mov.w	r1, #4294967295
 80180a0:	f7fa fbdc 	bl	801285c <rt_mutex_take>

    /* this device has more reference count */
    if (dev->ref_count > 1)
 80180a4:	687b      	ldr	r3, [r7, #4]
 80180a6:	7e9b      	ldrb	r3, [r3, #26]
 80180a8:	2b01      	cmp	r3, #1
 80180aa:	d906      	bls.n	80180ba <rt_can_close+0x42>
    {
        CAN_UNLOCK(can);
 80180ac:	697b      	ldr	r3, [r7, #20]
 80180ae:	33cc      	adds	r3, #204	; 0xcc
 80180b0:	4618      	mov	r0, r3
 80180b2:	f7fa fcab 	bl	8012a0c <rt_mutex_release>
        return RT_EOK;
 80180b6:	2300      	movs	r3, #0
 80180b8:	e06d      	b.n	8018196 <rt_can_close+0x11e>
    }

    if (can->timerinitflag)
 80180ba:	697b      	ldr	r3, [r7, #20]
 80180bc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80180c0:	2b00      	cmp	r3, #0
 80180c2:	d008      	beq.n	80180d6 <rt_can_close+0x5e>
    {
        can->timerinitflag = 0;
 80180c4:	697b      	ldr	r3, [r7, #20]
 80180c6:	2200      	movs	r2, #0
 80180c8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

        rt_timer_stop(&can->timer);
 80180cc:	697b      	ldr	r3, [r7, #20]
 80180ce:	3398      	adds	r3, #152	; 0x98
 80180d0:	4618      	mov	r0, r3
 80180d2:	f7fd fb9d 	bl	8015810 <rt_timer_stop>
    }

    can->status_indicate.ind = RT_NULL;
 80180d6:	697b      	ldr	r3, [r7, #20]
 80180d8:	2200      	movs	r2, #0
 80180da:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    can->status_indicate.args = RT_NULL;
 80180de:	697b      	ldr	r3, [r7, #20]
 80180e0:	2200      	movs	r2, #0
 80180e2:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        rt_free(can->hdr);
        can->hdr = RT_NULL;
    }
#endif

    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 80180e6:	687b      	ldr	r3, [r7, #4]
 80180e8:	8b1b      	ldrh	r3, [r3, #24]
 80180ea:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80180ee:	2b00      	cmp	r3, #0
 80180f0:	d01e      	beq.n	8018130 <rt_can_close+0xb8>
    {
        struct rt_can_rx_fifo *rx_fifo;

        rx_fifo = (struct rt_can_rx_fifo *)can->can_rx;
 80180f2:	697b      	ldr	r3, [r7, #20]
 80180f4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80180f8:	613b      	str	r3, [r7, #16]
        RT_ASSERT(rx_fifo != RT_NULL);
 80180fa:	693b      	ldr	r3, [r7, #16]
 80180fc:	2b00      	cmp	r3, #0
 80180fe:	d105      	bne.n	801810c <rt_can_close+0x94>
 8018100:	4829      	ldr	r0, [pc, #164]	; (80181a8 <rt_can_close+0x130>)
 8018102:	4928      	ldr	r1, [pc, #160]	; (80181a4 <rt_can_close+0x12c>)
 8018104:	f240 12ad 	movw	r2, #429	; 0x1ad
 8018108:	f7fb fe2c 	bl	8013d64 <rt_assert_handler>

        rt_free(rx_fifo);
 801810c:	6938      	ldr	r0, [r7, #16]
 801810e:	f7fc f967 	bl	80143e0 <rt_free>
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
 8018112:	687b      	ldr	r3, [r7, #4]
 8018114:	8b1b      	ldrh	r3, [r3, #24]
 8018116:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 801811a:	b29a      	uxth	r2, r3
 801811c:	687b      	ldr	r3, [r7, #4]
 801811e:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 8018120:	697b      	ldr	r3, [r7, #20]
 8018122:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8018124:	685b      	ldr	r3, [r3, #4]
 8018126:	6978      	ldr	r0, [r7, #20]
 8018128:	2111      	movs	r1, #17
 801812a:	f44f 7280 	mov.w	r2, #256	; 0x100
 801812e:	4798      	blx	r3
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 8018130:	687b      	ldr	r3, [r7, #4]
 8018132:	8b1b      	ldrh	r3, [r3, #24]
 8018134:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8018138:	2b00      	cmp	r3, #0
 801813a:	d01e      	beq.n	801817a <rt_can_close+0x102>
    {
        struct rt_can_tx_fifo *tx_fifo;

        tx_fifo = (struct rt_can_tx_fifo *)can->can_tx;
 801813c:	697b      	ldr	r3, [r7, #20]
 801813e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8018142:	60fb      	str	r3, [r7, #12]
        RT_ASSERT(tx_fifo != RT_NULL);
 8018144:	68fb      	ldr	r3, [r7, #12]
 8018146:	2b00      	cmp	r3, #0
 8018148:	d105      	bne.n	8018156 <rt_can_close+0xde>
 801814a:	4818      	ldr	r0, [pc, #96]	; (80181ac <rt_can_close+0x134>)
 801814c:	4915      	ldr	r1, [pc, #84]	; (80181a4 <rt_can_close+0x12c>)
 801814e:	f44f 72dd 	mov.w	r2, #442	; 0x1ba
 8018152:	f7fb fe07 	bl	8013d64 <rt_assert_handler>

        rt_free(tx_fifo);
 8018156:	68f8      	ldr	r0, [r7, #12]
 8018158:	f7fc f942 	bl	80143e0 <rt_free>
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
 801815c:	687b      	ldr	r3, [r7, #4]
 801815e:	8b1b      	ldrh	r3, [r3, #24]
 8018160:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8018164:	b29a      	uxth	r2, r3
 8018166:	687b      	ldr	r3, [r7, #4]
 8018168:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801816a:	697b      	ldr	r3, [r7, #20]
 801816c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801816e:	685b      	ldr	r3, [r3, #4]
 8018170:	6978      	ldr	r0, [r7, #20]
 8018172:	2111      	movs	r1, #17
 8018174:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8018178:	4798      	blx	r3
    }

    can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_CAN_INT_ERR);
 801817a:	697b      	ldr	r3, [r7, #20]
 801817c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801817e:	685b      	ldr	r3, [r3, #4]
 8018180:	6978      	ldr	r0, [r7, #20]
 8018182:	2111      	movs	r1, #17
 8018184:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8018188:	4798      	blx	r3

    CAN_UNLOCK(can);
 801818a:	697b      	ldr	r3, [r7, #20]
 801818c:	33cc      	adds	r3, #204	; 0xcc
 801818e:	4618      	mov	r0, r3
 8018190:	f7fa fc3c 	bl	8012a0c <rt_mutex_release>

    return RT_EOK;
 8018194:	2300      	movs	r3, #0
}
 8018196:	4618      	mov	r0, r3
 8018198:	3718      	adds	r7, #24
 801819a:	46bd      	mov	sp, r7
 801819c:	bd80      	pop	{r7, pc}
 801819e:	bf00      	nop
 80181a0:	08023704 	.word	0x08023704
 80181a4:	0802541c 	.word	0x0802541c
 80181a8:	08023724 	.word	0x08023724
 80181ac:	08023768 	.word	0x08023768

080181b0 <rt_can_read>:

static rt_size_t rt_can_read(struct rt_device *dev,
                             rt_off_t          pos,
                             void             *buffer,
                             rt_size_t         size)
{
 80181b0:	b580      	push	{r7, lr}
 80181b2:	b086      	sub	sp, #24
 80181b4:	af00      	add	r7, sp, #0
 80181b6:	60f8      	str	r0, [r7, #12]
 80181b8:	60b9      	str	r1, [r7, #8]
 80181ba:	607a      	str	r2, [r7, #4]
 80181bc:	603b      	str	r3, [r7, #0]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 80181be:	68fb      	ldr	r3, [r7, #12]
 80181c0:	2b00      	cmp	r3, #0
 80181c2:	d105      	bne.n	80181d0 <rt_can_read+0x20>
 80181c4:	4811      	ldr	r0, [pc, #68]	; (801820c <rt_can_read+0x5c>)
 80181c6:	4912      	ldr	r1, [pc, #72]	; (8018210 <rt_can_read+0x60>)
 80181c8:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
 80181cc:	f7fb fdca 	bl	8013d64 <rt_assert_handler>
    if (size == 0) return 0;
 80181d0:	683b      	ldr	r3, [r7, #0]
 80181d2:	2b00      	cmp	r3, #0
 80181d4:	d101      	bne.n	80181da <rt_can_read+0x2a>
 80181d6:	2300      	movs	r3, #0
 80181d8:	e014      	b.n	8018204 <rt_can_read+0x54>

    can = (struct rt_can_device *)dev;
 80181da:	68fb      	ldr	r3, [r7, #12]
 80181dc:	617b      	str	r3, [r7, #20]

    if ((dev->open_flag & RT_DEVICE_FLAG_INT_RX) && (dev->ref_count > 0))
 80181de:	68fb      	ldr	r3, [r7, #12]
 80181e0:	8b1b      	ldrh	r3, [r3, #24]
 80181e2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80181e6:	2b00      	cmp	r3, #0
 80181e8:	d00b      	beq.n	8018202 <rt_can_read+0x52>
 80181ea:	68fb      	ldr	r3, [r7, #12]
 80181ec:	7e9b      	ldrb	r3, [r3, #26]
 80181ee:	2b00      	cmp	r3, #0
 80181f0:	d007      	beq.n	8018202 <rt_can_read+0x52>
    {
        return _can_int_rx(can, buffer, size);
 80181f2:	683b      	ldr	r3, [r7, #0]
 80181f4:	6978      	ldr	r0, [r7, #20]
 80181f6:	6879      	ldr	r1, [r7, #4]
 80181f8:	461a      	mov	r2, r3
 80181fa:	f7ff fc09 	bl	8017a10 <_can_int_rx>
 80181fe:	4603      	mov	r3, r0
 8018200:	e000      	b.n	8018204 <rt_can_read+0x54>
    }

    return 0;
 8018202:	2300      	movs	r3, #0
}
 8018204:	4618      	mov	r0, r3
 8018206:	3718      	adds	r7, #24
 8018208:	46bd      	mov	sp, r7
 801820a:	bd80      	pop	{r7, pc}
 801820c:	08023704 	.word	0x08023704
 8018210:	0802542c 	.word	0x0802542c

08018214 <rt_can_write>:

static rt_size_t rt_can_write(struct rt_device *dev,
                              rt_off_t          pos,
                              const void       *buffer,
                              rt_size_t         size)
{
 8018214:	b580      	push	{r7, lr}
 8018216:	b086      	sub	sp, #24
 8018218:	af00      	add	r7, sp, #0
 801821a:	60f8      	str	r0, [r7, #12]
 801821c:	60b9      	str	r1, [r7, #8]
 801821e:	607a      	str	r2, [r7, #4]
 8018220:	603b      	str	r3, [r7, #0]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 8018222:	68fb      	ldr	r3, [r7, #12]
 8018224:	2b00      	cmp	r3, #0
 8018226:	d105      	bne.n	8018234 <rt_can_write+0x20>
 8018228:	481b      	ldr	r0, [pc, #108]	; (8018298 <rt_can_write+0x84>)
 801822a:	491c      	ldr	r1, [pc, #112]	; (801829c <rt_can_write+0x88>)
 801822c:	f44f 72f2 	mov.w	r2, #484	; 0x1e4
 8018230:	f7fb fd98 	bl	8013d64 <rt_assert_handler>
    if (size == 0) return 0;
 8018234:	683b      	ldr	r3, [r7, #0]
 8018236:	2b00      	cmp	r3, #0
 8018238:	d101      	bne.n	801823e <rt_can_write+0x2a>
 801823a:	2300      	movs	r3, #0
 801823c:	e028      	b.n	8018290 <rt_can_write+0x7c>

    can = (struct rt_can_device *)dev;
 801823e:	68fb      	ldr	r3, [r7, #12]
 8018240:	617b      	str	r3, [r7, #20]

    if ((dev->open_flag & RT_DEVICE_FLAG_INT_TX) && (dev->ref_count > 0))
 8018242:	68fb      	ldr	r3, [r7, #12]
 8018244:	8b1b      	ldrh	r3, [r3, #24]
 8018246:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801824a:	2b00      	cmp	r3, #0
 801824c:	d018      	beq.n	8018280 <rt_can_write+0x6c>
 801824e:	68fb      	ldr	r3, [r7, #12]
 8018250:	7e9b      	ldrb	r3, [r3, #26]
 8018252:	2b00      	cmp	r3, #0
 8018254:	d014      	beq.n	8018280 <rt_can_write+0x6c>
    {
        if (can->config.privmode)
 8018256:	697b      	ldr	r3, [r7, #20]
 8018258:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 801825c:	2b00      	cmp	r3, #0
 801825e:	d007      	beq.n	8018270 <rt_can_write+0x5c>
        {
            return _can_int_tx_priv(can, buffer, size);
 8018260:	683b      	ldr	r3, [r7, #0]
 8018262:	6978      	ldr	r0, [r7, #20]
 8018264:	6879      	ldr	r1, [r7, #4]
 8018266:	461a      	mov	r2, r3
 8018268:	f7ff fd22 	bl	8017cb0 <_can_int_tx_priv>
 801826c:	4603      	mov	r3, r0
 801826e:	e00f      	b.n	8018290 <rt_can_write+0x7c>
        }
        else
        {
            return _can_int_tx(can, buffer, size);
 8018270:	683b      	ldr	r3, [r7, #0]
 8018272:	6978      	ldr	r0, [r7, #20]
 8018274:	6879      	ldr	r1, [r7, #4]
 8018276:	461a      	mov	r2, r3
 8018278:	f7ff fc48 	bl	8017b0c <_can_int_tx>
 801827c:	4603      	mov	r3, r0
 801827e:	e007      	b.n	8018290 <rt_can_write+0x7c>
        }
    }
	else
		//stm32_CANsendmsg(can, buffer, size);
		return can->ops->sendmsg(can, buffer, size);
 8018280:	697b      	ldr	r3, [r7, #20]
 8018282:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8018284:	689b      	ldr	r3, [r3, #8]
 8018286:	6978      	ldr	r0, [r7, #20]
 8018288:	6879      	ldr	r1, [r7, #4]
 801828a:	683a      	ldr	r2, [r7, #0]
 801828c:	4798      	blx	r3
 801828e:	4603      	mov	r3, r0
    return 0;
}
 8018290:	4618      	mov	r0, r3
 8018292:	3718      	adds	r7, #24
 8018294:	46bd      	mov	sp, r7
 8018296:	bd80      	pop	{r7, pc}
 8018298:	08023704 	.word	0x08023704
 801829c:	08025444 	.word	0x08025444

080182a0 <rt_can_control>:

static rt_err_t rt_can_control(struct rt_device *dev,
                               rt_uint8_t        cmd,
                               void             *args)
{
 80182a0:	b580      	push	{r7, lr}
 80182a2:	b08a      	sub	sp, #40	; 0x28
 80182a4:	af00      	add	r7, sp, #0
 80182a6:	60f8      	str	r0, [r7, #12]
 80182a8:	460b      	mov	r3, r1
 80182aa:	607a      	str	r2, [r7, #4]
 80182ac:	72fb      	strb	r3, [r7, #11]
    struct rt_can_device *can;
    rt_err_t res;

    RT_ASSERT(dev != RT_NULL);
 80182ae:	68fb      	ldr	r3, [r7, #12]
 80182b0:	2b00      	cmp	r3, #0
 80182b2:	d105      	bne.n	80182c0 <rt_can_control+0x20>
 80182b4:	4870      	ldr	r0, [pc, #448]	; (8018478 <rt_can_control+0x1d8>)
 80182b6:	4971      	ldr	r1, [pc, #452]	; (801847c <rt_can_control+0x1dc>)
 80182b8:	f240 2201 	movw	r2, #513	; 0x201
 80182bc:	f7fb fd52 	bl	8013d64 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 80182c0:	68fb      	ldr	r3, [r7, #12]
 80182c2:	623b      	str	r3, [r7, #32]

    switch (cmd)
 80182c4:	7afb      	ldrb	r3, [r7, #11]
 80182c6:	3b01      	subs	r3, #1
 80182c8:	2b17      	cmp	r3, #23
 80182ca:	f200 80c1 	bhi.w	8018450 <rt_can_control+0x1b0>
 80182ce:	a201      	add	r2, pc, #4	; (adr r2, 80182d4 <rt_can_control+0x34>)
 80182d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80182d4:	08018345 	.word	0x08018345
 80182d8:	08018335 	.word	0x08018335
 80182dc:	08018355 	.word	0x08018355
 80182e0:	08018451 	.word	0x08018451
 80182e4:	08018451 	.word	0x08018451
 80182e8:	08018451 	.word	0x08018451
 80182ec:	08018451 	.word	0x08018451
 80182f0:	08018451 	.word	0x08018451
 80182f4:	08018451 	.word	0x08018451
 80182f8:	08018451 	.word	0x08018451
 80182fc:	08018451 	.word	0x08018451
 8018300:	08018451 	.word	0x08018451
 8018304:	08018451 	.word	0x08018451
 8018308:	08018451 	.word	0x08018451
 801830c:	08018451 	.word	0x08018451
 8018310:	08018451 	.word	0x08018451
 8018314:	08018451 	.word	0x08018451
 8018318:	08018451 	.word	0x08018451
 801831c:	08018451 	.word	0x08018451
 8018320:	08018451 	.word	0x08018451
 8018324:	08018451 	.word	0x08018451
 8018328:	08018363 	.word	0x08018363
 801832c:	08018451 	.word	0x08018451
 8018330:	0801843b 	.word	0x0801843b
    {
    case RT_DEVICE_CTRL_SUSPEND:
        /* suspend device */
        dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
 8018334:	68fb      	ldr	r3, [r7, #12]
 8018336:	8adb      	ldrh	r3, [r3, #22]
 8018338:	f043 0320 	orr.w	r3, r3, #32
 801833c:	b29a      	uxth	r2, r3
 801833e:	68fb      	ldr	r3, [r7, #12]
 8018340:	82da      	strh	r2, [r3, #22]
        break;
 8018342:	e094      	b.n	801846e <rt_can_control+0x1ce>

    case RT_DEVICE_CTRL_RESUME:
        /* resume device */
        dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
 8018344:	68fb      	ldr	r3, [r7, #12]
 8018346:	8adb      	ldrh	r3, [r3, #22]
 8018348:	f023 0320 	bic.w	r3, r3, #32
 801834c:	b29a      	uxth	r2, r3
 801834e:	68fb      	ldr	r3, [r7, #12]
 8018350:	82da      	strh	r2, [r3, #22]
        break;
 8018352:	e08c      	b.n	801846e <rt_can_control+0x1ce>

    case RT_DEVICE_CTRL_CONFIG:
        /* configure device */
        can->ops->configure(can, (struct can_configure *)args);
 8018354:	6a3b      	ldr	r3, [r7, #32]
 8018356:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8018358:	681b      	ldr	r3, [r3, #0]
 801835a:	6a38      	ldr	r0, [r7, #32]
 801835c:	6879      	ldr	r1, [r7, #4]
 801835e:	4798      	blx	r3
        break;
 8018360:	e085      	b.n	801846e <rt_can_control+0x1ce>
    case RT_CAN_CMD_SET_PRIV:
        /* configure device */
        if ((rt_uint32_t)args != can->config.privmode)
 8018362:	687b      	ldr	r3, [r7, #4]
 8018364:	6a3a      	ldr	r2, [r7, #32]
 8018366:	f892 2051 	ldrb.w	r2, [r2, #81]	; 0x51
 801836a:	4293      	cmp	r3, r2
 801836c:	d064      	beq.n	8018438 <rt_can_control+0x198>
        {
            int i;
            rt_base_t level;
            struct rt_can_tx_fifo *tx_fifo;

            res = can->ops->control(can, cmd, args);
 801836e:	6a3b      	ldr	r3, [r7, #32]
 8018370:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8018372:	685b      	ldr	r3, [r3, #4]
 8018374:	7afa      	ldrb	r2, [r7, #11]
 8018376:	6a38      	ldr	r0, [r7, #32]
 8018378:	4611      	mov	r1, r2
 801837a:	687a      	ldr	r2, [r7, #4]
 801837c:	4798      	blx	r3
 801837e:	61f8      	str	r0, [r7, #28]
            if (res != RT_EOK) return res;
 8018380:	69fb      	ldr	r3, [r7, #28]
 8018382:	2b00      	cmp	r3, #0
 8018384:	d001      	beq.n	801838a <rt_can_control+0xea>
 8018386:	69fb      	ldr	r3, [r7, #28]
 8018388:	e072      	b.n	8018470 <rt_can_control+0x1d0>

            tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 801838a:	6a3b      	ldr	r3, [r7, #32]
 801838c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8018390:	61bb      	str	r3, [r7, #24]
            if (can->config.privmode)
 8018392:	6a3b      	ldr	r3, [r7, #32]
 8018394:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8018398:	2b00      	cmp	r3, #0
 801839a:	d021      	beq.n	80183e0 <rt_can_control+0x140>
            {
                rt_completion_done(&(tx_fifo->completion));
 801839c:	69bb      	ldr	r3, [r7, #24]
 801839e:	3304      	adds	r3, #4
 80183a0:	4618      	mov	r0, r3
 80183a2:	f7fd fed7 	bl	8016154 <rt_completion_done>

                for (i = 0;  i < can->config.sndboxnumber; i++)
 80183a6:	2300      	movs	r3, #0
 80183a8:	627b      	str	r3, [r7, #36]	; 0x24
 80183aa:	e013      	b.n	80183d4 <rt_can_control+0x134>
                {
		    level = rt_hw_interrupt_disable();
 80183ac:	f7e7 ff0c 	bl	80001c8 <rt_hw_interrupt_disable>
 80183b0:	6178      	str	r0, [r7, #20]
                    rt_list_remove(&tx_fifo->buffer[i].list);
 80183b2:	69bb      	ldr	r3, [r7, #24]
 80183b4:	6819      	ldr	r1, [r3, #0]
 80183b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80183b8:	4613      	mov	r3, r2
 80183ba:	005b      	lsls	r3, r3, #1
 80183bc:	4413      	add	r3, r2
 80183be:	00db      	lsls	r3, r3, #3
 80183c0:	440b      	add	r3, r1
 80183c2:	4618      	mov	r0, r3
 80183c4:	f7ff fac8 	bl	8017958 <rt_list_remove>
                    rt_hw_interrupt_enable(level);
 80183c8:	6978      	ldr	r0, [r7, #20]
 80183ca:	f7e7 ff01 	bl	80001d0 <rt_hw_interrupt_enable>
            tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
            if (can->config.privmode)
            {
                rt_completion_done(&(tx_fifo->completion));

                for (i = 0;  i < can->config.sndboxnumber; i++)
 80183ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80183d0:	3301      	adds	r3, #1
 80183d2:	627b      	str	r3, [r7, #36]	; 0x24
 80183d4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80183d6:	6a3b      	ldr	r3, [r7, #32]
 80183d8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80183da:	429a      	cmp	r2, r3
 80183dc:	d3e6      	bcc.n	80183ac <rt_can_control+0x10c>
 80183de:	e029      	b.n	8018434 <rt_can_control+0x194>
                    rt_hw_interrupt_enable(level);
                }
            }
            else
            {
                for (i = 0;  i < can->config.sndboxnumber; i++)
 80183e0:	2300      	movs	r3, #0
 80183e2:	627b      	str	r3, [r7, #36]	; 0x24
 80183e4:	e021      	b.n	801842a <rt_can_control+0x18a>
                {
                    level = rt_hw_interrupt_disable();
 80183e6:	f7e7 feef 	bl	80001c8 <rt_hw_interrupt_disable>
 80183ea:	6178      	str	r0, [r7, #20]
                    if (tx_fifo->buffer[i].result == RT_CAN_SND_RESULT_OK)
 80183ec:	69bb      	ldr	r3, [r7, #24]
 80183ee:	6819      	ldr	r1, [r3, #0]
 80183f0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80183f2:	4613      	mov	r3, r2
 80183f4:	005b      	lsls	r3, r3, #1
 80183f6:	4413      	add	r3, r2
 80183f8:	00db      	lsls	r3, r3, #3
 80183fa:	440b      	add	r3, r1
 80183fc:	695b      	ldr	r3, [r3, #20]
 80183fe:	2b00      	cmp	r3, #0
 8018400:	d10d      	bne.n	801841e <rt_can_control+0x17e>
                    {
                        rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
 8018402:	69bb      	ldr	r3, [r7, #24]
 8018404:	f103 0010 	add.w	r0, r3, #16
 8018408:	69bb      	ldr	r3, [r7, #24]
 801840a:	6819      	ldr	r1, [r3, #0]
 801840c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801840e:	4613      	mov	r3, r2
 8018410:	005b      	lsls	r3, r3, #1
 8018412:	4413      	add	r3, r2
 8018414:	00db      	lsls	r3, r3, #3
 8018416:	440b      	add	r3, r1
 8018418:	4619      	mov	r1, r3
 801841a:	f7ff fa85 	bl	8017928 <rt_list_insert_before>
                    }
                    rt_hw_interrupt_enable(level);
 801841e:	6978      	ldr	r0, [r7, #20]
 8018420:	f7e7 fed6 	bl	80001d0 <rt_hw_interrupt_enable>
                    rt_hw_interrupt_enable(level);
                }
            }
            else
            {
                for (i = 0;  i < can->config.sndboxnumber; i++)
 8018424:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018426:	3301      	adds	r3, #1
 8018428:	627b      	str	r3, [r7, #36]	; 0x24
 801842a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801842c:	6a3b      	ldr	r3, [r7, #32]
 801842e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8018430:	429a      	cmp	r2, r3
 8018432:	d3d8      	bcc.n	80183e6 <rt_can_control+0x146>
                        rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
                    }
                    rt_hw_interrupt_enable(level);
                }
            }
            return RT_EOK;
 8018434:	2300      	movs	r3, #0
 8018436:	e01b      	b.n	8018470 <rt_can_control+0x1d0>
        }
        break;
 8018438:	e019      	b.n	801846e <rt_can_control+0x1ce>

    case RT_CAN_CMD_SET_STATUS_IND:
        can->status_indicate.ind = ((rt_can_status_ind_type_t)args)->ind;
 801843a:	687b      	ldr	r3, [r7, #4]
 801843c:	681a      	ldr	r2, [r3, #0]
 801843e:	6a3b      	ldr	r3, [r7, #32]
 8018440:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
        can->status_indicate.args = ((rt_can_status_ind_type_t)args)->args;
 8018444:	687b      	ldr	r3, [r7, #4]
 8018446:	685a      	ldr	r2, [r3, #4]
 8018448:	6a3b      	ldr	r3, [r7, #32]
 801844a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        break;
 801844e:	e00e      	b.n	801846e <rt_can_control+0x1ce>
        can->bus_hook = (rt_can_bus_hook) args;
        break;
#endif /*RT_CAN_USING_BUS_HOOK*/
    default :
        /* control device */
        if (can->ops->control != RT_NULL)
 8018450:	6a3b      	ldr	r3, [r7, #32]
 8018452:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8018454:	685b      	ldr	r3, [r3, #4]
 8018456:	2b00      	cmp	r3, #0
 8018458:	d008      	beq.n	801846c <rt_can_control+0x1cc>
        {
            can->ops->control(can, cmd, args);
 801845a:	6a3b      	ldr	r3, [r7, #32]
 801845c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801845e:	685b      	ldr	r3, [r3, #4]
 8018460:	7afa      	ldrb	r2, [r7, #11]
 8018462:	6a38      	ldr	r0, [r7, #32]
 8018464:	4611      	mov	r1, r2
 8018466:	687a      	ldr	r2, [r7, #4]
 8018468:	4798      	blx	r3
        }
        break;
 801846a:	e7ff      	b.n	801846c <rt_can_control+0x1cc>
 801846c:	bf00      	nop
    }

    return RT_EOK;
 801846e:	2300      	movs	r3, #0
}
 8018470:	4618      	mov	r0, r3
 8018472:	3728      	adds	r7, #40	; 0x28
 8018474:	46bd      	mov	sp, r7
 8018476:	bd80      	pop	{r7, pc}
 8018478:	08023704 	.word	0x08023704
 801847c:	08025474 	.word	0x08025474

08018480 <cantimeout>:

/*
 * can timer
 */
static void cantimeout(void *arg)
{
 8018480:	b580      	push	{r7, lr}
 8018482:	b084      	sub	sp, #16
 8018484:	af00      	add	r7, sp, #0
 8018486:	6078      	str	r0, [r7, #4]
    rt_can_t can = (rt_can_t)arg;
 8018488:	687b      	ldr	r3, [r7, #4]
 801848a:	60fb      	str	r3, [r7, #12]

    rt_device_control((rt_device_t)can, RT_CAN_CMD_GET_STATUS, (void *)&can->status);
 801848c:	68fb      	ldr	r3, [r7, #12]
 801848e:	3358      	adds	r3, #88	; 0x58
 8018490:	68f8      	ldr	r0, [r7, #12]
 8018492:	2117      	movs	r1, #23
 8018494:	461a      	mov	r2, r3
 8018496:	f7f9 feb3 	bl	8012200 <rt_device_control>

    if (can->status_indicate.ind != RT_NULL)
 801849a:	68fb      	ldr	r3, [r7, #12]
 801849c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80184a0:	2b00      	cmp	r3, #0
 80184a2:	d008      	beq.n	80184b6 <cantimeout+0x36>
    {
        can->status_indicate.ind(can, can->status_indicate.args);
 80184a4:	68fb      	ldr	r3, [r7, #12]
 80184a6:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80184aa:	68fa      	ldr	r2, [r7, #12]
 80184ac:	f8d2 20c8 	ldr.w	r2, [r2, #200]	; 0xc8
 80184b0:	68f8      	ldr	r0, [r7, #12]
 80184b2:	4611      	mov	r1, r2
 80184b4:	4798      	blx	r3
    if(can->bus_hook)
    {
        can->bus_hook(can);
    }
#endif /*RT_CAN_USING_BUS_HOOK*/
    if (can->timerinitflag == 1)
 80184b6:	68fb      	ldr	r3, [r7, #12]
 80184b8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80184bc:	2b01      	cmp	r3, #1
 80184be:	d103      	bne.n	80184c8 <cantimeout+0x48>
    {
        can->timerinitflag = 0xFF;
 80184c0:	68fb      	ldr	r3, [r7, #12]
 80184c2:	22ff      	movs	r2, #255	; 0xff
 80184c4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    }
}
 80184c8:	3710      	adds	r7, #16
 80184ca:	46bd      	mov	sp, r7
 80184cc:	bd80      	pop	{r7, pc}
 80184ce:	bf00      	nop

080184d0 <rt_hw_can_register>:
 */
rt_err_t rt_hw_can_register(struct rt_can_device *can,
                            const char              *name,
                            const struct rt_can_ops *ops,
                            void                    *data)
{
 80184d0:	b580      	push	{r7, lr}
 80184d2:	b088      	sub	sp, #32
 80184d4:	af02      	add	r7, sp, #8
 80184d6:	60f8      	str	r0, [r7, #12]
 80184d8:	60b9      	str	r1, [r7, #8]
 80184da:	607a      	str	r2, [r7, #4]
 80184dc:	603b      	str	r3, [r7, #0]
    struct rt_device *device;
    RT_ASSERT(can != RT_NULL);
 80184de:	68fb      	ldr	r3, [r7, #12]
 80184e0:	2b00      	cmp	r3, #0
 80184e2:	d105      	bne.n	80184f0 <rt_hw_can_register+0x20>
 80184e4:	4831      	ldr	r0, [pc, #196]	; (80185ac <rt_hw_can_register+0xdc>)
 80184e6:	4932      	ldr	r1, [pc, #200]	; (80185b0 <rt_hw_can_register+0xe0>)
 80184e8:	f240 22c3 	movw	r2, #707	; 0x2c3
 80184ec:	f7fb fc3a 	bl	8013d64 <rt_assert_handler>

    device = &(can->parent);
 80184f0:	68fb      	ldr	r3, [r7, #12]
 80184f2:	617b      	str	r3, [r7, #20]

    device->type        = RT_Device_Class_CAN;
 80184f4:	697b      	ldr	r3, [r7, #20]
 80184f6:	2204      	movs	r2, #4
 80184f8:	751a      	strb	r2, [r3, #20]
    device->rx_indicate = RT_NULL;
 80184fa:	697b      	ldr	r3, [r7, #20]
 80184fc:	2200      	movs	r2, #0
 80184fe:	61da      	str	r2, [r3, #28]
    device->tx_complete = RT_NULL;
 8018500:	697b      	ldr	r3, [r7, #20]
 8018502:	2200      	movs	r2, #0
 8018504:	621a      	str	r2, [r3, #32]
#ifdef RT_CAN_USING_HDR
    can->hdr            = RT_NULL;
#endif
    can->can_rx         = RT_NULL;
 8018506:	68fb      	ldr	r3, [r7, #12]
 8018508:	2200      	movs	r2, #0
 801850a:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    can->can_tx         = RT_NULL;
 801850e:	68fb      	ldr	r3, [r7, #12]
 8018510:	2200      	movs	r2, #0
 8018512:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    rt_mutex_init(&(can->lock), "can", RT_IPC_FLAG_PRIO);
 8018516:	68fb      	ldr	r3, [r7, #12]
 8018518:	33cc      	adds	r3, #204	; 0xcc
 801851a:	4618      	mov	r0, r3
 801851c:	4925      	ldr	r1, [pc, #148]	; (80185b4 <rt_hw_can_register+0xe4>)
 801851e:	2201      	movs	r2, #1
 8018520:	f7fa f96a 	bl	80127f8 <rt_mutex_init>
#ifdef RT_CAN_USING_BUS_HOOK
    can->bus_hook       = RT_NULL;
#endif /*RT_CAN_USING_BUS_HOOK*/
    device->init        = rt_can_init;
 8018524:	697b      	ldr	r3, [r7, #20]
 8018526:	4a24      	ldr	r2, [pc, #144]	; (80185b8 <rt_hw_can_register+0xe8>)
 8018528:	625a      	str	r2, [r3, #36]	; 0x24
    device->open        = rt_can_open;
 801852a:	697b      	ldr	r3, [r7, #20]
 801852c:	4a23      	ldr	r2, [pc, #140]	; (80185bc <rt_hw_can_register+0xec>)
 801852e:	629a      	str	r2, [r3, #40]	; 0x28
    device->close       = rt_can_close;
 8018530:	697b      	ldr	r3, [r7, #20]
 8018532:	4a23      	ldr	r2, [pc, #140]	; (80185c0 <rt_hw_can_register+0xf0>)
 8018534:	62da      	str	r2, [r3, #44]	; 0x2c
    device->read        = rt_can_read;
 8018536:	697b      	ldr	r3, [r7, #20]
 8018538:	4a22      	ldr	r2, [pc, #136]	; (80185c4 <rt_hw_can_register+0xf4>)
 801853a:	631a      	str	r2, [r3, #48]	; 0x30
    device->write       = rt_can_write;
 801853c:	697b      	ldr	r3, [r7, #20]
 801853e:	4a22      	ldr	r2, [pc, #136]	; (80185c8 <rt_hw_can_register+0xf8>)
 8018540:	635a      	str	r2, [r3, #52]	; 0x34
    device->control     = rt_can_control;
 8018542:	697b      	ldr	r3, [r7, #20]
 8018544:	4a21      	ldr	r2, [pc, #132]	; (80185cc <rt_hw_can_register+0xfc>)
 8018546:	639a      	str	r2, [r3, #56]	; 0x38
    can->ops            = ops;
 8018548:	68fb      	ldr	r3, [r7, #12]
 801854a:	687a      	ldr	r2, [r7, #4]
 801854c:	641a      	str	r2, [r3, #64]	; 0x40

    can->status_indicate.ind  = RT_NULL;
 801854e:	68fb      	ldr	r3, [r7, #12]
 8018550:	2200      	movs	r2, #0
 8018552:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    can->status_indicate.args = RT_NULL;
 8018556:	68fb      	ldr	r3, [r7, #12]
 8018558:	2200      	movs	r2, #0
 801855a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    rt_memset(&can->status, 0, sizeof(can->status));
 801855e:	68fb      	ldr	r3, [r7, #12]
 8018560:	3358      	adds	r3, #88	; 0x58
 8018562:	4618      	mov	r0, r3
 8018564:	2100      	movs	r1, #0
 8018566:	223c      	movs	r2, #60	; 0x3c
 8018568:	f7fa fdca 	bl	8013100 <rt_memset>

    device->user_data   = data;
 801856c:	697b      	ldr	r3, [r7, #20]
 801856e:	683a      	ldr	r2, [r7, #0]
 8018570:	63da      	str	r2, [r3, #60]	; 0x3c

    can->timerinitflag  = 0;
 8018572:	68fb      	ldr	r3, [r7, #12]
 8018574:	2200      	movs	r2, #0
 8018576:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    rt_timer_init(&can->timer,
 801857a:	68fb      	ldr	r3, [r7, #12]
 801857c:	f103 0298 	add.w	r2, r3, #152	; 0x98
 8018580:	68fb      	ldr	r3, [r7, #12]
 8018582:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8018584:	9300      	str	r3, [sp, #0]
 8018586:	2302      	movs	r3, #2
 8018588:	9301      	str	r3, [sp, #4]
 801858a:	4610      	mov	r0, r2
 801858c:	68b9      	ldr	r1, [r7, #8]
 801858e:	4a10      	ldr	r2, [pc, #64]	; (80185d0 <rt_hw_can_register+0x100>)
 8018590:	68fb      	ldr	r3, [r7, #12]
 8018592:	f7fc ffcb 	bl	801552c <rt_timer_init>
                  cantimeout,
                  (void *)can,
                  can->config.ticks,
                  RT_TIMER_FLAG_PERIODIC);
    /* register a character device */
    return rt_device_register(device, name, RT_DEVICE_FLAG_RDWR);
 8018596:	6978      	ldr	r0, [r7, #20]
 8018598:	68b9      	ldr	r1, [r7, #8]
 801859a:	2203      	movs	r2, #3
 801859c:	f7f9 fcb2 	bl	8011f04 <rt_device_register>
 80185a0:	4603      	mov	r3, r0
}
 80185a2:	4618      	mov	r0, r3
 80185a4:	3718      	adds	r7, #24
 80185a6:	46bd      	mov	sp, r7
 80185a8:	bd80      	pop	{r7, pc}
 80185aa:	bf00      	nop
 80185ac:	08023714 	.word	0x08023714
 80185b0:	08025484 	.word	0x08025484
 80185b4:	08023790 	.word	0x08023790
 80185b8:	080179b1 	.word	0x080179b1
 80185bc:	08017e11 	.word	0x08017e11
 80185c0:	08018079 	.word	0x08018079
 80185c4:	080181b1 	.word	0x080181b1
 80185c8:	08018215 	.word	0x08018215
 80185cc:	080182a1 	.word	0x080182a1
 80185d0:	08018481 	.word	0x08018481

080185d4 <cmd_canstat>:
}

#ifdef RT_USING_FINSH
#include <finsh.h>
int cmd_canstat(int argc, void **argv)
{
 80185d4:	b580      	push	{r7, lr}
 80185d6:	b092      	sub	sp, #72	; 0x48
 80185d8:	af00      	add	r7, sp, #0
 80185da:	6078      	str	r0, [r7, #4]
 80185dc:	6039      	str	r1, [r7, #0]
        "Warning !",
        "Passive !",
        "Bus Off !"
    };

    if (argc >= 2)
 80185de:	687b      	ldr	r3, [r7, #4]
 80185e0:	2b01      	cmp	r3, #1
 80185e2:	f340 8082 	ble.w	80186ea <cmd_canstat+0x116>
    {
        struct rt_can_status status;
        rt_device_t candev = rt_device_find(argv[1]);
 80185e6:	683b      	ldr	r3, [r7, #0]
 80185e8:	3304      	adds	r3, #4
 80185ea:	681b      	ldr	r3, [r3, #0]
 80185ec:	4618      	mov	r0, r3
 80185ee:	f7f9 fcb1 	bl	8011f54 <rt_device_find>
 80185f2:	6478      	str	r0, [r7, #68]	; 0x44
        if (!candev)
 80185f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80185f6:	2b00      	cmp	r3, #0
 80185f8:	d109      	bne.n	801860e <cmd_canstat+0x3a>
        {
            rt_kprintf(" Can't find can device %s\n", argv[1]);
 80185fa:	683b      	ldr	r3, [r7, #0]
 80185fc:	3304      	adds	r3, #4
 80185fe:	681b      	ldr	r3, [r3, #0]
 8018600:	4842      	ldr	r0, [pc, #264]	; (801870c <cmd_canstat+0x138>)
 8018602:	4619      	mov	r1, r3
 8018604:	f7fb fb34 	bl	8013c70 <rt_kprintf>
            return -1;
 8018608:	f04f 33ff 	mov.w	r3, #4294967295
 801860c:	e07a      	b.n	8018704 <cmd_canstat+0x130>
        }
        rt_kprintf(" Finded can device: %s...", argv[1]);
 801860e:	683b      	ldr	r3, [r7, #0]
 8018610:	3304      	adds	r3, #4
 8018612:	681b      	ldr	r3, [r3, #0]
 8018614:	483e      	ldr	r0, [pc, #248]	; (8018710 <cmd_canstat+0x13c>)
 8018616:	4619      	mov	r1, r3
 8018618:	f7fb fb2a 	bl	8013c70 <rt_kprintf>

        rt_device_control(candev, RT_CAN_CMD_GET_STATUS, &status);
 801861c:	f107 0308 	add.w	r3, r7, #8
 8018620:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8018622:	2117      	movs	r1, #23
 8018624:	461a      	mov	r2, r3
 8018626:	f7f9 fdeb 	bl	8012200 <rt_device_control>
        rt_kprintf("\n Receive...error..count: %010ld. Send.....error....count: %010ld.",
 801862a:	68ba      	ldr	r2, [r7, #8]
 801862c:	68fb      	ldr	r3, [r7, #12]
 801862e:	4839      	ldr	r0, [pc, #228]	; (8018714 <cmd_canstat+0x140>)
 8018630:	4611      	mov	r1, r2
 8018632:	461a      	mov	r2, r3
 8018634:	f7fb fb1c 	bl	8013c70 <rt_kprintf>
                   status.rcverrcnt, status.snderrcnt);
        rt_kprintf("\n Bit..pad..error..count: %010ld. Format...error....count: %010ld",
 8018638:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801863a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801863c:	4836      	ldr	r0, [pc, #216]	; (8018718 <cmd_canstat+0x144>)
 801863e:	4611      	mov	r1, r2
 8018640:	461a      	mov	r2, r3
 8018642:	f7fb fb15 	bl	8013c70 <rt_kprintf>
                   status.bitpaderrcnt, status.formaterrcnt);
        rt_kprintf("\n Ack.......error..count: %010ld. Bit......error....count: %010ld.",
 8018646:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8018648:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801864a:	4834      	ldr	r0, [pc, #208]	; (801871c <cmd_canstat+0x148>)
 801864c:	4611      	mov	r1, r2
 801864e:	461a      	mov	r2, r3
 8018650:	f7fb fb0e 	bl	8013c70 <rt_kprintf>
                   status.ackerrcnt, status.biterrcnt);
        rt_kprintf("\n CRC.......error..count: %010ld. Error.code.[%010ld]: ",
 8018654:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8018656:	693b      	ldr	r3, [r7, #16]
 8018658:	4831      	ldr	r0, [pc, #196]	; (8018720 <cmd_canstat+0x14c>)
 801865a:	4611      	mov	r1, r2
 801865c:	461a      	mov	r2, r3
 801865e:	f7fb fb07 	bl	8013c70 <rt_kprintf>
                   status.crcerrcnt, status.errcode);
        switch (status.errcode)
 8018662:	693b      	ldr	r3, [r7, #16]
 8018664:	2b07      	cmp	r3, #7
 8018666:	d82f      	bhi.n	80186c8 <cmd_canstat+0xf4>
 8018668:	a201      	add	r2, pc, #4	; (adr r2, 8018670 <cmd_canstat+0x9c>)
 801866a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801866e:	bf00      	nop
 8018670:	08018691 	.word	0x08018691
 8018674:	0801869f 	.word	0x0801869f
 8018678:	080186ad 	.word	0x080186ad
 801867c:	080186ad 	.word	0x080186ad
 8018680:	080186bb 	.word	0x080186bb
 8018684:	080186bb 	.word	0x080186bb
 8018688:	080186bb 	.word	0x080186bb
 801868c:	080186bb 	.word	0x080186bb
        {
        case 0:
            rt_kprintf("%s.", ErrCode[0]);
 8018690:	4b24      	ldr	r3, [pc, #144]	; (8018724 <cmd_canstat+0x150>)
 8018692:	681b      	ldr	r3, [r3, #0]
 8018694:	4824      	ldr	r0, [pc, #144]	; (8018728 <cmd_canstat+0x154>)
 8018696:	4619      	mov	r1, r3
 8018698:	f7fb faea 	bl	8013c70 <rt_kprintf>
            break;
 801869c:	e014      	b.n	80186c8 <cmd_canstat+0xf4>
        case 1:
            rt_kprintf("%s.", ErrCode[1]);
 801869e:	4b21      	ldr	r3, [pc, #132]	; (8018724 <cmd_canstat+0x150>)
 80186a0:	685b      	ldr	r3, [r3, #4]
 80186a2:	4821      	ldr	r0, [pc, #132]	; (8018728 <cmd_canstat+0x154>)
 80186a4:	4619      	mov	r1, r3
 80186a6:	f7fb fae3 	bl	8013c70 <rt_kprintf>
            break;
 80186aa:	e00d      	b.n	80186c8 <cmd_canstat+0xf4>
        case 2:
        case 3:
            rt_kprintf("%s.", ErrCode[2]);
 80186ac:	4b1d      	ldr	r3, [pc, #116]	; (8018724 <cmd_canstat+0x150>)
 80186ae:	689b      	ldr	r3, [r3, #8]
 80186b0:	481d      	ldr	r0, [pc, #116]	; (8018728 <cmd_canstat+0x154>)
 80186b2:	4619      	mov	r1, r3
 80186b4:	f7fb fadc 	bl	8013c70 <rt_kprintf>
            break;
 80186b8:	e006      	b.n	80186c8 <cmd_canstat+0xf4>
        case 4:
        case 5:
        case 6:
        case 7:
            rt_kprintf("%s.", ErrCode[3]);
 80186ba:	4b1a      	ldr	r3, [pc, #104]	; (8018724 <cmd_canstat+0x150>)
 80186bc:	68db      	ldr	r3, [r3, #12]
 80186be:	481a      	ldr	r0, [pc, #104]	; (8018728 <cmd_canstat+0x154>)
 80186c0:	4619      	mov	r1, r3
 80186c2:	f7fb fad5 	bl	8013c70 <rt_kprintf>
            break;
 80186c6:	bf00      	nop
        }
        rt_kprintf("\n Total.receive.packages: %010ld. Droped.receive.packages: %010ld.",
 80186c8:	697a      	ldr	r2, [r7, #20]
 80186ca:	69bb      	ldr	r3, [r7, #24]
 80186cc:	4817      	ldr	r0, [pc, #92]	; (801872c <cmd_canstat+0x158>)
 80186ce:	4611      	mov	r1, r2
 80186d0:	461a      	mov	r2, r3
 80186d2:	f7fb facd 	bl	8013c70 <rt_kprintf>
                   status.rcvpkg, status.dropedrcvpkg);
        rt_kprintf("\n Total..send...packages: %010ld. Droped...send..packages: %010ld.\n",
                   status.sndpkg + status.dropedsndpkg, status.dropedsndpkg);
 80186d6:	69fa      	ldr	r2, [r7, #28]
 80186d8:	6a3b      	ldr	r3, [r7, #32]
            rt_kprintf("%s.", ErrCode[3]);
            break;
        }
        rt_kprintf("\n Total.receive.packages: %010ld. Droped.receive.packages: %010ld.",
                   status.rcvpkg, status.dropedrcvpkg);
        rt_kprintf("\n Total..send...packages: %010ld. Droped...send..packages: %010ld.\n",
 80186da:	441a      	add	r2, r3
 80186dc:	6a3b      	ldr	r3, [r7, #32]
 80186de:	4814      	ldr	r0, [pc, #80]	; (8018730 <cmd_canstat+0x15c>)
 80186e0:	4611      	mov	r1, r2
 80186e2:	461a      	mov	r2, r3
 80186e4:	f7fb fac4 	bl	8013c70 <rt_kprintf>
 80186e8:	e00b      	b.n	8018702 <cmd_canstat+0x12e>
                   status.sndpkg + status.dropedsndpkg, status.dropedsndpkg);
    }
    else
    {
        rt_kprintf(" Invalid Call %s\n", argv[0]);
 80186ea:	683b      	ldr	r3, [r7, #0]
 80186ec:	681b      	ldr	r3, [r3, #0]
 80186ee:	4811      	ldr	r0, [pc, #68]	; (8018734 <cmd_canstat+0x160>)
 80186f0:	4619      	mov	r1, r3
 80186f2:	f7fb fabd 	bl	8013c70 <rt_kprintf>
        rt_kprintf(" Please using %s cannamex .Here canname is driver name and x is candrive number.\n", argv[0]);
 80186f6:	683b      	ldr	r3, [r7, #0]
 80186f8:	681b      	ldr	r3, [r3, #0]
 80186fa:	480f      	ldr	r0, [pc, #60]	; (8018738 <cmd_canstat+0x164>)
 80186fc:	4619      	mov	r1, r3
 80186fe:	f7fb fab7 	bl	8013c70 <rt_kprintf>
    }
    return 0;
 8018702:	2300      	movs	r3, #0
}
 8018704:	4618      	mov	r0, r3
 8018706:	3748      	adds	r7, #72	; 0x48
 8018708:	46bd      	mov	sp, r7
 801870a:	bd80      	pop	{r7, pc}
 801870c:	080237e0 	.word	0x080237e0
 8018710:	080237fc 	.word	0x080237fc
 8018714:	08023818 	.word	0x08023818
 8018718:	0802385c 	.word	0x0802385c
 801871c:	080238a0 	.word	0x080238a0
 8018720:	080238e4 	.word	0x080238e4
 8018724:	200100b4 	.word	0x200100b4
 8018728:	0802391c 	.word	0x0802391c
 801872c:	08023920 	.word	0x08023920
 8018730:	08023964 	.word	0x08023964
 8018734:	080239a8 	.word	0x080239a8
 8018738:	080239bc 	.word	0x080239bc

0801873c <finsh_get_prompt>:
#if defined(FINSH_USING_MSH) || (defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR))
#if defined(RT_USING_DFS)
#include <dfs_posix.h>
#endif
const char *finsh_get_prompt()
{
 801873c:	b580      	push	{r7, lr}
 801873e:	af00      	add	r7, sp, #0
#define _MSH_PROMPT "msh "
#define _PROMPT     "finsh "
    static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};

#ifdef FINSH_USING_MSH
    if (msh_is_used()) strcpy(finsh_prompt, _MSH_PROMPT);
 8018740:	f001 fb78 	bl	8019e34 <msh_is_used>
 8018744:	4603      	mov	r3, r0
 8018746:	2b00      	cmp	r3, #0
 8018748:	d007      	beq.n	801875a <finsh_get_prompt+0x1e>
 801874a:	4b10      	ldr	r3, [pc, #64]	; (801878c <finsh_get_prompt+0x50>)
 801874c:	4a10      	ldr	r2, [pc, #64]	; (8018790 <finsh_get_prompt+0x54>)
 801874e:	e892 0003 	ldmia.w	r2, {r0, r1}
 8018752:	6018      	str	r0, [r3, #0]
 8018754:	3304      	adds	r3, #4
 8018756:	7019      	strb	r1, [r3, #0]
 8018758:	e009      	b.n	801876e <finsh_get_prompt+0x32>
    else
#endif
        strcpy(finsh_prompt, _PROMPT);
 801875a:	4b0c      	ldr	r3, [pc, #48]	; (801878c <finsh_get_prompt+0x50>)
 801875c:	4a0d      	ldr	r2, [pc, #52]	; (8018794 <finsh_get_prompt+0x58>)
 801875e:	e892 0003 	ldmia.w	r2, {r0, r1}
 8018762:	6018      	str	r0, [r3, #0]
 8018764:	3304      	adds	r3, #4
 8018766:	8019      	strh	r1, [r3, #0]
 8018768:	3302      	adds	r3, #2
 801876a:	0c0a      	lsrs	r2, r1, #16
 801876c:	701a      	strb	r2, [r3, #0]
#if defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR)
    /* get current working directory */
    getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
#endif

    strcat(finsh_prompt, ">");
 801876e:	4807      	ldr	r0, [pc, #28]	; (801878c <finsh_get_prompt+0x50>)
 8018770:	f007 f972 	bl	801fa58 <strlen>
 8018774:	4603      	mov	r3, r0
 8018776:	461a      	mov	r2, r3
 8018778:	4b04      	ldr	r3, [pc, #16]	; (801878c <finsh_get_prompt+0x50>)
 801877a:	4413      	add	r3, r2
 801877c:	4906      	ldr	r1, [pc, #24]	; (8018798 <finsh_get_prompt+0x5c>)
 801877e:	461a      	mov	r2, r3
 8018780:	460b      	mov	r3, r1
 8018782:	881b      	ldrh	r3, [r3, #0]
 8018784:	8013      	strh	r3, [r2, #0]

    return finsh_prompt;
 8018786:	4b01      	ldr	r3, [pc, #4]	; (801878c <finsh_get_prompt+0x50>)
}
 8018788:	4618      	mov	r0, r3
 801878a:	bd80      	pop	{r7, pc}
 801878c:	20012148 	.word	0x20012148
 8018790:	08023a40 	.word	0x08023a40
 8018794:	08023a48 	.word	0x08023a48
 8018798:	08023a50 	.word	0x08023a50

0801879c <finsh_rx_ind>:
#endif

static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
{
 801879c:	b580      	push	{r7, lr}
 801879e:	b082      	sub	sp, #8
 80187a0:	af00      	add	r7, sp, #0
 80187a2:	6078      	str	r0, [r7, #4]
 80187a4:	6039      	str	r1, [r7, #0]
    RT_ASSERT(shell != RT_NULL);
 80187a6:	4b09      	ldr	r3, [pc, #36]	; (80187cc <finsh_rx_ind+0x30>)
 80187a8:	681b      	ldr	r3, [r3, #0]
 80187aa:	2b00      	cmp	r3, #0
 80187ac:	d104      	bne.n	80187b8 <finsh_rx_ind+0x1c>
 80187ae:	4808      	ldr	r0, [pc, #32]	; (80187d0 <finsh_rx_ind+0x34>)
 80187b0:	4908      	ldr	r1, [pc, #32]	; (80187d4 <finsh_rx_ind+0x38>)
 80187b2:	2256      	movs	r2, #86	; 0x56
 80187b4:	f7fb fad6 	bl	8013d64 <rt_assert_handler>

    /* release semaphore to let finsh thread rx data */
    rt_sem_release(&shell->rx_sem);
 80187b8:	4b04      	ldr	r3, [pc, #16]	; (80187cc <finsh_rx_ind+0x30>)
 80187ba:	681b      	ldr	r3, [r3, #0]
 80187bc:	4618      	mov	r0, r3
 80187be:	f7f9 ffe7 	bl	8012790 <rt_sem_release>

    return RT_EOK;
 80187c2:	2300      	movs	r3, #0
}
 80187c4:	4618      	mov	r0, r3
 80187c6:	3708      	adds	r7, #8
 80187c8:	46bd      	mov	sp, r7
 80187ca:	bd80      	pop	{r7, pc}
 80187cc:	200126e0 	.word	0x200126e0
 80187d0:	08023a54 	.word	0x08023a54
 80187d4:	08025498 	.word	0x08025498

080187d8 <shell_auto_complete>:

    return shell->echo_mode;
}

static void shell_auto_complete(char *prefix)
{
 80187d8:	b580      	push	{r7, lr}
 80187da:	b082      	sub	sp, #8
 80187dc:	af00      	add	r7, sp, #0
 80187de:	6078      	str	r0, [r7, #4]

    rt_kprintf("\n");
 80187e0:	480c      	ldr	r0, [pc, #48]	; (8018814 <shell_auto_complete+0x3c>)
 80187e2:	f7fb fa45 	bl	8013c70 <rt_kprintf>
#ifdef FINSH_USING_MSH
    if (msh_is_used() == RT_TRUE)
 80187e6:	f001 fb25 	bl	8019e34 <msh_is_used>
 80187ea:	4603      	mov	r3, r0
 80187ec:	2b01      	cmp	r3, #1
 80187ee:	d103      	bne.n	80187f8 <shell_auto_complete+0x20>
    {
        msh_auto_complete(prefix);
 80187f0:	6878      	ldr	r0, [r7, #4]
 80187f2:	f001 fd31 	bl	801a258 <msh_auto_complete>
 80187f6:	e002      	b.n	80187fe <shell_auto_complete+0x26>
    else
#endif
    {
#ifndef FINSH_USING_MSH_ONLY
        extern void list_prefix(char * prefix);
        list_prefix(prefix);
 80187f8:	6878      	ldr	r0, [r7, #4]
 80187fa:	f001 f9ad 	bl	8019b58 <list_prefix>
#endif
    }

    rt_kprintf("%s%s", FINSH_PROMPT, prefix);
 80187fe:	f7ff ff9d 	bl	801873c <finsh_get_prompt>
 8018802:	4603      	mov	r3, r0
 8018804:	4804      	ldr	r0, [pc, #16]	; (8018818 <shell_auto_complete+0x40>)
 8018806:	4619      	mov	r1, r3
 8018808:	687a      	ldr	r2, [r7, #4]
 801880a:	f7fb fa31 	bl	8013c70 <rt_kprintf>
}
 801880e:	3708      	adds	r7, #8
 8018810:	46bd      	mov	sp, r7
 8018812:	bd80      	pop	{r7, pc}
 8018814:	08023a88 	.word	0x08023a88
 8018818:	08023a8c 	.word	0x08023a8c

0801881c <finsh_run_line>:

#ifndef FINSH_USING_MSH_ONLY
void finsh_run_line(struct finsh_parser *parser, const char *line)
{
 801881c:	b5b0      	push	{r4, r5, r7, lr}
 801881e:	b084      	sub	sp, #16
 8018820:	af00      	add	r7, sp, #0
 8018822:	6078      	str	r0, [r7, #4]
 8018824:	6039      	str	r1, [r7, #0]
    const char *err_str;

    rt_kprintf("\n");
 8018826:	4829      	ldr	r0, [pc, #164]	; (80188cc <finsh_run_line+0xb0>)
 8018828:	f7fb fa22 	bl	8013c70 <rt_kprintf>
    finsh_parser_run(parser, (unsigned char *)line);
 801882c:	6878      	ldr	r0, [r7, #4]
 801882e:	6839      	ldr	r1, [r7, #0]
 8018830:	f005 fbce 	bl	801dfd0 <finsh_parser_run>

    /* compile node root */
    if (finsh_errno() == 0)
 8018834:	f003 fad4 	bl	801bde0 <finsh_errno>
 8018838:	4603      	mov	r3, r0
 801883a:	2b00      	cmp	r3, #0
 801883c:	d106      	bne.n	801884c <finsh_run_line+0x30>
    {
        finsh_compiler_run(parser->root);
 801883e:	687b      	ldr	r3, [r7, #4]
 8018840:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8018844:	4618      	mov	r0, r3
 8018846:	f003 fa69 	bl	801bd1c <finsh_compiler_run>
 801884a:	e00a      	b.n	8018862 <finsh_run_line+0x46>
    }
    else
    {
        err_str = finsh_error_string(finsh_errno());
 801884c:	f003 fac8 	bl	801bde0 <finsh_errno>
 8018850:	4603      	mov	r3, r0
 8018852:	4618      	mov	r0, r3
 8018854:	f003 fad0 	bl	801bdf8 <finsh_error_string>
 8018858:	60f8      	str	r0, [r7, #12]
        rt_kprintf("%s\n", err_str);
 801885a:	481d      	ldr	r0, [pc, #116]	; (80188d0 <finsh_run_line+0xb4>)
 801885c:	68f9      	ldr	r1, [r7, #12]
 801885e:	f7fb fa07 	bl	8013c70 <rt_kprintf>
    }

    /* run virtual machine */
    if (finsh_errno() == 0)
 8018862:	f003 fabd 	bl	801bde0 <finsh_errno>
 8018866:	4603      	mov	r3, r0
 8018868:	2b00      	cmp	r3, #0
 801886a:	d129      	bne.n	80188c0 <finsh_run_line+0xa4>
    {
        char ch;
        finsh_vm_run();
 801886c:	f005 fd44 	bl	801e2f8 <finsh_vm_run>

        ch = (unsigned char)finsh_stack_bottom();
 8018870:	f003 fcb8 	bl	801c1e4 <finsh_stack_bottom>
 8018874:	4603      	mov	r3, r0
 8018876:	72fb      	strb	r3, [r7, #11]
        if (ch > 0x20 && ch < 0x7e)
 8018878:	7afb      	ldrb	r3, [r7, #11]
 801887a:	2b20      	cmp	r3, #32
 801887c:	d914      	bls.n	80188a8 <finsh_run_line+0x8c>
 801887e:	7afb      	ldrb	r3, [r7, #11]
 8018880:	2b7d      	cmp	r3, #125	; 0x7d
 8018882:	d811      	bhi.n	80188a8 <finsh_run_line+0x8c>
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
                       (unsigned char)finsh_stack_bottom(),
 8018884:	f003 fcae 	bl	801c1e4 <finsh_stack_bottom>
 8018888:	4603      	mov	r3, r0
 801888a:	b2db      	uxtb	r3, r3
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 801888c:	461d      	mov	r5, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
 801888e:	f003 fca9 	bl	801c1e4 <finsh_stack_bottom>
 8018892:	4603      	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 8018894:	461c      	mov	r4, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
 8018896:	f003 fca5 	bl	801c1e4 <finsh_stack_bottom>
 801889a:	4603      	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 801889c:	480d      	ldr	r0, [pc, #52]	; (80188d4 <finsh_run_line+0xb8>)
 801889e:	4629      	mov	r1, r5
 80188a0:	4622      	mov	r2, r4
 80188a2:	f7fb f9e5 	bl	8013c70 <rt_kprintf>
 80188a6:	e00b      	b.n	80188c0 <finsh_run_line+0xa4>
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
                       (unsigned int)finsh_stack_bottom(),
 80188a8:	f003 fc9c 	bl	801c1e4 <finsh_stack_bottom>
 80188ac:	4603      	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
 80188ae:	461c      	mov	r4, r3
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
 80188b0:	f003 fc98 	bl	801c1e4 <finsh_stack_bottom>
 80188b4:	4603      	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
 80188b6:	4808      	ldr	r0, [pc, #32]	; (80188d8 <finsh_run_line+0xbc>)
 80188b8:	4621      	mov	r1, r4
 80188ba:	461a      	mov	r2, r3
 80188bc:	f7fb f9d8 	bl	8013c70 <rt_kprintf>
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
    }

    finsh_flush(parser);
 80188c0:	6878      	ldr	r0, [r7, #4]
 80188c2:	f003 fc9b 	bl	801c1fc <finsh_flush>
}
 80188c6:	3710      	adds	r7, #16
 80188c8:	46bd      	mov	sp, r7
 80188ca:	bdb0      	pop	{r4, r5, r7, pc}
 80188cc:	08023a88 	.word	0x08023a88
 80188d0:	08023a94 	.word	0x08023a94
 80188d4:	08023a98 	.word	0x08023a98
 80188d8:	08023aac 	.word	0x08023aac

080188dc <shell_handle_history>:
#endif

#ifdef FINSH_USING_HISTORY
static rt_bool_t shell_handle_history(struct finsh_shell *shell)
{
 80188dc:	b580      	push	{r7, lr}
 80188de:	b082      	sub	sp, #8
 80188e0:	af00      	add	r7, sp, #0
 80188e2:	6078      	str	r0, [r7, #4]
    for (i = 0; i <= 60; i++)
        putchar(' ');
    rt_kprintf("\r");

#else
    rt_kprintf("\033[2K\r");
 80188e4:	4809      	ldr	r0, [pc, #36]	; (801890c <shell_handle_history+0x30>)
 80188e6:	f7fb f9c3 	bl	8013c70 <rt_kprintf>
#endif
    rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
 80188ea:	f7ff ff27 	bl	801873c <finsh_get_prompt>
 80188ee:	4602      	mov	r2, r0
 80188f0:	687b      	ldr	r3, [r7, #4]
 80188f2:	f503 7315 	add.w	r3, r3, #596	; 0x254
 80188f6:	4806      	ldr	r0, [pc, #24]	; (8018910 <shell_handle_history+0x34>)
 80188f8:	4611      	mov	r1, r2
 80188fa:	461a      	mov	r2, r3
 80188fc:	f7fb f9b8 	bl	8013c70 <rt_kprintf>
    return RT_FALSE;
 8018900:	2300      	movs	r3, #0
}
 8018902:	4618      	mov	r0, r3
 8018904:	3708      	adds	r7, #8
 8018906:	46bd      	mov	sp, r7
 8018908:	bd80      	pop	{r7, pc}
 801890a:	bf00      	nop
 801890c:	08023abc 	.word	0x08023abc
 8018910:	08023a8c 	.word	0x08023a8c

08018914 <shell_push_history>:

static void shell_push_history(struct finsh_shell *shell)
{
 8018914:	b580      	push	{r7, lr}
 8018916:	b084      	sub	sp, #16
 8018918:	af00      	add	r7, sp, #0
 801891a:	6078      	str	r0, [r7, #4]
    if (shell->line_position != 0)
 801891c:	687b      	ldr	r3, [r7, #4]
 801891e:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018922:	2b00      	cmp	r3, #0
 8018924:	d076      	beq.n	8018a14 <shell_push_history+0x100>
    {
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
 8018926:	687b      	ldr	r3, [r7, #4]
 8018928:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801892a:	2b04      	cmp	r3, #4
 801892c:	d946      	bls.n	80189bc <shell_push_history+0xa8>
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
 801892e:	2300      	movs	r3, #0
 8018930:	60fb      	str	r3, [r7, #12]
 8018932:	e01a      	b.n	801896a <shell_push_history+0x56>
            {
                memcpy(&shell->cmd_history[index][0],
 8018934:	68fa      	ldr	r2, [r7, #12]
 8018936:	4613      	mov	r3, r2
 8018938:	009b      	lsls	r3, r3, #2
 801893a:	4413      	add	r3, r2
 801893c:	011b      	lsls	r3, r3, #4
 801893e:	3320      	adds	r3, #32
 8018940:	687a      	ldr	r2, [r7, #4]
 8018942:	4413      	add	r3, r2
 8018944:	1d99      	adds	r1, r3, #6
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
 8018946:	68fb      	ldr	r3, [r7, #12]
 8018948:	1c5a      	adds	r2, r3, #1
 801894a:	4613      	mov	r3, r2
 801894c:	009b      	lsls	r3, r3, #2
 801894e:	4413      	add	r3, r2
 8018950:	011b      	lsls	r3, r3, #4
 8018952:	3320      	adds	r3, #32
 8018954:	687a      	ldr	r2, [r7, #4]
 8018956:	4413      	add	r3, r2
 8018958:	3306      	adds	r3, #6
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
            {
                memcpy(&shell->cmd_history[index][0],
 801895a:	4608      	mov	r0, r1
 801895c:	4619      	mov	r1, r3
 801895e:	2250      	movs	r2, #80	; 0x50
 8018960:	f7e7 fcbc 	bl	80002dc <memcpy>
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
 8018964:	68fb      	ldr	r3, [r7, #12]
 8018966:	3301      	adds	r3, #1
 8018968:	60fb      	str	r3, [r7, #12]
 801896a:	68fb      	ldr	r3, [r7, #12]
 801896c:	2b03      	cmp	r3, #3
 801896e:	dde1      	ble.n	8018934 <shell_push_history+0x20>
            {
                memcpy(&shell->cmd_history[index][0],
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
            }
            memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
 8018970:	68fa      	ldr	r2, [r7, #12]
 8018972:	4613      	mov	r3, r2
 8018974:	009b      	lsls	r3, r3, #2
 8018976:	4413      	add	r3, r2
 8018978:	011b      	lsls	r3, r3, #4
 801897a:	3320      	adds	r3, #32
 801897c:	687a      	ldr	r2, [r7, #4]
 801897e:	4413      	add	r3, r2
 8018980:	3306      	adds	r3, #6
 8018982:	4618      	mov	r0, r3
 8018984:	2100      	movs	r1, #0
 8018986:	2250      	movs	r2, #80	; 0x50
 8018988:	f006 fbd4 	bl	801f134 <memset>
            memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
 801898c:	68fa      	ldr	r2, [r7, #12]
 801898e:	4613      	mov	r3, r2
 8018990:	009b      	lsls	r3, r3, #2
 8018992:	4413      	add	r3, r2
 8018994:	011b      	lsls	r3, r3, #4
 8018996:	3320      	adds	r3, #32
 8018998:	687a      	ldr	r2, [r7, #4]
 801899a:	4413      	add	r3, r2
 801899c:	1d99      	adds	r1, r3, #6
 801899e:	687b      	ldr	r3, [r7, #4]
 80189a0:	f503 7215 	add.w	r2, r3, #596	; 0x254
 80189a4:	687b      	ldr	r3, [r7, #4]
 80189a6:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 80189aa:	4608      	mov	r0, r1
 80189ac:	4611      	mov	r1, r2
 80189ae:	461a      	mov	r2, r3
 80189b0:	f7e7 fc94 	bl	80002dc <memcpy>

            /* it's the maximum history */
            shell->history_count = FINSH_HISTORY_LINES;
 80189b4:	687b      	ldr	r3, [r7, #4]
 80189b6:	2205      	movs	r2, #5
 80189b8:	849a      	strh	r2, [r3, #36]	; 0x24
 80189ba:	e02b      	b.n	8018a14 <shell_push_history+0x100>
        }
        else
        {
            memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
 80189bc:	687b      	ldr	r3, [r7, #4]
 80189be:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80189c0:	461a      	mov	r2, r3
 80189c2:	4613      	mov	r3, r2
 80189c4:	009b      	lsls	r3, r3, #2
 80189c6:	4413      	add	r3, r2
 80189c8:	011b      	lsls	r3, r3, #4
 80189ca:	3320      	adds	r3, #32
 80189cc:	687a      	ldr	r2, [r7, #4]
 80189ce:	4413      	add	r3, r2
 80189d0:	3306      	adds	r3, #6
 80189d2:	4618      	mov	r0, r3
 80189d4:	2100      	movs	r1, #0
 80189d6:	2250      	movs	r2, #80	; 0x50
 80189d8:	f006 fbac 	bl	801f134 <memset>
            memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
 80189dc:	687b      	ldr	r3, [r7, #4]
 80189de:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80189e0:	461a      	mov	r2, r3
 80189e2:	4613      	mov	r3, r2
 80189e4:	009b      	lsls	r3, r3, #2
 80189e6:	4413      	add	r3, r2
 80189e8:	011b      	lsls	r3, r3, #4
 80189ea:	3320      	adds	r3, #32
 80189ec:	687a      	ldr	r2, [r7, #4]
 80189ee:	4413      	add	r3, r2
 80189f0:	1d99      	adds	r1, r3, #6
 80189f2:	687b      	ldr	r3, [r7, #4]
 80189f4:	f503 7215 	add.w	r2, r3, #596	; 0x254
 80189f8:	687b      	ldr	r3, [r7, #4]
 80189fa:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 80189fe:	4608      	mov	r0, r1
 8018a00:	4611      	mov	r1, r2
 8018a02:	461a      	mov	r2, r3
 8018a04:	f7e7 fc6a 	bl	80002dc <memcpy>

            /* increase count and set current history position */
            shell->history_count ++;
 8018a08:	687b      	ldr	r3, [r7, #4]
 8018a0a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8018a0c:	3301      	adds	r3, #1
 8018a0e:	b29a      	uxth	r2, r3
 8018a10:	687b      	ldr	r3, [r7, #4]
 8018a12:	849a      	strh	r2, [r3, #36]	; 0x24
        }
    }
    shell->current_history = shell->history_count;
 8018a14:	687b      	ldr	r3, [r7, #4]
 8018a16:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 8018a18:	687b      	ldr	r3, [r7, #4]
 8018a1a:	845a      	strh	r2, [r3, #34]	; 0x22
}
 8018a1c:	3710      	adds	r7, #16
 8018a1e:	46bd      	mov	sp, r7
 8018a20:	bd80      	pop	{r7, pc}
 8018a22:	bf00      	nop

08018a24 <finsh_thread_entry>:

#ifndef RT_USING_HEAP
struct finsh_shell _shell;
#endif
void finsh_thread_entry(void *parameter)
{
 8018a24:	b5b0      	push	{r4, r5, r7, lr}
 8018a26:	b086      	sub	sp, #24
 8018a28:	af00      	add	r7, sp, #0
 8018a2a:	6078      	str	r0, [r7, #4]
    char ch;

    /* normal is echo mode */
    shell->echo_mode = 1;
 8018a2c:	4bae      	ldr	r3, [pc, #696]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018a2e:	681a      	ldr	r2, [r3, #0]
 8018a30:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 8018a34:	f043 0301 	orr.w	r3, r3, #1
 8018a38:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21

#ifndef FINSH_USING_MSH_ONLY
    finsh_init(&shell->parser);
 8018a3c:	4baa      	ldr	r3, [pc, #680]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018a3e:	681b      	ldr	r3, [r3, #0]
 8018a40:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8018a44:	4618      	mov	r0, r3
 8018a46:	f003 fbb9 	bl	801c1bc <finsh_init>
#endif
    rt_kprintf(FINSH_PROMPT);
 8018a4a:	f7ff fe77 	bl	801873c <finsh_get_prompt>
 8018a4e:	4603      	mov	r3, r0
 8018a50:	4618      	mov	r0, r3
 8018a52:	f7fb f90d 	bl	8013c70 <rt_kprintf>

    /* set console device as shell device */
    if (shell->device == RT_NULL)
 8018a56:	4ba4      	ldr	r3, [pc, #656]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018a58:	681b      	ldr	r3, [r3, #0]
 8018a5a:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 8018a5e:	2b00      	cmp	r3, #0
 8018a60:	d123      	bne.n	8018aaa <finsh_thread_entry+0x86>
    {
#ifdef RT_USING_CONSOLE
        shell->device = rt_console_get_device();
 8018a62:	4ba1      	ldr	r3, [pc, #644]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018a64:	681c      	ldr	r4, [r3, #0]
 8018a66:	f7fb f8c7 	bl	8013bf8 <rt_console_get_device>
 8018a6a:	4603      	mov	r3, r0
 8018a6c:	f8c4 32a8 	str.w	r3, [r4, #680]	; 0x2a8
        RT_ASSERT(shell->device);
 8018a70:	4b9d      	ldr	r3, [pc, #628]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018a72:	681b      	ldr	r3, [r3, #0]
 8018a74:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 8018a78:	2b00      	cmp	r3, #0
 8018a7a:	d105      	bne.n	8018a88 <finsh_thread_entry+0x64>
 8018a7c:	489b      	ldr	r0, [pc, #620]	; (8018cec <finsh_thread_entry+0x2c8>)
 8018a7e:	499c      	ldr	r1, [pc, #624]	; (8018cf0 <finsh_thread_entry+0x2cc>)
 8018a80:	f44f 729d 	mov.w	r2, #314	; 0x13a
 8018a84:	f7fb f96e 	bl	8013d64 <rt_assert_handler>
        rt_device_set_rx_indicate(shell->device, finsh_rx_ind);
 8018a88:	4b97      	ldr	r3, [pc, #604]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018a8a:	681b      	ldr	r3, [r3, #0]
 8018a8c:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 8018a90:	4618      	mov	r0, r3
 8018a92:	4998      	ldr	r1, [pc, #608]	; (8018cf4 <finsh_thread_entry+0x2d0>)
 8018a94:	f7f9 fbda 	bl	801224c <rt_device_set_rx_indicate>
        rt_device_open(shell->device, (RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_INT_RX));
 8018a98:	4b93      	ldr	r3, [pc, #588]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018a9a:	681b      	ldr	r3, [r3, #0]
 8018a9c:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 8018aa0:	4618      	mov	r0, r3
 8018aa2:	f240 1143 	movw	r1, #323	; 0x143
 8018aa6:	f7f9 fa91 	bl	8011fcc <rt_device_open>
    }

    while (1)
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;
 8018aaa:	4b8f      	ldr	r3, [pc, #572]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018aac:	681b      	ldr	r3, [r3, #0]
 8018aae:	4618      	mov	r0, r3
 8018ab0:	f04f 31ff 	mov.w	r1, #4294967295
 8018ab4:	f7f9 fdc8 	bl	8012648 <rt_sem_take>
 8018ab8:	4603      	mov	r3, r0
 8018aba:	2b00      	cmp	r3, #0
 8018abc:	d000      	beq.n	8018ac0 <finsh_thread_entry+0x9c>
 8018abe:	e2f4      	b.n	80190aa <finsh_thread_entry+0x686>

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
 8018ac0:	e2e3      	b.n	801908a <finsh_thread_entry+0x666>
             * up key  : 0x1b 0x5b 0x41
             * down key: 0x1b 0x5b 0x42
             * right key:0x1b 0x5b 0x43
             * left key: 0x1b 0x5b 0x44
             */
            if (ch == 0x1b)
 8018ac2:	7afb      	ldrb	r3, [r7, #11]
 8018ac4:	2b1b      	cmp	r3, #27
 8018ac6:	d105      	bne.n	8018ad4 <finsh_thread_entry+0xb0>
            {
                shell->stat = WAIT_SPEC_KEY;
 8018ac8:	4b87      	ldr	r3, [pc, #540]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018aca:	681b      	ldr	r3, [r3, #0]
 8018acc:	2201      	movs	r2, #1
 8018ace:	f883 2020 	strb.w	r2, [r3, #32]
                continue;
 8018ad2:	e2da      	b.n	801908a <finsh_thread_entry+0x666>
            }
            else if (shell->stat == WAIT_SPEC_KEY)
 8018ad4:	4b84      	ldr	r3, [pc, #528]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018ad6:	681b      	ldr	r3, [r3, #0]
 8018ad8:	f893 3020 	ldrb.w	r3, [r3, #32]
 8018adc:	2b01      	cmp	r3, #1
 8018ade:	d10e      	bne.n	8018afe <finsh_thread_entry+0xda>
            {
                if (ch == 0x5b)
 8018ae0:	7afb      	ldrb	r3, [r7, #11]
 8018ae2:	2b5b      	cmp	r3, #91	; 0x5b
 8018ae4:	d105      	bne.n	8018af2 <finsh_thread_entry+0xce>
                {
                    shell->stat = WAIT_FUNC_KEY;
 8018ae6:	4b80      	ldr	r3, [pc, #512]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018ae8:	681b      	ldr	r3, [r3, #0]
 8018aea:	2202      	movs	r2, #2
 8018aec:	f883 2020 	strb.w	r2, [r3, #32]
                    continue;
 8018af0:	e2cb      	b.n	801908a <finsh_thread_entry+0x666>
                }

                shell->stat = WAIT_NORMAL;
 8018af2:	4b7d      	ldr	r3, [pc, #500]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018af4:	681b      	ldr	r3, [r3, #0]
 8018af6:	2200      	movs	r2, #0
 8018af8:	f883 2020 	strb.w	r2, [r3, #32]
 8018afc:	e0d5      	b.n	8018caa <finsh_thread_entry+0x286>
            }
            else if (shell->stat == WAIT_FUNC_KEY)
 8018afe:	4b7a      	ldr	r3, [pc, #488]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b00:	681b      	ldr	r3, [r3, #0]
 8018b02:	f893 3020 	ldrb.w	r3, [r3, #32]
 8018b06:	2b02      	cmp	r3, #2
 8018b08:	f040 80cf 	bne.w	8018caa <finsh_thread_entry+0x286>
            {
                shell->stat = WAIT_NORMAL;
 8018b0c:	4b76      	ldr	r3, [pc, #472]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b0e:	681b      	ldr	r3, [r3, #0]
 8018b10:	2200      	movs	r2, #0
 8018b12:	f883 2020 	strb.w	r2, [r3, #32]

                if (ch == 0x41) /* up key */
 8018b16:	7afb      	ldrb	r3, [r7, #11]
 8018b18:	2b41      	cmp	r3, #65	; 0x41
 8018b1a:	d13d      	bne.n	8018b98 <finsh_thread_entry+0x174>
                {
#ifdef FINSH_USING_HISTORY
                    /* prev history */
                    if (shell->current_history > 0)
 8018b1c:	4b72      	ldr	r3, [pc, #456]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b1e:	681b      	ldr	r3, [r3, #0]
 8018b20:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8018b22:	2b00      	cmp	r3, #0
 8018b24:	d033      	beq.n	8018b8e <finsh_thread_entry+0x16a>
                        shell->current_history --;
 8018b26:	4b70      	ldr	r3, [pc, #448]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b28:	681b      	ldr	r3, [r3, #0]
 8018b2a:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 8018b2c:	3a01      	subs	r2, #1
 8018b2e:	b292      	uxth	r2, r2
 8018b30:	845a      	strh	r2, [r3, #34]	; 0x22
                        shell->current_history = 0;
                        continue;
                    }

                    /* copy the history command */
                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
 8018b32:	4b6d      	ldr	r3, [pc, #436]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b34:	681b      	ldr	r3, [r3, #0]
 8018b36:	f503 7015 	add.w	r0, r3, #596	; 0x254
 8018b3a:	4b6b      	ldr	r3, [pc, #428]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b3c:	681a      	ldr	r2, [r3, #0]
 8018b3e:	4b6a      	ldr	r3, [pc, #424]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b40:	681b      	ldr	r3, [r3, #0]
 8018b42:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8018b44:	4619      	mov	r1, r3
 8018b46:	460b      	mov	r3, r1
 8018b48:	009b      	lsls	r3, r3, #2
 8018b4a:	440b      	add	r3, r1
 8018b4c:	011b      	lsls	r3, r3, #4
 8018b4e:	3320      	adds	r3, #32
 8018b50:	4413      	add	r3, r2
 8018b52:	3306      	adds	r3, #6
 8018b54:	4619      	mov	r1, r3
 8018b56:	2250      	movs	r2, #80	; 0x50
 8018b58:	f7e7 fbc0 	bl	80002dc <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
 8018b5c:	4b62      	ldr	r3, [pc, #392]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b5e:	681d      	ldr	r5, [r3, #0]
 8018b60:	4b61      	ldr	r3, [pc, #388]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b62:	681c      	ldr	r4, [r3, #0]
 8018b64:	4b60      	ldr	r3, [pc, #384]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b66:	681b      	ldr	r3, [r3, #0]
 8018b68:	f503 7315 	add.w	r3, r3, #596	; 0x254
 8018b6c:	4618      	mov	r0, r3
 8018b6e:	f006 ff73 	bl	801fa58 <strlen>
 8018b72:	4603      	mov	r3, r0
 8018b74:	b2db      	uxtb	r3, r3
 8018b76:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 8018b7a:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 8018b7e:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5
                    shell_handle_history(shell);
 8018b82:	4b59      	ldr	r3, [pc, #356]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b84:	681b      	ldr	r3, [r3, #0]
 8018b86:	4618      	mov	r0, r3
 8018b88:	f7ff fea8 	bl	80188dc <shell_handle_history>
#endif
                    continue;
 8018b8c:	e27d      	b.n	801908a <finsh_thread_entry+0x666>
                    /* prev history */
                    if (shell->current_history > 0)
                        shell->current_history --;
                    else
                    {
                        shell->current_history = 0;
 8018b8e:	4b56      	ldr	r3, [pc, #344]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018b90:	681b      	ldr	r3, [r3, #0]
 8018b92:	2200      	movs	r2, #0
 8018b94:	845a      	strh	r2, [r3, #34]	; 0x22
                        continue;
 8018b96:	e278      	b.n	801908a <finsh_thread_entry+0x666>
                    shell->line_curpos = shell->line_position = strlen(shell->line);
                    shell_handle_history(shell);
#endif
                    continue;
                }
                else if (ch == 0x42) /* down key */
 8018b98:	7afb      	ldrb	r3, [r7, #11]
 8018b9a:	2b42      	cmp	r3, #66	; 0x42
 8018b9c:	d14d      	bne.n	8018c3a <finsh_thread_entry+0x216>
                {
#ifdef FINSH_USING_HISTORY
                    /* next history */
                    if (shell->current_history < shell->history_count - 1)
 8018b9e:	4b52      	ldr	r3, [pc, #328]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018ba0:	681b      	ldr	r3, [r3, #0]
 8018ba2:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8018ba4:	461a      	mov	r2, r3
 8018ba6:	4b50      	ldr	r3, [pc, #320]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018ba8:	681b      	ldr	r3, [r3, #0]
 8018baa:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8018bac:	3b01      	subs	r3, #1
 8018bae:	429a      	cmp	r2, r3
 8018bb0:	da06      	bge.n	8018bc0 <finsh_thread_entry+0x19c>
                        shell->current_history ++;
 8018bb2:	4b4d      	ldr	r3, [pc, #308]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018bb4:	681b      	ldr	r3, [r3, #0]
 8018bb6:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 8018bb8:	3201      	adds	r2, #1
 8018bba:	b292      	uxth	r2, r2
 8018bbc:	845a      	strh	r2, [r3, #34]	; 0x22
 8018bbe:	e00e      	b.n	8018bde <finsh_thread_entry+0x1ba>
                    else
                    {
                        /* set to the end of history */
                        if (shell->history_count != 0)
 8018bc0:	4b49      	ldr	r3, [pc, #292]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018bc2:	681b      	ldr	r3, [r3, #0]
 8018bc4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8018bc6:	2b00      	cmp	r3, #0
 8018bc8:	d008      	beq.n	8018bdc <finsh_thread_entry+0x1b8>
                            shell->current_history = shell->history_count - 1;
 8018bca:	4b47      	ldr	r3, [pc, #284]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018bcc:	681b      	ldr	r3, [r3, #0]
 8018bce:	4a46      	ldr	r2, [pc, #280]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018bd0:	6812      	ldr	r2, [r2, #0]
 8018bd2:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 8018bd4:	3a01      	subs	r2, #1
 8018bd6:	b292      	uxth	r2, r2
 8018bd8:	845a      	strh	r2, [r3, #34]	; 0x22
 8018bda:	e000      	b.n	8018bde <finsh_thread_entry+0x1ba>
                        else
                            continue;
 8018bdc:	e255      	b.n	801908a <finsh_thread_entry+0x666>
                    }

                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
 8018bde:	4b42      	ldr	r3, [pc, #264]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018be0:	681b      	ldr	r3, [r3, #0]
 8018be2:	f503 7015 	add.w	r0, r3, #596	; 0x254
 8018be6:	4b40      	ldr	r3, [pc, #256]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018be8:	681a      	ldr	r2, [r3, #0]
 8018bea:	4b3f      	ldr	r3, [pc, #252]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018bec:	681b      	ldr	r3, [r3, #0]
 8018bee:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8018bf0:	4619      	mov	r1, r3
 8018bf2:	460b      	mov	r3, r1
 8018bf4:	009b      	lsls	r3, r3, #2
 8018bf6:	440b      	add	r3, r1
 8018bf8:	011b      	lsls	r3, r3, #4
 8018bfa:	3320      	adds	r3, #32
 8018bfc:	4413      	add	r3, r2
 8018bfe:	3306      	adds	r3, #6
 8018c00:	4619      	mov	r1, r3
 8018c02:	2250      	movs	r2, #80	; 0x50
 8018c04:	f7e7 fb6a 	bl	80002dc <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
 8018c08:	4b37      	ldr	r3, [pc, #220]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c0a:	681d      	ldr	r5, [r3, #0]
 8018c0c:	4b36      	ldr	r3, [pc, #216]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c0e:	681c      	ldr	r4, [r3, #0]
 8018c10:	4b35      	ldr	r3, [pc, #212]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c12:	681b      	ldr	r3, [r3, #0]
 8018c14:	f503 7315 	add.w	r3, r3, #596	; 0x254
 8018c18:	4618      	mov	r0, r3
 8018c1a:	f006 ff1d 	bl	801fa58 <strlen>
 8018c1e:	4603      	mov	r3, r0
 8018c20:	b2db      	uxtb	r3, r3
 8018c22:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 8018c26:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 8018c2a:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5
                    shell_handle_history(shell);
 8018c2e:	4b2e      	ldr	r3, [pc, #184]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c30:	681b      	ldr	r3, [r3, #0]
 8018c32:	4618      	mov	r0, r3
 8018c34:	f7ff fe52 	bl	80188dc <shell_handle_history>
#endif
                    continue;
 8018c38:	e227      	b.n	801908a <finsh_thread_entry+0x666>
                }
                else if (ch == 0x44) /* left key */
 8018c3a:	7afb      	ldrb	r3, [r7, #11]
 8018c3c:	2b44      	cmp	r3, #68	; 0x44
 8018c3e:	d111      	bne.n	8018c64 <finsh_thread_entry+0x240>
                {
                    if (shell->line_curpos)
 8018c40:	4b29      	ldr	r3, [pc, #164]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c42:	681b      	ldr	r3, [r3, #0]
 8018c44:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018c48:	2b00      	cmp	r3, #0
 8018c4a:	d00a      	beq.n	8018c62 <finsh_thread_entry+0x23e>
                    {
                        rt_kprintf("\b");
 8018c4c:	482a      	ldr	r0, [pc, #168]	; (8018cf8 <finsh_thread_entry+0x2d4>)
 8018c4e:	f7fb f80f 	bl	8013c70 <rt_kprintf>
                        shell->line_curpos --;
 8018c52:	4b25      	ldr	r3, [pc, #148]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c54:	681b      	ldr	r3, [r3, #0]
 8018c56:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 8018c5a:	3a01      	subs	r2, #1
 8018c5c:	b2d2      	uxtb	r2, r2
 8018c5e:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
                    }

                    continue;
 8018c62:	e212      	b.n	801908a <finsh_thread_entry+0x666>
                }
                else if (ch == 0x43) /* right key */
 8018c64:	7afb      	ldrb	r3, [r7, #11]
 8018c66:	2b43      	cmp	r3, #67	; 0x43
 8018c68:	d11f      	bne.n	8018caa <finsh_thread_entry+0x286>
                {
                    if (shell->line_curpos < shell->line_position)
 8018c6a:	4b1f      	ldr	r3, [pc, #124]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c6c:	681b      	ldr	r3, [r3, #0]
 8018c6e:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 8018c72:	4b1d      	ldr	r3, [pc, #116]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c74:	681b      	ldr	r3, [r3, #0]
 8018c76:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018c7a:	429a      	cmp	r2, r3
 8018c7c:	d214      	bcs.n	8018ca8 <finsh_thread_entry+0x284>
                    {
                        rt_kprintf("%c", shell->line[shell->line_curpos]);
 8018c7e:	4b1a      	ldr	r3, [pc, #104]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c80:	681b      	ldr	r3, [r3, #0]
 8018c82:	4a19      	ldr	r2, [pc, #100]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c84:	6812      	ldr	r2, [r2, #0]
 8018c86:	f892 22a5 	ldrb.w	r2, [r2, #677]	; 0x2a5
 8018c8a:	4413      	add	r3, r2
 8018c8c:	f893 3254 	ldrb.w	r3, [r3, #596]	; 0x254
 8018c90:	481a      	ldr	r0, [pc, #104]	; (8018cfc <finsh_thread_entry+0x2d8>)
 8018c92:	4619      	mov	r1, r3
 8018c94:	f7fa ffec 	bl	8013c70 <rt_kprintf>
                        shell->line_curpos ++;
 8018c98:	4b13      	ldr	r3, [pc, #76]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018c9a:	681b      	ldr	r3, [r3, #0]
 8018c9c:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 8018ca0:	3201      	adds	r2, #1
 8018ca2:	b2d2      	uxtb	r2, r2
 8018ca4:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
                    }

                    continue;
 8018ca8:	e1ef      	b.n	801908a <finsh_thread_entry+0x666>
                }

            }

            /* handle CR key */
            if (ch == '\r')
 8018caa:	7afb      	ldrb	r3, [r7, #11]
 8018cac:	2b0d      	cmp	r3, #13
 8018cae:	d127      	bne.n	8018d00 <finsh_thread_entry+0x2dc>
            {
                char next;

                if (rt_device_read(shell->device, 0, &next, 1) == 1)
 8018cb0:	4b0d      	ldr	r3, [pc, #52]	; (8018ce8 <finsh_thread_entry+0x2c4>)
 8018cb2:	681b      	ldr	r3, [r3, #0]
 8018cb4:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
 8018cb8:	f107 030a 	add.w	r3, r7, #10
 8018cbc:	4610      	mov	r0, r2
 8018cbe:	2100      	movs	r1, #0
 8018cc0:	461a      	mov	r2, r3
 8018cc2:	2301      	movs	r3, #1
 8018cc4:	f7f9 fa34 	bl	8012130 <rt_device_read>
 8018cc8:	4603      	mov	r3, r0
 8018cca:	2b01      	cmp	r3, #1
 8018ccc:	d108      	bne.n	8018ce0 <finsh_thread_entry+0x2bc>
                {
                    if (next == '\0') ch = 'r'; /* linux telnet will issue '\0' */
 8018cce:	7abb      	ldrb	r3, [r7, #10]
 8018cd0:	2b00      	cmp	r3, #0
 8018cd2:	d102      	bne.n	8018cda <finsh_thread_entry+0x2b6>
 8018cd4:	2372      	movs	r3, #114	; 0x72
 8018cd6:	72fb      	strb	r3, [r7, #11]
 8018cd8:	e0c7      	b.n	8018e6a <finsh_thread_entry+0x446>
                    else ch = next;
 8018cda:	7abb      	ldrb	r3, [r7, #10]
 8018cdc:	72fb      	strb	r3, [r7, #11]
 8018cde:	e0c4      	b.n	8018e6a <finsh_thread_entry+0x446>
                }
                else ch = '\r';
 8018ce0:	230d      	movs	r3, #13
 8018ce2:	72fb      	strb	r3, [r7, #11]
 8018ce4:	e0c1      	b.n	8018e6a <finsh_thread_entry+0x446>
 8018ce6:	bf00      	nop
 8018ce8:	200126e0 	.word	0x200126e0
 8018cec:	08023ac4 	.word	0x08023ac4
 8018cf0:	080254a8 	.word	0x080254a8
 8018cf4:	0801879d 	.word	0x0801879d
 8018cf8:	08023ad4 	.word	0x08023ad4
 8018cfc:	08023ad8 	.word	0x08023ad8
            }
            /* handle tab key */
            else if (ch == '\t')
 8018d00:	7afb      	ldrb	r3, [r7, #11]
 8018d02:	2b09      	cmp	r3, #9
 8018d04:	d12b      	bne.n	8018d5e <finsh_thread_entry+0x33a>
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
 8018d06:	2300      	movs	r3, #0
 8018d08:	617b      	str	r3, [r7, #20]
 8018d0a:	e005      	b.n	8018d18 <finsh_thread_entry+0x2f4>
                    rt_kprintf("\b");
 8018d0c:	4884      	ldr	r0, [pc, #528]	; (8018f20 <finsh_thread_entry+0x4fc>)
 8018d0e:	f7fa ffaf 	bl	8013c70 <rt_kprintf>
            /* handle tab key */
            else if (ch == '\t')
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
 8018d12:	697b      	ldr	r3, [r7, #20]
 8018d14:	3301      	adds	r3, #1
 8018d16:	617b      	str	r3, [r7, #20]
 8018d18:	4b82      	ldr	r3, [pc, #520]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d1a:	681b      	ldr	r3, [r3, #0]
 8018d1c:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018d20:	461a      	mov	r2, r3
 8018d22:	697b      	ldr	r3, [r7, #20]
 8018d24:	429a      	cmp	r2, r3
 8018d26:	dcf1      	bgt.n	8018d0c <finsh_thread_entry+0x2e8>
                    rt_kprintf("\b");

                /* auto complete */
                shell_auto_complete(&shell->line[0]);
 8018d28:	4b7e      	ldr	r3, [pc, #504]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d2a:	681b      	ldr	r3, [r3, #0]
 8018d2c:	f503 7315 	add.w	r3, r3, #596	; 0x254
 8018d30:	4618      	mov	r0, r3
 8018d32:	f7ff fd51 	bl	80187d8 <shell_auto_complete>
                /* re-calculate position */
                shell->line_curpos = shell->line_position = strlen(shell->line);
 8018d36:	4b7b      	ldr	r3, [pc, #492]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d38:	681d      	ldr	r5, [r3, #0]
 8018d3a:	4b7a      	ldr	r3, [pc, #488]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d3c:	681c      	ldr	r4, [r3, #0]
 8018d3e:	4b79      	ldr	r3, [pc, #484]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d40:	681b      	ldr	r3, [r3, #0]
 8018d42:	f503 7315 	add.w	r3, r3, #596	; 0x254
 8018d46:	4618      	mov	r0, r3
 8018d48:	f006 fe86 	bl	801fa58 <strlen>
 8018d4c:	4603      	mov	r3, r0
 8018d4e:	b2db      	uxtb	r3, r3
 8018d50:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 8018d54:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 8018d58:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5

                continue;
 8018d5c:	e195      	b.n	801908a <finsh_thread_entry+0x666>
            }
            /* handle backspace key */
            else if (ch == 0x7f || ch == 0x08)
 8018d5e:	7afb      	ldrb	r3, [r7, #11]
 8018d60:	2b7f      	cmp	r3, #127	; 0x7f
 8018d62:	d002      	beq.n	8018d6a <finsh_thread_entry+0x346>
 8018d64:	7afb      	ldrb	r3, [r7, #11]
 8018d66:	2b08      	cmp	r3, #8
 8018d68:	d17f      	bne.n	8018e6a <finsh_thread_entry+0x446>
            {
                /* note that shell->line_curpos >= 0 */
                if (shell->line_curpos == 0)
 8018d6a:	4b6e      	ldr	r3, [pc, #440]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d6c:	681b      	ldr	r3, [r3, #0]
 8018d6e:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018d72:	2b00      	cmp	r3, #0
 8018d74:	d100      	bne.n	8018d78 <finsh_thread_entry+0x354>
                    continue;
 8018d76:	e188      	b.n	801908a <finsh_thread_entry+0x666>

                shell->line_position--;
 8018d78:	4b6a      	ldr	r3, [pc, #424]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d7a:	681b      	ldr	r3, [r3, #0]
 8018d7c:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 8018d80:	3a01      	subs	r2, #1
 8018d82:	b2d2      	uxtb	r2, r2
 8018d84:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
                shell->line_curpos--;
 8018d88:	4b66      	ldr	r3, [pc, #408]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d8a:	681b      	ldr	r3, [r3, #0]
 8018d8c:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 8018d90:	3a01      	subs	r2, #1
 8018d92:	b2d2      	uxtb	r2, r2
 8018d94:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5

                if (shell->line_position > shell->line_curpos)
 8018d98:	4b62      	ldr	r3, [pc, #392]	; (8018f24 <finsh_thread_entry+0x500>)
 8018d9a:	681b      	ldr	r3, [r3, #0]
 8018d9c:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 8018da0:	4b60      	ldr	r3, [pc, #384]	; (8018f24 <finsh_thread_entry+0x500>)
 8018da2:	681b      	ldr	r3, [r3, #0]
 8018da4:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018da8:	429a      	cmp	r2, r3
 8018daa:	d950      	bls.n	8018e4e <finsh_thread_entry+0x42a>
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
 8018dac:	4b5d      	ldr	r3, [pc, #372]	; (8018f24 <finsh_thread_entry+0x500>)
 8018dae:	681a      	ldr	r2, [r3, #0]
 8018db0:	4b5c      	ldr	r3, [pc, #368]	; (8018f24 <finsh_thread_entry+0x500>)
 8018db2:	681b      	ldr	r3, [r3, #0]
 8018db4:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018db8:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8018dbc:	4413      	add	r3, r2
 8018dbe:	1d19      	adds	r1, r3, #4
                               &shell->line[shell->line_curpos + 1],
 8018dc0:	4b58      	ldr	r3, [pc, #352]	; (8018f24 <finsh_thread_entry+0x500>)
 8018dc2:	681a      	ldr	r2, [r3, #0]
 8018dc4:	4b57      	ldr	r3, [pc, #348]	; (8018f24 <finsh_thread_entry+0x500>)
 8018dc6:	681b      	ldr	r3, [r3, #0]
 8018dc8:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018dcc:	3301      	adds	r3, #1
 8018dce:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8018dd2:	4413      	add	r3, r2
 8018dd4:	1d1a      	adds	r2, r3, #4
                               shell->line_position - shell->line_curpos);
 8018dd6:	4b53      	ldr	r3, [pc, #332]	; (8018f24 <finsh_thread_entry+0x500>)
 8018dd8:	681b      	ldr	r3, [r3, #0]
 8018dda:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018dde:	4618      	mov	r0, r3
 8018de0:	4b50      	ldr	r3, [pc, #320]	; (8018f24 <finsh_thread_entry+0x500>)
 8018de2:	681b      	ldr	r3, [r3, #0]
 8018de4:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018de8:	1ac3      	subs	r3, r0, r3

                if (shell->line_position > shell->line_curpos)
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
 8018dea:	4608      	mov	r0, r1
 8018dec:	4611      	mov	r1, r2
 8018dee:	461a      	mov	r2, r3
 8018df0:	f7fa fa4c 	bl	801328c <rt_memmove>
                               &shell->line[shell->line_curpos + 1],
                               shell->line_position - shell->line_curpos);
                    shell->line[shell->line_position] = 0;
 8018df4:	4b4b      	ldr	r3, [pc, #300]	; (8018f24 <finsh_thread_entry+0x500>)
 8018df6:	681b      	ldr	r3, [r3, #0]
 8018df8:	4a4a      	ldr	r2, [pc, #296]	; (8018f24 <finsh_thread_entry+0x500>)
 8018dfa:	6812      	ldr	r2, [r2, #0]
 8018dfc:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 8018e00:	4413      	add	r3, r2
 8018e02:	2200      	movs	r2, #0
 8018e04:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
 8018e08:	4b46      	ldr	r3, [pc, #280]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e0a:	681a      	ldr	r2, [r3, #0]
 8018e0c:	4b45      	ldr	r3, [pc, #276]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e0e:	681b      	ldr	r3, [r3, #0]
 8018e10:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018e14:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8018e18:	4413      	add	r3, r2
 8018e1a:	3304      	adds	r3, #4
 8018e1c:	4842      	ldr	r0, [pc, #264]	; (8018f28 <finsh_thread_entry+0x504>)
 8018e1e:	4619      	mov	r1, r3
 8018e20:	f7fa ff26 	bl	8013c70 <rt_kprintf>

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
 8018e24:	4b3f      	ldr	r3, [pc, #252]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e26:	681b      	ldr	r3, [r3, #0]
 8018e28:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018e2c:	613b      	str	r3, [r7, #16]
 8018e2e:	e005      	b.n	8018e3c <finsh_thread_entry+0x418>
                        rt_kprintf("\b");
 8018e30:	483b      	ldr	r0, [pc, #236]	; (8018f20 <finsh_thread_entry+0x4fc>)
 8018e32:	f7fa ff1d 	bl	8013c70 <rt_kprintf>
                    shell->line[shell->line_position] = 0;

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
 8018e36:	693b      	ldr	r3, [r7, #16]
 8018e38:	3301      	adds	r3, #1
 8018e3a:	613b      	str	r3, [r7, #16]
 8018e3c:	4b39      	ldr	r3, [pc, #228]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e3e:	681b      	ldr	r3, [r3, #0]
 8018e40:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018e44:	461a      	mov	r2, r3
 8018e46:	693b      	ldr	r3, [r7, #16]
 8018e48:	429a      	cmp	r2, r3
 8018e4a:	daf1      	bge.n	8018e30 <finsh_thread_entry+0x40c>
 8018e4c:	e00c      	b.n	8018e68 <finsh_thread_entry+0x444>
                        rt_kprintf("\b");
                }
                else
                {
                    rt_kprintf("\b \b");
 8018e4e:	4837      	ldr	r0, [pc, #220]	; (8018f2c <finsh_thread_entry+0x508>)
 8018e50:	f7fa ff0e 	bl	8013c70 <rt_kprintf>
                    shell->line[shell->line_position] = 0;
 8018e54:	4b33      	ldr	r3, [pc, #204]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e56:	681b      	ldr	r3, [r3, #0]
 8018e58:	4a32      	ldr	r2, [pc, #200]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e5a:	6812      	ldr	r2, [r2, #0]
 8018e5c:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 8018e60:	4413      	add	r3, r2
 8018e62:	2200      	movs	r2, #0
 8018e64:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                }

                continue;
 8018e68:	e10f      	b.n	801908a <finsh_thread_entry+0x666>
            }

            /* handle end of line, break */
            if (ch == '\r' || ch == '\n')
 8018e6a:	7afb      	ldrb	r3, [r7, #11]
 8018e6c:	2b0d      	cmp	r3, #13
 8018e6e:	d002      	beq.n	8018e76 <finsh_thread_entry+0x452>
 8018e70:	7afb      	ldrb	r3, [r7, #11]
 8018e72:	2b0a      	cmp	r3, #10
 8018e74:	d15e      	bne.n	8018f34 <finsh_thread_entry+0x510>
            {
#ifdef FINSH_USING_HISTORY
                shell_push_history(shell);
 8018e76:	4b2b      	ldr	r3, [pc, #172]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e78:	681b      	ldr	r3, [r3, #0]
 8018e7a:	4618      	mov	r0, r3
 8018e7c:	f7ff fd4a 	bl	8018914 <shell_push_history>
#endif

#ifdef FINSH_USING_MSH
                if (msh_is_used() == RT_TRUE)
 8018e80:	f000 ffd8 	bl	8019e34 <msh_is_used>
 8018e84:	4603      	mov	r3, r0
 8018e86:	2b01      	cmp	r3, #1
 8018e88:	d10f      	bne.n	8018eaa <finsh_thread_entry+0x486>
                {
                    rt_kprintf("\n");
 8018e8a:	4829      	ldr	r0, [pc, #164]	; (8018f30 <finsh_thread_entry+0x50c>)
 8018e8c:	f7fa fef0 	bl	8013c70 <rt_kprintf>
                    msh_exec(shell->line, shell->line_position);
 8018e90:	4b24      	ldr	r3, [pc, #144]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e92:	681b      	ldr	r3, [r3, #0]
 8018e94:	f503 7215 	add.w	r2, r3, #596	; 0x254
 8018e98:	4b22      	ldr	r3, [pc, #136]	; (8018f24 <finsh_thread_entry+0x500>)
 8018e9a:	681b      	ldr	r3, [r3, #0]
 8018e9c:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018ea0:	4610      	mov	r0, r2
 8018ea2:	4619      	mov	r1, r3
 8018ea4:	f001 f970 	bl	801a188 <msh_exec>
 8018ea8:	e01f      	b.n	8018eea <finsh_thread_entry+0x4c6>
                else
#endif
                {
#ifndef FINSH_USING_MSH_ONLY
                    /* add ';' and run the command line */
                    shell->line[shell->line_position] = ';';
 8018eaa:	4b1e      	ldr	r3, [pc, #120]	; (8018f24 <finsh_thread_entry+0x500>)
 8018eac:	681b      	ldr	r3, [r3, #0]
 8018eae:	4a1d      	ldr	r2, [pc, #116]	; (8018f24 <finsh_thread_entry+0x500>)
 8018eb0:	6812      	ldr	r2, [r2, #0]
 8018eb2:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 8018eb6:	4413      	add	r3, r2
 8018eb8:	223b      	movs	r2, #59	; 0x3b
 8018eba:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254

                    if (shell->line_position != 0) finsh_run_line(&shell->parser, shell->line);
 8018ebe:	4b19      	ldr	r3, [pc, #100]	; (8018f24 <finsh_thread_entry+0x500>)
 8018ec0:	681b      	ldr	r3, [r3, #0]
 8018ec2:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018ec6:	2b00      	cmp	r3, #0
 8018ec8:	d00c      	beq.n	8018ee4 <finsh_thread_entry+0x4c0>
 8018eca:	4b16      	ldr	r3, [pc, #88]	; (8018f24 <finsh_thread_entry+0x500>)
 8018ecc:	681b      	ldr	r3, [r3, #0]
 8018ece:	f503 72dc 	add.w	r2, r3, #440	; 0x1b8
 8018ed2:	4b14      	ldr	r3, [pc, #80]	; (8018f24 <finsh_thread_entry+0x500>)
 8018ed4:	681b      	ldr	r3, [r3, #0]
 8018ed6:	f503 7315 	add.w	r3, r3, #596	; 0x254
 8018eda:	4610      	mov	r0, r2
 8018edc:	4619      	mov	r1, r3
 8018ede:	f7ff fc9d 	bl	801881c <finsh_run_line>
 8018ee2:	e002      	b.n	8018eea <finsh_thread_entry+0x4c6>
                    else rt_kprintf("\n");
 8018ee4:	4812      	ldr	r0, [pc, #72]	; (8018f30 <finsh_thread_entry+0x50c>)
 8018ee6:	f7fa fec3 	bl	8013c70 <rt_kprintf>
#endif
                }

                rt_kprintf(FINSH_PROMPT);
 8018eea:	f7ff fc27 	bl	801873c <finsh_get_prompt>
 8018eee:	4603      	mov	r3, r0
 8018ef0:	4618      	mov	r0, r3
 8018ef2:	f7fa febd 	bl	8013c70 <rt_kprintf>
                memset(shell->line, 0, sizeof(shell->line));
 8018ef6:	4b0b      	ldr	r3, [pc, #44]	; (8018f24 <finsh_thread_entry+0x500>)
 8018ef8:	681b      	ldr	r3, [r3, #0]
 8018efa:	f503 7315 	add.w	r3, r3, #596	; 0x254
 8018efe:	4618      	mov	r0, r3
 8018f00:	2100      	movs	r1, #0
 8018f02:	2250      	movs	r2, #80	; 0x50
 8018f04:	f006 f916 	bl	801f134 <memset>
                shell->line_curpos = shell->line_position = 0;
 8018f08:	4b06      	ldr	r3, [pc, #24]	; (8018f24 <finsh_thread_entry+0x500>)
 8018f0a:	681a      	ldr	r2, [r3, #0]
 8018f0c:	4b05      	ldr	r3, [pc, #20]	; (8018f24 <finsh_thread_entry+0x500>)
 8018f0e:	681b      	ldr	r3, [r3, #0]
 8018f10:	2100      	movs	r1, #0
 8018f12:	f883 12a4 	strb.w	r1, [r3, #676]	; 0x2a4
 8018f16:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018f1a:	f882 32a5 	strb.w	r3, [r2, #677]	; 0x2a5
                break;
 8018f1e:	e0c4      	b.n	80190aa <finsh_thread_entry+0x686>
 8018f20:	08023ad4 	.word	0x08023ad4
 8018f24:	200126e0 	.word	0x200126e0
 8018f28:	08023adc 	.word	0x08023adc
 8018f2c:	08023ae4 	.word	0x08023ae4
 8018f30:	08023a88 	.word	0x08023a88
            }

            /* it's a large line, discard it */
            if (shell->line_position >= FINSH_CMD_SIZE)
 8018f34:	4b5d      	ldr	r3, [pc, #372]	; (80190ac <finsh_thread_entry+0x688>)
 8018f36:	681b      	ldr	r3, [r3, #0]
 8018f38:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018f3c:	2b4f      	cmp	r3, #79	; 0x4f
 8018f3e:	d904      	bls.n	8018f4a <finsh_thread_entry+0x526>
                shell->line_position = 0;
 8018f40:	4b5a      	ldr	r3, [pc, #360]	; (80190ac <finsh_thread_entry+0x688>)
 8018f42:	681b      	ldr	r3, [r3, #0]
 8018f44:	2200      	movs	r2, #0
 8018f46:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4

            /* normal character */
            if (shell->line_curpos < shell->line_position)
 8018f4a:	4b58      	ldr	r3, [pc, #352]	; (80190ac <finsh_thread_entry+0x688>)
 8018f4c:	681b      	ldr	r3, [r3, #0]
 8018f4e:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 8018f52:	4b56      	ldr	r3, [pc, #344]	; (80190ac <finsh_thread_entry+0x688>)
 8018f54:	681b      	ldr	r3, [r3, #0]
 8018f56:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018f5a:	429a      	cmp	r2, r3
 8018f5c:	d25a      	bcs.n	8019014 <finsh_thread_entry+0x5f0>
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
 8018f5e:	4b53      	ldr	r3, [pc, #332]	; (80190ac <finsh_thread_entry+0x688>)
 8018f60:	681a      	ldr	r2, [r3, #0]
 8018f62:	4b52      	ldr	r3, [pc, #328]	; (80190ac <finsh_thread_entry+0x688>)
 8018f64:	681b      	ldr	r3, [r3, #0]
 8018f66:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018f6a:	3301      	adds	r3, #1
 8018f6c:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8018f70:	4413      	add	r3, r2
 8018f72:	1d19      	adds	r1, r3, #4
                           &shell->line[shell->line_curpos],
 8018f74:	4b4d      	ldr	r3, [pc, #308]	; (80190ac <finsh_thread_entry+0x688>)
 8018f76:	681a      	ldr	r2, [r3, #0]
 8018f78:	4b4c      	ldr	r3, [pc, #304]	; (80190ac <finsh_thread_entry+0x688>)
 8018f7a:	681b      	ldr	r3, [r3, #0]
 8018f7c:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018f80:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8018f84:	4413      	add	r3, r2
 8018f86:	1d1a      	adds	r2, r3, #4
                           shell->line_position - shell->line_curpos);
 8018f88:	4b48      	ldr	r3, [pc, #288]	; (80190ac <finsh_thread_entry+0x688>)
 8018f8a:	681b      	ldr	r3, [r3, #0]
 8018f8c:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8018f90:	4618      	mov	r0, r3
 8018f92:	4b46      	ldr	r3, [pc, #280]	; (80190ac <finsh_thread_entry+0x688>)
 8018f94:	681b      	ldr	r3, [r3, #0]
 8018f96:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018f9a:	1ac3      	subs	r3, r0, r3
            /* normal character */
            if (shell->line_curpos < shell->line_position)
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
 8018f9c:	4608      	mov	r0, r1
 8018f9e:	4611      	mov	r1, r2
 8018fa0:	461a      	mov	r2, r3
 8018fa2:	f7fa f973 	bl	801328c <rt_memmove>
                           &shell->line[shell->line_curpos],
                           shell->line_position - shell->line_curpos);
                shell->line[shell->line_curpos] = ch;
 8018fa6:	4b41      	ldr	r3, [pc, #260]	; (80190ac <finsh_thread_entry+0x688>)
 8018fa8:	681b      	ldr	r3, [r3, #0]
 8018faa:	4a40      	ldr	r2, [pc, #256]	; (80190ac <finsh_thread_entry+0x688>)
 8018fac:	6812      	ldr	r2, [r2, #0]
 8018fae:	f892 22a5 	ldrb.w	r2, [r2, #677]	; 0x2a5
 8018fb2:	4611      	mov	r1, r2
 8018fb4:	7afa      	ldrb	r2, [r7, #11]
 8018fb6:	440b      	add	r3, r1
 8018fb8:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                if (shell->echo_mode)
 8018fbc:	4b3b      	ldr	r3, [pc, #236]	; (80190ac <finsh_thread_entry+0x688>)
 8018fbe:	681b      	ldr	r3, [r3, #0]
 8018fc0:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8018fc4:	f003 0301 	and.w	r3, r3, #1
 8018fc8:	b2db      	uxtb	r3, r3
 8018fca:	2b00      	cmp	r3, #0
 8018fcc:	d00d      	beq.n	8018fea <finsh_thread_entry+0x5c6>
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);
 8018fce:	4b37      	ldr	r3, [pc, #220]	; (80190ac <finsh_thread_entry+0x688>)
 8018fd0:	681a      	ldr	r2, [r3, #0]
 8018fd2:	4b36      	ldr	r3, [pc, #216]	; (80190ac <finsh_thread_entry+0x688>)
 8018fd4:	681b      	ldr	r3, [r3, #0]
 8018fd6:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018fda:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8018fde:	4413      	add	r3, r2
 8018fe0:	3304      	adds	r3, #4
 8018fe2:	4833      	ldr	r0, [pc, #204]	; (80190b0 <finsh_thread_entry+0x68c>)
 8018fe4:	4619      	mov	r1, r3
 8018fe6:	f7fa fe43 	bl	8013c70 <rt_kprintf>

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
 8018fea:	4b30      	ldr	r3, [pc, #192]	; (80190ac <finsh_thread_entry+0x688>)
 8018fec:	681b      	ldr	r3, [r3, #0]
 8018fee:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 8018ff2:	60fb      	str	r3, [r7, #12]
 8018ff4:	e005      	b.n	8019002 <finsh_thread_entry+0x5de>
                    rt_kprintf("\b");
 8018ff6:	482f      	ldr	r0, [pc, #188]	; (80190b4 <finsh_thread_entry+0x690>)
 8018ff8:	f7fa fe3a 	bl	8013c70 <rt_kprintf>
                shell->line[shell->line_curpos] = ch;
                if (shell->echo_mode)
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
 8018ffc:	68fb      	ldr	r3, [r7, #12]
 8018ffe:	3301      	adds	r3, #1
 8019000:	60fb      	str	r3, [r7, #12]
 8019002:	4b2a      	ldr	r3, [pc, #168]	; (80190ac <finsh_thread_entry+0x688>)
 8019004:	681b      	ldr	r3, [r3, #0]
 8019006:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801900a:	461a      	mov	r2, r3
 801900c:	68fb      	ldr	r3, [r7, #12]
 801900e:	429a      	cmp	r2, r3
 8019010:	dcf1      	bgt.n	8018ff6 <finsh_thread_entry+0x5d2>
 8019012:	e018      	b.n	8019046 <finsh_thread_entry+0x622>
                    rt_kprintf("\b");
            }
            else
            {
                shell->line[shell->line_position] = ch;
 8019014:	4b25      	ldr	r3, [pc, #148]	; (80190ac <finsh_thread_entry+0x688>)
 8019016:	681b      	ldr	r3, [r3, #0]
 8019018:	4a24      	ldr	r2, [pc, #144]	; (80190ac <finsh_thread_entry+0x688>)
 801901a:	6812      	ldr	r2, [r2, #0]
 801901c:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 8019020:	4611      	mov	r1, r2
 8019022:	7afa      	ldrb	r2, [r7, #11]
 8019024:	440b      	add	r3, r1
 8019026:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                if (shell->echo_mode)
 801902a:	4b20      	ldr	r3, [pc, #128]	; (80190ac <finsh_thread_entry+0x688>)
 801902c:	681b      	ldr	r3, [r3, #0]
 801902e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8019032:	f003 0301 	and.w	r3, r3, #1
 8019036:	b2db      	uxtb	r3, r3
 8019038:	2b00      	cmp	r3, #0
 801903a:	d004      	beq.n	8019046 <finsh_thread_entry+0x622>
                    rt_kprintf("%c", ch);
 801903c:	7afb      	ldrb	r3, [r7, #11]
 801903e:	481e      	ldr	r0, [pc, #120]	; (80190b8 <finsh_thread_entry+0x694>)
 8019040:	4619      	mov	r1, r3
 8019042:	f7fa fe15 	bl	8013c70 <rt_kprintf>
            }

            ch = 0;
 8019046:	2300      	movs	r3, #0
 8019048:	72fb      	strb	r3, [r7, #11]
            shell->line_position ++;
 801904a:	4b18      	ldr	r3, [pc, #96]	; (80190ac <finsh_thread_entry+0x688>)
 801904c:	681b      	ldr	r3, [r3, #0]
 801904e:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 8019052:	3201      	adds	r2, #1
 8019054:	b2d2      	uxtb	r2, r2
 8019056:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
            shell->line_curpos++;
 801905a:	4b14      	ldr	r3, [pc, #80]	; (80190ac <finsh_thread_entry+0x688>)
 801905c:	681b      	ldr	r3, [r3, #0]
 801905e:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 8019062:	3201      	adds	r2, #1
 8019064:	b2d2      	uxtb	r2, r2
 8019066:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
            if (shell->line_position >= 80)
 801906a:	4b10      	ldr	r3, [pc, #64]	; (80190ac <finsh_thread_entry+0x688>)
 801906c:	681b      	ldr	r3, [r3, #0]
 801906e:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 8019072:	2b4f      	cmp	r3, #79	; 0x4f
 8019074:	d909      	bls.n	801908a <finsh_thread_entry+0x666>
            {
                /* clear command line */
                shell->line_position = 0;
 8019076:	4b0d      	ldr	r3, [pc, #52]	; (80190ac <finsh_thread_entry+0x688>)
 8019078:	681b      	ldr	r3, [r3, #0]
 801907a:	2200      	movs	r2, #0
 801907c:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
                shell->line_curpos = 0;
 8019080:	4b0a      	ldr	r3, [pc, #40]	; (80190ac <finsh_thread_entry+0x688>)
 8019082:	681b      	ldr	r3, [r3, #0]
 8019084:	2200      	movs	r2, #0
 8019086:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
 801908a:	4b08      	ldr	r3, [pc, #32]	; (80190ac <finsh_thread_entry+0x688>)
 801908c:	681b      	ldr	r3, [r3, #0]
 801908e:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
 8019092:	f107 030b 	add.w	r3, r7, #11
 8019096:	4610      	mov	r0, r2
 8019098:	2100      	movs	r1, #0
 801909a:	461a      	mov	r2, r3
 801909c:	2301      	movs	r3, #1
 801909e:	f7f9 f847 	bl	8012130 <rt_device_read>
 80190a2:	4603      	mov	r3, r0
 80190a4:	2b01      	cmp	r3, #1
 80190a6:	f43f ad0c 	beq.w	8018ac2 <finsh_thread_entry+0x9e>
                /* clear command line */
                shell->line_position = 0;
                shell->line_curpos = 0;
            }
        } /* end of device read */
    }
 80190aa:	e4fe      	b.n	8018aaa <finsh_thread_entry+0x86>
 80190ac:	200126e0 	.word	0x200126e0
 80190b0:	08023ae8 	.word	0x08023ae8
 80190b4:	08023ad4 	.word	0x08023ad4
 80190b8:	08023ad8 	.word	0x08023ad8

080190bc <finsh_system_function_init>:
}

void finsh_system_function_init(const void *begin, const void *end)
{
 80190bc:	b480      	push	{r7}
 80190be:	b083      	sub	sp, #12
 80190c0:	af00      	add	r7, sp, #0
 80190c2:	6078      	str	r0, [r7, #4]
 80190c4:	6039      	str	r1, [r7, #0]
    _syscall_table_begin = (struct finsh_syscall *) begin;
 80190c6:	4a05      	ldr	r2, [pc, #20]	; (80190dc <finsh_system_function_init+0x20>)
 80190c8:	687b      	ldr	r3, [r7, #4]
 80190ca:	6013      	str	r3, [r2, #0]
    _syscall_table_end = (struct finsh_syscall *) end;
 80190cc:	4a04      	ldr	r2, [pc, #16]	; (80190e0 <finsh_system_function_init+0x24>)
 80190ce:	683b      	ldr	r3, [r7, #0]
 80190d0:	6013      	str	r3, [r2, #0]
}
 80190d2:	370c      	adds	r7, #12
 80190d4:	46bd      	mov	sp, r7
 80190d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80190da:	4770      	bx	lr
 80190dc:	200121cc 	.word	0x200121cc
 80190e0:	200121d0 	.word	0x200121d0

080190e4 <finsh_system_var_init>:

void finsh_system_var_init(const void *begin, const void *end)
{
 80190e4:	b480      	push	{r7}
 80190e6:	b083      	sub	sp, #12
 80190e8:	af00      	add	r7, sp, #0
 80190ea:	6078      	str	r0, [r7, #4]
 80190ec:	6039      	str	r1, [r7, #0]
    _sysvar_table_begin = (struct finsh_sysvar *) begin;
 80190ee:	4a05      	ldr	r2, [pc, #20]	; (8019104 <finsh_system_var_init+0x20>)
 80190f0:	687b      	ldr	r3, [r7, #4]
 80190f2:	6013      	str	r3, [r2, #0]
    _sysvar_table_end = (struct finsh_sysvar *) end;
 80190f4:	4a04      	ldr	r2, [pc, #16]	; (8019108 <finsh_system_var_init+0x24>)
 80190f6:	683b      	ldr	r3, [r7, #0]
 80190f8:	6013      	str	r3, [r2, #0]
}
 80190fa:	370c      	adds	r7, #12
 80190fc:	46bd      	mov	sp, r7
 80190fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019102:	4770      	bx	lr
 8019104:	200121d4 	.word	0x200121d4
 8019108:	200121d8 	.word	0x200121d8

0801910c <finsh_system_init>:
 * @ingroup finsh
 *
 * This function will initialize finsh shell
 */
int finsh_system_init(void)
{
 801910c:	b580      	push	{r7, lr}
 801910e:	b086      	sub	sp, #24
 8019110:	af04      	add	r7, sp, #16
    /* GNU GCC Compiler and TI CCS */
    extern const int __fsymtab_start;
    extern const int __fsymtab_end;
    extern const int __vsymtab_start;
    extern const int __vsymtab_end;
    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
 8019112:	4822      	ldr	r0, [pc, #136]	; (801919c <finsh_system_init+0x90>)
 8019114:	4922      	ldr	r1, [pc, #136]	; (80191a0 <finsh_system_init+0x94>)
 8019116:	f7ff ffd1 	bl	80190bc <finsh_system_function_init>
    finsh_system_var_init(&__vsymtab_start, &__vsymtab_end);
 801911a:	4822      	ldr	r0, [pc, #136]	; (80191a4 <finsh_system_init+0x98>)
 801911c:	4922      	ldr	r1, [pc, #136]	; (80191a8 <finsh_system_init+0x9c>)
 801911e:	f7ff ffe1 	bl	80190e4 <finsh_system_var_init>
#endif
#endif

    /* create or set shell structure */
#ifdef RT_USING_HEAP
    shell = (struct finsh_shell *)rt_malloc(sizeof(struct finsh_shell));
 8019122:	f44f 702b 	mov.w	r0, #684	; 0x2ac
 8019126:	f7fa ff51 	bl	8013fcc <rt_malloc>
 801912a:	4602      	mov	r2, r0
 801912c:	4b1f      	ldr	r3, [pc, #124]	; (80191ac <finsh_system_init+0xa0>)
 801912e:	601a      	str	r2, [r3, #0]
    if (shell == RT_NULL)
 8019130:	4b1e      	ldr	r3, [pc, #120]	; (80191ac <finsh_system_init+0xa0>)
 8019132:	681b      	ldr	r3, [r3, #0]
 8019134:	2b00      	cmp	r3, #0
 8019136:	d105      	bne.n	8019144 <finsh_system_init+0x38>
    {
        rt_kprintf("no memory for shell\n");
 8019138:	481d      	ldr	r0, [pc, #116]	; (80191b0 <finsh_system_init+0xa4>)
 801913a:	f7fa fd99 	bl	8013c70 <rt_kprintf>
        return -1;
 801913e:	f04f 33ff 	mov.w	r3, #4294967295
 8019142:	e026      	b.n	8019192 <finsh_system_init+0x86>
    }
#else
    shell = &_shell;
#endif

    memset(shell, 0, sizeof(struct finsh_shell));
 8019144:	4b19      	ldr	r3, [pc, #100]	; (80191ac <finsh_system_init+0xa0>)
 8019146:	681b      	ldr	r3, [r3, #0]
 8019148:	4618      	mov	r0, r3
 801914a:	2100      	movs	r1, #0
 801914c:	f44f 722b 	mov.w	r2, #684	; 0x2ac
 8019150:	f005 fff0 	bl	801f134 <memset>

    rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
 8019154:	4b15      	ldr	r3, [pc, #84]	; (80191ac <finsh_system_init+0xa0>)
 8019156:	681b      	ldr	r3, [r3, #0]
 8019158:	4618      	mov	r0, r3
 801915a:	4916      	ldr	r1, [pc, #88]	; (80191b4 <finsh_system_init+0xa8>)
 801915c:	2200      	movs	r2, #0
 801915e:	2300      	movs	r3, #0
 8019160:	f7f9 fa0c 	bl	801257c <rt_sem_init>
    result = rt_thread_init(&finsh_thread,
 8019164:	4b14      	ldr	r3, [pc, #80]	; (80191b8 <finsh_system_init+0xac>)
 8019166:	9300      	str	r3, [sp, #0]
 8019168:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801916c:	9301      	str	r3, [sp, #4]
 801916e:	230a      	movs	r3, #10
 8019170:	9302      	str	r3, [sp, #8]
 8019172:	230a      	movs	r3, #10
 8019174:	9303      	str	r3, [sp, #12]
 8019176:	4811      	ldr	r0, [pc, #68]	; (80191bc <finsh_system_init+0xb0>)
 8019178:	4911      	ldr	r1, [pc, #68]	; (80191c0 <finsh_system_init+0xb4>)
 801917a:	4a12      	ldr	r2, [pc, #72]	; (80191c4 <finsh_system_init+0xb8>)
 801917c:	2300      	movs	r3, #0
 801917e:	f7fb fecb 	bl	8014f18 <rt_thread_init>
 8019182:	6078      	str	r0, [r7, #4]
                            "tshell",
                            finsh_thread_entry, RT_NULL,
                            &finsh_thread_stack[0], sizeof(finsh_thread_stack),
                            FINSH_THREAD_PRIORITY, 10);

    if (result == RT_EOK)
 8019184:	687b      	ldr	r3, [r7, #4]
 8019186:	2b00      	cmp	r3, #0
 8019188:	d102      	bne.n	8019190 <finsh_system_init+0x84>
        rt_thread_startup(&finsh_thread);
 801918a:	480c      	ldr	r0, [pc, #48]	; (80191bc <finsh_system_init+0xb0>)
 801918c:	f7fb ff06 	bl	8014f9c <rt_thread_startup>
    return 0;
 8019190:	2300      	movs	r3, #0
}
 8019192:	4618      	mov	r0, r3
 8019194:	3708      	adds	r7, #8
 8019196:	46bd      	mov	sp, r7
 8019198:	bd80      	pop	{r7, pc}
 801919a:	bf00      	nop
 801919c:	08025db8 	.word	0x08025db8
 80191a0:	08026010 	.word	0x08026010
 80191a4:	08026010 	.word	0x08026010
 80191a8:	08026020 	.word	0x08026020
 80191ac:	200126e0 	.word	0x200126e0
 80191b0:	08023aec 	.word	0x08023aec
 80191b4:	08023b04 	.word	0x08023b04
 80191b8:	20011148 	.word	0x20011148
 80191bc:	200110c8 	.word	0x200110c8
 80191c0:	08023b0c 	.word	0x08023b0c
 80191c4:	08018a25 	.word	0x08018a25

080191c8 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 80191c8:	b480      	push	{r7}
 80191ca:	b083      	sub	sp, #12
 80191cc:	af00      	add	r7, sp, #0
 80191ce:	6078      	str	r0, [r7, #4]
    return l->next == l;
 80191d0:	687b      	ldr	r3, [r7, #4]
 80191d2:	681a      	ldr	r2, [r3, #0]
 80191d4:	687b      	ldr	r3, [r7, #4]
 80191d6:	429a      	cmp	r2, r3
 80191d8:	bf0c      	ite	eq
 80191da:	2301      	moveq	r3, #1
 80191dc:	2300      	movne	r3, #0
 80191de:	b2db      	uxtb	r3, r3
}
 80191e0:	4618      	mov	r0, r3
 80191e2:	370c      	adds	r7, #12
 80191e4:	46bd      	mov	sp, r7
 80191e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80191ea:	4770      	bx	lr

080191ec <rt_list_len>:

#include <rtthread.h>
#include "finsh.h"

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
 80191ec:	b480      	push	{r7}
 80191ee:	b085      	sub	sp, #20
 80191f0:	af00      	add	r7, sp, #0
 80191f2:	6078      	str	r0, [r7, #4]
    unsigned int len = 0;
 80191f4:	2300      	movs	r3, #0
 80191f6:	60fb      	str	r3, [r7, #12]
    const rt_list_t *p = l;
 80191f8:	687b      	ldr	r3, [r7, #4]
 80191fa:	60bb      	str	r3, [r7, #8]
    while (p->next != l)
 80191fc:	e005      	b.n	801920a <rt_list_len+0x1e>
    {
        p = p->next;
 80191fe:	68bb      	ldr	r3, [r7, #8]
 8019200:	681b      	ldr	r3, [r3, #0]
 8019202:	60bb      	str	r3, [r7, #8]
        len ++;
 8019204:	68fb      	ldr	r3, [r7, #12]
 8019206:	3301      	adds	r3, #1
 8019208:	60fb      	str	r3, [r7, #12]

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
    unsigned int len = 0;
    const rt_list_t *p = l;
    while (p->next != l)
 801920a:	68bb      	ldr	r3, [r7, #8]
 801920c:	681a      	ldr	r2, [r3, #0]
 801920e:	687b      	ldr	r3, [r7, #4]
 8019210:	429a      	cmp	r2, r3
 8019212:	d1f4      	bne.n	80191fe <rt_list_len+0x12>
    {
        p = p->next;
        len ++;
    }

    return len;
 8019214:	68fb      	ldr	r3, [r7, #12]
}
 8019216:	4618      	mov	r0, r3
 8019218:	3714      	adds	r7, #20
 801921a:	46bd      	mov	sp, r7
 801921c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019220:	4770      	bx	lr
 8019222:	bf00      	nop

08019224 <hello>:

long hello(void)
{
 8019224:	b580      	push	{r7, lr}
 8019226:	af00      	add	r7, sp, #0
    rt_kprintf("Hello RT-Thread!\n");
 8019228:	4802      	ldr	r0, [pc, #8]	; (8019234 <hello+0x10>)
 801922a:	f7fa fd21 	bl	8013c70 <rt_kprintf>

    return 0;
 801922e:	2300      	movs	r3, #0
}
 8019230:	4618      	mov	r0, r3
 8019232:	bd80      	pop	{r7, pc}
 8019234:	08023b14 	.word	0x08023b14

08019238 <version>:
FINSH_FUNCTION_EXPORT(hello, say hello world);

extern void rt_show_version(void);
long version(void)
{
 8019238:	b580      	push	{r7, lr}
 801923a:	af00      	add	r7, sp, #0
    rt_show_version();
 801923c:	f7fa f8d8 	bl	80133f0 <rt_show_version>

    return 0;
 8019240:	2300      	movs	r3, #0
}
 8019242:	4618      	mov	r0, r3
 8019244:	bd80      	pop	{r7, pc}
 8019246:	bf00      	nop

08019248 <_list_thread>:
MSH_CMD_EXPORT(version, show RT-Thread version information);

extern struct rt_object_information rt_object_container[];

static long _list_thread(struct rt_list_node *list)
{
 8019248:	b5b0      	push	{r4, r5, r7, lr}
 801924a:	b088      	sub	sp, #32
 801924c:	af02      	add	r7, sp, #8
 801924e:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
 8019250:	4837      	ldr	r0, [pc, #220]	; (8019330 <_list_thread+0xe8>)
 8019252:	f7fa fd0d 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
 8019256:	4837      	ldr	r0, [pc, #220]	; (8019334 <_list_thread+0xec>)
 8019258:	f7fa fd0a 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801925c:	687b      	ldr	r3, [r7, #4]
 801925e:	681b      	ldr	r3, [r3, #0]
 8019260:	617b      	str	r3, [r7, #20]
 8019262:	e05c      	b.n	801931e <_list_thread+0xd6>
    {
        thread = rt_list_entry(node, struct rt_thread, list);
 8019264:	697b      	ldr	r3, [r7, #20]
 8019266:	3b0c      	subs	r3, #12
 8019268:	60fb      	str	r3, [r7, #12]
        rt_kprintf("%-8.*s 0x%02x", RT_NAME_MAX, thread->name, thread->current_priority);
 801926a:	68fa      	ldr	r2, [r7, #12]
 801926c:	68fb      	ldr	r3, [r7, #12]
 801926e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8019272:	4831      	ldr	r0, [pc, #196]	; (8019338 <_list_thread+0xf0>)
 8019274:	2108      	movs	r1, #8
 8019276:	f7fa fcfb 	bl	8013c70 <rt_kprintf>

        if (thread->stat == RT_THREAD_READY)        rt_kprintf(" ready  ");
 801927a:	68fb      	ldr	r3, [r7, #12]
 801927c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8019280:	2b01      	cmp	r3, #1
 8019282:	d103      	bne.n	801928c <_list_thread+0x44>
 8019284:	482d      	ldr	r0, [pc, #180]	; (801933c <_list_thread+0xf4>)
 8019286:	f7fa fcf3 	bl	8013c70 <rt_kprintf>
 801928a:	e019      	b.n	80192c0 <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_SUSPEND) rt_kprintf(" suspend");
 801928c:	68fb      	ldr	r3, [r7, #12]
 801928e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8019292:	2b02      	cmp	r3, #2
 8019294:	d103      	bne.n	801929e <_list_thread+0x56>
 8019296:	482a      	ldr	r0, [pc, #168]	; (8019340 <_list_thread+0xf8>)
 8019298:	f7fa fcea 	bl	8013c70 <rt_kprintf>
 801929c:	e010      	b.n	80192c0 <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_INIT)    rt_kprintf(" init   ");
 801929e:	68fb      	ldr	r3, [r7, #12]
 80192a0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80192a4:	2b00      	cmp	r3, #0
 80192a6:	d103      	bne.n	80192b0 <_list_thread+0x68>
 80192a8:	4826      	ldr	r0, [pc, #152]	; (8019344 <_list_thread+0xfc>)
 80192aa:	f7fa fce1 	bl	8013c70 <rt_kprintf>
 80192ae:	e007      	b.n	80192c0 <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");
 80192b0:	68fb      	ldr	r3, [r7, #12]
 80192b2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80192b6:	2b04      	cmp	r3, #4
 80192b8:	d102      	bne.n	80192c0 <_list_thread+0x78>
 80192ba:	4823      	ldr	r0, [pc, #140]	; (8019348 <_list_thread+0x100>)
 80192bc:	f7fa fcd8 	bl	8013c70 <rt_kprintf>

        ptr = (rt_uint8_t*)thread->stack_addr;
 80192c0:	68fb      	ldr	r3, [r7, #12]
 80192c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80192c4:	613b      	str	r3, [r7, #16]
        while (*ptr == '#')ptr ++;
 80192c6:	e002      	b.n	80192ce <_list_thread+0x86>
 80192c8:	693b      	ldr	r3, [r7, #16]
 80192ca:	3301      	adds	r3, #1
 80192cc:	613b      	str	r3, [r7, #16]
 80192ce:	693b      	ldr	r3, [r7, #16]
 80192d0:	781b      	ldrb	r3, [r3, #0]
 80192d2:	2b23      	cmp	r3, #35	; 0x23
 80192d4:	d0f8      	beq.n	80192c8 <_list_thread+0x80>

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
 80192d6:	68fb      	ldr	r3, [r7, #12]
 80192d8:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 80192da:	461a      	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
 80192dc:	68fb      	ldr	r3, [r7, #12]
 80192de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80192e0:	4619      	mov	r1, r3
 80192e2:	68fb      	ldr	r3, [r7, #12]
 80192e4:	69db      	ldr	r3, [r3, #28]
 80192e6:	1acb      	subs	r3, r1, r3
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 80192e8:	18d1      	adds	r1, r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
 80192ea:	68fb      	ldr	r3, [r7, #12]
 80192ec:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 80192ee:	461d      	mov	r5, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
 80192f0:	68fb      	ldr	r3, [r7, #12]
 80192f2:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 80192f4:	461a      	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
 80192f6:	68fb      	ldr	r3, [r7, #12]
 80192f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80192fa:	4618      	mov	r0, r3
 80192fc:	693b      	ldr	r3, [r7, #16]
 80192fe:	1ac3      	subs	r3, r0, r3
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 8019300:	18d4      	adds	r4, r2, r3
 8019302:	68fb      	ldr	r3, [r7, #12]
 8019304:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8019306:	68fb      	ldr	r3, [r7, #12]
 8019308:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801930a:	9200      	str	r2, [sp, #0]
 801930c:	9301      	str	r3, [sp, #4]
 801930e:	480f      	ldr	r0, [pc, #60]	; (801934c <_list_thread+0x104>)
 8019310:	462a      	mov	r2, r5
 8019312:	4623      	mov	r3, r4
 8019314:	f7fa fcac 	bl	8013c70 <rt_kprintf>
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
    for (node = list->next; node != list; node = node->next)
 8019318:	697b      	ldr	r3, [r7, #20]
 801931a:	681b      	ldr	r3, [r3, #0]
 801931c:	617b      	str	r3, [r7, #20]
 801931e:	697a      	ldr	r2, [r7, #20]
 8019320:	687b      	ldr	r3, [r7, #4]
 8019322:	429a      	cmp	r2, r3
 8019324:	d19e      	bne.n	8019264 <_list_thread+0x1c>
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
            thread->remaining_tick,
            thread->error);
    }
	
    return 0;
 8019326:	2300      	movs	r3, #0
}
 8019328:	4618      	mov	r0, r3
 801932a:	3718      	adds	r7, #24
 801932c:	46bd      	mov	sp, r7
 801932e:	bdb0      	pop	{r4, r5, r7, pc}
 8019330:	08023b28 	.word	0x08023b28
 8019334:	08023b74 	.word	0x08023b74
 8019338:	08023bbc 	.word	0x08023bbc
 801933c:	08023bcc 	.word	0x08023bcc
 8019340:	08023bd8 	.word	0x08023bd8
 8019344:	08023be4 	.word	0x08023be4
 8019348:	08023bf0 	.word	0x08023bf0
 801934c:	08023bfc 	.word	0x08023bfc

08019350 <list_thread>:

long list_thread(void)
{
 8019350:	b580      	push	{r7, lr}
 8019352:	af00      	add	r7, sp, #0
    return _list_thread(&rt_object_container[RT_Object_Class_Thread].object_list);
 8019354:	4802      	ldr	r0, [pc, #8]	; (8019360 <list_thread+0x10>)
 8019356:	f7ff ff77 	bl	8019248 <_list_thread>
 801935a:	4603      	mov	r3, r0
}
 801935c:	4618      	mov	r0, r3
 801935e:	bd80      	pop	{r7, pc}
 8019360:	20010018 	.word	0x20010018

08019364 <show_wait_queue>:
FINSH_FUNCTION_EXPORT(list_thread, list thread);
MSH_CMD_EXPORT(list_thread, list thread);

static void show_wait_queue(struct rt_list_node *list)
{
 8019364:	b580      	push	{r7, lr}
 8019366:	b084      	sub	sp, #16
 8019368:	af00      	add	r7, sp, #0
 801936a:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
 801936c:	687b      	ldr	r3, [r7, #4]
 801936e:	681b      	ldr	r3, [r3, #0]
 8019370:	60fb      	str	r3, [r7, #12]
 8019372:	e012      	b.n	801939a <show_wait_queue+0x36>
    {
        thread = rt_list_entry(node, struct rt_thread, tlist);
 8019374:	68fb      	ldr	r3, [r7, #12]
 8019376:	3b14      	subs	r3, #20
 8019378:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%s", thread->name);
 801937a:	68bb      	ldr	r3, [r7, #8]
 801937c:	480a      	ldr	r0, [pc, #40]	; (80193a8 <show_wait_queue+0x44>)
 801937e:	4619      	mov	r1, r3
 8019380:	f7fa fc76 	bl	8013c70 <rt_kprintf>

        if (node->next != list)
 8019384:	68fb      	ldr	r3, [r7, #12]
 8019386:	681a      	ldr	r2, [r3, #0]
 8019388:	687b      	ldr	r3, [r7, #4]
 801938a:	429a      	cmp	r2, r3
 801938c:	d002      	beq.n	8019394 <show_wait_queue+0x30>
            rt_kprintf("/");
 801938e:	4807      	ldr	r0, [pc, #28]	; (80193ac <show_wait_queue+0x48>)
 8019390:	f7fa fc6e 	bl	8013c70 <rt_kprintf>
static void show_wait_queue(struct rt_list_node *list)
{
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
 8019394:	68fb      	ldr	r3, [r7, #12]
 8019396:	681b      	ldr	r3, [r3, #0]
 8019398:	60fb      	str	r3, [r7, #12]
 801939a:	68fa      	ldr	r2, [r7, #12]
 801939c:	687b      	ldr	r3, [r7, #4]
 801939e:	429a      	cmp	r2, r3
 80193a0:	d1e8      	bne.n	8019374 <show_wait_queue+0x10>
        rt_kprintf("%s", thread->name);

        if (node->next != list)
            rt_kprintf("/");
    }
}
 80193a2:	3710      	adds	r7, #16
 80193a4:	46bd      	mov	sp, r7
 80193a6:	bd80      	pop	{r7, pc}
 80193a8:	08023c20 	.word	0x08023c20
 80193ac:	08023c24 	.word	0x08023c24

080193b0 <_list_sem>:

#ifdef RT_USING_SEMAPHORE
static long _list_sem(struct rt_list_node *list)
{
 80193b0:	b5b0      	push	{r4, r5, r7, lr}
 80193b2:	b086      	sub	sp, #24
 80193b4:	af02      	add	r7, sp, #8
 80193b6:	6078      	str	r0, [r7, #4]
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
 80193b8:	4825      	ldr	r0, [pc, #148]	; (8019450 <_list_sem+0xa0>)
 80193ba:	f7fa fc59 	bl	8013c70 <rt_kprintf>
    rt_kprintf("--------  --- --------------\n");
 80193be:	4825      	ldr	r0, [pc, #148]	; (8019454 <_list_sem+0xa4>)
 80193c0:	f7fa fc56 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 80193c4:	687b      	ldr	r3, [r7, #4]
 80193c6:	681b      	ldr	r3, [r3, #0]
 80193c8:	60fb      	str	r3, [r7, #12]
 80193ca:	e038      	b.n	801943e <_list_sem+0x8e>
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
 80193cc:	68fb      	ldr	r3, [r7, #12]
 80193ce:	3b0c      	subs	r3, #12
 80193d0:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&sem->parent.suspend_thread))
 80193d2:	68bb      	ldr	r3, [r7, #8]
 80193d4:	3314      	adds	r3, #20
 80193d6:	4618      	mov	r0, r3
 80193d8:	f7ff fef6 	bl	80191c8 <rt_list_isempty>
 80193dc:	4603      	mov	r3, r0
 80193de:	2b00      	cmp	r3, #0
 80193e0:	d119      	bne.n	8019416 <_list_sem+0x66>
        {
            rt_kprintf("%-8.*s  %03d %d:", 
                       RT_NAME_MAX,
                       sem->parent.parent.name,
 80193e2:	68bc      	ldr	r4, [r7, #8]
                       sem->value,
 80193e4:	68bb      	ldr	r3, [r7, #8]
 80193e6:	8b9b      	ldrh	r3, [r3, #28]
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
 80193e8:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
 80193ea:	68bb      	ldr	r3, [r7, #8]
 80193ec:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
 80193ee:	4618      	mov	r0, r3
 80193f0:	f7ff fefc 	bl	80191ec <rt_list_len>
 80193f4:	4603      	mov	r3, r0
 80193f6:	9300      	str	r3, [sp, #0]
 80193f8:	4817      	ldr	r0, [pc, #92]	; (8019458 <_list_sem+0xa8>)
 80193fa:	2108      	movs	r1, #8
 80193fc:	4622      	mov	r2, r4
 80193fe:	462b      	mov	r3, r5
 8019400:	f7fa fc36 	bl	8013c70 <rt_kprintf>
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
            show_wait_queue(&(sem->parent.suspend_thread));
 8019404:	68bb      	ldr	r3, [r7, #8]
 8019406:	3314      	adds	r3, #20
 8019408:	4618      	mov	r0, r3
 801940a:	f7ff ffab 	bl	8019364 <show_wait_queue>
            rt_kprintf("\n");
 801940e:	4813      	ldr	r0, [pc, #76]	; (801945c <_list_sem+0xac>)
 8019410:	f7fa fc2e 	bl	8013c70 <rt_kprintf>
 8019414:	e010      	b.n	8019438 <_list_sem+0x88>
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
                       RT_NAME_MAX,
                       sem->parent.parent.name,
 8019416:	68bc      	ldr	r4, [r7, #8]
                       sem->value,
 8019418:	68bb      	ldr	r3, [r7, #8]
 801941a:	8b9b      	ldrh	r3, [r3, #28]
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
 801941c:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
 801941e:	68bb      	ldr	r3, [r7, #8]
 8019420:	3314      	adds	r3, #20
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
 8019422:	4618      	mov	r0, r3
 8019424:	f7ff fee2 	bl	80191ec <rt_list_len>
 8019428:	4603      	mov	r3, r0
 801942a:	9300      	str	r3, [sp, #0]
 801942c:	480c      	ldr	r0, [pc, #48]	; (8019460 <_list_sem+0xb0>)
 801942e:	2108      	movs	r1, #8
 8019430:	4622      	mov	r2, r4
 8019432:	462b      	mov	r3, r5
 8019434:	f7fa fc1c 	bl	8013c70 <rt_kprintf>
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
    rt_kprintf("--------  --- --------------\n");
    for (node = list->next; node != list; node = node->next)
 8019438:	68fb      	ldr	r3, [r7, #12]
 801943a:	681b      	ldr	r3, [r3, #0]
 801943c:	60fb      	str	r3, [r7, #12]
 801943e:	68fa      	ldr	r2, [r7, #12]
 8019440:	687b      	ldr	r3, [r7, #4]
 8019442:	429a      	cmp	r2, r3
 8019444:	d1c2      	bne.n	80193cc <_list_sem+0x1c>
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
        }
    }

    return 0;
 8019446:	2300      	movs	r3, #0
}
 8019448:	4618      	mov	r0, r3
 801944a:	3710      	adds	r7, #16
 801944c:	46bd      	mov	sp, r7
 801944e:	bdb0      	pop	{r4, r5, r7, pc}
 8019450:	08023c28 	.word	0x08023c28
 8019454:	08023c48 	.word	0x08023c48
 8019458:	08023c68 	.word	0x08023c68
 801945c:	08023c7c 	.word	0x08023c7c
 8019460:	08023c80 	.word	0x08023c80

08019464 <list_sem>:

long list_sem(void)
{
 8019464:	b580      	push	{r7, lr}
 8019466:	af00      	add	r7, sp, #0
    return _list_sem(&rt_object_container[RT_Object_Class_Semaphore].object_list);
 8019468:	4802      	ldr	r0, [pc, #8]	; (8019474 <list_sem+0x10>)
 801946a:	f7ff ffa1 	bl	80193b0 <_list_sem>
 801946e:	4603      	mov	r3, r0
}
 8019470:	4618      	mov	r0, r3
 8019472:	bd80      	pop	{r7, pc}
 8019474:	20010028 	.word	0x20010028

08019478 <_list_event>:
MSH_CMD_EXPORT(list_sem, list semaphore in system);
#endif

#ifdef RT_USING_EVENT
static long _list_event(struct rt_list_node *list)
{
 8019478:	b5b0      	push	{r4, r5, r7, lr}
 801947a:	b086      	sub	sp, #24
 801947c:	af02      	add	r7, sp, #8
 801947e:	6078      	str	r0, [r7, #4]
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
 8019480:	4820      	ldr	r0, [pc, #128]	; (8019504 <_list_event+0x8c>)
 8019482:	f7fa fbf5 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- ---------- --------------\n");
 8019486:	4820      	ldr	r0, [pc, #128]	; (8019508 <_list_event+0x90>)
 8019488:	f7fa fbf2 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801948c:	687b      	ldr	r3, [r7, #4]
 801948e:	681b      	ldr	r3, [r3, #0]
 8019490:	60fb      	str	r3, [r7, #12]
 8019492:	e02d      	b.n	80194f0 <_list_event+0x78>
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
 8019494:	68fb      	ldr	r3, [r7, #12]
 8019496:	3b0c      	subs	r3, #12
 8019498:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&e->parent.suspend_thread))
 801949a:	68bb      	ldr	r3, [r7, #8]
 801949c:	3314      	adds	r3, #20
 801949e:	4618      	mov	r0, r3
 80194a0:	f7ff fe92 	bl	80191c8 <rt_list_isempty>
 80194a4:	4603      	mov	r3, r0
 80194a6:	2b00      	cmp	r3, #0
 80194a8:	d118      	bne.n	80194dc <_list_event+0x64>
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
                       RT_NAME_MAX,
                       e->parent.parent.name,
 80194aa:	68bd      	ldr	r5, [r7, #8]
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
 80194ac:	68bb      	ldr	r3, [r7, #8]
 80194ae:	69dc      	ldr	r4, [r3, #28]
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
 80194b0:	68bb      	ldr	r3, [r7, #8]
 80194b2:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
 80194b4:	4618      	mov	r0, r3
 80194b6:	f7ff fe99 	bl	80191ec <rt_list_len>
 80194ba:	4603      	mov	r3, r0
 80194bc:	9300      	str	r3, [sp, #0]
 80194be:	4813      	ldr	r0, [pc, #76]	; (801950c <_list_event+0x94>)
 80194c0:	2108      	movs	r1, #8
 80194c2:	462a      	mov	r2, r5
 80194c4:	4623      	mov	r3, r4
 80194c6:	f7fa fbd3 	bl	8013c70 <rt_kprintf>
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
            show_wait_queue(&(e->parent.suspend_thread));
 80194ca:	68bb      	ldr	r3, [r7, #8]
 80194cc:	3314      	adds	r3, #20
 80194ce:	4618      	mov	r0, r3
 80194d0:	f7ff ff48 	bl	8019364 <show_wait_queue>
            rt_kprintf("\n");
 80194d4:	480e      	ldr	r0, [pc, #56]	; (8019510 <_list_event+0x98>)
 80194d6:	f7fa fbcb 	bl	8013c70 <rt_kprintf>
 80194da:	e006      	b.n	80194ea <_list_event+0x72>
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
 80194dc:	68ba      	ldr	r2, [r7, #8]
            show_wait_queue(&(e->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
 80194de:	68bb      	ldr	r3, [r7, #8]
 80194e0:	69db      	ldr	r3, [r3, #28]
 80194e2:	480c      	ldr	r0, [pc, #48]	; (8019514 <_list_event+0x9c>)
 80194e4:	2108      	movs	r1, #8
 80194e6:	f7fa fbc3 	bl	8013c70 <rt_kprintf>
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
    rt_kprintf("-------- ---------- --------------\n");
    for (node = list->next; node != list; node = node->next)
 80194ea:	68fb      	ldr	r3, [r7, #12]
 80194ec:	681b      	ldr	r3, [r3, #0]
 80194ee:	60fb      	str	r3, [r7, #12]
 80194f0:	68fa      	ldr	r2, [r7, #12]
 80194f2:	687b      	ldr	r3, [r7, #4]
 80194f4:	429a      	cmp	r2, r3
 80194f6:	d1cd      	bne.n	8019494 <_list_event+0x1c>
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
        }
    }

    return 0;
 80194f8:	2300      	movs	r3, #0
}
 80194fa:	4618      	mov	r0, r3
 80194fc:	3710      	adds	r7, #16
 80194fe:	46bd      	mov	sp, r7
 8019500:	bdb0      	pop	{r4, r5, r7, pc}
 8019502:	bf00      	nop
 8019504:	08023c94 	.word	0x08023c94
 8019508:	08023cb8 	.word	0x08023cb8
 801950c:	08023cdc 	.word	0x08023cdc
 8019510:	08023c7c 	.word	0x08023c7c
 8019514:	08023cf4 	.word	0x08023cf4

08019518 <list_event>:

long list_event(void)
{
 8019518:	b580      	push	{r7, lr}
 801951a:	af00      	add	r7, sp, #0
    return _list_event(&rt_object_container[RT_Object_Class_Event].object_list);
 801951c:	4802      	ldr	r0, [pc, #8]	; (8019528 <list_event+0x10>)
 801951e:	f7ff ffab 	bl	8019478 <_list_event>
 8019522:	4603      	mov	r3, r0
}
 8019524:	4618      	mov	r0, r3
 8019526:	bd80      	pop	{r7, pc}
 8019528:	20010048 	.word	0x20010048

0801952c <_list_mutex>:
MSH_CMD_EXPORT(list_event, list event in system);
#endif

#ifdef RT_USING_MUTEX
static long _list_mutex(struct rt_list_node *list)
{
 801952c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801952e:	b089      	sub	sp, #36	; 0x24
 8019530:	af04      	add	r7, sp, #16
 8019532:	6078      	str	r0, [r7, #4]
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
 8019534:	4817      	ldr	r0, [pc, #92]	; (8019594 <_list_mutex+0x68>)
 8019536:	f7fa fb9b 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- -------- ---- --------------\n");
 801953a:	4817      	ldr	r0, [pc, #92]	; (8019598 <_list_mutex+0x6c>)
 801953c:	f7fa fb98 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 8019540:	687b      	ldr	r3, [r7, #4]
 8019542:	681b      	ldr	r3, [r3, #0]
 8019544:	60fb      	str	r3, [r7, #12]
 8019546:	e01b      	b.n	8019580 <_list_mutex+0x54>
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
 8019548:	68fb      	ldr	r3, [r7, #12]
 801954a:	3b0c      	subs	r3, #12
 801954c:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
                   RT_NAME_MAX,
                   m->parent.parent.name,
 801954e:	68bc      	ldr	r4, [r7, #8]
                   RT_NAME_MAX,
                   m->owner->name,
 8019550:	68bb      	ldr	r3, [r7, #8]
 8019552:	6a1b      	ldr	r3, [r3, #32]
 8019554:	461e      	mov	r6, r3
                   m->hold,
 8019556:	68bb      	ldr	r3, [r7, #8]
 8019558:	7fdb      	ldrb	r3, [r3, #31]
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
 801955a:	461d      	mov	r5, r3
                   RT_NAME_MAX,
                   m->parent.parent.name,
                   RT_NAME_MAX,
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
 801955c:	68bb      	ldr	r3, [r7, #8]
 801955e:	3314      	adds	r3, #20
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
 8019560:	4618      	mov	r0, r3
 8019562:	f7ff fe43 	bl	80191ec <rt_list_len>
 8019566:	4603      	mov	r3, r0
 8019568:	9600      	str	r6, [sp, #0]
 801956a:	9501      	str	r5, [sp, #4]
 801956c:	9302      	str	r3, [sp, #8]
 801956e:	480b      	ldr	r0, [pc, #44]	; (801959c <_list_mutex+0x70>)
 8019570:	2108      	movs	r1, #8
 8019572:	4622      	mov	r2, r4
 8019574:	2308      	movs	r3, #8
 8019576:	f7fa fb7b 	bl	8013c70 <rt_kprintf>
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801957a:	68fb      	ldr	r3, [r7, #12]
 801957c:	681b      	ldr	r3, [r3, #0]
 801957e:	60fb      	str	r3, [r7, #12]
 8019580:	68fa      	ldr	r2, [r7, #12]
 8019582:	687b      	ldr	r3, [r7, #4]
 8019584:	429a      	cmp	r2, r3
 8019586:	d1df      	bne.n	8019548 <_list_mutex+0x1c>
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
    }

    return 0;
 8019588:	2300      	movs	r3, #0
}
 801958a:	4618      	mov	r0, r3
 801958c:	3714      	adds	r7, #20
 801958e:	46bd      	mov	sp, r7
 8019590:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8019592:	bf00      	nop
 8019594:	08023d08 	.word	0x08023d08
 8019598:	08023d30 	.word	0x08023d30
 801959c:	08023d58 	.word	0x08023d58

080195a0 <list_mutex>:

long list_mutex(void)
{
 80195a0:	b580      	push	{r7, lr}
 80195a2:	af00      	add	r7, sp, #0
    return _list_mutex(&rt_object_container[RT_Object_Class_Mutex].object_list);
 80195a4:	4802      	ldr	r0, [pc, #8]	; (80195b0 <list_mutex+0x10>)
 80195a6:	f7ff ffc1 	bl	801952c <_list_mutex>
 80195aa:	4603      	mov	r3, r0
}
 80195ac:	4618      	mov	r0, r3
 80195ae:	bd80      	pop	{r7, pc}
 80195b0:	20010038 	.word	0x20010038

080195b4 <_list_mailbox>:
MSH_CMD_EXPORT(list_mutex, list mutex in system);
#endif

#ifdef RT_USING_MAILBOX
static long _list_mailbox(struct rt_list_node *list)
{
 80195b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80195b6:	b087      	sub	sp, #28
 80195b8:	af02      	add	r7, sp, #8
 80195ba:	6078      	str	r0, [r7, #4]
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
 80195bc:	4829      	ldr	r0, [pc, #164]	; (8019664 <_list_mailbox+0xb0>)
 80195be:	f7fa fb57 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- ----  ---- --------------\n");
 80195c2:	4829      	ldr	r0, [pc, #164]	; (8019668 <_list_mailbox+0xb4>)
 80195c4:	f7fa fb54 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 80195c8:	687b      	ldr	r3, [r7, #4]
 80195ca:	681b      	ldr	r3, [r3, #0]
 80195cc:	60fb      	str	r3, [r7, #12]
 80195ce:	e040      	b.n	8019652 <_list_mailbox+0x9e>
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
 80195d0:	68fb      	ldr	r3, [r7, #12]
 80195d2:	3b0c      	subs	r3, #12
 80195d4:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&m->parent.suspend_thread))
 80195d6:	68bb      	ldr	r3, [r7, #8]
 80195d8:	3314      	adds	r3, #20
 80195da:	4618      	mov	r0, r3
 80195dc:	f7ff fdf4 	bl	80191c8 <rt_list_isempty>
 80195e0:	4603      	mov	r3, r0
 80195e2:	2b00      	cmp	r3, #0
 80195e4:	d11d      	bne.n	8019622 <_list_mailbox+0x6e>
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 80195e6:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 80195e8:	68bb      	ldr	r3, [r7, #8]
 80195ea:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 80195ec:	461e      	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
 80195ee:	68bb      	ldr	r3, [r7, #8]
 80195f0:	8c1b      	ldrh	r3, [r3, #32]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 80195f2:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
 80195f4:	68bb      	ldr	r3, [r7, #8]
 80195f6:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 80195f8:	4618      	mov	r0, r3
 80195fa:	f7ff fdf7 	bl	80191ec <rt_list_len>
 80195fe:	4603      	mov	r3, r0
 8019600:	9500      	str	r5, [sp, #0]
 8019602:	9301      	str	r3, [sp, #4]
 8019604:	4819      	ldr	r0, [pc, #100]	; (801966c <_list_mailbox+0xb8>)
 8019606:	2108      	movs	r1, #8
 8019608:	4622      	mov	r2, r4
 801960a:	4633      	mov	r3, r6
 801960c:	f7fa fb30 	bl	8013c70 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
 8019610:	68bb      	ldr	r3, [r7, #8]
 8019612:	3314      	adds	r3, #20
 8019614:	4618      	mov	r0, r3
 8019616:	f7ff fea5 	bl	8019364 <show_wait_queue>
            rt_kprintf("\n");
 801961a:	4815      	ldr	r0, [pc, #84]	; (8019670 <_list_mailbox+0xbc>)
 801961c:	f7fa fb28 	bl	8013c70 <rt_kprintf>
 8019620:	e014      	b.n	801964c <_list_mailbox+0x98>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 8019622:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 8019624:	68bb      	ldr	r3, [r7, #8]
 8019626:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 8019628:	461e      	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
 801962a:	68bb      	ldr	r3, [r7, #8]
 801962c:	8c1b      	ldrh	r3, [r3, #32]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 801962e:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
 8019630:	68bb      	ldr	r3, [r7, #8]
 8019632:	3314      	adds	r3, #20
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 8019634:	4618      	mov	r0, r3
 8019636:	f7ff fdd9 	bl	80191ec <rt_list_len>
 801963a:	4603      	mov	r3, r0
 801963c:	9500      	str	r5, [sp, #0]
 801963e:	9301      	str	r3, [sp, #4]
 8019640:	480c      	ldr	r0, [pc, #48]	; (8019674 <_list_mailbox+0xc0>)
 8019642:	2108      	movs	r1, #8
 8019644:	4622      	mov	r2, r4
 8019646:	4633      	mov	r3, r6
 8019648:	f7fa fb12 	bl	8013c70 <rt_kprintf>
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
    rt_kprintf("-------- ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801964c:	68fb      	ldr	r3, [r7, #12]
 801964e:	681b      	ldr	r3, [r3, #0]
 8019650:	60fb      	str	r3, [r7, #12]
 8019652:	68fa      	ldr	r2, [r7, #12]
 8019654:	687b      	ldr	r3, [r7, #4]
 8019656:	429a      	cmp	r2, r3
 8019658:	d1ba      	bne.n	80195d0 <_list_mailbox+0x1c>
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
 801965a:	2300      	movs	r3, #0
}
 801965c:	4618      	mov	r0, r3
 801965e:	3714      	adds	r7, #20
 8019660:	46bd      	mov	sp, r7
 8019662:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8019664:	08023d70 	.word	0x08023d70
 8019668:	08023d94 	.word	0x08023d94
 801966c:	08023db8 	.word	0x08023db8
 8019670:	08023c7c 	.word	0x08023c7c
 8019674:	08023dd0 	.word	0x08023dd0

08019678 <list_mailbox>:

long list_mailbox(void)
{
 8019678:	b580      	push	{r7, lr}
 801967a:	af00      	add	r7, sp, #0
    return _list_mailbox(&rt_object_container[RT_Object_Class_MailBox].object_list);
 801967c:	4802      	ldr	r0, [pc, #8]	; (8019688 <list_mailbox+0x10>)
 801967e:	f7ff ff99 	bl	80195b4 <_list_mailbox>
 8019682:	4603      	mov	r3, r0
}
 8019684:	4618      	mov	r0, r3
 8019686:	bd80      	pop	{r7, pc}
 8019688:	20010058 	.word	0x20010058

0801968c <_list_msgqueue>:
MSH_CMD_EXPORT(list_mailbox, list mail box in system);
#endif

#ifdef RT_USING_MESSAGEQUEUE
static long _list_msgqueue(struct rt_list_node *list)
{
 801968c:	b5b0      	push	{r4, r5, r7, lr}
 801968e:	b086      	sub	sp, #24
 8019690:	af02      	add	r7, sp, #8
 8019692:	6078      	str	r0, [r7, #4]
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
 8019694:	4825      	ldr	r0, [pc, #148]	; (801972c <_list_msgqueue+0xa0>)
 8019696:	f7fa faeb 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- ----  --------------\n");
 801969a:	4825      	ldr	r0, [pc, #148]	; (8019730 <_list_msgqueue+0xa4>)
 801969c:	f7fa fae8 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 80196a0:	687b      	ldr	r3, [r7, #4]
 80196a2:	681b      	ldr	r3, [r3, #0]
 80196a4:	60fb      	str	r3, [r7, #12]
 80196a6:	e038      	b.n	801971a <_list_msgqueue+0x8e>
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
 80196a8:	68fb      	ldr	r3, [r7, #12]
 80196aa:	3b0c      	subs	r3, #12
 80196ac:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&m->parent.suspend_thread))
 80196ae:	68bb      	ldr	r3, [r7, #8]
 80196b0:	3314      	adds	r3, #20
 80196b2:	4618      	mov	r0, r3
 80196b4:	f7ff fd88 	bl	80191c8 <rt_list_isempty>
 80196b8:	4603      	mov	r3, r0
 80196ba:	2b00      	cmp	r3, #0
 80196bc:	d119      	bne.n	80196f2 <_list_msgqueue+0x66>
        {
            rt_kprintf("%-8.*s %04d  %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 80196be:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 80196c0:	68bb      	ldr	r3, [r7, #8]
 80196c2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
 80196c4:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
 80196c6:	68bb      	ldr	r3, [r7, #8]
 80196c8:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
 80196ca:	4618      	mov	r0, r3
 80196cc:	f7ff fd8e 	bl	80191ec <rt_list_len>
 80196d0:	4603      	mov	r3, r0
 80196d2:	9300      	str	r3, [sp, #0]
 80196d4:	4817      	ldr	r0, [pc, #92]	; (8019734 <_list_msgqueue+0xa8>)
 80196d6:	2108      	movs	r1, #8
 80196d8:	4622      	mov	r2, r4
 80196da:	462b      	mov	r3, r5
 80196dc:	f7fa fac8 	bl	8013c70 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
 80196e0:	68bb      	ldr	r3, [r7, #8]
 80196e2:	3314      	adds	r3, #20
 80196e4:	4618      	mov	r0, r3
 80196e6:	f7ff fe3d 	bl	8019364 <show_wait_queue>
            rt_kprintf("\n");
 80196ea:	4813      	ldr	r0, [pc, #76]	; (8019738 <_list_msgqueue+0xac>)
 80196ec:	f7fa fac0 	bl	8013c70 <rt_kprintf>
 80196f0:	e010      	b.n	8019714 <_list_msgqueue+0x88>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 80196f2:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 80196f4:	68bb      	ldr	r3, [r7, #8]
 80196f6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
 80196f8:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
 80196fa:	68bb      	ldr	r3, [r7, #8]
 80196fc:	3314      	adds	r3, #20
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
 80196fe:	4618      	mov	r0, r3
 8019700:	f7ff fd74 	bl	80191ec <rt_list_len>
 8019704:	4603      	mov	r3, r0
 8019706:	9300      	str	r3, [sp, #0]
 8019708:	480c      	ldr	r0, [pc, #48]	; (801973c <_list_msgqueue+0xb0>)
 801970a:	2108      	movs	r1, #8
 801970c:	4622      	mov	r2, r4
 801970e:	462b      	mov	r3, r5
 8019710:	f7fa faae 	bl	8013c70 <rt_kprintf>
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
    rt_kprintf("-------- ----  --------------\n");
    for (node = list->next; node != list; node = node->next)
 8019714:	68fb      	ldr	r3, [r7, #12]
 8019716:	681b      	ldr	r3, [r3, #0]
 8019718:	60fb      	str	r3, [r7, #12]
 801971a:	68fa      	ldr	r2, [r7, #12]
 801971c:	687b      	ldr	r3, [r7, #4]
 801971e:	429a      	cmp	r2, r3
 8019720:	d1c2      	bne.n	80196a8 <_list_msgqueue+0x1c>
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
 8019722:	2300      	movs	r3, #0
}
 8019724:	4618      	mov	r0, r3
 8019726:	3710      	adds	r7, #16
 8019728:	46bd      	mov	sp, r7
 801972a:	bdb0      	pop	{r4, r5, r7, pc}
 801972c:	08023de8 	.word	0x08023de8
 8019730:	08023e08 	.word	0x08023e08
 8019734:	08023e28 	.word	0x08023e28
 8019738:	08023c7c 	.word	0x08023c7c
 801973c:	08023e3c 	.word	0x08023e3c

08019740 <list_msgqueue>:

long list_msgqueue(void)
{
 8019740:	b580      	push	{r7, lr}
 8019742:	af00      	add	r7, sp, #0
    return _list_msgqueue(&rt_object_container[RT_Object_Class_MessageQueue].object_list);
 8019744:	4802      	ldr	r0, [pc, #8]	; (8019750 <list_msgqueue+0x10>)
 8019746:	f7ff ffa1 	bl	801968c <_list_msgqueue>
 801974a:	4603      	mov	r3, r0
}
 801974c:	4618      	mov	r0, r3
 801974e:	bd80      	pop	{r7, pc}
 8019750:	20010068 	.word	0x20010068

08019754 <_list_memheap>:
MSH_CMD_EXPORT(list_msgqueue, list message queue in system);
#endif

#ifdef RT_USING_MEMHEAP
static long _list_memheap(struct rt_list_node *list)
{
 8019754:	b5b0      	push	{r4, r5, r7, lr}
 8019756:	b086      	sub	sp, #24
 8019758:	af02      	add	r7, sp, #8
 801975a:	6078      	str	r0, [r7, #4]
    struct rt_memheap *mh;
    struct rt_list_node *node;

    rt_kprintf("memheap  pool size  max used size available size\n");
 801975c:	4813      	ldr	r0, [pc, #76]	; (80197ac <_list_memheap+0x58>)
 801975e:	f7fa fa87 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- ---------- ------------- --------------\n");
 8019762:	4813      	ldr	r0, [pc, #76]	; (80197b0 <_list_memheap+0x5c>)
 8019764:	f7fa fa84 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 8019768:	687b      	ldr	r3, [r7, #4]
 801976a:	681b      	ldr	r3, [r3, #0]
 801976c:	60fb      	str	r3, [r7, #12]
 801976e:	e014      	b.n	801979a <_list_memheap+0x46>
    {
        mh = (struct rt_memheap *)rt_list_entry(node, struct rt_object, list);
 8019770:	68fb      	ldr	r3, [r7, #12]
 8019772:	3b0c      	subs	r3, #12
 8019774:	60bb      	str	r3, [r7, #8]

        rt_kprintf("%-8.*s %-010d %-013d %-05d\n",
                   RT_NAME_MAX,
                   mh->parent.name,
 8019776:	68bd      	ldr	r5, [r7, #8]
    rt_kprintf("-------- ---------- ------------- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        mh = (struct rt_memheap *)rt_list_entry(node, struct rt_object, list);

        rt_kprintf("%-8.*s %-010d %-013d %-05d\n",
 8019778:	68bb      	ldr	r3, [r7, #8]
 801977a:	699c      	ldr	r4, [r3, #24]
 801977c:	68bb      	ldr	r3, [r7, #8]
 801977e:	6a1a      	ldr	r2, [r3, #32]
 8019780:	68bb      	ldr	r3, [r7, #8]
 8019782:	69db      	ldr	r3, [r3, #28]
 8019784:	9200      	str	r2, [sp, #0]
 8019786:	9301      	str	r3, [sp, #4]
 8019788:	480a      	ldr	r0, [pc, #40]	; (80197b4 <_list_memheap+0x60>)
 801978a:	2108      	movs	r1, #8
 801978c:	462a      	mov	r2, r5
 801978e:	4623      	mov	r3, r4
 8019790:	f7fa fa6e 	bl	8013c70 <rt_kprintf>
    struct rt_memheap *mh;
    struct rt_list_node *node;

    rt_kprintf("memheap  pool size  max used size available size\n");
    rt_kprintf("-------- ---------- ------------- --------------\n");
    for (node = list->next; node != list; node = node->next)
 8019794:	68fb      	ldr	r3, [r7, #12]
 8019796:	681b      	ldr	r3, [r3, #0]
 8019798:	60fb      	str	r3, [r7, #12]
 801979a:	68fa      	ldr	r2, [r7, #12]
 801979c:	687b      	ldr	r3, [r7, #4]
 801979e:	429a      	cmp	r2, r3
 80197a0:	d1e6      	bne.n	8019770 <_list_memheap+0x1c>
                   mh->pool_size,
                   mh->max_used_size,
                   mh->available_size);
    }

    return 0;
 80197a2:	2300      	movs	r3, #0
}
 80197a4:	4618      	mov	r0, r3
 80197a6:	3710      	adds	r7, #16
 80197a8:	46bd      	mov	sp, r7
 80197aa:	bdb0      	pop	{r4, r5, r7, pc}
 80197ac:	08023e50 	.word	0x08023e50
 80197b0:	08023e84 	.word	0x08023e84
 80197b4:	08023eb8 	.word	0x08023eb8

080197b8 <list_memheap>:

long list_memheap(void)
{
 80197b8:	b580      	push	{r7, lr}
 80197ba:	af00      	add	r7, sp, #0
    return _list_memheap(&rt_object_container[RT_Object_Class_MemHeap].object_list);
 80197bc:	4802      	ldr	r0, [pc, #8]	; (80197c8 <list_memheap+0x10>)
 80197be:	f7ff ffc9 	bl	8019754 <_list_memheap>
 80197c2:	4603      	mov	r3, r0
}
 80197c4:	4618      	mov	r0, r3
 80197c6:	bd80      	pop	{r7, pc}
 80197c8:	20010078 	.word	0x20010078

080197cc <_list_mempool>:
MSH_CMD_EXPORT(list_memheap, list memory heap in system);
#endif

#ifdef RT_USING_MEMPOOL
static long _list_mempool(struct rt_list_node *list)
{
 80197cc:	b5b0      	push	{r4, r5, r7, lr}
 80197ce:	b088      	sub	sp, #32
 80197d0:	af04      	add	r7, sp, #16
 80197d2:	6078      	str	r0, [r7, #4]
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
 80197d4:	4824      	ldr	r0, [pc, #144]	; (8019868 <_list_mempool+0x9c>)
 80197d6:	f7fa fa4b 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- ----  ----  ---- --------------\n");
 80197da:	4824      	ldr	r0, [pc, #144]	; (801986c <_list_mempool+0xa0>)
 80197dc:	f7fa fa48 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 80197e0:	687b      	ldr	r3, [r7, #4]
 80197e2:	681b      	ldr	r3, [r3, #0]
 80197e4:	60fb      	str	r3, [r7, #12]
 80197e6:	e036      	b.n	8019856 <_list_mempool+0x8a>
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
 80197e8:	68fb      	ldr	r3, [r7, #12]
 80197ea:	3b0c      	subs	r3, #12
 80197ec:	60bb      	str	r3, [r7, #8]
        if (mp->suspend_thread_count > 0)
 80197ee:	68bb      	ldr	r3, [r7, #8]
 80197f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80197f2:	2b00      	cmp	r3, #0
 80197f4:	d01a      	beq.n	801982c <_list_mempool+0x60>
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
                       RT_NAME_MAX,
                       mp->parent.name,
 80197f6:	68bd      	ldr	r5, [r7, #8]
    for (node = list->next; node != list; node = node->next)
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
        if (mp->suspend_thread_count > 0)
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
 80197f8:	68bb      	ldr	r3, [r7, #8]
 80197fa:	69dc      	ldr	r4, [r3, #28]
 80197fc:	68bb      	ldr	r3, [r7, #8]
 80197fe:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8019800:	68bb      	ldr	r3, [r7, #8]
 8019802:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8019804:	68bb      	ldr	r3, [r7, #8]
 8019806:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8019808:	9100      	str	r1, [sp, #0]
 801980a:	9201      	str	r2, [sp, #4]
 801980c:	9302      	str	r3, [sp, #8]
 801980e:	4818      	ldr	r0, [pc, #96]	; (8019870 <_list_mempool+0xa4>)
 8019810:	2108      	movs	r1, #8
 8019812:	462a      	mov	r2, r5
 8019814:	4623      	mov	r3, r4
 8019816:	f7fa fa2b 	bl	8013c70 <rt_kprintf>
                       mp->parent.name,
                       mp->block_size,
                       mp->block_total_count,
                       mp->block_free_count,
                       mp->suspend_thread_count);
            show_wait_queue(&(mp->suspend_thread));
 801981a:	68bb      	ldr	r3, [r7, #8]
 801981c:	332c      	adds	r3, #44	; 0x2c
 801981e:	4618      	mov	r0, r3
 8019820:	f7ff fda0 	bl	8019364 <show_wait_queue>
            rt_kprintf("\n");
 8019824:	4813      	ldr	r0, [pc, #76]	; (8019874 <_list_mempool+0xa8>)
 8019826:	f7fa fa23 	bl	8013c70 <rt_kprintf>
 801982a:	e011      	b.n	8019850 <_list_mempool+0x84>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
                       RT_NAME_MAX,
                       mp->parent.name,
 801982c:	68bd      	ldr	r5, [r7, #8]
            show_wait_queue(&(mp->suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
 801982e:	68bb      	ldr	r3, [r7, #8]
 8019830:	69dc      	ldr	r4, [r3, #28]
 8019832:	68bb      	ldr	r3, [r7, #8]
 8019834:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8019836:	68bb      	ldr	r3, [r7, #8]
 8019838:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801983a:	68bb      	ldr	r3, [r7, #8]
 801983c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801983e:	9100      	str	r1, [sp, #0]
 8019840:	9201      	str	r2, [sp, #4]
 8019842:	9302      	str	r3, [sp, #8]
 8019844:	480c      	ldr	r0, [pc, #48]	; (8019878 <_list_mempool+0xac>)
 8019846:	2108      	movs	r1, #8
 8019848:	462a      	mov	r2, r5
 801984a:	4623      	mov	r3, r4
 801984c:	f7fa fa10 	bl	8013c70 <rt_kprintf>
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
    rt_kprintf("-------- ----  ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 8019850:	68fb      	ldr	r3, [r7, #12]
 8019852:	681b      	ldr	r3, [r3, #0]
 8019854:	60fb      	str	r3, [r7, #12]
 8019856:	68fa      	ldr	r2, [r7, #12]
 8019858:	687b      	ldr	r3, [r7, #4]
 801985a:	429a      	cmp	r2, r3
 801985c:	d1c4      	bne.n	80197e8 <_list_mempool+0x1c>
                       mp->block_free_count,
                       mp->suspend_thread_count);
        }
    }

    return 0;
 801985e:	2300      	movs	r3, #0
}
 8019860:	4618      	mov	r0, r3
 8019862:	3710      	adds	r7, #16
 8019864:	46bd      	mov	sp, r7
 8019866:	bdb0      	pop	{r4, r5, r7, pc}
 8019868:	08023ed4 	.word	0x08023ed4
 801986c:	08023f00 	.word	0x08023f00
 8019870:	08023f2c 	.word	0x08023f2c
 8019874:	08023c7c 	.word	0x08023c7c
 8019878:	08023f48 	.word	0x08023f48

0801987c <list_mempool>:

long list_mempool(void)
{
 801987c:	b580      	push	{r7, lr}
 801987e:	af00      	add	r7, sp, #0
    return _list_mempool(&rt_object_container[RT_Object_Class_MemPool].object_list);
 8019880:	4802      	ldr	r0, [pc, #8]	; (801988c <list_mempool+0x10>)
 8019882:	f7ff ffa3 	bl	80197cc <_list_mempool>
 8019886:	4603      	mov	r3, r0
}
 8019888:	4618      	mov	r0, r3
 801988a:	bd80      	pop	{r7, pc}
 801988c:	20010088 	.word	0x20010088

08019890 <_list_timer>:
FINSH_FUNCTION_EXPORT(list_mempool, list memory pool in system)
MSH_CMD_EXPORT(list_mempool, list memory pool in system);
#endif

static long _list_timer(struct rt_list_node *list)
{
 8019890:	b590      	push	{r4, r7, lr}
 8019892:	b087      	sub	sp, #28
 8019894:	af02      	add	r7, sp, #8
 8019896:	6078      	str	r0, [r7, #4]
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
 8019898:	481b      	ldr	r0, [pc, #108]	; (8019908 <_list_timer+0x78>)
 801989a:	f7fa f9e9 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- ---------- ---------- -----------\n");
 801989e:	481b      	ldr	r0, [pc, #108]	; (801990c <_list_timer+0x7c>)
 80198a0:	f7fa f9e6 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 80198a4:	687b      	ldr	r3, [r7, #4]
 80198a6:	681b      	ldr	r3, [r3, #0]
 80198a8:	60fb      	str	r3, [r7, #12]
 80198aa:	e01d      	b.n	80198e8 <_list_timer+0x58>
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
 80198ac:	68fb      	ldr	r3, [r7, #12]
 80198ae:	3b0c      	subs	r3, #12
 80198b0:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
                   RT_NAME_MAX,
                   timer->parent.name,
 80198b2:	68ba      	ldr	r2, [r7, #8]
    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
 80198b4:	68bb      	ldr	r3, [r7, #8]
 80198b6:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80198b8:	68bb      	ldr	r3, [r7, #8]
 80198ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80198bc:	9300      	str	r3, [sp, #0]
 80198be:	4814      	ldr	r0, [pc, #80]	; (8019910 <_list_timer+0x80>)
 80198c0:	2108      	movs	r1, #8
 80198c2:	4623      	mov	r3, r4
 80198c4:	f7fa f9d4 	bl	8013c70 <rt_kprintf>
                   RT_NAME_MAX,
                   timer->parent.name,
                   timer->init_tick,
                   timer->timeout_tick);
        if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
 80198c8:	68bb      	ldr	r3, [r7, #8]
 80198ca:	7a5b      	ldrb	r3, [r3, #9]
 80198cc:	f003 0301 	and.w	r3, r3, #1
 80198d0:	2b00      	cmp	r3, #0
 80198d2:	d003      	beq.n	80198dc <_list_timer+0x4c>
            rt_kprintf("activated\n");
 80198d4:	480f      	ldr	r0, [pc, #60]	; (8019914 <_list_timer+0x84>)
 80198d6:	f7fa f9cb 	bl	8013c70 <rt_kprintf>
 80198da:	e002      	b.n	80198e2 <_list_timer+0x52>
        else
            rt_kprintf("deactivated\n");
 80198dc:	480e      	ldr	r0, [pc, #56]	; (8019918 <_list_timer+0x88>)
 80198de:	f7fa f9c7 	bl	8013c70 <rt_kprintf>
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
 80198e2:	68fb      	ldr	r3, [r7, #12]
 80198e4:	681b      	ldr	r3, [r3, #0]
 80198e6:	60fb      	str	r3, [r7, #12]
 80198e8:	68fa      	ldr	r2, [r7, #12]
 80198ea:	687b      	ldr	r3, [r7, #4]
 80198ec:	429a      	cmp	r2, r3
 80198ee:	d1dd      	bne.n	80198ac <_list_timer+0x1c>
            rt_kprintf("activated\n");
        else
            rt_kprintf("deactivated\n");
    }

    rt_kprintf("current tick:0x%08x\n", rt_tick_get());
 80198f0:	f7f8 fa7a 	bl	8011de8 <rt_tick_get>
 80198f4:	4603      	mov	r3, r0
 80198f6:	4809      	ldr	r0, [pc, #36]	; (801991c <_list_timer+0x8c>)
 80198f8:	4619      	mov	r1, r3
 80198fa:	f7fa f9b9 	bl	8013c70 <rt_kprintf>

    return 0;
 80198fe:	2300      	movs	r3, #0
}
 8019900:	4618      	mov	r0, r3
 8019902:	3714      	adds	r7, #20
 8019904:	46bd      	mov	sp, r7
 8019906:	bd90      	pop	{r4, r7, pc}
 8019908:	08023f64 	.word	0x08023f64
 801990c:	08023f8c 	.word	0x08023f8c
 8019910:	08023fb8 	.word	0x08023fb8
 8019914:	08023fd0 	.word	0x08023fd0
 8019918:	08023fdc 	.word	0x08023fdc
 801991c:	08023fec 	.word	0x08023fec

08019920 <list_timer>:

long list_timer(void)
{
 8019920:	b580      	push	{r7, lr}
 8019922:	af00      	add	r7, sp, #0
    return _list_timer(&rt_object_container[RT_Object_Class_Timer].object_list);
 8019924:	4802      	ldr	r0, [pc, #8]	; (8019930 <list_timer+0x10>)
 8019926:	f7ff ffb3 	bl	8019890 <_list_timer>
 801992a:	4603      	mov	r3, r0
}
 801992c:	4618      	mov	r0, r3
 801992e:	bd80      	pop	{r7, pc}
 8019930:	200100a8 	.word	0x200100a8

08019934 <_list_device>:
FINSH_FUNCTION_EXPORT(list_timer, list timer in system);
MSH_CMD_EXPORT(list_timer, list timer in system);

#ifdef RT_USING_DEVICE
static long _list_device(struct rt_list_node *list)
{
 8019934:	b590      	push	{r4, r7, lr}
 8019936:	b09b      	sub	sp, #108	; 0x6c
 8019938:	af02      	add	r7, sp, #8
 801993a:	6078      	str	r0, [r7, #4]
    struct rt_device *device;
    struct rt_list_node *node;
    char * const device_type_str[] =
 801993c:	4a1b      	ldr	r2, [pc, #108]	; (80199ac <_list_device+0x78>)
 801993e:	f107 0308 	add.w	r3, r7, #8
 8019942:	4611      	mov	r1, r2
 8019944:	2250      	movs	r2, #80	; 0x50
 8019946:	4618      	mov	r0, r3
 8019948:	f7e6 fcc8 	bl	80002dc <memcpy>
		"Timer Device",
		"Miscellaneous Device",
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
 801994c:	4818      	ldr	r0, [pc, #96]	; (80199b0 <_list_device+0x7c>)
 801994e:	f7fa f98f 	bl	8013c70 <rt_kprintf>
    rt_kprintf("-------- -------------------- ----------\n");
 8019952:	4818      	ldr	r0, [pc, #96]	; (80199b4 <_list_device+0x80>)
 8019954:	f7fa f98c 	bl	8013c70 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 8019958:	687b      	ldr	r3, [r7, #4]
 801995a:	681b      	ldr	r3, [r3, #0]
 801995c:	65fb      	str	r3, [r7, #92]	; 0x5c
 801995e:	e01c      	b.n	801999a <_list_device+0x66>
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
 8019960:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8019962:	3b0c      	subs	r3, #12
 8019964:	65bb      	str	r3, [r7, #88]	; 0x58
        rt_kprintf("%-8.*s %-20s %-8d\n",
                   RT_NAME_MAX,
                   device->parent.name,
 8019966:	6dbc      	ldr	r4, [r7, #88]	; 0x58
                   (device->type <= RT_Device_Class_Unknown) ?
 8019968:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801996a:	7d1b      	ldrb	r3, [r3, #20]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 801996c:	2b13      	cmp	r3, #19
 801996e:	d808      	bhi.n	8019982 <_list_device+0x4e>
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
 8019970:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8019972:	7d1b      	ldrb	r3, [r3, #20]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 8019974:	009b      	lsls	r3, r3, #2
 8019976:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801997a:	4413      	add	r3, r2
 801997c:	f853 3c58 	ldr.w	r3, [r3, #-88]
 8019980:	e000      	b.n	8019984 <_list_device+0x50>
 8019982:	6d7b      	ldr	r3, [r7, #84]	; 0x54
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
 8019984:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8019986:	7e92      	ldrb	r2, [r2, #26]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 8019988:	9200      	str	r2, [sp, #0]
 801998a:	480b      	ldr	r0, [pc, #44]	; (80199b8 <_list_device+0x84>)
 801998c:	2108      	movs	r1, #8
 801998e:	4622      	mov	r2, r4
 8019990:	f7fa f96e 	bl	8013c70 <rt_kprintf>
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
 8019994:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8019996:	681b      	ldr	r3, [r3, #0]
 8019998:	65fb      	str	r3, [r7, #92]	; 0x5c
 801999a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801999c:	687b      	ldr	r3, [r7, #4]
 801999e:	429a      	cmp	r2, r3
 80199a0:	d1de      	bne.n	8019960 <_list_device+0x2c>
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
    }

    return 0;
 80199a2:	2300      	movs	r3, #0
}
 80199a4:	4618      	mov	r0, r3
 80199a6:	3764      	adds	r7, #100	; 0x64
 80199a8:	46bd      	mov	sp, r7
 80199aa:	bd90      	pop	{r4, r7, pc}
 80199ac:	0802418c 	.word	0x0802418c
 80199b0:	08024004 	.word	0x08024004
 80199b4:	08024030 	.word	0x08024030
 80199b8:	0802405c 	.word	0x0802405c

080199bc <list_device>:

long list_device(void)
{
 80199bc:	b580      	push	{r7, lr}
 80199be:	af00      	add	r7, sp, #0
    return _list_device(&rt_object_container[RT_Object_Class_Device].object_list);
 80199c0:	4802      	ldr	r0, [pc, #8]	; (80199cc <list_device+0x10>)
 80199c2:	f7ff ffb7 	bl	8019934 <_list_device>
 80199c6:	4603      	mov	r3, r0
}
 80199c8:	4618      	mov	r0, r3
 80199ca:	bd80      	pop	{r7, pc}
 80199cc:	20010098 	.word	0x20010098

080199d0 <list>:
}
FINSH_FUNCTION_EXPORT(list_mod_detail, list module objects in system)
#endif

long list(void)
{
 80199d0:	b580      	push	{r7, lr}
 80199d2:	b084      	sub	sp, #16
 80199d4:	af00      	add	r7, sp, #0
#ifndef FINSH_USING_MSH_ONLY
    struct finsh_syscall_item *syscall_item;
    struct finsh_sysvar_item *sysvar_item;
#endif
	
    rt_kprintf("--Function List:\n");
 80199d6:	4830      	ldr	r0, [pc, #192]	; (8019a98 <list+0xc8>)
 80199d8:	f7fa f94a 	bl	8013c70 <rt_kprintf>
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 80199dc:	4b2f      	ldr	r3, [pc, #188]	; (8019a9c <list+0xcc>)
 80199de:	681b      	ldr	r3, [r3, #0]
 80199e0:	607b      	str	r3, [r7, #4]
 80199e2:	e016      	b.n	8019a12 <list+0x42>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip the internal command */
			if (strncmp((char*)index->name, "__", 2) == 0) continue;
 80199e4:	687b      	ldr	r3, [r7, #4]
 80199e6:	681b      	ldr	r3, [r3, #0]
 80199e8:	4618      	mov	r0, r3
 80199ea:	492d      	ldr	r1, [pc, #180]	; (8019aa0 <list+0xd0>)
 80199ec:	2202      	movs	r2, #2
 80199ee:	f006 f861 	bl	801fab4 <strncmp>
 80199f2:	4603      	mov	r3, r0
 80199f4:	2b00      	cmp	r3, #0
 80199f6:	d100      	bne.n	80199fa <list+0x2a>
 80199f8:	e008      	b.n	8019a0c <list+0x3c>

#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 80199fa:	687b      	ldr	r3, [r7, #4]
 80199fc:	681a      	ldr	r2, [r3, #0]
 80199fe:	687b      	ldr	r3, [r7, #4]
 8019a00:	685b      	ldr	r3, [r3, #4]
 8019a02:	4828      	ldr	r0, [pc, #160]	; (8019aa4 <list+0xd4>)
 8019a04:	4611      	mov	r1, r2
 8019a06:	461a      	mov	r2, r3
 8019a08:	f7fa f932 	bl	8013c70 <rt_kprintf>
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
 8019a0c:	687b      	ldr	r3, [r7, #4]
 8019a0e:	330c      	adds	r3, #12
 8019a10:	607b      	str	r3, [r7, #4]
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
 8019a12:	4b25      	ldr	r3, [pc, #148]	; (8019aa8 <list+0xd8>)
 8019a14:	681b      	ldr	r3, [r3, #0]
#endif
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 8019a16:	687a      	ldr	r2, [r7, #4]
 8019a18:	429a      	cmp	r2, r3
 8019a1a:	d3e3      	bcc.n	80199e4 <list+0x14>
        }
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
 8019a1c:	4b23      	ldr	r3, [pc, #140]	; (8019aac <list+0xdc>)
 8019a1e:	681b      	ldr	r3, [r3, #0]
 8019a20:	60fb      	str	r3, [r7, #12]
    while (syscall_item != NULL)
 8019a22:	e008      	b.n	8019a36 <list+0x66>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
 8019a24:	68fb      	ldr	r3, [r7, #12]
 8019a26:	685b      	ldr	r3, [r3, #4]
 8019a28:	4821      	ldr	r0, [pc, #132]	; (8019ab0 <list+0xe0>)
 8019a2a:	4619      	mov	r1, r3
 8019a2c:	f7fa f920 	bl	8013c70 <rt_kprintf>
        syscall_item = syscall_item->next;
 8019a30:	68fb      	ldr	r3, [r7, #12]
 8019a32:	681b      	ldr	r3, [r3, #0]
 8019a34:	60fb      	str	r3, [r7, #12]
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
 8019a36:	68fb      	ldr	r3, [r7, #12]
 8019a38:	2b00      	cmp	r3, #0
 8019a3a:	d1f3      	bne.n	8019a24 <list+0x54>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
        syscall_item = syscall_item->next;
    }

    rt_kprintf("--Variable List:\n");
 8019a3c:	481d      	ldr	r0, [pc, #116]	; (8019ab4 <list+0xe4>)
 8019a3e:	f7fa f917 	bl	8013c70 <rt_kprintf>
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
 8019a42:	4b1d      	ldr	r3, [pc, #116]	; (8019ab8 <list+0xe8>)
 8019a44:	681b      	ldr	r3, [r3, #0]
 8019a46:	603b      	str	r3, [r7, #0]
 8019a48:	e00b      	b.n	8019a62 <list+0x92>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 8019a4a:	683b      	ldr	r3, [r7, #0]
 8019a4c:	681a      	ldr	r2, [r3, #0]
 8019a4e:	683b      	ldr	r3, [r7, #0]
 8019a50:	685b      	ldr	r3, [r3, #4]
 8019a52:	4814      	ldr	r0, [pc, #80]	; (8019aa4 <list+0xd4>)
 8019a54:	4611      	mov	r1, r2
 8019a56:	461a      	mov	r2, r3
 8019a58:	f7fa f90a 	bl	8013c70 <rt_kprintf>
    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
 8019a5c:	683b      	ldr	r3, [r7, #0]
 8019a5e:	3310      	adds	r3, #16
 8019a60:	603b      	str	r3, [r7, #0]

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
 8019a62:	4b16      	ldr	r3, [pc, #88]	; (8019abc <list+0xec>)
 8019a64:	681b      	ldr	r3, [r3, #0]
    }

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
 8019a66:	683a      	ldr	r2, [r7, #0]
 8019a68:	429a      	cmp	r2, r3
 8019a6a:	d3ee      	bcc.n	8019a4a <list+0x7a>
            rt_kprintf("%s\n", index->name);
#endif
        }
    }

    sysvar_item = global_sysvar_list;
 8019a6c:	4b14      	ldr	r3, [pc, #80]	; (8019ac0 <list+0xf0>)
 8019a6e:	681b      	ldr	r3, [r3, #0]
 8019a70:	60bb      	str	r3, [r7, #8]
    while (sysvar_item != NULL)
 8019a72:	e008      	b.n	8019a86 <list+0xb6>
    {
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
 8019a74:	68bb      	ldr	r3, [r7, #8]
 8019a76:	685b      	ldr	r3, [r3, #4]
 8019a78:	480d      	ldr	r0, [pc, #52]	; (8019ab0 <list+0xe0>)
 8019a7a:	4619      	mov	r1, r3
 8019a7c:	f7fa f8f8 	bl	8013c70 <rt_kprintf>
        sysvar_item = sysvar_item->next;
 8019a80:	68bb      	ldr	r3, [r7, #8]
 8019a82:	681b      	ldr	r3, [r3, #0]
 8019a84:	60bb      	str	r3, [r7, #8]
#endif
        }
    }

    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
 8019a86:	68bb      	ldr	r3, [r7, #8]
 8019a88:	2b00      	cmp	r3, #0
 8019a8a:	d1f3      	bne.n	8019a74 <list+0xa4>
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
        sysvar_item = sysvar_item->next;
    }
#endif
	
    return 0;
 8019a8c:	2300      	movs	r3, #0
}
 8019a8e:	4618      	mov	r0, r3
 8019a90:	3710      	adds	r7, #16
 8019a92:	46bd      	mov	sp, r7
 8019a94:	bd80      	pop	{r7, pc}
 8019a96:	bf00      	nop
 8019a98:	080241dc 	.word	0x080241dc
 8019a9c:	200121cc 	.word	0x200121cc
 8019aa0:	080241f0 	.word	0x080241f0
 8019aa4:	080241f4 	.word	0x080241f4
 8019aa8:	200121d0 	.word	0x200121d0
 8019aac:	200121e8 	.word	0x200121e8
 8019ab0:	08024204 	.word	0x08024204
 8019ab4:	0802420c 	.word	0x0802420c
 8019ab8:	200121d4 	.word	0x200121d4
 8019abc:	200121d8 	.word	0x200121d8
 8019ac0:	200128b0 	.word	0x200128b0

08019ac4 <str_is_prefix>:
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
 8019ac4:	b480      	push	{r7}
 8019ac6:	b083      	sub	sp, #12
 8019ac8:	af00      	add	r7, sp, #0
 8019aca:	6078      	str	r0, [r7, #4]
 8019acc:	6039      	str	r1, [r7, #0]
    while ((*prefix) && (*prefix == *str))
 8019ace:	e005      	b.n	8019adc <str_is_prefix+0x18>
    {
        prefix ++;
 8019ad0:	687b      	ldr	r3, [r7, #4]
 8019ad2:	3301      	adds	r3, #1
 8019ad4:	607b      	str	r3, [r7, #4]
        str ++;
 8019ad6:	683b      	ldr	r3, [r7, #0]
 8019ad8:	3301      	adds	r3, #1
 8019ada:	603b      	str	r3, [r7, #0]
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
    while ((*prefix) && (*prefix == *str))
 8019adc:	687b      	ldr	r3, [r7, #4]
 8019ade:	781b      	ldrb	r3, [r3, #0]
 8019ae0:	2b00      	cmp	r3, #0
 8019ae2:	d005      	beq.n	8019af0 <str_is_prefix+0x2c>
 8019ae4:	687b      	ldr	r3, [r7, #4]
 8019ae6:	781a      	ldrb	r2, [r3, #0]
 8019ae8:	683b      	ldr	r3, [r7, #0]
 8019aea:	781b      	ldrb	r3, [r3, #0]
 8019aec:	429a      	cmp	r2, r3
 8019aee:	d0ef      	beq.n	8019ad0 <str_is_prefix+0xc>
    {
        prefix ++;
        str ++;
    }

    if (*prefix == 0)
 8019af0:	687b      	ldr	r3, [r7, #4]
 8019af2:	781b      	ldrb	r3, [r3, #0]
 8019af4:	2b00      	cmp	r3, #0
 8019af6:	d101      	bne.n	8019afc <str_is_prefix+0x38>
        return 0;
 8019af8:	2300      	movs	r3, #0
 8019afa:	e001      	b.n	8019b00 <str_is_prefix+0x3c>

    return -1;
 8019afc:	f04f 33ff 	mov.w	r3, #4294967295
}
 8019b00:	4618      	mov	r0, r3
 8019b02:	370c      	adds	r7, #12
 8019b04:	46bd      	mov	sp, r7
 8019b06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019b0a:	4770      	bx	lr

08019b0c <str_common>:

static int str_common(const char *str1, const char *str2)
{
 8019b0c:	b480      	push	{r7}
 8019b0e:	b085      	sub	sp, #20
 8019b10:	af00      	add	r7, sp, #0
 8019b12:	6078      	str	r0, [r7, #4]
 8019b14:	6039      	str	r1, [r7, #0]
    const char *str = str1;
 8019b16:	687b      	ldr	r3, [r7, #4]
 8019b18:	60fb      	str	r3, [r7, #12]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 8019b1a:	e005      	b.n	8019b28 <str_common+0x1c>
    {
        str ++;
 8019b1c:	68fb      	ldr	r3, [r7, #12]
 8019b1e:	3301      	adds	r3, #1
 8019b20:	60fb      	str	r3, [r7, #12]
        str2 ++;
 8019b22:	683b      	ldr	r3, [r7, #0]
 8019b24:	3301      	adds	r3, #1
 8019b26:	603b      	str	r3, [r7, #0]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 8019b28:	68fb      	ldr	r3, [r7, #12]
 8019b2a:	781b      	ldrb	r3, [r3, #0]
 8019b2c:	2b00      	cmp	r3, #0
 8019b2e:	d009      	beq.n	8019b44 <str_common+0x38>
 8019b30:	683b      	ldr	r3, [r7, #0]
 8019b32:	781b      	ldrb	r3, [r3, #0]
 8019b34:	2b00      	cmp	r3, #0
 8019b36:	d005      	beq.n	8019b44 <str_common+0x38>
 8019b38:	68fb      	ldr	r3, [r7, #12]
 8019b3a:	781a      	ldrb	r2, [r3, #0]
 8019b3c:	683b      	ldr	r3, [r7, #0]
 8019b3e:	781b      	ldrb	r3, [r3, #0]
 8019b40:	429a      	cmp	r2, r3
 8019b42:	d0eb      	beq.n	8019b1c <str_common+0x10>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
 8019b44:	68fa      	ldr	r2, [r7, #12]
 8019b46:	687b      	ldr	r3, [r7, #4]
 8019b48:	1ad3      	subs	r3, r2, r3
}
 8019b4a:	4618      	mov	r0, r3
 8019b4c:	3714      	adds	r7, #20
 8019b4e:	46bd      	mov	sp, r7
 8019b50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019b54:	4770      	bx	lr
 8019b56:	bf00      	nop

08019b58 <list_prefix>:

void list_prefix(char *prefix)
{
 8019b58:	b580      	push	{r7, lr}
 8019b5a:	b08a      	sub	sp, #40	; 0x28
 8019b5c:	af00      	add	r7, sp, #0
 8019b5e:	6078      	str	r0, [r7, #4]
    struct finsh_sysvar_item *sysvar_item;
    rt_uint16_t func_cnt, var_cnt;
    int length, min_length;
    const char *name_ptr;

    func_cnt = 0;
 8019b60:	2300      	movs	r3, #0
 8019b62:	83fb      	strh	r3, [r7, #30]
    var_cnt  = 0;
 8019b64:	2300      	movs	r3, #0
 8019b66:	83bb      	strh	r3, [r7, #28]
    min_length = 0;
 8019b68:	2300      	movs	r3, #0
 8019b6a:	61bb      	str	r3, [r7, #24]
    name_ptr = RT_NULL;
 8019b6c:	2300      	movs	r3, #0
 8019b6e:	617b      	str	r3, [r7, #20]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 8019b70:	4b92      	ldr	r3, [pc, #584]	; (8019dbc <list_prefix+0x264>)
 8019b72:	681b      	ldr	r3, [r3, #0]
 8019b74:	613b      	str	r3, [r7, #16]
 8019b76:	e044      	b.n	8019c02 <list_prefix+0xaa>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip internal command */
			if (str_is_prefix("__", index->name) == 0) continue;
 8019b78:	693b      	ldr	r3, [r7, #16]
 8019b7a:	681b      	ldr	r3, [r3, #0]
 8019b7c:	4890      	ldr	r0, [pc, #576]	; (8019dc0 <list_prefix+0x268>)
 8019b7e:	4619      	mov	r1, r3
 8019b80:	f7ff ffa0 	bl	8019ac4 <str_is_prefix>
 8019b84:	4603      	mov	r3, r0
 8019b86:	2b00      	cmp	r3, #0
 8019b88:	d100      	bne.n	8019b8c <list_prefix+0x34>
 8019b8a:	e037      	b.n	8019bfc <list_prefix+0xa4>
			
            if (str_is_prefix(prefix, index->name) == 0)
 8019b8c:	693b      	ldr	r3, [r7, #16]
 8019b8e:	681b      	ldr	r3, [r3, #0]
 8019b90:	6878      	ldr	r0, [r7, #4]
 8019b92:	4619      	mov	r1, r3
 8019b94:	f7ff ff96 	bl	8019ac4 <str_is_prefix>
 8019b98:	4603      	mov	r3, r0
 8019b9a:	2b00      	cmp	r3, #0
 8019b9c:	d12e      	bne.n	8019bfc <list_prefix+0xa4>
            {
                if (func_cnt == 0)
 8019b9e:	8bfb      	ldrh	r3, [r7, #30]
 8019ba0:	2b00      	cmp	r3, #0
 8019ba2:	d10e      	bne.n	8019bc2 <list_prefix+0x6a>
                {
                    rt_kprintf("--function:\n");
 8019ba4:	4887      	ldr	r0, [pc, #540]	; (8019dc4 <list_prefix+0x26c>)
 8019ba6:	f7fa f863 	bl	8013c70 <rt_kprintf>

                    if (*prefix != 0)
 8019baa:	687b      	ldr	r3, [r7, #4]
 8019bac:	781b      	ldrb	r3, [r3, #0]
 8019bae:	2b00      	cmp	r3, #0
 8019bb0:	d007      	beq.n	8019bc2 <list_prefix+0x6a>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
 8019bb2:	693b      	ldr	r3, [r7, #16]
 8019bb4:	681b      	ldr	r3, [r3, #0]
 8019bb6:	617b      	str	r3, [r7, #20]

                        /* set initial length */
                        min_length = strlen(name_ptr);
 8019bb8:	6978      	ldr	r0, [r7, #20]
 8019bba:	f005 ff4d 	bl	801fa58 <strlen>
 8019bbe:	4603      	mov	r3, r0
 8019bc0:	61bb      	str	r3, [r7, #24]
                    }
                }

                func_cnt ++;
 8019bc2:	8bfb      	ldrh	r3, [r7, #30]
 8019bc4:	3301      	adds	r3, #1
 8019bc6:	83fb      	strh	r3, [r7, #30]

                if (*prefix != 0)
 8019bc8:	687b      	ldr	r3, [r7, #4]
 8019bca:	781b      	ldrb	r3, [r3, #0]
 8019bcc:	2b00      	cmp	r3, #0
 8019bce:	d00c      	beq.n	8019bea <list_prefix+0x92>
                {
                    length = str_common(name_ptr, index->name);
 8019bd0:	693b      	ldr	r3, [r7, #16]
 8019bd2:	681b      	ldr	r3, [r3, #0]
 8019bd4:	6978      	ldr	r0, [r7, #20]
 8019bd6:	4619      	mov	r1, r3
 8019bd8:	f7ff ff98 	bl	8019b0c <str_common>
 8019bdc:	60b8      	str	r0, [r7, #8]
                    if (length < min_length)
 8019bde:	68ba      	ldr	r2, [r7, #8]
 8019be0:	69bb      	ldr	r3, [r7, #24]
 8019be2:	429a      	cmp	r2, r3
 8019be4:	da01      	bge.n	8019bea <list_prefix+0x92>
                        min_length = length;
 8019be6:	68bb      	ldr	r3, [r7, #8]
 8019be8:	61bb      	str	r3, [r7, #24]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 8019bea:	693b      	ldr	r3, [r7, #16]
 8019bec:	681a      	ldr	r2, [r3, #0]
 8019bee:	693b      	ldr	r3, [r7, #16]
 8019bf0:	685b      	ldr	r3, [r3, #4]
 8019bf2:	4875      	ldr	r0, [pc, #468]	; (8019dc8 <list_prefix+0x270>)
 8019bf4:	4611      	mov	r1, r2
 8019bf6:	461a      	mov	r2, r3
 8019bf8:	f7fa f83a 	bl	8013c70 <rt_kprintf>
    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
 8019bfc:	693b      	ldr	r3, [r7, #16]
 8019bfe:	330c      	adds	r3, #12
 8019c00:	613b      	str	r3, [r7, #16]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
 8019c02:	4b72      	ldr	r3, [pc, #456]	; (8019dcc <list_prefix+0x274>)
 8019c04:	681b      	ldr	r3, [r3, #0]
    name_ptr = RT_NULL;

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 8019c06:	693a      	ldr	r2, [r7, #16]
 8019c08:	429a      	cmp	r2, r3
 8019c0a:	d3b5      	bcc.n	8019b78 <list_prefix+0x20>
            }
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
 8019c0c:	4b70      	ldr	r3, [pc, #448]	; (8019dd0 <list_prefix+0x278>)
 8019c0e:	681b      	ldr	r3, [r3, #0]
 8019c10:	627b      	str	r3, [r7, #36]	; 0x24
    while (syscall_item != NULL)
 8019c12:	e03a      	b.n	8019c8a <list_prefix+0x132>
    {
        if (str_is_prefix(prefix, syscall_item->syscall.name) == 0)
 8019c14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c16:	685b      	ldr	r3, [r3, #4]
 8019c18:	6878      	ldr	r0, [r7, #4]
 8019c1a:	4619      	mov	r1, r3
 8019c1c:	f7ff ff52 	bl	8019ac4 <str_is_prefix>
 8019c20:	4603      	mov	r3, r0
 8019c22:	2b00      	cmp	r3, #0
 8019c24:	d12e      	bne.n	8019c84 <list_prefix+0x12c>
        {
            if (func_cnt == 0)
 8019c26:	8bfb      	ldrh	r3, [r7, #30]
 8019c28:	2b00      	cmp	r3, #0
 8019c2a:	d111      	bne.n	8019c50 <list_prefix+0xf8>
            {
                rt_kprintf("--function:\n");
 8019c2c:	4865      	ldr	r0, [pc, #404]	; (8019dc4 <list_prefix+0x26c>)
 8019c2e:	f7fa f81f 	bl	8013c70 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
 8019c32:	687b      	ldr	r3, [r7, #4]
 8019c34:	781b      	ldrb	r3, [r3, #0]
 8019c36:	2b00      	cmp	r3, #0
 8019c38:	d00a      	beq.n	8019c50 <list_prefix+0xf8>
 8019c3a:	697b      	ldr	r3, [r7, #20]
 8019c3c:	2b00      	cmp	r3, #0
 8019c3e:	d107      	bne.n	8019c50 <list_prefix+0xf8>
                {
                    /* set name_ptr */
                    name_ptr = syscall_item->syscall.name;
 8019c40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c42:	685b      	ldr	r3, [r3, #4]
 8019c44:	617b      	str	r3, [r7, #20]

                    /* set initial length */
                    min_length = strlen(name_ptr);
 8019c46:	6978      	ldr	r0, [r7, #20]
 8019c48:	f005 ff06 	bl	801fa58 <strlen>
 8019c4c:	4603      	mov	r3, r0
 8019c4e:	61bb      	str	r3, [r7, #24]
                }
            }

            func_cnt ++;
 8019c50:	8bfb      	ldrh	r3, [r7, #30]
 8019c52:	3301      	adds	r3, #1
 8019c54:	83fb      	strh	r3, [r7, #30]

            if (*prefix != 0)
 8019c56:	687b      	ldr	r3, [r7, #4]
 8019c58:	781b      	ldrb	r3, [r3, #0]
 8019c5a:	2b00      	cmp	r3, #0
 8019c5c:	d00c      	beq.n	8019c78 <list_prefix+0x120>
            {
                length = str_common(name_ptr, syscall_item->syscall.name);
 8019c5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c60:	685b      	ldr	r3, [r3, #4]
 8019c62:	6978      	ldr	r0, [r7, #20]
 8019c64:	4619      	mov	r1, r3
 8019c66:	f7ff ff51 	bl	8019b0c <str_common>
 8019c6a:	60b8      	str	r0, [r7, #8]
                if (length < min_length)
 8019c6c:	68ba      	ldr	r2, [r7, #8]
 8019c6e:	69bb      	ldr	r3, [r7, #24]
 8019c70:	429a      	cmp	r2, r3
 8019c72:	da01      	bge.n	8019c78 <list_prefix+0x120>
                    min_length = length;
 8019c74:	68bb      	ldr	r3, [r7, #8]
 8019c76:	61bb      	str	r3, [r7, #24]
            }

            rt_kprintf("[l] %s\n", syscall_item->syscall.name);
 8019c78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c7a:	685b      	ldr	r3, [r3, #4]
 8019c7c:	4855      	ldr	r0, [pc, #340]	; (8019dd4 <list_prefix+0x27c>)
 8019c7e:	4619      	mov	r1, r3
 8019c80:	f7f9 fff6 	bl	8013c70 <rt_kprintf>
        }
        syscall_item = syscall_item->next;
 8019c84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c86:	681b      	ldr	r3, [r3, #0]
 8019c88:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
 8019c8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c8c:	2b00      	cmp	r3, #0
 8019c8e:	d1c1      	bne.n	8019c14 <list_prefix+0xbc>
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
 8019c90:	4b51      	ldr	r3, [pc, #324]	; (8019dd8 <list_prefix+0x280>)
 8019c92:	681b      	ldr	r3, [r3, #0]
 8019c94:	60fb      	str	r3, [r7, #12]
 8019c96:	e03d      	b.n	8019d14 <list_prefix+0x1bc>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
            if (str_is_prefix(prefix, index->name) == 0)
 8019c98:	68fb      	ldr	r3, [r7, #12]
 8019c9a:	681b      	ldr	r3, [r3, #0]
 8019c9c:	6878      	ldr	r0, [r7, #4]
 8019c9e:	4619      	mov	r1, r3
 8019ca0:	f7ff ff10 	bl	8019ac4 <str_is_prefix>
 8019ca4:	4603      	mov	r3, r0
 8019ca6:	2b00      	cmp	r3, #0
 8019ca8:	d131      	bne.n	8019d0e <list_prefix+0x1b6>
            {
                if (var_cnt == 0)
 8019caa:	8bbb      	ldrh	r3, [r7, #28]
 8019cac:	2b00      	cmp	r3, #0
 8019cae:	d111      	bne.n	8019cd4 <list_prefix+0x17c>
                {
                    rt_kprintf("--variable:\n");
 8019cb0:	484a      	ldr	r0, [pc, #296]	; (8019ddc <list_prefix+0x284>)
 8019cb2:	f7f9 ffdd 	bl	8013c70 <rt_kprintf>

                    if (*prefix != 0 && name_ptr == NULL)
 8019cb6:	687b      	ldr	r3, [r7, #4]
 8019cb8:	781b      	ldrb	r3, [r3, #0]
 8019cba:	2b00      	cmp	r3, #0
 8019cbc:	d00a      	beq.n	8019cd4 <list_prefix+0x17c>
 8019cbe:	697b      	ldr	r3, [r7, #20]
 8019cc0:	2b00      	cmp	r3, #0
 8019cc2:	d107      	bne.n	8019cd4 <list_prefix+0x17c>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
 8019cc4:	68fb      	ldr	r3, [r7, #12]
 8019cc6:	681b      	ldr	r3, [r3, #0]
 8019cc8:	617b      	str	r3, [r7, #20]

                        /* set initial length */
                        min_length = strlen(name_ptr);
 8019cca:	6978      	ldr	r0, [r7, #20]
 8019ccc:	f005 fec4 	bl	801fa58 <strlen>
 8019cd0:	4603      	mov	r3, r0
 8019cd2:	61bb      	str	r3, [r7, #24]

                    }
                }

                var_cnt ++;
 8019cd4:	8bbb      	ldrh	r3, [r7, #28]
 8019cd6:	3301      	adds	r3, #1
 8019cd8:	83bb      	strh	r3, [r7, #28]

                if (*prefix != 0)
 8019cda:	687b      	ldr	r3, [r7, #4]
 8019cdc:	781b      	ldrb	r3, [r3, #0]
 8019cde:	2b00      	cmp	r3, #0
 8019ce0:	d00c      	beq.n	8019cfc <list_prefix+0x1a4>
                {
                    length = str_common(name_ptr, index->name);
 8019ce2:	68fb      	ldr	r3, [r7, #12]
 8019ce4:	681b      	ldr	r3, [r3, #0]
 8019ce6:	6978      	ldr	r0, [r7, #20]
 8019ce8:	4619      	mov	r1, r3
 8019cea:	f7ff ff0f 	bl	8019b0c <str_common>
 8019cee:	60b8      	str	r0, [r7, #8]
                    if (length < min_length)
 8019cf0:	68ba      	ldr	r2, [r7, #8]
 8019cf2:	69bb      	ldr	r3, [r7, #24]
 8019cf4:	429a      	cmp	r2, r3
 8019cf6:	da01      	bge.n	8019cfc <list_prefix+0x1a4>
                        min_length = length;
 8019cf8:	68bb      	ldr	r3, [r7, #8]
 8019cfa:	61bb      	str	r3, [r7, #24]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 8019cfc:	68fb      	ldr	r3, [r7, #12]
 8019cfe:	681a      	ldr	r2, [r3, #0]
 8019d00:	68fb      	ldr	r3, [r7, #12]
 8019d02:	685b      	ldr	r3, [r3, #4]
 8019d04:	4830      	ldr	r0, [pc, #192]	; (8019dc8 <list_prefix+0x270>)
 8019d06:	4611      	mov	r1, r2
 8019d08:	461a      	mov	r2, r3
 8019d0a:	f7f9 ffb1 	bl	8013c70 <rt_kprintf>
    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
 8019d0e:	68fb      	ldr	r3, [r7, #12]
 8019d10:	3310      	adds	r3, #16
 8019d12:	60fb      	str	r3, [r7, #12]

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
 8019d14:	4b32      	ldr	r3, [pc, #200]	; (8019de0 <list_prefix+0x288>)
 8019d16:	681b      	ldr	r3, [r3, #0]
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
 8019d18:	68fa      	ldr	r2, [r7, #12]
 8019d1a:	429a      	cmp	r2, r3
 8019d1c:	d3bc      	bcc.n	8019c98 <list_prefix+0x140>
            }
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
 8019d1e:	4b31      	ldr	r3, [pc, #196]	; (8019de4 <list_prefix+0x28c>)
 8019d20:	681b      	ldr	r3, [r3, #0]
 8019d22:	623b      	str	r3, [r7, #32]
    while (sysvar_item != NULL)
 8019d24:	e03a      	b.n	8019d9c <list_prefix+0x244>
    {
        if (str_is_prefix(prefix, sysvar_item->sysvar.name) == 0)
 8019d26:	6a3b      	ldr	r3, [r7, #32]
 8019d28:	685b      	ldr	r3, [r3, #4]
 8019d2a:	6878      	ldr	r0, [r7, #4]
 8019d2c:	4619      	mov	r1, r3
 8019d2e:	f7ff fec9 	bl	8019ac4 <str_is_prefix>
 8019d32:	4603      	mov	r3, r0
 8019d34:	2b00      	cmp	r3, #0
 8019d36:	d12e      	bne.n	8019d96 <list_prefix+0x23e>
        {
            if (var_cnt == 0)
 8019d38:	8bbb      	ldrh	r3, [r7, #28]
 8019d3a:	2b00      	cmp	r3, #0
 8019d3c:	d111      	bne.n	8019d62 <list_prefix+0x20a>
            {
                rt_kprintf("--variable:\n");
 8019d3e:	4827      	ldr	r0, [pc, #156]	; (8019ddc <list_prefix+0x284>)
 8019d40:	f7f9 ff96 	bl	8013c70 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
 8019d44:	687b      	ldr	r3, [r7, #4]
 8019d46:	781b      	ldrb	r3, [r3, #0]
 8019d48:	2b00      	cmp	r3, #0
 8019d4a:	d00a      	beq.n	8019d62 <list_prefix+0x20a>
 8019d4c:	697b      	ldr	r3, [r7, #20]
 8019d4e:	2b00      	cmp	r3, #0
 8019d50:	d107      	bne.n	8019d62 <list_prefix+0x20a>
                {
                    /* set name_ptr */
                    name_ptr = sysvar_item->sysvar.name;
 8019d52:	6a3b      	ldr	r3, [r7, #32]
 8019d54:	685b      	ldr	r3, [r3, #4]
 8019d56:	617b      	str	r3, [r7, #20]

                    /* set initial length */
                    min_length = strlen(name_ptr);
 8019d58:	6978      	ldr	r0, [r7, #20]
 8019d5a:	f005 fe7d 	bl	801fa58 <strlen>
 8019d5e:	4603      	mov	r3, r0
 8019d60:	61bb      	str	r3, [r7, #24]
                }
            }

            var_cnt ++;
 8019d62:	8bbb      	ldrh	r3, [r7, #28]
 8019d64:	3301      	adds	r3, #1
 8019d66:	83bb      	strh	r3, [r7, #28]

            if (*prefix != 0)
 8019d68:	687b      	ldr	r3, [r7, #4]
 8019d6a:	781b      	ldrb	r3, [r3, #0]
 8019d6c:	2b00      	cmp	r3, #0
 8019d6e:	d00c      	beq.n	8019d8a <list_prefix+0x232>
            {
                length = str_common(name_ptr, sysvar_item->sysvar.name);
 8019d70:	6a3b      	ldr	r3, [r7, #32]
 8019d72:	685b      	ldr	r3, [r3, #4]
 8019d74:	6978      	ldr	r0, [r7, #20]
 8019d76:	4619      	mov	r1, r3
 8019d78:	f7ff fec8 	bl	8019b0c <str_common>
 8019d7c:	60b8      	str	r0, [r7, #8]
                if (length < min_length)
 8019d7e:	68ba      	ldr	r2, [r7, #8]
 8019d80:	69bb      	ldr	r3, [r7, #24]
 8019d82:	429a      	cmp	r2, r3
 8019d84:	da01      	bge.n	8019d8a <list_prefix+0x232>
                    min_length = length;
 8019d86:	68bb      	ldr	r3, [r7, #8]
 8019d88:	61bb      	str	r3, [r7, #24]
            }

            rt_kprintf("[v] %s\n", sysvar_item->sysvar.name);
 8019d8a:	6a3b      	ldr	r3, [r7, #32]
 8019d8c:	685b      	ldr	r3, [r3, #4]
 8019d8e:	4816      	ldr	r0, [pc, #88]	; (8019de8 <list_prefix+0x290>)
 8019d90:	4619      	mov	r1, r3
 8019d92:	f7f9 ff6d 	bl	8013c70 <rt_kprintf>
        }
        sysvar_item = sysvar_item->next;
 8019d96:	6a3b      	ldr	r3, [r7, #32]
 8019d98:	681b      	ldr	r3, [r3, #0]
 8019d9a:	623b      	str	r3, [r7, #32]
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
 8019d9c:	6a3b      	ldr	r3, [r7, #32]
 8019d9e:	2b00      	cmp	r3, #0
 8019da0:	d1c1      	bne.n	8019d26 <list_prefix+0x1ce>
        }
        sysvar_item = sysvar_item->next;
    }

    /* only one matched */
    if (name_ptr != NULL)
 8019da2:	697b      	ldr	r3, [r7, #20]
 8019da4:	2b00      	cmp	r3, #0
 8019da6:	d005      	beq.n	8019db4 <list_prefix+0x25c>
    {
        rt_strncpy(prefix, name_ptr, min_length);
 8019da8:	69bb      	ldr	r3, [r7, #24]
 8019daa:	6878      	ldr	r0, [r7, #4]
 8019dac:	6979      	ldr	r1, [r7, #20]
 8019dae:	461a      	mov	r2, r3
 8019db0:	f7f9 faae 	bl	8013310 <rt_strncpy>
    }
}
 8019db4:	3728      	adds	r7, #40	; 0x28
 8019db6:	46bd      	mov	sp, r7
 8019db8:	bd80      	pop	{r7, pc}
 8019dba:	bf00      	nop
 8019dbc:	200121cc 	.word	0x200121cc
 8019dc0:	080241f0 	.word	0x080241f0
 8019dc4:	08024220 	.word	0x08024220
 8019dc8:	080241f4 	.word	0x080241f4
 8019dcc:	200121d0 	.word	0x200121d0
 8019dd0:	200121e8 	.word	0x200121e8
 8019dd4:	08024204 	.word	0x08024204
 8019dd8:	200121d4 	.word	0x200121d4
 8019ddc:	08024230 	.word	0x08024230
 8019de0:	200121d8 	.word	0x200121d8
 8019de4:	200128b0 	.word	0x200128b0
 8019de8:	08024240 	.word	0x08024240

08019dec <cmd_ps>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_netstat, __cmd_netstat, list the information of TCP/IP);
#endif
#endif /* RT_USING_LWIP */

int cmd_ps(int argc, char** argv)
{
 8019dec:	b580      	push	{r7, lr}
 8019dee:	b082      	sub	sp, #8
 8019df0:	af00      	add	r7, sp, #0
 8019df2:	6078      	str	r0, [r7, #4]
 8019df4:	6039      	str	r1, [r7, #0]
    extern long list_thread(void);

    list_thread();
 8019df6:	f7ff faab 	bl	8019350 <list_thread>
    return 0;
 8019dfa:	2300      	movs	r3, #0
}
 8019dfc:	4618      	mov	r0, r3
 8019dfe:	3708      	adds	r7, #8
 8019e00:	46bd      	mov	sp, r7
 8019e02:	bd80      	pop	{r7, pc}

08019e04 <cmd_time>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_ps, __cmd_ps, List threads in the system.);

int cmd_time(int argc, char** argv)
{
 8019e04:	b480      	push	{r7}
 8019e06:	b083      	sub	sp, #12
 8019e08:	af00      	add	r7, sp, #0
 8019e0a:	6078      	str	r0, [r7, #4]
 8019e0c:	6039      	str	r1, [r7, #0]
    return 0;
 8019e0e:	2300      	movs	r3, #0
}
 8019e10:	4618      	mov	r0, r3
 8019e12:	370c      	adds	r7, #12
 8019e14:	46bd      	mov	sp, r7
 8019e16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e1a:	4770      	bx	lr

08019e1c <cmd_free>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_time, __cmd_time, Execute command with time.);

#ifdef RT_USING_HEAP
int cmd_free(int argc, char** argv)
{
 8019e1c:	b580      	push	{r7, lr}
 8019e1e:	b082      	sub	sp, #8
 8019e20:	af00      	add	r7, sp, #0
 8019e22:	6078      	str	r0, [r7, #4]
 8019e24:	6039      	str	r1, [r7, #0]
    extern void list_memheap(void);

#ifdef RT_USING_MEMHEAP_AS_HEAP
    list_memheap();
#else
    list_mem();
 8019e26:	f7fa fb81 	bl	801452c <list_mem>
#endif
    return 0;
 8019e2a:	2300      	movs	r3, #0
}
 8019e2c:	4618      	mov	r0, r3
 8019e2e:	3708      	adds	r7, #8
 8019e30:	46bd      	mov	sp, r7
 8019e32:	bd80      	pop	{r7, pc}

08019e34 <msh_is_used>:
static rt_bool_t __msh_state = RT_TRUE;
#else
static rt_bool_t __msh_state = RT_FALSE;
#endif
rt_bool_t msh_is_used(void)
{
 8019e34:	b480      	push	{r7}
 8019e36:	af00      	add	r7, sp, #0
    return __msh_state;
 8019e38:	4b03      	ldr	r3, [pc, #12]	; (8019e48 <msh_is_used+0x14>)
 8019e3a:	681b      	ldr	r3, [r3, #0]
}
 8019e3c:	4618      	mov	r0, r3
 8019e3e:	46bd      	mov	sp, r7
 8019e40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e44:	4770      	bx	lr
 8019e46:	bf00      	nop
 8019e48:	200100c4 	.word	0x200100c4

08019e4c <msh_exit>:

static int msh_exit(int argc, char** argv)
{
 8019e4c:	b480      	push	{r7}
 8019e4e:	b083      	sub	sp, #12
 8019e50:	af00      	add	r7, sp, #0
 8019e52:	6078      	str	r0, [r7, #4]
 8019e54:	6039      	str	r1, [r7, #0]
    /* return to finsh shell mode */
    __msh_state = RT_FALSE;
 8019e56:	4b05      	ldr	r3, [pc, #20]	; (8019e6c <msh_exit+0x20>)
 8019e58:	2200      	movs	r2, #0
 8019e5a:	601a      	str	r2, [r3, #0]

    return 0;
 8019e5c:	2300      	movs	r3, #0
}
 8019e5e:	4618      	mov	r0, r3
 8019e60:	370c      	adds	r7, #12
 8019e62:	46bd      	mov	sp, r7
 8019e64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e68:	4770      	bx	lr
 8019e6a:	bf00      	nop
 8019e6c:	200100c4 	.word	0x200100c4

08019e70 <msh_enter>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_exit, __cmd_exit, return to RT-Thread shell mode.);

static int msh_enter(void)
{
 8019e70:	b480      	push	{r7}
 8019e72:	af00      	add	r7, sp, #0
    /* enter module shell mode */
    __msh_state = RT_TRUE;
 8019e74:	4b04      	ldr	r3, [pc, #16]	; (8019e88 <msh_enter+0x18>)
 8019e76:	2201      	movs	r2, #1
 8019e78:	601a      	str	r2, [r3, #0]
    return 0;
 8019e7a:	2300      	movs	r3, #0
}
 8019e7c:	4618      	mov	r0, r3
 8019e7e:	46bd      	mov	sp, r7
 8019e80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e84:	4770      	bx	lr
 8019e86:	bf00      	nop
 8019e88:	200100c4 	.word	0x200100c4

08019e8c <msh_help>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_enter, msh, use module shell);
#endif

int msh_help(int argc, char** argv)
{
 8019e8c:	b580      	push	{r7, lr}
 8019e8e:	b084      	sub	sp, #16
 8019e90:	af00      	add	r7, sp, #0
 8019e92:	6078      	str	r0, [r7, #4]
 8019e94:	6039      	str	r1, [r7, #0]
    rt_kprintf("RT-Thread shell commands:\n");
 8019e96:	4816      	ldr	r0, [pc, #88]	; (8019ef0 <msh_help+0x64>)
 8019e98:	f7f9 feea 	bl	8013c70 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
 8019e9c:	4b15      	ldr	r3, [pc, #84]	; (8019ef4 <msh_help+0x68>)
 8019e9e:	681b      	ldr	r3, [r3, #0]
 8019ea0:	60fb      	str	r3, [r7, #12]
 8019ea2:	e017      	b.n	8019ed4 <msh_help+0x48>
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
        {
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 8019ea4:	68fb      	ldr	r3, [r7, #12]
 8019ea6:	681b      	ldr	r3, [r3, #0]
 8019ea8:	4618      	mov	r0, r3
 8019eaa:	4913      	ldr	r1, [pc, #76]	; (8019ef8 <msh_help+0x6c>)
 8019eac:	2206      	movs	r2, #6
 8019eae:	f005 fe01 	bl	801fab4 <strncmp>
 8019eb2:	4603      	mov	r3, r0
 8019eb4:	2b00      	cmp	r3, #0
 8019eb6:	d000      	beq.n	8019eba <msh_help+0x2e>
 8019eb8:	e009      	b.n	8019ece <msh_help+0x42>
#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
            rt_kprintf("%-16s - %s\n", &index->name[6], index->desc);
 8019eba:	68fb      	ldr	r3, [r7, #12]
 8019ebc:	681b      	ldr	r3, [r3, #0]
 8019ebe:	1d9a      	adds	r2, r3, #6
 8019ec0:	68fb      	ldr	r3, [r7, #12]
 8019ec2:	685b      	ldr	r3, [r3, #4]
 8019ec4:	480d      	ldr	r0, [pc, #52]	; (8019efc <msh_help+0x70>)
 8019ec6:	4611      	mov	r1, r2
 8019ec8:	461a      	mov	r2, r3
 8019eca:	f7f9 fed1 	bl	8013c70 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
 8019ece:	68fb      	ldr	r3, [r7, #12]
 8019ed0:	330c      	adds	r3, #12
 8019ed2:	60fb      	str	r3, [r7, #12]
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
 8019ed4:	4b0a      	ldr	r3, [pc, #40]	; (8019f00 <msh_help+0x74>)
 8019ed6:	681b      	ldr	r3, [r3, #0]
{
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
 8019ed8:	68fa      	ldr	r2, [r7, #12]
 8019eda:	429a      	cmp	r2, r3
 8019edc:	d3e2      	bcc.n	8019ea4 <msh_help+0x18>
#else
            rt_kprintf("%s ", &index->name[6]);
#endif
        }
    }
    rt_kprintf("\n");
 8019ede:	4809      	ldr	r0, [pc, #36]	; (8019f04 <msh_help+0x78>)
 8019ee0:	f7f9 fec6 	bl	8013c70 <rt_kprintf>

    return 0;
 8019ee4:	2300      	movs	r3, #0
}
 8019ee6:	4618      	mov	r0, r3
 8019ee8:	3710      	adds	r7, #16
 8019eea:	46bd      	mov	sp, r7
 8019eec:	bd80      	pop	{r7, pc}
 8019eee:	bf00      	nop
 8019ef0:	08024248 	.word	0x08024248
 8019ef4:	200121cc 	.word	0x200121cc
 8019ef8:	08024264 	.word	0x08024264
 8019efc:	0802426c 	.word	0x0802426c
 8019f00:	200121d0 	.word	0x200121d0
 8019f04:	08024278 	.word	0x08024278

08019f08 <msh_split>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_help, __cmd_help, RT-Thread shell help.);

static int msh_split(char* cmd, rt_size_t length, char* argv[RT_FINSH_ARG_MAX])
{
 8019f08:	b480      	push	{r7}
 8019f0a:	b089      	sub	sp, #36	; 0x24
 8019f0c:	af00      	add	r7, sp, #0
 8019f0e:	60f8      	str	r0, [r7, #12]
 8019f10:	60b9      	str	r1, [r7, #8]
 8019f12:	607a      	str	r2, [r7, #4]
    char *ptr;
    rt_size_t position;
    rt_size_t argc;

    ptr = cmd;
 8019f14:	68fb      	ldr	r3, [r7, #12]
 8019f16:	61fb      	str	r3, [r7, #28]
    position = 0; argc = 0;
 8019f18:	2300      	movs	r3, #0
 8019f1a:	61bb      	str	r3, [r7, #24]
 8019f1c:	2300      	movs	r3, #0
 8019f1e:	617b      	str	r3, [r7, #20]

    while (position < length)
 8019f20:	e07b      	b.n	801a01a <msh_split+0x112>
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
 8019f22:	e008      	b.n	8019f36 <msh_split+0x2e>
        {
            *ptr = '\0';
 8019f24:	69fb      	ldr	r3, [r7, #28]
 8019f26:	2200      	movs	r2, #0
 8019f28:	701a      	strb	r2, [r3, #0]
            ptr ++; position ++;
 8019f2a:	69fb      	ldr	r3, [r7, #28]
 8019f2c:	3301      	adds	r3, #1
 8019f2e:	61fb      	str	r3, [r7, #28]
 8019f30:	69bb      	ldr	r3, [r7, #24]
 8019f32:	3301      	adds	r3, #1
 8019f34:	61bb      	str	r3, [r7, #24]
    position = 0; argc = 0;

    while (position < length)
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
 8019f36:	69fb      	ldr	r3, [r7, #28]
 8019f38:	781b      	ldrb	r3, [r3, #0]
 8019f3a:	2b20      	cmp	r3, #32
 8019f3c:	d003      	beq.n	8019f46 <msh_split+0x3e>
 8019f3e:	69fb      	ldr	r3, [r7, #28]
 8019f40:	781b      	ldrb	r3, [r3, #0]
 8019f42:	2b09      	cmp	r3, #9
 8019f44:	d103      	bne.n	8019f4e <msh_split+0x46>
 8019f46:	69ba      	ldr	r2, [r7, #24]
 8019f48:	68bb      	ldr	r3, [r7, #8]
 8019f4a:	429a      	cmp	r2, r3
 8019f4c:	d3ea      	bcc.n	8019f24 <msh_split+0x1c>
        {
            *ptr = '\0';
            ptr ++; position ++;
        }
        if (position >= length) break;
 8019f4e:	69ba      	ldr	r2, [r7, #24]
 8019f50:	68bb      	ldr	r3, [r7, #8]
 8019f52:	429a      	cmp	r2, r3
 8019f54:	d300      	bcc.n	8019f58 <msh_split+0x50>
 8019f56:	e065      	b.n	801a024 <msh_split+0x11c>

        /* handle string */
        if (*ptr == '"')
 8019f58:	69fb      	ldr	r3, [r7, #28]
 8019f5a:	781b      	ldrb	r3, [r3, #0]
 8019f5c:	2b22      	cmp	r3, #34	; 0x22
 8019f5e:	d13b      	bne.n	8019fd8 <msh_split+0xd0>
        {
            ptr ++; position ++;
 8019f60:	69fb      	ldr	r3, [r7, #28]
 8019f62:	3301      	adds	r3, #1
 8019f64:	61fb      	str	r3, [r7, #28]
 8019f66:	69bb      	ldr	r3, [r7, #24]
 8019f68:	3301      	adds	r3, #1
 8019f6a:	61bb      	str	r3, [r7, #24]
            argv[argc] = ptr; argc ++;
 8019f6c:	697b      	ldr	r3, [r7, #20]
 8019f6e:	009b      	lsls	r3, r3, #2
 8019f70:	687a      	ldr	r2, [r7, #4]
 8019f72:	4413      	add	r3, r2
 8019f74:	69fa      	ldr	r2, [r7, #28]
 8019f76:	601a      	str	r2, [r3, #0]
 8019f78:	697b      	ldr	r3, [r7, #20]
 8019f7a:	3301      	adds	r3, #1
 8019f7c:	617b      	str	r3, [r7, #20]

            /* skip this string */
            while (*ptr != '"' && position < length)
 8019f7e:	e014      	b.n	8019faa <msh_split+0xa2>
            {
                if (*ptr == '\\')
 8019f80:	69fb      	ldr	r3, [r7, #28]
 8019f82:	781b      	ldrb	r3, [r3, #0]
 8019f84:	2b5c      	cmp	r3, #92	; 0x5c
 8019f86:	d10a      	bne.n	8019f9e <msh_split+0x96>
                {
                    if (*(ptr + 1) == '"')
 8019f88:	69fb      	ldr	r3, [r7, #28]
 8019f8a:	3301      	adds	r3, #1
 8019f8c:	781b      	ldrb	r3, [r3, #0]
 8019f8e:	2b22      	cmp	r3, #34	; 0x22
 8019f90:	d105      	bne.n	8019f9e <msh_split+0x96>
                    {
                        ptr ++; position ++;
 8019f92:	69fb      	ldr	r3, [r7, #28]
 8019f94:	3301      	adds	r3, #1
 8019f96:	61fb      	str	r3, [r7, #28]
 8019f98:	69bb      	ldr	r3, [r7, #24]
 8019f9a:	3301      	adds	r3, #1
 8019f9c:	61bb      	str	r3, [r7, #24]
                    }
                }
                ptr ++; position ++;
 8019f9e:	69fb      	ldr	r3, [r7, #28]
 8019fa0:	3301      	adds	r3, #1
 8019fa2:	61fb      	str	r3, [r7, #28]
 8019fa4:	69bb      	ldr	r3, [r7, #24]
 8019fa6:	3301      	adds	r3, #1
 8019fa8:	61bb      	str	r3, [r7, #24]
        {
            ptr ++; position ++;
            argv[argc] = ptr; argc ++;

            /* skip this string */
            while (*ptr != '"' && position < length)
 8019faa:	69fb      	ldr	r3, [r7, #28]
 8019fac:	781b      	ldrb	r3, [r3, #0]
 8019fae:	2b22      	cmp	r3, #34	; 0x22
 8019fb0:	d003      	beq.n	8019fba <msh_split+0xb2>
 8019fb2:	69ba      	ldr	r2, [r7, #24]
 8019fb4:	68bb      	ldr	r3, [r7, #8]
 8019fb6:	429a      	cmp	r2, r3
 8019fb8:	d3e2      	bcc.n	8019f80 <msh_split+0x78>
                        ptr ++; position ++;
                    }
                }
                ptr ++; position ++;
            }
            if (position >= length) break;
 8019fba:	69ba      	ldr	r2, [r7, #24]
 8019fbc:	68bb      	ldr	r3, [r7, #8]
 8019fbe:	429a      	cmp	r2, r3
 8019fc0:	d300      	bcc.n	8019fc4 <msh_split+0xbc>
 8019fc2:	e02f      	b.n	801a024 <msh_split+0x11c>

            /* skip '"' */
            *ptr = '\0'; ptr ++; position ++;
 8019fc4:	69fb      	ldr	r3, [r7, #28]
 8019fc6:	2200      	movs	r2, #0
 8019fc8:	701a      	strb	r2, [r3, #0]
 8019fca:	69fb      	ldr	r3, [r7, #28]
 8019fcc:	3301      	adds	r3, #1
 8019fce:	61fb      	str	r3, [r7, #28]
 8019fd0:	69bb      	ldr	r3, [r7, #24]
 8019fd2:	3301      	adds	r3, #1
 8019fd4:	61bb      	str	r3, [r7, #24]
 8019fd6:	e020      	b.n	801a01a <msh_split+0x112>
        }
        else
        {
            argv[argc] = ptr;
 8019fd8:	697b      	ldr	r3, [r7, #20]
 8019fda:	009b      	lsls	r3, r3, #2
 8019fdc:	687a      	ldr	r2, [r7, #4]
 8019fde:	4413      	add	r3, r2
 8019fe0:	69fa      	ldr	r2, [r7, #28]
 8019fe2:	601a      	str	r2, [r3, #0]
            argc ++;
 8019fe4:	697b      	ldr	r3, [r7, #20]
 8019fe6:	3301      	adds	r3, #1
 8019fe8:	617b      	str	r3, [r7, #20]
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
 8019fea:	e005      	b.n	8019ff8 <msh_split+0xf0>
            {
                ptr ++; position ++;
 8019fec:	69fb      	ldr	r3, [r7, #28]
 8019fee:	3301      	adds	r3, #1
 8019ff0:	61fb      	str	r3, [r7, #28]
 8019ff2:	69bb      	ldr	r3, [r7, #24]
 8019ff4:	3301      	adds	r3, #1
 8019ff6:	61bb      	str	r3, [r7, #24]
        }
        else
        {
            argv[argc] = ptr;
            argc ++;
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
 8019ff8:	69fb      	ldr	r3, [r7, #28]
 8019ffa:	781b      	ldrb	r3, [r3, #0]
 8019ffc:	2b20      	cmp	r3, #32
 8019ffe:	d007      	beq.n	801a010 <msh_split+0x108>
 801a000:	69fb      	ldr	r3, [r7, #28]
 801a002:	781b      	ldrb	r3, [r3, #0]
 801a004:	2b09      	cmp	r3, #9
 801a006:	d003      	beq.n	801a010 <msh_split+0x108>
 801a008:	69ba      	ldr	r2, [r7, #24]
 801a00a:	68bb      	ldr	r3, [r7, #8]
 801a00c:	429a      	cmp	r2, r3
 801a00e:	d3ed      	bcc.n	8019fec <msh_split+0xe4>
            {
                ptr ++; position ++;
            }
            if (position >= length) break;
 801a010:	69ba      	ldr	r2, [r7, #24]
 801a012:	68bb      	ldr	r3, [r7, #8]
 801a014:	429a      	cmp	r2, r3
 801a016:	d300      	bcc.n	801a01a <msh_split+0x112>
 801a018:	e004      	b.n	801a024 <msh_split+0x11c>
    rt_size_t argc;

    ptr = cmd;
    position = 0; argc = 0;

    while (position < length)
 801a01a:	69ba      	ldr	r2, [r7, #24]
 801a01c:	68bb      	ldr	r3, [r7, #8]
 801a01e:	429a      	cmp	r2, r3
 801a020:	f4ff af7f 	bcc.w	8019f22 <msh_split+0x1a>
            }
            if (position >= length) break;
        }
    }

    return argc;
 801a024:	697b      	ldr	r3, [r7, #20]
}
 801a026:	4618      	mov	r0, r3
 801a028:	3724      	adds	r7, #36	; 0x24
 801a02a:	46bd      	mov	sp, r7
 801a02c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a030:	4770      	bx	lr
 801a032:	bf00      	nop

0801a034 <msh_get_cmd>:

static cmd_function_t msh_get_cmd(char *cmd, int size)
{
 801a034:	b580      	push	{r7, lr}
 801a036:	b084      	sub	sp, #16
 801a038:	af00      	add	r7, sp, #0
 801a03a:	6078      	str	r0, [r7, #4]
 801a03c:	6039      	str	r1, [r7, #0]
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;
 801a03e:	2300      	movs	r3, #0
 801a040:	60bb      	str	r3, [r7, #8]

    for (index = _syscall_table_begin;
 801a042:	4b1a      	ldr	r3, [pc, #104]	; (801a0ac <msh_get_cmd+0x78>)
 801a044:	681b      	ldr	r3, [r3, #0]
 801a046:	60fb      	str	r3, [r7, #12]
 801a048:	e025      	b.n	801a096 <msh_get_cmd+0x62>
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 801a04a:	68fb      	ldr	r3, [r7, #12]
 801a04c:	681b      	ldr	r3, [r3, #0]
 801a04e:	4618      	mov	r0, r3
 801a050:	4917      	ldr	r1, [pc, #92]	; (801a0b0 <msh_get_cmd+0x7c>)
 801a052:	2206      	movs	r2, #6
 801a054:	f005 fd2e 	bl	801fab4 <strncmp>
 801a058:	4603      	mov	r3, r0
 801a05a:	2b00      	cmp	r3, #0
 801a05c:	d000      	beq.n	801a060 <msh_get_cmd+0x2c>
 801a05e:	e017      	b.n	801a090 <msh_get_cmd+0x5c>
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
 801a060:	68fb      	ldr	r3, [r7, #12]
 801a062:	681b      	ldr	r3, [r3, #0]
 801a064:	1d9a      	adds	r2, r3, #6
 801a066:	683b      	ldr	r3, [r7, #0]
 801a068:	4610      	mov	r0, r2
 801a06a:	6879      	ldr	r1, [r7, #4]
 801a06c:	461a      	mov	r2, r3
 801a06e:	f005 fd21 	bl	801fab4 <strncmp>
 801a072:	4603      	mov	r3, r0
 801a074:	2b00      	cmp	r3, #0
 801a076:	d10b      	bne.n	801a090 <msh_get_cmd+0x5c>
			index->name[6 + size] == '\0')
 801a078:	68fb      	ldr	r3, [r7, #12]
 801a07a:	681b      	ldr	r3, [r3, #0]
 801a07c:	683a      	ldr	r2, [r7, #0]
 801a07e:	3206      	adds	r2, #6
 801a080:	4413      	add	r3, r2
 801a082:	781b      	ldrb	r3, [r3, #0]
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
 801a084:	2b00      	cmp	r3, #0
 801a086:	d103      	bne.n	801a090 <msh_get_cmd+0x5c>
			index->name[6 + size] == '\0')
        {
            cmd_func = (cmd_function_t)index->func;
 801a088:	68fb      	ldr	r3, [r7, #12]
 801a08a:	689b      	ldr	r3, [r3, #8]
 801a08c:	60bb      	str	r3, [r7, #8]
            break;
 801a08e:	e007      	b.n	801a0a0 <msh_get_cmd+0x6c>
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
 801a090:	68fb      	ldr	r3, [r7, #12]
 801a092:	330c      	adds	r3, #12
 801a094:	60fb      	str	r3, [r7, #12]
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
 801a096:	4b07      	ldr	r3, [pc, #28]	; (801a0b4 <msh_get_cmd+0x80>)
 801a098:	681b      	ldr	r3, [r3, #0]
static cmd_function_t msh_get_cmd(char *cmd, int size)
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
 801a09a:	68fa      	ldr	r2, [r7, #12]
 801a09c:	429a      	cmp	r2, r3
 801a09e:	d3d4      	bcc.n	801a04a <msh_get_cmd+0x16>
            cmd_func = (cmd_function_t)index->func;
            break;
        }
    }

    return cmd_func;
 801a0a0:	68bb      	ldr	r3, [r7, #8]
}
 801a0a2:	4618      	mov	r0, r3
 801a0a4:	3710      	adds	r7, #16
 801a0a6:	46bd      	mov	sp, r7
 801a0a8:	bd80      	pop	{r7, pc}
 801a0aa:	bf00      	nop
 801a0ac:	200121cc 	.word	0x200121cc
 801a0b0:	08024264 	.word	0x08024264
 801a0b4:	200121d0 	.word	0x200121d0

0801a0b8 <_msh_exec_cmd>:
}
RTM_EXPORT(system);
#endif

static int _msh_exec_cmd(char* cmd, rt_size_t length, int *retp)
{
 801a0b8:	b580      	push	{r7, lr}
 801a0ba:	b092      	sub	sp, #72	; 0x48
 801a0bc:	af00      	add	r7, sp, #0
 801a0be:	60f8      	str	r0, [r7, #12]
 801a0c0:	60b9      	str	r1, [r7, #8]
 801a0c2:	607a      	str	r2, [r7, #4]
    int argc;
    int cmd0_size = 0;
 801a0c4:	2300      	movs	r3, #0
 801a0c6:	647b      	str	r3, [r7, #68]	; 0x44
    cmd_function_t cmd_func;
    char *argv[RT_FINSH_ARG_MAX];

    RT_ASSERT(cmd);
 801a0c8:	68fb      	ldr	r3, [r7, #12]
 801a0ca:	2b00      	cmp	r3, #0
 801a0cc:	d105      	bne.n	801a0da <_msh_exec_cmd+0x22>
 801a0ce:	482b      	ldr	r0, [pc, #172]	; (801a17c <_msh_exec_cmd+0xc4>)
 801a0d0:	492b      	ldr	r1, [pc, #172]	; (801a180 <_msh_exec_cmd+0xc8>)
 801a0d2:	f44f 7285 	mov.w	r2, #266	; 0x10a
 801a0d6:	f7f9 fe45 	bl	8013d64 <rt_assert_handler>
    RT_ASSERT(retp);
 801a0da:	687b      	ldr	r3, [r7, #4]
 801a0dc:	2b00      	cmp	r3, #0
 801a0de:	d105      	bne.n	801a0ec <_msh_exec_cmd+0x34>
 801a0e0:	4828      	ldr	r0, [pc, #160]	; (801a184 <_msh_exec_cmd+0xcc>)
 801a0e2:	4927      	ldr	r1, [pc, #156]	; (801a180 <_msh_exec_cmd+0xc8>)
 801a0e4:	f240 120b 	movw	r2, #267	; 0x10b
 801a0e8:	f7f9 fe3c 	bl	8013d64 <rt_assert_handler>

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
 801a0ec:	e002      	b.n	801a0f4 <_msh_exec_cmd+0x3c>
        cmd0_size ++;
 801a0ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a0f0:	3301      	adds	r3, #1
 801a0f2:	647b      	str	r3, [r7, #68]	; 0x44

    RT_ASSERT(cmd);
    RT_ASSERT(retp);

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
 801a0f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a0f6:	68fa      	ldr	r2, [r7, #12]
 801a0f8:	4413      	add	r3, r2
 801a0fa:	781b      	ldrb	r3, [r3, #0]
 801a0fc:	2b20      	cmp	r3, #32
 801a0fe:	d009      	beq.n	801a114 <_msh_exec_cmd+0x5c>
 801a100:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a102:	68fa      	ldr	r2, [r7, #12]
 801a104:	4413      	add	r3, r2
 801a106:	781b      	ldrb	r3, [r3, #0]
 801a108:	2b09      	cmp	r3, #9
 801a10a:	d003      	beq.n	801a114 <_msh_exec_cmd+0x5c>
 801a10c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a10e:	68bb      	ldr	r3, [r7, #8]
 801a110:	429a      	cmp	r2, r3
 801a112:	d3ec      	bcc.n	801a0ee <_msh_exec_cmd+0x36>
        cmd0_size ++;
    if (cmd0_size == 0)
 801a114:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a116:	2b00      	cmp	r3, #0
 801a118:	d102      	bne.n	801a120 <_msh_exec_cmd+0x68>
        return -RT_ERROR;
 801a11a:	f04f 33ff 	mov.w	r3, #4294967295
 801a11e:	e029      	b.n	801a174 <_msh_exec_cmd+0xbc>

    cmd_func = msh_get_cmd(cmd, cmd0_size);
 801a120:	68f8      	ldr	r0, [r7, #12]
 801a122:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a124:	f7ff ff86 	bl	801a034 <msh_get_cmd>
 801a128:	6438      	str	r0, [r7, #64]	; 0x40
    if (cmd_func == RT_NULL)
 801a12a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a12c:	2b00      	cmp	r3, #0
 801a12e:	d102      	bne.n	801a136 <_msh_exec_cmd+0x7e>
        return -RT_ERROR;
 801a130:	f04f 33ff 	mov.w	r3, #4294967295
 801a134:	e01e      	b.n	801a174 <_msh_exec_cmd+0xbc>

    /* split arguments */
    memset(argv, 0x00, sizeof(argv));
 801a136:	f107 0314 	add.w	r3, r7, #20
 801a13a:	4618      	mov	r0, r3
 801a13c:	2100      	movs	r1, #0
 801a13e:	2228      	movs	r2, #40	; 0x28
 801a140:	f004 fff8 	bl	801f134 <memset>
    argc = msh_split(cmd, length, argv);
 801a144:	f107 0314 	add.w	r3, r7, #20
 801a148:	68f8      	ldr	r0, [r7, #12]
 801a14a:	68b9      	ldr	r1, [r7, #8]
 801a14c:	461a      	mov	r2, r3
 801a14e:	f7ff fedb 	bl	8019f08 <msh_split>
 801a152:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (argc == 0)
 801a154:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a156:	2b00      	cmp	r3, #0
 801a158:	d102      	bne.n	801a160 <_msh_exec_cmd+0xa8>
        return -RT_ERROR;
 801a15a:	f04f 33ff 	mov.w	r3, #4294967295
 801a15e:	e009      	b.n	801a174 <_msh_exec_cmd+0xbc>

    /* exec this command */
    *retp = cmd_func(argc, argv);
 801a160:	f107 0214 	add.w	r2, r7, #20
 801a164:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a166:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801a168:	4611      	mov	r1, r2
 801a16a:	4798      	blx	r3
 801a16c:	4602      	mov	r2, r0
 801a16e:	687b      	ldr	r3, [r7, #4]
 801a170:	601a      	str	r2, [r3, #0]
    return 0;
 801a172:	2300      	movs	r3, #0
}
 801a174:	4618      	mov	r0, r3
 801a176:	3748      	adds	r7, #72	; 0x48
 801a178:	46bd      	mov	sp, r7
 801a17a:	bd80      	pop	{r7, pc}
 801a17c:	0802427c 	.word	0x0802427c
 801a180:	080259a4 	.word	0x080259a4
 801a184:	08024280 	.word	0x08024280

0801a188 <msh_exec>:

int msh_exec(char* cmd, rt_size_t length)
{
 801a188:	b580      	push	{r7, lr}
 801a18a:	b084      	sub	sp, #16
 801a18c:	af00      	add	r7, sp, #0
 801a18e:	6078      	str	r0, [r7, #4]
 801a190:	6039      	str	r1, [r7, #0]
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
 801a192:	e005      	b.n	801a1a0 <msh_exec+0x18>
    {
        cmd++;
 801a194:	687b      	ldr	r3, [r7, #4]
 801a196:	3301      	adds	r3, #1
 801a198:	607b      	str	r3, [r7, #4]
        length--;
 801a19a:	683b      	ldr	r3, [r7, #0]
 801a19c:	3b01      	subs	r3, #1
 801a19e:	603b      	str	r3, [r7, #0]
int msh_exec(char* cmd, rt_size_t length)
{
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
 801a1a0:	687b      	ldr	r3, [r7, #4]
 801a1a2:	781b      	ldrb	r3, [r3, #0]
 801a1a4:	2b20      	cmp	r3, #32
 801a1a6:	d0f5      	beq.n	801a194 <msh_exec+0xc>
 801a1a8:	687b      	ldr	r3, [r7, #4]
 801a1aa:	781b      	ldrb	r3, [r3, #0]
 801a1ac:	2b09      	cmp	r3, #9
 801a1ae:	d0f1      	beq.n	801a194 <msh_exec+0xc>
    {
        cmd++;
        length--;
    }

    if (length == 0)
 801a1b0:	683b      	ldr	r3, [r7, #0]
 801a1b2:	2b00      	cmp	r3, #0
 801a1b4:	d101      	bne.n	801a1ba <msh_exec+0x32>
        return 0;
 801a1b6:	2300      	movs	r3, #0
 801a1b8:	e022      	b.n	801a200 <msh_exec+0x78>
    /* Exec sequence:
     * 1. built-in command
     * 2. module(if enabled)
     * 3. chdir to the directry(if possible)
     */
    if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
 801a1ba:	f107 0308 	add.w	r3, r7, #8
 801a1be:	6878      	ldr	r0, [r7, #4]
 801a1c0:	6839      	ldr	r1, [r7, #0]
 801a1c2:	461a      	mov	r2, r3
 801a1c4:	f7ff ff78 	bl	801a0b8 <_msh_exec_cmd>
 801a1c8:	4603      	mov	r3, r0
 801a1ca:	2b00      	cmp	r3, #0
 801a1cc:	d101      	bne.n	801a1d2 <msh_exec+0x4a>
    {
        return cmd_ret;
 801a1ce:	68bb      	ldr	r3, [r7, #8]
 801a1d0:	e016      	b.n	801a200 <msh_exec+0x78>
#endif

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
 801a1d2:	687b      	ldr	r3, [r7, #4]
 801a1d4:	60fb      	str	r3, [r7, #12]
        while(*tcmd != ' ' && *tcmd != '\0')
 801a1d6:	e002      	b.n	801a1de <msh_exec+0x56>
        {
            tcmd++;
 801a1d8:	68fb      	ldr	r3, [r7, #12]
 801a1da:	3301      	adds	r3, #1
 801a1dc:	60fb      	str	r3, [r7, #12]

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
        while(*tcmd != ' ' && *tcmd != '\0')
 801a1de:	68fb      	ldr	r3, [r7, #12]
 801a1e0:	781b      	ldrb	r3, [r3, #0]
 801a1e2:	2b20      	cmp	r3, #32
 801a1e4:	d003      	beq.n	801a1ee <msh_exec+0x66>
 801a1e6:	68fb      	ldr	r3, [r7, #12]
 801a1e8:	781b      	ldrb	r3, [r3, #0]
 801a1ea:	2b00      	cmp	r3, #0
 801a1ec:	d1f4      	bne.n	801a1d8 <msh_exec+0x50>
        {
            tcmd++;
        }
        *tcmd = '\0';
 801a1ee:	68fb      	ldr	r3, [r7, #12]
 801a1f0:	2200      	movs	r2, #0
 801a1f2:	701a      	strb	r2, [r3, #0]
    }
    rt_kprintf("%s: command not found.\n", cmd);
 801a1f4:	4804      	ldr	r0, [pc, #16]	; (801a208 <msh_exec+0x80>)
 801a1f6:	6879      	ldr	r1, [r7, #4]
 801a1f8:	f7f9 fd3a 	bl	8013c70 <rt_kprintf>
    return -1;
 801a1fc:	f04f 33ff 	mov.w	r3, #4294967295
}
 801a200:	4618      	mov	r0, r3
 801a202:	3710      	adds	r7, #16
 801a204:	46bd      	mov	sp, r7
 801a206:	bd80      	pop	{r7, pc}
 801a208:	08024288 	.word	0x08024288

0801a20c <str_common>:

static int str_common(const char *str1, const char *str2)
{
 801a20c:	b480      	push	{r7}
 801a20e:	b085      	sub	sp, #20
 801a210:	af00      	add	r7, sp, #0
 801a212:	6078      	str	r0, [r7, #4]
 801a214:	6039      	str	r1, [r7, #0]
    const char *str = str1;
 801a216:	687b      	ldr	r3, [r7, #4]
 801a218:	60fb      	str	r3, [r7, #12]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801a21a:	e005      	b.n	801a228 <str_common+0x1c>
    {
        str ++;
 801a21c:	68fb      	ldr	r3, [r7, #12]
 801a21e:	3301      	adds	r3, #1
 801a220:	60fb      	str	r3, [r7, #12]
        str2 ++;
 801a222:	683b      	ldr	r3, [r7, #0]
 801a224:	3301      	adds	r3, #1
 801a226:	603b      	str	r3, [r7, #0]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801a228:	68fb      	ldr	r3, [r7, #12]
 801a22a:	781b      	ldrb	r3, [r3, #0]
 801a22c:	2b00      	cmp	r3, #0
 801a22e:	d009      	beq.n	801a244 <str_common+0x38>
 801a230:	683b      	ldr	r3, [r7, #0]
 801a232:	781b      	ldrb	r3, [r3, #0]
 801a234:	2b00      	cmp	r3, #0
 801a236:	d005      	beq.n	801a244 <str_common+0x38>
 801a238:	68fb      	ldr	r3, [r7, #12]
 801a23a:	781a      	ldrb	r2, [r3, #0]
 801a23c:	683b      	ldr	r3, [r7, #0]
 801a23e:	781b      	ldrb	r3, [r3, #0]
 801a240:	429a      	cmp	r2, r3
 801a242:	d0eb      	beq.n	801a21c <str_common+0x10>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
 801a244:	68fa      	ldr	r2, [r7, #12]
 801a246:	687b      	ldr	r3, [r7, #4]
 801a248:	1ad3      	subs	r3, r2, r3
}
 801a24a:	4618      	mov	r0, r3
 801a24c:	3714      	adds	r7, #20
 801a24e:	46bd      	mov	sp, r7
 801a250:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a254:	4770      	bx	lr
 801a256:	bf00      	nop

0801a258 <msh_auto_complete>:
    rt_free(full_path);
}
#endif

void msh_auto_complete(char *prefix)
{
 801a258:	b580      	push	{r7, lr}
 801a25a:	b088      	sub	sp, #32
 801a25c:	af00      	add	r7, sp, #0
 801a25e:	6078      	str	r0, [r7, #4]
    int length, min_length;
    const char *name_ptr, *cmd_name;
    struct finsh_syscall *index;

    min_length = 0;
 801a260:	2300      	movs	r3, #0
 801a262:	61fb      	str	r3, [r7, #28]
    name_ptr = RT_NULL;
 801a264:	2300      	movs	r3, #0
 801a266:	61bb      	str	r3, [r7, #24]

    if (*prefix == '\0') 
 801a268:	687b      	ldr	r3, [r7, #4]
 801a26a:	781b      	ldrb	r3, [r3, #0]
 801a26c:	2b00      	cmp	r3, #0
 801a26e:	d104      	bne.n	801a27a <msh_auto_complete+0x22>
    {
        msh_help(0, RT_NULL);
 801a270:	2000      	movs	r0, #0
 801a272:	2100      	movs	r1, #0
 801a274:	f7ff fe0a 	bl	8019e8c <msh_help>
        return;
 801a278:	e049      	b.n	801a30e <msh_auto_complete+0xb6>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 801a27a:	4b26      	ldr	r3, [pc, #152]	; (801a314 <msh_auto_complete+0xbc>)
 801a27c:	681b      	ldr	r3, [r3, #0]
 801a27e:	617b      	str	r3, [r7, #20]
 801a280:	e036      	b.n	801a2f0 <msh_auto_complete+0x98>
        {
            /* skip finsh shell function */
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 801a282:	697b      	ldr	r3, [r7, #20]
 801a284:	681b      	ldr	r3, [r3, #0]
 801a286:	4618      	mov	r0, r3
 801a288:	4923      	ldr	r1, [pc, #140]	; (801a318 <msh_auto_complete+0xc0>)
 801a28a:	2206      	movs	r2, #6
 801a28c:	f005 fc12 	bl	801fab4 <strncmp>
 801a290:	4603      	mov	r3, r0
 801a292:	2b00      	cmp	r3, #0
 801a294:	d000      	beq.n	801a298 <msh_auto_complete+0x40>
 801a296:	e028      	b.n	801a2ea <msh_auto_complete+0x92>

            cmd_name = (const char*) &index->name[6];
 801a298:	697b      	ldr	r3, [r7, #20]
 801a29a:	681b      	ldr	r3, [r3, #0]
 801a29c:	3306      	adds	r3, #6
 801a29e:	613b      	str	r3, [r7, #16]
            if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
 801a2a0:	6878      	ldr	r0, [r7, #4]
 801a2a2:	f005 fbd9 	bl	801fa58 <strlen>
 801a2a6:	4603      	mov	r3, r0
 801a2a8:	6878      	ldr	r0, [r7, #4]
 801a2aa:	6939      	ldr	r1, [r7, #16]
 801a2ac:	461a      	mov	r2, r3
 801a2ae:	f005 fc01 	bl	801fab4 <strncmp>
 801a2b2:	4603      	mov	r3, r0
 801a2b4:	2b00      	cmp	r3, #0
 801a2b6:	d118      	bne.n	801a2ea <msh_auto_complete+0x92>
            {
                if (min_length == 0)
 801a2b8:	69fb      	ldr	r3, [r7, #28]
 801a2ba:	2b00      	cmp	r3, #0
 801a2bc:	d106      	bne.n	801a2cc <msh_auto_complete+0x74>
                {
                    /* set name_ptr */
                    name_ptr = cmd_name;
 801a2be:	693b      	ldr	r3, [r7, #16]
 801a2c0:	61bb      	str	r3, [r7, #24]
                    /* set initial length */
                    min_length = strlen(name_ptr);
 801a2c2:	69b8      	ldr	r0, [r7, #24]
 801a2c4:	f005 fbc8 	bl	801fa58 <strlen>
 801a2c8:	4603      	mov	r3, r0
 801a2ca:	61fb      	str	r3, [r7, #28]
                }

                length = str_common(name_ptr, cmd_name);
 801a2cc:	69b8      	ldr	r0, [r7, #24]
 801a2ce:	6939      	ldr	r1, [r7, #16]
 801a2d0:	f7ff ff9c 	bl	801a20c <str_common>
 801a2d4:	60f8      	str	r0, [r7, #12]
                if (length < min_length)
 801a2d6:	68fa      	ldr	r2, [r7, #12]
 801a2d8:	69fb      	ldr	r3, [r7, #28]
 801a2da:	429a      	cmp	r2, r3
 801a2dc:	da01      	bge.n	801a2e2 <msh_auto_complete+0x8a>
                    min_length = length;
 801a2de:	68fb      	ldr	r3, [r7, #12]
 801a2e0:	61fb      	str	r3, [r7, #28]

                rt_kprintf("%s\n", cmd_name);
 801a2e2:	480e      	ldr	r0, [pc, #56]	; (801a31c <msh_auto_complete+0xc4>)
 801a2e4:	6939      	ldr	r1, [r7, #16]
 801a2e6:	f7f9 fcc3 	bl	8013c70 <rt_kprintf>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 801a2ea:	697b      	ldr	r3, [r7, #20]
 801a2ec:	330c      	adds	r3, #12
 801a2ee:	617b      	str	r3, [r7, #20]
 801a2f0:	4b0b      	ldr	r3, [pc, #44]	; (801a320 <msh_auto_complete+0xc8>)
 801a2f2:	681b      	ldr	r3, [r3, #0]
 801a2f4:	697a      	ldr	r2, [r7, #20]
 801a2f6:	429a      	cmp	r2, r3
 801a2f8:	d3c3      	bcc.n	801a282 <msh_auto_complete+0x2a>
            }
        }
    }

    /* auto complete string */
    if (name_ptr != NULL)
 801a2fa:	69bb      	ldr	r3, [r7, #24]
 801a2fc:	2b00      	cmp	r3, #0
 801a2fe:	d005      	beq.n	801a30c <msh_auto_complete+0xb4>
    {
        rt_strncpy(prefix, name_ptr, min_length);
 801a300:	69fb      	ldr	r3, [r7, #28]
 801a302:	6878      	ldr	r0, [r7, #4]
 801a304:	69b9      	ldr	r1, [r7, #24]
 801a306:	461a      	mov	r2, r3
 801a308:	f7f9 f802 	bl	8013310 <rt_strncpy>
    }

    return ;
 801a30c:	bf00      	nop
}
 801a30e:	3720      	adds	r7, #32
 801a310:	46bd      	mov	sp, r7
 801a312:	bd80      	pop	{r7, pc}
 801a314:	200121cc 	.word	0x200121cc
 801a318:	08024264 	.word	0x08024264
 801a31c:	080242a0 	.word	0x080242a0
 801a320:	200121d0 	.word	0x200121d0

0801a324 <finsh_compile>:
#define finsh_code_byte(x)  do { *finsh_compile_pc = (x); finsh_compile_pc ++; } while(0)
#define finsh_code_word(x)  do { FINSH_SET16(finsh_compile_pc, x); finsh_compile_pc +=2; } while(0)
#define finsh_code_dword(x) do { FINSH_SET32(finsh_compile_pc, x); finsh_compile_pc +=4; } while(0)

static int finsh_compile(struct finsh_node* node)
{
 801a324:	b580      	push	{r7, lr}
 801a326:	b08a      	sub	sp, #40	; 0x28
 801a328:	af00      	add	r7, sp, #0
 801a32a:	6078      	str	r0, [r7, #4]
    if (node != NULL)
 801a32c:	687b      	ldr	r3, [r7, #4]
 801a32e:	2b00      	cmp	r3, #0
 801a330:	f001 83e0 	beq.w	801baf4 <finsh_compile+0x17d0>
    {
        /* compile child node */
        if (finsh_node_child(node) != NULL)
 801a334:	687b      	ldr	r3, [r7, #4]
 801a336:	691b      	ldr	r3, [r3, #16]
 801a338:	2b00      	cmp	r3, #0
 801a33a:	d004      	beq.n	801a346 <finsh_compile+0x22>
            finsh_compile(finsh_node_child(node));
 801a33c:	687b      	ldr	r3, [r7, #4]
 801a33e:	691b      	ldr	r3, [r3, #16]
 801a340:	4618      	mov	r0, r3
 801a342:	f7ff ffef 	bl	801a324 <finsh_compile>

        /* compile current node */
        switch (node->node_type)
 801a346:	687b      	ldr	r3, [r7, #4]
 801a348:	781b      	ldrb	r3, [r3, #0]
 801a34a:	3b01      	subs	r3, #1
 801a34c:	2b1a      	cmp	r3, #26
 801a34e:	f201 83c1 	bhi.w	801bad4 <finsh_compile+0x17b0>
 801a352:	a201      	add	r2, pc, #4	; (adr r2, 801a358 <finsh_compile+0x34>)
 801a354:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a358:	0801a3c5 	.word	0x0801a3c5
 801a35c:	0801a7c7 	.word	0x0801a7c7
 801a360:	0801a7f1 	.word	0x0801a7f1
 801a364:	0801a7f1 	.word	0x0801a7f1
 801a368:	0801a84d 	.word	0x0801a84d
 801a36c:	0801a84d 	.word	0x0801a84d
 801a370:	0801a8a9 	.word	0x0801a8a9
 801a374:	0801a907 	.word	0x0801a907
 801a378:	0801a961 	.word	0x0801a961
 801a37c:	0801a9bb 	.word	0x0801a9bb
 801a380:	0801aa15 	.word	0x0801aa15
 801a384:	0801aa6f 	.word	0x0801aa6f
 801a388:	0801aac9 	.word	0x0801aac9
 801a38c:	0801ab29 	.word	0x0801ab29
 801a390:	0801ab83 	.word	0x0801ab83
 801a394:	0801abdd 	.word	0x0801abdd
 801a398:	0801ac37 	.word	0x0801ac37
 801a39c:	0801ac91 	.word	0x0801ac91
 801a3a0:	0801ace7 	.word	0x0801ace7
 801a3a4:	0801bad5 	.word	0x0801bad5
 801a3a8:	0801ae2d 	.word	0x0801ae2d
 801a3ac:	0801b0af 	.word	0x0801b0af
 801a3b0:	0801b32f 	.word	0x0801b32f
 801a3b4:	0801b6bd 	.word	0x0801b6bd
 801a3b8:	0801ba79 	.word	0x0801ba79
 801a3bc:	0801badd 	.word	0x0801badd
 801a3c0:	0801ba43 	.word	0x0801ba43
        {
        case FINSH_NODE_ID:
            {
                /* identifier::syscall */
                if (node->idtype & FINSH_IDTYPE_SYSCALL)
 801a3c4:	687b      	ldr	r3, [r7, #4]
 801a3c6:	789b      	ldrb	r3, [r3, #2]
 801a3c8:	f003 0304 	and.w	r3, r3, #4
 801a3cc:	2b00      	cmp	r3, #0
 801a3ce:	d030      	beq.n	801a432 <finsh_compile+0x10e>
                {
                    /* load address */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801a3d0:	4b9f      	ldr	r3, [pc, #636]	; (801a650 <finsh_compile+0x32c>)
 801a3d2:	681b      	ldr	r3, [r3, #0]
 801a3d4:	2224      	movs	r2, #36	; 0x24
 801a3d6:	701a      	strb	r2, [r3, #0]
 801a3d8:	4b9d      	ldr	r3, [pc, #628]	; (801a650 <finsh_compile+0x32c>)
 801a3da:	681b      	ldr	r3, [r3, #0]
 801a3dc:	3301      	adds	r3, #1
 801a3de:	4a9c      	ldr	r2, [pc, #624]	; (801a650 <finsh_compile+0x32c>)
 801a3e0:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)node->id.syscall->func);
 801a3e2:	4b9b      	ldr	r3, [pc, #620]	; (801a650 <finsh_compile+0x32c>)
 801a3e4:	681b      	ldr	r3, [r3, #0]
 801a3e6:	687a      	ldr	r2, [r7, #4]
 801a3e8:	6892      	ldr	r2, [r2, #8]
 801a3ea:	6892      	ldr	r2, [r2, #8]
 801a3ec:	b2d2      	uxtb	r2, r2
 801a3ee:	701a      	strb	r2, [r3, #0]
 801a3f0:	4b97      	ldr	r3, [pc, #604]	; (801a650 <finsh_compile+0x32c>)
 801a3f2:	681b      	ldr	r3, [r3, #0]
 801a3f4:	3301      	adds	r3, #1
 801a3f6:	687a      	ldr	r2, [r7, #4]
 801a3f8:	6892      	ldr	r2, [r2, #8]
 801a3fa:	6892      	ldr	r2, [r2, #8]
 801a3fc:	0a12      	lsrs	r2, r2, #8
 801a3fe:	b2d2      	uxtb	r2, r2
 801a400:	701a      	strb	r2, [r3, #0]
 801a402:	4b93      	ldr	r3, [pc, #588]	; (801a650 <finsh_compile+0x32c>)
 801a404:	681b      	ldr	r3, [r3, #0]
 801a406:	3302      	adds	r3, #2
 801a408:	687a      	ldr	r2, [r7, #4]
 801a40a:	6892      	ldr	r2, [r2, #8]
 801a40c:	6892      	ldr	r2, [r2, #8]
 801a40e:	0c12      	lsrs	r2, r2, #16
 801a410:	b2d2      	uxtb	r2, r2
 801a412:	701a      	strb	r2, [r3, #0]
 801a414:	4b8e      	ldr	r3, [pc, #568]	; (801a650 <finsh_compile+0x32c>)
 801a416:	681b      	ldr	r3, [r3, #0]
 801a418:	3303      	adds	r3, #3
 801a41a:	687a      	ldr	r2, [r7, #4]
 801a41c:	6892      	ldr	r2, [r2, #8]
 801a41e:	6892      	ldr	r2, [r2, #8]
 801a420:	0e12      	lsrs	r2, r2, #24
 801a422:	b2d2      	uxtb	r2, r2
 801a424:	701a      	strb	r2, [r3, #0]
 801a426:	4b8a      	ldr	r3, [pc, #552]	; (801a650 <finsh_compile+0x32c>)
 801a428:	681b      	ldr	r3, [r3, #0]
 801a42a:	3304      	adds	r3, #4
 801a42c:	4a88      	ldr	r2, [pc, #544]	; (801a650 <finsh_compile+0x32c>)
 801a42e:	6013      	str	r3, [r2, #0]
 801a430:	e1c7      	b.n	801a7c2 <finsh_compile+0x49e>
                }
                /* identifier::sysvar */
                else if (node->idtype & FINSH_IDTYPE_SYSVAR)
 801a432:	687b      	ldr	r3, [r7, #4]
 801a434:	789b      	ldrb	r3, [r3, #2]
 801a436:	f003 0302 	and.w	r3, r3, #2
 801a43a:	2b00      	cmp	r3, #0
 801a43c:	f000 80e0 	beq.w	801a600 <finsh_compile+0x2dc>
                {
                    struct finsh_sysvar* sysvar;

                    sysvar = node->id.sysvar;
 801a440:	687b      	ldr	r3, [r7, #4]
 801a442:	689b      	ldr	r3, [r3, #8]
 801a444:	61fb      	str	r3, [r7, #28]
                    if (sysvar != NULL)
 801a446:	69fb      	ldr	r3, [r7, #28]
 801a448:	2b00      	cmp	r3, #0
 801a44a:	f000 80d8 	beq.w	801a5fe <finsh_compile+0x2da>
                    {
                        switch (sysvar->type)
 801a44e:	69fb      	ldr	r3, [r7, #28]
 801a450:	7a1b      	ldrb	r3, [r3, #8]
 801a452:	3b03      	subs	r3, #3
 801a454:	2b0b      	cmp	r3, #11
 801a456:	f200 81b4 	bhi.w	801a7c2 <finsh_compile+0x49e>
 801a45a:	a201      	add	r2, pc, #4	; (adr r2, 801a460 <finsh_compile+0x13c>)
 801a45c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a460:	0801a491 	.word	0x0801a491
 801a464:	0801a491 	.word	0x0801a491
 801a468:	0801a585 	.word	0x0801a585
 801a46c:	0801a50b 	.word	0x0801a50b
 801a470:	0801a50b 	.word	0x0801a50b
 801a474:	0801a585 	.word	0x0801a585
 801a478:	0801a585 	.word	0x0801a585
 801a47c:	0801a585 	.word	0x0801a585
 801a480:	0801a585 	.word	0x0801a585
 801a484:	0801a585 	.word	0x0801a585
 801a488:	0801a585 	.word	0x0801a585
 801a48c:	0801a585 	.word	0x0801a585
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801a490:	687b      	ldr	r3, [r7, #4]
 801a492:	789b      	ldrb	r3, [r3, #2]
 801a494:	f003 0308 	and.w	r3, r3, #8
 801a498:	2b00      	cmp	r3, #0
 801a49a:	d009      	beq.n	801a4b0 <finsh_compile+0x18c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801a49c:	4b6c      	ldr	r3, [pc, #432]	; (801a650 <finsh_compile+0x32c>)
 801a49e:	681b      	ldr	r3, [r3, #0]
 801a4a0:	2224      	movs	r2, #36	; 0x24
 801a4a2:	701a      	strb	r2, [r3, #0]
 801a4a4:	4b6a      	ldr	r3, [pc, #424]	; (801a650 <finsh_compile+0x32c>)
 801a4a6:	681b      	ldr	r3, [r3, #0]
 801a4a8:	3301      	adds	r3, #1
 801a4aa:	4a69      	ldr	r2, [pc, #420]	; (801a650 <finsh_compile+0x32c>)
 801a4ac:	6013      	str	r3, [r2, #0]
 801a4ae:	e008      	b.n	801a4c2 <finsh_compile+0x19e>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801a4b0:	4b67      	ldr	r3, [pc, #412]	; (801a650 <finsh_compile+0x32c>)
 801a4b2:	681b      	ldr	r3, [r3, #0]
 801a4b4:	2225      	movs	r2, #37	; 0x25
 801a4b6:	701a      	strb	r2, [r3, #0]
 801a4b8:	4b65      	ldr	r3, [pc, #404]	; (801a650 <finsh_compile+0x32c>)
 801a4ba:	681b      	ldr	r3, [r3, #0]
 801a4bc:	3301      	adds	r3, #1
 801a4be:	4a64      	ldr	r2, [pc, #400]	; (801a650 <finsh_compile+0x32c>)
 801a4c0:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801a4c2:	4b63      	ldr	r3, [pc, #396]	; (801a650 <finsh_compile+0x32c>)
 801a4c4:	681b      	ldr	r3, [r3, #0]
 801a4c6:	69fa      	ldr	r2, [r7, #28]
 801a4c8:	68d2      	ldr	r2, [r2, #12]
 801a4ca:	b2d2      	uxtb	r2, r2
 801a4cc:	701a      	strb	r2, [r3, #0]
 801a4ce:	4b60      	ldr	r3, [pc, #384]	; (801a650 <finsh_compile+0x32c>)
 801a4d0:	681b      	ldr	r3, [r3, #0]
 801a4d2:	3301      	adds	r3, #1
 801a4d4:	69fa      	ldr	r2, [r7, #28]
 801a4d6:	68d2      	ldr	r2, [r2, #12]
 801a4d8:	0a12      	lsrs	r2, r2, #8
 801a4da:	b2d2      	uxtb	r2, r2
 801a4dc:	701a      	strb	r2, [r3, #0]
 801a4de:	4b5c      	ldr	r3, [pc, #368]	; (801a650 <finsh_compile+0x32c>)
 801a4e0:	681b      	ldr	r3, [r3, #0]
 801a4e2:	3302      	adds	r3, #2
 801a4e4:	69fa      	ldr	r2, [r7, #28]
 801a4e6:	68d2      	ldr	r2, [r2, #12]
 801a4e8:	0c12      	lsrs	r2, r2, #16
 801a4ea:	b2d2      	uxtb	r2, r2
 801a4ec:	701a      	strb	r2, [r3, #0]
 801a4ee:	4b58      	ldr	r3, [pc, #352]	; (801a650 <finsh_compile+0x32c>)
 801a4f0:	681b      	ldr	r3, [r3, #0]
 801a4f2:	3303      	adds	r3, #3
 801a4f4:	69fa      	ldr	r2, [r7, #28]
 801a4f6:	68d2      	ldr	r2, [r2, #12]
 801a4f8:	0e12      	lsrs	r2, r2, #24
 801a4fa:	b2d2      	uxtb	r2, r2
 801a4fc:	701a      	strb	r2, [r3, #0]
 801a4fe:	4b54      	ldr	r3, [pc, #336]	; (801a650 <finsh_compile+0x32c>)
 801a500:	681b      	ldr	r3, [r3, #0]
 801a502:	3304      	adds	r3, #4
 801a504:	4a52      	ldr	r2, [pc, #328]	; (801a650 <finsh_compile+0x32c>)
 801a506:	6013      	str	r3, [r2, #0]
                            break;
 801a508:	e079      	b.n	801a5fe <finsh_compile+0x2da>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801a50a:	687b      	ldr	r3, [r7, #4]
 801a50c:	789b      	ldrb	r3, [r3, #2]
 801a50e:	f003 0308 	and.w	r3, r3, #8
 801a512:	2b00      	cmp	r3, #0
 801a514:	d009      	beq.n	801a52a <finsh_compile+0x206>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801a516:	4b4e      	ldr	r3, [pc, #312]	; (801a650 <finsh_compile+0x32c>)
 801a518:	681b      	ldr	r3, [r3, #0]
 801a51a:	2224      	movs	r2, #36	; 0x24
 801a51c:	701a      	strb	r2, [r3, #0]
 801a51e:	4b4c      	ldr	r3, [pc, #304]	; (801a650 <finsh_compile+0x32c>)
 801a520:	681b      	ldr	r3, [r3, #0]
 801a522:	3301      	adds	r3, #1
 801a524:	4a4a      	ldr	r2, [pc, #296]	; (801a650 <finsh_compile+0x32c>)
 801a526:	6013      	str	r3, [r2, #0]
 801a528:	e008      	b.n	801a53c <finsh_compile+0x218>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801a52a:	4b49      	ldr	r3, [pc, #292]	; (801a650 <finsh_compile+0x32c>)
 801a52c:	681b      	ldr	r3, [r3, #0]
 801a52e:	2226      	movs	r2, #38	; 0x26
 801a530:	701a      	strb	r2, [r3, #0]
 801a532:	4b47      	ldr	r3, [pc, #284]	; (801a650 <finsh_compile+0x32c>)
 801a534:	681b      	ldr	r3, [r3, #0]
 801a536:	3301      	adds	r3, #1
 801a538:	4a45      	ldr	r2, [pc, #276]	; (801a650 <finsh_compile+0x32c>)
 801a53a:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801a53c:	4b44      	ldr	r3, [pc, #272]	; (801a650 <finsh_compile+0x32c>)
 801a53e:	681b      	ldr	r3, [r3, #0]
 801a540:	69fa      	ldr	r2, [r7, #28]
 801a542:	68d2      	ldr	r2, [r2, #12]
 801a544:	b2d2      	uxtb	r2, r2
 801a546:	701a      	strb	r2, [r3, #0]
 801a548:	4b41      	ldr	r3, [pc, #260]	; (801a650 <finsh_compile+0x32c>)
 801a54a:	681b      	ldr	r3, [r3, #0]
 801a54c:	3301      	adds	r3, #1
 801a54e:	69fa      	ldr	r2, [r7, #28]
 801a550:	68d2      	ldr	r2, [r2, #12]
 801a552:	0a12      	lsrs	r2, r2, #8
 801a554:	b2d2      	uxtb	r2, r2
 801a556:	701a      	strb	r2, [r3, #0]
 801a558:	4b3d      	ldr	r3, [pc, #244]	; (801a650 <finsh_compile+0x32c>)
 801a55a:	681b      	ldr	r3, [r3, #0]
 801a55c:	3302      	adds	r3, #2
 801a55e:	69fa      	ldr	r2, [r7, #28]
 801a560:	68d2      	ldr	r2, [r2, #12]
 801a562:	0c12      	lsrs	r2, r2, #16
 801a564:	b2d2      	uxtb	r2, r2
 801a566:	701a      	strb	r2, [r3, #0]
 801a568:	4b39      	ldr	r3, [pc, #228]	; (801a650 <finsh_compile+0x32c>)
 801a56a:	681b      	ldr	r3, [r3, #0]
 801a56c:	3303      	adds	r3, #3
 801a56e:	69fa      	ldr	r2, [r7, #28]
 801a570:	68d2      	ldr	r2, [r2, #12]
 801a572:	0e12      	lsrs	r2, r2, #24
 801a574:	b2d2      	uxtb	r2, r2
 801a576:	701a      	strb	r2, [r3, #0]
 801a578:	4b35      	ldr	r3, [pc, #212]	; (801a650 <finsh_compile+0x32c>)
 801a57a:	681b      	ldr	r3, [r3, #0]
 801a57c:	3304      	adds	r3, #4
 801a57e:	4a34      	ldr	r2, [pc, #208]	; (801a650 <finsh_compile+0x32c>)
 801a580:	6013      	str	r3, [r2, #0]
                            break;
 801a582:	e03c      	b.n	801a5fe <finsh_compile+0x2da>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801a584:	687b      	ldr	r3, [r7, #4]
 801a586:	789b      	ldrb	r3, [r3, #2]
 801a588:	f003 0308 	and.w	r3, r3, #8
 801a58c:	2b00      	cmp	r3, #0
 801a58e:	d009      	beq.n	801a5a4 <finsh_compile+0x280>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801a590:	4b2f      	ldr	r3, [pc, #188]	; (801a650 <finsh_compile+0x32c>)
 801a592:	681b      	ldr	r3, [r3, #0]
 801a594:	2224      	movs	r2, #36	; 0x24
 801a596:	701a      	strb	r2, [r3, #0]
 801a598:	4b2d      	ldr	r3, [pc, #180]	; (801a650 <finsh_compile+0x32c>)
 801a59a:	681b      	ldr	r3, [r3, #0]
 801a59c:	3301      	adds	r3, #1
 801a59e:	4a2c      	ldr	r2, [pc, #176]	; (801a650 <finsh_compile+0x32c>)
 801a5a0:	6013      	str	r3, [r2, #0]
 801a5a2:	e008      	b.n	801a5b6 <finsh_compile+0x292>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801a5a4:	4b2a      	ldr	r3, [pc, #168]	; (801a650 <finsh_compile+0x32c>)
 801a5a6:	681b      	ldr	r3, [r3, #0]
 801a5a8:	2227      	movs	r2, #39	; 0x27
 801a5aa:	701a      	strb	r2, [r3, #0]
 801a5ac:	4b28      	ldr	r3, [pc, #160]	; (801a650 <finsh_compile+0x32c>)
 801a5ae:	681b      	ldr	r3, [r3, #0]
 801a5b0:	3301      	adds	r3, #1
 801a5b2:	4a27      	ldr	r2, [pc, #156]	; (801a650 <finsh_compile+0x32c>)
 801a5b4:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801a5b6:	4b26      	ldr	r3, [pc, #152]	; (801a650 <finsh_compile+0x32c>)
 801a5b8:	681b      	ldr	r3, [r3, #0]
 801a5ba:	69fa      	ldr	r2, [r7, #28]
 801a5bc:	68d2      	ldr	r2, [r2, #12]
 801a5be:	b2d2      	uxtb	r2, r2
 801a5c0:	701a      	strb	r2, [r3, #0]
 801a5c2:	4b23      	ldr	r3, [pc, #140]	; (801a650 <finsh_compile+0x32c>)
 801a5c4:	681b      	ldr	r3, [r3, #0]
 801a5c6:	3301      	adds	r3, #1
 801a5c8:	69fa      	ldr	r2, [r7, #28]
 801a5ca:	68d2      	ldr	r2, [r2, #12]
 801a5cc:	0a12      	lsrs	r2, r2, #8
 801a5ce:	b2d2      	uxtb	r2, r2
 801a5d0:	701a      	strb	r2, [r3, #0]
 801a5d2:	4b1f      	ldr	r3, [pc, #124]	; (801a650 <finsh_compile+0x32c>)
 801a5d4:	681b      	ldr	r3, [r3, #0]
 801a5d6:	3302      	adds	r3, #2
 801a5d8:	69fa      	ldr	r2, [r7, #28]
 801a5da:	68d2      	ldr	r2, [r2, #12]
 801a5dc:	0c12      	lsrs	r2, r2, #16
 801a5de:	b2d2      	uxtb	r2, r2
 801a5e0:	701a      	strb	r2, [r3, #0]
 801a5e2:	4b1b      	ldr	r3, [pc, #108]	; (801a650 <finsh_compile+0x32c>)
 801a5e4:	681b      	ldr	r3, [r3, #0]
 801a5e6:	3303      	adds	r3, #3
 801a5e8:	69fa      	ldr	r2, [r7, #28]
 801a5ea:	68d2      	ldr	r2, [r2, #12]
 801a5ec:	0e12      	lsrs	r2, r2, #24
 801a5ee:	b2d2      	uxtb	r2, r2
 801a5f0:	701a      	strb	r2, [r3, #0]
 801a5f2:	4b17      	ldr	r3, [pc, #92]	; (801a650 <finsh_compile+0x32c>)
 801a5f4:	681b      	ldr	r3, [r3, #0]
 801a5f6:	3304      	adds	r3, #4
 801a5f8:	4a15      	ldr	r2, [pc, #84]	; (801a650 <finsh_compile+0x32c>)
 801a5fa:	6013      	str	r3, [r2, #0]
                            break;
 801a5fc:	bf00      	nop
 801a5fe:	e0e0      	b.n	801a7c2 <finsh_compile+0x49e>
                /* identifier::var */
                else
                {
                    struct finsh_var* var;

                    var = node->id.var;
 801a600:	687b      	ldr	r3, [r7, #4]
 801a602:	689b      	ldr	r3, [r3, #8]
 801a604:	61bb      	str	r3, [r7, #24]
                    if (var != NULL)
 801a606:	69bb      	ldr	r3, [r7, #24]
 801a608:	2b00      	cmp	r3, #0
 801a60a:	f000 80da 	beq.w	801a7c2 <finsh_compile+0x49e>
                    {
                        switch (var->type)
 801a60e:	69bb      	ldr	r3, [r7, #24]
 801a610:	7c5b      	ldrb	r3, [r3, #17]
 801a612:	3b03      	subs	r3, #3
 801a614:	2b0b      	cmp	r3, #11
 801a616:	f201 8263 	bhi.w	801bae0 <finsh_compile+0x17bc>
 801a61a:	a201      	add	r2, pc, #4	; (adr r2, 801a620 <finsh_compile+0x2fc>)
 801a61c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a620:	0801a655 	.word	0x0801a655
 801a624:	0801a655 	.word	0x0801a655
 801a628:	0801a749 	.word	0x0801a749
 801a62c:	0801a6cf 	.word	0x0801a6cf
 801a630:	0801a6cf 	.word	0x0801a6cf
 801a634:	0801a749 	.word	0x0801a749
 801a638:	0801a749 	.word	0x0801a749
 801a63c:	0801a749 	.word	0x0801a749
 801a640:	0801a749 	.word	0x0801a749
 801a644:	0801a749 	.word	0x0801a749
 801a648:	0801a749 	.word	0x0801a749
 801a64c:	0801a749 	.word	0x0801a749
 801a650:	200126e4 	.word	0x200126e4
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801a654:	687b      	ldr	r3, [r7, #4]
 801a656:	789b      	ldrb	r3, [r3, #2]
 801a658:	f003 0308 	and.w	r3, r3, #8
 801a65c:	2b00      	cmp	r3, #0
 801a65e:	d009      	beq.n	801a674 <finsh_compile+0x350>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801a660:	4b98      	ldr	r3, [pc, #608]	; (801a8c4 <finsh_compile+0x5a0>)
 801a662:	681b      	ldr	r3, [r3, #0]
 801a664:	2224      	movs	r2, #36	; 0x24
 801a666:	701a      	strb	r2, [r3, #0]
 801a668:	4b96      	ldr	r3, [pc, #600]	; (801a8c4 <finsh_compile+0x5a0>)
 801a66a:	681b      	ldr	r3, [r3, #0]
 801a66c:	3301      	adds	r3, #1
 801a66e:	4a95      	ldr	r2, [pc, #596]	; (801a8c4 <finsh_compile+0x5a0>)
 801a670:	6013      	str	r3, [r2, #0]
 801a672:	e008      	b.n	801a686 <finsh_compile+0x362>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801a674:	4b93      	ldr	r3, [pc, #588]	; (801a8c4 <finsh_compile+0x5a0>)
 801a676:	681b      	ldr	r3, [r3, #0]
 801a678:	2225      	movs	r2, #37	; 0x25
 801a67a:	701a      	strb	r2, [r3, #0]
 801a67c:	4b91      	ldr	r3, [pc, #580]	; (801a8c4 <finsh_compile+0x5a0>)
 801a67e:	681b      	ldr	r3, [r3, #0]
 801a680:	3301      	adds	r3, #1
 801a682:	4a90      	ldr	r2, [pc, #576]	; (801a8c4 <finsh_compile+0x5a0>)
 801a684:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.char_value));
 801a686:	4b8f      	ldr	r3, [pc, #572]	; (801a8c4 <finsh_compile+0x5a0>)
 801a688:	681b      	ldr	r3, [r3, #0]
 801a68a:	69ba      	ldr	r2, [r7, #24]
 801a68c:	3214      	adds	r2, #20
 801a68e:	b2d2      	uxtb	r2, r2
 801a690:	701a      	strb	r2, [r3, #0]
 801a692:	4b8c      	ldr	r3, [pc, #560]	; (801a8c4 <finsh_compile+0x5a0>)
 801a694:	681b      	ldr	r3, [r3, #0]
 801a696:	3301      	adds	r3, #1
 801a698:	69ba      	ldr	r2, [r7, #24]
 801a69a:	3214      	adds	r2, #20
 801a69c:	0a12      	lsrs	r2, r2, #8
 801a69e:	b2d2      	uxtb	r2, r2
 801a6a0:	701a      	strb	r2, [r3, #0]
 801a6a2:	4b88      	ldr	r3, [pc, #544]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6a4:	681b      	ldr	r3, [r3, #0]
 801a6a6:	3302      	adds	r3, #2
 801a6a8:	69ba      	ldr	r2, [r7, #24]
 801a6aa:	3214      	adds	r2, #20
 801a6ac:	0c12      	lsrs	r2, r2, #16
 801a6ae:	b2d2      	uxtb	r2, r2
 801a6b0:	701a      	strb	r2, [r3, #0]
 801a6b2:	4b84      	ldr	r3, [pc, #528]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6b4:	681b      	ldr	r3, [r3, #0]
 801a6b6:	3303      	adds	r3, #3
 801a6b8:	69ba      	ldr	r2, [r7, #24]
 801a6ba:	3214      	adds	r2, #20
 801a6bc:	0e12      	lsrs	r2, r2, #24
 801a6be:	b2d2      	uxtb	r2, r2
 801a6c0:	701a      	strb	r2, [r3, #0]
 801a6c2:	4b80      	ldr	r3, [pc, #512]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6c4:	681b      	ldr	r3, [r3, #0]
 801a6c6:	3304      	adds	r3, #4
 801a6c8:	4a7e      	ldr	r2, [pc, #504]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6ca:	6013      	str	r3, [r2, #0]
                            break;
 801a6cc:	e079      	b.n	801a7c2 <finsh_compile+0x49e>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801a6ce:	687b      	ldr	r3, [r7, #4]
 801a6d0:	789b      	ldrb	r3, [r3, #2]
 801a6d2:	f003 0308 	and.w	r3, r3, #8
 801a6d6:	2b00      	cmp	r3, #0
 801a6d8:	d009      	beq.n	801a6ee <finsh_compile+0x3ca>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801a6da:	4b7a      	ldr	r3, [pc, #488]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6dc:	681b      	ldr	r3, [r3, #0]
 801a6de:	2224      	movs	r2, #36	; 0x24
 801a6e0:	701a      	strb	r2, [r3, #0]
 801a6e2:	4b78      	ldr	r3, [pc, #480]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6e4:	681b      	ldr	r3, [r3, #0]
 801a6e6:	3301      	adds	r3, #1
 801a6e8:	4a76      	ldr	r2, [pc, #472]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6ea:	6013      	str	r3, [r2, #0]
 801a6ec:	e008      	b.n	801a700 <finsh_compile+0x3dc>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801a6ee:	4b75      	ldr	r3, [pc, #468]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6f0:	681b      	ldr	r3, [r3, #0]
 801a6f2:	2226      	movs	r2, #38	; 0x26
 801a6f4:	701a      	strb	r2, [r3, #0]
 801a6f6:	4b73      	ldr	r3, [pc, #460]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6f8:	681b      	ldr	r3, [r3, #0]
 801a6fa:	3301      	adds	r3, #1
 801a6fc:	4a71      	ldr	r2, [pc, #452]	; (801a8c4 <finsh_compile+0x5a0>)
 801a6fe:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.short_value));
 801a700:	4b70      	ldr	r3, [pc, #448]	; (801a8c4 <finsh_compile+0x5a0>)
 801a702:	681b      	ldr	r3, [r3, #0]
 801a704:	69ba      	ldr	r2, [r7, #24]
 801a706:	3214      	adds	r2, #20
 801a708:	b2d2      	uxtb	r2, r2
 801a70a:	701a      	strb	r2, [r3, #0]
 801a70c:	4b6d      	ldr	r3, [pc, #436]	; (801a8c4 <finsh_compile+0x5a0>)
 801a70e:	681b      	ldr	r3, [r3, #0]
 801a710:	3301      	adds	r3, #1
 801a712:	69ba      	ldr	r2, [r7, #24]
 801a714:	3214      	adds	r2, #20
 801a716:	0a12      	lsrs	r2, r2, #8
 801a718:	b2d2      	uxtb	r2, r2
 801a71a:	701a      	strb	r2, [r3, #0]
 801a71c:	4b69      	ldr	r3, [pc, #420]	; (801a8c4 <finsh_compile+0x5a0>)
 801a71e:	681b      	ldr	r3, [r3, #0]
 801a720:	3302      	adds	r3, #2
 801a722:	69ba      	ldr	r2, [r7, #24]
 801a724:	3214      	adds	r2, #20
 801a726:	0c12      	lsrs	r2, r2, #16
 801a728:	b2d2      	uxtb	r2, r2
 801a72a:	701a      	strb	r2, [r3, #0]
 801a72c:	4b65      	ldr	r3, [pc, #404]	; (801a8c4 <finsh_compile+0x5a0>)
 801a72e:	681b      	ldr	r3, [r3, #0]
 801a730:	3303      	adds	r3, #3
 801a732:	69ba      	ldr	r2, [r7, #24]
 801a734:	3214      	adds	r2, #20
 801a736:	0e12      	lsrs	r2, r2, #24
 801a738:	b2d2      	uxtb	r2, r2
 801a73a:	701a      	strb	r2, [r3, #0]
 801a73c:	4b61      	ldr	r3, [pc, #388]	; (801a8c4 <finsh_compile+0x5a0>)
 801a73e:	681b      	ldr	r3, [r3, #0]
 801a740:	3304      	adds	r3, #4
 801a742:	4a60      	ldr	r2, [pc, #384]	; (801a8c4 <finsh_compile+0x5a0>)
 801a744:	6013      	str	r3, [r2, #0]
                            break;
 801a746:	e03c      	b.n	801a7c2 <finsh_compile+0x49e>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801a748:	687b      	ldr	r3, [r7, #4]
 801a74a:	789b      	ldrb	r3, [r3, #2]
 801a74c:	f003 0308 	and.w	r3, r3, #8
 801a750:	2b00      	cmp	r3, #0
 801a752:	d009      	beq.n	801a768 <finsh_compile+0x444>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801a754:	4b5b      	ldr	r3, [pc, #364]	; (801a8c4 <finsh_compile+0x5a0>)
 801a756:	681b      	ldr	r3, [r3, #0]
 801a758:	2224      	movs	r2, #36	; 0x24
 801a75a:	701a      	strb	r2, [r3, #0]
 801a75c:	4b59      	ldr	r3, [pc, #356]	; (801a8c4 <finsh_compile+0x5a0>)
 801a75e:	681b      	ldr	r3, [r3, #0]
 801a760:	3301      	adds	r3, #1
 801a762:	4a58      	ldr	r2, [pc, #352]	; (801a8c4 <finsh_compile+0x5a0>)
 801a764:	6013      	str	r3, [r2, #0]
 801a766:	e008      	b.n	801a77a <finsh_compile+0x456>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801a768:	4b56      	ldr	r3, [pc, #344]	; (801a8c4 <finsh_compile+0x5a0>)
 801a76a:	681b      	ldr	r3, [r3, #0]
 801a76c:	2227      	movs	r2, #39	; 0x27
 801a76e:	701a      	strb	r2, [r3, #0]
 801a770:	4b54      	ldr	r3, [pc, #336]	; (801a8c4 <finsh_compile+0x5a0>)
 801a772:	681b      	ldr	r3, [r3, #0]
 801a774:	3301      	adds	r3, #1
 801a776:	4a53      	ldr	r2, [pc, #332]	; (801a8c4 <finsh_compile+0x5a0>)
 801a778:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.long_value));
 801a77a:	4b52      	ldr	r3, [pc, #328]	; (801a8c4 <finsh_compile+0x5a0>)
 801a77c:	681b      	ldr	r3, [r3, #0]
 801a77e:	69ba      	ldr	r2, [r7, #24]
 801a780:	3214      	adds	r2, #20
 801a782:	b2d2      	uxtb	r2, r2
 801a784:	701a      	strb	r2, [r3, #0]
 801a786:	4b4f      	ldr	r3, [pc, #316]	; (801a8c4 <finsh_compile+0x5a0>)
 801a788:	681b      	ldr	r3, [r3, #0]
 801a78a:	3301      	adds	r3, #1
 801a78c:	69ba      	ldr	r2, [r7, #24]
 801a78e:	3214      	adds	r2, #20
 801a790:	0a12      	lsrs	r2, r2, #8
 801a792:	b2d2      	uxtb	r2, r2
 801a794:	701a      	strb	r2, [r3, #0]
 801a796:	4b4b      	ldr	r3, [pc, #300]	; (801a8c4 <finsh_compile+0x5a0>)
 801a798:	681b      	ldr	r3, [r3, #0]
 801a79a:	3302      	adds	r3, #2
 801a79c:	69ba      	ldr	r2, [r7, #24]
 801a79e:	3214      	adds	r2, #20
 801a7a0:	0c12      	lsrs	r2, r2, #16
 801a7a2:	b2d2      	uxtb	r2, r2
 801a7a4:	701a      	strb	r2, [r3, #0]
 801a7a6:	4b47      	ldr	r3, [pc, #284]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7a8:	681b      	ldr	r3, [r3, #0]
 801a7aa:	3303      	adds	r3, #3
 801a7ac:	69ba      	ldr	r2, [r7, #24]
 801a7ae:	3214      	adds	r2, #20
 801a7b0:	0e12      	lsrs	r2, r2, #24
 801a7b2:	b2d2      	uxtb	r2, r2
 801a7b4:	701a      	strb	r2, [r3, #0]
 801a7b6:	4b43      	ldr	r3, [pc, #268]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7b8:	681b      	ldr	r3, [r3, #0]
 801a7ba:	3304      	adds	r3, #4
 801a7bc:	4a41      	ldr	r2, [pc, #260]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7be:	6013      	str	r3, [r2, #0]
                            break;
 801a7c0:	bf00      	nop
                        }
                    }
                }
            }
            break;
 801a7c2:	f001 b98d 	b.w	801bae0 <finsh_compile+0x17bc>

        /* load const */
        case FINSH_NODE_VALUE_CHAR:
            finsh_code_byte(FINSH_OP_LD_BYTE);
 801a7c6:	4b3f      	ldr	r3, [pc, #252]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7c8:	681b      	ldr	r3, [r3, #0]
 801a7ca:	2222      	movs	r2, #34	; 0x22
 801a7cc:	701a      	strb	r2, [r3, #0]
 801a7ce:	4b3d      	ldr	r3, [pc, #244]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7d0:	681b      	ldr	r3, [r3, #0]
 801a7d2:	3301      	adds	r3, #1
 801a7d4:	4a3b      	ldr	r2, [pc, #236]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7d6:	6013      	str	r3, [r2, #0]
            finsh_code_byte(node->value.char_value);
 801a7d8:	4b3a      	ldr	r3, [pc, #232]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7da:	681b      	ldr	r3, [r3, #0]
 801a7dc:	687a      	ldr	r2, [r7, #4]
 801a7de:	7912      	ldrb	r2, [r2, #4]
 801a7e0:	701a      	strb	r2, [r3, #0]
 801a7e2:	4b38      	ldr	r3, [pc, #224]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7e4:	681b      	ldr	r3, [r3, #0]
 801a7e6:	3301      	adds	r3, #1
 801a7e8:	4a36      	ldr	r2, [pc, #216]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7ea:	6013      	str	r3, [r2, #0]
            break;
 801a7ec:	f001 b979 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_VALUE_INT:
        case FINSH_NODE_VALUE_LONG:
            finsh_code_byte(FINSH_OP_LD_DWORD);
 801a7f0:	4b34      	ldr	r3, [pc, #208]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7f2:	681b      	ldr	r3, [r3, #0]
 801a7f4:	2224      	movs	r2, #36	; 0x24
 801a7f6:	701a      	strb	r2, [r3, #0]
 801a7f8:	4b32      	ldr	r3, [pc, #200]	; (801a8c4 <finsh_compile+0x5a0>)
 801a7fa:	681b      	ldr	r3, [r3, #0]
 801a7fc:	3301      	adds	r3, #1
 801a7fe:	4a31      	ldr	r2, [pc, #196]	; (801a8c4 <finsh_compile+0x5a0>)
 801a800:	6013      	str	r3, [r2, #0]
            finsh_code_dword(node->value.long_value);
 801a802:	4b30      	ldr	r3, [pc, #192]	; (801a8c4 <finsh_compile+0x5a0>)
 801a804:	681b      	ldr	r3, [r3, #0]
 801a806:	687a      	ldr	r2, [r7, #4]
 801a808:	6852      	ldr	r2, [r2, #4]
 801a80a:	b2d2      	uxtb	r2, r2
 801a80c:	701a      	strb	r2, [r3, #0]
 801a80e:	4b2d      	ldr	r3, [pc, #180]	; (801a8c4 <finsh_compile+0x5a0>)
 801a810:	681b      	ldr	r3, [r3, #0]
 801a812:	3301      	adds	r3, #1
 801a814:	687a      	ldr	r2, [r7, #4]
 801a816:	6852      	ldr	r2, [r2, #4]
 801a818:	0a12      	lsrs	r2, r2, #8
 801a81a:	b2d2      	uxtb	r2, r2
 801a81c:	701a      	strb	r2, [r3, #0]
 801a81e:	4b29      	ldr	r3, [pc, #164]	; (801a8c4 <finsh_compile+0x5a0>)
 801a820:	681b      	ldr	r3, [r3, #0]
 801a822:	3302      	adds	r3, #2
 801a824:	687a      	ldr	r2, [r7, #4]
 801a826:	6852      	ldr	r2, [r2, #4]
 801a828:	0c12      	lsrs	r2, r2, #16
 801a82a:	b2d2      	uxtb	r2, r2
 801a82c:	701a      	strb	r2, [r3, #0]
 801a82e:	4b25      	ldr	r3, [pc, #148]	; (801a8c4 <finsh_compile+0x5a0>)
 801a830:	681b      	ldr	r3, [r3, #0]
 801a832:	3303      	adds	r3, #3
 801a834:	687a      	ldr	r2, [r7, #4]
 801a836:	6852      	ldr	r2, [r2, #4]
 801a838:	0e12      	lsrs	r2, r2, #24
 801a83a:	b2d2      	uxtb	r2, r2
 801a83c:	701a      	strb	r2, [r3, #0]
 801a83e:	4b21      	ldr	r3, [pc, #132]	; (801a8c4 <finsh_compile+0x5a0>)
 801a840:	681b      	ldr	r3, [r3, #0]
 801a842:	3304      	adds	r3, #4
 801a844:	4a1f      	ldr	r2, [pc, #124]	; (801a8c4 <finsh_compile+0x5a0>)
 801a846:	6013      	str	r3, [r2, #0]
            break;
 801a848:	f001 b94b 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_VALUE_NULL:
        case FINSH_NODE_VALUE_STRING:
            finsh_code_byte(FINSH_OP_LD_DWORD);
 801a84c:	4b1d      	ldr	r3, [pc, #116]	; (801a8c4 <finsh_compile+0x5a0>)
 801a84e:	681b      	ldr	r3, [r3, #0]
 801a850:	2224      	movs	r2, #36	; 0x24
 801a852:	701a      	strb	r2, [r3, #0]
 801a854:	4b1b      	ldr	r3, [pc, #108]	; (801a8c4 <finsh_compile+0x5a0>)
 801a856:	681b      	ldr	r3, [r3, #0]
 801a858:	3301      	adds	r3, #1
 801a85a:	4a1a      	ldr	r2, [pc, #104]	; (801a8c4 <finsh_compile+0x5a0>)
 801a85c:	6013      	str	r3, [r2, #0]
            finsh_code_dword((u_long)node->value.ptr);
 801a85e:	4b19      	ldr	r3, [pc, #100]	; (801a8c4 <finsh_compile+0x5a0>)
 801a860:	681b      	ldr	r3, [r3, #0]
 801a862:	687a      	ldr	r2, [r7, #4]
 801a864:	6852      	ldr	r2, [r2, #4]
 801a866:	b2d2      	uxtb	r2, r2
 801a868:	701a      	strb	r2, [r3, #0]
 801a86a:	4b16      	ldr	r3, [pc, #88]	; (801a8c4 <finsh_compile+0x5a0>)
 801a86c:	681b      	ldr	r3, [r3, #0]
 801a86e:	3301      	adds	r3, #1
 801a870:	687a      	ldr	r2, [r7, #4]
 801a872:	6852      	ldr	r2, [r2, #4]
 801a874:	0a12      	lsrs	r2, r2, #8
 801a876:	b2d2      	uxtb	r2, r2
 801a878:	701a      	strb	r2, [r3, #0]
 801a87a:	4b12      	ldr	r3, [pc, #72]	; (801a8c4 <finsh_compile+0x5a0>)
 801a87c:	681b      	ldr	r3, [r3, #0]
 801a87e:	3302      	adds	r3, #2
 801a880:	687a      	ldr	r2, [r7, #4]
 801a882:	6852      	ldr	r2, [r2, #4]
 801a884:	0c12      	lsrs	r2, r2, #16
 801a886:	b2d2      	uxtb	r2, r2
 801a888:	701a      	strb	r2, [r3, #0]
 801a88a:	4b0e      	ldr	r3, [pc, #56]	; (801a8c4 <finsh_compile+0x5a0>)
 801a88c:	681b      	ldr	r3, [r3, #0]
 801a88e:	3303      	adds	r3, #3
 801a890:	687a      	ldr	r2, [r7, #4]
 801a892:	6852      	ldr	r2, [r2, #4]
 801a894:	0e12      	lsrs	r2, r2, #24
 801a896:	b2d2      	uxtb	r2, r2
 801a898:	701a      	strb	r2, [r3, #0]
 801a89a:	4b0a      	ldr	r3, [pc, #40]	; (801a8c4 <finsh_compile+0x5a0>)
 801a89c:	681b      	ldr	r3, [r3, #0]
 801a89e:	3304      	adds	r3, #4
 801a8a0:	4a08      	ldr	r2, [pc, #32]	; (801a8c4 <finsh_compile+0x5a0>)
 801a8a2:	6013      	str	r3, [r2, #0]
            break;
 801a8a4:	f001 b91d 	b.w	801bae2 <finsh_compile+0x17be>

        /* arithmetic operation */
        case FINSH_NODE_SYS_ADD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_ADD_BYTE);
 801a8a8:	687b      	ldr	r3, [r7, #4]
 801a8aa:	785b      	ldrb	r3, [r3, #1]
 801a8ac:	2b01      	cmp	r3, #1
 801a8ae:	d10b      	bne.n	801a8c8 <finsh_compile+0x5a4>
 801a8b0:	4b04      	ldr	r3, [pc, #16]	; (801a8c4 <finsh_compile+0x5a0>)
 801a8b2:	681b      	ldr	r3, [r3, #0]
 801a8b4:	2201      	movs	r2, #1
 801a8b6:	701a      	strb	r2, [r3, #0]
 801a8b8:	4b02      	ldr	r3, [pc, #8]	; (801a8c4 <finsh_compile+0x5a0>)
 801a8ba:	681b      	ldr	r3, [r3, #0]
 801a8bc:	3301      	adds	r3, #1
 801a8be:	4a01      	ldr	r2, [pc, #4]	; (801a8c4 <finsh_compile+0x5a0>)
 801a8c0:	6013      	str	r3, [r2, #0]
 801a8c2:	e01e      	b.n	801a902 <finsh_compile+0x5de>
 801a8c4:	200126e4 	.word	0x200126e4
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_ADD_WORD);
 801a8c8:	687b      	ldr	r3, [r7, #4]
 801a8ca:	785b      	ldrb	r3, [r3, #1]
 801a8cc:	2b02      	cmp	r3, #2
 801a8ce:	d109      	bne.n	801a8e4 <finsh_compile+0x5c0>
 801a8d0:	4b94      	ldr	r3, [pc, #592]	; (801ab24 <finsh_compile+0x800>)
 801a8d2:	681b      	ldr	r3, [r3, #0]
 801a8d4:	2202      	movs	r2, #2
 801a8d6:	701a      	strb	r2, [r3, #0]
 801a8d8:	4b92      	ldr	r3, [pc, #584]	; (801ab24 <finsh_compile+0x800>)
 801a8da:	681b      	ldr	r3, [r3, #0]
 801a8dc:	3301      	adds	r3, #1
 801a8de:	4a91      	ldr	r2, [pc, #580]	; (801ab24 <finsh_compile+0x800>)
 801a8e0:	6013      	str	r3, [r2, #0]
 801a8e2:	e00e      	b.n	801a902 <finsh_compile+0x5de>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_ADD_DWORD);
 801a8e4:	687b      	ldr	r3, [r7, #4]
 801a8e6:	785b      	ldrb	r3, [r3, #1]
 801a8e8:	2b03      	cmp	r3, #3
 801a8ea:	d10a      	bne.n	801a902 <finsh_compile+0x5de>
 801a8ec:	4b8d      	ldr	r3, [pc, #564]	; (801ab24 <finsh_compile+0x800>)
 801a8ee:	681b      	ldr	r3, [r3, #0]
 801a8f0:	2203      	movs	r2, #3
 801a8f2:	701a      	strb	r2, [r3, #0]
 801a8f4:	4b8b      	ldr	r3, [pc, #556]	; (801ab24 <finsh_compile+0x800>)
 801a8f6:	681b      	ldr	r3, [r3, #0]
 801a8f8:	3301      	adds	r3, #1
 801a8fa:	4a8a      	ldr	r2, [pc, #552]	; (801ab24 <finsh_compile+0x800>)
 801a8fc:	6013      	str	r3, [r2, #0]
            break;
 801a8fe:	f001 b8f0 	b.w	801bae2 <finsh_compile+0x17be>
 801a902:	f001 b8ee 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SUB:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SUB_BYTE);
 801a906:	687b      	ldr	r3, [r7, #4]
 801a908:	785b      	ldrb	r3, [r3, #1]
 801a90a:	2b01      	cmp	r3, #1
 801a90c:	d109      	bne.n	801a922 <finsh_compile+0x5fe>
 801a90e:	4b85      	ldr	r3, [pc, #532]	; (801ab24 <finsh_compile+0x800>)
 801a910:	681b      	ldr	r3, [r3, #0]
 801a912:	2204      	movs	r2, #4
 801a914:	701a      	strb	r2, [r3, #0]
 801a916:	4b83      	ldr	r3, [pc, #524]	; (801ab24 <finsh_compile+0x800>)
 801a918:	681b      	ldr	r3, [r3, #0]
 801a91a:	3301      	adds	r3, #1
 801a91c:	4a81      	ldr	r2, [pc, #516]	; (801ab24 <finsh_compile+0x800>)
 801a91e:	6013      	str	r3, [r2, #0]
 801a920:	e01c      	b.n	801a95c <finsh_compile+0x638>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SUB_WORD);
 801a922:	687b      	ldr	r3, [r7, #4]
 801a924:	785b      	ldrb	r3, [r3, #1]
 801a926:	2b02      	cmp	r3, #2
 801a928:	d109      	bne.n	801a93e <finsh_compile+0x61a>
 801a92a:	4b7e      	ldr	r3, [pc, #504]	; (801ab24 <finsh_compile+0x800>)
 801a92c:	681b      	ldr	r3, [r3, #0]
 801a92e:	2205      	movs	r2, #5
 801a930:	701a      	strb	r2, [r3, #0]
 801a932:	4b7c      	ldr	r3, [pc, #496]	; (801ab24 <finsh_compile+0x800>)
 801a934:	681b      	ldr	r3, [r3, #0]
 801a936:	3301      	adds	r3, #1
 801a938:	4a7a      	ldr	r2, [pc, #488]	; (801ab24 <finsh_compile+0x800>)
 801a93a:	6013      	str	r3, [r2, #0]
 801a93c:	e00e      	b.n	801a95c <finsh_compile+0x638>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SUB_DWORD);
 801a93e:	687b      	ldr	r3, [r7, #4]
 801a940:	785b      	ldrb	r3, [r3, #1]
 801a942:	2b03      	cmp	r3, #3
 801a944:	d10a      	bne.n	801a95c <finsh_compile+0x638>
 801a946:	4b77      	ldr	r3, [pc, #476]	; (801ab24 <finsh_compile+0x800>)
 801a948:	681b      	ldr	r3, [r3, #0]
 801a94a:	2206      	movs	r2, #6
 801a94c:	701a      	strb	r2, [r3, #0]
 801a94e:	4b75      	ldr	r3, [pc, #468]	; (801ab24 <finsh_compile+0x800>)
 801a950:	681b      	ldr	r3, [r3, #0]
 801a952:	3301      	adds	r3, #1
 801a954:	4a73      	ldr	r2, [pc, #460]	; (801ab24 <finsh_compile+0x800>)
 801a956:	6013      	str	r3, [r2, #0]
            break;
 801a958:	f001 b8c3 	b.w	801bae2 <finsh_compile+0x17be>
 801a95c:	f001 b8c1 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_MUL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MUL_BYTE);
 801a960:	687b      	ldr	r3, [r7, #4]
 801a962:	785b      	ldrb	r3, [r3, #1]
 801a964:	2b01      	cmp	r3, #1
 801a966:	d109      	bne.n	801a97c <finsh_compile+0x658>
 801a968:	4b6e      	ldr	r3, [pc, #440]	; (801ab24 <finsh_compile+0x800>)
 801a96a:	681b      	ldr	r3, [r3, #0]
 801a96c:	220d      	movs	r2, #13
 801a96e:	701a      	strb	r2, [r3, #0]
 801a970:	4b6c      	ldr	r3, [pc, #432]	; (801ab24 <finsh_compile+0x800>)
 801a972:	681b      	ldr	r3, [r3, #0]
 801a974:	3301      	adds	r3, #1
 801a976:	4a6b      	ldr	r2, [pc, #428]	; (801ab24 <finsh_compile+0x800>)
 801a978:	6013      	str	r3, [r2, #0]
 801a97a:	e01c      	b.n	801a9b6 <finsh_compile+0x692>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MUL_WORD);
 801a97c:	687b      	ldr	r3, [r7, #4]
 801a97e:	785b      	ldrb	r3, [r3, #1]
 801a980:	2b02      	cmp	r3, #2
 801a982:	d109      	bne.n	801a998 <finsh_compile+0x674>
 801a984:	4b67      	ldr	r3, [pc, #412]	; (801ab24 <finsh_compile+0x800>)
 801a986:	681b      	ldr	r3, [r3, #0]
 801a988:	220e      	movs	r2, #14
 801a98a:	701a      	strb	r2, [r3, #0]
 801a98c:	4b65      	ldr	r3, [pc, #404]	; (801ab24 <finsh_compile+0x800>)
 801a98e:	681b      	ldr	r3, [r3, #0]
 801a990:	3301      	adds	r3, #1
 801a992:	4a64      	ldr	r2, [pc, #400]	; (801ab24 <finsh_compile+0x800>)
 801a994:	6013      	str	r3, [r2, #0]
 801a996:	e00e      	b.n	801a9b6 <finsh_compile+0x692>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MUL_DWORD);
 801a998:	687b      	ldr	r3, [r7, #4]
 801a99a:	785b      	ldrb	r3, [r3, #1]
 801a99c:	2b03      	cmp	r3, #3
 801a99e:	d10a      	bne.n	801a9b6 <finsh_compile+0x692>
 801a9a0:	4b60      	ldr	r3, [pc, #384]	; (801ab24 <finsh_compile+0x800>)
 801a9a2:	681b      	ldr	r3, [r3, #0]
 801a9a4:	220f      	movs	r2, #15
 801a9a6:	701a      	strb	r2, [r3, #0]
 801a9a8:	4b5e      	ldr	r3, [pc, #376]	; (801ab24 <finsh_compile+0x800>)
 801a9aa:	681b      	ldr	r3, [r3, #0]
 801a9ac:	3301      	adds	r3, #1
 801a9ae:	4a5d      	ldr	r2, [pc, #372]	; (801ab24 <finsh_compile+0x800>)
 801a9b0:	6013      	str	r3, [r2, #0]
            break;
 801a9b2:	f001 b896 	b.w	801bae2 <finsh_compile+0x17be>
 801a9b6:	f001 b894 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_DIV:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_DIV_BYTE);
 801a9ba:	687b      	ldr	r3, [r7, #4]
 801a9bc:	785b      	ldrb	r3, [r3, #1]
 801a9be:	2b01      	cmp	r3, #1
 801a9c0:	d109      	bne.n	801a9d6 <finsh_compile+0x6b2>
 801a9c2:	4b58      	ldr	r3, [pc, #352]	; (801ab24 <finsh_compile+0x800>)
 801a9c4:	681b      	ldr	r3, [r3, #0]
 801a9c6:	2207      	movs	r2, #7
 801a9c8:	701a      	strb	r2, [r3, #0]
 801a9ca:	4b56      	ldr	r3, [pc, #344]	; (801ab24 <finsh_compile+0x800>)
 801a9cc:	681b      	ldr	r3, [r3, #0]
 801a9ce:	3301      	adds	r3, #1
 801a9d0:	4a54      	ldr	r2, [pc, #336]	; (801ab24 <finsh_compile+0x800>)
 801a9d2:	6013      	str	r3, [r2, #0]
 801a9d4:	e01c      	b.n	801aa10 <finsh_compile+0x6ec>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_DIV_WORD);
 801a9d6:	687b      	ldr	r3, [r7, #4]
 801a9d8:	785b      	ldrb	r3, [r3, #1]
 801a9da:	2b02      	cmp	r3, #2
 801a9dc:	d109      	bne.n	801a9f2 <finsh_compile+0x6ce>
 801a9de:	4b51      	ldr	r3, [pc, #324]	; (801ab24 <finsh_compile+0x800>)
 801a9e0:	681b      	ldr	r3, [r3, #0]
 801a9e2:	2208      	movs	r2, #8
 801a9e4:	701a      	strb	r2, [r3, #0]
 801a9e6:	4b4f      	ldr	r3, [pc, #316]	; (801ab24 <finsh_compile+0x800>)
 801a9e8:	681b      	ldr	r3, [r3, #0]
 801a9ea:	3301      	adds	r3, #1
 801a9ec:	4a4d      	ldr	r2, [pc, #308]	; (801ab24 <finsh_compile+0x800>)
 801a9ee:	6013      	str	r3, [r2, #0]
 801a9f0:	e00e      	b.n	801aa10 <finsh_compile+0x6ec>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_DIV_DWORD);
 801a9f2:	687b      	ldr	r3, [r7, #4]
 801a9f4:	785b      	ldrb	r3, [r3, #1]
 801a9f6:	2b03      	cmp	r3, #3
 801a9f8:	d10a      	bne.n	801aa10 <finsh_compile+0x6ec>
 801a9fa:	4b4a      	ldr	r3, [pc, #296]	; (801ab24 <finsh_compile+0x800>)
 801a9fc:	681b      	ldr	r3, [r3, #0]
 801a9fe:	2209      	movs	r2, #9
 801aa00:	701a      	strb	r2, [r3, #0]
 801aa02:	4b48      	ldr	r3, [pc, #288]	; (801ab24 <finsh_compile+0x800>)
 801aa04:	681b      	ldr	r3, [r3, #0]
 801aa06:	3301      	adds	r3, #1
 801aa08:	4a46      	ldr	r2, [pc, #280]	; (801ab24 <finsh_compile+0x800>)
 801aa0a:	6013      	str	r3, [r2, #0]
            break;
 801aa0c:	f001 b869 	b.w	801bae2 <finsh_compile+0x17be>
 801aa10:	f001 b867 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_MOD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MOD_BYTE);
 801aa14:	687b      	ldr	r3, [r7, #4]
 801aa16:	785b      	ldrb	r3, [r3, #1]
 801aa18:	2b01      	cmp	r3, #1
 801aa1a:	d109      	bne.n	801aa30 <finsh_compile+0x70c>
 801aa1c:	4b41      	ldr	r3, [pc, #260]	; (801ab24 <finsh_compile+0x800>)
 801aa1e:	681b      	ldr	r3, [r3, #0]
 801aa20:	220a      	movs	r2, #10
 801aa22:	701a      	strb	r2, [r3, #0]
 801aa24:	4b3f      	ldr	r3, [pc, #252]	; (801ab24 <finsh_compile+0x800>)
 801aa26:	681b      	ldr	r3, [r3, #0]
 801aa28:	3301      	adds	r3, #1
 801aa2a:	4a3e      	ldr	r2, [pc, #248]	; (801ab24 <finsh_compile+0x800>)
 801aa2c:	6013      	str	r3, [r2, #0]
 801aa2e:	e01c      	b.n	801aa6a <finsh_compile+0x746>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MOD_WORD);
 801aa30:	687b      	ldr	r3, [r7, #4]
 801aa32:	785b      	ldrb	r3, [r3, #1]
 801aa34:	2b02      	cmp	r3, #2
 801aa36:	d109      	bne.n	801aa4c <finsh_compile+0x728>
 801aa38:	4b3a      	ldr	r3, [pc, #232]	; (801ab24 <finsh_compile+0x800>)
 801aa3a:	681b      	ldr	r3, [r3, #0]
 801aa3c:	220b      	movs	r2, #11
 801aa3e:	701a      	strb	r2, [r3, #0]
 801aa40:	4b38      	ldr	r3, [pc, #224]	; (801ab24 <finsh_compile+0x800>)
 801aa42:	681b      	ldr	r3, [r3, #0]
 801aa44:	3301      	adds	r3, #1
 801aa46:	4a37      	ldr	r2, [pc, #220]	; (801ab24 <finsh_compile+0x800>)
 801aa48:	6013      	str	r3, [r2, #0]
 801aa4a:	e00e      	b.n	801aa6a <finsh_compile+0x746>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MOD_DWORD);
 801aa4c:	687b      	ldr	r3, [r7, #4]
 801aa4e:	785b      	ldrb	r3, [r3, #1]
 801aa50:	2b03      	cmp	r3, #3
 801aa52:	d10a      	bne.n	801aa6a <finsh_compile+0x746>
 801aa54:	4b33      	ldr	r3, [pc, #204]	; (801ab24 <finsh_compile+0x800>)
 801aa56:	681b      	ldr	r3, [r3, #0]
 801aa58:	220c      	movs	r2, #12
 801aa5a:	701a      	strb	r2, [r3, #0]
 801aa5c:	4b31      	ldr	r3, [pc, #196]	; (801ab24 <finsh_compile+0x800>)
 801aa5e:	681b      	ldr	r3, [r3, #0]
 801aa60:	3301      	adds	r3, #1
 801aa62:	4a30      	ldr	r2, [pc, #192]	; (801ab24 <finsh_compile+0x800>)
 801aa64:	6013      	str	r3, [r2, #0]
            break;
 801aa66:	f001 b83c 	b.w	801bae2 <finsh_compile+0x17be>
 801aa6a:	f001 b83a 	b.w	801bae2 <finsh_compile+0x17be>

        /* bit operation */
        case FINSH_NODE_SYS_AND:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_AND_BYTE);
 801aa6e:	687b      	ldr	r3, [r7, #4]
 801aa70:	785b      	ldrb	r3, [r3, #1]
 801aa72:	2b01      	cmp	r3, #1
 801aa74:	d109      	bne.n	801aa8a <finsh_compile+0x766>
 801aa76:	4b2b      	ldr	r3, [pc, #172]	; (801ab24 <finsh_compile+0x800>)
 801aa78:	681b      	ldr	r3, [r3, #0]
 801aa7a:	2210      	movs	r2, #16
 801aa7c:	701a      	strb	r2, [r3, #0]
 801aa7e:	4b29      	ldr	r3, [pc, #164]	; (801ab24 <finsh_compile+0x800>)
 801aa80:	681b      	ldr	r3, [r3, #0]
 801aa82:	3301      	adds	r3, #1
 801aa84:	4a27      	ldr	r2, [pc, #156]	; (801ab24 <finsh_compile+0x800>)
 801aa86:	6013      	str	r3, [r2, #0]
 801aa88:	e01c      	b.n	801aac4 <finsh_compile+0x7a0>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_AND_WORD);
 801aa8a:	687b      	ldr	r3, [r7, #4]
 801aa8c:	785b      	ldrb	r3, [r3, #1]
 801aa8e:	2b02      	cmp	r3, #2
 801aa90:	d109      	bne.n	801aaa6 <finsh_compile+0x782>
 801aa92:	4b24      	ldr	r3, [pc, #144]	; (801ab24 <finsh_compile+0x800>)
 801aa94:	681b      	ldr	r3, [r3, #0]
 801aa96:	2211      	movs	r2, #17
 801aa98:	701a      	strb	r2, [r3, #0]
 801aa9a:	4b22      	ldr	r3, [pc, #136]	; (801ab24 <finsh_compile+0x800>)
 801aa9c:	681b      	ldr	r3, [r3, #0]
 801aa9e:	3301      	adds	r3, #1
 801aaa0:	4a20      	ldr	r2, [pc, #128]	; (801ab24 <finsh_compile+0x800>)
 801aaa2:	6013      	str	r3, [r2, #0]
 801aaa4:	e00e      	b.n	801aac4 <finsh_compile+0x7a0>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_AND_DWORD);
 801aaa6:	687b      	ldr	r3, [r7, #4]
 801aaa8:	785b      	ldrb	r3, [r3, #1]
 801aaaa:	2b03      	cmp	r3, #3
 801aaac:	d10a      	bne.n	801aac4 <finsh_compile+0x7a0>
 801aaae:	4b1d      	ldr	r3, [pc, #116]	; (801ab24 <finsh_compile+0x800>)
 801aab0:	681b      	ldr	r3, [r3, #0]
 801aab2:	2212      	movs	r2, #18
 801aab4:	701a      	strb	r2, [r3, #0]
 801aab6:	4b1b      	ldr	r3, [pc, #108]	; (801ab24 <finsh_compile+0x800>)
 801aab8:	681b      	ldr	r3, [r3, #0]
 801aaba:	3301      	adds	r3, #1
 801aabc:	4a19      	ldr	r2, [pc, #100]	; (801ab24 <finsh_compile+0x800>)
 801aabe:	6013      	str	r3, [r2, #0]
            break;
 801aac0:	f001 b80f 	b.w	801bae2 <finsh_compile+0x17be>
 801aac4:	f001 b80d 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_OR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_OR_BYTE);
 801aac8:	687b      	ldr	r3, [r7, #4]
 801aaca:	785b      	ldrb	r3, [r3, #1]
 801aacc:	2b01      	cmp	r3, #1
 801aace:	d109      	bne.n	801aae4 <finsh_compile+0x7c0>
 801aad0:	4b14      	ldr	r3, [pc, #80]	; (801ab24 <finsh_compile+0x800>)
 801aad2:	681b      	ldr	r3, [r3, #0]
 801aad4:	2213      	movs	r2, #19
 801aad6:	701a      	strb	r2, [r3, #0]
 801aad8:	4b12      	ldr	r3, [pc, #72]	; (801ab24 <finsh_compile+0x800>)
 801aada:	681b      	ldr	r3, [r3, #0]
 801aadc:	3301      	adds	r3, #1
 801aade:	4a11      	ldr	r2, [pc, #68]	; (801ab24 <finsh_compile+0x800>)
 801aae0:	6013      	str	r3, [r2, #0]
 801aae2:	e01c      	b.n	801ab1e <finsh_compile+0x7fa>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_OR_WORD);
 801aae4:	687b      	ldr	r3, [r7, #4]
 801aae6:	785b      	ldrb	r3, [r3, #1]
 801aae8:	2b02      	cmp	r3, #2
 801aaea:	d109      	bne.n	801ab00 <finsh_compile+0x7dc>
 801aaec:	4b0d      	ldr	r3, [pc, #52]	; (801ab24 <finsh_compile+0x800>)
 801aaee:	681b      	ldr	r3, [r3, #0]
 801aaf0:	2214      	movs	r2, #20
 801aaf2:	701a      	strb	r2, [r3, #0]
 801aaf4:	4b0b      	ldr	r3, [pc, #44]	; (801ab24 <finsh_compile+0x800>)
 801aaf6:	681b      	ldr	r3, [r3, #0]
 801aaf8:	3301      	adds	r3, #1
 801aafa:	4a0a      	ldr	r2, [pc, #40]	; (801ab24 <finsh_compile+0x800>)
 801aafc:	6013      	str	r3, [r2, #0]
 801aafe:	e00e      	b.n	801ab1e <finsh_compile+0x7fa>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_OR_DWORD);
 801ab00:	687b      	ldr	r3, [r7, #4]
 801ab02:	785b      	ldrb	r3, [r3, #1]
 801ab04:	2b03      	cmp	r3, #3
 801ab06:	d10a      	bne.n	801ab1e <finsh_compile+0x7fa>
 801ab08:	4b06      	ldr	r3, [pc, #24]	; (801ab24 <finsh_compile+0x800>)
 801ab0a:	681b      	ldr	r3, [r3, #0]
 801ab0c:	2215      	movs	r2, #21
 801ab0e:	701a      	strb	r2, [r3, #0]
 801ab10:	4b04      	ldr	r3, [pc, #16]	; (801ab24 <finsh_compile+0x800>)
 801ab12:	681b      	ldr	r3, [r3, #0]
 801ab14:	3301      	adds	r3, #1
 801ab16:	4a03      	ldr	r2, [pc, #12]	; (801ab24 <finsh_compile+0x800>)
 801ab18:	6013      	str	r3, [r2, #0]
            break;
 801ab1a:	f000 bfe2 	b.w	801bae2 <finsh_compile+0x17be>
 801ab1e:	f000 bfe0 	b.w	801bae2 <finsh_compile+0x17be>
 801ab22:	bf00      	nop
 801ab24:	200126e4 	.word	0x200126e4

        case FINSH_NODE_SYS_XOR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_XOR_BYTE);
 801ab28:	687b      	ldr	r3, [r7, #4]
 801ab2a:	785b      	ldrb	r3, [r3, #1]
 801ab2c:	2b01      	cmp	r3, #1
 801ab2e:	d109      	bne.n	801ab44 <finsh_compile+0x820>
 801ab30:	4b95      	ldr	r3, [pc, #596]	; (801ad88 <finsh_compile+0xa64>)
 801ab32:	681b      	ldr	r3, [r3, #0]
 801ab34:	2216      	movs	r2, #22
 801ab36:	701a      	strb	r2, [r3, #0]
 801ab38:	4b93      	ldr	r3, [pc, #588]	; (801ad88 <finsh_compile+0xa64>)
 801ab3a:	681b      	ldr	r3, [r3, #0]
 801ab3c:	3301      	adds	r3, #1
 801ab3e:	4a92      	ldr	r2, [pc, #584]	; (801ad88 <finsh_compile+0xa64>)
 801ab40:	6013      	str	r3, [r2, #0]
 801ab42:	e01c      	b.n	801ab7e <finsh_compile+0x85a>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_XOR_WORD);
 801ab44:	687b      	ldr	r3, [r7, #4]
 801ab46:	785b      	ldrb	r3, [r3, #1]
 801ab48:	2b02      	cmp	r3, #2
 801ab4a:	d109      	bne.n	801ab60 <finsh_compile+0x83c>
 801ab4c:	4b8e      	ldr	r3, [pc, #568]	; (801ad88 <finsh_compile+0xa64>)
 801ab4e:	681b      	ldr	r3, [r3, #0]
 801ab50:	2217      	movs	r2, #23
 801ab52:	701a      	strb	r2, [r3, #0]
 801ab54:	4b8c      	ldr	r3, [pc, #560]	; (801ad88 <finsh_compile+0xa64>)
 801ab56:	681b      	ldr	r3, [r3, #0]
 801ab58:	3301      	adds	r3, #1
 801ab5a:	4a8b      	ldr	r2, [pc, #556]	; (801ad88 <finsh_compile+0xa64>)
 801ab5c:	6013      	str	r3, [r2, #0]
 801ab5e:	e00e      	b.n	801ab7e <finsh_compile+0x85a>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_XOR_DWORD);
 801ab60:	687b      	ldr	r3, [r7, #4]
 801ab62:	785b      	ldrb	r3, [r3, #1]
 801ab64:	2b03      	cmp	r3, #3
 801ab66:	d10a      	bne.n	801ab7e <finsh_compile+0x85a>
 801ab68:	4b87      	ldr	r3, [pc, #540]	; (801ad88 <finsh_compile+0xa64>)
 801ab6a:	681b      	ldr	r3, [r3, #0]
 801ab6c:	2218      	movs	r2, #24
 801ab6e:	701a      	strb	r2, [r3, #0]
 801ab70:	4b85      	ldr	r3, [pc, #532]	; (801ad88 <finsh_compile+0xa64>)
 801ab72:	681b      	ldr	r3, [r3, #0]
 801ab74:	3301      	adds	r3, #1
 801ab76:	4a84      	ldr	r2, [pc, #528]	; (801ad88 <finsh_compile+0xa64>)
 801ab78:	6013      	str	r3, [r2, #0]
            break;
 801ab7a:	f000 bfb2 	b.w	801bae2 <finsh_compile+0x17be>
 801ab7e:	f000 bfb0 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_BITWISE:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_BITWISE_BYTE);
 801ab82:	687b      	ldr	r3, [r7, #4]
 801ab84:	785b      	ldrb	r3, [r3, #1]
 801ab86:	2b01      	cmp	r3, #1
 801ab88:	d109      	bne.n	801ab9e <finsh_compile+0x87a>
 801ab8a:	4b7f      	ldr	r3, [pc, #508]	; (801ad88 <finsh_compile+0xa64>)
 801ab8c:	681b      	ldr	r3, [r3, #0]
 801ab8e:	2219      	movs	r2, #25
 801ab90:	701a      	strb	r2, [r3, #0]
 801ab92:	4b7d      	ldr	r3, [pc, #500]	; (801ad88 <finsh_compile+0xa64>)
 801ab94:	681b      	ldr	r3, [r3, #0]
 801ab96:	3301      	adds	r3, #1
 801ab98:	4a7b      	ldr	r2, [pc, #492]	; (801ad88 <finsh_compile+0xa64>)
 801ab9a:	6013      	str	r3, [r2, #0]
 801ab9c:	e01c      	b.n	801abd8 <finsh_compile+0x8b4>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_BITWISE_WORD);
 801ab9e:	687b      	ldr	r3, [r7, #4]
 801aba0:	785b      	ldrb	r3, [r3, #1]
 801aba2:	2b02      	cmp	r3, #2
 801aba4:	d109      	bne.n	801abba <finsh_compile+0x896>
 801aba6:	4b78      	ldr	r3, [pc, #480]	; (801ad88 <finsh_compile+0xa64>)
 801aba8:	681b      	ldr	r3, [r3, #0]
 801abaa:	221a      	movs	r2, #26
 801abac:	701a      	strb	r2, [r3, #0]
 801abae:	4b76      	ldr	r3, [pc, #472]	; (801ad88 <finsh_compile+0xa64>)
 801abb0:	681b      	ldr	r3, [r3, #0]
 801abb2:	3301      	adds	r3, #1
 801abb4:	4a74      	ldr	r2, [pc, #464]	; (801ad88 <finsh_compile+0xa64>)
 801abb6:	6013      	str	r3, [r2, #0]
 801abb8:	e00e      	b.n	801abd8 <finsh_compile+0x8b4>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_BITWISE_DWORD);
 801abba:	687b      	ldr	r3, [r7, #4]
 801abbc:	785b      	ldrb	r3, [r3, #1]
 801abbe:	2b03      	cmp	r3, #3
 801abc0:	d10a      	bne.n	801abd8 <finsh_compile+0x8b4>
 801abc2:	4b71      	ldr	r3, [pc, #452]	; (801ad88 <finsh_compile+0xa64>)
 801abc4:	681b      	ldr	r3, [r3, #0]
 801abc6:	221b      	movs	r2, #27
 801abc8:	701a      	strb	r2, [r3, #0]
 801abca:	4b6f      	ldr	r3, [pc, #444]	; (801ad88 <finsh_compile+0xa64>)
 801abcc:	681b      	ldr	r3, [r3, #0]
 801abce:	3301      	adds	r3, #1
 801abd0:	4a6d      	ldr	r2, [pc, #436]	; (801ad88 <finsh_compile+0xa64>)
 801abd2:	6013      	str	r3, [r2, #0]
            break;
 801abd4:	f000 bf85 	b.w	801bae2 <finsh_compile+0x17be>
 801abd8:	f000 bf83 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SHL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHL_BYTE);
 801abdc:	687b      	ldr	r3, [r7, #4]
 801abde:	785b      	ldrb	r3, [r3, #1]
 801abe0:	2b01      	cmp	r3, #1
 801abe2:	d109      	bne.n	801abf8 <finsh_compile+0x8d4>
 801abe4:	4b68      	ldr	r3, [pc, #416]	; (801ad88 <finsh_compile+0xa64>)
 801abe6:	681b      	ldr	r3, [r3, #0]
 801abe8:	221c      	movs	r2, #28
 801abea:	701a      	strb	r2, [r3, #0]
 801abec:	4b66      	ldr	r3, [pc, #408]	; (801ad88 <finsh_compile+0xa64>)
 801abee:	681b      	ldr	r3, [r3, #0]
 801abf0:	3301      	adds	r3, #1
 801abf2:	4a65      	ldr	r2, [pc, #404]	; (801ad88 <finsh_compile+0xa64>)
 801abf4:	6013      	str	r3, [r2, #0]
 801abf6:	e01c      	b.n	801ac32 <finsh_compile+0x90e>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHL_WORD);
 801abf8:	687b      	ldr	r3, [r7, #4]
 801abfa:	785b      	ldrb	r3, [r3, #1]
 801abfc:	2b02      	cmp	r3, #2
 801abfe:	d109      	bne.n	801ac14 <finsh_compile+0x8f0>
 801ac00:	4b61      	ldr	r3, [pc, #388]	; (801ad88 <finsh_compile+0xa64>)
 801ac02:	681b      	ldr	r3, [r3, #0]
 801ac04:	221d      	movs	r2, #29
 801ac06:	701a      	strb	r2, [r3, #0]
 801ac08:	4b5f      	ldr	r3, [pc, #380]	; (801ad88 <finsh_compile+0xa64>)
 801ac0a:	681b      	ldr	r3, [r3, #0]
 801ac0c:	3301      	adds	r3, #1
 801ac0e:	4a5e      	ldr	r2, [pc, #376]	; (801ad88 <finsh_compile+0xa64>)
 801ac10:	6013      	str	r3, [r2, #0]
 801ac12:	e00e      	b.n	801ac32 <finsh_compile+0x90e>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHL_DWORD);
 801ac14:	687b      	ldr	r3, [r7, #4]
 801ac16:	785b      	ldrb	r3, [r3, #1]
 801ac18:	2b03      	cmp	r3, #3
 801ac1a:	d10a      	bne.n	801ac32 <finsh_compile+0x90e>
 801ac1c:	4b5a      	ldr	r3, [pc, #360]	; (801ad88 <finsh_compile+0xa64>)
 801ac1e:	681b      	ldr	r3, [r3, #0]
 801ac20:	221e      	movs	r2, #30
 801ac22:	701a      	strb	r2, [r3, #0]
 801ac24:	4b58      	ldr	r3, [pc, #352]	; (801ad88 <finsh_compile+0xa64>)
 801ac26:	681b      	ldr	r3, [r3, #0]
 801ac28:	3301      	adds	r3, #1
 801ac2a:	4a57      	ldr	r2, [pc, #348]	; (801ad88 <finsh_compile+0xa64>)
 801ac2c:	6013      	str	r3, [r2, #0]
            break;
 801ac2e:	f000 bf58 	b.w	801bae2 <finsh_compile+0x17be>
 801ac32:	f000 bf56 	b.w	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SHR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHR_BYTE);
 801ac36:	687b      	ldr	r3, [r7, #4]
 801ac38:	785b      	ldrb	r3, [r3, #1]
 801ac3a:	2b01      	cmp	r3, #1
 801ac3c:	d109      	bne.n	801ac52 <finsh_compile+0x92e>
 801ac3e:	4b52      	ldr	r3, [pc, #328]	; (801ad88 <finsh_compile+0xa64>)
 801ac40:	681b      	ldr	r3, [r3, #0]
 801ac42:	221f      	movs	r2, #31
 801ac44:	701a      	strb	r2, [r3, #0]
 801ac46:	4b50      	ldr	r3, [pc, #320]	; (801ad88 <finsh_compile+0xa64>)
 801ac48:	681b      	ldr	r3, [r3, #0]
 801ac4a:	3301      	adds	r3, #1
 801ac4c:	4a4e      	ldr	r2, [pc, #312]	; (801ad88 <finsh_compile+0xa64>)
 801ac4e:	6013      	str	r3, [r2, #0]
 801ac50:	e01c      	b.n	801ac8c <finsh_compile+0x968>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHR_WORD);
 801ac52:	687b      	ldr	r3, [r7, #4]
 801ac54:	785b      	ldrb	r3, [r3, #1]
 801ac56:	2b02      	cmp	r3, #2
 801ac58:	d109      	bne.n	801ac6e <finsh_compile+0x94a>
 801ac5a:	4b4b      	ldr	r3, [pc, #300]	; (801ad88 <finsh_compile+0xa64>)
 801ac5c:	681b      	ldr	r3, [r3, #0]
 801ac5e:	2220      	movs	r2, #32
 801ac60:	701a      	strb	r2, [r3, #0]
 801ac62:	4b49      	ldr	r3, [pc, #292]	; (801ad88 <finsh_compile+0xa64>)
 801ac64:	681b      	ldr	r3, [r3, #0]
 801ac66:	3301      	adds	r3, #1
 801ac68:	4a47      	ldr	r2, [pc, #284]	; (801ad88 <finsh_compile+0xa64>)
 801ac6a:	6013      	str	r3, [r2, #0]
 801ac6c:	e00e      	b.n	801ac8c <finsh_compile+0x968>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHR_DWORD);
 801ac6e:	687b      	ldr	r3, [r7, #4]
 801ac70:	785b      	ldrb	r3, [r3, #1]
 801ac72:	2b03      	cmp	r3, #3
 801ac74:	d10a      	bne.n	801ac8c <finsh_compile+0x968>
 801ac76:	4b44      	ldr	r3, [pc, #272]	; (801ad88 <finsh_compile+0xa64>)
 801ac78:	681b      	ldr	r3, [r3, #0]
 801ac7a:	2221      	movs	r2, #33	; 0x21
 801ac7c:	701a      	strb	r2, [r3, #0]
 801ac7e:	4b42      	ldr	r3, [pc, #264]	; (801ad88 <finsh_compile+0xa64>)
 801ac80:	681b      	ldr	r3, [r3, #0]
 801ac82:	3301      	adds	r3, #1
 801ac84:	4a40      	ldr	r2, [pc, #256]	; (801ad88 <finsh_compile+0xa64>)
 801ac86:	6013      	str	r3, [r2, #0]
            break;
 801ac88:	f000 bf2b 	b.w	801bae2 <finsh_compile+0x17be>
 801ac8c:	f000 bf29 	b.w	801bae2 <finsh_compile+0x17be>
        case FINSH_NODE_SYS_FUNC:
            {
                int parameters;
                struct finsh_node* sibling;

                parameters = 0;
 801ac90:	2300      	movs	r3, #0
 801ac92:	627b      	str	r3, [r7, #36]	; 0x24
                if (finsh_node_child(node) != NULL)
 801ac94:	687b      	ldr	r3, [r7, #4]
 801ac96:	691b      	ldr	r3, [r3, #16]
 801ac98:	2b00      	cmp	r3, #0
 801ac9a:	d022      	beq.n	801ace2 <finsh_compile+0x9be>
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
 801ac9c:	687b      	ldr	r3, [r7, #4]
 801ac9e:	691b      	ldr	r3, [r3, #16]
 801aca0:	68db      	ldr	r3, [r3, #12]
 801aca2:	623b      	str	r3, [r7, #32]
                    while (sibling != NULL)
 801aca4:	e005      	b.n	801acb2 <finsh_compile+0x98e>
                    {
                        parameters ++;
 801aca6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aca8:	3301      	adds	r3, #1
 801acaa:	627b      	str	r3, [r7, #36]	; 0x24
                        sibling = finsh_node_sibling(sibling);
 801acac:	6a3b      	ldr	r3, [r7, #32]
 801acae:	68db      	ldr	r3, [r3, #12]
 801acb0:	623b      	str	r3, [r7, #32]

                parameters = 0;
                if (finsh_node_child(node) != NULL)
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
                    while (sibling != NULL)
 801acb2:	6a3b      	ldr	r3, [r7, #32]
 801acb4:	2b00      	cmp	r3, #0
 801acb6:	d1f6      	bne.n	801aca6 <finsh_compile+0x982>

                    /* load address of function */
                    // finsh_code_dword((long)&(node->var->value.ptr));

                    /* syscall parameters */
                    finsh_code_byte(FINSH_OP_SYSCALL);
 801acb8:	4b33      	ldr	r3, [pc, #204]	; (801ad88 <finsh_compile+0xa64>)
 801acba:	681b      	ldr	r3, [r3, #0]
 801acbc:	222c      	movs	r2, #44	; 0x2c
 801acbe:	701a      	strb	r2, [r3, #0]
 801acc0:	4b31      	ldr	r3, [pc, #196]	; (801ad88 <finsh_compile+0xa64>)
 801acc2:	681b      	ldr	r3, [r3, #0]
 801acc4:	3301      	adds	r3, #1
 801acc6:	4a30      	ldr	r2, [pc, #192]	; (801ad88 <finsh_compile+0xa64>)
 801acc8:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(parameters);
 801acca:	4b2f      	ldr	r3, [pc, #188]	; (801ad88 <finsh_compile+0xa64>)
 801accc:	681b      	ldr	r3, [r3, #0]
 801acce:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801acd0:	b2d2      	uxtb	r2, r2
 801acd2:	701a      	strb	r2, [r3, #0]
 801acd4:	4b2c      	ldr	r3, [pc, #176]	; (801ad88 <finsh_compile+0xa64>)
 801acd6:	681b      	ldr	r3, [r3, #0]
 801acd8:	3301      	adds	r3, #1
 801acda:	4a2b      	ldr	r2, [pc, #172]	; (801ad88 <finsh_compile+0xa64>)
 801acdc:	6013      	str	r3, [r2, #0]
                }
            }
            break;
 801acde:	f000 bf00 	b.w	801bae2 <finsh_compile+0x17be>
 801ace2:	f000 befe 	b.w	801bae2 <finsh_compile+0x17be>

        /* assign expression */
        case FINSH_NODE_SYS_ASSIGN:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801ace6:	687b      	ldr	r3, [r7, #4]
 801ace8:	691b      	ldr	r3, [r3, #16]
 801acea:	2b00      	cmp	r3, #0
 801acec:	d04e      	beq.n	801ad8c <finsh_compile+0xa68>
 801acee:	687b      	ldr	r3, [r7, #4]
 801acf0:	691b      	ldr	r3, [r3, #16]
 801acf2:	781b      	ldrb	r3, [r3, #0]
 801acf4:	2b01      	cmp	r3, #1
 801acf6:	d149      	bne.n	801ad8c <finsh_compile+0xa68>
            {
                switch (finsh_node_child(node)->data_type)
 801acf8:	687b      	ldr	r3, [r7, #4]
 801acfa:	691b      	ldr	r3, [r3, #16]
 801acfc:	785b      	ldrb	r3, [r3, #1]
 801acfe:	2b02      	cmp	r3, #2
 801ad00:	d016      	beq.n	801ad30 <finsh_compile+0xa0c>
 801ad02:	2b03      	cmp	r3, #3
 801ad04:	d027      	beq.n	801ad56 <finsh_compile+0xa32>
 801ad06:	2b01      	cmp	r3, #1
 801ad08:	d138      	bne.n	801ad7c <finsh_compile+0xa58>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801ad0a:	4b1f      	ldr	r3, [pc, #124]	; (801ad88 <finsh_compile+0xa64>)
 801ad0c:	681b      	ldr	r3, [r3, #0]
 801ad0e:	2228      	movs	r2, #40	; 0x28
 801ad10:	701a      	strb	r2, [r3, #0]
 801ad12:	4b1d      	ldr	r3, [pc, #116]	; (801ad88 <finsh_compile+0xa64>)
 801ad14:	681b      	ldr	r3, [r3, #0]
 801ad16:	3301      	adds	r3, #1
 801ad18:	4a1b      	ldr	r2, [pc, #108]	; (801ad88 <finsh_compile+0xa64>)
 801ad1a:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801ad1c:	4b1a      	ldr	r3, [pc, #104]	; (801ad88 <finsh_compile+0xa64>)
 801ad1e:	681b      	ldr	r3, [r3, #0]
 801ad20:	222d      	movs	r2, #45	; 0x2d
 801ad22:	701a      	strb	r2, [r3, #0]
 801ad24:	4b18      	ldr	r3, [pc, #96]	; (801ad88 <finsh_compile+0xa64>)
 801ad26:	681b      	ldr	r3, [r3, #0]
 801ad28:	3301      	adds	r3, #1
 801ad2a:	4a17      	ldr	r2, [pc, #92]	; (801ad88 <finsh_compile+0xa64>)
 801ad2c:	6013      	str	r3, [r2, #0]
                    break;
 801ad2e:	e029      	b.n	801ad84 <finsh_compile+0xa60>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801ad30:	4b15      	ldr	r3, [pc, #84]	; (801ad88 <finsh_compile+0xa64>)
 801ad32:	681b      	ldr	r3, [r3, #0]
 801ad34:	2229      	movs	r2, #41	; 0x29
 801ad36:	701a      	strb	r2, [r3, #0]
 801ad38:	4b13      	ldr	r3, [pc, #76]	; (801ad88 <finsh_compile+0xa64>)
 801ad3a:	681b      	ldr	r3, [r3, #0]
 801ad3c:	3301      	adds	r3, #1
 801ad3e:	4a12      	ldr	r2, [pc, #72]	; (801ad88 <finsh_compile+0xa64>)
 801ad40:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801ad42:	4b11      	ldr	r3, [pc, #68]	; (801ad88 <finsh_compile+0xa64>)
 801ad44:	681b      	ldr	r3, [r3, #0]
 801ad46:	222e      	movs	r2, #46	; 0x2e
 801ad48:	701a      	strb	r2, [r3, #0]
 801ad4a:	4b0f      	ldr	r3, [pc, #60]	; (801ad88 <finsh_compile+0xa64>)
 801ad4c:	681b      	ldr	r3, [r3, #0]
 801ad4e:	3301      	adds	r3, #1
 801ad50:	4a0d      	ldr	r2, [pc, #52]	; (801ad88 <finsh_compile+0xa64>)
 801ad52:	6013      	str	r3, [r2, #0]
                    break;
 801ad54:	e016      	b.n	801ad84 <finsh_compile+0xa60>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801ad56:	4b0c      	ldr	r3, [pc, #48]	; (801ad88 <finsh_compile+0xa64>)
 801ad58:	681b      	ldr	r3, [r3, #0]
 801ad5a:	222a      	movs	r2, #42	; 0x2a
 801ad5c:	701a      	strb	r2, [r3, #0]
 801ad5e:	4b0a      	ldr	r3, [pc, #40]	; (801ad88 <finsh_compile+0xa64>)
 801ad60:	681b      	ldr	r3, [r3, #0]
 801ad62:	3301      	adds	r3, #1
 801ad64:	4a08      	ldr	r2, [pc, #32]	; (801ad88 <finsh_compile+0xa64>)
 801ad66:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801ad68:	4b07      	ldr	r3, [pc, #28]	; (801ad88 <finsh_compile+0xa64>)
 801ad6a:	681b      	ldr	r3, [r3, #0]
 801ad6c:	222f      	movs	r2, #47	; 0x2f
 801ad6e:	701a      	strb	r2, [r3, #0]
 801ad70:	4b05      	ldr	r3, [pc, #20]	; (801ad88 <finsh_compile+0xa64>)
 801ad72:	681b      	ldr	r3, [r3, #0]
 801ad74:	3301      	adds	r3, #1
 801ad76:	4a04      	ldr	r2, [pc, #16]	; (801ad88 <finsh_compile+0xa64>)
 801ad78:	6013      	str	r3, [r2, #0]
                    break;
 801ad7a:	e003      	b.n	801ad84 <finsh_compile+0xa60>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801ad7c:	2003      	movs	r0, #3
 801ad7e:	f001 f81d 	bl	801bdbc <finsh_error_set>
                }
            }
 801ad82:	e051      	b.n	801ae28 <finsh_compile+0xb04>
 801ad84:	e050      	b.n	801ae28 <finsh_compile+0xb04>
 801ad86:	bf00      	nop
 801ad88:	200126e4 	.word	0x200126e4
            else if (finsh_node_child(node)->node_type == FINSH_NODE_SYS_GETVALUE)
 801ad8c:	687b      	ldr	r3, [r7, #4]
 801ad8e:	691b      	ldr	r3, [r3, #16]
 801ad90:	781b      	ldrb	r3, [r3, #0]
 801ad92:	2b19      	cmp	r3, #25
 801ad94:	d148      	bne.n	801ae28 <finsh_compile+0xb04>
            {
                switch ((finsh_node_child(node)->data_type) & 0x0F)
 801ad96:	687b      	ldr	r3, [r7, #4]
 801ad98:	691b      	ldr	r3, [r3, #16]
 801ad9a:	785b      	ldrb	r3, [r3, #1]
 801ad9c:	f003 030f 	and.w	r3, r3, #15
 801ada0:	2b02      	cmp	r3, #2
 801ada2:	d016      	beq.n	801add2 <finsh_compile+0xaae>
 801ada4:	2b03      	cmp	r3, #3
 801ada6:	d027      	beq.n	801adf8 <finsh_compile+0xad4>
 801ada8:	2b01      	cmp	r3, #1
 801adaa:	d138      	bne.n	801ae1e <finsh_compile+0xafa>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801adac:	4b89      	ldr	r3, [pc, #548]	; (801afd4 <finsh_compile+0xcb0>)
 801adae:	681b      	ldr	r3, [r3, #0]
 801adb0:	2228      	movs	r2, #40	; 0x28
 801adb2:	701a      	strb	r2, [r3, #0]
 801adb4:	4b87      	ldr	r3, [pc, #540]	; (801afd4 <finsh_compile+0xcb0>)
 801adb6:	681b      	ldr	r3, [r3, #0]
 801adb8:	3301      	adds	r3, #1
 801adba:	4a86      	ldr	r2, [pc, #536]	; (801afd4 <finsh_compile+0xcb0>)
 801adbc:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801adbe:	4b85      	ldr	r3, [pc, #532]	; (801afd4 <finsh_compile+0xcb0>)
 801adc0:	681b      	ldr	r3, [r3, #0]
 801adc2:	222d      	movs	r2, #45	; 0x2d
 801adc4:	701a      	strb	r2, [r3, #0]
 801adc6:	4b83      	ldr	r3, [pc, #524]	; (801afd4 <finsh_compile+0xcb0>)
 801adc8:	681b      	ldr	r3, [r3, #0]
 801adca:	3301      	adds	r3, #1
 801adcc:	4a81      	ldr	r2, [pc, #516]	; (801afd4 <finsh_compile+0xcb0>)
 801adce:	6013      	str	r3, [r2, #0]
                    break;
 801add0:	e02a      	b.n	801ae28 <finsh_compile+0xb04>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801add2:	4b80      	ldr	r3, [pc, #512]	; (801afd4 <finsh_compile+0xcb0>)
 801add4:	681b      	ldr	r3, [r3, #0]
 801add6:	2229      	movs	r2, #41	; 0x29
 801add8:	701a      	strb	r2, [r3, #0]
 801adda:	4b7e      	ldr	r3, [pc, #504]	; (801afd4 <finsh_compile+0xcb0>)
 801addc:	681b      	ldr	r3, [r3, #0]
 801adde:	3301      	adds	r3, #1
 801ade0:	4a7c      	ldr	r2, [pc, #496]	; (801afd4 <finsh_compile+0xcb0>)
 801ade2:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801ade4:	4b7b      	ldr	r3, [pc, #492]	; (801afd4 <finsh_compile+0xcb0>)
 801ade6:	681b      	ldr	r3, [r3, #0]
 801ade8:	222e      	movs	r2, #46	; 0x2e
 801adea:	701a      	strb	r2, [r3, #0]
 801adec:	4b79      	ldr	r3, [pc, #484]	; (801afd4 <finsh_compile+0xcb0>)
 801adee:	681b      	ldr	r3, [r3, #0]
 801adf0:	3301      	adds	r3, #1
 801adf2:	4a78      	ldr	r2, [pc, #480]	; (801afd4 <finsh_compile+0xcb0>)
 801adf4:	6013      	str	r3, [r2, #0]
                    break;
 801adf6:	e017      	b.n	801ae28 <finsh_compile+0xb04>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801adf8:	4b76      	ldr	r3, [pc, #472]	; (801afd4 <finsh_compile+0xcb0>)
 801adfa:	681b      	ldr	r3, [r3, #0]
 801adfc:	222a      	movs	r2, #42	; 0x2a
 801adfe:	701a      	strb	r2, [r3, #0]
 801ae00:	4b74      	ldr	r3, [pc, #464]	; (801afd4 <finsh_compile+0xcb0>)
 801ae02:	681b      	ldr	r3, [r3, #0]
 801ae04:	3301      	adds	r3, #1
 801ae06:	4a73      	ldr	r2, [pc, #460]	; (801afd4 <finsh_compile+0xcb0>)
 801ae08:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801ae0a:	4b72      	ldr	r3, [pc, #456]	; (801afd4 <finsh_compile+0xcb0>)
 801ae0c:	681b      	ldr	r3, [r3, #0]
 801ae0e:	222f      	movs	r2, #47	; 0x2f
 801ae10:	701a      	strb	r2, [r3, #0]
 801ae12:	4b70      	ldr	r3, [pc, #448]	; (801afd4 <finsh_compile+0xcb0>)
 801ae14:	681b      	ldr	r3, [r3, #0]
 801ae16:	3301      	adds	r3, #1
 801ae18:	4a6e      	ldr	r2, [pc, #440]	; (801afd4 <finsh_compile+0xcb0>)
 801ae1a:	6013      	str	r3, [r2, #0]
                    break;
 801ae1c:	e004      	b.n	801ae28 <finsh_compile+0xb04>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801ae1e:	2003      	movs	r0, #3
 801ae20:	f000 ffcc 	bl	801bdbc <finsh_error_set>
                }
            }
            break;
 801ae24:	f000 be5d 	b.w	801bae2 <finsh_compile+0x17be>
 801ae28:	f000 be5b 	b.w	801bae2 <finsh_compile+0x17be>

        /* pre-increase */
        case FINSH_NODE_SYS_PREINC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801ae2c:	687b      	ldr	r3, [r7, #4]
 801ae2e:	691b      	ldr	r3, [r3, #16]
 801ae30:	2b00      	cmp	r3, #0
 801ae32:	f000 813a 	beq.w	801b0aa <finsh_compile+0xd86>
 801ae36:	687b      	ldr	r3, [r7, #4]
 801ae38:	691b      	ldr	r3, [r3, #16]
 801ae3a:	781b      	ldrb	r3, [r3, #0]
 801ae3c:	2b01      	cmp	r3, #1
 801ae3e:	f040 8134 	bne.w	801b0aa <finsh_compile+0xd86>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801ae42:	687b      	ldr	r3, [r7, #4]
 801ae44:	691b      	ldr	r3, [r3, #16]
 801ae46:	689b      	ldr	r3, [r3, #8]
 801ae48:	617b      	str	r3, [r7, #20]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
 801ae4a:	687b      	ldr	r3, [r7, #4]
 801ae4c:	785b      	ldrb	r3, [r3, #1]
 801ae4e:	2b02      	cmp	r3, #2
 801ae50:	d060      	beq.n	801af14 <finsh_compile+0xbf0>
 801ae52:	2b03      	cmp	r3, #3
 801ae54:	f000 80c0 	beq.w	801afd8 <finsh_compile+0xcb4>
 801ae58:	2b01      	cmp	r3, #1
 801ae5a:	d001      	beq.n	801ae60 <finsh_compile+0xb3c>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
 801ae5c:	f000 be41 	b.w	801bae2 <finsh_compile+0x17be>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801ae60:	4b5c      	ldr	r3, [pc, #368]	; (801afd4 <finsh_compile+0xcb0>)
 801ae62:	681b      	ldr	r3, [r3, #0]
 801ae64:	2225      	movs	r2, #37	; 0x25
 801ae66:	701a      	strb	r2, [r3, #0]
 801ae68:	4b5a      	ldr	r3, [pc, #360]	; (801afd4 <finsh_compile+0xcb0>)
 801ae6a:	681b      	ldr	r3, [r3, #0]
 801ae6c:	3301      	adds	r3, #1
 801ae6e:	4a59      	ldr	r2, [pc, #356]	; (801afd4 <finsh_compile+0xcb0>)
 801ae70:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801ae72:	4b58      	ldr	r3, [pc, #352]	; (801afd4 <finsh_compile+0xcb0>)
 801ae74:	681b      	ldr	r3, [r3, #0]
 801ae76:	697a      	ldr	r2, [r7, #20]
 801ae78:	3214      	adds	r2, #20
 801ae7a:	b2d2      	uxtb	r2, r2
 801ae7c:	701a      	strb	r2, [r3, #0]
 801ae7e:	4b55      	ldr	r3, [pc, #340]	; (801afd4 <finsh_compile+0xcb0>)
 801ae80:	681b      	ldr	r3, [r3, #0]
 801ae82:	3301      	adds	r3, #1
 801ae84:	697a      	ldr	r2, [r7, #20]
 801ae86:	3214      	adds	r2, #20
 801ae88:	0a12      	lsrs	r2, r2, #8
 801ae8a:	b2d2      	uxtb	r2, r2
 801ae8c:	701a      	strb	r2, [r3, #0]
 801ae8e:	4b51      	ldr	r3, [pc, #324]	; (801afd4 <finsh_compile+0xcb0>)
 801ae90:	681b      	ldr	r3, [r3, #0]
 801ae92:	3302      	adds	r3, #2
 801ae94:	697a      	ldr	r2, [r7, #20]
 801ae96:	3214      	adds	r2, #20
 801ae98:	0c12      	lsrs	r2, r2, #16
 801ae9a:	b2d2      	uxtb	r2, r2
 801ae9c:	701a      	strb	r2, [r3, #0]
 801ae9e:	4b4d      	ldr	r3, [pc, #308]	; (801afd4 <finsh_compile+0xcb0>)
 801aea0:	681b      	ldr	r3, [r3, #0]
 801aea2:	3303      	adds	r3, #3
 801aea4:	697a      	ldr	r2, [r7, #20]
 801aea6:	3214      	adds	r2, #20
 801aea8:	0e12      	lsrs	r2, r2, #24
 801aeaa:	b2d2      	uxtb	r2, r2
 801aeac:	701a      	strb	r2, [r3, #0]
 801aeae:	4b49      	ldr	r3, [pc, #292]	; (801afd4 <finsh_compile+0xcb0>)
 801aeb0:	681b      	ldr	r3, [r3, #0]
 801aeb2:	3304      	adds	r3, #4
 801aeb4:	4a47      	ldr	r2, [pc, #284]	; (801afd4 <finsh_compile+0xcb0>)
 801aeb6:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801aeb8:	4b46      	ldr	r3, [pc, #280]	; (801afd4 <finsh_compile+0xcb0>)
 801aeba:	681b      	ldr	r3, [r3, #0]
 801aebc:	2222      	movs	r2, #34	; 0x22
 801aebe:	701a      	strb	r2, [r3, #0]
 801aec0:	4b44      	ldr	r3, [pc, #272]	; (801afd4 <finsh_compile+0xcb0>)
 801aec2:	681b      	ldr	r3, [r3, #0]
 801aec4:	3301      	adds	r3, #1
 801aec6:	4a43      	ldr	r2, [pc, #268]	; (801afd4 <finsh_compile+0xcb0>)
 801aec8:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801aeca:	4b42      	ldr	r3, [pc, #264]	; (801afd4 <finsh_compile+0xcb0>)
 801aecc:	681b      	ldr	r3, [r3, #0]
 801aece:	2201      	movs	r2, #1
 801aed0:	701a      	strb	r2, [r3, #0]
 801aed2:	4b40      	ldr	r3, [pc, #256]	; (801afd4 <finsh_compile+0xcb0>)
 801aed4:	681b      	ldr	r3, [r3, #0]
 801aed6:	3301      	adds	r3, #1
 801aed8:	4a3e      	ldr	r2, [pc, #248]	; (801afd4 <finsh_compile+0xcb0>)
 801aeda:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
 801aedc:	4b3d      	ldr	r3, [pc, #244]	; (801afd4 <finsh_compile+0xcb0>)
 801aede:	681b      	ldr	r3, [r3, #0]
 801aee0:	2201      	movs	r2, #1
 801aee2:	701a      	strb	r2, [r3, #0]
 801aee4:	4b3b      	ldr	r3, [pc, #236]	; (801afd4 <finsh_compile+0xcb0>)
 801aee6:	681b      	ldr	r3, [r3, #0]
 801aee8:	3301      	adds	r3, #1
 801aeea:	4a3a      	ldr	r2, [pc, #232]	; (801afd4 <finsh_compile+0xcb0>)
 801aeec:	6013      	str	r3, [r2, #0]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801aeee:	4b39      	ldr	r3, [pc, #228]	; (801afd4 <finsh_compile+0xcb0>)
 801aef0:	681b      	ldr	r3, [r3, #0]
 801aef2:	2228      	movs	r2, #40	; 0x28
 801aef4:	701a      	strb	r2, [r3, #0]
 801aef6:	4b37      	ldr	r3, [pc, #220]	; (801afd4 <finsh_compile+0xcb0>)
 801aef8:	681b      	ldr	r3, [r3, #0]
 801aefa:	3301      	adds	r3, #1
 801aefc:	4a35      	ldr	r2, [pc, #212]	; (801afd4 <finsh_compile+0xcb0>)
 801aefe:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801af00:	4b34      	ldr	r3, [pc, #208]	; (801afd4 <finsh_compile+0xcb0>)
 801af02:	681b      	ldr	r3, [r3, #0]
 801af04:	222f      	movs	r2, #47	; 0x2f
 801af06:	701a      	strb	r2, [r3, #0]
 801af08:	4b32      	ldr	r3, [pc, #200]	; (801afd4 <finsh_compile+0xcb0>)
 801af0a:	681b      	ldr	r3, [r3, #0]
 801af0c:	3301      	adds	r3, #1
 801af0e:	4a31      	ldr	r2, [pc, #196]	; (801afd4 <finsh_compile+0xcb0>)
 801af10:	6013      	str	r3, [r2, #0]

                    break;
 801af12:	e0ca      	b.n	801b0aa <finsh_compile+0xd86>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801af14:	4b2f      	ldr	r3, [pc, #188]	; (801afd4 <finsh_compile+0xcb0>)
 801af16:	681b      	ldr	r3, [r3, #0]
 801af18:	2226      	movs	r2, #38	; 0x26
 801af1a:	701a      	strb	r2, [r3, #0]
 801af1c:	4b2d      	ldr	r3, [pc, #180]	; (801afd4 <finsh_compile+0xcb0>)
 801af1e:	681b      	ldr	r3, [r3, #0]
 801af20:	3301      	adds	r3, #1
 801af22:	4a2c      	ldr	r2, [pc, #176]	; (801afd4 <finsh_compile+0xcb0>)
 801af24:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801af26:	4b2b      	ldr	r3, [pc, #172]	; (801afd4 <finsh_compile+0xcb0>)
 801af28:	681b      	ldr	r3, [r3, #0]
 801af2a:	697a      	ldr	r2, [r7, #20]
 801af2c:	3214      	adds	r2, #20
 801af2e:	b2d2      	uxtb	r2, r2
 801af30:	701a      	strb	r2, [r3, #0]
 801af32:	4b28      	ldr	r3, [pc, #160]	; (801afd4 <finsh_compile+0xcb0>)
 801af34:	681b      	ldr	r3, [r3, #0]
 801af36:	3301      	adds	r3, #1
 801af38:	697a      	ldr	r2, [r7, #20]
 801af3a:	3214      	adds	r2, #20
 801af3c:	0a12      	lsrs	r2, r2, #8
 801af3e:	b2d2      	uxtb	r2, r2
 801af40:	701a      	strb	r2, [r3, #0]
 801af42:	4b24      	ldr	r3, [pc, #144]	; (801afd4 <finsh_compile+0xcb0>)
 801af44:	681b      	ldr	r3, [r3, #0]
 801af46:	3302      	adds	r3, #2
 801af48:	697a      	ldr	r2, [r7, #20]
 801af4a:	3214      	adds	r2, #20
 801af4c:	0c12      	lsrs	r2, r2, #16
 801af4e:	b2d2      	uxtb	r2, r2
 801af50:	701a      	strb	r2, [r3, #0]
 801af52:	4b20      	ldr	r3, [pc, #128]	; (801afd4 <finsh_compile+0xcb0>)
 801af54:	681b      	ldr	r3, [r3, #0]
 801af56:	3303      	adds	r3, #3
 801af58:	697a      	ldr	r2, [r7, #20]
 801af5a:	3214      	adds	r2, #20
 801af5c:	0e12      	lsrs	r2, r2, #24
 801af5e:	b2d2      	uxtb	r2, r2
 801af60:	701a      	strb	r2, [r3, #0]
 801af62:	4b1c      	ldr	r3, [pc, #112]	; (801afd4 <finsh_compile+0xcb0>)
 801af64:	681b      	ldr	r3, [r3, #0]
 801af66:	3304      	adds	r3, #4
 801af68:	4a1a      	ldr	r2, [pc, #104]	; (801afd4 <finsh_compile+0xcb0>)
 801af6a:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801af6c:	4b19      	ldr	r3, [pc, #100]	; (801afd4 <finsh_compile+0xcb0>)
 801af6e:	681b      	ldr	r3, [r3, #0]
 801af70:	2223      	movs	r2, #35	; 0x23
 801af72:	701a      	strb	r2, [r3, #0]
 801af74:	4b17      	ldr	r3, [pc, #92]	; (801afd4 <finsh_compile+0xcb0>)
 801af76:	681b      	ldr	r3, [r3, #0]
 801af78:	3301      	adds	r3, #1
 801af7a:	4a16      	ldr	r2, [pc, #88]	; (801afd4 <finsh_compile+0xcb0>)
 801af7c:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801af7e:	4b15      	ldr	r3, [pc, #84]	; (801afd4 <finsh_compile+0xcb0>)
 801af80:	681b      	ldr	r3, [r3, #0]
 801af82:	2201      	movs	r2, #1
 801af84:	701a      	strb	r2, [r3, #0]
 801af86:	4b13      	ldr	r3, [pc, #76]	; (801afd4 <finsh_compile+0xcb0>)
 801af88:	681b      	ldr	r3, [r3, #0]
 801af8a:	3301      	adds	r3, #1
 801af8c:	2200      	movs	r2, #0
 801af8e:	701a      	strb	r2, [r3, #0]
 801af90:	4b10      	ldr	r3, [pc, #64]	; (801afd4 <finsh_compile+0xcb0>)
 801af92:	681b      	ldr	r3, [r3, #0]
 801af94:	3302      	adds	r3, #2
 801af96:	4a0f      	ldr	r2, [pc, #60]	; (801afd4 <finsh_compile+0xcb0>)
 801af98:	6013      	str	r3, [r2, #0]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
 801af9a:	4b0e      	ldr	r3, [pc, #56]	; (801afd4 <finsh_compile+0xcb0>)
 801af9c:	681b      	ldr	r3, [r3, #0]
 801af9e:	2202      	movs	r2, #2
 801afa0:	701a      	strb	r2, [r3, #0]
 801afa2:	4b0c      	ldr	r3, [pc, #48]	; (801afd4 <finsh_compile+0xcb0>)
 801afa4:	681b      	ldr	r3, [r3, #0]
 801afa6:	3301      	adds	r3, #1
 801afa8:	4a0a      	ldr	r2, [pc, #40]	; (801afd4 <finsh_compile+0xcb0>)
 801afaa:	6013      	str	r3, [r2, #0]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801afac:	4b09      	ldr	r3, [pc, #36]	; (801afd4 <finsh_compile+0xcb0>)
 801afae:	681b      	ldr	r3, [r3, #0]
 801afb0:	2229      	movs	r2, #41	; 0x29
 801afb2:	701a      	strb	r2, [r3, #0]
 801afb4:	4b07      	ldr	r3, [pc, #28]	; (801afd4 <finsh_compile+0xcb0>)
 801afb6:	681b      	ldr	r3, [r3, #0]
 801afb8:	3301      	adds	r3, #1
 801afba:	4a06      	ldr	r2, [pc, #24]	; (801afd4 <finsh_compile+0xcb0>)
 801afbc:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801afbe:	4b05      	ldr	r3, [pc, #20]	; (801afd4 <finsh_compile+0xcb0>)
 801afc0:	681b      	ldr	r3, [r3, #0]
 801afc2:	222f      	movs	r2, #47	; 0x2f
 801afc4:	701a      	strb	r2, [r3, #0]
 801afc6:	4b03      	ldr	r3, [pc, #12]	; (801afd4 <finsh_compile+0xcb0>)
 801afc8:	681b      	ldr	r3, [r3, #0]
 801afca:	3301      	adds	r3, #1
 801afcc:	4a01      	ldr	r2, [pc, #4]	; (801afd4 <finsh_compile+0xcb0>)
 801afce:	6013      	str	r3, [r2, #0]

                    break;
 801afd0:	e06b      	b.n	801b0aa <finsh_compile+0xd86>
 801afd2:	bf00      	nop
 801afd4:	200126e4 	.word	0x200126e4
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801afd8:	4b6f      	ldr	r3, [pc, #444]	; (801b198 <finsh_compile+0xe74>)
 801afda:	681b      	ldr	r3, [r3, #0]
 801afdc:	2227      	movs	r2, #39	; 0x27
 801afde:	701a      	strb	r2, [r3, #0]
 801afe0:	4b6d      	ldr	r3, [pc, #436]	; (801b198 <finsh_compile+0xe74>)
 801afe2:	681b      	ldr	r3, [r3, #0]
 801afe4:	3301      	adds	r3, #1
 801afe6:	4a6c      	ldr	r2, [pc, #432]	; (801b198 <finsh_compile+0xe74>)
 801afe8:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801afea:	4b6b      	ldr	r3, [pc, #428]	; (801b198 <finsh_compile+0xe74>)
 801afec:	681b      	ldr	r3, [r3, #0]
 801afee:	697a      	ldr	r2, [r7, #20]
 801aff0:	3214      	adds	r2, #20
 801aff2:	b2d2      	uxtb	r2, r2
 801aff4:	701a      	strb	r2, [r3, #0]
 801aff6:	4b68      	ldr	r3, [pc, #416]	; (801b198 <finsh_compile+0xe74>)
 801aff8:	681b      	ldr	r3, [r3, #0]
 801affa:	3301      	adds	r3, #1
 801affc:	697a      	ldr	r2, [r7, #20]
 801affe:	3214      	adds	r2, #20
 801b000:	0a12      	lsrs	r2, r2, #8
 801b002:	b2d2      	uxtb	r2, r2
 801b004:	701a      	strb	r2, [r3, #0]
 801b006:	4b64      	ldr	r3, [pc, #400]	; (801b198 <finsh_compile+0xe74>)
 801b008:	681b      	ldr	r3, [r3, #0]
 801b00a:	3302      	adds	r3, #2
 801b00c:	697a      	ldr	r2, [r7, #20]
 801b00e:	3214      	adds	r2, #20
 801b010:	0c12      	lsrs	r2, r2, #16
 801b012:	b2d2      	uxtb	r2, r2
 801b014:	701a      	strb	r2, [r3, #0]
 801b016:	4b60      	ldr	r3, [pc, #384]	; (801b198 <finsh_compile+0xe74>)
 801b018:	681b      	ldr	r3, [r3, #0]
 801b01a:	3303      	adds	r3, #3
 801b01c:	697a      	ldr	r2, [r7, #20]
 801b01e:	3214      	adds	r2, #20
 801b020:	0e12      	lsrs	r2, r2, #24
 801b022:	b2d2      	uxtb	r2, r2
 801b024:	701a      	strb	r2, [r3, #0]
 801b026:	4b5c      	ldr	r3, [pc, #368]	; (801b198 <finsh_compile+0xe74>)
 801b028:	681b      	ldr	r3, [r3, #0]
 801b02a:	3304      	adds	r3, #4
 801b02c:	4a5a      	ldr	r2, [pc, #360]	; (801b198 <finsh_compile+0xe74>)
 801b02e:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b030:	4b59      	ldr	r3, [pc, #356]	; (801b198 <finsh_compile+0xe74>)
 801b032:	681b      	ldr	r3, [r3, #0]
 801b034:	2224      	movs	r2, #36	; 0x24
 801b036:	701a      	strb	r2, [r3, #0]
 801b038:	4b57      	ldr	r3, [pc, #348]	; (801b198 <finsh_compile+0xe74>)
 801b03a:	681b      	ldr	r3, [r3, #0]
 801b03c:	3301      	adds	r3, #1
 801b03e:	4a56      	ldr	r2, [pc, #344]	; (801b198 <finsh_compile+0xe74>)
 801b040:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801b042:	4b55      	ldr	r3, [pc, #340]	; (801b198 <finsh_compile+0xe74>)
 801b044:	681b      	ldr	r3, [r3, #0]
 801b046:	2201      	movs	r2, #1
 801b048:	701a      	strb	r2, [r3, #0]
 801b04a:	4b53      	ldr	r3, [pc, #332]	; (801b198 <finsh_compile+0xe74>)
 801b04c:	681b      	ldr	r3, [r3, #0]
 801b04e:	3301      	adds	r3, #1
 801b050:	2200      	movs	r2, #0
 801b052:	701a      	strb	r2, [r3, #0]
 801b054:	4b50      	ldr	r3, [pc, #320]	; (801b198 <finsh_compile+0xe74>)
 801b056:	681b      	ldr	r3, [r3, #0]
 801b058:	3302      	adds	r3, #2
 801b05a:	2200      	movs	r2, #0
 801b05c:	701a      	strb	r2, [r3, #0]
 801b05e:	4b4e      	ldr	r3, [pc, #312]	; (801b198 <finsh_compile+0xe74>)
 801b060:	681b      	ldr	r3, [r3, #0]
 801b062:	3303      	adds	r3, #3
 801b064:	2200      	movs	r2, #0
 801b066:	701a      	strb	r2, [r3, #0]
 801b068:	4b4b      	ldr	r3, [pc, #300]	; (801b198 <finsh_compile+0xe74>)
 801b06a:	681b      	ldr	r3, [r3, #0]
 801b06c:	3304      	adds	r3, #4
 801b06e:	4a4a      	ldr	r2, [pc, #296]	; (801b198 <finsh_compile+0xe74>)
 801b070:	6013      	str	r3, [r2, #0]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
 801b072:	4b49      	ldr	r3, [pc, #292]	; (801b198 <finsh_compile+0xe74>)
 801b074:	681b      	ldr	r3, [r3, #0]
 801b076:	2203      	movs	r2, #3
 801b078:	701a      	strb	r2, [r3, #0]
 801b07a:	4b47      	ldr	r3, [pc, #284]	; (801b198 <finsh_compile+0xe74>)
 801b07c:	681b      	ldr	r3, [r3, #0]
 801b07e:	3301      	adds	r3, #1
 801b080:	4a45      	ldr	r2, [pc, #276]	; (801b198 <finsh_compile+0xe74>)
 801b082:	6013      	str	r3, [r2, #0]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801b084:	4b44      	ldr	r3, [pc, #272]	; (801b198 <finsh_compile+0xe74>)
 801b086:	681b      	ldr	r3, [r3, #0]
 801b088:	222a      	movs	r2, #42	; 0x2a
 801b08a:	701a      	strb	r2, [r3, #0]
 801b08c:	4b42      	ldr	r3, [pc, #264]	; (801b198 <finsh_compile+0xe74>)
 801b08e:	681b      	ldr	r3, [r3, #0]
 801b090:	3301      	adds	r3, #1
 801b092:	4a41      	ldr	r2, [pc, #260]	; (801b198 <finsh_compile+0xe74>)
 801b094:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801b096:	4b40      	ldr	r3, [pc, #256]	; (801b198 <finsh_compile+0xe74>)
 801b098:	681b      	ldr	r3, [r3, #0]
 801b09a:	222f      	movs	r2, #47	; 0x2f
 801b09c:	701a      	strb	r2, [r3, #0]
 801b09e:	4b3e      	ldr	r3, [pc, #248]	; (801b198 <finsh_compile+0xe74>)
 801b0a0:	681b      	ldr	r3, [r3, #0]
 801b0a2:	3301      	adds	r3, #1
 801b0a4:	4a3c      	ldr	r2, [pc, #240]	; (801b198 <finsh_compile+0xe74>)
 801b0a6:	6013      	str	r3, [r2, #0]

                    break;
 801b0a8:	bf00      	nop
                }
            }
            break;
 801b0aa:	f000 bd1a 	b.w	801bae2 <finsh_compile+0x17be>

        /* pre-decrease */
        case FINSH_NODE_SYS_PREDEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801b0ae:	687b      	ldr	r3, [r7, #4]
 801b0b0:	691b      	ldr	r3, [r3, #16]
 801b0b2:	2b00      	cmp	r3, #0
 801b0b4:	f000 813a 	beq.w	801b32c <finsh_compile+0x1008>
 801b0b8:	687b      	ldr	r3, [r7, #4]
 801b0ba:	691b      	ldr	r3, [r3, #16]
 801b0bc:	781b      	ldrb	r3, [r3, #0]
 801b0be:	2b01      	cmp	r3, #1
 801b0c0:	f040 8134 	bne.w	801b32c <finsh_compile+0x1008>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801b0c4:	687b      	ldr	r3, [r7, #4]
 801b0c6:	691b      	ldr	r3, [r3, #16]
 801b0c8:	689b      	ldr	r3, [r3, #8]
 801b0ca:	613b      	str	r3, [r7, #16]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
 801b0cc:	687b      	ldr	r3, [r7, #4]
 801b0ce:	785b      	ldrb	r3, [r3, #1]
 801b0d0:	2b02      	cmp	r3, #2
 801b0d2:	d063      	beq.n	801b19c <finsh_compile+0xe78>
 801b0d4:	2b03      	cmp	r3, #3
 801b0d6:	f000 80c0 	beq.w	801b25a <finsh_compile+0xf36>
 801b0da:	2b01      	cmp	r3, #1
 801b0dc:	d001      	beq.n	801b0e2 <finsh_compile+0xdbe>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
 801b0de:	f000 bd00 	b.w	801bae2 <finsh_compile+0x17be>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801b0e2:	4b2d      	ldr	r3, [pc, #180]	; (801b198 <finsh_compile+0xe74>)
 801b0e4:	681b      	ldr	r3, [r3, #0]
 801b0e6:	2225      	movs	r2, #37	; 0x25
 801b0e8:	701a      	strb	r2, [r3, #0]
 801b0ea:	4b2b      	ldr	r3, [pc, #172]	; (801b198 <finsh_compile+0xe74>)
 801b0ec:	681b      	ldr	r3, [r3, #0]
 801b0ee:	3301      	adds	r3, #1
 801b0f0:	4a29      	ldr	r2, [pc, #164]	; (801b198 <finsh_compile+0xe74>)
 801b0f2:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801b0f4:	4b28      	ldr	r3, [pc, #160]	; (801b198 <finsh_compile+0xe74>)
 801b0f6:	681b      	ldr	r3, [r3, #0]
 801b0f8:	693a      	ldr	r2, [r7, #16]
 801b0fa:	3214      	adds	r2, #20
 801b0fc:	b2d2      	uxtb	r2, r2
 801b0fe:	701a      	strb	r2, [r3, #0]
 801b100:	4b25      	ldr	r3, [pc, #148]	; (801b198 <finsh_compile+0xe74>)
 801b102:	681b      	ldr	r3, [r3, #0]
 801b104:	3301      	adds	r3, #1
 801b106:	693a      	ldr	r2, [r7, #16]
 801b108:	3214      	adds	r2, #20
 801b10a:	0a12      	lsrs	r2, r2, #8
 801b10c:	b2d2      	uxtb	r2, r2
 801b10e:	701a      	strb	r2, [r3, #0]
 801b110:	4b21      	ldr	r3, [pc, #132]	; (801b198 <finsh_compile+0xe74>)
 801b112:	681b      	ldr	r3, [r3, #0]
 801b114:	3302      	adds	r3, #2
 801b116:	693a      	ldr	r2, [r7, #16]
 801b118:	3214      	adds	r2, #20
 801b11a:	0c12      	lsrs	r2, r2, #16
 801b11c:	b2d2      	uxtb	r2, r2
 801b11e:	701a      	strb	r2, [r3, #0]
 801b120:	4b1d      	ldr	r3, [pc, #116]	; (801b198 <finsh_compile+0xe74>)
 801b122:	681b      	ldr	r3, [r3, #0]
 801b124:	3303      	adds	r3, #3
 801b126:	693a      	ldr	r2, [r7, #16]
 801b128:	3214      	adds	r2, #20
 801b12a:	0e12      	lsrs	r2, r2, #24
 801b12c:	b2d2      	uxtb	r2, r2
 801b12e:	701a      	strb	r2, [r3, #0]
 801b130:	4b19      	ldr	r3, [pc, #100]	; (801b198 <finsh_compile+0xe74>)
 801b132:	681b      	ldr	r3, [r3, #0]
 801b134:	3304      	adds	r3, #4
 801b136:	4a18      	ldr	r2, [pc, #96]	; (801b198 <finsh_compile+0xe74>)
 801b138:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801b13a:	4b17      	ldr	r3, [pc, #92]	; (801b198 <finsh_compile+0xe74>)
 801b13c:	681b      	ldr	r3, [r3, #0]
 801b13e:	2222      	movs	r2, #34	; 0x22
 801b140:	701a      	strb	r2, [r3, #0]
 801b142:	4b15      	ldr	r3, [pc, #84]	; (801b198 <finsh_compile+0xe74>)
 801b144:	681b      	ldr	r3, [r3, #0]
 801b146:	3301      	adds	r3, #1
 801b148:	4a13      	ldr	r2, [pc, #76]	; (801b198 <finsh_compile+0xe74>)
 801b14a:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801b14c:	4b12      	ldr	r3, [pc, #72]	; (801b198 <finsh_compile+0xe74>)
 801b14e:	681b      	ldr	r3, [r3, #0]
 801b150:	2201      	movs	r2, #1
 801b152:	701a      	strb	r2, [r3, #0]
 801b154:	4b10      	ldr	r3, [pc, #64]	; (801b198 <finsh_compile+0xe74>)
 801b156:	681b      	ldr	r3, [r3, #0]
 801b158:	3301      	adds	r3, #1
 801b15a:	4a0f      	ldr	r2, [pc, #60]	; (801b198 <finsh_compile+0xe74>)
 801b15c:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
 801b15e:	4b0e      	ldr	r3, [pc, #56]	; (801b198 <finsh_compile+0xe74>)
 801b160:	681b      	ldr	r3, [r3, #0]
 801b162:	2204      	movs	r2, #4
 801b164:	701a      	strb	r2, [r3, #0]
 801b166:	4b0c      	ldr	r3, [pc, #48]	; (801b198 <finsh_compile+0xe74>)
 801b168:	681b      	ldr	r3, [r3, #0]
 801b16a:	3301      	adds	r3, #1
 801b16c:	4a0a      	ldr	r2, [pc, #40]	; (801b198 <finsh_compile+0xe74>)
 801b16e:	6013      	str	r3, [r2, #0]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801b170:	4b09      	ldr	r3, [pc, #36]	; (801b198 <finsh_compile+0xe74>)
 801b172:	681b      	ldr	r3, [r3, #0]
 801b174:	2228      	movs	r2, #40	; 0x28
 801b176:	701a      	strb	r2, [r3, #0]
 801b178:	4b07      	ldr	r3, [pc, #28]	; (801b198 <finsh_compile+0xe74>)
 801b17a:	681b      	ldr	r3, [r3, #0]
 801b17c:	3301      	adds	r3, #1
 801b17e:	4a06      	ldr	r2, [pc, #24]	; (801b198 <finsh_compile+0xe74>)
 801b180:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801b182:	4b05      	ldr	r3, [pc, #20]	; (801b198 <finsh_compile+0xe74>)
 801b184:	681b      	ldr	r3, [r3, #0]
 801b186:	222f      	movs	r2, #47	; 0x2f
 801b188:	701a      	strb	r2, [r3, #0]
 801b18a:	4b03      	ldr	r3, [pc, #12]	; (801b198 <finsh_compile+0xe74>)
 801b18c:	681b      	ldr	r3, [r3, #0]
 801b18e:	3301      	adds	r3, #1
 801b190:	4a01      	ldr	r2, [pc, #4]	; (801b198 <finsh_compile+0xe74>)
 801b192:	6013      	str	r3, [r2, #0]

                    break;
 801b194:	e0ca      	b.n	801b32c <finsh_compile+0x1008>
 801b196:	bf00      	nop
 801b198:	200126e4 	.word	0x200126e4
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801b19c:	4b71      	ldr	r3, [pc, #452]	; (801b364 <finsh_compile+0x1040>)
 801b19e:	681b      	ldr	r3, [r3, #0]
 801b1a0:	2226      	movs	r2, #38	; 0x26
 801b1a2:	701a      	strb	r2, [r3, #0]
 801b1a4:	4b6f      	ldr	r3, [pc, #444]	; (801b364 <finsh_compile+0x1040>)
 801b1a6:	681b      	ldr	r3, [r3, #0]
 801b1a8:	3301      	adds	r3, #1
 801b1aa:	4a6e      	ldr	r2, [pc, #440]	; (801b364 <finsh_compile+0x1040>)
 801b1ac:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801b1ae:	4b6d      	ldr	r3, [pc, #436]	; (801b364 <finsh_compile+0x1040>)
 801b1b0:	681b      	ldr	r3, [r3, #0]
 801b1b2:	693a      	ldr	r2, [r7, #16]
 801b1b4:	3214      	adds	r2, #20
 801b1b6:	b2d2      	uxtb	r2, r2
 801b1b8:	701a      	strb	r2, [r3, #0]
 801b1ba:	4b6a      	ldr	r3, [pc, #424]	; (801b364 <finsh_compile+0x1040>)
 801b1bc:	681b      	ldr	r3, [r3, #0]
 801b1be:	3301      	adds	r3, #1
 801b1c0:	693a      	ldr	r2, [r7, #16]
 801b1c2:	3214      	adds	r2, #20
 801b1c4:	0a12      	lsrs	r2, r2, #8
 801b1c6:	b2d2      	uxtb	r2, r2
 801b1c8:	701a      	strb	r2, [r3, #0]
 801b1ca:	4b66      	ldr	r3, [pc, #408]	; (801b364 <finsh_compile+0x1040>)
 801b1cc:	681b      	ldr	r3, [r3, #0]
 801b1ce:	3302      	adds	r3, #2
 801b1d0:	693a      	ldr	r2, [r7, #16]
 801b1d2:	3214      	adds	r2, #20
 801b1d4:	0c12      	lsrs	r2, r2, #16
 801b1d6:	b2d2      	uxtb	r2, r2
 801b1d8:	701a      	strb	r2, [r3, #0]
 801b1da:	4b62      	ldr	r3, [pc, #392]	; (801b364 <finsh_compile+0x1040>)
 801b1dc:	681b      	ldr	r3, [r3, #0]
 801b1de:	3303      	adds	r3, #3
 801b1e0:	693a      	ldr	r2, [r7, #16]
 801b1e2:	3214      	adds	r2, #20
 801b1e4:	0e12      	lsrs	r2, r2, #24
 801b1e6:	b2d2      	uxtb	r2, r2
 801b1e8:	701a      	strb	r2, [r3, #0]
 801b1ea:	4b5e      	ldr	r3, [pc, #376]	; (801b364 <finsh_compile+0x1040>)
 801b1ec:	681b      	ldr	r3, [r3, #0]
 801b1ee:	3304      	adds	r3, #4
 801b1f0:	4a5c      	ldr	r2, [pc, #368]	; (801b364 <finsh_compile+0x1040>)
 801b1f2:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801b1f4:	4b5b      	ldr	r3, [pc, #364]	; (801b364 <finsh_compile+0x1040>)
 801b1f6:	681b      	ldr	r3, [r3, #0]
 801b1f8:	2223      	movs	r2, #35	; 0x23
 801b1fa:	701a      	strb	r2, [r3, #0]
 801b1fc:	4b59      	ldr	r3, [pc, #356]	; (801b364 <finsh_compile+0x1040>)
 801b1fe:	681b      	ldr	r3, [r3, #0]
 801b200:	3301      	adds	r3, #1
 801b202:	4a58      	ldr	r2, [pc, #352]	; (801b364 <finsh_compile+0x1040>)
 801b204:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801b206:	4b57      	ldr	r3, [pc, #348]	; (801b364 <finsh_compile+0x1040>)
 801b208:	681b      	ldr	r3, [r3, #0]
 801b20a:	2201      	movs	r2, #1
 801b20c:	701a      	strb	r2, [r3, #0]
 801b20e:	4b55      	ldr	r3, [pc, #340]	; (801b364 <finsh_compile+0x1040>)
 801b210:	681b      	ldr	r3, [r3, #0]
 801b212:	3301      	adds	r3, #1
 801b214:	2200      	movs	r2, #0
 801b216:	701a      	strb	r2, [r3, #0]
 801b218:	4b52      	ldr	r3, [pc, #328]	; (801b364 <finsh_compile+0x1040>)
 801b21a:	681b      	ldr	r3, [r3, #0]
 801b21c:	3302      	adds	r3, #2
 801b21e:	4a51      	ldr	r2, [pc, #324]	; (801b364 <finsh_compile+0x1040>)
 801b220:	6013      	str	r3, [r2, #0]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
 801b222:	4b50      	ldr	r3, [pc, #320]	; (801b364 <finsh_compile+0x1040>)
 801b224:	681b      	ldr	r3, [r3, #0]
 801b226:	2205      	movs	r2, #5
 801b228:	701a      	strb	r2, [r3, #0]
 801b22a:	4b4e      	ldr	r3, [pc, #312]	; (801b364 <finsh_compile+0x1040>)
 801b22c:	681b      	ldr	r3, [r3, #0]
 801b22e:	3301      	adds	r3, #1
 801b230:	4a4c      	ldr	r2, [pc, #304]	; (801b364 <finsh_compile+0x1040>)
 801b232:	6013      	str	r3, [r2, #0]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801b234:	4b4b      	ldr	r3, [pc, #300]	; (801b364 <finsh_compile+0x1040>)
 801b236:	681b      	ldr	r3, [r3, #0]
 801b238:	2229      	movs	r2, #41	; 0x29
 801b23a:	701a      	strb	r2, [r3, #0]
 801b23c:	4b49      	ldr	r3, [pc, #292]	; (801b364 <finsh_compile+0x1040>)
 801b23e:	681b      	ldr	r3, [r3, #0]
 801b240:	3301      	adds	r3, #1
 801b242:	4a48      	ldr	r2, [pc, #288]	; (801b364 <finsh_compile+0x1040>)
 801b244:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801b246:	4b47      	ldr	r3, [pc, #284]	; (801b364 <finsh_compile+0x1040>)
 801b248:	681b      	ldr	r3, [r3, #0]
 801b24a:	222f      	movs	r2, #47	; 0x2f
 801b24c:	701a      	strb	r2, [r3, #0]
 801b24e:	4b45      	ldr	r3, [pc, #276]	; (801b364 <finsh_compile+0x1040>)
 801b250:	681b      	ldr	r3, [r3, #0]
 801b252:	3301      	adds	r3, #1
 801b254:	4a43      	ldr	r2, [pc, #268]	; (801b364 <finsh_compile+0x1040>)
 801b256:	6013      	str	r3, [r2, #0]

                    break;
 801b258:	e068      	b.n	801b32c <finsh_compile+0x1008>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801b25a:	4b42      	ldr	r3, [pc, #264]	; (801b364 <finsh_compile+0x1040>)
 801b25c:	681b      	ldr	r3, [r3, #0]
 801b25e:	2227      	movs	r2, #39	; 0x27
 801b260:	701a      	strb	r2, [r3, #0]
 801b262:	4b40      	ldr	r3, [pc, #256]	; (801b364 <finsh_compile+0x1040>)
 801b264:	681b      	ldr	r3, [r3, #0]
 801b266:	3301      	adds	r3, #1
 801b268:	4a3e      	ldr	r2, [pc, #248]	; (801b364 <finsh_compile+0x1040>)
 801b26a:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801b26c:	4b3d      	ldr	r3, [pc, #244]	; (801b364 <finsh_compile+0x1040>)
 801b26e:	681b      	ldr	r3, [r3, #0]
 801b270:	693a      	ldr	r2, [r7, #16]
 801b272:	3214      	adds	r2, #20
 801b274:	b2d2      	uxtb	r2, r2
 801b276:	701a      	strb	r2, [r3, #0]
 801b278:	4b3a      	ldr	r3, [pc, #232]	; (801b364 <finsh_compile+0x1040>)
 801b27a:	681b      	ldr	r3, [r3, #0]
 801b27c:	3301      	adds	r3, #1
 801b27e:	693a      	ldr	r2, [r7, #16]
 801b280:	3214      	adds	r2, #20
 801b282:	0a12      	lsrs	r2, r2, #8
 801b284:	b2d2      	uxtb	r2, r2
 801b286:	701a      	strb	r2, [r3, #0]
 801b288:	4b36      	ldr	r3, [pc, #216]	; (801b364 <finsh_compile+0x1040>)
 801b28a:	681b      	ldr	r3, [r3, #0]
 801b28c:	3302      	adds	r3, #2
 801b28e:	693a      	ldr	r2, [r7, #16]
 801b290:	3214      	adds	r2, #20
 801b292:	0c12      	lsrs	r2, r2, #16
 801b294:	b2d2      	uxtb	r2, r2
 801b296:	701a      	strb	r2, [r3, #0]
 801b298:	4b32      	ldr	r3, [pc, #200]	; (801b364 <finsh_compile+0x1040>)
 801b29a:	681b      	ldr	r3, [r3, #0]
 801b29c:	3303      	adds	r3, #3
 801b29e:	693a      	ldr	r2, [r7, #16]
 801b2a0:	3214      	adds	r2, #20
 801b2a2:	0e12      	lsrs	r2, r2, #24
 801b2a4:	b2d2      	uxtb	r2, r2
 801b2a6:	701a      	strb	r2, [r3, #0]
 801b2a8:	4b2e      	ldr	r3, [pc, #184]	; (801b364 <finsh_compile+0x1040>)
 801b2aa:	681b      	ldr	r3, [r3, #0]
 801b2ac:	3304      	adds	r3, #4
 801b2ae:	4a2d      	ldr	r2, [pc, #180]	; (801b364 <finsh_compile+0x1040>)
 801b2b0:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b2b2:	4b2c      	ldr	r3, [pc, #176]	; (801b364 <finsh_compile+0x1040>)
 801b2b4:	681b      	ldr	r3, [r3, #0]
 801b2b6:	2224      	movs	r2, #36	; 0x24
 801b2b8:	701a      	strb	r2, [r3, #0]
 801b2ba:	4b2a      	ldr	r3, [pc, #168]	; (801b364 <finsh_compile+0x1040>)
 801b2bc:	681b      	ldr	r3, [r3, #0]
 801b2be:	3301      	adds	r3, #1
 801b2c0:	4a28      	ldr	r2, [pc, #160]	; (801b364 <finsh_compile+0x1040>)
 801b2c2:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801b2c4:	4b27      	ldr	r3, [pc, #156]	; (801b364 <finsh_compile+0x1040>)
 801b2c6:	681b      	ldr	r3, [r3, #0]
 801b2c8:	2201      	movs	r2, #1
 801b2ca:	701a      	strb	r2, [r3, #0]
 801b2cc:	4b25      	ldr	r3, [pc, #148]	; (801b364 <finsh_compile+0x1040>)
 801b2ce:	681b      	ldr	r3, [r3, #0]
 801b2d0:	3301      	adds	r3, #1
 801b2d2:	2200      	movs	r2, #0
 801b2d4:	701a      	strb	r2, [r3, #0]
 801b2d6:	4b23      	ldr	r3, [pc, #140]	; (801b364 <finsh_compile+0x1040>)
 801b2d8:	681b      	ldr	r3, [r3, #0]
 801b2da:	3302      	adds	r3, #2
 801b2dc:	2200      	movs	r2, #0
 801b2de:	701a      	strb	r2, [r3, #0]
 801b2e0:	4b20      	ldr	r3, [pc, #128]	; (801b364 <finsh_compile+0x1040>)
 801b2e2:	681b      	ldr	r3, [r3, #0]
 801b2e4:	3303      	adds	r3, #3
 801b2e6:	2200      	movs	r2, #0
 801b2e8:	701a      	strb	r2, [r3, #0]
 801b2ea:	4b1e      	ldr	r3, [pc, #120]	; (801b364 <finsh_compile+0x1040>)
 801b2ec:	681b      	ldr	r3, [r3, #0]
 801b2ee:	3304      	adds	r3, #4
 801b2f0:	4a1c      	ldr	r2, [pc, #112]	; (801b364 <finsh_compile+0x1040>)
 801b2f2:	6013      	str	r3, [r2, #0]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
 801b2f4:	4b1b      	ldr	r3, [pc, #108]	; (801b364 <finsh_compile+0x1040>)
 801b2f6:	681b      	ldr	r3, [r3, #0]
 801b2f8:	2206      	movs	r2, #6
 801b2fa:	701a      	strb	r2, [r3, #0]
 801b2fc:	4b19      	ldr	r3, [pc, #100]	; (801b364 <finsh_compile+0x1040>)
 801b2fe:	681b      	ldr	r3, [r3, #0]
 801b300:	3301      	adds	r3, #1
 801b302:	4a18      	ldr	r2, [pc, #96]	; (801b364 <finsh_compile+0x1040>)
 801b304:	6013      	str	r3, [r2, #0]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801b306:	4b17      	ldr	r3, [pc, #92]	; (801b364 <finsh_compile+0x1040>)
 801b308:	681b      	ldr	r3, [r3, #0]
 801b30a:	222a      	movs	r2, #42	; 0x2a
 801b30c:	701a      	strb	r2, [r3, #0]
 801b30e:	4b15      	ldr	r3, [pc, #84]	; (801b364 <finsh_compile+0x1040>)
 801b310:	681b      	ldr	r3, [r3, #0]
 801b312:	3301      	adds	r3, #1
 801b314:	4a13      	ldr	r2, [pc, #76]	; (801b364 <finsh_compile+0x1040>)
 801b316:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801b318:	4b12      	ldr	r3, [pc, #72]	; (801b364 <finsh_compile+0x1040>)
 801b31a:	681b      	ldr	r3, [r3, #0]
 801b31c:	222f      	movs	r2, #47	; 0x2f
 801b31e:	701a      	strb	r2, [r3, #0]
 801b320:	4b10      	ldr	r3, [pc, #64]	; (801b364 <finsh_compile+0x1040>)
 801b322:	681b      	ldr	r3, [r3, #0]
 801b324:	3301      	adds	r3, #1
 801b326:	4a0f      	ldr	r2, [pc, #60]	; (801b364 <finsh_compile+0x1040>)
 801b328:	6013      	str	r3, [r2, #0]

                    break;
 801b32a:	bf00      	nop
                }
            }
            break;
 801b32c:	e3d9      	b.n	801bae2 <finsh_compile+0x17be>

        /* increase */
        case FINSH_NODE_SYS_INC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801b32e:	687b      	ldr	r3, [r7, #4]
 801b330:	691b      	ldr	r3, [r3, #16]
 801b332:	2b00      	cmp	r3, #0
 801b334:	f000 81c1 	beq.w	801b6ba <finsh_compile+0x1396>
 801b338:	687b      	ldr	r3, [r7, #4]
 801b33a:	691b      	ldr	r3, [r3, #16]
 801b33c:	781b      	ldrb	r3, [r3, #0]
 801b33e:	2b01      	cmp	r3, #1
 801b340:	f040 81bb 	bne.w	801b6ba <finsh_compile+0x1396>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801b344:	687b      	ldr	r3, [r7, #4]
 801b346:	691b      	ldr	r3, [r3, #16]
 801b348:	689b      	ldr	r3, [r3, #8]
 801b34a:	60fb      	str	r3, [r7, #12]

                switch (node->data_type)
 801b34c:	687b      	ldr	r3, [r7, #4]
 801b34e:	785b      	ldrb	r3, [r3, #1]
 801b350:	2b02      	cmp	r3, #2
 801b352:	f000 808f 	beq.w	801b474 <finsh_compile+0x1150>
 801b356:	2b03      	cmp	r3, #3
 801b358:	f000 811a 	beq.w	801b590 <finsh_compile+0x126c>
 801b35c:	2b01      	cmp	r3, #1
 801b35e:	d003      	beq.n	801b368 <finsh_compile+0x1044>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
 801b360:	e3bf      	b.n	801bae2 <finsh_compile+0x17be>
 801b362:	bf00      	nop
 801b364:	200126e4 	.word	0x200126e4
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b368:	4b88      	ldr	r3, [pc, #544]	; (801b58c <finsh_compile+0x1268>)
 801b36a:	681b      	ldr	r3, [r3, #0]
 801b36c:	2224      	movs	r2, #36	; 0x24
 801b36e:	701a      	strb	r2, [r3, #0]
 801b370:	4b86      	ldr	r3, [pc, #536]	; (801b58c <finsh_compile+0x1268>)
 801b372:	681b      	ldr	r3, [r3, #0]
 801b374:	3301      	adds	r3, #1
 801b376:	4a85      	ldr	r2, [pc, #532]	; (801b58c <finsh_compile+0x1268>)
 801b378:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801b37a:	4b84      	ldr	r3, [pc, #528]	; (801b58c <finsh_compile+0x1268>)
 801b37c:	681b      	ldr	r3, [r3, #0]
 801b37e:	68fa      	ldr	r2, [r7, #12]
 801b380:	3214      	adds	r2, #20
 801b382:	b2d2      	uxtb	r2, r2
 801b384:	701a      	strb	r2, [r3, #0]
 801b386:	4b81      	ldr	r3, [pc, #516]	; (801b58c <finsh_compile+0x1268>)
 801b388:	681b      	ldr	r3, [r3, #0]
 801b38a:	3301      	adds	r3, #1
 801b38c:	68fa      	ldr	r2, [r7, #12]
 801b38e:	3214      	adds	r2, #20
 801b390:	0a12      	lsrs	r2, r2, #8
 801b392:	b2d2      	uxtb	r2, r2
 801b394:	701a      	strb	r2, [r3, #0]
 801b396:	4b7d      	ldr	r3, [pc, #500]	; (801b58c <finsh_compile+0x1268>)
 801b398:	681b      	ldr	r3, [r3, #0]
 801b39a:	3302      	adds	r3, #2
 801b39c:	68fa      	ldr	r2, [r7, #12]
 801b39e:	3214      	adds	r2, #20
 801b3a0:	0c12      	lsrs	r2, r2, #16
 801b3a2:	b2d2      	uxtb	r2, r2
 801b3a4:	701a      	strb	r2, [r3, #0]
 801b3a6:	4b79      	ldr	r3, [pc, #484]	; (801b58c <finsh_compile+0x1268>)
 801b3a8:	681b      	ldr	r3, [r3, #0]
 801b3aa:	3303      	adds	r3, #3
 801b3ac:	68fa      	ldr	r2, [r7, #12]
 801b3ae:	3214      	adds	r2, #20
 801b3b0:	0e12      	lsrs	r2, r2, #24
 801b3b2:	b2d2      	uxtb	r2, r2
 801b3b4:	701a      	strb	r2, [r3, #0]
 801b3b6:	4b75      	ldr	r3, [pc, #468]	; (801b58c <finsh_compile+0x1268>)
 801b3b8:	681b      	ldr	r3, [r3, #0]
 801b3ba:	3304      	adds	r3, #4
 801b3bc:	4a73      	ldr	r2, [pc, #460]	; (801b58c <finsh_compile+0x1268>)
 801b3be:	6013      	str	r3, [r2, #0]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801b3c0:	4b72      	ldr	r3, [pc, #456]	; (801b58c <finsh_compile+0x1268>)
 801b3c2:	681b      	ldr	r3, [r3, #0]
 801b3c4:	2225      	movs	r2, #37	; 0x25
 801b3c6:	701a      	strb	r2, [r3, #0]
 801b3c8:	4b70      	ldr	r3, [pc, #448]	; (801b58c <finsh_compile+0x1268>)
 801b3ca:	681b      	ldr	r3, [r3, #0]
 801b3cc:	3301      	adds	r3, #1
 801b3ce:	4a6f      	ldr	r2, [pc, #444]	; (801b58c <finsh_compile+0x1268>)
 801b3d0:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801b3d2:	4b6e      	ldr	r3, [pc, #440]	; (801b58c <finsh_compile+0x1268>)
 801b3d4:	681b      	ldr	r3, [r3, #0]
 801b3d6:	68fa      	ldr	r2, [r7, #12]
 801b3d8:	3214      	adds	r2, #20
 801b3da:	b2d2      	uxtb	r2, r2
 801b3dc:	701a      	strb	r2, [r3, #0]
 801b3de:	4b6b      	ldr	r3, [pc, #428]	; (801b58c <finsh_compile+0x1268>)
 801b3e0:	681b      	ldr	r3, [r3, #0]
 801b3e2:	3301      	adds	r3, #1
 801b3e4:	68fa      	ldr	r2, [r7, #12]
 801b3e6:	3214      	adds	r2, #20
 801b3e8:	0a12      	lsrs	r2, r2, #8
 801b3ea:	b2d2      	uxtb	r2, r2
 801b3ec:	701a      	strb	r2, [r3, #0]
 801b3ee:	4b67      	ldr	r3, [pc, #412]	; (801b58c <finsh_compile+0x1268>)
 801b3f0:	681b      	ldr	r3, [r3, #0]
 801b3f2:	3302      	adds	r3, #2
 801b3f4:	68fa      	ldr	r2, [r7, #12]
 801b3f6:	3214      	adds	r2, #20
 801b3f8:	0c12      	lsrs	r2, r2, #16
 801b3fa:	b2d2      	uxtb	r2, r2
 801b3fc:	701a      	strb	r2, [r3, #0]
 801b3fe:	4b63      	ldr	r3, [pc, #396]	; (801b58c <finsh_compile+0x1268>)
 801b400:	681b      	ldr	r3, [r3, #0]
 801b402:	3303      	adds	r3, #3
 801b404:	68fa      	ldr	r2, [r7, #12]
 801b406:	3214      	adds	r2, #20
 801b408:	0e12      	lsrs	r2, r2, #24
 801b40a:	b2d2      	uxtb	r2, r2
 801b40c:	701a      	strb	r2, [r3, #0]
 801b40e:	4b5f      	ldr	r3, [pc, #380]	; (801b58c <finsh_compile+0x1268>)
 801b410:	681b      	ldr	r3, [r3, #0]
 801b412:	3304      	adds	r3, #4
 801b414:	4a5d      	ldr	r2, [pc, #372]	; (801b58c <finsh_compile+0x1268>)
 801b416:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801b418:	4b5c      	ldr	r3, [pc, #368]	; (801b58c <finsh_compile+0x1268>)
 801b41a:	681b      	ldr	r3, [r3, #0]
 801b41c:	2222      	movs	r2, #34	; 0x22
 801b41e:	701a      	strb	r2, [r3, #0]
 801b420:	4b5a      	ldr	r3, [pc, #360]	; (801b58c <finsh_compile+0x1268>)
 801b422:	681b      	ldr	r3, [r3, #0]
 801b424:	3301      	adds	r3, #1
 801b426:	4a59      	ldr	r2, [pc, #356]	; (801b58c <finsh_compile+0x1268>)
 801b428:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801b42a:	4b58      	ldr	r3, [pc, #352]	; (801b58c <finsh_compile+0x1268>)
 801b42c:	681b      	ldr	r3, [r3, #0]
 801b42e:	2201      	movs	r2, #1
 801b430:	701a      	strb	r2, [r3, #0]
 801b432:	4b56      	ldr	r3, [pc, #344]	; (801b58c <finsh_compile+0x1268>)
 801b434:	681b      	ldr	r3, [r3, #0]
 801b436:	3301      	adds	r3, #1
 801b438:	4a54      	ldr	r2, [pc, #336]	; (801b58c <finsh_compile+0x1268>)
 801b43a:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
 801b43c:	4b53      	ldr	r3, [pc, #332]	; (801b58c <finsh_compile+0x1268>)
 801b43e:	681b      	ldr	r3, [r3, #0]
 801b440:	2201      	movs	r2, #1
 801b442:	701a      	strb	r2, [r3, #0]
 801b444:	4b51      	ldr	r3, [pc, #324]	; (801b58c <finsh_compile+0x1268>)
 801b446:	681b      	ldr	r3, [r3, #0]
 801b448:	3301      	adds	r3, #1
 801b44a:	4a50      	ldr	r2, [pc, #320]	; (801b58c <finsh_compile+0x1268>)
 801b44c:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801b44e:	4b4f      	ldr	r3, [pc, #316]	; (801b58c <finsh_compile+0x1268>)
 801b450:	681b      	ldr	r3, [r3, #0]
 801b452:	2228      	movs	r2, #40	; 0x28
 801b454:	701a      	strb	r2, [r3, #0]
 801b456:	4b4d      	ldr	r3, [pc, #308]	; (801b58c <finsh_compile+0x1268>)
 801b458:	681b      	ldr	r3, [r3, #0]
 801b45a:	3301      	adds	r3, #1
 801b45c:	4a4b      	ldr	r2, [pc, #300]	; (801b58c <finsh_compile+0x1268>)
 801b45e:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801b460:	4b4a      	ldr	r3, [pc, #296]	; (801b58c <finsh_compile+0x1268>)
 801b462:	681b      	ldr	r3, [r3, #0]
 801b464:	222b      	movs	r2, #43	; 0x2b
 801b466:	701a      	strb	r2, [r3, #0]
 801b468:	4b48      	ldr	r3, [pc, #288]	; (801b58c <finsh_compile+0x1268>)
 801b46a:	681b      	ldr	r3, [r3, #0]
 801b46c:	3301      	adds	r3, #1
 801b46e:	4a47      	ldr	r2, [pc, #284]	; (801b58c <finsh_compile+0x1268>)
 801b470:	6013      	str	r3, [r2, #0]
                    break;
 801b472:	e122      	b.n	801b6ba <finsh_compile+0x1396>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b474:	4b45      	ldr	r3, [pc, #276]	; (801b58c <finsh_compile+0x1268>)
 801b476:	681b      	ldr	r3, [r3, #0]
 801b478:	2224      	movs	r2, #36	; 0x24
 801b47a:	701a      	strb	r2, [r3, #0]
 801b47c:	4b43      	ldr	r3, [pc, #268]	; (801b58c <finsh_compile+0x1268>)
 801b47e:	681b      	ldr	r3, [r3, #0]
 801b480:	3301      	adds	r3, #1
 801b482:	4a42      	ldr	r2, [pc, #264]	; (801b58c <finsh_compile+0x1268>)
 801b484:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801b486:	4b41      	ldr	r3, [pc, #260]	; (801b58c <finsh_compile+0x1268>)
 801b488:	681b      	ldr	r3, [r3, #0]
 801b48a:	68fa      	ldr	r2, [r7, #12]
 801b48c:	3214      	adds	r2, #20
 801b48e:	b2d2      	uxtb	r2, r2
 801b490:	701a      	strb	r2, [r3, #0]
 801b492:	4b3e      	ldr	r3, [pc, #248]	; (801b58c <finsh_compile+0x1268>)
 801b494:	681b      	ldr	r3, [r3, #0]
 801b496:	3301      	adds	r3, #1
 801b498:	68fa      	ldr	r2, [r7, #12]
 801b49a:	3214      	adds	r2, #20
 801b49c:	0a12      	lsrs	r2, r2, #8
 801b49e:	b2d2      	uxtb	r2, r2
 801b4a0:	701a      	strb	r2, [r3, #0]
 801b4a2:	4b3a      	ldr	r3, [pc, #232]	; (801b58c <finsh_compile+0x1268>)
 801b4a4:	681b      	ldr	r3, [r3, #0]
 801b4a6:	3302      	adds	r3, #2
 801b4a8:	68fa      	ldr	r2, [r7, #12]
 801b4aa:	3214      	adds	r2, #20
 801b4ac:	0c12      	lsrs	r2, r2, #16
 801b4ae:	b2d2      	uxtb	r2, r2
 801b4b0:	701a      	strb	r2, [r3, #0]
 801b4b2:	4b36      	ldr	r3, [pc, #216]	; (801b58c <finsh_compile+0x1268>)
 801b4b4:	681b      	ldr	r3, [r3, #0]
 801b4b6:	3303      	adds	r3, #3
 801b4b8:	68fa      	ldr	r2, [r7, #12]
 801b4ba:	3214      	adds	r2, #20
 801b4bc:	0e12      	lsrs	r2, r2, #24
 801b4be:	b2d2      	uxtb	r2, r2
 801b4c0:	701a      	strb	r2, [r3, #0]
 801b4c2:	4b32      	ldr	r3, [pc, #200]	; (801b58c <finsh_compile+0x1268>)
 801b4c4:	681b      	ldr	r3, [r3, #0]
 801b4c6:	3304      	adds	r3, #4
 801b4c8:	4a30      	ldr	r2, [pc, #192]	; (801b58c <finsh_compile+0x1268>)
 801b4ca:	6013      	str	r3, [r2, #0]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801b4cc:	4b2f      	ldr	r3, [pc, #188]	; (801b58c <finsh_compile+0x1268>)
 801b4ce:	681b      	ldr	r3, [r3, #0]
 801b4d0:	2226      	movs	r2, #38	; 0x26
 801b4d2:	701a      	strb	r2, [r3, #0]
 801b4d4:	4b2d      	ldr	r3, [pc, #180]	; (801b58c <finsh_compile+0x1268>)
 801b4d6:	681b      	ldr	r3, [r3, #0]
 801b4d8:	3301      	adds	r3, #1
 801b4da:	4a2c      	ldr	r2, [pc, #176]	; (801b58c <finsh_compile+0x1268>)
 801b4dc:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801b4de:	4b2b      	ldr	r3, [pc, #172]	; (801b58c <finsh_compile+0x1268>)
 801b4e0:	681b      	ldr	r3, [r3, #0]
 801b4e2:	68fa      	ldr	r2, [r7, #12]
 801b4e4:	3214      	adds	r2, #20
 801b4e6:	b2d2      	uxtb	r2, r2
 801b4e8:	701a      	strb	r2, [r3, #0]
 801b4ea:	4b28      	ldr	r3, [pc, #160]	; (801b58c <finsh_compile+0x1268>)
 801b4ec:	681b      	ldr	r3, [r3, #0]
 801b4ee:	3301      	adds	r3, #1
 801b4f0:	68fa      	ldr	r2, [r7, #12]
 801b4f2:	3214      	adds	r2, #20
 801b4f4:	0a12      	lsrs	r2, r2, #8
 801b4f6:	b2d2      	uxtb	r2, r2
 801b4f8:	701a      	strb	r2, [r3, #0]
 801b4fa:	4b24      	ldr	r3, [pc, #144]	; (801b58c <finsh_compile+0x1268>)
 801b4fc:	681b      	ldr	r3, [r3, #0]
 801b4fe:	3302      	adds	r3, #2
 801b500:	68fa      	ldr	r2, [r7, #12]
 801b502:	3214      	adds	r2, #20
 801b504:	0c12      	lsrs	r2, r2, #16
 801b506:	b2d2      	uxtb	r2, r2
 801b508:	701a      	strb	r2, [r3, #0]
 801b50a:	4b20      	ldr	r3, [pc, #128]	; (801b58c <finsh_compile+0x1268>)
 801b50c:	681b      	ldr	r3, [r3, #0]
 801b50e:	3303      	adds	r3, #3
 801b510:	68fa      	ldr	r2, [r7, #12]
 801b512:	3214      	adds	r2, #20
 801b514:	0e12      	lsrs	r2, r2, #24
 801b516:	b2d2      	uxtb	r2, r2
 801b518:	701a      	strb	r2, [r3, #0]
 801b51a:	4b1c      	ldr	r3, [pc, #112]	; (801b58c <finsh_compile+0x1268>)
 801b51c:	681b      	ldr	r3, [r3, #0]
 801b51e:	3304      	adds	r3, #4
 801b520:	4a1a      	ldr	r2, [pc, #104]	; (801b58c <finsh_compile+0x1268>)
 801b522:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801b524:	4b19      	ldr	r3, [pc, #100]	; (801b58c <finsh_compile+0x1268>)
 801b526:	681b      	ldr	r3, [r3, #0]
 801b528:	2223      	movs	r2, #35	; 0x23
 801b52a:	701a      	strb	r2, [r3, #0]
 801b52c:	4b17      	ldr	r3, [pc, #92]	; (801b58c <finsh_compile+0x1268>)
 801b52e:	681b      	ldr	r3, [r3, #0]
 801b530:	3301      	adds	r3, #1
 801b532:	4a16      	ldr	r2, [pc, #88]	; (801b58c <finsh_compile+0x1268>)
 801b534:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801b536:	4b15      	ldr	r3, [pc, #84]	; (801b58c <finsh_compile+0x1268>)
 801b538:	681b      	ldr	r3, [r3, #0]
 801b53a:	2201      	movs	r2, #1
 801b53c:	701a      	strb	r2, [r3, #0]
 801b53e:	4b13      	ldr	r3, [pc, #76]	; (801b58c <finsh_compile+0x1268>)
 801b540:	681b      	ldr	r3, [r3, #0]
 801b542:	3301      	adds	r3, #1
 801b544:	2200      	movs	r2, #0
 801b546:	701a      	strb	r2, [r3, #0]
 801b548:	4b10      	ldr	r3, [pc, #64]	; (801b58c <finsh_compile+0x1268>)
 801b54a:	681b      	ldr	r3, [r3, #0]
 801b54c:	3302      	adds	r3, #2
 801b54e:	4a0f      	ldr	r2, [pc, #60]	; (801b58c <finsh_compile+0x1268>)
 801b550:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
 801b552:	4b0e      	ldr	r3, [pc, #56]	; (801b58c <finsh_compile+0x1268>)
 801b554:	681b      	ldr	r3, [r3, #0]
 801b556:	2202      	movs	r2, #2
 801b558:	701a      	strb	r2, [r3, #0]
 801b55a:	4b0c      	ldr	r3, [pc, #48]	; (801b58c <finsh_compile+0x1268>)
 801b55c:	681b      	ldr	r3, [r3, #0]
 801b55e:	3301      	adds	r3, #1
 801b560:	4a0a      	ldr	r2, [pc, #40]	; (801b58c <finsh_compile+0x1268>)
 801b562:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801b564:	4b09      	ldr	r3, [pc, #36]	; (801b58c <finsh_compile+0x1268>)
 801b566:	681b      	ldr	r3, [r3, #0]
 801b568:	2229      	movs	r2, #41	; 0x29
 801b56a:	701a      	strb	r2, [r3, #0]
 801b56c:	4b07      	ldr	r3, [pc, #28]	; (801b58c <finsh_compile+0x1268>)
 801b56e:	681b      	ldr	r3, [r3, #0]
 801b570:	3301      	adds	r3, #1
 801b572:	4a06      	ldr	r2, [pc, #24]	; (801b58c <finsh_compile+0x1268>)
 801b574:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801b576:	4b05      	ldr	r3, [pc, #20]	; (801b58c <finsh_compile+0x1268>)
 801b578:	681b      	ldr	r3, [r3, #0]
 801b57a:	222b      	movs	r2, #43	; 0x2b
 801b57c:	701a      	strb	r2, [r3, #0]
 801b57e:	4b03      	ldr	r3, [pc, #12]	; (801b58c <finsh_compile+0x1268>)
 801b580:	681b      	ldr	r3, [r3, #0]
 801b582:	3301      	adds	r3, #1
 801b584:	4a01      	ldr	r2, [pc, #4]	; (801b58c <finsh_compile+0x1268>)
 801b586:	6013      	str	r3, [r2, #0]
                    break;
 801b588:	e097      	b.n	801b6ba <finsh_compile+0x1396>
 801b58a:	bf00      	nop
 801b58c:	200126e4 	.word	0x200126e4
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b590:	4b9a      	ldr	r3, [pc, #616]	; (801b7fc <finsh_compile+0x14d8>)
 801b592:	681b      	ldr	r3, [r3, #0]
 801b594:	2224      	movs	r2, #36	; 0x24
 801b596:	701a      	strb	r2, [r3, #0]
 801b598:	4b98      	ldr	r3, [pc, #608]	; (801b7fc <finsh_compile+0x14d8>)
 801b59a:	681b      	ldr	r3, [r3, #0]
 801b59c:	3301      	adds	r3, #1
 801b59e:	4a97      	ldr	r2, [pc, #604]	; (801b7fc <finsh_compile+0x14d8>)
 801b5a0:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801b5a2:	4b96      	ldr	r3, [pc, #600]	; (801b7fc <finsh_compile+0x14d8>)
 801b5a4:	681b      	ldr	r3, [r3, #0]
 801b5a6:	68fa      	ldr	r2, [r7, #12]
 801b5a8:	3214      	adds	r2, #20
 801b5aa:	b2d2      	uxtb	r2, r2
 801b5ac:	701a      	strb	r2, [r3, #0]
 801b5ae:	4b93      	ldr	r3, [pc, #588]	; (801b7fc <finsh_compile+0x14d8>)
 801b5b0:	681b      	ldr	r3, [r3, #0]
 801b5b2:	3301      	adds	r3, #1
 801b5b4:	68fa      	ldr	r2, [r7, #12]
 801b5b6:	3214      	adds	r2, #20
 801b5b8:	0a12      	lsrs	r2, r2, #8
 801b5ba:	b2d2      	uxtb	r2, r2
 801b5bc:	701a      	strb	r2, [r3, #0]
 801b5be:	4b8f      	ldr	r3, [pc, #572]	; (801b7fc <finsh_compile+0x14d8>)
 801b5c0:	681b      	ldr	r3, [r3, #0]
 801b5c2:	3302      	adds	r3, #2
 801b5c4:	68fa      	ldr	r2, [r7, #12]
 801b5c6:	3214      	adds	r2, #20
 801b5c8:	0c12      	lsrs	r2, r2, #16
 801b5ca:	b2d2      	uxtb	r2, r2
 801b5cc:	701a      	strb	r2, [r3, #0]
 801b5ce:	4b8b      	ldr	r3, [pc, #556]	; (801b7fc <finsh_compile+0x14d8>)
 801b5d0:	681b      	ldr	r3, [r3, #0]
 801b5d2:	3303      	adds	r3, #3
 801b5d4:	68fa      	ldr	r2, [r7, #12]
 801b5d6:	3214      	adds	r2, #20
 801b5d8:	0e12      	lsrs	r2, r2, #24
 801b5da:	b2d2      	uxtb	r2, r2
 801b5dc:	701a      	strb	r2, [r3, #0]
 801b5de:	4b87      	ldr	r3, [pc, #540]	; (801b7fc <finsh_compile+0x14d8>)
 801b5e0:	681b      	ldr	r3, [r3, #0]
 801b5e2:	3304      	adds	r3, #4
 801b5e4:	4a85      	ldr	r2, [pc, #532]	; (801b7fc <finsh_compile+0x14d8>)
 801b5e6:	6013      	str	r3, [r2, #0]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801b5e8:	4b84      	ldr	r3, [pc, #528]	; (801b7fc <finsh_compile+0x14d8>)
 801b5ea:	681b      	ldr	r3, [r3, #0]
 801b5ec:	2227      	movs	r2, #39	; 0x27
 801b5ee:	701a      	strb	r2, [r3, #0]
 801b5f0:	4b82      	ldr	r3, [pc, #520]	; (801b7fc <finsh_compile+0x14d8>)
 801b5f2:	681b      	ldr	r3, [r3, #0]
 801b5f4:	3301      	adds	r3, #1
 801b5f6:	4a81      	ldr	r2, [pc, #516]	; (801b7fc <finsh_compile+0x14d8>)
 801b5f8:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801b5fa:	4b80      	ldr	r3, [pc, #512]	; (801b7fc <finsh_compile+0x14d8>)
 801b5fc:	681b      	ldr	r3, [r3, #0]
 801b5fe:	68fa      	ldr	r2, [r7, #12]
 801b600:	3214      	adds	r2, #20
 801b602:	b2d2      	uxtb	r2, r2
 801b604:	701a      	strb	r2, [r3, #0]
 801b606:	4b7d      	ldr	r3, [pc, #500]	; (801b7fc <finsh_compile+0x14d8>)
 801b608:	681b      	ldr	r3, [r3, #0]
 801b60a:	3301      	adds	r3, #1
 801b60c:	68fa      	ldr	r2, [r7, #12]
 801b60e:	3214      	adds	r2, #20
 801b610:	0a12      	lsrs	r2, r2, #8
 801b612:	b2d2      	uxtb	r2, r2
 801b614:	701a      	strb	r2, [r3, #0]
 801b616:	4b79      	ldr	r3, [pc, #484]	; (801b7fc <finsh_compile+0x14d8>)
 801b618:	681b      	ldr	r3, [r3, #0]
 801b61a:	3302      	adds	r3, #2
 801b61c:	68fa      	ldr	r2, [r7, #12]
 801b61e:	3214      	adds	r2, #20
 801b620:	0c12      	lsrs	r2, r2, #16
 801b622:	b2d2      	uxtb	r2, r2
 801b624:	701a      	strb	r2, [r3, #0]
 801b626:	4b75      	ldr	r3, [pc, #468]	; (801b7fc <finsh_compile+0x14d8>)
 801b628:	681b      	ldr	r3, [r3, #0]
 801b62a:	3303      	adds	r3, #3
 801b62c:	68fa      	ldr	r2, [r7, #12]
 801b62e:	3214      	adds	r2, #20
 801b630:	0e12      	lsrs	r2, r2, #24
 801b632:	b2d2      	uxtb	r2, r2
 801b634:	701a      	strb	r2, [r3, #0]
 801b636:	4b71      	ldr	r3, [pc, #452]	; (801b7fc <finsh_compile+0x14d8>)
 801b638:	681b      	ldr	r3, [r3, #0]
 801b63a:	3304      	adds	r3, #4
 801b63c:	4a6f      	ldr	r2, [pc, #444]	; (801b7fc <finsh_compile+0x14d8>)
 801b63e:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b640:	4b6e      	ldr	r3, [pc, #440]	; (801b7fc <finsh_compile+0x14d8>)
 801b642:	681b      	ldr	r3, [r3, #0]
 801b644:	2224      	movs	r2, #36	; 0x24
 801b646:	701a      	strb	r2, [r3, #0]
 801b648:	4b6c      	ldr	r3, [pc, #432]	; (801b7fc <finsh_compile+0x14d8>)
 801b64a:	681b      	ldr	r3, [r3, #0]
 801b64c:	3301      	adds	r3, #1
 801b64e:	4a6b      	ldr	r2, [pc, #428]	; (801b7fc <finsh_compile+0x14d8>)
 801b650:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801b652:	4b6a      	ldr	r3, [pc, #424]	; (801b7fc <finsh_compile+0x14d8>)
 801b654:	681b      	ldr	r3, [r3, #0]
 801b656:	2201      	movs	r2, #1
 801b658:	701a      	strb	r2, [r3, #0]
 801b65a:	4b68      	ldr	r3, [pc, #416]	; (801b7fc <finsh_compile+0x14d8>)
 801b65c:	681b      	ldr	r3, [r3, #0]
 801b65e:	3301      	adds	r3, #1
 801b660:	2200      	movs	r2, #0
 801b662:	701a      	strb	r2, [r3, #0]
 801b664:	4b65      	ldr	r3, [pc, #404]	; (801b7fc <finsh_compile+0x14d8>)
 801b666:	681b      	ldr	r3, [r3, #0]
 801b668:	3302      	adds	r3, #2
 801b66a:	2200      	movs	r2, #0
 801b66c:	701a      	strb	r2, [r3, #0]
 801b66e:	4b63      	ldr	r3, [pc, #396]	; (801b7fc <finsh_compile+0x14d8>)
 801b670:	681b      	ldr	r3, [r3, #0]
 801b672:	3303      	adds	r3, #3
 801b674:	2200      	movs	r2, #0
 801b676:	701a      	strb	r2, [r3, #0]
 801b678:	4b60      	ldr	r3, [pc, #384]	; (801b7fc <finsh_compile+0x14d8>)
 801b67a:	681b      	ldr	r3, [r3, #0]
 801b67c:	3304      	adds	r3, #4
 801b67e:	4a5f      	ldr	r2, [pc, #380]	; (801b7fc <finsh_compile+0x14d8>)
 801b680:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
 801b682:	4b5e      	ldr	r3, [pc, #376]	; (801b7fc <finsh_compile+0x14d8>)
 801b684:	681b      	ldr	r3, [r3, #0]
 801b686:	2203      	movs	r2, #3
 801b688:	701a      	strb	r2, [r3, #0]
 801b68a:	4b5c      	ldr	r3, [pc, #368]	; (801b7fc <finsh_compile+0x14d8>)
 801b68c:	681b      	ldr	r3, [r3, #0]
 801b68e:	3301      	adds	r3, #1
 801b690:	4a5a      	ldr	r2, [pc, #360]	; (801b7fc <finsh_compile+0x14d8>)
 801b692:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801b694:	4b59      	ldr	r3, [pc, #356]	; (801b7fc <finsh_compile+0x14d8>)
 801b696:	681b      	ldr	r3, [r3, #0]
 801b698:	222a      	movs	r2, #42	; 0x2a
 801b69a:	701a      	strb	r2, [r3, #0]
 801b69c:	4b57      	ldr	r3, [pc, #348]	; (801b7fc <finsh_compile+0x14d8>)
 801b69e:	681b      	ldr	r3, [r3, #0]
 801b6a0:	3301      	adds	r3, #1
 801b6a2:	4a56      	ldr	r2, [pc, #344]	; (801b7fc <finsh_compile+0x14d8>)
 801b6a4:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801b6a6:	4b55      	ldr	r3, [pc, #340]	; (801b7fc <finsh_compile+0x14d8>)
 801b6a8:	681b      	ldr	r3, [r3, #0]
 801b6aa:	222b      	movs	r2, #43	; 0x2b
 801b6ac:	701a      	strb	r2, [r3, #0]
 801b6ae:	4b53      	ldr	r3, [pc, #332]	; (801b7fc <finsh_compile+0x14d8>)
 801b6b0:	681b      	ldr	r3, [r3, #0]
 801b6b2:	3301      	adds	r3, #1
 801b6b4:	4a51      	ldr	r2, [pc, #324]	; (801b7fc <finsh_compile+0x14d8>)
 801b6b6:	6013      	str	r3, [r2, #0]
                    break;
 801b6b8:	bf00      	nop
                }
            }
            break;
 801b6ba:	e212      	b.n	801bae2 <finsh_compile+0x17be>

        /* decrease */
        case FINSH_NODE_SYS_DEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801b6bc:	687b      	ldr	r3, [r7, #4]
 801b6be:	691b      	ldr	r3, [r3, #16]
 801b6c0:	2b00      	cmp	r3, #0
 801b6c2:	f000 81bd 	beq.w	801ba40 <finsh_compile+0x171c>
 801b6c6:	687b      	ldr	r3, [r7, #4]
 801b6c8:	691b      	ldr	r3, [r3, #16]
 801b6ca:	781b      	ldrb	r3, [r3, #0]
 801b6cc:	2b01      	cmp	r3, #1
 801b6ce:	f040 81b7 	bne.w	801ba40 <finsh_compile+0x171c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801b6d2:	687b      	ldr	r3, [r7, #4]
 801b6d4:	691b      	ldr	r3, [r3, #16]
 801b6d6:	689b      	ldr	r3, [r3, #8]
 801b6d8:	60bb      	str	r3, [r7, #8]

                switch (node->data_type)
 801b6da:	687b      	ldr	r3, [r7, #4]
 801b6dc:	785b      	ldrb	r3, [r3, #1]
 801b6de:	2b02      	cmp	r3, #2
 801b6e0:	f000 808e 	beq.w	801b800 <finsh_compile+0x14dc>
 801b6e4:	2b03      	cmp	r3, #3
 801b6e6:	f000 8116 	beq.w	801b916 <finsh_compile+0x15f2>
 801b6ea:	2b01      	cmp	r3, #1
 801b6ec:	d000      	beq.n	801b6f0 <finsh_compile+0x13cc>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
 801b6ee:	e1f8      	b.n	801bae2 <finsh_compile+0x17be>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b6f0:	4b42      	ldr	r3, [pc, #264]	; (801b7fc <finsh_compile+0x14d8>)
 801b6f2:	681b      	ldr	r3, [r3, #0]
 801b6f4:	2224      	movs	r2, #36	; 0x24
 801b6f6:	701a      	strb	r2, [r3, #0]
 801b6f8:	4b40      	ldr	r3, [pc, #256]	; (801b7fc <finsh_compile+0x14d8>)
 801b6fa:	681b      	ldr	r3, [r3, #0]
 801b6fc:	3301      	adds	r3, #1
 801b6fe:	4a3f      	ldr	r2, [pc, #252]	; (801b7fc <finsh_compile+0x14d8>)
 801b700:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801b702:	4b3e      	ldr	r3, [pc, #248]	; (801b7fc <finsh_compile+0x14d8>)
 801b704:	681b      	ldr	r3, [r3, #0]
 801b706:	68ba      	ldr	r2, [r7, #8]
 801b708:	3214      	adds	r2, #20
 801b70a:	b2d2      	uxtb	r2, r2
 801b70c:	701a      	strb	r2, [r3, #0]
 801b70e:	4b3b      	ldr	r3, [pc, #236]	; (801b7fc <finsh_compile+0x14d8>)
 801b710:	681b      	ldr	r3, [r3, #0]
 801b712:	3301      	adds	r3, #1
 801b714:	68ba      	ldr	r2, [r7, #8]
 801b716:	3214      	adds	r2, #20
 801b718:	0a12      	lsrs	r2, r2, #8
 801b71a:	b2d2      	uxtb	r2, r2
 801b71c:	701a      	strb	r2, [r3, #0]
 801b71e:	4b37      	ldr	r3, [pc, #220]	; (801b7fc <finsh_compile+0x14d8>)
 801b720:	681b      	ldr	r3, [r3, #0]
 801b722:	3302      	adds	r3, #2
 801b724:	68ba      	ldr	r2, [r7, #8]
 801b726:	3214      	adds	r2, #20
 801b728:	0c12      	lsrs	r2, r2, #16
 801b72a:	b2d2      	uxtb	r2, r2
 801b72c:	701a      	strb	r2, [r3, #0]
 801b72e:	4b33      	ldr	r3, [pc, #204]	; (801b7fc <finsh_compile+0x14d8>)
 801b730:	681b      	ldr	r3, [r3, #0]
 801b732:	3303      	adds	r3, #3
 801b734:	68ba      	ldr	r2, [r7, #8]
 801b736:	3214      	adds	r2, #20
 801b738:	0e12      	lsrs	r2, r2, #24
 801b73a:	b2d2      	uxtb	r2, r2
 801b73c:	701a      	strb	r2, [r3, #0]
 801b73e:	4b2f      	ldr	r3, [pc, #188]	; (801b7fc <finsh_compile+0x14d8>)
 801b740:	681b      	ldr	r3, [r3, #0]
 801b742:	3304      	adds	r3, #4
 801b744:	4a2d      	ldr	r2, [pc, #180]	; (801b7fc <finsh_compile+0x14d8>)
 801b746:	6013      	str	r3, [r2, #0]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801b748:	4b2c      	ldr	r3, [pc, #176]	; (801b7fc <finsh_compile+0x14d8>)
 801b74a:	681b      	ldr	r3, [r3, #0]
 801b74c:	2225      	movs	r2, #37	; 0x25
 801b74e:	701a      	strb	r2, [r3, #0]
 801b750:	4b2a      	ldr	r3, [pc, #168]	; (801b7fc <finsh_compile+0x14d8>)
 801b752:	681b      	ldr	r3, [r3, #0]
 801b754:	3301      	adds	r3, #1
 801b756:	4a29      	ldr	r2, [pc, #164]	; (801b7fc <finsh_compile+0x14d8>)
 801b758:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801b75a:	4b28      	ldr	r3, [pc, #160]	; (801b7fc <finsh_compile+0x14d8>)
 801b75c:	681b      	ldr	r3, [r3, #0]
 801b75e:	68ba      	ldr	r2, [r7, #8]
 801b760:	3214      	adds	r2, #20
 801b762:	b2d2      	uxtb	r2, r2
 801b764:	701a      	strb	r2, [r3, #0]
 801b766:	4b25      	ldr	r3, [pc, #148]	; (801b7fc <finsh_compile+0x14d8>)
 801b768:	681b      	ldr	r3, [r3, #0]
 801b76a:	3301      	adds	r3, #1
 801b76c:	68ba      	ldr	r2, [r7, #8]
 801b76e:	3214      	adds	r2, #20
 801b770:	0a12      	lsrs	r2, r2, #8
 801b772:	b2d2      	uxtb	r2, r2
 801b774:	701a      	strb	r2, [r3, #0]
 801b776:	4b21      	ldr	r3, [pc, #132]	; (801b7fc <finsh_compile+0x14d8>)
 801b778:	681b      	ldr	r3, [r3, #0]
 801b77a:	3302      	adds	r3, #2
 801b77c:	68ba      	ldr	r2, [r7, #8]
 801b77e:	3214      	adds	r2, #20
 801b780:	0c12      	lsrs	r2, r2, #16
 801b782:	b2d2      	uxtb	r2, r2
 801b784:	701a      	strb	r2, [r3, #0]
 801b786:	4b1d      	ldr	r3, [pc, #116]	; (801b7fc <finsh_compile+0x14d8>)
 801b788:	681b      	ldr	r3, [r3, #0]
 801b78a:	3303      	adds	r3, #3
 801b78c:	68ba      	ldr	r2, [r7, #8]
 801b78e:	3214      	adds	r2, #20
 801b790:	0e12      	lsrs	r2, r2, #24
 801b792:	b2d2      	uxtb	r2, r2
 801b794:	701a      	strb	r2, [r3, #0]
 801b796:	4b19      	ldr	r3, [pc, #100]	; (801b7fc <finsh_compile+0x14d8>)
 801b798:	681b      	ldr	r3, [r3, #0]
 801b79a:	3304      	adds	r3, #4
 801b79c:	4a17      	ldr	r2, [pc, #92]	; (801b7fc <finsh_compile+0x14d8>)
 801b79e:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801b7a0:	4b16      	ldr	r3, [pc, #88]	; (801b7fc <finsh_compile+0x14d8>)
 801b7a2:	681b      	ldr	r3, [r3, #0]
 801b7a4:	2222      	movs	r2, #34	; 0x22
 801b7a6:	701a      	strb	r2, [r3, #0]
 801b7a8:	4b14      	ldr	r3, [pc, #80]	; (801b7fc <finsh_compile+0x14d8>)
 801b7aa:	681b      	ldr	r3, [r3, #0]
 801b7ac:	3301      	adds	r3, #1
 801b7ae:	4a13      	ldr	r2, [pc, #76]	; (801b7fc <finsh_compile+0x14d8>)
 801b7b0:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801b7b2:	4b12      	ldr	r3, [pc, #72]	; (801b7fc <finsh_compile+0x14d8>)
 801b7b4:	681b      	ldr	r3, [r3, #0]
 801b7b6:	2201      	movs	r2, #1
 801b7b8:	701a      	strb	r2, [r3, #0]
 801b7ba:	4b10      	ldr	r3, [pc, #64]	; (801b7fc <finsh_compile+0x14d8>)
 801b7bc:	681b      	ldr	r3, [r3, #0]
 801b7be:	3301      	adds	r3, #1
 801b7c0:	4a0e      	ldr	r2, [pc, #56]	; (801b7fc <finsh_compile+0x14d8>)
 801b7c2:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
 801b7c4:	4b0d      	ldr	r3, [pc, #52]	; (801b7fc <finsh_compile+0x14d8>)
 801b7c6:	681b      	ldr	r3, [r3, #0]
 801b7c8:	2204      	movs	r2, #4
 801b7ca:	701a      	strb	r2, [r3, #0]
 801b7cc:	4b0b      	ldr	r3, [pc, #44]	; (801b7fc <finsh_compile+0x14d8>)
 801b7ce:	681b      	ldr	r3, [r3, #0]
 801b7d0:	3301      	adds	r3, #1
 801b7d2:	4a0a      	ldr	r2, [pc, #40]	; (801b7fc <finsh_compile+0x14d8>)
 801b7d4:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801b7d6:	4b09      	ldr	r3, [pc, #36]	; (801b7fc <finsh_compile+0x14d8>)
 801b7d8:	681b      	ldr	r3, [r3, #0]
 801b7da:	2228      	movs	r2, #40	; 0x28
 801b7dc:	701a      	strb	r2, [r3, #0]
 801b7de:	4b07      	ldr	r3, [pc, #28]	; (801b7fc <finsh_compile+0x14d8>)
 801b7e0:	681b      	ldr	r3, [r3, #0]
 801b7e2:	3301      	adds	r3, #1
 801b7e4:	4a05      	ldr	r2, [pc, #20]	; (801b7fc <finsh_compile+0x14d8>)
 801b7e6:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801b7e8:	4b04      	ldr	r3, [pc, #16]	; (801b7fc <finsh_compile+0x14d8>)
 801b7ea:	681b      	ldr	r3, [r3, #0]
 801b7ec:	222b      	movs	r2, #43	; 0x2b
 801b7ee:	701a      	strb	r2, [r3, #0]
 801b7f0:	4b02      	ldr	r3, [pc, #8]	; (801b7fc <finsh_compile+0x14d8>)
 801b7f2:	681b      	ldr	r3, [r3, #0]
 801b7f4:	3301      	adds	r3, #1
 801b7f6:	4a01      	ldr	r2, [pc, #4]	; (801b7fc <finsh_compile+0x14d8>)
 801b7f8:	6013      	str	r3, [r2, #0]
                    break;
 801b7fa:	e121      	b.n	801ba40 <finsh_compile+0x171c>
 801b7fc:	200126e4 	.word	0x200126e4
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b800:	4b9c      	ldr	r3, [pc, #624]	; (801ba74 <finsh_compile+0x1750>)
 801b802:	681b      	ldr	r3, [r3, #0]
 801b804:	2224      	movs	r2, #36	; 0x24
 801b806:	701a      	strb	r2, [r3, #0]
 801b808:	4b9a      	ldr	r3, [pc, #616]	; (801ba74 <finsh_compile+0x1750>)
 801b80a:	681b      	ldr	r3, [r3, #0]
 801b80c:	3301      	adds	r3, #1
 801b80e:	4a99      	ldr	r2, [pc, #612]	; (801ba74 <finsh_compile+0x1750>)
 801b810:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801b812:	4b98      	ldr	r3, [pc, #608]	; (801ba74 <finsh_compile+0x1750>)
 801b814:	681b      	ldr	r3, [r3, #0]
 801b816:	68ba      	ldr	r2, [r7, #8]
 801b818:	3214      	adds	r2, #20
 801b81a:	b2d2      	uxtb	r2, r2
 801b81c:	701a      	strb	r2, [r3, #0]
 801b81e:	4b95      	ldr	r3, [pc, #596]	; (801ba74 <finsh_compile+0x1750>)
 801b820:	681b      	ldr	r3, [r3, #0]
 801b822:	3301      	adds	r3, #1
 801b824:	68ba      	ldr	r2, [r7, #8]
 801b826:	3214      	adds	r2, #20
 801b828:	0a12      	lsrs	r2, r2, #8
 801b82a:	b2d2      	uxtb	r2, r2
 801b82c:	701a      	strb	r2, [r3, #0]
 801b82e:	4b91      	ldr	r3, [pc, #580]	; (801ba74 <finsh_compile+0x1750>)
 801b830:	681b      	ldr	r3, [r3, #0]
 801b832:	3302      	adds	r3, #2
 801b834:	68ba      	ldr	r2, [r7, #8]
 801b836:	3214      	adds	r2, #20
 801b838:	0c12      	lsrs	r2, r2, #16
 801b83a:	b2d2      	uxtb	r2, r2
 801b83c:	701a      	strb	r2, [r3, #0]
 801b83e:	4b8d      	ldr	r3, [pc, #564]	; (801ba74 <finsh_compile+0x1750>)
 801b840:	681b      	ldr	r3, [r3, #0]
 801b842:	3303      	adds	r3, #3
 801b844:	68ba      	ldr	r2, [r7, #8]
 801b846:	3214      	adds	r2, #20
 801b848:	0e12      	lsrs	r2, r2, #24
 801b84a:	b2d2      	uxtb	r2, r2
 801b84c:	701a      	strb	r2, [r3, #0]
 801b84e:	4b89      	ldr	r3, [pc, #548]	; (801ba74 <finsh_compile+0x1750>)
 801b850:	681b      	ldr	r3, [r3, #0]
 801b852:	3304      	adds	r3, #4
 801b854:	4a87      	ldr	r2, [pc, #540]	; (801ba74 <finsh_compile+0x1750>)
 801b856:	6013      	str	r3, [r2, #0]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801b858:	4b86      	ldr	r3, [pc, #536]	; (801ba74 <finsh_compile+0x1750>)
 801b85a:	681b      	ldr	r3, [r3, #0]
 801b85c:	2226      	movs	r2, #38	; 0x26
 801b85e:	701a      	strb	r2, [r3, #0]
 801b860:	4b84      	ldr	r3, [pc, #528]	; (801ba74 <finsh_compile+0x1750>)
 801b862:	681b      	ldr	r3, [r3, #0]
 801b864:	3301      	adds	r3, #1
 801b866:	4a83      	ldr	r2, [pc, #524]	; (801ba74 <finsh_compile+0x1750>)
 801b868:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801b86a:	4b82      	ldr	r3, [pc, #520]	; (801ba74 <finsh_compile+0x1750>)
 801b86c:	681b      	ldr	r3, [r3, #0]
 801b86e:	68ba      	ldr	r2, [r7, #8]
 801b870:	3214      	adds	r2, #20
 801b872:	b2d2      	uxtb	r2, r2
 801b874:	701a      	strb	r2, [r3, #0]
 801b876:	4b7f      	ldr	r3, [pc, #508]	; (801ba74 <finsh_compile+0x1750>)
 801b878:	681b      	ldr	r3, [r3, #0]
 801b87a:	3301      	adds	r3, #1
 801b87c:	68ba      	ldr	r2, [r7, #8]
 801b87e:	3214      	adds	r2, #20
 801b880:	0a12      	lsrs	r2, r2, #8
 801b882:	b2d2      	uxtb	r2, r2
 801b884:	701a      	strb	r2, [r3, #0]
 801b886:	4b7b      	ldr	r3, [pc, #492]	; (801ba74 <finsh_compile+0x1750>)
 801b888:	681b      	ldr	r3, [r3, #0]
 801b88a:	3302      	adds	r3, #2
 801b88c:	68ba      	ldr	r2, [r7, #8]
 801b88e:	3214      	adds	r2, #20
 801b890:	0c12      	lsrs	r2, r2, #16
 801b892:	b2d2      	uxtb	r2, r2
 801b894:	701a      	strb	r2, [r3, #0]
 801b896:	4b77      	ldr	r3, [pc, #476]	; (801ba74 <finsh_compile+0x1750>)
 801b898:	681b      	ldr	r3, [r3, #0]
 801b89a:	3303      	adds	r3, #3
 801b89c:	68ba      	ldr	r2, [r7, #8]
 801b89e:	3214      	adds	r2, #20
 801b8a0:	0e12      	lsrs	r2, r2, #24
 801b8a2:	b2d2      	uxtb	r2, r2
 801b8a4:	701a      	strb	r2, [r3, #0]
 801b8a6:	4b73      	ldr	r3, [pc, #460]	; (801ba74 <finsh_compile+0x1750>)
 801b8a8:	681b      	ldr	r3, [r3, #0]
 801b8aa:	3304      	adds	r3, #4
 801b8ac:	4a71      	ldr	r2, [pc, #452]	; (801ba74 <finsh_compile+0x1750>)
 801b8ae:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801b8b0:	4b70      	ldr	r3, [pc, #448]	; (801ba74 <finsh_compile+0x1750>)
 801b8b2:	681b      	ldr	r3, [r3, #0]
 801b8b4:	2223      	movs	r2, #35	; 0x23
 801b8b6:	701a      	strb	r2, [r3, #0]
 801b8b8:	4b6e      	ldr	r3, [pc, #440]	; (801ba74 <finsh_compile+0x1750>)
 801b8ba:	681b      	ldr	r3, [r3, #0]
 801b8bc:	3301      	adds	r3, #1
 801b8be:	4a6d      	ldr	r2, [pc, #436]	; (801ba74 <finsh_compile+0x1750>)
 801b8c0:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801b8c2:	4b6c      	ldr	r3, [pc, #432]	; (801ba74 <finsh_compile+0x1750>)
 801b8c4:	681b      	ldr	r3, [r3, #0]
 801b8c6:	2201      	movs	r2, #1
 801b8c8:	701a      	strb	r2, [r3, #0]
 801b8ca:	4b6a      	ldr	r3, [pc, #424]	; (801ba74 <finsh_compile+0x1750>)
 801b8cc:	681b      	ldr	r3, [r3, #0]
 801b8ce:	3301      	adds	r3, #1
 801b8d0:	2200      	movs	r2, #0
 801b8d2:	701a      	strb	r2, [r3, #0]
 801b8d4:	4b67      	ldr	r3, [pc, #412]	; (801ba74 <finsh_compile+0x1750>)
 801b8d6:	681b      	ldr	r3, [r3, #0]
 801b8d8:	3302      	adds	r3, #2
 801b8da:	4a66      	ldr	r2, [pc, #408]	; (801ba74 <finsh_compile+0x1750>)
 801b8dc:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
 801b8de:	4b65      	ldr	r3, [pc, #404]	; (801ba74 <finsh_compile+0x1750>)
 801b8e0:	681b      	ldr	r3, [r3, #0]
 801b8e2:	2205      	movs	r2, #5
 801b8e4:	701a      	strb	r2, [r3, #0]
 801b8e6:	4b63      	ldr	r3, [pc, #396]	; (801ba74 <finsh_compile+0x1750>)
 801b8e8:	681b      	ldr	r3, [r3, #0]
 801b8ea:	3301      	adds	r3, #1
 801b8ec:	4a61      	ldr	r2, [pc, #388]	; (801ba74 <finsh_compile+0x1750>)
 801b8ee:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801b8f0:	4b60      	ldr	r3, [pc, #384]	; (801ba74 <finsh_compile+0x1750>)
 801b8f2:	681b      	ldr	r3, [r3, #0]
 801b8f4:	2229      	movs	r2, #41	; 0x29
 801b8f6:	701a      	strb	r2, [r3, #0]
 801b8f8:	4b5e      	ldr	r3, [pc, #376]	; (801ba74 <finsh_compile+0x1750>)
 801b8fa:	681b      	ldr	r3, [r3, #0]
 801b8fc:	3301      	adds	r3, #1
 801b8fe:	4a5d      	ldr	r2, [pc, #372]	; (801ba74 <finsh_compile+0x1750>)
 801b900:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801b902:	4b5c      	ldr	r3, [pc, #368]	; (801ba74 <finsh_compile+0x1750>)
 801b904:	681b      	ldr	r3, [r3, #0]
 801b906:	222b      	movs	r2, #43	; 0x2b
 801b908:	701a      	strb	r2, [r3, #0]
 801b90a:	4b5a      	ldr	r3, [pc, #360]	; (801ba74 <finsh_compile+0x1750>)
 801b90c:	681b      	ldr	r3, [r3, #0]
 801b90e:	3301      	adds	r3, #1
 801b910:	4a58      	ldr	r2, [pc, #352]	; (801ba74 <finsh_compile+0x1750>)
 801b912:	6013      	str	r3, [r2, #0]
                    break;
 801b914:	e094      	b.n	801ba40 <finsh_compile+0x171c>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b916:	4b57      	ldr	r3, [pc, #348]	; (801ba74 <finsh_compile+0x1750>)
 801b918:	681b      	ldr	r3, [r3, #0]
 801b91a:	2224      	movs	r2, #36	; 0x24
 801b91c:	701a      	strb	r2, [r3, #0]
 801b91e:	4b55      	ldr	r3, [pc, #340]	; (801ba74 <finsh_compile+0x1750>)
 801b920:	681b      	ldr	r3, [r3, #0]
 801b922:	3301      	adds	r3, #1
 801b924:	4a53      	ldr	r2, [pc, #332]	; (801ba74 <finsh_compile+0x1750>)
 801b926:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801b928:	4b52      	ldr	r3, [pc, #328]	; (801ba74 <finsh_compile+0x1750>)
 801b92a:	681b      	ldr	r3, [r3, #0]
 801b92c:	68ba      	ldr	r2, [r7, #8]
 801b92e:	3214      	adds	r2, #20
 801b930:	b2d2      	uxtb	r2, r2
 801b932:	701a      	strb	r2, [r3, #0]
 801b934:	4b4f      	ldr	r3, [pc, #316]	; (801ba74 <finsh_compile+0x1750>)
 801b936:	681b      	ldr	r3, [r3, #0]
 801b938:	3301      	adds	r3, #1
 801b93a:	68ba      	ldr	r2, [r7, #8]
 801b93c:	3214      	adds	r2, #20
 801b93e:	0a12      	lsrs	r2, r2, #8
 801b940:	b2d2      	uxtb	r2, r2
 801b942:	701a      	strb	r2, [r3, #0]
 801b944:	4b4b      	ldr	r3, [pc, #300]	; (801ba74 <finsh_compile+0x1750>)
 801b946:	681b      	ldr	r3, [r3, #0]
 801b948:	3302      	adds	r3, #2
 801b94a:	68ba      	ldr	r2, [r7, #8]
 801b94c:	3214      	adds	r2, #20
 801b94e:	0c12      	lsrs	r2, r2, #16
 801b950:	b2d2      	uxtb	r2, r2
 801b952:	701a      	strb	r2, [r3, #0]
 801b954:	4b47      	ldr	r3, [pc, #284]	; (801ba74 <finsh_compile+0x1750>)
 801b956:	681b      	ldr	r3, [r3, #0]
 801b958:	3303      	adds	r3, #3
 801b95a:	68ba      	ldr	r2, [r7, #8]
 801b95c:	3214      	adds	r2, #20
 801b95e:	0e12      	lsrs	r2, r2, #24
 801b960:	b2d2      	uxtb	r2, r2
 801b962:	701a      	strb	r2, [r3, #0]
 801b964:	4b43      	ldr	r3, [pc, #268]	; (801ba74 <finsh_compile+0x1750>)
 801b966:	681b      	ldr	r3, [r3, #0]
 801b968:	3304      	adds	r3, #4
 801b96a:	4a42      	ldr	r2, [pc, #264]	; (801ba74 <finsh_compile+0x1750>)
 801b96c:	6013      	str	r3, [r2, #0]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801b96e:	4b41      	ldr	r3, [pc, #260]	; (801ba74 <finsh_compile+0x1750>)
 801b970:	681b      	ldr	r3, [r3, #0]
 801b972:	2227      	movs	r2, #39	; 0x27
 801b974:	701a      	strb	r2, [r3, #0]
 801b976:	4b3f      	ldr	r3, [pc, #252]	; (801ba74 <finsh_compile+0x1750>)
 801b978:	681b      	ldr	r3, [r3, #0]
 801b97a:	3301      	adds	r3, #1
 801b97c:	4a3d      	ldr	r2, [pc, #244]	; (801ba74 <finsh_compile+0x1750>)
 801b97e:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801b980:	4b3c      	ldr	r3, [pc, #240]	; (801ba74 <finsh_compile+0x1750>)
 801b982:	681b      	ldr	r3, [r3, #0]
 801b984:	68ba      	ldr	r2, [r7, #8]
 801b986:	3214      	adds	r2, #20
 801b988:	b2d2      	uxtb	r2, r2
 801b98a:	701a      	strb	r2, [r3, #0]
 801b98c:	4b39      	ldr	r3, [pc, #228]	; (801ba74 <finsh_compile+0x1750>)
 801b98e:	681b      	ldr	r3, [r3, #0]
 801b990:	3301      	adds	r3, #1
 801b992:	68ba      	ldr	r2, [r7, #8]
 801b994:	3214      	adds	r2, #20
 801b996:	0a12      	lsrs	r2, r2, #8
 801b998:	b2d2      	uxtb	r2, r2
 801b99a:	701a      	strb	r2, [r3, #0]
 801b99c:	4b35      	ldr	r3, [pc, #212]	; (801ba74 <finsh_compile+0x1750>)
 801b99e:	681b      	ldr	r3, [r3, #0]
 801b9a0:	3302      	adds	r3, #2
 801b9a2:	68ba      	ldr	r2, [r7, #8]
 801b9a4:	3214      	adds	r2, #20
 801b9a6:	0c12      	lsrs	r2, r2, #16
 801b9a8:	b2d2      	uxtb	r2, r2
 801b9aa:	701a      	strb	r2, [r3, #0]
 801b9ac:	4b31      	ldr	r3, [pc, #196]	; (801ba74 <finsh_compile+0x1750>)
 801b9ae:	681b      	ldr	r3, [r3, #0]
 801b9b0:	3303      	adds	r3, #3
 801b9b2:	68ba      	ldr	r2, [r7, #8]
 801b9b4:	3214      	adds	r2, #20
 801b9b6:	0e12      	lsrs	r2, r2, #24
 801b9b8:	b2d2      	uxtb	r2, r2
 801b9ba:	701a      	strb	r2, [r3, #0]
 801b9bc:	4b2d      	ldr	r3, [pc, #180]	; (801ba74 <finsh_compile+0x1750>)
 801b9be:	681b      	ldr	r3, [r3, #0]
 801b9c0:	3304      	adds	r3, #4
 801b9c2:	4a2c      	ldr	r2, [pc, #176]	; (801ba74 <finsh_compile+0x1750>)
 801b9c4:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801b9c6:	4b2b      	ldr	r3, [pc, #172]	; (801ba74 <finsh_compile+0x1750>)
 801b9c8:	681b      	ldr	r3, [r3, #0]
 801b9ca:	2224      	movs	r2, #36	; 0x24
 801b9cc:	701a      	strb	r2, [r3, #0]
 801b9ce:	4b29      	ldr	r3, [pc, #164]	; (801ba74 <finsh_compile+0x1750>)
 801b9d0:	681b      	ldr	r3, [r3, #0]
 801b9d2:	3301      	adds	r3, #1
 801b9d4:	4a27      	ldr	r2, [pc, #156]	; (801ba74 <finsh_compile+0x1750>)
 801b9d6:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801b9d8:	4b26      	ldr	r3, [pc, #152]	; (801ba74 <finsh_compile+0x1750>)
 801b9da:	681b      	ldr	r3, [r3, #0]
 801b9dc:	2201      	movs	r2, #1
 801b9de:	701a      	strb	r2, [r3, #0]
 801b9e0:	4b24      	ldr	r3, [pc, #144]	; (801ba74 <finsh_compile+0x1750>)
 801b9e2:	681b      	ldr	r3, [r3, #0]
 801b9e4:	3301      	adds	r3, #1
 801b9e6:	2200      	movs	r2, #0
 801b9e8:	701a      	strb	r2, [r3, #0]
 801b9ea:	4b22      	ldr	r3, [pc, #136]	; (801ba74 <finsh_compile+0x1750>)
 801b9ec:	681b      	ldr	r3, [r3, #0]
 801b9ee:	3302      	adds	r3, #2
 801b9f0:	2200      	movs	r2, #0
 801b9f2:	701a      	strb	r2, [r3, #0]
 801b9f4:	4b1f      	ldr	r3, [pc, #124]	; (801ba74 <finsh_compile+0x1750>)
 801b9f6:	681b      	ldr	r3, [r3, #0]
 801b9f8:	3303      	adds	r3, #3
 801b9fa:	2200      	movs	r2, #0
 801b9fc:	701a      	strb	r2, [r3, #0]
 801b9fe:	4b1d      	ldr	r3, [pc, #116]	; (801ba74 <finsh_compile+0x1750>)
 801ba00:	681b      	ldr	r3, [r3, #0]
 801ba02:	3304      	adds	r3, #4
 801ba04:	4a1b      	ldr	r2, [pc, #108]	; (801ba74 <finsh_compile+0x1750>)
 801ba06:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
 801ba08:	4b1a      	ldr	r3, [pc, #104]	; (801ba74 <finsh_compile+0x1750>)
 801ba0a:	681b      	ldr	r3, [r3, #0]
 801ba0c:	2206      	movs	r2, #6
 801ba0e:	701a      	strb	r2, [r3, #0]
 801ba10:	4b18      	ldr	r3, [pc, #96]	; (801ba74 <finsh_compile+0x1750>)
 801ba12:	681b      	ldr	r3, [r3, #0]
 801ba14:	3301      	adds	r3, #1
 801ba16:	4a17      	ldr	r2, [pc, #92]	; (801ba74 <finsh_compile+0x1750>)
 801ba18:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801ba1a:	4b16      	ldr	r3, [pc, #88]	; (801ba74 <finsh_compile+0x1750>)
 801ba1c:	681b      	ldr	r3, [r3, #0]
 801ba1e:	222a      	movs	r2, #42	; 0x2a
 801ba20:	701a      	strb	r2, [r3, #0]
 801ba22:	4b14      	ldr	r3, [pc, #80]	; (801ba74 <finsh_compile+0x1750>)
 801ba24:	681b      	ldr	r3, [r3, #0]
 801ba26:	3301      	adds	r3, #1
 801ba28:	4a12      	ldr	r2, [pc, #72]	; (801ba74 <finsh_compile+0x1750>)
 801ba2a:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801ba2c:	4b11      	ldr	r3, [pc, #68]	; (801ba74 <finsh_compile+0x1750>)
 801ba2e:	681b      	ldr	r3, [r3, #0]
 801ba30:	222b      	movs	r2, #43	; 0x2b
 801ba32:	701a      	strb	r2, [r3, #0]
 801ba34:	4b0f      	ldr	r3, [pc, #60]	; (801ba74 <finsh_compile+0x1750>)
 801ba36:	681b      	ldr	r3, [r3, #0]
 801ba38:	3301      	adds	r3, #1
 801ba3a:	4a0e      	ldr	r2, [pc, #56]	; (801ba74 <finsh_compile+0x1750>)
 801ba3c:	6013      	str	r3, [r2, #0]
                    break;
 801ba3e:	bf00      	nop
                }
            }
            break;
 801ba40:	e04f      	b.n	801bae2 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_NULL:
            finsh_code_dword(0);
 801ba42:	4b0c      	ldr	r3, [pc, #48]	; (801ba74 <finsh_compile+0x1750>)
 801ba44:	681b      	ldr	r3, [r3, #0]
 801ba46:	2200      	movs	r2, #0
 801ba48:	701a      	strb	r2, [r3, #0]
 801ba4a:	4b0a      	ldr	r3, [pc, #40]	; (801ba74 <finsh_compile+0x1750>)
 801ba4c:	681b      	ldr	r3, [r3, #0]
 801ba4e:	3301      	adds	r3, #1
 801ba50:	2200      	movs	r2, #0
 801ba52:	701a      	strb	r2, [r3, #0]
 801ba54:	4b07      	ldr	r3, [pc, #28]	; (801ba74 <finsh_compile+0x1750>)
 801ba56:	681b      	ldr	r3, [r3, #0]
 801ba58:	3302      	adds	r3, #2
 801ba5a:	2200      	movs	r2, #0
 801ba5c:	701a      	strb	r2, [r3, #0]
 801ba5e:	4b05      	ldr	r3, [pc, #20]	; (801ba74 <finsh_compile+0x1750>)
 801ba60:	681b      	ldr	r3, [r3, #0]
 801ba62:	3303      	adds	r3, #3
 801ba64:	2200      	movs	r2, #0
 801ba66:	701a      	strb	r2, [r3, #0]
 801ba68:	4b02      	ldr	r3, [pc, #8]	; (801ba74 <finsh_compile+0x1750>)
 801ba6a:	681b      	ldr	r3, [r3, #0]
 801ba6c:	3304      	adds	r3, #4
 801ba6e:	4a01      	ldr	r2, [pc, #4]	; (801ba74 <finsh_compile+0x1750>)
 801ba70:	6013      	str	r3, [r2, #0]
            break;
 801ba72:	e036      	b.n	801bae2 <finsh_compile+0x17be>
 801ba74:	200126e4 	.word	0x200126e4

        case FINSH_NODE_SYS_GETVALUE:
            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801ba78:	687b      	ldr	r3, [r7, #4]
 801ba7a:	789b      	ldrb	r3, [r3, #2]
 801ba7c:	f003 0308 	and.w	r3, r3, #8
 801ba80:	2b00      	cmp	r3, #0
 801ba82:	d126      	bne.n	801bad2 <finsh_compile+0x17ae>
            {
                /* nothing will be generated */
            }
            else
            {
                switch (node->data_type)
 801ba84:	687b      	ldr	r3, [r7, #4]
 801ba86:	785b      	ldrb	r3, [r3, #1]
 801ba88:	2b02      	cmp	r3, #2
 801ba8a:	d00e      	beq.n	801baaa <finsh_compile+0x1786>
 801ba8c:	2b03      	cmp	r3, #3
 801ba8e:	d016      	beq.n	801babe <finsh_compile+0x179a>
 801ba90:	2b01      	cmp	r3, #1
 801ba92:	d000      	beq.n	801ba96 <finsh_compile+0x1772>
                    break;
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
                    break;
                default:
                    break;
 801ba94:	e01d      	b.n	801bad2 <finsh_compile+0x17ae>
            else
            {
                switch (node->data_type)
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801ba96:	4b1a      	ldr	r3, [pc, #104]	; (801bb00 <finsh_compile+0x17dc>)
 801ba98:	681b      	ldr	r3, [r3, #0]
 801ba9a:	222d      	movs	r2, #45	; 0x2d
 801ba9c:	701a      	strb	r2, [r3, #0]
 801ba9e:	4b18      	ldr	r3, [pc, #96]	; (801bb00 <finsh_compile+0x17dc>)
 801baa0:	681b      	ldr	r3, [r3, #0]
 801baa2:	3301      	adds	r3, #1
 801baa4:	4a16      	ldr	r2, [pc, #88]	; (801bb00 <finsh_compile+0x17dc>)
 801baa6:	6013      	str	r3, [r2, #0]
                    break;
 801baa8:	e013      	b.n	801bad2 <finsh_compile+0x17ae>
                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801baaa:	4b15      	ldr	r3, [pc, #84]	; (801bb00 <finsh_compile+0x17dc>)
 801baac:	681b      	ldr	r3, [r3, #0]
 801baae:	222e      	movs	r2, #46	; 0x2e
 801bab0:	701a      	strb	r2, [r3, #0]
 801bab2:	4b13      	ldr	r3, [pc, #76]	; (801bb00 <finsh_compile+0x17dc>)
 801bab4:	681b      	ldr	r3, [r3, #0]
 801bab6:	3301      	adds	r3, #1
 801bab8:	4a11      	ldr	r2, [pc, #68]	; (801bb00 <finsh_compile+0x17dc>)
 801baba:	6013      	str	r3, [r2, #0]
                    break;
 801babc:	e009      	b.n	801bad2 <finsh_compile+0x17ae>
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801babe:	4b10      	ldr	r3, [pc, #64]	; (801bb00 <finsh_compile+0x17dc>)
 801bac0:	681b      	ldr	r3, [r3, #0]
 801bac2:	222f      	movs	r2, #47	; 0x2f
 801bac4:	701a      	strb	r2, [r3, #0]
 801bac6:	4b0e      	ldr	r3, [pc, #56]	; (801bb00 <finsh_compile+0x17dc>)
 801bac8:	681b      	ldr	r3, [r3, #0]
 801baca:	3301      	adds	r3, #1
 801bacc:	4a0c      	ldr	r2, [pc, #48]	; (801bb00 <finsh_compile+0x17dc>)
 801bace:	6013      	str	r3, [r2, #0]
                    break;
 801bad0:	bf00      	nop
                default:
                    break;
                }
            }
            break;
 801bad2:	e006      	b.n	801bae2 <finsh_compile+0x17be>
        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;

        default:
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
 801bad4:	2008      	movs	r0, #8
 801bad6:	f000 f971 	bl	801bdbc <finsh_error_set>
            break;
 801bada:	e002      	b.n	801bae2 <finsh_compile+0x17be>
            }
            break;

        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;
 801badc:	bf00      	nop
 801bade:	e000      	b.n	801bae2 <finsh_compile+0x17be>
                            break;
                        }
                    }
                }
            }
            break;
 801bae0:	bf00      	nop
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
            break;
        }

        /* compile sibling node */
        if (finsh_node_sibling(node) != NULL)
 801bae2:	687b      	ldr	r3, [r7, #4]
 801bae4:	68db      	ldr	r3, [r3, #12]
 801bae6:	2b00      	cmp	r3, #0
 801bae8:	d004      	beq.n	801baf4 <finsh_compile+0x17d0>
            finsh_compile(finsh_node_sibling(node));
 801baea:	687b      	ldr	r3, [r7, #4]
 801baec:	68db      	ldr	r3, [r3, #12]
 801baee:	4618      	mov	r0, r3
 801baf0:	f7fe fc18 	bl	801a324 <finsh_compile>
    }

    return 0;
 801baf4:	2300      	movs	r3, #0
}
 801baf6:	4618      	mov	r0, r3
 801baf8:	3728      	adds	r7, #40	; 0x28
 801bafa:	46bd      	mov	sp, r7
 801bafc:	bd80      	pop	{r7, pc}
 801bafe:	bf00      	nop
 801bb00:	200126e4 	.word	0x200126e4

0801bb04 <finsh_type_check>:

static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
 801bb04:	b580      	push	{r7, lr}
 801bb06:	b084      	sub	sp, #16
 801bb08:	af00      	add	r7, sp, #0
 801bb0a:	6078      	str	r0, [r7, #4]
 801bb0c:	460b      	mov	r3, r1
 801bb0e:	70fb      	strb	r3, [r7, #3]
    if (node != NULL)
 801bb10:	687b      	ldr	r3, [r7, #4]
 801bb12:	2b00      	cmp	r3, #0
 801bb14:	f000 80fc 	beq.w	801bd10 <finsh_type_check+0x20c>
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
 801bb18:	687b      	ldr	r3, [r7, #4]
 801bb1a:	781b      	ldrb	r3, [r3, #0]
 801bb1c:	2b13      	cmp	r3, #19
 801bb1e:	d00b      	beq.n	801bb38 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREINC ||
 801bb20:	687b      	ldr	r3, [r7, #4]
 801bb22:	781b      	ldrb	r3, [r3, #0]
static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
 801bb24:	2b15      	cmp	r3, #21
 801bb26:	d007      	beq.n	801bb38 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
 801bb28:	687b      	ldr	r3, [r7, #4]
 801bb2a:	781b      	ldrb	r3, [r3, #0]
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
 801bb2c:	2b16      	cmp	r3, #22
 801bb2e:	d003      	beq.n	801bb38 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREDEC ||
            node->node_type == FINSH_NODE_SYS_GETADDR)
 801bb30:	687b      	ldr	r3, [r7, #4]
 801bb32:	781b      	ldrb	r3, [r3, #0]
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
 801bb34:	2b1a      	cmp	r3, #26
 801bb36:	d106      	bne.n	801bb46 <finsh_type_check+0x42>
            node->node_type == FINSH_NODE_SYS_GETADDR)
        {
            /* address */
            finsh_type_check(finsh_node_child(node), FINSH_IDTYPE_ADDRESS);
 801bb38:	687b      	ldr	r3, [r7, #4]
 801bb3a:	691b      	ldr	r3, [r3, #16]
 801bb3c:	4618      	mov	r0, r3
 801bb3e:	2108      	movs	r1, #8
 801bb40:	f7ff ffe0 	bl	801bb04 <finsh_type_check>
 801bb44:	e014      	b.n	801bb70 <finsh_type_check+0x6c>
        }
        else if (node->node_type == FINSH_NODE_SYS_GETVALUE && is_addr)
 801bb46:	687b      	ldr	r3, [r7, #4]
 801bb48:	781b      	ldrb	r3, [r3, #0]
 801bb4a:	2b19      	cmp	r3, #25
 801bb4c:	d109      	bne.n	801bb62 <finsh_type_check+0x5e>
 801bb4e:	78fb      	ldrb	r3, [r7, #3]
 801bb50:	2b00      	cmp	r3, #0
 801bb52:	d006      	beq.n	801bb62 <finsh_type_check+0x5e>
        {
            /* change the attribute of getvalue in left expr */
            finsh_type_check(finsh_node_child(node), 0);
 801bb54:	687b      	ldr	r3, [r7, #4]
 801bb56:	691b      	ldr	r3, [r3, #16]
 801bb58:	4618      	mov	r0, r3
 801bb5a:	2100      	movs	r1, #0
 801bb5c:	f7ff ffd2 	bl	801bb04 <finsh_type_check>
 801bb60:	e006      	b.n	801bb70 <finsh_type_check+0x6c>
        }
        else
        {
            /* transfer 'av' to child node */
            finsh_type_check(finsh_node_child(node), is_addr);
 801bb62:	687b      	ldr	r3, [r7, #4]
 801bb64:	691a      	ldr	r2, [r3, #16]
 801bb66:	78fb      	ldrb	r3, [r7, #3]
 801bb68:	4610      	mov	r0, r2
 801bb6a:	4619      	mov	r1, r3
 801bb6c:	f7ff ffca 	bl	801bb04 <finsh_type_check>
        }

        /* always does not load address in sibling */
        finsh_type_check(finsh_node_sibling(node), FINSH_NODE_VALUE);
 801bb70:	687b      	ldr	r3, [r7, #4]
 801bb72:	68db      	ldr	r3, [r3, #12]
 801bb74:	4618      	mov	r0, r3
 801bb76:	2100      	movs	r1, #0
 801bb78:	f7ff ffc4 	bl	801bb04 <finsh_type_check>

        /** set attribute of current node */

        /* make sure the current node is address or value */
        if (node->idtype != FINSH_IDTYPE_SYSCALL) node->idtype |= is_addr;
 801bb7c:	687b      	ldr	r3, [r7, #4]
 801bb7e:	789b      	ldrb	r3, [r3, #2]
 801bb80:	2b04      	cmp	r3, #4
 801bb82:	d006      	beq.n	801bb92 <finsh_type_check+0x8e>
 801bb84:	687b      	ldr	r3, [r7, #4]
 801bb86:	789a      	ldrb	r2, [r3, #2]
 801bb88:	78fb      	ldrb	r3, [r7, #3]
 801bb8a:	4313      	orrs	r3, r2
 801bb8c:	b2da      	uxtb	r2, r3
 801bb8e:	687b      	ldr	r3, [r7, #4]
 801bb90:	709a      	strb	r2, [r3, #2]

        if (finsh_node_child(node) != NULL)
 801bb92:	687b      	ldr	r3, [r7, #4]
 801bb94:	691b      	ldr	r3, [r3, #16]
 801bb96:	2b00      	cmp	r3, #0
 801bb98:	d006      	beq.n	801bba8 <finsh_type_check+0xa4>
        {
            node->data_type = finsh_node_child(node)->data_type;
 801bb9a:	687b      	ldr	r3, [r7, #4]
 801bb9c:	691b      	ldr	r3, [r3, #16]
 801bb9e:	785a      	ldrb	r2, [r3, #1]
 801bba0:	687b      	ldr	r3, [r7, #4]
 801bba2:	705a      	strb	r2, [r3, #1]
            return 0;
 801bba4:	2300      	movs	r3, #0
 801bba6:	e0b4      	b.n	801bd12 <finsh_type_check+0x20e>
        }

        if (node->node_type == FINSH_NODE_ID)
 801bba8:	687b      	ldr	r3, [r7, #4]
 801bbaa:	781b      	ldrb	r3, [r3, #0]
 801bbac:	2b01      	cmp	r3, #1
 801bbae:	f040 8094 	bne.w	801bcda <finsh_type_check+0x1d6>
        {
            if (node->idtype & FINSH_IDTYPE_VAR)
 801bbb2:	687b      	ldr	r3, [r7, #4]
 801bbb4:	789b      	ldrb	r3, [r3, #2]
 801bbb6:	f003 0301 	and.w	r3, r3, #1
 801bbba:	2b00      	cmp	r3, #0
 801bbbc:	d043      	beq.n	801bc46 <finsh_type_check+0x142>
            {
                struct finsh_var* var;

                var = node->id.var;
 801bbbe:	687b      	ldr	r3, [r7, #4]
 801bbc0:	689b      	ldr	r3, [r3, #8]
 801bbc2:	60fb      	str	r3, [r7, #12]
                if (var != NULL)
 801bbc4:	68fb      	ldr	r3, [r7, #12]
 801bbc6:	2b00      	cmp	r3, #0
 801bbc8:	d03c      	beq.n	801bc44 <finsh_type_check+0x140>
                {
                    switch (var->type)
 801bbca:	68fb      	ldr	r3, [r7, #12]
 801bbcc:	7c5b      	ldrb	r3, [r3, #17]
 801bbce:	3b01      	subs	r3, #1
 801bbd0:	2b0d      	cmp	r3, #13
 801bbd2:	d833      	bhi.n	801bc3c <finsh_type_check+0x138>
 801bbd4:	a201      	add	r2, pc, #4	; (adr r2, 801bbdc <finsh_type_check+0xd8>)
 801bbd6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801bbda:	bf00      	nop
 801bbdc:	0801bc15 	.word	0x0801bc15
 801bbe0:	0801bc35 	.word	0x0801bc35
 801bbe4:	0801bc1d 	.word	0x0801bc1d
 801bbe8:	0801bc1d 	.word	0x0801bc1d
 801bbec:	0801bc35 	.word	0x0801bc35
 801bbf0:	0801bc25 	.word	0x0801bc25
 801bbf4:	0801bc25 	.word	0x0801bc25
 801bbf8:	0801bc35 	.word	0x0801bc35
 801bbfc:	0801bc2d 	.word	0x0801bc2d
 801bc00:	0801bc2d 	.word	0x0801bc2d
 801bc04:	0801bc35 	.word	0x0801bc35
 801bc08:	0801bc2d 	.word	0x0801bc2d
 801bc0c:	0801bc2d 	.word	0x0801bc2d
 801bc10:	0801bc35 	.word	0x0801bc35
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
 801bc14:	687b      	ldr	r3, [r7, #4]
 801bc16:	2200      	movs	r2, #0
 801bc18:	705a      	strb	r2, [r3, #1]
                        break;
 801bc1a:	e013      	b.n	801bc44 <finsh_type_check+0x140>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
 801bc1c:	687b      	ldr	r3, [r7, #4]
 801bc1e:	2201      	movs	r2, #1
 801bc20:	705a      	strb	r2, [r3, #1]
                        break;
 801bc22:	e00f      	b.n	801bc44 <finsh_type_check+0x140>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
 801bc24:	687b      	ldr	r3, [r7, #4]
 801bc26:	2202      	movs	r2, #2
 801bc28:	705a      	strb	r2, [r3, #1]
                        break;
 801bc2a:	e00b      	b.n	801bc44 <finsh_type_check+0x140>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801bc2c:	687b      	ldr	r3, [r7, #4]
 801bc2e:	2203      	movs	r2, #3
 801bc30:	705a      	strb	r2, [r3, #1]
                        break;
 801bc32:	e007      	b.n	801bc44 <finsh_type_check+0x140>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801bc34:	687b      	ldr	r3, [r7, #4]
 801bc36:	2203      	movs	r2, #3
 801bc38:	705a      	strb	r2, [r3, #1]
                        break;
 801bc3a:	e003      	b.n	801bc44 <finsh_type_check+0x140>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801bc3c:	2003      	movs	r0, #3
 801bc3e:	f000 f8bd 	bl	801bdbc <finsh_error_set>
                        break;
 801bc42:	bf00      	nop
 801bc44:	e064      	b.n	801bd10 <finsh_type_check+0x20c>
                    }
                }
            }
            else if (node->idtype & FINSH_IDTYPE_SYSVAR)
 801bc46:	687b      	ldr	r3, [r7, #4]
 801bc48:	789b      	ldrb	r3, [r3, #2]
 801bc4a:	f003 0302 	and.w	r3, r3, #2
 801bc4e:	2b00      	cmp	r3, #0
 801bc50:	d042      	beq.n	801bcd8 <finsh_type_check+0x1d4>
            {
                struct finsh_sysvar *sysvar;

                sysvar = node->id.sysvar;
 801bc52:	687b      	ldr	r3, [r7, #4]
 801bc54:	689b      	ldr	r3, [r3, #8]
 801bc56:	60bb      	str	r3, [r7, #8]
                if (sysvar != NULL)
 801bc58:	68bb      	ldr	r3, [r7, #8]
 801bc5a:	2b00      	cmp	r3, #0
 801bc5c:	d03c      	beq.n	801bcd8 <finsh_type_check+0x1d4>
                {
                    switch (sysvar->type)
 801bc5e:	68bb      	ldr	r3, [r7, #8]
 801bc60:	7a1b      	ldrb	r3, [r3, #8]
 801bc62:	3b01      	subs	r3, #1
 801bc64:	2b0d      	cmp	r3, #13
 801bc66:	d833      	bhi.n	801bcd0 <finsh_type_check+0x1cc>
 801bc68:	a201      	add	r2, pc, #4	; (adr r2, 801bc70 <finsh_type_check+0x16c>)
 801bc6a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801bc6e:	bf00      	nop
 801bc70:	0801bca9 	.word	0x0801bca9
 801bc74:	0801bcc9 	.word	0x0801bcc9
 801bc78:	0801bcb1 	.word	0x0801bcb1
 801bc7c:	0801bcb1 	.word	0x0801bcb1
 801bc80:	0801bcc9 	.word	0x0801bcc9
 801bc84:	0801bcb9 	.word	0x0801bcb9
 801bc88:	0801bcb9 	.word	0x0801bcb9
 801bc8c:	0801bcc9 	.word	0x0801bcc9
 801bc90:	0801bcc1 	.word	0x0801bcc1
 801bc94:	0801bcc1 	.word	0x0801bcc1
 801bc98:	0801bcc9 	.word	0x0801bcc9
 801bc9c:	0801bcc1 	.word	0x0801bcc1
 801bca0:	0801bcc1 	.word	0x0801bcc1
 801bca4:	0801bcc9 	.word	0x0801bcc9
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
 801bca8:	687b      	ldr	r3, [r7, #4]
 801bcaa:	2200      	movs	r2, #0
 801bcac:	705a      	strb	r2, [r3, #1]
                        break;
 801bcae:	e013      	b.n	801bcd8 <finsh_type_check+0x1d4>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
 801bcb0:	687b      	ldr	r3, [r7, #4]
 801bcb2:	2201      	movs	r2, #1
 801bcb4:	705a      	strb	r2, [r3, #1]
                        break;
 801bcb6:	e00f      	b.n	801bcd8 <finsh_type_check+0x1d4>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
 801bcb8:	687b      	ldr	r3, [r7, #4]
 801bcba:	2202      	movs	r2, #2
 801bcbc:	705a      	strb	r2, [r3, #1]
                        break;
 801bcbe:	e00b      	b.n	801bcd8 <finsh_type_check+0x1d4>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801bcc0:	687b      	ldr	r3, [r7, #4]
 801bcc2:	2203      	movs	r2, #3
 801bcc4:	705a      	strb	r2, [r3, #1]
                        break;
 801bcc6:	e007      	b.n	801bcd8 <finsh_type_check+0x1d4>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801bcc8:	687b      	ldr	r3, [r7, #4]
 801bcca:	2203      	movs	r2, #3
 801bccc:	705a      	strb	r2, [r3, #1]
                        break;
 801bcce:	e003      	b.n	801bcd8 <finsh_type_check+0x1d4>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801bcd0:	2003      	movs	r0, #3
 801bcd2:	f000 f873 	bl	801bdbc <finsh_error_set>
                        break;
 801bcd6:	bf00      	nop
 801bcd8:	e01a      	b.n	801bd10 <finsh_type_check+0x20c>
                    }
                }
            }
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
 801bcda:	687b      	ldr	r3, [r7, #4]
 801bcdc:	781b      	ldrb	r3, [r3, #0]
 801bcde:	2b02      	cmp	r3, #2
 801bce0:	d103      	bne.n	801bcea <finsh_type_check+0x1e6>
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
 801bce2:	687b      	ldr	r3, [r7, #4]
 801bce4:	2201      	movs	r2, #1
 801bce6:	705a      	strb	r2, [r3, #1]
 801bce8:	e012      	b.n	801bd10 <finsh_type_check+0x20c>
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
 801bcea:	687b      	ldr	r3, [r7, #4]
 801bcec:	781b      	ldrb	r3, [r3, #0]
 801bcee:	2b03      	cmp	r3, #3
 801bcf0:	d00b      	beq.n	801bd0a <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
 801bcf2:	687b      	ldr	r3, [r7, #4]
 801bcf4:	781b      	ldrb	r3, [r3, #0]
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
 801bcf6:	2b04      	cmp	r3, #4
 801bcf8:	d007      	beq.n	801bd0a <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
 801bcfa:	687b      	ldr	r3, [r7, #4]
 801bcfc:	781b      	ldrb	r3, [r3, #0]
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
 801bcfe:	2b05      	cmp	r3, #5
 801bd00:	d003      	beq.n	801bd0a <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_STRING  ||
            node->node_type == FINSH_NODE_VALUE_NULL)
 801bd02:	687b      	ldr	r3, [r7, #4]
 801bd04:	781b      	ldrb	r3, [r3, #0]
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
 801bd06:	2b06      	cmp	r3, #6
 801bd08:	d102      	bne.n	801bd10 <finsh_type_check+0x20c>
            node->node_type == FINSH_NODE_VALUE_NULL)
        {
            node->data_type = FINSH_DATA_TYPE_DWORD;
 801bd0a:	687b      	ldr	r3, [r7, #4]
 801bd0c:	2203      	movs	r2, #3
 801bd0e:	705a      	strb	r2, [r3, #1]
        }
    }
    return 0;
 801bd10:	2300      	movs	r3, #0
}
 801bd12:	4618      	mov	r0, r3
 801bd14:	3710      	adds	r7, #16
 801bd16:	46bd      	mov	sp, r7
 801bd18:	bd80      	pop	{r7, pc}
 801bd1a:	bf00      	nop

0801bd1c <finsh_compiler_run>:

int finsh_compiler_run(struct finsh_node* node)
{
 801bd1c:	b580      	push	{r7, lr}
 801bd1e:	b084      	sub	sp, #16
 801bd20:	af00      	add	r7, sp, #0
 801bd22:	6078      	str	r0, [r7, #4]
    struct finsh_node* sibling;

    /* type check */
    finsh_type_check(node, FINSH_NODE_VALUE);
 801bd24:	6878      	ldr	r0, [r7, #4]
 801bd26:	2100      	movs	r1, #0
 801bd28:	f7ff feec 	bl	801bb04 <finsh_type_check>

    /* clean text segment and vm stack */
    memset(&text_segment[0], 0, sizeof(text_segment));
 801bd2c:	4818      	ldr	r0, [pc, #96]	; (801bd90 <finsh_compiler_run+0x74>)
 801bd2e:	2100      	movs	r1, #0
 801bd30:	2280      	movs	r2, #128	; 0x80
 801bd32:	f003 f9ff 	bl	801f134 <memset>
    memset(&finsh_vm_stack[0], 0, sizeof(finsh_vm_stack[0]));
 801bd36:	4817      	ldr	r0, [pc, #92]	; (801bd94 <finsh_compiler_run+0x78>)
 801bd38:	2100      	movs	r1, #0
 801bd3a:	2204      	movs	r2, #4
 801bd3c:	f003 f9fa 	bl	801f134 <memset>

    /* reset compile stack pointer and pc */
    finsh_compile_sp = &finsh_vm_stack[0];
 801bd40:	4b15      	ldr	r3, [pc, #84]	; (801bd98 <finsh_compiler_run+0x7c>)
 801bd42:	4a14      	ldr	r2, [pc, #80]	; (801bd94 <finsh_compiler_run+0x78>)
 801bd44:	601a      	str	r2, [r3, #0]
    finsh_compile_pc = &text_segment[0];
 801bd46:	4b15      	ldr	r3, [pc, #84]	; (801bd9c <finsh_compiler_run+0x80>)
 801bd48:	4a11      	ldr	r2, [pc, #68]	; (801bd90 <finsh_compiler_run+0x74>)
 801bd4a:	601a      	str	r2, [r3, #0]

    /* compile node */
    sibling = node;
 801bd4c:	687b      	ldr	r3, [r7, #4]
 801bd4e:	60fb      	str	r3, [r7, #12]
    while (sibling != NULL)
 801bd50:	e016      	b.n	801bd80 <finsh_compiler_run+0x64>
    {
        struct finsh_node* current_node;
        current_node = sibling;
 801bd52:	68fb      	ldr	r3, [r7, #12]
 801bd54:	60bb      	str	r3, [r7, #8]

        /* get sibling node */
        sibling = current_node->sibling;
 801bd56:	68bb      	ldr	r3, [r7, #8]
 801bd58:	68db      	ldr	r3, [r3, #12]
 801bd5a:	60fb      	str	r3, [r7, #12]

        /* clean sibling node */
        current_node->sibling = NULL;
 801bd5c:	68bb      	ldr	r3, [r7, #8]
 801bd5e:	2200      	movs	r2, #0
 801bd60:	60da      	str	r2, [r3, #12]
        finsh_compile(current_node);
 801bd62:	68b8      	ldr	r0, [r7, #8]
 801bd64:	f7fe fade 	bl	801a324 <finsh_compile>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
 801bd68:	68fb      	ldr	r3, [r7, #12]
 801bd6a:	2b00      	cmp	r3, #0
 801bd6c:	d008      	beq.n	801bd80 <finsh_compiler_run+0x64>
 801bd6e:	4b0b      	ldr	r3, [pc, #44]	; (801bd9c <finsh_compiler_run+0x80>)
 801bd70:	681b      	ldr	r3, [r3, #0]
 801bd72:	222b      	movs	r2, #43	; 0x2b
 801bd74:	701a      	strb	r2, [r3, #0]
 801bd76:	4b09      	ldr	r3, [pc, #36]	; (801bd9c <finsh_compiler_run+0x80>)
 801bd78:	681b      	ldr	r3, [r3, #0]
 801bd7a:	3301      	adds	r3, #1
 801bd7c:	4a07      	ldr	r2, [pc, #28]	; (801bd9c <finsh_compiler_run+0x80>)
 801bd7e:	6013      	str	r3, [r2, #0]
    finsh_compile_sp = &finsh_vm_stack[0];
    finsh_compile_pc = &text_segment[0];

    /* compile node */
    sibling = node;
    while (sibling != NULL)
 801bd80:	68fb      	ldr	r3, [r7, #12]
 801bd82:	2b00      	cmp	r3, #0
 801bd84:	d1e5      	bne.n	801bd52 <finsh_compiler_run+0x36>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
    }

    return 0;
 801bd86:	2300      	movs	r3, #0
}
 801bd88:	4618      	mov	r0, r3
 801bd8a:	3710      	adds	r7, #16
 801bd8c:	46bd      	mov	sp, r7
 801bd8e:	bd80      	pop	{r7, pc}
 801bd90:	20012974 	.word	0x20012974
 801bd94:	200129f4 	.word	0x200129f4
 801bd98:	200126e8 	.word	0x200126e8
 801bd9c:	200126e4 	.word	0x200126e4

0801bda0 <finsh_error_init>:
	"Unknown symbol",
	"Null node"
};

int finsh_error_init()
{
 801bda0:	b480      	push	{r7}
 801bda2:	af00      	add	r7, sp, #0
	global_errno = FINSH_ERROR_OK;
 801bda4:	4b04      	ldr	r3, [pc, #16]	; (801bdb8 <finsh_error_init+0x18>)
 801bda6:	2200      	movs	r2, #0
 801bda8:	701a      	strb	r2, [r3, #0]

	return 0;
 801bdaa:	2300      	movs	r3, #0
}
 801bdac:	4618      	mov	r0, r3
 801bdae:	46bd      	mov	sp, r7
 801bdb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bdb4:	4770      	bx	lr
 801bdb6:	bf00      	nop
 801bdb8:	200126ec 	.word	0x200126ec

0801bdbc <finsh_error_set>:

int finsh_error_set(u_char type)
{
 801bdbc:	b480      	push	{r7}
 801bdbe:	b083      	sub	sp, #12
 801bdc0:	af00      	add	r7, sp, #0
 801bdc2:	4603      	mov	r3, r0
 801bdc4:	71fb      	strb	r3, [r7, #7]
	global_errno = type;
 801bdc6:	4a05      	ldr	r2, [pc, #20]	; (801bddc <finsh_error_set+0x20>)
 801bdc8:	79fb      	ldrb	r3, [r7, #7]
 801bdca:	7013      	strb	r3, [r2, #0]

	return 0;
 801bdcc:	2300      	movs	r3, #0
}
 801bdce:	4618      	mov	r0, r3
 801bdd0:	370c      	adds	r7, #12
 801bdd2:	46bd      	mov	sp, r7
 801bdd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bdd8:	4770      	bx	lr
 801bdda:	bf00      	nop
 801bddc:	200126ec 	.word	0x200126ec

0801bde0 <finsh_errno>:

u_char finsh_errno()
{
 801bde0:	b480      	push	{r7}
 801bde2:	af00      	add	r7, sp, #0
	return global_errno;
 801bde4:	4b03      	ldr	r3, [pc, #12]	; (801bdf4 <finsh_errno+0x14>)
 801bde6:	781b      	ldrb	r3, [r3, #0]
}
 801bde8:	4618      	mov	r0, r3
 801bdea:	46bd      	mov	sp, r7
 801bdec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bdf0:	4770      	bx	lr
 801bdf2:	bf00      	nop
 801bdf4:	200126ec 	.word	0x200126ec

0801bdf8 <finsh_error_string>:

const char* finsh_error_string(u_char type)
{
 801bdf8:	b480      	push	{r7}
 801bdfa:	b083      	sub	sp, #12
 801bdfc:	af00      	add	r7, sp, #0
 801bdfe:	4603      	mov	r3, r0
 801be00:	71fb      	strb	r3, [r7, #7]
	return finsh_error_string_table[type];
 801be02:	79fb      	ldrb	r3, [r7, #7]
 801be04:	4a04      	ldr	r2, [pc, #16]	; (801be18 <finsh_error_string+0x20>)
 801be06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 801be0a:	4618      	mov	r0, r3
 801be0c:	370c      	adds	r7, #12
 801be0e:	46bd      	mov	sp, r7
 801be10:	f85d 7b04 	ldr.w	r7, [sp], #4
 801be14:	4770      	bx	lr
 801be16:	bf00      	nop
 801be18:	200100c8 	.word	0x200100c8

0801be1c <finsh_heap_init>:
static void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header);
static void finsh_block_split(struct finsh_block_header* header, size_t size);
static void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header);

int finsh_heap_init(void)
{
 801be1c:	b580      	push	{r7, lr}
 801be1e:	af00      	add	r7, sp, #0
	/* clear heap to zero */
	memset(&finsh_heap[0], 0, sizeof(finsh_heap));
 801be20:	480a      	ldr	r0, [pc, #40]	; (801be4c <finsh_heap_init+0x30>)
 801be22:	2100      	movs	r1, #0
 801be24:	2280      	movs	r2, #128	; 0x80
 801be26:	f003 f985 	bl	801f134 <memset>

	/* init free and alloc list */
    free_list           = BLOCK_HEADER(&finsh_heap[0]);
 801be2a:	4b09      	ldr	r3, [pc, #36]	; (801be50 <finsh_heap_init+0x34>)
 801be2c:	4a07      	ldr	r2, [pc, #28]	; (801be4c <finsh_heap_init+0x30>)
 801be2e:	601a      	str	r2, [r3, #0]
	free_list->length   = FINSH_HEAP_MAX - sizeof(struct finsh_block_header);
 801be30:	4b07      	ldr	r3, [pc, #28]	; (801be50 <finsh_heap_init+0x34>)
 801be32:	681b      	ldr	r3, [r3, #0]
 801be34:	2278      	movs	r2, #120	; 0x78
 801be36:	601a      	str	r2, [r3, #0]
    free_list->next     = NULL;
 801be38:	4b05      	ldr	r3, [pc, #20]	; (801be50 <finsh_heap_init+0x34>)
 801be3a:	681b      	ldr	r3, [r3, #0]
 801be3c:	2200      	movs	r2, #0
 801be3e:	605a      	str	r2, [r3, #4]

    allocate_list       = NULL;
 801be40:	4b04      	ldr	r3, [pc, #16]	; (801be54 <finsh_heap_init+0x38>)
 801be42:	2200      	movs	r2, #0
 801be44:	601a      	str	r2, [r3, #0]

    return 0;
 801be46:	2300      	movs	r3, #0
}
 801be48:	4618      	mov	r0, r3
 801be4a:	bd80      	pop	{r7, pc}
 801be4c:	200126f0 	.word	0x200126f0
 801be50:	200121e0 	.word	0x200121e0
 801be54:	200121e4 	.word	0x200121e4

0801be58 <finsh_heap_allocate>:

/**
 * allocate a block from heap
 */
void* finsh_heap_allocate(size_t size)
{
 801be58:	b580      	push	{r7, lr}
 801be5a:	b084      	sub	sp, #16
 801be5c:	af00      	add	r7, sp, #0
 801be5e:	6078      	str	r0, [r7, #4]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);
 801be60:	687b      	ldr	r3, [r7, #4]
 801be62:	3303      	adds	r3, #3
 801be64:	f023 0303 	bic.w	r3, r3, #3
 801be68:	607b      	str	r3, [r7, #4]

    /* find the first fit block */
    for (header = free_list;
 801be6a:	4b23      	ldr	r3, [pc, #140]	; (801bef8 <finsh_heap_allocate+0xa0>)
 801be6c:	681b      	ldr	r3, [r3, #0]
 801be6e:	60fb      	str	r3, [r7, #12]
 801be70:	e002      	b.n	801be78 <finsh_heap_allocate+0x20>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
        header = header->next) ;
 801be72:	68fb      	ldr	r3, [r7, #12]
 801be74:	685b      	ldr	r3, [r3, #4]
 801be76:	60fb      	str	r3, [r7, #12]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);

    /* find the first fit block */
    for (header = free_list;
 801be78:	68fb      	ldr	r3, [r7, #12]
 801be7a:	2b00      	cmp	r3, #0
 801be7c:	d005      	beq.n	801be8a <finsh_heap_allocate+0x32>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
 801be7e:	68fb      	ldr	r3, [r7, #12]
 801be80:	681a      	ldr	r2, [r3, #0]
 801be82:	687b      	ldr	r3, [r7, #4]
 801be84:	3308      	adds	r3, #8
 801be86:	429a      	cmp	r2, r3
 801be88:	d9f3      	bls.n	801be72 <finsh_heap_allocate+0x1a>
        header = header->next) ;

	if (header == NULL)
 801be8a:	68fb      	ldr	r3, [r7, #12]
 801be8c:	2b00      	cmp	r3, #0
 801be8e:	d116      	bne.n	801bebe <finsh_heap_allocate+0x66>
	{
		finsh_heap_gc();
 801be90:	f000 f850 	bl	801bf34 <finsh_heap_gc>

		/* find the first fit block */
		for (header = free_list;
 801be94:	4b18      	ldr	r3, [pc, #96]	; (801bef8 <finsh_heap_allocate+0xa0>)
 801be96:	681b      	ldr	r3, [r3, #0]
 801be98:	60fb      	str	r3, [r7, #12]
 801be9a:	e002      	b.n	801bea2 <finsh_heap_allocate+0x4a>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
			header = header->next) ;
 801be9c:	68fb      	ldr	r3, [r7, #12]
 801be9e:	685b      	ldr	r3, [r3, #4]
 801bea0:	60fb      	str	r3, [r7, #12]
	if (header == NULL)
	{
		finsh_heap_gc();

		/* find the first fit block */
		for (header = free_list;
 801bea2:	68fb      	ldr	r3, [r7, #12]
 801bea4:	2b00      	cmp	r3, #0
 801bea6:	d005      	beq.n	801beb4 <finsh_heap_allocate+0x5c>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
 801bea8:	68fb      	ldr	r3, [r7, #12]
 801beaa:	681a      	ldr	r2, [r3, #0]
 801beac:	687b      	ldr	r3, [r7, #4]
 801beae:	3308      	adds	r3, #8
 801beb0:	429a      	cmp	r2, r3
 801beb2:	d3f3      	bcc.n	801be9c <finsh_heap_allocate+0x44>
			header = header->next) ;

		/* there is no memory */
		if (header == NULL) return NULL;
 801beb4:	68fb      	ldr	r3, [r7, #12]
 801beb6:	2b00      	cmp	r3, #0
 801beb8:	d101      	bne.n	801bebe <finsh_heap_allocate+0x66>
 801beba:	2300      	movs	r3, #0
 801bebc:	e017      	b.n	801beee <finsh_heap_allocate+0x96>
	}

    /* split block */
	finsh_block_split(header, size);
 801bebe:	68f8      	ldr	r0, [r7, #12]
 801bec0:	6879      	ldr	r1, [r7, #4]
 801bec2:	f000 f8e7 	bl	801c094 <finsh_block_split>

	/* remove from free list */
	finsh_block_remove(&free_list, header);
 801bec6:	480c      	ldr	r0, [pc, #48]	; (801bef8 <finsh_heap_allocate+0xa0>)
 801bec8:	68f9      	ldr	r1, [r7, #12]
 801beca:	f000 f8b5 	bl	801c038 <finsh_block_remove>
	header->next = NULL;
 801bece:	68fb      	ldr	r3, [r7, #12]
 801bed0:	2200      	movs	r2, #0
 801bed2:	605a      	str	r2, [r3, #4]

    /* insert to allocate list */
    finsh_block_insert(&allocate_list, header);
 801bed4:	4809      	ldr	r0, [pc, #36]	; (801befc <finsh_heap_allocate+0xa4>)
 801bed6:	68f9      	ldr	r1, [r7, #12]
 801bed8:	f000 f86e 	bl	801bfb8 <finsh_block_insert>

	memset(finsh_block_get_data(header), 0, size);
 801bedc:	68fb      	ldr	r3, [r7, #12]
 801bede:	3308      	adds	r3, #8
 801bee0:	4618      	mov	r0, r3
 801bee2:	2100      	movs	r1, #0
 801bee4:	687a      	ldr	r2, [r7, #4]
 801bee6:	f003 f925 	bl	801f134 <memset>

	return finsh_block_get_data(header);
 801beea:	68fb      	ldr	r3, [r7, #12]
 801beec:	3308      	adds	r3, #8
}
 801beee:	4618      	mov	r0, r3
 801bef0:	3710      	adds	r7, #16
 801bef2:	46bd      	mov	sp, r7
 801bef4:	bd80      	pop	{r7, pc}
 801bef6:	bf00      	nop
 801bef8:	200121e0 	.word	0x200121e0
 801befc:	200121e4 	.word	0x200121e4

0801bf00 <finsh_heap_free>:

/**
 * release the allocated block
 */
void  finsh_heap_free(void*ptr)
{
 801bf00:	b580      	push	{r7, lr}
 801bf02:	b084      	sub	sp, #16
 801bf04:	af00      	add	r7, sp, #0
 801bf06:	6078      	str	r0, [r7, #4]
    struct finsh_block_header* header;

    /* get block header */
	header = finsh_block_get_header(ptr);
 801bf08:	687b      	ldr	r3, [r7, #4]
 801bf0a:	3b08      	subs	r3, #8
 801bf0c:	60fb      	str	r3, [r7, #12]

    /* remove from allocate list */
	finsh_block_remove(&allocate_list, header);
 801bf0e:	4807      	ldr	r0, [pc, #28]	; (801bf2c <finsh_heap_free+0x2c>)
 801bf10:	68f9      	ldr	r1, [r7, #12]
 801bf12:	f000 f891 	bl	801c038 <finsh_block_remove>

	/* insert to free list */
	finsh_block_insert(&free_list, header);
 801bf16:	4806      	ldr	r0, [pc, #24]	; (801bf30 <finsh_heap_free+0x30>)
 801bf18:	68f9      	ldr	r1, [r7, #12]
 801bf1a:	f000 f84d 	bl	801bfb8 <finsh_block_insert>
	finsh_block_merge(&free_list, header);
 801bf1e:	4804      	ldr	r0, [pc, #16]	; (801bf30 <finsh_heap_free+0x30>)
 801bf20:	68f9      	ldr	r1, [r7, #12]
 801bf22:	f000 f8d9 	bl	801c0d8 <finsh_block_merge>
}
 801bf26:	3710      	adds	r7, #16
 801bf28:	46bd      	mov	sp, r7
 801bf2a:	bd80      	pop	{r7, pc}
 801bf2c:	200121e4 	.word	0x200121e4
 801bf30:	200121e0 	.word	0x200121e0

0801bf34 <finsh_heap_gc>:

/**
 * garbage collector
 */
static void finsh_heap_gc(void)
{
 801bf34:	b580      	push	{r7, lr}
 801bf36:	b084      	sub	sp, #16
 801bf38:	af00      	add	r7, sp, #0
	int i;
	struct finsh_block_header *header, *temp;

	temp = NULL;
 801bf3a:	2300      	movs	r3, #0
 801bf3c:	607b      	str	r3, [r7, #4]

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
 801bf3e:	4b1c      	ldr	r3, [pc, #112]	; (801bfb0 <finsh_heap_gc+0x7c>)
 801bf40:	681b      	ldr	r3, [r3, #0]
 801bf42:	60bb      	str	r3, [r7, #8]
 801bf44:	e02e      	b.n	801bfa4 <finsh_heap_gc+0x70>
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801bf46:	2300      	movs	r3, #0
 801bf48:	60fb      	str	r3, [r7, #12]
 801bf4a:	e01b      	b.n	801bf84 <finsh_heap_gc+0x50>
    	{
    		if (global_variable[i].type != finsh_type_unknown)
 801bf4c:	4919      	ldr	r1, [pc, #100]	; (801bfb4 <finsh_heap_gc+0x80>)
 801bf4e:	68fa      	ldr	r2, [r7, #12]
 801bf50:	4613      	mov	r3, r2
 801bf52:	005b      	lsls	r3, r3, #1
 801bf54:	4413      	add	r3, r2
 801bf56:	00db      	lsls	r3, r3, #3
 801bf58:	440b      	add	r3, r1
 801bf5a:	3310      	adds	r3, #16
 801bf5c:	785b      	ldrb	r3, [r3, #1]
 801bf5e:	2b00      	cmp	r3, #0
 801bf60:	d00d      	beq.n	801bf7e <finsh_heap_gc+0x4a>
    		{
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
 801bf62:	4914      	ldr	r1, [pc, #80]	; (801bfb4 <finsh_heap_gc+0x80>)
 801bf64:	68fa      	ldr	r2, [r7, #12]
 801bf66:	4613      	mov	r3, r2
 801bf68:	005b      	lsls	r3, r3, #1
 801bf6a:	4413      	add	r3, r2
 801bf6c:	00db      	lsls	r3, r3, #3
 801bf6e:	440b      	add	r3, r1
 801bf70:	3310      	adds	r3, #16
 801bf72:	685a      	ldr	r2, [r3, #4]
 801bf74:	68bb      	ldr	r3, [r7, #8]
 801bf76:	3308      	adds	r3, #8
 801bf78:	429a      	cmp	r2, r3
 801bf7a:	d100      	bne.n	801bf7e <finsh_heap_gc+0x4a>
					break;
 801bf7c:	e005      	b.n	801bf8a <finsh_heap_gc+0x56>
	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801bf7e:	68fb      	ldr	r3, [r7, #12]
 801bf80:	3301      	adds	r3, #1
 801bf82:	60fb      	str	r3, [r7, #12]
 801bf84:	68fb      	ldr	r3, [r7, #12]
 801bf86:	2b07      	cmp	r3, #7
 801bf88:	dde0      	ble.n	801bf4c <finsh_heap_gc+0x18>
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
					break;
    		}
    	}

		temp   = header;
 801bf8a:	68bb      	ldr	r3, [r7, #8]
 801bf8c:	607b      	str	r3, [r7, #4]
		header = header->next;
 801bf8e:	68bb      	ldr	r3, [r7, #8]
 801bf90:	685b      	ldr	r3, [r3, #4]
 801bf92:	60bb      	str	r3, [r7, #8]

		/* this block is an unused block, release it */
    	if (i == FINSH_VARIABLE_MAX)
 801bf94:	68fb      	ldr	r3, [r7, #12]
 801bf96:	2b08      	cmp	r3, #8
 801bf98:	d104      	bne.n	801bfa4 <finsh_heap_gc+0x70>
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
 801bf9a:	687b      	ldr	r3, [r7, #4]
 801bf9c:	3308      	adds	r3, #8
 801bf9e:	4618      	mov	r0, r3
 801bfa0:	f7ff ffae 	bl	801bf00 <finsh_heap_free>
	struct finsh_block_header *header, *temp;

	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
 801bfa4:	68bb      	ldr	r3, [r7, #8]
 801bfa6:	2b00      	cmp	r3, #0
 801bfa8:	d1cd      	bne.n	801bf46 <finsh_heap_gc+0x12>
    	if (i == FINSH_VARIABLE_MAX)
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
    	}
    }
}
 801bfaa:	3710      	adds	r7, #16
 801bfac:	46bd      	mov	sp, r7
 801bfae:	bd80      	pop	{r7, pc}
 801bfb0:	200121e4 	.word	0x200121e4
 801bfb4:	200128b4 	.word	0x200128b4

0801bfb8 <finsh_block_insert>:

/**
 * insert a block to list
 */
void finsh_block_insert(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801bfb8:	b480      	push	{r7}
 801bfba:	b085      	sub	sp, #20
 801bfbc:	af00      	add	r7, sp, #0
 801bfbe:	6078      	str	r0, [r7, #4]
 801bfc0:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* node;

    if (*list == NULL)
 801bfc2:	687b      	ldr	r3, [r7, #4]
 801bfc4:	681b      	ldr	r3, [r3, #0]
 801bfc6:	2b00      	cmp	r3, #0
 801bfc8:	d103      	bne.n	801bfd2 <finsh_block_insert+0x1a>
    {
        *list = header;
 801bfca:	687b      	ldr	r3, [r7, #4]
 801bfcc:	683a      	ldr	r2, [r7, #0]
 801bfce:	601a      	str	r2, [r3, #0]
        return;
 801bfd0:	e02d      	b.n	801c02e <finsh_block_insert+0x76>
    }

    /* find out insert point */
	node = *list;
 801bfd2:	687b      	ldr	r3, [r7, #4]
 801bfd4:	681b      	ldr	r3, [r3, #0]
 801bfd6:	60fb      	str	r3, [r7, #12]

	if (node > header)
 801bfd8:	68fa      	ldr	r2, [r7, #12]
 801bfda:	683b      	ldr	r3, [r7, #0]
 801bfdc:	429a      	cmp	r2, r3
 801bfde:	d906      	bls.n	801bfee <finsh_block_insert+0x36>
	{
		/* insert node in the header of list */
		header->next = node;
 801bfe0:	683b      	ldr	r3, [r7, #0]
 801bfe2:	68fa      	ldr	r2, [r7, #12]
 801bfe4:	605a      	str	r2, [r3, #4]
		*list = header;
 801bfe6:	687b      	ldr	r3, [r7, #4]
 801bfe8:	683a      	ldr	r2, [r7, #0]
 801bfea:	601a      	str	r2, [r3, #0]

		return;
 801bfec:	e01f      	b.n	801c02e <finsh_block_insert+0x76>
	}
	else
	{
		for (node = *list; node; node = node->next)
 801bfee:	687b      	ldr	r3, [r7, #4]
 801bff0:	681b      	ldr	r3, [r3, #0]
 801bff2:	60fb      	str	r3, [r7, #12]
 801bff4:	e00d      	b.n	801c012 <finsh_block_insert+0x5a>
		{
    		if (node->next > header) break;
 801bff6:	68fb      	ldr	r3, [r7, #12]
 801bff8:	685a      	ldr	r2, [r3, #4]
 801bffa:	683b      	ldr	r3, [r7, #0]
 801bffc:	429a      	cmp	r2, r3
 801bffe:	d900      	bls.n	801c002 <finsh_block_insert+0x4a>
 801c000:	e00a      	b.n	801c018 <finsh_block_insert+0x60>

    		if (node->next == NULL) break;
 801c002:	68fb      	ldr	r3, [r7, #12]
 801c004:	685b      	ldr	r3, [r3, #4]
 801c006:	2b00      	cmp	r3, #0
 801c008:	d100      	bne.n	801c00c <finsh_block_insert+0x54>
 801c00a:	e005      	b.n	801c018 <finsh_block_insert+0x60>

		return;
	}
	else
	{
		for (node = *list; node; node = node->next)
 801c00c:	68fb      	ldr	r3, [r7, #12]
 801c00e:	685b      	ldr	r3, [r3, #4]
 801c010:	60fb      	str	r3, [r7, #12]
 801c012:	68fb      	ldr	r3, [r7, #12]
 801c014:	2b00      	cmp	r3, #0
 801c016:	d1ee      	bne.n	801bff6 <finsh_block_insert+0x3e>
    		if (node->next == NULL) break;
		}
	}

    /* insert node */
    if (node->next != NULL) header->next = node->next;
 801c018:	68fb      	ldr	r3, [r7, #12]
 801c01a:	685b      	ldr	r3, [r3, #4]
 801c01c:	2b00      	cmp	r3, #0
 801c01e:	d003      	beq.n	801c028 <finsh_block_insert+0x70>
 801c020:	68fb      	ldr	r3, [r7, #12]
 801c022:	685a      	ldr	r2, [r3, #4]
 801c024:	683b      	ldr	r3, [r7, #0]
 801c026:	605a      	str	r2, [r3, #4]
    node->next      = header;
 801c028:	68fb      	ldr	r3, [r7, #12]
 801c02a:	683a      	ldr	r2, [r7, #0]
 801c02c:	605a      	str	r2, [r3, #4]
}
 801c02e:	3714      	adds	r7, #20
 801c030:	46bd      	mov	sp, r7
 801c032:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c036:	4770      	bx	lr

0801c038 <finsh_block_remove>:

/**
 * remove block from list
 */
void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801c038:	b480      	push	{r7}
 801c03a:	b085      	sub	sp, #20
 801c03c:	af00      	add	r7, sp, #0
 801c03e:	6078      	str	r0, [r7, #4]
 801c040:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* node;

    node = *list;
 801c042:	687b      	ldr	r3, [r7, #4]
 801c044:	681b      	ldr	r3, [r3, #0]
 801c046:	60fb      	str	r3, [r7, #12]
    if (node == header)
 801c048:	68fa      	ldr	r2, [r7, #12]
 801c04a:	683b      	ldr	r3, [r7, #0]
 801c04c:	429a      	cmp	r2, r3
 801c04e:	d107      	bne.n	801c060 <finsh_block_remove+0x28>
    {
        /* remove list header */
        *list = header->next;
 801c050:	683b      	ldr	r3, [r7, #0]
 801c052:	685a      	ldr	r2, [r3, #4]
 801c054:	687b      	ldr	r3, [r7, #4]
 801c056:	601a      	str	r2, [r3, #0]
        header->next = NULL;
 801c058:	683b      	ldr	r3, [r7, #0]
 801c05a:	2200      	movs	r2, #0
 801c05c:	605a      	str	r2, [r3, #4]

        return;
 801c05e:	e013      	b.n	801c088 <finsh_block_remove+0x50>
    }

    for (node = *list; node != NULL; node = node->next)
 801c060:	687b      	ldr	r3, [r7, #4]
 801c062:	681b      	ldr	r3, [r3, #0]
 801c064:	60fb      	str	r3, [r7, #12]
 801c066:	e00c      	b.n	801c082 <finsh_block_remove+0x4a>
    {
        if (node->next == header)
 801c068:	68fb      	ldr	r3, [r7, #12]
 801c06a:	685a      	ldr	r2, [r3, #4]
 801c06c:	683b      	ldr	r3, [r7, #0]
 801c06e:	429a      	cmp	r2, r3
 801c070:	d104      	bne.n	801c07c <finsh_block_remove+0x44>
        {
            node->next = header->next;
 801c072:	683b      	ldr	r3, [r7, #0]
 801c074:	685a      	ldr	r2, [r3, #4]
 801c076:	68fb      	ldr	r3, [r7, #12]
 801c078:	605a      	str	r2, [r3, #4]
            break;
 801c07a:	e005      	b.n	801c088 <finsh_block_remove+0x50>
        header->next = NULL;

        return;
    }

    for (node = *list; node != NULL; node = node->next)
 801c07c:	68fb      	ldr	r3, [r7, #12]
 801c07e:	685b      	ldr	r3, [r3, #4]
 801c080:	60fb      	str	r3, [r7, #12]
 801c082:	68fb      	ldr	r3, [r7, #12]
 801c084:	2b00      	cmp	r3, #0
 801c086:	d1ef      	bne.n	801c068 <finsh_block_remove+0x30>
        {
            node->next = header->next;
            break;
        }
    }
}
 801c088:	3714      	adds	r7, #20
 801c08a:	46bd      	mov	sp, r7
 801c08c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c090:	4770      	bx	lr
 801c092:	bf00      	nop

0801c094 <finsh_block_split>:

/**
 * split block
 */
void finsh_block_split(struct finsh_block_header* header, size_t size)
{
 801c094:	b480      	push	{r7}
 801c096:	b085      	sub	sp, #20
 801c098:	af00      	add	r7, sp, #0
 801c09a:	6078      	str	r0, [r7, #4]
 801c09c:	6039      	str	r1, [r7, #0]

    /*
     * split header into two node:
     * header->next->...
     */
    next = BLOCK_HEADER((u_char*)header + sizeof(struct finsh_block_header) + size);
 801c09e:	683b      	ldr	r3, [r7, #0]
 801c0a0:	3308      	adds	r3, #8
 801c0a2:	687a      	ldr	r2, [r7, #4]
 801c0a4:	4413      	add	r3, r2
 801c0a6:	60fb      	str	r3, [r7, #12]
    next->length = header->length - sizeof(struct finsh_block_header) - size;
 801c0a8:	687b      	ldr	r3, [r7, #4]
 801c0aa:	681a      	ldr	r2, [r3, #0]
 801c0ac:	683b      	ldr	r3, [r7, #0]
 801c0ae:	1ad3      	subs	r3, r2, r3
 801c0b0:	f1a3 0208 	sub.w	r2, r3, #8
 801c0b4:	68fb      	ldr	r3, [r7, #12]
 801c0b6:	601a      	str	r2, [r3, #0]
    header->length = size;
 801c0b8:	687b      	ldr	r3, [r7, #4]
 801c0ba:	683a      	ldr	r2, [r7, #0]
 801c0bc:	601a      	str	r2, [r3, #0]
    next->next = header->next;
 801c0be:	687b      	ldr	r3, [r7, #4]
 801c0c0:	685a      	ldr	r2, [r3, #4]
 801c0c2:	68fb      	ldr	r3, [r7, #12]
 801c0c4:	605a      	str	r2, [r3, #4]

    header->next = next;
 801c0c6:	687b      	ldr	r3, [r7, #4]
 801c0c8:	68fa      	ldr	r2, [r7, #12]
 801c0ca:	605a      	str	r2, [r3, #4]
}
 801c0cc:	3714      	adds	r7, #20
 801c0ce:	46bd      	mov	sp, r7
 801c0d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c0d4:	4770      	bx	lr
 801c0d6:	bf00      	nop

0801c0d8 <finsh_block_merge>:

void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801c0d8:	b480      	push	{r7}
 801c0da:	b085      	sub	sp, #20
 801c0dc:	af00      	add	r7, sp, #0
 801c0de:	6078      	str	r0, [r7, #4]
 801c0e0:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* prev_node;
    struct finsh_block_header* next_node;

    next_node = header->next;
 801c0e2:	683b      	ldr	r3, [r7, #0]
 801c0e4:	685b      	ldr	r3, [r3, #4]
 801c0e6:	60bb      	str	r3, [r7, #8]

    if (*list == header) prev_node = NULL;
 801c0e8:	687b      	ldr	r3, [r7, #4]
 801c0ea:	681a      	ldr	r2, [r3, #0]
 801c0ec:	683b      	ldr	r3, [r7, #0]
 801c0ee:	429a      	cmp	r2, r3
 801c0f0:	d102      	bne.n	801c0f8 <finsh_block_merge+0x20>
 801c0f2:	2300      	movs	r3, #0
 801c0f4:	60fb      	str	r3, [r7, #12]
 801c0f6:	e00f      	b.n	801c118 <finsh_block_merge+0x40>
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
 801c0f8:	687b      	ldr	r3, [r7, #4]
 801c0fa:	681b      	ldr	r3, [r3, #0]
 801c0fc:	60fb      	str	r3, [r7, #12]
 801c0fe:	e008      	b.n	801c112 <finsh_block_merge+0x3a>
        {
            if (prev_node->next == header)
 801c100:	68fb      	ldr	r3, [r7, #12]
 801c102:	685a      	ldr	r2, [r3, #4]
 801c104:	683b      	ldr	r3, [r7, #0]
 801c106:	429a      	cmp	r2, r3
 801c108:	d100      	bne.n	801c10c <finsh_block_merge+0x34>
                break;
 801c10a:	e005      	b.n	801c118 <finsh_block_merge+0x40>

    if (*list == header) prev_node = NULL;
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
 801c10c:	68fb      	ldr	r3, [r7, #12]
 801c10e:	685b      	ldr	r3, [r3, #4]
 801c110:	60fb      	str	r3, [r7, #12]
 801c112:	68fb      	ldr	r3, [r7, #12]
 801c114:	2b00      	cmp	r3, #0
 801c116:	d1f3      	bne.n	801c100 <finsh_block_merge+0x28>
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
 801c118:	68fb      	ldr	r3, [r7, #12]
 801c11a:	2b00      	cmp	r3, #0
 801c11c:	d031      	beq.n	801c182 <finsh_block_merge+0xaa>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
 801c11e:	68fb      	ldr	r3, [r7, #12]
 801c120:	681b      	ldr	r3, [r3, #0]
 801c122:	3308      	adds	r3, #8
 801c124:	68fa      	ldr	r2, [r7, #12]
 801c126:	441a      	add	r2, r3
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
 801c128:	683b      	ldr	r3, [r7, #0]
 801c12a:	429a      	cmp	r2, r3
 801c12c:	d129      	bne.n	801c182 <finsh_block_merge+0xaa>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801c12e:	68bb      	ldr	r3, [r7, #8]
 801c130:	2b00      	cmp	r3, #0
 801c132:	d018      	beq.n	801c166 <finsh_block_merge+0x8e>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
 801c134:	683b      	ldr	r3, [r7, #0]
 801c136:	681b      	ldr	r3, [r3, #0]
 801c138:	3308      	adds	r3, #8
 801c13a:	683a      	ldr	r2, [r7, #0]
 801c13c:	441a      	add	r2, r3
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801c13e:	68bb      	ldr	r3, [r7, #8]
 801c140:	429a      	cmp	r2, r3
 801c142:	d110      	bne.n	801c166 <finsh_block_merge+0x8e>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
            == (u_char*)next_node))
        {
            /* merge three node */
        	prev_node->length += header->length + next_node->length +
 801c144:	68fb      	ldr	r3, [r7, #12]
 801c146:	681a      	ldr	r2, [r3, #0]
 801c148:	683b      	ldr	r3, [r7, #0]
 801c14a:	6819      	ldr	r1, [r3, #0]
 801c14c:	68bb      	ldr	r3, [r7, #8]
 801c14e:	681b      	ldr	r3, [r3, #0]
 801c150:	440b      	add	r3, r1
 801c152:	4413      	add	r3, r2
 801c154:	f103 0210 	add.w	r2, r3, #16
 801c158:	68fb      	ldr	r3, [r7, #12]
 801c15a:	601a      	str	r2, [r3, #0]
                2 * sizeof(struct finsh_block_header);

            prev_node->next = next_node->next;
 801c15c:	68bb      	ldr	r3, [r7, #8]
 801c15e:	685a      	ldr	r2, [r3, #4]
 801c160:	68fb      	ldr	r3, [r7, #12]
 801c162:	605a      	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801c164:	e025      	b.n	801c1b2 <finsh_block_merge+0xda>

            prev_node->next = next_node->next;
        }
        else
        {
            prev_node->length += header->length + sizeof(struct finsh_block_header);
 801c166:	68fb      	ldr	r3, [r7, #12]
 801c168:	681a      	ldr	r2, [r3, #0]
 801c16a:	683b      	ldr	r3, [r7, #0]
 801c16c:	681b      	ldr	r3, [r3, #0]
 801c16e:	4413      	add	r3, r2
 801c170:	f103 0208 	add.w	r2, r3, #8
 801c174:	68fb      	ldr	r3, [r7, #12]
 801c176:	601a      	str	r2, [r3, #0]
            prev_node->next = header->next;
 801c178:	683b      	ldr	r3, [r7, #0]
 801c17a:	685a      	ldr	r2, [r3, #4]
 801c17c:	68fb      	ldr	r3, [r7, #12]
 801c17e:	605a      	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801c180:	e017      	b.n	801c1b2 <finsh_block_merge+0xda>
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
 801c182:	68bb      	ldr	r3, [r7, #8]
 801c184:	2b00      	cmp	r3, #0
 801c186:	d014      	beq.n	801c1b2 <finsh_block_merge+0xda>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
 801c188:	683b      	ldr	r3, [r7, #0]
 801c18a:	681b      	ldr	r3, [r3, #0]
 801c18c:	3308      	adds	r3, #8
 801c18e:	683a      	ldr	r2, [r7, #0]
 801c190:	441a      	add	r2, r3
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
 801c192:	68bb      	ldr	r3, [r7, #8]
 801c194:	429a      	cmp	r2, r3
 801c196:	d10c      	bne.n	801c1b2 <finsh_block_merge+0xda>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
        == (u_char*)next_node))
    {
        header->length += next_node->length + sizeof(struct finsh_block_header);
 801c198:	683b      	ldr	r3, [r7, #0]
 801c19a:	681a      	ldr	r2, [r3, #0]
 801c19c:	68bb      	ldr	r3, [r7, #8]
 801c19e:	681b      	ldr	r3, [r3, #0]
 801c1a0:	4413      	add	r3, r2
 801c1a2:	f103 0208 	add.w	r2, r3, #8
 801c1a6:	683b      	ldr	r3, [r7, #0]
 801c1a8:	601a      	str	r2, [r3, #0]
        header->next = next_node->next;
 801c1aa:	68bb      	ldr	r3, [r7, #8]
 801c1ac:	685a      	ldr	r2, [r3, #4]
 801c1ae:	683b      	ldr	r3, [r7, #0]
 801c1b0:	605a      	str	r2, [r3, #4]
    }
}
 801c1b2:	3714      	adds	r7, #20
 801c1b4:	46bd      	mov	sp, r7
 801c1b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c1ba:	4770      	bx	lr

0801c1bc <finsh_init>:
#include "finsh_var.h"
#include "finsh_error.h"
#include "finsh_heap.h"

int finsh_init(struct finsh_parser* parser)
{
 801c1bc:	b580      	push	{r7, lr}
 801c1be:	b082      	sub	sp, #8
 801c1c0:	af00      	add	r7, sp, #0
 801c1c2:	6078      	str	r0, [r7, #4]
	finsh_parser_init(parser);
 801c1c4:	6878      	ldr	r0, [r7, #4]
 801c1c6:	f001 ffb1 	bl	801e12c <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
 801c1ca:	f000 f827 	bl	801c21c <finsh_node_init>
	finsh_var_init();
 801c1ce:	f001 ffbb 	bl	801e148 <finsh_var_init>
	finsh_error_init();
 801c1d2:	f7ff fde5 	bl	801bda0 <finsh_error_init>
	finsh_heap_init();
 801c1d6:	f7ff fe21 	bl	801be1c <finsh_heap_init>

	return 0;
 801c1da:	2300      	movs	r3, #0
}
 801c1dc:	4618      	mov	r0, r3
 801c1de:	3708      	adds	r7, #8
 801c1e0:	46bd      	mov	sp, r7
 801c1e2:	bd80      	pop	{r7, pc}

0801c1e4 <finsh_stack_bottom>:

long finsh_stack_bottom()
{
 801c1e4:	b480      	push	{r7}
 801c1e6:	af00      	add	r7, sp, #0
    return finsh_vm_stack[0].long_value;
 801c1e8:	4b03      	ldr	r3, [pc, #12]	; (801c1f8 <finsh_stack_bottom+0x14>)
 801c1ea:	681b      	ldr	r3, [r3, #0]
}
 801c1ec:	4618      	mov	r0, r3
 801c1ee:	46bd      	mov	sp, r7
 801c1f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c1f4:	4770      	bx	lr
 801c1f6:	bf00      	nop
 801c1f8:	200129f4 	.word	0x200129f4

0801c1fc <finsh_flush>:

int finsh_flush(struct finsh_parser* parser)
{
 801c1fc:	b580      	push	{r7, lr}
 801c1fe:	b082      	sub	sp, #8
 801c200:	af00      	add	r7, sp, #0
 801c202:	6078      	str	r0, [r7, #4]
	finsh_parser_init(parser);
 801c204:	6878      	ldr	r0, [r7, #4]
 801c206:	f001 ff91 	bl	801e12c <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
 801c20a:	f000 f807 	bl	801c21c <finsh_node_init>
	finsh_error_init();
 801c20e:	f7ff fdc7 	bl	801bda0 <finsh_error_init>

	return 0;
 801c212:	2300      	movs	r3, #0
}
 801c214:	4618      	mov	r0, r3
 801c216:	3708      	adds	r7, #8
 801c218:	46bd      	mov	sp, r7
 801c21a:	bd80      	pop	{r7, pc}

0801c21c <finsh_node_init>:
#include "finsh_heap.h"

struct finsh_node global_node_table[FINSH_NODE_MAX];

int finsh_node_init()
{
 801c21c:	b580      	push	{r7, lr}
 801c21e:	af00      	add	r7, sp, #0
	memset(global_node_table, 0, sizeof(global_node_table));
 801c220:	4804      	ldr	r0, [pc, #16]	; (801c234 <finsh_node_init+0x18>)
 801c222:	2100      	movs	r1, #0
 801c224:	f44f 72a0 	mov.w	r2, #320	; 0x140
 801c228:	f002 ff84 	bl	801f134 <memset>

	return 0;
 801c22c:	2300      	movs	r3, #0
}
 801c22e:	4618      	mov	r0, r3
 801c230:	bd80      	pop	{r7, pc}
 801c232:	bf00      	nop
 801c234:	20012770 	.word	0x20012770

0801c238 <finsh_node_allocate>:

struct finsh_node* finsh_node_allocate(u_char type)
{
 801c238:	b480      	push	{r7}
 801c23a:	b085      	sub	sp, #20
 801c23c:	af00      	add	r7, sp, #0
 801c23e:	4603      	mov	r3, r0
 801c240:	71fb      	strb	r3, [r7, #7]
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
 801c242:	2300      	movs	r3, #0
 801c244:	60fb      	str	r3, [r7, #12]
 801c246:	e00d      	b.n	801c264 <finsh_node_allocate+0x2c>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
 801c248:	4915      	ldr	r1, [pc, #84]	; (801c2a0 <finsh_node_allocate+0x68>)
 801c24a:	68fa      	ldr	r2, [r7, #12]
 801c24c:	4613      	mov	r3, r2
 801c24e:	009b      	lsls	r3, r3, #2
 801c250:	4413      	add	r3, r2
 801c252:	009b      	lsls	r3, r3, #2
 801c254:	440b      	add	r3, r1
 801c256:	781b      	ldrb	r3, [r3, #0]
 801c258:	2b00      	cmp	r3, #0
 801c25a:	d100      	bne.n	801c25e <finsh_node_allocate+0x26>
 801c25c:	e005      	b.n	801c26a <finsh_node_allocate+0x32>
struct finsh_node* finsh_node_allocate(u_char type)
{
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
 801c25e:	68fb      	ldr	r3, [r7, #12]
 801c260:	3301      	adds	r3, #1
 801c262:	60fb      	str	r3, [r7, #12]
 801c264:	68fb      	ldr	r3, [r7, #12]
 801c266:	2b0f      	cmp	r3, #15
 801c268:	ddee      	ble.n	801c248 <finsh_node_allocate+0x10>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
	}

	if (i == FINSH_NODE_MAX) return NULL;
 801c26a:	68fb      	ldr	r3, [r7, #12]
 801c26c:	2b10      	cmp	r3, #16
 801c26e:	d101      	bne.n	801c274 <finsh_node_allocate+0x3c>
 801c270:	2300      	movs	r3, #0
 801c272:	e00f      	b.n	801c294 <finsh_node_allocate+0x5c>

	/* fill type field */
	global_node_table[i].node_type = type;
 801c274:	490a      	ldr	r1, [pc, #40]	; (801c2a0 <finsh_node_allocate+0x68>)
 801c276:	68fa      	ldr	r2, [r7, #12]
 801c278:	4613      	mov	r3, r2
 801c27a:	009b      	lsls	r3, r3, #2
 801c27c:	4413      	add	r3, r2
 801c27e:	009b      	lsls	r3, r3, #2
 801c280:	440b      	add	r3, r1
 801c282:	79fa      	ldrb	r2, [r7, #7]
 801c284:	701a      	strb	r2, [r3, #0]

	/* return this allocated node */
	return &global_node_table[i];
 801c286:	68fa      	ldr	r2, [r7, #12]
 801c288:	4613      	mov	r3, r2
 801c28a:	009b      	lsls	r3, r3, #2
 801c28c:	4413      	add	r3, r2
 801c28e:	009b      	lsls	r3, r3, #2
 801c290:	4a03      	ldr	r2, [pc, #12]	; (801c2a0 <finsh_node_allocate+0x68>)
 801c292:	4413      	add	r3, r2
}
 801c294:	4618      	mov	r0, r3
 801c296:	3714      	adds	r7, #20
 801c298:	46bd      	mov	sp, r7
 801c29a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c29e:	4770      	bx	lr
 801c2a0:	20012770 	.word	0x20012770

0801c2a4 <finsh_node_new_id>:

struct finsh_node* finsh_node_new_id(char* id)
{
 801c2a4:	b580      	push	{r7, lr}
 801c2a6:	b086      	sub	sp, #24
 801c2a8:	af00      	add	r7, sp, #0
 801c2aa:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;
	void*  symbol;
	unsigned char type;

	symbol	= NULL;
 801c2ac:	2300      	movs	r3, #0
 801c2ae:	613b      	str	r3, [r7, #16]
	type	= 0;
 801c2b0:	2300      	movs	r3, #0
 801c2b2:	73fb      	strb	r3, [r7, #15]
	node	= NULL;
 801c2b4:	2300      	movs	r3, #0
 801c2b6:	617b      	str	r3, [r7, #20]

	/* lookup variable firstly */
	symbol = (void*)finsh_var_lookup(id);
 801c2b8:	6878      	ldr	r0, [r7, #4]
 801c2ba:	f001 ffab 	bl	801e214 <finsh_var_lookup>
 801c2be:	6138      	str	r0, [r7, #16]
	if (symbol == NULL)
 801c2c0:	693b      	ldr	r3, [r7, #16]
 801c2c2:	2b00      	cmp	r3, #0
 801c2c4:	d113      	bne.n	801c2ee <finsh_node_new_id+0x4a>
	{
		/* then lookup system variable */
		symbol = (void*)finsh_sysvar_lookup(id);
 801c2c6:	6878      	ldr	r0, [r7, #4]
 801c2c8:	f001 ffd4 	bl	801e274 <finsh_sysvar_lookup>
 801c2cc:	6138      	str	r0, [r7, #16]
		if (symbol == NULL)
 801c2ce:	693b      	ldr	r3, [r7, #16]
 801c2d0:	2b00      	cmp	r3, #0
 801c2d2:	d109      	bne.n	801c2e8 <finsh_node_new_id+0x44>
		{
			/* then lookup system call */
			symbol = (void*)finsh_syscall_lookup(id);
 801c2d4:	6878      	ldr	r0, [r7, #4]
 801c2d6:	f002 f841 	bl	801e35c <finsh_syscall_lookup>
 801c2da:	6138      	str	r0, [r7, #16]
			if (symbol != NULL) type = FINSH_IDTYPE_SYSCALL;
 801c2dc:	693b      	ldr	r3, [r7, #16]
 801c2de:	2b00      	cmp	r3, #0
 801c2e0:	d007      	beq.n	801c2f2 <finsh_node_new_id+0x4e>
 801c2e2:	2304      	movs	r3, #4
 801c2e4:	73fb      	strb	r3, [r7, #15]
 801c2e6:	e004      	b.n	801c2f2 <finsh_node_new_id+0x4e>
		}
		else type = FINSH_IDTYPE_SYSVAR;
 801c2e8:	2302      	movs	r3, #2
 801c2ea:	73fb      	strb	r3, [r7, #15]
 801c2ec:	e001      	b.n	801c2f2 <finsh_node_new_id+0x4e>
	}
	else type = FINSH_IDTYPE_VAR;
 801c2ee:	2301      	movs	r3, #1
 801c2f0:	73fb      	strb	r3, [r7, #15]

	if (symbol != NULL)
 801c2f2:	693b      	ldr	r3, [r7, #16]
 801c2f4:	2b00      	cmp	r3, #0
 801c2f6:	d022      	beq.n	801c33e <finsh_node_new_id+0x9a>
	{
		/* allocate a new node */
		node = finsh_node_allocate(FINSH_NODE_ID);
 801c2f8:	2001      	movs	r0, #1
 801c2fa:	f7ff ff9d 	bl	801c238 <finsh_node_allocate>
 801c2fe:	6178      	str	r0, [r7, #20]

		/* allocate node error */
		if (node == NULL)
 801c300:	697b      	ldr	r3, [r7, #20]
 801c302:	2b00      	cmp	r3, #0
 801c304:	d104      	bne.n	801c310 <finsh_node_new_id+0x6c>
		{
			finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801c306:	2006      	movs	r0, #6
 801c308:	f7ff fd58 	bl	801bdbc <finsh_error_set>
			return NULL;
 801c30c:	2300      	movs	r3, #0
 801c30e:	e01a      	b.n	801c346 <finsh_node_new_id+0xa2>
		}

		/* fill node value according type */
		switch (type)
 801c310:	7bfb      	ldrb	r3, [r7, #15]
 801c312:	2b02      	cmp	r3, #2
 801c314:	d007      	beq.n	801c326 <finsh_node_new_id+0x82>
 801c316:	2b04      	cmp	r3, #4
 801c318:	d009      	beq.n	801c32e <finsh_node_new_id+0x8a>
 801c31a:	2b01      	cmp	r3, #1
 801c31c:	d10b      	bne.n	801c336 <finsh_node_new_id+0x92>
		{
		case FINSH_IDTYPE_VAR:
			node->id.var = (struct finsh_var*)symbol;
 801c31e:	697b      	ldr	r3, [r7, #20]
 801c320:	693a      	ldr	r2, [r7, #16]
 801c322:	609a      	str	r2, [r3, #8]
			break;
 801c324:	e007      	b.n	801c336 <finsh_node_new_id+0x92>

		case FINSH_IDTYPE_SYSVAR:
			node->id.sysvar = (struct finsh_sysvar*)symbol;
 801c326:	697b      	ldr	r3, [r7, #20]
 801c328:	693a      	ldr	r2, [r7, #16]
 801c32a:	609a      	str	r2, [r3, #8]
			break;
 801c32c:	e003      	b.n	801c336 <finsh_node_new_id+0x92>

		case FINSH_IDTYPE_SYSCALL:
			node->id.syscall = (struct finsh_syscall*)symbol;
 801c32e:	697b      	ldr	r3, [r7, #20]
 801c330:	693a      	ldr	r2, [r7, #16]
 801c332:	609a      	str	r2, [r3, #8]
			break;
 801c334:	bf00      	nop
		}
		/* fill identifier type */
		node->idtype = type;
 801c336:	697b      	ldr	r3, [r7, #20]
 801c338:	7bfa      	ldrb	r2, [r7, #15]
 801c33a:	709a      	strb	r2, [r3, #2]
 801c33c:	e002      	b.n	801c344 <finsh_node_new_id+0xa0>
	}
	else finsh_error_set(FINSH_ERROR_UNKNOWN_SYMBOL);
 801c33e:	200d      	movs	r0, #13
 801c340:	f7ff fd3c 	bl	801bdbc <finsh_error_set>

	return node;
 801c344:	697b      	ldr	r3, [r7, #20]
}
 801c346:	4618      	mov	r0, r3
 801c348:	3718      	adds	r7, #24
 801c34a:	46bd      	mov	sp, r7
 801c34c:	bd80      	pop	{r7, pc}
 801c34e:	bf00      	nop

0801c350 <finsh_node_new_char>:

struct finsh_node* finsh_node_new_char(char c)
{
 801c350:	b580      	push	{r7, lr}
 801c352:	b084      	sub	sp, #16
 801c354:	af00      	add	r7, sp, #0
 801c356:	4603      	mov	r3, r0
 801c358:	71fb      	strb	r3, [r7, #7]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_CHAR);
 801c35a:	2002      	movs	r0, #2
 801c35c:	f7ff ff6c 	bl	801c238 <finsh_node_allocate>
 801c360:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801c362:	68fb      	ldr	r3, [r7, #12]
 801c364:	2b00      	cmp	r3, #0
 801c366:	d104      	bne.n	801c372 <finsh_node_new_char+0x22>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801c368:	2006      	movs	r0, #6
 801c36a:	f7ff fd27 	bl	801bdbc <finsh_error_set>
		return NULL;
 801c36e:	2300      	movs	r3, #0
 801c370:	e003      	b.n	801c37a <finsh_node_new_char+0x2a>
	}

	node->value.char_value = c;
 801c372:	68fb      	ldr	r3, [r7, #12]
 801c374:	79fa      	ldrb	r2, [r7, #7]
 801c376:	711a      	strb	r2, [r3, #4]
	return node;
 801c378:	68fb      	ldr	r3, [r7, #12]
}
 801c37a:	4618      	mov	r0, r3
 801c37c:	3710      	adds	r7, #16
 801c37e:	46bd      	mov	sp, r7
 801c380:	bd80      	pop	{r7, pc}
 801c382:	bf00      	nop

0801c384 <finsh_node_new_int>:

struct finsh_node* finsh_node_new_int(int i)
{
 801c384:	b580      	push	{r7, lr}
 801c386:	b084      	sub	sp, #16
 801c388:	af00      	add	r7, sp, #0
 801c38a:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_INT);
 801c38c:	2003      	movs	r0, #3
 801c38e:	f7ff ff53 	bl	801c238 <finsh_node_allocate>
 801c392:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801c394:	68fb      	ldr	r3, [r7, #12]
 801c396:	2b00      	cmp	r3, #0
 801c398:	d104      	bne.n	801c3a4 <finsh_node_new_int+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801c39a:	2006      	movs	r0, #6
 801c39c:	f7ff fd0e 	bl	801bdbc <finsh_error_set>
		return NULL;
 801c3a0:	2300      	movs	r3, #0
 801c3a2:	e003      	b.n	801c3ac <finsh_node_new_int+0x28>
	}

	node->value.int_value = i;
 801c3a4:	68fb      	ldr	r3, [r7, #12]
 801c3a6:	687a      	ldr	r2, [r7, #4]
 801c3a8:	605a      	str	r2, [r3, #4]
	return node;
 801c3aa:	68fb      	ldr	r3, [r7, #12]
}
 801c3ac:	4618      	mov	r0, r3
 801c3ae:	3710      	adds	r7, #16
 801c3b0:	46bd      	mov	sp, r7
 801c3b2:	bd80      	pop	{r7, pc}

0801c3b4 <finsh_node_new_long>:

struct finsh_node* finsh_node_new_long(long l)
{
 801c3b4:	b580      	push	{r7, lr}
 801c3b6:	b084      	sub	sp, #16
 801c3b8:	af00      	add	r7, sp, #0
 801c3ba:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_LONG);
 801c3bc:	2004      	movs	r0, #4
 801c3be:	f7ff ff3b 	bl	801c238 <finsh_node_allocate>
 801c3c2:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801c3c4:	68fb      	ldr	r3, [r7, #12]
 801c3c6:	2b00      	cmp	r3, #0
 801c3c8:	d104      	bne.n	801c3d4 <finsh_node_new_long+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801c3ca:	2006      	movs	r0, #6
 801c3cc:	f7ff fcf6 	bl	801bdbc <finsh_error_set>
		return NULL;
 801c3d0:	2300      	movs	r3, #0
 801c3d2:	e003      	b.n	801c3dc <finsh_node_new_long+0x28>
	}

	node->value.long_value = l;
 801c3d4:	68fb      	ldr	r3, [r7, #12]
 801c3d6:	687a      	ldr	r2, [r7, #4]
 801c3d8:	605a      	str	r2, [r3, #4]
	return node;
 801c3da:	68fb      	ldr	r3, [r7, #12]
}
 801c3dc:	4618      	mov	r0, r3
 801c3de:	3710      	adds	r7, #16
 801c3e0:	46bd      	mov	sp, r7
 801c3e2:	bd80      	pop	{r7, pc}

0801c3e4 <finsh_node_new_string>:

struct finsh_node* finsh_node_new_string(char* s)
{
 801c3e4:	b590      	push	{r4, r7, lr}
 801c3e6:	b085      	sub	sp, #20
 801c3e8:	af00      	add	r7, sp, #0
 801c3ea:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_STRING);
 801c3ec:	2005      	movs	r0, #5
 801c3ee:	f7ff ff23 	bl	801c238 <finsh_node_allocate>
 801c3f2:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801c3f4:	68fb      	ldr	r3, [r7, #12]
 801c3f6:	2b00      	cmp	r3, #0
 801c3f8:	d104      	bne.n	801c404 <finsh_node_new_string+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801c3fa:	2006      	movs	r0, #6
 801c3fc:	f7ff fcde 	bl	801bdbc <finsh_error_set>
		return NULL;
 801c400:	2300      	movs	r3, #0
 801c402:	e01f      	b.n	801c444 <finsh_node_new_string+0x60>
	}

	/* make string */
	node->value.ptr = finsh_heap_allocate(strlen(s) + 1);
 801c404:	6878      	ldr	r0, [r7, #4]
 801c406:	f003 fb27 	bl	801fa58 <strlen>
 801c40a:	4603      	mov	r3, r0
 801c40c:	3301      	adds	r3, #1
 801c40e:	4618      	mov	r0, r3
 801c410:	f7ff fd22 	bl	801be58 <finsh_heap_allocate>
 801c414:	4602      	mov	r2, r0
 801c416:	68fb      	ldr	r3, [r7, #12]
 801c418:	605a      	str	r2, [r3, #4]
	strncpy(node->value.ptr, s, strlen(s));
 801c41a:	68fb      	ldr	r3, [r7, #12]
 801c41c:	685c      	ldr	r4, [r3, #4]
 801c41e:	6878      	ldr	r0, [r7, #4]
 801c420:	f003 fb1a 	bl	801fa58 <strlen>
 801c424:	4603      	mov	r3, r0
 801c426:	4620      	mov	r0, r4
 801c428:	6879      	ldr	r1, [r7, #4]
 801c42a:	461a      	mov	r2, r3
 801c42c:	f003 fb8e 	bl	801fb4c <strncpy>
	((u_char*)node->value.ptr)[strlen(s)] = '\0';
 801c430:	68fb      	ldr	r3, [r7, #12]
 801c432:	685c      	ldr	r4, [r3, #4]
 801c434:	6878      	ldr	r0, [r7, #4]
 801c436:	f003 fb0f 	bl	801fa58 <strlen>
 801c43a:	4603      	mov	r3, r0
 801c43c:	4423      	add	r3, r4
 801c43e:	2200      	movs	r2, #0
 801c440:	701a      	strb	r2, [r3, #0]

	return node;
 801c442:	68fb      	ldr	r3, [r7, #12]
}
 801c444:	4618      	mov	r0, r3
 801c446:	3714      	adds	r7, #20
 801c448:	46bd      	mov	sp, r7
 801c44a:	bd90      	pop	{r4, r7, pc}

0801c44c <finsh_node_new_ptr>:

struct finsh_node* finsh_node_new_ptr(void* ptr)
{
 801c44c:	b580      	push	{r7, lr}
 801c44e:	b084      	sub	sp, #16
 801c450:	af00      	add	r7, sp, #0
 801c452:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_NULL);
 801c454:	2006      	movs	r0, #6
 801c456:	f7ff feef 	bl	801c238 <finsh_node_allocate>
 801c45a:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801c45c:	68fb      	ldr	r3, [r7, #12]
 801c45e:	2b00      	cmp	r3, #0
 801c460:	d104      	bne.n	801c46c <finsh_node_new_ptr+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801c462:	2006      	movs	r0, #6
 801c464:	f7ff fcaa 	bl	801bdbc <finsh_error_set>
		return NULL;
 801c468:	2300      	movs	r3, #0
 801c46a:	e003      	b.n	801c474 <finsh_node_new_ptr+0x28>
	}

	node->value.ptr = ptr;
 801c46c:	68fb      	ldr	r3, [r7, #12]
 801c46e:	687a      	ldr	r2, [r7, #4]
 801c470:	605a      	str	r2, [r3, #4]
	return node;
 801c472:	68fb      	ldr	r3, [r7, #12]
}
 801c474:	4618      	mov	r0, r3
 801c476:	3710      	adds	r7, #16
 801c478:	46bd      	mov	sp, r7
 801c47a:	bd80      	pop	{r7, pc}

0801c47c <OP_no_op>:
        finsh_sp--; \
    }while (0)

/* --- noop --- */
void OP_no_op()
{
 801c47c:	b480      	push	{r7}
 801c47e:	af00      	add	r7, sp, #0
	/* none */
	return ;
 801c480:	bf00      	nop
}
 801c482:	46bd      	mov	sp, r7
 801c484:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c488:	4770      	bx	lr
 801c48a:	bf00      	nop

0801c48c <OP_add_byte>:

/* --- add --- */
void OP_add_byte()
{
 801c48c:	b480      	push	{r7}
 801c48e:	af00      	add	r7, sp, #0
    OP_BIN_BYTE(+);
 801c490:	4b0b      	ldr	r3, [pc, #44]	; (801c4c0 <OP_add_byte+0x34>)
 801c492:	681b      	ldr	r3, [r3, #0]
 801c494:	3b08      	subs	r3, #8
 801c496:	4a0a      	ldr	r2, [pc, #40]	; (801c4c0 <OP_add_byte+0x34>)
 801c498:	6812      	ldr	r2, [r2, #0]
 801c49a:	3a08      	subs	r2, #8
 801c49c:	7811      	ldrb	r1, [r2, #0]
 801c49e:	4a08      	ldr	r2, [pc, #32]	; (801c4c0 <OP_add_byte+0x34>)
 801c4a0:	6812      	ldr	r2, [r2, #0]
 801c4a2:	3a04      	subs	r2, #4
 801c4a4:	7812      	ldrb	r2, [r2, #0]
 801c4a6:	440a      	add	r2, r1
 801c4a8:	b2d2      	uxtb	r2, r2
 801c4aa:	701a      	strb	r2, [r3, #0]
 801c4ac:	4b04      	ldr	r3, [pc, #16]	; (801c4c0 <OP_add_byte+0x34>)
 801c4ae:	681b      	ldr	r3, [r3, #0]
 801c4b0:	3b04      	subs	r3, #4
 801c4b2:	4a03      	ldr	r2, [pc, #12]	; (801c4c0 <OP_add_byte+0x34>)
 801c4b4:	6013      	str	r3, [r2, #0]

	return ;
 801c4b6:	bf00      	nop
}
 801c4b8:	46bd      	mov	sp, r7
 801c4ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c4be:	4770      	bx	lr
 801c4c0:	20012af8 	.word	0x20012af8

0801c4c4 <OP_add_word>:

void OP_add_word()
{
 801c4c4:	b480      	push	{r7}
 801c4c6:	af00      	add	r7, sp, #0
    OP_BIN_WORD(+);
 801c4c8:	4b0d      	ldr	r3, [pc, #52]	; (801c500 <OP_add_word+0x3c>)
 801c4ca:	681b      	ldr	r3, [r3, #0]
 801c4cc:	3b08      	subs	r3, #8
 801c4ce:	4a0c      	ldr	r2, [pc, #48]	; (801c500 <OP_add_word+0x3c>)
 801c4d0:	6812      	ldr	r2, [r2, #0]
 801c4d2:	3a08      	subs	r2, #8
 801c4d4:	8812      	ldrh	r2, [r2, #0]
 801c4d6:	b291      	uxth	r1, r2
 801c4d8:	4a09      	ldr	r2, [pc, #36]	; (801c500 <OP_add_word+0x3c>)
 801c4da:	6812      	ldr	r2, [r2, #0]
 801c4dc:	3a04      	subs	r2, #4
 801c4de:	8812      	ldrh	r2, [r2, #0]
 801c4e0:	b292      	uxth	r2, r2
 801c4e2:	440a      	add	r2, r1
 801c4e4:	b292      	uxth	r2, r2
 801c4e6:	b292      	uxth	r2, r2
 801c4e8:	801a      	strh	r2, [r3, #0]
 801c4ea:	4b05      	ldr	r3, [pc, #20]	; (801c500 <OP_add_word+0x3c>)
 801c4ec:	681b      	ldr	r3, [r3, #0]
 801c4ee:	3b04      	subs	r3, #4
 801c4f0:	4a03      	ldr	r2, [pc, #12]	; (801c500 <OP_add_word+0x3c>)
 801c4f2:	6013      	str	r3, [r2, #0]

	return ;
 801c4f4:	bf00      	nop
}
 801c4f6:	46bd      	mov	sp, r7
 801c4f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c4fc:	4770      	bx	lr
 801c4fe:	bf00      	nop
 801c500:	20012af8 	.word	0x20012af8

0801c504 <OP_add_dword>:

void OP_add_dword()
{
 801c504:	b480      	push	{r7}
 801c506:	af00      	add	r7, sp, #0
    OP_BIN_DWORD(+);
 801c508:	4b0b      	ldr	r3, [pc, #44]	; (801c538 <OP_add_dword+0x34>)
 801c50a:	681b      	ldr	r3, [r3, #0]
 801c50c:	3b08      	subs	r3, #8
 801c50e:	4a0a      	ldr	r2, [pc, #40]	; (801c538 <OP_add_dword+0x34>)
 801c510:	6812      	ldr	r2, [r2, #0]
 801c512:	3a08      	subs	r2, #8
 801c514:	6811      	ldr	r1, [r2, #0]
 801c516:	4a08      	ldr	r2, [pc, #32]	; (801c538 <OP_add_dword+0x34>)
 801c518:	6812      	ldr	r2, [r2, #0]
 801c51a:	3a04      	subs	r2, #4
 801c51c:	6812      	ldr	r2, [r2, #0]
 801c51e:	440a      	add	r2, r1
 801c520:	601a      	str	r2, [r3, #0]
 801c522:	4b05      	ldr	r3, [pc, #20]	; (801c538 <OP_add_dword+0x34>)
 801c524:	681b      	ldr	r3, [r3, #0]
 801c526:	3b04      	subs	r3, #4
 801c528:	4a03      	ldr	r2, [pc, #12]	; (801c538 <OP_add_dword+0x34>)
 801c52a:	6013      	str	r3, [r2, #0]

	return ;
 801c52c:	bf00      	nop
}
 801c52e:	46bd      	mov	sp, r7
 801c530:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c534:	4770      	bx	lr
 801c536:	bf00      	nop
 801c538:	20012af8 	.word	0x20012af8

0801c53c <OP_sub_byte>:

/* --- sub --- */
void OP_sub_byte()
{
 801c53c:	b480      	push	{r7}
 801c53e:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(-);
 801c540:	4b0b      	ldr	r3, [pc, #44]	; (801c570 <OP_sub_byte+0x34>)
 801c542:	681b      	ldr	r3, [r3, #0]
 801c544:	3b08      	subs	r3, #8
 801c546:	4a0a      	ldr	r2, [pc, #40]	; (801c570 <OP_sub_byte+0x34>)
 801c548:	6812      	ldr	r2, [r2, #0]
 801c54a:	3a08      	subs	r2, #8
 801c54c:	7811      	ldrb	r1, [r2, #0]
 801c54e:	4a08      	ldr	r2, [pc, #32]	; (801c570 <OP_sub_byte+0x34>)
 801c550:	6812      	ldr	r2, [r2, #0]
 801c552:	3a04      	subs	r2, #4
 801c554:	7812      	ldrb	r2, [r2, #0]
 801c556:	1a8a      	subs	r2, r1, r2
 801c558:	b2d2      	uxtb	r2, r2
 801c55a:	701a      	strb	r2, [r3, #0]
 801c55c:	4b04      	ldr	r3, [pc, #16]	; (801c570 <OP_sub_byte+0x34>)
 801c55e:	681b      	ldr	r3, [r3, #0]
 801c560:	3b04      	subs	r3, #4
 801c562:	4a03      	ldr	r2, [pc, #12]	; (801c570 <OP_sub_byte+0x34>)
 801c564:	6013      	str	r3, [r2, #0]

	return ;
 801c566:	bf00      	nop
}
 801c568:	46bd      	mov	sp, r7
 801c56a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c56e:	4770      	bx	lr
 801c570:	20012af8 	.word	0x20012af8

0801c574 <OP_sub_word>:

void OP_sub_word()
{
 801c574:	b480      	push	{r7}
 801c576:	af00      	add	r7, sp, #0
	OP_BIN_WORD(-);
 801c578:	4b0d      	ldr	r3, [pc, #52]	; (801c5b0 <OP_sub_word+0x3c>)
 801c57a:	681b      	ldr	r3, [r3, #0]
 801c57c:	3b08      	subs	r3, #8
 801c57e:	4a0c      	ldr	r2, [pc, #48]	; (801c5b0 <OP_sub_word+0x3c>)
 801c580:	6812      	ldr	r2, [r2, #0]
 801c582:	3a08      	subs	r2, #8
 801c584:	8812      	ldrh	r2, [r2, #0]
 801c586:	b291      	uxth	r1, r2
 801c588:	4a09      	ldr	r2, [pc, #36]	; (801c5b0 <OP_sub_word+0x3c>)
 801c58a:	6812      	ldr	r2, [r2, #0]
 801c58c:	3a04      	subs	r2, #4
 801c58e:	8812      	ldrh	r2, [r2, #0]
 801c590:	b292      	uxth	r2, r2
 801c592:	1a8a      	subs	r2, r1, r2
 801c594:	b292      	uxth	r2, r2
 801c596:	b292      	uxth	r2, r2
 801c598:	801a      	strh	r2, [r3, #0]
 801c59a:	4b05      	ldr	r3, [pc, #20]	; (801c5b0 <OP_sub_word+0x3c>)
 801c59c:	681b      	ldr	r3, [r3, #0]
 801c59e:	3b04      	subs	r3, #4
 801c5a0:	4a03      	ldr	r2, [pc, #12]	; (801c5b0 <OP_sub_word+0x3c>)
 801c5a2:	6013      	str	r3, [r2, #0]

	return ;
 801c5a4:	bf00      	nop
}
 801c5a6:	46bd      	mov	sp, r7
 801c5a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c5ac:	4770      	bx	lr
 801c5ae:	bf00      	nop
 801c5b0:	20012af8 	.word	0x20012af8

0801c5b4 <OP_sub_dword>:

void OP_sub_dword()
{
 801c5b4:	b480      	push	{r7}
 801c5b6:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(-);
 801c5b8:	4b0b      	ldr	r3, [pc, #44]	; (801c5e8 <OP_sub_dword+0x34>)
 801c5ba:	681b      	ldr	r3, [r3, #0]
 801c5bc:	3b08      	subs	r3, #8
 801c5be:	4a0a      	ldr	r2, [pc, #40]	; (801c5e8 <OP_sub_dword+0x34>)
 801c5c0:	6812      	ldr	r2, [r2, #0]
 801c5c2:	3a08      	subs	r2, #8
 801c5c4:	6811      	ldr	r1, [r2, #0]
 801c5c6:	4a08      	ldr	r2, [pc, #32]	; (801c5e8 <OP_sub_dword+0x34>)
 801c5c8:	6812      	ldr	r2, [r2, #0]
 801c5ca:	3a04      	subs	r2, #4
 801c5cc:	6812      	ldr	r2, [r2, #0]
 801c5ce:	1a8a      	subs	r2, r1, r2
 801c5d0:	601a      	str	r2, [r3, #0]
 801c5d2:	4b05      	ldr	r3, [pc, #20]	; (801c5e8 <OP_sub_dword+0x34>)
 801c5d4:	681b      	ldr	r3, [r3, #0]
 801c5d6:	3b04      	subs	r3, #4
 801c5d8:	4a03      	ldr	r2, [pc, #12]	; (801c5e8 <OP_sub_dword+0x34>)
 801c5da:	6013      	str	r3, [r2, #0]

	return ;
 801c5dc:	bf00      	nop
}
 801c5de:	46bd      	mov	sp, r7
 801c5e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c5e4:	4770      	bx	lr
 801c5e6:	bf00      	nop
 801c5e8:	20012af8 	.word	0x20012af8

0801c5ec <OP_div_byte>:

/* --- div --- */
void OP_div_byte()
{
 801c5ec:	b480      	push	{r7}
 801c5ee:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(/);
 801c5f0:	4b0c      	ldr	r3, [pc, #48]	; (801c624 <OP_div_byte+0x38>)
 801c5f2:	681b      	ldr	r3, [r3, #0]
 801c5f4:	3b08      	subs	r3, #8
 801c5f6:	4a0b      	ldr	r2, [pc, #44]	; (801c624 <OP_div_byte+0x38>)
 801c5f8:	6812      	ldr	r2, [r2, #0]
 801c5fa:	3a08      	subs	r2, #8
 801c5fc:	7811      	ldrb	r1, [r2, #0]
 801c5fe:	4a09      	ldr	r2, [pc, #36]	; (801c624 <OP_div_byte+0x38>)
 801c600:	6812      	ldr	r2, [r2, #0]
 801c602:	3a04      	subs	r2, #4
 801c604:	7812      	ldrb	r2, [r2, #0]
 801c606:	fbb1 f2f2 	udiv	r2, r1, r2
 801c60a:	b2d2      	uxtb	r2, r2
 801c60c:	701a      	strb	r2, [r3, #0]
 801c60e:	4b05      	ldr	r3, [pc, #20]	; (801c624 <OP_div_byte+0x38>)
 801c610:	681b      	ldr	r3, [r3, #0]
 801c612:	3b04      	subs	r3, #4
 801c614:	4a03      	ldr	r2, [pc, #12]	; (801c624 <OP_div_byte+0x38>)
 801c616:	6013      	str	r3, [r2, #0]

	return ;
 801c618:	bf00      	nop
}
 801c61a:	46bd      	mov	sp, r7
 801c61c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c620:	4770      	bx	lr
 801c622:	bf00      	nop
 801c624:	20012af8 	.word	0x20012af8

0801c628 <OP_div_word>:

void OP_div_word()
{
 801c628:	b480      	push	{r7}
 801c62a:	af00      	add	r7, sp, #0
	OP_BIN_WORD(/);
 801c62c:	4b0d      	ldr	r3, [pc, #52]	; (801c664 <OP_div_word+0x3c>)
 801c62e:	681b      	ldr	r3, [r3, #0]
 801c630:	3b08      	subs	r3, #8
 801c632:	4a0c      	ldr	r2, [pc, #48]	; (801c664 <OP_div_word+0x3c>)
 801c634:	6812      	ldr	r2, [r2, #0]
 801c636:	3a08      	subs	r2, #8
 801c638:	8812      	ldrh	r2, [r2, #0]
 801c63a:	b211      	sxth	r1, r2
 801c63c:	4a09      	ldr	r2, [pc, #36]	; (801c664 <OP_div_word+0x3c>)
 801c63e:	6812      	ldr	r2, [r2, #0]
 801c640:	3a04      	subs	r2, #4
 801c642:	8812      	ldrh	r2, [r2, #0]
 801c644:	b212      	sxth	r2, r2
 801c646:	fb91 f2f2 	sdiv	r2, r1, r2
 801c64a:	b292      	uxth	r2, r2
 801c64c:	801a      	strh	r2, [r3, #0]
 801c64e:	4b05      	ldr	r3, [pc, #20]	; (801c664 <OP_div_word+0x3c>)
 801c650:	681b      	ldr	r3, [r3, #0]
 801c652:	3b04      	subs	r3, #4
 801c654:	4a03      	ldr	r2, [pc, #12]	; (801c664 <OP_div_word+0x3c>)
 801c656:	6013      	str	r3, [r2, #0]

	return ;
 801c658:	bf00      	nop
}
 801c65a:	46bd      	mov	sp, r7
 801c65c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c660:	4770      	bx	lr
 801c662:	bf00      	nop
 801c664:	20012af8 	.word	0x20012af8

0801c668 <OP_div_dword>:

void OP_div_dword()
{
 801c668:	b480      	push	{r7}
 801c66a:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(/);
 801c66c:	4b0b      	ldr	r3, [pc, #44]	; (801c69c <OP_div_dword+0x34>)
 801c66e:	681b      	ldr	r3, [r3, #0]
 801c670:	3b08      	subs	r3, #8
 801c672:	4a0a      	ldr	r2, [pc, #40]	; (801c69c <OP_div_dword+0x34>)
 801c674:	6812      	ldr	r2, [r2, #0]
 801c676:	3a08      	subs	r2, #8
 801c678:	6811      	ldr	r1, [r2, #0]
 801c67a:	4a08      	ldr	r2, [pc, #32]	; (801c69c <OP_div_dword+0x34>)
 801c67c:	6812      	ldr	r2, [r2, #0]
 801c67e:	3a04      	subs	r2, #4
 801c680:	6812      	ldr	r2, [r2, #0]
 801c682:	fb91 f2f2 	sdiv	r2, r1, r2
 801c686:	601a      	str	r2, [r3, #0]
 801c688:	4b04      	ldr	r3, [pc, #16]	; (801c69c <OP_div_dword+0x34>)
 801c68a:	681b      	ldr	r3, [r3, #0]
 801c68c:	3b04      	subs	r3, #4
 801c68e:	4a03      	ldr	r2, [pc, #12]	; (801c69c <OP_div_dword+0x34>)
 801c690:	6013      	str	r3, [r2, #0]

	return ;
 801c692:	bf00      	nop
}
 801c694:	46bd      	mov	sp, r7
 801c696:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c69a:	4770      	bx	lr
 801c69c:	20012af8 	.word	0x20012af8

0801c6a0 <OP_mod_byte>:

/* --- mod --- */
void OP_mod_byte()
{
 801c6a0:	b480      	push	{r7}
 801c6a2:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(%);
 801c6a4:	4b0e      	ldr	r3, [pc, #56]	; (801c6e0 <OP_mod_byte+0x40>)
 801c6a6:	681b      	ldr	r3, [r3, #0]
 801c6a8:	f1a3 0108 	sub.w	r1, r3, #8
 801c6ac:	4b0c      	ldr	r3, [pc, #48]	; (801c6e0 <OP_mod_byte+0x40>)
 801c6ae:	681b      	ldr	r3, [r3, #0]
 801c6b0:	3b08      	subs	r3, #8
 801c6b2:	781b      	ldrb	r3, [r3, #0]
 801c6b4:	4a0a      	ldr	r2, [pc, #40]	; (801c6e0 <OP_mod_byte+0x40>)
 801c6b6:	6812      	ldr	r2, [r2, #0]
 801c6b8:	3a04      	subs	r2, #4
 801c6ba:	7812      	ldrb	r2, [r2, #0]
 801c6bc:	fbb3 f0f2 	udiv	r0, r3, r2
 801c6c0:	fb02 f200 	mul.w	r2, r2, r0
 801c6c4:	1a9b      	subs	r3, r3, r2
 801c6c6:	b2db      	uxtb	r3, r3
 801c6c8:	700b      	strb	r3, [r1, #0]
 801c6ca:	4b05      	ldr	r3, [pc, #20]	; (801c6e0 <OP_mod_byte+0x40>)
 801c6cc:	681b      	ldr	r3, [r3, #0]
 801c6ce:	3b04      	subs	r3, #4
 801c6d0:	4a03      	ldr	r2, [pc, #12]	; (801c6e0 <OP_mod_byte+0x40>)
 801c6d2:	6013      	str	r3, [r2, #0]

	return ;
 801c6d4:	bf00      	nop
}
 801c6d6:	46bd      	mov	sp, r7
 801c6d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c6dc:	4770      	bx	lr
 801c6de:	bf00      	nop
 801c6e0:	20012af8 	.word	0x20012af8

0801c6e4 <OP_mod_word>:

void OP_mod_word()
{
 801c6e4:	b480      	push	{r7}
 801c6e6:	af00      	add	r7, sp, #0
	OP_BIN_WORD(%);
 801c6e8:	4b0f      	ldr	r3, [pc, #60]	; (801c728 <OP_mod_word+0x44>)
 801c6ea:	681b      	ldr	r3, [r3, #0]
 801c6ec:	f1a3 0108 	sub.w	r1, r3, #8
 801c6f0:	4b0d      	ldr	r3, [pc, #52]	; (801c728 <OP_mod_word+0x44>)
 801c6f2:	681b      	ldr	r3, [r3, #0]
 801c6f4:	3b08      	subs	r3, #8
 801c6f6:	881b      	ldrh	r3, [r3, #0]
 801c6f8:	b21b      	sxth	r3, r3
 801c6fa:	4a0b      	ldr	r2, [pc, #44]	; (801c728 <OP_mod_word+0x44>)
 801c6fc:	6812      	ldr	r2, [r2, #0]
 801c6fe:	3a04      	subs	r2, #4
 801c700:	8812      	ldrh	r2, [r2, #0]
 801c702:	b212      	sxth	r2, r2
 801c704:	fb93 f0f2 	sdiv	r0, r3, r2
 801c708:	fb02 f200 	mul.w	r2, r2, r0
 801c70c:	1a9b      	subs	r3, r3, r2
 801c70e:	b29b      	uxth	r3, r3
 801c710:	800b      	strh	r3, [r1, #0]
 801c712:	4b05      	ldr	r3, [pc, #20]	; (801c728 <OP_mod_word+0x44>)
 801c714:	681b      	ldr	r3, [r3, #0]
 801c716:	3b04      	subs	r3, #4
 801c718:	4a03      	ldr	r2, [pc, #12]	; (801c728 <OP_mod_word+0x44>)
 801c71a:	6013      	str	r3, [r2, #0]

	return ;
 801c71c:	bf00      	nop
}
 801c71e:	46bd      	mov	sp, r7
 801c720:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c724:	4770      	bx	lr
 801c726:	bf00      	nop
 801c728:	20012af8 	.word	0x20012af8

0801c72c <OP_mod_dword>:

void OP_mod_dword()
{
 801c72c:	b480      	push	{r7}
 801c72e:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(%);
 801c730:	4b0d      	ldr	r3, [pc, #52]	; (801c768 <OP_mod_dword+0x3c>)
 801c732:	681b      	ldr	r3, [r3, #0]
 801c734:	f1a3 0108 	sub.w	r1, r3, #8
 801c738:	4b0b      	ldr	r3, [pc, #44]	; (801c768 <OP_mod_dword+0x3c>)
 801c73a:	681b      	ldr	r3, [r3, #0]
 801c73c:	3b08      	subs	r3, #8
 801c73e:	681b      	ldr	r3, [r3, #0]
 801c740:	4a09      	ldr	r2, [pc, #36]	; (801c768 <OP_mod_dword+0x3c>)
 801c742:	6812      	ldr	r2, [r2, #0]
 801c744:	3a04      	subs	r2, #4
 801c746:	6812      	ldr	r2, [r2, #0]
 801c748:	fb93 f0f2 	sdiv	r0, r3, r2
 801c74c:	fb02 f200 	mul.w	r2, r2, r0
 801c750:	1a9b      	subs	r3, r3, r2
 801c752:	600b      	str	r3, [r1, #0]
 801c754:	4b04      	ldr	r3, [pc, #16]	; (801c768 <OP_mod_dword+0x3c>)
 801c756:	681b      	ldr	r3, [r3, #0]
 801c758:	3b04      	subs	r3, #4
 801c75a:	4a03      	ldr	r2, [pc, #12]	; (801c768 <OP_mod_dword+0x3c>)
 801c75c:	6013      	str	r3, [r2, #0]

	return ;
 801c75e:	bf00      	nop
}
 801c760:	46bd      	mov	sp, r7
 801c762:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c766:	4770      	bx	lr
 801c768:	20012af8 	.word	0x20012af8

0801c76c <OP_mul_byte>:

/* --- mul --- */
void OP_mul_byte()
{
 801c76c:	b480      	push	{r7}
 801c76e:	af00      	add	r7, sp, #0
    OP_BIN_BYTE(*);
 801c770:	4b0c      	ldr	r3, [pc, #48]	; (801c7a4 <OP_mul_byte+0x38>)
 801c772:	681b      	ldr	r3, [r3, #0]
 801c774:	3b08      	subs	r3, #8
 801c776:	4a0b      	ldr	r2, [pc, #44]	; (801c7a4 <OP_mul_byte+0x38>)
 801c778:	6812      	ldr	r2, [r2, #0]
 801c77a:	3a08      	subs	r2, #8
 801c77c:	7811      	ldrb	r1, [r2, #0]
 801c77e:	4a09      	ldr	r2, [pc, #36]	; (801c7a4 <OP_mul_byte+0x38>)
 801c780:	6812      	ldr	r2, [r2, #0]
 801c782:	3a04      	subs	r2, #4
 801c784:	7812      	ldrb	r2, [r2, #0]
 801c786:	fb11 f202 	smulbb	r2, r1, r2
 801c78a:	b2d2      	uxtb	r2, r2
 801c78c:	701a      	strb	r2, [r3, #0]
 801c78e:	4b05      	ldr	r3, [pc, #20]	; (801c7a4 <OP_mul_byte+0x38>)
 801c790:	681b      	ldr	r3, [r3, #0]
 801c792:	3b04      	subs	r3, #4
 801c794:	4a03      	ldr	r2, [pc, #12]	; (801c7a4 <OP_mul_byte+0x38>)
 801c796:	6013      	str	r3, [r2, #0]

	return ;
 801c798:	bf00      	nop
}
 801c79a:	46bd      	mov	sp, r7
 801c79c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c7a0:	4770      	bx	lr
 801c7a2:	bf00      	nop
 801c7a4:	20012af8 	.word	0x20012af8

0801c7a8 <OP_mul_word>:

void OP_mul_word()
{
 801c7a8:	b480      	push	{r7}
 801c7aa:	af00      	add	r7, sp, #0
	OP_BIN_WORD(*);
 801c7ac:	4b0d      	ldr	r3, [pc, #52]	; (801c7e4 <OP_mul_word+0x3c>)
 801c7ae:	681b      	ldr	r3, [r3, #0]
 801c7b0:	3b08      	subs	r3, #8
 801c7b2:	4a0c      	ldr	r2, [pc, #48]	; (801c7e4 <OP_mul_word+0x3c>)
 801c7b4:	6812      	ldr	r2, [r2, #0]
 801c7b6:	3a08      	subs	r2, #8
 801c7b8:	8812      	ldrh	r2, [r2, #0]
 801c7ba:	b291      	uxth	r1, r2
 801c7bc:	4a09      	ldr	r2, [pc, #36]	; (801c7e4 <OP_mul_word+0x3c>)
 801c7be:	6812      	ldr	r2, [r2, #0]
 801c7c0:	3a04      	subs	r2, #4
 801c7c2:	8812      	ldrh	r2, [r2, #0]
 801c7c4:	b292      	uxth	r2, r2
 801c7c6:	fb11 f202 	smulbb	r2, r1, r2
 801c7ca:	b292      	uxth	r2, r2
 801c7cc:	b292      	uxth	r2, r2
 801c7ce:	801a      	strh	r2, [r3, #0]
 801c7d0:	4b04      	ldr	r3, [pc, #16]	; (801c7e4 <OP_mul_word+0x3c>)
 801c7d2:	681b      	ldr	r3, [r3, #0]
 801c7d4:	3b04      	subs	r3, #4
 801c7d6:	4a03      	ldr	r2, [pc, #12]	; (801c7e4 <OP_mul_word+0x3c>)
 801c7d8:	6013      	str	r3, [r2, #0]

	return ;
 801c7da:	bf00      	nop
}
 801c7dc:	46bd      	mov	sp, r7
 801c7de:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c7e2:	4770      	bx	lr
 801c7e4:	20012af8 	.word	0x20012af8

0801c7e8 <OP_mul_dword>:

void OP_mul_dword()
{
 801c7e8:	b480      	push	{r7}
 801c7ea:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(*);
 801c7ec:	4b0b      	ldr	r3, [pc, #44]	; (801c81c <OP_mul_dword+0x34>)
 801c7ee:	681b      	ldr	r3, [r3, #0]
 801c7f0:	3b08      	subs	r3, #8
 801c7f2:	4a0a      	ldr	r2, [pc, #40]	; (801c81c <OP_mul_dword+0x34>)
 801c7f4:	6812      	ldr	r2, [r2, #0]
 801c7f6:	3a08      	subs	r2, #8
 801c7f8:	6812      	ldr	r2, [r2, #0]
 801c7fa:	4908      	ldr	r1, [pc, #32]	; (801c81c <OP_mul_dword+0x34>)
 801c7fc:	6809      	ldr	r1, [r1, #0]
 801c7fe:	3904      	subs	r1, #4
 801c800:	6809      	ldr	r1, [r1, #0]
 801c802:	fb01 f202 	mul.w	r2, r1, r2
 801c806:	601a      	str	r2, [r3, #0]
 801c808:	4b04      	ldr	r3, [pc, #16]	; (801c81c <OP_mul_dword+0x34>)
 801c80a:	681b      	ldr	r3, [r3, #0]
 801c80c:	3b04      	subs	r3, #4
 801c80e:	4a03      	ldr	r2, [pc, #12]	; (801c81c <OP_mul_dword+0x34>)
 801c810:	6013      	str	r3, [r2, #0]

	return ;
 801c812:	bf00      	nop
}
 801c814:	46bd      	mov	sp, r7
 801c816:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c81a:	4770      	bx	lr
 801c81c:	20012af8 	.word	0x20012af8

0801c820 <OP_and_byte>:

/* --- and --- */
void OP_and_byte()
{
 801c820:	b480      	push	{r7}
 801c822:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(&);
 801c824:	4b0b      	ldr	r3, [pc, #44]	; (801c854 <OP_and_byte+0x34>)
 801c826:	681b      	ldr	r3, [r3, #0]
 801c828:	3b08      	subs	r3, #8
 801c82a:	4a0a      	ldr	r2, [pc, #40]	; (801c854 <OP_and_byte+0x34>)
 801c82c:	6812      	ldr	r2, [r2, #0]
 801c82e:	3a08      	subs	r2, #8
 801c830:	7811      	ldrb	r1, [r2, #0]
 801c832:	4a08      	ldr	r2, [pc, #32]	; (801c854 <OP_and_byte+0x34>)
 801c834:	6812      	ldr	r2, [r2, #0]
 801c836:	3a04      	subs	r2, #4
 801c838:	7812      	ldrb	r2, [r2, #0]
 801c83a:	400a      	ands	r2, r1
 801c83c:	b2d2      	uxtb	r2, r2
 801c83e:	701a      	strb	r2, [r3, #0]
 801c840:	4b04      	ldr	r3, [pc, #16]	; (801c854 <OP_and_byte+0x34>)
 801c842:	681b      	ldr	r3, [r3, #0]
 801c844:	3b04      	subs	r3, #4
 801c846:	4a03      	ldr	r2, [pc, #12]	; (801c854 <OP_and_byte+0x34>)
 801c848:	6013      	str	r3, [r2, #0]

	return ;
 801c84a:	bf00      	nop
}
 801c84c:	46bd      	mov	sp, r7
 801c84e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c852:	4770      	bx	lr
 801c854:	20012af8 	.word	0x20012af8

0801c858 <OP_and_word>:

void OP_and_word()
{
 801c858:	b480      	push	{r7}
 801c85a:	af00      	add	r7, sp, #0
	OP_BIN_WORD(&);
 801c85c:	4b0b      	ldr	r3, [pc, #44]	; (801c88c <OP_and_word+0x34>)
 801c85e:	681b      	ldr	r3, [r3, #0]
 801c860:	3b08      	subs	r3, #8
 801c862:	4a0a      	ldr	r2, [pc, #40]	; (801c88c <OP_and_word+0x34>)
 801c864:	6812      	ldr	r2, [r2, #0]
 801c866:	3a08      	subs	r2, #8
 801c868:	8811      	ldrh	r1, [r2, #0]
 801c86a:	4a08      	ldr	r2, [pc, #32]	; (801c88c <OP_and_word+0x34>)
 801c86c:	6812      	ldr	r2, [r2, #0]
 801c86e:	3a04      	subs	r2, #4
 801c870:	8812      	ldrh	r2, [r2, #0]
 801c872:	400a      	ands	r2, r1
 801c874:	b292      	uxth	r2, r2
 801c876:	801a      	strh	r2, [r3, #0]
 801c878:	4b04      	ldr	r3, [pc, #16]	; (801c88c <OP_and_word+0x34>)
 801c87a:	681b      	ldr	r3, [r3, #0]
 801c87c:	3b04      	subs	r3, #4
 801c87e:	4a03      	ldr	r2, [pc, #12]	; (801c88c <OP_and_word+0x34>)
 801c880:	6013      	str	r3, [r2, #0]

	return ;
 801c882:	bf00      	nop
}
 801c884:	46bd      	mov	sp, r7
 801c886:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c88a:	4770      	bx	lr
 801c88c:	20012af8 	.word	0x20012af8

0801c890 <OP_and_dword>:

void OP_and_dword()
{
 801c890:	b480      	push	{r7}
 801c892:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(&);
 801c894:	4b0b      	ldr	r3, [pc, #44]	; (801c8c4 <OP_and_dword+0x34>)
 801c896:	681b      	ldr	r3, [r3, #0]
 801c898:	3b08      	subs	r3, #8
 801c89a:	4a0a      	ldr	r2, [pc, #40]	; (801c8c4 <OP_and_dword+0x34>)
 801c89c:	6812      	ldr	r2, [r2, #0]
 801c89e:	3a08      	subs	r2, #8
 801c8a0:	6811      	ldr	r1, [r2, #0]
 801c8a2:	4a08      	ldr	r2, [pc, #32]	; (801c8c4 <OP_and_dword+0x34>)
 801c8a4:	6812      	ldr	r2, [r2, #0]
 801c8a6:	3a04      	subs	r2, #4
 801c8a8:	6812      	ldr	r2, [r2, #0]
 801c8aa:	400a      	ands	r2, r1
 801c8ac:	601a      	str	r2, [r3, #0]
 801c8ae:	4b05      	ldr	r3, [pc, #20]	; (801c8c4 <OP_and_dword+0x34>)
 801c8b0:	681b      	ldr	r3, [r3, #0]
 801c8b2:	3b04      	subs	r3, #4
 801c8b4:	4a03      	ldr	r2, [pc, #12]	; (801c8c4 <OP_and_dword+0x34>)
 801c8b6:	6013      	str	r3, [r2, #0]

	return ;
 801c8b8:	bf00      	nop
}
 801c8ba:	46bd      	mov	sp, r7
 801c8bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c8c0:	4770      	bx	lr
 801c8c2:	bf00      	nop
 801c8c4:	20012af8 	.word	0x20012af8

0801c8c8 <OP_or_byte>:

/* --- or --- */
void OP_or_byte()
{
 801c8c8:	b480      	push	{r7}
 801c8ca:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(|);
 801c8cc:	4b0b      	ldr	r3, [pc, #44]	; (801c8fc <OP_or_byte+0x34>)
 801c8ce:	681b      	ldr	r3, [r3, #0]
 801c8d0:	3b08      	subs	r3, #8
 801c8d2:	4a0a      	ldr	r2, [pc, #40]	; (801c8fc <OP_or_byte+0x34>)
 801c8d4:	6812      	ldr	r2, [r2, #0]
 801c8d6:	3a08      	subs	r2, #8
 801c8d8:	7811      	ldrb	r1, [r2, #0]
 801c8da:	4a08      	ldr	r2, [pc, #32]	; (801c8fc <OP_or_byte+0x34>)
 801c8dc:	6812      	ldr	r2, [r2, #0]
 801c8de:	3a04      	subs	r2, #4
 801c8e0:	7812      	ldrb	r2, [r2, #0]
 801c8e2:	430a      	orrs	r2, r1
 801c8e4:	b2d2      	uxtb	r2, r2
 801c8e6:	701a      	strb	r2, [r3, #0]
 801c8e8:	4b04      	ldr	r3, [pc, #16]	; (801c8fc <OP_or_byte+0x34>)
 801c8ea:	681b      	ldr	r3, [r3, #0]
 801c8ec:	3b04      	subs	r3, #4
 801c8ee:	4a03      	ldr	r2, [pc, #12]	; (801c8fc <OP_or_byte+0x34>)
 801c8f0:	6013      	str	r3, [r2, #0]

	return ;
 801c8f2:	bf00      	nop
}
 801c8f4:	46bd      	mov	sp, r7
 801c8f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c8fa:	4770      	bx	lr
 801c8fc:	20012af8 	.word	0x20012af8

0801c900 <OP_or_word>:

void OP_or_word()
{
 801c900:	b480      	push	{r7}
 801c902:	af00      	add	r7, sp, #0
	OP_BIN_WORD(|);
 801c904:	4b0b      	ldr	r3, [pc, #44]	; (801c934 <OP_or_word+0x34>)
 801c906:	681b      	ldr	r3, [r3, #0]
 801c908:	3b08      	subs	r3, #8
 801c90a:	4a0a      	ldr	r2, [pc, #40]	; (801c934 <OP_or_word+0x34>)
 801c90c:	6812      	ldr	r2, [r2, #0]
 801c90e:	3a08      	subs	r2, #8
 801c910:	8811      	ldrh	r1, [r2, #0]
 801c912:	4a08      	ldr	r2, [pc, #32]	; (801c934 <OP_or_word+0x34>)
 801c914:	6812      	ldr	r2, [r2, #0]
 801c916:	3a04      	subs	r2, #4
 801c918:	8812      	ldrh	r2, [r2, #0]
 801c91a:	430a      	orrs	r2, r1
 801c91c:	b292      	uxth	r2, r2
 801c91e:	801a      	strh	r2, [r3, #0]
 801c920:	4b04      	ldr	r3, [pc, #16]	; (801c934 <OP_or_word+0x34>)
 801c922:	681b      	ldr	r3, [r3, #0]
 801c924:	3b04      	subs	r3, #4
 801c926:	4a03      	ldr	r2, [pc, #12]	; (801c934 <OP_or_word+0x34>)
 801c928:	6013      	str	r3, [r2, #0]

	return ;
 801c92a:	bf00      	nop
}
 801c92c:	46bd      	mov	sp, r7
 801c92e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c932:	4770      	bx	lr
 801c934:	20012af8 	.word	0x20012af8

0801c938 <OP_or_dword>:

void OP_or_dword()
{
 801c938:	b480      	push	{r7}
 801c93a:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(|);
 801c93c:	4b0b      	ldr	r3, [pc, #44]	; (801c96c <OP_or_dword+0x34>)
 801c93e:	681b      	ldr	r3, [r3, #0]
 801c940:	3b08      	subs	r3, #8
 801c942:	4a0a      	ldr	r2, [pc, #40]	; (801c96c <OP_or_dword+0x34>)
 801c944:	6812      	ldr	r2, [r2, #0]
 801c946:	3a08      	subs	r2, #8
 801c948:	6811      	ldr	r1, [r2, #0]
 801c94a:	4a08      	ldr	r2, [pc, #32]	; (801c96c <OP_or_dword+0x34>)
 801c94c:	6812      	ldr	r2, [r2, #0]
 801c94e:	3a04      	subs	r2, #4
 801c950:	6812      	ldr	r2, [r2, #0]
 801c952:	430a      	orrs	r2, r1
 801c954:	601a      	str	r2, [r3, #0]
 801c956:	4b05      	ldr	r3, [pc, #20]	; (801c96c <OP_or_dword+0x34>)
 801c958:	681b      	ldr	r3, [r3, #0]
 801c95a:	3b04      	subs	r3, #4
 801c95c:	4a03      	ldr	r2, [pc, #12]	; (801c96c <OP_or_dword+0x34>)
 801c95e:	6013      	str	r3, [r2, #0]

	return ;
 801c960:	bf00      	nop
}
 801c962:	46bd      	mov	sp, r7
 801c964:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c968:	4770      	bx	lr
 801c96a:	bf00      	nop
 801c96c:	20012af8 	.word	0x20012af8

0801c970 <OP_xor_byte>:

/* --- xor --- */
void OP_xor_byte()
{
 801c970:	b480      	push	{r7}
 801c972:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(^);
 801c974:	4b0b      	ldr	r3, [pc, #44]	; (801c9a4 <OP_xor_byte+0x34>)
 801c976:	681b      	ldr	r3, [r3, #0]
 801c978:	3b08      	subs	r3, #8
 801c97a:	4a0a      	ldr	r2, [pc, #40]	; (801c9a4 <OP_xor_byte+0x34>)
 801c97c:	6812      	ldr	r2, [r2, #0]
 801c97e:	3a08      	subs	r2, #8
 801c980:	7811      	ldrb	r1, [r2, #0]
 801c982:	4a08      	ldr	r2, [pc, #32]	; (801c9a4 <OP_xor_byte+0x34>)
 801c984:	6812      	ldr	r2, [r2, #0]
 801c986:	3a04      	subs	r2, #4
 801c988:	7812      	ldrb	r2, [r2, #0]
 801c98a:	404a      	eors	r2, r1
 801c98c:	b2d2      	uxtb	r2, r2
 801c98e:	701a      	strb	r2, [r3, #0]
 801c990:	4b04      	ldr	r3, [pc, #16]	; (801c9a4 <OP_xor_byte+0x34>)
 801c992:	681b      	ldr	r3, [r3, #0]
 801c994:	3b04      	subs	r3, #4
 801c996:	4a03      	ldr	r2, [pc, #12]	; (801c9a4 <OP_xor_byte+0x34>)
 801c998:	6013      	str	r3, [r2, #0]

	return ;
 801c99a:	bf00      	nop
}
 801c99c:	46bd      	mov	sp, r7
 801c99e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c9a2:	4770      	bx	lr
 801c9a4:	20012af8 	.word	0x20012af8

0801c9a8 <OP_xor_word>:

void OP_xor_word()
{
 801c9a8:	b480      	push	{r7}
 801c9aa:	af00      	add	r7, sp, #0
	OP_BIN_WORD(^);
 801c9ac:	4b0b      	ldr	r3, [pc, #44]	; (801c9dc <OP_xor_word+0x34>)
 801c9ae:	681b      	ldr	r3, [r3, #0]
 801c9b0:	3b08      	subs	r3, #8
 801c9b2:	4a0a      	ldr	r2, [pc, #40]	; (801c9dc <OP_xor_word+0x34>)
 801c9b4:	6812      	ldr	r2, [r2, #0]
 801c9b6:	3a08      	subs	r2, #8
 801c9b8:	8811      	ldrh	r1, [r2, #0]
 801c9ba:	4a08      	ldr	r2, [pc, #32]	; (801c9dc <OP_xor_word+0x34>)
 801c9bc:	6812      	ldr	r2, [r2, #0]
 801c9be:	3a04      	subs	r2, #4
 801c9c0:	8812      	ldrh	r2, [r2, #0]
 801c9c2:	404a      	eors	r2, r1
 801c9c4:	b292      	uxth	r2, r2
 801c9c6:	801a      	strh	r2, [r3, #0]
 801c9c8:	4b04      	ldr	r3, [pc, #16]	; (801c9dc <OP_xor_word+0x34>)
 801c9ca:	681b      	ldr	r3, [r3, #0]
 801c9cc:	3b04      	subs	r3, #4
 801c9ce:	4a03      	ldr	r2, [pc, #12]	; (801c9dc <OP_xor_word+0x34>)
 801c9d0:	6013      	str	r3, [r2, #0]

	return ;
 801c9d2:	bf00      	nop
}
 801c9d4:	46bd      	mov	sp, r7
 801c9d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c9da:	4770      	bx	lr
 801c9dc:	20012af8 	.word	0x20012af8

0801c9e0 <OP_xor_dword>:

void OP_xor_dword()
{
 801c9e0:	b480      	push	{r7}
 801c9e2:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(^);
 801c9e4:	4b0b      	ldr	r3, [pc, #44]	; (801ca14 <OP_xor_dword+0x34>)
 801c9e6:	681b      	ldr	r3, [r3, #0]
 801c9e8:	3b08      	subs	r3, #8
 801c9ea:	4a0a      	ldr	r2, [pc, #40]	; (801ca14 <OP_xor_dword+0x34>)
 801c9ec:	6812      	ldr	r2, [r2, #0]
 801c9ee:	3a08      	subs	r2, #8
 801c9f0:	6811      	ldr	r1, [r2, #0]
 801c9f2:	4a08      	ldr	r2, [pc, #32]	; (801ca14 <OP_xor_dword+0x34>)
 801c9f4:	6812      	ldr	r2, [r2, #0]
 801c9f6:	3a04      	subs	r2, #4
 801c9f8:	6812      	ldr	r2, [r2, #0]
 801c9fa:	404a      	eors	r2, r1
 801c9fc:	601a      	str	r2, [r3, #0]
 801c9fe:	4b05      	ldr	r3, [pc, #20]	; (801ca14 <OP_xor_dword+0x34>)
 801ca00:	681b      	ldr	r3, [r3, #0]
 801ca02:	3b04      	subs	r3, #4
 801ca04:	4a03      	ldr	r2, [pc, #12]	; (801ca14 <OP_xor_dword+0x34>)
 801ca06:	6013      	str	r3, [r2, #0]

	return ;
 801ca08:	bf00      	nop
}
 801ca0a:	46bd      	mov	sp, r7
 801ca0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ca10:	4770      	bx	lr
 801ca12:	bf00      	nop
 801ca14:	20012af8 	.word	0x20012af8

0801ca18 <OP_bw_byte>:

/* --- bw --- */
void OP_bw_byte()
{
 801ca18:	b480      	push	{r7}
 801ca1a:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->char_value = ~ ((finsh_sp - 1)->char_value);
 801ca1c:	4b07      	ldr	r3, [pc, #28]	; (801ca3c <OP_bw_byte+0x24>)
 801ca1e:	681b      	ldr	r3, [r3, #0]
 801ca20:	3b04      	subs	r3, #4
 801ca22:	4a06      	ldr	r2, [pc, #24]	; (801ca3c <OP_bw_byte+0x24>)
 801ca24:	6812      	ldr	r2, [r2, #0]
 801ca26:	3a04      	subs	r2, #4
 801ca28:	7812      	ldrb	r2, [r2, #0]
 801ca2a:	43d2      	mvns	r2, r2
 801ca2c:	b2d2      	uxtb	r2, r2
 801ca2e:	701a      	strb	r2, [r3, #0]

	return ;
 801ca30:	bf00      	nop
}
 801ca32:	46bd      	mov	sp, r7
 801ca34:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ca38:	4770      	bx	lr
 801ca3a:	bf00      	nop
 801ca3c:	20012af8 	.word	0x20012af8

0801ca40 <OP_bw_word>:

void OP_bw_word()
{
 801ca40:	b480      	push	{r7}
 801ca42:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->short_value = ~ ((finsh_sp - 1)->short_value);
 801ca44:	4b07      	ldr	r3, [pc, #28]	; (801ca64 <OP_bw_word+0x24>)
 801ca46:	681b      	ldr	r3, [r3, #0]
 801ca48:	3b04      	subs	r3, #4
 801ca4a:	4a06      	ldr	r2, [pc, #24]	; (801ca64 <OP_bw_word+0x24>)
 801ca4c:	6812      	ldr	r2, [r2, #0]
 801ca4e:	3a04      	subs	r2, #4
 801ca50:	8812      	ldrh	r2, [r2, #0]
 801ca52:	43d2      	mvns	r2, r2
 801ca54:	b292      	uxth	r2, r2
 801ca56:	801a      	strh	r2, [r3, #0]

	return ;
 801ca58:	bf00      	nop
}
 801ca5a:	46bd      	mov	sp, r7
 801ca5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ca60:	4770      	bx	lr
 801ca62:	bf00      	nop
 801ca64:	20012af8 	.word	0x20012af8

0801ca68 <OP_bw_dword>:

void OP_bw_dword()
{
 801ca68:	b480      	push	{r7}
 801ca6a:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->long_value = ~ ((finsh_sp - 1)->long_value);
 801ca6c:	4b06      	ldr	r3, [pc, #24]	; (801ca88 <OP_bw_dword+0x20>)
 801ca6e:	681b      	ldr	r3, [r3, #0]
 801ca70:	3b04      	subs	r3, #4
 801ca72:	4a05      	ldr	r2, [pc, #20]	; (801ca88 <OP_bw_dword+0x20>)
 801ca74:	6812      	ldr	r2, [r2, #0]
 801ca76:	3a04      	subs	r2, #4
 801ca78:	6812      	ldr	r2, [r2, #0]
 801ca7a:	43d2      	mvns	r2, r2
 801ca7c:	601a      	str	r2, [r3, #0]

	return ;
 801ca7e:	bf00      	nop
}
 801ca80:	46bd      	mov	sp, r7
 801ca82:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ca86:	4770      	bx	lr
 801ca88:	20012af8 	.word	0x20012af8

0801ca8c <OP_shl_byte>:

/* --- shl --- */
void OP_shl_byte()
{
 801ca8c:	b480      	push	{r7}
 801ca8e:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(<<);
 801ca90:	4b0c      	ldr	r3, [pc, #48]	; (801cac4 <OP_shl_byte+0x38>)
 801ca92:	681b      	ldr	r3, [r3, #0]
 801ca94:	3b08      	subs	r3, #8
 801ca96:	4a0b      	ldr	r2, [pc, #44]	; (801cac4 <OP_shl_byte+0x38>)
 801ca98:	6812      	ldr	r2, [r2, #0]
 801ca9a:	3a08      	subs	r2, #8
 801ca9c:	7812      	ldrb	r2, [r2, #0]
 801ca9e:	4611      	mov	r1, r2
 801caa0:	4a08      	ldr	r2, [pc, #32]	; (801cac4 <OP_shl_byte+0x38>)
 801caa2:	6812      	ldr	r2, [r2, #0]
 801caa4:	3a04      	subs	r2, #4
 801caa6:	7812      	ldrb	r2, [r2, #0]
 801caa8:	fa01 f202 	lsl.w	r2, r1, r2
 801caac:	b2d2      	uxtb	r2, r2
 801caae:	701a      	strb	r2, [r3, #0]
 801cab0:	4b04      	ldr	r3, [pc, #16]	; (801cac4 <OP_shl_byte+0x38>)
 801cab2:	681b      	ldr	r3, [r3, #0]
 801cab4:	3b04      	subs	r3, #4
 801cab6:	4a03      	ldr	r2, [pc, #12]	; (801cac4 <OP_shl_byte+0x38>)
 801cab8:	6013      	str	r3, [r2, #0]

	return ;
 801caba:	bf00      	nop
}
 801cabc:	46bd      	mov	sp, r7
 801cabe:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cac2:	4770      	bx	lr
 801cac4:	20012af8 	.word	0x20012af8

0801cac8 <OP_shl_word>:

void OP_shl_word()
{
 801cac8:	b480      	push	{r7}
 801caca:	af00      	add	r7, sp, #0
	OP_BIN_WORD(<<);
 801cacc:	4b0d      	ldr	r3, [pc, #52]	; (801cb04 <OP_shl_word+0x3c>)
 801cace:	681b      	ldr	r3, [r3, #0]
 801cad0:	3b08      	subs	r3, #8
 801cad2:	4a0c      	ldr	r2, [pc, #48]	; (801cb04 <OP_shl_word+0x3c>)
 801cad4:	6812      	ldr	r2, [r2, #0]
 801cad6:	3a08      	subs	r2, #8
 801cad8:	8812      	ldrh	r2, [r2, #0]
 801cada:	b211      	sxth	r1, r2
 801cadc:	4a09      	ldr	r2, [pc, #36]	; (801cb04 <OP_shl_word+0x3c>)
 801cade:	6812      	ldr	r2, [r2, #0]
 801cae0:	3a04      	subs	r2, #4
 801cae2:	8812      	ldrh	r2, [r2, #0]
 801cae4:	b212      	sxth	r2, r2
 801cae6:	fa01 f202 	lsl.w	r2, r1, r2
 801caea:	b292      	uxth	r2, r2
 801caec:	801a      	strh	r2, [r3, #0]
 801caee:	4b05      	ldr	r3, [pc, #20]	; (801cb04 <OP_shl_word+0x3c>)
 801caf0:	681b      	ldr	r3, [r3, #0]
 801caf2:	3b04      	subs	r3, #4
 801caf4:	4a03      	ldr	r2, [pc, #12]	; (801cb04 <OP_shl_word+0x3c>)
 801caf6:	6013      	str	r3, [r2, #0]

	return ;
 801caf8:	bf00      	nop
}
 801cafa:	46bd      	mov	sp, r7
 801cafc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cb00:	4770      	bx	lr
 801cb02:	bf00      	nop
 801cb04:	20012af8 	.word	0x20012af8

0801cb08 <OP_shl_dword>:

void OP_shl_dword()
{
 801cb08:	b480      	push	{r7}
 801cb0a:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(<<);
 801cb0c:	4b0b      	ldr	r3, [pc, #44]	; (801cb3c <OP_shl_dword+0x34>)
 801cb0e:	681b      	ldr	r3, [r3, #0]
 801cb10:	3b08      	subs	r3, #8
 801cb12:	4a0a      	ldr	r2, [pc, #40]	; (801cb3c <OP_shl_dword+0x34>)
 801cb14:	6812      	ldr	r2, [r2, #0]
 801cb16:	3a08      	subs	r2, #8
 801cb18:	6811      	ldr	r1, [r2, #0]
 801cb1a:	4a08      	ldr	r2, [pc, #32]	; (801cb3c <OP_shl_dword+0x34>)
 801cb1c:	6812      	ldr	r2, [r2, #0]
 801cb1e:	3a04      	subs	r2, #4
 801cb20:	6812      	ldr	r2, [r2, #0]
 801cb22:	fa01 f202 	lsl.w	r2, r1, r2
 801cb26:	601a      	str	r2, [r3, #0]
 801cb28:	4b04      	ldr	r3, [pc, #16]	; (801cb3c <OP_shl_dword+0x34>)
 801cb2a:	681b      	ldr	r3, [r3, #0]
 801cb2c:	3b04      	subs	r3, #4
 801cb2e:	4a03      	ldr	r2, [pc, #12]	; (801cb3c <OP_shl_dword+0x34>)
 801cb30:	6013      	str	r3, [r2, #0]

	return ;
 801cb32:	bf00      	nop
}
 801cb34:	46bd      	mov	sp, r7
 801cb36:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cb3a:	4770      	bx	lr
 801cb3c:	20012af8 	.word	0x20012af8

0801cb40 <OP_shr_byte>:

/* --- shr --- */
void OP_shr_byte()
{
 801cb40:	b480      	push	{r7}
 801cb42:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(>>);
 801cb44:	4b0c      	ldr	r3, [pc, #48]	; (801cb78 <OP_shr_byte+0x38>)
 801cb46:	681b      	ldr	r3, [r3, #0]
 801cb48:	3b08      	subs	r3, #8
 801cb4a:	4a0b      	ldr	r2, [pc, #44]	; (801cb78 <OP_shr_byte+0x38>)
 801cb4c:	6812      	ldr	r2, [r2, #0]
 801cb4e:	3a08      	subs	r2, #8
 801cb50:	7812      	ldrb	r2, [r2, #0]
 801cb52:	4611      	mov	r1, r2
 801cb54:	4a08      	ldr	r2, [pc, #32]	; (801cb78 <OP_shr_byte+0x38>)
 801cb56:	6812      	ldr	r2, [r2, #0]
 801cb58:	3a04      	subs	r2, #4
 801cb5a:	7812      	ldrb	r2, [r2, #0]
 801cb5c:	fa41 f202 	asr.w	r2, r1, r2
 801cb60:	b2d2      	uxtb	r2, r2
 801cb62:	701a      	strb	r2, [r3, #0]
 801cb64:	4b04      	ldr	r3, [pc, #16]	; (801cb78 <OP_shr_byte+0x38>)
 801cb66:	681b      	ldr	r3, [r3, #0]
 801cb68:	3b04      	subs	r3, #4
 801cb6a:	4a03      	ldr	r2, [pc, #12]	; (801cb78 <OP_shr_byte+0x38>)
 801cb6c:	6013      	str	r3, [r2, #0]

	return ;
 801cb6e:	bf00      	nop
}
 801cb70:	46bd      	mov	sp, r7
 801cb72:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cb76:	4770      	bx	lr
 801cb78:	20012af8 	.word	0x20012af8

0801cb7c <OP_shr_word>:

void OP_shr_word()
{
 801cb7c:	b480      	push	{r7}
 801cb7e:	af00      	add	r7, sp, #0
	OP_BIN_WORD(>>);
 801cb80:	4b0d      	ldr	r3, [pc, #52]	; (801cbb8 <OP_shr_word+0x3c>)
 801cb82:	681b      	ldr	r3, [r3, #0]
 801cb84:	3b08      	subs	r3, #8
 801cb86:	4a0c      	ldr	r2, [pc, #48]	; (801cbb8 <OP_shr_word+0x3c>)
 801cb88:	6812      	ldr	r2, [r2, #0]
 801cb8a:	3a08      	subs	r2, #8
 801cb8c:	8812      	ldrh	r2, [r2, #0]
 801cb8e:	b211      	sxth	r1, r2
 801cb90:	4a09      	ldr	r2, [pc, #36]	; (801cbb8 <OP_shr_word+0x3c>)
 801cb92:	6812      	ldr	r2, [r2, #0]
 801cb94:	3a04      	subs	r2, #4
 801cb96:	8812      	ldrh	r2, [r2, #0]
 801cb98:	b212      	sxth	r2, r2
 801cb9a:	fa41 f202 	asr.w	r2, r1, r2
 801cb9e:	b292      	uxth	r2, r2
 801cba0:	801a      	strh	r2, [r3, #0]
 801cba2:	4b05      	ldr	r3, [pc, #20]	; (801cbb8 <OP_shr_word+0x3c>)
 801cba4:	681b      	ldr	r3, [r3, #0]
 801cba6:	3b04      	subs	r3, #4
 801cba8:	4a03      	ldr	r2, [pc, #12]	; (801cbb8 <OP_shr_word+0x3c>)
 801cbaa:	6013      	str	r3, [r2, #0]

	return ;
 801cbac:	bf00      	nop
}
 801cbae:	46bd      	mov	sp, r7
 801cbb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cbb4:	4770      	bx	lr
 801cbb6:	bf00      	nop
 801cbb8:	20012af8 	.word	0x20012af8

0801cbbc <OP_shr_dword>:

void OP_shr_dword()
{
 801cbbc:	b480      	push	{r7}
 801cbbe:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(>>);
 801cbc0:	4b0b      	ldr	r3, [pc, #44]	; (801cbf0 <OP_shr_dword+0x34>)
 801cbc2:	681b      	ldr	r3, [r3, #0]
 801cbc4:	3b08      	subs	r3, #8
 801cbc6:	4a0a      	ldr	r2, [pc, #40]	; (801cbf0 <OP_shr_dword+0x34>)
 801cbc8:	6812      	ldr	r2, [r2, #0]
 801cbca:	3a08      	subs	r2, #8
 801cbcc:	6811      	ldr	r1, [r2, #0]
 801cbce:	4a08      	ldr	r2, [pc, #32]	; (801cbf0 <OP_shr_dword+0x34>)
 801cbd0:	6812      	ldr	r2, [r2, #0]
 801cbd2:	3a04      	subs	r2, #4
 801cbd4:	6812      	ldr	r2, [r2, #0]
 801cbd6:	fa41 f202 	asr.w	r2, r1, r2
 801cbda:	601a      	str	r2, [r3, #0]
 801cbdc:	4b04      	ldr	r3, [pc, #16]	; (801cbf0 <OP_shr_dword+0x34>)
 801cbde:	681b      	ldr	r3, [r3, #0]
 801cbe0:	3b04      	subs	r3, #4
 801cbe2:	4a03      	ldr	r2, [pc, #12]	; (801cbf0 <OP_shr_dword+0x34>)
 801cbe4:	6013      	str	r3, [r2, #0]

	return ;
 801cbe6:	bf00      	nop
}
 801cbe8:	46bd      	mov	sp, r7
 801cbea:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cbee:	4770      	bx	lr
 801cbf0:	20012af8 	.word	0x20012af8

0801cbf4 <OP_ld_byte>:

/* --- ld --- */
void OP_ld_byte()
{
 801cbf4:	b480      	push	{r7}
 801cbf6:	af00      	add	r7, sp, #0
	finsh_sp->char_value = *finsh_pc;
 801cbf8:	4b0a      	ldr	r3, [pc, #40]	; (801cc24 <OP_ld_byte+0x30>)
 801cbfa:	681b      	ldr	r3, [r3, #0]
 801cbfc:	4a0a      	ldr	r2, [pc, #40]	; (801cc28 <OP_ld_byte+0x34>)
 801cbfe:	6812      	ldr	r2, [r2, #0]
 801cc00:	7812      	ldrb	r2, [r2, #0]
 801cc02:	701a      	strb	r2, [r3, #0]

	finsh_sp++;
 801cc04:	4b07      	ldr	r3, [pc, #28]	; (801cc24 <OP_ld_byte+0x30>)
 801cc06:	681b      	ldr	r3, [r3, #0]
 801cc08:	3304      	adds	r3, #4
 801cc0a:	4a06      	ldr	r2, [pc, #24]	; (801cc24 <OP_ld_byte+0x30>)
 801cc0c:	6013      	str	r3, [r2, #0]
	finsh_pc++;
 801cc0e:	4b06      	ldr	r3, [pc, #24]	; (801cc28 <OP_ld_byte+0x34>)
 801cc10:	681b      	ldr	r3, [r3, #0]
 801cc12:	3301      	adds	r3, #1
 801cc14:	4a04      	ldr	r2, [pc, #16]	; (801cc28 <OP_ld_byte+0x34>)
 801cc16:	6013      	str	r3, [r2, #0]

	return ;
 801cc18:	bf00      	nop
}
 801cc1a:	46bd      	mov	sp, r7
 801cc1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cc20:	4770      	bx	lr
 801cc22:	bf00      	nop
 801cc24:	20012af8 	.word	0x20012af8
 801cc28:	20012af4 	.word	0x20012af4

0801cc2c <OP_ld_word>:

void OP_ld_word()
{
 801cc2c:	b480      	push	{r7}
 801cc2e:	af00      	add	r7, sp, #0
	finsh_sp->short_value = FINSH_GET16(finsh_pc);
 801cc30:	4b0e      	ldr	r3, [pc, #56]	; (801cc6c <OP_ld_word+0x40>)
 801cc32:	681b      	ldr	r3, [r3, #0]
 801cc34:	4a0e      	ldr	r2, [pc, #56]	; (801cc70 <OP_ld_word+0x44>)
 801cc36:	6812      	ldr	r2, [r2, #0]
 801cc38:	7812      	ldrb	r2, [r2, #0]
 801cc3a:	b291      	uxth	r1, r2
 801cc3c:	4a0c      	ldr	r2, [pc, #48]	; (801cc70 <OP_ld_word+0x44>)
 801cc3e:	6812      	ldr	r2, [r2, #0]
 801cc40:	3201      	adds	r2, #1
 801cc42:	7812      	ldrb	r2, [r2, #0]
 801cc44:	0212      	lsls	r2, r2, #8
 801cc46:	b292      	uxth	r2, r2
 801cc48:	430a      	orrs	r2, r1
 801cc4a:	b292      	uxth	r2, r2
 801cc4c:	801a      	strh	r2, [r3, #0]

	finsh_sp ++;
 801cc4e:	4b07      	ldr	r3, [pc, #28]	; (801cc6c <OP_ld_word+0x40>)
 801cc50:	681b      	ldr	r3, [r3, #0]
 801cc52:	3304      	adds	r3, #4
 801cc54:	4a05      	ldr	r2, [pc, #20]	; (801cc6c <OP_ld_word+0x40>)
 801cc56:	6013      	str	r3, [r2, #0]
	finsh_pc += 2;
 801cc58:	4b05      	ldr	r3, [pc, #20]	; (801cc70 <OP_ld_word+0x44>)
 801cc5a:	681b      	ldr	r3, [r3, #0]
 801cc5c:	3302      	adds	r3, #2
 801cc5e:	4a04      	ldr	r2, [pc, #16]	; (801cc70 <OP_ld_word+0x44>)
 801cc60:	6013      	str	r3, [r2, #0]

	return ;
 801cc62:	bf00      	nop
}
 801cc64:	46bd      	mov	sp, r7
 801cc66:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cc6a:	4770      	bx	lr
 801cc6c:	20012af8 	.word	0x20012af8
 801cc70:	20012af4 	.word	0x20012af4

0801cc74 <OP_ld_dword>:

void OP_ld_dword()
{
 801cc74:	b480      	push	{r7}
 801cc76:	af00      	add	r7, sp, #0
	finsh_sp->long_value = FINSH_GET32(finsh_pc);
 801cc78:	4b13      	ldr	r3, [pc, #76]	; (801ccc8 <OP_ld_dword+0x54>)
 801cc7a:	681b      	ldr	r3, [r3, #0]
 801cc7c:	4a13      	ldr	r2, [pc, #76]	; (801cccc <OP_ld_dword+0x58>)
 801cc7e:	6812      	ldr	r2, [r2, #0]
 801cc80:	7812      	ldrb	r2, [r2, #0]
 801cc82:	4611      	mov	r1, r2
 801cc84:	4a11      	ldr	r2, [pc, #68]	; (801cccc <OP_ld_dword+0x58>)
 801cc86:	6812      	ldr	r2, [r2, #0]
 801cc88:	3201      	adds	r2, #1
 801cc8a:	7812      	ldrb	r2, [r2, #0]
 801cc8c:	0212      	lsls	r2, r2, #8
 801cc8e:	4311      	orrs	r1, r2
 801cc90:	4a0e      	ldr	r2, [pc, #56]	; (801cccc <OP_ld_dword+0x58>)
 801cc92:	6812      	ldr	r2, [r2, #0]
 801cc94:	3202      	adds	r2, #2
 801cc96:	7812      	ldrb	r2, [r2, #0]
 801cc98:	0412      	lsls	r2, r2, #16
 801cc9a:	4311      	orrs	r1, r2
 801cc9c:	4a0b      	ldr	r2, [pc, #44]	; (801cccc <OP_ld_dword+0x58>)
 801cc9e:	6812      	ldr	r2, [r2, #0]
 801cca0:	3203      	adds	r2, #3
 801cca2:	7812      	ldrb	r2, [r2, #0]
 801cca4:	0612      	lsls	r2, r2, #24
 801cca6:	430a      	orrs	r2, r1
 801cca8:	601a      	str	r2, [r3, #0]

	finsh_sp ++;
 801ccaa:	4b07      	ldr	r3, [pc, #28]	; (801ccc8 <OP_ld_dword+0x54>)
 801ccac:	681b      	ldr	r3, [r3, #0]
 801ccae:	3304      	adds	r3, #4
 801ccb0:	4a05      	ldr	r2, [pc, #20]	; (801ccc8 <OP_ld_dword+0x54>)
 801ccb2:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 801ccb4:	4b05      	ldr	r3, [pc, #20]	; (801cccc <OP_ld_dword+0x58>)
 801ccb6:	681b      	ldr	r3, [r3, #0]
 801ccb8:	3304      	adds	r3, #4
 801ccba:	4a04      	ldr	r2, [pc, #16]	; (801cccc <OP_ld_dword+0x58>)
 801ccbc:	6013      	str	r3, [r2, #0]

	return ;
 801ccbe:	bf00      	nop
}
 801ccc0:	46bd      	mov	sp, r7
 801ccc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ccc6:	4770      	bx	lr
 801ccc8:	20012af8 	.word	0x20012af8
 801cccc:	20012af4 	.word	0x20012af4

0801ccd0 <OP_ld_value_byte>:

void OP_ld_value_byte()
{
 801ccd0:	b480      	push	{r7}
 801ccd2:	b083      	sub	sp, #12
 801ccd4:	af00      	add	r7, sp, #0
	char* c;

	c = (char*) (FINSH_GET32(finsh_pc));
 801ccd6:	4b16      	ldr	r3, [pc, #88]	; (801cd30 <OP_ld_value_byte+0x60>)
 801ccd8:	681b      	ldr	r3, [r3, #0]
 801ccda:	781b      	ldrb	r3, [r3, #0]
 801ccdc:	461a      	mov	r2, r3
 801ccde:	4b14      	ldr	r3, [pc, #80]	; (801cd30 <OP_ld_value_byte+0x60>)
 801cce0:	681b      	ldr	r3, [r3, #0]
 801cce2:	3301      	adds	r3, #1
 801cce4:	781b      	ldrb	r3, [r3, #0]
 801cce6:	021b      	lsls	r3, r3, #8
 801cce8:	431a      	orrs	r2, r3
 801ccea:	4b11      	ldr	r3, [pc, #68]	; (801cd30 <OP_ld_value_byte+0x60>)
 801ccec:	681b      	ldr	r3, [r3, #0]
 801ccee:	3302      	adds	r3, #2
 801ccf0:	781b      	ldrb	r3, [r3, #0]
 801ccf2:	041b      	lsls	r3, r3, #16
 801ccf4:	431a      	orrs	r2, r3
 801ccf6:	4b0e      	ldr	r3, [pc, #56]	; (801cd30 <OP_ld_value_byte+0x60>)
 801ccf8:	681b      	ldr	r3, [r3, #0]
 801ccfa:	3303      	adds	r3, #3
 801ccfc:	781b      	ldrb	r3, [r3, #0]
 801ccfe:	061b      	lsls	r3, r3, #24
 801cd00:	4313      	orrs	r3, r2
 801cd02:	607b      	str	r3, [r7, #4]

	finsh_sp->char_value = *c;
 801cd04:	4b0b      	ldr	r3, [pc, #44]	; (801cd34 <OP_ld_value_byte+0x64>)
 801cd06:	681b      	ldr	r3, [r3, #0]
 801cd08:	687a      	ldr	r2, [r7, #4]
 801cd0a:	7812      	ldrb	r2, [r2, #0]
 801cd0c:	701a      	strb	r2, [r3, #0]

	finsh_sp ++;
 801cd0e:	4b09      	ldr	r3, [pc, #36]	; (801cd34 <OP_ld_value_byte+0x64>)
 801cd10:	681b      	ldr	r3, [r3, #0]
 801cd12:	3304      	adds	r3, #4
 801cd14:	4a07      	ldr	r2, [pc, #28]	; (801cd34 <OP_ld_value_byte+0x64>)
 801cd16:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 801cd18:	4b05      	ldr	r3, [pc, #20]	; (801cd30 <OP_ld_value_byte+0x60>)
 801cd1a:	681b      	ldr	r3, [r3, #0]
 801cd1c:	3304      	adds	r3, #4
 801cd1e:	4a04      	ldr	r2, [pc, #16]	; (801cd30 <OP_ld_value_byte+0x60>)
 801cd20:	6013      	str	r3, [r2, #0]

	return;
 801cd22:	bf00      	nop
}
 801cd24:	370c      	adds	r7, #12
 801cd26:	46bd      	mov	sp, r7
 801cd28:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cd2c:	4770      	bx	lr
 801cd2e:	bf00      	nop
 801cd30:	20012af4 	.word	0x20012af4
 801cd34:	20012af8 	.word	0x20012af8

0801cd38 <OP_ld_value_byte_stack>:

void OP_ld_value_byte_stack()
{
 801cd38:	b480      	push	{r7}
 801cd3a:	b083      	sub	sp, #12
 801cd3c:	af00      	add	r7, sp, #0
	char* c;

	c = (char *)(finsh_sp - 1)->long_value;
 801cd3e:	4b08      	ldr	r3, [pc, #32]	; (801cd60 <OP_ld_value_byte_stack+0x28>)
 801cd40:	681b      	ldr	r3, [r3, #0]
 801cd42:	3b04      	subs	r3, #4
 801cd44:	681b      	ldr	r3, [r3, #0]
 801cd46:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->char_value = *c;
 801cd48:	4b05      	ldr	r3, [pc, #20]	; (801cd60 <OP_ld_value_byte_stack+0x28>)
 801cd4a:	681b      	ldr	r3, [r3, #0]
 801cd4c:	3b04      	subs	r3, #4
 801cd4e:	687a      	ldr	r2, [r7, #4]
 801cd50:	7812      	ldrb	r2, [r2, #0]
 801cd52:	701a      	strb	r2, [r3, #0]

	return;
 801cd54:	bf00      	nop
}
 801cd56:	370c      	adds	r7, #12
 801cd58:	46bd      	mov	sp, r7
 801cd5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cd5e:	4770      	bx	lr
 801cd60:	20012af8 	.word	0x20012af8

0801cd64 <OP_ld_value_word>:

void OP_ld_value_word()
{
 801cd64:	b480      	push	{r7}
 801cd66:	b083      	sub	sp, #12
 801cd68:	af00      	add	r7, sp, #0
	short* s;

	s = (short*) (FINSH_GET32(finsh_pc));
 801cd6a:	4b16      	ldr	r3, [pc, #88]	; (801cdc4 <OP_ld_value_word+0x60>)
 801cd6c:	681b      	ldr	r3, [r3, #0]
 801cd6e:	781b      	ldrb	r3, [r3, #0]
 801cd70:	461a      	mov	r2, r3
 801cd72:	4b14      	ldr	r3, [pc, #80]	; (801cdc4 <OP_ld_value_word+0x60>)
 801cd74:	681b      	ldr	r3, [r3, #0]
 801cd76:	3301      	adds	r3, #1
 801cd78:	781b      	ldrb	r3, [r3, #0]
 801cd7a:	021b      	lsls	r3, r3, #8
 801cd7c:	431a      	orrs	r2, r3
 801cd7e:	4b11      	ldr	r3, [pc, #68]	; (801cdc4 <OP_ld_value_word+0x60>)
 801cd80:	681b      	ldr	r3, [r3, #0]
 801cd82:	3302      	adds	r3, #2
 801cd84:	781b      	ldrb	r3, [r3, #0]
 801cd86:	041b      	lsls	r3, r3, #16
 801cd88:	431a      	orrs	r2, r3
 801cd8a:	4b0e      	ldr	r3, [pc, #56]	; (801cdc4 <OP_ld_value_word+0x60>)
 801cd8c:	681b      	ldr	r3, [r3, #0]
 801cd8e:	3303      	adds	r3, #3
 801cd90:	781b      	ldrb	r3, [r3, #0]
 801cd92:	061b      	lsls	r3, r3, #24
 801cd94:	4313      	orrs	r3, r2
 801cd96:	607b      	str	r3, [r7, #4]

	finsh_sp->short_value = *s;
 801cd98:	4b0b      	ldr	r3, [pc, #44]	; (801cdc8 <OP_ld_value_word+0x64>)
 801cd9a:	681b      	ldr	r3, [r3, #0]
 801cd9c:	687a      	ldr	r2, [r7, #4]
 801cd9e:	8812      	ldrh	r2, [r2, #0]
 801cda0:	801a      	strh	r2, [r3, #0]

	finsh_sp ++;
 801cda2:	4b09      	ldr	r3, [pc, #36]	; (801cdc8 <OP_ld_value_word+0x64>)
 801cda4:	681b      	ldr	r3, [r3, #0]
 801cda6:	3304      	adds	r3, #4
 801cda8:	4a07      	ldr	r2, [pc, #28]	; (801cdc8 <OP_ld_value_word+0x64>)
 801cdaa:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 801cdac:	4b05      	ldr	r3, [pc, #20]	; (801cdc4 <OP_ld_value_word+0x60>)
 801cdae:	681b      	ldr	r3, [r3, #0]
 801cdb0:	3304      	adds	r3, #4
 801cdb2:	4a04      	ldr	r2, [pc, #16]	; (801cdc4 <OP_ld_value_word+0x60>)
 801cdb4:	6013      	str	r3, [r2, #0]

	return;
 801cdb6:	bf00      	nop
}
 801cdb8:	370c      	adds	r7, #12
 801cdba:	46bd      	mov	sp, r7
 801cdbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cdc0:	4770      	bx	lr
 801cdc2:	bf00      	nop
 801cdc4:	20012af4 	.word	0x20012af4
 801cdc8:	20012af8 	.word	0x20012af8

0801cdcc <OP_ld_value_word_stack>:

void OP_ld_value_word_stack()
{
 801cdcc:	b480      	push	{r7}
 801cdce:	b083      	sub	sp, #12
 801cdd0:	af00      	add	r7, sp, #0
	short* s;

	s = (short *)(finsh_sp - 1)->long_value;
 801cdd2:	4b08      	ldr	r3, [pc, #32]	; (801cdf4 <OP_ld_value_word_stack+0x28>)
 801cdd4:	681b      	ldr	r3, [r3, #0]
 801cdd6:	3b04      	subs	r3, #4
 801cdd8:	681b      	ldr	r3, [r3, #0]
 801cdda:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->short_value = *s;
 801cddc:	4b05      	ldr	r3, [pc, #20]	; (801cdf4 <OP_ld_value_word_stack+0x28>)
 801cdde:	681b      	ldr	r3, [r3, #0]
 801cde0:	3b04      	subs	r3, #4
 801cde2:	687a      	ldr	r2, [r7, #4]
 801cde4:	8812      	ldrh	r2, [r2, #0]
 801cde6:	801a      	strh	r2, [r3, #0]

	return;
 801cde8:	bf00      	nop
}
 801cdea:	370c      	adds	r7, #12
 801cdec:	46bd      	mov	sp, r7
 801cdee:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cdf2:	4770      	bx	lr
 801cdf4:	20012af8 	.word	0x20012af8

0801cdf8 <OP_ld_value_dword>:

void OP_ld_value_dword()
{
 801cdf8:	b480      	push	{r7}
 801cdfa:	b083      	sub	sp, #12
 801cdfc:	af00      	add	r7, sp, #0
	long* l;

	l = (long*) (FINSH_GET32(finsh_pc));
 801cdfe:	4b16      	ldr	r3, [pc, #88]	; (801ce58 <OP_ld_value_dword+0x60>)
 801ce00:	681b      	ldr	r3, [r3, #0]
 801ce02:	781b      	ldrb	r3, [r3, #0]
 801ce04:	461a      	mov	r2, r3
 801ce06:	4b14      	ldr	r3, [pc, #80]	; (801ce58 <OP_ld_value_dword+0x60>)
 801ce08:	681b      	ldr	r3, [r3, #0]
 801ce0a:	3301      	adds	r3, #1
 801ce0c:	781b      	ldrb	r3, [r3, #0]
 801ce0e:	021b      	lsls	r3, r3, #8
 801ce10:	431a      	orrs	r2, r3
 801ce12:	4b11      	ldr	r3, [pc, #68]	; (801ce58 <OP_ld_value_dword+0x60>)
 801ce14:	681b      	ldr	r3, [r3, #0]
 801ce16:	3302      	adds	r3, #2
 801ce18:	781b      	ldrb	r3, [r3, #0]
 801ce1a:	041b      	lsls	r3, r3, #16
 801ce1c:	431a      	orrs	r2, r3
 801ce1e:	4b0e      	ldr	r3, [pc, #56]	; (801ce58 <OP_ld_value_dword+0x60>)
 801ce20:	681b      	ldr	r3, [r3, #0]
 801ce22:	3303      	adds	r3, #3
 801ce24:	781b      	ldrb	r3, [r3, #0]
 801ce26:	061b      	lsls	r3, r3, #24
 801ce28:	4313      	orrs	r3, r2
 801ce2a:	607b      	str	r3, [r7, #4]

	finsh_sp->long_value = *l;
 801ce2c:	4b0b      	ldr	r3, [pc, #44]	; (801ce5c <OP_ld_value_dword+0x64>)
 801ce2e:	681b      	ldr	r3, [r3, #0]
 801ce30:	687a      	ldr	r2, [r7, #4]
 801ce32:	6812      	ldr	r2, [r2, #0]
 801ce34:	601a      	str	r2, [r3, #0]

	finsh_sp ++;
 801ce36:	4b09      	ldr	r3, [pc, #36]	; (801ce5c <OP_ld_value_dword+0x64>)
 801ce38:	681b      	ldr	r3, [r3, #0]
 801ce3a:	3304      	adds	r3, #4
 801ce3c:	4a07      	ldr	r2, [pc, #28]	; (801ce5c <OP_ld_value_dword+0x64>)
 801ce3e:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 801ce40:	4b05      	ldr	r3, [pc, #20]	; (801ce58 <OP_ld_value_dword+0x60>)
 801ce42:	681b      	ldr	r3, [r3, #0]
 801ce44:	3304      	adds	r3, #4
 801ce46:	4a04      	ldr	r2, [pc, #16]	; (801ce58 <OP_ld_value_dword+0x60>)
 801ce48:	6013      	str	r3, [r2, #0]

	return;
 801ce4a:	bf00      	nop
}
 801ce4c:	370c      	adds	r7, #12
 801ce4e:	46bd      	mov	sp, r7
 801ce50:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ce54:	4770      	bx	lr
 801ce56:	bf00      	nop
 801ce58:	20012af4 	.word	0x20012af4
 801ce5c:	20012af8 	.word	0x20012af8

0801ce60 <OP_ld_value_dword_stack>:

void OP_ld_value_dword_stack()
{
 801ce60:	b480      	push	{r7}
 801ce62:	b083      	sub	sp, #12
 801ce64:	af00      	add	r7, sp, #0
	long* l;

	l = (long *)(finsh_sp - 1)->long_value;
 801ce66:	4b08      	ldr	r3, [pc, #32]	; (801ce88 <OP_ld_value_dword_stack+0x28>)
 801ce68:	681b      	ldr	r3, [r3, #0]
 801ce6a:	3b04      	subs	r3, #4
 801ce6c:	681b      	ldr	r3, [r3, #0]
 801ce6e:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->long_value = *l;
 801ce70:	4b05      	ldr	r3, [pc, #20]	; (801ce88 <OP_ld_value_dword_stack+0x28>)
 801ce72:	681b      	ldr	r3, [r3, #0]
 801ce74:	3b04      	subs	r3, #4
 801ce76:	687a      	ldr	r2, [r7, #4]
 801ce78:	6812      	ldr	r2, [r2, #0]
 801ce7a:	601a      	str	r2, [r3, #0]

	return;
 801ce7c:	bf00      	nop
}
 801ce7e:	370c      	adds	r7, #12
 801ce80:	46bd      	mov	sp, r7
 801ce82:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ce86:	4770      	bx	lr
 801ce88:	20012af8 	.word	0x20012af8

0801ce8c <OP_st_byte>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_byte()
{
 801ce8c:	b480      	push	{r7}
 801ce8e:	af00      	add	r7, sp, #0
	*(char*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->char_value;
 801ce90:	4b09      	ldr	r3, [pc, #36]	; (801ceb8 <OP_st_byte+0x2c>)
 801ce92:	681b      	ldr	r3, [r3, #0]
 801ce94:	3b08      	subs	r3, #8
 801ce96:	681b      	ldr	r3, [r3, #0]
 801ce98:	461a      	mov	r2, r3
 801ce9a:	4b07      	ldr	r3, [pc, #28]	; (801ceb8 <OP_st_byte+0x2c>)
 801ce9c:	681b      	ldr	r3, [r3, #0]
 801ce9e:	3b04      	subs	r3, #4
 801cea0:	781b      	ldrb	r3, [r3, #0]
 801cea2:	7013      	strb	r3, [r2, #0]
	finsh_sp --;
 801cea4:	4b04      	ldr	r3, [pc, #16]	; (801ceb8 <OP_st_byte+0x2c>)
 801cea6:	681b      	ldr	r3, [r3, #0]
 801cea8:	3b04      	subs	r3, #4
 801ceaa:	4a03      	ldr	r2, [pc, #12]	; (801ceb8 <OP_st_byte+0x2c>)
 801ceac:	6013      	str	r3, [r2, #0]

	return ;
 801ceae:	bf00      	nop
}
 801ceb0:	46bd      	mov	sp, r7
 801ceb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ceb6:	4770      	bx	lr
 801ceb8:	20012af8 	.word	0x20012af8

0801cebc <OP_st_word>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_word()
{
 801cebc:	b480      	push	{r7}
 801cebe:	af00      	add	r7, sp, #0
	*(short*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->short_value;
 801cec0:	4b09      	ldr	r3, [pc, #36]	; (801cee8 <OP_st_word+0x2c>)
 801cec2:	681b      	ldr	r3, [r3, #0]
 801cec4:	3b08      	subs	r3, #8
 801cec6:	681b      	ldr	r3, [r3, #0]
 801cec8:	461a      	mov	r2, r3
 801ceca:	4b07      	ldr	r3, [pc, #28]	; (801cee8 <OP_st_word+0x2c>)
 801cecc:	681b      	ldr	r3, [r3, #0]
 801cece:	3b04      	subs	r3, #4
 801ced0:	881b      	ldrh	r3, [r3, #0]
 801ced2:	8013      	strh	r3, [r2, #0]
	finsh_sp --;
 801ced4:	4b04      	ldr	r3, [pc, #16]	; (801cee8 <OP_st_word+0x2c>)
 801ced6:	681b      	ldr	r3, [r3, #0]
 801ced8:	3b04      	subs	r3, #4
 801ceda:	4a03      	ldr	r2, [pc, #12]	; (801cee8 <OP_st_word+0x2c>)
 801cedc:	6013      	str	r3, [r2, #0]

	return ;
 801cede:	bf00      	nop
}
 801cee0:	46bd      	mov	sp, r7
 801cee2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cee6:	4770      	bx	lr
 801cee8:	20012af8 	.word	0x20012af8

0801ceec <OP_st_dword>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_dword()
{
 801ceec:	b480      	push	{r7}
 801ceee:	af00      	add	r7, sp, #0
	*(long*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->long_value;
 801cef0:	4b09      	ldr	r3, [pc, #36]	; (801cf18 <OP_st_dword+0x2c>)
 801cef2:	681b      	ldr	r3, [r3, #0]
 801cef4:	3b08      	subs	r3, #8
 801cef6:	681b      	ldr	r3, [r3, #0]
 801cef8:	461a      	mov	r2, r3
 801cefa:	4b07      	ldr	r3, [pc, #28]	; (801cf18 <OP_st_dword+0x2c>)
 801cefc:	681b      	ldr	r3, [r3, #0]
 801cefe:	3b04      	subs	r3, #4
 801cf00:	681b      	ldr	r3, [r3, #0]
 801cf02:	6013      	str	r3, [r2, #0]
	finsh_sp --;
 801cf04:	4b04      	ldr	r3, [pc, #16]	; (801cf18 <OP_st_dword+0x2c>)
 801cf06:	681b      	ldr	r3, [r3, #0]
 801cf08:	3b04      	subs	r3, #4
 801cf0a:	4a03      	ldr	r2, [pc, #12]	; (801cf18 <OP_st_dword+0x2c>)
 801cf0c:	6013      	str	r3, [r2, #0]

	return ;
 801cf0e:	bf00      	nop
}
 801cf10:	46bd      	mov	sp, r7
 801cf12:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cf16:	4770      	bx	lr
 801cf18:	20012af8 	.word	0x20012af8

0801cf1c <OP_pop>:

/* --- pop --- */
void OP_pop()
{
 801cf1c:	b480      	push	{r7}
 801cf1e:	af00      	add	r7, sp, #0
	finsh_sp --;
 801cf20:	4b04      	ldr	r3, [pc, #16]	; (801cf34 <OP_pop+0x18>)
 801cf22:	681b      	ldr	r3, [r3, #0]
 801cf24:	3b04      	subs	r3, #4
 801cf26:	4a03      	ldr	r2, [pc, #12]	; (801cf34 <OP_pop+0x18>)
 801cf28:	6013      	str	r3, [r2, #0]
	return ;
 801cf2a:	bf00      	nop
}
 801cf2c:	46bd      	mov	sp, r7
 801cf2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cf32:	4770      	bx	lr
 801cf34:	20012af8 	.word	0x20012af8

0801cf38 <OP_call>:

/* --- call --- */
void OP_call()
{
 801cf38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801cf3c:	b0a5      	sub	sp, #148	; 0x94
 801cf3e:	af0c      	add	r7, sp, #48	; 0x30
	typedef unsigned long var_t;
	typedef var_t (*op_func)();
	op_func f;
	var_t   r;

	parameters = *finsh_pc ++;
 801cf40:	4b95      	ldr	r3, [pc, #596]	; (801d198 <OP_call+0x260>)
 801cf42:	681b      	ldr	r3, [r3, #0]
 801cf44:	1c5a      	adds	r2, r3, #1
 801cf46:	4994      	ldr	r1, [pc, #592]	; (801d198 <OP_call+0x260>)
 801cf48:	600a      	str	r2, [r1, #0]
 801cf4a:	781b      	ldrb	r3, [r3, #0]
 801cf4c:	657b      	str	r3, [r7, #84]	; 0x54

	i = 0; finsh_sp --;
 801cf4e:	2300      	movs	r3, #0
 801cf50:	65fb      	str	r3, [r7, #92]	; 0x5c
 801cf52:	4b92      	ldr	r3, [pc, #584]	; (801d19c <OP_call+0x264>)
 801cf54:	681b      	ldr	r3, [r3, #0]
 801cf56:	3b04      	subs	r3, #4
 801cf58:	4a90      	ldr	r2, [pc, #576]	; (801d19c <OP_call+0x264>)
 801cf5a:	6013      	str	r3, [r2, #0]
	while (i < parameters)
 801cf5c:	e014      	b.n	801cf88 <OP_call+0x50>
	{
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
 801cf5e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cf60:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801cf62:	1ad3      	subs	r3, r2, r3
 801cf64:	3b01      	subs	r3, #1
 801cf66:	4a8d      	ldr	r2, [pc, #564]	; (801d19c <OP_call+0x264>)
 801cf68:	6812      	ldr	r2, [r2, #0]
 801cf6a:	6812      	ldr	r2, [r2, #0]
 801cf6c:	009b      	lsls	r3, r3, #2
 801cf6e:	f107 0160 	add.w	r1, r7, #96	; 0x60
 801cf72:	440b      	add	r3, r1
 801cf74:	f843 2c50 	str.w	r2, [r3, #-80]
		finsh_sp --;
 801cf78:	4b88      	ldr	r3, [pc, #544]	; (801d19c <OP_call+0x264>)
 801cf7a:	681b      	ldr	r3, [r3, #0]
 801cf7c:	3b04      	subs	r3, #4
 801cf7e:	4a87      	ldr	r2, [pc, #540]	; (801d19c <OP_call+0x264>)
 801cf80:	6013      	str	r3, [r2, #0]
		i++;
 801cf82:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801cf84:	3301      	adds	r3, #1
 801cf86:	65fb      	str	r3, [r7, #92]	; 0x5c
	var_t   r;

	parameters = *finsh_pc ++;

	i = 0; finsh_sp --;
	while (i < parameters)
 801cf88:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801cf8a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801cf8c:	429a      	cmp	r2, r3
 801cf8e:	d3e6      	bcc.n	801cf5e <OP_call+0x26>
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
		finsh_sp --;
		i++;
	}

	f = (op_func)(finsh_sp->long_value);
 801cf90:	4b82      	ldr	r3, [pc, #520]	; (801d19c <OP_call+0x264>)
 801cf92:	681b      	ldr	r3, [r3, #0]
 801cf94:	681b      	ldr	r3, [r3, #0]
 801cf96:	653b      	str	r3, [r7, #80]	; 0x50
	switch (parameters)
 801cf98:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801cf9a:	2b10      	cmp	r3, #16
 801cf9c:	f200 81b0 	bhi.w	801d300 <OP_call+0x3c8>
 801cfa0:	a201      	add	r2, pc, #4	; (adr r2, 801cfa8 <OP_call+0x70>)
 801cfa2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801cfa6:	bf00      	nop
 801cfa8:	0801cfed 	.word	0x0801cfed
 801cfac:	0801cff7 	.word	0x0801cff7
 801cfb0:	0801d003 	.word	0x0801d003
 801cfb4:	0801d013 	.word	0x0801d013
 801cfb8:	0801d021 	.word	0x0801d021
 801cfbc:	0801d031 	.word	0x0801d031
 801cfc0:	0801d047 	.word	0x0801d047
 801cfc4:	0801d063 	.word	0x0801d063
 801cfc8:	0801d087 	.word	0x0801d087
 801cfcc:	0801d0b3 	.word	0x0801d0b3
 801cfd0:	0801d0e3 	.word	0x0801d0e3
 801cfd4:	0801d119 	.word	0x0801d119
 801cfd8:	0801d155 	.word	0x0801d155
 801cfdc:	0801d1a1 	.word	0x0801d1a1
 801cfe0:	0801d1ed 	.word	0x0801d1ed
 801cfe4:	0801d241 	.word	0x0801d241
 801cfe8:	0801d29d 	.word	0x0801d29d
	{
	case 0:
		r = f(0);
 801cfec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801cfee:	2000      	movs	r0, #0
 801cff0:	4798      	blx	r3
 801cff2:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 801cff4:	e187      	b.n	801d306 <OP_call+0x3ce>

	case 1:
		r = f(parameterv[0]);
 801cff6:	693a      	ldr	r2, [r7, #16]
 801cff8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801cffa:	4610      	mov	r0, r2
 801cffc:	4798      	blx	r3
 801cffe:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 801d000:	e181      	b.n	801d306 <OP_call+0x3ce>

	case 2:
		r = f(parameterv[0], parameterv[1]);
 801d002:	6939      	ldr	r1, [r7, #16]
 801d004:	697a      	ldr	r2, [r7, #20]
 801d006:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801d008:	4608      	mov	r0, r1
 801d00a:	4611      	mov	r1, r2
 801d00c:	4798      	blx	r3
 801d00e:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 801d010:	e179      	b.n	801d306 <OP_call+0x3ce>

	case 3:
		r = f(parameterv[0], parameterv[1], parameterv[2]);
 801d012:	6938      	ldr	r0, [r7, #16]
 801d014:	6979      	ldr	r1, [r7, #20]
 801d016:	69ba      	ldr	r2, [r7, #24]
 801d018:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801d01a:	4798      	blx	r3
 801d01c:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 801d01e:	e172      	b.n	801d306 <OP_call+0x3ce>

	case 4:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3]);
 801d020:	6938      	ldr	r0, [r7, #16]
 801d022:	6979      	ldr	r1, [r7, #20]
 801d024:	69ba      	ldr	r2, [r7, #24]
 801d026:	69fb      	ldr	r3, [r7, #28]
 801d028:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d02a:	47a0      	blx	r4
 801d02c:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 801d02e:	e16a      	b.n	801d306 <OP_call+0x3ce>

	case 5:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d030:	6938      	ldr	r0, [r7, #16]
 801d032:	6979      	ldr	r1, [r7, #20]
 801d034:	69ba      	ldr	r2, [r7, #24]
 801d036:	69fd      	ldr	r5, [r7, #28]
 801d038:	6a3b      	ldr	r3, [r7, #32]
 801d03a:	9300      	str	r3, [sp, #0]
 801d03c:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d03e:	462b      	mov	r3, r5
 801d040:	47a0      	blx	r4
 801d042:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4]);
		break;
 801d044:	e15f      	b.n	801d306 <OP_call+0x3ce>

	case 6:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d046:	6938      	ldr	r0, [r7, #16]
 801d048:	6979      	ldr	r1, [r7, #20]
 801d04a:	69be      	ldr	r6, [r7, #24]
 801d04c:	69fd      	ldr	r5, [r7, #28]
 801d04e:	6a3a      	ldr	r2, [r7, #32]
 801d050:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d052:	9200      	str	r2, [sp, #0]
 801d054:	9301      	str	r3, [sp, #4]
 801d056:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d058:	4632      	mov	r2, r6
 801d05a:	462b      	mov	r3, r5
 801d05c:	47a0      	blx	r4
 801d05e:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5]);
		break;
 801d060:	e151      	b.n	801d306 <OP_call+0x3ce>

	case 7:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d062:	6938      	ldr	r0, [r7, #16]
 801d064:	f8d7 e014 	ldr.w	lr, [r7, #20]
 801d068:	69be      	ldr	r6, [r7, #24]
 801d06a:	69fd      	ldr	r5, [r7, #28]
 801d06c:	6a39      	ldr	r1, [r7, #32]
 801d06e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801d070:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d072:	9100      	str	r1, [sp, #0]
 801d074:	9201      	str	r2, [sp, #4]
 801d076:	9302      	str	r3, [sp, #8]
 801d078:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d07a:	4671      	mov	r1, lr
 801d07c:	4632      	mov	r2, r6
 801d07e:	462b      	mov	r3, r5
 801d080:	47a0      	blx	r4
 801d082:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6]);
		break;
 801d084:	e13f      	b.n	801d306 <OP_call+0x3ce>

	case 8:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d086:	f8d7 c010 	ldr.w	ip, [r7, #16]
 801d08a:	f8d7 e014 	ldr.w	lr, [r7, #20]
 801d08e:	69be      	ldr	r6, [r7, #24]
 801d090:	69fd      	ldr	r5, [r7, #28]
 801d092:	6a38      	ldr	r0, [r7, #32]
 801d094:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801d096:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801d098:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d09a:	9000      	str	r0, [sp, #0]
 801d09c:	9101      	str	r1, [sp, #4]
 801d09e:	9202      	str	r2, [sp, #8]
 801d0a0:	9303      	str	r3, [sp, #12]
 801d0a2:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d0a4:	4660      	mov	r0, ip
 801d0a6:	4671      	mov	r1, lr
 801d0a8:	4632      	mov	r2, r6
 801d0aa:	462b      	mov	r3, r5
 801d0ac:	47a0      	blx	r4
 801d0ae:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7]);
		break;
 801d0b0:	e129      	b.n	801d306 <OP_call+0x3ce>

	case 9:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d0b2:	f8d7 c010 	ldr.w	ip, [r7, #16]
 801d0b6:	f8d7 e014 	ldr.w	lr, [r7, #20]
 801d0ba:	69be      	ldr	r6, [r7, #24]
 801d0bc:	69fd      	ldr	r5, [r7, #28]
 801d0be:	6a3c      	ldr	r4, [r7, #32]
 801d0c0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801d0c2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801d0c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d0c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d0c8:	9400      	str	r4, [sp, #0]
 801d0ca:	9001      	str	r0, [sp, #4]
 801d0cc:	9102      	str	r1, [sp, #8]
 801d0ce:	9203      	str	r2, [sp, #12]
 801d0d0:	9304      	str	r3, [sp, #16]
 801d0d2:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d0d4:	4660      	mov	r0, ip
 801d0d6:	4671      	mov	r1, lr
 801d0d8:	4632      	mov	r2, r6
 801d0da:	462b      	mov	r3, r5
 801d0dc:	47a0      	blx	r4
 801d0de:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8]);
		break;
 801d0e0:	e111      	b.n	801d306 <OP_call+0x3ce>

	case 10:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d0e2:	f8d7 8010 	ldr.w	r8, [r7, #16]
 801d0e6:	f8d7 c014 	ldr.w	ip, [r7, #20]
 801d0ea:	f8d7 e018 	ldr.w	lr, [r7, #24]
 801d0ee:	69fe      	ldr	r6, [r7, #28]
 801d0f0:	6a3d      	ldr	r5, [r7, #32]
 801d0f2:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 801d0f4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801d0f6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801d0f8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801d0fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d0fc:	9500      	str	r5, [sp, #0]
 801d0fe:	9401      	str	r4, [sp, #4]
 801d100:	9002      	str	r0, [sp, #8]
 801d102:	9103      	str	r1, [sp, #12]
 801d104:	9204      	str	r2, [sp, #16]
 801d106:	9305      	str	r3, [sp, #20]
 801d108:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d10a:	4640      	mov	r0, r8
 801d10c:	4661      	mov	r1, ip
 801d10e:	4672      	mov	r2, lr
 801d110:	4633      	mov	r3, r6
 801d112:	47a0      	blx	r4
 801d114:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9]);
		break;
 801d116:	e0f6      	b.n	801d306 <OP_call+0x3ce>

	case 11:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d118:	f8d7 9010 	ldr.w	r9, [r7, #16]
 801d11c:	f8d7 8014 	ldr.w	r8, [r7, #20]
 801d120:	f8d7 c018 	ldr.w	ip, [r7, #24]
 801d124:	f8d7 e01c 	ldr.w	lr, [r7, #28]
 801d128:	6a3e      	ldr	r6, [r7, #32]
 801d12a:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 801d12c:	6abc      	ldr	r4, [r7, #40]	; 0x28
 801d12e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801d130:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801d132:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801d134:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d136:	9600      	str	r6, [sp, #0]
 801d138:	9501      	str	r5, [sp, #4]
 801d13a:	9402      	str	r4, [sp, #8]
 801d13c:	9003      	str	r0, [sp, #12]
 801d13e:	9104      	str	r1, [sp, #16]
 801d140:	9205      	str	r2, [sp, #20]
 801d142:	9306      	str	r3, [sp, #24]
 801d144:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d146:	4648      	mov	r0, r9
 801d148:	4641      	mov	r1, r8
 801d14a:	4662      	mov	r2, ip
 801d14c:	4673      	mov	r3, lr
 801d14e:	47a0      	blx	r4
 801d150:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10]);
		break;
 801d152:	e0d8      	b.n	801d306 <OP_call+0x3ce>

	case 12:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d154:	f8d7 a010 	ldr.w	sl, [r7, #16]
 801d158:	f8d7 9014 	ldr.w	r9, [r7, #20]
 801d15c:	f8d7 8018 	ldr.w	r8, [r7, #24]
 801d160:	f8d7 c01c 	ldr.w	ip, [r7, #28]
 801d164:	f8d7 e020 	ldr.w	lr, [r7, #32]
 801d168:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 801d16a:	6abd      	ldr	r5, [r7, #40]	; 0x28
 801d16c:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 801d16e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801d170:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801d172:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801d174:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801d176:	f8cd e000 	str.w	lr, [sp]
 801d17a:	9601      	str	r6, [sp, #4]
 801d17c:	9502      	str	r5, [sp, #8]
 801d17e:	9403      	str	r4, [sp, #12]
 801d180:	9004      	str	r0, [sp, #16]
 801d182:	9105      	str	r1, [sp, #20]
 801d184:	9206      	str	r2, [sp, #24]
 801d186:	9307      	str	r3, [sp, #28]
 801d188:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d18a:	4650      	mov	r0, sl
 801d18c:	4649      	mov	r1, r9
 801d18e:	4642      	mov	r2, r8
 801d190:	4663      	mov	r3, ip
 801d192:	47a0      	blx	r4
 801d194:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11]);
		break;
 801d196:	e0b6      	b.n	801d306 <OP_call+0x3ce>
 801d198:	20012af4 	.word	0x20012af4
 801d19c:	20012af8 	.word	0x20012af8

	case 13:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d1a0:	f8d7 b010 	ldr.w	fp, [r7, #16]
 801d1a4:	f8d7 a014 	ldr.w	sl, [r7, #20]
 801d1a8:	f8d7 9018 	ldr.w	r9, [r7, #24]
 801d1ac:	f8d7 801c 	ldr.w	r8, [r7, #28]
 801d1b0:	f8d7 c020 	ldr.w	ip, [r7, #32]
 801d1b4:	f8d7 e024 	ldr.w	lr, [r7, #36]	; 0x24
 801d1b8:	6abe      	ldr	r6, [r7, #40]	; 0x28
 801d1ba:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 801d1bc:	6b3c      	ldr	r4, [r7, #48]	; 0x30
 801d1be:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801d1c0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801d1c2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801d1c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d1c6:	f8cd c000 	str.w	ip, [sp]
 801d1ca:	f8cd e004 	str.w	lr, [sp, #4]
 801d1ce:	9602      	str	r6, [sp, #8]
 801d1d0:	9503      	str	r5, [sp, #12]
 801d1d2:	9404      	str	r4, [sp, #16]
 801d1d4:	9005      	str	r0, [sp, #20]
 801d1d6:	9106      	str	r1, [sp, #24]
 801d1d8:	9207      	str	r2, [sp, #28]
 801d1da:	9308      	str	r3, [sp, #32]
 801d1dc:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d1de:	4658      	mov	r0, fp
 801d1e0:	4651      	mov	r1, sl
 801d1e2:	464a      	mov	r2, r9
 801d1e4:	4643      	mov	r3, r8
 801d1e6:	47a0      	blx	r4
 801d1e8:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12]);
		break;
 801d1ea:	e08c      	b.n	801d306 <OP_call+0x3ce>

	case 14:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d1ec:	693b      	ldr	r3, [r7, #16]
 801d1ee:	60fb      	str	r3, [r7, #12]
 801d1f0:	f8d7 b014 	ldr.w	fp, [r7, #20]
 801d1f4:	f8d7 a018 	ldr.w	sl, [r7, #24]
 801d1f8:	f8d7 901c 	ldr.w	r9, [r7, #28]
 801d1fc:	f8d7 8020 	ldr.w	r8, [r7, #32]
 801d200:	f8d7 c024 	ldr.w	ip, [r7, #36]	; 0x24
 801d204:	f8d7 e028 	ldr.w	lr, [r7, #40]	; 0x28
 801d208:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 801d20a:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 801d20c:	6b7c      	ldr	r4, [r7, #52]	; 0x34
 801d20e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 801d210:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801d212:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801d214:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d216:	f8cd 8000 	str.w	r8, [sp]
 801d21a:	f8cd c004 	str.w	ip, [sp, #4]
 801d21e:	f8cd e008 	str.w	lr, [sp, #8]
 801d222:	9603      	str	r6, [sp, #12]
 801d224:	9504      	str	r5, [sp, #16]
 801d226:	9405      	str	r4, [sp, #20]
 801d228:	9006      	str	r0, [sp, #24]
 801d22a:	9107      	str	r1, [sp, #28]
 801d22c:	9208      	str	r2, [sp, #32]
 801d22e:	9309      	str	r3, [sp, #36]	; 0x24
 801d230:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d232:	68f8      	ldr	r0, [r7, #12]
 801d234:	4659      	mov	r1, fp
 801d236:	4652      	mov	r2, sl
 801d238:	464b      	mov	r3, r9
 801d23a:	47a0      	blx	r4
 801d23c:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13]);
		break;
 801d23e:	e062      	b.n	801d306 <OP_call+0x3ce>

	case 15:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d240:	693b      	ldr	r3, [r7, #16]
 801d242:	60fb      	str	r3, [r7, #12]
 801d244:	697a      	ldr	r2, [r7, #20]
 801d246:	60ba      	str	r2, [r7, #8]
 801d248:	f8d7 b018 	ldr.w	fp, [r7, #24]
 801d24c:	f8d7 a01c 	ldr.w	sl, [r7, #28]
 801d250:	6a3a      	ldr	r2, [r7, #32]
 801d252:	f8d7 9024 	ldr.w	r9, [r7, #36]	; 0x24
 801d256:	f8d7 8028 	ldr.w	r8, [r7, #40]	; 0x28
 801d25a:	f8d7 c02c 	ldr.w	ip, [r7, #44]	; 0x2c
 801d25e:	f8d7 e030 	ldr.w	lr, [r7, #48]	; 0x30
 801d262:	6b7e      	ldr	r6, [r7, #52]	; 0x34
 801d264:	6bbd      	ldr	r5, [r7, #56]	; 0x38
 801d266:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
 801d268:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801d26a:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801d26c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d26e:	9200      	str	r2, [sp, #0]
 801d270:	f8cd 9004 	str.w	r9, [sp, #4]
 801d274:	f8cd 8008 	str.w	r8, [sp, #8]
 801d278:	f8cd c00c 	str.w	ip, [sp, #12]
 801d27c:	f8cd e010 	str.w	lr, [sp, #16]
 801d280:	9605      	str	r6, [sp, #20]
 801d282:	9506      	str	r5, [sp, #24]
 801d284:	9407      	str	r4, [sp, #28]
 801d286:	9008      	str	r0, [sp, #32]
 801d288:	9109      	str	r1, [sp, #36]	; 0x24
 801d28a:	930a      	str	r3, [sp, #40]	; 0x28
 801d28c:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d28e:	68f8      	ldr	r0, [r7, #12]
 801d290:	68b9      	ldr	r1, [r7, #8]
 801d292:	465a      	mov	r2, fp
 801d294:	4653      	mov	r3, sl
 801d296:	47a0      	blx	r4
 801d298:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14]);
		break;
 801d29a:	e034      	b.n	801d306 <OP_call+0x3ce>

	case 16:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 801d29c:	693b      	ldr	r3, [r7, #16]
 801d29e:	60fb      	str	r3, [r7, #12]
 801d2a0:	697a      	ldr	r2, [r7, #20]
 801d2a2:	60ba      	str	r2, [r7, #8]
 801d2a4:	69bc      	ldr	r4, [r7, #24]
 801d2a6:	607c      	str	r4, [r7, #4]
 801d2a8:	f8d7 b01c 	ldr.w	fp, [r7, #28]
 801d2ac:	6a3a      	ldr	r2, [r7, #32]
 801d2ae:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801d2b0:	f8d7 a028 	ldr.w	sl, [r7, #40]	; 0x28
 801d2b4:	f8d7 902c 	ldr.w	r9, [r7, #44]	; 0x2c
 801d2b8:	f8d7 8030 	ldr.w	r8, [r7, #48]	; 0x30
 801d2bc:	f8d7 c034 	ldr.w	ip, [r7, #52]	; 0x34
 801d2c0:	f8d7 e038 	ldr.w	lr, [r7, #56]	; 0x38
 801d2c4:	6bfe      	ldr	r6, [r7, #60]	; 0x3c
 801d2c6:	6c3d      	ldr	r5, [r7, #64]	; 0x40
 801d2c8:	6c7c      	ldr	r4, [r7, #68]	; 0x44
 801d2ca:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801d2cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d2ce:	9200      	str	r2, [sp, #0]
 801d2d0:	9001      	str	r0, [sp, #4]
 801d2d2:	f8cd a008 	str.w	sl, [sp, #8]
 801d2d6:	f8cd 900c 	str.w	r9, [sp, #12]
 801d2da:	f8cd 8010 	str.w	r8, [sp, #16]
 801d2de:	f8cd c014 	str.w	ip, [sp, #20]
 801d2e2:	f8cd e018 	str.w	lr, [sp, #24]
 801d2e6:	9607      	str	r6, [sp, #28]
 801d2e8:	9508      	str	r5, [sp, #32]
 801d2ea:	9409      	str	r4, [sp, #36]	; 0x24
 801d2ec:	910a      	str	r1, [sp, #40]	; 0x28
 801d2ee:	930b      	str	r3, [sp, #44]	; 0x2c
 801d2f0:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 801d2f2:	68f8      	ldr	r0, [r7, #12]
 801d2f4:	68b9      	ldr	r1, [r7, #8]
 801d2f6:	687a      	ldr	r2, [r7, #4]
 801d2f8:	465b      	mov	r3, fp
 801d2fa:	47a0      	blx	r4
 801d2fc:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14], parameterv[15]);
		break;
 801d2fe:	e002      	b.n	801d306 <OP_call+0x3ce>

	default:
		r = 0;
 801d300:	2300      	movs	r3, #0
 801d302:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801d304:	bf00      	nop
	}

	finsh_sp->long_value = r;
 801d306:	4b07      	ldr	r3, [pc, #28]	; (801d324 <OP_call+0x3ec>)
 801d308:	681b      	ldr	r3, [r3, #0]
 801d30a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801d30c:	601a      	str	r2, [r3, #0]
	finsh_sp ++;
 801d30e:	4b05      	ldr	r3, [pc, #20]	; (801d324 <OP_call+0x3ec>)
 801d310:	681b      	ldr	r3, [r3, #0]
 801d312:	3304      	adds	r3, #4
 801d314:	4a03      	ldr	r2, [pc, #12]	; (801d324 <OP_call+0x3ec>)
 801d316:	6013      	str	r3, [r2, #0]

	return ;
 801d318:	bf00      	nop
}
 801d31a:	3764      	adds	r7, #100	; 0x64
 801d31c:	46bd      	mov	sp, r7
 801d31e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d322:	bf00      	nop
 801d324:	20012af8 	.word	0x20012af8

0801d328 <proc_variable_decl>:
	| declarator
declarator -> identifier
	| identifier ASSIGN expr_assign
*/
static struct finsh_node* proc_variable_decl(struct finsh_parser* self)
{
 801d328:	b580      	push	{r7, lr}
 801d32a:	b090      	sub	sp, #64	; 0x40
 801d32c:	af00      	add	r7, sp, #0
 801d32e:	6078      	str	r0, [r7, #4]

	struct finsh_node *node;
	struct finsh_node *end;
	struct finsh_node *assign;

    node = NULL;
 801d330:	2300      	movs	r3, #0
 801d332:	63bb      	str	r3, [r7, #56]	; 0x38
	end  = NULL;
 801d334:	2300      	movs	r3, #0
 801d336:	637b      	str	r3, [r7, #52]	; 0x34

	/* get type */
	type = proc_type(self);
 801d338:	6878      	ldr	r0, [r7, #4]
 801d33a:	f000 f955 	bl	801d5e8 <proc_type>
 801d33e:	4603      	mov	r3, r0
 801d340:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

	/*process id.*/
	if (proc_identifier(self, id) == 0)
 801d344:	f107 030c 	add.w	r3, r7, #12
 801d348:	6878      	ldr	r0, [r7, #4]
 801d34a:	4619      	mov	r1, r3
 801d34c:	f000 fa1a 	bl	801d784 <proc_identifier>
 801d350:	4603      	mov	r3, r0
 801d352:	2b00      	cmp	r3, #0
 801d354:	d10d      	bne.n	801d372 <proc_variable_decl+0x4a>
	{
		/* if add variable failed */
		if (finsh_var_insert(id, type) < 0)
 801d356:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801d35a:	f107 020c 	add.w	r2, r7, #12
 801d35e:	4610      	mov	r0, r2
 801d360:	4619      	mov	r1, r3
 801d362:	f000 fefd 	bl	801e160 <finsh_var_insert>
 801d366:	4603      	mov	r3, r0
 801d368:	2b00      	cmp	r3, #0
 801d36a:	da02      	bge.n	801d372 <proc_variable_decl+0x4a>
		{
			finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 801d36c:	2004      	movs	r0, #4
 801d36e:	f7fe fd25 	bl	801bdbc <finsh_error_set>
		}
	}

	next_token(token, &(self->token));
 801d372:	687b      	ldr	r3, [r7, #4]
 801d374:	3304      	adds	r3, #4
 801d376:	4618      	mov	r0, r3
 801d378:	f001 f844 	bl	801e404 <finsh_token_token>
 801d37c:	4603      	mov	r3, r0
 801d37e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	switch ( token )
 801d382:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d386:	2b04      	cmp	r3, #4
 801d388:	f000 8123 	beq.w	801d5d2 <proc_variable_decl+0x2aa>
 801d38c:	2b0c      	cmp	r3, #12
 801d38e:	f000 80a3 	beq.w	801d4d8 <proc_variable_decl+0x1b0>
 801d392:	2b03      	cmp	r3, #3
 801d394:	f040 811f 	bne.w	801d5d6 <proc_variable_decl+0x2ae>
	{
	case finsh_token_type_comma:/*',', it's a variable_list declaration.*/
		if (proc_identifier(self, id) == 0)
 801d398:	f107 030c 	add.w	r3, r7, #12
 801d39c:	6878      	ldr	r0, [r7, #4]
 801d39e:	4619      	mov	r1, r3
 801d3a0:	f000 f9f0 	bl	801d784 <proc_identifier>
 801d3a4:	4603      	mov	r3, r0
 801d3a6:	2b00      	cmp	r3, #0
 801d3a8:	d10d      	bne.n	801d3c6 <proc_variable_decl+0x9e>
		{
			/* if add variable failed */
			if (finsh_var_insert(id, type) < 0)
 801d3aa:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801d3ae:	f107 020c 	add.w	r2, r7, #12
 801d3b2:	4610      	mov	r0, r2
 801d3b4:	4619      	mov	r1, r3
 801d3b6:	f000 fed3 	bl	801e160 <finsh_var_insert>
 801d3ba:	4603      	mov	r3, r0
 801d3bc:	2b00      	cmp	r3, #0
 801d3be:	da02      	bge.n	801d3c6 <proc_variable_decl+0x9e>
			{
				finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 801d3c0:	2004      	movs	r0, #4
 801d3c2:	f7fe fcfb 	bl	801bdbc <finsh_error_set>
			}
		}

		next_token(token, &(self->token));
 801d3c6:	687b      	ldr	r3, [r7, #4]
 801d3c8:	3304      	adds	r3, #4
 801d3ca:	4618      	mov	r0, r3
 801d3cc:	f001 f81a 	bl	801e404 <finsh_token_token>
 801d3d0:	4603      	mov	r3, r0
 801d3d2:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
		if ( token == finsh_token_type_assign )
 801d3d6:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d3da:	2b0c      	cmp	r3, #12
 801d3dc:	d11c      	bne.n	801d418 <proc_variable_decl+0xf0>
		{
			/* get the right side of assign expression */
			assign = proc_assign_expr(self);
 801d3de:	6878      	ldr	r0, [r7, #4]
 801d3e0:	f000 fa2a 	bl	801d838 <proc_assign_expr>
 801d3e4:	62f8      	str	r0, [r7, #44]	; 0x2c

			if (assign != NULL)
 801d3e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d3e8:	2b00      	cmp	r3, #0
 801d3ea:	d015      	beq.n	801d418 <proc_variable_decl+0xf0>
			{
				struct finsh_node* idnode;

				idnode = finsh_node_new_id(id);
 801d3ec:	f107 030c 	add.w	r3, r7, #12
 801d3f0:	4618      	mov	r0, r3
 801d3f2:	f7fe ff57 	bl	801c2a4 <finsh_node_new_id>
 801d3f6:	62b8      	str	r0, [r7, #40]	; 0x28
				end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 801d3f8:	2013      	movs	r0, #19
 801d3fa:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801d3fc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d3fe:	f000 fdc5 	bl	801df8c <make_sys_node>
 801d402:	6378      	str	r0, [r7, #52]	; 0x34
				node = end;
 801d404:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d406:	63bb      	str	r3, [r7, #56]	; 0x38

				next_token(token, &(self->token));
 801d408:	687b      	ldr	r3, [r7, #4]
 801d40a:	3304      	adds	r3, #4
 801d40c:	4618      	mov	r0, r3
 801d40e:	f000 fff9 	bl	801e404 <finsh_token_token>
 801d412:	4603      	mov	r3, r0
 801d414:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			}
		}

		while ( token == finsh_token_type_comma )
 801d418:	e04e      	b.n	801d4b8 <proc_variable_decl+0x190>
		{
			if (proc_identifier(self, id) == 0)
 801d41a:	f107 030c 	add.w	r3, r7, #12
 801d41e:	6878      	ldr	r0, [r7, #4]
 801d420:	4619      	mov	r1, r3
 801d422:	f000 f9af 	bl	801d784 <proc_identifier>
 801d426:	4603      	mov	r3, r0
 801d428:	2b00      	cmp	r3, #0
 801d42a:	d10d      	bne.n	801d448 <proc_variable_decl+0x120>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
 801d42c:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801d430:	f107 020c 	add.w	r2, r7, #12
 801d434:	4610      	mov	r0, r2
 801d436:	4619      	mov	r1, r3
 801d438:	f000 fe92 	bl	801e160 <finsh_var_insert>
 801d43c:	4603      	mov	r3, r0
 801d43e:	2b00      	cmp	r3, #0
 801d440:	da02      	bge.n	801d448 <proc_variable_decl+0x120>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 801d442:	2004      	movs	r0, #4
 801d444:	f7fe fcba 	bl	801bdbc <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
 801d448:	687b      	ldr	r3, [r7, #4]
 801d44a:	3304      	adds	r3, #4
 801d44c:	4618      	mov	r0, r3
 801d44e:	f000 ffd9 	bl	801e404 <finsh_token_token>
 801d452:	4603      	mov	r3, r0
 801d454:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			if ( token == finsh_token_type_assign )
 801d458:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d45c:	2b0c      	cmp	r3, #12
 801d45e:	d12b      	bne.n	801d4b8 <proc_variable_decl+0x190>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
 801d460:	6878      	ldr	r0, [r7, #4]
 801d462:	f000 f9e9 	bl	801d838 <proc_assign_expr>
 801d466:	62f8      	str	r0, [r7, #44]	; 0x2c

				if (assign != NULL)
 801d468:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d46a:	2b00      	cmp	r3, #0
 801d46c:	d024      	beq.n	801d4b8 <proc_variable_decl+0x190>
				{
					struct finsh_node* idnode;

					idnode = finsh_node_new_id(id);
 801d46e:	f107 030c 	add.w	r3, r7, #12
 801d472:	4618      	mov	r0, r3
 801d474:	f7fe ff16 	bl	801c2a4 <finsh_node_new_id>
 801d478:	6278      	str	r0, [r7, #36]	; 0x24

					/* make assign expression node */
					if (node != NULL)
 801d47a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d47c:	2b00      	cmp	r3, #0
 801d47e:	d00b      	beq.n	801d498 <proc_variable_decl+0x170>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 801d480:	2013      	movs	r0, #19
 801d482:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801d484:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d486:	f000 fd81 	bl	801df8c <make_sys_node>
 801d48a:	4602      	mov	r2, r0
 801d48c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d48e:	60da      	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
 801d490:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d492:	68db      	ldr	r3, [r3, #12]
 801d494:	637b      	str	r3, [r7, #52]	; 0x34
 801d496:	e007      	b.n	801d4a8 <proc_variable_decl+0x180>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 801d498:	2013      	movs	r0, #19
 801d49a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801d49c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d49e:	f000 fd75 	bl	801df8c <make_sys_node>
 801d4a2:	6378      	str	r0, [r7, #52]	; 0x34
						node = end;
 801d4a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d4a6:	63bb      	str	r3, [r7, #56]	; 0x38
					}

					next_token(token, &(self->token));
 801d4a8:	687b      	ldr	r3, [r7, #4]
 801d4aa:	3304      	adds	r3, #4
 801d4ac:	4618      	mov	r0, r3
 801d4ae:	f000 ffa9 	bl	801e404 <finsh_token_token>
 801d4b2:	4603      	mov	r3, r0
 801d4b4:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

				next_token(token, &(self->token));
			}
		}

		while ( token == finsh_token_type_comma )
 801d4b8:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d4bc:	2b03      	cmp	r3, #3
 801d4be:	d0ac      	beq.n	801d41a <proc_variable_decl+0xf2>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
 801d4c0:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d4c4:	2b04      	cmp	r3, #4
 801d4c6:	d005      	beq.n	801d4d4 <proc_variable_decl+0x1ac>
 801d4c8:	2001      	movs	r0, #1
 801d4ca:	f7fe fc77 	bl	801bdbc <finsh_error_set>
 801d4ce:	687b      	ldr	r3, [r7, #4]
 801d4d0:	2201      	movs	r2, #1
 801d4d2:	715a      	strb	r2, [r3, #5]
		return node;
 801d4d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d4d6:	e082      	b.n	801d5de <proc_variable_decl+0x2b6>

	case finsh_token_type_assign:/*'=', it's a variable with assign declaration.*/
	{
		struct finsh_node *idnode;

		assign = proc_assign_expr(self);
 801d4d8:	6878      	ldr	r0, [r7, #4]
 801d4da:	f000 f9ad 	bl	801d838 <proc_assign_expr>
 801d4de:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (assign != NULL)
 801d4e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d4e2:	2b00      	cmp	r3, #0
 801d4e4:	d015      	beq.n	801d512 <proc_variable_decl+0x1ea>
		{
			idnode = finsh_node_new_id(id);
 801d4e6:	f107 030c 	add.w	r3, r7, #12
 801d4ea:	4618      	mov	r0, r3
 801d4ec:	f7fe feda 	bl	801c2a4 <finsh_node_new_id>
 801d4f0:	6238      	str	r0, [r7, #32]

			/* make assign expression node */
			end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 801d4f2:	2013      	movs	r0, #19
 801d4f4:	6a39      	ldr	r1, [r7, #32]
 801d4f6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d4f8:	f000 fd48 	bl	801df8c <make_sys_node>
 801d4fc:	6378      	str	r0, [r7, #52]	; 0x34
			node = end;
 801d4fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d500:	63bb      	str	r3, [r7, #56]	; 0x38

			next_token(token, &(self->token));
 801d502:	687b      	ldr	r3, [r7, #4]
 801d504:	3304      	adds	r3, #4
 801d506:	4618      	mov	r0, r3
 801d508:	f000 ff7c 	bl	801e404 <finsh_token_token>
 801d50c:	4603      	mov	r3, r0
 801d50e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
		}

		while ( token == finsh_token_type_comma )
 801d512:	e04e      	b.n	801d5b2 <proc_variable_decl+0x28a>
		{
			if (proc_identifier(self, id) == 0)
 801d514:	f107 030c 	add.w	r3, r7, #12
 801d518:	6878      	ldr	r0, [r7, #4]
 801d51a:	4619      	mov	r1, r3
 801d51c:	f000 f932 	bl	801d784 <proc_identifier>
 801d520:	4603      	mov	r3, r0
 801d522:	2b00      	cmp	r3, #0
 801d524:	d10d      	bne.n	801d542 <proc_variable_decl+0x21a>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
 801d526:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801d52a:	f107 020c 	add.w	r2, r7, #12
 801d52e:	4610      	mov	r0, r2
 801d530:	4619      	mov	r1, r3
 801d532:	f000 fe15 	bl	801e160 <finsh_var_insert>
 801d536:	4603      	mov	r3, r0
 801d538:	2b00      	cmp	r3, #0
 801d53a:	da02      	bge.n	801d542 <proc_variable_decl+0x21a>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 801d53c:	2004      	movs	r0, #4
 801d53e:	f7fe fc3d 	bl	801bdbc <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
 801d542:	687b      	ldr	r3, [r7, #4]
 801d544:	3304      	adds	r3, #4
 801d546:	4618      	mov	r0, r3
 801d548:	f000 ff5c 	bl	801e404 <finsh_token_token>
 801d54c:	4603      	mov	r3, r0
 801d54e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			if (token == finsh_token_type_assign)
 801d552:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d556:	2b0c      	cmp	r3, #12
 801d558:	d12b      	bne.n	801d5b2 <proc_variable_decl+0x28a>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
 801d55a:	6878      	ldr	r0, [r7, #4]
 801d55c:	f000 f96c 	bl	801d838 <proc_assign_expr>
 801d560:	62f8      	str	r0, [r7, #44]	; 0x2c

				if (assign != NULL)
 801d562:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d564:	2b00      	cmp	r3, #0
 801d566:	d024      	beq.n	801d5b2 <proc_variable_decl+0x28a>
				{
					idnode = finsh_node_new_id(id);
 801d568:	f107 030c 	add.w	r3, r7, #12
 801d56c:	4618      	mov	r0, r3
 801d56e:	f7fe fe99 	bl	801c2a4 <finsh_node_new_id>
 801d572:	6238      	str	r0, [r7, #32]

					/* make assign expression node */
					if (node != NULL)
 801d574:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d576:	2b00      	cmp	r3, #0
 801d578:	d00b      	beq.n	801d592 <proc_variable_decl+0x26a>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 801d57a:	2013      	movs	r0, #19
 801d57c:	6a39      	ldr	r1, [r7, #32]
 801d57e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d580:	f000 fd04 	bl	801df8c <make_sys_node>
 801d584:	4602      	mov	r2, r0
 801d586:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d588:	60da      	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
 801d58a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d58c:	68db      	ldr	r3, [r3, #12]
 801d58e:	637b      	str	r3, [r7, #52]	; 0x34
 801d590:	e007      	b.n	801d5a2 <proc_variable_decl+0x27a>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 801d592:	2013      	movs	r0, #19
 801d594:	6a39      	ldr	r1, [r7, #32]
 801d596:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d598:	f000 fcf8 	bl	801df8c <make_sys_node>
 801d59c:	6378      	str	r0, [r7, #52]	; 0x34
						node = end;
 801d59e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d5a0:	63bb      	str	r3, [r7, #56]	; 0x38
					}

					next_token(token, &(self->token));
 801d5a2:	687b      	ldr	r3, [r7, #4]
 801d5a4:	3304      	adds	r3, #4
 801d5a6:	4618      	mov	r0, r3
 801d5a8:	f000 ff2c 	bl	801e404 <finsh_token_token>
 801d5ac:	4603      	mov	r3, r0
 801d5ae:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			node = end;

			next_token(token, &(self->token));
		}

		while ( token == finsh_token_type_comma )
 801d5b2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d5b6:	2b03      	cmp	r3, #3
 801d5b8:	d0ac      	beq.n	801d514 <proc_variable_decl+0x1ec>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
 801d5ba:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d5be:	2b04      	cmp	r3, #4
 801d5c0:	d005      	beq.n	801d5ce <proc_variable_decl+0x2a6>
 801d5c2:	2001      	movs	r0, #1
 801d5c4:	f7fe fbfa 	bl	801bdbc <finsh_error_set>
 801d5c8:	687b      	ldr	r3, [r7, #4]
 801d5ca:	2201      	movs	r2, #1
 801d5cc:	715a      	strb	r2, [r3, #5]
		return node;
 801d5ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d5d0:	e005      	b.n	801d5de <proc_variable_decl+0x2b6>
	}

	case finsh_token_type_semicolon:/*';', it's a variable declaration.*/
		return node;
 801d5d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d5d4:	e003      	b.n	801d5de <proc_variable_decl+0x2b6>

	default:
		finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
 801d5d6:	2002      	movs	r0, #2
 801d5d8:	f7fe fbf0 	bl	801bdbc <finsh_error_set>

		return NULL;
 801d5dc:	2300      	movs	r3, #0
	}
}
 801d5de:	4618      	mov	r0, r3
 801d5e0:	3740      	adds	r7, #64	; 0x40
 801d5e2:	46bd      	mov	sp, r7
 801d5e4:	bd80      	pop	{r7, pc}
 801d5e6:	bf00      	nop

0801d5e8 <proc_type>:
	| SHORT
	| INT
	| STRING
*/
static enum finsh_type proc_type(struct finsh_parser* self)
{
 801d5e8:	b580      	push	{r7, lr}
 801d5ea:	b084      	sub	sp, #16
 801d5ec:	af00      	add	r7, sp, #0
 801d5ee:	6078      	str	r0, [r7, #4]
	enum finsh_type type;
	enum finsh_token_type token;

	/* set init type */
	type = finsh_type_unknown;
 801d5f0:	2300      	movs	r3, #0
 801d5f2:	73fb      	strb	r3, [r7, #15]

	next_token(token, &(self->token));
 801d5f4:	687b      	ldr	r3, [r7, #4]
 801d5f6:	3304      	adds	r3, #4
 801d5f8:	4618      	mov	r0, r3
 801d5fa:	f000 ff03 	bl	801e404 <finsh_token_token>
 801d5fe:	4603      	mov	r3, r0
 801d600:	73bb      	strb	r3, [r7, #14]
	if ( is_base_type(token) ) /* base_type */
 801d602:	7bbb      	ldrb	r3, [r7, #14]
 801d604:	2b14      	cmp	r3, #20
 801d606:	d00b      	beq.n	801d620 <proc_type+0x38>
 801d608:	7bbb      	ldrb	r3, [r7, #14]
 801d60a:	2b15      	cmp	r3, #21
 801d60c:	d008      	beq.n	801d620 <proc_type+0x38>
 801d60e:	7bbb      	ldrb	r3, [r7, #14]
 801d610:	2b16      	cmp	r3, #22
 801d612:	d005      	beq.n	801d620 <proc_type+0x38>
 801d614:	7bbb      	ldrb	r3, [r7, #14]
 801d616:	2b17      	cmp	r3, #23
 801d618:	d002      	beq.n	801d620 <proc_type+0x38>
 801d61a:	7bbb      	ldrb	r3, [r7, #14]
 801d61c:	2b18      	cmp	r3, #24
 801d61e:	d121      	bne.n	801d664 <proc_type+0x7c>
	{
		switch (token)
 801d620:	7bbb      	ldrb	r3, [r7, #14]
 801d622:	3b14      	subs	r3, #20
 801d624:	2b04      	cmp	r3, #4
 801d626:	f200 809f 	bhi.w	801d768 <proc_type+0x180>
 801d62a:	a201      	add	r2, pc, #4	; (adr r2, 801d630 <proc_type+0x48>)
 801d62c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d630:	0801d645 	.word	0x0801d645
 801d634:	0801d64b 	.word	0x0801d64b
 801d638:	0801d651 	.word	0x0801d651
 801d63c:	0801d657 	.word	0x0801d657
 801d640:	0801d65d 	.word	0x0801d65d
		{
		case finsh_token_type_void:
			type = finsh_type_void;
 801d644:	2301      	movs	r3, #1
 801d646:	73fb      	strb	r3, [r7, #15]
			break;
 801d648:	e00b      	b.n	801d662 <proc_type+0x7a>

		case finsh_token_type_char:
			type = finsh_type_char;
 801d64a:	2303      	movs	r3, #3
 801d64c:	73fb      	strb	r3, [r7, #15]
			break;
 801d64e:	e008      	b.n	801d662 <proc_type+0x7a>

		case finsh_token_type_short:
			type = finsh_type_short;
 801d650:	2306      	movs	r3, #6
 801d652:	73fb      	strb	r3, [r7, #15]
			break;
 801d654:	e005      	b.n	801d662 <proc_type+0x7a>

		case finsh_token_type_int:
			type = finsh_type_int;
 801d656:	2309      	movs	r3, #9
 801d658:	73fb      	strb	r3, [r7, #15]
			break;
 801d65a:	e002      	b.n	801d662 <proc_type+0x7a>

		case finsh_token_type_long:
			type = finsh_type_long;
 801d65c:	230c      	movs	r3, #12
 801d65e:	73fb      	strb	r3, [r7, #15]
			break;
 801d660:	bf00      	nop

		default:
			goto __return;
		}
	}
 801d662:	e03d      	b.n	801d6e0 <proc_type+0xf8>
	else if ( token == finsh_token_type_unsigned ) /* unsigned base_type */
 801d664:	7bbb      	ldrb	r3, [r7, #14]
 801d666:	2b19      	cmp	r3, #25
 801d668:	d139      	bne.n	801d6de <proc_type+0xf6>
	{
		next_token(token, &(self->token));
 801d66a:	687b      	ldr	r3, [r7, #4]
 801d66c:	3304      	adds	r3, #4
 801d66e:	4618      	mov	r0, r3
 801d670:	f000 fec8 	bl	801e404 <finsh_token_token>
 801d674:	4603      	mov	r3, r0
 801d676:	73bb      	strb	r3, [r7, #14]
		if ( is_base_type(token) )
 801d678:	7bbb      	ldrb	r3, [r7, #14]
 801d67a:	2b14      	cmp	r3, #20
 801d67c:	d00b      	beq.n	801d696 <proc_type+0xae>
 801d67e:	7bbb      	ldrb	r3, [r7, #14]
 801d680:	2b15      	cmp	r3, #21
 801d682:	d008      	beq.n	801d696 <proc_type+0xae>
 801d684:	7bbb      	ldrb	r3, [r7, #14]
 801d686:	2b16      	cmp	r3, #22
 801d688:	d005      	beq.n	801d696 <proc_type+0xae>
 801d68a:	7bbb      	ldrb	r3, [r7, #14]
 801d68c:	2b17      	cmp	r3, #23
 801d68e:	d002      	beq.n	801d696 <proc_type+0xae>
 801d690:	7bbb      	ldrb	r3, [r7, #14]
 801d692:	2b18      	cmp	r3, #24
 801d694:	d11c      	bne.n	801d6d0 <proc_type+0xe8>
		{
			switch (token)
 801d696:	7bbb      	ldrb	r3, [r7, #14]
 801d698:	3b15      	subs	r3, #21
 801d69a:	2b03      	cmp	r3, #3
 801d69c:	d866      	bhi.n	801d76c <proc_type+0x184>
 801d69e:	a201      	add	r2, pc, #4	; (adr r2, 801d6a4 <proc_type+0xbc>)
 801d6a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d6a4:	0801d6b5 	.word	0x0801d6b5
 801d6a8:	0801d6bb 	.word	0x0801d6bb
 801d6ac:	0801d6c1 	.word	0x0801d6c1
 801d6b0:	0801d6c7 	.word	0x0801d6c7
			{
			case finsh_token_type_char:
				type = finsh_type_uchar;
 801d6b4:	2304      	movs	r3, #4
 801d6b6:	73fb      	strb	r3, [r7, #15]
				break;
 801d6b8:	e008      	b.n	801d6cc <proc_type+0xe4>

			case finsh_token_type_short:
				type = finsh_type_ushort;
 801d6ba:	2307      	movs	r3, #7
 801d6bc:	73fb      	strb	r3, [r7, #15]
				break;
 801d6be:	e005      	b.n	801d6cc <proc_type+0xe4>

			case finsh_token_type_int:
				type = finsh_type_uint;
 801d6c0:	230a      	movs	r3, #10
 801d6c2:	73fb      	strb	r3, [r7, #15]
				break;
 801d6c4:	e002      	b.n	801d6cc <proc_type+0xe4>

			case finsh_token_type_long:
				type = finsh_type_ulong;
 801d6c6:	230d      	movs	r3, #13
 801d6c8:	73fb      	strb	r3, [r7, #15]
				break;
 801d6ca:	bf00      	nop

			default:
				goto __return;
			}
		}
 801d6cc:	bf00      	nop
 801d6ce:	e007      	b.n	801d6e0 <proc_type+0xf8>
		else
		{
			finsh_token_replay(&(self->token));
 801d6d0:	687b      	ldr	r3, [r7, #4]
 801d6d2:	2201      	movs	r2, #1
 801d6d4:	715a      	strb	r2, [r3, #5]
			finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
 801d6d6:	2002      	movs	r0, #2
 801d6d8:	f7fe fb70 	bl	801bdbc <finsh_error_set>
 801d6dc:	e000      	b.n	801d6e0 <proc_type+0xf8>
		}
	}
	else
	{
		goto __return;
 801d6de:	e046      	b.n	801d76e <proc_type+0x186>
	}

	/* parse for pointer */
	next_token(token, &(self->token));
 801d6e0:	687b      	ldr	r3, [r7, #4]
 801d6e2:	3304      	adds	r3, #4
 801d6e4:	4618      	mov	r0, r3
 801d6e6:	f000 fe8d 	bl	801e404 <finsh_token_token>
 801d6ea:	4603      	mov	r3, r0
 801d6ec:	73bb      	strb	r3, [r7, #14]
	if (token == finsh_token_type_mul)
 801d6ee:	7bbb      	ldrb	r3, [r7, #14]
 801d6f0:	2b05      	cmp	r3, #5
 801d6f2:	d134      	bne.n	801d75e <proc_type+0x176>
	{
		switch (type)
 801d6f4:	7bfb      	ldrb	r3, [r7, #15]
 801d6f6:	3b01      	subs	r3, #1
 801d6f8:	2b0c      	cmp	r3, #12
 801d6fa:	d82c      	bhi.n	801d756 <proc_type+0x16e>
 801d6fc:	a201      	add	r2, pc, #4	; (adr r2, 801d704 <proc_type+0x11c>)
 801d6fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d702:	bf00      	nop
 801d704:	0801d739 	.word	0x0801d739
 801d708:	0801d757 	.word	0x0801d757
 801d70c:	0801d73f 	.word	0x0801d73f
 801d710:	0801d73f 	.word	0x0801d73f
 801d714:	0801d757 	.word	0x0801d757
 801d718:	0801d745 	.word	0x0801d745
 801d71c:	0801d745 	.word	0x0801d745
 801d720:	0801d757 	.word	0x0801d757
 801d724:	0801d74b 	.word	0x0801d74b
 801d728:	0801d74b 	.word	0x0801d74b
 801d72c:	0801d757 	.word	0x0801d757
 801d730:	0801d751 	.word	0x0801d751
 801d734:	0801d751 	.word	0x0801d751
		{
		case finsh_type_void:
			type = finsh_type_voidp;
 801d738:	2302      	movs	r3, #2
 801d73a:	73fb      	strb	r3, [r7, #15]
			break;
 801d73c:	e00e      	b.n	801d75c <proc_type+0x174>

		case finsh_type_char:
		case finsh_type_uchar:
			type = finsh_type_charp;
 801d73e:	2305      	movs	r3, #5
 801d740:	73fb      	strb	r3, [r7, #15]
			break;
 801d742:	e00b      	b.n	801d75c <proc_type+0x174>

		case finsh_type_short:
		case finsh_type_ushort:
			type = finsh_type_shortp;
 801d744:	2308      	movs	r3, #8
 801d746:	73fb      	strb	r3, [r7, #15]
			break;
 801d748:	e008      	b.n	801d75c <proc_type+0x174>

		case finsh_type_int:
		case finsh_type_uint:
			type = finsh_type_intp;
 801d74a:	230b      	movs	r3, #11
 801d74c:	73fb      	strb	r3, [r7, #15]
			break;
 801d74e:	e005      	b.n	801d75c <proc_type+0x174>

		case finsh_type_long:
		case finsh_type_ulong:
			type = finsh_type_longp;
 801d750:	230e      	movs	r3, #14
 801d752:	73fb      	strb	r3, [r7, #15]
			break;
 801d754:	e002      	b.n	801d75c <proc_type+0x174>

		default:
			type = finsh_type_voidp;
 801d756:	2302      	movs	r3, #2
 801d758:	73fb      	strb	r3, [r7, #15]
			break;
 801d75a:	bf00      	nop
 801d75c:	e002      	b.n	801d764 <proc_type+0x17c>
		}
	}
	else finsh_token_replay(&(self->token));
 801d75e:	687b      	ldr	r3, [r7, #4]
 801d760:	2201      	movs	r2, #1
 801d762:	715a      	strb	r2, [r3, #5]

	return type;
 801d764:	7bfb      	ldrb	r3, [r7, #15]
 801d766:	e009      	b.n	801d77c <proc_type+0x194>
		case finsh_token_type_long:
			type = finsh_type_long;
			break;

		default:
			goto __return;
 801d768:	bf00      	nop
 801d76a:	e000      	b.n	801d76e <proc_type+0x186>
			case finsh_token_type_long:
				type = finsh_type_ulong;
				break;

			default:
				goto __return;
 801d76c:	bf00      	nop
	else finsh_token_replay(&(self->token));

	return type;

__return:
	finsh_token_replay(&(self->token));
 801d76e:	687b      	ldr	r3, [r7, #4]
 801d770:	2201      	movs	r2, #1
 801d772:	715a      	strb	r2, [r3, #5]
	finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801d774:	2003      	movs	r0, #3
 801d776:	f7fe fb21 	bl	801bdbc <finsh_error_set>

	return type;
 801d77a:	7bfb      	ldrb	r3, [r7, #15]
}
 801d77c:	4618      	mov	r0, r3
 801d77e:	3710      	adds	r7, #16
 801d780:	46bd      	mov	sp, r7
 801d782:	bd80      	pop	{r7, pc}

0801d784 <proc_identifier>:

/*
identifier -> IDENTIFIER
*/
static int proc_identifier(struct finsh_parser* self, char* id)
{
 801d784:	b580      	push	{r7, lr}
 801d786:	b084      	sub	sp, #16
 801d788:	af00      	add	r7, sp, #0
 801d78a:	6078      	str	r0, [r7, #4]
 801d78c:	6039      	str	r1, [r7, #0]
	enum finsh_token_type token;

	match_token(token, &(self->token), finsh_token_type_identifier);
 801d78e:	687b      	ldr	r3, [r7, #4]
 801d790:	3304      	adds	r3, #4
 801d792:	4618      	mov	r0, r3
 801d794:	f000 fe36 	bl	801e404 <finsh_token_token>
 801d798:	4603      	mov	r3, r0
 801d79a:	73fb      	strb	r3, [r7, #15]
 801d79c:	7bfb      	ldrb	r3, [r7, #15]
 801d79e:	2b1f      	cmp	r3, #31
 801d7a0:	d005      	beq.n	801d7ae <proc_identifier+0x2a>
 801d7a2:	2001      	movs	r0, #1
 801d7a4:	f7fe fb0a 	bl	801bdbc <finsh_error_set>
 801d7a8:	687b      	ldr	r3, [r7, #4]
 801d7aa:	2201      	movs	r2, #1
 801d7ac:	715a      	strb	r2, [r3, #5]

	strncpy(id, (char*)self->token.string, FINSH_NAME_MAX);
 801d7ae:	687b      	ldr	r3, [r7, #4]
 801d7b0:	3314      	adds	r3, #20
 801d7b2:	6838      	ldr	r0, [r7, #0]
 801d7b4:	4619      	mov	r1, r3
 801d7b6:	2210      	movs	r2, #16
 801d7b8:	f002 f9c8 	bl	801fb4c <strncpy>

	return 0;
 801d7bc:	2300      	movs	r3, #0
}
 801d7be:	4618      	mov	r0, r3
 801d7c0:	3710      	adds	r7, #16
 801d7c2:	46bd      	mov	sp, r7
 801d7c4:	bd80      	pop	{r7, pc}
 801d7c6:	bf00      	nop

0801d7c8 <proc_expr_statement>:
/*
statement_expr -> ';'
	| expr ';'
*/
static struct finsh_node* proc_expr_statement(struct finsh_parser* self)
{
 801d7c8:	b580      	push	{r7, lr}
 801d7ca:	b084      	sub	sp, #16
 801d7cc:	af00      	add	r7, sp, #0
 801d7ce:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* expr;

	expr = NULL;
 801d7d0:	2300      	movs	r3, #0
 801d7d2:	60fb      	str	r3, [r7, #12]
	next_token(token, &(self->token));
 801d7d4:	687b      	ldr	r3, [r7, #4]
 801d7d6:	3304      	adds	r3, #4
 801d7d8:	4618      	mov	r0, r3
 801d7da:	f000 fe13 	bl	801e404 <finsh_token_token>
 801d7de:	4603      	mov	r3, r0
 801d7e0:	72fb      	strb	r3, [r7, #11]
	if ( token != finsh_token_type_semicolon )
 801d7e2:	7afb      	ldrb	r3, [r7, #11]
 801d7e4:	2b04      	cmp	r3, #4
 801d7e6:	d016      	beq.n	801d816 <proc_expr_statement+0x4e>
	{
		finsh_token_replay(&(self->token));
 801d7e8:	687b      	ldr	r3, [r7, #4]
 801d7ea:	2201      	movs	r2, #1
 801d7ec:	715a      	strb	r2, [r3, #5]
		expr = proc_expr(self);
 801d7ee:	6878      	ldr	r0, [r7, #4]
 801d7f0:	f000 f816 	bl	801d820 <proc_expr>
 801d7f4:	60f8      	str	r0, [r7, #12]

		match_token(token, &(self->token), finsh_token_type_semicolon);
 801d7f6:	687b      	ldr	r3, [r7, #4]
 801d7f8:	3304      	adds	r3, #4
 801d7fa:	4618      	mov	r0, r3
 801d7fc:	f000 fe02 	bl	801e404 <finsh_token_token>
 801d800:	4603      	mov	r3, r0
 801d802:	72fb      	strb	r3, [r7, #11]
 801d804:	7afb      	ldrb	r3, [r7, #11]
 801d806:	2b04      	cmp	r3, #4
 801d808:	d005      	beq.n	801d816 <proc_expr_statement+0x4e>
 801d80a:	2001      	movs	r0, #1
 801d80c:	f7fe fad6 	bl	801bdbc <finsh_error_set>
 801d810:	687b      	ldr	r3, [r7, #4]
 801d812:	2201      	movs	r2, #1
 801d814:	715a      	strb	r2, [r3, #5]
	}

	return expr;
 801d816:	68fb      	ldr	r3, [r7, #12]
}
 801d818:	4618      	mov	r0, r3
 801d81a:	3710      	adds	r7, #16
 801d81c:	46bd      	mov	sp, r7
 801d81e:	bd80      	pop	{r7, pc}

0801d820 <proc_expr>:

/*
expr -> expr_assign
*/
static struct finsh_node* proc_expr(struct finsh_parser* self)
{
 801d820:	b580      	push	{r7, lr}
 801d822:	b082      	sub	sp, #8
 801d824:	af00      	add	r7, sp, #0
 801d826:	6078      	str	r0, [r7, #4]
	return proc_assign_expr(self);
 801d828:	6878      	ldr	r0, [r7, #4]
 801d82a:	f000 f805 	bl	801d838 <proc_assign_expr>
 801d82e:	4603      	mov	r3, r0
}
 801d830:	4618      	mov	r0, r3
 801d832:	3708      	adds	r7, #8
 801d834:	46bd      	mov	sp, r7
 801d836:	bd80      	pop	{r7, pc}

0801d838 <proc_assign_expr>:
/*
expr_assign -> expr_inclusive_or
	| expr_unary ASSIGN expr_assign
*/
static struct finsh_node* proc_assign_expr(struct finsh_parser* self)
{
 801d838:	b580      	push	{r7, lr}
 801d83a:	b086      	sub	sp, #24
 801d83c:	af00      	add	r7, sp, #0
 801d83e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* or;
	struct finsh_node* assign;

	or = proc_inclusive_or_expr(self);
 801d840:	6878      	ldr	r0, [r7, #4]
 801d842:	f000 f81f 	bl	801d884 <proc_inclusive_or_expr>
 801d846:	6178      	str	r0, [r7, #20]

	next_token(token, &(self->token));
 801d848:	687b      	ldr	r3, [r7, #4]
 801d84a:	3304      	adds	r3, #4
 801d84c:	4618      	mov	r0, r3
 801d84e:	f000 fdd9 	bl	801e404 <finsh_token_token>
 801d852:	4603      	mov	r3, r0
 801d854:	74fb      	strb	r3, [r7, #19]

	if (token == finsh_token_type_assign)
 801d856:	7cfb      	ldrb	r3, [r7, #19]
 801d858:	2b0c      	cmp	r3, #12
 801d85a:	d10a      	bne.n	801d872 <proc_assign_expr+0x3a>
	{
		assign = proc_assign_expr(self);
 801d85c:	6878      	ldr	r0, [r7, #4]
 801d85e:	f7ff ffeb 	bl	801d838 <proc_assign_expr>
 801d862:	60f8      	str	r0, [r7, #12]

		return make_sys_node(FINSH_NODE_SYS_ASSIGN, or, assign);
 801d864:	2013      	movs	r0, #19
 801d866:	6979      	ldr	r1, [r7, #20]
 801d868:	68fa      	ldr	r2, [r7, #12]
 801d86a:	f000 fb8f 	bl	801df8c <make_sys_node>
 801d86e:	4603      	mov	r3, r0
 801d870:	e003      	b.n	801d87a <proc_assign_expr+0x42>
	}
	else finsh_token_replay(&(self->token));
 801d872:	687b      	ldr	r3, [r7, #4]
 801d874:	2201      	movs	r2, #1
 801d876:	715a      	strb	r2, [r3, #5]

	return or;
 801d878:	697b      	ldr	r3, [r7, #20]
}
 801d87a:	4618      	mov	r0, r3
 801d87c:	3718      	adds	r7, #24
 801d87e:	46bd      	mov	sp, r7
 801d880:	bd80      	pop	{r7, pc}
 801d882:	bf00      	nop

0801d884 <proc_inclusive_or_expr>:
/*
expr_inclusive_or -> expr_exclusive_or
	| expr_inclusive_or '|' expr_exclusive_or
*/
static struct finsh_node* proc_inclusive_or_expr(struct finsh_parser* self)
{
 801d884:	b580      	push	{r7, lr}
 801d886:	b086      	sub	sp, #24
 801d888:	af00      	add	r7, sp, #0
 801d88a:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* xor;
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);
 801d88c:	6878      	ldr	r0, [r7, #4]
 801d88e:	f000 f82d 	bl	801d8ec <proc_exclusive_or_expr>
 801d892:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 801d894:	687b      	ldr	r3, [r7, #4]
 801d896:	3304      	adds	r3, #4
 801d898:	4618      	mov	r0, r3
 801d89a:	f000 fdb3 	bl	801e404 <finsh_token_token>
 801d89e:	4603      	mov	r3, r0
 801d8a0:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_or )
 801d8a2:	e017      	b.n	801d8d4 <proc_inclusive_or_expr+0x50>
	{
		xor_new = proc_exclusive_or_expr(self);
 801d8a4:	6878      	ldr	r0, [r7, #4]
 801d8a6:	f000 f821 	bl	801d8ec <proc_exclusive_or_expr>
 801d8aa:	60f8      	str	r0, [r7, #12]

		if (xor_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801d8ac:	68fb      	ldr	r3, [r7, #12]
 801d8ae:	2b00      	cmp	r3, #0
 801d8b0:	d103      	bne.n	801d8ba <proc_inclusive_or_expr+0x36>
 801d8b2:	2005      	movs	r0, #5
 801d8b4:	f7fe fa82 	bl	801bdbc <finsh_error_set>
 801d8b8:	e005      	b.n	801d8c6 <proc_inclusive_or_expr+0x42>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);
 801d8ba:	200d      	movs	r0, #13
 801d8bc:	6939      	ldr	r1, [r7, #16]
 801d8be:	68fa      	ldr	r2, [r7, #12]
 801d8c0:	f000 fb64 	bl	801df8c <make_sys_node>
 801d8c4:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 801d8c6:	687b      	ldr	r3, [r7, #4]
 801d8c8:	3304      	adds	r3, #4
 801d8ca:	4618      	mov	r0, r3
 801d8cc:	f000 fd9a 	bl	801e404 <finsh_token_token>
 801d8d0:	4603      	mov	r3, r0
 801d8d2:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_or )
 801d8d4:	7dfb      	ldrb	r3, [r7, #23]
 801d8d6:	2b0e      	cmp	r3, #14
 801d8d8:	d0e4      	beq.n	801d8a4 <proc_inclusive_or_expr+0x20>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 801d8da:	687b      	ldr	r3, [r7, #4]
 801d8dc:	2201      	movs	r2, #1
 801d8de:	715a      	strb	r2, [r3, #5]
	return xor;
 801d8e0:	693b      	ldr	r3, [r7, #16]
}
 801d8e2:	4618      	mov	r0, r3
 801d8e4:	3718      	adds	r7, #24
 801d8e6:	46bd      	mov	sp, r7
 801d8e8:	bd80      	pop	{r7, pc}
 801d8ea:	bf00      	nop

0801d8ec <proc_exclusive_or_expr>:
/*
expr_exclusive_or -> expr_and
	| expr_exclusive '^' expr_and
*/
static struct finsh_node* proc_exclusive_or_expr(struct finsh_parser* self)
{
 801d8ec:	b580      	push	{r7, lr}
 801d8ee:	b086      	sub	sp, #24
 801d8f0:	af00      	add	r7, sp, #0
 801d8f2:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
 801d8f4:	6878      	ldr	r0, [r7, #4]
 801d8f6:	f000 f82d 	bl	801d954 <proc_and_expr>
 801d8fa:	6138      	str	r0, [r7, #16]
	next_token(token, &(self->token));
 801d8fc:	687b      	ldr	r3, [r7, #4]
 801d8fe:	3304      	adds	r3, #4
 801d900:	4618      	mov	r0, r3
 801d902:	f000 fd7f 	bl	801e404 <finsh_token_token>
 801d906:	4603      	mov	r3, r0
 801d908:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_xor )
 801d90a:	e017      	b.n	801d93c <proc_exclusive_or_expr+0x50>
	{
		and_new = proc_and_expr(self);
 801d90c:	6878      	ldr	r0, [r7, #4]
 801d90e:	f000 f821 	bl	801d954 <proc_and_expr>
 801d912:	60f8      	str	r0, [r7, #12]
		if (and_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801d914:	68fb      	ldr	r3, [r7, #12]
 801d916:	2b00      	cmp	r3, #0
 801d918:	d103      	bne.n	801d922 <proc_exclusive_or_expr+0x36>
 801d91a:	2005      	movs	r0, #5
 801d91c:	f7fe fa4e 	bl	801bdbc <finsh_error_set>
 801d920:	e005      	b.n	801d92e <proc_exclusive_or_expr+0x42>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);
 801d922:	200e      	movs	r0, #14
 801d924:	6939      	ldr	r1, [r7, #16]
 801d926:	68fa      	ldr	r2, [r7, #12]
 801d928:	f000 fb30 	bl	801df8c <make_sys_node>
 801d92c:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 801d92e:	687b      	ldr	r3, [r7, #4]
 801d930:	3304      	adds	r3, #4
 801d932:	4618      	mov	r0, r3
 801d934:	f000 fd66 	bl	801e404 <finsh_token_token>
 801d938:	4603      	mov	r3, r0
 801d93a:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
	next_token(token, &(self->token));
	while ( token == finsh_token_type_xor )
 801d93c:	7dfb      	ldrb	r3, [r7, #23]
 801d93e:	2b0f      	cmp	r3, #15
 801d940:	d0e4      	beq.n	801d90c <proc_exclusive_or_expr+0x20>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 801d942:	687b      	ldr	r3, [r7, #4]
 801d944:	2201      	movs	r2, #1
 801d946:	715a      	strb	r2, [r3, #5]
	return and;
 801d948:	693b      	ldr	r3, [r7, #16]
}
 801d94a:	4618      	mov	r0, r3
 801d94c:	3718      	adds	r7, #24
 801d94e:	46bd      	mov	sp, r7
 801d950:	bd80      	pop	{r7, pc}
 801d952:	bf00      	nop

0801d954 <proc_and_expr>:
/*
expr_and -> expr_shift
	| expr_and '&' expr_shift
*/
static struct finsh_node* proc_and_expr(struct finsh_parser* self)
{
 801d954:	b580      	push	{r7, lr}
 801d956:	b086      	sub	sp, #24
 801d958:	af00      	add	r7, sp, #0
 801d95a:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* shift;
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);
 801d95c:	6878      	ldr	r0, [r7, #4]
 801d95e:	f000 f82d 	bl	801d9bc <proc_shift_expr>
 801d962:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 801d964:	687b      	ldr	r3, [r7, #4]
 801d966:	3304      	adds	r3, #4
 801d968:	4618      	mov	r0, r3
 801d96a:	f000 fd4b 	bl	801e404 <finsh_token_token>
 801d96e:	4603      	mov	r3, r0
 801d970:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_and )
 801d972:	e017      	b.n	801d9a4 <proc_and_expr+0x50>
	{
		shift_new = proc_shift_expr(self);
 801d974:	6878      	ldr	r0, [r7, #4]
 801d976:	f000 f821 	bl	801d9bc <proc_shift_expr>
 801d97a:	60f8      	str	r0, [r7, #12]

		if (shift_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801d97c:	68fb      	ldr	r3, [r7, #12]
 801d97e:	2b00      	cmp	r3, #0
 801d980:	d103      	bne.n	801d98a <proc_and_expr+0x36>
 801d982:	2005      	movs	r0, #5
 801d984:	f7fe fa1a 	bl	801bdbc <finsh_error_set>
 801d988:	e005      	b.n	801d996 <proc_and_expr+0x42>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);
 801d98a:	200c      	movs	r0, #12
 801d98c:	6939      	ldr	r1, [r7, #16]
 801d98e:	68fa      	ldr	r2, [r7, #12]
 801d990:	f000 fafc 	bl	801df8c <make_sys_node>
 801d994:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 801d996:	687b      	ldr	r3, [r7, #4]
 801d998:	3304      	adds	r3, #4
 801d99a:	4618      	mov	r0, r3
 801d99c:	f000 fd32 	bl	801e404 <finsh_token_token>
 801d9a0:	4603      	mov	r3, r0
 801d9a2:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_and )
 801d9a4:	7dfb      	ldrb	r3, [r7, #23]
 801d9a6:	2b0d      	cmp	r3, #13
 801d9a8:	d0e4      	beq.n	801d974 <proc_and_expr+0x20>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 801d9aa:	687b      	ldr	r3, [r7, #4]
 801d9ac:	2201      	movs	r2, #1
 801d9ae:	715a      	strb	r2, [r3, #5]
	return shift;
 801d9b0:	693b      	ldr	r3, [r7, #16]
}
 801d9b2:	4618      	mov	r0, r3
 801d9b4:	3718      	adds	r7, #24
 801d9b6:	46bd      	mov	sp, r7
 801d9b8:	bd80      	pop	{r7, pc}
 801d9ba:	bf00      	nop

0801d9bc <proc_shift_expr>:
expr_shift -> expr_additive
	| expr_shift '<<' expr_additive
	| expr_shift '>>' expr_additive
*/
static struct finsh_node* proc_shift_expr(struct finsh_parser* self)
{
 801d9bc:	b580      	push	{r7, lr}
 801d9be:	b086      	sub	sp, #24
 801d9c0:	af00      	add	r7, sp, #0
 801d9c2:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* add;
	struct finsh_node* add_new;

	add = proc_additive_expr(self);
 801d9c4:	6878      	ldr	r0, [r7, #4]
 801d9c6:	f000 f841 	bl	801da4c <proc_additive_expr>
 801d9ca:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 801d9cc:	687b      	ldr	r3, [r7, #4]
 801d9ce:	3304      	adds	r3, #4
 801d9d0:	4618      	mov	r0, r3
 801d9d2:	f000 fd17 	bl	801e404 <finsh_token_token>
 801d9d6:	4603      	mov	r3, r0
 801d9d8:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
 801d9da:	e029      	b.n	801da30 <proc_shift_expr+0x74>
	{
		add_new = proc_additive_expr(self);
 801d9dc:	6878      	ldr	r0, [r7, #4]
 801d9de:	f000 f835 	bl	801da4c <proc_additive_expr>
 801d9e2:	60f8      	str	r0, [r7, #12]
		if (add_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801d9e4:	68fb      	ldr	r3, [r7, #12]
 801d9e6:	2b00      	cmp	r3, #0
 801d9e8:	d103      	bne.n	801d9f2 <proc_shift_expr+0x36>
 801d9ea:	2005      	movs	r0, #5
 801d9ec:	f7fe f9e6 	bl	801bdbc <finsh_error_set>
 801d9f0:	e017      	b.n	801da22 <proc_shift_expr+0x66>
		else
		{
			switch (token)
 801d9f2:	7dfb      	ldrb	r3, [r7, #23]
 801d9f4:	2b11      	cmp	r3, #17
 801d9f6:	d002      	beq.n	801d9fe <proc_shift_expr+0x42>
 801d9f8:	2b12      	cmp	r3, #18
 801d9fa:	d007      	beq.n	801da0c <proc_shift_expr+0x50>
 801d9fc:	e00d      	b.n	801da1a <proc_shift_expr+0x5e>
			{
			case finsh_token_type_shl:
				add = make_sys_node(FINSH_NODE_SYS_SHL, add, add_new);
 801d9fe:	2010      	movs	r0, #16
 801da00:	6939      	ldr	r1, [r7, #16]
 801da02:	68fa      	ldr	r2, [r7, #12]
 801da04:	f000 fac2 	bl	801df8c <make_sys_node>
 801da08:	6138      	str	r0, [r7, #16]
				break;
 801da0a:	e00a      	b.n	801da22 <proc_shift_expr+0x66>
			case finsh_token_type_shr:
				add = make_sys_node(FINSH_NODE_SYS_SHR, add, add_new);
 801da0c:	2011      	movs	r0, #17
 801da0e:	6939      	ldr	r1, [r7, #16]
 801da10:	68fa      	ldr	r2, [r7, #12]
 801da12:	f000 fabb 	bl	801df8c <make_sys_node>
 801da16:	6138      	str	r0, [r7, #16]
				break;
 801da18:	e003      	b.n	801da22 <proc_shift_expr+0x66>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801da1a:	2005      	movs	r0, #5
 801da1c:	f7fe f9ce 	bl	801bdbc <finsh_error_set>
				break;
 801da20:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 801da22:	687b      	ldr	r3, [r7, #4]
 801da24:	3304      	adds	r3, #4
 801da26:	4618      	mov	r0, r3
 801da28:	f000 fcec 	bl	801e404 <finsh_token_token>
 801da2c:	4603      	mov	r3, r0
 801da2e:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* add_new;

	add = proc_additive_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
 801da30:	7dfb      	ldrb	r3, [r7, #23]
 801da32:	2b11      	cmp	r3, #17
 801da34:	d0d2      	beq.n	801d9dc <proc_shift_expr+0x20>
 801da36:	7dfb      	ldrb	r3, [r7, #23]
 801da38:	2b12      	cmp	r3, #18
 801da3a:	d0cf      	beq.n	801d9dc <proc_shift_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 801da3c:	687b      	ldr	r3, [r7, #4]
 801da3e:	2201      	movs	r2, #1
 801da40:	715a      	strb	r2, [r3, #5]
	return add;
 801da42:	693b      	ldr	r3, [r7, #16]
}
 801da44:	4618      	mov	r0, r3
 801da46:	3718      	adds	r7, #24
 801da48:	46bd      	mov	sp, r7
 801da4a:	bd80      	pop	{r7, pc}

0801da4c <proc_additive_expr>:
expr_additive -> expr_multiplicative
	| expr_additive SUB expr_multiplicative
	| expr_additive ADD expr_multiplicative
*/
static struct finsh_node* proc_additive_expr(struct finsh_parser* self)
{
 801da4c:	b580      	push	{r7, lr}
 801da4e:	b086      	sub	sp, #24
 801da50:	af00      	add	r7, sp, #0
 801da52:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* mul;
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);
 801da54:	6878      	ldr	r0, [r7, #4]
 801da56:	f000 f841 	bl	801dadc <proc_multiplicative_expr>
 801da5a:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 801da5c:	687b      	ldr	r3, [r7, #4]
 801da5e:	3304      	adds	r3, #4
 801da60:	4618      	mov	r0, r3
 801da62:	f000 fccf 	bl	801e404 <finsh_token_token>
 801da66:	4603      	mov	r3, r0
 801da68:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
 801da6a:	e028      	b.n	801dabe <proc_additive_expr+0x72>
	{
		mul_new = proc_multiplicative_expr(self);
 801da6c:	6878      	ldr	r0, [r7, #4]
 801da6e:	f000 f835 	bl	801dadc <proc_multiplicative_expr>
 801da72:	60f8      	str	r0, [r7, #12]
		if (mul_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801da74:	68fb      	ldr	r3, [r7, #12]
 801da76:	2b00      	cmp	r3, #0
 801da78:	d103      	bne.n	801da82 <proc_additive_expr+0x36>
 801da7a:	2005      	movs	r0, #5
 801da7c:	f7fe f99e 	bl	801bdbc <finsh_error_set>
 801da80:	e016      	b.n	801dab0 <proc_additive_expr+0x64>
		else
		{
			switch (token)
 801da82:	7dfb      	ldrb	r3, [r7, #23]
 801da84:	2b06      	cmp	r3, #6
 801da86:	d008      	beq.n	801da9a <proc_additive_expr+0x4e>
 801da88:	2b08      	cmp	r3, #8
 801da8a:	d10d      	bne.n	801daa8 <proc_additive_expr+0x5c>
			{
			case finsh_token_type_sub:
				mul = make_sys_node(FINSH_NODE_SYS_SUB, mul, mul_new);
 801da8c:	2008      	movs	r0, #8
 801da8e:	6939      	ldr	r1, [r7, #16]
 801da90:	68fa      	ldr	r2, [r7, #12]
 801da92:	f000 fa7b 	bl	801df8c <make_sys_node>
 801da96:	6138      	str	r0, [r7, #16]
				break;
 801da98:	e00a      	b.n	801dab0 <proc_additive_expr+0x64>
			case finsh_token_type_add:
				mul = make_sys_node(FINSH_NODE_SYS_ADD, mul, mul_new);
 801da9a:	2007      	movs	r0, #7
 801da9c:	6939      	ldr	r1, [r7, #16]
 801da9e:	68fa      	ldr	r2, [r7, #12]
 801daa0:	f000 fa74 	bl	801df8c <make_sys_node>
 801daa4:	6138      	str	r0, [r7, #16]
				break;
 801daa6:	e003      	b.n	801dab0 <proc_additive_expr+0x64>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801daa8:	2005      	movs	r0, #5
 801daaa:	f7fe f987 	bl	801bdbc <finsh_error_set>
				break;
 801daae:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 801dab0:	687b      	ldr	r3, [r7, #4]
 801dab2:	3304      	adds	r3, #4
 801dab4:	4618      	mov	r0, r3
 801dab6:	f000 fca5 	bl	801e404 <finsh_token_token>
 801daba:	4603      	mov	r3, r0
 801dabc:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
 801dabe:	7dfb      	ldrb	r3, [r7, #23]
 801dac0:	2b08      	cmp	r3, #8
 801dac2:	d0d3      	beq.n	801da6c <proc_additive_expr+0x20>
 801dac4:	7dfb      	ldrb	r3, [r7, #23]
 801dac6:	2b06      	cmp	r3, #6
 801dac8:	d0d0      	beq.n	801da6c <proc_additive_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 801daca:	687b      	ldr	r3, [r7, #4]
 801dacc:	2201      	movs	r2, #1
 801dace:	715a      	strb	r2, [r3, #5]
	return mul;
 801dad0:	693b      	ldr	r3, [r7, #16]
}
 801dad2:	4618      	mov	r0, r3
 801dad4:	3718      	adds	r7, #24
 801dad6:	46bd      	mov	sp, r7
 801dad8:	bd80      	pop	{r7, pc}
 801dada:	bf00      	nop

0801dadc <proc_multiplicative_expr>:
	| expr_multiplicative '*' expr_cast
	| expr_multiplicative '/' expr_cast
	| expr_multiplicative '%' expr_cast
*/
static struct finsh_node* proc_multiplicative_expr(struct finsh_parser* self)
{
 801dadc:	b580      	push	{r7, lr}
 801dade:	b086      	sub	sp, #24
 801dae0:	af00      	add	r7, sp, #0
 801dae2:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
 801dae4:	6878      	ldr	r0, [r7, #4]
 801dae6:	f000 f84d 	bl	801db84 <proc_cast_expr>
 801daea:	6138      	str	r0, [r7, #16]
	next_token(token, &(self->token));
 801daec:	687b      	ldr	r3, [r7, #4]
 801daee:	3304      	adds	r3, #4
 801daf0:	4618      	mov	r0, r3
 801daf2:	f000 fc87 	bl	801e404 <finsh_token_token>
 801daf6:	4603      	mov	r3, r0
 801daf8:	75fb      	strb	r3, [r7, #23]
	while (token == finsh_token_type_mul ||
 801dafa:	e031      	b.n	801db60 <proc_multiplicative_expr+0x84>
		token == finsh_token_type_div ||
		token == finsh_token_type_mod )
	{
		cast_new = proc_cast_expr(self);
 801dafc:	6878      	ldr	r0, [r7, #4]
 801dafe:	f000 f841 	bl	801db84 <proc_cast_expr>
 801db02:	60f8      	str	r0, [r7, #12]
		if (cast_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801db04:	68fb      	ldr	r3, [r7, #12]
 801db06:	2b00      	cmp	r3, #0
 801db08:	d103      	bne.n	801db12 <proc_multiplicative_expr+0x36>
 801db0a:	2005      	movs	r0, #5
 801db0c:	f7fe f956 	bl	801bdbc <finsh_error_set>
 801db10:	e01f      	b.n	801db52 <proc_multiplicative_expr+0x76>
		else
		{
			switch (token)
 801db12:	7dfb      	ldrb	r3, [r7, #23]
 801db14:	2b0a      	cmp	r3, #10
 801db16:	d00a      	beq.n	801db2e <proc_multiplicative_expr+0x52>
 801db18:	2b0b      	cmp	r3, #11
 801db1a:	d00f      	beq.n	801db3c <proc_multiplicative_expr+0x60>
 801db1c:	2b05      	cmp	r3, #5
 801db1e:	d114      	bne.n	801db4a <proc_multiplicative_expr+0x6e>
			{
			case finsh_token_type_mul:
				cast = make_sys_node(FINSH_NODE_SYS_MUL, cast, cast_new);
 801db20:	2009      	movs	r0, #9
 801db22:	6939      	ldr	r1, [r7, #16]
 801db24:	68fa      	ldr	r2, [r7, #12]
 801db26:	f000 fa31 	bl	801df8c <make_sys_node>
 801db2a:	6138      	str	r0, [r7, #16]
				break;
 801db2c:	e011      	b.n	801db52 <proc_multiplicative_expr+0x76>

			case finsh_token_type_div:
				cast = make_sys_node(FINSH_NODE_SYS_DIV, cast, cast_new);
 801db2e:	200a      	movs	r0, #10
 801db30:	6939      	ldr	r1, [r7, #16]
 801db32:	68fa      	ldr	r2, [r7, #12]
 801db34:	f000 fa2a 	bl	801df8c <make_sys_node>
 801db38:	6138      	str	r0, [r7, #16]
				break;
 801db3a:	e00a      	b.n	801db52 <proc_multiplicative_expr+0x76>

			case finsh_token_type_mod:
				cast = make_sys_node(FINSH_NODE_SYS_MOD, cast, cast_new);
 801db3c:	200b      	movs	r0, #11
 801db3e:	6939      	ldr	r1, [r7, #16]
 801db40:	68fa      	ldr	r2, [r7, #12]
 801db42:	f000 fa23 	bl	801df8c <make_sys_node>
 801db46:	6138      	str	r0, [r7, #16]
				break;
 801db48:	e003      	b.n	801db52 <proc_multiplicative_expr+0x76>

			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801db4a:	2005      	movs	r0, #5
 801db4c:	f7fe f936 	bl	801bdbc <finsh_error_set>
				break;
 801db50:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 801db52:	687b      	ldr	r3, [r7, #4]
 801db54:	3304      	adds	r3, #4
 801db56:	4618      	mov	r0, r3
 801db58:	f000 fc54 	bl	801e404 <finsh_token_token>
 801db5c:	4603      	mov	r3, r0
 801db5e:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
	next_token(token, &(self->token));
	while (token == finsh_token_type_mul ||
 801db60:	7dfb      	ldrb	r3, [r7, #23]
 801db62:	2b05      	cmp	r3, #5
 801db64:	d0ca      	beq.n	801dafc <proc_multiplicative_expr+0x20>
 801db66:	7dfb      	ldrb	r3, [r7, #23]
 801db68:	2b0a      	cmp	r3, #10
 801db6a:	d0c7      	beq.n	801dafc <proc_multiplicative_expr+0x20>
		token == finsh_token_type_div ||
 801db6c:	7dfb      	ldrb	r3, [r7, #23]
 801db6e:	2b0b      	cmp	r3, #11
 801db70:	d0c4      	beq.n	801dafc <proc_multiplicative_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 801db72:	687b      	ldr	r3, [r7, #4]
 801db74:	2201      	movs	r2, #1
 801db76:	715a      	strb	r2, [r3, #5]
	return cast;
 801db78:	693b      	ldr	r3, [r7, #16]
}
 801db7a:	4618      	mov	r0, r3
 801db7c:	3718      	adds	r7, #24
 801db7e:	46bd      	mov	sp, r7
 801db80:	bd80      	pop	{r7, pc}
 801db82:	bf00      	nop

0801db84 <proc_cast_expr>:
20060313, add recast parse
expr_cast -> expr_unary
	| '(' type ')' expr_cast
*/
static struct finsh_node* proc_cast_expr(struct finsh_parser* self)
{
 801db84:	b580      	push	{r7, lr}
 801db86:	b084      	sub	sp, #16
 801db88:	af00      	add	r7, sp, #0
 801db8a:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	enum finsh_type type;
	struct finsh_node* cast;

	next_token(token, &(self->token));
 801db8c:	687b      	ldr	r3, [r7, #4]
 801db8e:	3304      	adds	r3, #4
 801db90:	4618      	mov	r0, r3
 801db92:	f000 fc37 	bl	801e404 <finsh_token_token>
 801db96:	4603      	mov	r3, r0
 801db98:	73fb      	strb	r3, [r7, #15]
	if (token == finsh_token_type_left_paren)
 801db9a:	7bfb      	ldrb	r3, [r7, #15]
 801db9c:	2b01      	cmp	r3, #1
 801db9e:	d120      	bne.n	801dbe2 <proc_cast_expr+0x5e>
	{
		type = proc_type(self);
 801dba0:	6878      	ldr	r0, [r7, #4]
 801dba2:	f7ff fd21 	bl	801d5e8 <proc_type>
 801dba6:	4603      	mov	r3, r0
 801dba8:	73bb      	strb	r3, [r7, #14]
		match_token(token, &(self->token), finsh_token_type_right_paren);
 801dbaa:	687b      	ldr	r3, [r7, #4]
 801dbac:	3304      	adds	r3, #4
 801dbae:	4618      	mov	r0, r3
 801dbb0:	f000 fc28 	bl	801e404 <finsh_token_token>
 801dbb4:	4603      	mov	r3, r0
 801dbb6:	73fb      	strb	r3, [r7, #15]
 801dbb8:	7bfb      	ldrb	r3, [r7, #15]
 801dbba:	2b02      	cmp	r3, #2
 801dbbc:	d005      	beq.n	801dbca <proc_cast_expr+0x46>
 801dbbe:	2001      	movs	r0, #1
 801dbc0:	f7fe f8fc 	bl	801bdbc <finsh_error_set>
 801dbc4:	687b      	ldr	r3, [r7, #4]
 801dbc6:	2201      	movs	r2, #1
 801dbc8:	715a      	strb	r2, [r3, #5]

		cast = proc_cast_expr(self);
 801dbca:	6878      	ldr	r0, [r7, #4]
 801dbcc:	f7ff ffda 	bl	801db84 <proc_cast_expr>
 801dbd0:	60b8      	str	r0, [r7, #8]
		if (cast != NULL)
 801dbd2:	68bb      	ldr	r3, [r7, #8]
 801dbd4:	2b00      	cmp	r3, #0
 801dbd6:	d004      	beq.n	801dbe2 <proc_cast_expr+0x5e>
		{
			cast->data_type = type;
 801dbd8:	68bb      	ldr	r3, [r7, #8]
 801dbda:	7bba      	ldrb	r2, [r7, #14]
 801dbdc:	705a      	strb	r2, [r3, #1]
			return cast;
 801dbde:	68bb      	ldr	r3, [r7, #8]
 801dbe0:	e006      	b.n	801dbf0 <proc_cast_expr+0x6c>
		}
	}

	finsh_token_replay(&(self->token));
 801dbe2:	687b      	ldr	r3, [r7, #4]
 801dbe4:	2201      	movs	r2, #1
 801dbe6:	715a      	strb	r2, [r3, #5]
	return proc_unary_expr(self);
 801dbe8:	6878      	ldr	r0, [r7, #4]
 801dbea:	f000 f805 	bl	801dbf8 <proc_unary_expr>
 801dbee:	4603      	mov	r3, r0
}
 801dbf0:	4618      	mov	r0, r3
 801dbf2:	3710      	adds	r7, #16
 801dbf4:	46bd      	mov	sp, r7
 801dbf6:	bd80      	pop	{r7, pc}

0801dbf8 <proc_unary_expr>:
	| '~' expr_cast
	| '*' expr_cast
	| '&' expr_cast
*/
static struct finsh_node* proc_unary_expr(struct finsh_parser* self)
{
 801dbf8:	b580      	push	{r7, lr}
 801dbfa:	b084      	sub	sp, #16
 801dbfc:	af00      	add	r7, sp, #0
 801dbfe:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node *cast;

	next_token(token, &(self->token));
 801dc00:	687b      	ldr	r3, [r7, #4]
 801dc02:	3304      	adds	r3, #4
 801dc04:	4618      	mov	r0, r3
 801dc06:	f000 fbfd 	bl	801e404 <finsh_token_token>
 801dc0a:	4603      	mov	r3, r0
 801dc0c:	73fb      	strb	r3, [r7, #15]
	switch (token)
 801dc0e:	7bfb      	ldrb	r3, [r7, #15]
 801dc10:	3b05      	subs	r3, #5
 801dc12:	2b0b      	cmp	r3, #11
 801dc14:	d866      	bhi.n	801dce4 <proc_unary_expr+0xec>
 801dc16:	a201      	add	r2, pc, #4	; (adr r2, 801dc1c <proc_unary_expr+0x24>)
 801dc18:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801dc1c:	0801dcb9 	.word	0x0801dcb9
 801dc20:	0801dc4d 	.word	0x0801dc4d
 801dc24:	0801dc59 	.word	0x0801dc59
 801dc28:	0801dc6f 	.word	0x0801dc6f
 801dc2c:	0801dc8d 	.word	0x0801dc8d
 801dc30:	0801dce5 	.word	0x0801dce5
 801dc34:	0801dce5 	.word	0x0801dce5
 801dc38:	0801dce5 	.word	0x0801dce5
 801dc3c:	0801dccf 	.word	0x0801dccf
 801dc40:	0801dce5 	.word	0x0801dce5
 801dc44:	0801dce5 	.word	0x0801dce5
 801dc48:	0801dca3 	.word	0x0801dca3
	{
	case finsh_token_type_add: /* + */
		cast = proc_cast_expr(self);
 801dc4c:	6878      	ldr	r0, [r7, #4]
 801dc4e:	f7ff ff99 	bl	801db84 <proc_cast_expr>
 801dc52:	60b8      	str	r0, [r7, #8]
		return cast;
 801dc54:	68bb      	ldr	r3, [r7, #8]
 801dc56:	e04c      	b.n	801dcf2 <proc_unary_expr+0xfa>

	case finsh_token_type_inc: /* ++ */
		cast = proc_cast_expr(self);
 801dc58:	6878      	ldr	r0, [r7, #4]
 801dc5a:	f7ff ff93 	bl	801db84 <proc_cast_expr>
 801dc5e:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_PREINC, cast, NULL);
 801dc60:	2015      	movs	r0, #21
 801dc62:	68b9      	ldr	r1, [r7, #8]
 801dc64:	2200      	movs	r2, #0
 801dc66:	f000 f991 	bl	801df8c <make_sys_node>
 801dc6a:	4603      	mov	r3, r0
 801dc6c:	e041      	b.n	801dcf2 <proc_unary_expr+0xfa>

	case finsh_token_type_sub: /* - */
		cast = proc_cast_expr(self);
 801dc6e:	6878      	ldr	r0, [r7, #4]
 801dc70:	f7ff ff88 	bl	801db84 <proc_cast_expr>
 801dc74:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_SUB, finsh_node_new_long(0), cast);
 801dc76:	2000      	movs	r0, #0
 801dc78:	f7fe fb9c 	bl	801c3b4 <finsh_node_new_long>
 801dc7c:	4603      	mov	r3, r0
 801dc7e:	2008      	movs	r0, #8
 801dc80:	4619      	mov	r1, r3
 801dc82:	68ba      	ldr	r2, [r7, #8]
 801dc84:	f000 f982 	bl	801df8c <make_sys_node>
 801dc88:	4603      	mov	r3, r0
 801dc8a:	e032      	b.n	801dcf2 <proc_unary_expr+0xfa>

	case finsh_token_type_dec: /* -- */
		cast = proc_cast_expr(self);
 801dc8c:	6878      	ldr	r0, [r7, #4]
 801dc8e:	f7ff ff79 	bl	801db84 <proc_cast_expr>
 801dc92:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_PREDEC, cast, NULL);
 801dc94:	2016      	movs	r0, #22
 801dc96:	68b9      	ldr	r1, [r7, #8]
 801dc98:	2200      	movs	r2, #0
 801dc9a:	f000 f977 	bl	801df8c <make_sys_node>
 801dc9e:	4603      	mov	r3, r0
 801dca0:	e027      	b.n	801dcf2 <proc_unary_expr+0xfa>

	case finsh_token_type_bitwise: /* ~ */
		cast = proc_cast_expr(self);
 801dca2:	6878      	ldr	r0, [r7, #4]
 801dca4:	f7ff ff6e 	bl	801db84 <proc_cast_expr>
 801dca8:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_BITWISE, cast, NULL);
 801dcaa:	200f      	movs	r0, #15
 801dcac:	68b9      	ldr	r1, [r7, #8]
 801dcae:	2200      	movs	r2, #0
 801dcb0:	f000 f96c 	bl	801df8c <make_sys_node>
 801dcb4:	4603      	mov	r3, r0
 801dcb6:	e01c      	b.n	801dcf2 <proc_unary_expr+0xfa>

    case finsh_token_type_mul: /* * */
        cast = proc_cast_expr(self);
 801dcb8:	6878      	ldr	r0, [r7, #4]
 801dcba:	f7ff ff63 	bl	801db84 <proc_cast_expr>
 801dcbe:	60b8      	str	r0, [r7, #8]
        return make_sys_node(FINSH_NODE_SYS_GETVALUE, cast, NULL);
 801dcc0:	2019      	movs	r0, #25
 801dcc2:	68b9      	ldr	r1, [r7, #8]
 801dcc4:	2200      	movs	r2, #0
 801dcc6:	f000 f961 	bl	801df8c <make_sys_node>
 801dcca:	4603      	mov	r3, r0
 801dccc:	e011      	b.n	801dcf2 <proc_unary_expr+0xfa>

    case finsh_token_type_and: /* & */
        cast = proc_cast_expr(self);
 801dcce:	6878      	ldr	r0, [r7, #4]
 801dcd0:	f7ff ff58 	bl	801db84 <proc_cast_expr>
 801dcd4:	60b8      	str	r0, [r7, #8]
        return make_sys_node(FINSH_NODE_SYS_GETADDR, cast, NULL);
 801dcd6:	201a      	movs	r0, #26
 801dcd8:	68b9      	ldr	r1, [r7, #8]
 801dcda:	2200      	movs	r2, #0
 801dcdc:	f000 f956 	bl	801df8c <make_sys_node>
 801dce0:	4603      	mov	r3, r0
 801dce2:	e006      	b.n	801dcf2 <proc_unary_expr+0xfa>

	default:
		finsh_token_replay(&(self->token));
 801dce4:	687b      	ldr	r3, [r7, #4]
 801dce6:	2201      	movs	r2, #1
 801dce8:	715a      	strb	r2, [r3, #5]
		return proc_postfix_expr(self);
 801dcea:	6878      	ldr	r0, [r7, #4]
 801dcec:	f000 f806 	bl	801dcfc <proc_postfix_expr>
 801dcf0:	4603      	mov	r3, r0
	}
}
 801dcf2:	4618      	mov	r0, r3
 801dcf4:	3710      	adds	r7, #16
 801dcf6:	46bd      	mov	sp, r7
 801dcf8:	bd80      	pop	{r7, pc}
 801dcfa:	bf00      	nop

0801dcfc <proc_postfix_expr>:
	| expr_postfix INC
	| expr_postfix DEC
	| expr_postfix '(' param_list ')'
*/
static struct finsh_node* proc_postfix_expr(struct finsh_parser* self)
{
 801dcfc:	b580      	push	{r7, lr}
 801dcfe:	b086      	sub	sp, #24
 801dd00:	af00      	add	r7, sp, #0
 801dd02:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);
 801dd04:	6878      	ldr	r0, [r7, #4]
 801dd06:	f000 f861 	bl	801ddcc <proc_primary_expr>
 801dd0a:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 801dd0c:	687b      	ldr	r3, [r7, #4]
 801dd0e:	3304      	adds	r3, #4
 801dd10:	4618      	mov	r0, r3
 801dd12:	f000 fb77 	bl	801e404 <finsh_token_token>
 801dd16:	4603      	mov	r3, r0
 801dd18:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_inc 	||
 801dd1a:	e046      	b.n	801ddaa <proc_postfix_expr+0xae>
		token == finsh_token_type_dec 		||
		token == finsh_token_type_left_paren )
	{
		switch (token)
 801dd1c:	7dfb      	ldrb	r3, [r7, #23]
 801dd1e:	2b07      	cmp	r3, #7
 801dd20:	d004      	beq.n	801dd2c <proc_postfix_expr+0x30>
 801dd22:	2b09      	cmp	r3, #9
 801dd24:	d009      	beq.n	801dd3a <proc_postfix_expr+0x3e>
 801dd26:	2b01      	cmp	r3, #1
 801dd28:	d00e      	beq.n	801dd48 <proc_postfix_expr+0x4c>
				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
			}
			break;

		default:
			break;
 801dd2a:	e037      	b.n	801dd9c <proc_postfix_expr+0xa0>
		token == finsh_token_type_left_paren )
	{
		switch (token)
		{
		case finsh_token_type_inc :/* '++' */
			postfix = make_sys_node(FINSH_NODE_SYS_INC, postfix, NULL);
 801dd2c:	2017      	movs	r0, #23
 801dd2e:	6939      	ldr	r1, [r7, #16]
 801dd30:	2200      	movs	r2, #0
 801dd32:	f000 f92b 	bl	801df8c <make_sys_node>
 801dd36:	6138      	str	r0, [r7, #16]
			break;
 801dd38:	e030      	b.n	801dd9c <proc_postfix_expr+0xa0>

		case finsh_token_type_dec :/* '--' */
			postfix = make_sys_node(FINSH_NODE_SYS_DEC, postfix, NULL);
 801dd3a:	2018      	movs	r0, #24
 801dd3c:	6939      	ldr	r1, [r7, #16]
 801dd3e:	2200      	movs	r2, #0
 801dd40:	f000 f924 	bl	801df8c <make_sys_node>
 801dd44:	6138      	str	r0, [r7, #16]
			break;
 801dd46:	e029      	b.n	801dd9c <proc_postfix_expr+0xa0>

		case finsh_token_type_left_paren :/* '(' */
			{
				struct finsh_node* param_list;

				param_list = NULL;
 801dd48:	2300      	movs	r3, #0
 801dd4a:	60fb      	str	r3, [r7, #12]
				next_token(token, &(self->token));
 801dd4c:	687b      	ldr	r3, [r7, #4]
 801dd4e:	3304      	adds	r3, #4
 801dd50:	4618      	mov	r0, r3
 801dd52:	f000 fb57 	bl	801e404 <finsh_token_token>
 801dd56:	4603      	mov	r3, r0
 801dd58:	75fb      	strb	r3, [r7, #23]
				if (token != finsh_token_type_right_paren)
 801dd5a:	7dfb      	ldrb	r3, [r7, #23]
 801dd5c:	2b02      	cmp	r3, #2
 801dd5e:	d016      	beq.n	801dd8e <proc_postfix_expr+0x92>
				{
					finsh_token_replay(&(self->token));
 801dd60:	687b      	ldr	r3, [r7, #4]
 801dd62:	2201      	movs	r2, #1
 801dd64:	715a      	strb	r2, [r3, #5]
					param_list = proc_param_list(self);
 801dd66:	6878      	ldr	r0, [r7, #4]
 801dd68:	f000 f8d6 	bl	801df18 <proc_param_list>
 801dd6c:	60f8      	str	r0, [r7, #12]

					match_token(token, &(self->token), finsh_token_type_right_paren);
 801dd6e:	687b      	ldr	r3, [r7, #4]
 801dd70:	3304      	adds	r3, #4
 801dd72:	4618      	mov	r0, r3
 801dd74:	f000 fb46 	bl	801e404 <finsh_token_token>
 801dd78:	4603      	mov	r3, r0
 801dd7a:	75fb      	strb	r3, [r7, #23]
 801dd7c:	7dfb      	ldrb	r3, [r7, #23]
 801dd7e:	2b02      	cmp	r3, #2
 801dd80:	d005      	beq.n	801dd8e <proc_postfix_expr+0x92>
 801dd82:	2001      	movs	r0, #1
 801dd84:	f7fe f81a 	bl	801bdbc <finsh_error_set>
 801dd88:	687b      	ldr	r3, [r7, #4]
 801dd8a:	2201      	movs	r2, #1
 801dd8c:	715a      	strb	r2, [r3, #5]
				}

				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
 801dd8e:	2012      	movs	r0, #18
 801dd90:	6939      	ldr	r1, [r7, #16]
 801dd92:	68fa      	ldr	r2, [r7, #12]
 801dd94:	f000 f8fa 	bl	801df8c <make_sys_node>
 801dd98:	6138      	str	r0, [r7, #16]
			}
			break;
 801dd9a:	bf00      	nop

		default:
			break;
		}

		next_token(token, &(self->token));
 801dd9c:	687b      	ldr	r3, [r7, #4]
 801dd9e:	3304      	adds	r3, #4
 801dda0:	4618      	mov	r0, r3
 801dda2:	f000 fb2f 	bl	801e404 <finsh_token_token>
 801dda6:	4603      	mov	r3, r0
 801dda8:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_inc 	||
 801ddaa:	7dfb      	ldrb	r3, [r7, #23]
 801ddac:	2b07      	cmp	r3, #7
 801ddae:	d0b5      	beq.n	801dd1c <proc_postfix_expr+0x20>
 801ddb0:	7dfb      	ldrb	r3, [r7, #23]
 801ddb2:	2b09      	cmp	r3, #9
 801ddb4:	d0b2      	beq.n	801dd1c <proc_postfix_expr+0x20>
		token == finsh_token_type_dec 		||
 801ddb6:	7dfb      	ldrb	r3, [r7, #23]
 801ddb8:	2b01      	cmp	r3, #1
 801ddba:	d0af      	beq.n	801dd1c <proc_postfix_expr+0x20>
		}

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 801ddbc:	687b      	ldr	r3, [r7, #4]
 801ddbe:	2201      	movs	r2, #1
 801ddc0:	715a      	strb	r2, [r3, #5]
	return postfix;
 801ddc2:	693b      	ldr	r3, [r7, #16]
}
 801ddc4:	4618      	mov	r0, r3
 801ddc6:	3718      	adds	r7, #24
 801ddc8:	46bd      	mov	sp, r7
 801ddca:	bd80      	pop	{r7, pc}

0801ddcc <proc_primary_expr>:
expr_primary -> literal
	| '(' expr ')'
	| identifier
*/
static struct finsh_node* proc_primary_expr(struct finsh_parser* self)
{
 801ddcc:	b580      	push	{r7, lr}
 801ddce:	b08a      	sub	sp, #40	; 0x28
 801ddd0:	af00      	add	r7, sp, #0
 801ddd2:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* expr;

	next_token(token, &(self->token));
 801ddd4:	687b      	ldr	r3, [r7, #4]
 801ddd6:	3304      	adds	r3, #4
 801ddd8:	4618      	mov	r0, r3
 801ddda:	f000 fb13 	bl	801e404 <finsh_token_token>
 801ddde:	4603      	mov	r3, r0
 801dde0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	switch ( token )
 801dde4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801dde8:	3b01      	subs	r3, #1
 801ddea:	2b1e      	cmp	r3, #30
 801ddec:	f200 808b 	bhi.w	801df06 <proc_primary_expr+0x13a>
 801ddf0:	a201      	add	r2, pc, #4	; (adr r2, 801ddf8 <proc_primary_expr+0x2c>)
 801ddf2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ddf6:	bf00      	nop
 801ddf8:	0801de95 	.word	0x0801de95
 801ddfc:	0801df07 	.word	0x0801df07
 801de00:	0801df07 	.word	0x0801df07
 801de04:	0801df07 	.word	0x0801df07
 801de08:	0801df07 	.word	0x0801df07
 801de0c:	0801df07 	.word	0x0801df07
 801de10:	0801df07 	.word	0x0801df07
 801de14:	0801df07 	.word	0x0801df07
 801de18:	0801df07 	.word	0x0801df07
 801de1c:	0801df07 	.word	0x0801df07
 801de20:	0801df07 	.word	0x0801df07
 801de24:	0801df07 	.word	0x0801df07
 801de28:	0801df07 	.word	0x0801df07
 801de2c:	0801df07 	.word	0x0801df07
 801de30:	0801df07 	.word	0x0801df07
 801de34:	0801df07 	.word	0x0801df07
 801de38:	0801df07 	.word	0x0801df07
 801de3c:	0801df07 	.word	0x0801df07
 801de40:	0801df07 	.word	0x0801df07
 801de44:	0801df07 	.word	0x0801df07
 801de48:	0801df07 	.word	0x0801df07
 801de4c:	0801df07 	.word	0x0801df07
 801de50:	0801df07 	.word	0x0801df07
 801de54:	0801df07 	.word	0x0801df07
 801de58:	0801df07 	.word	0x0801df07
 801de5c:	0801dee1 	.word	0x0801dee1
 801de60:	0801dec5 	.word	0x0801dec5
 801de64:	0801ded3 	.word	0x0801ded3
 801de68:	0801deef 	.word	0x0801deef
 801de6c:	0801defd 	.word	0x0801defd
 801de70:	0801de75 	.word	0x0801de75
	{
	case finsh_token_type_identifier:
		{
			char id[FINSH_NAME_MAX + 1];

			finsh_token_replay(&(self->token));
 801de74:	687b      	ldr	r3, [r7, #4]
 801de76:	2201      	movs	r2, #1
 801de78:	715a      	strb	r2, [r3, #5]
			proc_identifier(self, id);
 801de7a:	f107 030c 	add.w	r3, r7, #12
 801de7e:	6878      	ldr	r0, [r7, #4]
 801de80:	4619      	mov	r1, r3
 801de82:	f7ff fc7f 	bl	801d784 <proc_identifier>
			return finsh_node_new_id(id);
 801de86:	f107 030c 	add.w	r3, r7, #12
 801de8a:	4618      	mov	r0, r3
 801de8c:	f7fe fa0a 	bl	801c2a4 <finsh_node_new_id>
 801de90:	4603      	mov	r3, r0
 801de92:	e03d      	b.n	801df10 <proc_primary_expr+0x144>
		}

	case finsh_token_type_left_paren:
		expr = proc_expr(self);
 801de94:	6878      	ldr	r0, [r7, #4]
 801de96:	f7ff fcc3 	bl	801d820 <proc_expr>
 801de9a:	6238      	str	r0, [r7, #32]
		match_token(token, &(self->token), finsh_token_type_right_paren);
 801de9c:	687b      	ldr	r3, [r7, #4]
 801de9e:	3304      	adds	r3, #4
 801dea0:	4618      	mov	r0, r3
 801dea2:	f000 faaf 	bl	801e404 <finsh_token_token>
 801dea6:	4603      	mov	r3, r0
 801dea8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 801deac:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801deb0:	2b02      	cmp	r3, #2
 801deb2:	d005      	beq.n	801dec0 <proc_primary_expr+0xf4>
 801deb4:	2001      	movs	r0, #1
 801deb6:	f7fd ff81 	bl	801bdbc <finsh_error_set>
 801deba:	687b      	ldr	r3, [r7, #4]
 801debc:	2201      	movs	r2, #1
 801debe:	715a      	strb	r2, [r3, #5]
		return expr;
 801dec0:	6a3b      	ldr	r3, [r7, #32]
 801dec2:	e025      	b.n	801df10 <proc_primary_expr+0x144>

	case finsh_token_type_value_int:
		return finsh_node_new_int(self->token.value.int_value);
 801dec4:	687b      	ldr	r3, [r7, #4]
 801dec6:	691b      	ldr	r3, [r3, #16]
 801dec8:	4618      	mov	r0, r3
 801deca:	f7fe fa5b 	bl	801c384 <finsh_node_new_int>
 801dece:	4603      	mov	r3, r0
 801ded0:	e01e      	b.n	801df10 <proc_primary_expr+0x144>

	case finsh_token_type_value_long:
		return finsh_node_new_long(self->token.value.long_value);
 801ded2:	687b      	ldr	r3, [r7, #4]
 801ded4:	691b      	ldr	r3, [r3, #16]
 801ded6:	4618      	mov	r0, r3
 801ded8:	f7fe fa6c 	bl	801c3b4 <finsh_node_new_long>
 801dedc:	4603      	mov	r3, r0
 801dede:	e017      	b.n	801df10 <proc_primary_expr+0x144>

	case finsh_token_type_value_char:
		return finsh_node_new_char(self->token.value.char_value);
 801dee0:	687b      	ldr	r3, [r7, #4]
 801dee2:	7c1b      	ldrb	r3, [r3, #16]
 801dee4:	4618      	mov	r0, r3
 801dee6:	f7fe fa33 	bl	801c350 <finsh_node_new_char>
 801deea:	4603      	mov	r3, r0
 801deec:	e010      	b.n	801df10 <proc_primary_expr+0x144>

	case finsh_token_type_value_string:
		return finsh_node_new_string((char*)self->token.string);
 801deee:	687b      	ldr	r3, [r7, #4]
 801def0:	3314      	adds	r3, #20
 801def2:	4618      	mov	r0, r3
 801def4:	f7fe fa76 	bl	801c3e4 <finsh_node_new_string>
 801def8:	4603      	mov	r3, r0
 801defa:	e009      	b.n	801df10 <proc_primary_expr+0x144>

	case finsh_token_type_value_null:
		return finsh_node_new_ptr(NULL);
 801defc:	2000      	movs	r0, #0
 801defe:	f7fe faa5 	bl	801c44c <finsh_node_new_ptr>
 801df02:	4603      	mov	r3, r0
 801df04:	e004      	b.n	801df10 <proc_primary_expr+0x144>

	default:
		finsh_error_set(FINSH_ERROR_INVALID_TOKEN);
 801df06:	2001      	movs	r0, #1
 801df08:	f7fd ff58 	bl	801bdbc <finsh_error_set>
		break;
 801df0c:	bf00      	nop
	}

	return NULL;
 801df0e:	2300      	movs	r3, #0
}
 801df10:	4618      	mov	r0, r3
 801df12:	3728      	adds	r7, #40	; 0x28
 801df14:	46bd      	mov	sp, r7
 801df16:	bd80      	pop	{r7, pc}

0801df18 <proc_param_list>:
param_list -> empty
	| expr_assign
	| param_list ',' expr_assign
*/
static struct finsh_node* proc_param_list(struct finsh_parser* self)
{
 801df18:	b580      	push	{r7, lr}
 801df1a:	b086      	sub	sp, #24
 801df1c:	af00      	add	r7, sp, #0
 801df1e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node *node, *assign;

	assign = proc_assign_expr(self);
 801df20:	6878      	ldr	r0, [r7, #4]
 801df22:	f7ff fc89 	bl	801d838 <proc_assign_expr>
 801df26:	6138      	str	r0, [r7, #16]
	if (assign == NULL) return NULL;
 801df28:	693b      	ldr	r3, [r7, #16]
 801df2a:	2b00      	cmp	r3, #0
 801df2c:	d101      	bne.n	801df32 <proc_param_list+0x1a>
 801df2e:	2300      	movs	r3, #0
 801df30:	e028      	b.n	801df84 <proc_param_list+0x6c>
	node = assign;
 801df32:	693b      	ldr	r3, [r7, #16]
 801df34:	60fb      	str	r3, [r7, #12]

	next_token(token, &(self->token));
 801df36:	687b      	ldr	r3, [r7, #4]
 801df38:	3304      	adds	r3, #4
 801df3a:	4618      	mov	r0, r3
 801df3c:	f000 fa62 	bl	801e404 <finsh_token_token>
 801df40:	4603      	mov	r3, r0
 801df42:	75fb      	strb	r3, [r7, #23]
	while (token == finsh_token_type_comma )
 801df44:	e017      	b.n	801df76 <proc_param_list+0x5e>
	{
		finsh_node_sibling(assign) = proc_assign_expr(self);
 801df46:	6878      	ldr	r0, [r7, #4]
 801df48:	f7ff fc76 	bl	801d838 <proc_assign_expr>
 801df4c:	4602      	mov	r2, r0
 801df4e:	693b      	ldr	r3, [r7, #16]
 801df50:	60da      	str	r2, [r3, #12]

		if (finsh_node_sibling(assign) != NULL)	assign = finsh_node_sibling(assign);
 801df52:	693b      	ldr	r3, [r7, #16]
 801df54:	68db      	ldr	r3, [r3, #12]
 801df56:	2b00      	cmp	r3, #0
 801df58:	d003      	beq.n	801df62 <proc_param_list+0x4a>
 801df5a:	693b      	ldr	r3, [r7, #16]
 801df5c:	68db      	ldr	r3, [r3, #12]
 801df5e:	613b      	str	r3, [r7, #16]
 801df60:	e002      	b.n	801df68 <proc_param_list+0x50>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 801df62:	2005      	movs	r0, #5
 801df64:	f7fd ff2a 	bl	801bdbc <finsh_error_set>

		next_token(token, &(self->token));
 801df68:	687b      	ldr	r3, [r7, #4]
 801df6a:	3304      	adds	r3, #4
 801df6c:	4618      	mov	r0, r3
 801df6e:	f000 fa49 	bl	801e404 <finsh_token_token>
 801df72:	4603      	mov	r3, r0
 801df74:	75fb      	strb	r3, [r7, #23]
	assign = proc_assign_expr(self);
	if (assign == NULL) return NULL;
	node = assign;

	next_token(token, &(self->token));
	while (token == finsh_token_type_comma )
 801df76:	7dfb      	ldrb	r3, [r7, #23]
 801df78:	2b03      	cmp	r3, #3
 801df7a:	d0e4      	beq.n	801df46 <proc_param_list+0x2e>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 801df7c:	687b      	ldr	r3, [r7, #4]
 801df7e:	2201      	movs	r2, #1
 801df80:	715a      	strb	r2, [r3, #5]

	return node;
 801df82:	68fb      	ldr	r3, [r7, #12]
}
 801df84:	4618      	mov	r0, r3
 801df86:	3718      	adds	r7, #24
 801df88:	46bd      	mov	sp, r7
 801df8a:	bd80      	pop	{r7, pc}

0801df8c <make_sys_node>:
node1__
       \
       node2
*/
static struct finsh_node* make_sys_node(u_char type, struct finsh_node* node1, struct finsh_node* node2)
{
 801df8c:	b580      	push	{r7, lr}
 801df8e:	b086      	sub	sp, #24
 801df90:	af00      	add	r7, sp, #0
 801df92:	4603      	mov	r3, r0
 801df94:	60b9      	str	r1, [r7, #8]
 801df96:	607a      	str	r2, [r7, #4]
 801df98:	73fb      	strb	r3, [r7, #15]
	struct finsh_node* node;

	node = finsh_node_allocate(type);
 801df9a:	7bfb      	ldrb	r3, [r7, #15]
 801df9c:	4618      	mov	r0, r3
 801df9e:	f7fe f94b 	bl	801c238 <finsh_node_allocate>
 801dfa2:	6178      	str	r0, [r7, #20]

	if ((node1 != NULL) && (node != NULL))
 801dfa4:	68bb      	ldr	r3, [r7, #8]
 801dfa6:	2b00      	cmp	r3, #0
 801dfa8:	d009      	beq.n	801dfbe <make_sys_node+0x32>
 801dfaa:	697b      	ldr	r3, [r7, #20]
 801dfac:	2b00      	cmp	r3, #0
 801dfae:	d006      	beq.n	801dfbe <make_sys_node+0x32>
	{
		finsh_node_child(node) = node1;
 801dfb0:	697b      	ldr	r3, [r7, #20]
 801dfb2:	68ba      	ldr	r2, [r7, #8]
 801dfb4:	611a      	str	r2, [r3, #16]
		finsh_node_sibling(node1) = node2;
 801dfb6:	68bb      	ldr	r3, [r7, #8]
 801dfb8:	687a      	ldr	r2, [r7, #4]
 801dfba:	60da      	str	r2, [r3, #12]
 801dfbc:	e002      	b.n	801dfc4 <make_sys_node+0x38>
	}
	else finsh_error_set(FINSH_ERROR_NULL_NODE);
 801dfbe:	200e      	movs	r0, #14
 801dfc0:	f7fd fefc 	bl	801bdbc <finsh_error_set>

	return node;
 801dfc4:	697b      	ldr	r3, [r7, #20]
}
 801dfc6:	4618      	mov	r0, r3
 801dfc8:	3718      	adds	r7, #24
 801dfca:	46bd      	mov	sp, r7
 801dfcc:	bd80      	pop	{r7, pc}
 801dfce:	bf00      	nop

0801dfd0 <finsh_parser_run>:

/*
start -> statement_expr | decl_variable
*/
void finsh_parser_run(struct finsh_parser* self, const u_char* string)
{
 801dfd0:	b580      	push	{r7, lr}
 801dfd2:	b084      	sub	sp, #16
 801dfd4:	af00      	add	r7, sp, #0
 801dfd6:	6078      	str	r0, [r7, #4]
 801dfd8:	6039      	str	r1, [r7, #0]
	enum finsh_token_type token;
	struct finsh_node *node;

    node = NULL;
 801dfda:	2300      	movs	r3, #0
 801dfdc:	60bb      	str	r3, [r7, #8]

	/* init parser */
	self->parser_string = (u_char*)string;
 801dfde:	687b      	ldr	r3, [r7, #4]
 801dfe0:	683a      	ldr	r2, [r7, #0]
 801dfe2:	601a      	str	r2, [r3, #0]

	/* init token */
	finsh_token_init(&(self->token), self->parser_string);
 801dfe4:	687b      	ldr	r3, [r7, #4]
 801dfe6:	1d1a      	adds	r2, r3, #4
 801dfe8:	687b      	ldr	r3, [r7, #4]
 801dfea:	681b      	ldr	r3, [r3, #0]
 801dfec:	4610      	mov	r0, r2
 801dfee:	4619      	mov	r1, r3
 801dff0:	f000 f9f6 	bl	801e3e0 <finsh_token_init>

	/* get next token */
	next_token(token, &(self->token));
 801dff4:	687b      	ldr	r3, [r7, #4]
 801dff6:	3304      	adds	r3, #4
 801dff8:	4618      	mov	r0, r3
 801dffa:	f000 fa03 	bl	801e404 <finsh_token_token>
 801dffe:	4603      	mov	r3, r0
 801e000:	73fb      	strb	r3, [r7, #15]
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
 801e002:	e089      	b.n	801e118 <finsh_parser_run+0x148>
	{
		switch (token)
 801e004:	7bfb      	ldrb	r3, [r7, #15]
 801e006:	2b1f      	cmp	r3, #31
 801e008:	d11f      	bne.n	801e04a <finsh_parser_run+0x7a>
		{
        case finsh_token_type_identifier:
            /* process expr_statement */
            finsh_token_replay(&(self->token));
 801e00a:	687b      	ldr	r3, [r7, #4]
 801e00c:	2201      	movs	r2, #1
 801e00e:	715a      	strb	r2, [r3, #5]

			if (self->root != NULL)
 801e010:	687b      	ldr	r3, [r7, #4]
 801e012:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 801e016:	2b00      	cmp	r3, #0
 801e018:	d00d      	beq.n	801e036 <finsh_parser_run+0x66>
			{
				finsh_node_sibling(node) = proc_expr_statement(self);
 801e01a:	6878      	ldr	r0, [r7, #4]
 801e01c:	f7ff fbd4 	bl	801d7c8 <proc_expr_statement>
 801e020:	4602      	mov	r2, r0
 801e022:	68bb      	ldr	r3, [r7, #8]
 801e024:	60da      	str	r2, [r3, #12]
				if (finsh_node_sibling(node) != NULL)
 801e026:	68bb      	ldr	r3, [r7, #8]
 801e028:	68db      	ldr	r3, [r3, #12]
 801e02a:	2b00      	cmp	r3, #0
 801e02c:	d00c      	beq.n	801e048 <finsh_parser_run+0x78>
					node = finsh_node_sibling(node);
 801e02e:	68bb      	ldr	r3, [r7, #8]
 801e030:	68db      	ldr	r3, [r3, #12]
 801e032:	60bb      	str	r3, [r7, #8]
			else
			{
            	node = proc_expr_statement(self);
				self->root = node;
			}
            break;
 801e034:	e063      	b.n	801e0fe <finsh_parser_run+0x12e>
				if (finsh_node_sibling(node) != NULL)
					node = finsh_node_sibling(node);
			}
			else
			{
            	node = proc_expr_statement(self);
 801e036:	6878      	ldr	r0, [r7, #4]
 801e038:	f7ff fbc6 	bl	801d7c8 <proc_expr_statement>
 801e03c:	60b8      	str	r0, [r7, #8]
				self->root = node;
 801e03e:	687b      	ldr	r3, [r7, #4]
 801e040:	68ba      	ldr	r2, [r7, #8]
 801e042:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			}
            break;
 801e046:	e05a      	b.n	801e0fe <finsh_parser_run+0x12e>
 801e048:	e059      	b.n	801e0fe <finsh_parser_run+0x12e>

		default:
            if (is_base_type(token) || token == finsh_token_type_unsigned)
 801e04a:	7bfb      	ldrb	r3, [r7, #15]
 801e04c:	2b14      	cmp	r3, #20
 801e04e:	d00e      	beq.n	801e06e <finsh_parser_run+0x9e>
 801e050:	7bfb      	ldrb	r3, [r7, #15]
 801e052:	2b15      	cmp	r3, #21
 801e054:	d00b      	beq.n	801e06e <finsh_parser_run+0x9e>
 801e056:	7bfb      	ldrb	r3, [r7, #15]
 801e058:	2b16      	cmp	r3, #22
 801e05a:	d008      	beq.n	801e06e <finsh_parser_run+0x9e>
 801e05c:	7bfb      	ldrb	r3, [r7, #15]
 801e05e:	2b17      	cmp	r3, #23
 801e060:	d005      	beq.n	801e06e <finsh_parser_run+0x9e>
 801e062:	7bfb      	ldrb	r3, [r7, #15]
 801e064:	2b18      	cmp	r3, #24
 801e066:	d002      	beq.n	801e06e <finsh_parser_run+0x9e>
 801e068:	7bfb      	ldrb	r3, [r7, #15]
 801e06a:	2b19      	cmp	r3, #25
 801e06c:	d11f      	bne.n	801e0ae <finsh_parser_run+0xde>
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));
 801e06e:	687b      	ldr	r3, [r7, #4]
 801e070:	2201      	movs	r2, #1
 801e072:	715a      	strb	r2, [r3, #5]

				if (self->root != NULL)
 801e074:	687b      	ldr	r3, [r7, #4]
 801e076:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 801e07a:	2b00      	cmp	r3, #0
 801e07c:	d00d      	beq.n	801e09a <finsh_parser_run+0xca>
				{
					finsh_node_sibling(node) = proc_variable_decl(self);
 801e07e:	6878      	ldr	r0, [r7, #4]
 801e080:	f7ff f952 	bl	801d328 <proc_variable_decl>
 801e084:	4602      	mov	r2, r0
 801e086:	68bb      	ldr	r3, [r7, #8]
 801e088:	60da      	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
 801e08a:	68bb      	ldr	r3, [r7, #8]
 801e08c:	68db      	ldr	r3, [r3, #12]
 801e08e:	2b00      	cmp	r3, #0
 801e090:	d00c      	beq.n	801e0ac <finsh_parser_run+0xdc>
						node = finsh_node_sibling(node);
 801e092:	68bb      	ldr	r3, [r7, #8]
 801e094:	68db      	ldr	r3, [r3, #12]
 801e096:	60bb      	str	r3, [r7, #8]
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
 801e098:	e030      	b.n	801e0fc <finsh_parser_run+0x12c>
					if (finsh_node_sibling(node) != NULL)
						node = finsh_node_sibling(node);
				}
				else
				{
					node = proc_variable_decl(self);
 801e09a:	6878      	ldr	r0, [r7, #4]
 801e09c:	f7ff f944 	bl	801d328 <proc_variable_decl>
 801e0a0:	60b8      	str	r0, [r7, #8]
					self->root = node;
 801e0a2:	687b      	ldr	r3, [r7, #4]
 801e0a4:	68ba      	ldr	r2, [r7, #8]
 801e0a6:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
 801e0aa:	e027      	b.n	801e0fc <finsh_parser_run+0x12c>
 801e0ac:	e026      	b.n	801e0fc <finsh_parser_run+0x12c>
				}
            }
            else
            {
            	/* process expr_statement */
                finsh_token_replay(&(self->token));
 801e0ae:	687b      	ldr	r3, [r7, #4]
 801e0b0:	2201      	movs	r2, #1
 801e0b2:	715a      	strb	r2, [r3, #5]

				if (self->root != NULL)
 801e0b4:	687b      	ldr	r3, [r7, #4]
 801e0b6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 801e0ba:	2b00      	cmp	r3, #0
 801e0bc:	d015      	beq.n	801e0ea <finsh_parser_run+0x11a>
				{
                    finsh_node_sibling(node) = proc_expr_statement(self);
 801e0be:	6878      	ldr	r0, [r7, #4]
 801e0c0:	f7ff fb82 	bl	801d7c8 <proc_expr_statement>
 801e0c4:	4602      	mov	r2, r0
 801e0c6:	68bb      	ldr	r3, [r7, #8]
 801e0c8:	60da      	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
 801e0ca:	68bb      	ldr	r3, [r7, #8]
 801e0cc:	68db      	ldr	r3, [r3, #12]
 801e0ce:	2b00      	cmp	r3, #0
 801e0d0:	d003      	beq.n	801e0da <finsh_parser_run+0x10a>
						node = finsh_node_sibling(node);
 801e0d2:	68bb      	ldr	r3, [r7, #8]
 801e0d4:	68db      	ldr	r3, [r3, #12]
 801e0d6:	60bb      	str	r3, [r7, #8]
 801e0d8:	e010      	b.n	801e0fc <finsh_parser_run+0x12c>
					else next_token(token, &(self->token));
 801e0da:	687b      	ldr	r3, [r7, #4]
 801e0dc:	3304      	adds	r3, #4
 801e0de:	4618      	mov	r0, r3
 801e0e0:	f000 f990 	bl	801e404 <finsh_token_token>
 801e0e4:	4603      	mov	r3, r0
 801e0e6:	73fb      	strb	r3, [r7, #15]
					node = proc_expr_statement(self);
					self->root = node;
				}
            }

			break;
 801e0e8:	e008      	b.n	801e0fc <finsh_parser_run+0x12c>
						node = finsh_node_sibling(node);
					else next_token(token, &(self->token));
				}
				else
				{
					node = proc_expr_statement(self);
 801e0ea:	6878      	ldr	r0, [r7, #4]
 801e0ec:	f7ff fb6c 	bl	801d7c8 <proc_expr_statement>
 801e0f0:	60b8      	str	r0, [r7, #8]
					self->root = node;
 801e0f2:	687b      	ldr	r3, [r7, #4]
 801e0f4:	68ba      	ldr	r2, [r7, #8]
 801e0f6:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
				}
            }

			break;
 801e0fa:	e7ff      	b.n	801e0fc <finsh_parser_run+0x12c>
 801e0fc:	bf00      	nop
		}

		/* no root found, break out */
		if (self->root == NULL) break;
 801e0fe:	687b      	ldr	r3, [r7, #4]
 801e100:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 801e104:	2b00      	cmp	r3, #0
 801e106:	d100      	bne.n	801e10a <finsh_parser_run+0x13a>
 801e108:	e00d      	b.n	801e126 <finsh_parser_run+0x156>

        /* get next token */
		next_token(token, &(self->token));
 801e10a:	687b      	ldr	r3, [r7, #4]
 801e10c:	3304      	adds	r3, #4
 801e10e:	4618      	mov	r0, r3
 801e110:	f000 f978 	bl	801e404 <finsh_token_token>
 801e114:	4603      	mov	r3, r0
 801e116:	73fb      	strb	r3, [r7, #15]
	/* init token */
	finsh_token_init(&(self->token), self->parser_string);

	/* get next token */
	next_token(token, &(self->token));
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
 801e118:	7bfb      	ldrb	r3, [r7, #15]
 801e11a:	2b21      	cmp	r3, #33	; 0x21
 801e11c:	d003      	beq.n	801e126 <finsh_parser_run+0x156>
 801e11e:	7bfb      	ldrb	r3, [r7, #15]
 801e120:	2b20      	cmp	r3, #32
 801e122:	f47f af6f 	bne.w	801e004 <finsh_parser_run+0x34>
		if (self->root == NULL) break;

        /* get next token */
		next_token(token, &(self->token));
	}
}
 801e126:	3710      	adds	r7, #16
 801e128:	46bd      	mov	sp, r7
 801e12a:	bd80      	pop	{r7, pc}

0801e12c <finsh_parser_init>:

int finsh_parser_init(struct finsh_parser* self)
{
 801e12c:	b580      	push	{r7, lr}
 801e12e:	b082      	sub	sp, #8
 801e130:	af00      	add	r7, sp, #0
 801e132:	6078      	str	r0, [r7, #4]
	memset(self, 0, sizeof(struct finsh_parser));
 801e134:	6878      	ldr	r0, [r7, #4]
 801e136:	2100      	movs	r1, #0
 801e138:	229c      	movs	r2, #156	; 0x9c
 801e13a:	f000 fffb 	bl	801f134 <memset>

	return 0;
 801e13e:	2300      	movs	r3, #0
}
 801e140:	4618      	mov	r0, r3
 801e142:	3708      	adds	r7, #8
 801e144:	46bd      	mov	sp, r7
 801e146:	bd80      	pop	{r7, pc}

0801e148 <finsh_var_init>:

struct finsh_var global_variable[FINSH_VARIABLE_MAX];
struct finsh_sysvar_item* global_sysvar_list;

int finsh_var_init()
{
 801e148:	b580      	push	{r7, lr}
 801e14a:	af00      	add	r7, sp, #0
	memset(global_variable, 0, sizeof(global_variable));
 801e14c:	4803      	ldr	r0, [pc, #12]	; (801e15c <finsh_var_init+0x14>)
 801e14e:	2100      	movs	r1, #0
 801e150:	22c0      	movs	r2, #192	; 0xc0
 801e152:	f000 ffef 	bl	801f134 <memset>

	return 0;
 801e156:	2300      	movs	r3, #0
}
 801e158:	4618      	mov	r0, r3
 801e15a:	bd80      	pop	{r7, pc}
 801e15c:	200128b4 	.word	0x200128b4

0801e160 <finsh_var_insert>:

int finsh_var_insert(const char* name, int type)
{
 801e160:	b580      	push	{r7, lr}
 801e162:	b084      	sub	sp, #16
 801e164:	af00      	add	r7, sp, #0
 801e166:	6078      	str	r0, [r7, #4]
 801e168:	6039      	str	r1, [r7, #0]
	int i, empty;

	empty = -1;
 801e16a:	f04f 33ff 	mov.w	r3, #4294967295
 801e16e:	60bb      	str	r3, [r7, #8]
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801e170:	2300      	movs	r3, #0
 801e172:	60fb      	str	r3, [r7, #12]
 801e174:	e025      	b.n	801e1c2 <finsh_var_insert+0x62>
	{
		/* there is a same name variable exist. */
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
 801e176:	68fa      	ldr	r2, [r7, #12]
 801e178:	4613      	mov	r3, r2
 801e17a:	005b      	lsls	r3, r3, #1
 801e17c:	4413      	add	r3, r2
 801e17e:	00db      	lsls	r3, r3, #3
 801e180:	4a23      	ldr	r2, [pc, #140]	; (801e210 <finsh_var_insert+0xb0>)
 801e182:	4413      	add	r3, r2
 801e184:	4618      	mov	r0, r3
 801e186:	6879      	ldr	r1, [r7, #4]
 801e188:	2210      	movs	r2, #16
 801e18a:	f001 fc93 	bl	801fab4 <strncmp>
 801e18e:	4603      	mov	r3, r0
 801e190:	2b00      	cmp	r3, #0
 801e192:	d102      	bne.n	801e19a <finsh_var_insert+0x3a>
			return -1;
 801e194:	f04f 33ff 	mov.w	r3, #4294967295
 801e198:	e036      	b.n	801e208 <finsh_var_insert+0xa8>

		if (global_variable[i].type == finsh_type_unknown && empty == -1)
 801e19a:	491d      	ldr	r1, [pc, #116]	; (801e210 <finsh_var_insert+0xb0>)
 801e19c:	68fa      	ldr	r2, [r7, #12]
 801e19e:	4613      	mov	r3, r2
 801e1a0:	005b      	lsls	r3, r3, #1
 801e1a2:	4413      	add	r3, r2
 801e1a4:	00db      	lsls	r3, r3, #3
 801e1a6:	440b      	add	r3, r1
 801e1a8:	3310      	adds	r3, #16
 801e1aa:	785b      	ldrb	r3, [r3, #1]
 801e1ac:	2b00      	cmp	r3, #0
 801e1ae:	d105      	bne.n	801e1bc <finsh_var_insert+0x5c>
 801e1b0:	68bb      	ldr	r3, [r7, #8]
 801e1b2:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e1b6:	d101      	bne.n	801e1bc <finsh_var_insert+0x5c>
		{
			empty = i;
 801e1b8:	68fb      	ldr	r3, [r7, #12]
 801e1ba:	60bb      	str	r3, [r7, #8]
int finsh_var_insert(const char* name, int type)
{
	int i, empty;

	empty = -1;
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801e1bc:	68fb      	ldr	r3, [r7, #12]
 801e1be:	3301      	adds	r3, #1
 801e1c0:	60fb      	str	r3, [r7, #12]
 801e1c2:	68fb      	ldr	r3, [r7, #12]
 801e1c4:	2b07      	cmp	r3, #7
 801e1c6:	ddd6      	ble.n	801e176 <finsh_var_insert+0x16>
			empty = i;
		}
	}

	/* there is no empty entry */
	if (empty == -1) return -1;
 801e1c8:	68bb      	ldr	r3, [r7, #8]
 801e1ca:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e1ce:	d102      	bne.n	801e1d6 <finsh_var_insert+0x76>
 801e1d0:	f04f 33ff 	mov.w	r3, #4294967295
 801e1d4:	e018      	b.n	801e208 <finsh_var_insert+0xa8>

	/* insert entry */
	strncpy(global_variable[empty].name, name, FINSH_NAME_MAX);
 801e1d6:	68ba      	ldr	r2, [r7, #8]
 801e1d8:	4613      	mov	r3, r2
 801e1da:	005b      	lsls	r3, r3, #1
 801e1dc:	4413      	add	r3, r2
 801e1de:	00db      	lsls	r3, r3, #3
 801e1e0:	4a0b      	ldr	r2, [pc, #44]	; (801e210 <finsh_var_insert+0xb0>)
 801e1e2:	4413      	add	r3, r2
 801e1e4:	4618      	mov	r0, r3
 801e1e6:	6879      	ldr	r1, [r7, #4]
 801e1e8:	2210      	movs	r2, #16
 801e1ea:	f001 fcaf 	bl	801fb4c <strncpy>
	global_variable[empty].type = type;
 801e1ee:	683b      	ldr	r3, [r7, #0]
 801e1f0:	b2d8      	uxtb	r0, r3
 801e1f2:	4907      	ldr	r1, [pc, #28]	; (801e210 <finsh_var_insert+0xb0>)
 801e1f4:	68ba      	ldr	r2, [r7, #8]
 801e1f6:	4613      	mov	r3, r2
 801e1f8:	005b      	lsls	r3, r3, #1
 801e1fa:	4413      	add	r3, r2
 801e1fc:	00db      	lsls	r3, r3, #3
 801e1fe:	440b      	add	r3, r1
 801e200:	3310      	adds	r3, #16
 801e202:	4602      	mov	r2, r0
 801e204:	705a      	strb	r2, [r3, #1]

	/* return the offset */
	return empty;
 801e206:	68bb      	ldr	r3, [r7, #8]
}
 801e208:	4618      	mov	r0, r3
 801e20a:	3710      	adds	r7, #16
 801e20c:	46bd      	mov	sp, r7
 801e20e:	bd80      	pop	{r7, pc}
 801e210:	200128b4 	.word	0x200128b4

0801e214 <finsh_var_lookup>:

	return 0;
}

struct finsh_var* finsh_var_lookup(const char* name)
{
 801e214:	b580      	push	{r7, lr}
 801e216:	b084      	sub	sp, #16
 801e218:	af00      	add	r7, sp, #0
 801e21a:	6078      	str	r0, [r7, #4]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801e21c:	2300      	movs	r3, #0
 801e21e:	60fb      	str	r3, [r7, #12]
 801e220:	e012      	b.n	801e248 <finsh_var_lookup+0x34>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
 801e222:	68fa      	ldr	r2, [r7, #12]
 801e224:	4613      	mov	r3, r2
 801e226:	005b      	lsls	r3, r3, #1
 801e228:	4413      	add	r3, r2
 801e22a:	00db      	lsls	r3, r3, #3
 801e22c:	4a10      	ldr	r2, [pc, #64]	; (801e270 <finsh_var_lookup+0x5c>)
 801e22e:	4413      	add	r3, r2
 801e230:	4618      	mov	r0, r3
 801e232:	6879      	ldr	r1, [r7, #4]
 801e234:	2210      	movs	r2, #16
 801e236:	f001 fc3d 	bl	801fab4 <strncmp>
 801e23a:	4603      	mov	r3, r0
 801e23c:	2b00      	cmp	r3, #0
 801e23e:	d100      	bne.n	801e242 <finsh_var_lookup+0x2e>
			break;
 801e240:	e005      	b.n	801e24e <finsh_var_lookup+0x3a>

struct finsh_var* finsh_var_lookup(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801e242:	68fb      	ldr	r3, [r7, #12]
 801e244:	3301      	adds	r3, #1
 801e246:	60fb      	str	r3, [r7, #12]
 801e248:	68fb      	ldr	r3, [r7, #12]
 801e24a:	2b07      	cmp	r3, #7
 801e24c:	dde9      	ble.n	801e222 <finsh_var_lookup+0xe>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return NULL;
 801e24e:	68fb      	ldr	r3, [r7, #12]
 801e250:	2b08      	cmp	r3, #8
 801e252:	d101      	bne.n	801e258 <finsh_var_lookup+0x44>
 801e254:	2300      	movs	r3, #0
 801e256:	e006      	b.n	801e266 <finsh_var_lookup+0x52>

	return &global_variable[i];
 801e258:	68fa      	ldr	r2, [r7, #12]
 801e25a:	4613      	mov	r3, r2
 801e25c:	005b      	lsls	r3, r3, #1
 801e25e:	4413      	add	r3, r2
 801e260:	00db      	lsls	r3, r3, #3
 801e262:	4a03      	ldr	r2, [pc, #12]	; (801e270 <finsh_var_lookup+0x5c>)
 801e264:	4413      	add	r3, r2
}
 801e266:	4618      	mov	r0, r3
 801e268:	3710      	adds	r7, #16
 801e26a:	46bd      	mov	sp, r7
 801e26c:	bd80      	pop	{r7, pc}
 801e26e:	bf00      	nop
 801e270:	200128b4 	.word	0x200128b4

0801e274 <finsh_sysvar_lookup>:
	}
}
#endif

struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
 801e274:	b590      	push	{r4, r7, lr}
 801e276:	b085      	sub	sp, #20
 801e278:	af00      	add	r7, sp, #0
 801e27a:	6078      	str	r0, [r7, #4]
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
 801e27c:	4b1b      	ldr	r3, [pc, #108]	; (801e2ec <finsh_sysvar_lookup+0x78>)
 801e27e:	681b      	ldr	r3, [r3, #0]
 801e280:	60fb      	str	r3, [r7, #12]
 801e282:	e00d      	b.n	801e2a0 <finsh_sysvar_lookup+0x2c>
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
	{
		if (strcmp(index->name, name) == 0)
 801e284:	68fb      	ldr	r3, [r7, #12]
 801e286:	681b      	ldr	r3, [r3, #0]
 801e288:	4618      	mov	r0, r3
 801e28a:	6879      	ldr	r1, [r7, #4]
 801e28c:	f7e2 f8cc 	bl	8000428 <strcmp>
 801e290:	4603      	mov	r3, r0
 801e292:	2b00      	cmp	r3, #0
 801e294:	d101      	bne.n	801e29a <finsh_sysvar_lookup+0x26>
			return index;
 801e296:	68fb      	ldr	r3, [r7, #12]
 801e298:	e023      	b.n	801e2e2 <finsh_sysvar_lookup+0x6e>
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
 801e29a:	68fb      	ldr	r3, [r7, #12]
 801e29c:	3310      	adds	r3, #16
 801e29e:	60fb      	str	r3, [r7, #12]
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
 801e2a0:	4b13      	ldr	r3, [pc, #76]	; (801e2f0 <finsh_sysvar_lookup+0x7c>)
 801e2a2:	681b      	ldr	r3, [r3, #0]
struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
 801e2a4:	68fa      	ldr	r2, [r7, #12]
 801e2a6:	429a      	cmp	r2, r3
 801e2a8:	d3ec      	bcc.n	801e284 <finsh_sysvar_lookup+0x10>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
 801e2aa:	4b12      	ldr	r3, [pc, #72]	; (801e2f4 <finsh_sysvar_lookup+0x80>)
 801e2ac:	681b      	ldr	r3, [r3, #0]
 801e2ae:	60bb      	str	r3, [r7, #8]
	while (item != NULL)
 801e2b0:	e013      	b.n	801e2da <finsh_sysvar_lookup+0x66>
	{
		if (strncmp(item->sysvar.name, name, strlen(name)) == 0)
 801e2b2:	68bb      	ldr	r3, [r7, #8]
 801e2b4:	685c      	ldr	r4, [r3, #4]
 801e2b6:	6878      	ldr	r0, [r7, #4]
 801e2b8:	f001 fbce 	bl	801fa58 <strlen>
 801e2bc:	4603      	mov	r3, r0
 801e2be:	4620      	mov	r0, r4
 801e2c0:	6879      	ldr	r1, [r7, #4]
 801e2c2:	461a      	mov	r2, r3
 801e2c4:	f001 fbf6 	bl	801fab4 <strncmp>
 801e2c8:	4603      	mov	r3, r0
 801e2ca:	2b00      	cmp	r3, #0
 801e2cc:	d102      	bne.n	801e2d4 <finsh_sysvar_lookup+0x60>
		{
			return &(item->sysvar);
 801e2ce:	68bb      	ldr	r3, [r7, #8]
 801e2d0:	3304      	adds	r3, #4
 801e2d2:	e006      	b.n	801e2e2 <finsh_sysvar_lookup+0x6e>
		}

		/* move to next item */
		item = item->next;
 801e2d4:	68bb      	ldr	r3, [r7, #8]
 801e2d6:	681b      	ldr	r3, [r3, #0]
 801e2d8:	60bb      	str	r3, [r7, #8]
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
	while (item != NULL)
 801e2da:	68bb      	ldr	r3, [r7, #8]
 801e2dc:	2b00      	cmp	r3, #0
 801e2de:	d1e8      	bne.n	801e2b2 <finsh_sysvar_lookup+0x3e>
		/* move to next item */
		item = item->next;
	}

	/* can't find variable */
	return NULL;
 801e2e0:	2300      	movs	r3, #0
}
 801e2e2:	4618      	mov	r0, r3
 801e2e4:	3714      	adds	r7, #20
 801e2e6:	46bd      	mov	sp, r7
 801e2e8:	bd90      	pop	{r4, r7, pc}
 801e2ea:	bf00      	nop
 801e2ec:	200121d4 	.word	0x200121d4
 801e2f0:	200121d8 	.word	0x200121d8
 801e2f4:	200128b0 	.word	0x200128b0

0801e2f8 <finsh_vm_run>:
/* syscall list, for dynamic system call register */
struct finsh_syscall_item* global_syscall_list = NULL;

// #define FINSH_VM_DISASSEMBLE
void finsh_vm_run()
{
 801e2f8:	b580      	push	{r7, lr}
 801e2fa:	b082      	sub	sp, #8
 801e2fc:	af00      	add	r7, sp, #0
	void finsh_disassemble();
	finsh_disassemble();
#endif

	/* set sp(stack pointer) to the beginning of stack */
	finsh_sp = &finsh_vm_stack[0];
 801e2fe:	4b12      	ldr	r3, [pc, #72]	; (801e348 <finsh_vm_run+0x50>)
 801e300:	4a12      	ldr	r2, [pc, #72]	; (801e34c <finsh_vm_run+0x54>)
 801e302:	601a      	str	r2, [r3, #0]

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];
 801e304:	4b12      	ldr	r3, [pc, #72]	; (801e350 <finsh_vm_run+0x58>)
 801e306:	4a13      	ldr	r2, [pc, #76]	; (801e354 <finsh_vm_run+0x5c>)
 801e308:	601a      	str	r2, [r3, #0]

	while ((finsh_pc - &text_segment[0] >= 0) &&
 801e30a:	e00b      	b.n	801e324 <finsh_vm_run+0x2c>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
	{
		/* get op */
		op = *finsh_pc++;
 801e30c:	4b10      	ldr	r3, [pc, #64]	; (801e350 <finsh_vm_run+0x58>)
 801e30e:	681b      	ldr	r3, [r3, #0]
 801e310:	1c5a      	adds	r2, r3, #1
 801e312:	490f      	ldr	r1, [pc, #60]	; (801e350 <finsh_vm_run+0x58>)
 801e314:	600a      	str	r2, [r1, #0]
 801e316:	781b      	ldrb	r3, [r3, #0]
 801e318:	71fb      	strb	r3, [r7, #7]

		/* call op function */
		op_table[op]();
 801e31a:	79fb      	ldrb	r3, [r7, #7]
 801e31c:	4a0e      	ldr	r2, [pc, #56]	; (801e358 <finsh_vm_run+0x60>)
 801e31e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e322:	4798      	blx	r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
 801e324:	4b0a      	ldr	r3, [pc, #40]	; (801e350 <finsh_vm_run+0x58>)
 801e326:	681b      	ldr	r3, [r3, #0]
 801e328:	461a      	mov	r2, r3
 801e32a:	4b0a      	ldr	r3, [pc, #40]	; (801e354 <finsh_vm_run+0x5c>)
 801e32c:	1ad3      	subs	r3, r2, r3
 801e32e:	2b00      	cmp	r3, #0
 801e330:	db06      	blt.n	801e340 <finsh_vm_run+0x48>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
 801e332:	4b07      	ldr	r3, [pc, #28]	; (801e350 <finsh_vm_run+0x58>)
 801e334:	681b      	ldr	r3, [r3, #0]
 801e336:	461a      	mov	r2, r3
 801e338:	4b06      	ldr	r3, [pc, #24]	; (801e354 <finsh_vm_run+0x5c>)
 801e33a:	1ad3      	subs	r3, r2, r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
 801e33c:	2b7f      	cmp	r3, #127	; 0x7f
 801e33e:	dde5      	ble.n	801e30c <finsh_vm_run+0x14>
		op = *finsh_pc++;

		/* call op function */
		op_table[op]();
	}
}
 801e340:	3708      	adds	r7, #8
 801e342:	46bd      	mov	sp, r7
 801e344:	bd80      	pop	{r7, pc}
 801e346:	bf00      	nop
 801e348:	20012af8 	.word	0x20012af8
 801e34c:	200129f4 	.word	0x200129f4
 801e350:	20012af4 	.word	0x20012af4
 801e354:	20012974 	.word	0x20012974
 801e358:	080259b4 	.word	0x080259b4

0801e35c <finsh_syscall_lookup>:
	return (struct finsh_sysvar*)ptr;
}
#endif

struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
 801e35c:	b590      	push	{r4, r7, lr}
 801e35e:	b085      	sub	sp, #20
 801e360:	af00      	add	r7, sp, #0
 801e362:	6078      	str	r0, [r7, #4]
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 801e364:	4b1b      	ldr	r3, [pc, #108]	; (801e3d4 <finsh_syscall_lookup+0x78>)
 801e366:	681b      	ldr	r3, [r3, #0]
 801e368:	60fb      	str	r3, [r7, #12]
 801e36a:	e00d      	b.n	801e388 <finsh_syscall_lookup+0x2c>
	{
		if (strcmp(index->name, name) == 0)
 801e36c:	68fb      	ldr	r3, [r7, #12]
 801e36e:	681b      	ldr	r3, [r3, #0]
 801e370:	4618      	mov	r0, r3
 801e372:	6879      	ldr	r1, [r7, #4]
 801e374:	f7e2 f858 	bl	8000428 <strcmp>
 801e378:	4603      	mov	r3, r0
 801e37a:	2b00      	cmp	r3, #0
 801e37c:	d101      	bne.n	801e382 <finsh_syscall_lookup+0x26>
			return index;
 801e37e:	68fb      	ldr	r3, [r7, #12]
 801e380:	e023      	b.n	801e3ca <finsh_syscall_lookup+0x6e>
struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 801e382:	68fb      	ldr	r3, [r7, #12]
 801e384:	330c      	adds	r3, #12
 801e386:	60fb      	str	r3, [r7, #12]
 801e388:	4b13      	ldr	r3, [pc, #76]	; (801e3d8 <finsh_syscall_lookup+0x7c>)
 801e38a:	681b      	ldr	r3, [r3, #0]
 801e38c:	68fa      	ldr	r2, [r7, #12]
 801e38e:	429a      	cmp	r2, r3
 801e390:	d3ec      	bcc.n	801e36c <finsh_syscall_lookup+0x10>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
 801e392:	4b12      	ldr	r3, [pc, #72]	; (801e3dc <finsh_syscall_lookup+0x80>)
 801e394:	681b      	ldr	r3, [r3, #0]
 801e396:	60bb      	str	r3, [r7, #8]
	while (item != NULL)
 801e398:	e013      	b.n	801e3c2 <finsh_syscall_lookup+0x66>
	{
		if (strncmp(item->syscall.name, name, strlen(name)) == 0)
 801e39a:	68bb      	ldr	r3, [r7, #8]
 801e39c:	685c      	ldr	r4, [r3, #4]
 801e39e:	6878      	ldr	r0, [r7, #4]
 801e3a0:	f001 fb5a 	bl	801fa58 <strlen>
 801e3a4:	4603      	mov	r3, r0
 801e3a6:	4620      	mov	r0, r4
 801e3a8:	6879      	ldr	r1, [r7, #4]
 801e3aa:	461a      	mov	r2, r3
 801e3ac:	f001 fb82 	bl	801fab4 <strncmp>
 801e3b0:	4603      	mov	r3, r0
 801e3b2:	2b00      	cmp	r3, #0
 801e3b4:	d102      	bne.n	801e3bc <finsh_syscall_lookup+0x60>
		{
			return &(item->syscall);
 801e3b6:	68bb      	ldr	r3, [r7, #8]
 801e3b8:	3304      	adds	r3, #4
 801e3ba:	e006      	b.n	801e3ca <finsh_syscall_lookup+0x6e>
		}

		item = item->next;
 801e3bc:	68bb      	ldr	r3, [r7, #8]
 801e3be:	681b      	ldr	r3, [r3, #0]
 801e3c0:	60bb      	str	r3, [r7, #8]
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
	while (item != NULL)
 801e3c2:	68bb      	ldr	r3, [r7, #8]
 801e3c4:	2b00      	cmp	r3, #0
 801e3c6:	d1e8      	bne.n	801e39a <finsh_syscall_lookup+0x3e>
		}

		item = item->next;
	}

	return NULL;
 801e3c8:	2300      	movs	r3, #0
}
 801e3ca:	4618      	mov	r0, r3
 801e3cc:	3714      	adds	r7, #20
 801e3ce:	46bd      	mov	sp, r7
 801e3d0:	bd90      	pop	{r4, r7, pc}
 801e3d2:	bf00      	nop
 801e3d4:	200121cc 	.word	0x200121cc
 801e3d8:	200121d0 	.word	0x200121d0
 801e3dc:	200121e8 	.word	0x200121e8

0801e3e0 <finsh_token_init>:
static void token_trim_space(struct finsh_token* self);
static char token_proc_char(struct finsh_token* self);
static int token_proc_escape(struct finsh_token* self);

void finsh_token_init(struct finsh_token* self, u_char* line)
{
 801e3e0:	b580      	push	{r7, lr}
 801e3e2:	b082      	sub	sp, #8
 801e3e4:	af00      	add	r7, sp, #0
 801e3e6:	6078      	str	r0, [r7, #4]
 801e3e8:	6039      	str	r1, [r7, #0]
	memset(self, 0, sizeof(struct finsh_token));
 801e3ea:	6878      	ldr	r0, [r7, #4]
 801e3ec:	2100      	movs	r1, #0
 801e3ee:	2294      	movs	r2, #148	; 0x94
 801e3f0:	f000 fea0 	bl	801f134 <memset>

	self->line = line;
 801e3f4:	687b      	ldr	r3, [r7, #4]
 801e3f6:	683a      	ldr	r2, [r7, #0]
 801e3f8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
 801e3fc:	3708      	adds	r7, #8
 801e3fe:	46bd      	mov	sp, r7
 801e400:	bd80      	pop	{r7, pc}
 801e402:	bf00      	nop

0801e404 <finsh_token_token>:

enum finsh_token_type finsh_token_token(struct finsh_token* self)
{
 801e404:	b580      	push	{r7, lr}
 801e406:	b082      	sub	sp, #8
 801e408:	af00      	add	r7, sp, #0
 801e40a:	6078      	str	r0, [r7, #4]
	if ( self->replay )	self->replay = 0;
 801e40c:	687b      	ldr	r3, [r7, #4]
 801e40e:	785b      	ldrb	r3, [r3, #1]
 801e410:	2b00      	cmp	r3, #0
 801e412:	d003      	beq.n	801e41c <finsh_token_token+0x18>
 801e414:	687b      	ldr	r3, [r7, #4]
 801e416:	2200      	movs	r2, #0
 801e418:	705a      	strb	r2, [r3, #1]
 801e41a:	e002      	b.n	801e422 <finsh_token_token+0x1e>
	else token_run(self);
 801e41c:	6878      	ldr	r0, [r7, #4]
 801e41e:	f000 f8a7 	bl	801e570 <token_run>

	return (enum finsh_token_type)self->current_token;
 801e422:	687b      	ldr	r3, [r7, #4]
 801e424:	7a1b      	ldrb	r3, [r3, #8]
}
 801e426:	4618      	mov	r0, r3
 801e428:	3708      	adds	r7, #8
 801e42a:	46bd      	mov	sp, r7
 801e42c:	bd80      	pop	{r7, pc}
 801e42e:	bf00      	nop

0801e430 <token_get_string>:
{
	strncpy((char*)token, (char*)self->string, FINSH_NAME_MAX);
}

int token_get_string(struct finsh_token* self, u_char* str)
{
 801e430:	b580      	push	{r7, lr}
 801e432:	b084      	sub	sp, #16
 801e434:	af00      	add	r7, sp, #0
 801e436:	6078      	str	r0, [r7, #4]
 801e438:	6039      	str	r1, [r7, #0]
	unsigned char *p=str;
 801e43a:	683b      	ldr	r3, [r7, #0]
 801e43c:	60fb      	str	r3, [r7, #12]
	char ch;

	ch = token_next_char(self);
 801e43e:	6878      	ldr	r0, [r7, #4]
 801e440:	f000 f84a 	bl	801e4d8 <token_next_char>
 801e444:	4603      	mov	r3, r0
 801e446:	72fb      	strb	r3, [r7, #11]
	if (is_eof(self)) return -1;
 801e448:	687b      	ldr	r3, [r7, #4]
 801e44a:	781b      	ldrb	r3, [r3, #0]
 801e44c:	2b00      	cmp	r3, #0
 801e44e:	d002      	beq.n	801e456 <token_get_string+0x26>
 801e450:	f04f 33ff 	mov.w	r3, #4294967295
 801e454:	e03c      	b.n	801e4d0 <token_get_string+0xa0>

	str[0] = '\0';
 801e456:	683b      	ldr	r3, [r7, #0]
 801e458:	2200      	movs	r2, #0
 801e45a:	701a      	strb	r2, [r3, #0]

	if ( is_digit(ch) )/*the first character of identifier is not a digit.*/
 801e45c:	7afb      	ldrb	r3, [r7, #11]
 801e45e:	2b2f      	cmp	r3, #47	; 0x2f
 801e460:	d908      	bls.n	801e474 <token_get_string+0x44>
 801e462:	7afb      	ldrb	r3, [r7, #11]
 801e464:	2b39      	cmp	r3, #57	; 0x39
 801e466:	d805      	bhi.n	801e474 <token_get_string+0x44>
	{
		token_prev_char(self);
 801e468:	6878      	ldr	r0, [r7, #4]
 801e46a:	f000 f869 	bl	801e540 <token_prev_char>
		return -1;
 801e46e:	f04f 33ff 	mov.w	r3, #4294967295
 801e472:	e02d      	b.n	801e4d0 <token_get_string+0xa0>
	}

	while (!is_separator(ch) && !is_eof(self))
 801e474:	e009      	b.n	801e48a <token_get_string+0x5a>
	{
		*p++ = ch;
 801e476:	68fb      	ldr	r3, [r7, #12]
 801e478:	1c5a      	adds	r2, r3, #1
 801e47a:	60fa      	str	r2, [r7, #12]
 801e47c:	7afa      	ldrb	r2, [r7, #11]
 801e47e:	701a      	strb	r2, [r3, #0]

		ch = token_next_char(self);
 801e480:	6878      	ldr	r0, [r7, #4]
 801e482:	f000 f829 	bl	801e4d8 <token_next_char>
 801e486:	4603      	mov	r3, r0
 801e488:	72fb      	strb	r3, [r7, #11]
	{
		token_prev_char(self);
		return -1;
	}

	while (!is_separator(ch) && !is_eof(self))
 801e48a:	7afb      	ldrb	r3, [r7, #11]
 801e48c:	2b60      	cmp	r3, #96	; 0x60
 801e48e:	d902      	bls.n	801e496 <token_get_string+0x66>
 801e490:	7afb      	ldrb	r3, [r7, #11]
 801e492:	2b7a      	cmp	r3, #122	; 0x7a
 801e494:	d90e      	bls.n	801e4b4 <token_get_string+0x84>
 801e496:	7afb      	ldrb	r3, [r7, #11]
 801e498:	2b40      	cmp	r3, #64	; 0x40
 801e49a:	d902      	bls.n	801e4a2 <token_get_string+0x72>
 801e49c:	7afb      	ldrb	r3, [r7, #11]
 801e49e:	2b5a      	cmp	r3, #90	; 0x5a
 801e4a0:	d908      	bls.n	801e4b4 <token_get_string+0x84>
 801e4a2:	7afb      	ldrb	r3, [r7, #11]
 801e4a4:	2b2f      	cmp	r3, #47	; 0x2f
 801e4a6:	d902      	bls.n	801e4ae <token_get_string+0x7e>
 801e4a8:	7afb      	ldrb	r3, [r7, #11]
 801e4aa:	2b39      	cmp	r3, #57	; 0x39
 801e4ac:	d902      	bls.n	801e4b4 <token_get_string+0x84>
 801e4ae:	7afb      	ldrb	r3, [r7, #11]
 801e4b0:	2b5f      	cmp	r3, #95	; 0x5f
 801e4b2:	d103      	bne.n	801e4bc <token_get_string+0x8c>
 801e4b4:	687b      	ldr	r3, [r7, #4]
 801e4b6:	781b      	ldrb	r3, [r3, #0]
 801e4b8:	2b00      	cmp	r3, #0
 801e4ba:	d0dc      	beq.n	801e476 <token_get_string+0x46>
	{
		*p++ = ch;

		ch = token_next_char(self);
	}
	self->eof = 0;
 801e4bc:	687b      	ldr	r3, [r7, #4]
 801e4be:	2200      	movs	r2, #0
 801e4c0:	701a      	strb	r2, [r3, #0]

	token_prev_char(self);
 801e4c2:	6878      	ldr	r0, [r7, #4]
 801e4c4:	f000 f83c 	bl	801e540 <token_prev_char>
	*p = '\0';
 801e4c8:	68fb      	ldr	r3, [r7, #12]
 801e4ca:	2200      	movs	r2, #0
 801e4cc:	701a      	strb	r2, [r3, #0]

	return 0;
 801e4ce:	2300      	movs	r3, #0
}
 801e4d0:	4618      	mov	r0, r3
 801e4d2:	3710      	adds	r7, #16
 801e4d4:	46bd      	mov	sp, r7
 801e4d6:	bd80      	pop	{r7, pc}

0801e4d8 <token_next_char>:

/*
get next character.
*/
static char token_next_char(struct finsh_token* self)
{
 801e4d8:	b590      	push	{r4, r7, lr}
 801e4da:	b083      	sub	sp, #12
 801e4dc:	af00      	add	r7, sp, #0
 801e4de:	6078      	str	r0, [r7, #4]
	if (self->eof) return '\0';
 801e4e0:	687b      	ldr	r3, [r7, #4]
 801e4e2:	781b      	ldrb	r3, [r3, #0]
 801e4e4:	2b00      	cmp	r3, #0
 801e4e6:	d001      	beq.n	801e4ec <token_next_char+0x14>
 801e4e8:	2300      	movs	r3, #0
 801e4ea:	e025      	b.n	801e538 <token_next_char+0x60>

	if (self->position == (int)strlen((char*)self->line) || self->line[self->position] =='\n')
 801e4ec:	687b      	ldr	r3, [r7, #4]
 801e4ee:	685c      	ldr	r4, [r3, #4]
 801e4f0:	687b      	ldr	r3, [r7, #4]
 801e4f2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801e4f6:	4618      	mov	r0, r3
 801e4f8:	f001 faae 	bl	801fa58 <strlen>
 801e4fc:	4603      	mov	r3, r0
 801e4fe:	429c      	cmp	r4, r3
 801e500:	d008      	beq.n	801e514 <token_next_char+0x3c>
 801e502:	687b      	ldr	r3, [r7, #4]
 801e504:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801e508:	687a      	ldr	r2, [r7, #4]
 801e50a:	6852      	ldr	r2, [r2, #4]
 801e50c:	4413      	add	r3, r2
 801e50e:	781b      	ldrb	r3, [r3, #0]
 801e510:	2b0a      	cmp	r3, #10
 801e512:	d107      	bne.n	801e524 <token_next_char+0x4c>
	{
			self->eof = 1;
 801e514:	687b      	ldr	r3, [r7, #4]
 801e516:	2201      	movs	r2, #1
 801e518:	701a      	strb	r2, [r3, #0]
			self->position = 0;
 801e51a:	687b      	ldr	r3, [r7, #4]
 801e51c:	2200      	movs	r2, #0
 801e51e:	605a      	str	r2, [r3, #4]
			return '\0';
 801e520:	2300      	movs	r3, #0
 801e522:	e009      	b.n	801e538 <token_next_char+0x60>
	}

	return self->line[self->position++];
 801e524:	687b      	ldr	r3, [r7, #4]
 801e526:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 801e52a:	687b      	ldr	r3, [r7, #4]
 801e52c:	685b      	ldr	r3, [r3, #4]
 801e52e:	1c58      	adds	r0, r3, #1
 801e530:	6879      	ldr	r1, [r7, #4]
 801e532:	6048      	str	r0, [r1, #4]
 801e534:	4413      	add	r3, r2
 801e536:	781b      	ldrb	r3, [r3, #0]
}
 801e538:	4618      	mov	r0, r3
 801e53a:	370c      	adds	r7, #12
 801e53c:	46bd      	mov	sp, r7
 801e53e:	bd90      	pop	{r4, r7, pc}

0801e540 <token_prev_char>:

static void token_prev_char(struct finsh_token* self)
{
 801e540:	b480      	push	{r7}
 801e542:	b083      	sub	sp, #12
 801e544:	af00      	add	r7, sp, #0
 801e546:	6078      	str	r0, [r7, #4]
	if ( self->eof ) return;
 801e548:	687b      	ldr	r3, [r7, #4]
 801e54a:	781b      	ldrb	r3, [r3, #0]
 801e54c:	2b00      	cmp	r3, #0
 801e54e:	d000      	beq.n	801e552 <token_prev_char+0x12>
 801e550:	e009      	b.n	801e566 <token_prev_char+0x26>

	if ( self->position == 0 ) return;
 801e552:	687b      	ldr	r3, [r7, #4]
 801e554:	685b      	ldr	r3, [r3, #4]
 801e556:	2b00      	cmp	r3, #0
 801e558:	d100      	bne.n	801e55c <token_prev_char+0x1c>
 801e55a:	e004      	b.n	801e566 <token_prev_char+0x26>
    else self->position--;
 801e55c:	687b      	ldr	r3, [r7, #4]
 801e55e:	685b      	ldr	r3, [r3, #4]
 801e560:	1e5a      	subs	r2, r3, #1
 801e562:	687b      	ldr	r3, [r7, #4]
 801e564:	605a      	str	r2, [r3, #4]
}
 801e566:	370c      	adds	r7, #12
 801e568:	46bd      	mov	sp, r7
 801e56a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e56e:	4770      	bx	lr

0801e570 <token_run>:

static void token_run(struct finsh_token* self)
{
 801e570:	b580      	push	{r7, lr}
 801e572:	b084      	sub	sp, #16
 801e574:	af00      	add	r7, sp, #0
 801e576:	6078      	str	r0, [r7, #4]
	char ch;

	token_trim_space(self); /* first trim space and tab. */
 801e578:	6878      	ldr	r0, [r7, #4]
 801e57a:	f000 f9c5 	bl	801e908 <token_trim_space>
	token_get_string(self, &(self->string[0]));
 801e57e:	687b      	ldr	r3, [r7, #4]
 801e580:	3310      	adds	r3, #16
 801e582:	6878      	ldr	r0, [r7, #4]
 801e584:	4619      	mov	r1, r3
 801e586:	f7ff ff53 	bl	801e430 <token_get_string>

	if ( is_eof(self) ) /*if it is eof, break;*/
 801e58a:	687b      	ldr	r3, [r7, #4]
 801e58c:	781b      	ldrb	r3, [r3, #0]
 801e58e:	2b00      	cmp	r3, #0
 801e590:	d003      	beq.n	801e59a <token_run+0x2a>
	{
		self->current_token = finsh_token_type_eof;
 801e592:	687b      	ldr	r3, [r7, #4]
 801e594:	2221      	movs	r2, #33	; 0x21
 801e596:	721a      	strb	r2, [r3, #8]
		return ;
 801e598:	e189      	b.n	801e8ae <token_run+0x33e>
	}

	if (self->string[0] != '\0') /*It is a key word or a identifier.*/
 801e59a:	687b      	ldr	r3, [r7, #4]
 801e59c:	7c1b      	ldrb	r3, [r3, #16]
 801e59e:	2b00      	cmp	r3, #0
 801e5a0:	d00d      	beq.n	801e5be <token_run+0x4e>
	{
		if ( !token_match_name(self, (char*)self->string) )
 801e5a2:	687b      	ldr	r3, [r7, #4]
 801e5a4:	3310      	adds	r3, #16
 801e5a6:	6878      	ldr	r0, [r7, #4]
 801e5a8:	4619      	mov	r1, r3
 801e5aa:	f000 f983 	bl	801e8b4 <token_match_name>
 801e5ae:	4603      	mov	r3, r0
 801e5b0:	2b00      	cmp	r3, #0
 801e5b2:	f040 817c 	bne.w	801e8ae <token_run+0x33e>
		{
			self->current_token = finsh_token_type_identifier;
 801e5b6:	687b      	ldr	r3, [r7, #4]
 801e5b8:	221f      	movs	r2, #31
 801e5ba:	721a      	strb	r2, [r3, #8]
 801e5bc:	e177      	b.n	801e8ae <token_run+0x33e>
		}
	}
	else/*It is a operator character.*/
	{
		ch = token_next_char(self);
 801e5be:	6878      	ldr	r0, [r7, #4]
 801e5c0:	f7ff ff8a 	bl	801e4d8 <token_next_char>
 801e5c4:	4603      	mov	r3, r0
 801e5c6:	73fb      	strb	r3, [r7, #15]

		switch ( ch )
 801e5c8:	7bfb      	ldrb	r3, [r7, #15]
 801e5ca:	3b22      	subs	r3, #34	; 0x22
 801e5cc:	2b5c      	cmp	r3, #92	; 0x5c
 801e5ce:	f200 815a 	bhi.w	801e886 <token_run+0x316>
 801e5d2:	a201      	add	r2, pc, #4	; (adr r2, 801e5d8 <token_run+0x68>)
 801e5d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e5d8:	0801e879 	.word	0x0801e879
 801e5dc:	0801e887 	.word	0x0801e887
 801e5e0:	0801e887 	.word	0x0801e887
 801e5e4:	0801e843 	.word	0x0801e843
 801e5e8:	0801e76d 	.word	0x0801e76d
 801e5ec:	0801e863 	.word	0x0801e863
 801e5f0:	0801e74d 	.word	0x0801e74d
 801e5f4:	0801e755 	.word	0x0801e755
 801e5f8:	0801e775 	.word	0x0801e775
 801e5fc:	0801e77d 	.word	0x0801e77d
 801e600:	0801e75d 	.word	0x0801e75d
 801e604:	0801e7a3 	.word	0x0801e7a3
 801e608:	0801e887 	.word	0x0801e887
 801e60c:	0801e7c9 	.word	0x0801e7c9
 801e610:	0801e887 	.word	0x0801e887
 801e614:	0801e887 	.word	0x0801e887
 801e618:	0801e887 	.word	0x0801e887
 801e61c:	0801e887 	.word	0x0801e887
 801e620:	0801e887 	.word	0x0801e887
 801e624:	0801e887 	.word	0x0801e887
 801e628:	0801e887 	.word	0x0801e887
 801e62c:	0801e887 	.word	0x0801e887
 801e630:	0801e887 	.word	0x0801e887
 801e634:	0801e887 	.word	0x0801e887
 801e638:	0801e887 	.word	0x0801e887
 801e63c:	0801e765 	.word	0x0801e765
 801e640:	0801e7ef 	.word	0x0801e7ef
 801e644:	0801e85b 	.word	0x0801e85b
 801e648:	0801e815 	.word	0x0801e815
 801e64c:	0801e887 	.word	0x0801e887
 801e650:	0801e887 	.word	0x0801e887
 801e654:	0801e887 	.word	0x0801e887
 801e658:	0801e887 	.word	0x0801e887
 801e65c:	0801e887 	.word	0x0801e887
 801e660:	0801e887 	.word	0x0801e887
 801e664:	0801e887 	.word	0x0801e887
 801e668:	0801e887 	.word	0x0801e887
 801e66c:	0801e887 	.word	0x0801e887
 801e670:	0801e887 	.word	0x0801e887
 801e674:	0801e887 	.word	0x0801e887
 801e678:	0801e887 	.word	0x0801e887
 801e67c:	0801e887 	.word	0x0801e887
 801e680:	0801e887 	.word	0x0801e887
 801e684:	0801e887 	.word	0x0801e887
 801e688:	0801e887 	.word	0x0801e887
 801e68c:	0801e887 	.word	0x0801e887
 801e690:	0801e887 	.word	0x0801e887
 801e694:	0801e887 	.word	0x0801e887
 801e698:	0801e887 	.word	0x0801e887
 801e69c:	0801e887 	.word	0x0801e887
 801e6a0:	0801e887 	.word	0x0801e887
 801e6a4:	0801e887 	.word	0x0801e887
 801e6a8:	0801e887 	.word	0x0801e887
 801e6ac:	0801e887 	.word	0x0801e887
 801e6b0:	0801e887 	.word	0x0801e887
 801e6b4:	0801e887 	.word	0x0801e887
 801e6b8:	0801e887 	.word	0x0801e887
 801e6bc:	0801e887 	.word	0x0801e887
 801e6c0:	0801e887 	.word	0x0801e887
 801e6c4:	0801e887 	.word	0x0801e887
 801e6c8:	0801e853 	.word	0x0801e853
 801e6cc:	0801e887 	.word	0x0801e887
 801e6d0:	0801e887 	.word	0x0801e887
 801e6d4:	0801e887 	.word	0x0801e887
 801e6d8:	0801e887 	.word	0x0801e887
 801e6dc:	0801e887 	.word	0x0801e887
 801e6e0:	0801e887 	.word	0x0801e887
 801e6e4:	0801e887 	.word	0x0801e887
 801e6e8:	0801e887 	.word	0x0801e887
 801e6ec:	0801e887 	.word	0x0801e887
 801e6f0:	0801e887 	.word	0x0801e887
 801e6f4:	0801e887 	.word	0x0801e887
 801e6f8:	0801e887 	.word	0x0801e887
 801e6fc:	0801e887 	.word	0x0801e887
 801e700:	0801e887 	.word	0x0801e887
 801e704:	0801e887 	.word	0x0801e887
 801e708:	0801e887 	.word	0x0801e887
 801e70c:	0801e887 	.word	0x0801e887
 801e710:	0801e887 	.word	0x0801e887
 801e714:	0801e887 	.word	0x0801e887
 801e718:	0801e887 	.word	0x0801e887
 801e71c:	0801e887 	.word	0x0801e887
 801e720:	0801e887 	.word	0x0801e887
 801e724:	0801e887 	.word	0x0801e887
 801e728:	0801e887 	.word	0x0801e887
 801e72c:	0801e887 	.word	0x0801e887
 801e730:	0801e887 	.word	0x0801e887
 801e734:	0801e887 	.word	0x0801e887
 801e738:	0801e887 	.word	0x0801e887
 801e73c:	0801e887 	.word	0x0801e887
 801e740:	0801e83b 	.word	0x0801e83b
 801e744:	0801e887 	.word	0x0801e887
 801e748:	0801e84b 	.word	0x0801e84b
		{
		case '(':
			self->current_token = finsh_token_type_left_paren;
 801e74c:	687b      	ldr	r3, [r7, #4]
 801e74e:	2201      	movs	r2, #1
 801e750:	721a      	strb	r2, [r3, #8]
			break;
 801e752:	e0ac      	b.n	801e8ae <token_run+0x33e>

		case ')':
			self->current_token = finsh_token_type_right_paren;
 801e754:	687b      	ldr	r3, [r7, #4]
 801e756:	2202      	movs	r2, #2
 801e758:	721a      	strb	r2, [r3, #8]
			break;
 801e75a:	e0a8      	b.n	801e8ae <token_run+0x33e>

		case ',':
			self->current_token = finsh_token_type_comma;
 801e75c:	687b      	ldr	r3, [r7, #4]
 801e75e:	2203      	movs	r2, #3
 801e760:	721a      	strb	r2, [r3, #8]
			break;
 801e762:	e0a4      	b.n	801e8ae <token_run+0x33e>

		case ';':
			self->current_token = finsh_token_type_semicolon;
 801e764:	687b      	ldr	r3, [r7, #4]
 801e766:	2204      	movs	r2, #4
 801e768:	721a      	strb	r2, [r3, #8]
			break;
 801e76a:	e0a0      	b.n	801e8ae <token_run+0x33e>

		case '&':
			self->current_token = finsh_token_type_and;
 801e76c:	687b      	ldr	r3, [r7, #4]
 801e76e:	220d      	movs	r2, #13
 801e770:	721a      	strb	r2, [r3, #8]
			break;
 801e772:	e09c      	b.n	801e8ae <token_run+0x33e>

		case '*':
			self->current_token = finsh_token_type_mul;
 801e774:	687b      	ldr	r3, [r7, #4]
 801e776:	2205      	movs	r2, #5
 801e778:	721a      	strb	r2, [r3, #8]
			break;
 801e77a:	e098      	b.n	801e8ae <token_run+0x33e>

		case '+':
			ch = token_next_char(self);
 801e77c:	6878      	ldr	r0, [r7, #4]
 801e77e:	f7ff feab 	bl	801e4d8 <token_next_char>
 801e782:	4603      	mov	r3, r0
 801e784:	73fb      	strb	r3, [r7, #15]

			if ( ch == '+' )
 801e786:	7bfb      	ldrb	r3, [r7, #15]
 801e788:	2b2b      	cmp	r3, #43	; 0x2b
 801e78a:	d103      	bne.n	801e794 <token_run+0x224>
			{
				self->current_token = finsh_token_type_inc;
 801e78c:	687b      	ldr	r3, [r7, #4]
 801e78e:	2207      	movs	r2, #7
 801e790:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_add;
			}
			break;
 801e792:	e08c      	b.n	801e8ae <token_run+0x33e>
			{
				self->current_token = finsh_token_type_inc;
			}
			else
			{
				token_prev_char(self);
 801e794:	6878      	ldr	r0, [r7, #4]
 801e796:	f7ff fed3 	bl	801e540 <token_prev_char>
				self->current_token = finsh_token_type_add;
 801e79a:	687b      	ldr	r3, [r7, #4]
 801e79c:	2206      	movs	r2, #6
 801e79e:	721a      	strb	r2, [r3, #8]
			}
			break;
 801e7a0:	e085      	b.n	801e8ae <token_run+0x33e>

		case '-':
			ch = token_next_char(self);
 801e7a2:	6878      	ldr	r0, [r7, #4]
 801e7a4:	f7ff fe98 	bl	801e4d8 <token_next_char>
 801e7a8:	4603      	mov	r3, r0
 801e7aa:	73fb      	strb	r3, [r7, #15]

			if ( ch == '-' )
 801e7ac:	7bfb      	ldrb	r3, [r7, #15]
 801e7ae:	2b2d      	cmp	r3, #45	; 0x2d
 801e7b0:	d103      	bne.n	801e7ba <token_run+0x24a>
			{
				self->current_token = finsh_token_type_dec;
 801e7b2:	687b      	ldr	r3, [r7, #4]
 801e7b4:	2209      	movs	r2, #9
 801e7b6:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_sub;
			}
			break;
 801e7b8:	e079      	b.n	801e8ae <token_run+0x33e>
			{
				self->current_token = finsh_token_type_dec;
			}
			else
			{
				token_prev_char(self);
 801e7ba:	6878      	ldr	r0, [r7, #4]
 801e7bc:	f7ff fec0 	bl	801e540 <token_prev_char>
				self->current_token = finsh_token_type_sub;
 801e7c0:	687b      	ldr	r3, [r7, #4]
 801e7c2:	2208      	movs	r2, #8
 801e7c4:	721a      	strb	r2, [r3, #8]
			}
			break;
 801e7c6:	e072      	b.n	801e8ae <token_run+0x33e>

		case '/':
			ch = token_next_char(self);
 801e7c8:	6878      	ldr	r0, [r7, #4]
 801e7ca:	f7ff fe85 	bl	801e4d8 <token_next_char>
 801e7ce:	4603      	mov	r3, r0
 801e7d0:	73fb      	strb	r3, [r7, #15]
			if (ch == '/')
 801e7d2:	7bfb      	ldrb	r3, [r7, #15]
 801e7d4:	2b2f      	cmp	r3, #47	; 0x2f
 801e7d6:	d103      	bne.n	801e7e0 <token_run+0x270>
			{
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
 801e7d8:	687b      	ldr	r3, [r7, #4]
 801e7da:	2221      	movs	r2, #33	; 0x21
 801e7dc:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_div;
			}
			break;
 801e7de:	e066      	b.n	801e8ae <token_run+0x33e>
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
			}
			else
			{
				token_prev_char(self);
 801e7e0:	6878      	ldr	r0, [r7, #4]
 801e7e2:	f7ff fead 	bl	801e540 <token_prev_char>
				self->current_token = finsh_token_type_div;
 801e7e6:	687b      	ldr	r3, [r7, #4]
 801e7e8:	220a      	movs	r2, #10
 801e7ea:	721a      	strb	r2, [r3, #8]
			}
			break;
 801e7ec:	e05f      	b.n	801e8ae <token_run+0x33e>

		case '<':
			ch = token_next_char(self);
 801e7ee:	6878      	ldr	r0, [r7, #4]
 801e7f0:	f7ff fe72 	bl	801e4d8 <token_next_char>
 801e7f4:	4603      	mov	r3, r0
 801e7f6:	73fb      	strb	r3, [r7, #15]

			if ( ch == '<' )
 801e7f8:	7bfb      	ldrb	r3, [r7, #15]
 801e7fa:	2b3c      	cmp	r3, #60	; 0x3c
 801e7fc:	d103      	bne.n	801e806 <token_run+0x296>
			{
				self->current_token = finsh_token_type_shl;
 801e7fe:	687b      	ldr	r3, [r7, #4]
 801e800:	2211      	movs	r2, #17
 801e802:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
 801e804:	e053      	b.n	801e8ae <token_run+0x33e>
			{
				self->current_token = finsh_token_type_shl;
			}
			else
			{
				token_prev_char(self);
 801e806:	6878      	ldr	r0, [r7, #4]
 801e808:	f7ff fe9a 	bl	801e540 <token_prev_char>
				self->current_token = finsh_token_type_bad;
 801e80c:	687b      	ldr	r3, [r7, #4]
 801e80e:	2220      	movs	r2, #32
 801e810:	721a      	strb	r2, [r3, #8]
			}
			break;
 801e812:	e04c      	b.n	801e8ae <token_run+0x33e>

		case '>':
			ch = token_next_char(self);
 801e814:	6878      	ldr	r0, [r7, #4]
 801e816:	f7ff fe5f 	bl	801e4d8 <token_next_char>
 801e81a:	4603      	mov	r3, r0
 801e81c:	73fb      	strb	r3, [r7, #15]

			if ( ch == '>' )
 801e81e:	7bfb      	ldrb	r3, [r7, #15]
 801e820:	2b3e      	cmp	r3, #62	; 0x3e
 801e822:	d103      	bne.n	801e82c <token_run+0x2bc>
			{
				self->current_token = finsh_token_type_shr;
 801e824:	687b      	ldr	r3, [r7, #4]
 801e826:	2212      	movs	r2, #18
 801e828:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
 801e82a:	e040      	b.n	801e8ae <token_run+0x33e>
			{
				self->current_token = finsh_token_type_shr;
			}
			else
			{
				token_prev_char(self);
 801e82c:	6878      	ldr	r0, [r7, #4]
 801e82e:	f7ff fe87 	bl	801e540 <token_prev_char>
				self->current_token = finsh_token_type_bad;
 801e832:	687b      	ldr	r3, [r7, #4]
 801e834:	2220      	movs	r2, #32
 801e836:	721a      	strb	r2, [r3, #8]
			}
			break;
 801e838:	e039      	b.n	801e8ae <token_run+0x33e>

		case '|':
			self->current_token = finsh_token_type_or;
 801e83a:	687b      	ldr	r3, [r7, #4]
 801e83c:	220e      	movs	r2, #14
 801e83e:	721a      	strb	r2, [r3, #8]
			break;
 801e840:	e035      	b.n	801e8ae <token_run+0x33e>

		case '%':
			self->current_token = finsh_token_type_mod;
 801e842:	687b      	ldr	r3, [r7, #4]
 801e844:	220b      	movs	r2, #11
 801e846:	721a      	strb	r2, [r3, #8]
			break;
 801e848:	e031      	b.n	801e8ae <token_run+0x33e>

		case '~':
			self->current_token = finsh_token_type_bitwise;
 801e84a:	687b      	ldr	r3, [r7, #4]
 801e84c:	2210      	movs	r2, #16
 801e84e:	721a      	strb	r2, [r3, #8]
			break;
 801e850:	e02d      	b.n	801e8ae <token_run+0x33e>

		case '^':
			self->current_token = finsh_token_type_xor;
 801e852:	687b      	ldr	r3, [r7, #4]
 801e854:	220f      	movs	r2, #15
 801e856:	721a      	strb	r2, [r3, #8]
			break;
 801e858:	e029      	b.n	801e8ae <token_run+0x33e>

		case '=':
			self->current_token = finsh_token_type_assign;
 801e85a:	687b      	ldr	r3, [r7, #4]
 801e85c:	220c      	movs	r2, #12
 801e85e:	721a      	strb	r2, [r3, #8]
			break;
 801e860:	e025      	b.n	801e8ae <token_run+0x33e>

		case '\'':
			self->value.char_value = token_proc_char(self);
 801e862:	6878      	ldr	r0, [r7, #4]
 801e864:	f000 f868 	bl	801e938 <token_proc_char>
 801e868:	4603      	mov	r3, r0
 801e86a:	461a      	mov	r2, r3
 801e86c:	687b      	ldr	r3, [r7, #4]
 801e86e:	731a      	strb	r2, [r3, #12]
			self->current_token = finsh_token_type_value_char;
 801e870:	687b      	ldr	r3, [r7, #4]
 801e872:	221a      	movs	r2, #26
 801e874:	721a      	strb	r2, [r3, #8]
			break;
 801e876:	e01a      	b.n	801e8ae <token_run+0x33e>

		case '"':
			token_proc_string(self);
 801e878:	6878      	ldr	r0, [r7, #4]
 801e87a:	f000 f8c9 	bl	801ea10 <token_proc_string>
			self->current_token = finsh_token_type_value_string;
 801e87e:	687b      	ldr	r3, [r7, #4]
 801e880:	221d      	movs	r2, #29
 801e882:	721a      	strb	r2, [r3, #8]
			break;
 801e884:	e013      	b.n	801e8ae <token_run+0x33e>

		default:
			if ( is_digit(ch) )
 801e886:	7bfb      	ldrb	r3, [r7, #15]
 801e888:	2b2f      	cmp	r3, #47	; 0x2f
 801e88a:	d909      	bls.n	801e8a0 <token_run+0x330>
 801e88c:	7bfb      	ldrb	r3, [r7, #15]
 801e88e:	2b39      	cmp	r3, #57	; 0x39
 801e890:	d806      	bhi.n	801e8a0 <token_run+0x330>
			{
				token_prev_char(self);
 801e892:	6878      	ldr	r0, [r7, #4]
 801e894:	f7ff fe54 	bl	801e540 <token_prev_char>
				token_proc_number(self);
 801e898:	6878      	ldr	r0, [r7, #4]
 801e89a:	f000 f983 	bl	801eba4 <token_proc_number>
				break;
 801e89e:	e006      	b.n	801e8ae <token_run+0x33e>
			}

			finsh_error_set(FINSH_ERROR_UNKNOWN_TOKEN);
 801e8a0:	200b      	movs	r0, #11
 801e8a2:	f7fd fa8b 	bl	801bdbc <finsh_error_set>
			self->current_token = finsh_token_type_bad;
 801e8a6:	687b      	ldr	r3, [r7, #4]
 801e8a8:	2220      	movs	r2, #32
 801e8aa:	721a      	strb	r2, [r3, #8]

			break;
 801e8ac:	bf00      	nop
		}
	}
}
 801e8ae:	3710      	adds	r7, #16
 801e8b0:	46bd      	mov	sp, r7
 801e8b2:	bd80      	pop	{r7, pc}

0801e8b4 <token_match_name>:

static int token_match_name(struct finsh_token* self, const char* str)
{
 801e8b4:	b580      	push	{r7, lr}
 801e8b6:	b084      	sub	sp, #16
 801e8b8:	af00      	add	r7, sp, #0
 801e8ba:	6078      	str	r0, [r7, #4]
 801e8bc:	6039      	str	r1, [r7, #0]
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
 801e8be:	2300      	movs	r3, #0
 801e8c0:	60fb      	str	r3, [r7, #12]
 801e8c2:	e016      	b.n	801e8f2 <token_match_name+0x3e>
	{
		if ( strcmp(finsh_name_table[i].name, str)==0 )
 801e8c4:	4a0f      	ldr	r2, [pc, #60]	; (801e904 <token_match_name+0x50>)
 801e8c6:	68fb      	ldr	r3, [r7, #12]
 801e8c8:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 801e8cc:	4618      	mov	r0, r3
 801e8ce:	6839      	ldr	r1, [r7, #0]
 801e8d0:	f7e1 fdaa 	bl	8000428 <strcmp>
 801e8d4:	4603      	mov	r3, r0
 801e8d6:	2b00      	cmp	r3, #0
 801e8d8:	d108      	bne.n	801e8ec <token_match_name+0x38>
		{
			self->current_token = finsh_name_table[i].type;
 801e8da:	4a0a      	ldr	r2, [pc, #40]	; (801e904 <token_match_name+0x50>)
 801e8dc:	68fb      	ldr	r3, [r7, #12]
 801e8de:	00db      	lsls	r3, r3, #3
 801e8e0:	4413      	add	r3, r2
 801e8e2:	791a      	ldrb	r2, [r3, #4]
 801e8e4:	687b      	ldr	r3, [r7, #4]
 801e8e6:	721a      	strb	r2, [r3, #8]
			return 1;
 801e8e8:	2301      	movs	r3, #1
 801e8ea:	e006      	b.n	801e8fa <token_match_name+0x46>

static int token_match_name(struct finsh_token* self, const char* str)
{
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
 801e8ec:	68fb      	ldr	r3, [r7, #12]
 801e8ee:	3301      	adds	r3, #1
 801e8f0:	60fb      	str	r3, [r7, #12]
 801e8f2:	68fb      	ldr	r3, [r7, #12]
 801e8f4:	2b07      	cmp	r3, #7
 801e8f6:	d9e5      	bls.n	801e8c4 <token_match_name+0x10>
			self->current_token = finsh_name_table[i].type;
			return 1;
		}
	}

	return 0;
 801e8f8:	2300      	movs	r3, #0
}
 801e8fa:	4618      	mov	r0, r3
 801e8fc:	3710      	adds	r7, #16
 801e8fe:	46bd      	mov	sp, r7
 801e900:	bd80      	pop	{r7, pc}
 801e902:	bf00      	nop
 801e904:	08025a78 	.word	0x08025a78

0801e908 <token_trim_space>:

static void token_trim_space(struct finsh_token* self)
{
 801e908:	b580      	push	{r7, lr}
 801e90a:	b084      	sub	sp, #16
 801e90c:	af00      	add	r7, sp, #0
 801e90e:	6078      	str	r0, [r7, #4]
	char ch;
	while ( (ch = token_next_char(self)) ==' ' || 
 801e910:	6878      	ldr	r0, [r7, #4]
 801e912:	f7ff fde1 	bl	801e4d8 <token_next_char>
 801e916:	4603      	mov	r3, r0
 801e918:	73fb      	strb	r3, [r7, #15]
 801e91a:	7bfb      	ldrb	r3, [r7, #15]
 801e91c:	2b20      	cmp	r3, #32
 801e91e:	d0f7      	beq.n	801e910 <token_trim_space+0x8>
 801e920:	7bfb      	ldrb	r3, [r7, #15]
 801e922:	2b09      	cmp	r3, #9
 801e924:	d0f4      	beq.n	801e910 <token_trim_space+0x8>
        ch == '\t' || 
 801e926:	7bfb      	ldrb	r3, [r7, #15]
 801e928:	2b0d      	cmp	r3, #13
 801e92a:	d0f1      	beq.n	801e910 <token_trim_space+0x8>
        ch == '\r');

	token_prev_char(self);
 801e92c:	6878      	ldr	r0, [r7, #4]
 801e92e:	f7ff fe07 	bl	801e540 <token_prev_char>
}
 801e932:	3710      	adds	r7, #16
 801e934:	46bd      	mov	sp, r7
 801e936:	bd80      	pop	{r7, pc}

0801e938 <token_proc_char>:

static char token_proc_char(struct finsh_token* self)
{
 801e938:	b580      	push	{r7, lr}
 801e93a:	b086      	sub	sp, #24
 801e93c:	af00      	add	r7, sp, #0
 801e93e:	6078      	str	r0, [r7, #4]
	char ch;
	char buf[4], *p;

	p = buf;
 801e940:	f107 030c 	add.w	r3, r7, #12
 801e944:	613b      	str	r3, [r7, #16]
	ch = token_next_char(self);
 801e946:	6878      	ldr	r0, [r7, #4]
 801e948:	f7ff fdc6 	bl	801e4d8 <token_next_char>
 801e94c:	4603      	mov	r3, r0
 801e94e:	75fb      	strb	r3, [r7, #23]

	if ( ch == '\\' )
 801e950:	7dfb      	ldrb	r3, [r7, #23]
 801e952:	2b5c      	cmp	r3, #92	; 0x5c
 801e954:	d149      	bne.n	801e9ea <token_proc_char+0xb2>
	{
		ch = token_next_char(self);
 801e956:	6878      	ldr	r0, [r7, #4]
 801e958:	f7ff fdbe 	bl	801e4d8 <token_next_char>
 801e95c:	4603      	mov	r3, r0
 801e95e:	75fb      	strb	r3, [r7, #23]
		switch ( ch )
 801e960:	7dfb      	ldrb	r3, [r7, #23]
 801e962:	2b6e      	cmp	r3, #110	; 0x6e
 801e964:	d00f      	beq.n	801e986 <token_proc_char+0x4e>
 801e966:	2b6e      	cmp	r3, #110	; 0x6e
 801e968:	dc06      	bgt.n	801e978 <token_proc_char+0x40>
 801e96a:	2b5c      	cmp	r3, #92	; 0x5c
 801e96c:	d01a      	beq.n	801e9a4 <token_proc_char+0x6c>
 801e96e:	2b62      	cmp	r3, #98	; 0x62
 801e970:	d012      	beq.n	801e998 <token_proc_char+0x60>
 801e972:	2b27      	cmp	r3, #39	; 0x27
 801e974:	d019      	beq.n	801e9aa <token_proc_char+0x72>
 801e976:	e01b      	b.n	801e9b0 <token_proc_char+0x78>
 801e978:	2b74      	cmp	r3, #116	; 0x74
 801e97a:	d007      	beq.n	801e98c <token_proc_char+0x54>
 801e97c:	2b76      	cmp	r3, #118	; 0x76
 801e97e:	d008      	beq.n	801e992 <token_proc_char+0x5a>
 801e980:	2b72      	cmp	r3, #114	; 0x72
 801e982:	d00c      	beq.n	801e99e <token_proc_char+0x66>
 801e984:	e014      	b.n	801e9b0 <token_proc_char+0x78>
		{
		case 'n': ch = '\n'; break;
 801e986:	230a      	movs	r3, #10
 801e988:	75fb      	strb	r3, [r7, #23]
 801e98a:	e02e      	b.n	801e9ea <token_proc_char+0xb2>
		case 't': ch = '\t'; break;
 801e98c:	2309      	movs	r3, #9
 801e98e:	75fb      	strb	r3, [r7, #23]
 801e990:	e02b      	b.n	801e9ea <token_proc_char+0xb2>
		case 'v': ch = '\v'; break;
 801e992:	230b      	movs	r3, #11
 801e994:	75fb      	strb	r3, [r7, #23]
 801e996:	e028      	b.n	801e9ea <token_proc_char+0xb2>
		case 'b': ch = '\b'; break;
 801e998:	2308      	movs	r3, #8
 801e99a:	75fb      	strb	r3, [r7, #23]
 801e99c:	e025      	b.n	801e9ea <token_proc_char+0xb2>
		case 'r': ch = '\r'; break;
 801e99e:	230d      	movs	r3, #13
 801e9a0:	75fb      	strb	r3, [r7, #23]
 801e9a2:	e022      	b.n	801e9ea <token_proc_char+0xb2>
		case '\\': ch = '\\';  break;
 801e9a4:	235c      	movs	r3, #92	; 0x5c
 801e9a6:	75fb      	strb	r3, [r7, #23]
 801e9a8:	e01f      	b.n	801e9ea <token_proc_char+0xb2>
		case '\'': ch = '\'';  break;
 801e9aa:	2327      	movs	r3, #39	; 0x27
 801e9ac:	75fb      	strb	r3, [r7, #23]
 801e9ae:	e01c      	b.n	801e9ea <token_proc_char+0xb2>
		default :
			while ( is_digit(ch) )/*for '\113' char*/
 801e9b0:	e009      	b.n	801e9c6 <token_proc_char+0x8e>
			{
				ch = token_next_char(self);
 801e9b2:	6878      	ldr	r0, [r7, #4]
 801e9b4:	f7ff fd90 	bl	801e4d8 <token_next_char>
 801e9b8:	4603      	mov	r3, r0
 801e9ba:	75fb      	strb	r3, [r7, #23]
				*p++ = ch;
 801e9bc:	693b      	ldr	r3, [r7, #16]
 801e9be:	1c5a      	adds	r2, r3, #1
 801e9c0:	613a      	str	r2, [r7, #16]
 801e9c2:	7dfa      	ldrb	r2, [r7, #23]
 801e9c4:	701a      	strb	r2, [r3, #0]
		case 'b': ch = '\b'; break;
		case 'r': ch = '\r'; break;
		case '\\': ch = '\\';  break;
		case '\'': ch = '\'';  break;
		default :
			while ( is_digit(ch) )/*for '\113' char*/
 801e9c6:	7dfb      	ldrb	r3, [r7, #23]
 801e9c8:	2b2f      	cmp	r3, #47	; 0x2f
 801e9ca:	d902      	bls.n	801e9d2 <token_proc_char+0x9a>
 801e9cc:	7dfb      	ldrb	r3, [r7, #23]
 801e9ce:	2b39      	cmp	r3, #57	; 0x39
 801e9d0:	d9ef      	bls.n	801e9b2 <token_proc_char+0x7a>
			{
				ch = token_next_char(self);
				*p++ = ch;
			}

			token_prev_char(self);
 801e9d2:	6878      	ldr	r0, [r7, #4]
 801e9d4:	f7ff fdb4 	bl	801e540 <token_prev_char>
			*p = '\0';
 801e9d8:	693b      	ldr	r3, [r7, #16]
 801e9da:	2200      	movs	r2, #0
 801e9dc:	701a      	strb	r2, [r3, #0]
			ch = atoi(p);
 801e9de:	6938      	ldr	r0, [r7, #16]
 801e9e0:	f000 fa5a 	bl	801ee98 <atoi>
 801e9e4:	4603      	mov	r3, r0
 801e9e6:	75fb      	strb	r3, [r7, #23]
			break;
 801e9e8:	bf00      	nop
		}
	}

	if ( token_next_char(self) != '\'' )
 801e9ea:	6878      	ldr	r0, [r7, #4]
 801e9ec:	f7ff fd74 	bl	801e4d8 <token_next_char>
 801e9f0:	4603      	mov	r3, r0
 801e9f2:	2b27      	cmp	r3, #39	; 0x27
 801e9f4:	d007      	beq.n	801ea06 <token_proc_char+0xce>
	{
		token_prev_char(self);
 801e9f6:	6878      	ldr	r0, [r7, #4]
 801e9f8:	f7ff fda2 	bl	801e540 <token_prev_char>
		finsh_error_set(FINSH_ERROR_EXPECT_CHAR);
 801e9fc:	2009      	movs	r0, #9
 801e9fe:	f7fd f9dd 	bl	801bdbc <finsh_error_set>
		return ch;
 801ea02:	7dfb      	ldrb	r3, [r7, #23]
 801ea04:	e000      	b.n	801ea08 <token_proc_char+0xd0>
	}

	return ch;
 801ea06:	7dfb      	ldrb	r3, [r7, #23]
}
 801ea08:	4618      	mov	r0, r3
 801ea0a:	3718      	adds	r7, #24
 801ea0c:	46bd      	mov	sp, r7
 801ea0e:	bd80      	pop	{r7, pc}

0801ea10 <token_proc_string>:

static u_char* token_proc_string(struct finsh_token* self)
{
 801ea10:	b580      	push	{r7, lr}
 801ea12:	b084      	sub	sp, #16
 801ea14:	af00      	add	r7, sp, #0
 801ea16:	6078      	str	r0, [r7, #4]
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
 801ea18:	687b      	ldr	r3, [r7, #4]
 801ea1a:	3310      	adds	r3, #16
 801ea1c:	60fb      	str	r3, [r7, #12]
 801ea1e:	e024      	b.n	801ea6a <token_proc_string+0x5a>
	{
		char ch = token_next_char(self);
 801ea20:	6878      	ldr	r0, [r7, #4]
 801ea22:	f7ff fd59 	bl	801e4d8 <token_next_char>
 801ea26:	4603      	mov	r3, r0
 801ea28:	72fb      	strb	r3, [r7, #11]

		if ( is_eof(self) )
 801ea2a:	687b      	ldr	r3, [r7, #4]
 801ea2c:	781b      	ldrb	r3, [r3, #0]
 801ea2e:	2b00      	cmp	r3, #0
 801ea30:	d004      	beq.n	801ea3c <token_proc_string+0x2c>
		{
			finsh_error_set(FINSH_ERROR_UNEXPECT_END);
 801ea32:	200a      	movs	r0, #10
 801ea34:	f7fd f9c2 	bl	801bdbc <finsh_error_set>
			return NULL;;
 801ea38:	2300      	movs	r3, #0
 801ea3a:	e01d      	b.n	801ea78 <token_proc_string+0x68>
		}
		if ( ch == '\\' )
 801ea3c:	7afb      	ldrb	r3, [r7, #11]
 801ea3e:	2b5c      	cmp	r3, #92	; 0x5c
 801ea40:	d105      	bne.n	801ea4e <token_proc_string+0x3e>
		{
			ch = token_proc_escape(self);
 801ea42:	6878      	ldr	r0, [r7, #4]
 801ea44:	f000 f81c 	bl	801ea80 <token_proc_escape>
 801ea48:	4603      	mov	r3, r0
 801ea4a:	72fb      	strb	r3, [r7, #11]
 801ea4c:	e008      	b.n	801ea60 <token_proc_string+0x50>
		}
		else if ( ch == '"' )/*end of string.*/
 801ea4e:	7afb      	ldrb	r3, [r7, #11]
 801ea50:	2b22      	cmp	r3, #34	; 0x22
 801ea52:	d105      	bne.n	801ea60 <token_proc_string+0x50>
		{
			*p = '\0';
 801ea54:	68fb      	ldr	r3, [r7, #12]
 801ea56:	2200      	movs	r2, #0
 801ea58:	701a      	strb	r2, [r3, #0]
			return self->string;
 801ea5a:	687b      	ldr	r3, [r7, #4]
 801ea5c:	3310      	adds	r3, #16
 801ea5e:	e00b      	b.n	801ea78 <token_proc_string+0x68>
		}

		*p++ = ch;
 801ea60:	68fb      	ldr	r3, [r7, #12]
 801ea62:	1c5a      	adds	r2, r3, #1
 801ea64:	60fa      	str	r2, [r7, #12]
 801ea66:	7afa      	ldrb	r2, [r7, #11]
 801ea68:	701a      	strb	r2, [r3, #0]

static u_char* token_proc_string(struct finsh_token* self)
{
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
 801ea6a:	68fb      	ldr	r3, [r7, #12]
 801ea6c:	687a      	ldr	r2, [r7, #4]
 801ea6e:	3210      	adds	r2, #16
 801ea70:	1a9b      	subs	r3, r3, r2
 801ea72:	2b7f      	cmp	r3, #127	; 0x7f
 801ea74:	ddd4      	ble.n	801ea20 <token_proc_string+0x10>
		}

		*p++ = ch;
	}

	return NULL;
 801ea76:	2300      	movs	r3, #0
}
 801ea78:	4618      	mov	r0, r3
 801ea7a:	3710      	adds	r7, #16
 801ea7c:	46bd      	mov	sp, r7
 801ea7e:	bd80      	pop	{r7, pc}

0801ea80 <token_proc_escape>:

static int token_proc_escape(struct finsh_token* self)
{
 801ea80:	b580      	push	{r7, lr}
 801ea82:	b084      	sub	sp, #16
 801ea84:	af00      	add	r7, sp, #0
 801ea86:	6078      	str	r0, [r7, #4]
	char ch;
	int result=0;
 801ea88:	2300      	movs	r3, #0
 801ea8a:	60bb      	str	r3, [r7, #8]

	ch = token_next_char(self);
 801ea8c:	6878      	ldr	r0, [r7, #4]
 801ea8e:	f7ff fd23 	bl	801e4d8 <token_next_char>
 801ea92:	4603      	mov	r3, r0
 801ea94:	73fb      	strb	r3, [r7, #15]
	switch (ch)
 801ea96:	7bfb      	ldrb	r3, [r7, #15]
 801ea98:	3b61      	subs	r3, #97	; 0x61
 801ea9a:	2b17      	cmp	r3, #23
 801ea9c:	d862      	bhi.n	801eb64 <token_proc_escape+0xe4>
 801ea9e:	a201      	add	r2, pc, #4	; (adr r2, 801eaa4 <token_proc_escape+0x24>)
 801eaa0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801eaa4:	0801eb29 	.word	0x0801eb29
 801eaa8:	0801eb17 	.word	0x0801eb17
 801eaac:	0801eb65 	.word	0x0801eb65
 801eab0:	0801eb65 	.word	0x0801eb65
 801eab4:	0801eb65 	.word	0x0801eb65
 801eab8:	0801eb23 	.word	0x0801eb23
 801eabc:	0801eb65 	.word	0x0801eb65
 801eac0:	0801eb65 	.word	0x0801eb65
 801eac4:	0801eb65 	.word	0x0801eb65
 801eac8:	0801eb65 	.word	0x0801eb65
 801eacc:	0801eb65 	.word	0x0801eb65
 801ead0:	0801eb65 	.word	0x0801eb65
 801ead4:	0801eb65 	.word	0x0801eb65
 801ead8:	0801eb05 	.word	0x0801eb05
 801eadc:	0801eb65 	.word	0x0801eb65
 801eae0:	0801eb65 	.word	0x0801eb65
 801eae4:	0801eb65 	.word	0x0801eb65
 801eae8:	0801eb1d 	.word	0x0801eb1d
 801eaec:	0801eb65 	.word	0x0801eb65
 801eaf0:	0801eb0b 	.word	0x0801eb0b
 801eaf4:	0801eb65 	.word	0x0801eb65
 801eaf8:	0801eb11 	.word	0x0801eb11
 801eafc:	0801eb65 	.word	0x0801eb65
 801eb00:	0801eb2f 	.word	0x0801eb2f
	{
	case 'n':
		result = '\n';
 801eb04:	230a      	movs	r3, #10
 801eb06:	60bb      	str	r3, [r7, #8]
		break;
 801eb08:	e047      	b.n	801eb9a <token_proc_escape+0x11a>
	case 't':
		result = '\t';
 801eb0a:	2309      	movs	r3, #9
 801eb0c:	60bb      	str	r3, [r7, #8]
		break;
 801eb0e:	e044      	b.n	801eb9a <token_proc_escape+0x11a>
	case 'v':
		result = '\v';
 801eb10:	230b      	movs	r3, #11
 801eb12:	60bb      	str	r3, [r7, #8]
		break;
 801eb14:	e041      	b.n	801eb9a <token_proc_escape+0x11a>
	case 'b':
		result = '\b';
 801eb16:	2308      	movs	r3, #8
 801eb18:	60bb      	str	r3, [r7, #8]
		break;
 801eb1a:	e03e      	b.n	801eb9a <token_proc_escape+0x11a>
	case 'r':
		result = '\r';
 801eb1c:	230d      	movs	r3, #13
 801eb1e:	60bb      	str	r3, [r7, #8]
		break;
 801eb20:	e03b      	b.n	801eb9a <token_proc_escape+0x11a>
	case 'f':
		result = '\f';
 801eb22:	230c      	movs	r3, #12
 801eb24:	60bb      	str	r3, [r7, #8]
		break;
 801eb26:	e038      	b.n	801eb9a <token_proc_escape+0x11a>
	case 'a':
		result = '\007';
 801eb28:	2307      	movs	r3, #7
 801eb2a:	60bb      	str	r3, [r7, #8]
		break;
 801eb2c:	e035      	b.n	801eb9a <token_proc_escape+0x11a>
	case 'x':
		result = 0;
 801eb2e:	2300      	movs	r3, #0
 801eb30:	60bb      	str	r3, [r7, #8]
		ch  = token_next_char(self);
 801eb32:	6878      	ldr	r0, [r7, #4]
 801eb34:	f7ff fcd0 	bl	801e4d8 <token_next_char>
 801eb38:	4603      	mov	r3, r0
 801eb3a:	73fb      	strb	r3, [r7, #15]
		while ( (ch - '0')<16u )
 801eb3c:	e00a      	b.n	801eb54 <token_proc_escape+0xd4>
		{
			result = result*16 + ch - '0';
 801eb3e:	68bb      	ldr	r3, [r7, #8]
 801eb40:	011a      	lsls	r2, r3, #4
 801eb42:	7bfb      	ldrb	r3, [r7, #15]
 801eb44:	4413      	add	r3, r2
 801eb46:	3b30      	subs	r3, #48	; 0x30
 801eb48:	60bb      	str	r3, [r7, #8]
			ch = token_next_char(self);
 801eb4a:	6878      	ldr	r0, [r7, #4]
 801eb4c:	f7ff fcc4 	bl	801e4d8 <token_next_char>
 801eb50:	4603      	mov	r3, r0
 801eb52:	73fb      	strb	r3, [r7, #15]
		result = '\007';
		break;
	case 'x':
		result = 0;
		ch  = token_next_char(self);
		while ( (ch - '0')<16u )
 801eb54:	7bfb      	ldrb	r3, [r7, #15]
 801eb56:	3b30      	subs	r3, #48	; 0x30
 801eb58:	2b0f      	cmp	r3, #15
 801eb5a:	d9f0      	bls.n	801eb3e <token_proc_escape+0xbe>
		{
			result = result*16 + ch - '0';
			ch = token_next_char(self);
		}
		token_prev_char(self);
 801eb5c:	6878      	ldr	r0, [r7, #4]
 801eb5e:	f7ff fcef 	bl	801e540 <token_prev_char>
		break;
 801eb62:	e01a      	b.n	801eb9a <token_proc_escape+0x11a>
	default:
		if ( (ch - '0') < 8u)
 801eb64:	7bfb      	ldrb	r3, [r7, #15]
 801eb66:	3b30      	subs	r3, #48	; 0x30
 801eb68:	2b07      	cmp	r3, #7
 801eb6a:	d815      	bhi.n	801eb98 <token_proc_escape+0x118>
		{
			result = 0;
 801eb6c:	2300      	movs	r3, #0
 801eb6e:	60bb      	str	r3, [r7, #8]
			while ( (ch - '0') < 8u )
 801eb70:	e00a      	b.n	801eb88 <token_proc_escape+0x108>
			{
				result = result*8 + ch - '0';
 801eb72:	68bb      	ldr	r3, [r7, #8]
 801eb74:	00da      	lsls	r2, r3, #3
 801eb76:	7bfb      	ldrb	r3, [r7, #15]
 801eb78:	4413      	add	r3, r2
 801eb7a:	3b30      	subs	r3, #48	; 0x30
 801eb7c:	60bb      	str	r3, [r7, #8]
				ch = token_next_char(self);
 801eb7e:	6878      	ldr	r0, [r7, #4]
 801eb80:	f7ff fcaa 	bl	801e4d8 <token_next_char>
 801eb84:	4603      	mov	r3, r0
 801eb86:	73fb      	strb	r3, [r7, #15]
		break;
	default:
		if ( (ch - '0') < 8u)
		{
			result = 0;
			while ( (ch - '0') < 8u )
 801eb88:	7bfb      	ldrb	r3, [r7, #15]
 801eb8a:	3b30      	subs	r3, #48	; 0x30
 801eb8c:	2b07      	cmp	r3, #7
 801eb8e:	d9f0      	bls.n	801eb72 <token_proc_escape+0xf2>
			{
				result = result*8 + ch - '0';
				ch = token_next_char(self);
			}

			token_prev_char(self);
 801eb90:	6878      	ldr	r0, [r7, #4]
 801eb92:	f7ff fcd5 	bl	801e540 <token_prev_char>
		}
		break;
 801eb96:	e7ff      	b.n	801eb98 <token_proc_escape+0x118>
 801eb98:	bf00      	nop
	}

	return result;
 801eb9a:	68bb      	ldr	r3, [r7, #8]
}
 801eb9c:	4618      	mov	r0, r3
 801eb9e:	3710      	adds	r7, #16
 801eba0:	46bd      	mov	sp, r7
 801eba2:	bd80      	pop	{r7, pc}

0801eba4 <token_proc_number>:

/*
(0|0x|0X|0b|0B)number+(l|L)
*/
static void token_proc_number(struct finsh_token* self)
{
 801eba4:	b580      	push	{r7, lr}
 801eba6:	b0a6      	sub	sp, #152	; 0x98
 801eba8:	af00      	add	r7, sp, #0
 801ebaa:	6078      	str	r0, [r7, #4]
	char ch;
	char *p, buf[128];
	long value;

	value = 0;
 801ebac:	2300      	movs	r3, #0
 801ebae:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	p = buf;
 801ebb2:	f107 0308 	add.w	r3, r7, #8
 801ebb6:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

	ch  = token_next_char(self);
 801ebba:	6878      	ldr	r0, [r7, #4]
 801ebbc:	f7ff fc8c 	bl	801e4d8 <token_next_char>
 801ebc0:	4603      	mov	r3, r0
 801ebc2:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
	if ( ch == '0' )
 801ebc6:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ebca:	2b30      	cmp	r3, #48	; 0x30
 801ebcc:	f040 80af 	bne.w	801ed2e <token_proc_number+0x18a>
	{
		int b;
		ch = token_next_char(self);
 801ebd0:	6878      	ldr	r0, [r7, #4]
 801ebd2:	f7ff fc81 	bl	801e4d8 <token_next_char>
 801ebd6:	4603      	mov	r3, r0
 801ebd8:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
 801ebdc:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ebe0:	2b78      	cmp	r3, #120	; 0x78
 801ebe2:	d003      	beq.n	801ebec <token_proc_number+0x48>
 801ebe4:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ebe8:	2b58      	cmp	r3, #88	; 0x58
 801ebea:	d12c      	bne.n	801ec46 <token_proc_number+0xa2>
		{
			b = 16;
 801ebec:	2310      	movs	r3, #16
 801ebee:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			ch = token_next_char(self);
 801ebf2:	6878      	ldr	r0, [r7, #4]
 801ebf4:	f7ff fc70 	bl	801e4d8 <token_next_char>
 801ebf8:	4603      	mov	r3, r0
 801ebfa:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			while ( is_digit(ch) || is_alpha(ch) )
 801ebfe:	e00d      	b.n	801ec1c <token_proc_number+0x78>
			{
				*p++ = ch;
 801ec00:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801ec04:	1c5a      	adds	r2, r3, #1
 801ec06:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 801ec0a:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 801ec0e:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 801ec10:	6878      	ldr	r0, [r7, #4]
 801ec12:	f7ff fc61 	bl	801e4d8 <token_next_char>
 801ec16:	4603      	mov	r3, r0
 801ec18:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		ch = token_next_char(self);
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
		{
			b = 16;
			ch = token_next_char(self);
			while ( is_digit(ch) || is_alpha(ch) )
 801ec1c:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ec20:	2b2f      	cmp	r3, #47	; 0x2f
 801ec22:	d903      	bls.n	801ec2c <token_proc_number+0x88>
 801ec24:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ec28:	2b39      	cmp	r3, #57	; 0x39
 801ec2a:	d9e9      	bls.n	801ec00 <token_proc_number+0x5c>
 801ec2c:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ec30:	f043 0320 	orr.w	r3, r3, #32
 801ec34:	b2db      	uxtb	r3, r3
 801ec36:	3b61      	subs	r3, #97	; 0x61
 801ec38:	2b19      	cmp	r3, #25
 801ec3a:	d9e1      	bls.n	801ec00 <token_proc_number+0x5c>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 801ec3c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801ec40:	2200      	movs	r2, #0
 801ec42:	701a      	strb	r2, [r3, #0]
 801ec44:	e05d      	b.n	801ed02 <token_proc_number+0x15e>
		}
		else if ( ch == 'b' || ch == 'B' )
 801ec46:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ec4a:	2b62      	cmp	r3, #98	; 0x62
 801ec4c:	d003      	beq.n	801ec56 <token_proc_number+0xb2>
 801ec4e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ec52:	2b42      	cmp	r3, #66	; 0x42
 801ec54:	d124      	bne.n	801eca0 <token_proc_number+0xfc>
		{
			b = 2;
 801ec56:	2302      	movs	r3, #2
 801ec58:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			ch = token_next_char(self);
 801ec5c:	6878      	ldr	r0, [r7, #4]
 801ec5e:	f7ff fc3b 	bl	801e4d8 <token_next_char>
 801ec62:	4603      	mov	r3, r0
 801ec64:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			while ( (ch=='0')||(ch=='1') )
 801ec68:	e00d      	b.n	801ec86 <token_proc_number+0xe2>
			{
				*p++ = ch;
 801ec6a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801ec6e:	1c5a      	adds	r2, r3, #1
 801ec70:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 801ec74:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 801ec78:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 801ec7a:	6878      	ldr	r0, [r7, #4]
 801ec7c:	f7ff fc2c 	bl	801e4d8 <token_next_char>
 801ec80:	4603      	mov	r3, r0
 801ec82:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		}
		else if ( ch == 'b' || ch == 'B' )
		{
			b = 2;
			ch = token_next_char(self);
			while ( (ch=='0')||(ch=='1') )
 801ec86:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ec8a:	2b30      	cmp	r3, #48	; 0x30
 801ec8c:	d0ed      	beq.n	801ec6a <token_proc_number+0xc6>
 801ec8e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ec92:	2b31      	cmp	r3, #49	; 0x31
 801ec94:	d0e9      	beq.n	801ec6a <token_proc_number+0xc6>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 801ec96:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801ec9a:	2200      	movs	r2, #0
 801ec9c:	701a      	strb	r2, [r3, #0]
 801ec9e:	e030      	b.n	801ed02 <token_proc_number+0x15e>
		}
		else if ( '0' <= ch && ch <= '7' )
 801eca0:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801eca4:	2b2f      	cmp	r3, #47	; 0x2f
 801eca6:	d922      	bls.n	801ecee <token_proc_number+0x14a>
 801eca8:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ecac:	2b37      	cmp	r3, #55	; 0x37
 801ecae:	d81e      	bhi.n	801ecee <token_proc_number+0x14a>
		{
			b = 8;
 801ecb0:	2308      	movs	r3, #8
 801ecb2:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			while ( '0' <= ch && ch <= '7' )
 801ecb6:	e00d      	b.n	801ecd4 <token_proc_number+0x130>
			{
				*p++ = ch;
 801ecb8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801ecbc:	1c5a      	adds	r2, r3, #1
 801ecbe:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 801ecc2:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 801ecc6:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 801ecc8:	6878      	ldr	r0, [r7, #4]
 801ecca:	f7ff fc05 	bl	801e4d8 <token_next_char>
 801ecce:	4603      	mov	r3, r0
 801ecd0:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			*p = '\0';
		}
		else if ( '0' <= ch && ch <= '7' )
		{
			b = 8;
			while ( '0' <= ch && ch <= '7' )
 801ecd4:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ecd8:	2b2f      	cmp	r3, #47	; 0x2f
 801ecda:	d903      	bls.n	801ece4 <token_proc_number+0x140>
 801ecdc:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ece0:	2b37      	cmp	r3, #55	; 0x37
 801ece2:	d9e9      	bls.n	801ecb8 <token_proc_number+0x114>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 801ece4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801ece8:	2200      	movs	r2, #0
 801ecea:	701a      	strb	r2, [r3, #0]
 801ecec:	e009      	b.n	801ed02 <token_proc_number+0x15e>
		}
		else
		{
			token_prev_char(self);
 801ecee:	6878      	ldr	r0, [r7, #4]
 801ecf0:	f7ff fc26 	bl	801e540 <token_prev_char>

			/* made as 0 value */
			self->value.int_value = 0;
 801ecf4:	687b      	ldr	r3, [r7, #4]
 801ecf6:	2200      	movs	r2, #0
 801ecf8:	60da      	str	r2, [r3, #12]
			self->current_token = finsh_token_type_value_int;
 801ecfa:	687b      	ldr	r3, [r7, #4]
 801ecfc:	221b      	movs	r2, #27
 801ecfe:	721a      	strb	r2, [r3, #8]
			return;
 801ed00:	e046      	b.n	801ed90 <token_proc_number+0x1ec>
		}

		self->value.int_value = token_spec_number(buf, strlen(buf), b);
 801ed02:	f107 0308 	add.w	r3, r7, #8
 801ed06:	4618      	mov	r0, r3
 801ed08:	f000 fea6 	bl	801fa58 <strlen>
 801ed0c:	4603      	mov	r3, r0
 801ed0e:	461a      	mov	r2, r3
 801ed10:	f107 0308 	add.w	r3, r7, #8
 801ed14:	4618      	mov	r0, r3
 801ed16:	4611      	mov	r1, r2
 801ed18:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 801ed1c:	f000 f83c 	bl	801ed98 <token_spec_number>
 801ed20:	4602      	mov	r2, r0
 801ed22:	687b      	ldr	r3, [r7, #4]
 801ed24:	60da      	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
 801ed26:	687b      	ldr	r3, [r7, #4]
 801ed28:	221b      	movs	r2, #27
 801ed2a:	721a      	strb	r2, [r3, #8]
 801ed2c:	e022      	b.n	801ed74 <token_proc_number+0x1d0>
	}
	else
	{
		while ( is_digit(ch) )
 801ed2e:	e012      	b.n	801ed56 <token_proc_number+0x1b2>
		{
			value = value*10 + ( ch - '0' );
 801ed30:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 801ed34:	4613      	mov	r3, r2
 801ed36:	009b      	lsls	r3, r3, #2
 801ed38:	4413      	add	r3, r2
 801ed3a:	005b      	lsls	r3, r3, #1
 801ed3c:	461a      	mov	r2, r3
 801ed3e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ed42:	3b30      	subs	r3, #48	; 0x30
 801ed44:	4413      	add	r3, r2
 801ed46:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
			ch = token_next_char(self);
 801ed4a:	6878      	ldr	r0, [r7, #4]
 801ed4c:	f7ff fbc4 	bl	801e4d8 <token_next_char>
 801ed50:	4603      	mov	r3, r0
 801ed52:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		self->value.int_value = token_spec_number(buf, strlen(buf), b);
		self->current_token = finsh_token_type_value_int;
	}
	else
	{
		while ( is_digit(ch) )
 801ed56:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ed5a:	2b2f      	cmp	r3, #47	; 0x2f
 801ed5c:	d903      	bls.n	801ed66 <token_proc_number+0x1c2>
 801ed5e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ed62:	2b39      	cmp	r3, #57	; 0x39
 801ed64:	d9e4      	bls.n	801ed30 <token_proc_number+0x18c>
		{
			value = value*10 + ( ch - '0' );
			ch = token_next_char(self);
		}

		self->value.int_value = value;
 801ed66:	687b      	ldr	r3, [r7, #4]
 801ed68:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 801ed6c:	60da      	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
 801ed6e:	687b      	ldr	r3, [r7, #4]
 801ed70:	221b      	movs	r2, #27
 801ed72:	721a      	strb	r2, [r3, #8]
	}

	switch ( ch )
 801ed74:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801ed78:	2b4c      	cmp	r3, #76	; 0x4c
 801ed7a:	d001      	beq.n	801ed80 <token_proc_number+0x1dc>
 801ed7c:	2b6c      	cmp	r3, #108	; 0x6c
 801ed7e:	d103      	bne.n	801ed88 <token_proc_number+0x1e4>
	{
	case 'l':
	case 'L':
		self->current_token = finsh_token_type_value_long;
 801ed80:	687b      	ldr	r3, [r7, #4]
 801ed82:	221c      	movs	r2, #28
 801ed84:	721a      	strb	r2, [r3, #8]
		break;
 801ed86:	e003      	b.n	801ed90 <token_proc_number+0x1ec>

	default:
		token_prev_char(self);
 801ed88:	6878      	ldr	r0, [r7, #4]
 801ed8a:	f7ff fbd9 	bl	801e540 <token_prev_char>
		break;
 801ed8e:	bf00      	nop
	}
}
 801ed90:	3798      	adds	r7, #152	; 0x98
 801ed92:	46bd      	mov	sp, r7
 801ed94:	bd80      	pop	{r7, pc}
 801ed96:	bf00      	nop

0801ed98 <token_spec_number>:

/*use 64 bit number*/
#define BN_SIZE 2

static long token_spec_number(char* string, int length, int b)
{
 801ed98:	b480      	push	{r7}
 801ed9a:	b08f      	sub	sp, #60	; 0x3c
 801ed9c:	af00      	add	r7, sp, #0
 801ed9e:	60f8      	str	r0, [r7, #12]
 801eda0:	60b9      	str	r1, [r7, #8]
 801eda2:	607a      	str	r2, [r7, #4]
	char* p;
	int t;
	int i, j, shift=1;
 801eda4:	2301      	movs	r3, #1
 801eda6:	627b      	str	r3, [r7, #36]	; 0x24
	unsigned int bn[BN_SIZE], v;
	long d;

	p = string;
 801eda8:	68fb      	ldr	r3, [r7, #12]
 801edaa:	637b      	str	r3, [r7, #52]	; 0x34
	i = 0;
 801edac:	2300      	movs	r3, #0
 801edae:	62fb      	str	r3, [r7, #44]	; 0x2c

	switch ( b )
 801edb0:	687b      	ldr	r3, [r7, #4]
 801edb2:	2b08      	cmp	r3, #8
 801edb4:	d007      	beq.n	801edc6 <token_spec_number+0x2e>
 801edb6:	2b10      	cmp	r3, #16
 801edb8:	d002      	beq.n	801edc0 <token_spec_number+0x28>
 801edba:	2b02      	cmp	r3, #2
 801edbc:	d006      	beq.n	801edcc <token_spec_number+0x34>
		break;
	case 8:  shift = 3;
		break;
	case 2:  shift = 1;
		break;
	default: break;
 801edbe:	e008      	b.n	801edd2 <token_spec_number+0x3a>
	p = string;
	i = 0;

	switch ( b )
	{
	case 16: shift = 4;
 801edc0:	2304      	movs	r3, #4
 801edc2:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 801edc4:	e005      	b.n	801edd2 <token_spec_number+0x3a>
	case 8:  shift = 3;
 801edc6:	2303      	movs	r3, #3
 801edc8:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 801edca:	e002      	b.n	801edd2 <token_spec_number+0x3a>
	case 2:  shift = 1;
 801edcc:	2301      	movs	r3, #1
 801edce:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 801edd0:	bf00      	nop
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;
 801edd2:	2300      	movs	r3, #0
 801edd4:	62bb      	str	r3, [r7, #40]	; 0x28
 801edd6:	e00a      	b.n	801edee <token_spec_number+0x56>
 801edd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801edda:	009b      	lsls	r3, r3, #2
 801eddc:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801ede0:	4413      	add	r3, r2
 801ede2:	2200      	movs	r2, #0
 801ede4:	f843 2c24 	str.w	r2, [r3, #-36]
 801ede8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801edea:	3301      	adds	r3, #1
 801edec:	62bb      	str	r3, [r7, #40]	; 0x28
 801edee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801edf0:	2b01      	cmp	r3, #1
 801edf2:	ddf1      	ble.n	801edd8 <token_spec_number+0x40>

	while ( i<length )
 801edf4:	e042      	b.n	801ee7c <token_spec_number+0xe4>
	{
		t = *p++;
 801edf6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801edf8:	1c5a      	adds	r2, r3, #1
 801edfa:	637a      	str	r2, [r7, #52]	; 0x34
 801edfc:	781b      	ldrb	r3, [r3, #0]
 801edfe:	633b      	str	r3, [r7, #48]	; 0x30
		if ( t>='a' && t <='f' )
 801ee00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ee02:	2b60      	cmp	r3, #96	; 0x60
 801ee04:	dd06      	ble.n	801ee14 <token_spec_number+0x7c>
 801ee06:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ee08:	2b66      	cmp	r3, #102	; 0x66
 801ee0a:	dc03      	bgt.n	801ee14 <token_spec_number+0x7c>
		{
			t = t - 'a' +10;
 801ee0c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ee0e:	3b57      	subs	r3, #87	; 0x57
 801ee10:	633b      	str	r3, [r7, #48]	; 0x30
 801ee12:	e00c      	b.n	801ee2e <token_spec_number+0x96>
		}
		else if ( t >='A' && t <='F' )
 801ee14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ee16:	2b40      	cmp	r3, #64	; 0x40
 801ee18:	dd06      	ble.n	801ee28 <token_spec_number+0x90>
 801ee1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ee1c:	2b46      	cmp	r3, #70	; 0x46
 801ee1e:	dc03      	bgt.n	801ee28 <token_spec_number+0x90>
		{
			t = t - 'A' +10;
 801ee20:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ee22:	3b37      	subs	r3, #55	; 0x37
 801ee24:	633b      	str	r3, [r7, #48]	; 0x30
 801ee26:	e002      	b.n	801ee2e <token_spec_number+0x96>
		}
		else t = t - '0';
 801ee28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ee2a:	3b30      	subs	r3, #48	; 0x30
 801ee2c:	633b      	str	r3, [r7, #48]	; 0x30

		for ( j=0; j<BN_SIZE ; j++)
 801ee2e:	2300      	movs	r3, #0
 801ee30:	62bb      	str	r3, [r7, #40]	; 0x28
 801ee32:	e01d      	b.n	801ee70 <token_spec_number+0xd8>
		{
			v = bn[j];
 801ee34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ee36:	009b      	lsls	r3, r3, #2
 801ee38:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801ee3c:	4413      	add	r3, r2
 801ee3e:	f853 3c24 	ldr.w	r3, [r3, #-36]
 801ee42:	623b      	str	r3, [r7, #32]
			bn[j] = (v<<shift) | t;
 801ee44:	6a3a      	ldr	r2, [r7, #32]
 801ee46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ee48:	409a      	lsls	r2, r3
 801ee4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ee4c:	431a      	orrs	r2, r3
 801ee4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ee50:	009b      	lsls	r3, r3, #2
 801ee52:	f107 0138 	add.w	r1, r7, #56	; 0x38
 801ee56:	440b      	add	r3, r1
 801ee58:	f843 2c24 	str.w	r2, [r3, #-36]
			t = v >> (32 - shift);
 801ee5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ee5e:	f1c3 0320 	rsb	r3, r3, #32
 801ee62:	6a3a      	ldr	r2, [r7, #32]
 801ee64:	fa22 f303 	lsr.w	r3, r2, r3
 801ee68:	633b      	str	r3, [r7, #48]	; 0x30
		{
			t = t - 'A' +10;
		}
		else t = t - '0';

		for ( j=0; j<BN_SIZE ; j++)
 801ee6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ee6c:	3301      	adds	r3, #1
 801ee6e:	62bb      	str	r3, [r7, #40]	; 0x28
 801ee70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ee72:	2b01      	cmp	r3, #1
 801ee74:	ddde      	ble.n	801ee34 <token_spec_number+0x9c>
		{
			v = bn[j];
			bn[j] = (v<<shift) | t;
			t = v >> (32 - shift);
		}
		i++;
 801ee76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ee78:	3301      	adds	r3, #1
 801ee7a:	62fb      	str	r3, [r7, #44]	; 0x2c
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;

	while ( i<length )
 801ee7c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801ee7e:	68bb      	ldr	r3, [r7, #8]
 801ee80:	429a      	cmp	r2, r3
 801ee82:	dbb8      	blt.n	801edf6 <token_spec_number+0x5e>
			t = v >> (32 - shift);
		}
		i++;
	}

	d = (long)bn[0];
 801ee84:	697b      	ldr	r3, [r7, #20]
 801ee86:	61fb      	str	r3, [r7, #28]

	return d;
 801ee88:	69fb      	ldr	r3, [r7, #28]
}
 801ee8a:	4618      	mov	r0, r3
 801ee8c:	373c      	adds	r7, #60	; 0x3c
 801ee8e:	46bd      	mov	sp, r7
 801ee90:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ee94:	4770      	bx	lr
 801ee96:	bf00      	nop

0801ee98 <atoi>:
 801ee98:	2100      	movs	r1, #0
 801ee9a:	220a      	movs	r2, #10
 801ee9c:	f000 bf18 	b.w	801fcd0 <strtol>

0801eea0 <ctime>:
 801eea0:	b508      	push	{r3, lr}
 801eea2:	f000 f805 	bl	801eeb0 <localtime>
 801eea6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801eeaa:	f001 b9a7 	b.w	80201fc <asctime>
 801eeae:	bf00      	nop

0801eeb0 <localtime>:
 801eeb0:	4b02      	ldr	r3, [pc, #8]	; (801eebc <localtime+0xc>)
 801eeb2:	6819      	ldr	r1, [r3, #0]
 801eeb4:	317c      	adds	r1, #124	; 0x7c
 801eeb6:	f000 b803 	b.w	801eec0 <localtime_r>
 801eeba:	bf00      	nop
 801eebc:	20010580 	.word	0x20010580

0801eec0 <localtime_r>:
 801eec0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801eec4:	460c      	mov	r4, r1
 801eec6:	4606      	mov	r6, r0
 801eec8:	f001 fa40 	bl	802034c <__gettzinfo>
 801eecc:	4621      	mov	r1, r4
 801eece:	4680      	mov	r8, r0
 801eed0:	4630      	mov	r0, r6
 801eed2:	f001 fa3f 	bl	8020354 <gmtime_r>
 801eed6:	6947      	ldr	r7, [r0, #20]
 801eed8:	f207 776c 	addw	r7, r7, #1900	; 0x76c
 801eedc:	07b9      	lsls	r1, r7, #30
 801eede:	4604      	mov	r4, r0
 801eee0:	f000 80c6 	beq.w	801f070 <localtime_r+0x1b0>
 801eee4:	17fa      	asrs	r2, r7, #31
 801eee6:	4b86      	ldr	r3, [pc, #536]	; (801f100 <localtime_r+0x240>)
 801eee8:	fb83 1307 	smull	r1, r3, r3, r7
 801eeec:	ebc2 12e3 	rsb	r2, r2, r3, asr #7
 801eef0:	f44f 73c8 	mov.w	r3, #400	; 0x190
 801eef4:	fb03 7312 	mls	r3, r3, r2, r7
 801eef8:	fab3 f383 	clz	r3, r3
 801eefc:	095b      	lsrs	r3, r3, #5
 801eefe:	005a      	lsls	r2, r3, #1
 801ef00:	4d80      	ldr	r5, [pc, #512]	; (801f104 <localtime_r+0x244>)
 801ef02:	4413      	add	r3, r2
 801ef04:	eb05 1503 	add.w	r5, r5, r3, lsl #4
 801ef08:	f000 ffb4 	bl	801fe74 <__tz_lock>
 801ef0c:	4b7e      	ldr	r3, [pc, #504]	; (801f108 <localtime_r+0x248>)
 801ef0e:	681b      	ldr	r3, [r3, #0]
 801ef10:	b343      	cbz	r3, 801ef64 <localtime_r+0xa4>
 801ef12:	f8d8 3004 	ldr.w	r3, [r8, #4]
 801ef16:	42bb      	cmp	r3, r7
 801ef18:	d005      	beq.n	801ef26 <localtime_r+0x66>
 801ef1a:	4638      	mov	r0, r7
 801ef1c:	f000 fee4 	bl	801fce8 <__tzcalc_limits>
 801ef20:	2800      	cmp	r0, #0
 801ef22:	f000 80b3 	beq.w	801f08c <localtime_r+0x1cc>
 801ef26:	f8d8 3000 	ldr.w	r3, [r8]
 801ef2a:	b983      	cbnz	r3, 801ef4e <localtime_r+0x8e>
 801ef2c:	6833      	ldr	r3, [r6, #0]
 801ef2e:	f8d8 201c 	ldr.w	r2, [r8, #28]
 801ef32:	4293      	cmp	r3, r2
 801ef34:	f280 80ae 	bge.w	801f094 <localtime_r+0x1d4>
 801ef38:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 801ef3c:	4293      	cmp	r3, r2
 801ef3e:	bfac      	ite	ge
 801ef40:	2300      	movge	r3, #0
 801ef42:	2301      	movlt	r3, #1
 801ef44:	6223      	str	r3, [r4, #32]
 801ef46:	b173      	cbz	r3, 801ef66 <localtime_r+0xa6>
 801ef48:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
 801ef4c:	e00d      	b.n	801ef6a <localtime_r+0xaa>
 801ef4e:	6833      	ldr	r3, [r6, #0]
 801ef50:	f8d8 201c 	ldr.w	r2, [r8, #28]
 801ef54:	4293      	cmp	r3, r2
 801ef56:	db04      	blt.n	801ef62 <localtime_r+0xa2>
 801ef58:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 801ef5c:	4293      	cmp	r3, r2
 801ef5e:	f2c0 8099 	blt.w	801f094 <localtime_r+0x1d4>
 801ef62:	2300      	movs	r3, #0
 801ef64:	6223      	str	r3, [r4, #32]
 801ef66:	f8d8 2020 	ldr.w	r2, [r8, #32]
 801ef6a:	4868      	ldr	r0, [pc, #416]	; (801f10c <localtime_r+0x24c>)
 801ef6c:	4968      	ldr	r1, [pc, #416]	; (801f110 <localtime_r+0x250>)
 801ef6e:	68a6      	ldr	r6, [r4, #8]
 801ef70:	fb82 8900 	smull	r8, r9, r2, r0
 801ef74:	eb02 0309 	add.w	r3, r2, r9
 801ef78:	17d7      	asrs	r7, r2, #31
 801ef7a:	f44f 6861 	mov.w	r8, #3600	; 0xe10
 801ef7e:	ebc7 23e3 	rsb	r3, r7, r3, asr #11
 801ef82:	fb08 2313 	mls	r3, r8, r3, r2
 801ef86:	fb83 8901 	smull	r8, r9, r3, r1
 801ef8a:	4499      	add	r9, r3
 801ef8c:	ea4f 78e3 	mov.w	r8, r3, asr #31
 801ef90:	ebc8 1969 	rsb	r9, r8, r9, asr #5
 801ef94:	fb81 1e03 	smull	r1, lr, r1, r3
 801ef98:	ebc9 1909 	rsb	r9, r9, r9, lsl #4
 801ef9c:	6821      	ldr	r1, [r4, #0]
 801ef9e:	449e      	add	lr, r3
 801efa0:	fb80 0c02 	smull	r0, ip, r0, r2
 801efa4:	eba3 0389 	sub.w	r3, r3, r9, lsl #2
 801efa8:	1acb      	subs	r3, r1, r3
 801efaa:	4462      	add	r2, ip
 801efac:	6861      	ldr	r1, [r4, #4]
 801efae:	6023      	str	r3, [r4, #0]
 801efb0:	ebc7 22e2 	rsb	r2, r7, r2, asr #11
 801efb4:	ebc8 1e6e 	rsb	lr, r8, lr, asr #5
 801efb8:	1ab2      	subs	r2, r6, r2
 801efba:	ebce 0101 	rsb	r1, lr, r1
 801efbe:	2b3b      	cmp	r3, #59	; 0x3b
 801efc0:	60a2      	str	r2, [r4, #8]
 801efc2:	6061      	str	r1, [r4, #4]
 801efc4:	dd4d      	ble.n	801f062 <localtime_r+0x1a2>
 801efc6:	3101      	adds	r1, #1
 801efc8:	3b3c      	subs	r3, #60	; 0x3c
 801efca:	6061      	str	r1, [r4, #4]
 801efcc:	6023      	str	r3, [r4, #0]
 801efce:	293b      	cmp	r1, #59	; 0x3b
 801efd0:	dd40      	ble.n	801f054 <localtime_r+0x194>
 801efd2:	3201      	adds	r2, #1
 801efd4:	393c      	subs	r1, #60	; 0x3c
 801efd6:	60a2      	str	r2, [r4, #8]
 801efd8:	6061      	str	r1, [r4, #4]
 801efda:	2a17      	cmp	r2, #23
 801efdc:	dd1d      	ble.n	801f01a <localtime_r+0x15a>
 801efde:	69a3      	ldr	r3, [r4, #24]
 801efe0:	69e1      	ldr	r1, [r4, #28]
 801efe2:	3301      	adds	r3, #1
 801efe4:	2b06      	cmp	r3, #6
 801efe6:	bfc8      	it	gt
 801efe8:	2300      	movgt	r3, #0
 801efea:	61a3      	str	r3, [r4, #24]
 801efec:	68e3      	ldr	r3, [r4, #12]
 801efee:	3101      	adds	r1, #1
 801eff0:	61e1      	str	r1, [r4, #28]
 801eff2:	3a18      	subs	r2, #24
 801eff4:	3301      	adds	r3, #1
 801eff6:	6921      	ldr	r1, [r4, #16]
 801eff8:	60a2      	str	r2, [r4, #8]
 801effa:	60e3      	str	r3, [r4, #12]
 801effc:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
 801f000:	4293      	cmp	r3, r2
 801f002:	dd05      	ble.n	801f010 <localtime_r+0x150>
 801f004:	3101      	adds	r1, #1
 801f006:	1a9b      	subs	r3, r3, r2
 801f008:	290c      	cmp	r1, #12
 801f00a:	60e3      	str	r3, [r4, #12]
 801f00c:	d045      	beq.n	801f09a <localtime_r+0x1da>
 801f00e:	6121      	str	r1, [r4, #16]
 801f010:	f000 ff32 	bl	801fe78 <__tz_unlock>
 801f014:	4620      	mov	r0, r4
 801f016:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801f01a:	2a00      	cmp	r2, #0
 801f01c:	daf8      	bge.n	801f010 <localtime_r+0x150>
 801f01e:	69a3      	ldr	r3, [r4, #24]
 801f020:	69e1      	ldr	r1, [r4, #28]
 801f022:	3b01      	subs	r3, #1
 801f024:	bf48      	it	mi
 801f026:	2306      	movmi	r3, #6
 801f028:	61a3      	str	r3, [r4, #24]
 801f02a:	68e3      	ldr	r3, [r4, #12]
 801f02c:	3901      	subs	r1, #1
 801f02e:	3218      	adds	r2, #24
 801f030:	3b01      	subs	r3, #1
 801f032:	61e1      	str	r1, [r4, #28]
 801f034:	60a2      	str	r2, [r4, #8]
 801f036:	60e3      	str	r3, [r4, #12]
 801f038:	2b00      	cmp	r3, #0
 801f03a:	d1e9      	bne.n	801f010 <localtime_r+0x150>
 801f03c:	6923      	ldr	r3, [r4, #16]
 801f03e:	3b01      	subs	r3, #1
 801f040:	d432      	bmi.n	801f0a8 <localtime_r+0x1e8>
 801f042:	6123      	str	r3, [r4, #16]
 801f044:	009b      	lsls	r3, r3, #2
 801f046:	58eb      	ldr	r3, [r5, r3]
 801f048:	60e3      	str	r3, [r4, #12]
 801f04a:	f000 ff15 	bl	801fe78 <__tz_unlock>
 801f04e:	4620      	mov	r0, r4
 801f050:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801f054:	2900      	cmp	r1, #0
 801f056:	dac0      	bge.n	801efda <localtime_r+0x11a>
 801f058:	3a01      	subs	r2, #1
 801f05a:	313c      	adds	r1, #60	; 0x3c
 801f05c:	60a2      	str	r2, [r4, #8]
 801f05e:	6061      	str	r1, [r4, #4]
 801f060:	e7bb      	b.n	801efda <localtime_r+0x11a>
 801f062:	2b00      	cmp	r3, #0
 801f064:	dab3      	bge.n	801efce <localtime_r+0x10e>
 801f066:	3901      	subs	r1, #1
 801f068:	333c      	adds	r3, #60	; 0x3c
 801f06a:	6061      	str	r1, [r4, #4]
 801f06c:	6023      	str	r3, [r4, #0]
 801f06e:	e7ae      	b.n	801efce <localtime_r+0x10e>
 801f070:	4b23      	ldr	r3, [pc, #140]	; (801f100 <localtime_r+0x240>)
 801f072:	17fa      	asrs	r2, r7, #31
 801f074:	fb83 1307 	smull	r1, r3, r3, r7
 801f078:	ebc2 1363 	rsb	r3, r2, r3, asr #5
 801f07c:	2164      	movs	r1, #100	; 0x64
 801f07e:	fb01 7313 	mls	r3, r1, r3, r7
 801f082:	2b00      	cmp	r3, #0
 801f084:	f43f af2f 	beq.w	801eee6 <localtime_r+0x26>
 801f088:	2301      	movs	r3, #1
 801f08a:	e738      	b.n	801eefe <localtime_r+0x3e>
 801f08c:	f04f 33ff 	mov.w	r3, #4294967295
 801f090:	6223      	str	r3, [r4, #32]
 801f092:	e768      	b.n	801ef66 <localtime_r+0xa6>
 801f094:	2301      	movs	r3, #1
 801f096:	6223      	str	r3, [r4, #32]
 801f098:	e756      	b.n	801ef48 <localtime_r+0x88>
 801f09a:	6963      	ldr	r3, [r4, #20]
 801f09c:	2200      	movs	r2, #0
 801f09e:	3301      	adds	r3, #1
 801f0a0:	6163      	str	r3, [r4, #20]
 801f0a2:	6122      	str	r2, [r4, #16]
 801f0a4:	61e2      	str	r2, [r4, #28]
 801f0a6:	e7b3      	b.n	801f010 <localtime_r+0x150>
 801f0a8:	6963      	ldr	r3, [r4, #20]
 801f0aa:	1e5a      	subs	r2, r3, #1
 801f0ac:	210b      	movs	r1, #11
 801f0ae:	6162      	str	r2, [r4, #20]
 801f0b0:	0792      	lsls	r2, r2, #30
 801f0b2:	6121      	str	r1, [r4, #16]
 801f0b4:	d013      	beq.n	801f0de <localtime_r+0x21e>
 801f0b6:	f203 716b 	addw	r1, r3, #1899	; 0x76b
 801f0ba:	17ca      	asrs	r2, r1, #31
 801f0bc:	4b10      	ldr	r3, [pc, #64]	; (801f100 <localtime_r+0x240>)
 801f0be:	fb83 0301 	smull	r0, r3, r3, r1
 801f0c2:	ebc2 12e3 	rsb	r2, r2, r3, asr #7
 801f0c6:	f44f 73c8 	mov.w	r3, #400	; 0x190
 801f0ca:	fb03 1312 	mls	r3, r3, r2, r1
 801f0ce:	fab3 f383 	clz	r3, r3
 801f0d2:	095b      	lsrs	r3, r3, #5
 801f0d4:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 801f0d8:	61e3      	str	r3, [r4, #28]
 801f0da:	232c      	movs	r3, #44	; 0x2c
 801f0dc:	e7b3      	b.n	801f046 <localtime_r+0x186>
 801f0de:	4a08      	ldr	r2, [pc, #32]	; (801f100 <localtime_r+0x240>)
 801f0e0:	f203 716b 	addw	r1, r3, #1899	; 0x76b
 801f0e4:	fb82 2301 	smull	r2, r3, r2, r1
 801f0e8:	17ca      	asrs	r2, r1, #31
 801f0ea:	ebc2 1363 	rsb	r3, r2, r3, asr #5
 801f0ee:	2064      	movs	r0, #100	; 0x64
 801f0f0:	fb00 1313 	mls	r3, r0, r3, r1
 801f0f4:	2b00      	cmp	r3, #0
 801f0f6:	d0e1      	beq.n	801f0bc <localtime_r+0x1fc>
 801f0f8:	f240 136d 	movw	r3, #365	; 0x16d
 801f0fc:	e7ec      	b.n	801f0d8 <localtime_r+0x218>
 801f0fe:	bf00      	nop
 801f100:	51eb851f 	.word	0x51eb851f
 801f104:	08025b18 	.word	0x08025b18
 801f108:	2001220c 	.word	0x2001220c
 801f10c:	91a2b3c5 	.word	0x91a2b3c5
 801f110:	88888889 	.word	0x88888889

0801f114 <malloc>:
 801f114:	4b02      	ldr	r3, [pc, #8]	; (801f120 <malloc+0xc>)
 801f116:	4601      	mov	r1, r0
 801f118:	6818      	ldr	r0, [r3, #0]
 801f11a:	f7f6 be53 	b.w	8015dc4 <_malloc_r>
 801f11e:	bf00      	nop
 801f120:	20010580 	.word	0x20010580

0801f124 <free>:
 801f124:	4b02      	ldr	r3, [pc, #8]	; (801f130 <free+0xc>)
 801f126:	4601      	mov	r1, r0
 801f128:	6818      	ldr	r0, [r3, #0]
 801f12a:	f7f6 be75 	b.w	8015e18 <_free_r>
 801f12e:	bf00      	nop
 801f130:	20010580 	.word	0x20010580

0801f134 <memset>:
 801f134:	b470      	push	{r4, r5, r6}
 801f136:	0784      	lsls	r4, r0, #30
 801f138:	d046      	beq.n	801f1c8 <memset+0x94>
 801f13a:	1e54      	subs	r4, r2, #1
 801f13c:	2a00      	cmp	r2, #0
 801f13e:	d041      	beq.n	801f1c4 <memset+0x90>
 801f140:	b2cd      	uxtb	r5, r1
 801f142:	4603      	mov	r3, r0
 801f144:	e002      	b.n	801f14c <memset+0x18>
 801f146:	1e62      	subs	r2, r4, #1
 801f148:	b3e4      	cbz	r4, 801f1c4 <memset+0x90>
 801f14a:	4614      	mov	r4, r2
 801f14c:	f803 5b01 	strb.w	r5, [r3], #1
 801f150:	079a      	lsls	r2, r3, #30
 801f152:	d1f8      	bne.n	801f146 <memset+0x12>
 801f154:	2c03      	cmp	r4, #3
 801f156:	d92e      	bls.n	801f1b6 <memset+0x82>
 801f158:	b2cd      	uxtb	r5, r1
 801f15a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 801f15e:	2c0f      	cmp	r4, #15
 801f160:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 801f164:	d919      	bls.n	801f19a <memset+0x66>
 801f166:	f103 0210 	add.w	r2, r3, #16
 801f16a:	4626      	mov	r6, r4
 801f16c:	3e10      	subs	r6, #16
 801f16e:	2e0f      	cmp	r6, #15
 801f170:	f842 5c10 	str.w	r5, [r2, #-16]
 801f174:	f842 5c0c 	str.w	r5, [r2, #-12]
 801f178:	f842 5c08 	str.w	r5, [r2, #-8]
 801f17c:	f842 5c04 	str.w	r5, [r2, #-4]
 801f180:	f102 0210 	add.w	r2, r2, #16
 801f184:	d8f2      	bhi.n	801f16c <memset+0x38>
 801f186:	f1a4 0210 	sub.w	r2, r4, #16
 801f18a:	f022 020f 	bic.w	r2, r2, #15
 801f18e:	f004 040f 	and.w	r4, r4, #15
 801f192:	3210      	adds	r2, #16
 801f194:	2c03      	cmp	r4, #3
 801f196:	4413      	add	r3, r2
 801f198:	d90d      	bls.n	801f1b6 <memset+0x82>
 801f19a:	461e      	mov	r6, r3
 801f19c:	4622      	mov	r2, r4
 801f19e:	3a04      	subs	r2, #4
 801f1a0:	2a03      	cmp	r2, #3
 801f1a2:	f846 5b04 	str.w	r5, [r6], #4
 801f1a6:	d8fa      	bhi.n	801f19e <memset+0x6a>
 801f1a8:	1f22      	subs	r2, r4, #4
 801f1aa:	f022 0203 	bic.w	r2, r2, #3
 801f1ae:	3204      	adds	r2, #4
 801f1b0:	4413      	add	r3, r2
 801f1b2:	f004 0403 	and.w	r4, r4, #3
 801f1b6:	b12c      	cbz	r4, 801f1c4 <memset+0x90>
 801f1b8:	b2c9      	uxtb	r1, r1
 801f1ba:	441c      	add	r4, r3
 801f1bc:	f803 1b01 	strb.w	r1, [r3], #1
 801f1c0:	42a3      	cmp	r3, r4
 801f1c2:	d1fb      	bne.n	801f1bc <memset+0x88>
 801f1c4:	bc70      	pop	{r4, r5, r6}
 801f1c6:	4770      	bx	lr
 801f1c8:	4614      	mov	r4, r2
 801f1ca:	4603      	mov	r3, r0
 801f1cc:	e7c2      	b.n	801f154 <memset+0x20>
 801f1ce:	bf00      	nop

0801f1d0 <validate_structure>:
 801f1d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801f1d4:	6801      	ldr	r1, [r0, #0]
 801f1d6:	293b      	cmp	r1, #59	; 0x3b
 801f1d8:	b083      	sub	sp, #12
 801f1da:	4604      	mov	r4, r0
 801f1dc:	f200 80bc 	bhi.w	801f358 <validate_structure+0x188>
 801f1e0:	6841      	ldr	r1, [r0, #4]
 801f1e2:	293b      	cmp	r1, #59	; 0x3b
 801f1e4:	f200 80ab 	bhi.w	801f33e <validate_structure+0x16e>
 801f1e8:	68a1      	ldr	r1, [r4, #8]
 801f1ea:	2917      	cmp	r1, #23
 801f1ec:	f200 809a 	bhi.w	801f324 <validate_structure+0x154>
 801f1f0:	6921      	ldr	r1, [r4, #16]
 801f1f2:	290b      	cmp	r1, #11
 801f1f4:	f200 8089 	bhi.w	801f30a <validate_structure+0x13a>
 801f1f8:	6963      	ldr	r3, [r4, #20]
 801f1fa:	079e      	lsls	r6, r3, #30
 801f1fc:	d13d      	bne.n	801f27a <validate_structure+0xaa>
 801f1fe:	4875      	ldr	r0, [pc, #468]	; (801f3d4 <validate_structure+0x204>)
 801f200:	17da      	asrs	r2, r3, #31
 801f202:	fb80 6503 	smull	r6, r5, r0, r3
 801f206:	ebc2 1265 	rsb	r2, r2, r5, asr #5
 801f20a:	2564      	movs	r5, #100	; 0x64
 801f20c:	fb05 3212 	mls	r2, r5, r2, r3
 801f210:	2a00      	cmp	r2, #0
 801f212:	d173      	bne.n	801f2fc <validate_structure+0x12c>
 801f214:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 801f218:	fb80 2003 	smull	r2, r0, r0, r3
 801f21c:	17da      	asrs	r2, r3, #31
 801f21e:	ebc2 10e0 	rsb	r0, r2, r0, asr #7
 801f222:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801f226:	fb02 3310 	mls	r3, r2, r0, r3
 801f22a:	2b00      	cmp	r3, #0
 801f22c:	bf0c      	ite	eq
 801f22e:	251d      	moveq	r5, #29
 801f230:	251c      	movne	r5, #28
 801f232:	68e3      	ldr	r3, [r4, #12]
 801f234:	2b00      	cmp	r3, #0
 801f236:	dc25      	bgt.n	801f284 <validate_structure+0xb4>
 801f238:	4e67      	ldr	r6, [pc, #412]	; (801f3d8 <validate_structure+0x208>)
 801f23a:	4f66      	ldr	r7, [pc, #408]	; (801f3d4 <validate_structure+0x204>)
 801f23c:	f04f 0e64 	mov.w	lr, #100	; 0x64
 801f240:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 801f244:	e006      	b.n	801f254 <validate_structure+0x84>
 801f246:	2901      	cmp	r1, #1
 801f248:	d05a      	beq.n	801f300 <validate_structure+0x130>
 801f24a:	f856 2021 	ldr.w	r2, [r6, r1, lsl #2]
 801f24e:	4413      	add	r3, r2
 801f250:	2b00      	cmp	r3, #0
 801f252:	dc39      	bgt.n	801f2c8 <validate_structure+0xf8>
 801f254:	f111 31ff 	adds.w	r1, r1, #4294967295
 801f258:	d2f5      	bcs.n	801f246 <validate_structure+0x76>
 801f25a:	6961      	ldr	r1, [r4, #20]
 801f25c:	1e4a      	subs	r2, r1, #1
 801f25e:	0795      	lsls	r5, r2, #30
 801f260:	6162      	str	r2, [r4, #20]
 801f262:	d14f      	bne.n	801f304 <validate_structure+0x134>
 801f264:	fb87 0502 	smull	r0, r5, r7, r2
 801f268:	17d0      	asrs	r0, r2, #31
 801f26a:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 801f26e:	fb0e 2210 	mls	r2, lr, r0, r2
 801f272:	2a00      	cmp	r2, #0
 801f274:	d07d      	beq.n	801f372 <validate_structure+0x1a2>
 801f276:	251d      	movs	r5, #29
 801f278:	e045      	b.n	801f306 <validate_structure+0x136>
 801f27a:	68e3      	ldr	r3, [r4, #12]
 801f27c:	2b00      	cmp	r3, #0
 801f27e:	f04f 051c 	mov.w	r5, #28
 801f282:	ddd9      	ble.n	801f238 <validate_structure+0x68>
 801f284:	4f54      	ldr	r7, [pc, #336]	; (801f3d8 <validate_structure+0x208>)
 801f286:	f8df c14c 	ldr.w	ip, [pc, #332]	; 801f3d4 <validate_structure+0x204>
 801f28a:	f04f 0e00 	mov.w	lr, #0
 801f28e:	f04f 0864 	mov.w	r8, #100	; 0x64
 801f292:	f44f 79c8 	mov.w	r9, #400	; 0x190
 801f296:	1c4a      	adds	r2, r1, #1
 801f298:	eb07 0081 	add.w	r0, r7, r1, lsl #2
 801f29c:	e00b      	b.n	801f2b6 <validate_structure+0xe6>
 801f29e:	6806      	ldr	r6, [r0, #0]
 801f2a0:	429e      	cmp	r6, r3
 801f2a2:	eba3 0306 	sub.w	r3, r3, r6
 801f2a6:	da11      	bge.n	801f2cc <validate_structure+0xfc>
 801f2a8:	2a0c      	cmp	r2, #12
 801f2aa:	60e3      	str	r3, [r4, #12]
 801f2ac:	6122      	str	r2, [r4, #16]
 801f2ae:	d010      	beq.n	801f2d2 <validate_structure+0x102>
 801f2b0:	3101      	adds	r1, #1
 801f2b2:	3201      	adds	r2, #1
 801f2b4:	3004      	adds	r0, #4
 801f2b6:	2901      	cmp	r1, #1
 801f2b8:	d1f1      	bne.n	801f29e <validate_structure+0xce>
 801f2ba:	429d      	cmp	r5, r3
 801f2bc:	eba3 0305 	sub.w	r3, r3, r5
 801f2c0:	da04      	bge.n	801f2cc <validate_structure+0xfc>
 801f2c2:	60e3      	str	r3, [r4, #12]
 801f2c4:	6122      	str	r2, [r4, #16]
 801f2c6:	e7f3      	b.n	801f2b0 <validate_structure+0xe0>
 801f2c8:	6121      	str	r1, [r4, #16]
 801f2ca:	60e3      	str	r3, [r4, #12]
 801f2cc:	b003      	add	sp, #12
 801f2ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801f2d2:	6961      	ldr	r1, [r4, #20]
 801f2d4:	f8c4 e010 	str.w	lr, [r4, #16]
 801f2d8:	1c4a      	adds	r2, r1, #1
 801f2da:	0790      	lsls	r0, r2, #30
 801f2dc:	6162      	str	r2, [r4, #20]
 801f2de:	d002      	beq.n	801f2e6 <validate_structure+0x116>
 801f2e0:	251c      	movs	r5, #28
 801f2e2:	2100      	movs	r1, #0
 801f2e4:	e7d7      	b.n	801f296 <validate_structure+0xc6>
 801f2e6:	fb8c 0502 	smull	r0, r5, ip, r2
 801f2ea:	17d0      	asrs	r0, r2, #31
 801f2ec:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 801f2f0:	fb08 2210 	mls	r2, r8, r0, r2
 801f2f4:	2a00      	cmp	r2, #0
 801f2f6:	d04a      	beq.n	801f38e <validate_structure+0x1be>
 801f2f8:	251d      	movs	r5, #29
 801f2fa:	e7f2      	b.n	801f2e2 <validate_structure+0x112>
 801f2fc:	251d      	movs	r5, #29
 801f2fe:	e798      	b.n	801f232 <validate_structure+0x62>
 801f300:	462a      	mov	r2, r5
 801f302:	e7a4      	b.n	801f24e <validate_structure+0x7e>
 801f304:	251c      	movs	r5, #28
 801f306:	210b      	movs	r1, #11
 801f308:	e79f      	b.n	801f24a <validate_structure+0x7a>
 801f30a:	220c      	movs	r2, #12
 801f30c:	4668      	mov	r0, sp
 801f30e:	f000 ffa7 	bl	8020260 <div>
 801f312:	6962      	ldr	r2, [r4, #20]
 801f314:	9b00      	ldr	r3, [sp, #0]
 801f316:	9901      	ldr	r1, [sp, #4]
 801f318:	4413      	add	r3, r2
 801f31a:	2900      	cmp	r1, #0
 801f31c:	6163      	str	r3, [r4, #20]
 801f31e:	db53      	blt.n	801f3c8 <validate_structure+0x1f8>
 801f320:	6121      	str	r1, [r4, #16]
 801f322:	e76a      	b.n	801f1fa <validate_structure+0x2a>
 801f324:	2218      	movs	r2, #24
 801f326:	4668      	mov	r0, sp
 801f328:	f000 ff9a 	bl	8020260 <div>
 801f32c:	68e1      	ldr	r1, [r4, #12]
 801f32e:	9b00      	ldr	r3, [sp, #0]
 801f330:	9a01      	ldr	r2, [sp, #4]
 801f332:	440b      	add	r3, r1
 801f334:	2a00      	cmp	r2, #0
 801f336:	60e3      	str	r3, [r4, #12]
 801f338:	db41      	blt.n	801f3be <validate_structure+0x1ee>
 801f33a:	60a2      	str	r2, [r4, #8]
 801f33c:	e758      	b.n	801f1f0 <validate_structure+0x20>
 801f33e:	223c      	movs	r2, #60	; 0x3c
 801f340:	4668      	mov	r0, sp
 801f342:	f000 ff8d 	bl	8020260 <div>
 801f346:	68a1      	ldr	r1, [r4, #8]
 801f348:	9b00      	ldr	r3, [sp, #0]
 801f34a:	9a01      	ldr	r2, [sp, #4]
 801f34c:	4419      	add	r1, r3
 801f34e:	2a00      	cmp	r2, #0
 801f350:	60a1      	str	r1, [r4, #8]
 801f352:	db2f      	blt.n	801f3b4 <validate_structure+0x1e4>
 801f354:	6062      	str	r2, [r4, #4]
 801f356:	e748      	b.n	801f1ea <validate_structure+0x1a>
 801f358:	223c      	movs	r2, #60	; 0x3c
 801f35a:	4668      	mov	r0, sp
 801f35c:	f000 ff80 	bl	8020260 <div>
 801f360:	6863      	ldr	r3, [r4, #4]
 801f362:	9900      	ldr	r1, [sp, #0]
 801f364:	9a01      	ldr	r2, [sp, #4]
 801f366:	4419      	add	r1, r3
 801f368:	2a00      	cmp	r2, #0
 801f36a:	6061      	str	r1, [r4, #4]
 801f36c:	db1d      	blt.n	801f3aa <validate_structure+0x1da>
 801f36e:	6022      	str	r2, [r4, #0]
 801f370:	e737      	b.n	801f1e2 <validate_structure+0x12>
 801f372:	f201 716b 	addw	r1, r1, #1899	; 0x76b
 801f376:	fb87 2001 	smull	r2, r0, r7, r1
 801f37a:	17ca      	asrs	r2, r1, #31
 801f37c:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 801f380:	fb0c 1112 	mls	r1, ip, r2, r1
 801f384:	2900      	cmp	r1, #0
 801f386:	bf14      	ite	ne
 801f388:	251c      	movne	r5, #28
 801f38a:	251d      	moveq	r5, #29
 801f38c:	e7bb      	b.n	801f306 <validate_structure+0x136>
 801f38e:	f201 716d 	addw	r1, r1, #1901	; 0x76d
 801f392:	fb8c 2001 	smull	r2, r0, ip, r1
 801f396:	17ca      	asrs	r2, r1, #31
 801f398:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 801f39c:	fb09 1112 	mls	r1, r9, r2, r1
 801f3a0:	2900      	cmp	r1, #0
 801f3a2:	bf14      	ite	ne
 801f3a4:	251c      	movne	r5, #28
 801f3a6:	251d      	moveq	r5, #29
 801f3a8:	e79b      	b.n	801f2e2 <validate_structure+0x112>
 801f3aa:	323c      	adds	r2, #60	; 0x3c
 801f3ac:	3901      	subs	r1, #1
 801f3ae:	6022      	str	r2, [r4, #0]
 801f3b0:	6061      	str	r1, [r4, #4]
 801f3b2:	e716      	b.n	801f1e2 <validate_structure+0x12>
 801f3b4:	323c      	adds	r2, #60	; 0x3c
 801f3b6:	3901      	subs	r1, #1
 801f3b8:	6062      	str	r2, [r4, #4]
 801f3ba:	60a1      	str	r1, [r4, #8]
 801f3bc:	e715      	b.n	801f1ea <validate_structure+0x1a>
 801f3be:	3218      	adds	r2, #24
 801f3c0:	3b01      	subs	r3, #1
 801f3c2:	60a2      	str	r2, [r4, #8]
 801f3c4:	60e3      	str	r3, [r4, #12]
 801f3c6:	e713      	b.n	801f1f0 <validate_structure+0x20>
 801f3c8:	310c      	adds	r1, #12
 801f3ca:	3b01      	subs	r3, #1
 801f3cc:	6121      	str	r1, [r4, #16]
 801f3ce:	6163      	str	r3, [r4, #20]
 801f3d0:	e713      	b.n	801f1fa <validate_structure+0x2a>
 801f3d2:	bf00      	nop
 801f3d4:	51eb851f 	.word	0x51eb851f
 801f3d8:	08025ae8 	.word	0x08025ae8

0801f3dc <mktime>:
 801f3dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f3e0:	4606      	mov	r6, r0
 801f3e2:	f000 ffb3 	bl	802034c <__gettzinfo>
 801f3e6:	4680      	mov	r8, r0
 801f3e8:	4630      	mov	r0, r6
 801f3ea:	f7ff fef1 	bl	801f1d0 <validate_structure>
 801f3ee:	4cbd      	ldr	r4, [pc, #756]	; (801f6e4 <mktime+0x308>)
 801f3f0:	6935      	ldr	r5, [r6, #16]
 801f3f2:	6873      	ldr	r3, [r6, #4]
 801f3f4:	6830      	ldr	r0, [r6, #0]
 801f3f6:	68f2      	ldr	r2, [r6, #12]
 801f3f8:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
 801f3fc:	68b1      	ldr	r1, [r6, #8]
 801f3fe:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 801f402:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 801f406:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
 801f40a:	3a01      	subs	r2, #1
 801f40c:	2d01      	cmp	r5, #1
 801f40e:	fb0e 3e01 	mla	lr, lr, r1, r3
 801f412:	4414      	add	r4, r2
 801f414:	6975      	ldr	r5, [r6, #20]
 801f416:	dd02      	ble.n	801f41e <mktime+0x42>
 801f418:	07ab      	lsls	r3, r5, #30
 801f41a:	f000 80c0 	beq.w	801f59e <mktime+0x1c2>
 801f41e:	f505 531c 	add.w	r3, r5, #9984	; 0x2700
 801f422:	3310      	adds	r3, #16
 801f424:	f644 6220 	movw	r2, #20000	; 0x4e20
 801f428:	4293      	cmp	r3, r2
 801f42a:	61f4      	str	r4, [r6, #28]
 801f42c:	f200 8153 	bhi.w	801f6d6 <mktime+0x2fa>
 801f430:	2d46      	cmp	r5, #70	; 0x46
 801f432:	dc55      	bgt.n	801f4e0 <mktime+0x104>
 801f434:	f000 8081 	beq.w	801f53a <mktime+0x15e>
 801f438:	2d45      	cmp	r5, #69	; 0x45
 801f43a:	f000 80f8 	beq.w	801f62e <mktime+0x252>
 801f43e:	48aa      	ldr	r0, [pc, #680]	; (801f6e8 <mktime+0x30c>)
 801f440:	2345      	movs	r3, #69	; 0x45
 801f442:	f240 196d 	movw	r9, #365	; 0x16d
 801f446:	2764      	movs	r7, #100	; 0x64
 801f448:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 801f44c:	e016      	b.n	801f47c <mktime+0xa0>
 801f44e:	f203 7b6c 	addw	fp, r3, #1900	; 0x76c
 801f452:	fb80 a10b 	smull	sl, r1, r0, fp
 801f456:	ea4f 7aeb 	mov.w	sl, fp, asr #31
 801f45a:	ebca 11e1 	rsb	r1, sl, r1, asr #7
 801f45e:	fb0c b111 	mls	r1, ip, r1, fp
 801f462:	2a00      	cmp	r2, #0
 801f464:	f040 80ca 	bne.w	801f5fc <mktime+0x220>
 801f468:	2900      	cmp	r1, #0
 801f46a:	bf14      	ite	ne
 801f46c:	464a      	movne	r2, r9
 801f46e:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 801f472:	3b01      	subs	r3, #1
 801f474:	42ab      	cmp	r3, r5
 801f476:	eba4 0402 	sub.w	r4, r4, r2
 801f47a:	d010      	beq.n	801f49e <mktime+0xc2>
 801f47c:	fb80 1203 	smull	r1, r2, r0, r3
 801f480:	17d9      	asrs	r1, r3, #31
 801f482:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 801f486:	f013 0f03 	tst.w	r3, #3
 801f48a:	fb07 3212 	mls	r2, r7, r2, r3
 801f48e:	d0de      	beq.n	801f44e <mktime+0x72>
 801f490:	3b01      	subs	r3, #1
 801f492:	f240 126d 	movw	r2, #365	; 0x16d
 801f496:	42ab      	cmp	r3, r5
 801f498:	eba4 0402 	sub.w	r4, r4, r2
 801f49c:	d1ee      	bne.n	801f47c <mktime+0xa0>
 801f49e:	07af      	lsls	r7, r5, #30
 801f4a0:	f040 80c5 	bne.w	801f62e <mktime+0x252>
 801f4a4:	4a90      	ldr	r2, [pc, #576]	; (801f6e8 <mktime+0x30c>)
 801f4a6:	17eb      	asrs	r3, r5, #31
 801f4a8:	fb82 0105 	smull	r0, r1, r2, r5
 801f4ac:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 801f4b0:	2164      	movs	r1, #100	; 0x64
 801f4b2:	fb01 5313 	mls	r3, r1, r3, r5
 801f4b6:	2b00      	cmp	r3, #0
 801f4b8:	f040 8108 	bne.w	801f6cc <mktime+0x2f0>
 801f4bc:	f205 716c 	addw	r1, r5, #1900	; 0x76c
 801f4c0:	fb82 3201 	smull	r3, r2, r2, r1
 801f4c4:	17cb      	asrs	r3, r1, #31
 801f4c6:	ebc3 12e2 	rsb	r2, r3, r2, asr #7
 801f4ca:	f44f 73c8 	mov.w	r3, #400	; 0x190
 801f4ce:	fb03 1312 	mls	r3, r3, r2, r1
 801f4d2:	2b00      	cmp	r3, #0
 801f4d4:	f240 136d 	movw	r3, #365	; 0x16d
 801f4d8:	bf08      	it	eq
 801f4da:	f44f 73b7 	moveq.w	r3, #366	; 0x16e
 801f4de:	e0a8      	b.n	801f632 <mktime+0x256>
 801f4e0:	4881      	ldr	r0, [pc, #516]	; (801f6e8 <mktime+0x30c>)
 801f4e2:	2346      	movs	r3, #70	; 0x46
 801f4e4:	f240 196d 	movw	r9, #365	; 0x16d
 801f4e8:	2764      	movs	r7, #100	; 0x64
 801f4ea:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 801f4ee:	e014      	b.n	801f51a <mktime+0x13e>
 801f4f0:	f203 7b6c 	addw	fp, r3, #1900	; 0x76c
 801f4f4:	fb80 a10b 	smull	sl, r1, r0, fp
 801f4f8:	ea4f 7aeb 	mov.w	sl, fp, asr #31
 801f4fc:	ebca 11e1 	rsb	r1, sl, r1, asr #7
 801f500:	fb0c b111 	mls	r1, ip, r1, fp
 801f504:	2a00      	cmp	r2, #0
 801f506:	d156      	bne.n	801f5b6 <mktime+0x1da>
 801f508:	2900      	cmp	r1, #0
 801f50a:	bf14      	ite	ne
 801f50c:	464a      	movne	r2, r9
 801f50e:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 801f512:	3301      	adds	r3, #1
 801f514:	42ab      	cmp	r3, r5
 801f516:	4414      	add	r4, r2
 801f518:	d00f      	beq.n	801f53a <mktime+0x15e>
 801f51a:	fb80 1203 	smull	r1, r2, r0, r3
 801f51e:	17d9      	asrs	r1, r3, #31
 801f520:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 801f524:	f013 0f03 	tst.w	r3, #3
 801f528:	fb07 3212 	mls	r2, r7, r2, r3
 801f52c:	d0e0      	beq.n	801f4f0 <mktime+0x114>
 801f52e:	3301      	adds	r3, #1
 801f530:	f240 126d 	movw	r2, #365	; 0x16d
 801f534:	42ab      	cmp	r3, r5
 801f536:	4414      	add	r4, r2
 801f538:	d1ef      	bne.n	801f51a <mktime+0x13e>
 801f53a:	486c      	ldr	r0, [pc, #432]	; (801f6ec <mktime+0x310>)
 801f53c:	fb00 e904 	mla	r9, r0, r4, lr
 801f540:	f000 fc98 	bl	801fe74 <__tz_lock>
 801f544:	4b6a      	ldr	r3, [pc, #424]	; (801f6f0 <mktime+0x314>)
 801f546:	681f      	ldr	r7, [r3, #0]
 801f548:	2f00      	cmp	r7, #0
 801f54a:	d052      	beq.n	801f5f2 <mktime+0x216>
 801f54c:	6a37      	ldr	r7, [r6, #32]
 801f54e:	6970      	ldr	r0, [r6, #20]
 801f550:	f8d8 3004 	ldr.w	r3, [r8, #4]
 801f554:	2f01      	cmp	r7, #1
 801f556:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 801f55a:	bfa8      	it	ge
 801f55c:	2701      	movge	r7, #1
 801f55e:	4283      	cmp	r3, r0
 801f560:	d02c      	beq.n	801f5bc <mktime+0x1e0>
 801f562:	f000 fbc1 	bl	801fce8 <__tzcalc_limits>
 801f566:	bb48      	cbnz	r0, 801f5bc <mktime+0x1e0>
 801f568:	2f01      	cmp	r7, #1
 801f56a:	d142      	bne.n	801f5f2 <mktime+0x216>
 801f56c:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 801f570:	eb09 0501 	add.w	r5, r9, r1
 801f574:	2701      	movs	r7, #1
 801f576:	f000 fc7f 	bl	801fe78 <__tz_unlock>
 801f57a:	4a5e      	ldr	r2, [pc, #376]	; (801f6f4 <mktime+0x318>)
 801f57c:	6237      	str	r7, [r6, #32]
 801f57e:	3404      	adds	r4, #4
 801f580:	fb84 2302 	smull	r2, r3, r4, r2
 801f584:	18e2      	adds	r2, r4, r3
 801f586:	17e3      	asrs	r3, r4, #31
 801f588:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 801f58c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801f590:	1ae3      	subs	r3, r4, r3
 801f592:	bf48      	it	mi
 801f594:	3307      	addmi	r3, #7
 801f596:	61b3      	str	r3, [r6, #24]
 801f598:	4628      	mov	r0, r5
 801f59a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f59e:	4a52      	ldr	r2, [pc, #328]	; (801f6e8 <mktime+0x30c>)
 801f5a0:	17eb      	asrs	r3, r5, #31
 801f5a2:	fb82 0105 	smull	r0, r1, r2, r5
 801f5a6:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 801f5aa:	2164      	movs	r1, #100	; 0x64
 801f5ac:	fb01 5313 	mls	r3, r1, r3, r5
 801f5b0:	b33b      	cbz	r3, 801f602 <mktime+0x226>
 801f5b2:	3401      	adds	r4, #1
 801f5b4:	e733      	b.n	801f41e <mktime+0x42>
 801f5b6:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 801f5ba:	e7aa      	b.n	801f512 <mktime+0x136>
 801f5bc:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 801f5c0:	f8d8 0020 	ldr.w	r0, [r8, #32]
 801f5c4:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 801f5c8:	f8d8 301c 	ldr.w	r3, [r8, #28]
 801f5cc:	ebc0 0e02 	rsb	lr, r0, r2
 801f5d0:	45f1      	cmp	r9, lr
 801f5d2:	eba3 0301 	sub.w	r3, r3, r1
 801f5d6:	db02      	blt.n	801f5de <mktime+0x202>
 801f5d8:	1a52      	subs	r2, r2, r1
 801f5da:	4591      	cmp	r9, r2
 801f5dc:	dbc4      	blt.n	801f568 <mktime+0x18c>
 801f5de:	f8d8 2000 	ldr.w	r2, [r8]
 801f5e2:	b1ea      	cbz	r2, 801f620 <mktime+0x244>
 801f5e4:	4599      	cmp	r9, r3
 801f5e6:	da26      	bge.n	801f636 <mktime+0x25a>
 801f5e8:	2f00      	cmp	r7, #0
 801f5ea:	db72      	blt.n	801f6d2 <mktime+0x2f6>
 801f5ec:	f04f 0a00 	mov.w	sl, #0
 801f5f0:	e029      	b.n	801f646 <mktime+0x26a>
 801f5f2:	f8d8 0020 	ldr.w	r0, [r8, #32]
 801f5f6:	eb09 0500 	add.w	r5, r9, r0
 801f5fa:	e7bc      	b.n	801f576 <mktime+0x19a>
 801f5fc:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 801f600:	e737      	b.n	801f472 <mktime+0x96>
 801f602:	f205 716c 	addw	r1, r5, #1900	; 0x76c
 801f606:	fb82 3201 	smull	r3, r2, r2, r1
 801f60a:	17cb      	asrs	r3, r1, #31
 801f60c:	ebc3 12e2 	rsb	r2, r3, r2, asr #7
 801f610:	f44f 73c8 	mov.w	r3, #400	; 0x190
 801f614:	fb03 1212 	mls	r2, r3, r2, r1
 801f618:	2a00      	cmp	r2, #0
 801f61a:	f47f af00 	bne.w	801f41e <mktime+0x42>
 801f61e:	e7c8      	b.n	801f5b2 <mktime+0x1d6>
 801f620:	4599      	cmp	r9, r3
 801f622:	db08      	blt.n	801f636 <mktime+0x25a>
 801f624:	2f00      	cmp	r7, #0
 801f626:	dba3      	blt.n	801f570 <mktime+0x194>
 801f628:	f04f 0a01 	mov.w	sl, #1
 801f62c:	e00b      	b.n	801f646 <mktime+0x26a>
 801f62e:	f240 136d 	movw	r3, #365	; 0x16d
 801f632:	1ae4      	subs	r4, r4, r3
 801f634:	e781      	b.n	801f53a <mktime+0x15e>
 801f636:	45f1      	cmp	r9, lr
 801f638:	bfac      	ite	ge
 801f63a:	f04f 0a00 	movge.w	sl, #0
 801f63e:	f04f 0a01 	movlt.w	sl, #1
 801f642:	2f00      	cmp	r7, #0
 801f644:	db03      	blt.n	801f64e <mktime+0x272>
 801f646:	ea8a 0707 	eor.w	r7, sl, r7
 801f64a:	2f01      	cmp	r7, #1
 801f64c:	d001      	beq.n	801f652 <mktime+0x276>
 801f64e:	4657      	mov	r7, sl
 801f650:	e78a      	b.n	801f568 <mktime+0x18c>
 801f652:	f08a 0301 	eor.w	r3, sl, #1
 801f656:	425a      	negs	r2, r3
 801f658:	1a41      	subs	r1, r0, r1
 801f65a:	4051      	eors	r1, r2
 801f65c:	6832      	ldr	r2, [r6, #0]
 801f65e:	68f7      	ldr	r7, [r6, #12]
 801f660:	440b      	add	r3, r1
 801f662:	441a      	add	r2, r3
 801f664:	6032      	str	r2, [r6, #0]
 801f666:	4630      	mov	r0, r6
 801f668:	4499      	add	r9, r3
 801f66a:	f7ff fdb1 	bl	801f1d0 <validate_structure>
 801f66e:	68f3      	ldr	r3, [r6, #12]
 801f670:	1bdb      	subs	r3, r3, r7
 801f672:	d0ec      	beq.n	801f64e <mktime+0x272>
 801f674:	2b01      	cmp	r3, #1
 801f676:	dd5e      	ble.n	801f736 <mktime+0x35a>
 801f678:	f04f 33ff 	mov.w	r3, #4294967295
 801f67c:	69f2      	ldr	r2, [r6, #28]
 801f67e:	441c      	add	r4, r3
 801f680:	189b      	adds	r3, r3, r2
 801f682:	d439      	bmi.n	801f6f8 <mktime+0x31c>
 801f684:	07aa      	lsls	r2, r5, #30
 801f686:	d12a      	bne.n	801f6de <mktime+0x302>
 801f688:	4917      	ldr	r1, [pc, #92]	; (801f6e8 <mktime+0x30c>)
 801f68a:	17ea      	asrs	r2, r5, #31
 801f68c:	fb81 7005 	smull	r7, r0, r1, r5
 801f690:	ebc2 1260 	rsb	r2, r2, r0, asr #5
 801f694:	2064      	movs	r0, #100	; 0x64
 801f696:	fb00 5212 	mls	r2, r0, r2, r5
 801f69a:	2a00      	cmp	r2, #0
 801f69c:	d14f      	bne.n	801f73e <mktime+0x362>
 801f69e:	f205 756c 	addw	r5, r5, #1900	; 0x76c
 801f6a2:	fb81 1205 	smull	r1, r2, r1, r5
 801f6a6:	17e9      	asrs	r1, r5, #31
 801f6a8:	ebc1 11e2 	rsb	r1, r1, r2, asr #7
 801f6ac:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801f6b0:	fb02 5211 	mls	r2, r2, r1, r5
 801f6b4:	2a00      	cmp	r2, #0
 801f6b6:	f240 126d 	movw	r2, #365	; 0x16d
 801f6ba:	bf08      	it	eq
 801f6bc:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 801f6c0:	429a      	cmp	r2, r3
 801f6c2:	bfd8      	it	le
 801f6c4:	1a9b      	suble	r3, r3, r2
 801f6c6:	61f3      	str	r3, [r6, #28]
 801f6c8:	4657      	mov	r7, sl
 801f6ca:	e74d      	b.n	801f568 <mktime+0x18c>
 801f6cc:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 801f6d0:	e7af      	b.n	801f632 <mktime+0x256>
 801f6d2:	2700      	movs	r7, #0
 801f6d4:	e78f      	b.n	801f5f6 <mktime+0x21a>
 801f6d6:	f04f 30ff 	mov.w	r0, #4294967295
 801f6da:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f6de:	f240 126d 	movw	r2, #365	; 0x16d
 801f6e2:	e7ed      	b.n	801f6c0 <mktime+0x2e4>
 801f6e4:	08025ab8 	.word	0x08025ab8
 801f6e8:	51eb851f 	.word	0x51eb851f
 801f6ec:	00015180 	.word	0x00015180
 801f6f0:	2001220c 	.word	0x2001220c
 801f6f4:	92492493 	.word	0x92492493
 801f6f8:	1e68      	subs	r0, r5, #1
 801f6fa:	0781      	lsls	r1, r0, #30
 801f6fc:	d122      	bne.n	801f744 <mktime+0x368>
 801f6fe:	4914      	ldr	r1, [pc, #80]	; (801f750 <mktime+0x374>)
 801f700:	17c2      	asrs	r2, r0, #31
 801f702:	fb81 7300 	smull	r7, r3, r1, r0
 801f706:	ebc2 1263 	rsb	r2, r2, r3, asr #5
 801f70a:	2364      	movs	r3, #100	; 0x64
 801f70c:	fb03 0312 	mls	r3, r3, r2, r0
 801f710:	b9db      	cbnz	r3, 801f74a <mktime+0x36e>
 801f712:	f205 756b 	addw	r5, r5, #1899	; 0x76b
 801f716:	fb81 3105 	smull	r3, r1, r1, r5
 801f71a:	17ea      	asrs	r2, r5, #31
 801f71c:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 801f720:	f44f 73c8 	mov.w	r3, #400	; 0x190
 801f724:	fb03 5312 	mls	r3, r3, r2, r5
 801f728:	2b00      	cmp	r3, #0
 801f72a:	f240 136d 	movw	r3, #365	; 0x16d
 801f72e:	bf18      	it	ne
 801f730:	f44f 73b6 	movne.w	r3, #364	; 0x16c
 801f734:	e7c7      	b.n	801f6c6 <mktime+0x2ea>
 801f736:	1c98      	adds	r0, r3, #2
 801f738:	bfd8      	it	le
 801f73a:	2301      	movle	r3, #1
 801f73c:	e79e      	b.n	801f67c <mktime+0x2a0>
 801f73e:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 801f742:	e7bd      	b.n	801f6c0 <mktime+0x2e4>
 801f744:	f44f 73b6 	mov.w	r3, #364	; 0x16c
 801f748:	e7bd      	b.n	801f6c6 <mktime+0x2ea>
 801f74a:	f240 136d 	movw	r3, #365	; 0x16d
 801f74e:	e7ba      	b.n	801f6c6 <mktime+0x2ea>
 801f750:	51eb851f 	.word	0x51eb851f

0801f754 <putenv>:
 801f754:	4b02      	ldr	r3, [pc, #8]	; (801f760 <putenv+0xc>)
 801f756:	4601      	mov	r1, r0
 801f758:	6818      	ldr	r0, [r3, #0]
 801f75a:	f000 b803 	b.w	801f764 <_putenv_r>
 801f75e:	bf00      	nop
 801f760:	20010580 	.word	0x20010580

0801f764 <_putenv_r>:
 801f764:	b570      	push	{r4, r5, r6, lr}
 801f766:	4606      	mov	r6, r0
 801f768:	f000 f962 	bl	801fa30 <_strdup_r>
 801f76c:	b1a0      	cbz	r0, 801f798 <_putenv_r+0x34>
 801f76e:	213d      	movs	r1, #61	; 0x3d
 801f770:	4605      	mov	r5, r0
 801f772:	f000 f8f7 	bl	801f964 <strchr>
 801f776:	b188      	cbz	r0, 801f79c <_putenv_r+0x38>
 801f778:	4602      	mov	r2, r0
 801f77a:	2300      	movs	r3, #0
 801f77c:	f802 3b01 	strb.w	r3, [r2], #1
 801f780:	4629      	mov	r1, r5
 801f782:	2301      	movs	r3, #1
 801f784:	4630      	mov	r0, r6
 801f786:	f000 f80f 	bl	801f7a8 <_setenv_r>
 801f78a:	4629      	mov	r1, r5
 801f78c:	4604      	mov	r4, r0
 801f78e:	4630      	mov	r0, r6
 801f790:	f7f6 fb42 	bl	8015e18 <_free_r>
 801f794:	4620      	mov	r0, r4
 801f796:	bd70      	pop	{r4, r5, r6, pc}
 801f798:	2001      	movs	r0, #1
 801f79a:	bd70      	pop	{r4, r5, r6, pc}
 801f79c:	4630      	mov	r0, r6
 801f79e:	4629      	mov	r1, r5
 801f7a0:	f7f6 fb3a 	bl	8015e18 <_free_r>
 801f7a4:	2001      	movs	r0, #1
 801f7a6:	bd70      	pop	{r4, r5, r6, pc}

0801f7a8 <_setenv_r>:
 801f7a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f7ac:	460d      	mov	r5, r1
 801f7ae:	b083      	sub	sp, #12
 801f7b0:	4606      	mov	r6, r0
 801f7b2:	213d      	movs	r1, #61	; 0x3d
 801f7b4:	4628      	mov	r0, r5
 801f7b6:	4614      	mov	r4, r2
 801f7b8:	461f      	mov	r7, r3
 801f7ba:	f000 f8d3 	bl	801f964 <strchr>
 801f7be:	2800      	cmp	r0, #0
 801f7c0:	d17e      	bne.n	801f8c0 <_setenv_r+0x118>
 801f7c2:	4630      	mov	r0, r6
 801f7c4:	f000 fd6c 	bl	80202a0 <__env_lock>
 801f7c8:	4620      	mov	r0, r4
 801f7ca:	f000 f945 	bl	801fa58 <strlen>
 801f7ce:	4629      	mov	r1, r5
 801f7d0:	4680      	mov	r8, r0
 801f7d2:	aa01      	add	r2, sp, #4
 801f7d4:	4630      	mov	r0, r6
 801f7d6:	f000 fd6d 	bl	80202b4 <_findenv_r>
 801f7da:	4682      	mov	sl, r0
 801f7dc:	2800      	cmp	r0, #0
 801f7de:	d078      	beq.n	801f8d2 <_setenv_r+0x12a>
 801f7e0:	2f00      	cmp	r7, #0
 801f7e2:	d052      	beq.n	801f88a <_setenv_r+0xe2>
 801f7e4:	f000 f938 	bl	801fa58 <strlen>
 801f7e8:	4580      	cmp	r8, r0
 801f7ea:	d955      	bls.n	801f898 <_setenv_r+0xf0>
 801f7ec:	9b01      	ldr	r3, [sp, #4]
 801f7ee:	4f59      	ldr	r7, [pc, #356]	; (801f954 <_setenv_r+0x1ac>)
 801f7f0:	ea4f 0983 	mov.w	r9, r3, lsl #2
 801f7f4:	7829      	ldrb	r1, [r5, #0]
 801f7f6:	b159      	cbz	r1, 801f810 <_setenv_r+0x68>
 801f7f8:	293d      	cmp	r1, #61	; 0x3d
 801f7fa:	f000 809f 	beq.w	801f93c <_setenv_r+0x194>
 801f7fe:	4629      	mov	r1, r5
 801f800:	e001      	b.n	801f806 <_setenv_r+0x5e>
 801f802:	2b3d      	cmp	r3, #61	; 0x3d
 801f804:	d003      	beq.n	801f80e <_setenv_r+0x66>
 801f806:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 801f80a:	2b00      	cmp	r3, #0
 801f80c:	d1f9      	bne.n	801f802 <_setenv_r+0x5a>
 801f80e:	1b49      	subs	r1, r1, r5
 801f810:	4441      	add	r1, r8
 801f812:	3102      	adds	r1, #2
 801f814:	4630      	mov	r0, r6
 801f816:	f8d7 8000 	ldr.w	r8, [r7]
 801f81a:	f8df a138 	ldr.w	sl, [pc, #312]	; 801f954 <_setenv_r+0x1ac>
 801f81e:	f7f6 fad1 	bl	8015dc4 <_malloc_r>
 801f822:	f848 0009 	str.w	r0, [r8, r9]
 801f826:	2800      	cmp	r0, #0
 801f828:	f000 808d 	beq.w	801f946 <_setenv_r+0x19e>
 801f82c:	9901      	ldr	r1, [sp, #4]
 801f82e:	f8da 2000 	ldr.w	r2, [sl]
 801f832:	782b      	ldrb	r3, [r5, #0]
 801f834:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 801f838:	1c69      	adds	r1, r5, #1
 801f83a:	7013      	strb	r3, [r2, #0]
 801f83c:	b163      	cbz	r3, 801f858 <_setenv_r+0xb0>
 801f83e:	2b3d      	cmp	r3, #61	; 0x3d
 801f840:	d00a      	beq.n	801f858 <_setenv_r+0xb0>
 801f842:	1c50      	adds	r0, r2, #1
 801f844:	e001      	b.n	801f84a <_setenv_r+0xa2>
 801f846:	2b3d      	cmp	r3, #61	; 0x3d
 801f848:	d006      	beq.n	801f858 <_setenv_r+0xb0>
 801f84a:	f811 3b01 	ldrb.w	r3, [r1], #1
 801f84e:	4602      	mov	r2, r0
 801f850:	f800 3b01 	strb.w	r3, [r0], #1
 801f854:	2b00      	cmp	r3, #0
 801f856:	d1f6      	bne.n	801f846 <_setenv_r+0x9e>
 801f858:	233d      	movs	r3, #61	; 0x3d
 801f85a:	7013      	strb	r3, [r2, #0]
 801f85c:	4613      	mov	r3, r2
 801f85e:	f814 2b01 	ldrb.w	r2, [r4], #1
 801f862:	f803 2f01 	strb.w	r2, [r3, #1]!
 801f866:	2a00      	cmp	r2, #0
 801f868:	d1f9      	bne.n	801f85e <_setenv_r+0xb6>
 801f86a:	4630      	mov	r0, r6
 801f86c:	f000 fd1a 	bl	80202a4 <__env_unlock>
 801f870:	9a01      	ldr	r2, [sp, #4]
 801f872:	683b      	ldr	r3, [r7, #0]
 801f874:	4938      	ldr	r1, [pc, #224]	; (801f958 <_setenv_r+0x1b0>)
 801f876:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 801f87a:	2203      	movs	r2, #3
 801f87c:	f000 f91a 	bl	801fab4 <strncmp>
 801f880:	b1d8      	cbz	r0, 801f8ba <_setenv_r+0x112>
 801f882:	2000      	movs	r0, #0
 801f884:	b003      	add	sp, #12
 801f886:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f88a:	4630      	mov	r0, r6
 801f88c:	f000 fd0a 	bl	80202a4 <__env_unlock>
 801f890:	4638      	mov	r0, r7
 801f892:	b003      	add	sp, #12
 801f894:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f898:	f10a 30ff 	add.w	r0, sl, #4294967295
 801f89c:	f814 3b01 	ldrb.w	r3, [r4], #1
 801f8a0:	f800 3f01 	strb.w	r3, [r0, #1]!
 801f8a4:	2b00      	cmp	r3, #0
 801f8a6:	d1f9      	bne.n	801f89c <_setenv_r+0xf4>
 801f8a8:	4630      	mov	r0, r6
 801f8aa:	f000 fcfb 	bl	80202a4 <__env_unlock>
 801f8ae:	4628      	mov	r0, r5
 801f8b0:	492a      	ldr	r1, [pc, #168]	; (801f95c <_setenv_r+0x1b4>)
 801f8b2:	f7e0 fdb9 	bl	8000428 <strcmp>
 801f8b6:	2800      	cmp	r0, #0
 801f8b8:	d1e3      	bne.n	801f882 <_setenv_r+0xda>
 801f8ba:	f000 fadf 	bl	801fe7c <tzset>
 801f8be:	e7e0      	b.n	801f882 <_setenv_r+0xda>
 801f8c0:	f000 fcf2 	bl	80202a8 <__errno>
 801f8c4:	2316      	movs	r3, #22
 801f8c6:	6003      	str	r3, [r0, #0]
 801f8c8:	f04f 30ff 	mov.w	r0, #4294967295
 801f8cc:	b003      	add	sp, #12
 801f8ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f8d2:	4f20      	ldr	r7, [pc, #128]	; (801f954 <_setenv_r+0x1ac>)
 801f8d4:	6839      	ldr	r1, [r7, #0]
 801f8d6:	6808      	ldr	r0, [r1, #0]
 801f8d8:	b390      	cbz	r0, 801f940 <_setenv_r+0x198>
 801f8da:	460b      	mov	r3, r1
 801f8dc:	f853 2f04 	ldr.w	r2, [r3, #4]!
 801f8e0:	f10a 0a01 	add.w	sl, sl, #1
 801f8e4:	2a00      	cmp	r2, #0
 801f8e6:	d1f9      	bne.n	801f8dc <_setenv_r+0x134>
 801f8e8:	f10a 0202 	add.w	r2, sl, #2
 801f8ec:	0092      	lsls	r2, r2, #2
 801f8ee:	f8df e070 	ldr.w	lr, [pc, #112]	; 801f960 <_setenv_r+0x1b8>
 801f8f2:	f8de 3000 	ldr.w	r3, [lr]
 801f8f6:	b173      	cbz	r3, 801f916 <_setenv_r+0x16e>
 801f8f8:	4630      	mov	r0, r6
 801f8fa:	f7f6 fa77 	bl	8015dec <_realloc_r>
 801f8fe:	6038      	str	r0, [r7, #0]
 801f900:	b308      	cbz	r0, 801f946 <_setenv_r+0x19e>
 801f902:	ea4f 098a 	mov.w	r9, sl, lsl #2
 801f906:	f10a 0301 	add.w	r3, sl, #1
 801f90a:	2200      	movs	r2, #0
 801f90c:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 801f910:	f8cd a004 	str.w	sl, [sp, #4]
 801f914:	e76e      	b.n	801f7f4 <_setenv_r+0x4c>
 801f916:	2301      	movs	r3, #1
 801f918:	4611      	mov	r1, r2
 801f91a:	4630      	mov	r0, r6
 801f91c:	f8ce 3000 	str.w	r3, [lr]
 801f920:	f7f6 fa50 	bl	8015dc4 <_malloc_r>
 801f924:	4683      	mov	fp, r0
 801f926:	b170      	cbz	r0, 801f946 <_setenv_r+0x19e>
 801f928:	ea4f 098a 	mov.w	r9, sl, lsl #2
 801f92c:	464a      	mov	r2, r9
 801f92e:	6839      	ldr	r1, [r7, #0]
 801f930:	f7e0 fcd4 	bl	80002dc <memcpy>
 801f934:	f8c7 b000 	str.w	fp, [r7]
 801f938:	4658      	mov	r0, fp
 801f93a:	e7e4      	b.n	801f906 <_setenv_r+0x15e>
 801f93c:	2100      	movs	r1, #0
 801f93e:	e767      	b.n	801f810 <_setenv_r+0x68>
 801f940:	4682      	mov	sl, r0
 801f942:	2208      	movs	r2, #8
 801f944:	e7d3      	b.n	801f8ee <_setenv_r+0x146>
 801f946:	4630      	mov	r0, r6
 801f948:	f000 fcac 	bl	80202a4 <__env_unlock>
 801f94c:	f04f 30ff 	mov.w	r0, #4294967295
 801f950:	e79f      	b.n	801f892 <_setenv_r+0xea>
 801f952:	bf00      	nop
 801f954:	20010110 	.word	0x20010110
 801f958:	08025b7c 	.word	0x08025b7c
 801f95c:	08025b78 	.word	0x08025b78
 801f960:	200121ec 	.word	0x200121ec

0801f964 <strchr>:
 801f964:	b2c9      	uxtb	r1, r1
 801f966:	b470      	push	{r4, r5, r6}
 801f968:	2900      	cmp	r1, #0
 801f96a:	d033      	beq.n	801f9d4 <strchr+0x70>
 801f96c:	0785      	lsls	r5, r0, #30
 801f96e:	d010      	beq.n	801f992 <strchr+0x2e>
 801f970:	7803      	ldrb	r3, [r0, #0]
 801f972:	2b00      	cmp	r3, #0
 801f974:	d059      	beq.n	801fa2a <strchr+0xc6>
 801f976:	4299      	cmp	r1, r3
 801f978:	bf18      	it	ne
 801f97a:	1c43      	addne	r3, r0, #1
 801f97c:	d106      	bne.n	801f98c <strchr+0x28>
 801f97e:	e027      	b.n	801f9d0 <strchr+0x6c>
 801f980:	f813 2b01 	ldrb.w	r2, [r3], #1
 801f984:	2a00      	cmp	r2, #0
 801f986:	d04d      	beq.n	801fa24 <strchr+0xc0>
 801f988:	4291      	cmp	r1, r2
 801f98a:	d021      	beq.n	801f9d0 <strchr+0x6c>
 801f98c:	079a      	lsls	r2, r3, #30
 801f98e:	4618      	mov	r0, r3
 801f990:	d1f6      	bne.n	801f980 <strchr+0x1c>
 801f992:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 801f996:	6803      	ldr	r3, [r0, #0]
 801f998:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 801f99c:	e001      	b.n	801f9a2 <strchr+0x3e>
 801f99e:	f850 3f04 	ldr.w	r3, [r0, #4]!
 801f9a2:	ea83 0506 	eor.w	r5, r3, r6
 801f9a6:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 801f9aa:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 801f9ae:	ea24 0405 	bic.w	r4, r4, r5
 801f9b2:	ea22 0303 	bic.w	r3, r2, r3
 801f9b6:	4323      	orrs	r3, r4
 801f9b8:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 801f9bc:	d0ef      	beq.n	801f99e <strchr+0x3a>
 801f9be:	7803      	ldrb	r3, [r0, #0]
 801f9c0:	b923      	cbnz	r3, 801f9cc <strchr+0x68>
 801f9c2:	e032      	b.n	801fa2a <strchr+0xc6>
 801f9c4:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 801f9c8:	2b00      	cmp	r3, #0
 801f9ca:	d02e      	beq.n	801fa2a <strchr+0xc6>
 801f9cc:	4299      	cmp	r1, r3
 801f9ce:	d1f9      	bne.n	801f9c4 <strchr+0x60>
 801f9d0:	bc70      	pop	{r4, r5, r6}
 801f9d2:	4770      	bx	lr
 801f9d4:	0784      	lsls	r4, r0, #30
 801f9d6:	d00b      	beq.n	801f9f0 <strchr+0x8c>
 801f9d8:	7803      	ldrb	r3, [r0, #0]
 801f9da:	2b00      	cmp	r3, #0
 801f9dc:	d0f8      	beq.n	801f9d0 <strchr+0x6c>
 801f9de:	1c43      	adds	r3, r0, #1
 801f9e0:	e003      	b.n	801f9ea <strchr+0x86>
 801f9e2:	7802      	ldrb	r2, [r0, #0]
 801f9e4:	3301      	adds	r3, #1
 801f9e6:	2a00      	cmp	r2, #0
 801f9e8:	d0f2      	beq.n	801f9d0 <strchr+0x6c>
 801f9ea:	0799      	lsls	r1, r3, #30
 801f9ec:	4618      	mov	r0, r3
 801f9ee:	d1f8      	bne.n	801f9e2 <strchr+0x7e>
 801f9f0:	6802      	ldr	r2, [r0, #0]
 801f9f2:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 801f9f6:	ea23 0302 	bic.w	r3, r3, r2
 801f9fa:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 801f9fe:	d108      	bne.n	801fa12 <strchr+0xae>
 801fa00:	f850 2f04 	ldr.w	r2, [r0, #4]!
 801fa04:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 801fa08:	ea23 0302 	bic.w	r3, r3, r2
 801fa0c:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 801fa10:	d0f6      	beq.n	801fa00 <strchr+0x9c>
 801fa12:	7803      	ldrb	r3, [r0, #0]
 801fa14:	2b00      	cmp	r3, #0
 801fa16:	d0db      	beq.n	801f9d0 <strchr+0x6c>
 801fa18:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 801fa1c:	2b00      	cmp	r3, #0
 801fa1e:	d1fb      	bne.n	801fa18 <strchr+0xb4>
 801fa20:	bc70      	pop	{r4, r5, r6}
 801fa22:	4770      	bx	lr
 801fa24:	4610      	mov	r0, r2
 801fa26:	bc70      	pop	{r4, r5, r6}
 801fa28:	4770      	bx	lr
 801fa2a:	4618      	mov	r0, r3
 801fa2c:	bc70      	pop	{r4, r5, r6}
 801fa2e:	4770      	bx	lr

0801fa30 <_strdup_r>:
 801fa30:	b570      	push	{r4, r5, r6, lr}
 801fa32:	4606      	mov	r6, r0
 801fa34:	4608      	mov	r0, r1
 801fa36:	460d      	mov	r5, r1
 801fa38:	f000 f80e 	bl	801fa58 <strlen>
 801fa3c:	1c44      	adds	r4, r0, #1
 801fa3e:	4621      	mov	r1, r4
 801fa40:	4630      	mov	r0, r6
 801fa42:	f7f6 f9bf 	bl	8015dc4 <_malloc_r>
 801fa46:	4606      	mov	r6, r0
 801fa48:	b118      	cbz	r0, 801fa52 <_strdup_r+0x22>
 801fa4a:	4629      	mov	r1, r5
 801fa4c:	4622      	mov	r2, r4
 801fa4e:	f7e0 fc45 	bl	80002dc <memcpy>
 801fa52:	4630      	mov	r0, r6
 801fa54:	bd70      	pop	{r4, r5, r6, pc}
 801fa56:	bf00      	nop

0801fa58 <strlen>:
 801fa58:	f020 0103 	bic.w	r1, r0, #3
 801fa5c:	f010 0003 	ands.w	r0, r0, #3
 801fa60:	f1c0 0000 	rsb	r0, r0, #0
 801fa64:	f851 3b04 	ldr.w	r3, [r1], #4
 801fa68:	f100 0c04 	add.w	ip, r0, #4
 801fa6c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801fa70:	f06f 0200 	mvn.w	r2, #0
 801fa74:	bf1c      	itt	ne
 801fa76:	fa22 f20c 	lsrne.w	r2, r2, ip
 801fa7a:	4313      	orrne	r3, r2
 801fa7c:	f04f 0c01 	mov.w	ip, #1
 801fa80:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 801fa84:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 801fa88:	eba3 020c 	sub.w	r2, r3, ip
 801fa8c:	ea22 0203 	bic.w	r2, r2, r3
 801fa90:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 801fa94:	bf04      	itt	eq
 801fa96:	f851 3b04 	ldreq.w	r3, [r1], #4
 801fa9a:	3004      	addeq	r0, #4
 801fa9c:	d0f4      	beq.n	801fa88 <strlen+0x30>
 801fa9e:	f1c2 0100 	rsb	r1, r2, #0
 801faa2:	ea02 0201 	and.w	r2, r2, r1
 801faa6:	fab2 f282 	clz	r2, r2
 801faaa:	f1c2 021f 	rsb	r2, r2, #31
 801faae:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 801fab2:	4770      	bx	lr

0801fab4 <strncmp>:
 801fab4:	2a00      	cmp	r2, #0
 801fab6:	d03e      	beq.n	801fb36 <strncmp+0x82>
 801fab8:	ea40 0301 	orr.w	r3, r0, r1
 801fabc:	f013 0303 	ands.w	r3, r3, #3
 801fac0:	b4f0      	push	{r4, r5, r6, r7}
 801fac2:	d125      	bne.n	801fb10 <strncmp+0x5c>
 801fac4:	2a03      	cmp	r2, #3
 801fac6:	d923      	bls.n	801fb10 <strncmp+0x5c>
 801fac8:	6804      	ldr	r4, [r0, #0]
 801faca:	680d      	ldr	r5, [r1, #0]
 801facc:	42ac      	cmp	r4, r5
 801face:	d11f      	bne.n	801fb10 <strncmp+0x5c>
 801fad0:	3a04      	subs	r2, #4
 801fad2:	d032      	beq.n	801fb3a <strncmp+0x86>
 801fad4:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 801fad8:	ea25 0404 	bic.w	r4, r5, r4
 801fadc:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801fae0:	d12e      	bne.n	801fb40 <strncmp+0x8c>
 801fae2:	1d07      	adds	r7, r0, #4
 801fae4:	1d0d      	adds	r5, r1, #4
 801fae6:	e00d      	b.n	801fb04 <strncmp+0x50>
 801fae8:	f857 3b04 	ldr.w	r3, [r7], #4
 801faec:	680e      	ldr	r6, [r1, #0]
 801faee:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 801faf2:	42b3      	cmp	r3, r6
 801faf4:	ea24 0403 	bic.w	r4, r4, r3
 801faf8:	d10a      	bne.n	801fb10 <strncmp+0x5c>
 801fafa:	3a04      	subs	r2, #4
 801fafc:	d01d      	beq.n	801fb3a <strncmp+0x86>
 801fafe:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801fb02:	d120      	bne.n	801fb46 <strncmp+0x92>
 801fb04:	2a03      	cmp	r2, #3
 801fb06:	4629      	mov	r1, r5
 801fb08:	4638      	mov	r0, r7
 801fb0a:	f105 0504 	add.w	r5, r5, #4
 801fb0e:	d8eb      	bhi.n	801fae8 <strncmp+0x34>
 801fb10:	7803      	ldrb	r3, [r0, #0]
 801fb12:	780c      	ldrb	r4, [r1, #0]
 801fb14:	42a3      	cmp	r3, r4
 801fb16:	f102 32ff 	add.w	r2, r2, #4294967295
 801fb1a:	d109      	bne.n	801fb30 <strncmp+0x7c>
 801fb1c:	b16a      	cbz	r2, 801fb3a <strncmp+0x86>
 801fb1e:	b17b      	cbz	r3, 801fb40 <strncmp+0x8c>
 801fb20:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 801fb24:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 801fb28:	42a3      	cmp	r3, r4
 801fb2a:	f102 32ff 	add.w	r2, r2, #4294967295
 801fb2e:	d0f5      	beq.n	801fb1c <strncmp+0x68>
 801fb30:	1b18      	subs	r0, r3, r4
 801fb32:	bcf0      	pop	{r4, r5, r6, r7}
 801fb34:	4770      	bx	lr
 801fb36:	4610      	mov	r0, r2
 801fb38:	4770      	bx	lr
 801fb3a:	4610      	mov	r0, r2
 801fb3c:	bcf0      	pop	{r4, r5, r6, r7}
 801fb3e:	4770      	bx	lr
 801fb40:	4618      	mov	r0, r3
 801fb42:	bcf0      	pop	{r4, r5, r6, r7}
 801fb44:	4770      	bx	lr
 801fb46:	2000      	movs	r0, #0
 801fb48:	e7f3      	b.n	801fb32 <strncmp+0x7e>
 801fb4a:	bf00      	nop

0801fb4c <strncpy>:
 801fb4c:	ea40 0301 	orr.w	r3, r0, r1
 801fb50:	079b      	lsls	r3, r3, #30
 801fb52:	b470      	push	{r4, r5, r6}
 801fb54:	d12b      	bne.n	801fbae <strncpy+0x62>
 801fb56:	2a03      	cmp	r2, #3
 801fb58:	d929      	bls.n	801fbae <strncpy+0x62>
 801fb5a:	460c      	mov	r4, r1
 801fb5c:	4603      	mov	r3, r0
 801fb5e:	4621      	mov	r1, r4
 801fb60:	f854 6b04 	ldr.w	r6, [r4], #4
 801fb64:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
 801fb68:	ea25 0506 	bic.w	r5, r5, r6
 801fb6c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 801fb70:	d105      	bne.n	801fb7e <strncpy+0x32>
 801fb72:	3a04      	subs	r2, #4
 801fb74:	2a03      	cmp	r2, #3
 801fb76:	f843 6b04 	str.w	r6, [r3], #4
 801fb7a:	4621      	mov	r1, r4
 801fb7c:	d8ef      	bhi.n	801fb5e <strncpy+0x12>
 801fb7e:	b1a2      	cbz	r2, 801fbaa <strncpy+0x5e>
 801fb80:	780c      	ldrb	r4, [r1, #0]
 801fb82:	701c      	strb	r4, [r3, #0]
 801fb84:	3a01      	subs	r2, #1
 801fb86:	3301      	adds	r3, #1
 801fb88:	3101      	adds	r1, #1
 801fb8a:	b13c      	cbz	r4, 801fb9c <strncpy+0x50>
 801fb8c:	b16a      	cbz	r2, 801fbaa <strncpy+0x5e>
 801fb8e:	f811 4b01 	ldrb.w	r4, [r1], #1
 801fb92:	f803 4b01 	strb.w	r4, [r3], #1
 801fb96:	3a01      	subs	r2, #1
 801fb98:	2c00      	cmp	r4, #0
 801fb9a:	d1f7      	bne.n	801fb8c <strncpy+0x40>
 801fb9c:	b12a      	cbz	r2, 801fbaa <strncpy+0x5e>
 801fb9e:	441a      	add	r2, r3
 801fba0:	2100      	movs	r1, #0
 801fba2:	f803 1b01 	strb.w	r1, [r3], #1
 801fba6:	4293      	cmp	r3, r2
 801fba8:	d1fb      	bne.n	801fba2 <strncpy+0x56>
 801fbaa:	bc70      	pop	{r4, r5, r6}
 801fbac:	4770      	bx	lr
 801fbae:	4603      	mov	r3, r0
 801fbb0:	e7e5      	b.n	801fb7e <strncpy+0x32>
 801fbb2:	bf00      	nop

0801fbb4 <_strtol_r>:
 801fbb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fbb8:	4c44      	ldr	r4, [pc, #272]	; (801fccc <_strtol_r+0x118>)
 801fbba:	4683      	mov	fp, r0
 801fbbc:	460e      	mov	r6, r1
 801fbbe:	f8d4 e000 	ldr.w	lr, [r4]
 801fbc2:	e000      	b.n	801fbc6 <_strtol_r+0x12>
 801fbc4:	4626      	mov	r6, r4
 801fbc6:	4634      	mov	r4, r6
 801fbc8:	f814 5b01 	ldrb.w	r5, [r4], #1
 801fbcc:	eb0e 0005 	add.w	r0, lr, r5
 801fbd0:	7840      	ldrb	r0, [r0, #1]
 801fbd2:	f000 0008 	and.w	r0, r0, #8
 801fbd6:	f000 08ff 	and.w	r8, r0, #255	; 0xff
 801fbda:	2800      	cmp	r0, #0
 801fbdc:	d1f2      	bne.n	801fbc4 <_strtol_r+0x10>
 801fbde:	2d2d      	cmp	r5, #45	; 0x2d
 801fbe0:	d04b      	beq.n	801fc7a <_strtol_r+0xc6>
 801fbe2:	2d2b      	cmp	r5, #43	; 0x2b
 801fbe4:	bf04      	itt	eq
 801fbe6:	7875      	ldrbeq	r5, [r6, #1]
 801fbe8:	1cb4      	addeq	r4, r6, #2
 801fbea:	b11b      	cbz	r3, 801fbf4 <_strtol_r+0x40>
 801fbec:	2b10      	cmp	r3, #16
 801fbee:	d060      	beq.n	801fcb2 <_strtol_r+0xfe>
 801fbf0:	469a      	mov	sl, r3
 801fbf2:	e003      	b.n	801fbfc <_strtol_r+0x48>
 801fbf4:	2d30      	cmp	r5, #48	; 0x30
 801fbf6:	d054      	beq.n	801fca2 <_strtol_r+0xee>
 801fbf8:	230a      	movs	r3, #10
 801fbfa:	469a      	mov	sl, r3
 801fbfc:	f1b8 0f00 	cmp.w	r8, #0
 801fc00:	bf14      	ite	ne
 801fc02:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 801fc06:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 801fc0a:	2700      	movs	r7, #0
 801fc0c:	fbb0 f9fa 	udiv	r9, r0, sl
 801fc10:	46bc      	mov	ip, r7
 801fc12:	fb0a 0019 	mls	r0, sl, r9, r0
 801fc16:	e00c      	b.n	801fc32 <_strtol_r+0x7e>
 801fc18:	3d30      	subs	r5, #48	; 0x30
 801fc1a:	42ab      	cmp	r3, r5
 801fc1c:	dd19      	ble.n	801fc52 <_strtol_r+0x9e>
 801fc1e:	1c7e      	adds	r6, r7, #1
 801fc20:	d005      	beq.n	801fc2e <_strtol_r+0x7a>
 801fc22:	45cc      	cmp	ip, r9
 801fc24:	d824      	bhi.n	801fc70 <_strtol_r+0xbc>
 801fc26:	d021      	beq.n	801fc6c <_strtol_r+0xb8>
 801fc28:	fb0a 5c0c 	mla	ip, sl, ip, r5
 801fc2c:	2701      	movs	r7, #1
 801fc2e:	f814 5b01 	ldrb.w	r5, [r4], #1
 801fc32:	eb0e 0605 	add.w	r6, lr, r5
 801fc36:	7876      	ldrb	r6, [r6, #1]
 801fc38:	f016 0f04 	tst.w	r6, #4
 801fc3c:	d1ec      	bne.n	801fc18 <_strtol_r+0x64>
 801fc3e:	f016 0603 	ands.w	r6, r6, #3
 801fc42:	d006      	beq.n	801fc52 <_strtol_r+0x9e>
 801fc44:	2e01      	cmp	r6, #1
 801fc46:	bf0c      	ite	eq
 801fc48:	2637      	moveq	r6, #55	; 0x37
 801fc4a:	2657      	movne	r6, #87	; 0x57
 801fc4c:	1bad      	subs	r5, r5, r6
 801fc4e:	42ab      	cmp	r3, r5
 801fc50:	dce5      	bgt.n	801fc1e <_strtol_r+0x6a>
 801fc52:	1c7b      	adds	r3, r7, #1
 801fc54:	d016      	beq.n	801fc84 <_strtol_r+0xd0>
 801fc56:	f1c8 0000 	rsb	r0, r8, #0
 801fc5a:	ea8c 0000 	eor.w	r0, ip, r0
 801fc5e:	4440      	add	r0, r8
 801fc60:	b14a      	cbz	r2, 801fc76 <_strtol_r+0xc2>
 801fc62:	b107      	cbz	r7, 801fc66 <_strtol_r+0xb2>
 801fc64:	1e61      	subs	r1, r4, #1
 801fc66:	6011      	str	r1, [r2, #0]
 801fc68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fc6c:	4285      	cmp	r5, r0
 801fc6e:	dddb      	ble.n	801fc28 <_strtol_r+0x74>
 801fc70:	f04f 37ff 	mov.w	r7, #4294967295
 801fc74:	e7db      	b.n	801fc2e <_strtol_r+0x7a>
 801fc76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fc7a:	1cb4      	adds	r4, r6, #2
 801fc7c:	7875      	ldrb	r5, [r6, #1]
 801fc7e:	f04f 0801 	mov.w	r8, #1
 801fc82:	e7b2      	b.n	801fbea <_strtol_r+0x36>
 801fc84:	f1b8 0f00 	cmp.w	r8, #0
 801fc88:	f04f 0322 	mov.w	r3, #34	; 0x22
 801fc8c:	bf14      	ite	ne
 801fc8e:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 801fc92:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 801fc96:	f8cb 3000 	str.w	r3, [fp]
 801fc9a:	2a00      	cmp	r2, #0
 801fc9c:	d1e2      	bne.n	801fc64 <_strtol_r+0xb0>
 801fc9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fca2:	7823      	ldrb	r3, [r4, #0]
 801fca4:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801fca8:	2b58      	cmp	r3, #88	; 0x58
 801fcaa:	d009      	beq.n	801fcc0 <_strtol_r+0x10c>
 801fcac:	2308      	movs	r3, #8
 801fcae:	469a      	mov	sl, r3
 801fcb0:	e7a4      	b.n	801fbfc <_strtol_r+0x48>
 801fcb2:	2d30      	cmp	r5, #48	; 0x30
 801fcb4:	d19c      	bne.n	801fbf0 <_strtol_r+0x3c>
 801fcb6:	7820      	ldrb	r0, [r4, #0]
 801fcb8:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 801fcbc:	2858      	cmp	r0, #88	; 0x58
 801fcbe:	d197      	bne.n	801fbf0 <_strtol_r+0x3c>
 801fcc0:	f04f 0a10 	mov.w	sl, #16
 801fcc4:	7865      	ldrb	r5, [r4, #1]
 801fcc6:	4653      	mov	r3, sl
 801fcc8:	3402      	adds	r4, #2
 801fcca:	e797      	b.n	801fbfc <_strtol_r+0x48>
 801fccc:	2001010c 	.word	0x2001010c

0801fcd0 <strtol>:
 801fcd0:	b430      	push	{r4, r5}
 801fcd2:	4c04      	ldr	r4, [pc, #16]	; (801fce4 <strtol+0x14>)
 801fcd4:	460d      	mov	r5, r1
 801fcd6:	4613      	mov	r3, r2
 801fcd8:	4601      	mov	r1, r0
 801fcda:	462a      	mov	r2, r5
 801fcdc:	6820      	ldr	r0, [r4, #0]
 801fcde:	bc30      	pop	{r4, r5}
 801fce0:	f7ff bf68 	b.w	801fbb4 <_strtol_r>
 801fce4:	20010580 	.word	0x20010580

0801fce8 <__tzcalc_limits>:
 801fce8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fcec:	b083      	sub	sp, #12
 801fcee:	4604      	mov	r4, r0
 801fcf0:	f000 fb2c 	bl	802034c <__gettzinfo>
 801fcf4:	f240 73b1 	movw	r3, #1969	; 0x7b1
 801fcf8:	429c      	cmp	r4, r3
 801fcfa:	f340 8097 	ble.w	801fe2c <__tzcalc_limits+0x144>
 801fcfe:	4959      	ldr	r1, [pc, #356]	; (801fe64 <__tzcalc_limits+0x17c>)
 801fd00:	f8df c16c 	ldr.w	ip, [pc, #364]	; 801fe70 <__tzcalc_limits+0x188>
 801fd04:	6044      	str	r4, [r0, #4]
 801fd06:	f2a4 736d 	subw	r3, r4, #1901	; 0x76d
 801fd0a:	f46f 62f6 	mvn.w	r2, #1968	; 0x7b0
 801fd0e:	eb04 0902 	add.w	r9, r4, r2
 801fd12:	fb81 2503 	smull	r2, r5, r1, r3
 801fd16:	17db      	asrs	r3, r3, #31
 801fd18:	eba3 1365 	sub.w	r3, r3, r5, asr #5
 801fd1c:	f46f 65c8 	mvn.w	r5, #1600	; 0x640
 801fd20:	f2a4 72b2 	subw	r2, r4, #1970	; 0x7b2
 801fd24:	1965      	adds	r5, r4, r5
 801fd26:	ea4f 06a9 	mov.w	r6, r9, asr #2
 801fd2a:	f240 196d 	movw	r9, #365	; 0x16d
 801fd2e:	fb81 7e04 	smull	r7, lr, r1, r4
 801fd32:	fb09 6902 	mla	r9, r9, r2, r6
 801fd36:	fb81 2105 	smull	r2, r1, r1, r5
 801fd3a:	17ea      	asrs	r2, r5, #31
 801fd3c:	17e7      	asrs	r7, r4, #31
 801fd3e:	444b      	add	r3, r9
 801fd40:	ebc2 15e1 	rsb	r5, r2, r1, asr #7
 801fd44:	ebc7 16ee 	rsb	r6, r7, lr, asr #7
 801fd48:	f44f 78c8 	mov.w	r8, #400	; 0x190
 801fd4c:	ebc7 176e 	rsb	r7, r7, lr, asr #5
 801fd50:	441d      	add	r5, r3
 801fd52:	f04f 0e64 	mov.w	lr, #100	; 0x64
 801fd56:	f004 0303 	and.w	r3, r4, #3
 801fd5a:	fb08 4616 	mls	r6, r8, r6, r4
 801fd5e:	fb0e 4717 	mls	r7, lr, r7, r4
 801fd62:	fab6 f686 	clz	r6, r6
 801fd66:	4604      	mov	r4, r0
 801fd68:	0976      	lsrs	r6, r6, #5
 801fd6a:	f100 0e38 	add.w	lr, r0, #56	; 0x38
 801fd6e:	469b      	mov	fp, r3
 801fd70:	7a23      	ldrb	r3, [r4, #8]
 801fd72:	2b4a      	cmp	r3, #74	; 0x4a
 801fd74:	d05e      	beq.n	801fe34 <__tzcalc_limits+0x14c>
 801fd76:	2b44      	cmp	r3, #68	; 0x44
 801fd78:	d06d      	beq.n	801fe56 <__tzcalc_limits+0x16e>
 801fd7a:	f1bb 0f00 	cmp.w	fp, #0
 801fd7e:	d050      	beq.n	801fe22 <__tzcalc_limits+0x13a>
 801fd80:	4633      	mov	r3, r6
 801fd82:	0059      	lsls	r1, r3, #1
 801fd84:	68e2      	ldr	r2, [r4, #12]
 801fd86:	4419      	add	r1, r3
 801fd88:	4b37      	ldr	r3, [pc, #220]	; (801fe68 <__tzcalc_limits+0x180>)
 801fd8a:	2a01      	cmp	r2, #1
 801fd8c:	eb03 1101 	add.w	r1, r3, r1, lsl #4
 801fd90:	dd64      	ble.n	801fe5c <__tzcalc_limits+0x174>
 801fd92:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 801fd96:	3a02      	subs	r2, #2
 801fd98:	ea4f 0a82 	mov.w	sl, r2, lsl #2
 801fd9c:	eb01 090a 	add.w	r9, r1, sl
 801fda0:	f1a1 0804 	sub.w	r8, r1, #4
 801fda4:	462b      	mov	r3, r5
 801fda6:	f858 2f04 	ldr.w	r2, [r8, #4]!
 801fdaa:	45c8      	cmp	r8, r9
 801fdac:	4413      	add	r3, r2
 801fdae:	d1fa      	bne.n	801fda6 <__tzcalc_limits+0xbe>
 801fdb0:	f10a 0204 	add.w	r2, sl, #4
 801fdb4:	9201      	str	r2, [sp, #4]
 801fdb6:	4a2d      	ldr	r2, [pc, #180]	; (801fe6c <__tzcalc_limits+0x184>)
 801fdb8:	f103 0a04 	add.w	sl, r3, #4
 801fdbc:	fb8a 8902 	smull	r8, r9, sl, r2
 801fdc0:	44d1      	add	r9, sl
 801fdc2:	ea4f 78ea 	mov.w	r8, sl, asr #31
 801fdc6:	ebc8 08a9 	rsb	r8, r8, r9, asr #2
 801fdca:	6962      	ldr	r2, [r4, #20]
 801fdcc:	ebc8 08c8 	rsb	r8, r8, r8, lsl #3
 801fdd0:	ebc8 0a0a 	rsb	sl, r8, sl
 801fdd4:	ebb2 0a0a 	subs.w	sl, r2, sl
 801fdd8:	9a01      	ldr	r2, [sp, #4]
 801fdda:	588a      	ldr	r2, [r1, r2]
 801fddc:	6921      	ldr	r1, [r4, #16]
 801fdde:	f101 31ff 	add.w	r1, r1, #4294967295
 801fde2:	bf48      	it	mi
 801fde4:	f10a 0a07 	addmi.w	sl, sl, #7
 801fde8:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 801fdec:	4451      	add	r1, sl
 801fdee:	4291      	cmp	r1, r2
 801fdf0:	db02      	blt.n	801fdf8 <__tzcalc_limits+0x110>
 801fdf2:	3907      	subs	r1, #7
 801fdf4:	4291      	cmp	r1, r2
 801fdf6:	dafc      	bge.n	801fdf2 <__tzcalc_limits+0x10a>
 801fdf8:	440b      	add	r3, r1
 801fdfa:	69a1      	ldr	r1, [r4, #24]
 801fdfc:	6a22      	ldr	r2, [r4, #32]
 801fdfe:	fb0c 1103 	mla	r1, ip, r3, r1
 801fe02:	4411      	add	r1, r2
 801fe04:	f844 1f1c 	str.w	r1, [r4, #28]!
 801fe08:	4574      	cmp	r4, lr
 801fe0a:	d1b1      	bne.n	801fd70 <__tzcalc_limits+0x88>
 801fe0c:	69c3      	ldr	r3, [r0, #28]
 801fe0e:	6b82      	ldr	r2, [r0, #56]	; 0x38
 801fe10:	4293      	cmp	r3, r2
 801fe12:	bfac      	ite	ge
 801fe14:	2300      	movge	r3, #0
 801fe16:	2301      	movlt	r3, #1
 801fe18:	6003      	str	r3, [r0, #0]
 801fe1a:	2001      	movs	r0, #1
 801fe1c:	b003      	add	sp, #12
 801fe1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fe22:	2f00      	cmp	r7, #0
 801fe24:	bf0c      	ite	eq
 801fe26:	4633      	moveq	r3, r6
 801fe28:	2301      	movne	r3, #1
 801fe2a:	e7aa      	b.n	801fd82 <__tzcalc_limits+0x9a>
 801fe2c:	2000      	movs	r0, #0
 801fe2e:	b003      	add	sp, #12
 801fe30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fe34:	6962      	ldr	r2, [r4, #20]
 801fe36:	1951      	adds	r1, r2, r5
 801fe38:	f1bb 0f00 	cmp.w	fp, #0
 801fe3c:	d107      	bne.n	801fe4e <__tzcalc_limits+0x166>
 801fe3e:	b137      	cbz	r7, 801fe4e <__tzcalc_limits+0x166>
 801fe40:	2a3b      	cmp	r2, #59	; 0x3b
 801fe42:	bfd4      	ite	le
 801fe44:	2200      	movle	r2, #0
 801fe46:	2201      	movgt	r2, #1
 801fe48:	4411      	add	r1, r2
 801fe4a:	1e4b      	subs	r3, r1, #1
 801fe4c:	e7d5      	b.n	801fdfa <__tzcalc_limits+0x112>
 801fe4e:	2e00      	cmp	r6, #0
 801fe50:	d1f6      	bne.n	801fe40 <__tzcalc_limits+0x158>
 801fe52:	4632      	mov	r2, r6
 801fe54:	e7f8      	b.n	801fe48 <__tzcalc_limits+0x160>
 801fe56:	6961      	ldr	r1, [r4, #20]
 801fe58:	186b      	adds	r3, r5, r1
 801fe5a:	e7ce      	b.n	801fdfa <__tzcalc_limits+0x112>
 801fe5c:	2200      	movs	r2, #0
 801fe5e:	462b      	mov	r3, r5
 801fe60:	9201      	str	r2, [sp, #4]
 801fe62:	e7a8      	b.n	801fdb6 <__tzcalc_limits+0xce>
 801fe64:	51eb851f 	.word	0x51eb851f
 801fe68:	08025b18 	.word	0x08025b18
 801fe6c:	92492493 	.word	0x92492493
 801fe70:	00015180 	.word	0x00015180

0801fe74 <__tz_lock>:
 801fe74:	4770      	bx	lr
 801fe76:	bf00      	nop

0801fe78 <__tz_unlock>:
 801fe78:	4770      	bx	lr
 801fe7a:	bf00      	nop

0801fe7c <tzset>:
 801fe7c:	4b01      	ldr	r3, [pc, #4]	; (801fe84 <tzset+0x8>)
 801fe7e:	6818      	ldr	r0, [r3, #0]
 801fe80:	f000 b802 	b.w	801fe88 <_tzset_r>
 801fe84:	20010580 	.word	0x20010580

0801fe88 <_tzset_r>:
 801fe88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fe8c:	b08d      	sub	sp, #52	; 0x34
 801fe8e:	4606      	mov	r6, r0
 801fe90:	f000 fa5c 	bl	802034c <__gettzinfo>
 801fe94:	49c7      	ldr	r1, [pc, #796]	; (80201b4 <_tzset_r+0x32c>)
 801fe96:	4dc8      	ldr	r5, [pc, #800]	; (80201b8 <_tzset_r+0x330>)
 801fe98:	4682      	mov	sl, r0
 801fe9a:	4630      	mov	r0, r6
 801fe9c:	f000 fa4e 	bl	802033c <_getenv_r>
 801fea0:	4604      	mov	r4, r0
 801fea2:	2800      	cmp	r0, #0
 801fea4:	f000 8102 	beq.w	80200ac <_tzset_r+0x224>
 801fea8:	f7ff ffe4 	bl	801fe74 <__tz_lock>
 801feac:	6829      	ldr	r1, [r5, #0]
 801feae:	b131      	cbz	r1, 801febe <_tzset_r+0x36>
 801feb0:	4620      	mov	r0, r4
 801feb2:	f7e0 fab9 	bl	8000428 <strcmp>
 801feb6:	2800      	cmp	r0, #0
 801feb8:	f000 80ec 	beq.w	8020094 <_tzset_r+0x20c>
 801febc:	6829      	ldr	r1, [r5, #0]
 801febe:	4608      	mov	r0, r1
 801fec0:	f7ff f930 	bl	801f124 <free>
 801fec4:	4620      	mov	r0, r4
 801fec6:	f7ff fdc7 	bl	801fa58 <strlen>
 801feca:	1c41      	adds	r1, r0, #1
 801fecc:	4630      	mov	r0, r6
 801fece:	f7f5 ff79 	bl	8015dc4 <_malloc_r>
 801fed2:	6028      	str	r0, [r5, #0]
 801fed4:	b110      	cbz	r0, 801fedc <_tzset_r+0x54>
 801fed6:	4621      	mov	r1, r4
 801fed8:	f000 fb40 	bl	802055c <strcpy>
 801fedc:	7823      	ldrb	r3, [r4, #0]
 801fede:	49b7      	ldr	r1, [pc, #732]	; (80201bc <_tzset_r+0x334>)
 801fee0:	4ab7      	ldr	r2, [pc, #732]	; (80201c0 <_tzset_r+0x338>)
 801fee2:	2b3a      	cmp	r3, #58	; 0x3a
 801fee4:	bf08      	it	eq
 801fee6:	3401      	addeq	r4, #1
 801fee8:	ad0a      	add	r5, sp, #40	; 0x28
 801feea:	462b      	mov	r3, r5
 801feec:	4620      	mov	r0, r4
 801feee:	f000 fb07 	bl	8020500 <siscanf>
 801fef2:	2800      	cmp	r0, #0
 801fef4:	f340 80ce 	ble.w	8020094 <_tzset_r+0x20c>
 801fef8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801fefa:	5ce2      	ldrb	r2, [r4, r3]
 801fefc:	2a2d      	cmp	r2, #45	; 0x2d
 801fefe:	441c      	add	r4, r3
 801ff00:	f000 80d0 	beq.w	80200a4 <_tzset_r+0x21c>
 801ff04:	2a2b      	cmp	r2, #43	; 0x2b
 801ff06:	bf08      	it	eq
 801ff08:	3401      	addeq	r4, #1
 801ff0a:	f04f 0801 	mov.w	r8, #1
 801ff0e:	f10d 061e 	add.w	r6, sp, #30
 801ff12:	af08      	add	r7, sp, #32
 801ff14:	f04f 0900 	mov.w	r9, #0
 801ff18:	9501      	str	r5, [sp, #4]
 801ff1a:	9503      	str	r5, [sp, #12]
 801ff1c:	aa07      	add	r2, sp, #28
 801ff1e:	9600      	str	r6, [sp, #0]
 801ff20:	9702      	str	r7, [sp, #8]
 801ff22:	4620      	mov	r0, r4
 801ff24:	49a7      	ldr	r1, [pc, #668]	; (80201c4 <_tzset_r+0x33c>)
 801ff26:	f8ad 901e 	strh.w	r9, [sp, #30]
 801ff2a:	462b      	mov	r3, r5
 801ff2c:	f8ad 9020 	strh.w	r9, [sp, #32]
 801ff30:	f000 fae6 	bl	8020500 <siscanf>
 801ff34:	4548      	cmp	r0, r9
 801ff36:	f340 80ad 	ble.w	8020094 <_tzset_r+0x20c>
 801ff3a:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 801ff3e:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 801ff42:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 801ff46:	980a      	ldr	r0, [sp, #40]	; 0x28
 801ff48:	f8df c294 	ldr.w	ip, [pc, #660]	; 80201e0 <_tzset_r+0x358>
 801ff4c:	f8df b280 	ldr.w	fp, [pc, #640]	; 80201d0 <_tzset_r+0x348>
 801ff50:	f8cd c014 	str.w	ip, [sp, #20]
 801ff54:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 801ff58:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 801ff5c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 801ff60:	fb01 3302 	mla	r3, r1, r2, r3
 801ff64:	fb08 f303 	mul.w	r3, r8, r3
 801ff68:	f8ca 3020 	str.w	r3, [sl, #32]
 801ff6c:	4404      	add	r4, r0
 801ff6e:	4b94      	ldr	r3, [pc, #592]	; (80201c0 <_tzset_r+0x338>)
 801ff70:	f8cb 3000 	str.w	r3, [fp]
 801ff74:	4662      	mov	r2, ip
 801ff76:	4620      	mov	r0, r4
 801ff78:	4990      	ldr	r1, [pc, #576]	; (80201bc <_tzset_r+0x334>)
 801ff7a:	462b      	mov	r3, r5
 801ff7c:	f000 fac0 	bl	8020500 <siscanf>
 801ff80:	4548      	cmp	r0, r9
 801ff82:	f8dd c014 	ldr.w	ip, [sp, #20]
 801ff86:	f340 8107 	ble.w	8020198 <_tzset_r+0x310>
 801ff8a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ff8c:	f8cb c004 	str.w	ip, [fp, #4]
 801ff90:	5ce2      	ldrb	r2, [r4, r3]
 801ff92:	2a2d      	cmp	r2, #45	; 0x2d
 801ff94:	441c      	add	r4, r3
 801ff96:	f000 809c 	beq.w	80200d2 <_tzset_r+0x24a>
 801ff9a:	2a2b      	cmp	r2, #43	; 0x2b
 801ff9c:	bf08      	it	eq
 801ff9e:	3401      	addeq	r4, #1
 801ffa0:	f04f 0801 	mov.w	r8, #1
 801ffa4:	f04f 0e00 	mov.w	lr, #0
 801ffa8:	9600      	str	r6, [sp, #0]
 801ffaa:	9501      	str	r5, [sp, #4]
 801ffac:	9702      	str	r7, [sp, #8]
 801ffae:	9503      	str	r5, [sp, #12]
 801ffb0:	4620      	mov	r0, r4
 801ffb2:	4984      	ldr	r1, [pc, #528]	; (80201c4 <_tzset_r+0x33c>)
 801ffb4:	f8ad e01c 	strh.w	lr, [sp, #28]
 801ffb8:	aa07      	add	r2, sp, #28
 801ffba:	462b      	mov	r3, r5
 801ffbc:	f8ad e01e 	strh.w	lr, [sp, #30]
 801ffc0:	f8ad e020 	strh.w	lr, [sp, #32]
 801ffc4:	f8cd e028 	str.w	lr, [sp, #40]	; 0x28
 801ffc8:	f000 fa9a 	bl	8020500 <siscanf>
 801ffcc:	2800      	cmp	r0, #0
 801ffce:	f340 8084 	ble.w	80200da <_tzset_r+0x252>
 801ffd2:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 801ffd6:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 801ffda:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 801ffde:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 801ffe2:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 801ffe6:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 801ffea:	fb01 3302 	mla	r3, r1, r2, r3
 801ffee:	fb08 f303 	mul.w	r3, r8, r3
 801fff2:	f8ca 303c 	str.w	r3, [sl, #60]	; 0x3c
 801fff6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801fff8:	46d1      	mov	r9, sl
 801fffa:	441c      	add	r4, r3
 801fffc:	f04f 0b00 	mov.w	fp, #0
 8020000:	f894 8000 	ldrb.w	r8, [r4]
 8020004:	f1b8 0f2c 	cmp.w	r8, #44	; 0x2c
 8020008:	bf04      	itt	eq
 802000a:	f894 8001 	ldrbeq.w	r8, [r4, #1]
 802000e:	3401      	addeq	r4, #1
 8020010:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
 8020014:	d068      	beq.n	80200e8 <_tzset_r+0x260>
 8020016:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
 802001a:	bf08      	it	eq
 802001c:	3401      	addeq	r4, #1
 802001e:	4620      	mov	r0, r4
 8020020:	a90b      	add	r1, sp, #44	; 0x2c
 8020022:	f04f 020a 	mov.w	r2, #10
 8020026:	bf18      	it	ne
 8020028:	f04f 0844 	movne.w	r8, #68	; 0x44
 802002c:	f000 fb88 	bl	8020740 <strtoul>
 8020030:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 8020034:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
 8020038:	45a4      	cmp	ip, r4
 802003a:	f000 809d 	beq.w	8020178 <_tzset_r+0x2f0>
 802003e:	b280      	uxth	r0, r0
 8020040:	f8c9 0014 	str.w	r0, [r9, #20]
 8020044:	f889 8008 	strb.w	r8, [r9, #8]
 8020048:	2400      	movs	r4, #0
 802004a:	2302      	movs	r3, #2
 802004c:	f8ad 301c 	strh.w	r3, [sp, #28]
 8020050:	f8ad 401e 	strh.w	r4, [sp, #30]
 8020054:	f8ad 4020 	strh.w	r4, [sp, #32]
 8020058:	940a      	str	r4, [sp, #40]	; 0x28
 802005a:	f89c 3000 	ldrb.w	r3, [ip]
 802005e:	2b2f      	cmp	r3, #47	; 0x2f
 8020060:	d06c      	beq.n	802013c <_tzset_r+0x2b4>
 8020062:	f44f 53e1 	mov.w	r3, #7200	; 0x1c20
 8020066:	f8c9 3018 	str.w	r3, [r9, #24]
 802006a:	4464      	add	r4, ip
 802006c:	f109 091c 	add.w	r9, r9, #28
 8020070:	f1bb 0f00 	cmp.w	fp, #0
 8020074:	d013      	beq.n	802009e <_tzset_r+0x216>
 8020076:	f8da 0004 	ldr.w	r0, [sl, #4]
 802007a:	f7ff fe35 	bl	801fce8 <__tzcalc_limits>
 802007e:	f8da 2020 	ldr.w	r2, [sl, #32]
 8020082:	f8da 303c 	ldr.w	r3, [sl, #60]	; 0x3c
 8020086:	4850      	ldr	r0, [pc, #320]	; (80201c8 <_tzset_r+0x340>)
 8020088:	4950      	ldr	r1, [pc, #320]	; (80201cc <_tzset_r+0x344>)
 802008a:	1ad3      	subs	r3, r2, r3
 802008c:	bf18      	it	ne
 802008e:	2301      	movne	r3, #1
 8020090:	6003      	str	r3, [r0, #0]
 8020092:	600a      	str	r2, [r1, #0]
 8020094:	f7ff fef0 	bl	801fe78 <__tz_unlock>
 8020098:	b00d      	add	sp, #52	; 0x34
 802009a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802009e:	f04f 0b01 	mov.w	fp, #1
 80200a2:	e7ad      	b.n	8020000 <_tzset_r+0x178>
 80200a4:	3401      	adds	r4, #1
 80200a6:	f04f 38ff 	mov.w	r8, #4294967295
 80200aa:	e730      	b.n	801ff0e <_tzset_r+0x86>
 80200ac:	f7ff fee2 	bl	801fe74 <__tz_lock>
 80200b0:	4e46      	ldr	r6, [pc, #280]	; (80201cc <_tzset_r+0x344>)
 80200b2:	4b47      	ldr	r3, [pc, #284]	; (80201d0 <_tzset_r+0x348>)
 80200b4:	4944      	ldr	r1, [pc, #272]	; (80201c8 <_tzset_r+0x340>)
 80200b6:	4a47      	ldr	r2, [pc, #284]	; (80201d4 <_tzset_r+0x34c>)
 80200b8:	6828      	ldr	r0, [r5, #0]
 80200ba:	600c      	str	r4, [r1, #0]
 80200bc:	601a      	str	r2, [r3, #0]
 80200be:	605a      	str	r2, [r3, #4]
 80200c0:	6034      	str	r4, [r6, #0]
 80200c2:	f7ff f82f 	bl	801f124 <free>
 80200c6:	602c      	str	r4, [r5, #0]
 80200c8:	f7ff fed6 	bl	801fe78 <__tz_unlock>
 80200cc:	b00d      	add	sp, #52	; 0x34
 80200ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80200d2:	3401      	adds	r4, #1
 80200d4:	f04f 38ff 	mov.w	r8, #4294967295
 80200d8:	e764      	b.n	801ffa4 <_tzset_r+0x11c>
 80200da:	f8da 3020 	ldr.w	r3, [sl, #32]
 80200de:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
 80200e2:	f8ca 303c 	str.w	r3, [sl, #60]	; 0x3c
 80200e6:	e786      	b.n	801fff6 <_tzset_r+0x16e>
 80200e8:	aa09      	add	r2, sp, #36	; 0x24
 80200ea:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 80200ee:	9200      	str	r2, [sp, #0]
 80200f0:	9302      	str	r3, [sp, #8]
 80200f2:	9501      	str	r5, [sp, #4]
 80200f4:	9503      	str	r5, [sp, #12]
 80200f6:	4620      	mov	r0, r4
 80200f8:	4937      	ldr	r1, [pc, #220]	; (80201d8 <_tzset_r+0x350>)
 80200fa:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 80200fe:	462b      	mov	r3, r5
 8020100:	f000 f9fe 	bl	8020500 <siscanf>
 8020104:	2803      	cmp	r0, #3
 8020106:	d1c5      	bne.n	8020094 <_tzset_r+0x20c>
 8020108:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 802010c:	1e5a      	subs	r2, r3, #1
 802010e:	2a0b      	cmp	r2, #11
 8020110:	d8c0      	bhi.n	8020094 <_tzset_r+0x20c>
 8020112:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 8020116:	1e51      	subs	r1, r2, #1
 8020118:	2904      	cmp	r1, #4
 802011a:	d8bb      	bhi.n	8020094 <_tzset_r+0x20c>
 802011c:	f8bd 1026 	ldrh.w	r1, [sp, #38]	; 0x26
 8020120:	2906      	cmp	r1, #6
 8020122:	d8b7      	bhi.n	8020094 <_tzset_r+0x20c>
 8020124:	f889 8008 	strb.w	r8, [r9, #8]
 8020128:	f8c9 300c 	str.w	r3, [r9, #12]
 802012c:	f8c9 2010 	str.w	r2, [r9, #16]
 8020130:	f8c9 1014 	str.w	r1, [r9, #20]
 8020134:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020136:	eb04 0c03 	add.w	ip, r4, r3
 802013a:	e785      	b.n	8020048 <_tzset_r+0x1c0>
 802013c:	4660      	mov	r0, ip
 802013e:	4927      	ldr	r1, [pc, #156]	; (80201dc <_tzset_r+0x354>)
 8020140:	9600      	str	r6, [sp, #0]
 8020142:	aa07      	add	r2, sp, #28
 8020144:	462b      	mov	r3, r5
 8020146:	9501      	str	r5, [sp, #4]
 8020148:	9702      	str	r7, [sp, #8]
 802014a:	9503      	str	r5, [sp, #12]
 802014c:	f8cd c014 	str.w	ip, [sp, #20]
 8020150:	f000 f9d6 	bl	8020500 <siscanf>
 8020154:	f8bd 101e 	ldrh.w	r1, [sp, #30]
 8020158:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 802015c:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8020160:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8020162:	f8dd c014 	ldr.w	ip, [sp, #20]
 8020166:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 802016a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 802016e:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 8020172:	fb03 1302 	mla	r3, r3, r2, r1
 8020176:	e776      	b.n	8020066 <_tzset_r+0x1de>
 8020178:	f1bb 0f00 	cmp.w	fp, #0
 802017c:	d032      	beq.n	80201e4 <_tzset_r+0x35c>
 802017e:	204d      	movs	r0, #77	; 0x4d
 8020180:	210b      	movs	r1, #11
 8020182:	2201      	movs	r2, #1
 8020184:	2300      	movs	r3, #0
 8020186:	f88a 0024 	strb.w	r0, [sl, #36]	; 0x24
 802018a:	f8ca 1028 	str.w	r1, [sl, #40]	; 0x28
 802018e:	f8ca 202c 	str.w	r2, [sl, #44]	; 0x2c
 8020192:	f8ca 3030 	str.w	r3, [sl, #48]	; 0x30
 8020196:	e757      	b.n	8020048 <_tzset_r+0x1c0>
 8020198:	490c      	ldr	r1, [pc, #48]	; (80201cc <_tzset_r+0x344>)
 802019a:	4a0b      	ldr	r2, [pc, #44]	; (80201c8 <_tzset_r+0x340>)
 802019c:	f8da 0020 	ldr.w	r0, [sl, #32]
 80201a0:	f8db 3000 	ldr.w	r3, [fp]
 80201a4:	6008      	str	r0, [r1, #0]
 80201a6:	f8c2 9000 	str.w	r9, [r2]
 80201aa:	f8cb 3004 	str.w	r3, [fp, #4]
 80201ae:	f7ff fe63 	bl	801fe78 <__tz_unlock>
 80201b2:	e771      	b.n	8020098 <_tzset_r+0x210>
 80201b4:	08025b78 	.word	0x08025b78
 80201b8:	20012208 	.word	0x20012208
 80201bc:	08025b84 	.word	0x08025b84
 80201c0:	200121fc 	.word	0x200121fc
 80201c4:	08025b94 	.word	0x08025b94
 80201c8:	2001220c 	.word	0x2001220c
 80201cc:	20012210 	.word	0x20012210
 80201d0:	20010104 	.word	0x20010104
 80201d4:	08025b80 	.word	0x08025b80
 80201d8:	08025ba8 	.word	0x08025ba8
 80201dc:	08025bbc 	.word	0x08025bbc
 80201e0:	200121f0 	.word	0x200121f0
 80201e4:	214d      	movs	r1, #77	; 0x4d
 80201e6:	2203      	movs	r2, #3
 80201e8:	2302      	movs	r3, #2
 80201ea:	f8ca b014 	str.w	fp, [sl, #20]
 80201ee:	f88a 1008 	strb.w	r1, [sl, #8]
 80201f2:	f8ca 200c 	str.w	r2, [sl, #12]
 80201f6:	f8ca 3010 	str.w	r3, [sl, #16]
 80201fa:	e725      	b.n	8020048 <_tzset_r+0x1c0>

080201fc <asctime>:
 80201fc:	4b02      	ldr	r3, [pc, #8]	; (8020208 <asctime+0xc>)
 80201fe:	6819      	ldr	r1, [r3, #0]
 8020200:	3160      	adds	r1, #96	; 0x60
 8020202:	f000 b803 	b.w	802020c <asctime_r>
 8020206:	bf00      	nop
 8020208:	20010580 	.word	0x20010580

0802020c <asctime_r>:
 802020c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802020e:	f8d0 c008 	ldr.w	ip, [r0, #8]
 8020212:	6946      	ldr	r6, [r0, #20]
 8020214:	6985      	ldr	r5, [r0, #24]
 8020216:	6904      	ldr	r4, [r0, #16]
 8020218:	68c7      	ldr	r7, [r0, #12]
 802021a:	4a0e      	ldr	r2, [pc, #56]	; (8020254 <asctime_r+0x48>)
 802021c:	4b0e      	ldr	r3, [pc, #56]	; (8020258 <asctime_r+0x4c>)
 802021e:	e890 4001 	ldmia.w	r0, {r0, lr}
 8020222:	b087      	sub	sp, #28
 8020224:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8020228:	9700      	str	r7, [sp, #0]
 802022a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 802022e:	460f      	mov	r7, r1
 8020230:	f206 716c 	addw	r1, r6, #1900	; 0x76c
 8020234:	9104      	str	r1, [sp, #16]
 8020236:	9003      	str	r0, [sp, #12]
 8020238:	442a      	add	r2, r5
 802023a:	4423      	add	r3, r4
 802023c:	f8cd c004 	str.w	ip, [sp, #4]
 8020240:	f8cd e008 	str.w	lr, [sp, #8]
 8020244:	4638      	mov	r0, r7
 8020246:	4905      	ldr	r1, [pc, #20]	; (802025c <asctime_r+0x50>)
 8020248:	f000 f934 	bl	80204b4 <siprintf>
 802024c:	4638      	mov	r0, r7
 802024e:	b007      	add	sp, #28
 8020250:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020252:	bf00      	nop
 8020254:	08025c14 	.word	0x08025c14
 8020258:	08025bd0 	.word	0x08025bd0
 802025c:	08025bf4 	.word	0x08025bf4

08020260 <div>:
 8020260:	2900      	cmp	r1, #0
 8020262:	b410      	push	{r4}
 8020264:	fb91 f4f2 	sdiv	r4, r1, r2
 8020268:	fb02 1314 	mls	r3, r2, r4, r1
 802026c:	db06      	blt.n	802027c <div+0x1c>
 802026e:	2b00      	cmp	r3, #0
 8020270:	db0e      	blt.n	8020290 <div+0x30>
 8020272:	6004      	str	r4, [r0, #0]
 8020274:	6043      	str	r3, [r0, #4]
 8020276:	f85d 4b04 	ldr.w	r4, [sp], #4
 802027a:	4770      	bx	lr
 802027c:	2b00      	cmp	r3, #0
 802027e:	bfc4      	itt	gt
 8020280:	f104 34ff 	addgt.w	r4, r4, #4294967295
 8020284:	189b      	addgt	r3, r3, r2
 8020286:	6004      	str	r4, [r0, #0]
 8020288:	6043      	str	r3, [r0, #4]
 802028a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802028e:	4770      	bx	lr
 8020290:	3401      	adds	r4, #1
 8020292:	1a9b      	subs	r3, r3, r2
 8020294:	6004      	str	r4, [r0, #0]
 8020296:	6043      	str	r3, [r0, #4]
 8020298:	f85d 4b04 	ldr.w	r4, [sp], #4
 802029c:	4770      	bx	lr
 802029e:	bf00      	nop

080202a0 <__env_lock>:
 80202a0:	4770      	bx	lr
 80202a2:	bf00      	nop

080202a4 <__env_unlock>:
 80202a4:	4770      	bx	lr
 80202a6:	bf00      	nop

080202a8 <__errno>:
 80202a8:	4b01      	ldr	r3, [pc, #4]	; (80202b0 <__errno+0x8>)
 80202aa:	6818      	ldr	r0, [r3, #0]
 80202ac:	4770      	bx	lr
 80202ae:	bf00      	nop
 80202b0:	20010580 	.word	0x20010580

080202b4 <_findenv_r>:
 80202b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80202b8:	4e1f      	ldr	r6, [pc, #124]	; (8020338 <_findenv_r+0x84>)
 80202ba:	460d      	mov	r5, r1
 80202bc:	4690      	mov	r8, r2
 80202be:	4607      	mov	r7, r0
 80202c0:	f7ff ffee 	bl	80202a0 <__env_lock>
 80202c4:	f8d6 9000 	ldr.w	r9, [r6]
 80202c8:	f1b9 0f00 	cmp.w	r9, #0
 80202cc:	d020      	beq.n	8020310 <_findenv_r+0x5c>
 80202ce:	782c      	ldrb	r4, [r5, #0]
 80202d0:	b15c      	cbz	r4, 80202ea <_findenv_r+0x36>
 80202d2:	2c3d      	cmp	r4, #61	; 0x3d
 80202d4:	bf18      	it	ne
 80202d6:	462c      	movne	r4, r5
 80202d8:	d102      	bne.n	80202e0 <_findenv_r+0x2c>
 80202da:	e019      	b.n	8020310 <_findenv_r+0x5c>
 80202dc:	2b3d      	cmp	r3, #61	; 0x3d
 80202de:	d017      	beq.n	8020310 <_findenv_r+0x5c>
 80202e0:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 80202e4:	2b00      	cmp	r3, #0
 80202e6:	d1f9      	bne.n	80202dc <_findenv_r+0x28>
 80202e8:	1b64      	subs	r4, r4, r5
 80202ea:	f8d9 0000 	ldr.w	r0, [r9]
 80202ee:	b178      	cbz	r0, 8020310 <_findenv_r+0x5c>
 80202f0:	4629      	mov	r1, r5
 80202f2:	4622      	mov	r2, r4
 80202f4:	f7ff fbde 	bl	801fab4 <strncmp>
 80202f8:	b930      	cbnz	r0, 8020308 <_findenv_r+0x54>
 80202fa:	f8d9 0000 	ldr.w	r0, [r9]
 80202fe:	5d03      	ldrb	r3, [r0, r4]
 8020300:	2b3d      	cmp	r3, #61	; 0x3d
 8020302:	eb00 0a04 	add.w	sl, r0, r4
 8020306:	d009      	beq.n	802031c <_findenv_r+0x68>
 8020308:	f859 0f04 	ldr.w	r0, [r9, #4]!
 802030c:	2800      	cmp	r0, #0
 802030e:	d1ef      	bne.n	80202f0 <_findenv_r+0x3c>
 8020310:	4638      	mov	r0, r7
 8020312:	f7ff ffc7 	bl	80202a4 <__env_unlock>
 8020316:	2000      	movs	r0, #0
 8020318:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802031c:	6833      	ldr	r3, [r6, #0]
 802031e:	ebc3 0909 	rsb	r9, r3, r9
 8020322:	ea4f 03a9 	mov.w	r3, r9, asr #2
 8020326:	4638      	mov	r0, r7
 8020328:	f8c8 3000 	str.w	r3, [r8]
 802032c:	f7ff ffba 	bl	80202a4 <__env_unlock>
 8020330:	f10a 0001 	add.w	r0, sl, #1
 8020334:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020338:	20010110 	.word	0x20010110

0802033c <_getenv_r>:
 802033c:	b500      	push	{lr}
 802033e:	b083      	sub	sp, #12
 8020340:	aa01      	add	r2, sp, #4
 8020342:	f7ff ffb7 	bl	80202b4 <_findenv_r>
 8020346:	b003      	add	sp, #12
 8020348:	f85d fb04 	ldr.w	pc, [sp], #4

0802034c <__gettzinfo>:
 802034c:	4800      	ldr	r0, [pc, #0]	; (8020350 <__gettzinfo+0x4>)
 802034e:	4770      	bx	lr
 8020350:	20010114 	.word	0x20010114

08020354 <gmtime_r>:
 8020354:	6800      	ldr	r0, [r0, #0]
 8020356:	4b4c      	ldr	r3, [pc, #304]	; (8020488 <gmtime_r+0x134>)
 8020358:	4a4c      	ldr	r2, [pc, #304]	; (802048c <gmtime_r+0x138>)
 802035a:	b5f0      	push	{r4, r5, r6, r7, lr}
 802035c:	fb83 4300 	smull	r4, r3, r3, r0
 8020360:	4403      	add	r3, r0
 8020362:	17c4      	asrs	r4, r0, #31
 8020364:	ebc4 4323 	rsb	r3, r4, r3, asr #16
 8020368:	fb02 0213 	mls	r2, r2, r3, r0
 802036c:	2a00      	cmp	r2, #0
 802036e:	da04      	bge.n	802037a <gmtime_r+0x26>
 8020370:	f502 32a8 	add.w	r2, r2, #86016	; 0x15000
 8020374:	f502 72c0 	add.w	r2, r2, #384	; 0x180
 8020378:	3b01      	subs	r3, #1
 802037a:	4845      	ldr	r0, [pc, #276]	; (8020490 <gmtime_r+0x13c>)
 802037c:	4d45      	ldr	r5, [pc, #276]	; (8020494 <gmtime_r+0x140>)
 802037e:	4e46      	ldr	r6, [pc, #280]	; (8020498 <gmtime_r+0x144>)
 8020380:	fb80 0e02 	smull	r0, lr, r0, r2
 8020384:	eb0e 0002 	add.w	r0, lr, r2
 8020388:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 802038c:	ebce 2ee0 	rsb	lr, lr, r0, asr #11
 8020390:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 8020394:	fb00 221e 	mls	r2, r0, lr, r2
 8020398:	1d1c      	adds	r4, r3, #4
 802039a:	fb85 0502 	smull	r0, r5, r5, r2
 802039e:	fb84 6706 	smull	r6, r7, r4, r6
 80203a2:	17d0      	asrs	r0, r2, #31
 80203a4:	4415      	add	r5, r2
 80203a6:	ebc0 1565 	rsb	r5, r0, r5, asr #5
 80203aa:	4427      	add	r7, r4
 80203ac:	17e0      	asrs	r0, r4, #31
 80203ae:	ebc5 1605 	rsb	r6, r5, r5, lsl #4
 80203b2:	ebc0 00a7 	rsb	r0, r0, r7, asr #2
 80203b6:	eba2 0286 	sub.w	r2, r2, r6, lsl #2
 80203ba:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80203be:	1a20      	subs	r0, r4, r0
 80203c0:	e881 4024 	stmia.w	r1, {r2, r5, lr}
 80203c4:	4a35      	ldr	r2, [pc, #212]	; (802049c <gmtime_r+0x148>)
 80203c6:	4c36      	ldr	r4, [pc, #216]	; (80204a0 <gmtime_r+0x14c>)
 80203c8:	bf48      	it	mi
 80203ca:	3007      	addmi	r0, #7
 80203cc:	6188      	str	r0, [r1, #24]
 80203ce:	fb82 2003 	smull	r2, r0, r2, r3
 80203d2:	17da      	asrs	r2, r3, #31
 80203d4:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 80203d8:	fb04 3302 	mla	r3, r4, r2, r3
 80203dc:	2b00      	cmp	r3, #0
 80203de:	ea4f 0282 	mov.w	r2, r2, lsl #2
 80203e2:	f202 72b2 	addw	r2, r2, #1970	; 0x7b2
 80203e6:	db46      	blt.n	8020476 <gmtime_r+0x122>
 80203e8:	f5b3 7fb6 	cmp.w	r3, #364	; 0x16c
 80203ec:	dd09      	ble.n	8020402 <gmtime_r+0xae>
 80203ee:	4d2d      	ldr	r5, [pc, #180]	; (80204a4 <gmtime_r+0x150>)
 80203f0:	f240 146d 	movw	r4, #365	; 0x16d
 80203f4:	1b1b      	subs	r3, r3, r4
 80203f6:	f855 4f04 	ldr.w	r4, [r5, #4]!
 80203fa:	429c      	cmp	r4, r3
 80203fc:	f102 0201 	add.w	r2, r2, #1
 8020400:	ddf8      	ble.n	80203f4 <gmtime_r+0xa0>
 8020402:	f2a2 706c 	subw	r0, r2, #1900	; 0x76c
 8020406:	6148      	str	r0, [r1, #20]
 8020408:	0790      	lsls	r0, r2, #30
 802040a:	61cb      	str	r3, [r1, #28]
 802040c:	d026      	beq.n	802045c <gmtime_r+0x108>
 802040e:	17d0      	asrs	r0, r2, #31
 8020410:	4c25      	ldr	r4, [pc, #148]	; (80204a8 <gmtime_r+0x154>)
 8020412:	fb84 5402 	smull	r5, r4, r4, r2
 8020416:	ebc0 10e4 	rsb	r0, r0, r4, asr #7
 802041a:	f44f 74c8 	mov.w	r4, #400	; 0x190
 802041e:	fb04 2210 	mls	r2, r4, r0, r2
 8020422:	fab2 f282 	clz	r2, r2
 8020426:	0952      	lsrs	r2, r2, #5
 8020428:	0055      	lsls	r5, r2, #1
 802042a:	4415      	add	r5, r2
 802042c:	012d      	lsls	r5, r5, #4
 802042e:	4c1f      	ldr	r4, [pc, #124]	; (80204ac <gmtime_r+0x158>)
 8020430:	592a      	ldr	r2, [r5, r4]
 8020432:	2000      	movs	r0, #0
 8020434:	4293      	cmp	r3, r2
 8020436:	4425      	add	r5, r4
 8020438:	6108      	str	r0, [r1, #16]
 802043a:	db09      	blt.n	8020450 <gmtime_r+0xfc>
 802043c:	2401      	movs	r4, #1
 802043e:	1a9b      	subs	r3, r3, r2
 8020440:	f855 2f04 	ldr.w	r2, [r5, #4]!
 8020444:	429a      	cmp	r2, r3
 8020446:	4620      	mov	r0, r4
 8020448:	f104 0401 	add.w	r4, r4, #1
 802044c:	ddf7      	ble.n	802043e <gmtime_r+0xea>
 802044e:	6108      	str	r0, [r1, #16]
 8020450:	3301      	adds	r3, #1
 8020452:	2200      	movs	r2, #0
 8020454:	60cb      	str	r3, [r1, #12]
 8020456:	620a      	str	r2, [r1, #32]
 8020458:	4608      	mov	r0, r1
 802045a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802045c:	4c12      	ldr	r4, [pc, #72]	; (80204a8 <gmtime_r+0x154>)
 802045e:	17d0      	asrs	r0, r2, #31
 8020460:	fb84 5402 	smull	r5, r4, r4, r2
 8020464:	ebc0 1464 	rsb	r4, r0, r4, asr #5
 8020468:	2564      	movs	r5, #100	; 0x64
 802046a:	fb05 2414 	mls	r4, r5, r4, r2
 802046e:	2c00      	cmp	r4, #0
 8020470:	d0ce      	beq.n	8020410 <gmtime_r+0xbc>
 8020472:	2201      	movs	r2, #1
 8020474:	e7d8      	b.n	8020428 <gmtime_r+0xd4>
 8020476:	4c0e      	ldr	r4, [pc, #56]	; (80204b0 <gmtime_r+0x15c>)
 8020478:	f854 0904 	ldr.w	r0, [r4], #-4
 802047c:	181b      	adds	r3, r3, r0
 802047e:	f102 32ff 	add.w	r2, r2, #4294967295
 8020482:	d4f9      	bmi.n	8020478 <gmtime_r+0x124>
 8020484:	e7bd      	b.n	8020402 <gmtime_r+0xae>
 8020486:	bf00      	nop
 8020488:	c22e4507 	.word	0xc22e4507
 802048c:	00015180 	.word	0x00015180
 8020490:	91a2b3c5 	.word	0x91a2b3c5
 8020494:	88888889 	.word	0x88888889
 8020498:	92492493 	.word	0x92492493
 802049c:	166db073 	.word	0x166db073
 80204a0:	fffffa4b 	.word	0xfffffa4b
 80204a4:	08025d30 	.word	0x08025d30
 80204a8:	51eb851f 	.word	0x51eb851f
 80204ac:	08025b18 	.word	0x08025b18
 80204b0:	08025d3c 	.word	0x08025d3c

080204b4 <siprintf>:
 80204b4:	b40e      	push	{r1, r2, r3}
 80204b6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80204b8:	b09c      	sub	sp, #112	; 0x70
 80204ba:	ab21      	add	r3, sp, #132	; 0x84
 80204bc:	490f      	ldr	r1, [pc, #60]	; (80204fc <siprintf+0x48>)
 80204be:	f853 2b04 	ldr.w	r2, [r3], #4
 80204c2:	9301      	str	r3, [sp, #4]
 80204c4:	4605      	mov	r5, r0
 80204c6:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 80204ca:	6808      	ldr	r0, [r1, #0]
 80204cc:	9502      	str	r5, [sp, #8]
 80204ce:	f44f 7702 	mov.w	r7, #520	; 0x208
 80204d2:	f64f 76ff 	movw	r6, #65535	; 0xffff
 80204d6:	a902      	add	r1, sp, #8
 80204d8:	9506      	str	r5, [sp, #24]
 80204da:	f8ad 7014 	strh.w	r7, [sp, #20]
 80204de:	9404      	str	r4, [sp, #16]
 80204e0:	9407      	str	r4, [sp, #28]
 80204e2:	f8ad 6016 	strh.w	r6, [sp, #22]
 80204e6:	f000 f9b9 	bl	802085c <_svfiprintf_r>
 80204ea:	9b02      	ldr	r3, [sp, #8]
 80204ec:	2200      	movs	r2, #0
 80204ee:	701a      	strb	r2, [r3, #0]
 80204f0:	b01c      	add	sp, #112	; 0x70
 80204f2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80204f6:	b003      	add	sp, #12
 80204f8:	4770      	bx	lr
 80204fa:	bf00      	nop
 80204fc:	20010580 	.word	0x20010580

08020500 <siscanf>:
 8020500:	b40e      	push	{r1, r2, r3}
 8020502:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020504:	b09c      	sub	sp, #112	; 0x70
 8020506:	ac21      	add	r4, sp, #132	; 0x84
 8020508:	f44f 7201 	mov.w	r2, #516	; 0x204
 802050c:	f854 6b04 	ldr.w	r6, [r4], #4
 8020510:	f8ad 2014 	strh.w	r2, [sp, #20]
 8020514:	9002      	str	r0, [sp, #8]
 8020516:	9006      	str	r0, [sp, #24]
 8020518:	f7ff fa9e 	bl	801fa58 <strlen>
 802051c:	4b0c      	ldr	r3, [pc, #48]	; (8020550 <siscanf+0x50>)
 802051e:	9401      	str	r4, [sp, #4]
 8020520:	4605      	mov	r5, r0
 8020522:	4632      	mov	r2, r6
 8020524:	4f0b      	ldr	r7, [pc, #44]	; (8020554 <siscanf+0x54>)
 8020526:	6818      	ldr	r0, [r3, #0]
 8020528:	9503      	str	r5, [sp, #12]
 802052a:	4623      	mov	r3, r4
 802052c:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8020530:	2400      	movs	r4, #0
 8020532:	a902      	add	r1, sp, #8
 8020534:	9507      	str	r5, [sp, #28]
 8020536:	970a      	str	r7, [sp, #40]	; 0x28
 8020538:	940e      	str	r4, [sp, #56]	; 0x38
 802053a:	9413      	str	r4, [sp, #76]	; 0x4c
 802053c:	f8ad 6016 	strh.w	r6, [sp, #22]
 8020540:	f000 ff78 	bl	8021434 <__ssvfiscanf_r>
 8020544:	b01c      	add	sp, #112	; 0x70
 8020546:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 802054a:	b003      	add	sp, #12
 802054c:	4770      	bx	lr
 802054e:	bf00      	nop
 8020550:	20010580 	.word	0x20010580
 8020554:	08020559 	.word	0x08020559

08020558 <__seofread>:
 8020558:	2000      	movs	r0, #0
 802055a:	4770      	bx	lr

0802055c <strcpy>:
 802055c:	ea80 0201 	eor.w	r2, r0, r1
 8020560:	4684      	mov	ip, r0
 8020562:	f012 0f03 	tst.w	r2, #3
 8020566:	d14f      	bne.n	8020608 <strcpy+0xac>
 8020568:	f011 0f03 	tst.w	r1, #3
 802056c:	d132      	bne.n	80205d4 <strcpy+0x78>
 802056e:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8020572:	f011 0f04 	tst.w	r1, #4
 8020576:	f851 3b04 	ldr.w	r3, [r1], #4
 802057a:	d00b      	beq.n	8020594 <strcpy+0x38>
 802057c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8020580:	439a      	bics	r2, r3
 8020582:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8020586:	bf04      	itt	eq
 8020588:	f84c 3b04 	streq.w	r3, [ip], #4
 802058c:	f851 3b04 	ldreq.w	r3, [r1], #4
 8020590:	d116      	bne.n	80205c0 <strcpy+0x64>
 8020592:	bf00      	nop
 8020594:	f851 4b04 	ldr.w	r4, [r1], #4
 8020598:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 802059c:	439a      	bics	r2, r3
 802059e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80205a2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 80205a6:	d10b      	bne.n	80205c0 <strcpy+0x64>
 80205a8:	f84c 3b04 	str.w	r3, [ip], #4
 80205ac:	43a2      	bics	r2, r4
 80205ae:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80205b2:	bf04      	itt	eq
 80205b4:	f851 3b04 	ldreq.w	r3, [r1], #4
 80205b8:	f84c 4b04 	streq.w	r4, [ip], #4
 80205bc:	d0ea      	beq.n	8020594 <strcpy+0x38>
 80205be:	4623      	mov	r3, r4
 80205c0:	f80c 3b01 	strb.w	r3, [ip], #1
 80205c4:	f013 0fff 	tst.w	r3, #255	; 0xff
 80205c8:	ea4f 2333 	mov.w	r3, r3, ror #8
 80205cc:	d1f8      	bne.n	80205c0 <strcpy+0x64>
 80205ce:	f85d 4b04 	ldr.w	r4, [sp], #4
 80205d2:	4770      	bx	lr
 80205d4:	f011 0f01 	tst.w	r1, #1
 80205d8:	d006      	beq.n	80205e8 <strcpy+0x8c>
 80205da:	f811 2b01 	ldrb.w	r2, [r1], #1
 80205de:	f80c 2b01 	strb.w	r2, [ip], #1
 80205e2:	2a00      	cmp	r2, #0
 80205e4:	bf08      	it	eq
 80205e6:	4770      	bxeq	lr
 80205e8:	f011 0f02 	tst.w	r1, #2
 80205ec:	d0bf      	beq.n	802056e <strcpy+0x12>
 80205ee:	f831 2b02 	ldrh.w	r2, [r1], #2
 80205f2:	f012 0fff 	tst.w	r2, #255	; 0xff
 80205f6:	bf16      	itet	ne
 80205f8:	f82c 2b02 	strhne.w	r2, [ip], #2
 80205fc:	f88c 2000 	strbeq.w	r2, [ip]
 8020600:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 8020604:	d1b3      	bne.n	802056e <strcpy+0x12>
 8020606:	4770      	bx	lr
 8020608:	f811 2b01 	ldrb.w	r2, [r1], #1
 802060c:	f80c 2b01 	strb.w	r2, [ip], #1
 8020610:	2a00      	cmp	r2, #0
 8020612:	d1f9      	bne.n	8020608 <strcpy+0xac>
 8020614:	4770      	bx	lr
 8020616:	bf00      	nop

08020618 <_strtoul_r>:
 8020618:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802061c:	4c46      	ldr	r4, [pc, #280]	; (8020738 <_strtoul_r+0x120>)
 802061e:	460f      	mov	r7, r1
 8020620:	f8d4 e000 	ldr.w	lr, [r4]
 8020624:	e000      	b.n	8020628 <_strtoul_r+0x10>
 8020626:	4627      	mov	r7, r4
 8020628:	463c      	mov	r4, r7
 802062a:	f814 5b01 	ldrb.w	r5, [r4], #1
 802062e:	eb0e 0605 	add.w	r6, lr, r5
 8020632:	7876      	ldrb	r6, [r6, #1]
 8020634:	f006 0608 	and.w	r6, r6, #8
 8020638:	f006 08ff 	and.w	r8, r6, #255	; 0xff
 802063c:	2e00      	cmp	r6, #0
 802063e:	d1f2      	bne.n	8020626 <_strtoul_r+0xe>
 8020640:	2d2d      	cmp	r5, #45	; 0x2d
 8020642:	d051      	beq.n	80206e8 <_strtoul_r+0xd0>
 8020644:	2d2b      	cmp	r5, #43	; 0x2b
 8020646:	bf04      	itt	eq
 8020648:	787d      	ldrbeq	r5, [r7, #1]
 802064a:	1cbc      	addeq	r4, r7, #2
 802064c:	b15b      	cbz	r3, 8020666 <_strtoul_r+0x4e>
 802064e:	2b10      	cmp	r3, #16
 8020650:	d05b      	beq.n	802070a <_strtoul_r+0xf2>
 8020652:	f04f 39ff 	mov.w	r9, #4294967295
 8020656:	fbb9 f9f3 	udiv	r9, r9, r3
 802065a:	fb03 fb09 	mul.w	fp, r3, r9
 802065e:	ea6f 0b0b 	mvn.w	fp, fp
 8020662:	469a      	mov	sl, r3
 8020664:	e007      	b.n	8020676 <_strtoul_r+0x5e>
 8020666:	2d30      	cmp	r5, #48	; 0x30
 8020668:	d043      	beq.n	80206f2 <_strtoul_r+0xda>
 802066a:	230a      	movs	r3, #10
 802066c:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 802073c <_strtoul_r+0x124>
 8020670:	469a      	mov	sl, r3
 8020672:	f04f 0b05 	mov.w	fp, #5
 8020676:	2700      	movs	r7, #0
 8020678:	46bc      	mov	ip, r7
 802067a:	e00c      	b.n	8020696 <_strtoul_r+0x7e>
 802067c:	3d30      	subs	r5, #48	; 0x30
 802067e:	42ab      	cmp	r3, r5
 8020680:	dd19      	ble.n	80206b6 <_strtoul_r+0x9e>
 8020682:	1c7e      	adds	r6, r7, #1
 8020684:	d005      	beq.n	8020692 <_strtoul_r+0x7a>
 8020686:	45cc      	cmp	ip, r9
 8020688:	d824      	bhi.n	80206d4 <_strtoul_r+0xbc>
 802068a:	d021      	beq.n	80206d0 <_strtoul_r+0xb8>
 802068c:	fb0a 5c0c 	mla	ip, sl, ip, r5
 8020690:	2701      	movs	r7, #1
 8020692:	f814 5b01 	ldrb.w	r5, [r4], #1
 8020696:	eb0e 0605 	add.w	r6, lr, r5
 802069a:	7876      	ldrb	r6, [r6, #1]
 802069c:	f016 0f04 	tst.w	r6, #4
 80206a0:	d1ec      	bne.n	802067c <_strtoul_r+0x64>
 80206a2:	f016 0603 	ands.w	r6, r6, #3
 80206a6:	d006      	beq.n	80206b6 <_strtoul_r+0x9e>
 80206a8:	2e01      	cmp	r6, #1
 80206aa:	bf0c      	ite	eq
 80206ac:	2637      	moveq	r6, #55	; 0x37
 80206ae:	2657      	movne	r6, #87	; 0x57
 80206b0:	1bad      	subs	r5, r5, r6
 80206b2:	42ab      	cmp	r3, r5
 80206b4:	dce5      	bgt.n	8020682 <_strtoul_r+0x6a>
 80206b6:	2f00      	cmp	r7, #0
 80206b8:	db11      	blt.n	80206de <_strtoul_r+0xc6>
 80206ba:	f1c8 0000 	rsb	r0, r8, #0
 80206be:	ea8c 0000 	eor.w	r0, ip, r0
 80206c2:	4440      	add	r0, r8
 80206c4:	b14a      	cbz	r2, 80206da <_strtoul_r+0xc2>
 80206c6:	b107      	cbz	r7, 80206ca <_strtoul_r+0xb2>
 80206c8:	1e61      	subs	r1, r4, #1
 80206ca:	6011      	str	r1, [r2, #0]
 80206cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80206d0:	455d      	cmp	r5, fp
 80206d2:	dddb      	ble.n	802068c <_strtoul_r+0x74>
 80206d4:	f04f 37ff 	mov.w	r7, #4294967295
 80206d8:	e7db      	b.n	8020692 <_strtoul_r+0x7a>
 80206da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80206de:	2322      	movs	r3, #34	; 0x22
 80206e0:	6003      	str	r3, [r0, #0]
 80206e2:	f04f 30ff 	mov.w	r0, #4294967295
 80206e6:	e7ed      	b.n	80206c4 <_strtoul_r+0xac>
 80206e8:	1cbc      	adds	r4, r7, #2
 80206ea:	787d      	ldrb	r5, [r7, #1]
 80206ec:	f04f 0801 	mov.w	r8, #1
 80206f0:	e7ac      	b.n	802064c <_strtoul_r+0x34>
 80206f2:	7823      	ldrb	r3, [r4, #0]
 80206f4:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80206f8:	2b58      	cmp	r3, #88	; 0x58
 80206fa:	d013      	beq.n	8020724 <_strtoul_r+0x10c>
 80206fc:	2308      	movs	r3, #8
 80206fe:	469a      	mov	sl, r3
 8020700:	f04f 0b07 	mov.w	fp, #7
 8020704:	f06f 4960 	mvn.w	r9, #3758096384	; 0xe0000000
 8020708:	e7b5      	b.n	8020676 <_strtoul_r+0x5e>
 802070a:	2d30      	cmp	r5, #48	; 0x30
 802070c:	d005      	beq.n	802071a <_strtoul_r+0x102>
 802070e:	f04f 0b0f 	mov.w	fp, #15
 8020712:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
 8020716:	469a      	mov	sl, r3
 8020718:	e7ad      	b.n	8020676 <_strtoul_r+0x5e>
 802071a:	7826      	ldrb	r6, [r4, #0]
 802071c:	f006 06df 	and.w	r6, r6, #223	; 0xdf
 8020720:	2e58      	cmp	r6, #88	; 0x58
 8020722:	d1f4      	bne.n	802070e <_strtoul_r+0xf6>
 8020724:	f04f 0a10 	mov.w	sl, #16
 8020728:	7865      	ldrb	r5, [r4, #1]
 802072a:	4653      	mov	r3, sl
 802072c:	f04f 0b0f 	mov.w	fp, #15
 8020730:	3402      	adds	r4, #2
 8020732:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
 8020736:	e79e      	b.n	8020676 <_strtoul_r+0x5e>
 8020738:	2001010c 	.word	0x2001010c
 802073c:	19999999 	.word	0x19999999

08020740 <strtoul>:
 8020740:	b430      	push	{r4, r5}
 8020742:	4c04      	ldr	r4, [pc, #16]	; (8020754 <strtoul+0x14>)
 8020744:	460d      	mov	r5, r1
 8020746:	4613      	mov	r3, r2
 8020748:	4601      	mov	r1, r0
 802074a:	462a      	mov	r2, r5
 802074c:	6820      	ldr	r0, [r4, #0]
 802074e:	bc30      	pop	{r4, r5}
 8020750:	f7ff bf62 	b.w	8020618 <_strtoul_r>
 8020754:	20010580 	.word	0x20010580

08020758 <__ssprint_r>:
 8020758:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802075c:	6893      	ldr	r3, [r2, #8]
 802075e:	f8d2 8000 	ldr.w	r8, [r2]
 8020762:	b083      	sub	sp, #12
 8020764:	4691      	mov	r9, r2
 8020766:	2b00      	cmp	r3, #0
 8020768:	d072      	beq.n	8020850 <__ssprint_r+0xf8>
 802076a:	4607      	mov	r7, r0
 802076c:	f04f 0b00 	mov.w	fp, #0
 8020770:	6808      	ldr	r0, [r1, #0]
 8020772:	688b      	ldr	r3, [r1, #8]
 8020774:	460d      	mov	r5, r1
 8020776:	465c      	mov	r4, fp
 8020778:	2c00      	cmp	r4, #0
 802077a:	d045      	beq.n	8020808 <__ssprint_r+0xb0>
 802077c:	429c      	cmp	r4, r3
 802077e:	461e      	mov	r6, r3
 8020780:	469a      	mov	sl, r3
 8020782:	d348      	bcc.n	8020816 <__ssprint_r+0xbe>
 8020784:	89ab      	ldrh	r3, [r5, #12]
 8020786:	f413 6f90 	tst.w	r3, #1152	; 0x480
 802078a:	d02d      	beq.n	80207e8 <__ssprint_r+0x90>
 802078c:	696e      	ldr	r6, [r5, #20]
 802078e:	6929      	ldr	r1, [r5, #16]
 8020790:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 8020794:	ebc1 0a00 	rsb	sl, r1, r0
 8020798:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
 802079c:	1c60      	adds	r0, r4, #1
 802079e:	1076      	asrs	r6, r6, #1
 80207a0:	4450      	add	r0, sl
 80207a2:	4286      	cmp	r6, r0
 80207a4:	4632      	mov	r2, r6
 80207a6:	bf3c      	itt	cc
 80207a8:	4606      	movcc	r6, r0
 80207aa:	4632      	movcc	r2, r6
 80207ac:	055b      	lsls	r3, r3, #21
 80207ae:	d535      	bpl.n	802081c <__ssprint_r+0xc4>
 80207b0:	4611      	mov	r1, r2
 80207b2:	4638      	mov	r0, r7
 80207b4:	f7f5 fb06 	bl	8015dc4 <_malloc_r>
 80207b8:	2800      	cmp	r0, #0
 80207ba:	d039      	beq.n	8020830 <__ssprint_r+0xd8>
 80207bc:	4652      	mov	r2, sl
 80207be:	6929      	ldr	r1, [r5, #16]
 80207c0:	9001      	str	r0, [sp, #4]
 80207c2:	f7df fd8b 	bl	80002dc <memcpy>
 80207c6:	89aa      	ldrh	r2, [r5, #12]
 80207c8:	9b01      	ldr	r3, [sp, #4]
 80207ca:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 80207ce:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80207d2:	81aa      	strh	r2, [r5, #12]
 80207d4:	ebca 0206 	rsb	r2, sl, r6
 80207d8:	eb03 000a 	add.w	r0, r3, sl
 80207dc:	616e      	str	r6, [r5, #20]
 80207de:	612b      	str	r3, [r5, #16]
 80207e0:	6028      	str	r0, [r5, #0]
 80207e2:	60aa      	str	r2, [r5, #8]
 80207e4:	4626      	mov	r6, r4
 80207e6:	46a2      	mov	sl, r4
 80207e8:	4652      	mov	r2, sl
 80207ea:	4659      	mov	r1, fp
 80207ec:	f001 fbe0 	bl	8021fb0 <memmove>
 80207f0:	f8d9 2008 	ldr.w	r2, [r9, #8]
 80207f4:	68ab      	ldr	r3, [r5, #8]
 80207f6:	6828      	ldr	r0, [r5, #0]
 80207f8:	1b9b      	subs	r3, r3, r6
 80207fa:	4450      	add	r0, sl
 80207fc:	1b14      	subs	r4, r2, r4
 80207fe:	60ab      	str	r3, [r5, #8]
 8020800:	6028      	str	r0, [r5, #0]
 8020802:	f8c9 4008 	str.w	r4, [r9, #8]
 8020806:	b31c      	cbz	r4, 8020850 <__ssprint_r+0xf8>
 8020808:	f8d8 b000 	ldr.w	fp, [r8]
 802080c:	f8d8 4004 	ldr.w	r4, [r8, #4]
 8020810:	f108 0808 	add.w	r8, r8, #8
 8020814:	e7b0      	b.n	8020778 <__ssprint_r+0x20>
 8020816:	4626      	mov	r6, r4
 8020818:	46a2      	mov	sl, r4
 802081a:	e7e5      	b.n	80207e8 <__ssprint_r+0x90>
 802081c:	4638      	mov	r0, r7
 802081e:	f7f5 fae5 	bl	8015dec <_realloc_r>
 8020822:	4603      	mov	r3, r0
 8020824:	2800      	cmp	r0, #0
 8020826:	d1d5      	bne.n	80207d4 <__ssprint_r+0x7c>
 8020828:	4638      	mov	r0, r7
 802082a:	6929      	ldr	r1, [r5, #16]
 802082c:	f7f5 faf4 	bl	8015e18 <_free_r>
 8020830:	230c      	movs	r3, #12
 8020832:	603b      	str	r3, [r7, #0]
 8020834:	89ab      	ldrh	r3, [r5, #12]
 8020836:	2200      	movs	r2, #0
 8020838:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802083c:	f04f 30ff 	mov.w	r0, #4294967295
 8020840:	81ab      	strh	r3, [r5, #12]
 8020842:	f8c9 2008 	str.w	r2, [r9, #8]
 8020846:	f8c9 2004 	str.w	r2, [r9, #4]
 802084a:	b003      	add	sp, #12
 802084c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020850:	2000      	movs	r0, #0
 8020852:	f8c9 0004 	str.w	r0, [r9, #4]
 8020856:	b003      	add	sp, #12
 8020858:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0802085c <_svfiprintf_r>:
 802085c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020860:	4691      	mov	r9, r2
 8020862:	898a      	ldrh	r2, [r1, #12]
 8020864:	b0ad      	sub	sp, #180	; 0xb4
 8020866:	0612      	lsls	r2, r2, #24
 8020868:	468a      	mov	sl, r1
 802086a:	9306      	str	r3, [sp, #24]
 802086c:	9004      	str	r0, [sp, #16]
 802086e:	d503      	bpl.n	8020878 <_svfiprintf_r+0x1c>
 8020870:	690b      	ldr	r3, [r1, #16]
 8020872:	2b00      	cmp	r3, #0
 8020874:	f000 850f 	beq.w	8021296 <_svfiprintf_r+0xa3a>
 8020878:	2300      	movs	r3, #0
 802087a:	f10d 0870 	add.w	r8, sp, #112	; 0x70
 802087e:	930a      	str	r3, [sp, #40]	; 0x28
 8020880:	9311      	str	r3, [sp, #68]	; 0x44
 8020882:	9310      	str	r3, [sp, #64]	; 0x40
 8020884:	9303      	str	r3, [sp, #12]
 8020886:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 802088a:	4644      	mov	r4, r8
 802088c:	f899 3000 	ldrb.w	r3, [r9]
 8020890:	2b00      	cmp	r3, #0
 8020892:	f000 8382 	beq.w	8020f9a <_svfiprintf_r+0x73e>
 8020896:	2b25      	cmp	r3, #37	; 0x25
 8020898:	f000 837f 	beq.w	8020f9a <_svfiprintf_r+0x73e>
 802089c:	464a      	mov	r2, r9
 802089e:	e001      	b.n	80208a4 <_svfiprintf_r+0x48>
 80208a0:	2b25      	cmp	r3, #37	; 0x25
 80208a2:	d003      	beq.n	80208ac <_svfiprintf_r+0x50>
 80208a4:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80208a8:	2b00      	cmp	r3, #0
 80208aa:	d1f9      	bne.n	80208a0 <_svfiprintf_r+0x44>
 80208ac:	ebc9 0602 	rsb	r6, r9, r2
 80208b0:	4615      	mov	r5, r2
 80208b2:	b17e      	cbz	r6, 80208d4 <_svfiprintf_r+0x78>
 80208b4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80208b6:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80208b8:	f8c4 9000 	str.w	r9, [r4]
 80208bc:	3301      	adds	r3, #1
 80208be:	4432      	add	r2, r6
 80208c0:	2b07      	cmp	r3, #7
 80208c2:	6066      	str	r6, [r4, #4]
 80208c4:	9211      	str	r2, [sp, #68]	; 0x44
 80208c6:	9310      	str	r3, [sp, #64]	; 0x40
 80208c8:	f300 83fb 	bgt.w	80210c2 <_svfiprintf_r+0x866>
 80208cc:	3408      	adds	r4, #8
 80208ce:	9b03      	ldr	r3, [sp, #12]
 80208d0:	4433      	add	r3, r6
 80208d2:	9303      	str	r3, [sp, #12]
 80208d4:	782b      	ldrb	r3, [r5, #0]
 80208d6:	2b00      	cmp	r3, #0
 80208d8:	f000 8384 	beq.w	8020fe4 <_svfiprintf_r+0x788>
 80208dc:	2100      	movs	r1, #0
 80208de:	f04f 32ff 	mov.w	r2, #4294967295
 80208e2:	1c68      	adds	r0, r5, #1
 80208e4:	786b      	ldrb	r3, [r5, #1]
 80208e6:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 80208ea:	9100      	str	r1, [sp, #0]
 80208ec:	9201      	str	r2, [sp, #4]
 80208ee:	460d      	mov	r5, r1
 80208f0:	f100 0901 	add.w	r9, r0, #1
 80208f4:	f1a3 0220 	sub.w	r2, r3, #32
 80208f8:	2a58      	cmp	r2, #88	; 0x58
 80208fa:	f200 8286 	bhi.w	8020e0a <_svfiprintf_r+0x5ae>
 80208fe:	e8df f012 	tbh	[pc, r2, lsl #1]
 8020902:	01e0      	.short	0x01e0
 8020904:	02840284 	.word	0x02840284
 8020908:	028401d8 	.word	0x028401d8
 802090c:	02840284 	.word	0x02840284
 8020910:	02840284 	.word	0x02840284
 8020914:	02530284 	.word	0x02530284
 8020918:	0284024e 	.word	0x0284024e
 802091c:	026700b7 	.word	0x026700b7
 8020920:	02460284 	.word	0x02460284
 8020924:	02380238 	.word	0x02380238
 8020928:	02380238 	.word	0x02380238
 802092c:	02380238 	.word	0x02380238
 8020930:	02380238 	.word	0x02380238
 8020934:	02840238 	.word	0x02840238
 8020938:	02840284 	.word	0x02840284
 802093c:	02840284 	.word	0x02840284
 8020940:	02840284 	.word	0x02840284
 8020944:	02840284 	.word	0x02840284
 8020948:	021c0284 	.word	0x021c0284
 802094c:	02840284 	.word	0x02840284
 8020950:	02840284 	.word	0x02840284
 8020954:	02840284 	.word	0x02840284
 8020958:	02840284 	.word	0x02840284
 802095c:	02840284 	.word	0x02840284
 8020960:	02840200 	.word	0x02840200
 8020964:	02840284 	.word	0x02840284
 8020968:	02840284 	.word	0x02840284
 802096c:	028401c3 	.word	0x028401c3
 8020970:	019f0284 	.word	0x019f0284
 8020974:	02840284 	.word	0x02840284
 8020978:	02840284 	.word	0x02840284
 802097c:	02840284 	.word	0x02840284
 8020980:	02840284 	.word	0x02840284
 8020984:	02840284 	.word	0x02840284
 8020988:	01270143 	.word	0x01270143
 802098c:	02840284 	.word	0x02840284
 8020990:	011f0284 	.word	0x011f0284
 8020994:	02840127 	.word	0x02840127
 8020998:	01140284 	.word	0x01140284
 802099c:	00fe0284 	.word	0x00fe0284
 80209a0:	00e900a6 	.word	0x00e900a6
 80209a4:	028400e1 	.word	0x028400e1
 80209a8:	028400bf 	.word	0x028400bf
 80209ac:	02840059 	.word	0x02840059
 80209b0:	01e80284 	.word	0x01e80284
 80209b4:	9b00      	ldr	r3, [sp, #0]
 80209b6:	9505      	str	r5, [sp, #20]
 80209b8:	069a      	lsls	r2, r3, #26
 80209ba:	f140 816e 	bpl.w	8020c9a <_svfiprintf_r+0x43e>
 80209be:	9b06      	ldr	r3, [sp, #24]
 80209c0:	3307      	adds	r3, #7
 80209c2:	f023 0307 	bic.w	r3, r3, #7
 80209c6:	f103 0208 	add.w	r2, r3, #8
 80209ca:	e9d3 6700 	ldrd	r6, r7, [r3]
 80209ce:	9206      	str	r2, [sp, #24]
 80209d0:	2301      	movs	r3, #1
 80209d2:	2200      	movs	r2, #0
 80209d4:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
 80209d8:	9a01      	ldr	r2, [sp, #4]
 80209da:	9202      	str	r2, [sp, #8]
 80209dc:	f04f 0b00 	mov.w	fp, #0
 80209e0:	9a01      	ldr	r2, [sp, #4]
 80209e2:	2a00      	cmp	r2, #0
 80209e4:	db03      	blt.n	80209ee <_svfiprintf_r+0x192>
 80209e6:	9a00      	ldr	r2, [sp, #0]
 80209e8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80209ec:	9200      	str	r2, [sp, #0]
 80209ee:	ea56 0207 	orrs.w	r2, r6, r7
 80209f2:	f040 82d4 	bne.w	8020f9e <_svfiprintf_r+0x742>
 80209f6:	9a01      	ldr	r2, [sp, #4]
 80209f8:	2a00      	cmp	r2, #0
 80209fa:	f000 8350 	beq.w	802109e <_svfiprintf_r+0x842>
 80209fe:	2b01      	cmp	r3, #1
 8020a00:	f000 83b2 	beq.w	8021168 <_svfiprintf_r+0x90c>
 8020a04:	2b02      	cmp	r3, #2
 8020a06:	f000 8371 	beq.w	80210ec <_svfiprintf_r+0x890>
 8020a0a:	4641      	mov	r1, r8
 8020a0c:	08f2      	lsrs	r2, r6, #3
 8020a0e:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
 8020a12:	08f8      	lsrs	r0, r7, #3
 8020a14:	f006 0307 	and.w	r3, r6, #7
 8020a18:	4607      	mov	r7, r0
 8020a1a:	4616      	mov	r6, r2
 8020a1c:	3330      	adds	r3, #48	; 0x30
 8020a1e:	ea56 0207 	orrs.w	r2, r6, r7
 8020a22:	f801 3d01 	strb.w	r3, [r1, #-1]!
 8020a26:	d1f1      	bne.n	8020a0c <_svfiprintf_r+0x1b0>
 8020a28:	9a00      	ldr	r2, [sp, #0]
 8020a2a:	9109      	str	r1, [sp, #36]	; 0x24
 8020a2c:	07d0      	lsls	r0, r2, #31
 8020a2e:	f140 8397 	bpl.w	8021160 <_svfiprintf_r+0x904>
 8020a32:	2b30      	cmp	r3, #48	; 0x30
 8020a34:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020a36:	f000 82d1 	beq.w	8020fdc <_svfiprintf_r+0x780>
 8020a3a:	3b01      	subs	r3, #1
 8020a3c:	461a      	mov	r2, r3
 8020a3e:	9309      	str	r3, [sp, #36]	; 0x24
 8020a40:	ebc2 0208 	rsb	r2, r2, r8
 8020a44:	2330      	movs	r3, #48	; 0x30
 8020a46:	9202      	str	r2, [sp, #8]
 8020a48:	f801 3c01 	strb.w	r3, [r1, #-1]
 8020a4c:	e32d      	b.n	80210aa <_svfiprintf_r+0x84e>
 8020a4e:	9b00      	ldr	r3, [sp, #0]
 8020a50:	9505      	str	r5, [sp, #20]
 8020a52:	f013 0320 	ands.w	r3, r3, #32
 8020a56:	f000 815e 	beq.w	8020d16 <_svfiprintf_r+0x4ba>
 8020a5a:	9b06      	ldr	r3, [sp, #24]
 8020a5c:	3307      	adds	r3, #7
 8020a5e:	f023 0307 	bic.w	r3, r3, #7
 8020a62:	f103 0208 	add.w	r2, r3, #8
 8020a66:	e9d3 6700 	ldrd	r6, r7, [r3]
 8020a6a:	9206      	str	r2, [sp, #24]
 8020a6c:	2300      	movs	r3, #0
 8020a6e:	e7b0      	b.n	80209d2 <_svfiprintf_r+0x176>
 8020a70:	4648      	mov	r0, r9
 8020a72:	9b00      	ldr	r3, [sp, #0]
 8020a74:	f043 0304 	orr.w	r3, r3, #4
 8020a78:	9300      	str	r3, [sp, #0]
 8020a7a:	f899 3000 	ldrb.w	r3, [r9]
 8020a7e:	e737      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020a80:	9a06      	ldr	r2, [sp, #24]
 8020a82:	9505      	str	r5, [sp, #20]
 8020a84:	6813      	ldr	r3, [r2, #0]
 8020a86:	9309      	str	r3, [sp, #36]	; 0x24
 8020a88:	2100      	movs	r1, #0
 8020a8a:	1d16      	adds	r6, r2, #4
 8020a8c:	9a01      	ldr	r2, [sp, #4]
 8020a8e:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8020a92:	9202      	str	r2, [sp, #8]
 8020a94:	2b00      	cmp	r3, #0
 8020a96:	f000 83f3 	beq.w	8021280 <_svfiprintf_r+0xa24>
 8020a9a:	9b01      	ldr	r3, [sp, #4]
 8020a9c:	2b00      	cmp	r3, #0
 8020a9e:	f2c0 83e5 	blt.w	802126c <_svfiprintf_r+0xa10>
 8020aa2:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8020aa4:	461a      	mov	r2, r3
 8020aa6:	4628      	mov	r0, r5
 8020aa8:	2100      	movs	r1, #0
 8020aaa:	f001 fa37 	bl	8021f1c <memchr>
 8020aae:	2800      	cmp	r0, #0
 8020ab0:	f000 8402 	beq.w	80212b8 <_svfiprintf_r+0xa5c>
 8020ab4:	1b43      	subs	r3, r0, r5
 8020ab6:	9302      	str	r3, [sp, #8]
 8020ab8:	2300      	movs	r3, #0
 8020aba:	9606      	str	r6, [sp, #24]
 8020abc:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 8020ac0:	9301      	str	r3, [sp, #4]
 8020ac2:	e2f2      	b.n	80210aa <_svfiprintf_r+0x84e>
 8020ac4:	9b00      	ldr	r3, [sp, #0]
 8020ac6:	f043 0320 	orr.w	r3, r3, #32
 8020aca:	9300      	str	r3, [sp, #0]
 8020acc:	f899 3000 	ldrb.w	r3, [r9]
 8020ad0:	4648      	mov	r0, r9
 8020ad2:	e70d      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020ad4:	9806      	ldr	r0, [sp, #24]
 8020ad6:	9900      	ldr	r1, [sp, #0]
 8020ad8:	9505      	str	r5, [sp, #20]
 8020ada:	2330      	movs	r3, #48	; 0x30
 8020adc:	4602      	mov	r2, r0
 8020ade:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
 8020ae2:	2378      	movs	r3, #120	; 0x78
 8020ae4:	f041 0102 	orr.w	r1, r1, #2
 8020ae8:	3204      	adds	r2, #4
 8020aea:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
 8020aee:	4bb5      	ldr	r3, [pc, #724]	; (8020dc4 <_svfiprintf_r+0x568>)
 8020af0:	930a      	str	r3, [sp, #40]	; 0x28
 8020af2:	6806      	ldr	r6, [r0, #0]
 8020af4:	9100      	str	r1, [sp, #0]
 8020af6:	9206      	str	r2, [sp, #24]
 8020af8:	2700      	movs	r7, #0
 8020afa:	2302      	movs	r3, #2
 8020afc:	e769      	b.n	80209d2 <_svfiprintf_r+0x176>
 8020afe:	9b00      	ldr	r3, [sp, #0]
 8020b00:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8020b04:	069d      	lsls	r5, r3, #26
 8020b06:	f100 837f 	bmi.w	8021208 <_svfiprintf_r+0x9ac>
 8020b0a:	9b00      	ldr	r3, [sp, #0]
 8020b0c:	06d8      	lsls	r0, r3, #27
 8020b0e:	f100 8394 	bmi.w	802123a <_svfiprintf_r+0x9de>
 8020b12:	9b00      	ldr	r3, [sp, #0]
 8020b14:	0659      	lsls	r1, r3, #25
 8020b16:	f140 8390 	bpl.w	802123a <_svfiprintf_r+0x9de>
 8020b1a:	9a06      	ldr	r2, [sp, #24]
 8020b1c:	6813      	ldr	r3, [r2, #0]
 8020b1e:	3204      	adds	r2, #4
 8020b20:	9206      	str	r2, [sp, #24]
 8020b22:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 8020b26:	801a      	strh	r2, [r3, #0]
 8020b28:	e6b0      	b.n	802088c <_svfiprintf_r+0x30>
 8020b2a:	f899 3000 	ldrb.w	r3, [r9]
 8020b2e:	2b6c      	cmp	r3, #108	; 0x6c
 8020b30:	4648      	mov	r0, r9
 8020b32:	f000 8375 	beq.w	8021220 <_svfiprintf_r+0x9c4>
 8020b36:	9a00      	ldr	r2, [sp, #0]
 8020b38:	f042 0210 	orr.w	r2, r2, #16
 8020b3c:	9200      	str	r2, [sp, #0]
 8020b3e:	e6d7      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020b40:	9b00      	ldr	r3, [sp, #0]
 8020b42:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8020b46:	9300      	str	r3, [sp, #0]
 8020b48:	f899 3000 	ldrb.w	r3, [r9]
 8020b4c:	4648      	mov	r0, r9
 8020b4e:	e6cf      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020b50:	9b00      	ldr	r3, [sp, #0]
 8020b52:	9505      	str	r5, [sp, #20]
 8020b54:	069b      	lsls	r3, r3, #26
 8020b56:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8020b5a:	f140 80f9 	bpl.w	8020d50 <_svfiprintf_r+0x4f4>
 8020b5e:	9906      	ldr	r1, [sp, #24]
 8020b60:	3107      	adds	r1, #7
 8020b62:	f021 0107 	bic.w	r1, r1, #7
 8020b66:	e9d1 2300 	ldrd	r2, r3, [r1]
 8020b6a:	3108      	adds	r1, #8
 8020b6c:	9106      	str	r1, [sp, #24]
 8020b6e:	4616      	mov	r6, r2
 8020b70:	461f      	mov	r7, r3
 8020b72:	2a00      	cmp	r2, #0
 8020b74:	f173 0300 	sbcs.w	r3, r3, #0
 8020b78:	f2c0 8326 	blt.w	80211c8 <_svfiprintf_r+0x96c>
 8020b7c:	9b01      	ldr	r3, [sp, #4]
 8020b7e:	9302      	str	r3, [sp, #8]
 8020b80:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 8020b84:	2301      	movs	r3, #1
 8020b86:	e72b      	b.n	80209e0 <_svfiprintf_r+0x184>
 8020b88:	9a06      	ldr	r2, [sp, #24]
 8020b8a:	9505      	str	r5, [sp, #20]
 8020b8c:	6813      	ldr	r3, [r2, #0]
 8020b8e:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 8020b92:	4613      	mov	r3, r2
 8020b94:	3304      	adds	r3, #4
 8020b96:	2601      	movs	r6, #1
 8020b98:	2100      	movs	r1, #0
 8020b9a:	9306      	str	r3, [sp, #24]
 8020b9c:	ab12      	add	r3, sp, #72	; 0x48
 8020b9e:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8020ba2:	9602      	str	r6, [sp, #8]
 8020ba4:	9309      	str	r3, [sp, #36]	; 0x24
 8020ba6:	2300      	movs	r3, #0
 8020ba8:	9301      	str	r3, [sp, #4]
 8020baa:	9b00      	ldr	r3, [sp, #0]
 8020bac:	f013 0302 	ands.w	r3, r3, #2
 8020bb0:	9307      	str	r3, [sp, #28]
 8020bb2:	9b00      	ldr	r3, [sp, #0]
 8020bb4:	bf18      	it	ne
 8020bb6:	3602      	addne	r6, #2
 8020bb8:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 8020bbc:	9308      	str	r3, [sp, #32]
 8020bbe:	f040 8136 	bne.w	8020e2e <_svfiprintf_r+0x5d2>
 8020bc2:	9b05      	ldr	r3, [sp, #20]
 8020bc4:	1b9d      	subs	r5, r3, r6
 8020bc6:	2d00      	cmp	r5, #0
 8020bc8:	f340 8131 	ble.w	8020e2e <_svfiprintf_r+0x5d2>
 8020bcc:	2d10      	cmp	r5, #16
 8020bce:	9911      	ldr	r1, [sp, #68]	; 0x44
 8020bd0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020bd2:	f8df b1f8 	ldr.w	fp, [pc, #504]	; 8020dcc <_svfiprintf_r+0x570>
 8020bd6:	dd27      	ble.n	8020c28 <_svfiprintf_r+0x3cc>
 8020bd8:	960b      	str	r6, [sp, #44]	; 0x2c
 8020bda:	2710      	movs	r7, #16
 8020bdc:	465e      	mov	r6, fp
 8020bde:	46ab      	mov	fp, r5
 8020be0:	9d04      	ldr	r5, [sp, #16]
 8020be2:	e006      	b.n	8020bf2 <_svfiprintf_r+0x396>
 8020be4:	f1ab 0b10 	sub.w	fp, fp, #16
 8020be8:	f1bb 0f10 	cmp.w	fp, #16
 8020bec:	f104 0408 	add.w	r4, r4, #8
 8020bf0:	dd17      	ble.n	8020c22 <_svfiprintf_r+0x3c6>
 8020bf2:	3201      	adds	r2, #1
 8020bf4:	3110      	adds	r1, #16
 8020bf6:	2a07      	cmp	r2, #7
 8020bf8:	9111      	str	r1, [sp, #68]	; 0x44
 8020bfa:	9210      	str	r2, [sp, #64]	; 0x40
 8020bfc:	e884 00c0 	stmia.w	r4, {r6, r7}
 8020c00:	ddf0      	ble.n	8020be4 <_svfiprintf_r+0x388>
 8020c02:	4628      	mov	r0, r5
 8020c04:	4651      	mov	r1, sl
 8020c06:	aa0f      	add	r2, sp, #60	; 0x3c
 8020c08:	f7ff fda6 	bl	8020758 <__ssprint_r>
 8020c0c:	2800      	cmp	r0, #0
 8020c0e:	f040 81f0 	bne.w	8020ff2 <_svfiprintf_r+0x796>
 8020c12:	f1ab 0b10 	sub.w	fp, fp, #16
 8020c16:	f1bb 0f10 	cmp.w	fp, #16
 8020c1a:	9911      	ldr	r1, [sp, #68]	; 0x44
 8020c1c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020c1e:	4644      	mov	r4, r8
 8020c20:	dce7      	bgt.n	8020bf2 <_svfiprintf_r+0x396>
 8020c22:	465d      	mov	r5, fp
 8020c24:	46b3      	mov	fp, r6
 8020c26:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8020c28:	f8c4 b000 	str.w	fp, [r4]
 8020c2c:	3201      	adds	r2, #1
 8020c2e:	4429      	add	r1, r5
 8020c30:	2a07      	cmp	r2, #7
 8020c32:	9111      	str	r1, [sp, #68]	; 0x44
 8020c34:	9210      	str	r2, [sp, #64]	; 0x40
 8020c36:	6065      	str	r5, [r4, #4]
 8020c38:	f300 8281 	bgt.w	802113e <_svfiprintf_r+0x8e2>
 8020c3c:	3408      	adds	r4, #8
 8020c3e:	e0f8      	b.n	8020e32 <_svfiprintf_r+0x5d6>
 8020c40:	4a61      	ldr	r2, [pc, #388]	; (8020dc8 <_svfiprintf_r+0x56c>)
 8020c42:	920a      	str	r2, [sp, #40]	; 0x28
 8020c44:	9a00      	ldr	r2, [sp, #0]
 8020c46:	9505      	str	r5, [sp, #20]
 8020c48:	0697      	lsls	r7, r2, #26
 8020c4a:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8020c4e:	d548      	bpl.n	8020ce2 <_svfiprintf_r+0x486>
 8020c50:	9a06      	ldr	r2, [sp, #24]
 8020c52:	3207      	adds	r2, #7
 8020c54:	f022 0207 	bic.w	r2, r2, #7
 8020c58:	e9d2 6700 	ldrd	r6, r7, [r2]
 8020c5c:	f102 0108 	add.w	r1, r2, #8
 8020c60:	9106      	str	r1, [sp, #24]
 8020c62:	9a00      	ldr	r2, [sp, #0]
 8020c64:	07d5      	lsls	r5, r2, #31
 8020c66:	f140 80e0 	bpl.w	8020e2a <_svfiprintf_r+0x5ce>
 8020c6a:	ea56 0207 	orrs.w	r2, r6, r7
 8020c6e:	f000 80dc 	beq.w	8020e2a <_svfiprintf_r+0x5ce>
 8020c72:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
 8020c76:	9b00      	ldr	r3, [sp, #0]
 8020c78:	2230      	movs	r2, #48	; 0x30
 8020c7a:	f043 0302 	orr.w	r3, r3, #2
 8020c7e:	9300      	str	r3, [sp, #0]
 8020c80:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
 8020c84:	2302      	movs	r3, #2
 8020c86:	e6a4      	b.n	80209d2 <_svfiprintf_r+0x176>
 8020c88:	9b00      	ldr	r3, [sp, #0]
 8020c8a:	9505      	str	r5, [sp, #20]
 8020c8c:	f043 0310 	orr.w	r3, r3, #16
 8020c90:	9300      	str	r3, [sp, #0]
 8020c92:	9b00      	ldr	r3, [sp, #0]
 8020c94:	069a      	lsls	r2, r3, #26
 8020c96:	f53f ae92 	bmi.w	80209be <_svfiprintf_r+0x162>
 8020c9a:	9b00      	ldr	r3, [sp, #0]
 8020c9c:	06db      	lsls	r3, r3, #27
 8020c9e:	f140 82a5 	bpl.w	80211ec <_svfiprintf_r+0x990>
 8020ca2:	9a06      	ldr	r2, [sp, #24]
 8020ca4:	4613      	mov	r3, r2
 8020ca6:	3204      	adds	r2, #4
 8020ca8:	681e      	ldr	r6, [r3, #0]
 8020caa:	9206      	str	r2, [sp, #24]
 8020cac:	2301      	movs	r3, #1
 8020cae:	2700      	movs	r7, #0
 8020cb0:	e68f      	b.n	80209d2 <_svfiprintf_r+0x176>
 8020cb2:	9b00      	ldr	r3, [sp, #0]
 8020cb4:	f043 0301 	orr.w	r3, r3, #1
 8020cb8:	9300      	str	r3, [sp, #0]
 8020cba:	f899 3000 	ldrb.w	r3, [r9]
 8020cbe:	4648      	mov	r0, r9
 8020cc0:	e616      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020cc2:	f899 3000 	ldrb.w	r3, [r9]
 8020cc6:	4648      	mov	r0, r9
 8020cc8:	2900      	cmp	r1, #0
 8020cca:	f47f ae11 	bne.w	80208f0 <_svfiprintf_r+0x94>
 8020cce:	2120      	movs	r1, #32
 8020cd0:	e60e      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020cd2:	4a3c      	ldr	r2, [pc, #240]	; (8020dc4 <_svfiprintf_r+0x568>)
 8020cd4:	920a      	str	r2, [sp, #40]	; 0x28
 8020cd6:	9a00      	ldr	r2, [sp, #0]
 8020cd8:	9505      	str	r5, [sp, #20]
 8020cda:	0697      	lsls	r7, r2, #26
 8020cdc:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8020ce0:	d4b6      	bmi.n	8020c50 <_svfiprintf_r+0x3f4>
 8020ce2:	9a00      	ldr	r2, [sp, #0]
 8020ce4:	06d6      	lsls	r6, r2, #27
 8020ce6:	f100 827a 	bmi.w	80211de <_svfiprintf_r+0x982>
 8020cea:	9a00      	ldr	r2, [sp, #0]
 8020cec:	9906      	ldr	r1, [sp, #24]
 8020cee:	f012 0f40 	tst.w	r2, #64	; 0x40
 8020cf2:	460a      	mov	r2, r1
 8020cf4:	f000 82b5 	beq.w	8021262 <_svfiprintf_r+0xa06>
 8020cf8:	3204      	adds	r2, #4
 8020cfa:	880e      	ldrh	r6, [r1, #0]
 8020cfc:	9206      	str	r2, [sp, #24]
 8020cfe:	2700      	movs	r7, #0
 8020d00:	e7af      	b.n	8020c62 <_svfiprintf_r+0x406>
 8020d02:	9b00      	ldr	r3, [sp, #0]
 8020d04:	9505      	str	r5, [sp, #20]
 8020d06:	f043 0310 	orr.w	r3, r3, #16
 8020d0a:	9300      	str	r3, [sp, #0]
 8020d0c:	9b00      	ldr	r3, [sp, #0]
 8020d0e:	f013 0320 	ands.w	r3, r3, #32
 8020d12:	f47f aea2 	bne.w	8020a5a <_svfiprintf_r+0x1fe>
 8020d16:	9a00      	ldr	r2, [sp, #0]
 8020d18:	f012 0210 	ands.w	r2, r2, #16
 8020d1c:	f040 8240 	bne.w	80211a0 <_svfiprintf_r+0x944>
 8020d20:	9b00      	ldr	r3, [sp, #0]
 8020d22:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 8020d26:	f000 823b 	beq.w	80211a0 <_svfiprintf_r+0x944>
 8020d2a:	9906      	ldr	r1, [sp, #24]
 8020d2c:	4613      	mov	r3, r2
 8020d2e:	460a      	mov	r2, r1
 8020d30:	3204      	adds	r2, #4
 8020d32:	880e      	ldrh	r6, [r1, #0]
 8020d34:	9206      	str	r2, [sp, #24]
 8020d36:	2700      	movs	r7, #0
 8020d38:	e64b      	b.n	80209d2 <_svfiprintf_r+0x176>
 8020d3a:	9b00      	ldr	r3, [sp, #0]
 8020d3c:	9505      	str	r5, [sp, #20]
 8020d3e:	f043 0310 	orr.w	r3, r3, #16
 8020d42:	9300      	str	r3, [sp, #0]
 8020d44:	9b00      	ldr	r3, [sp, #0]
 8020d46:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8020d4a:	069b      	lsls	r3, r3, #26
 8020d4c:	f53f af07 	bmi.w	8020b5e <_svfiprintf_r+0x302>
 8020d50:	9b00      	ldr	r3, [sp, #0]
 8020d52:	06df      	lsls	r7, r3, #27
 8020d54:	f100 822b 	bmi.w	80211ae <_svfiprintf_r+0x952>
 8020d58:	9b00      	ldr	r3, [sp, #0]
 8020d5a:	065e      	lsls	r6, r3, #25
 8020d5c:	f140 8227 	bpl.w	80211ae <_svfiprintf_r+0x952>
 8020d60:	9906      	ldr	r1, [sp, #24]
 8020d62:	f9b1 6000 	ldrsh.w	r6, [r1]
 8020d66:	3104      	adds	r1, #4
 8020d68:	17f7      	asrs	r7, r6, #31
 8020d6a:	4632      	mov	r2, r6
 8020d6c:	463b      	mov	r3, r7
 8020d6e:	9106      	str	r1, [sp, #24]
 8020d70:	e6ff      	b.n	8020b72 <_svfiprintf_r+0x316>
 8020d72:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8020d76:	2500      	movs	r5, #0
 8020d78:	f819 3b01 	ldrb.w	r3, [r9], #1
 8020d7c:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8020d80:	eb02 0545 	add.w	r5, r2, r5, lsl #1
 8020d84:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8020d88:	2a09      	cmp	r2, #9
 8020d8a:	d9f5      	bls.n	8020d78 <_svfiprintf_r+0x51c>
 8020d8c:	e5b2      	b.n	80208f4 <_svfiprintf_r+0x98>
 8020d8e:	9b00      	ldr	r3, [sp, #0]
 8020d90:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8020d94:	9300      	str	r3, [sp, #0]
 8020d96:	f899 3000 	ldrb.w	r3, [r9]
 8020d9a:	4648      	mov	r0, r9
 8020d9c:	e5a8      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020d9e:	f899 3000 	ldrb.w	r3, [r9]
 8020da2:	4648      	mov	r0, r9
 8020da4:	212b      	movs	r1, #43	; 0x2b
 8020da6:	e5a3      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020da8:	9a06      	ldr	r2, [sp, #24]
 8020daa:	6815      	ldr	r5, [r2, #0]
 8020dac:	4613      	mov	r3, r2
 8020dae:	2d00      	cmp	r5, #0
 8020db0:	f103 0304 	add.w	r3, r3, #4
 8020db4:	f2c0 823d 	blt.w	8021232 <_svfiprintf_r+0x9d6>
 8020db8:	9306      	str	r3, [sp, #24]
 8020dba:	f899 3000 	ldrb.w	r3, [r9]
 8020dbe:	4648      	mov	r0, r9
 8020dc0:	e596      	b.n	80208f0 <_svfiprintf_r+0x94>
 8020dc2:	bf00      	nop
 8020dc4:	08025d68 	.word	0x08025d68
 8020dc8:	08025d54 	.word	0x08025d54
 8020dcc:	08025d44 	.word	0x08025d44
 8020dd0:	f899 3000 	ldrb.w	r3, [r9]
 8020dd4:	2b2a      	cmp	r3, #42	; 0x2a
 8020dd6:	f109 0001 	add.w	r0, r9, #1
 8020dda:	f000 8272 	beq.w	80212c2 <_svfiprintf_r+0xa66>
 8020dde:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8020de2:	2a09      	cmp	r2, #9
 8020de4:	4681      	mov	r9, r0
 8020de6:	bf98      	it	ls
 8020de8:	2000      	movls	r0, #0
 8020dea:	f200 8261 	bhi.w	80212b0 <_svfiprintf_r+0xa54>
 8020dee:	f819 3b01 	ldrb.w	r3, [r9], #1
 8020df2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8020df6:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8020dfa:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8020dfe:	2a09      	cmp	r2, #9
 8020e00:	d9f5      	bls.n	8020dee <_svfiprintf_r+0x592>
 8020e02:	ea40 72e0 	orr.w	r2, r0, r0, asr #31
 8020e06:	9201      	str	r2, [sp, #4]
 8020e08:	e574      	b.n	80208f4 <_svfiprintf_r+0x98>
 8020e0a:	9505      	str	r5, [sp, #20]
 8020e0c:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8020e10:	2b00      	cmp	r3, #0
 8020e12:	f000 80e7 	beq.w	8020fe4 <_svfiprintf_r+0x788>
 8020e16:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 8020e1a:	2300      	movs	r3, #0
 8020e1c:	2601      	movs	r6, #1
 8020e1e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8020e22:	ab12      	add	r3, sp, #72	; 0x48
 8020e24:	9602      	str	r6, [sp, #8]
 8020e26:	9309      	str	r3, [sp, #36]	; 0x24
 8020e28:	e6bd      	b.n	8020ba6 <_svfiprintf_r+0x34a>
 8020e2a:	2302      	movs	r3, #2
 8020e2c:	e5d1      	b.n	80209d2 <_svfiprintf_r+0x176>
 8020e2e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8020e30:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020e32:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8020e36:	b163      	cbz	r3, 8020e52 <_svfiprintf_r+0x5f6>
 8020e38:	3201      	adds	r2, #1
 8020e3a:	3101      	adds	r1, #1
 8020e3c:	f10d 0037 	add.w	r0, sp, #55	; 0x37
 8020e40:	2301      	movs	r3, #1
 8020e42:	2a07      	cmp	r2, #7
 8020e44:	9111      	str	r1, [sp, #68]	; 0x44
 8020e46:	9210      	str	r2, [sp, #64]	; 0x40
 8020e48:	e884 0009 	stmia.w	r4, {r0, r3}
 8020e4c:	f300 815f 	bgt.w	802110e <_svfiprintf_r+0x8b2>
 8020e50:	3408      	adds	r4, #8
 8020e52:	9b07      	ldr	r3, [sp, #28]
 8020e54:	b15b      	cbz	r3, 8020e6e <_svfiprintf_r+0x612>
 8020e56:	3201      	adds	r2, #1
 8020e58:	3102      	adds	r1, #2
 8020e5a:	a80e      	add	r0, sp, #56	; 0x38
 8020e5c:	2302      	movs	r3, #2
 8020e5e:	2a07      	cmp	r2, #7
 8020e60:	9111      	str	r1, [sp, #68]	; 0x44
 8020e62:	9210      	str	r2, [sp, #64]	; 0x40
 8020e64:	e884 0009 	stmia.w	r4, {r0, r3}
 8020e68:	f300 815d 	bgt.w	8021126 <_svfiprintf_r+0x8ca>
 8020e6c:	3408      	adds	r4, #8
 8020e6e:	9b08      	ldr	r3, [sp, #32]
 8020e70:	2b80      	cmp	r3, #128	; 0x80
 8020e72:	f000 80ca 	beq.w	802100a <_svfiprintf_r+0x7ae>
 8020e76:	9b01      	ldr	r3, [sp, #4]
 8020e78:	9802      	ldr	r0, [sp, #8]
 8020e7a:	1a1d      	subs	r5, r3, r0
 8020e7c:	2d00      	cmp	r5, #0
 8020e7e:	dd31      	ble.n	8020ee4 <_svfiprintf_r+0x688>
 8020e80:	2d10      	cmp	r5, #16
 8020e82:	4fb5      	ldr	r7, [pc, #724]	; (8021158 <_svfiprintf_r+0x8fc>)
 8020e84:	dd24      	ble.n	8020ed0 <_svfiprintf_r+0x674>
 8020e86:	9601      	str	r6, [sp, #4]
 8020e88:	f04f 0b10 	mov.w	fp, #16
 8020e8c:	463e      	mov	r6, r7
 8020e8e:	462f      	mov	r7, r5
 8020e90:	9d04      	ldr	r5, [sp, #16]
 8020e92:	e004      	b.n	8020e9e <_svfiprintf_r+0x642>
 8020e94:	3f10      	subs	r7, #16
 8020e96:	2f10      	cmp	r7, #16
 8020e98:	f104 0408 	add.w	r4, r4, #8
 8020e9c:	dd15      	ble.n	8020eca <_svfiprintf_r+0x66e>
 8020e9e:	3201      	adds	r2, #1
 8020ea0:	3110      	adds	r1, #16
 8020ea2:	2a07      	cmp	r2, #7
 8020ea4:	9111      	str	r1, [sp, #68]	; 0x44
 8020ea6:	9210      	str	r2, [sp, #64]	; 0x40
 8020ea8:	e884 0840 	stmia.w	r4, {r6, fp}
 8020eac:	ddf2      	ble.n	8020e94 <_svfiprintf_r+0x638>
 8020eae:	4628      	mov	r0, r5
 8020eb0:	4651      	mov	r1, sl
 8020eb2:	aa0f      	add	r2, sp, #60	; 0x3c
 8020eb4:	f7ff fc50 	bl	8020758 <__ssprint_r>
 8020eb8:	2800      	cmp	r0, #0
 8020eba:	f040 809a 	bne.w	8020ff2 <_svfiprintf_r+0x796>
 8020ebe:	3f10      	subs	r7, #16
 8020ec0:	2f10      	cmp	r7, #16
 8020ec2:	9911      	ldr	r1, [sp, #68]	; 0x44
 8020ec4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020ec6:	4644      	mov	r4, r8
 8020ec8:	dce9      	bgt.n	8020e9e <_svfiprintf_r+0x642>
 8020eca:	463d      	mov	r5, r7
 8020ecc:	4637      	mov	r7, r6
 8020ece:	9e01      	ldr	r6, [sp, #4]
 8020ed0:	6027      	str	r7, [r4, #0]
 8020ed2:	3201      	adds	r2, #1
 8020ed4:	4429      	add	r1, r5
 8020ed6:	2a07      	cmp	r2, #7
 8020ed8:	9111      	str	r1, [sp, #68]	; 0x44
 8020eda:	9210      	str	r2, [sp, #64]	; 0x40
 8020edc:	6065      	str	r5, [r4, #4]
 8020ede:	f300 80fa 	bgt.w	80210d6 <_svfiprintf_r+0x87a>
 8020ee2:	3408      	adds	r4, #8
 8020ee4:	9802      	ldr	r0, [sp, #8]
 8020ee6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020ee8:	6023      	str	r3, [r4, #0]
 8020eea:	3201      	adds	r2, #1
 8020eec:	4401      	add	r1, r0
 8020eee:	2a07      	cmp	r2, #7
 8020ef0:	9111      	str	r1, [sp, #68]	; 0x44
 8020ef2:	9210      	str	r2, [sp, #64]	; 0x40
 8020ef4:	6060      	str	r0, [r4, #4]
 8020ef6:	f300 80bf 	bgt.w	8021078 <_svfiprintf_r+0x81c>
 8020efa:	3408      	adds	r4, #8
 8020efc:	9b00      	ldr	r3, [sp, #0]
 8020efe:	075b      	lsls	r3, r3, #29
 8020f00:	d539      	bpl.n	8020f76 <_svfiprintf_r+0x71a>
 8020f02:	9b05      	ldr	r3, [sp, #20]
 8020f04:	1b9d      	subs	r5, r3, r6
 8020f06:	2d00      	cmp	r5, #0
 8020f08:	dd35      	ble.n	8020f76 <_svfiprintf_r+0x71a>
 8020f0a:	2d10      	cmp	r5, #16
 8020f0c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020f0e:	f8df b24c 	ldr.w	fp, [pc, #588]	; 802115c <_svfiprintf_r+0x900>
 8020f12:	dd26      	ble.n	8020f62 <_svfiprintf_r+0x706>
 8020f14:	9600      	str	r6, [sp, #0]
 8020f16:	2710      	movs	r7, #16
 8020f18:	465e      	mov	r6, fp
 8020f1a:	46ab      	mov	fp, r5
 8020f1c:	9d04      	ldr	r5, [sp, #16]
 8020f1e:	e006      	b.n	8020f2e <_svfiprintf_r+0x6d2>
 8020f20:	f1ab 0b10 	sub.w	fp, fp, #16
 8020f24:	f1bb 0f10 	cmp.w	fp, #16
 8020f28:	f104 0408 	add.w	r4, r4, #8
 8020f2c:	dd16      	ble.n	8020f5c <_svfiprintf_r+0x700>
 8020f2e:	3201      	adds	r2, #1
 8020f30:	3110      	adds	r1, #16
 8020f32:	2a07      	cmp	r2, #7
 8020f34:	9111      	str	r1, [sp, #68]	; 0x44
 8020f36:	9210      	str	r2, [sp, #64]	; 0x40
 8020f38:	e884 00c0 	stmia.w	r4, {r6, r7}
 8020f3c:	ddf0      	ble.n	8020f20 <_svfiprintf_r+0x6c4>
 8020f3e:	4628      	mov	r0, r5
 8020f40:	4651      	mov	r1, sl
 8020f42:	aa0f      	add	r2, sp, #60	; 0x3c
 8020f44:	f7ff fc08 	bl	8020758 <__ssprint_r>
 8020f48:	2800      	cmp	r0, #0
 8020f4a:	d152      	bne.n	8020ff2 <_svfiprintf_r+0x796>
 8020f4c:	f1ab 0b10 	sub.w	fp, fp, #16
 8020f50:	f1bb 0f10 	cmp.w	fp, #16
 8020f54:	9911      	ldr	r1, [sp, #68]	; 0x44
 8020f56:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020f58:	4644      	mov	r4, r8
 8020f5a:	dce8      	bgt.n	8020f2e <_svfiprintf_r+0x6d2>
 8020f5c:	465d      	mov	r5, fp
 8020f5e:	46b3      	mov	fp, r6
 8020f60:	9e00      	ldr	r6, [sp, #0]
 8020f62:	f8c4 b000 	str.w	fp, [r4]
 8020f66:	3201      	adds	r2, #1
 8020f68:	4429      	add	r1, r5
 8020f6a:	2a07      	cmp	r2, #7
 8020f6c:	9111      	str	r1, [sp, #68]	; 0x44
 8020f6e:	9210      	str	r2, [sp, #64]	; 0x40
 8020f70:	6065      	str	r5, [r4, #4]
 8020f72:	f300 8102 	bgt.w	802117a <_svfiprintf_r+0x91e>
 8020f76:	9b03      	ldr	r3, [sp, #12]
 8020f78:	9a05      	ldr	r2, [sp, #20]
 8020f7a:	4296      	cmp	r6, r2
 8020f7c:	bfac      	ite	ge
 8020f7e:	199b      	addge	r3, r3, r6
 8020f80:	189b      	addlt	r3, r3, r2
 8020f82:	9303      	str	r3, [sp, #12]
 8020f84:	2900      	cmp	r1, #0
 8020f86:	f040 8081 	bne.w	802108c <_svfiprintf_r+0x830>
 8020f8a:	2300      	movs	r3, #0
 8020f8c:	9310      	str	r3, [sp, #64]	; 0x40
 8020f8e:	f899 3000 	ldrb.w	r3, [r9]
 8020f92:	4644      	mov	r4, r8
 8020f94:	2b00      	cmp	r3, #0
 8020f96:	f47f ac7e 	bne.w	8020896 <_svfiprintf_r+0x3a>
 8020f9a:	464d      	mov	r5, r9
 8020f9c:	e49a      	b.n	80208d4 <_svfiprintf_r+0x78>
 8020f9e:	2b01      	cmp	r3, #1
 8020fa0:	f47f ad30 	bne.w	8020a04 <_svfiprintf_r+0x1a8>
 8020fa4:	2f00      	cmp	r7, #0
 8020fa6:	bf08      	it	eq
 8020fa8:	2e0a      	cmpeq	r6, #10
 8020faa:	f0c0 80dd 	bcc.w	8021168 <_svfiprintf_r+0x90c>
 8020fae:	4645      	mov	r5, r8
 8020fb0:	4630      	mov	r0, r6
 8020fb2:	4639      	mov	r1, r7
 8020fb4:	220a      	movs	r2, #10
 8020fb6:	2300      	movs	r3, #0
 8020fb8:	f7e0 f814 	bl	8000fe4 <__aeabi_uldivmod>
 8020fbc:	3230      	adds	r2, #48	; 0x30
 8020fbe:	4630      	mov	r0, r6
 8020fc0:	4639      	mov	r1, r7
 8020fc2:	f805 2d01 	strb.w	r2, [r5, #-1]!
 8020fc6:	2300      	movs	r3, #0
 8020fc8:	220a      	movs	r2, #10
 8020fca:	f7e0 f80b 	bl	8000fe4 <__aeabi_uldivmod>
 8020fce:	4606      	mov	r6, r0
 8020fd0:	460f      	mov	r7, r1
 8020fd2:	ea56 0307 	orrs.w	r3, r6, r7
 8020fd6:	d1eb      	bne.n	8020fb0 <_svfiprintf_r+0x754>
 8020fd8:	462b      	mov	r3, r5
 8020fda:	9509      	str	r5, [sp, #36]	; 0x24
 8020fdc:	ebc3 0308 	rsb	r3, r3, r8
 8020fe0:	9302      	str	r3, [sp, #8]
 8020fe2:	e062      	b.n	80210aa <_svfiprintf_r+0x84e>
 8020fe4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8020fe6:	b123      	cbz	r3, 8020ff2 <_svfiprintf_r+0x796>
 8020fe8:	9804      	ldr	r0, [sp, #16]
 8020fea:	4651      	mov	r1, sl
 8020fec:	aa0f      	add	r2, sp, #60	; 0x3c
 8020fee:	f7ff fbb3 	bl	8020758 <__ssprint_r>
 8020ff2:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 8020ff6:	f013 0f40 	tst.w	r3, #64	; 0x40
 8020ffa:	9b03      	ldr	r3, [sp, #12]
 8020ffc:	bf18      	it	ne
 8020ffe:	f04f 33ff 	movne.w	r3, #4294967295
 8021002:	4618      	mov	r0, r3
 8021004:	b02d      	add	sp, #180	; 0xb4
 8021006:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802100a:	9b05      	ldr	r3, [sp, #20]
 802100c:	1b9d      	subs	r5, r3, r6
 802100e:	2d00      	cmp	r5, #0
 8021010:	f77f af31 	ble.w	8020e76 <_svfiprintf_r+0x61a>
 8021014:	2d10      	cmp	r5, #16
 8021016:	4f50      	ldr	r7, [pc, #320]	; (8021158 <_svfiprintf_r+0x8fc>)
 8021018:	dd23      	ble.n	8021062 <_svfiprintf_r+0x806>
 802101a:	9607      	str	r6, [sp, #28]
 802101c:	f04f 0b10 	mov.w	fp, #16
 8021020:	463e      	mov	r6, r7
 8021022:	462f      	mov	r7, r5
 8021024:	9d04      	ldr	r5, [sp, #16]
 8021026:	e004      	b.n	8021032 <_svfiprintf_r+0x7d6>
 8021028:	3f10      	subs	r7, #16
 802102a:	2f10      	cmp	r7, #16
 802102c:	f104 0408 	add.w	r4, r4, #8
 8021030:	dd14      	ble.n	802105c <_svfiprintf_r+0x800>
 8021032:	3201      	adds	r2, #1
 8021034:	3110      	adds	r1, #16
 8021036:	2a07      	cmp	r2, #7
 8021038:	9111      	str	r1, [sp, #68]	; 0x44
 802103a:	9210      	str	r2, [sp, #64]	; 0x40
 802103c:	e884 0840 	stmia.w	r4, {r6, fp}
 8021040:	ddf2      	ble.n	8021028 <_svfiprintf_r+0x7cc>
 8021042:	4628      	mov	r0, r5
 8021044:	4651      	mov	r1, sl
 8021046:	aa0f      	add	r2, sp, #60	; 0x3c
 8021048:	f7ff fb86 	bl	8020758 <__ssprint_r>
 802104c:	2800      	cmp	r0, #0
 802104e:	d1d0      	bne.n	8020ff2 <_svfiprintf_r+0x796>
 8021050:	3f10      	subs	r7, #16
 8021052:	2f10      	cmp	r7, #16
 8021054:	9911      	ldr	r1, [sp, #68]	; 0x44
 8021056:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8021058:	4644      	mov	r4, r8
 802105a:	dcea      	bgt.n	8021032 <_svfiprintf_r+0x7d6>
 802105c:	463d      	mov	r5, r7
 802105e:	4637      	mov	r7, r6
 8021060:	9e07      	ldr	r6, [sp, #28]
 8021062:	6027      	str	r7, [r4, #0]
 8021064:	3201      	adds	r2, #1
 8021066:	4429      	add	r1, r5
 8021068:	2a07      	cmp	r2, #7
 802106a:	9111      	str	r1, [sp, #68]	; 0x44
 802106c:	9210      	str	r2, [sp, #64]	; 0x40
 802106e:	6065      	str	r5, [r4, #4]
 8021070:	f300 80eb 	bgt.w	802124a <_svfiprintf_r+0x9ee>
 8021074:	3408      	adds	r4, #8
 8021076:	e6fe      	b.n	8020e76 <_svfiprintf_r+0x61a>
 8021078:	9804      	ldr	r0, [sp, #16]
 802107a:	4651      	mov	r1, sl
 802107c:	aa0f      	add	r2, sp, #60	; 0x3c
 802107e:	f7ff fb6b 	bl	8020758 <__ssprint_r>
 8021082:	2800      	cmp	r0, #0
 8021084:	d1b5      	bne.n	8020ff2 <_svfiprintf_r+0x796>
 8021086:	9911      	ldr	r1, [sp, #68]	; 0x44
 8021088:	4644      	mov	r4, r8
 802108a:	e737      	b.n	8020efc <_svfiprintf_r+0x6a0>
 802108c:	9804      	ldr	r0, [sp, #16]
 802108e:	4651      	mov	r1, sl
 8021090:	aa0f      	add	r2, sp, #60	; 0x3c
 8021092:	f7ff fb61 	bl	8020758 <__ssprint_r>
 8021096:	2800      	cmp	r0, #0
 8021098:	f43f af77 	beq.w	8020f8a <_svfiprintf_r+0x72e>
 802109c:	e7a9      	b.n	8020ff2 <_svfiprintf_r+0x796>
 802109e:	b913      	cbnz	r3, 80210a6 <_svfiprintf_r+0x84a>
 80210a0:	9b00      	ldr	r3, [sp, #0]
 80210a2:	07da      	lsls	r2, r3, #31
 80210a4:	d473      	bmi.n	802118e <_svfiprintf_r+0x932>
 80210a6:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 80210aa:	9b02      	ldr	r3, [sp, #8]
 80210ac:	9a01      	ldr	r2, [sp, #4]
 80210ae:	4293      	cmp	r3, r2
 80210b0:	bfb8      	it	lt
 80210b2:	4613      	movlt	r3, r2
 80210b4:	461e      	mov	r6, r3
 80210b6:	f1bb 0f00 	cmp.w	fp, #0
 80210ba:	f43f ad76 	beq.w	8020baa <_svfiprintf_r+0x34e>
 80210be:	3601      	adds	r6, #1
 80210c0:	e573      	b.n	8020baa <_svfiprintf_r+0x34e>
 80210c2:	9804      	ldr	r0, [sp, #16]
 80210c4:	4651      	mov	r1, sl
 80210c6:	aa0f      	add	r2, sp, #60	; 0x3c
 80210c8:	f7ff fb46 	bl	8020758 <__ssprint_r>
 80210cc:	2800      	cmp	r0, #0
 80210ce:	d190      	bne.n	8020ff2 <_svfiprintf_r+0x796>
 80210d0:	4644      	mov	r4, r8
 80210d2:	f7ff bbfc 	b.w	80208ce <_svfiprintf_r+0x72>
 80210d6:	9804      	ldr	r0, [sp, #16]
 80210d8:	4651      	mov	r1, sl
 80210da:	aa0f      	add	r2, sp, #60	; 0x3c
 80210dc:	f7ff fb3c 	bl	8020758 <__ssprint_r>
 80210e0:	2800      	cmp	r0, #0
 80210e2:	d186      	bne.n	8020ff2 <_svfiprintf_r+0x796>
 80210e4:	9911      	ldr	r1, [sp, #68]	; 0x44
 80210e6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80210e8:	4644      	mov	r4, r8
 80210ea:	e6fb      	b.n	8020ee4 <_svfiprintf_r+0x688>
 80210ec:	980a      	ldr	r0, [sp, #40]	; 0x28
 80210ee:	4645      	mov	r5, r8
 80210f0:	0933      	lsrs	r3, r6, #4
 80210f2:	f006 010f 	and.w	r1, r6, #15
 80210f6:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 80210fa:	093a      	lsrs	r2, r7, #4
 80210fc:	461e      	mov	r6, r3
 80210fe:	4617      	mov	r7, r2
 8021100:	5c43      	ldrb	r3, [r0, r1]
 8021102:	f805 3d01 	strb.w	r3, [r5, #-1]!
 8021106:	ea56 0307 	orrs.w	r3, r6, r7
 802110a:	d1f1      	bne.n	80210f0 <_svfiprintf_r+0x894>
 802110c:	e764      	b.n	8020fd8 <_svfiprintf_r+0x77c>
 802110e:	9804      	ldr	r0, [sp, #16]
 8021110:	4651      	mov	r1, sl
 8021112:	aa0f      	add	r2, sp, #60	; 0x3c
 8021114:	f7ff fb20 	bl	8020758 <__ssprint_r>
 8021118:	2800      	cmp	r0, #0
 802111a:	f47f af6a 	bne.w	8020ff2 <_svfiprintf_r+0x796>
 802111e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8021120:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8021122:	4644      	mov	r4, r8
 8021124:	e695      	b.n	8020e52 <_svfiprintf_r+0x5f6>
 8021126:	9804      	ldr	r0, [sp, #16]
 8021128:	4651      	mov	r1, sl
 802112a:	aa0f      	add	r2, sp, #60	; 0x3c
 802112c:	f7ff fb14 	bl	8020758 <__ssprint_r>
 8021130:	2800      	cmp	r0, #0
 8021132:	f47f af5e 	bne.w	8020ff2 <_svfiprintf_r+0x796>
 8021136:	9911      	ldr	r1, [sp, #68]	; 0x44
 8021138:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802113a:	4644      	mov	r4, r8
 802113c:	e697      	b.n	8020e6e <_svfiprintf_r+0x612>
 802113e:	9804      	ldr	r0, [sp, #16]
 8021140:	4651      	mov	r1, sl
 8021142:	aa0f      	add	r2, sp, #60	; 0x3c
 8021144:	f7ff fb08 	bl	8020758 <__ssprint_r>
 8021148:	2800      	cmp	r0, #0
 802114a:	f47f af52 	bne.w	8020ff2 <_svfiprintf_r+0x796>
 802114e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8021150:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8021152:	4644      	mov	r4, r8
 8021154:	e66d      	b.n	8020e32 <_svfiprintf_r+0x5d6>
 8021156:	bf00      	nop
 8021158:	08025d84 	.word	0x08025d84
 802115c:	08025d44 	.word	0x08025d44
 8021160:	ebc1 0308 	rsb	r3, r1, r8
 8021164:	9302      	str	r3, [sp, #8]
 8021166:	e7a0      	b.n	80210aa <_svfiprintf_r+0x84e>
 8021168:	ad2c      	add	r5, sp, #176	; 0xb0
 802116a:	3630      	adds	r6, #48	; 0x30
 802116c:	f805 6d41 	strb.w	r6, [r5, #-65]!
 8021170:	ebc5 0308 	rsb	r3, r5, r8
 8021174:	9302      	str	r3, [sp, #8]
 8021176:	9509      	str	r5, [sp, #36]	; 0x24
 8021178:	e797      	b.n	80210aa <_svfiprintf_r+0x84e>
 802117a:	9804      	ldr	r0, [sp, #16]
 802117c:	4651      	mov	r1, sl
 802117e:	aa0f      	add	r2, sp, #60	; 0x3c
 8021180:	f7ff faea 	bl	8020758 <__ssprint_r>
 8021184:	2800      	cmp	r0, #0
 8021186:	f47f af34 	bne.w	8020ff2 <_svfiprintf_r+0x796>
 802118a:	9911      	ldr	r1, [sp, #68]	; 0x44
 802118c:	e6f3      	b.n	8020f76 <_svfiprintf_r+0x71a>
 802118e:	ad2c      	add	r5, sp, #176	; 0xb0
 8021190:	2330      	movs	r3, #48	; 0x30
 8021192:	f805 3d41 	strb.w	r3, [r5, #-65]!
 8021196:	ebc5 0308 	rsb	r3, r5, r8
 802119a:	9302      	str	r3, [sp, #8]
 802119c:	9509      	str	r5, [sp, #36]	; 0x24
 802119e:	e784      	b.n	80210aa <_svfiprintf_r+0x84e>
 80211a0:	9906      	ldr	r1, [sp, #24]
 80211a2:	460a      	mov	r2, r1
 80211a4:	3204      	adds	r2, #4
 80211a6:	680e      	ldr	r6, [r1, #0]
 80211a8:	9206      	str	r2, [sp, #24]
 80211aa:	2700      	movs	r7, #0
 80211ac:	e411      	b.n	80209d2 <_svfiprintf_r+0x176>
 80211ae:	9a06      	ldr	r2, [sp, #24]
 80211b0:	6816      	ldr	r6, [r2, #0]
 80211b2:	4613      	mov	r3, r2
 80211b4:	3304      	adds	r3, #4
 80211b6:	17f7      	asrs	r7, r6, #31
 80211b8:	4632      	mov	r2, r6
 80211ba:	9306      	str	r3, [sp, #24]
 80211bc:	2a00      	cmp	r2, #0
 80211be:	463b      	mov	r3, r7
 80211c0:	f173 0300 	sbcs.w	r3, r3, #0
 80211c4:	f6bf acda 	bge.w	8020b7c <_svfiprintf_r+0x320>
 80211c8:	9b01      	ldr	r3, [sp, #4]
 80211ca:	9302      	str	r3, [sp, #8]
 80211cc:	f04f 0b2d 	mov.w	fp, #45	; 0x2d
 80211d0:	4276      	negs	r6, r6
 80211d2:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 80211d6:	f88d b037 	strb.w	fp, [sp, #55]	; 0x37
 80211da:	2301      	movs	r3, #1
 80211dc:	e400      	b.n	80209e0 <_svfiprintf_r+0x184>
 80211de:	9906      	ldr	r1, [sp, #24]
 80211e0:	460a      	mov	r2, r1
 80211e2:	3204      	adds	r2, #4
 80211e4:	680e      	ldr	r6, [r1, #0]
 80211e6:	9206      	str	r2, [sp, #24]
 80211e8:	2700      	movs	r7, #0
 80211ea:	e53a      	b.n	8020c62 <_svfiprintf_r+0x406>
 80211ec:	9b00      	ldr	r3, [sp, #0]
 80211ee:	9a06      	ldr	r2, [sp, #24]
 80211f0:	f013 0f40 	tst.w	r3, #64	; 0x40
 80211f4:	4613      	mov	r3, r2
 80211f6:	f43f ad56 	beq.w	8020ca6 <_svfiprintf_r+0x44a>
 80211fa:	8816      	ldrh	r6, [r2, #0]
 80211fc:	3204      	adds	r2, #4
 80211fe:	2700      	movs	r7, #0
 8021200:	2301      	movs	r3, #1
 8021202:	9206      	str	r2, [sp, #24]
 8021204:	f7ff bbe5 	b.w	80209d2 <_svfiprintf_r+0x176>
 8021208:	9a06      	ldr	r2, [sp, #24]
 802120a:	9903      	ldr	r1, [sp, #12]
 802120c:	6813      	ldr	r3, [r2, #0]
 802120e:	17cf      	asrs	r7, r1, #31
 8021210:	4608      	mov	r0, r1
 8021212:	3204      	adds	r2, #4
 8021214:	4639      	mov	r1, r7
 8021216:	9206      	str	r2, [sp, #24]
 8021218:	e9c3 0100 	strd	r0, r1, [r3]
 802121c:	f7ff bb36 	b.w	802088c <_svfiprintf_r+0x30>
 8021220:	9b00      	ldr	r3, [sp, #0]
 8021222:	f043 0320 	orr.w	r3, r3, #32
 8021226:	9300      	str	r3, [sp, #0]
 8021228:	3001      	adds	r0, #1
 802122a:	f899 3001 	ldrb.w	r3, [r9, #1]
 802122e:	f7ff bb5f 	b.w	80208f0 <_svfiprintf_r+0x94>
 8021232:	426d      	negs	r5, r5
 8021234:	9306      	str	r3, [sp, #24]
 8021236:	4648      	mov	r0, r9
 8021238:	e41b      	b.n	8020a72 <_svfiprintf_r+0x216>
 802123a:	9a06      	ldr	r2, [sp, #24]
 802123c:	6813      	ldr	r3, [r2, #0]
 802123e:	3204      	adds	r2, #4
 8021240:	9206      	str	r2, [sp, #24]
 8021242:	9a03      	ldr	r2, [sp, #12]
 8021244:	601a      	str	r2, [r3, #0]
 8021246:	f7ff bb21 	b.w	802088c <_svfiprintf_r+0x30>
 802124a:	9804      	ldr	r0, [sp, #16]
 802124c:	4651      	mov	r1, sl
 802124e:	aa0f      	add	r2, sp, #60	; 0x3c
 8021250:	f7ff fa82 	bl	8020758 <__ssprint_r>
 8021254:	2800      	cmp	r0, #0
 8021256:	f47f aecc 	bne.w	8020ff2 <_svfiprintf_r+0x796>
 802125a:	9911      	ldr	r1, [sp, #68]	; 0x44
 802125c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802125e:	4644      	mov	r4, r8
 8021260:	e609      	b.n	8020e76 <_svfiprintf_r+0x61a>
 8021262:	3204      	adds	r2, #4
 8021264:	680e      	ldr	r6, [r1, #0]
 8021266:	9206      	str	r2, [sp, #24]
 8021268:	2700      	movs	r7, #0
 802126a:	e4fa      	b.n	8020c62 <_svfiprintf_r+0x406>
 802126c:	9809      	ldr	r0, [sp, #36]	; 0x24
 802126e:	9606      	str	r6, [sp, #24]
 8021270:	f7fe fbf2 	bl	801fa58 <strlen>
 8021274:	2300      	movs	r3, #0
 8021276:	9002      	str	r0, [sp, #8]
 8021278:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 802127c:	9301      	str	r3, [sp, #4]
 802127e:	e714      	b.n	80210aa <_svfiprintf_r+0x84e>
 8021280:	2a06      	cmp	r2, #6
 8021282:	4613      	mov	r3, r2
 8021284:	bf28      	it	cs
 8021286:	2306      	movcs	r3, #6
 8021288:	9302      	str	r3, [sp, #8]
 802128a:	9606      	str	r6, [sp, #24]
 802128c:	ea23 76e3 	bic.w	r6, r3, r3, asr #31
 8021290:	4b16      	ldr	r3, [pc, #88]	; (80212ec <_svfiprintf_r+0xa90>)
 8021292:	9309      	str	r3, [sp, #36]	; 0x24
 8021294:	e487      	b.n	8020ba6 <_svfiprintf_r+0x34a>
 8021296:	2140      	movs	r1, #64	; 0x40
 8021298:	f7f4 fd94 	bl	8015dc4 <_malloc_r>
 802129c:	f8ca 0000 	str.w	r0, [sl]
 80212a0:	f8ca 0010 	str.w	r0, [sl, #16]
 80212a4:	b1e0      	cbz	r0, 80212e0 <_svfiprintf_r+0xa84>
 80212a6:	2340      	movs	r3, #64	; 0x40
 80212a8:	f8ca 3014 	str.w	r3, [sl, #20]
 80212ac:	f7ff bae4 	b.w	8020878 <_svfiprintf_r+0x1c>
 80212b0:	2200      	movs	r2, #0
 80212b2:	9201      	str	r2, [sp, #4]
 80212b4:	f7ff bb1e 	b.w	80208f4 <_svfiprintf_r+0x98>
 80212b8:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 80212bc:	9606      	str	r6, [sp, #24]
 80212be:	9001      	str	r0, [sp, #4]
 80212c0:	e6f3      	b.n	80210aa <_svfiprintf_r+0x84e>
 80212c2:	9a06      	ldr	r2, [sp, #24]
 80212c4:	6813      	ldr	r3, [r2, #0]
 80212c6:	9301      	str	r3, [sp, #4]
 80212c8:	3204      	adds	r2, #4
 80212ca:	2b00      	cmp	r3, #0
 80212cc:	9206      	str	r2, [sp, #24]
 80212ce:	f899 3001 	ldrb.w	r3, [r9, #1]
 80212d2:	f6bf ab0d 	bge.w	80208f0 <_svfiprintf_r+0x94>
 80212d6:	f04f 32ff 	mov.w	r2, #4294967295
 80212da:	9201      	str	r2, [sp, #4]
 80212dc:	f7ff bb08 	b.w	80208f0 <_svfiprintf_r+0x94>
 80212e0:	9a04      	ldr	r2, [sp, #16]
 80212e2:	230c      	movs	r3, #12
 80212e4:	6013      	str	r3, [r2, #0]
 80212e6:	f04f 30ff 	mov.w	r0, #4294967295
 80212ea:	e68b      	b.n	8021004 <_svfiprintf_r+0x7a8>
 80212ec:	08025d7c 	.word	0x08025d7c

080212f0 <_sungetc_r>:
 80212f0:	f1b1 3fff 	cmp.w	r1, #4294967295
 80212f4:	d037      	beq.n	8021366 <_sungetc_r+0x76>
 80212f6:	b538      	push	{r3, r4, r5, lr}
 80212f8:	8993      	ldrh	r3, [r2, #12]
 80212fa:	4614      	mov	r4, r2
 80212fc:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80212fe:	f023 0320 	bic.w	r3, r3, #32
 8021302:	b2cd      	uxtb	r5, r1
 8021304:	81a3      	strh	r3, [r4, #12]
 8021306:	b1aa      	cbz	r2, 8021334 <_sungetc_r+0x44>
 8021308:	6862      	ldr	r2, [r4, #4]
 802130a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802130c:	429a      	cmp	r2, r3
 802130e:	da09      	bge.n	8021324 <_sungetc_r+0x34>
 8021310:	6823      	ldr	r3, [r4, #0]
 8021312:	1e5a      	subs	r2, r3, #1
 8021314:	6022      	str	r2, [r4, #0]
 8021316:	f803 5c01 	strb.w	r5, [r3, #-1]
 802131a:	6863      	ldr	r3, [r4, #4]
 802131c:	3301      	adds	r3, #1
 802131e:	4628      	mov	r0, r5
 8021320:	6063      	str	r3, [r4, #4]
 8021322:	bd38      	pop	{r3, r4, r5, pc}
 8021324:	4621      	mov	r1, r4
 8021326:	f000 fd61 	bl	8021dec <__submore>
 802132a:	2800      	cmp	r0, #0
 802132c:	d0f0      	beq.n	8021310 <_sungetc_r+0x20>
 802132e:	f04f 30ff 	mov.w	r0, #4294967295
 8021332:	bd38      	pop	{r3, r4, r5, pc}
 8021334:	6922      	ldr	r2, [r4, #16]
 8021336:	6823      	ldr	r3, [r4, #0]
 8021338:	b12a      	cbz	r2, 8021346 <_sungetc_r+0x56>
 802133a:	429a      	cmp	r2, r3
 802133c:	d203      	bcs.n	8021346 <_sungetc_r+0x56>
 802133e:	f813 0c01 	ldrb.w	r0, [r3, #-1]
 8021342:	42a8      	cmp	r0, r5
 8021344:	d012      	beq.n	802136c <_sungetc_r+0x7c>
 8021346:	63a3      	str	r3, [r4, #56]	; 0x38
 8021348:	4623      	mov	r3, r4
 802134a:	6860      	ldr	r0, [r4, #4]
 802134c:	63e0      	str	r0, [r4, #60]	; 0x3c
 802134e:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8021352:	2203      	movs	r2, #3
 8021354:	6362      	str	r2, [r4, #52]	; 0x34
 8021356:	6321      	str	r1, [r4, #48]	; 0x30
 8021358:	f803 5f42 	strb.w	r5, [r3, #66]!
 802135c:	2201      	movs	r2, #1
 802135e:	6023      	str	r3, [r4, #0]
 8021360:	4628      	mov	r0, r5
 8021362:	6062      	str	r2, [r4, #4]
 8021364:	bd38      	pop	{r3, r4, r5, pc}
 8021366:	f04f 30ff 	mov.w	r0, #4294967295
 802136a:	4770      	bx	lr
 802136c:	6862      	ldr	r2, [r4, #4]
 802136e:	3b01      	subs	r3, #1
 8021370:	3201      	adds	r2, #1
 8021372:	6023      	str	r3, [r4, #0]
 8021374:	6062      	str	r2, [r4, #4]
 8021376:	bd38      	pop	{r3, r4, r5, pc}

08021378 <__ssrefill_r>:
 8021378:	b510      	push	{r4, lr}
 802137a:	460c      	mov	r4, r1
 802137c:	6b09      	ldr	r1, [r1, #48]	; 0x30
 802137e:	b169      	cbz	r1, 802139c <__ssrefill_r+0x24>
 8021380:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8021384:	4299      	cmp	r1, r3
 8021386:	d001      	beq.n	802138c <__ssrefill_r+0x14>
 8021388:	f7f4 fd46 	bl	8015e18 <_free_r>
 802138c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 802138e:	6063      	str	r3, [r4, #4]
 8021390:	2000      	movs	r0, #0
 8021392:	6320      	str	r0, [r4, #48]	; 0x30
 8021394:	b113      	cbz	r3, 802139c <__ssrefill_r+0x24>
 8021396:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8021398:	6023      	str	r3, [r4, #0]
 802139a:	bd10      	pop	{r4, pc}
 802139c:	89a3      	ldrh	r3, [r4, #12]
 802139e:	6922      	ldr	r2, [r4, #16]
 80213a0:	6022      	str	r2, [r4, #0]
 80213a2:	f043 0320 	orr.w	r3, r3, #32
 80213a6:	2200      	movs	r2, #0
 80213a8:	81a3      	strh	r3, [r4, #12]
 80213aa:	6062      	str	r2, [r4, #4]
 80213ac:	f04f 30ff 	mov.w	r0, #4294967295
 80213b0:	bd10      	pop	{r4, pc}
 80213b2:	bf00      	nop

080213b4 <_sfread_r>:
 80213b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80213b8:	469a      	mov	sl, r3
 80213ba:	b083      	sub	sp, #12
 80213bc:	fb02 f90a 	mul.w	r9, r2, sl
 80213c0:	9201      	str	r2, [sp, #4]
 80213c2:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80213c4:	f1b9 0f00 	cmp.w	r9, #0
 80213c8:	d028      	beq.n	802141c <_sfread_r+0x68>
 80213ca:	4607      	mov	r7, r0
 80213cc:	460e      	mov	r6, r1
 80213ce:	464d      	mov	r5, r9
 80213d0:	f04f 0800 	mov.w	r8, #0
 80213d4:	e00e      	b.n	80213f4 <_sfread_r+0x40>
 80213d6:	f7de ff81 	bl	80002dc <memcpy>
 80213da:	6822      	ldr	r2, [r4, #0]
 80213dc:	f8c4 8004 	str.w	r8, [r4, #4]
 80213e0:	445a      	add	r2, fp
 80213e2:	6022      	str	r2, [r4, #0]
 80213e4:	4638      	mov	r0, r7
 80213e6:	4621      	mov	r1, r4
 80213e8:	445e      	add	r6, fp
 80213ea:	ebcb 0505 	rsb	r5, fp, r5
 80213ee:	f7ff ffc3 	bl	8021378 <__ssrefill_r>
 80213f2:	b9b8      	cbnz	r0, 8021424 <_sfread_r+0x70>
 80213f4:	f8d4 b004 	ldr.w	fp, [r4, #4]
 80213f8:	6821      	ldr	r1, [r4, #0]
 80213fa:	455d      	cmp	r5, fp
 80213fc:	4630      	mov	r0, r6
 80213fe:	465a      	mov	r2, fp
 8021400:	d8e9      	bhi.n	80213d6 <_sfread_r+0x22>
 8021402:	462a      	mov	r2, r5
 8021404:	f7de ff6a 	bl	80002dc <memcpy>
 8021408:	6862      	ldr	r2, [r4, #4]
 802140a:	6823      	ldr	r3, [r4, #0]
 802140c:	1b52      	subs	r2, r2, r5
 802140e:	442b      	add	r3, r5
 8021410:	4650      	mov	r0, sl
 8021412:	6062      	str	r2, [r4, #4]
 8021414:	6023      	str	r3, [r4, #0]
 8021416:	b003      	add	sp, #12
 8021418:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802141c:	4648      	mov	r0, r9
 802141e:	b003      	add	sp, #12
 8021420:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021424:	9b01      	ldr	r3, [sp, #4]
 8021426:	ebc5 0909 	rsb	r9, r5, r9
 802142a:	fbb9 f0f3 	udiv	r0, r9, r3
 802142e:	b003      	add	sp, #12
 8021430:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08021434 <__ssvfiscanf_r>:
 8021434:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021438:	460c      	mov	r4, r1
 802143a:	8989      	ldrh	r1, [r1, #12]
 802143c:	b0db      	sub	sp, #364	; 0x16c
 802143e:	048d      	lsls	r5, r1, #18
 8021440:	9305      	str	r3, [sp, #20]
 8021442:	d406      	bmi.n	8021452 <__ssvfiscanf_r+0x1e>
 8021444:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8021446:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 802144a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802144e:	81a1      	strh	r1, [r4, #12]
 8021450:	6663      	str	r3, [r4, #100]	; 0x64
 8021452:	4617      	mov	r7, r2
 8021454:	2300      	movs	r3, #0
 8021456:	f817 1b01 	ldrb.w	r1, [r7], #1
 802145a:	9306      	str	r3, [sp, #24]
 802145c:	9304      	str	r3, [sp, #16]
 802145e:	461d      	mov	r5, r3
 8021460:	9308      	str	r3, [sp, #32]
 8021462:	f8df b3e8 	ldr.w	fp, [pc, #1000]	; 802184c <__ssvfiscanf_r+0x418>
 8021466:	910d      	str	r1, [sp, #52]	; 0x34
 8021468:	4680      	mov	r8, r0
 802146a:	b339      	cbz	r1, 80214bc <__ssvfiscanf_r+0x88>
 802146c:	f8db 0000 	ldr.w	r0, [fp]
 8021470:	1843      	adds	r3, r0, r1
 8021472:	785b      	ldrb	r3, [r3, #1]
 8021474:	f003 0308 	and.w	r3, r3, #8
 8021478:	f003 09ff 	and.w	r9, r3, #255	; 0xff
 802147c:	b313      	cbz	r3, 80214c4 <__ssvfiscanf_r+0x90>
 802147e:	6863      	ldr	r3, [r4, #4]
 8021480:	e00d      	b.n	802149e <__ssvfiscanf_r+0x6a>
 8021482:	6823      	ldr	r3, [r4, #0]
 8021484:	f8db 1000 	ldr.w	r1, [fp]
 8021488:	781a      	ldrb	r2, [r3, #0]
 802148a:	440a      	add	r2, r1
 802148c:	3301      	adds	r3, #1
 802148e:	7852      	ldrb	r2, [r2, #1]
 8021490:	0711      	lsls	r1, r2, #28
 8021492:	d50c      	bpl.n	80214ae <__ssvfiscanf_r+0x7a>
 8021494:	6862      	ldr	r2, [r4, #4]
 8021496:	6023      	str	r3, [r4, #0]
 8021498:	1e53      	subs	r3, r2, #1
 802149a:	3501      	adds	r5, #1
 802149c:	6063      	str	r3, [r4, #4]
 802149e:	2b00      	cmp	r3, #0
 80214a0:	dcef      	bgt.n	8021482 <__ssvfiscanf_r+0x4e>
 80214a2:	4640      	mov	r0, r8
 80214a4:	4621      	mov	r1, r4
 80214a6:	f7ff ff67 	bl	8021378 <__ssrefill_r>
 80214aa:	2800      	cmp	r0, #0
 80214ac:	d0e9      	beq.n	8021482 <__ssvfiscanf_r+0x4e>
 80214ae:	463a      	mov	r2, r7
 80214b0:	4617      	mov	r7, r2
 80214b2:	f817 1b01 	ldrb.w	r1, [r7], #1
 80214b6:	910d      	str	r1, [sp, #52]	; 0x34
 80214b8:	2900      	cmp	r1, #0
 80214ba:	d1d7      	bne.n	802146c <__ssvfiscanf_r+0x38>
 80214bc:	9808      	ldr	r0, [sp, #32]
 80214be:	b05b      	add	sp, #364	; 0x16c
 80214c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80214c4:	2925      	cmp	r1, #37	; 0x25
 80214c6:	f040 8087 	bne.w	80215d8 <__ssvfiscanf_r+0x1a4>
 80214ca:	7853      	ldrb	r3, [r2, #1]
 80214cc:	46ca      	mov	sl, r9
 80214ce:	1c79      	adds	r1, r7, #1
 80214d0:	2b78      	cmp	r3, #120	; 0x78
 80214d2:	f200 814a 	bhi.w	802176a <__ssvfiscanf_r+0x336>
 80214d6:	e8df f013 	tbh	[pc, r3, lsl #1]
 80214da:	0079      	.short	0x0079
 80214dc:	01480148 	.word	0x01480148
 80214e0:	01480148 	.word	0x01480148
 80214e4:	01480148 	.word	0x01480148
 80214e8:	01480148 	.word	0x01480148
 80214ec:	01480148 	.word	0x01480148
 80214f0:	01480148 	.word	0x01480148
 80214f4:	01480148 	.word	0x01480148
 80214f8:	01480148 	.word	0x01480148
 80214fc:	01480148 	.word	0x01480148
 8021500:	01480148 	.word	0x01480148
 8021504:	01480148 	.word	0x01480148
 8021508:	01480148 	.word	0x01480148
 802150c:	01480148 	.word	0x01480148
 8021510:	01480148 	.word	0x01480148
 8021514:	01480148 	.word	0x01480148
 8021518:	01480148 	.word	0x01480148
 802151c:	01480148 	.word	0x01480148
 8021520:	01480148 	.word	0x01480148
 8021524:	0148007e 	.word	0x0148007e
 8021528:	01480148 	.word	0x01480148
 802152c:	01430148 	.word	0x01430148
 8021530:	01480148 	.word	0x01480148
 8021534:	01480148 	.word	0x01480148
 8021538:	013a0148 	.word	0x013a0148
 802153c:	013a013a 	.word	0x013a013a
 8021540:	013a013a 	.word	0x013a013a
 8021544:	013a013a 	.word	0x013a013a
 8021548:	013a013a 	.word	0x013a013a
 802154c:	0148013a 	.word	0x0148013a
 8021550:	01480148 	.word	0x01480148
 8021554:	01480148 	.word	0x01480148
 8021558:	01480148 	.word	0x01480148
 802155c:	01480148 	.word	0x01480148
 8021560:	01360148 	.word	0x01360148
 8021564:	01480148 	.word	0x01480148
 8021568:	01480148 	.word	0x01480148
 802156c:	01480148 	.word	0x01480148
 8021570:	01310148 	.word	0x01310148
 8021574:	01480148 	.word	0x01480148
 8021578:	0148012d 	.word	0x0148012d
 802157c:	01480148 	.word	0x01480148
 8021580:	01480148 	.word	0x01480148
 8021584:	01480148 	.word	0x01480148
 8021588:	01290148 	.word	0x01290148
 802158c:	01480148 	.word	0x01480148
 8021590:	01480120 	.word	0x01480120
 8021594:	01480148 	.word	0x01480148
 8021598:	01480148 	.word	0x01480148
 802159c:	01480148 	.word	0x01480148
 80215a0:	0112011a 	.word	0x0112011a
 80215a4:	01480148 	.word	0x01480148
 80215a8:	010d0148 	.word	0x010d0148
 80215ac:	01480105 	.word	0x01480105
 80215b0:	00fd0148 	.word	0x00fd0148
 80215b4:	00e30148 	.word	0x00e30148
 80215b8:	00f300db 	.word	0x00f300db
 80215bc:	01480148 	.word	0x01480148
 80215c0:	014800be 	.word	0x014800be
 80215c4:	01480092 	.word	0x01480092
 80215c8:	01290148 	.word	0x01290148
 80215cc:	f04f 30ff 	mov.w	r0, #4294967295
 80215d0:	b05b      	add	sp, #364	; 0x16c
 80215d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80215d6:	460f      	mov	r7, r1
 80215d8:	6863      	ldr	r3, [r4, #4]
 80215da:	2b00      	cmp	r3, #0
 80215dc:	f340 834f 	ble.w	8021c7e <__ssvfiscanf_r+0x84a>
 80215e0:	6823      	ldr	r3, [r4, #0]
 80215e2:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 80215e6:	7819      	ldrb	r1, [r3, #0]
 80215e8:	4291      	cmp	r1, r2
 80215ea:	f47f af67 	bne.w	80214bc <__ssvfiscanf_r+0x88>
 80215ee:	6862      	ldr	r2, [r4, #4]
 80215f0:	3301      	adds	r3, #1
 80215f2:	3a01      	subs	r2, #1
 80215f4:	6062      	str	r2, [r4, #4]
 80215f6:	6023      	str	r3, [r4, #0]
 80215f8:	3501      	adds	r5, #1
 80215fa:	463a      	mov	r2, r7
 80215fc:	e758      	b.n	80214b0 <__ssvfiscanf_r+0x7c>
 80215fe:	4b91      	ldr	r3, [pc, #580]	; (8021844 <__ssvfiscanf_r+0x410>)
 8021600:	9306      	str	r3, [sp, #24]
 8021602:	230a      	movs	r3, #10
 8021604:	9304      	str	r3, [sp, #16]
 8021606:	460f      	mov	r7, r1
 8021608:	4656      	mov	r6, sl
 802160a:	2303      	movs	r3, #3
 802160c:	6862      	ldr	r2, [r4, #4]
 802160e:	2a00      	cmp	r2, #0
 8021610:	dd28      	ble.n	8021664 <__ssvfiscanf_r+0x230>
 8021612:	f019 0f40 	tst.w	r9, #64	; 0x40
 8021616:	f040 80b6 	bne.w	8021786 <__ssvfiscanf_r+0x352>
 802161a:	f8db 0000 	ldr.w	r0, [fp]
 802161e:	6821      	ldr	r1, [r4, #0]
 8021620:	e000      	b.n	8021624 <__ssvfiscanf_r+0x1f0>
 8021622:	6021      	str	r1, [r4, #0]
 8021624:	780a      	ldrb	r2, [r1, #0]
 8021626:	4402      	add	r2, r0
 8021628:	3101      	adds	r1, #1
 802162a:	7852      	ldrb	r2, [r2, #1]
 802162c:	0712      	lsls	r2, r2, #28
 802162e:	f140 80aa 	bpl.w	8021786 <__ssvfiscanf_r+0x352>
 8021632:	6862      	ldr	r2, [r4, #4]
 8021634:	3a01      	subs	r2, #1
 8021636:	2a00      	cmp	r2, #0
 8021638:	f105 0501 	add.w	r5, r5, #1
 802163c:	6062      	str	r2, [r4, #4]
 802163e:	dcf0      	bgt.n	8021622 <__ssvfiscanf_r+0x1ee>
 8021640:	4640      	mov	r0, r8
 8021642:	4621      	mov	r1, r4
 8021644:	9303      	str	r3, [sp, #12]
 8021646:	f7ff fe97 	bl	8021378 <__ssrefill_r>
 802164a:	b998      	cbnz	r0, 8021674 <__ssvfiscanf_r+0x240>
 802164c:	f8db 0000 	ldr.w	r0, [fp]
 8021650:	6821      	ldr	r1, [r4, #0]
 8021652:	9b03      	ldr	r3, [sp, #12]
 8021654:	e7e6      	b.n	8021624 <__ssvfiscanf_r+0x1f0>
 8021656:	6862      	ldr	r2, [r4, #4]
 8021658:	2a00      	cmp	r2, #0
 802165a:	460f      	mov	r7, r1
 802165c:	4656      	mov	r6, sl
 802165e:	f04f 0302 	mov.w	r3, #2
 8021662:	dcd6      	bgt.n	8021612 <__ssvfiscanf_r+0x1de>
 8021664:	4640      	mov	r0, r8
 8021666:	4621      	mov	r1, r4
 8021668:	9303      	str	r3, [sp, #12]
 802166a:	f7ff fe85 	bl	8021378 <__ssrefill_r>
 802166e:	9b03      	ldr	r3, [sp, #12]
 8021670:	2800      	cmp	r0, #0
 8021672:	d0ce      	beq.n	8021612 <__ssvfiscanf_r+0x1de>
 8021674:	9a08      	ldr	r2, [sp, #32]
 8021676:	2a00      	cmp	r2, #0
 8021678:	d0a8      	beq.n	80215cc <__ssvfiscanf_r+0x198>
 802167a:	89a3      	ldrh	r3, [r4, #12]
 802167c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8021680:	4613      	mov	r3, r2
 8021682:	bf18      	it	ne
 8021684:	f04f 33ff 	movne.w	r3, #4294967295
 8021688:	4618      	mov	r0, r3
 802168a:	b05b      	add	sp, #364	; 0x16c
 802168c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021690:	460f      	mov	r7, r1
 8021692:	4b6c      	ldr	r3, [pc, #432]	; (8021844 <__ssvfiscanf_r+0x410>)
 8021694:	9306      	str	r3, [sp, #24]
 8021696:	2308      	movs	r3, #8
 8021698:	9304      	str	r3, [sp, #16]
 802169a:	4656      	mov	r6, sl
 802169c:	2303      	movs	r3, #3
 802169e:	e7b5      	b.n	802160c <__ssvfiscanf_r+0x1d8>
 80216a0:	f019 0f10 	tst.w	r9, #16
 80216a4:	460f      	mov	r7, r1
 80216a6:	f47f af02 	bne.w	80214ae <__ssvfiscanf_r+0x7a>
 80216aa:	f019 0f04 	tst.w	r9, #4
 80216ae:	f000 8300 	beq.w	8021cb2 <__ssvfiscanf_r+0x87e>
 80216b2:	9a05      	ldr	r2, [sp, #20]
 80216b4:	6813      	ldr	r3, [r2, #0]
 80216b6:	3204      	adds	r2, #4
 80216b8:	9205      	str	r2, [sp, #20]
 80216ba:	801d      	strh	r5, [r3, #0]
 80216bc:	463a      	mov	r2, r7
 80216be:	e6f7      	b.n	80214b0 <__ssvfiscanf_r+0x7c>
 80216c0:	460f      	mov	r7, r1
 80216c2:	f449 7908 	orr.w	r9, r9, #544	; 0x220
 80216c6:	4b5f      	ldr	r3, [pc, #380]	; (8021844 <__ssvfiscanf_r+0x410>)
 80216c8:	9306      	str	r3, [sp, #24]
 80216ca:	2310      	movs	r3, #16
 80216cc:	9304      	str	r3, [sp, #16]
 80216ce:	4656      	mov	r6, sl
 80216d0:	2303      	movs	r3, #3
 80216d2:	e79b      	b.n	802160c <__ssvfiscanf_r+0x1d8>
 80216d4:	787b      	ldrb	r3, [r7, #1]
 80216d6:	2b6c      	cmp	r3, #108	; 0x6c
 80216d8:	f000 82e6 	beq.w	8021ca8 <__ssvfiscanf_r+0x874>
 80216dc:	f049 0901 	orr.w	r9, r9, #1
 80216e0:	460f      	mov	r7, r1
 80216e2:	e6f4      	b.n	80214ce <__ssvfiscanf_r+0x9a>
 80216e4:	4b58      	ldr	r3, [pc, #352]	; (8021848 <__ssvfiscanf_r+0x414>)
 80216e6:	9306      	str	r3, [sp, #24]
 80216e8:	2300      	movs	r3, #0
 80216ea:	9304      	str	r3, [sp, #16]
 80216ec:	460f      	mov	r7, r1
 80216ee:	4656      	mov	r6, sl
 80216f0:	2303      	movs	r3, #3
 80216f2:	e78b      	b.n	802160c <__ssvfiscanf_r+0x1d8>
 80216f4:	787b      	ldrb	r3, [r7, #1]
 80216f6:	f049 0904 	orr.w	r9, r9, #4
 80216fa:	460f      	mov	r7, r1
 80216fc:	e6e7      	b.n	80214ce <__ssvfiscanf_r+0x9a>
 80216fe:	460f      	mov	r7, r1
 8021700:	4b51      	ldr	r3, [pc, #324]	; (8021848 <__ssvfiscanf_r+0x414>)
 8021702:	9306      	str	r3, [sp, #24]
 8021704:	230a      	movs	r3, #10
 8021706:	9304      	str	r3, [sp, #16]
 8021708:	4656      	mov	r6, sl
 802170a:	2303      	movs	r3, #3
 802170c:	e77e      	b.n	802160c <__ssvfiscanf_r+0x1d8>
 802170e:	460f      	mov	r7, r1
 8021710:	f049 0940 	orr.w	r9, r9, #64	; 0x40
 8021714:	4656      	mov	r6, sl
 8021716:	2300      	movs	r3, #0
 8021718:	e778      	b.n	802160c <__ssvfiscanf_r+0x1d8>
 802171a:	a81a      	add	r0, sp, #104	; 0x68
 802171c:	f000 fcac 	bl	8022078 <__sccl>
 8021720:	f049 0940 	orr.w	r9, r9, #64	; 0x40
 8021724:	4607      	mov	r7, r0
 8021726:	4656      	mov	r6, sl
 8021728:	2301      	movs	r3, #1
 802172a:	e76f      	b.n	802160c <__ssvfiscanf_r+0x1d8>
 802172c:	460f      	mov	r7, r1
 802172e:	f449 7900 	orr.w	r9, r9, #512	; 0x200
 8021732:	e7c8      	b.n	80216c6 <__ssvfiscanf_r+0x292>
 8021734:	460f      	mov	r7, r1
 8021736:	f049 0901 	orr.w	r9, r9, #1
 802173a:	e7aa      	b.n	8021692 <__ssvfiscanf_r+0x25e>
 802173c:	787b      	ldrb	r3, [r7, #1]
 802173e:	f049 0902 	orr.w	r9, r9, #2
 8021742:	460f      	mov	r7, r1
 8021744:	e6c3      	b.n	80214ce <__ssvfiscanf_r+0x9a>
 8021746:	460f      	mov	r7, r1
 8021748:	f049 0901 	orr.w	r9, r9, #1
 802174c:	e7d8      	b.n	8021700 <__ssvfiscanf_r+0x2cc>
 802174e:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
 8021752:	eb03 0a4a 	add.w	sl, r3, sl, lsl #1
 8021756:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
 802175a:	787b      	ldrb	r3, [r7, #1]
 802175c:	460f      	mov	r7, r1
 802175e:	e6b6      	b.n	80214ce <__ssvfiscanf_r+0x9a>
 8021760:	787b      	ldrb	r3, [r7, #1]
 8021762:	f049 0910 	orr.w	r9, r9, #16
 8021766:	460f      	mov	r7, r1
 8021768:	e6b1      	b.n	80214ce <__ssvfiscanf_r+0x9a>
 802176a:	4403      	add	r3, r0
 802176c:	460f      	mov	r7, r1
 802176e:	785b      	ldrb	r3, [r3, #1]
 8021770:	f003 0303 	and.w	r3, r3, #3
 8021774:	2b01      	cmp	r3, #1
 8021776:	d0e7      	beq.n	8021748 <__ssvfiscanf_r+0x314>
 8021778:	4b33      	ldr	r3, [pc, #204]	; (8021848 <__ssvfiscanf_r+0x414>)
 802177a:	9306      	str	r3, [sp, #24]
 802177c:	230a      	movs	r3, #10
 802177e:	9304      	str	r3, [sp, #16]
 8021780:	4656      	mov	r6, sl
 8021782:	2303      	movs	r3, #3
 8021784:	e742      	b.n	802160c <__ssvfiscanf_r+0x1d8>
 8021786:	2b02      	cmp	r3, #2
 8021788:	f000 8115 	beq.w	80219b6 <__ssvfiscanf_r+0x582>
 802178c:	2b03      	cmp	r3, #3
 802178e:	d05f      	beq.n	8021850 <__ssvfiscanf_r+0x41c>
 8021790:	2b01      	cmp	r3, #1
 8021792:	d025      	beq.n	80217e0 <__ssvfiscanf_r+0x3ac>
 8021794:	f1ba 0f00 	cmp.w	sl, #0
 8021798:	bf14      	ite	ne
 802179a:	4656      	movne	r6, sl
 802179c:	2601      	moveq	r6, #1
 802179e:	f019 0301 	ands.w	r3, r9, #1
 80217a2:	f040 81d3 	bne.w	8021b4c <__ssvfiscanf_r+0x718>
 80217a6:	f019 0f10 	tst.w	r9, #16
 80217aa:	f000 8252 	beq.w	8021c52 <__ssvfiscanf_r+0x81e>
 80217ae:	4699      	mov	r9, r3
 80217b0:	e008      	b.n	80217c4 <__ssvfiscanf_r+0x390>
 80217b2:	4413      	add	r3, r2
 80217b4:	6023      	str	r3, [r4, #0]
 80217b6:	4491      	add	r9, r2
 80217b8:	1ab6      	subs	r6, r6, r2
 80217ba:	f7ff fddd 	bl	8021378 <__ssrefill_r>
 80217be:	2800      	cmp	r0, #0
 80217c0:	f040 8241 	bne.w	8021c46 <__ssvfiscanf_r+0x812>
 80217c4:	6862      	ldr	r2, [r4, #4]
 80217c6:	6823      	ldr	r3, [r4, #0]
 80217c8:	42b2      	cmp	r2, r6
 80217ca:	4640      	mov	r0, r8
 80217cc:	4621      	mov	r1, r4
 80217ce:	dbf0      	blt.n	80217b2 <__ssvfiscanf_r+0x37e>
 80217d0:	1b92      	subs	r2, r2, r6
 80217d2:	4433      	add	r3, r6
 80217d4:	6062      	str	r2, [r4, #4]
 80217d6:	44b1      	add	r9, r6
 80217d8:	6023      	str	r3, [r4, #0]
 80217da:	444d      	add	r5, r9
 80217dc:	463a      	mov	r2, r7
 80217de:	e667      	b.n	80214b0 <__ssvfiscanf_r+0x7c>
 80217e0:	f1ba 0f00 	cmp.w	sl, #0
 80217e4:	bf14      	ite	ne
 80217e6:	4656      	movne	r6, sl
 80217e8:	f04f 36ff 	moveq.w	r6, #4294967295
 80217ec:	f019 0f10 	tst.w	r9, #16
 80217f0:	f000 810f 	beq.w	8021a12 <__ssvfiscanf_r+0x5de>
 80217f4:	aa1a      	add	r2, sp, #104	; 0x68
 80217f6:	6821      	ldr	r1, [r4, #0]
 80217f8:	f04f 0900 	mov.w	r9, #0
 80217fc:	4692      	mov	sl, r2
 80217fe:	780b      	ldrb	r3, [r1, #0]
 8021800:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8021804:	3101      	adds	r1, #1
 8021806:	b1b3      	cbz	r3, 8021836 <__ssvfiscanf_r+0x402>
 8021808:	6863      	ldr	r3, [r4, #4]
 802180a:	6021      	str	r1, [r4, #0]
 802180c:	f109 0901 	add.w	r9, r9, #1
 8021810:	3b01      	subs	r3, #1
 8021812:	454e      	cmp	r6, r9
 8021814:	6063      	str	r3, [r4, #4]
 8021816:	d0e0      	beq.n	80217da <__ssvfiscanf_r+0x3a6>
 8021818:	2b00      	cmp	r3, #0
 802181a:	dcf0      	bgt.n	80217fe <__ssvfiscanf_r+0x3ca>
 802181c:	4640      	mov	r0, r8
 802181e:	4621      	mov	r1, r4
 8021820:	f7ff fdaa 	bl	8021378 <__ssrefill_r>
 8021824:	2800      	cmp	r0, #0
 8021826:	d1d8      	bne.n	80217da <__ssvfiscanf_r+0x3a6>
 8021828:	6821      	ldr	r1, [r4, #0]
 802182a:	780b      	ldrb	r3, [r1, #0]
 802182c:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8021830:	3101      	adds	r1, #1
 8021832:	2b00      	cmp	r3, #0
 8021834:	d1e8      	bne.n	8021808 <__ssvfiscanf_r+0x3d4>
 8021836:	f1b9 0f00 	cmp.w	r9, #0
 802183a:	f43f ae3f 	beq.w	80214bc <__ssvfiscanf_r+0x88>
 802183e:	444d      	add	r5, r9
 8021840:	e7cc      	b.n	80217dc <__ssvfiscanf_r+0x3a8>
 8021842:	bf00      	nop
 8021844:	08020619 	.word	0x08020619
 8021848:	0801fbb5 	.word	0x0801fbb5
 802184c:	2001010c 	.word	0x2001010c
 8021850:	f10a 33ff 	add.w	r3, sl, #4294967295
 8021854:	2b26      	cmp	r3, #38	; 0x26
 8021856:	bf8c      	ite	hi
 8021858:	f1aa 0327 	subhi.w	r3, sl, #39	; 0x27
 802185c:	2300      	movls	r3, #0
 802185e:	f04f 0200 	mov.w	r2, #0
 8021862:	f10d 0c40 	add.w	ip, sp, #64	; 0x40
 8021866:	9307      	str	r3, [sp, #28]
 8021868:	462b      	mov	r3, r5
 802186a:	9d04      	ldr	r5, [sp, #16]
 802186c:	9203      	str	r2, [sp, #12]
 802186e:	bf88      	it	hi
 8021870:	2627      	movhi	r6, #39	; 0x27
 8021872:	f449 6958 	orr.w	r9, r9, #3456	; 0xd80
 8021876:	46e2      	mov	sl, ip
 8021878:	463a      	mov	r2, r7
 802187a:	6820      	ldr	r0, [r4, #0]
 802187c:	f890 e000 	ldrb.w	lr, [r0]
 8021880:	f1ae 012b 	sub.w	r1, lr, #43	; 0x2b
 8021884:	294d      	cmp	r1, #77	; 0x4d
 8021886:	d83f      	bhi.n	8021908 <__ssvfiscanf_r+0x4d4>
 8021888:	e8df f001 	tbb	[pc, r1]
 802188c:	3e8f3e8f 	.word	0x3e8f3e8f
 8021890:	6060663e 	.word	0x6060663e
 8021894:	60606060 	.word	0x60606060
 8021898:	3e5a5a60 	.word	0x3e5a5a60
 802189c:	3e3e3e3e 	.word	0x3e3e3e3e
 80218a0:	55553e3e 	.word	0x55553e3e
 80218a4:	55555555 	.word	0x55555555
 80218a8:	3e3e3e3e 	.word	0x3e3e3e3e
 80218ac:	3e3e3e3e 	.word	0x3e3e3e3e
 80218b0:	3e3e3e3e 	.word	0x3e3e3e3e
 80218b4:	3e3e3e3e 	.word	0x3e3e3e3e
 80218b8:	3e3e273e 	.word	0x3e3e273e
 80218bc:	3e3e3e3e 	.word	0x3e3e3e3e
 80218c0:	55553e3e 	.word	0x55553e3e
 80218c4:	55555555 	.word	0x55555555
 80218c8:	3e3e3e3e 	.word	0x3e3e3e3e
 80218cc:	3e3e3e3e 	.word	0x3e3e3e3e
 80218d0:	3e3e3e3e 	.word	0x3e3e3e3e
 80218d4:	3e3e3e3e 	.word	0x3e3e3e3e
 80218d8:	273e      	.short	0x273e
 80218da:	f409 61c0 	and.w	r1, r9, #1536	; 0x600
 80218de:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80218e2:	d111      	bne.n	8021908 <__ssvfiscanf_r+0x4d4>
 80218e4:	f429 7900 	bic.w	r9, r9, #512	; 0x200
 80218e8:	f449 69a0 	orr.w	r9, r9, #1280	; 0x500
 80218ec:	2510      	movs	r5, #16
 80218ee:	6861      	ldr	r1, [r4, #4]
 80218f0:	f88a e000 	strb.w	lr, [sl]
 80218f4:	3901      	subs	r1, #1
 80218f6:	2900      	cmp	r1, #0
 80218f8:	f10a 0a01 	add.w	sl, sl, #1
 80218fc:	6061      	str	r1, [r4, #4]
 80218fe:	dd45      	ble.n	802198c <__ssvfiscanf_r+0x558>
 8021900:	3001      	adds	r0, #1
 8021902:	6020      	str	r0, [r4, #0]
 8021904:	3e01      	subs	r6, #1
 8021906:	d1b8      	bne.n	802187a <__ssvfiscanf_r+0x446>
 8021908:	f419 7f80 	tst.w	r9, #256	; 0x100
 802190c:	9504      	str	r5, [sp, #16]
 802190e:	4617      	mov	r7, r2
 8021910:	461d      	mov	r5, r3
 8021912:	d005      	beq.n	8021920 <__ssvfiscanf_r+0x4ec>
 8021914:	45e2      	cmp	sl, ip
 8021916:	f200 81ba 	bhi.w	8021c8e <__ssvfiscanf_r+0x85a>
 802191a:	45e2      	cmp	sl, ip
 802191c:	f43f adce 	beq.w	80214bc <__ssvfiscanf_r+0x88>
 8021920:	f019 0610 	ands.w	r6, r9, #16
 8021924:	f000 80fa 	beq.w	8021b1c <__ssvfiscanf_r+0x6e8>
 8021928:	9b03      	ldr	r3, [sp, #12]
 802192a:	ebcc 0c0a 	rsb	ip, ip, sl
 802192e:	449c      	add	ip, r3
 8021930:	4465      	add	r5, ip
 8021932:	463a      	mov	r2, r7
 8021934:	e5bc      	b.n	80214b0 <__ssvfiscanf_r+0x7c>
 8021936:	2d0a      	cmp	r5, #10
 8021938:	dde6      	ble.n	8021908 <__ssvfiscanf_r+0x4d4>
 802193a:	f429 6938 	bic.w	r9, r9, #2944	; 0xb80
 802193e:	e7d6      	b.n	80218ee <__ssvfiscanf_r+0x4ba>
 8021940:	49ad      	ldr	r1, [pc, #692]	; (8021bf8 <__ssvfiscanf_r+0x7c4>)
 8021942:	f931 5015 	ldrsh.w	r5, [r1, r5, lsl #1]
 8021946:	2d08      	cmp	r5, #8
 8021948:	dcf7      	bgt.n	802193a <__ssvfiscanf_r+0x506>
 802194a:	e7dd      	b.n	8021908 <__ssvfiscanf_r+0x4d4>
 802194c:	49aa      	ldr	r1, [pc, #680]	; (8021bf8 <__ssvfiscanf_r+0x7c4>)
 802194e:	f429 6938 	bic.w	r9, r9, #2944	; 0xb80
 8021952:	f931 5015 	ldrsh.w	r5, [r1, r5, lsl #1]
 8021956:	e7ca      	b.n	80218ee <__ssvfiscanf_r+0x4ba>
 8021958:	f419 6f00 	tst.w	r9, #2048	; 0x800
 802195c:	d0c7      	beq.n	80218ee <__ssvfiscanf_r+0x4ba>
 802195e:	b915      	cbnz	r5, 8021966 <__ssvfiscanf_r+0x532>
 8021960:	f449 7900 	orr.w	r9, r9, #512	; 0x200
 8021964:	2508      	movs	r5, #8
 8021966:	f419 6f80 	tst.w	r9, #1024	; 0x400
 802196a:	f040 813b 	bne.w	8021be4 <__ssvfiscanf_r+0x7b0>
 802196e:	9907      	ldr	r1, [sp, #28]
 8021970:	f429 7960 	bic.w	r9, r9, #896	; 0x380
 8021974:	b111      	cbz	r1, 802197c <__ssvfiscanf_r+0x548>
 8021976:	3901      	subs	r1, #1
 8021978:	9107      	str	r1, [sp, #28]
 802197a:	3601      	adds	r6, #1
 802197c:	9903      	ldr	r1, [sp, #12]
 802197e:	3101      	adds	r1, #1
 8021980:	9103      	str	r1, [sp, #12]
 8021982:	6861      	ldr	r1, [r4, #4]
 8021984:	3901      	subs	r1, #1
 8021986:	2900      	cmp	r1, #0
 8021988:	6061      	str	r1, [r4, #4]
 802198a:	dcb9      	bgt.n	8021900 <__ssvfiscanf_r+0x4cc>
 802198c:	4640      	mov	r0, r8
 802198e:	4621      	mov	r1, r4
 8021990:	920a      	str	r2, [sp, #40]	; 0x28
 8021992:	9309      	str	r3, [sp, #36]	; 0x24
 8021994:	f8cd c010 	str.w	ip, [sp, #16]
 8021998:	f7ff fcee 	bl	8021378 <__ssrefill_r>
 802199c:	f8dd c010 	ldr.w	ip, [sp, #16]
 80219a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80219a2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80219a4:	2800      	cmp	r0, #0
 80219a6:	d0ad      	beq.n	8021904 <__ssvfiscanf_r+0x4d0>
 80219a8:	e7ae      	b.n	8021908 <__ssvfiscanf_r+0x4d4>
 80219aa:	f019 0f80 	tst.w	r9, #128	; 0x80
 80219ae:	d0ab      	beq.n	8021908 <__ssvfiscanf_r+0x4d4>
 80219b0:	f029 0980 	bic.w	r9, r9, #128	; 0x80
 80219b4:	e79b      	b.n	80218ee <__ssvfiscanf_r+0x4ba>
 80219b6:	f1ba 0f00 	cmp.w	sl, #0
 80219ba:	bf14      	ite	ne
 80219bc:	4656      	movne	r6, sl
 80219be:	f04f 36ff 	moveq.w	r6, #4294967295
 80219c2:	f019 0301 	ands.w	r3, r9, #1
 80219c6:	f040 8083 	bne.w	8021ad0 <__ssvfiscanf_r+0x69c>
 80219ca:	f019 0f10 	tst.w	r9, #16
 80219ce:	d050      	beq.n	8021a72 <__ssvfiscanf_r+0x63e>
 80219d0:	f8db 1000 	ldr.w	r1, [fp]
 80219d4:	6822      	ldr	r2, [r4, #0]
 80219d6:	4699      	mov	r9, r3
 80219d8:	7813      	ldrb	r3, [r2, #0]
 80219da:	440b      	add	r3, r1
 80219dc:	3201      	adds	r2, #1
 80219de:	785b      	ldrb	r3, [r3, #1]
 80219e0:	0718      	lsls	r0, r3, #28
 80219e2:	f53f aefa 	bmi.w	80217da <__ssvfiscanf_r+0x3a6>
 80219e6:	6863      	ldr	r3, [r4, #4]
 80219e8:	6022      	str	r2, [r4, #0]
 80219ea:	f109 0901 	add.w	r9, r9, #1
 80219ee:	3b01      	subs	r3, #1
 80219f0:	454e      	cmp	r6, r9
 80219f2:	6063      	str	r3, [r4, #4]
 80219f4:	f43f aef1 	beq.w	80217da <__ssvfiscanf_r+0x3a6>
 80219f8:	2b00      	cmp	r3, #0
 80219fa:	dced      	bgt.n	80219d8 <__ssvfiscanf_r+0x5a4>
 80219fc:	4640      	mov	r0, r8
 80219fe:	4621      	mov	r1, r4
 8021a00:	f7ff fcba 	bl	8021378 <__ssrefill_r>
 8021a04:	2800      	cmp	r0, #0
 8021a06:	f47f aee8 	bne.w	80217da <__ssvfiscanf_r+0x3a6>
 8021a0a:	f8db 1000 	ldr.w	r1, [fp]
 8021a0e:	6822      	ldr	r2, [r4, #0]
 8021a10:	e7e2      	b.n	80219d8 <__ssvfiscanf_r+0x5a4>
 8021a12:	9a05      	ldr	r2, [sp, #20]
 8021a14:	4613      	mov	r3, r2
 8021a16:	f8d2 9000 	ldr.w	r9, [r2]
 8021a1a:	3304      	adds	r3, #4
 8021a1c:	9305      	str	r3, [sp, #20]
 8021a1e:	46ca      	mov	sl, r9
 8021a20:	aa1a      	add	r2, sp, #104	; 0x68
 8021a22:	6823      	ldr	r3, [r4, #0]
 8021a24:	7819      	ldrb	r1, [r3, #0]
 8021a26:	5c51      	ldrb	r1, [r2, r1]
 8021a28:	1c58      	adds	r0, r3, #1
 8021a2a:	b1b1      	cbz	r1, 8021a5a <__ssvfiscanf_r+0x626>
 8021a2c:	6861      	ldr	r1, [r4, #4]
 8021a2e:	6020      	str	r0, [r4, #0]
 8021a30:	3901      	subs	r1, #1
 8021a32:	6061      	str	r1, [r4, #4]
 8021a34:	781b      	ldrb	r3, [r3, #0]
 8021a36:	f80a 3b01 	strb.w	r3, [sl], #1
 8021a3a:	3e01      	subs	r6, #1
 8021a3c:	d00d      	beq.n	8021a5a <__ssvfiscanf_r+0x626>
 8021a3e:	6863      	ldr	r3, [r4, #4]
 8021a40:	2b00      	cmp	r3, #0
 8021a42:	dcee      	bgt.n	8021a22 <__ssvfiscanf_r+0x5ee>
 8021a44:	4640      	mov	r0, r8
 8021a46:	4621      	mov	r1, r4
 8021a48:	9203      	str	r2, [sp, #12]
 8021a4a:	f7ff fc95 	bl	8021378 <__ssrefill_r>
 8021a4e:	9a03      	ldr	r2, [sp, #12]
 8021a50:	2800      	cmp	r0, #0
 8021a52:	d0e6      	beq.n	8021a22 <__ssvfiscanf_r+0x5ee>
 8021a54:	45ca      	cmp	sl, r9
 8021a56:	f43f ae0d 	beq.w	8021674 <__ssvfiscanf_r+0x240>
 8021a5a:	ebba 0909 	subs.w	r9, sl, r9
 8021a5e:	f43f ad2d 	beq.w	80214bc <__ssvfiscanf_r+0x88>
 8021a62:	9b08      	ldr	r3, [sp, #32]
 8021a64:	2200      	movs	r2, #0
 8021a66:	3301      	adds	r3, #1
 8021a68:	9308      	str	r3, [sp, #32]
 8021a6a:	f88a 2000 	strb.w	r2, [sl]
 8021a6e:	444d      	add	r5, r9
 8021a70:	e6b4      	b.n	80217dc <__ssvfiscanf_r+0x3a8>
 8021a72:	9a05      	ldr	r2, [sp, #20]
 8021a74:	4613      	mov	r3, r2
 8021a76:	f8d2 9000 	ldr.w	r9, [r2]
 8021a7a:	3304      	adds	r3, #4
 8021a7c:	9303      	str	r3, [sp, #12]
 8021a7e:	46ca      	mov	sl, r9
 8021a80:	6821      	ldr	r1, [r4, #0]
 8021a82:	f8db 2000 	ldr.w	r2, [fp]
 8021a86:	780b      	ldrb	r3, [r1, #0]
 8021a88:	4413      	add	r3, r2
 8021a8a:	1c4a      	adds	r2, r1, #1
 8021a8c:	785b      	ldrb	r3, [r3, #1]
 8021a8e:	071b      	lsls	r3, r3, #28
 8021a90:	d411      	bmi.n	8021ab6 <__ssvfiscanf_r+0x682>
 8021a92:	6863      	ldr	r3, [r4, #4]
 8021a94:	6022      	str	r2, [r4, #0]
 8021a96:	3b01      	subs	r3, #1
 8021a98:	6063      	str	r3, [r4, #4]
 8021a9a:	780b      	ldrb	r3, [r1, #0]
 8021a9c:	f80a 3b01 	strb.w	r3, [sl], #1
 8021aa0:	3e01      	subs	r6, #1
 8021aa2:	d008      	beq.n	8021ab6 <__ssvfiscanf_r+0x682>
 8021aa4:	6863      	ldr	r3, [r4, #4]
 8021aa6:	2b00      	cmp	r3, #0
 8021aa8:	dcea      	bgt.n	8021a80 <__ssvfiscanf_r+0x64c>
 8021aaa:	4640      	mov	r0, r8
 8021aac:	4621      	mov	r1, r4
 8021aae:	f7ff fc63 	bl	8021378 <__ssrefill_r>
 8021ab2:	2800      	cmp	r0, #0
 8021ab4:	d0e4      	beq.n	8021a80 <__ssvfiscanf_r+0x64c>
 8021ab6:	9a08      	ldr	r2, [sp, #32]
 8021ab8:	3201      	adds	r2, #1
 8021aba:	ebc9 090a 	rsb	r9, r9, sl
 8021abe:	2300      	movs	r3, #0
 8021ac0:	9208      	str	r2, [sp, #32]
 8021ac2:	9a03      	ldr	r2, [sp, #12]
 8021ac4:	9205      	str	r2, [sp, #20]
 8021ac6:	444d      	add	r5, r9
 8021ac8:	f88a 3000 	strb.w	r3, [sl]
 8021acc:	463a      	mov	r2, r7
 8021ace:	e4ef      	b.n	80214b0 <__ssvfiscanf_r+0x7c>
 8021ad0:	ab0e      	add	r3, sp, #56	; 0x38
 8021ad2:	4618      	mov	r0, r3
 8021ad4:	2100      	movs	r1, #0
 8021ad6:	2208      	movs	r2, #8
 8021ad8:	9309      	str	r3, [sp, #36]	; 0x24
 8021ada:	f7fd fb2b 	bl	801f134 <memset>
 8021ade:	f019 0310 	ands.w	r3, r9, #16
 8021ae2:	9303      	str	r3, [sp, #12]
 8021ae4:	f000 8081 	beq.w	8021bea <__ssvfiscanf_r+0x7b6>
 8021ae8:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
 8021aec:	2200      	movs	r2, #0
 8021aee:	4691      	mov	r9, r2
 8021af0:	6823      	ldr	r3, [r4, #0]
 8021af2:	f8db 2000 	ldr.w	r2, [fp]
 8021af6:	781b      	ldrb	r3, [r3, #0]
 8021af8:	4413      	add	r3, r2
 8021afa:	785b      	ldrb	r3, [r3, #1]
 8021afc:	071b      	lsls	r3, r3, #28
 8021afe:	d402      	bmi.n	8021b06 <__ssvfiscanf_r+0x6d2>
 8021b00:	2e00      	cmp	r6, #0
 8021b02:	f040 810b 	bne.w	8021d1c <__ssvfiscanf_r+0x8e8>
 8021b06:	9b03      	ldr	r3, [sp, #12]
 8021b08:	2b00      	cmp	r3, #0
 8021b0a:	f47f acd0 	bne.w	80214ae <__ssvfiscanf_r+0x7a>
 8021b0e:	f8ca 3000 	str.w	r3, [sl]
 8021b12:	9b08      	ldr	r3, [sp, #32]
 8021b14:	3301      	adds	r3, #1
 8021b16:	9308      	str	r3, [sp, #32]
 8021b18:	463a      	mov	r2, r7
 8021b1a:	e4c9      	b.n	80214b0 <__ssvfiscanf_r+0x7c>
 8021b1c:	4632      	mov	r2, r6
 8021b1e:	4661      	mov	r1, ip
 8021b20:	f88a 6000 	strb.w	r6, [sl]
 8021b24:	4640      	mov	r0, r8
 8021b26:	9b04      	ldr	r3, [sp, #16]
 8021b28:	9e06      	ldr	r6, [sp, #24]
 8021b2a:	f8cd c01c 	str.w	ip, [sp, #28]
 8021b2e:	47b0      	blx	r6
 8021b30:	f019 0f20 	tst.w	r9, #32
 8021b34:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8021b38:	d075      	beq.n	8021c26 <__ssvfiscanf_r+0x7f2>
 8021b3a:	9a05      	ldr	r2, [sp, #20]
 8021b3c:	6813      	ldr	r3, [r2, #0]
 8021b3e:	3204      	adds	r2, #4
 8021b40:	9205      	str	r2, [sp, #20]
 8021b42:	6018      	str	r0, [r3, #0]
 8021b44:	9b08      	ldr	r3, [sp, #32]
 8021b46:	3301      	adds	r3, #1
 8021b48:	9308      	str	r3, [sp, #32]
 8021b4a:	e6ed      	b.n	8021928 <__ssvfiscanf_r+0x4f4>
 8021b4c:	ab0e      	add	r3, sp, #56	; 0x38
 8021b4e:	4618      	mov	r0, r3
 8021b50:	2100      	movs	r1, #0
 8021b52:	2208      	movs	r2, #8
 8021b54:	9309      	str	r3, [sp, #36]	; 0x24
 8021b56:	f7fd faed 	bl	801f134 <memset>
 8021b5a:	f019 0310 	ands.w	r3, r9, #16
 8021b5e:	930a      	str	r3, [sp, #40]	; 0x28
 8021b60:	d05a      	beq.n	8021c18 <__ssvfiscanf_r+0x7e4>
 8021b62:	2300      	movs	r3, #0
 8021b64:	4619      	mov	r1, r3
 8021b66:	9503      	str	r5, [sp, #12]
 8021b68:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8021b6a:	970b      	str	r7, [sp, #44]	; 0x2c
 8021b6c:	f04f 0a00 	mov.w	sl, #0
 8021b70:	f10d 0940 	add.w	r9, sp, #64	; 0x40
 8021b74:	460f      	mov	r7, r1
 8021b76:	f8cd 801c 	str.w	r8, [sp, #28]
 8021b7a:	f000 f985 	bl	8021e88 <__locale_mb_cur_max>
 8021b7e:	4550      	cmp	r0, sl
 8021b80:	f43f ad78 	beq.w	8021674 <__ssvfiscanf_r+0x240>
 8021b84:	e894 000a 	ldmia.w	r4, {r1, r3}
 8021b88:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8021b8a:	f811 eb01 	ldrb.w	lr, [r1], #1
 8021b8e:	6021      	str	r1, [r4, #0]
 8021b90:	3b01      	subs	r3, #1
 8021b92:	f10a 0801 	add.w	r8, sl, #1
 8021b96:	9200      	str	r2, [sp, #0]
 8021b98:	4639      	mov	r1, r7
 8021b9a:	6063      	str	r3, [r4, #4]
 8021b9c:	9807      	ldr	r0, [sp, #28]
 8021b9e:	f809 e00a 	strb.w	lr, [r9, sl]
 8021ba2:	4643      	mov	r3, r8
 8021ba4:	464a      	mov	r2, r9
 8021ba6:	f000 f975 	bl	8021e94 <_mbrtowc_r>
 8021baa:	1c41      	adds	r1, r0, #1
 8021bac:	f43f ad62 	beq.w	8021674 <__ssvfiscanf_r+0x240>
 8021bb0:	2800      	cmp	r0, #0
 8021bb2:	d141      	bne.n	8021c38 <__ssvfiscanf_r+0x804>
 8021bb4:	b905      	cbnz	r5, 8021bb8 <__ssvfiscanf_r+0x784>
 8021bb6:	603d      	str	r5, [r7, #0]
 8021bb8:	9b03      	ldr	r3, [sp, #12]
 8021bba:	4443      	add	r3, r8
 8021bbc:	9303      	str	r3, [sp, #12]
 8021bbe:	3e01      	subs	r6, #1
 8021bc0:	2d00      	cmp	r5, #0
 8021bc2:	d13d      	bne.n	8021c40 <__ssvfiscanf_r+0x80c>
 8021bc4:	3704      	adds	r7, #4
 8021bc6:	46aa      	mov	sl, r5
 8021bc8:	6863      	ldr	r3, [r4, #4]
 8021bca:	2b00      	cmp	r3, #0
 8021bcc:	dd16      	ble.n	8021bfc <__ssvfiscanf_r+0x7c8>
 8021bce:	2e00      	cmp	r6, #0
 8021bd0:	d1d3      	bne.n	8021b7a <__ssvfiscanf_r+0x746>
 8021bd2:	9d03      	ldr	r5, [sp, #12]
 8021bd4:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8021bd6:	f8dd 801c 	ldr.w	r8, [sp, #28]
 8021bda:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8021bdc:	2b00      	cmp	r3, #0
 8021bde:	d098      	beq.n	8021b12 <__ssvfiscanf_r+0x6de>
 8021be0:	463a      	mov	r2, r7
 8021be2:	e465      	b.n	80214b0 <__ssvfiscanf_r+0x7c>
 8021be4:	f429 69b0 	bic.w	r9, r9, #1408	; 0x580
 8021be8:	e681      	b.n	80218ee <__ssvfiscanf_r+0x4ba>
 8021bea:	9a05      	ldr	r2, [sp, #20]
 8021bec:	4613      	mov	r3, r2
 8021bee:	3304      	adds	r3, #4
 8021bf0:	f8d2 a000 	ldr.w	sl, [r2]
 8021bf4:	9305      	str	r3, [sp, #20]
 8021bf6:	e779      	b.n	8021aec <__ssvfiscanf_r+0x6b8>
 8021bf8:	08025d94 	.word	0x08025d94
 8021bfc:	9807      	ldr	r0, [sp, #28]
 8021bfe:	4621      	mov	r1, r4
 8021c00:	f7ff fbba 	bl	8021378 <__ssrefill_r>
 8021c04:	2800      	cmp	r0, #0
 8021c06:	d0e2      	beq.n	8021bce <__ssvfiscanf_r+0x79a>
 8021c08:	9d03      	ldr	r5, [sp, #12]
 8021c0a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8021c0c:	f8dd 801c 	ldr.w	r8, [sp, #28]
 8021c10:	f1ba 0f00 	cmp.w	sl, #0
 8021c14:	d0e1      	beq.n	8021bda <__ssvfiscanf_r+0x7a6>
 8021c16:	e52d      	b.n	8021674 <__ssvfiscanf_r+0x240>
 8021c18:	9a05      	ldr	r2, [sp, #20]
 8021c1a:	6813      	ldr	r3, [r2, #0]
 8021c1c:	4619      	mov	r1, r3
 8021c1e:	4613      	mov	r3, r2
 8021c20:	3304      	adds	r3, #4
 8021c22:	9305      	str	r3, [sp, #20]
 8021c24:	e79f      	b.n	8021b66 <__ssvfiscanf_r+0x732>
 8021c26:	f019 0f04 	tst.w	r9, #4
 8021c2a:	d05b      	beq.n	8021ce4 <__ssvfiscanf_r+0x8b0>
 8021c2c:	9a05      	ldr	r2, [sp, #20]
 8021c2e:	6813      	ldr	r3, [r2, #0]
 8021c30:	3204      	adds	r2, #4
 8021c32:	9205      	str	r2, [sp, #20]
 8021c34:	8018      	strh	r0, [r3, #0]
 8021c36:	e785      	b.n	8021b44 <__ssvfiscanf_r+0x710>
 8021c38:	3002      	adds	r0, #2
 8021c3a:	d1bd      	bne.n	8021bb8 <__ssvfiscanf_r+0x784>
 8021c3c:	46c2      	mov	sl, r8
 8021c3e:	e7c3      	b.n	8021bc8 <__ssvfiscanf_r+0x794>
 8021c40:	f04f 0a00 	mov.w	sl, #0
 8021c44:	e7c0      	b.n	8021bc8 <__ssvfiscanf_r+0x794>
 8021c46:	f1b9 0f00 	cmp.w	r9, #0
 8021c4a:	f43f ad13 	beq.w	8021674 <__ssvfiscanf_r+0x240>
 8021c4e:	444d      	add	r5, r9
 8021c50:	e5c4      	b.n	80217dc <__ssvfiscanf_r+0x3a8>
 8021c52:	9b05      	ldr	r3, [sp, #20]
 8021c54:	4640      	mov	r0, r8
 8021c56:	6819      	ldr	r1, [r3, #0]
 8021c58:	9400      	str	r4, [sp, #0]
 8021c5a:	4633      	mov	r3, r6
 8021c5c:	2201      	movs	r2, #1
 8021c5e:	f7ff fba9 	bl	80213b4 <_sfread_r>
 8021c62:	9b05      	ldr	r3, [sp, #20]
 8021c64:	f103 0a04 	add.w	sl, r3, #4
 8021c68:	2800      	cmp	r0, #0
 8021c6a:	f43f ad03 	beq.w	8021674 <__ssvfiscanf_r+0x240>
 8021c6e:	9b08      	ldr	r3, [sp, #32]
 8021c70:	f8cd a014 	str.w	sl, [sp, #20]
 8021c74:	3301      	adds	r3, #1
 8021c76:	4405      	add	r5, r0
 8021c78:	9308      	str	r3, [sp, #32]
 8021c7a:	463a      	mov	r2, r7
 8021c7c:	e418      	b.n	80214b0 <__ssvfiscanf_r+0x7c>
 8021c7e:	4640      	mov	r0, r8
 8021c80:	4621      	mov	r1, r4
 8021c82:	f7ff fb79 	bl	8021378 <__ssrefill_r>
 8021c86:	2800      	cmp	r0, #0
 8021c88:	f43f acaa 	beq.w	80215e0 <__ssvfiscanf_r+0x1ac>
 8021c8c:	e4f2      	b.n	8021674 <__ssvfiscanf_r+0x240>
 8021c8e:	f81a 1c01 	ldrb.w	r1, [sl, #-1]
 8021c92:	f8cd c01c 	str.w	ip, [sp, #28]
 8021c96:	4640      	mov	r0, r8
 8021c98:	4622      	mov	r2, r4
 8021c9a:	f7ff fb29 	bl	80212f0 <_sungetc_r>
 8021c9e:	f10a 3aff 	add.w	sl, sl, #4294967295
 8021ca2:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8021ca6:	e638      	b.n	802191a <__ssvfiscanf_r+0x4e6>
 8021ca8:	78bb      	ldrb	r3, [r7, #2]
 8021caa:	f049 0902 	orr.w	r9, r9, #2
 8021cae:	3702      	adds	r7, #2
 8021cb0:	e40d      	b.n	80214ce <__ssvfiscanf_r+0x9a>
 8021cb2:	f019 0f01 	tst.w	r9, #1
 8021cb6:	d10d      	bne.n	8021cd4 <__ssvfiscanf_r+0x8a0>
 8021cb8:	f019 0f02 	tst.w	r9, #2
 8021cbc:	d00a      	beq.n	8021cd4 <__ssvfiscanf_r+0x8a0>
 8021cbe:	9a05      	ldr	r2, [sp, #20]
 8021cc0:	6813      	ldr	r3, [r2, #0]
 8021cc2:	4628      	mov	r0, r5
 8021cc4:	3204      	adds	r2, #4
 8021cc6:	17e9      	asrs	r1, r5, #31
 8021cc8:	9205      	str	r2, [sp, #20]
 8021cca:	e9c3 0100 	strd	r0, r1, [r3]
 8021cce:	463a      	mov	r2, r7
 8021cd0:	f7ff bbee 	b.w	80214b0 <__ssvfiscanf_r+0x7c>
 8021cd4:	9a05      	ldr	r2, [sp, #20]
 8021cd6:	6813      	ldr	r3, [r2, #0]
 8021cd8:	3204      	adds	r2, #4
 8021cda:	9205      	str	r2, [sp, #20]
 8021cdc:	601d      	str	r5, [r3, #0]
 8021cde:	463a      	mov	r2, r7
 8021ce0:	f7ff bbe6 	b.w	80214b0 <__ssvfiscanf_r+0x7c>
 8021ce4:	f019 0201 	ands.w	r2, r9, #1
 8021ce8:	f47f af27 	bne.w	8021b3a <__ssvfiscanf_r+0x706>
 8021cec:	f019 0f02 	tst.w	r9, #2
 8021cf0:	f43f af23 	beq.w	8021b3a <__ssvfiscanf_r+0x706>
 8021cf4:	4b3c      	ldr	r3, [pc, #240]	; (8021de8 <__ssvfiscanf_r+0x9b4>)
 8021cf6:	9906      	ldr	r1, [sp, #24]
 8021cf8:	f8cd c01c 	str.w	ip, [sp, #28]
 8021cfc:	4299      	cmp	r1, r3
 8021cfe:	4640      	mov	r0, r8
 8021d00:	4661      	mov	r1, ip
 8021d02:	9b04      	ldr	r3, [sp, #16]
 8021d04:	d067      	beq.n	8021dd6 <__ssvfiscanf_r+0x9a2>
 8021d06:	f000 f9f3 	bl	80220f0 <_strtoll_r>
 8021d0a:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8021d0e:	9a05      	ldr	r2, [sp, #20]
 8021d10:	6813      	ldr	r3, [r2, #0]
 8021d12:	3204      	adds	r2, #4
 8021d14:	9205      	str	r2, [sp, #20]
 8021d16:	e9c3 0100 	strd	r0, r1, [r3]
 8021d1a:	e713      	b.n	8021b44 <__ssvfiscanf_r+0x710>
 8021d1c:	f000 f8b4 	bl	8021e88 <__locale_mb_cur_max>
 8021d20:	4548      	cmp	r0, r9
 8021d22:	f43f aca7 	beq.w	8021674 <__ssvfiscanf_r+0x240>
 8021d26:	e894 000a 	ldmia.w	r4, {r1, r3}
 8021d2a:	f10d 0e40 	add.w	lr, sp, #64	; 0x40
 8021d2e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8021d32:	6021      	str	r1, [r4, #0]
 8021d34:	f109 0c01 	add.w	ip, r9, #1
 8021d38:	9909      	ldr	r1, [sp, #36]	; 0x24
 8021d3a:	9100      	str	r1, [sp, #0]
 8021d3c:	3b01      	subs	r3, #1
 8021d3e:	6063      	str	r3, [r4, #4]
 8021d40:	f80e 2009 	strb.w	r2, [lr, r9]
 8021d44:	4663      	mov	r3, ip
 8021d46:	4672      	mov	r2, lr
 8021d48:	4640      	mov	r0, r8
 8021d4a:	4651      	mov	r1, sl
 8021d4c:	f8cd c01c 	str.w	ip, [sp, #28]
 8021d50:	f000 f8a0 	bl	8021e94 <_mbrtowc_r>
 8021d54:	1c42      	adds	r2, r0, #1
 8021d56:	f43f ac8d 	beq.w	8021674 <__ssvfiscanf_r+0x240>
 8021d5a:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8021d5e:	b198      	cbz	r0, 8021d88 <__ssvfiscanf_r+0x954>
 8021d60:	3002      	adds	r0, #2
 8021d62:	bf08      	it	eq
 8021d64:	46e1      	moveq	r9, ip
 8021d66:	d13b      	bne.n	8021de0 <__ssvfiscanf_r+0x9ac>
 8021d68:	6863      	ldr	r3, [r4, #4]
 8021d6a:	2b00      	cmp	r3, #0
 8021d6c:	f73f aec0 	bgt.w	8021af0 <__ssvfiscanf_r+0x6bc>
 8021d70:	4640      	mov	r0, r8
 8021d72:	4621      	mov	r1, r4
 8021d74:	f7ff fb00 	bl	8021378 <__ssrefill_r>
 8021d78:	2800      	cmp	r0, #0
 8021d7a:	f43f aeb9 	beq.w	8021af0 <__ssvfiscanf_r+0x6bc>
 8021d7e:	464a      	mov	r2, r9
 8021d80:	2a00      	cmp	r2, #0
 8021d82:	f47f ac77 	bne.w	8021674 <__ssvfiscanf_r+0x240>
 8021d86:	e6be      	b.n	8021b06 <__ssvfiscanf_r+0x6d2>
 8021d88:	f8ca 0000 	str.w	r0, [sl]
 8021d8c:	f8cd c01c 	str.w	ip, [sp, #28]
 8021d90:	f000 f868 	bl	8021e64 <iswspace>
 8021d94:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8021d98:	b198      	cbz	r0, 8021dc2 <__ssvfiscanf_r+0x98e>
 8021d9a:	46e1      	mov	r9, ip
 8021d9c:	f1bc 0f00 	cmp.w	ip, #0
 8021da0:	f43f aeb1 	beq.w	8021b06 <__ssvfiscanf_r+0x6d2>
 8021da4:	ab10      	add	r3, sp, #64	; 0x40
 8021da6:	eb03 060c 	add.w	r6, r3, ip
 8021daa:	f109 39ff 	add.w	r9, r9, #4294967295
 8021dae:	4640      	mov	r0, r8
 8021db0:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 8021db4:	4622      	mov	r2, r4
 8021db6:	f7ff fa9b 	bl	80212f0 <_sungetc_r>
 8021dba:	f1b9 0f00 	cmp.w	r9, #0
 8021dbe:	d1f4      	bne.n	8021daa <__ssvfiscanf_r+0x976>
 8021dc0:	e6a1      	b.n	8021b06 <__ssvfiscanf_r+0x6d2>
 8021dc2:	9b03      	ldr	r3, [sp, #12]
 8021dc4:	4465      	add	r5, ip
 8021dc6:	3e01      	subs	r6, #1
 8021dc8:	b91b      	cbnz	r3, 8021dd2 <__ssvfiscanf_r+0x99e>
 8021dca:	f10a 0a04 	add.w	sl, sl, #4
 8021dce:	4699      	mov	r9, r3
 8021dd0:	e7ca      	b.n	8021d68 <__ssvfiscanf_r+0x934>
 8021dd2:	4681      	mov	r9, r0
 8021dd4:	e7c8      	b.n	8021d68 <__ssvfiscanf_r+0x934>
 8021dd6:	f000 fa71 	bl	80222bc <_strtoull_r>
 8021dda:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8021dde:	e796      	b.n	8021d0e <__ssvfiscanf_r+0x8da>
 8021de0:	f8da 0000 	ldr.w	r0, [sl]
 8021de4:	e7d2      	b.n	8021d8c <__ssvfiscanf_r+0x958>
 8021de6:	bf00      	nop
 8021de8:	08020619 	.word	0x08020619

08021dec <__submore>:
 8021dec:	f101 0340 	add.w	r3, r1, #64	; 0x40
 8021df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021df4:	460c      	mov	r4, r1
 8021df6:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8021df8:	4299      	cmp	r1, r3
 8021dfa:	d014      	beq.n	8021e26 <__submore+0x3a>
 8021dfc:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8021dfe:	0077      	lsls	r7, r6, #1
 8021e00:	463a      	mov	r2, r7
 8021e02:	f7f3 fff3 	bl	8015dec <_realloc_r>
 8021e06:	4605      	mov	r5, r0
 8021e08:	b340      	cbz	r0, 8021e5c <__submore+0x70>
 8021e0a:	eb00 0806 	add.w	r8, r0, r6
 8021e0e:	4632      	mov	r2, r6
 8021e10:	4640      	mov	r0, r8
 8021e12:	4629      	mov	r1, r5
 8021e14:	f7de fa62 	bl	80002dc <memcpy>
 8021e18:	f8c4 8000 	str.w	r8, [r4]
 8021e1c:	6325      	str	r5, [r4, #48]	; 0x30
 8021e1e:	6367      	str	r7, [r4, #52]	; 0x34
 8021e20:	2000      	movs	r0, #0
 8021e22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021e26:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8021e2a:	f7f3 ffcb 	bl	8015dc4 <_malloc_r>
 8021e2e:	b1a8      	cbz	r0, 8021e5c <__submore+0x70>
 8021e30:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8021e34:	6320      	str	r0, [r4, #48]	; 0x30
 8021e36:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8021e3a:	6362      	str	r2, [r4, #52]	; 0x34
 8021e3c:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 8021e40:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8021e44:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 8021e48:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8021e4c:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 8021e50:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 8021e54:	6020      	str	r0, [r4, #0]
 8021e56:	2000      	movs	r0, #0
 8021e58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021e5c:	f04f 30ff 	mov.w	r0, #4294967295
 8021e60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08021e64 <iswspace>:
 8021e64:	28ff      	cmp	r0, #255	; 0xff
 8021e66:	d807      	bhi.n	8021e78 <iswspace+0x14>
 8021e68:	4b04      	ldr	r3, [pc, #16]	; (8021e7c <iswspace+0x18>)
 8021e6a:	681b      	ldr	r3, [r3, #0]
 8021e6c:	4418      	add	r0, r3
 8021e6e:	7840      	ldrb	r0, [r0, #1]
 8021e70:	f000 0008 	and.w	r0, r0, #8
 8021e74:	b2c0      	uxtb	r0, r0
 8021e76:	4770      	bx	lr
 8021e78:	2000      	movs	r0, #0
 8021e7a:	4770      	bx	lr
 8021e7c:	2001010c 	.word	0x2001010c

08021e80 <__locale_charset>:
 8021e80:	4800      	ldr	r0, [pc, #0]	; (8021e84 <__locale_charset+0x4>)
 8021e82:	4770      	bx	lr
 8021e84:	20010584 	.word	0x20010584

08021e88 <__locale_mb_cur_max>:
 8021e88:	4b01      	ldr	r3, [pc, #4]	; (8021e90 <__locale_mb_cur_max+0x8>)
 8021e8a:	6818      	ldr	r0, [r3, #0]
 8021e8c:	4770      	bx	lr
 8021e8e:	bf00      	nop
 8021e90:	200105a4 	.word	0x200105a4

08021e94 <_mbrtowc_r>:
 8021e94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8021e98:	b083      	sub	sp, #12
 8021e9a:	4605      	mov	r5, r0
 8021e9c:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8021e9e:	4614      	mov	r4, r2
 8021ea0:	b1b2      	cbz	r2, 8021ed0 <_mbrtowc_r+0x3c>
 8021ea2:	461f      	mov	r7, r3
 8021ea4:	4b10      	ldr	r3, [pc, #64]	; (8021ee8 <_mbrtowc_r+0x54>)
 8021ea6:	4688      	mov	r8, r1
 8021ea8:	f8d3 9000 	ldr.w	r9, [r3]
 8021eac:	f7ff ffe8 	bl	8021e80 <__locale_charset>
 8021eb0:	4641      	mov	r1, r8
 8021eb2:	e88d 0041 	stmia.w	sp, {r0, r6}
 8021eb6:	4622      	mov	r2, r4
 8021eb8:	463b      	mov	r3, r7
 8021eba:	4628      	mov	r0, r5
 8021ebc:	47c8      	blx	r9
 8021ebe:	1c43      	adds	r3, r0, #1
 8021ec0:	d103      	bne.n	8021eca <_mbrtowc_r+0x36>
 8021ec2:	2200      	movs	r2, #0
 8021ec4:	238a      	movs	r3, #138	; 0x8a
 8021ec6:	6032      	str	r2, [r6, #0]
 8021ec8:	602b      	str	r3, [r5, #0]
 8021eca:	b003      	add	sp, #12
 8021ecc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8021ed0:	4b05      	ldr	r3, [pc, #20]	; (8021ee8 <_mbrtowc_r+0x54>)
 8021ed2:	681f      	ldr	r7, [r3, #0]
 8021ed4:	f7ff ffd4 	bl	8021e80 <__locale_charset>
 8021ed8:	4621      	mov	r1, r4
 8021eda:	e88d 0041 	stmia.w	sp, {r0, r6}
 8021ede:	4a03      	ldr	r2, [pc, #12]	; (8021eec <_mbrtowc_r+0x58>)
 8021ee0:	4628      	mov	r0, r5
 8021ee2:	2301      	movs	r3, #1
 8021ee4:	47b8      	blx	r7
 8021ee6:	e7ea      	b.n	8021ebe <_mbrtowc_r+0x2a>
 8021ee8:	200105a8 	.word	0x200105a8
 8021eec:	08025d64 	.word	0x08025d64

08021ef0 <__ascii_mbtowc>:
 8021ef0:	b082      	sub	sp, #8
 8021ef2:	b149      	cbz	r1, 8021f08 <__ascii_mbtowc+0x18>
 8021ef4:	b15a      	cbz	r2, 8021f0e <__ascii_mbtowc+0x1e>
 8021ef6:	b16b      	cbz	r3, 8021f14 <__ascii_mbtowc+0x24>
 8021ef8:	7813      	ldrb	r3, [r2, #0]
 8021efa:	600b      	str	r3, [r1, #0]
 8021efc:	7812      	ldrb	r2, [r2, #0]
 8021efe:	1c10      	adds	r0, r2, #0
 8021f00:	bf18      	it	ne
 8021f02:	2001      	movne	r0, #1
 8021f04:	b002      	add	sp, #8
 8021f06:	4770      	bx	lr
 8021f08:	a901      	add	r1, sp, #4
 8021f0a:	2a00      	cmp	r2, #0
 8021f0c:	d1f3      	bne.n	8021ef6 <__ascii_mbtowc+0x6>
 8021f0e:	4610      	mov	r0, r2
 8021f10:	b002      	add	sp, #8
 8021f12:	4770      	bx	lr
 8021f14:	f06f 0001 	mvn.w	r0, #1
 8021f18:	e7f4      	b.n	8021f04 <__ascii_mbtowc+0x14>
 8021f1a:	bf00      	nop

08021f1c <memchr>:
 8021f1c:	0783      	lsls	r3, r0, #30
 8021f1e:	b470      	push	{r4, r5, r6}
 8021f20:	b2c9      	uxtb	r1, r1
 8021f22:	d040      	beq.n	8021fa6 <memchr+0x8a>
 8021f24:	1e54      	subs	r4, r2, #1
 8021f26:	2a00      	cmp	r2, #0
 8021f28:	d03f      	beq.n	8021faa <memchr+0x8e>
 8021f2a:	7803      	ldrb	r3, [r0, #0]
 8021f2c:	428b      	cmp	r3, r1
 8021f2e:	bf18      	it	ne
 8021f30:	1c43      	addne	r3, r0, #1
 8021f32:	d106      	bne.n	8021f42 <memchr+0x26>
 8021f34:	e01d      	b.n	8021f72 <memchr+0x56>
 8021f36:	b1f4      	cbz	r4, 8021f76 <memchr+0x5a>
 8021f38:	7802      	ldrb	r2, [r0, #0]
 8021f3a:	428a      	cmp	r2, r1
 8021f3c:	f104 34ff 	add.w	r4, r4, #4294967295
 8021f40:	d017      	beq.n	8021f72 <memchr+0x56>
 8021f42:	f013 0f03 	tst.w	r3, #3
 8021f46:	4618      	mov	r0, r3
 8021f48:	f103 0301 	add.w	r3, r3, #1
 8021f4c:	d1f3      	bne.n	8021f36 <memchr+0x1a>
 8021f4e:	2c03      	cmp	r4, #3
 8021f50:	d814      	bhi.n	8021f7c <memchr+0x60>
 8021f52:	b184      	cbz	r4, 8021f76 <memchr+0x5a>
 8021f54:	7803      	ldrb	r3, [r0, #0]
 8021f56:	428b      	cmp	r3, r1
 8021f58:	d00b      	beq.n	8021f72 <memchr+0x56>
 8021f5a:	1905      	adds	r5, r0, r4
 8021f5c:	1c43      	adds	r3, r0, #1
 8021f5e:	e002      	b.n	8021f66 <memchr+0x4a>
 8021f60:	7802      	ldrb	r2, [r0, #0]
 8021f62:	428a      	cmp	r2, r1
 8021f64:	d005      	beq.n	8021f72 <memchr+0x56>
 8021f66:	42ab      	cmp	r3, r5
 8021f68:	4618      	mov	r0, r3
 8021f6a:	f103 0301 	add.w	r3, r3, #1
 8021f6e:	d1f7      	bne.n	8021f60 <memchr+0x44>
 8021f70:	2000      	movs	r0, #0
 8021f72:	bc70      	pop	{r4, r5, r6}
 8021f74:	4770      	bx	lr
 8021f76:	4620      	mov	r0, r4
 8021f78:	bc70      	pop	{r4, r5, r6}
 8021f7a:	4770      	bx	lr
 8021f7c:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8021f80:	4602      	mov	r2, r0
 8021f82:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8021f86:	4610      	mov	r0, r2
 8021f88:	3204      	adds	r2, #4
 8021f8a:	6803      	ldr	r3, [r0, #0]
 8021f8c:	4073      	eors	r3, r6
 8021f8e:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 8021f92:	ea25 0303 	bic.w	r3, r5, r3
 8021f96:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8021f9a:	d1da      	bne.n	8021f52 <memchr+0x36>
 8021f9c:	3c04      	subs	r4, #4
 8021f9e:	2c03      	cmp	r4, #3
 8021fa0:	4610      	mov	r0, r2
 8021fa2:	d8f0      	bhi.n	8021f86 <memchr+0x6a>
 8021fa4:	e7d5      	b.n	8021f52 <memchr+0x36>
 8021fa6:	4614      	mov	r4, r2
 8021fa8:	e7d1      	b.n	8021f4e <memchr+0x32>
 8021faa:	4610      	mov	r0, r2
 8021fac:	e7e1      	b.n	8021f72 <memchr+0x56>
 8021fae:	bf00      	nop

08021fb0 <memmove>:
 8021fb0:	4288      	cmp	r0, r1
 8021fb2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021fb4:	d90d      	bls.n	8021fd2 <memmove+0x22>
 8021fb6:	188b      	adds	r3, r1, r2
 8021fb8:	4298      	cmp	r0, r3
 8021fba:	d20a      	bcs.n	8021fd2 <memmove+0x22>
 8021fbc:	1881      	adds	r1, r0, r2
 8021fbe:	2a00      	cmp	r2, #0
 8021fc0:	d054      	beq.n	802206c <memmove+0xbc>
 8021fc2:	1a9a      	subs	r2, r3, r2
 8021fc4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8021fc8:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8021fcc:	4293      	cmp	r3, r2
 8021fce:	d1f9      	bne.n	8021fc4 <memmove+0x14>
 8021fd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021fd2:	2a0f      	cmp	r2, #15
 8021fd4:	d948      	bls.n	8022068 <memmove+0xb8>
 8021fd6:	ea40 0301 	orr.w	r3, r0, r1
 8021fda:	079b      	lsls	r3, r3, #30
 8021fdc:	d147      	bne.n	802206e <memmove+0xbe>
 8021fde:	f100 0410 	add.w	r4, r0, #16
 8021fe2:	f101 0310 	add.w	r3, r1, #16
 8021fe6:	4615      	mov	r5, r2
 8021fe8:	f853 6c10 	ldr.w	r6, [r3, #-16]
 8021fec:	f844 6c10 	str.w	r6, [r4, #-16]
 8021ff0:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 8021ff4:	f844 6c0c 	str.w	r6, [r4, #-12]
 8021ff8:	f853 6c08 	ldr.w	r6, [r3, #-8]
 8021ffc:	f844 6c08 	str.w	r6, [r4, #-8]
 8022000:	3d10      	subs	r5, #16
 8022002:	f853 6c04 	ldr.w	r6, [r3, #-4]
 8022006:	f844 6c04 	str.w	r6, [r4, #-4]
 802200a:	2d0f      	cmp	r5, #15
 802200c:	f103 0310 	add.w	r3, r3, #16
 8022010:	f104 0410 	add.w	r4, r4, #16
 8022014:	d8e8      	bhi.n	8021fe8 <memmove+0x38>
 8022016:	f1a2 0310 	sub.w	r3, r2, #16
 802201a:	f023 030f 	bic.w	r3, r3, #15
 802201e:	f002 0e0f 	and.w	lr, r2, #15
 8022022:	3310      	adds	r3, #16
 8022024:	f1be 0f03 	cmp.w	lr, #3
 8022028:	4419      	add	r1, r3
 802202a:	4403      	add	r3, r0
 802202c:	d921      	bls.n	8022072 <memmove+0xc2>
 802202e:	1f1e      	subs	r6, r3, #4
 8022030:	460d      	mov	r5, r1
 8022032:	4674      	mov	r4, lr
 8022034:	3c04      	subs	r4, #4
 8022036:	f855 7b04 	ldr.w	r7, [r5], #4
 802203a:	f846 7f04 	str.w	r7, [r6, #4]!
 802203e:	2c03      	cmp	r4, #3
 8022040:	d8f8      	bhi.n	8022034 <memmove+0x84>
 8022042:	f1ae 0404 	sub.w	r4, lr, #4
 8022046:	f024 0403 	bic.w	r4, r4, #3
 802204a:	3404      	adds	r4, #4
 802204c:	4423      	add	r3, r4
 802204e:	4421      	add	r1, r4
 8022050:	f002 0203 	and.w	r2, r2, #3
 8022054:	b152      	cbz	r2, 802206c <memmove+0xbc>
 8022056:	3b01      	subs	r3, #1
 8022058:	440a      	add	r2, r1
 802205a:	f811 4b01 	ldrb.w	r4, [r1], #1
 802205e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8022062:	4291      	cmp	r1, r2
 8022064:	d1f9      	bne.n	802205a <memmove+0xaa>
 8022066:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022068:	4603      	mov	r3, r0
 802206a:	e7f3      	b.n	8022054 <memmove+0xa4>
 802206c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802206e:	4603      	mov	r3, r0
 8022070:	e7f1      	b.n	8022056 <memmove+0xa6>
 8022072:	4672      	mov	r2, lr
 8022074:	e7ee      	b.n	8022054 <memmove+0xa4>
 8022076:	bf00      	nop

08022078 <__sccl>:
 8022078:	b470      	push	{r4, r5, r6}
 802207a:	780d      	ldrb	r5, [r1, #0]
 802207c:	2d5e      	cmp	r5, #94	; 0x5e
 802207e:	d02f      	beq.n	80220e0 <__sccl+0x68>
 8022080:	2200      	movs	r2, #0
 8022082:	3101      	adds	r1, #1
 8022084:	4616      	mov	r6, r2
 8022086:	1e43      	subs	r3, r0, #1
 8022088:	f100 04ff 	add.w	r4, r0, #255	; 0xff
 802208c:	f803 2f01 	strb.w	r2, [r3, #1]!
 8022090:	42a3      	cmp	r3, r4
 8022092:	d1fb      	bne.n	802208c <__sccl+0x14>
 8022094:	b185      	cbz	r5, 80220b8 <__sccl+0x40>
 8022096:	f086 0201 	eor.w	r2, r6, #1
 802209a:	5542      	strb	r2, [r0, r5]
 802209c:	1c4e      	adds	r6, r1, #1
 802209e:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 80220a2:	2b2d      	cmp	r3, #45	; 0x2d
 80220a4:	d00e      	beq.n	80220c4 <__sccl+0x4c>
 80220a6:	2b5d      	cmp	r3, #93	; 0x5d
 80220a8:	d009      	beq.n	80220be <__sccl+0x46>
 80220aa:	b113      	cbz	r3, 80220b2 <__sccl+0x3a>
 80220ac:	461d      	mov	r5, r3
 80220ae:	4631      	mov	r1, r6
 80220b0:	e7f3      	b.n	802209a <__sccl+0x22>
 80220b2:	4608      	mov	r0, r1
 80220b4:	bc70      	pop	{r4, r5, r6}
 80220b6:	4770      	bx	lr
 80220b8:	1e48      	subs	r0, r1, #1
 80220ba:	bc70      	pop	{r4, r5, r6}
 80220bc:	4770      	bx	lr
 80220be:	4630      	mov	r0, r6
 80220c0:	bc70      	pop	{r4, r5, r6}
 80220c2:	4770      	bx	lr
 80220c4:	784c      	ldrb	r4, [r1, #1]
 80220c6:	2c5d      	cmp	r4, #93	; 0x5d
 80220c8:	d00f      	beq.n	80220ea <__sccl+0x72>
 80220ca:	42a5      	cmp	r5, r4
 80220cc:	dc0d      	bgt.n	80220ea <__sccl+0x72>
 80220ce:	3102      	adds	r1, #2
 80220d0:	1943      	adds	r3, r0, r5
 80220d2:	3501      	adds	r5, #1
 80220d4:	42ac      	cmp	r4, r5
 80220d6:	f803 2f01 	strb.w	r2, [r3, #1]!
 80220da:	dcfa      	bgt.n	80220d2 <__sccl+0x5a>
 80220dc:	3602      	adds	r6, #2
 80220de:	e7de      	b.n	802209e <__sccl+0x26>
 80220e0:	2201      	movs	r2, #1
 80220e2:	784d      	ldrb	r5, [r1, #1]
 80220e4:	4616      	mov	r6, r2
 80220e6:	3102      	adds	r1, #2
 80220e8:	e7cd      	b.n	8022086 <__sccl+0xe>
 80220ea:	4631      	mov	r1, r6
 80220ec:	461d      	mov	r5, r3
 80220ee:	e7d4      	b.n	802209a <__sccl+0x22>

080220f0 <_strtoll_r>:
 80220f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80220f4:	4c70      	ldr	r4, [pc, #448]	; (80222b8 <_strtoll_r+0x1c8>)
 80220f6:	b087      	sub	sp, #28
 80220f8:	469b      	mov	fp, r3
 80220fa:	9201      	str	r2, [sp, #4]
 80220fc:	9104      	str	r1, [sp, #16]
 80220fe:	9005      	str	r0, [sp, #20]
 8022100:	460a      	mov	r2, r1
 8022102:	f8d4 a000 	ldr.w	sl, [r4]
 8022106:	e000      	b.n	802210a <_strtoll_r+0x1a>
 8022108:	462a      	mov	r2, r5
 802210a:	4615      	mov	r5, r2
 802210c:	f815 4b01 	ldrb.w	r4, [r5], #1
 8022110:	eb0a 0304 	add.w	r3, sl, r4
 8022114:	785b      	ldrb	r3, [r3, #1]
 8022116:	f003 0308 	and.w	r3, r3, #8
 802211a:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 802211e:	2b00      	cmp	r3, #0
 8022120:	d1f2      	bne.n	8022108 <_strtoll_r+0x18>
 8022122:	2c2d      	cmp	r4, #45	; 0x2d
 8022124:	f000 8092 	beq.w	802224c <_strtoll_r+0x15c>
 8022128:	2c2b      	cmp	r4, #43	; 0x2b
 802212a:	bf08      	it	eq
 802212c:	7854      	ldrbeq	r4, [r2, #1]
 802212e:	468c      	mov	ip, r1
 8022130:	bf08      	it	eq
 8022132:	1c95      	addeq	r5, r2, #2
 8022134:	f1bb 0f00 	cmp.w	fp, #0
 8022138:	d071      	beq.n	802221e <_strtoll_r+0x12e>
 802213a:	f1bb 0f10 	cmp.w	fp, #16
 802213e:	f000 80a2 	beq.w	8022286 <_strtoll_r+0x196>
 8022142:	465e      	mov	r6, fp
 8022144:	17f7      	asrs	r7, r6, #31
 8022146:	f1bc 0f00 	cmp.w	ip, #0
 802214a:	d171      	bne.n	8022230 <_strtoll_r+0x140>
 802214c:	f04f 38ff 	mov.w	r8, #4294967295
 8022150:	f06f 4900 	mvn.w	r9, #2147483648	; 0x80000000
 8022154:	4640      	mov	r0, r8
 8022156:	4649      	mov	r1, r9
 8022158:	4632      	mov	r2, r6
 802215a:	463b      	mov	r3, r7
 802215c:	f8cd c00c 	str.w	ip, [sp, #12]
 8022160:	f7de ff40 	bl	8000fe4 <__aeabi_uldivmod>
 8022164:	4640      	mov	r0, r8
 8022166:	9202      	str	r2, [sp, #8]
 8022168:	463b      	mov	r3, r7
 802216a:	4632      	mov	r2, r6
 802216c:	4649      	mov	r1, r9
 802216e:	f7de ff39 	bl	8000fe4 <__aeabi_uldivmod>
 8022172:	f04f 0e00 	mov.w	lr, #0
 8022176:	2200      	movs	r2, #0
 8022178:	2300      	movs	r3, #0
 802217a:	f8dd c00c 	ldr.w	ip, [sp, #12]
 802217e:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8022182:	e01b      	b.n	80221bc <_strtoll_r+0xcc>
 8022184:	3c30      	subs	r4, #48	; 0x30
 8022186:	45a3      	cmp	fp, r4
 8022188:	dd2d      	ble.n	80221e6 <_strtoll_r+0xf6>
 802218a:	f1be 3fff 	cmp.w	lr, #4294967295
 802218e:	d013      	beq.n	80221b8 <_strtoll_r+0xc8>
 8022190:	4299      	cmp	r1, r3
 8022192:	bf08      	it	eq
 8022194:	4290      	cmpeq	r0, r2
 8022196:	d352      	bcc.n	802223e <_strtoll_r+0x14e>
 8022198:	428b      	cmp	r3, r1
 802219a:	bf08      	it	eq
 802219c:	4282      	cmpeq	r2, r0
 802219e:	d04c      	beq.n	802223a <_strtoll_r+0x14a>
 80221a0:	fb02 fe07 	mul.w	lr, r2, r7
 80221a4:	fb06 ee03 	mla	lr, r6, r3, lr
 80221a8:	fba2 2306 	umull	r2, r3, r2, r6
 80221ac:	4473      	add	r3, lr
 80221ae:	1912      	adds	r2, r2, r4
 80221b0:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
 80221b4:	f04f 0e01 	mov.w	lr, #1
 80221b8:	f815 4b01 	ldrb.w	r4, [r5], #1
 80221bc:	eb0a 0904 	add.w	r9, sl, r4
 80221c0:	f899 9001 	ldrb.w	r9, [r9, #1]
 80221c4:	f019 0f04 	tst.w	r9, #4
 80221c8:	d1dc      	bne.n	8022184 <_strtoll_r+0x94>
 80221ca:	f019 0903 	ands.w	r9, r9, #3
 80221ce:	d00a      	beq.n	80221e6 <_strtoll_r+0xf6>
 80221d0:	f1b9 0f01 	cmp.w	r9, #1
 80221d4:	bf0c      	ite	eq
 80221d6:	f04f 0937 	moveq.w	r9, #55	; 0x37
 80221da:	f04f 0957 	movne.w	r9, #87	; 0x57
 80221de:	ebc9 0404 	rsb	r4, r9, r4
 80221e2:	45a3      	cmp	fp, r4
 80221e4:	dcd1      	bgt.n	802218a <_strtoll_r+0x9a>
 80221e6:	f1be 3fff 	cmp.w	lr, #4294967295
 80221ea:	d034      	beq.n	8022256 <_strtoll_r+0x166>
 80221ec:	4660      	mov	r0, ip
 80221ee:	17c1      	asrs	r1, r0, #31
 80221f0:	f1dc 0600 	rsbs	r6, ip, #0
 80221f4:	eb61 0741 	sbc.w	r7, r1, r1, lsl #1
 80221f8:	4072      	eors	r2, r6
 80221fa:	407b      	eors	r3, r7
 80221fc:	eb12 020c 	adds.w	r2, r2, ip
 8022200:	414b      	adcs	r3, r1
 8022202:	9901      	ldr	r1, [sp, #4]
 8022204:	2900      	cmp	r1, #0
 8022206:	d053      	beq.n	80222b0 <_strtoll_r+0x1c0>
 8022208:	f1be 0f00 	cmp.w	lr, #0
 802220c:	d11a      	bne.n	8022244 <_strtoll_r+0x154>
 802220e:	9d04      	ldr	r5, [sp, #16]
 8022210:	4610      	mov	r0, r2
 8022212:	4619      	mov	r1, r3
 8022214:	9b01      	ldr	r3, [sp, #4]
 8022216:	601d      	str	r5, [r3, #0]
 8022218:	b007      	add	sp, #28
 802221a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802221e:	2c30      	cmp	r4, #48	; 0x30
 8022220:	d027      	beq.n	8022272 <_strtoll_r+0x182>
 8022222:	260a      	movs	r6, #10
 8022224:	2700      	movs	r7, #0
 8022226:	f04f 0b0a 	mov.w	fp, #10
 802222a:	f1bc 0f00 	cmp.w	ip, #0
 802222e:	d08d      	beq.n	802214c <_strtoll_r+0x5c>
 8022230:	f04f 0800 	mov.w	r8, #0
 8022234:	f04f 4900 	mov.w	r9, #2147483648	; 0x80000000
 8022238:	e78c      	b.n	8022154 <_strtoll_r+0x64>
 802223a:	4544      	cmp	r4, r8
 802223c:	ddb0      	ble.n	80221a0 <_strtoll_r+0xb0>
 802223e:	f04f 3eff 	mov.w	lr, #4294967295
 8022242:	e7b9      	b.n	80221b8 <_strtoll_r+0xc8>
 8022244:	4610      	mov	r0, r2
 8022246:	4619      	mov	r1, r3
 8022248:	3d01      	subs	r5, #1
 802224a:	e7e3      	b.n	8022214 <_strtoll_r+0x124>
 802224c:	1c95      	adds	r5, r2, #2
 802224e:	7854      	ldrb	r4, [r2, #1]
 8022250:	f04f 0c01 	mov.w	ip, #1
 8022254:	e76e      	b.n	8022134 <_strtoll_r+0x44>
 8022256:	f1bc 0f00 	cmp.w	ip, #0
 802225a:	d119      	bne.n	8022290 <_strtoll_r+0x1a0>
 802225c:	f04f 30ff 	mov.w	r0, #4294967295
 8022260:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8022264:	9a05      	ldr	r2, [sp, #20]
 8022266:	2322      	movs	r3, #34	; 0x22
 8022268:	6013      	str	r3, [r2, #0]
 802226a:	9b01      	ldr	r3, [sp, #4]
 802226c:	2b00      	cmp	r3, #0
 802226e:	d1eb      	bne.n	8022248 <_strtoll_r+0x158>
 8022270:	e7d2      	b.n	8022218 <_strtoll_r+0x128>
 8022272:	782b      	ldrb	r3, [r5, #0]
 8022274:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8022278:	2b58      	cmp	r3, #88	; 0x58
 802227a:	d012      	beq.n	80222a2 <_strtoll_r+0x1b2>
 802227c:	2608      	movs	r6, #8
 802227e:	2700      	movs	r7, #0
 8022280:	f04f 0b08 	mov.w	fp, #8
 8022284:	e75f      	b.n	8022146 <_strtoll_r+0x56>
 8022286:	2c30      	cmp	r4, #48	; 0x30
 8022288:	d006      	beq.n	8022298 <_strtoll_r+0x1a8>
 802228a:	2610      	movs	r6, #16
 802228c:	2700      	movs	r7, #0
 802228e:	e75a      	b.n	8022146 <_strtoll_r+0x56>
 8022290:	2000      	movs	r0, #0
 8022292:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8022296:	e7e5      	b.n	8022264 <_strtoll_r+0x174>
 8022298:	782b      	ldrb	r3, [r5, #0]
 802229a:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 802229e:	2b58      	cmp	r3, #88	; 0x58
 80222a0:	d1f3      	bne.n	802228a <_strtoll_r+0x19a>
 80222a2:	786c      	ldrb	r4, [r5, #1]
 80222a4:	2610      	movs	r6, #16
 80222a6:	2700      	movs	r7, #0
 80222a8:	3502      	adds	r5, #2
 80222aa:	f04f 0b10 	mov.w	fp, #16
 80222ae:	e74a      	b.n	8022146 <_strtoll_r+0x56>
 80222b0:	4610      	mov	r0, r2
 80222b2:	4619      	mov	r1, r3
 80222b4:	e7b0      	b.n	8022218 <_strtoll_r+0x128>
 80222b6:	bf00      	nop
 80222b8:	2001010c 	.word	0x2001010c

080222bc <_strtoull_r>:
 80222bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80222c0:	4c72      	ldr	r4, [pc, #456]	; (802248c <_strtoull_r+0x1d0>)
 80222c2:	b087      	sub	sp, #28
 80222c4:	4692      	mov	sl, r2
 80222c6:	468b      	mov	fp, r1
 80222c8:	9004      	str	r0, [sp, #16]
 80222ca:	4699      	mov	r9, r3
 80222cc:	460a      	mov	r2, r1
 80222ce:	f8d4 8000 	ldr.w	r8, [r4]
 80222d2:	e000      	b.n	80222d6 <_strtoull_r+0x1a>
 80222d4:	462a      	mov	r2, r5
 80222d6:	4615      	mov	r5, r2
 80222d8:	f815 4b01 	ldrb.w	r4, [r5], #1
 80222dc:	eb08 0304 	add.w	r3, r8, r4
 80222e0:	785b      	ldrb	r3, [r3, #1]
 80222e2:	f003 0308 	and.w	r3, r3, #8
 80222e6:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80222ea:	2b00      	cmp	r3, #0
 80222ec:	d1f2      	bne.n	80222d4 <_strtoull_r+0x18>
 80222ee:	2c2d      	cmp	r4, #45	; 0x2d
 80222f0:	f000 8099 	beq.w	8022426 <_strtoull_r+0x16a>
 80222f4:	2c2b      	cmp	r4, #43	; 0x2b
 80222f6:	bf08      	it	eq
 80222f8:	7854      	ldrbeq	r4, [r2, #1]
 80222fa:	9003      	str	r0, [sp, #12]
 80222fc:	bf08      	it	eq
 80222fe:	1c95      	addeq	r5, r2, #2
 8022300:	f1b9 0f00 	cmp.w	r9, #0
 8022304:	d01d      	beq.n	8022342 <_strtoull_r+0x86>
 8022306:	f1b9 0f10 	cmp.w	r9, #16
 802230a:	f000 80a1 	beq.w	8022450 <_strtoull_r+0x194>
 802230e:	464e      	mov	r6, r9
 8022310:	17f7      	asrs	r7, r6, #31
 8022312:	464a      	mov	r2, r9
 8022314:	463b      	mov	r3, r7
 8022316:	f04f 30ff 	mov.w	r0, #4294967295
 802231a:	f04f 31ff 	mov.w	r1, #4294967295
 802231e:	f7de fe61 	bl	8000fe4 <__aeabi_uldivmod>
 8022322:	464a      	mov	r2, r9
 8022324:	9005      	str	r0, [sp, #20]
 8022326:	9100      	str	r1, [sp, #0]
 8022328:	463b      	mov	r3, r7
 802232a:	f04f 30ff 	mov.w	r0, #4294967295
 802232e:	f04f 31ff 	mov.w	r1, #4294967295
 8022332:	f7de fe57 	bl	8000fe4 <__aeabi_uldivmod>
 8022336:	f8dd c014 	ldr.w	ip, [sp, #20]
 802233a:	9202      	str	r2, [sp, #8]
 802233c:	4660      	mov	r0, ip
 802233e:	9900      	ldr	r1, [sp, #0]
 8022340:	e00a      	b.n	8022358 <_strtoull_r+0x9c>
 8022342:	2c30      	cmp	r4, #48	; 0x30
 8022344:	d074      	beq.n	8022430 <_strtoull_r+0x174>
 8022346:	2305      	movs	r3, #5
 8022348:	4951      	ldr	r1, [pc, #324]	; (8022490 <_strtoull_r+0x1d4>)
 802234a:	9302      	str	r3, [sp, #8]
 802234c:	f04f 3099 	mov.w	r0, #2576980377	; 0x99999999
 8022350:	260a      	movs	r6, #10
 8022352:	2700      	movs	r7, #0
 8022354:	f04f 090a 	mov.w	r9, #10
 8022358:	f04f 0e00 	mov.w	lr, #0
 802235c:	2200      	movs	r2, #0
 802235e:	2300      	movs	r3, #0
 8022360:	e9cd 6700 	strd	r6, r7, [sp]
 8022364:	e01d      	b.n	80223a2 <_strtoull_r+0xe6>
 8022366:	3c30      	subs	r4, #48	; 0x30
 8022368:	45a1      	cmp	r9, r4
 802236a:	dd2f      	ble.n	80223cc <_strtoull_r+0x110>
 802236c:	f1be 3fff 	cmp.w	lr, #4294967295
 8022370:	d015      	beq.n	802239e <_strtoull_r+0xe2>
 8022372:	4299      	cmp	r1, r3
 8022374:	bf08      	it	eq
 8022376:	4290      	cmpeq	r0, r2
 8022378:	d348      	bcc.n	802240c <_strtoull_r+0x150>
 802237a:	428b      	cmp	r3, r1
 802237c:	bf08      	it	eq
 802237e:	4282      	cmpeq	r2, r0
 8022380:	d041      	beq.n	8022406 <_strtoull_r+0x14a>
 8022382:	9e01      	ldr	r6, [sp, #4]
 8022384:	fb02 fe06 	mul.w	lr, r2, r6
 8022388:	9e00      	ldr	r6, [sp, #0]
 802238a:	fb06 ee03 	mla	lr, r6, r3, lr
 802238e:	fba2 2306 	umull	r2, r3, r2, r6
 8022392:	4473      	add	r3, lr
 8022394:	1912      	adds	r2, r2, r4
 8022396:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
 802239a:	f04f 0e01 	mov.w	lr, #1
 802239e:	f815 4b01 	ldrb.w	r4, [r5], #1
 80223a2:	eb08 0c04 	add.w	ip, r8, r4
 80223a6:	f89c c001 	ldrb.w	ip, [ip, #1]
 80223aa:	f01c 0f04 	tst.w	ip, #4
 80223ae:	d1da      	bne.n	8022366 <_strtoull_r+0xaa>
 80223b0:	f01c 0c03 	ands.w	ip, ip, #3
 80223b4:	d00a      	beq.n	80223cc <_strtoull_r+0x110>
 80223b6:	f1bc 0f01 	cmp.w	ip, #1
 80223ba:	bf0c      	ite	eq
 80223bc:	f04f 0c37 	moveq.w	ip, #55	; 0x37
 80223c0:	f04f 0c57 	movne.w	ip, #87	; 0x57
 80223c4:	ebcc 0404 	rsb	r4, ip, r4
 80223c8:	45a1      	cmp	r9, r4
 80223ca:	dccf      	bgt.n	802236c <_strtoull_r+0xb0>
 80223cc:	f1be 0f00 	cmp.w	lr, #0
 80223d0:	db21      	blt.n	8022416 <_strtoull_r+0x15a>
 80223d2:	9903      	ldr	r1, [sp, #12]
 80223d4:	460e      	mov	r6, r1
 80223d6:	4276      	negs	r6, r6
 80223d8:	ea4f 77e1 	mov.w	r7, r1, asr #31
 80223dc:	4608      	mov	r0, r1
 80223de:	ea82 0206 	eor.w	r2, r2, r6
 80223e2:	4639      	mov	r1, r7
 80223e4:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 80223e8:	407b      	eors	r3, r7
 80223ea:	1880      	adds	r0, r0, r2
 80223ec:	4159      	adcs	r1, r3
 80223ee:	f1ba 0f00 	cmp.w	sl, #0
 80223f2:	d005      	beq.n	8022400 <_strtoull_r+0x144>
 80223f4:	f1be 0f00 	cmp.w	lr, #0
 80223f8:	d00b      	beq.n	8022412 <_strtoull_r+0x156>
 80223fa:	3d01      	subs	r5, #1
 80223fc:	f8ca 5000 	str.w	r5, [sl]
 8022400:	b007      	add	sp, #28
 8022402:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022406:	9e02      	ldr	r6, [sp, #8]
 8022408:	42b4      	cmp	r4, r6
 802240a:	ddba      	ble.n	8022382 <_strtoull_r+0xc6>
 802240c:	f04f 3eff 	mov.w	lr, #4294967295
 8022410:	e7c5      	b.n	802239e <_strtoull_r+0xe2>
 8022412:	465d      	mov	r5, fp
 8022414:	e7f2      	b.n	80223fc <_strtoull_r+0x140>
 8022416:	9a04      	ldr	r2, [sp, #16]
 8022418:	2322      	movs	r3, #34	; 0x22
 802241a:	6013      	str	r3, [r2, #0]
 802241c:	f04f 30ff 	mov.w	r0, #4294967295
 8022420:	f04f 31ff 	mov.w	r1, #4294967295
 8022424:	e7e3      	b.n	80223ee <_strtoull_r+0x132>
 8022426:	2301      	movs	r3, #1
 8022428:	1c95      	adds	r5, r2, #2
 802242a:	7854      	ldrb	r4, [r2, #1]
 802242c:	9303      	str	r3, [sp, #12]
 802242e:	e767      	b.n	8022300 <_strtoull_r+0x44>
 8022430:	782b      	ldrb	r3, [r5, #0]
 8022432:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8022436:	2b58      	cmp	r3, #88	; 0x58
 8022438:	d01a      	beq.n	8022470 <_strtoull_r+0x1b4>
 802243a:	2307      	movs	r3, #7
 802243c:	9302      	str	r3, [sp, #8]
 802243e:	f04f 30ff 	mov.w	r0, #4294967295
 8022442:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
 8022446:	2608      	movs	r6, #8
 8022448:	2700      	movs	r7, #0
 802244a:	f04f 0908 	mov.w	r9, #8
 802244e:	e783      	b.n	8022358 <_strtoull_r+0x9c>
 8022450:	2c30      	cmp	r4, #48	; 0x30
 8022452:	d008      	beq.n	8022466 <_strtoull_r+0x1aa>
 8022454:	230f      	movs	r3, #15
 8022456:	9302      	str	r3, [sp, #8]
 8022458:	f04f 30ff 	mov.w	r0, #4294967295
 802245c:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 8022460:	2610      	movs	r6, #16
 8022462:	2700      	movs	r7, #0
 8022464:	e778      	b.n	8022358 <_strtoull_r+0x9c>
 8022466:	782b      	ldrb	r3, [r5, #0]
 8022468:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 802246c:	2b58      	cmp	r3, #88	; 0x58
 802246e:	d1f1      	bne.n	8022454 <_strtoull_r+0x198>
 8022470:	230f      	movs	r3, #15
 8022472:	9302      	str	r3, [sp, #8]
 8022474:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 8022478:	786c      	ldrb	r4, [r5, #1]
 802247a:	9300      	str	r3, [sp, #0]
 802247c:	3502      	adds	r5, #2
 802247e:	f04f 3cff 	mov.w	ip, #4294967295
 8022482:	2610      	movs	r6, #16
 8022484:	2700      	movs	r7, #0
 8022486:	f04f 0910 	mov.w	r9, #16
 802248a:	e757      	b.n	802233c <_strtoull_r+0x80>
 802248c:	2001010c 	.word	0x2001010c
 8022490:	19999999 	.word	0x19999999
 8022494:	00000000 	.word	0x00000000

08022498 <ceil>:
 8022498:	ec51 0b10 	vmov	r0, r1, d0
 802249c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80224a0:	f3c1 570a 	ubfx	r7, r1, #20, #11
 80224a4:	f2a7 35ff 	subw	r5, r7, #1023	; 0x3ff
 80224a8:	2d13      	cmp	r5, #19
 80224aa:	460c      	mov	r4, r1
 80224ac:	ee10 3a10 	vmov	r3, s0
 80224b0:	4688      	mov	r8, r1
 80224b2:	4606      	mov	r6, r0
 80224b4:	dc20      	bgt.n	80224f8 <ceil+0x60>
 80224b6:	2d00      	cmp	r5, #0
 80224b8:	db51      	blt.n	802255e <ceil+0xc6>
 80224ba:	4f3b      	ldr	r7, [pc, #236]	; (80225a8 <ceil+0x110>)
 80224bc:	412f      	asrs	r7, r5
 80224be:	ea07 0201 	and.w	r2, r7, r1
 80224c2:	4313      	orrs	r3, r2
 80224c4:	d01d      	beq.n	8022502 <ceil+0x6a>
 80224c6:	a336      	add	r3, pc, #216	; (adr r3, 80225a0 <ceil+0x108>)
 80224c8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80224cc:	f7de f91e 	bl	800070c <__adddf3>
 80224d0:	2200      	movs	r2, #0
 80224d2:	2300      	movs	r3, #0
 80224d4:	f7de fd5c 	bl	8000f90 <__aeabi_dcmpgt>
 80224d8:	b140      	cbz	r0, 80224ec <ceil+0x54>
 80224da:	2c00      	cmp	r4, #0
 80224dc:	dd03      	ble.n	80224e6 <ceil+0x4e>
 80224de:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80224e2:	412b      	asrs	r3, r5
 80224e4:	4498      	add	r8, r3
 80224e6:	ea28 0407 	bic.w	r4, r8, r7
 80224ea:	2600      	movs	r6, #0
 80224ec:	4623      	mov	r3, r4
 80224ee:	4632      	mov	r2, r6
 80224f0:	ec43 2b10 	vmov	d0, r2, r3
 80224f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80224f8:	2d33      	cmp	r5, #51	; 0x33
 80224fa:	dd06      	ble.n	802250a <ceil+0x72>
 80224fc:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 8022500:	d03f      	beq.n	8022582 <ceil+0xea>
 8022502:	ec41 0b10 	vmov	d0, r0, r1
 8022506:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802250a:	f2a7 4313 	subw	r3, r7, #1043	; 0x413
 802250e:	f04f 39ff 	mov.w	r9, #4294967295
 8022512:	fa29 f903 	lsr.w	r9, r9, r3
 8022516:	ea19 0f00 	tst.w	r9, r0
 802251a:	d0f2      	beq.n	8022502 <ceil+0x6a>
 802251c:	a320      	add	r3, pc, #128	; (adr r3, 80225a0 <ceil+0x108>)
 802251e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022522:	f7de f8f3 	bl	800070c <__adddf3>
 8022526:	2200      	movs	r2, #0
 8022528:	2300      	movs	r3, #0
 802252a:	f7de fd31 	bl	8000f90 <__aeabi_dcmpgt>
 802252e:	2800      	cmp	r0, #0
 8022530:	d0dc      	beq.n	80224ec <ceil+0x54>
 8022532:	2c00      	cmp	r4, #0
 8022534:	dd0a      	ble.n	802254c <ceil+0xb4>
 8022536:	2d14      	cmp	r5, #20
 8022538:	d006      	beq.n	8022548 <ceil+0xb0>
 802253a:	f5c7 6786 	rsb	r7, r7, #1072	; 0x430
 802253e:	3703      	adds	r7, #3
 8022540:	2401      	movs	r4, #1
 8022542:	40bc      	lsls	r4, r7
 8022544:	19a6      	adds	r6, r4, r6
 8022546:	d301      	bcc.n	802254c <ceil+0xb4>
 8022548:	f108 0801 	add.w	r8, r8, #1
 802254c:	4644      	mov	r4, r8
 802254e:	ea26 0609 	bic.w	r6, r6, r9
 8022552:	4623      	mov	r3, r4
 8022554:	4632      	mov	r2, r6
 8022556:	ec43 2b10 	vmov	d0, r2, r3
 802255a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802255e:	a310      	add	r3, pc, #64	; (adr r3, 80225a0 <ceil+0x108>)
 8022560:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022564:	f7de f8d2 	bl	800070c <__adddf3>
 8022568:	2200      	movs	r2, #0
 802256a:	2300      	movs	r3, #0
 802256c:	f7de fd10 	bl	8000f90 <__aeabi_dcmpgt>
 8022570:	2800      	cmp	r0, #0
 8022572:	d0bb      	beq.n	80224ec <ceil+0x54>
 8022574:	2c00      	cmp	r4, #0
 8022576:	db0f      	blt.n	8022598 <ceil+0x100>
 8022578:	4326      	orrs	r6, r4
 802257a:	d00b      	beq.n	8022594 <ceil+0xfc>
 802257c:	4c0b      	ldr	r4, [pc, #44]	; (80225ac <ceil+0x114>)
 802257e:	2600      	movs	r6, #0
 8022580:	e7b4      	b.n	80224ec <ceil+0x54>
 8022582:	ee10 2a10 	vmov	r2, s0
 8022586:	460b      	mov	r3, r1
 8022588:	f7de f8c0 	bl	800070c <__adddf3>
 802258c:	ec41 0b10 	vmov	d0, r0, r1
 8022590:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022594:	4634      	mov	r4, r6
 8022596:	e7a9      	b.n	80224ec <ceil+0x54>
 8022598:	2600      	movs	r6, #0
 802259a:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 802259e:	e7a5      	b.n	80224ec <ceil+0x54>
 80225a0:	8800759c 	.word	0x8800759c
 80225a4:	7e37e43c 	.word	0x7e37e43c
 80225a8:	000fffff 	.word	0x000fffff
 80225ac:	3ff00000 	.word	0x3ff00000
 80225b0:	00007874 	.word	0x00007874
 80225b4:	0a0d7325 	.word	0x0a0d7325
 80225b8:	00000000 	.word	0x00000000
 80225bc:	00007872 	.word	0x00007872
 80225c0:	65636572 	.word	0x65636572
 80225c4:	20657669 	.word	0x20657669
 80225c8:	20737472 	.word	0x20737472
 80225cc:	6b636170 	.word	0x6b636170
 80225d0:	20737465 	.word	0x20737465
 80225d4:	6425203d 	.word	0x6425203d
 80225d8:	00000a0d 	.word	0x00000a0d
 80225dc:	6d61620a 	.word	0x6d61620a
 80225e0:	63657220 	.word	0x63657220
 80225e4:	65766965 	.word	0x65766965
 80225e8:	20642520 	.word	0x20642520
 80225ec:	61746164 	.word	0x61746164
 80225f0:	000a0d3a 	.word	0x000a0d3a
 80225f4:	61746144 	.word	0x61746144
 80225f8:	205d305b 	.word	0x205d305b
 80225fc:	6425203d 	.word	0x6425203d
 8022600:	6372202c 	.word	0x6372202c
 8022604:	63617076 	.word	0x63617076
 8022608:	7374656b 	.word	0x7374656b
 802260c:	25203d20 	.word	0x25203d20
 8022610:	000a0d64 	.word	0x000a0d64
 8022614:	2054440a 	.word	0x2054440a
 8022618:	65636572 	.word	0x65636572
 802261c:	20657669 	.word	0x20657669
 8022620:	64206425 	.word	0x64206425
 8022624:	3a617461 	.word	0x3a617461
 8022628:	00000a0d 	.word	0x00000a0d
 802262c:	65636572 	.word	0x65636572
 8022630:	20657669 	.word	0x20657669
 8022634:	4f646e65 	.word	0x4f646e65
 8022638:	67734d66 	.word	0x67734d66
 802263c:	0d6b6341 	.word	0x0d6b6341
 8022640:	0000000a 	.word	0x0000000a
 8022644:	65636572 	.word	0x65636572
 8022648:	20657669 	.word	0x20657669
 802264c:	0d6d6162 	.word	0x0d6d6162
 8022650:	0000000a 	.word	0x0000000a
 8022654:	3339314a 	.word	0x3339314a
 8022658:	6d697439 	.word	0x6d697439
 802265c:	00007265 	.word	0x00007265
 8022660:	316e6163 	.word	0x316e6163
 8022664:	00000000 	.word	0x00000000
 8022668:	63207874 	.word	0x63207874
 802266c:	6c706d6f 	.word	0x6c706d6f
 8022670:	0d657465 	.word	0x0d657465
 8022674:	0000000a 	.word	0x0000000a
 8022678:	64207872 	.word	0x64207872
 802267c:	3a617461 	.word	0x3a617461
 8022680:	00000020 	.word	0x00000020
 8022684:	78257830 	.word	0x78257830
 8022688:	00000020 	.word	0x00000020
 802268c:	00000a0d 	.word	0x00000a0d
 8022690:	20677765 	.word	0x20677765
 8022694:	6f727265 	.word	0x6f727265
 8022698:	000a0d72 	.word	0x000a0d72
 802269c:	20767065 	.word	0x20767065
 80226a0:	6f727265 	.word	0x6f727265
 80226a4:	000a0d72 	.word	0x000a0d72
 80226a8:	20666f62 	.word	0x20666f62
 80226ac:	6f727265 	.word	0x6f727265
 80226b0:	000a0d72 	.word	0x000a0d72
 80226b4:	20667473 	.word	0x20667473
 80226b8:	6f727265 	.word	0x6f727265
 80226bc:	000a0d72 	.word	0x000a0d72
 80226c0:	20726f66 	.word	0x20726f66
 80226c4:	6f727265 	.word	0x6f727265
 80226c8:	000a0d72 	.word	0x000a0d72
 80226cc:	206b6361 	.word	0x206b6361
 80226d0:	6f727265 	.word	0x6f727265
 80226d4:	000a0d72 	.word	0x000a0d72
 80226d8:	65207262 	.word	0x65207262
 80226dc:	726f7272 	.word	0x726f7272
 80226e0:	00000a0d 	.word	0x00000a0d
 80226e4:	65206462 	.word	0x65206462
 80226e8:	726f7272 	.word	0x726f7272
 80226ec:	00000a0d 	.word	0x00000a0d
 80226f0:	20637263 	.word	0x20637263
 80226f4:	6f727265 	.word	0x6f727265
 80226f8:	000a0d72 	.word	0x000a0d72
 80226fc:	204e4143 	.word	0x204e4143
 8022700:	66207874 	.word	0x66207874
 8022704:	216c6961 	.word	0x216c6961
 8022708:	0d782520 	.word	0x0d782520
 802270c:	0000000a 	.word	0x0000000a
 8022710:	65636572 	.word	0x65636572
 8022714:	20657669 	.word	0x20657669
 8022718:	0d6e6163 	.word	0x0d6e6163
 802271c:	0000000a 	.word	0x0000000a
 8022720:	665f7872 	.word	0x665f7872
 8022724:	206f6669 	.word	0x206f6669
 8022728:	52203d21 	.word	0x52203d21
 802272c:	554e5f54 	.word	0x554e5f54
 8022730:	00004c4c 	.word	0x00004c4c
 8022734:	665f7872 	.word	0x665f7872
 8022738:	2d6f6669 	.word	0x2d6f6669
 802273c:	6572663e 	.word	0x6572663e
 8022740:	6d756e65 	.word	0x6d756e65
 8022744:	73726562 	.word	0x73726562
 8022748:	30203e20 	.word	0x30203e20
 802274c:	00000000 	.word	0x00000000
 8022750:	6f727265 	.word	0x6f727265
 8022754:	65642072 	.word	0x65642072
 8022758:	74696e69 	.word	0x74696e69
 802275c:	6e616320 	.word	0x6e616320
 8022760:	00000a0d 	.word	0x00000a0d
 8022764:	6f727265 	.word	0x6f727265
 8022768:	6e692072 	.word	0x6e692072
 802276c:	63207469 	.word	0x63207469
 8022770:	0a0d6e61 	.word	0x0a0d6e61
 8022774:	00000000 	.word	0x00000000
 8022778:	6c6c616d 	.word	0x6c6c616d
 802277c:	6620636f 	.word	0x6620636f
 8022780:	0d6c6961 	.word	0x0d6c6961
 8022784:	0000000a 	.word	0x0000000a
 8022788:	656d6974 	.word	0x656d6974
 802278c:	6e614372 	.word	0x6e614372
 8022790:	00007872 	.word	0x00007872
 8022794:	316e6163 	.word	0x316e6163
 8022798:	00000000 	.word	0x00000000
 802279c:	000000fa 	.word	0x000000fa
 80227a0:	00000040 	.word	0x00000040
	...
 80227ac:	0000000a 	.word	0x0000000a
 80227b0:	74726175 	.word	0x74726175
 80227b4:	00000031 	.word	0x00000031
 80227b8:	34333231 	.word	0x34333231
 80227bc:	38373635 	.word	0x38373635
 80227c0:	32313039 	.word	0x32313039
 80227c4:	00000a0d 	.word	0x00000a0d
 80227c8:	45524220 	.word	0x45524220
 80227cc:	20314b41 	.word	0x20314b41
 80227d0:	74207369 	.word	0x74207369
 80227d4:	67676972 	.word	0x67676972
 80227d8:	64657265 	.word	0x64657265
 80227dc:	00000a0d 	.word	0x00000a0d
 80227e0:	45524220 	.word	0x45524220
 80227e4:	20324b41 	.word	0x20324b41
 80227e8:	74207369 	.word	0x74207369
 80227ec:	67676972 	.word	0x67676972
 80227f0:	64657265 	.word	0x64657265
 80227f4:	00000a0d 	.word	0x00000a0d
 80227f8:	384d4954 	.word	0x384d4954
 80227fc:	20736920 	.word	0x20736920
 8022800:	67697274 	.word	0x67697274
 8022804:	65726567 	.word	0x65726567
 8022808:	000a0d64 	.word	0x000a0d64
 802280c:	69726573 	.word	0x69726573
 8022810:	21206c61 	.word	0x21206c61
 8022814:	5452203d 	.word	0x5452203d
 8022818:	4c554e5f 	.word	0x4c554e5f
 802281c:	0000004c 	.word	0x0000004c
 8022820:	20676663 	.word	0x20676663
 8022824:	52203d21 	.word	0x52203d21
 8022828:	554e5f54 	.word	0x554e5f54
 802282c:	00004c4c 	.word	0x00004c4c
 8022830:	74206e69 	.word	0x74206e69
 8022834:	63206568 	.word	0x63206568
 8022838:	72746e6f 	.word	0x72746e6f
 802283c:	0a0d6c6f 	.word	0x0a0d6c6f
 8022840:	00000000 	.word	0x00000000
 8022844:	74726175 	.word	0x74726175
 8022848:	00000031 	.word	0x00000031
 802284c:	74726175 	.word	0x74726175
 8022850:	00000033 	.word	0x00000033
 8022854:	0001c200 	.word	0x0001c200
 8022858:	00010008 	.word	0x00010008
 802285c:	00038400 	.word	0x00038400
 8022860:	00010008 	.word	0x00010008
 8022864:	655f6372 	.word	0x655f6372
 8022868:	726f7272 	.word	0x726f7272
 802286c:	00000a0d 	.word	0x00000a0d
 8022870:	3339314a 	.word	0x3339314a
 8022874:	64787439 	.word	0x64787439
 8022878:	00000000 	.word	0x00000000
 802287c:	316e6163 	.word	0x316e6163
 8022880:	00000000 	.word	0x00000000
 8022884:	6e65706f 	.word	0x6e65706f
 8022888:	72726520 	.word	0x72726520
 802288c:	0a0d726f 	.word	0x0a0d726f
 8022890:	00000000 	.word	0x00000000
 8022894:	206c6176 	.word	0x206c6176
 8022898:	6c6c756e 	.word	0x6c6c756e
 802289c:	00000a0d 	.word	0x00000a0d
 80228a0:	3a706420 	.word	0x3a706420
 80228a4:	0d782520 	.word	0x0d782520
 80228a8:	0000000a 	.word	0x0000000a
 80228ac:	203a6670 	.word	0x203a6670
 80228b0:	0d207825 	.word	0x0d207825
 80228b4:	0000000a 	.word	0x0000000a
 80228b8:	203a7370 	.word	0x203a7370
 80228bc:	0d207825 	.word	0x0d207825
 80228c0:	0000000a 	.word	0x0000000a
 80228c4:	20766372 	.word	0x20766372
 80228c8:	61746164 	.word	0x61746164
 80228cc:	0000203a 	.word	0x0000203a
 80228d0:	00207825 	.word	0x00207825
 80228d4:	00000a0d 	.word	0x00000a0d
 80228d8:	08a00047 	.word	0x08a00047
 80228dc:	352e46aa 	.word	0x352e46aa
 80228e0:	006e6143 	.word	0x006e6143
 80228e4:	3339314a 	.word	0x3339314a
 80228e8:	76637239 	.word	0x76637239
 80228ec:	00000000 	.word	0x00000000
 80228f0:	5f6e6163 	.word	0x5f6e6163
 80228f4:	735f7872 	.word	0x735f7872
 80228f8:	63206d65 	.word	0x63206d65
 80228fc:	74616572 	.word	0x74616572
 8022900:	72652065 	.word	0x72652065
 8022904:	0d726f72 	.word	0x0d726f72
 8022908:	0000000a 	.word	0x0000000a
 802290c:	3339314a 	.word	0x3339314a
 8022910:	76635239 	.word	0x76635239
 8022914:	00000000 	.word	0x00000000
 8022918:	0a0d7325 	.word	0x0a0d7325
 802291c:	00000000 	.word	0x00000000
 8022920:	00000030 	.word	0x00000030
 8022924:	00000031 	.word	0x00000031
 8022928:	00000032 	.word	0x00000032
 802292c:	00000033 	.word	0x00000033
 8022930:	6e6b6e75 	.word	0x6e6b6e75
 8022934:	206e776f 	.word	0x206e776f
 8022938:	61726170 	.word	0x61726170
 802293c:	6574656d 	.word	0x6574656d
 8022940:	000a0d72 	.word	0x000a0d72
 8022944:	00006e6f 	.word	0x00006e6f
 8022948:	0066666f 	.word	0x0066666f
 802294c:	706d6574 	.word	0x706d6574
 8022950:	7830203d 	.word	0x7830203d
 8022954:	0d207825 	.word	0x0d207825
 8022958:	0000000a 	.word	0x0000000a
 802295c:	20535542 	.word	0x20535542
 8022960:	30203d56 	.word	0x30203d56
 8022964:	20782578 	.word	0x20782578
 8022968:	00000a0d 	.word	0x00000a0d
 802296c:	20535542 	.word	0x20535542
 8022970:	30203d49 	.word	0x30203d49
 8022974:	20782578 	.word	0x20782578
 8022978:	00000a0d 	.word	0x00000a0d
 802297c:	544c4f56 	.word	0x544c4f56
 8022980:	20454741 	.word	0x20454741
 8022984:	30203d43 	.word	0x30203d43
 8022988:	20782578 	.word	0x20782578
 802298c:	00000a0d 	.word	0x00000a0d
 8022990:	544c4f56 	.word	0x544c4f56
 8022994:	20454741 	.word	0x20454741
 8022998:	30203d42 	.word	0x30203d42
 802299c:	20782578 	.word	0x20782578
 80229a0:	00000a0d 	.word	0x00000a0d
 80229a4:	544c4f56 	.word	0x544c4f56
 80229a8:	20454741 	.word	0x20454741
 80229ac:	30203d41 	.word	0x30203d41
 80229b0:	20782578 	.word	0x20782578
 80229b4:	00000a0d 	.word	0x00000a0d
 80229b8:	72727563 	.word	0x72727563
 80229bc:	20746e65 	.word	0x20746e65
 80229c0:	203d3243 	.word	0x203d3243
 80229c4:	78257830 	.word	0x78257830
 80229c8:	000a0d20 	.word	0x000a0d20
 80229cc:	72727563 	.word	0x72727563
 80229d0:	20746e65 	.word	0x20746e65
 80229d4:	203d3143 	.word	0x203d3143
 80229d8:	78257830 	.word	0x78257830
 80229dc:	000a0d20 	.word	0x000a0d20
 80229e0:	72727563 	.word	0x72727563
 80229e4:	20746e65 	.word	0x20746e65
 80229e8:	203d3242 	.word	0x203d3242
 80229ec:	78257830 	.word	0x78257830
 80229f0:	000a0d20 	.word	0x000a0d20
 80229f4:	72727563 	.word	0x72727563
 80229f8:	20746e65 	.word	0x20746e65
 80229fc:	203d3142 	.word	0x203d3142
 8022a00:	78257830 	.word	0x78257830
 8022a04:	000a0d20 	.word	0x000a0d20
 8022a08:	72727563 	.word	0x72727563
 8022a0c:	20746e65 	.word	0x20746e65
 8022a10:	203d3241 	.word	0x203d3241
 8022a14:	78257830 	.word	0x78257830
 8022a18:	000a0d20 	.word	0x000a0d20
 8022a1c:	72727563 	.word	0x72727563
 8022a20:	20746e65 	.word	0x20746e65
 8022a24:	203d3141 	.word	0x203d3141
 8022a28:	78257830 	.word	0x78257830
 8022a2c:	000a0d20 	.word	0x000a0d20
 8022a30:	706d6574 	.word	0x706d6574
 8022a34:	66666f20 	.word	0x66666f20
 8022a38:	3d746573 	.word	0x3d746573
 8022a3c:	25783020 	.word	0x25783020
 8022a40:	0a0d2078 	.word	0x0a0d2078
 8022a44:	00000000 	.word	0x00000000
 8022a48:	20535542 	.word	0x20535542
 8022a4c:	6f202056 	.word	0x6f202056
 8022a50:	65736666 	.word	0x65736666
 8022a54:	30203d74 	.word	0x30203d74
 8022a58:	20782578 	.word	0x20782578
 8022a5c:	00000a0d 	.word	0x00000a0d
 8022a60:	20535542 	.word	0x20535542
 8022a64:	666f2049 	.word	0x666f2049
 8022a68:	74657366 	.word	0x74657366
 8022a6c:	7830203d 	.word	0x7830203d
 8022a70:	0d207825 	.word	0x0d207825
 8022a74:	0000000a 	.word	0x0000000a
 8022a78:	544c4f56 	.word	0x544c4f56
 8022a7c:	20454741 	.word	0x20454741
 8022a80:	666f2043 	.word	0x666f2043
 8022a84:	74657366 	.word	0x74657366
 8022a88:	7830203d 	.word	0x7830203d
 8022a8c:	0d207825 	.word	0x0d207825
 8022a90:	0000000a 	.word	0x0000000a
 8022a94:	544c4f56 	.word	0x544c4f56
 8022a98:	20454741 	.word	0x20454741
 8022a9c:	666f2042 	.word	0x666f2042
 8022aa0:	74657366 	.word	0x74657366
 8022aa4:	7830203d 	.word	0x7830203d
 8022aa8:	0d207825 	.word	0x0d207825
 8022aac:	0000000a 	.word	0x0000000a
 8022ab0:	544c4f56 	.word	0x544c4f56
 8022ab4:	20454741 	.word	0x20454741
 8022ab8:	666f2041 	.word	0x666f2041
 8022abc:	74657366 	.word	0x74657366
 8022ac0:	7830203d 	.word	0x7830203d
 8022ac4:	0d207825 	.word	0x0d207825
 8022ac8:	0000000a 	.word	0x0000000a
 8022acc:	72727563 	.word	0x72727563
 8022ad0:	20746e65 	.word	0x20746e65
 8022ad4:	6f203243 	.word	0x6f203243
 8022ad8:	65736666 	.word	0x65736666
 8022adc:	30203d74 	.word	0x30203d74
 8022ae0:	20782578 	.word	0x20782578
 8022ae4:	00000a0d 	.word	0x00000a0d
 8022ae8:	72727563 	.word	0x72727563
 8022aec:	20746e65 	.word	0x20746e65
 8022af0:	6f203143 	.word	0x6f203143
 8022af4:	65736666 	.word	0x65736666
 8022af8:	30203d74 	.word	0x30203d74
 8022afc:	20782578 	.word	0x20782578
 8022b00:	00000a0d 	.word	0x00000a0d
 8022b04:	72727563 	.word	0x72727563
 8022b08:	20746e65 	.word	0x20746e65
 8022b0c:	6f203242 	.word	0x6f203242
 8022b10:	65736666 	.word	0x65736666
 8022b14:	30203d74 	.word	0x30203d74
 8022b18:	20782578 	.word	0x20782578
 8022b1c:	00000a0d 	.word	0x00000a0d
 8022b20:	72727563 	.word	0x72727563
 8022b24:	20746e65 	.word	0x20746e65
 8022b28:	6f203142 	.word	0x6f203142
 8022b2c:	65736666 	.word	0x65736666
 8022b30:	30203d74 	.word	0x30203d74
 8022b34:	20782578 	.word	0x20782578
 8022b38:	00000a0d 	.word	0x00000a0d
 8022b3c:	72727563 	.word	0x72727563
 8022b40:	20746e65 	.word	0x20746e65
 8022b44:	6f203241 	.word	0x6f203241
 8022b48:	65736666 	.word	0x65736666
 8022b4c:	30203d74 	.word	0x30203d74
 8022b50:	20782578 	.word	0x20782578
 8022b54:	00000a0d 	.word	0x00000a0d
 8022b58:	72727563 	.word	0x72727563
 8022b5c:	20746e65 	.word	0x20746e65
 8022b60:	6f203141 	.word	0x6f203141
 8022b64:	65736666 	.word	0x65736666
 8022b68:	30203d74 	.word	0x30203d74
 8022b6c:	20782578 	.word	0x20782578
 8022b70:	00000a0d 	.word	0x00000a0d
 8022b74:	6f746f4d 	.word	0x6f746f4d
 8022b78:	73692072 	.word	0x73692072
 8022b7c:	61747320 	.word	0x61747320
 8022b80:	64657472 	.word	0x64657472
 8022b84:	00000a0d 	.word	0x00000a0d
 8022b88:	6f746f4d 	.word	0x6f746f4d
 8022b8c:	73692072 	.word	0x73692072
 8022b90:	6f747320 	.word	0x6f747320
 8022b94:	64657070 	.word	0x64657070
 8022b98:	00000a0d 	.word	0x00000a0d
 8022b9c:	354d4954 	.word	0x354d4954
 8022ba0:	544e4320 	.word	0x544e4320
 8022ba4:	78253d20 	.word	0x78253d20
 8022ba8:	00000a0d 	.word	0x00000a0d
 8022bac:	6f746f4d 	.word	0x6f746f4d
 8022bb0:	00000072 	.word	0x00000072
 8022bb4:	74696e69 	.word	0x74696e69
 8022bb8:	00000000 	.word	0x00000000
 8022bbc:	74737973 	.word	0x74737973
 8022bc0:	00006d65 	.word	0x00006d65
 8022bc4:	74726175 	.word	0x74726175
 8022bc8:	00000033 	.word	0x00000033
 8022bcc:	6e65706f 	.word	0x6e65706f
 8022bd0:	72726520 	.word	0x72726520
 8022bd4:	0a0d726f 	.word	0x0a0d726f
 8022bd8:	00000000 	.word	0x00000000
 8022bdc:	72617375 	.word	0x72617375
 8022be0:	78743374 	.word	0x78743374
 8022be4:	00000000 	.word	0x00000000
 8022be8:	206d6573 	.word	0x206d6573
 8022bec:	61657263 	.word	0x61657263
 8022bf0:	65206574 	.word	0x65206574
 8022bf4:	726f7272 	.word	0x726f7272
 8022bf8:	00000a0d 	.word	0x00000a0d
 8022bfc:	72617375 	.word	0x72617375
 8022c00:	63723374 	.word	0x63723374
 8022c04:	00000076 	.word	0x00000076
 8022c08:	72617375 	.word	0x72617375
 8022c0c:	78723374 	.word	0x78723374
 8022c10:	0000716d 	.word	0x0000716d
 8022c14:	6d5f7872 	.word	0x6d5f7872
 8022c18:	72632071 	.word	0x72632071
 8022c1c:	65746165 	.word	0x65746165
 8022c20:	72726520 	.word	0x72726520
 8022c24:	0a0d726f 	.word	0x0a0d726f
 8022c28:	00000000 	.word	0x00000000
 8022c2c:	72617375 	.word	0x72617375
 8022c30:	78723374 	.word	0x78723374
 8022c34:	00000000 	.word	0x00000000
 8022c38:	6f727265 	.word	0x6f727265
 8022c3c:	72653a72 	.word	0x72653a72
 8022c40:	20726f72 	.word	0x20726f72
 8022c44:	65646f63 	.word	0x65646f63
 8022c48:	25783020 	.word	0x25783020
 8022c4c:	000a0d78 	.word	0x000a0d78
 8022c50:	20766564 	.word	0x20766564
 8022c54:	52203d21 	.word	0x52203d21
 8022c58:	554e5f54 	.word	0x554e5f54
 8022c5c:	00004c4c 	.word	0x00004c4c
 8022c60:	69206f54 	.word	0x69206f54
 8022c64:	6974696e 	.word	0x6974696e
 8022c68:	7a696c61 	.word	0x7a696c61
 8022c6c:	65642065 	.word	0x65642065
 8022c70:	65636976 	.word	0x65636976
 8022c74:	2073253a 	.word	0x2073253a
 8022c78:	6c696166 	.word	0x6c696166
 8022c7c:	202e6465 	.word	0x202e6465
 8022c80:	20656854 	.word	0x20656854
 8022c84:	6f727265 	.word	0x6f727265
 8022c88:	6f632072 	.word	0x6f632072
 8022c8c:	69206564 	.word	0x69206564
 8022c90:	64252073 	.word	0x64252073
 8022c94:	0000000a 	.word	0x0000000a
 8022c98:	2d766564 	.word	0x2d766564
 8022c9c:	6665723e 	.word	0x6665723e
 8022ca0:	756f635f 	.word	0x756f635f
 8022ca4:	2120746e 	.word	0x2120746e
 8022ca8:	0030203d 	.word	0x0030203d
 8022cac:	636e7546 	.word	0x636e7546
 8022cb0:	6e6f6974 	.word	0x6e6f6974
 8022cb4:	5d73255b 	.word	0x5d73255b
 8022cb8:	61687320 	.word	0x61687320
 8022cbc:	6e206c6c 	.word	0x6e206c6c
 8022cc0:	7520746f 	.word	0x7520746f
 8022cc4:	20646573 	.word	0x20646573
 8022cc8:	49206e69 	.word	0x49206e69
 8022ccc:	000a5253 	.word	0x000a5253
 8022cd0:	00000030 	.word	0x00000030
 8022cd4:	6c646974 	.word	0x6c646974
 8022cd8:	00000065 	.word	0x00000065
 8022cdc:	206d6573 	.word	0x206d6573
 8022ce0:	52203d21 	.word	0x52203d21
 8022ce4:	554e5f54 	.word	0x554e5f54
 8022ce8:	00004c4c 	.word	0x00004c4c
 8022cec:	636e7546 	.word	0x636e7546
 8022cf0:	6e6f6974 	.word	0x6e6f6974
 8022cf4:	5d73255b 	.word	0x5d73255b
 8022cf8:	61687320 	.word	0x61687320
 8022cfc:	6e206c6c 	.word	0x6e206c6c
 8022d00:	7520746f 	.word	0x7520746f
 8022d04:	20646573 	.word	0x20646573
 8022d08:	49206e69 	.word	0x49206e69
 8022d0c:	000a5253 	.word	0x000a5253
 8022d10:	00000030 	.word	0x00000030
 8022d14:	636e7546 	.word	0x636e7546
 8022d18:	6e6f6974 	.word	0x6e6f6974
 8022d1c:	5d73255b 	.word	0x5d73255b
 8022d20:	61687320 	.word	0x61687320
 8022d24:	6e206c6c 	.word	0x6e206c6c
 8022d28:	6220746f 	.word	0x6220746f
 8022d2c:	73752065 	.word	0x73752065
 8022d30:	62206465 	.word	0x62206465
 8022d34:	726f6665 	.word	0x726f6665
 8022d38:	63732065 	.word	0x63732065
 8022d3c:	75646568 	.word	0x75646568
 8022d40:	2072656c 	.word	0x2072656c
 8022d44:	72617473 	.word	0x72617473
 8022d48:	00000a74 	.word	0x00000a74
 8022d4c:	6574756d 	.word	0x6574756d
 8022d50:	3d212078 	.word	0x3d212078
 8022d54:	5f545220 	.word	0x5f545220
 8022d58:	4c4c554e 	.word	0x4c4c554e
 8022d5c:	00000000 	.word	0x00000000
 8022d60:	6e657665 	.word	0x6e657665
 8022d64:	3d212074 	.word	0x3d212074
 8022d68:	5f545220 	.word	0x5f545220
 8022d6c:	4c4c554e 	.word	0x4c4c554e
 8022d70:	00000000 	.word	0x00000000
 8022d74:	2120626d 	.word	0x2120626d
 8022d78:	5452203d 	.word	0x5452203d
 8022d7c:	4c554e5f 	.word	0x4c554e5f
 8022d80:	0000004c 	.word	0x0000004c
 8022d84:	2120716d 	.word	0x2120716d
 8022d88:	5452203d 	.word	0x5452203d
 8022d8c:	4c554e5f 	.word	0x4c554e5f
 8022d90:	0000004c 	.word	0x0000004c
 8022d94:	66667562 	.word	0x66667562
 8022d98:	21207265 	.word	0x21207265
 8022d9c:	5452203d 	.word	0x5452203d
 8022da0:	4c554e5f 	.word	0x4c554e5f
 8022da4:	0000004c 	.word	0x0000004c
 8022da8:	657a6973 	.word	0x657a6973
 8022dac:	203d2120 	.word	0x203d2120
 8022db0:	00000030 	.word	0x00000030
 8022db4:	205c200a 	.word	0x205c200a
 8022db8:	0a2f207c 	.word	0x0a2f207c
 8022dbc:	00000000 	.word	0x00000000
 8022dc0:	5452202d 	.word	0x5452202d
 8022dc4:	20202d20 	.word	0x20202d20
 8022dc8:	54202020 	.word	0x54202020
 8022dcc:	61657268 	.word	0x61657268
 8022dd0:	704f2064 	.word	0x704f2064
 8022dd4:	74617265 	.word	0x74617265
 8022dd8:	20676e69 	.word	0x20676e69
 8022ddc:	74737953 	.word	0x74737953
 8022de0:	000a6d65 	.word	0x000a6d65
 8022de4:	7c202f20 	.word	0x7c202f20
 8022de8:	20205c20 	.word	0x20205c20
 8022dec:	25202020 	.word	0x25202020
 8022df0:	64252e64 	.word	0x64252e64
 8022df4:	2064252e 	.word	0x2064252e
 8022df8:	6c697562 	.word	0x6c697562
 8022dfc:	73252064 	.word	0x73252064
 8022e00:	0000000a 	.word	0x0000000a
 8022e04:	206c754a 	.word	0x206c754a
 8022e08:	32203033 	.word	0x32203033
 8022e0c:	00363130 	.word	0x00363130
 8022e10:	30303220 	.word	0x30303220
 8022e14:	202d2036 	.word	0x202d2036
 8022e18:	35313032 	.word	0x35313032
 8022e1c:	706f4320 	.word	0x706f4320
 8022e20:	67697279 	.word	0x67697279
 8022e24:	62207468 	.word	0x62207468
 8022e28:	74722079 	.word	0x74722079
 8022e2c:	7268742d 	.word	0x7268742d
 8022e30:	20646165 	.word	0x20646165
 8022e34:	6d616574 	.word	0x6d616574
 8022e38:	0000000a 	.word	0x0000000a
 8022e3c:	4c554e28 	.word	0x4c554e28
 8022e40:	0000294c 	.word	0x0000294c
 8022e44:	29732528 	.word	0x29732528
 8022e48:	73736120 	.word	0x73736120
 8022e4c:	69747265 	.word	0x69747265
 8022e50:	66206e6f 	.word	0x66206e6f
 8022e54:	656c6961 	.word	0x656c6961
 8022e58:	74612064 	.word	0x74612064
 8022e5c:	6e756620 	.word	0x6e756620
 8022e60:	6f697463 	.word	0x6f697463
 8022e64:	73253a6e 	.word	0x73253a6e
 8022e68:	696c202c 	.word	0x696c202c
 8022e6c:	6e20656e 	.word	0x6e20656e
 8022e70:	65626d75 	.word	0x65626d75
 8022e74:	64253a72 	.word	0x64253a72
 8022e78:	00000a20 	.word	0x00000a20
 8022e7c:	5f747228 	.word	0x5f747228
 8022e80:	746e6975 	.word	0x746e6975
 8022e84:	20745f38 	.word	0x20745f38
 8022e88:	656d292a 	.word	0x656d292a
 8022e8c:	3d3e206d 	.word	0x3d3e206d
 8022e90:	61656820 	.word	0x61656820
 8022e94:	74705f70 	.word	0x74705f70
 8022e98:	00000072 	.word	0x00000072
 8022e9c:	5f747228 	.word	0x5f747228
 8022ea0:	746e6975 	.word	0x746e6975
 8022ea4:	20745f38 	.word	0x20745f38
 8022ea8:	656d292a 	.word	0x656d292a
 8022eac:	203c206d 	.word	0x203c206d
 8022eb0:	5f747228 	.word	0x5f747228
 8022eb4:	746e6975 	.word	0x746e6975
 8022eb8:	20745f38 	.word	0x20745f38
 8022ebc:	6568292a 	.word	0x6568292a
 8022ec0:	655f7061 	.word	0x655f7061
 8022ec4:	0000646e 	.word	0x0000646e
 8022ec8:	2d6d656d 	.word	0x2d6d656d
 8022ecc:	6573753e 	.word	0x6573753e
 8022ed0:	3d3d2064 	.word	0x3d3d2064
 8022ed4:	00003020 	.word	0x00003020
 8022ed8:	636e7546 	.word	0x636e7546
 8022edc:	6e6f6974 	.word	0x6e6f6974
 8022ee0:	5d73255b 	.word	0x5d73255b
 8022ee4:	61687320 	.word	0x61687320
 8022ee8:	6e206c6c 	.word	0x6e206c6c
 8022eec:	7520746f 	.word	0x7520746f
 8022ef0:	20646573 	.word	0x20646573
 8022ef4:	49206e69 	.word	0x49206e69
 8022ef8:	000a5253 	.word	0x000a5253
 8022efc:	00000030 	.word	0x00000030
 8022f00:	206d656d 	.word	0x206d656d
 8022f04:	74696e69 	.word	0x74696e69
 8022f08:	7265202c 	.word	0x7265202c
 8022f0c:	20726f72 	.word	0x20726f72
 8022f10:	69676562 	.word	0x69676562
 8022f14:	6461206e 	.word	0x6461206e
 8022f18:	73657264 	.word	0x73657264
 8022f1c:	78302073 	.word	0x78302073
 8022f20:	202c7825 	.word	0x202c7825
 8022f24:	20646e61 	.word	0x20646e61
 8022f28:	20646e65 	.word	0x20646e65
 8022f2c:	72646461 	.word	0x72646461
 8022f30:	20737365 	.word	0x20737365
 8022f34:	78257830 	.word	0x78257830
 8022f38:	0000000a 	.word	0x0000000a
 8022f3c:	70616568 	.word	0x70616568
 8022f40:	00000000 	.word	0x00000000
 8022f44:	666c2828 	.word	0x666c2828
 8022f48:	20656572 	.word	0x20656572
 8022f4c:	68203d3d 	.word	0x68203d3d
 8022f50:	5f706165 	.word	0x5f706165
 8022f54:	29646e65 	.word	0x29646e65
 8022f58:	207c7c20 	.word	0x207c7c20
 8022f5c:	666c2128 	.word	0x666c2128
 8022f60:	2d656572 	.word	0x2d656572
 8022f64:	6573753e 	.word	0x6573753e
 8022f68:	00292964 	.word	0x00292964
 8022f6c:	5f747228 	.word	0x5f747228
 8022f70:	746e6975 	.word	0x746e6975
 8022f74:	745f3233 	.word	0x745f3233
 8022f78:	6d656d29 	.word	0x6d656d29
 8022f7c:	53202b20 	.word	0x53202b20
 8022f80:	4f455a49 	.word	0x4f455a49
 8022f84:	54535f46 	.word	0x54535f46
 8022f88:	54435552 	.word	0x54435552
 8022f8c:	4d454d5f 	.word	0x4d454d5f
 8022f90:	73202b20 	.word	0x73202b20
 8022f94:	20657a69 	.word	0x20657a69
 8022f98:	28203d3c 	.word	0x28203d3c
 8022f9c:	755f7472 	.word	0x755f7472
 8022fa0:	33746e69 	.word	0x33746e69
 8022fa4:	29745f32 	.word	0x29745f32
 8022fa8:	70616568 	.word	0x70616568
 8022fac:	646e655f 	.word	0x646e655f
 8022fb0:	00000000 	.word	0x00000000
 8022fb4:	5f747228 	.word	0x5f747228
 8022fb8:	746e6975 	.word	0x746e6975
 8022fbc:	745f3233 	.word	0x745f3233
 8022fc0:	72282829 	.word	0x72282829
 8022fc4:	69755f74 	.word	0x69755f74
 8022fc8:	5f38746e 	.word	0x5f38746e
 8022fcc:	292a2074 	.word	0x292a2074
 8022fd0:	206d656d 	.word	0x206d656d
 8022fd4:	4953202b 	.word	0x4953202b
 8022fd8:	464f455a 	.word	0x464f455a
 8022fdc:	5254535f 	.word	0x5254535f
 8022fe0:	5f544355 	.word	0x5f544355
 8022fe4:	294d454d 	.word	0x294d454d
 8022fe8:	52202520 	.word	0x52202520
 8022fec:	4c415f54 	.word	0x4c415f54
 8022ff0:	5f4e4749 	.word	0x5f4e4749
 8022ff4:	455a4953 	.word	0x455a4953
 8022ff8:	203d3d20 	.word	0x203d3d20
 8022ffc:	00000030 	.word	0x00000030
 8023000:	72282828 	.word	0x72282828
 8023004:	69755f74 	.word	0x69755f74
 8023008:	3233746e 	.word	0x3233746e
 802300c:	6d29745f 	.word	0x6d29745f
 8023010:	20296d65 	.word	0x20296d65
 8023014:	52282026 	.word	0x52282026
 8023018:	4c415f54 	.word	0x4c415f54
 802301c:	5f4e4749 	.word	0x5f4e4749
 8023020:	455a4953 	.word	0x455a4953
 8023024:	2929312d 	.word	0x2929312d
 8023028:	203d3d20 	.word	0x203d3d20
 802302c:	00000030 	.word	0x00000030
 8023030:	72282828 	.word	0x72282828
 8023034:	69755f74 	.word	0x69755f74
 8023038:	3233746e 	.word	0x3233746e
 802303c:	7229745f 	.word	0x7229745f
 8023040:	296d656d 	.word	0x296d656d
 8023044:	28202620 	.word	0x28202620
 8023048:	415f5452 	.word	0x415f5452
 802304c:	4e47494c 	.word	0x4e47494c
 8023050:	5a49535f 	.word	0x5a49535f
 8023054:	29312d45 	.word	0x29312d45
 8023058:	3d3d2029 	.word	0x3d3d2029
 802305c:	00003020 	.word	0x00003020
 8023060:	5f747228 	.word	0x5f747228
 8023064:	746e6975 	.word	0x746e6975
 8023068:	20745f38 	.word	0x20745f38
 802306c:	6d72292a 	.word	0x6d72292a
 8023070:	3e206d65 	.word	0x3e206d65
 8023074:	7228203d 	.word	0x7228203d
 8023078:	69755f74 	.word	0x69755f74
 802307c:	5f38746e 	.word	0x5f38746e
 8023080:	292a2074 	.word	0x292a2074
 8023084:	70616568 	.word	0x70616568
 8023088:	7274705f 	.word	0x7274705f
 802308c:	20262620 	.word	0x20262620
 8023090:	5f747228 	.word	0x5f747228
 8023094:	746e6975 	.word	0x746e6975
 8023098:	20745f38 	.word	0x20745f38
 802309c:	6d72292a 	.word	0x6d72292a
 80230a0:	3c206d65 	.word	0x3c206d65
 80230a4:	74722820 	.word	0x74722820
 80230a8:	6e69755f 	.word	0x6e69755f
 80230ac:	745f3874 	.word	0x745f3874
 80230b0:	68292a20 	.word	0x68292a20
 80230b4:	5f706165 	.word	0x5f706165
 80230b8:	00646e65 	.word	0x00646e65
 80230bc:	2d6d656d 	.word	0x2d6d656d
 80230c0:	6573753e 	.word	0x6573753e
 80230c4:	00000064 	.word	0x00000064
 80230c8:	2d6d656d 	.word	0x2d6d656d
 80230cc:	67616d3e 	.word	0x67616d3e
 80230d0:	3d206369 	.word	0x3d206369
 80230d4:	4548203d 	.word	0x4548203d
 80230d8:	4d5f5041 	.word	0x4d5f5041
 80230dc:	43494741 	.word	0x43494741
 80230e0:	00000000 	.word	0x00000000
 80230e4:	61746f74 	.word	0x61746f74
 80230e8:	656d206c 	.word	0x656d206c
 80230ec:	79726f6d 	.word	0x79726f6d
 80230f0:	6425203a 	.word	0x6425203a
 80230f4:	0000000a 	.word	0x0000000a
 80230f8:	64657375 	.word	0x64657375
 80230fc:	6d656d20 	.word	0x6d656d20
 8023100:	2079726f 	.word	0x2079726f
 8023104:	6425203a 	.word	0x6425203a
 8023108:	0000000a 	.word	0x0000000a
 802310c:	6978616d 	.word	0x6978616d
 8023110:	206d756d 	.word	0x206d756d
 8023114:	6f6c6c61 	.word	0x6f6c6c61
 8023118:	65746163 	.word	0x65746163
 802311c:	656d2064 	.word	0x656d2064
 8023120:	79726f6d 	.word	0x79726f6d
 8023124:	6425203a 	.word	0x6425203a
 8023128:	0000000a 	.word	0x0000000a
 802312c:	686d656d 	.word	0x686d656d
 8023130:	20706165 	.word	0x20706165
 8023134:	52203d21 	.word	0x52203d21
 8023138:	554e5f54 	.word	0x554e5f54
 802313c:	00004c4c 	.word	0x00004c4c
 8023140:	70616568 	.word	0x70616568
 8023144:	00000000 	.word	0x00000000
 8023148:	70616568 	.word	0x70616568
 802314c:	203d2120 	.word	0x203d2120
 8023150:	4e5f5452 	.word	0x4e5f5452
 8023154:	004c4c55 	.word	0x004c4c55
 8023158:	7478656e 	.word	0x7478656e
 802315c:	7274705f 	.word	0x7274705f
 8023160:	68203e20 	.word	0x68203e20
 8023164:	65646165 	.word	0x65646165
 8023168:	74705f72 	.word	0x74705f72
 802316c:	00000072 	.word	0x00000072
 8023170:	7478656e 	.word	0x7478656e
 8023174:	7274705f 	.word	0x7274705f
 8023178:	30203e20 	.word	0x30203e20
 802317c:	00000000 	.word	0x00000000
 8023180:	61656828 	.word	0x61656828
 8023184:	5f726564 	.word	0x5f726564
 8023188:	2d727470 	.word	0x2d727470
 802318c:	67616d3e 	.word	0x67616d3e
 8023190:	26206369 	.word	0x26206369
 8023194:	5f545220 	.word	0x5f545220
 8023198:	484d454d 	.word	0x484d454d
 802319c:	5f504145 	.word	0x5f504145
 80231a0:	4b53414d 	.word	0x4b53414d
 80231a4:	3d3d2029 	.word	0x3d3d2029
 80231a8:	5f545220 	.word	0x5f545220
 80231ac:	484d454d 	.word	0x484d454d
 80231b0:	5f504145 	.word	0x5f504145
 80231b4:	4947414d 	.word	0x4947414d
 80231b8:	00000043 	.word	0x00000043
 80231bc:	64616568 	.word	0x64616568
 80231c0:	705f7265 	.word	0x705f7265
 80231c4:	3e2d7274 	.word	0x3e2d7274
 80231c8:	6967616d 	.word	0x6967616d
 80231cc:	20262063 	.word	0x20262063
 80231d0:	4d5f5452 	.word	0x4d5f5452
 80231d4:	45484d45 	.word	0x45484d45
 80231d8:	555f5041 	.word	0x555f5041
 80231dc:	00444553 	.word	0x00444553
 80231e0:	61656828 	.word	0x61656828
 80231e4:	5f726564 	.word	0x5f726564
 80231e8:	2d727470 	.word	0x2d727470
 80231ec:	78656e3e 	.word	0x78656e3e
 80231f0:	6d3e2d74 	.word	0x6d3e2d74
 80231f4:	63696761 	.word	0x63696761
 80231f8:	52202620 	.word	0x52202620
 80231fc:	454d5f54 	.word	0x454d5f54
 8023200:	4145484d 	.word	0x4145484d
 8023204:	414d5f50 	.word	0x414d5f50
 8023208:	20294b53 	.word	0x20294b53
 802320c:	52203d3d 	.word	0x52203d3d
 8023210:	454d5f54 	.word	0x454d5f54
 8023214:	4145484d 	.word	0x4145484d
 8023218:	414d5f50 	.word	0x414d5f50
 802321c:	00434947 	.word	0x00434947
 8023220:	656a626f 	.word	0x656a626f
 8023224:	21207463 	.word	0x21207463
 8023228:	5452203d 	.word	0x5452203d
 802322c:	4c554e5f 	.word	0x4c554e5f
 8023230:	0000004c 	.word	0x0000004c
 8023234:	636e7546 	.word	0x636e7546
 8023238:	6e6f6974 	.word	0x6e6f6974
 802323c:	5d73255b 	.word	0x5d73255b
 8023240:	61687320 	.word	0x61687320
 8023244:	6e206c6c 	.word	0x6e206c6c
 8023248:	7520746f 	.word	0x7520746f
 802324c:	20646573 	.word	0x20646573
 8023250:	49206e69 	.word	0x49206e69
 8023254:	000a5253 	.word	0x000a5253
 8023258:	00000030 	.word	0x00000030
 802325c:	626f2821 	.word	0x626f2821
 8023260:	7463656a 	.word	0x7463656a
 8023264:	79743e2d 	.word	0x79743e2d
 8023268:	26206570 	.word	0x26206570
 802326c:	5f545220 	.word	0x5f545220
 8023270:	656a624f 	.word	0x656a624f
 8023274:	435f7463 	.word	0x435f7463
 8023278:	7373616c 	.word	0x7373616c
 802327c:	6174535f 	.word	0x6174535f
 8023280:	29636974 	.word	0x29636974
 8023284:	00000000 	.word	0x00000000
 8023288:	65726874 	.word	0x65726874
 802328c:	21206461 	.word	0x21206461
 8023290:	5452203d 	.word	0x5452203d
 8023294:	4c554e5f 	.word	0x4c554e5f
 8023298:	0000004c 	.word	0x0000004c
 802329c:	65726874 	.word	0x65726874
 80232a0:	253a6461 	.word	0x253a6461
 80232a4:	74732073 	.word	0x74732073
 80232a8:	206b6361 	.word	0x206b6361
 80232ac:	7265766f 	.word	0x7265766f
 80232b0:	776f6c66 	.word	0x776f6c66
 80232b4:	0000000a 	.word	0x0000000a
 80232b8:	6e726177 	.word	0x6e726177
 80232bc:	3a676e69 	.word	0x3a676e69
 80232c0:	20732520 	.word	0x20732520
 80232c4:	63617473 	.word	0x63617473
 80232c8:	7369206b 	.word	0x7369206b
 80232cc:	6f6c6320 	.word	0x6f6c6320
 80232d0:	74206573 	.word	0x74206573
 80232d4:	6e65206f 	.word	0x6e65206f
 80232d8:	666f2064 	.word	0x666f2064
 80232dc:	61747320 	.word	0x61747320
 80232e0:	61206b63 	.word	0x61206b63
 80232e4:	65726464 	.word	0x65726464
 80232e8:	0a2e7373 	.word	0x0a2e7373
 80232ec:	00000000 	.word	0x00000000
 80232f0:	6f697270 	.word	0x6f697270
 80232f4:	79746972 	.word	0x79746972
 80232f8:	52203c20 	.word	0x52203c20
 80232fc:	48545f54 	.word	0x48545f54
 8023300:	44414552 	.word	0x44414552
 8023304:	4952505f 	.word	0x4952505f
 8023308:	5449524f 	.word	0x5449524f
 802330c:	414d5f59 	.word	0x414d5f59
 8023310:	00000058 	.word	0x00000058
 8023314:	65726874 	.word	0x65726874
 8023318:	21206461 	.word	0x21206461
 802331c:	5452203d 	.word	0x5452203d
 8023320:	4c554e5f 	.word	0x4c554e5f
 8023324:	0000004c 	.word	0x0000004c
 8023328:	63617473 	.word	0x63617473
 802332c:	74735f6b 	.word	0x74735f6b
 8023330:	20747261 	.word	0x20747261
 8023334:	52203d21 	.word	0x52203d21
 8023338:	554e5f54 	.word	0x554e5f54
 802333c:	00004c4c 	.word	0x00004c4c
 8023340:	65726874 	.word	0x65726874
 8023344:	3e2d6461 	.word	0x3e2d6461
 8023348:	74617473 	.word	0x74617473
 802334c:	203d3d20 	.word	0x203d3d20
 8023350:	545f5452 	.word	0x545f5452
 8023354:	41455248 	.word	0x41455248
 8023358:	4e495f44 	.word	0x4e495f44
 802335c:	00005449 	.word	0x00005449
 8023360:	65726874 	.word	0x65726874
 8023364:	3e2d6461 	.word	0x3e2d6461
 8023368:	74617473 	.word	0x74617473
 802336c:	203d3d20 	.word	0x203d3d20
 8023370:	545f5452 	.word	0x545f5452
 8023374:	41455248 	.word	0x41455248
 8023378:	55535f44 	.word	0x55535f44
 802337c:	4e455053 	.word	0x4e455053
 8023380:	00000044 	.word	0x00000044
 8023384:	656d6974 	.word	0x656d6974
 8023388:	3d212072 	.word	0x3d212072
 802338c:	5f545220 	.word	0x5f545220
 8023390:	4c4c554e 	.word	0x4c4c554e
 8023394:	00000000 	.word	0x00000000
 8023398:	656d6974 	.word	0x656d6974
 802339c:	693e2d72 	.word	0x693e2d72
 80233a0:	5f74696e 	.word	0x5f74696e
 80233a4:	6b636974 	.word	0x6b636974
 80233a8:	52203c20 	.word	0x52203c20
 80233ac:	49545f54 	.word	0x49545f54
 80233b0:	4d5f4b43 	.word	0x4d5f4b43
 80233b4:	2f205841 	.word	0x2f205841
 80233b8:	00003220 	.word	0x00003220
 80233bc:	656d6974 	.word	0x656d6974
 80233c0:	00000072 	.word	0x00000072
 80233c4:	3a727370 	.word	0x3a727370
 80233c8:	25783020 	.word	0x25783020
 80233cc:	0a783830 	.word	0x0a783830
 80233d0:	00000000 	.word	0x00000000
 80233d4:	3a637020 	.word	0x3a637020
 80233d8:	25783020 	.word	0x25783020
 80233dc:	0a783830 	.word	0x0a783830
 80233e0:	00000000 	.word	0x00000000
 80233e4:	3a726c20 	.word	0x3a726c20
 80233e8:	25783020 	.word	0x25783020
 80233ec:	0a783830 	.word	0x0a783830
 80233f0:	00000000 	.word	0x00000000
 80233f4:	3a323172 	.word	0x3a323172
 80233f8:	25783020 	.word	0x25783020
 80233fc:	0a783830 	.word	0x0a783830
 8023400:	00000000 	.word	0x00000000
 8023404:	3a333072 	.word	0x3a333072
 8023408:	25783020 	.word	0x25783020
 802340c:	0a783830 	.word	0x0a783830
 8023410:	00000000 	.word	0x00000000
 8023414:	3a323072 	.word	0x3a323072
 8023418:	25783020 	.word	0x25783020
 802341c:	0a783830 	.word	0x0a783830
 8023420:	00000000 	.word	0x00000000
 8023424:	3a313072 	.word	0x3a313072
 8023428:	25783020 	.word	0x25783020
 802342c:	0a783830 	.word	0x0a783830
 8023430:	00000000 	.word	0x00000000
 8023434:	3a303072 	.word	0x3a303072
 8023438:	25783020 	.word	0x25783020
 802343c:	0a783830 	.word	0x0a783830
 8023440:	00000000 	.word	0x00000000
 8023444:	64726168 	.word	0x64726168
 8023448:	75616620 	.word	0x75616620
 802344c:	6f20746c 	.word	0x6f20746c
 8023450:	6874206e 	.word	0x6874206e
 8023454:	64616572 	.word	0x64616572
 8023458:	7325203a 	.word	0x7325203a
 802345c:	0000000a 	.word	0x0000000a
 8023460:	74756873 	.word	0x74756873
 8023464:	6e776f64 	.word	0x6e776f64
 8023468:	0a2e2e2e 	.word	0x0a2e2e2e
 802346c:	00000000 	.word	0x00000000
 8023470:	00000030 	.word	0x00000030
 8023474:	00637472 	.word	0x00637472
 8023478:	656d6974 	.word	0x656d6974
 802347c:	203d2120 	.word	0x203d2120
 8023480:	4e5f5452 	.word	0x4e5f5452
 8023484:	004c4c55 	.word	0x004c4c55
 8023488:	00716d70 	.word	0x00716d70
 802348c:	6d657370 	.word	0x6d657370
 8023490:	00000000 	.word	0x00000000
 8023494:	6d657370 	.word	0x6d657370
 8023498:	64323025 	.word	0x64323025
 802349c:	00000000 	.word	0x00000000
 80234a0:	48544150 	.word	0x48544150
 80234a4:	69622f3d 	.word	0x69622f3d
 80234a8:	0000006e 	.word	0x0000006e
 80234ac:	454d4f48 	.word	0x454d4f48
 80234b0:	6f682f3d 	.word	0x6f682f3d
 80234b4:	0000656d 	.word	0x0000656d
 80234b8:	706d6f63 	.word	0x706d6f63
 80234bc:	6974656c 	.word	0x6974656c
 80234c0:	21206e6f 	.word	0x21206e6f
 80234c4:	5452203d 	.word	0x5452203d
 80234c8:	4c554e5f 	.word	0x4c554e5f
 80234cc:	0000004c 	.word	0x0000004c
 80234d0:	6c5f7472 	.word	0x6c5f7472
 80234d4:	5f747369 	.word	0x5f747369
 80234d8:	6d657369 	.word	0x6d657369
 80234dc:	28797470 	.word	0x28797470
 80234e0:	6f632826 	.word	0x6f632826
 80234e4:	656c706d 	.word	0x656c706d
 80234e8:	6e6f6974 	.word	0x6e6f6974
 80234ec:	75733e2d 	.word	0x75733e2d
 80234f0:	6e657073 	.word	0x6e657073
 80234f4:	5f646564 	.word	0x5f646564
 80234f8:	7473696c 	.word	0x7473696c
 80234fc:	00002929 	.word	0x00002929
 8023500:	636e7546 	.word	0x636e7546
 8023504:	6e6f6974 	.word	0x6e6f6974
 8023508:	5d73255b 	.word	0x5d73255b
 802350c:	61687320 	.word	0x61687320
 8023510:	6e206c6c 	.word	0x6e206c6c
 8023514:	7520746f 	.word	0x7520746f
 8023518:	20646573 	.word	0x20646573
 802351c:	49206e69 	.word	0x49206e69
 8023520:	000a5253 	.word	0x000a5253
 8023524:	00000030 	.word	0x00000030
 8023528:	75657571 	.word	0x75657571
 802352c:	3d212065 	.word	0x3d212065
 8023530:	5f545220 	.word	0x5f545220
 8023534:	4c4c554e 	.word	0x4c4c554e
 8023538:	00000000 	.word	0x00000000
 802353c:	636e7546 	.word	0x636e7546
 8023540:	6e6f6974 	.word	0x6e6f6974
 8023544:	5d73255b 	.word	0x5d73255b
 8023548:	61687320 	.word	0x61687320
 802354c:	6e206c6c 	.word	0x6e206c6c
 8023550:	7520746f 	.word	0x7520746f
 8023554:	20646573 	.word	0x20646573
 8023558:	49206e69 	.word	0x49206e69
 802355c:	000a5253 	.word	0x000a5253
 8023560:	00000030 	.word	0x00000030
 8023564:	61746164 	.word	0x61746164
 8023568:	7274705f 	.word	0x7274705f
 802356c:	203d2120 	.word	0x203d2120
 8023570:	4e5f5452 	.word	0x4e5f5452
 8023574:	004c4c55 	.word	0x004c4c55
 8023578:	657a6973 	.word	0x657a6973
 802357c:	203d2120 	.word	0x203d2120
 8023580:	4e5f5452 	.word	0x4e5f5452
 8023584:	004c4c55 	.word	0x004c4c55
 8023588:	20766564 	.word	0x20766564
 802358c:	52203d21 	.word	0x52203d21
 8023590:	554e5f54 	.word	0x554e5f54
 8023594:	00004c4c 	.word	0x00004c4c
 8023598:	78363025 	.word	0x78363025
 802359c:	0000203a 	.word	0x0000203a
 80235a0:	78323025 	.word	0x78323025
 80235a4:	00000020 	.word	0x00000020
 80235a8:	00202020 	.word	0x00202020
 80235ac:	00000020 	.word	0x00000020
 80235b0:	00006325 	.word	0x00006325
 80235b4:	0000000a 	.word	0x0000000a
 80235b8:	6e206f6e 	.word	0x6e206f6e
 80235bc:	20646e61 	.word	0x20646e61
 80235c0:	69766564 	.word	0x69766564
 80235c4:	66206563 	.word	0x66206563
 80235c8:	646e756f 	.word	0x646e756f
 80235cc:	00000a21 	.word	0x00000a21
 80235d0:	2074756f 	.word	0x2074756f
 80235d4:	6d20666f 	.word	0x6d20666f
 80235d8:	726f6d65 	.word	0x726f6d65
 80235dc:	000a2179 	.word	0x000a2179
 80235e0:	64616572 	.word	0x64616572
 80235e4:	67617020 	.word	0x67617020
 80235e8:	72202c65 	.word	0x72202c65
 80235ec:	64253d63 	.word	0x64253d63
 80235f0:	0000000a 	.word	0x0000000a
 80235f4:	74697277 	.word	0x74697277
 80235f8:	61702065 	.word	0x61702065
 80235fc:	66206567 	.word	0x66206567
 8023600:	656c6961 	.word	0x656c6961
 8023604:	202c2164 	.word	0x202c2164
 8023608:	253d6372 	.word	0x253d6372
 802360c:	00000a64 	.word	0x00000a64
 8023610:	00637472 	.word	0x00637472
 8023614:	000a7325 	.word	0x000a7325
 8023618:	69726573 	.word	0x69726573
 802361c:	21206c61 	.word	0x21206c61
 8023620:	5452203d 	.word	0x5452203d
 8023624:	4c554e5f 	.word	0x4c554e5f
 8023628:	0000004c 	.word	0x0000004c
 802362c:	665f7872 	.word	0x665f7872
 8023630:	206f6669 	.word	0x206f6669
 8023634:	52203d21 	.word	0x52203d21
 8023638:	554e5f54 	.word	0x554e5f54
 802363c:	00004c4c 	.word	0x00004c4c
 8023640:	21207874 	.word	0x21207874
 8023644:	5452203d 	.word	0x5452203d
 8023648:	4c554e5f 	.word	0x4c554e5f
 802364c:	0000004c 	.word	0x0000004c
 8023650:	72657328 	.word	0x72657328
 8023654:	206c6169 	.word	0x206c6169
 8023658:	52203d21 	.word	0x52203d21
 802365c:	554e5f54 	.word	0x554e5f54
 8023660:	20294c4c 	.word	0x20294c4c
 8023664:	28202626 	.word	0x28202626
 8023668:	61746164 	.word	0x61746164
 802366c:	203d2120 	.word	0x203d2120
 8023670:	4e5f5452 	.word	0x4e5f5452
 8023674:	294c4c55 	.word	0x294c4c55
 8023678:	00000000 	.word	0x00000000
 802367c:	645f7872 	.word	0x645f7872
 8023680:	2120616d 	.word	0x2120616d
 8023684:	5452203d 	.word	0x5452203d
 8023688:	4c554e5f 	.word	0x4c554e5f
 802368c:	0000004c 	.word	0x0000004c
 8023690:	20766564 	.word	0x20766564
 8023694:	52203d21 	.word	0x52203d21
 8023698:	554e5f54 	.word	0x554e5f54
 802369c:	00004c4c 	.word	0x00004c4c
 80236a0:	0a0d7825 	.word	0x0a0d7825
 80236a4:	00000000 	.word	0x00000000
 80236a8:	645f7874 	.word	0x645f7874
 80236ac:	2120616d 	.word	0x2120616d
 80236b0:	5452203d 	.word	0x5452203d
 80236b4:	4c554e5f 	.word	0x4c554e5f
 80236b8:	0000004c 	.word	0x0000004c
 80236bc:	665f7874 	.word	0x665f7874
 80236c0:	206f6669 	.word	0x206f6669
 80236c4:	52203d21 	.word	0x52203d21
 80236c8:	554e5f54 	.word	0x554e5f54
 80236cc:	00004c4c 	.word	0x00004c4c
 80236d0:	69726573 	.word	0x69726573
 80236d4:	3e2d6c61 	.word	0x3e2d6c61
 80236d8:	65726170 	.word	0x65726170
 80236dc:	6f2e746e 	.word	0x6f2e746e
 80236e0:	5f6e6570 	.word	0x5f6e6570
 80236e4:	67616c66 	.word	0x67616c66
 80236e8:	52202620 	.word	0x52202620
 80236ec:	45445f54 	.word	0x45445f54
 80236f0:	45434956 	.word	0x45434956
 80236f4:	414c465f 	.word	0x414c465f
 80236f8:	4e495f47 	.word	0x4e495f47
 80236fc:	58525f54 	.word	0x58525f54
 8023700:	00000000 	.word	0x00000000
 8023704:	20766564 	.word	0x20766564
 8023708:	52203d21 	.word	0x52203d21
 802370c:	554e5f54 	.word	0x554e5f54
 8023710:	00004c4c 	.word	0x00004c4c
 8023714:	206e6163 	.word	0x206e6163
 8023718:	52203d21 	.word	0x52203d21
 802371c:	554e5f54 	.word	0x554e5f54
 8023720:	00004c4c 	.word	0x00004c4c
 8023724:	665f7872 	.word	0x665f7872
 8023728:	206f6669 	.word	0x206f6669
 802372c:	52203d21 	.word	0x52203d21
 8023730:	554e5f54 	.word	0x554e5f54
 8023734:	00004c4c 	.word	0x00004c4c
 8023738:	665f7872 	.word	0x665f7872
 802373c:	2d6f6669 	.word	0x2d6f6669
 8023740:	6572663e 	.word	0x6572663e
 8023744:	6d756e65 	.word	0x6d756e65
 8023748:	73726562 	.word	0x73726562
 802374c:	203d3c20 	.word	0x203d3c20
 8023750:	2d6e6163 	.word	0x2d6e6163
 8023754:	6e6f633e 	.word	0x6e6f633e
 8023758:	2e676966 	.word	0x2e676966
 802375c:	6267736d 	.word	0x6267736d
 8023760:	7a73786f 	.word	0x7a73786f
 8023764:	00000000 	.word	0x00000000
 8023768:	665f7874 	.word	0x665f7874
 802376c:	206f6669 	.word	0x206f6669
 8023770:	52203d21 	.word	0x52203d21
 8023774:	554e5f54 	.word	0x554e5f54
 8023778:	00004c4c 	.word	0x00004c4c
 802377c:	745f7874 	.word	0x745f7874
 8023780:	646e736f 	.word	0x646e736f
 8023784:	203d2120 	.word	0x203d2120
 8023788:	4e5f5452 	.word	0x4e5f5452
 802378c:	004c4c55 	.word	0x004c4c55
 8023790:	006e6163 	.word	0x006e6163
 8023794:	2d6e6163 	.word	0x2d6e6163
 8023798:	7261703e 	.word	0x7261703e
 802379c:	2e746e65 	.word	0x2e746e65
 80237a0:	6e65706f 	.word	0x6e65706f
 80237a4:	616c665f 	.word	0x616c665f
 80237a8:	20262067 	.word	0x20262067
 80237ac:	445f5452 	.word	0x445f5452
 80237b0:	43495645 	.word	0x43495645
 80237b4:	4c465f45 	.word	0x4c465f45
 80237b8:	495f4741 	.word	0x495f4741
 80237bc:	525f544e 	.word	0x525f544e
 80237c0:	00000058 	.word	0x00000058
 80237c4:	665f7872 	.word	0x665f7872
 80237c8:	2d6f6669 	.word	0x2d6f6669
 80237cc:	6572663e 	.word	0x6572663e
 80237d0:	6d756e65 	.word	0x6d756e65
 80237d4:	73726562 	.word	0x73726562
 80237d8:	30203e20 	.word	0x30203e20
 80237dc:	00000000 	.word	0x00000000
 80237e0:	6e614320 	.word	0x6e614320
 80237e4:	66207427 	.word	0x66207427
 80237e8:	20646e69 	.word	0x20646e69
 80237ec:	206e6163 	.word	0x206e6163
 80237f0:	69766564 	.word	0x69766564
 80237f4:	25206563 	.word	0x25206563
 80237f8:	00000a73 	.word	0x00000a73
 80237fc:	6e694620 	.word	0x6e694620
 8023800:	20646564 	.word	0x20646564
 8023804:	206e6163 	.word	0x206e6163
 8023808:	69766564 	.word	0x69766564
 802380c:	203a6563 	.word	0x203a6563
 8023810:	2e2e7325 	.word	0x2e2e7325
 8023814:	0000002e 	.word	0x0000002e
 8023818:	6552200a 	.word	0x6552200a
 802381c:	76696563 	.word	0x76696563
 8023820:	2e2e2e65 	.word	0x2e2e2e65
 8023824:	6f727265 	.word	0x6f727265
 8023828:	632e2e72 	.word	0x632e2e72
 802382c:	746e756f 	.word	0x746e756f
 8023830:	3025203a 	.word	0x3025203a
 8023834:	646c3031 	.word	0x646c3031
 8023838:	6553202e 	.word	0x6553202e
 802383c:	2e2e646e 	.word	0x2e2e646e
 8023840:	652e2e2e 	.word	0x652e2e2e
 8023844:	726f7272 	.word	0x726f7272
 8023848:	2e2e2e2e 	.word	0x2e2e2e2e
 802384c:	6e756f63 	.word	0x6e756f63
 8023850:	25203a74 	.word	0x25203a74
 8023854:	6c303130 	.word	0x6c303130
 8023858:	00002e64 	.word	0x00002e64
 802385c:	6942200a 	.word	0x6942200a
 8023860:	702e2e74 	.word	0x702e2e74
 8023864:	2e2e6461 	.word	0x2e2e6461
 8023868:	6f727265 	.word	0x6f727265
 802386c:	632e2e72 	.word	0x632e2e72
 8023870:	746e756f 	.word	0x746e756f
 8023874:	3025203a 	.word	0x3025203a
 8023878:	646c3031 	.word	0x646c3031
 802387c:	6f46202e 	.word	0x6f46202e
 8023880:	74616d72 	.word	0x74616d72
 8023884:	652e2e2e 	.word	0x652e2e2e
 8023888:	726f7272 	.word	0x726f7272
 802388c:	2e2e2e2e 	.word	0x2e2e2e2e
 8023890:	6e756f63 	.word	0x6e756f63
 8023894:	25203a74 	.word	0x25203a74
 8023898:	6c303130 	.word	0x6c303130
 802389c:	00000064 	.word	0x00000064
 80238a0:	6341200a 	.word	0x6341200a
 80238a4:	2e2e2e6b 	.word	0x2e2e2e6b
 80238a8:	2e2e2e2e 	.word	0x2e2e2e2e
 80238ac:	6f727265 	.word	0x6f727265
 80238b0:	632e2e72 	.word	0x632e2e72
 80238b4:	746e756f 	.word	0x746e756f
 80238b8:	3025203a 	.word	0x3025203a
 80238bc:	646c3031 	.word	0x646c3031
 80238c0:	6942202e 	.word	0x6942202e
 80238c4:	2e2e2e74 	.word	0x2e2e2e74
 80238c8:	652e2e2e 	.word	0x652e2e2e
 80238cc:	726f7272 	.word	0x726f7272
 80238d0:	2e2e2e2e 	.word	0x2e2e2e2e
 80238d4:	6e756f63 	.word	0x6e756f63
 80238d8:	25203a74 	.word	0x25203a74
 80238dc:	6c303130 	.word	0x6c303130
 80238e0:	00002e64 	.word	0x00002e64
 80238e4:	5243200a 	.word	0x5243200a
 80238e8:	2e2e2e43 	.word	0x2e2e2e43
 80238ec:	2e2e2e2e 	.word	0x2e2e2e2e
 80238f0:	6f727265 	.word	0x6f727265
 80238f4:	632e2e72 	.word	0x632e2e72
 80238f8:	746e756f 	.word	0x746e756f
 80238fc:	3025203a 	.word	0x3025203a
 8023900:	646c3031 	.word	0x646c3031
 8023904:	7245202e 	.word	0x7245202e
 8023908:	2e726f72 	.word	0x2e726f72
 802390c:	65646f63 	.word	0x65646f63
 8023910:	30255b2e 	.word	0x30255b2e
 8023914:	646c3031 	.word	0x646c3031
 8023918:	00203a5d 	.word	0x00203a5d
 802391c:	002e7325 	.word	0x002e7325
 8023920:	6f54200a 	.word	0x6f54200a
 8023924:	2e6c6174 	.word	0x2e6c6174
 8023928:	65636572 	.word	0x65636572
 802392c:	2e657669 	.word	0x2e657669
 8023930:	6b636170 	.word	0x6b636170
 8023934:	73656761 	.word	0x73656761
 8023938:	3025203a 	.word	0x3025203a
 802393c:	646c3031 	.word	0x646c3031
 8023940:	7244202e 	.word	0x7244202e
 8023944:	6465706f 	.word	0x6465706f
 8023948:	6365722e 	.word	0x6365722e
 802394c:	65766965 	.word	0x65766965
 8023950:	6361702e 	.word	0x6361702e
 8023954:	6567616b 	.word	0x6567616b
 8023958:	25203a73 	.word	0x25203a73
 802395c:	6c303130 	.word	0x6c303130
 8023960:	00002e64 	.word	0x00002e64
 8023964:	6f54200a 	.word	0x6f54200a
 8023968:	2e6c6174 	.word	0x2e6c6174
 802396c:	6e65732e 	.word	0x6e65732e
 8023970:	2e2e2e64 	.word	0x2e2e2e64
 8023974:	6b636170 	.word	0x6b636170
 8023978:	73656761 	.word	0x73656761
 802397c:	3025203a 	.word	0x3025203a
 8023980:	646c3031 	.word	0x646c3031
 8023984:	7244202e 	.word	0x7244202e
 8023988:	6465706f 	.word	0x6465706f
 802398c:	732e2e2e 	.word	0x732e2e2e
 8023990:	2e646e65 	.word	0x2e646e65
 8023994:	6361702e 	.word	0x6361702e
 8023998:	6567616b 	.word	0x6567616b
 802399c:	25203a73 	.word	0x25203a73
 80239a0:	6c303130 	.word	0x6c303130
 80239a4:	000a2e64 	.word	0x000a2e64
 80239a8:	766e4920 	.word	0x766e4920
 80239ac:	64696c61 	.word	0x64696c61
 80239b0:	6c614320 	.word	0x6c614320
 80239b4:	7325206c 	.word	0x7325206c
 80239b8:	0000000a 	.word	0x0000000a
 80239bc:	656c5020 	.word	0x656c5020
 80239c0:	20657361 	.word	0x20657361
 80239c4:	6e697375 	.word	0x6e697375
 80239c8:	73252067 	.word	0x73252067
 80239cc:	6e616320 	.word	0x6e616320
 80239d0:	656d616e 	.word	0x656d616e
 80239d4:	482e2078 	.word	0x482e2078
 80239d8:	20657265 	.word	0x20657265
 80239dc:	6e6e6163 	.word	0x6e6e6163
 80239e0:	20656d61 	.word	0x20656d61
 80239e4:	64207369 	.word	0x64207369
 80239e8:	65766972 	.word	0x65766972
 80239ec:	616e2072 	.word	0x616e2072
 80239f0:	6120656d 	.word	0x6120656d
 80239f4:	7820646e 	.word	0x7820646e
 80239f8:	20736920 	.word	0x20736920
 80239fc:	646e6163 	.word	0x646e6163
 8023a00:	65766972 	.word	0x65766972
 8023a04:	6d756e20 	.word	0x6d756e20
 8023a08:	2e726562 	.word	0x2e726562
 8023a0c:	0000000a 	.word	0x0000000a
 8023a10:	45206f4e 	.word	0x45206f4e
 8023a14:	726f7272 	.word	0x726f7272
 8023a18:	00000021 	.word	0x00000021
 8023a1c:	6e726157 	.word	0x6e726157
 8023a20:	20676e69 	.word	0x20676e69
 8023a24:	00000021 	.word	0x00000021
 8023a28:	73736150 	.word	0x73736150
 8023a2c:	20657669 	.word	0x20657669
 8023a30:	00000021 	.word	0x00000021
 8023a34:	20737542 	.word	0x20737542
 8023a38:	2066664f 	.word	0x2066664f
 8023a3c:	00000021 	.word	0x00000021
 8023a40:	2068736d 	.word	0x2068736d
 8023a44:	00000000 	.word	0x00000000
 8023a48:	736e6966 	.word	0x736e6966
 8023a4c:	00002068 	.word	0x00002068
 8023a50:	0000003e 	.word	0x0000003e
 8023a54:	6c656873 	.word	0x6c656873
 8023a58:	3d21206c 	.word	0x3d21206c
 8023a5c:	5f545220 	.word	0x5f545220
 8023a60:	4c4c554e 	.word	0x4c4c554e
 8023a64:	00000000 	.word	0x00000000
 8023a68:	736e6966 	.word	0x736e6966
 8023a6c:	63203a68 	.word	0x63203a68
 8023a70:	6e206e61 	.word	0x6e206e61
 8023a74:	6620746f 	.word	0x6620746f
 8023a78:	20646e69 	.word	0x20646e69
 8023a7c:	69766564 	.word	0x69766564
 8023a80:	203a6563 	.word	0x203a6563
 8023a84:	000a7325 	.word	0x000a7325
 8023a88:	0000000a 	.word	0x0000000a
 8023a8c:	73257325 	.word	0x73257325
 8023a90:	00000000 	.word	0x00000000
 8023a94:	000a7325 	.word	0x000a7325
 8023a98:	63252709 	.word	0x63252709
 8023a9c:	25202c27 	.word	0x25202c27
 8023aa0:	30202c64 	.word	0x30202c64
 8023aa4:	38302578 	.word	0x38302578
 8023aa8:	00000a78 	.word	0x00000a78
 8023aac:	2c642509 	.word	0x2c642509
 8023ab0:	25783020 	.word	0x25783020
 8023ab4:	0a783830 	.word	0x0a783830
 8023ab8:	00000000 	.word	0x00000000
 8023abc:	4b325b1b 	.word	0x4b325b1b
 8023ac0:	0000000d 	.word	0x0000000d
 8023ac4:	6c656873 	.word	0x6c656873
 8023ac8:	643e2d6c 	.word	0x643e2d6c
 8023acc:	63697665 	.word	0x63697665
 8023ad0:	00000065 	.word	0x00000065
 8023ad4:	00000008 	.word	0x00000008
 8023ad8:	00006325 	.word	0x00006325
 8023adc:	20732508 	.word	0x20732508
 8023ae0:	00000820 	.word	0x00000820
 8023ae4:	00082008 	.word	0x00082008
 8023ae8:	00007325 	.word	0x00007325
 8023aec:	6d206f6e 	.word	0x6d206f6e
 8023af0:	726f6d65 	.word	0x726f6d65
 8023af4:	6f662079 	.word	0x6f662079
 8023af8:	68732072 	.word	0x68732072
 8023afc:	0a6c6c65 	.word	0x0a6c6c65
 8023b00:	00000000 	.word	0x00000000
 8023b04:	78726873 	.word	0x78726873
 8023b08:	00000000 	.word	0x00000000
 8023b0c:	65687374 	.word	0x65687374
 8023b10:	00006c6c 	.word	0x00006c6c
 8023b14:	6c6c6548 	.word	0x6c6c6548
 8023b18:	5452206f 	.word	0x5452206f
 8023b1c:	7268542d 	.word	0x7268542d
 8023b20:	21646165 	.word	0x21646165
 8023b24:	0000000a 	.word	0x0000000a
 8023b28:	72687420 	.word	0x72687420
 8023b2c:	20646165 	.word	0x20646165
 8023b30:	69727020 	.word	0x69727020
 8023b34:	74732020 	.word	0x74732020
 8023b38:	73757461 	.word	0x73757461
 8023b3c:	20202020 	.word	0x20202020
 8023b40:	70732020 	.word	0x70732020
 8023b44:	20202020 	.word	0x20202020
 8023b48:	61747320 	.word	0x61747320
 8023b4c:	73206b63 	.word	0x73206b63
 8023b50:	20657a69 	.word	0x20657a69
 8023b54:	2078616d 	.word	0x2078616d
 8023b58:	64657375 	.word	0x64657375
 8023b5c:	6c202020 	.word	0x6c202020
 8023b60:	20746665 	.word	0x20746665
 8023b64:	6b636974 	.word	0x6b636974
 8023b68:	72652020 	.word	0x72652020
 8023b6c:	0a726f72 	.word	0x0a726f72
 8023b70:	00000000 	.word	0x00000000
 8023b74:	2d2d2d2d 	.word	0x2d2d2d2d
 8023b78:	2d2d2d2d 	.word	0x2d2d2d2d
 8023b7c:	2d2d2d20 	.word	0x2d2d2d20
 8023b80:	2d2d202d 	.word	0x2d2d202d
 8023b84:	2d2d2d2d 	.word	0x2d2d2d2d
 8023b88:	2d2d202d 	.word	0x2d2d202d
 8023b8c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023b90:	2d2d2d2d 	.word	0x2d2d2d2d
 8023b94:	2d2d2d20 	.word	0x2d2d2d20
 8023b98:	2d2d2d2d 	.word	0x2d2d2d2d
 8023b9c:	202d2d2d 	.word	0x202d2d2d
 8023ba0:	2d2d2d2d 	.word	0x2d2d2d2d
 8023ba4:	2d2d2d2d 	.word	0x2d2d2d2d
 8023ba8:	2d202d2d 	.word	0x2d202d2d
 8023bac:	2d2d2d2d 	.word	0x2d2d2d2d
 8023bb0:	2d2d2d2d 	.word	0x2d2d2d2d
 8023bb4:	2d2d202d 	.word	0x2d2d202d
 8023bb8:	00000a2d 	.word	0x00000a2d
 8023bbc:	2e382d25 	.word	0x2e382d25
 8023bc0:	3020732a 	.word	0x3020732a
 8023bc4:	32302578 	.word	0x32302578
 8023bc8:	00000078 	.word	0x00000078
 8023bcc:	61657220 	.word	0x61657220
 8023bd0:	20207964 	.word	0x20207964
 8023bd4:	00000000 	.word	0x00000000
 8023bd8:	73757320 	.word	0x73757320
 8023bdc:	646e6570 	.word	0x646e6570
 8023be0:	00000000 	.word	0x00000000
 8023be4:	696e6920 	.word	0x696e6920
 8023be8:	20202074 	.word	0x20202074
 8023bec:	00000000 	.word	0x00000000
 8023bf0:	6f6c6320 	.word	0x6f6c6320
 8023bf4:	20206573 	.word	0x20206573
 8023bf8:	00000000 	.word	0x00000000
 8023bfc:	25783020 	.word	0x25783020
 8023c00:	20783830 	.word	0x20783830
 8023c04:	30257830 	.word	0x30257830
 8023c08:	30207838 	.word	0x30207838
 8023c0c:	38302578 	.word	0x38302578
 8023c10:	78302078 	.word	0x78302078
 8023c14:	78383025 	.word	0x78383025
 8023c18:	33302520 	.word	0x33302520
 8023c1c:	00000a64 	.word	0x00000a64
 8023c20:	00007325 	.word	0x00007325
 8023c24:	0000002f 	.word	0x0000002f
 8023c28:	616d6573 	.word	0x616d6573
 8023c2c:	726f6870 	.word	0x726f6870
 8023c30:	20762065 	.word	0x20762065
 8023c34:	75732020 	.word	0x75732020
 8023c38:	6e657073 	.word	0x6e657073
 8023c3c:	68742064 	.word	0x68742064
 8023c40:	64616572 	.word	0x64616572
 8023c44:	0000000a 	.word	0x0000000a
 8023c48:	2d2d2d2d 	.word	0x2d2d2d2d
 8023c4c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023c50:	2d2d2020 	.word	0x2d2d2020
 8023c54:	2d2d202d 	.word	0x2d2d202d
 8023c58:	2d2d2d2d 	.word	0x2d2d2d2d
 8023c5c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023c60:	2d2d2d2d 	.word	0x2d2d2d2d
 8023c64:	0000000a 	.word	0x0000000a
 8023c68:	2e382d25 	.word	0x2e382d25
 8023c6c:	2020732a 	.word	0x2020732a
 8023c70:	64333025 	.word	0x64333025
 8023c74:	3a642520 	.word	0x3a642520
 8023c78:	00000000 	.word	0x00000000
 8023c7c:	0000000a 	.word	0x0000000a
 8023c80:	2e382d25 	.word	0x2e382d25
 8023c84:	2020732a 	.word	0x2020732a
 8023c88:	64333025 	.word	0x64333025
 8023c8c:	0a642520 	.word	0x0a642520
 8023c90:	00000000 	.word	0x00000000
 8023c94:	6e657665 	.word	0x6e657665
 8023c98:	20202074 	.word	0x20202074
 8023c9c:	74657320 	.word	0x74657320
 8023ca0:	20202020 	.word	0x20202020
 8023ca4:	20202020 	.word	0x20202020
 8023ca8:	70737573 	.word	0x70737573
 8023cac:	20646e65 	.word	0x20646e65
 8023cb0:	65726874 	.word	0x65726874
 8023cb4:	000a6461 	.word	0x000a6461
 8023cb8:	2d2d2d2d 	.word	0x2d2d2d2d
 8023cbc:	2d2d2d2d 	.word	0x2d2d2d2d
 8023cc0:	2d2d2d20 	.word	0x2d2d2d20
 8023cc4:	2d2d2d2d 	.word	0x2d2d2d2d
 8023cc8:	202d2d2d 	.word	0x202d2d2d
 8023ccc:	2d2d2d2d 	.word	0x2d2d2d2d
 8023cd0:	2d2d2d2d 	.word	0x2d2d2d2d
 8023cd4:	2d2d2d2d 	.word	0x2d2d2d2d
 8023cd8:	000a2d2d 	.word	0x000a2d2d
 8023cdc:	2e382d25 	.word	0x2e382d25
 8023ce0:	2020732a 	.word	0x2020732a
 8023ce4:	30257830 	.word	0x30257830
 8023ce8:	25207838 	.word	0x25207838
 8023cec:	3a643330 	.word	0x3a643330
 8023cf0:	00000000 	.word	0x00000000
 8023cf4:	2e382d25 	.word	0x2e382d25
 8023cf8:	2020732a 	.word	0x2020732a
 8023cfc:	30257830 	.word	0x30257830
 8023d00:	30207838 	.word	0x30207838
 8023d04:	0000000a 	.word	0x0000000a
 8023d08:	6574756d 	.word	0x6574756d
 8023d0c:	20202078 	.word	0x20202078
 8023d10:	6e776f20 	.word	0x6e776f20
 8023d14:	20207265 	.word	0x20207265
 8023d18:	6f682020 	.word	0x6f682020
 8023d1c:	7320646c 	.word	0x7320646c
 8023d20:	65707375 	.word	0x65707375
 8023d24:	7420646e 	.word	0x7420646e
 8023d28:	61657268 	.word	0x61657268
 8023d2c:	00000a64 	.word	0x00000a64
 8023d30:	2d2d2d2d 	.word	0x2d2d2d2d
 8023d34:	2d2d2d2d 	.word	0x2d2d2d2d
 8023d38:	2d2d2d20 	.word	0x2d2d2d20
 8023d3c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023d40:	2d2d202d 	.word	0x2d2d202d
 8023d44:	2d202d2d 	.word	0x2d202d2d
 8023d48:	2d2d2d2d 	.word	0x2d2d2d2d
 8023d4c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023d50:	2d2d2d2d 	.word	0x2d2d2d2d
 8023d54:	00000a2d 	.word	0x00000a2d
 8023d58:	2e382d25 	.word	0x2e382d25
 8023d5c:	2520732a 	.word	0x2520732a
 8023d60:	2a2e382d 	.word	0x2a2e382d
 8023d64:	30252073 	.word	0x30252073
 8023d68:	25206434 	.word	0x25206434
 8023d6c:	00000a64 	.word	0x00000a64
 8023d70:	6c69616d 	.word	0x6c69616d
 8023d74:	20786f62 	.word	0x20786f62
 8023d78:	746e6520 	.word	0x746e6520
 8023d7c:	73207972 	.word	0x73207972
 8023d80:	20657a69 	.word	0x20657a69
 8023d84:	70737573 	.word	0x70737573
 8023d88:	20646e65 	.word	0x20646e65
 8023d8c:	65726874 	.word	0x65726874
 8023d90:	000a6461 	.word	0x000a6461
 8023d94:	2d2d2d2d 	.word	0x2d2d2d2d
 8023d98:	2d2d2d2d 	.word	0x2d2d2d2d
 8023d9c:	2d2d2d20 	.word	0x2d2d2d20
 8023da0:	2d20202d 	.word	0x2d20202d
 8023da4:	202d2d2d 	.word	0x202d2d2d
 8023da8:	2d2d2d2d 	.word	0x2d2d2d2d
 8023dac:	2d2d2d2d 	.word	0x2d2d2d2d
 8023db0:	2d2d2d2d 	.word	0x2d2d2d2d
 8023db4:	000a2d2d 	.word	0x000a2d2d
 8023db8:	2e382d25 	.word	0x2e382d25
 8023dbc:	2520732a 	.word	0x2520732a
 8023dc0:	20643430 	.word	0x20643430
 8023dc4:	34302520 	.word	0x34302520
 8023dc8:	64252064 	.word	0x64252064
 8023dcc:	0000003a 	.word	0x0000003a
 8023dd0:	2e382d25 	.word	0x2e382d25
 8023dd4:	2520732a 	.word	0x2520732a
 8023dd8:	20643430 	.word	0x20643430
 8023ddc:	34302520 	.word	0x34302520
 8023de0:	64252064 	.word	0x64252064
 8023de4:	0000000a 	.word	0x0000000a
 8023de8:	7167736d 	.word	0x7167736d
 8023dec:	65756575 	.word	0x65756575
 8023df0:	746e6520 	.word	0x746e6520
 8023df4:	73207972 	.word	0x73207972
 8023df8:	65707375 	.word	0x65707375
 8023dfc:	7420646e 	.word	0x7420646e
 8023e00:	61657268 	.word	0x61657268
 8023e04:	00000a64 	.word	0x00000a64
 8023e08:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e0c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e10:	2d2d2d20 	.word	0x2d2d2d20
 8023e14:	2d20202d 	.word	0x2d20202d
 8023e18:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e1c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e20:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e24:	00000a2d 	.word	0x00000a2d
 8023e28:	2e382d25 	.word	0x2e382d25
 8023e2c:	2520732a 	.word	0x2520732a
 8023e30:	20643430 	.word	0x20643430
 8023e34:	3a642520 	.word	0x3a642520
 8023e38:	00000000 	.word	0x00000000
 8023e3c:	2e382d25 	.word	0x2e382d25
 8023e40:	2520732a 	.word	0x2520732a
 8023e44:	20643430 	.word	0x20643430
 8023e48:	0a642520 	.word	0x0a642520
 8023e4c:	00000000 	.word	0x00000000
 8023e50:	686d656d 	.word	0x686d656d
 8023e54:	20706165 	.word	0x20706165
 8023e58:	6f6f7020 	.word	0x6f6f7020
 8023e5c:	6973206c 	.word	0x6973206c
 8023e60:	2020657a 	.word	0x2020657a
 8023e64:	2078616d 	.word	0x2078616d
 8023e68:	64657375 	.word	0x64657375
 8023e6c:	7a697320 	.word	0x7a697320
 8023e70:	76612065 	.word	0x76612065
 8023e74:	616c6961 	.word	0x616c6961
 8023e78:	20656c62 	.word	0x20656c62
 8023e7c:	657a6973 	.word	0x657a6973
 8023e80:	0000000a 	.word	0x0000000a
 8023e84:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e88:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e8c:	2d2d2d20 	.word	0x2d2d2d20
 8023e90:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e94:	202d2d2d 	.word	0x202d2d2d
 8023e98:	2d2d2d2d 	.word	0x2d2d2d2d
 8023e9c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023ea0:	2d2d2d2d 	.word	0x2d2d2d2d
 8023ea4:	2d2d202d 	.word	0x2d2d202d
 8023ea8:	2d2d2d2d 	.word	0x2d2d2d2d
 8023eac:	2d2d2d2d 	.word	0x2d2d2d2d
 8023eb0:	2d2d2d2d 	.word	0x2d2d2d2d
 8023eb4:	0000000a 	.word	0x0000000a
 8023eb8:	2e382d25 	.word	0x2e382d25
 8023ebc:	2520732a 	.word	0x2520732a
 8023ec0:	3031302d 	.word	0x3031302d
 8023ec4:	2d252064 	.word	0x2d252064
 8023ec8:	64333130 	.word	0x64333130
 8023ecc:	302d2520 	.word	0x302d2520
 8023ed0:	000a6435 	.word	0x000a6435
 8023ed4:	706d656d 	.word	0x706d656d
 8023ed8:	206c6f6f 	.word	0x206c6f6f
 8023edc:	6f6c6220 	.word	0x6f6c6220
 8023ee0:	74206b63 	.word	0x74206b63
 8023ee4:	6c61746f 	.word	0x6c61746f
 8023ee8:	65726620 	.word	0x65726620
 8023eec:	75732065 	.word	0x75732065
 8023ef0:	6e657073 	.word	0x6e657073
 8023ef4:	68742064 	.word	0x68742064
 8023ef8:	64616572 	.word	0x64616572
 8023efc:	0000000a 	.word	0x0000000a
 8023f00:	2d2d2d2d 	.word	0x2d2d2d2d
 8023f04:	2d2d2d2d 	.word	0x2d2d2d2d
 8023f08:	2d2d2d20 	.word	0x2d2d2d20
 8023f0c:	2d20202d 	.word	0x2d20202d
 8023f10:	202d2d2d 	.word	0x202d2d2d
 8023f14:	2d2d2d20 	.word	0x2d2d2d20
 8023f18:	2d2d202d 	.word	0x2d2d202d
 8023f1c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023f20:	2d2d2d2d 	.word	0x2d2d2d2d
 8023f24:	2d2d2d2d 	.word	0x2d2d2d2d
 8023f28:	0000000a 	.word	0x0000000a
 8023f2c:	2e382d25 	.word	0x2e382d25
 8023f30:	2520732a 	.word	0x2520732a
 8023f34:	20643430 	.word	0x20643430
 8023f38:	34302520 	.word	0x34302520
 8023f3c:	25202064 	.word	0x25202064
 8023f40:	20643430 	.word	0x20643430
 8023f44:	003a6425 	.word	0x003a6425
 8023f48:	2e382d25 	.word	0x2e382d25
 8023f4c:	2520732a 	.word	0x2520732a
 8023f50:	20643430 	.word	0x20643430
 8023f54:	34302520 	.word	0x34302520
 8023f58:	25202064 	.word	0x25202064
 8023f5c:	20643430 	.word	0x20643430
 8023f60:	000a6425 	.word	0x000a6425
 8023f64:	656d6974 	.word	0x656d6974
 8023f68:	20202072 	.word	0x20202072
 8023f6c:	72657020 	.word	0x72657020
 8023f70:	69646f69 	.word	0x69646f69
 8023f74:	20202063 	.word	0x20202063
 8023f78:	656d6974 	.word	0x656d6974
 8023f7c:	2074756f 	.word	0x2074756f
 8023f80:	66202020 	.word	0x66202020
 8023f84:	0a67616c 	.word	0x0a67616c
 8023f88:	00000000 	.word	0x00000000
 8023f8c:	2d2d2d2d 	.word	0x2d2d2d2d
 8023f90:	2d2d2d2d 	.word	0x2d2d2d2d
 8023f94:	2d2d2d20 	.word	0x2d2d2d20
 8023f98:	2d2d2d2d 	.word	0x2d2d2d2d
 8023f9c:	202d2d2d 	.word	0x202d2d2d
 8023fa0:	2d2d2d2d 	.word	0x2d2d2d2d
 8023fa4:	2d2d2d2d 	.word	0x2d2d2d2d
 8023fa8:	2d202d2d 	.word	0x2d202d2d
 8023fac:	2d2d2d2d 	.word	0x2d2d2d2d
 8023fb0:	2d2d2d2d 	.word	0x2d2d2d2d
 8023fb4:	000a2d2d 	.word	0x000a2d2d
 8023fb8:	2e382d25 	.word	0x2e382d25
 8023fbc:	3020732a 	.word	0x3020732a
 8023fc0:	38302578 	.word	0x38302578
 8023fc4:	78302078 	.word	0x78302078
 8023fc8:	78383025 	.word	0x78383025
 8023fcc:	00000020 	.word	0x00000020
 8023fd0:	69746361 	.word	0x69746361
 8023fd4:	65746176 	.word	0x65746176
 8023fd8:	00000a64 	.word	0x00000a64
 8023fdc:	63616564 	.word	0x63616564
 8023fe0:	61766974 	.word	0x61766974
 8023fe4:	0a646574 	.word	0x0a646574
 8023fe8:	00000000 	.word	0x00000000
 8023fec:	72727563 	.word	0x72727563
 8023ff0:	20746e65 	.word	0x20746e65
 8023ff4:	6b636974 	.word	0x6b636974
 8023ff8:	2578303a 	.word	0x2578303a
 8023ffc:	0a783830 	.word	0x0a783830
 8024000:	00000000 	.word	0x00000000
 8024004:	69766564 	.word	0x69766564
 8024008:	20206563 	.word	0x20206563
 802400c:	70797420 	.word	0x70797420
 8024010:	20202065 	.word	0x20202065
 8024014:	20202020 	.word	0x20202020
 8024018:	20202020 	.word	0x20202020
 802401c:	20202020 	.word	0x20202020
 8024020:	65722020 	.word	0x65722020
 8024024:	6f632066 	.word	0x6f632066
 8024028:	0a746e75 	.word	0x0a746e75
 802402c:	00000000 	.word	0x00000000
 8024030:	2d2d2d2d 	.word	0x2d2d2d2d
 8024034:	2d2d2d2d 	.word	0x2d2d2d2d
 8024038:	2d2d2d20 	.word	0x2d2d2d20
 802403c:	2d2d2d2d 	.word	0x2d2d2d2d
 8024040:	2d2d2d2d 	.word	0x2d2d2d2d
 8024044:	2d2d2d2d 	.word	0x2d2d2d2d
 8024048:	2d2d2d2d 	.word	0x2d2d2d2d
 802404c:	2d2d202d 	.word	0x2d2d202d
 8024050:	2d2d2d2d 	.word	0x2d2d2d2d
 8024054:	2d2d2d2d 	.word	0x2d2d2d2d
 8024058:	0000000a 	.word	0x0000000a
 802405c:	2e382d25 	.word	0x2e382d25
 8024060:	2520732a 	.word	0x2520732a
 8024064:	7330322d 	.word	0x7330322d
 8024068:	382d2520 	.word	0x382d2520
 802406c:	00000a64 	.word	0x00000a64
 8024070:	72616843 	.word	0x72616843
 8024074:	65746361 	.word	0x65746361
 8024078:	65442072 	.word	0x65442072
 802407c:	65636976 	.word	0x65636976
 8024080:	00000000 	.word	0x00000000
 8024084:	636f6c42 	.word	0x636f6c42
 8024088:	6544206b 	.word	0x6544206b
 802408c:	65636976 	.word	0x65636976
 8024090:	00000000 	.word	0x00000000
 8024094:	7774654e 	.word	0x7774654e
 8024098:	206b726f 	.word	0x206b726f
 802409c:	65746e49 	.word	0x65746e49
 80240a0:	63616672 	.word	0x63616672
 80240a4:	00000065 	.word	0x00000065
 80240a8:	2044544d 	.word	0x2044544d
 80240ac:	69766544 	.word	0x69766544
 80240b0:	00006563 	.word	0x00006563
 80240b4:	204e4143 	.word	0x204e4143
 80240b8:	69766544 	.word	0x69766544
 80240bc:	00006563 	.word	0x00006563
 80240c0:	00435452 	.word	0x00435452
 80240c4:	6e756f53 	.word	0x6e756f53
 80240c8:	65442064 	.word	0x65442064
 80240cc:	65636976 	.word	0x65636976
 80240d0:	00000000 	.word	0x00000000
 80240d4:	70617247 	.word	0x70617247
 80240d8:	20636968 	.word	0x20636968
 80240dc:	69766544 	.word	0x69766544
 80240e0:	00006563 	.word	0x00006563
 80240e4:	20433249 	.word	0x20433249
 80240e8:	00737542 	.word	0x00737542
 80240ec:	20425355 	.word	0x20425355
 80240f0:	76616c53 	.word	0x76616c53
 80240f4:	65442065 	.word	0x65442065
 80240f8:	65636976 	.word	0x65636976
 80240fc:	00000000 	.word	0x00000000
 8024100:	20425355 	.word	0x20425355
 8024104:	74736f48 	.word	0x74736f48
 8024108:	73754220 	.word	0x73754220
 802410c:	00000000 	.word	0x00000000
 8024110:	20495053 	.word	0x20495053
 8024114:	00737542 	.word	0x00737542
 8024118:	20495053 	.word	0x20495053
 802411c:	69766544 	.word	0x69766544
 8024120:	00006563 	.word	0x00006563
 8024124:	4f494453 	.word	0x4f494453
 8024128:	73754220 	.word	0x73754220
 802412c:	00000000 	.word	0x00000000
 8024130:	50204d50 	.word	0x50204d50
 8024134:	64756573 	.word	0x64756573
 8024138:	6544206f 	.word	0x6544206f
 802413c:	65636976 	.word	0x65636976
 8024140:	00000000 	.word	0x00000000
 8024144:	65706950 	.word	0x65706950
 8024148:	00000000 	.word	0x00000000
 802414c:	74726f50 	.word	0x74726f50
 8024150:	44206c61 	.word	0x44206c61
 8024154:	63697665 	.word	0x63697665
 8024158:	00000065 	.word	0x00000065
 802415c:	656d6954 	.word	0x656d6954
 8024160:	65442072 	.word	0x65442072
 8024164:	65636976 	.word	0x65636976
 8024168:	00000000 	.word	0x00000000
 802416c:	6373694d 	.word	0x6373694d
 8024170:	616c6c65 	.word	0x616c6c65
 8024174:	756f656e 	.word	0x756f656e
 8024178:	65442073 	.word	0x65442073
 802417c:	65636976 	.word	0x65636976
 8024180:	00000000 	.word	0x00000000
 8024184:	6e6b6e55 	.word	0x6e6b6e55
 8024188:	006e776f 	.word	0x006e776f
 802418c:	08024070 	.word	0x08024070
 8024190:	08024084 	.word	0x08024084
 8024194:	08024094 	.word	0x08024094
 8024198:	080240a8 	.word	0x080240a8
 802419c:	080240b4 	.word	0x080240b4
 80241a0:	080240c0 	.word	0x080240c0
 80241a4:	080240c4 	.word	0x080240c4
 80241a8:	080240d4 	.word	0x080240d4
 80241ac:	080240e4 	.word	0x080240e4
 80241b0:	080240ec 	.word	0x080240ec
 80241b4:	08024100 	.word	0x08024100
 80241b8:	08024110 	.word	0x08024110
 80241bc:	08024118 	.word	0x08024118
 80241c0:	08024124 	.word	0x08024124
 80241c4:	08024130 	.word	0x08024130
 80241c8:	08024144 	.word	0x08024144
 80241cc:	0802414c 	.word	0x0802414c
 80241d0:	0802415c 	.word	0x0802415c
 80241d4:	0802416c 	.word	0x0802416c
 80241d8:	08024184 	.word	0x08024184
 80241dc:	75462d2d 	.word	0x75462d2d
 80241e0:	6974636e 	.word	0x6974636e
 80241e4:	4c206e6f 	.word	0x4c206e6f
 80241e8:	3a747369 	.word	0x3a747369
 80241ec:	0000000a 	.word	0x0000000a
 80241f0:	00005f5f 	.word	0x00005f5f
 80241f4:	36312d25 	.word	0x36312d25
 80241f8:	2d2d2073 	.word	0x2d2d2073
 80241fc:	0a732520 	.word	0x0a732520
 8024200:	00000000 	.word	0x00000000
 8024204:	205d6c5b 	.word	0x205d6c5b
 8024208:	000a7325 	.word	0x000a7325
 802420c:	61562d2d 	.word	0x61562d2d
 8024210:	62616972 	.word	0x62616972
 8024214:	4c20656c 	.word	0x4c20656c
 8024218:	3a747369 	.word	0x3a747369
 802421c:	0000000a 	.word	0x0000000a
 8024220:	75662d2d 	.word	0x75662d2d
 8024224:	6974636e 	.word	0x6974636e
 8024228:	0a3a6e6f 	.word	0x0a3a6e6f
 802422c:	00000000 	.word	0x00000000
 8024230:	61762d2d 	.word	0x61762d2d
 8024234:	62616972 	.word	0x62616972
 8024238:	0a3a656c 	.word	0x0a3a656c
 802423c:	00000000 	.word	0x00000000
 8024240:	205d765b 	.word	0x205d765b
 8024244:	000a7325 	.word	0x000a7325
 8024248:	542d5452 	.word	0x542d5452
 802424c:	61657268 	.word	0x61657268
 8024250:	68732064 	.word	0x68732064
 8024254:	206c6c65 	.word	0x206c6c65
 8024258:	6d6d6f63 	.word	0x6d6d6f63
 802425c:	73646e61 	.word	0x73646e61
 8024260:	00000a3a 	.word	0x00000a3a
 8024264:	6d635f5f 	.word	0x6d635f5f
 8024268:	00005f64 	.word	0x00005f64
 802426c:	36312d25 	.word	0x36312d25
 8024270:	202d2073 	.word	0x202d2073
 8024274:	000a7325 	.word	0x000a7325
 8024278:	0000000a 	.word	0x0000000a
 802427c:	00646d63 	.word	0x00646d63
 8024280:	70746572 	.word	0x70746572
 8024284:	00000000 	.word	0x00000000
 8024288:	203a7325 	.word	0x203a7325
 802428c:	6d6d6f63 	.word	0x6d6d6f63
 8024290:	20646e61 	.word	0x20646e61
 8024294:	20746f6e 	.word	0x20746f6e
 8024298:	6e756f66 	.word	0x6e756f66
 802429c:	000a2e64 	.word	0x000a2e64
 80242a0:	000a7325 	.word	0x000a7325
 80242a4:	65206f4e 	.word	0x65206f4e
 80242a8:	726f7272 	.word	0x726f7272
 80242ac:	00000000 	.word	0x00000000
 80242b0:	61766e49 	.word	0x61766e49
 80242b4:	2064696c 	.word	0x2064696c
 80242b8:	656b6f74 	.word	0x656b6f74
 80242bc:	0000006e 	.word	0x0000006e
 80242c0:	65707845 	.word	0x65707845
 80242c4:	61207463 	.word	0x61207463
 80242c8:	70797420 	.word	0x70797420
 80242cc:	00000065 	.word	0x00000065
 80242d0:	6e6b6e55 	.word	0x6e6b6e55
 80242d4:	206e776f 	.word	0x206e776f
 80242d8:	65707974 	.word	0x65707974
 80242dc:	00000000 	.word	0x00000000
 80242e0:	69726156 	.word	0x69726156
 80242e4:	656c6261 	.word	0x656c6261
 80242e8:	69786520 	.word	0x69786520
 80242ec:	00007473 	.word	0x00007473
 80242f0:	65707845 	.word	0x65707845
 80242f4:	61207463 	.word	0x61207463
 80242f8:	65706f20 	.word	0x65706f20
 80242fc:	65746172 	.word	0x65746172
 8024300:	00000072 	.word	0x00000072
 8024304:	6f6d654d 	.word	0x6f6d654d
 8024308:	66207972 	.word	0x66207972
 802430c:	006c6c75 	.word	0x006c6c75
 8024310:	6e6b6e55 	.word	0x6e6b6e55
 8024314:	206e776f 	.word	0x206e776f
 8024318:	7265706f 	.word	0x7265706f
 802431c:	726f7461 	.word	0x726f7461
 8024320:	00000000 	.word	0x00000000
 8024324:	6e6b6e55 	.word	0x6e6b6e55
 8024328:	206e776f 	.word	0x206e776f
 802432c:	65646f6e 	.word	0x65646f6e
 8024330:	00000000 	.word	0x00000000
 8024334:	65707845 	.word	0x65707845
 8024338:	61207463 	.word	0x61207463
 802433c:	61686320 	.word	0x61686320
 8024340:	74636172 	.word	0x74636172
 8024344:	00007265 	.word	0x00007265
 8024348:	78656e55 	.word	0x78656e55
 802434c:	74636570 	.word	0x74636570
 8024350:	646e6520 	.word	0x646e6520
 8024354:	00000000 	.word	0x00000000
 8024358:	6e6b6e55 	.word	0x6e6b6e55
 802435c:	206e776f 	.word	0x206e776f
 8024360:	656b6f74 	.word	0x656b6f74
 8024364:	0000006e 	.word	0x0000006e
 8024368:	616f6c46 	.word	0x616f6c46
 802436c:	6f6e2074 	.word	0x6f6e2074
 8024370:	75732074 	.word	0x75732074
 8024374:	726f7070 	.word	0x726f7070
 8024378:	00646574 	.word	0x00646574
 802437c:	6e6b6e55 	.word	0x6e6b6e55
 8024380:	206e776f 	.word	0x206e776f
 8024384:	626d7973 	.word	0x626d7973
 8024388:	00006c6f 	.word	0x00006c6f
 802438c:	6c6c754e 	.word	0x6c6c754e
 8024390:	646f6e20 	.word	0x646f6e20
 8024394:	00000065 	.word	0x00000065
 8024398:	64696f76 	.word	0x64696f76
 802439c:	00000000 	.word	0x00000000
 80243a0:	72616863 	.word	0x72616863
 80243a4:	00000000 	.word	0x00000000
 80243a8:	726f6873 	.word	0x726f6873
 80243ac:	00000074 	.word	0x00000074
 80243b0:	00746e69 	.word	0x00746e69
 80243b4:	676e6f6c 	.word	0x676e6f6c
 80243b8:	00000000 	.word	0x00000000
 80243bc:	69736e75 	.word	0x69736e75
 80243c0:	64656e67 	.word	0x64656e67
 80243c4:	00000000 	.word	0x00000000
 80243c8:	4c4c554e 	.word	0x4c4c554e
 80243cc:	00000000 	.word	0x00000000
 80243d0:	6c6c756e 	.word	0x6c6c756e
 80243d4:	00000000 	.word	0x00000000

080243d8 <APBAHBPrescTable>:
 80243d8:	00000000 04030201 04030201 09080706     ................

080243e8 <stm32_can_ops>:
 80243e8:	0800d2b5 0800cf89 0800cfdd 0800d0b5     ................

080243f8 <__FUNCTION__.12225>:
 80243f8:	336d7473 41435f32 6365724e 67736d76     stm32_CANrecvmsg
 8024408:	00000000                                ....

0802440c <stm32_uart_ops>:
 802440c:	0800f089 0800f2ad 0800f431 0800f481     ........1.......
 802441c:	0800f4d1                                ....

08024420 <__FUNCTION__.12007>:
 8024420:	336d7473 6f635f32 6769666e 00657275     stm32_configure.

08024430 <__FUNCTION__.12050>:
 8024430:	336d7473 6f635f32 6f72746e 0000006c     stm32_control...

08024440 <__FUNCTION__.12061>:
 8024440:	336d7473 75705f32 00006374              stm32_putc..

0802444c <__FUNCTION__.12071>:
 802444c:	336d7473 65675f32 00006374              stm32_getc..

08024458 <__FUNCTION__.12082>:
 8024458:	336d7473 6d645f32 72745f61 6d736e61     stm32_dma_transm
 8024468:	00007469                                it..

0802446c <__fsym___cmd_CANtx_name>:
 802446c:	6d635f5f 41435f64 0078744e              __cmd_CANtx.

08024478 <__fsym___cmd_CANtx_desc>:
 8024478:	744e4143 65732078 6973646e 7020657a     CANtx sendsize p
 8024488:	73702066 00000000                       f ps....

08024490 <__fsym___cmd_TS_name>:
 8024490:	6d635f5f 53545f64 00000000              __cmd_TS....

0802449c <__fsym___cmd_TS_desc>:
 802449c:	30205354 20726f20 31205354 20726f20     TS 0 or TS 1 or 
 80244ac:	32205354 20726f20 33205354 00000000     TS 2 or TS 3....

080244bc <__fsym___cmd_FANtest_name>:
 80244bc:	6d635f5f 41465f64 7365744e 00000074     __cmd_FANtest...

080244cc <__fsym___cmd_FANtest_desc>:
 80244cc:	744e4146 20747365 6f206e6f 41462072     FANtest on or FA
 80244dc:	7365744e 666f2074 00000066              Ntest off...

080244e8 <__fsym___cmd_ADCtest_name>:
 80244e8:	6d635f5f 44415f64 73657443 00000074     __cmd_ADCtest...

080244f8 <__fsym___cmd_ADCtest_desc>:
 80244f8:	74434441 20747365 6e697270 44412074     ADCtest print AD
 8024508:	6c615643 00006575                       CValue..

08024510 <__fsym___cmd_PWMset_name>:
 8024510:	6d635f5f 57505f64 7465734d 00000000     __cmd_PWMset....

08024520 <__fsym___cmd_PWMset_desc>:
 8024520:	734d5750 54207465 32542031 00335420     PWMset T1 T2 T3.

08024530 <__fsym___cmd_PWMdis_name>:
 8024530:	6d635f5f 57505f64 7369644d 00000000     __cmd_PWMdis....

08024540 <__fsym___cmd_PWMdis_desc>:
 8024540:	644d5750 62617369 0000656c              PWMdisable..

0802454c <__fsym___cmd_PWMen_name>:
 802454c:	6d635f5f 57505f64 006e654d              __cmd_PWMen.

08024558 <__fsym___cmd_PWMen_desc>:
 8024558:	654d5750 6c62616e 00000065              PWMenable...

08024564 <__fsym___cmd_MCctrl_name>:
 8024564:	6d635f5f 434d5f64 6c727463 00000000     __cmd_MCctrl....

08024574 <__fsym___cmd_MCctrl_desc>:
 8024574:	7463434d 6f206c72 726f206e 63434d20     MCctrl on or MCc
 8024584:	206c7274 0066666f                       trl off.

0802458c <__fsym___cmd_QEPtest_name>:
 802458c:	6d635f5f 45515f64 73657450 00000074     __cmd_QEPtest...

0802459c <__fsym___cmd_QEPtest_desc>:
 802459c:	74504551 00747365                       QEPtest.

080245a4 <circle_limit_table>:
 80245a4:	7dce7ee3 7bb87cc0 7a397ab7 784f7941     .~.}.|.{.z9zAyOx
 80245b4:	767b7763 74bc7599 731073e4 71db72a8     cw{v.u.t.s.s.r.q
 80245c4:	704e7113 6ed16f8d 6d626e17 6c586cb0     .qNp.o.n.nbm.lXl
 80245d4:	6b016bab 69b66a5a 68776915 674367dc     .k.kZj.i.iwh.gCg
 80245e4:	666366f8 654165d1 642964b4 631963a0     .fcf.eAe.d)d.c.c
 80245f4:	62536294 615161d1 605860d4 5f665fde     .bSb.aQa.`X`._f_
 8024604:	5e7a5eef 5dcf5e41 5cef5d5e 5c155c81     .^z^A^.]^].\.\.\
 8024614:	5b425bab 5aa65ada 59dc5a41 59185979     .[B[.Z.ZAZ.YyY.Y
 8024624:	585858b7 579d57f9                       .XXX.W.W

0802462c <hSin_Cos_Table>:
 802462c:	03240000 096a0648 0fab0c8c 15e212c8     ..$.H.j.........
 802463c:	1c0b18f9 22231f1a 28262528 2e112b1f     ......#"(%&(.+..
 802464c:	33df30fb 398c36ba 3f173c56 447a41ce     .0.3.6.9V<.?.AzD
 802465c:	49b4471c 4ebf4c3f 539b5133 584255f5     .G.I?L.N3Q.S.UBX
 802466c:	5cb35a82 60eb5ed7 64e862f1 68a666cf     .Z.\.^.`.b.d.f.h
 802467c:	6c236a6d 6f5e6dc9 725470e2 750473b5     mj#l.m^o.pTr.s.u
 802468c:	776b7641 79897884 7b5c7a7c 7ce37c29     Avkw.x.y|z\{)|.|
 802469c:	7e1d7d89 7f097e9c 7fa67f61 7ff57fd8     .}.~.~..a.......
 80246ac:	7ff57fff 7fa67fd8 7f097f61 7e1d7e9c     ........a....~.~
 80246bc:	7ce37d89 7b5c7c29 79897a7c 776b7884     .}.|)|\{|z.y.xkw
 80246cc:	75047641 725473b5 6f5e70e2 6c236dc9     Av.u.sTr.p^o.m#l
 80246dc:	68a66a6d 64e866cf 60eb62f1 5cb35ed7     mj.h.f.d.b.`.^.\
 80246ec:	58425a82 539b55f5 4ebf5133 49b44c3f     .ZBX.U.S3Q.N?L.I
 80246fc:	447a471c 3f1741ce 398c3c56 33df36ba     .GzD.A.?V<.9.6.3
 802470c:	2e1130fb 28262b1f 22232528 1c0b1f1a     .0...+&((%#"....
 802471c:	15e218f9 0fab12c8 096a0c8c 03240648     ..........j.H.$.
 802472c:	fcdc0000 f696f9b8 f055f374 ea1eed38     ........t.U.8...
 802473c:	e3f5e707 dddde0e6 d7dadad8 d1efd4e1     ................
 802474c:	cc21cf05 c674c946 c0e9c3aa bb86be32     ..!.F.t.....2...
 802475c:	b64cb8e4 b141b3c1 ac65aecd a7beaa0b     ..L...A...e.....
 802476c:	a34da57e 9f15a129 9b189d0f 975a9931     ~.M.).......1.Z.
 802477c:	93dd9593 90a29237 8dac8f1e 8afc8c4b     ....7.......K...
 802478c:	889589bf 8677877c 84a48584 831d83d7     ....|.w.........
 802479c:	81e38277 80f78164 805a809f 800b8028     w...d.....Z.(...
 80247ac:	800b8001 805a8028 80f7809f 81e38164     ....(.Z.....d...
 80247bc:	831d8277 84a483d7 86778584 8895877c     w.........w.|...
 80247cc:	8afc89bf 8dac8c4b 90a28f1e 93dd9237     ....K.......7...
 80247dc:	975a9593 9b189931 9f159d0f a34da129     ..Z.1.......).M.
 80247ec:	a7bea57e ac65aa0b b141aecd b64cb3c1     ~.....e...A...L.
 80247fc:	bb86b8e4 c0e9be32 c674c3aa cc21c946     ....2.....t.F.!.
 802480c:	d1efcf05 d7dad4e1 dddddad8 e3f5e0e6     ................
 802481c:	ea1ee707 f055ed38 f696f374 fcdcf9b8     ....8.U.t.......

0802482c <hflux_reference>:
 802482c:	238e2406 22992318 21b82227 20e0214b     .$.#.#."'".!K!. 
 802483c:	20102077 1f481fab 1e881ee7 1dc61e22     w . ..H....."...
 802484c:	1d141d6c 1c671cbc 1bc01c13 1b1f1b6f     l.....g.....o...
 802485c:	1a7b1ad0 19e41a2f 1951199a 18c3190a     ..{./.....Q.....
 802486c:	1839187e 17b317f5 172a176b 16ab16ea     ~.9.....k.*.....
 802487c:	162f166d 15b715f3 1541157b 14c91507     m./.....{.A.....
 802488c:	14591491 13ec1422 138113b6 1318134c     ..Y.".......L...
 802489c:	12b212e5 1249127b 11e71218 118711b7     ....{.I.........
 80248ac:	11281157 10cb10fa 106c109e 1013103f     W.(.......l.?...
 80248bc:	0fbb0fe7 0f640f8f 0f0f0f39 0ebb0ee5     ......d.9.......
 80248cc:	0e640e8d 0e120e3b 0dc20dea 0d720d9a     ..d.;.........r.
 80248dc:	0d230d4b 0cf70d0b 0cd20ce4 0cae0cc0     K.#.............
 80248ec:	0c8a0c9c 0c680c79 0c460c57 0c230c34     ....y.h.W.F.4.#.
 80248fc:	0c030c13 0be30bf3 0bc40bd3 0ba50bb4     ................
 802490c:	0b860b96 0b690b77 0b4c0b5a 0b300b3e     ....w.i.Z.L.>.0.
 802491c:	0b140b22 0af90b07 0ade0aeb 0ac30ad0     "...............
 802492c:	0aaa0ab7 0a910a9d 0a780a84 0a5f0a6c     ..........x.l._.
 802493c:	0a470a53 0a300a3c 0a190a24 0a030a0e     S.G.<.0.$.......
 802494c:	09ec09f7 09d609e1 09c009cb 09ab09b6     ................
 802495c:	099709a1 0982098d 096e0978 095a0964     ........x.n.d.Z.
 802496c:	09470950 0934093d 0921092a 090f0918     P.G.=.4.*.!.....
 802497c:	08fc0905 08ea08f3 08d808e1 08c708d0     ................
 802498c:	08b608be 08a408ae 0894089c 0884088c     ................
 802499c:	0874087c 0864086c 0854085c 0844084c     |.t.l.d.\.T.L.D.
 80249ac:	0835083d 0826082e 0818081f 08090810     =.5...&.........
 80249bc:	07fa0802 07ec07f3 07de07e5 07d107d7     ................
 80249cc:	07c307ca 07b507bc 07a807af 079b07a1     ................
 80249dc:	078e0795 07820788 0775077b 0768076e     ........{.u.n.h.
 80249ec:	075c0762 07500756 0744074a 0739073e     b.\.V.P.J.D.>.9.
 80249fc:	072d0733 07210727 0716071c 070b0710     3.-.'.!.........
 8024a0c:	07000705 06f506fa 06ea06ef 06df06e5     ................
 8024a1c:	06d506da 06ca06d0 06c006c5 06b606bb     ................

08024a2c <htorque_reference>:
 8024a2c:	4d334cfb 4da14d69 4e034dd3 4e5e4e31     .L3MiM.M.M.N1N^N
 8024a3c:	4eb34e89 4f064edf 4f514f2c 4f964f74     .N.N.N.O,OQOtO.O
 8024a4c:	4fdb4fb7 50184ffa 50525035 5088506d     .O.O.O.P5PRPmP.P
 8024a5c:	50be50a5 50ef50d7 511d5106 51485133     .P.P.P.P.Q.Q3QHQ
 8024a6c:	5173515f 519a5187 51bf51ad 51e451d1     _QsQ.Q.Q.Q.Q.Q.Q
 8024a7c:	520651f5 52265216 52445235 52625254     .Q.R.R&R5RDRTRbR
 8024a8c:	527e5270 5299528b 52b352a5 52cb52bf     pR~R.R.R.R.R.R.R
 8024a9c:	52e252d7 52f852ed 530e5303 53235319     .R.R.R.R.S.S.S#S
 8024aac:	5336532d 53495340 535c5353 536d5365     -S6S@SISSS\SeSmS
 8024abc:	537e5376 538e5386 539e5396 53ad53a5     vS~S.S.S.S.S.S.S
 8024acc:	53bb53b4 53c953c2 53d753d0 53e353dd     .S.S.S.S.S.S.S.S
 8024adc:	53f053ea 53fc53f6 53f05402 53045379     .S.S.S.S.T.SyS.S
 8024aec:	52135290 513151a2 505550c2 4f7c4fe8     .R.R.Q1Q.PUP.O|O
 8024afc:	4e9f4f08 4dd04e37 4d054d6a 4c364ca1     .O.N7N.MjM.M.L6L
 8024b0c:	4b734bd4 4ab44b13 49f94a56 4939499d     .KsK.K.JVJ.I.I9I
 8024b1c:	488548df 47d5482d 4728477e 467746cb     .H.H-H.G~G(G.FwF
 8024b2c:	45d04623 452d457e 448544dc 43e74436     #F.E~E-E.D.D6D.C
 8024b3c:	434d439a 42b54300 42194263 418641cf     .CMC.C.BcB.B.A.A
 8024b4c:	40f6413e 406840af 3fd7401c 3f4e3f92     >A.@.@h@.@.?.?N?
 8024b5c:	3ec73f0a 3e3d3e85 3dbb3dfc 3d3b3d7b     .?.>.>=>.=.={=;=
 8024b6c:	3cbd3cfc 3c3c3c79 3bc23bfe 3b4a3b86     .<.<y<<<.;.;.;J;
 8024b7c:	3ace3b0f 3a5a3a94 39e83a21 397739af     .;.:.:Z:!:.9.9w9
 8024b8c:	39033940 389638cc 382a3860 37c037f5     @9.9.8.8`8*8.7.7
 8024b9c:	37533787 36ec3720 368736b9 361f3655     .7S7 7.6.6.6U6.6
 8024bac:	35bc35ed 355b358b 34fb352b 349934c8     .5.5.5[5+5.4.4.4
 8024bbc:	343c346a 33e0340e 338533b3 33283355     j4<4.4.3.3.3U3(3
 8024bcc:	32d032fc 327932a5 3220324e 31cb31f5     .2.2.2y2N2 2.1.1
 8024bdc:	317831a1 3126314f 30d130f9 308130a8     .1x1O1&1.0.0.0.0
 8024bec:	30313059 2fe0300a 2f932fb9 2f462f6c     Y010.0./././l/F/
 8024bfc:	2efb2f21 2eae2ed6 2e642e89 2e1c2e40     !/........d.@...
 8024c0c:	2dd42df8 2d8b2dae 2d452d68 2d002d22     .-.-.-.-h-E-"-.-
 8024c1c:	2cb92cde 2c752c97 2c332c54 2bf12c12     .,.,.,u,T,3,.,.+

08024c2c <__FUNCTION__.4872>:
 8024c2c:	645f7472 63697665 706f5f65 00006e65     rt_device_open..

08024c3c <__FUNCTION__.4877>:
 8024c3c:	645f7472 63697665 6c635f65 0065736f     rt_device_close.

08024c4c <__FUNCTION__.4884>:
 8024c4c:	645f7472 63697665 65725f65 00006461     rt_device_read..

08024c5c <__FUNCTION__.4891>:
 8024c5c:	645f7472 63697665 72775f65 00657469     rt_device_write.

08024c6c <__FUNCTION__.4897>:
 8024c6c:	645f7472 63697665 6f635f65 6f72746e     rt_device_contro
 8024c7c:	0000006c                                l...

08024c80 <__FUNCTION__.4904>:
 8024c80:	645f7472 63697665 65735f65 78725f74     rt_device_set_rx
 8024c90:	646e695f 74616369 00000065              _indicate...

08024c9c <__FUNCTION__.4918>:
 8024c9c:	745f7472 61657268 64695f64 655f656c     rt_thread_idle_e
 8024cac:	74756378 00000065                       xcute...

08024cb4 <__FUNCTION__.4940>:
 8024cb4:	735f7472 695f6d65 0074696e              rt_sem_init.

08024cc0 <__FUNCTION__.4952>:
 8024cc0:	735f7472 635f6d65 74616572 00000065     rt_sem_create...

08024cd0 <__FUNCTION__.4964>:
 8024cd0:	735f7472 745f6d65 00656b61              rt_sem_take.

08024cdc <__FUNCTION__.4988>:
 8024cdc:	6d5f7472 78657475 696e695f 00000074     rt_mutex_init...

08024cec <__FUNCTION__.5012>:
 8024cec:	6d5f7472 78657475 6b61745f 00000065     rt_mutex_take...

08024cfc <__FUNCTION__.5021>:
 8024cfc:	6d5f7472 78657475 6c65725f 65736165     rt_mutex_release
 8024d0c:	00000000                                ....

08024d10 <__FUNCTION__.5177>:
 8024d10:	6d5f7472 72635f71 65746165 00000000     rt_mq_create....

08024d20 <__FUNCTION__.5185>:
 8024d20:	6d5f7472 65645f71 6574656c 00000000     rt_mq_delete....

08024d30 <__FUNCTION__.5193>:
 8024d30:	6d5f7472 65735f71 0000646e              rt_mq_send..

08024d3c <__FUNCTION__.5212>:
 8024d3c:	6d5f7472 65725f71 00007663              rt_mq_recv..

08024d48 <__lowest_bit_bitmap>:
 8024d48:	00010000 00010002 00010003 00010002     ................
 8024d58:	00010004 00010002 00010003 00010002     ................
 8024d68:	00010005 00010002 00010003 00010002     ................
 8024d78:	00010004 00010002 00010003 00010002     ................
 8024d88:	00010006 00010002 00010003 00010002     ................
 8024d98:	00010004 00010002 00010003 00010002     ................
 8024da8:	00010005 00010002 00010003 00010002     ................
 8024db8:	00010004 00010002 00010003 00010002     ................
 8024dc8:	00010007 00010002 00010003 00010002     ................
 8024dd8:	00010004 00010002 00010003 00010002     ................
 8024de8:	00010005 00010002 00010003 00010002     ................
 8024df8:	00010004 00010002 00010003 00010002     ................
 8024e08:	00010006 00010002 00010003 00010002     ................
 8024e18:	00010004 00010002 00010003 00010002     ................
 8024e28:	00010005 00010002 00010003 00010002     ................
 8024e38:	00010004 00010002 00010003 00010002     ................

08024e48 <large_digits.5065>:
 8024e48:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 8024e58:	00000000                                ....

08024e5c <small_digits.5064>:
 8024e5c:	33323130 37363534 62613938 66656463     0123456789abcdef
 8024e6c:	00000000                                ....

08024e70 <__fsym_list_mem_name>:
 8024e70:	7473696c 6d656d5f 00000000              list_mem....

08024e7c <__fsym_list_mem_desc>:
 8024e7c:	7473696c 6d656d20 2079726f 67617375     list memory usag
 8024e8c:	6e692065 6d726f66 6f697461 0000006e     e information...

08024e9c <__FUNCTION__.4931>:
 8024e9c:	67756c70 6c6f685f 00007365              plug_holes..

08024ea8 <__FUNCTION__.4940>:
 8024ea8:	735f7472 65747379 65685f6d 695f7061     rt_system_heap_i
 8024eb8:	0074696e                                nit.

08024ebc <__FUNCTION__.4949>:
 8024ebc:	6d5f7472 6f6c6c61 00000063              rt_malloc...

08024ec8 <__FUNCTION__.4967>:
 8024ec8:	725f7472 6c6c6165 0000636f              rt_realloc..

08024ed4 <__FUNCTION__.4980>:
 8024ed4:	665f7472 00656572                       rt_free.

08024edc <__FUNCTION__.4907>:
 8024edc:	6d5f7472 65686d65 695f7061 0074696e     rt_memheap_init.

08024eec <__FUNCTION__.4948>:
 8024eec:	6f5f7472 63656a62 65645f74 68636174     rt_object_detach
 8024efc:	00000000                                ....

08024f00 <__FUNCTION__.4957>:
 8024f00:	6f5f7472 63656a62 6c615f74 61636f6c     rt_object_alloca
 8024f10:	00006574                                te..

08024f14 <__FUNCTION__.4962>:
 8024f14:	6f5f7472 63656a62 65645f74 6574656c     rt_object_delete
 8024f24:	00000000                                ....

08024f28 <__FUNCTION__.4966>:
 8024f28:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
 8024f38:	6f6d6574 63656a62 00000074              temobject...

08024f44 <__FUNCTION__.4920>:
 8024f44:	5f74725f 65686373 656c7564 74735f72     _rt_scheduler_st
 8024f54:	5f6b6361 63656863 0000006b              ack_check...

08024f60 <__FUNCTION__.4951>:
 8024f60:	735f7472 64656863 5f656c75 65736e69     rt_schedule_inse
 8024f70:	745f7472 61657268 00000064              rt_thread...

08024f7c <__FUNCTION__.4956>:
 8024f7c:	735f7472 64656863 5f656c75 6f6d6572     rt_schedule_remo
 8024f8c:	745f6576 61657268 00000064              ve_thread...

08024f98 <__FUNCTION__.4919>:
 8024f98:	5f74725f 65726874 695f6461 0074696e     _rt_thread_init.

08024fa8 <__FUNCTION__.4931>:
 8024fa8:	745f7472 61657268 6e695f64 00007469     rt_thread_init..

08024fb8 <__FUNCTION__.4938>:
 8024fb8:	745f7472 61657268 74735f64 75747261     rt_thread_startu
 8024fc8:	00000070                                p...

08024fcc <__FUNCTION__.4959>:
 8024fcc:	745f7472 61657268 65645f64 6574656c     rt_thread_delete
 8024fdc:	00000000                                ....

08024fe0 <__FUNCTION__.4970>:
 8024fe0:	745f7472 61657268 6c735f64 00706565     rt_thread_sleep.

08024ff0 <__FUNCTION__.4980>:
 8024ff0:	745f7472 61657268 6f635f64 6f72746e     rt_thread_contro
 8025000:	0000006c                                l...

08025004 <__FUNCTION__.4990>:
 8025004:	745f7472 61657268 75735f64 6e657073     rt_thread_suspen
 8025014:	00000064                                d...

08025018 <__FUNCTION__.4995>:
 8025018:	745f7472 61657268 65725f64 656d7573     rt_thread_resume
 8025028:	00000000                                ....

0802502c <__FUNCTION__.5000>:
 802502c:	745f7472 61657268 69745f64 756f656d     rt_thread_timeou
 802503c:	00000074                                t...

08025040 <__FUNCTION__.4946>:
 8025040:	745f7472 72656d69 696e695f 00000074     rt_timer_init...

08025050 <__FUNCTION__.4951>:
 8025050:	745f7472 72656d69 7465645f 00686361     rt_timer_detach.

08025060 <__FUNCTION__.4975>:
 8025060:	745f7472 72656d69 6174735f 00007472     rt_timer_start..

08025070 <__FUNCTION__.4992>:
 8025070:	745f7472 72656d69 6f74735f 00000070     rt_timer_stop...

08025080 <__FUNCTION__.4998>:
 8025080:	745f7472 72656d69 6e6f635f 6c6f7274     rt_timer_control
 8025090:	00000000                                ....

08025094 <__FUNCTION__.6081>:
 8025094:	635f7472 6c706d6f 6f697465 6e695f6e     rt_completion_in
 80250a4:	00007469                                it..

080250a8 <__FUNCTION__.6089>:
 80250a8:	635f7472 6c706d6f 6f697465 61775f6e     rt_completion_wa
 80250b8:	00007469                                it..

080250bc <__FUNCTION__.6096>:
 80250bc:	635f7472 6c706d6f 6f697465 6f645f6e     rt_completion_do
 80250cc:	0000656e                                ne..

080250d0 <__FUNCTION__.6087>:
 80250d0:	645f7472 5f617461 75657571 6e695f65     rt_data_queue_in
 80250e0:	00007469                                it..

080250e4 <__FUNCTION__.6098>:
 80250e4:	645f7472 5f617461 75657571 75705f65     rt_data_queue_pu
 80250f4:	00006873                                sh..

080250f8 <__FUNCTION__.6114>:
 80250f8:	645f7472 5f617461 75657571 6f705f65     rt_data_queue_po
 8025108:	00000070                                p...

0802510c <__FUNCTION__.6127>:
 802510c:	645f7472 5f617461 75657571 65705f65     rt_data_queue_pe
 802511c:	00006b61                                ak..

08025120 <__fsym_nand_id_name>:
 8025120:	646e616e 0064695f                       nand_id.

08025128 <__fsym_nand_id_desc>:
 8025128:	64616572 20444920 616e202d 6469646e     read ID - nandid
 8025138:	6d616e28 00002965                       (name)..

08025140 <__fsym_nand_read_name>:
 8025140:	646e616e 6165725f 00000064              nand_read...

0802514c <__fsym_nand_read_desc>:
 802514c:	64616572 67617020 6e692065 6e616e20     read page in nan
 802515c:	202d2064 646e616e 6165725f 616e2864     d - nand_read(na
 802516c:	202c656d 636f6c62 70202c6b 29656761     me, block, page)
 802517c:	00000000                                ....

08025180 <__fsym_nand_readoob_name>:
 8025180:	646e616e 6165725f 626f6f64 00000000     nand_readoob....

08025190 <__fsym_nand_readoob_desc>:
 8025190:	64616572 61707320 64206572 20617461     read spare data 
 80251a0:	6e206e69 20646e61 616e202d 725f646e     in nand - nand_r
 80251b0:	6f646165 6e28626f 2c656d61 6f6c6220     eadoob(name, blo
 80251c0:	202c6b63 65676170 00000029              ck, page)...

080251cc <__fsym_nand_write_name>:
 80251cc:	646e616e 6972775f 00006574              nand_write..

080251d8 <__fsym_nand_write_desc>:
 80251d8:	74697277 75642065 6420706d 20617461     write dump data 
 80251e8:	6e206f74 20646e61 616e202d 775f646e     to nand - nand_w
 80251f8:	65746972 6d616e28 62202c65 6b636f6c     rite(name, block
 8025208:	6170202c 00296567                       , page).

08025210 <__fsym_nand_erase_name>:
 8025210:	646e616e 6172655f 00006573              nand_erase..

0802521c <__fsym_nand_erase_desc>:
 802521c:	646e616e 6172655f 6e286573 2c656d61     nand_erase(name,
 802522c:	6f6c6220 00296b63                        block).

08025234 <__fsym_nand_erase_all_name>:
 8025234:	646e616e 6172655f 615f6573 00006c6c     nand_erase_all..

08025244 <__fsym_nand_erase_all_desc>:
 8025244:	73617265 6c612065 666f206c 6e616e20     erase all of nan
 8025254:	65642064 65636976 6e202d20 5f646e61     d device - nand_
 8025264:	73617265 6c615f65 616e286c 202c656d     erase_all(name, 
 8025274:	636f6c62 0000296b                       block)..

0802527c <__fsym_list_date_name>:
 802527c:	7473696c 7461645f 00000065              list_date...

08025288 <__fsym_list_date_desc>:
 8025288:	776f6873 74616420 6e612065 69742064     show date and ti
 8025298:	002e656d                                me..

0802529c <__fsym_set_date_name>:
 802529c:	5f746573 65746164 00000000              set_date....

080252a8 <__fsym_set_date_desc>:
 80252a8:	20746573 65746164 2e65202e 73203a67     set date. e.g: s
 80252b8:	645f7465 28657461 30313032 322c322c     et_date(2010,2,2
 80252c8:	00002938                                8)..

080252cc <__fsym_set_time_name>:
 80252cc:	5f746573 656d6974 00000000              set_time....

080252d8 <__fsym_set_time_desc>:
 80252d8:	20746573 656d6974 2e65202e 73203a67     set time. e.g: s
 80252e8:	745f7465 28656d69 352c3332 39352c39     et_time(23,59,59
 80252f8:	00000029                                )...

080252fc <__FUNCTION__.6144>:
 80252fc:	735f7472 61697265 6e695f6c 00007469     rt_serial_init..

0802530c <__FUNCTION__.6150>:
 802530c:	735f7472 61697265 706f5f6c 00006e65     rt_serial_open..

0802531c <__FUNCTION__.6159>:
 802531c:	735f7472 61697265 6c635f6c 0065736f     rt_serial_close.

0802532c <__FUNCTION__.6171>:
 802532c:	735f7472 61697265 65725f6c 00006461     rt_serial_read..

0802533c <__FUNCTION__.6105>:
 802533c:	7265735f 5f6c6169 5f746e69 00007872     _serial_int_rx..

0802534c <__FUNCTION__.6130>:
 802534c:	7265735f 5f6c6169 5f616d64 00007872     _serial_dma_rx..

0802535c <__FUNCTION__.6084>:
 802535c:	7265735f 5f6c6169 6c6c6f70 0078725f     _serial_poll_rx.

0802536c <__FUNCTION__.6179>:
 802536c:	735f7472 61697265 72775f6c 00657469     rt_serial_write.

0802537c <__FUNCTION__.6118>:
 802537c:	7265735f 5f6c6169 5f746e69 00007874     _serial_int_tx..

0802538c <__FUNCTION__.6094>:
 802538c:	7265735f 5f6c6169 6c6c6f70 0078745f     _serial_poll_tx.

0802539c <__FUNCTION__.6186>:
 802539c:	735f7472 61697265 6f635f6c 6f72746e     rt_serial_contro
 80253ac:	0000006c                                l...

080253b0 <__FUNCTION__.6199>:
 80253b0:	685f7472 65735f77 6c616972 6765725f     rt_hw_serial_reg
 80253c0:	65747369 00000072                       ister...

080253c8 <__FUNCTION__.6208>:
 80253c8:	685f7472 65735f77 6c616972 7273695f     rt_hw_serial_isr
 80253d8:	00000000                                ....

080253dc <__fsym___cmd_canstat_name>:
 80253dc:	6d635f5f 61635f64 6174736e 00000074     __cmd_canstat...

080253ec <__fsym___cmd_canstat_desc>:
 80253ec:	74617453 6e614320 76654420 20656369     Stat Can Device 
 80253fc:	74617453 002e7375                       Status..

08025404 <__FUNCTION__.6082>:
 8025404:	635f7472 695f6e61 0074696e              rt_can_init.

08025410 <__FUNCTION__.6130>:
 8025410:	635f7472 6f5f6e61 006e6570              rt_can_open.

0802541c <__FUNCTION__.6145>:
 802541c:	635f7472 635f6e61 65736f6c 00000000     rt_can_close....

0802542c <__FUNCTION__.6155>:
 802542c:	635f7472 725f6e61 00646165              rt_can_read.

08025438 <__FUNCTION__.6090>:
 8025438:	6e61635f 746e695f 0078725f              _can_int_rx.

08025444 <__FUNCTION__.6163>:
 8025444:	635f7472 775f6e61 65746972 00000000     rt_can_write....

08025454 <__FUNCTION__.6121>:
 8025454:	6e61635f 746e695f 5f78745f 76697270     _can_int_tx_priv
 8025464:	00000000                                ....

08025468 <__FUNCTION__.6103>:
 8025468:	6e61635f 746e695f 0078745f              _can_int_tx.

08025474 <__FUNCTION__.6171>:
 8025474:	635f7472 635f6e61 72746e6f 00006c6f     rt_can_control..

08025484 <__FUNCTION__.6199>:
 8025484:	685f7472 61635f77 65725f6e 74736967     rt_hw_can_regist
 8025494:	00007265                                er..

08025498 <__FUNCTION__.5426>:
 8025498:	736e6966 78725f68 646e695f 00000000     finsh_rx_ind....

080254a8 <__FUNCTION__.5468>:
 80254a8:	736e6966 68745f68 64616572 746e655f     finsh_thread_ent
 80254b8:	00007972                                ry..

080254bc <__fsym_hello_name>:
 80254bc:	6c6c6568 0000006f                       hello...

080254c4 <__fsym_hello_desc>:
 80254c4:	20796173 6c6c6568 6f77206f 00646c72     say hello world.

080254d4 <__fsym_version_name>:
 80254d4:	73726576 006e6f69                       version.

080254dc <__fsym_version_desc>:
 80254dc:	776f6873 2d545220 65726854 76206461     show RT-Thread v
 80254ec:	69737265 69206e6f 726f666e 6974616d     ersion informati
 80254fc:	00006e6f                                on..

08025500 <__fsym___cmd_version_name>:
 8025500:	6d635f5f 65765f64 6f697372 0000006e     __cmd_version...

08025510 <__fsym___cmd_version_desc>:
 8025510:	776f6873 2d545220 65726854 76206461     show RT-Thread v
 8025520:	69737265 69206e6f 726f666e 6974616d     ersion informati
 8025530:	00006e6f                                on..

08025534 <__fsym_list_thread_name>:
 8025534:	7473696c 7268745f 00646165              list_thread.

08025540 <__fsym_list_thread_desc>:
 8025540:	7473696c 72687420 00646165              list thread.

0802554c <__fsym___cmd_list_thread_name>:
 802554c:	6d635f5f 696c5f64 745f7473 61657268     __cmd_list_threa
 802555c:	00000064                                d...

08025560 <__fsym___cmd_list_thread_desc>:
 8025560:	7473696c 72687420 00646165              list thread.

0802556c <__fsym_list_sem_name>:
 802556c:	7473696c 6d65735f 00000000              list_sem....

08025578 <__fsym_list_sem_desc>:
 8025578:	7473696c 6d657320 6f687061 6920656e     list semaphone i
 8025588:	7973206e 6d657473 00000000              n system....

08025594 <__fsym___cmd_list_sem_name>:
 8025594:	6d635f5f 696c5f64 735f7473 00006d65     __cmd_list_sem..

080255a4 <__fsym___cmd_list_sem_desc>:
 80255a4:	7473696c 6d657320 6f687061 69206572     list semaphore i
 80255b4:	7973206e 6d657473 00000000              n system....

080255c0 <__fsym_list_event_name>:
 80255c0:	7473696c 6576655f 0000746e              list_event..

080255cc <__fsym_list_event_desc>:
 80255cc:	7473696c 65766520 6920746e 7973206e     list event in sy
 80255dc:	6d657473 00000000                       stem....

080255e4 <__fsym___cmd_list_event_name>:
 80255e4:	6d635f5f 696c5f64 655f7473 746e6576     __cmd_list_event
 80255f4:	00000000                                ....

080255f8 <__fsym___cmd_list_event_desc>:
 80255f8:	7473696c 65766520 6920746e 7973206e     list event in sy
 8025608:	6d657473 00000000                       stem....

08025610 <__fsym_list_mutex_name>:
 8025610:	7473696c 74756d5f 00007865              list_mutex..

0802561c <__fsym_list_mutex_desc>:
 802561c:	7473696c 74756d20 69207865 7973206e     list mutex in sy
 802562c:	6d657473 00000000                       stem....

08025634 <__fsym___cmd_list_mutex_name>:
 8025634:	6d635f5f 696c5f64 6d5f7473 78657475     __cmd_list_mutex
 8025644:	00000000                                ....

08025648 <__fsym___cmd_list_mutex_desc>:
 8025648:	7473696c 74756d20 69207865 7973206e     list mutex in sy
 8025658:	6d657473 00000000                       stem....

08025660 <__fsym_list_mailbox_name>:
 8025660:	7473696c 69616d5f 786f626c 00000000     list_mailbox....

08025670 <__fsym_list_mailbox_desc>:
 8025670:	7473696c 69616d20 6f62206c 6e692078     list mail box in
 8025680:	73797320 006d6574                        system.

08025688 <__fsym___cmd_list_mailbox_name>:
 8025688:	6d635f5f 696c5f64 6d5f7473 626c6961     __cmd_list_mailb
 8025698:	0000786f                                ox..

0802569c <__fsym___cmd_list_mailbox_desc>:
 802569c:	7473696c 69616d20 6f62206c 6e692078     list mail box in
 80256ac:	73797320 006d6574                        system.

080256b4 <__fsym_list_msgqueue_name>:
 80256b4:	7473696c 67736d5f 75657571 00000065     list_msgqueue...

080256c4 <__fsym_list_msgqueue_desc>:
 80256c4:	7473696c 73656d20 65676173 65757120     list message que
 80256d4:	69206575 7973206e 6d657473 00000000     ue in system....

080256e4 <__fsym___cmd_list_msgqueue_name>:
 80256e4:	6d635f5f 696c5f64 6d5f7473 75716773     __cmd_list_msgqu
 80256f4:	00657565                                eue.

080256f8 <__fsym___cmd_list_msgqueue_desc>:
 80256f8:	7473696c 73656d20 65676173 65757120     list message que
 8025708:	69206575 7973206e 6d657473 00000000     ue in system....

08025718 <__fsym_list_memheap_name>:
 8025718:	7473696c 6d656d5f 70616568 00000000     list_memheap....

08025728 <__fsym_list_memheap_desc>:
 8025728:	7473696c 6d656d20 2079726f 70616568     list memory heap
 8025738:	206e6920 74737973 00006d65               in system..

08025744 <__fsym___cmd_list_memheap_name>:
 8025744:	6d635f5f 696c5f64 6d5f7473 65686d65     __cmd_list_memhe
 8025754:	00007061                                ap..

08025758 <__fsym___cmd_list_memheap_desc>:
 8025758:	7473696c 6d656d20 2079726f 70616568     list memory heap
 8025768:	206e6920 74737973 00006d65               in system..

08025774 <__fsym_list_mempool_name>:
 8025774:	7473696c 6d656d5f 6c6f6f70 00000000     list_mempool....

08025784 <__fsym_list_mempool_desc>:
 8025784:	7473696c 6d656d20 2079726f 6c6f6f70     list memory pool
 8025794:	206e6920 74737973 00006d65               in system..

080257a0 <__fsym___cmd_list_mempool_name>:
 80257a0:	6d635f5f 696c5f64 6d5f7473 6f706d65     __cmd_list_mempo
 80257b0:	00006c6f                                ol..

080257b4 <__fsym___cmd_list_mempool_desc>:
 80257b4:	7473696c 6d656d20 2079726f 6c6f6f70     list memory pool
 80257c4:	206e6920 74737973 00006d65               in system..

080257d0 <__fsym_list_timer_name>:
 80257d0:	7473696c 6d69745f 00007265              list_timer..

080257dc <__fsym_list_timer_desc>:
 80257dc:	7473696c 6d697420 69207265 7973206e     list timer in sy
 80257ec:	6d657473 00000000                       stem....

080257f4 <__fsym___cmd_list_timer_name>:
 80257f4:	6d635f5f 696c5f64 745f7473 72656d69     __cmd_list_timer
 8025804:	00000000                                ....

08025808 <__fsym___cmd_list_timer_desc>:
 8025808:	7473696c 6d697420 69207265 7973206e     list timer in sy
 8025818:	6d657473 00000000                       stem....

08025820 <__fsym_list_device_name>:
 8025820:	7473696c 7665645f 00656369              list_device.

0802582c <__fsym_list_device_desc>:
 802582c:	7473696c 76656420 20656369 73206e69     list device in s
 802583c:	65747379 0000006d                       ystem...

08025844 <__fsym___cmd_list_device_name>:
 8025844:	6d635f5f 696c5f64 645f7473 63697665     __cmd_list_devic
 8025854:	00000065                                e...

08025858 <__fsym___cmd_list_device_desc>:
 8025858:	7473696c 76656420 20656369 73206e69     list device in s
 8025868:	65747379 0000006d                       ystem...

08025870 <__fsym_list_name>:
 8025870:	7473696c 00000000                       list....

08025878 <__fsym_list_desc>:
 8025878:	7473696c 6c6c6120 6d797320 206c6f62     list all symbol 
 8025888:	73206e69 65747379 0000006d              in system...

08025894 <__vsym_dummy_name>:
 8025894:	6d6d7564 00000079                       dummy...

0802589c <__vsym_dummy_desc>:
 802589c:	6d6d7564 61762079 62616972 6620656c     dummy variable f
 80258ac:	6620726f 68736e69 00000000              or finsh....

080258b8 <__fsym___cmd_ps_name>:
 80258b8:	6d635f5f 73705f64 00000000              __cmd_ps....

080258c4 <__fsym___cmd_ps_desc>:
 80258c4:	7473694c 72687420 73646165 206e6920     List threads in 
 80258d4:	20656874 74737973 002e6d65              the system..

080258e0 <__fsym___cmd_time_name>:
 80258e0:	6d635f5f 69745f64 0000656d              __cmd_time..

080258ec <__fsym___cmd_time_desc>:
 80258ec:	63657845 20657475 6d6d6f63 20646e61     Execute command 
 80258fc:	68746977 6d697420 00002e65              with time...

08025908 <__fsym___cmd_free_name>:
 8025908:	6d635f5f 72665f64 00006565              __cmd_free..

08025914 <__fsym___cmd_free_desc>:
 8025914:	776f6853 65687420 6d656d20 2079726f     Show the memory 
 8025924:	67617375 6e692065 65687420 73797320     usage in the sys
 8025934:	2e6d6574 00000000                       tem.....

0802593c <__fsym___cmd_exit_name>:
 802593c:	6d635f5f 78655f64 00007469              __cmd_exit..

08025948 <__fsym___cmd_exit_desc>:
 8025948:	75746572 74206e72 5452206f 7268542d     return to RT-Thr
 8025958:	20646165 6c656873 6f6d206c 002e6564     ead shell mode..

08025968 <__fsym_msh_name>:
 8025968:	0068736d                                msh.

0802596c <__fsym_msh_desc>:
 802596c:	20657375 75646f6d 7320656c 6c6c6568     use module shell
 802597c:	00000000                                ....

08025980 <__fsym___cmd_help_name>:
 8025980:	6d635f5f 65685f64 0000706c              __cmd_help..

0802598c <__fsym___cmd_help_desc>:
 802598c:	542d5452 61657268 68732064 206c6c65     RT-Thread shell 
 802599c:	706c6568 0000002e                       help....

080259a4 <__FUNCTION__.5426>:
 80259a4:	68736d5f 6578655f 6d635f63 00000064     _msh_exec_cmd...

080259b4 <op_table>:
 80259b4:	0801c47d 0801c48d 0801c4c5 0801c505     }...............
 80259c4:	0801c53d 0801c575 0801c5b5 0801c5ed     =...u...........
 80259d4:	0801c629 0801c669 0801c6a1 0801c6e5     )...i...........
 80259e4:	0801c72d 0801c76d 0801c7a9 0801c7e9     -...m...........
 80259f4:	0801c821 0801c859 0801c891 0801c8c9     !...Y...........
 8025a04:	0801c901 0801c939 0801c971 0801c9a9     ....9...q.......
 8025a14:	0801c9e1 0801ca19 0801ca41 0801ca69     ........A...i...
 8025a24:	0801ca8d 0801cac9 0801cb09 0801cb41     ............A...
 8025a34:	0801cb7d 0801cbbd 0801cbf5 0801cc2d     }...........-...
 8025a44:	0801cc75 0801ccd1 0801cd65 0801cdf9     u.......e.......
 8025a54:	0801ce8d 0801cebd 0801ceed 0801cf1d     ................
 8025a64:	0801cf39 0801cd39 0801cdcd 0801ce61     9...9.......a...
 8025a74:	00000000                                ....

08025a78 <finsh_name_table>:
 8025a78:	08024398 00000014 080243a0 00000015     .C.......C......
 8025a88:	080243a8 00000016 080243b0 00000017     .C.......C......
 8025a98:	080243b4 00000018 080243bc 00000019     .C.......C......
 8025aa8:	080243c8 0000001e 080243d0 0000001e     .C.......C......

08025ab8 <_DAYS_BEFORE_MONTH>:
 8025ab8:	00000000 0000001f 0000003b 0000005a     ........;...Z...
 8025ac8:	00000078 00000097 000000b5 000000d4     x...............
 8025ad8:	000000f3 00000111 00000130 0000014e     ........0...N...

08025ae8 <DAYS_IN_MONTH>:
 8025ae8:	0000001f 0000001c 0000001f 0000001e     ................
 8025af8:	0000001f 0000001e 0000001f 0000001f     ................
 8025b08:	0000001e 0000001f 0000001e 0000001f     ................

08025b18 <__month_lengths>:
 8025b18:	0000001f 0000001c 0000001f 0000001e     ................
 8025b28:	0000001f 0000001e 0000001f 0000001f     ................
 8025b38:	0000001e 0000001f 0000001e 0000001f     ................
 8025b48:	0000001f 0000001d 0000001f 0000001e     ................
 8025b58:	0000001f 0000001e 0000001f 0000001f     ................
 8025b68:	0000001e 0000001f 0000001e 0000001f     ................
 8025b78:	00005a54 003d5a54 00544d47 5b303125     TZ..TZ=.GMT.%10[
 8025b88:	392d305e 5d2d2b2c 00006e25 25756825     ^0-9,+-]%n..%hu%
 8025b98:	68253a6e 3a6e2575 25756825 0000006e     n:%hu%n:%hu%n...
 8025ba8:	7568254d 252e6e25 6e257568 7568252e     M%hu%n.%hu%n.%hu
 8025bb8:	00006e25 7568252f 253a6e25 6e257568     %n../%hu%n:%hu%n
 8025bc8:	7568253a 00006e25                       :%hu%n..

08025bd0 <mon_name.4605>:
 8025bd0:	466e614a 614d6265 72704172 4a79614d     JanFebMarAprMayJ
 8025be0:	754a6e75 6775416c 4f706553 6f4e7463     unJulAugSepOctNo
 8025bf0:	63654476 73332e25 332e2520 64332573     vDec%.3s %.3s%3d
 8025c00:	322e2520 2e253a64 253a6432 2064322e      %.2d:%.2d:%.2d 
 8025c10:	000a6425                                %d..

08025c14 <day_name.4604>:
 8025c14:	4d6e7553 75546e6f 64655765 46756854     SunMonTueWedThuF
 8025c24:	61536972 00000074                       riSat...

08025c2c <_ctype_>:
 8025c2c:	20202000 20202020 28282020 20282828     .         ((((( 
 8025c3c:	20202020 20202020 20202020 20202020                     
 8025c4c:	10108820 10101010 10101010 10101010      ...............
 8025c5c:	04040410 04040404 10040404 10101010     ................
 8025c6c:	41411010 41414141 01010101 01010101     ..AAAAAA........
 8025c7c:	01010101 01010101 01010101 10101010     ................
 8025c8c:	42421010 42424242 02020202 02020202     ..BBBBBB........
 8025c9c:	02020202 02020202 02020202 10101010     ................
 8025cac:	00000020 00000000 00000000 00000000      ...............
	...

08025d30 <days_per_year>:
 8025d30:	0000016d 0000016d 0000016e 0000016d     m...m...n...m...
 8025d40:	00000043                                C...

08025d44 <blanks.6738>:
 8025d44:	20202020 20202020 20202020 20202020                     
 8025d54:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 8025d64:	00000000 33323130 37363534 62613938     ....0123456789ab
 8025d74:	66656463 00000000 6c756e28 0000296c     cdef....(null)..

08025d84 <zeroes.6739>:
 8025d84:	30303030 30303030 30303030 30303030     0000000000000000

08025d94 <basefix.6210>:
 8025d94:	0001000a 00030002 00050004 00070006     ................
 8025da4:	00090008 000b000a 000d000c 000f000e     ................
 8025db4:	00000010                                ....

08025db8 <__fsym___cmd_CANtx>:
 8025db8:	0802446c 08024478 0800f941              lD..xD..A...

08025dc4 <__fsym___cmd_TS>:
 8025dc4:	08024490 0802449c 0800ff15              .D...D......

08025dd0 <__fsym___cmd_FANtest>:
 8025dd0:	080244bc 080244cc 0800ffed              .D...D......

08025ddc <__fsym___cmd_ADCtest>:
 8025ddc:	080244e8 080244f8 08010055              .D...D..U...

08025de8 <__fsym___cmd_PWMset>:
 8025de8:	08024510 08024520 08010205              .E.. E......

08025df4 <__fsym___cmd_PWMdis>:
 8025df4:	08024530 08024540 08010255              0E..@E..U...

08025e00 <__fsym___cmd_PWMen>:
 8025e00:	0802454c 08024558 08010271              LE..XE..q...

08025e0c <__fsym___cmd_MCctrl>:
 8025e0c:	08024564 08024574 0801028d              dE..tE......

08025e18 <__fsym___cmd_QEPtest>:
 8025e18:	0802458c 0802459c 080102f5              .E...E......

08025e24 <__fsym_list_mem>:
 8025e24:	08024e70 08024e7c 0801452d              pN..|N..-E..

08025e30 <__fsym_nand_id>:
 8025e30:	08025120 08025128 0801684d               Q..(Q..Mh..

08025e3c <__fsym_nand_read>:
 8025e3c:	08025140 0802514c 08016885              @Q..LQ...h..

08025e48 <__fsym_nand_readoob>:
 8025e48:	08025180 08025190 08016971              .Q...Q..qi..

08025e54 <__fsym_nand_write>:
 8025e54:	080251cc 080251d8 08016a11              .Q...Q...j..

08025e60 <__fsym_nand_erase>:
 8025e60:	08025210 0802521c 08016b19              .R...R...k..

08025e6c <__fsym_nand_erase_all>:
 8025e6c:	08025234 08025244 08016b55              4R..DR..Uk..

08025e78 <__fsym_list_date>:
 8025e78:	0802527c 08025288 08016d3d              |R...R..=m..

08025e84 <__fsym_set_date>:
 8025e84:	0802529c 080252a8 08016c21              .R...R..!l..

08025e90 <__fsym_set_time>:
 8025e90:	080252cc 080252d8 08016cb1              .R...R...l..

08025e9c <__fsym___cmd_canstat>:
 8025e9c:	080253dc 080253ec 080185d5              .S...S......

08025ea8 <__fsym_hello>:
 8025ea8:	080254bc 080254c4 08019225              .T...T..%...

08025eb4 <__fsym_version>:
 8025eb4:	080254d4 080254dc 08019239              .T...T..9...

08025ec0 <__fsym___cmd_version>:
 8025ec0:	08025500 08025510 08019239              .U...U..9...

08025ecc <__fsym_list_thread>:
 8025ecc:	08025534 08025540 08019351              4U..@U..Q...

08025ed8 <__fsym___cmd_list_thread>:
 8025ed8:	0802554c 08025560 08019351              LU..`U..Q...

08025ee4 <__fsym_list_sem>:
 8025ee4:	0802556c 08025578 08019465              lU..xU..e...

08025ef0 <__fsym___cmd_list_sem>:
 8025ef0:	08025594 080255a4 08019465              .U...U..e...

08025efc <__fsym_list_event>:
 8025efc:	080255c0 080255cc 08019519              .U...U......

08025f08 <__fsym___cmd_list_event>:
 8025f08:	080255e4 080255f8 08019519              .U...U......

08025f14 <__fsym_list_mutex>:
 8025f14:	08025610 0802561c 080195a1              .V...V......

08025f20 <__fsym___cmd_list_mutex>:
 8025f20:	08025634 08025648 080195a1              4V..HV......

08025f2c <__fsym_list_mailbox>:
 8025f2c:	08025660 08025670 08019679              `V..pV..y...

08025f38 <__fsym___cmd_list_mailbox>:
 8025f38:	08025688 0802569c 08019679              .V...V..y...

08025f44 <__fsym_list_msgqueue>:
 8025f44:	080256b4 080256c4 08019741              .V...V..A...

08025f50 <__fsym___cmd_list_msgqueue>:
 8025f50:	080256e4 080256f8 08019741              .V...V..A...

08025f5c <__fsym_list_memheap>:
 8025f5c:	08025718 08025728 080197b9              .W..(W......

08025f68 <__fsym___cmd_list_memheap>:
 8025f68:	08025744 08025758 080197b9              DW..XW......

08025f74 <__fsym_list_mempool>:
 8025f74:	08025774 08025784 0801987d              tW...W..}...

08025f80 <__fsym___cmd_list_mempool>:
 8025f80:	080257a0 080257b4 0801987d              .W...W..}...

08025f8c <__fsym_list_timer>:
 8025f8c:	080257d0 080257dc 08019921              .W...W..!...

08025f98 <__fsym___cmd_list_timer>:
 8025f98:	080257f4 08025808 08019921              .W...X..!...

08025fa4 <__fsym_list_device>:
 8025fa4:	08025820 0802582c 080199bd               X..,X......

08025fb0 <__fsym___cmd_list_device>:
 8025fb0:	08025844 08025858 080199bd              DX..XX......

08025fbc <__fsym_list>:
 8025fbc:	08025870 08025878 080199d1              pX..xX......

08025fc8 <__fsym___cmd_ps>:
 8025fc8:	080258b8 080258c4 08019ded              .X...X......

08025fd4 <__fsym___cmd_time>:
 8025fd4:	080258e0 080258ec 08019e05              .X...X......

08025fe0 <__fsym___cmd_free>:
 8025fe0:	08025908 08025914 08019e1d              .Y...Y......

08025fec <__fsym___cmd_exit>:
 8025fec:	0802593c 08025948 08019e4d              <Y..HY..M...

08025ff8 <__fsym_msh>:
 8025ff8:	08025968 0802596c 08019e71              hY..lY..q...

08026004 <__fsym___cmd_help>:
 8026004:	08025980 0802598c 08019e8d              .Y...Y......

08026010 <__fsymtab_end>:
 8026010:	08025894 	.word	0x08025894
 8026014:	0802589c 	.word	0x0802589c
 8026018:	00000009 	.word	0x00000009
 802601c:	200121dc 	.word	0x200121dc

08026020 <__rt_init_rti_start>:
 8026020:	08011e75                                u...

08026024 <__rt_init_Can_hw_init>:
 8026024:	0800d401                                ....

08026028 <__rt_init_stm32_hw_usart_init>:
 8026028:	0800f81d                                ....

0802602c <__rt_init_USER_Motor_hwinit>:
 802602c:	0800ff05                                ....

08026030 <__rt_init_rti_board_end>:
 8026030:	08011e85                                ....

08026034 <__rt_init_rt_i2c_core_init>:
 8026034:	080166c1                                .f..

08026038 <__rt_init_finsh_system_init>:
 8026038:	0801910d                                ....

0802603c <__rt_init_libc_system_init>:
 802603c:	08015da1                                .]..

08026040 <__rt_init_USER_CanTask_init>:
 8026040:	0800fb75                                u...

08026044 <__rt_init_J1939_RcvTask_init>:
 8026044:	0800fc1d                                ....

08026048 <__rt_init_USER_MotorTask_init>:
 8026048:	0801031d                                ....

0802604c <__rt_init_USER_Usart3txTask_init>:
 802604c:	08010535                                5...

08026050 <__rt_init_USER_Usart3rxTask_init>:
 8026050:	0801074d                                M...

08026054 <__rt_init_rti_end>:
 8026054:	08011e95                                ....
