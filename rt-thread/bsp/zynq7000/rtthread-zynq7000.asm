
rtthread-zynq7000.elf:     file format elf32-littlearm


Disassembly of section .text:

10000000 <__text_start>:
.section .vectors, "ax"
.code 32

.globl system_vectors
system_vectors:
    ldr pc, _vector_reset
10000000:	e59ff018 	ldr	pc, [pc, #24]	; 10000020 <_vector_reset>
    ldr pc, _vector_undef
10000004:	e59ff018 	ldr	pc, [pc, #24]	; 10000024 <_vector_undef>
    ldr pc, _vector_swi
10000008:	e59ff018 	ldr	pc, [pc, #24]	; 10000028 <_vector_swi>
    ldr pc, _vector_pabt
1000000c:	e59ff018 	ldr	pc, [pc, #24]	; 1000002c <_vector_pabt>
    ldr pc, _vector_dabt
10000010:	e59ff018 	ldr	pc, [pc, #24]	; 10000030 <_vector_dabt>
    ldr pc, _vector_resv
10000014:	e59ff018 	ldr	pc, [pc, #24]	; 10000034 <_vector_resv>
    ldr pc, _vector_irq
10000018:	e59ff018 	ldr	pc, [pc, #24]	; 10000038 <_vector_irq>
    ldr pc, _vector_fiq
1000001c:	e59ff018 	ldr	pc, [pc, #24]	; 1000003c <_vector_fiq>

10000020 <_vector_reset>:
10000020:	100197fc 	.word	0x100197fc

10000024 <_vector_undef>:
10000024:	10000120 	.word	0x10000120

10000028 <_vector_swi>:
10000028:	100000e0 	.word	0x100000e0

1000002c <_vector_pabt>:
1000002c:	10000160 	.word	0x10000160

10000030 <_vector_dabt>:
10000030:	100001a0 	.word	0x100001a0

10000034 <_vector_resv>:
10000034:	100001e0 	.word	0x100001e0

10000038 <_vector_irq>:
10000038:	10000060 	.word	0x10000060

1000003c <_vector_fiq>:
1000003c:	10000040 	.word	0x10000040

10000040 <vector_fiq>:
.section .text.isr, "ax"
/* exception handlers: undef, swi, padt, dabt, resv, irq, fiq          */
    .align  5
.globl vector_fiq
vector_fiq:
    stmfd   sp!,{r0-r7,lr}
10000040:	e92d40ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
    bl      rt_hw_trap_fiq
10000044:	eb006552 	bl	10019594 <rt_hw_trap_fiq>
    ldmfd   sp!,{r0-r7,lr}
10000048:	e8bd40ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
    subs    pc,lr,#4
1000004c:	e25ef004 	subs	pc, lr, #4
10000050:	e320f000 	nop	{0}
10000054:	e320f000 	nop	{0}
10000058:	e320f000 	nop	{0}
1000005c:	e320f000 	nop	{0}

10000060 <vector_irq>:
.globl      rt_interrupt_to_thread

    .align  5
.globl vector_irq
vector_irq:
    stmfd   sp!, {r0-r12,lr}
10000060:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    bl      rt_interrupt_enter
10000064:	eb004801 	bl	10012070 <rt_interrupt_enter>
    bl      rt_hw_trap_irq
10000068:	eb00651f 	bl	100194ec <rt_hw_trap_irq>
    bl      rt_interrupt_leave
1000006c:	eb004811 	bl	100120b8 <rt_interrupt_leave>

    @ if rt_thread_switch_interrupt_flag set, jump to
    @ rt_hw_context_switch_interrupt_do and don't return
    ldr     r0, =rt_thread_switch_interrupt_flag
10000070:	e59f0194 	ldr	r0, [pc, #404]	; 1000020c <vector_resv+0x2c>
    ldr     r1, [r0]
10000074:	e5901000 	ldr	r1, [r0]
    cmp     r1, #1
10000078:	e3510001 	cmp	r1, #1
    beq rt_hw_context_switch_interrupt_do
1000007c:	0a000001 	beq	10000088 <rt_hw_context_switch_interrupt_do>

    ldmfd   sp!, {r0-r12,lr}
10000080:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    subs    pc, lr, #4
10000084:	e25ef004 	subs	pc, lr, #4

10000088 <rt_hw_context_switch_interrupt_do>:

rt_hw_context_switch_interrupt_do:
    mov     r1,  #0         @ clear flag
10000088:	e3a01000 	mov	r1, #0
    str     r1,  [r0]
1000008c:	e5801000 	str	r1, [r0]

    mov     r1, sp          @ r1 point to {r0-r3} in stack
10000090:	e1a0100d 	mov	r1, sp
    add     sp, sp, #4*4
10000094:	e28dd010 	add	sp, sp, #16
    ldmfd   sp!, {r4-r12,lr}@ reload saved registers
10000098:	e8bd5ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    mrs     r0,  spsr       @ get cpsr of interrupt thread
1000009c:	e14f0000 	mrs	r0, SPSR
    sub     r2,  lr, #4     @ save old task's pc to r2
100000a0:	e24e2004 	sub	r2, lr, #4

    @ Switch to SVC mode with no interrupt.
    msr     cpsr_c, #I_Bit|F_Bit|Mode_SVC
100000a4:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

    stmfd   sp!, {r2}       @ push old task's pc
100000a8:	e92d0004 	stmfd	sp!, {r2}
    stmfd   sp!, {r4-r12,lr}@ push old task's lr,r12-r4
100000ac:	e92d5ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    ldmfd   r1,  {r1-r4}    @ restore r0-r3 of the interrupt thread
100000b0:	e891001e 	ldm	r1, {r1, r2, r3, r4}
    stmfd   sp!, {r1-r4}    @ push old task's r0-r3
100000b4:	e92d001e 	push	{r1, r2, r3, r4}
    stmfd   sp!, {r0}       @ push old task's cpsr
100000b8:	e92d0001 	stmfd	sp!, {r0}

    ldr     r4,  =rt_interrupt_from_thread
100000bc:	e59f414c 	ldr	r4, [pc, #332]	; 10000210 <vector_resv+0x30>
    ldr     r5,  [r4]
100000c0:	e5945000 	ldr	r5, [r4]
    str     sp,  [r5]       @ store sp in preempted tasks's TCB
100000c4:	e585d000 	str	sp, [r5]

    ldr     r6,  =rt_interrupt_to_thread
100000c8:	e59f6144 	ldr	r6, [pc, #324]	; 10000214 <vector_resv+0x34>
    ldr     r7,  [r6]
100000cc:	e5967000 	ldr	r7, [r6]
    ldr     sp,  [r7]       @ get new task's stack pointer
100000d0:	e597d000 	ldr	sp, [r7]

    ldmfd   sp!, {r4}       @ pop new task's cpsr to spsr
100000d4:	e8bd0010 	ldmfd	sp!, {r4}
    msr     spsr_cxsf, r4
100000d8:	e16ff004 	msr	SPSR_fsxc, r4

    ldmfd   sp!, {r0-r12,lr,pc}^ @ pop new task's r0-r12,lr & pc, copy spsr to cpsr
100000dc:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

100000e0 <vector_swi>:
.endm

    .align  5
    .globl	vector_swi
vector_swi:
    push_svc_reg
100000e0:	e24dd044 	sub	sp, sp, #68	; 0x44
100000e4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
100000e8:	e1a0000d 	mov	r0, sp
100000ec:	e14f6000 	mrs	r6, SPSR
100000f0:	e580e03c 	str	lr, [r0, #60]	; 0x3c
100000f4:	e5806040 	str	r6, [r0, #64]	; 0x40
100000f8:	f1020013 	cps	#19
100000fc:	e580d034 	str	sp, [r0, #52]	; 0x34
10000100:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_swi
10000104:	eb0064c4 	bl	1001941c <rt_hw_trap_swi>
    b       .
10000108:	eafffffe 	b	10000108 <vector_swi+0x28>
1000010c:	e320f000 	nop	{0}
10000110:	e320f000 	nop	{0}
10000114:	e320f000 	nop	{0}
10000118:	e320f000 	nop	{0}
1000011c:	e320f000 	nop	{0}

10000120 <vector_undef>:

    .align  5
    .globl	vector_undef
vector_undef:
    push_svc_reg
10000120:	e24dd044 	sub	sp, sp, #68	; 0x44
10000124:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
10000128:	e1a0000d 	mov	r0, sp
1000012c:	e14f6000 	mrs	r6, SPSR
10000130:	e580e03c 	str	lr, [r0, #60]	; 0x3c
10000134:	e5806040 	str	r6, [r0, #64]	; 0x40
10000138:	f1020013 	cps	#19
1000013c:	e580d034 	str	sp, [r0, #52]	; 0x34
10000140:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_undef
10000144:	eb0064a7 	bl	100193e8 <rt_hw_trap_undef>
    b       .
10000148:	eafffffe 	b	10000148 <vector_undef+0x28>
1000014c:	e320f000 	nop	{0}
10000150:	e320f000 	nop	{0}
10000154:	e320f000 	nop	{0}
10000158:	e320f000 	nop	{0}
1000015c:	e320f000 	nop	{0}

10000160 <vector_pabt>:

    .align  5
    .globl	vector_pabt
vector_pabt:
    push_svc_reg
10000160:	e24dd044 	sub	sp, sp, #68	; 0x44
10000164:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
10000168:	e1a0000d 	mov	r0, sp
1000016c:	e14f6000 	mrs	r6, SPSR
10000170:	e580e03c 	str	lr, [r0, #60]	; 0x3c
10000174:	e5806040 	str	r6, [r0, #64]	; 0x40
10000178:	f1020013 	cps	#19
1000017c:	e580d034 	str	sp, [r0, #52]	; 0x34
10000180:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_pabt
10000184:	eb0064b1 	bl	10019450 <rt_hw_trap_pabt>
    b       .
10000188:	eafffffe 	b	10000188 <vector_pabt+0x28>
1000018c:	e320f000 	nop	{0}
10000190:	e320f000 	nop	{0}
10000194:	e320f000 	nop	{0}
10000198:	e320f000 	nop	{0}
1000019c:	e320f000 	nop	{0}

100001a0 <vector_dabt>:

    .align  5
    .globl	vector_dabt
vector_dabt:
    push_svc_reg
100001a0:	e24dd044 	sub	sp, sp, #68	; 0x44
100001a4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
100001a8:	e1a0000d 	mov	r0, sp
100001ac:	e14f6000 	mrs	r6, SPSR
100001b0:	e580e03c 	str	lr, [r0, #60]	; 0x3c
100001b4:	e5806040 	str	r6, [r0, #64]	; 0x40
100001b8:	f1020013 	cps	#19
100001bc:	e580d034 	str	sp, [r0, #52]	; 0x34
100001c0:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_dabt
100001c4:	eb0064ae 	bl	10019484 <rt_hw_trap_dabt>
    b       .
100001c8:	eafffffe 	b	100001c8 <vector_dabt+0x28>
100001cc:	e320f000 	nop	{0}
100001d0:	e320f000 	nop	{0}
100001d4:	e320f000 	nop	{0}
100001d8:	e320f000 	nop	{0}
100001dc:	e320f000 	nop	{0}

100001e0 <vector_resv>:

    .align  5
    .globl	vector_resv
vector_resv:
    push_svc_reg
100001e0:	e24dd044 	sub	sp, sp, #68	; 0x44
100001e4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
100001e8:	e1a0000d 	mov	r0, sp
100001ec:	e14f6000 	mrs	r6, SPSR
100001f0:	e580e03c 	str	lr, [r0, #60]	; 0x3c
100001f4:	e5806040 	str	r6, [r0, #64]	; 0x40
100001f8:	f1020013 	cps	#19
100001fc:	e580d034 	str	sp, [r0, #52]	; 0x34
10000200:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_resv
10000204:	eb0064ab 	bl	100194b8 <rt_hw_trap_resv>
    b       .
10000208:	eafffffe 	b	10000208 <vector_resv+0x28>
    bl      rt_hw_trap_irq
    bl      rt_interrupt_leave

    @ if rt_thread_switch_interrupt_flag set, jump to
    @ rt_hw_context_switch_interrupt_do and don't return
    ldr     r0, =rt_thread_switch_interrupt_flag
1000020c:	10042ad4 	.word	0x10042ad4
    stmfd   sp!, {r4-r12,lr}@ push old task's lr,r12-r4
    ldmfd   r1,  {r1-r4}    @ restore r0-r3 of the interrupt thread
    stmfd   sp!, {r1-r4}    @ push old task's r0-r3
    stmfd   sp!, {r0}       @ push old task's cpsr

    ldr     r4,  =rt_interrupt_from_thread
10000210:	10042ad0 	.word	0x10042ad0
    ldr     r5,  [r4]
    str     sp,  [r5]       @ store sp in preempted tasks's TCB

    ldr     r6,  =rt_interrupt_to_thread
10000214:	10042acc 	.word	0x10042acc

10000218 <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
10000218:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000021c:	e28db000 	add	fp, sp, #0
10000220:	e24dd014 	sub	sp, sp, #20
10000224:	ed0b0a04 	vstr	s0, [fp, #-16]
  float_t out = in;
10000228:	e51b3010 	ldr	r3, [fp, #-16]
1000022c:	e50b3008 	str	r3, [fp, #-8]


  if(in < 0.0f)
10000230:	ed5b7a04 	vldr	s15, [fp, #-16]
10000234:	eef57ac0 	vcmpe.f32	s15, #0.0
10000238:	eef1fa10 	vmrs	APSR_nzcv, fpscr
1000023c:	5a000002 	bpl	1000024c <MATH_abs+0x34>
    {
      out = -in;
10000240:	ed5b7a04 	vldr	s15, [fp, #-16]
10000244:	eef17a67 	vneg.f32	s15, s15
10000248:	ed4b7a02 	vstr	s15, [fp, #-8]
    }

  return(out);
1000024c:	e51b3008 	ldr	r3, [fp, #-8]
10000250:	ee073a90 	vmov	s15, r3
} // end of MATH_abs() function
10000254:	eeb00a67 	vmov.f32	s0, s15
10000258:	e24bd000 	sub	sp, fp, #0
1000025c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000260:	e12fff1e 	bx	lr

10000264 <INITPOSDET_Init>:

#include "modules/InitPosDet/InitPosDet.h"


INITPOSDET_Handle INITPOSDET_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
10000264:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000268:	e28db000 	add	fp, sp, #0
1000026c:	e24dd014 	sub	sp, sp, #20
10000270:	e50b0010 	str	r0, [fp, #-16]
10000274:	e50b1014 	str	r1, [fp, #-20]
	INITPOSDET_Handle handle;
	uint16_t i;

	if (numBytes < sizeof(INITPOSDET_Obj))
10000278:	e51b3014 	ldr	r3, [fp, #-20]
1000027c:	e353005f 	cmp	r3, #95	; 0x5f
10000280:	8a000001 	bhi	1000028c <INITPOSDET_Init+0x28>
		return((INITPOSDET_Handle)NULL);
10000284:	e3a03000 	mov	r3, #0
10000288:	ea000041 	b	10000394 <INITPOSDET_Init+0x130>

	// assign the handle
	handle = (INITPOSDET_Handle)pMemory;
1000028c:	e51b3010 	ldr	r3, [fp, #-16]
10000290:	e50b300c 	str	r3, [fp, #-12]

	handle->InitPosDetFlag = true;
10000294:	e51b300c 	ldr	r3, [fp, #-12]
10000298:	e3a02001 	mov	r2, #1
1000029c:	e1c320b0 	strh	r2, [r3]
	handle->InitPosAngleCount = 0;
100002a0:	e51b300c 	ldr	r3, [fp, #-12]
100002a4:	e3a02000 	mov	r2, #0
100002a8:	e1c320b2 	strh	r2, [r3, #2]
	handle->InitPosAngle = (0.0);
100002ac:	e51b300c 	ldr	r3, [fp, #-12]
100002b0:	e3a02000 	mov	r2, #0
100002b4:	e5832004 	str	r2, [r3, #4]
	handle->SubdivideAngle = (SUBDIVIDE_ANGLE_PU);
100002b8:	e51b300c 	ldr	r3, [fp, #-12]
100002bc:	e30a2aa6 	movw	r2, #43686	; 0xaaa6
100002c0:	e3432daa 	movt	r2, #15786	; 0x3daa
100002c4:	e5832008 	str	r2, [r3, #8]
	handle->VolVecAngleFlag = false;
100002c8:	e51b300c 	ldr	r3, [fp, #-12]
100002cc:	e3a02000 	mov	r2, #0
100002d0:	e1c320bc 	strh	r2, [r3, #12]
	handle->VolVecAngleCount = 0;
100002d4:	e51b300c 	ldr	r3, [fp, #-12]
100002d8:	e3a02000 	mov	r2, #0
100002dc:	e1c320be 	strh	r2, [r3, #14]
	handle->VolVecAngle = (0.0);
100002e0:	e51b300c 	ldr	r3, [fp, #-12]
100002e4:	e3a02000 	mov	r2, #0
100002e8:	e5832010 	str	r2, [r3, #16]
	handle->VolVecAngleOffset = (-0.5);//-0.1666667
100002ec:	e51b300c 	ldr	r3, [fp, #-12]
100002f0:	e3a024bf 	mov	r2, #-1090519040	; 0xbf000000
100002f4:	e5832014 	str	r2, [r3, #20]
	handle->VolVecAngleIntervalTime = VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR;
100002f8:	e51b300c 	ldr	r3, [fp, #-12]
100002fc:	e3a0200a 	mov	r2, #10
10000300:	e1c321b8 	strh	r2, [r3, #24]
	handle->IdSampAngleFlag = false;
10000304:	e51b300c 	ldr	r3, [fp, #-12]
10000308:	e3a02000 	mov	r2, #0
1000030c:	e1c321ba 	strh	r2, [r3, #26]
	handle->IdSampAngle = (0.0);
10000310:	e51b300c 	ldr	r3, [fp, #-12]
10000314:	e3a02000 	mov	r2, #0
10000318:	e583201c 	str	r2, [r3, #28]
	handle->IdSampAngleCount = 0;
1000031c:	e51b300c 	ldr	r3, [fp, #-12]
10000320:	e3a02000 	mov	r2, #0
10000324:	e1c322b0 	strh	r2, [r3, #32]
	for (i = 0; i<VOL_VEC_ANGLE_SCLAR / 2; i++)
10000328:	e3a03000 	mov	r3, #0
1000032c:	e14b30b6 	strh	r3, [fp, #-6]
10000330:	ea000009 	b	1000035c <INITPOSDET_Init+0xf8>
	{
		handle->IdEvg[i] = (0.0);
10000334:	e15b30b6 	ldrh	r3, [fp, #-6]
10000338:	e51b200c 	ldr	r2, [fp, #-12]
1000033c:	e2833008 	add	r3, r3, #8
10000340:	e1a03103 	lsl	r3, r3, #2
10000344:	e0823003 	add	r3, r2, r3
10000348:	e3a02000 	mov	r2, #0
1000034c:	e5832004 	str	r2, [r3, #4]
	handle->VolVecAngleOffset = (-0.5);//-0.1666667
	handle->VolVecAngleIntervalTime = VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR;
	handle->IdSampAngleFlag = false;
	handle->IdSampAngle = (0.0);
	handle->IdSampAngleCount = 0;
	for (i = 0; i<VOL_VEC_ANGLE_SCLAR / 2; i++)
10000350:	e15b30b6 	ldrh	r3, [fp, #-6]
10000354:	e2833001 	add	r3, r3, #1
10000358:	e14b30b6 	strh	r3, [fp, #-6]
1000035c:	e15b30b6 	ldrh	r3, [fp, #-6]
10000360:	e353000b 	cmp	r3, #11
10000364:	9afffff2 	bls	10000334 <INITPOSDET_Init+0xd0>
	{
		handle->IdEvg[i] = (0.0);
	}
	handle->IdEvgCoeff = (1.0 / ID_EVG_SCLAR1);
10000368:	e51b300c 	ldr	r3, [fp, #-12]
1000036c:	e30d270a 	movw	r2, #55050	; 0xd70a
10000370:	e3432ca3 	movt	r2, #15523	; 0x3ca3
10000374:	e5832054 	str	r2, [r3, #84]	; 0x54
	handle->IdEvgCount = 0;
10000378:	e51b300c 	ldr	r3, [fp, #-12]
1000037c:	e3a02000 	mov	r2, #0
10000380:	e1c325b8 	strh	r2, [r3, #88]	; 0x58

	handle->IdEvgTmp = (0.0);
10000384:	e51b300c 	ldr	r3, [fp, #-12]
10000388:	e3a02000 	mov	r2, #0
1000038c:	e583205c 	str	r2, [r3, #92]	; 0x5c

	return(handle);
10000390:	e51b300c 	ldr	r3, [fp, #-12]
}
10000394:	e1a00003 	mov	r0, r3
10000398:	e24bd000 	sub	sp, fp, #0
1000039c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100003a0:	e12fff1e 	bx	lr

100003a4 <BubbleSort>:


void BubbleSort(float_t a[], uint16_t b[],uint16_t size)
{
100003a4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100003a8:	e28db000 	add	fp, sp, #0
100003ac:	e24dd024 	sub	sp, sp, #36	; 0x24
100003b0:	e50b0018 	str	r0, [fp, #-24]
100003b4:	e50b101c 	str	r1, [fp, #-28]
100003b8:	e1a03002 	mov	r3, r2
100003bc:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
	uint16_t lastSwapPos = 0,lastSwapPosTemp = 0;
100003c0:	e3a03000 	mov	r3, #0
100003c4:	e14b30bc 	strh	r3, [fp, #-12]
100003c8:	e3a03000 	mov	r3, #0
100003cc:	e14b30b6 	strh	r3, [fp, #-6]
	uint16_t i,j;
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
100003d0:	e3a03000 	mov	r3, #0
100003d4:	e14b30b8 	strh	r3, [fp, #-8]
100003d8:	ea000054 	b	10000530 <BubbleSort+0x18c>
    {
        lastSwapPos = lastSwapPosTemp;
100003dc:	e15b30b6 	ldrh	r3, [fp, #-6]
100003e0:	e14b30bc 	strh	r3, [fp, #-12]
        for (j = size - 1; j >lastSwapPos; j--)
100003e4:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
100003e8:	e2433001 	sub	r3, r3, #1
100003ec:	e14b30ba 	strh	r3, [fp, #-10]
100003f0:	ea000042 	b	10000500 <BubbleSort+0x15c>
        {
            if (a[j - 1] < a[j])
100003f4:	e15b30ba 	ldrh	r3, [fp, #-10]
100003f8:	e2433107 	sub	r3, r3, #-1073741823	; 0xc0000001
100003fc:	e1a03103 	lsl	r3, r3, #2
10000400:	e51b2018 	ldr	r2, [fp, #-24]
10000404:	e0823003 	add	r3, r2, r3
10000408:	ed937a00 	vldr	s14, [r3]
1000040c:	e15b30ba 	ldrh	r3, [fp, #-10]
10000410:	e1a03103 	lsl	r3, r3, #2
10000414:	e51b2018 	ldr	r2, [fp, #-24]
10000418:	e0823003 	add	r3, r2, r3
1000041c:	edd37a00 	vldr	s15, [r3]
10000420:	eeb47ae7 	vcmpe.f32	s14, s15
10000424:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10000428:	5a000031 	bpl	100004f4 <BubbleSort+0x150>
            {
            	temp = a[j - 1];
1000042c:	e15b30ba 	ldrh	r3, [fp, #-10]
10000430:	e2433107 	sub	r3, r3, #-1073741823	; 0xc0000001
10000434:	e1a03103 	lsl	r3, r3, #2
10000438:	e51b2018 	ldr	r2, [fp, #-24]
1000043c:	e0823003 	add	r3, r2, r3
10000440:	e5933000 	ldr	r3, [r3]
10000444:	e50b3010 	str	r3, [fp, #-16]
                a[j - 1] = a[j];
10000448:	e15b30ba 	ldrh	r3, [fp, #-10]
1000044c:	e2433107 	sub	r3, r3, #-1073741823	; 0xc0000001
10000450:	e1a03103 	lsl	r3, r3, #2
10000454:	e51b2018 	ldr	r2, [fp, #-24]
10000458:	e0823003 	add	r3, r2, r3
1000045c:	e15b20ba 	ldrh	r2, [fp, #-10]
10000460:	e1a02102 	lsl	r2, r2, #2
10000464:	e51b1018 	ldr	r1, [fp, #-24]
10000468:	e0812002 	add	r2, r1, r2
1000046c:	e5922000 	ldr	r2, [r2]
10000470:	e5832000 	str	r2, [r3]
                a[j] = temp;
10000474:	e15b30ba 	ldrh	r3, [fp, #-10]
10000478:	e1a03103 	lsl	r3, r3, #2
1000047c:	e51b2018 	ldr	r2, [fp, #-24]
10000480:	e0823003 	add	r3, r2, r3
10000484:	e51b2010 	ldr	r2, [fp, #-16]
10000488:	e5832000 	str	r2, [r3]

                temp1 = b[j - 1];
1000048c:	e15b30ba 	ldrh	r3, [fp, #-10]
10000490:	e2433106 	sub	r3, r3, #-2147483647	; 0x80000001
10000494:	e1a03083 	lsl	r3, r3, #1
10000498:	e51b201c 	ldr	r2, [fp, #-28]
1000049c:	e0823003 	add	r3, r2, r3
100004a0:	e1d330b0 	ldrh	r3, [r3]
100004a4:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
                b[j - 1] = b[j];
100004a8:	e15b30ba 	ldrh	r3, [fp, #-10]
100004ac:	e2433106 	sub	r3, r3, #-2147483647	; 0x80000001
100004b0:	e1a03083 	lsl	r3, r3, #1
100004b4:	e51b201c 	ldr	r2, [fp, #-28]
100004b8:	e0823003 	add	r3, r2, r3
100004bc:	e15b20ba 	ldrh	r2, [fp, #-10]
100004c0:	e1a02082 	lsl	r2, r2, #1
100004c4:	e51b101c 	ldr	r1, [fp, #-28]
100004c8:	e0812002 	add	r2, r1, r2
100004cc:	e1d220b0 	ldrh	r2, [r2]
100004d0:	e1c320b0 	strh	r2, [r3]
                b[j] = temp1;
100004d4:	e15b30ba 	ldrh	r3, [fp, #-10]
100004d8:	e1a03083 	lsl	r3, r3, #1
100004dc:	e51b201c 	ldr	r2, [fp, #-28]
100004e0:	e0823003 	add	r3, r2, r3
100004e4:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
100004e8:	e1c320b0 	strh	r2, [r3]

                lastSwapPosTemp = j;
100004ec:	e15b30ba 	ldrh	r3, [fp, #-10]
100004f0:	e14b30b6 	strh	r3, [fp, #-6]
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
    {
        lastSwapPos = lastSwapPosTemp;
        for (j = size - 1; j >lastSwapPos; j--)
100004f4:	e15b30ba 	ldrh	r3, [fp, #-10]
100004f8:	e2433001 	sub	r3, r3, #1
100004fc:	e14b30ba 	strh	r3, [fp, #-10]
10000500:	e15b20ba 	ldrh	r2, [fp, #-10]
10000504:	e15b30bc 	ldrh	r3, [fp, #-12]
10000508:	e1520003 	cmp	r2, r3
1000050c:	8affffb8 	bhi	100003f4 <BubbleSort+0x50>
                b[j] = temp1;

                lastSwapPosTemp = j;
            }
        }
        if (lastSwapPos == lastSwapPosTemp)break;
10000510:	e15b20bc 	ldrh	r2, [fp, #-12]
10000514:	e15b30b6 	ldrh	r3, [fp, #-6]
10000518:	e1520003 	cmp	r2, r3
1000051c:	1a000000 	bne	10000524 <BubbleSort+0x180>
10000520:	ea000007 	b	10000544 <BubbleSort+0x1a0>
{
	uint16_t lastSwapPos = 0,lastSwapPosTemp = 0;
	uint16_t i,j;
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
10000524:	e15b30b8 	ldrh	r3, [fp, #-8]
10000528:	e2833001 	add	r3, r3, #1
1000052c:	e14b30b8 	strh	r3, [fp, #-8]
10000530:	e15b20b8 	ldrh	r2, [fp, #-8]
10000534:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
10000538:	e2433001 	sub	r3, r3, #1
1000053c:	e1520003 	cmp	r2, r3
10000540:	baffffa5 	blt	100003dc <BubbleSort+0x38>
                lastSwapPosTemp = j;
            }
        }
        if (lastSwapPos == lastSwapPosTemp)break;
    }
}
10000544:	e24bd000 	sub	sp, fp, #0
10000548:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000054c:	e12fff1e 	bx	lr

10000550 <MATH_UINT16_T_ABS>:

uint16_t MATH_UINT16_T_ABS(uint16_t a, uint16_t b)
{
10000550:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000554:	e28db000 	add	fp, sp, #0
10000558:	e24dd00c 	sub	sp, sp, #12
1000055c:	e1a02000 	mov	r2, r0
10000560:	e1a03001 	mov	r3, r1
10000564:	e14b20b6 	strh	r2, [fp, #-6]
10000568:	e14b30b8 	strh	r3, [fp, #-8]
	if(a>b)
1000056c:	e15b20b6 	ldrh	r2, [fp, #-6]
10000570:	e15b30b8 	ldrh	r3, [fp, #-8]
10000574:	e1520003 	cmp	r2, r3
10000578:	9a000004 	bls	10000590 <MATH_UINT16_T_ABS+0x40>
		return a-b;
1000057c:	e15b20b6 	ldrh	r2, [fp, #-6]
10000580:	e15b30b8 	ldrh	r3, [fp, #-8]
10000584:	e0633002 	rsb	r3, r3, r2
10000588:	e6ff3073 	uxth	r3, r3
1000058c:	ea000003 	b	100005a0 <MATH_UINT16_T_ABS+0x50>
	else
		return b-a;
10000590:	e15b20b8 	ldrh	r2, [fp, #-8]
10000594:	e15b30b6 	ldrh	r3, [fp, #-6]
10000598:	e0633002 	rsb	r3, r3, r2
1000059c:	e6ff3073 	uxth	r3, r3
}
100005a0:	e1a00003 	mov	r0, r3
100005a4:	e24bd000 	sub	sp, fp, #0
100005a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100005ac:	e12fff1e 	bx	lr

100005b0 <INITPOSDET_Run>:

void INITPOSDET_Run(INITPOSDET_Handle handle, float_t value)
{
100005b0:	e92d4800 	push	{fp, lr}
100005b4:	e28db004 	add	fp, sp, #4
100005b8:	e24dd038 	sub	sp, sp, #56	; 0x38
100005bc:	e50b0038 	str	r0, [fp, #-56]	; 0x38
100005c0:	ed0b0a0f 	vstr	s0, [fp, #-60]	; 0xffffffc4
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
100005c4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100005c8:	e50b300c 	str	r3, [fp, #-12]
	uint16_t i,InitPosAngleCount_Evg,InitPosAngleCount_Min,InitPosAngleCount_Mid,InitPosAngleCount_Max,b[VOL_VEC_ANGLE_SCLAR/2]={0};
100005cc:	e24b3030 	sub	r3, fp, #48	; 0x30
100005d0:	e3a02000 	mov	r2, #0
100005d4:	e5832000 	str	r2, [r3]
100005d8:	e2833004 	add	r3, r3, #4
100005dc:	e3a02000 	mov	r2, #0
100005e0:	e5832000 	str	r2, [r3]
100005e4:	e2833004 	add	r3, r3, #4
100005e8:	e3a02000 	mov	r2, #0
100005ec:	e5832000 	str	r2, [r3]
100005f0:	e2833004 	add	r3, r3, #4
100005f4:	e3a02000 	mov	r2, #0
100005f8:	e5832000 	str	r2, [r3]
100005fc:	e2833004 	add	r3, r3, #4
10000600:	e3a02000 	mov	r2, #0
10000604:	e5832000 	str	r2, [r3]
10000608:	e2833004 	add	r3, r3, #4
1000060c:	e3a02000 	mov	r2, #0
10000610:	e5832000 	str	r2, [r3]
10000614:	e2833004 	add	r3, r3, #4

	if(obj->IdSampAngleFlag)
10000618:	e51b300c 	ldr	r3, [fp, #-12]
1000061c:	e1d331ba 	ldrh	r3, [r3, #26]
10000620:	e3530000 	cmp	r3, #0
10000624:	0a00014e 	beq	10000b64 <INITPOSDET_Run+0x5b4>
	{
		if( obj->IdEvgCount<ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
10000628:	e51b300c 	ldr	r3, [fp, #-12]
1000062c:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
10000630:	e3530f96 	cmp	r3, #600	; 0x258
10000634:	2a00014a 	bcs	10000b64 <INITPOSDET_Run+0x5b4>
		{
			if(obj->IdEvgCount>=ID_EVG_SCLAR2*VOL_VEC_ANGLE_SCLAR/2)// Need Improve
10000638:	e51b300c 	ldr	r3, [fp, #-12]
1000063c:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
10000640:	e353003b 	cmp	r3, #59	; 0x3b
10000644:	9a000047 	bls	10000768 <INITPOSDET_Run+0x1b8>
			{
				float_t value_tmp = obj->IdEvg[obj->IdSampAngleCount]/(obj->IdEvgCount/(VOL_VEC_ANGLE_SCLAR/2));
10000648:	e51b300c 	ldr	r3, [fp, #-12]
1000064c:	e1d332b0 	ldrh	r3, [r3, #32]
10000650:	e51b200c 	ldr	r2, [fp, #-12]
10000654:	e2833008 	add	r3, r3, #8
10000658:	e1a03103 	lsl	r3, r3, #2
1000065c:	e0823003 	add	r3, r2, r3
10000660:	ed937a01 	vldr	s14, [r3, #4]
10000664:	e51b300c 	ldr	r3, [fp, #-12]
10000668:	e1d325b8 	ldrh	r2, [r3, #88]	; 0x58
1000066c:	e30a3aab 	movw	r3, #43691	; 0xaaab
10000670:	e34a3aaa 	movt	r3, #43690	; 0xaaaa
10000674:	e0832392 	umull	r2, r3, r2, r3
10000678:	e1a031a3 	lsr	r3, r3, #3
1000067c:	e6ff3073 	uxth	r3, r3
10000680:	ee073a90 	vmov	s15, r3
10000684:	eef87ae7 	vcvt.f32.s32	s15, s15
10000688:	eec77a27 	vdiv.f32	s15, s14, s15
1000068c:	ed4b7a04 	vstr	s15, [fp, #-16]
				if( MATH_abs( value_tmp - (obj->IdEvgCoeff * value) )
10000690:	e51b300c 	ldr	r3, [fp, #-12]
10000694:	ed937a15 	vldr	s14, [r3, #84]	; 0x54
10000698:	ed5b7a0f 	vldr	s15, [fp, #-60]	; 0xffffffc4
1000069c:	ee677a27 	vmul.f32	s15, s14, s15
100006a0:	ed1b7a04 	vldr	s14, [fp, #-16]
100006a4:	ee777a67 	vsub.f32	s15, s14, s15
100006a8:	eeb00a67 	vmov.f32	s0, s15
100006ac:	ebfffed9 	bl	10000218 <MATH_abs>
100006b0:	eef06a40 	vmov.f32	s13, s0
						> ((0.2f) * value_tmp) )
100006b4:	ed5b7a04 	vldr	s15, [fp, #-16]
100006b8:	ed9f7af7 	vldr	s14, [pc, #988]	; 10000a9c <INITPOSDET_Run+0x4ec>
100006bc:	ee677a87 	vmul.f32	s15, s15, s14
		if( obj->IdEvgCount<ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
		{
			if(obj->IdEvgCount>=ID_EVG_SCLAR2*VOL_VEC_ANGLE_SCLAR/2)// Need Improve
			{
				float_t value_tmp = obj->IdEvg[obj->IdSampAngleCount]/(obj->IdEvgCount/(VOL_VEC_ANGLE_SCLAR/2));
				if( MATH_abs( value_tmp - (obj->IdEvgCoeff * value) )
100006c0:	eef46ae7 	vcmpe.f32	s13, s15
100006c4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100006c8:	da000011 	ble	10000714 <INITPOSDET_Run+0x164>
						> ((0.2f) * value_tmp) )
				{
					obj->IdEvg[obj->IdSampAngleCount] += value_tmp;
100006cc:	e51b300c 	ldr	r3, [fp, #-12]
100006d0:	e1d332b0 	ldrh	r3, [r3, #32]
100006d4:	e1a01003 	mov	r1, r3
100006d8:	e51b300c 	ldr	r3, [fp, #-12]
100006dc:	e1d332b0 	ldrh	r3, [r3, #32]
100006e0:	e51b200c 	ldr	r2, [fp, #-12]
100006e4:	e2833008 	add	r3, r3, #8
100006e8:	e1a03103 	lsl	r3, r3, #2
100006ec:	e0823003 	add	r3, r2, r3
100006f0:	ed937a01 	vldr	s14, [r3, #4]
100006f4:	ed5b7a04 	vldr	s15, [fp, #-16]
100006f8:	ee777a27 	vadd.f32	s15, s14, s15
100006fc:	e51b200c 	ldr	r2, [fp, #-12]
10000700:	e2813008 	add	r3, r1, #8
10000704:	e1a03103 	lsl	r3, r3, #2
10000708:	e0823003 	add	r3, r2, r3
1000070c:	edc37a01 	vstr	s15, [r3, #4]
10000710:	ea000028 	b	100007b8 <INITPOSDET_Run+0x208>
				}
				else
				{
					obj->IdEvg[obj->IdSampAngleCount] += (obj->IdEvgCoeff * value);
10000714:	e51b300c 	ldr	r3, [fp, #-12]
10000718:	e1d332b0 	ldrh	r3, [r3, #32]
1000071c:	e1a01003 	mov	r1, r3
10000720:	e51b300c 	ldr	r3, [fp, #-12]
10000724:	e1d332b0 	ldrh	r3, [r3, #32]
10000728:	e51b200c 	ldr	r2, [fp, #-12]
1000072c:	e2833008 	add	r3, r3, #8
10000730:	e1a03103 	lsl	r3, r3, #2
10000734:	e0823003 	add	r3, r2, r3
10000738:	ed937a01 	vldr	s14, [r3, #4]
1000073c:	e51b300c 	ldr	r3, [fp, #-12]
10000740:	edd36a15 	vldr	s13, [r3, #84]	; 0x54
10000744:	ed5b7a0f 	vldr	s15, [fp, #-60]	; 0xffffffc4
10000748:	ee667aa7 	vmul.f32	s15, s13, s15
1000074c:	ee777a27 	vadd.f32	s15, s14, s15
10000750:	e51b200c 	ldr	r2, [fp, #-12]
10000754:	e2813008 	add	r3, r1, #8
10000758:	e1a03103 	lsl	r3, r3, #2
1000075c:	e0823003 	add	r3, r2, r3
10000760:	edc37a01 	vstr	s15, [r3, #4]
10000764:	ea000013 	b	100007b8 <INITPOSDET_Run+0x208>
				}
			}
			else
			{
				obj->IdEvg[obj->IdSampAngleCount] += (obj->IdEvgCoeff * value);
10000768:	e51b300c 	ldr	r3, [fp, #-12]
1000076c:	e1d332b0 	ldrh	r3, [r3, #32]
10000770:	e1a01003 	mov	r1, r3
10000774:	e51b300c 	ldr	r3, [fp, #-12]
10000778:	e1d332b0 	ldrh	r3, [r3, #32]
1000077c:	e51b200c 	ldr	r2, [fp, #-12]
10000780:	e2833008 	add	r3, r3, #8
10000784:	e1a03103 	lsl	r3, r3, #2
10000788:	e0823003 	add	r3, r2, r3
1000078c:	ed937a01 	vldr	s14, [r3, #4]
10000790:	e51b300c 	ldr	r3, [fp, #-12]
10000794:	edd36a15 	vldr	s13, [r3, #84]	; 0x54
10000798:	ed5b7a0f 	vldr	s15, [fp, #-60]	; 0xffffffc4
1000079c:	ee667aa7 	vmul.f32	s15, s13, s15
100007a0:	ee777a27 	vadd.f32	s15, s14, s15
100007a4:	e51b200c 	ldr	r2, [fp, #-12]
100007a8:	e2813008 	add	r3, r1, #8
100007ac:	e1a03103 	lsl	r3, r3, #2
100007b0:	e0823003 	add	r3, r2, r3
100007b4:	edc37a01 	vstr	s15, [r3, #4]
			}

			obj->IdEvgCount++;
100007b8:	e51b300c 	ldr	r3, [fp, #-12]
100007bc:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
100007c0:	e2833001 	add	r3, r3, #1
100007c4:	e6ff2073 	uxth	r2, r3
100007c8:	e51b300c 	ldr	r3, [fp, #-12]
100007cc:	e1c325b8 	strh	r2, [r3, #88]	; 0x58

			if( obj->IdEvgCount>=ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
100007d0:	e51b300c 	ldr	r3, [fp, #-12]
100007d4:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
100007d8:	e3530f96 	cmp	r3, #600	; 0x258
100007dc:	3a0000e0 	bcc	10000b64 <INITPOSDET_Run+0x5b4>
//						Id_max = obj->IdEvg[i];
//						obj->InitPosAngleCount = i;
//					}
//				}

				for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
100007e0:	e3a03000 	mov	r3, #0
100007e4:	e14b30b6 	strh	r3, [fp, #-6]
100007e8:	ea000009 	b	10000814 <INITPOSDET_Run+0x264>
				{
					b[i]=i;
100007ec:	e15b30b6 	ldrh	r3, [fp, #-6]
100007f0:	e1a03083 	lsl	r3, r3, #1
100007f4:	e24b2004 	sub	r2, fp, #4
100007f8:	e0823003 	add	r3, r2, r3
100007fc:	e243302c 	sub	r3, r3, #44	; 0x2c
10000800:	e15b20b6 	ldrh	r2, [fp, #-6]
10000804:	e1c320b0 	strh	r2, [r3]
//						Id_max = obj->IdEvg[i];
//						obj->InitPosAngleCount = i;
//					}
//				}

				for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
10000808:	e15b30b6 	ldrh	r3, [fp, #-6]
1000080c:	e2833001 	add	r3, r3, #1
10000810:	e14b30b6 	strh	r3, [fp, #-6]
10000814:	e15b30b6 	ldrh	r3, [fp, #-6]
10000818:	e353000b 	cmp	r3, #11
1000081c:	9afffff2 	bls	100007ec <INITPOSDET_Run+0x23c>
				{
					b[i]=i;
					//obj->IdEvgArray[obj->ArrayCount][i]=obj->IdEvg[i];
				}

				obj->IdEvg[0]=0;obj->IdEvg[1]=2;obj->IdEvg[2]=4;obj->IdEvg[3]=6;obj->IdEvg[4]=8;obj->IdEvg[5]=10;
10000820:	e51b300c 	ldr	r3, [fp, #-12]
10000824:	e3a02000 	mov	r2, #0
10000828:	e5832024 	str	r2, [r3, #36]	; 0x24
1000082c:	e51b300c 	ldr	r3, [fp, #-12]
10000830:	e3a02101 	mov	r2, #1073741824	; 0x40000000
10000834:	e5832028 	str	r2, [r3, #40]	; 0x28
10000838:	e51b300c 	ldr	r3, [fp, #-12]
1000083c:	e3a02000 	mov	r2, #0
10000840:	e3442080 	movt	r2, #16512	; 0x4080
10000844:	e583202c 	str	r2, [r3, #44]	; 0x2c
10000848:	e51b300c 	ldr	r3, [fp, #-12]
1000084c:	e3a02000 	mov	r2, #0
10000850:	e34420c0 	movt	r2, #16576	; 0x40c0
10000854:	e5832030 	str	r2, [r3, #48]	; 0x30
10000858:	e51b300c 	ldr	r3, [fp, #-12]
1000085c:	e3a02441 	mov	r2, #1090519040	; 0x41000000
10000860:	e5832034 	str	r2, [r3, #52]	; 0x34
10000864:	e51b300c 	ldr	r3, [fp, #-12]
10000868:	e3a02000 	mov	r2, #0
1000086c:	e3442120 	movt	r2, #16672	; 0x4120
10000870:	e5832038 	str	r2, [r3, #56]	; 0x38
				obj->IdEvg[6]=1;obj->IdEvg[7]=3;obj->IdEvg[8]=5;obj->IdEvg[9]=7;obj->IdEvg[10]=9;obj->IdEvg[11]=11;
10000874:	e51b300c 	ldr	r3, [fp, #-12]
10000878:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
1000087c:	e583203c 	str	r2, [r3, #60]	; 0x3c
10000880:	e51b300c 	ldr	r3, [fp, #-12]
10000884:	e3a02000 	mov	r2, #0
10000888:	e3442040 	movt	r2, #16448	; 0x4040
1000088c:	e5832040 	str	r2, [r3, #64]	; 0x40
10000890:	e51b300c 	ldr	r3, [fp, #-12]
10000894:	e3a02000 	mov	r2, #0
10000898:	e34420a0 	movt	r2, #16544	; 0x40a0
1000089c:	e5832044 	str	r2, [r3, #68]	; 0x44
100008a0:	e51b300c 	ldr	r3, [fp, #-12]
100008a4:	e3a02000 	mov	r2, #0
100008a8:	e34420e0 	movt	r2, #16608	; 0x40e0
100008ac:	e5832048 	str	r2, [r3, #72]	; 0x48
100008b0:	e51b300c 	ldr	r3, [fp, #-12]
100008b4:	e3a02000 	mov	r2, #0
100008b8:	e3442110 	movt	r2, #16656	; 0x4110
100008bc:	e583204c 	str	r2, [r3, #76]	; 0x4c
100008c0:	e51b300c 	ldr	r3, [fp, #-12]
100008c4:	e3a02000 	mov	r2, #0
100008c8:	e3442130 	movt	r2, #16688	; 0x4130
100008cc:	e5832050 	str	r2, [r3, #80]	; 0x50
				BubbleSort(obj->IdEvg,b,VOL_VEC_ANGLE_SCLAR/2);
100008d0:	e51b300c 	ldr	r3, [fp, #-12]
100008d4:	e2832024 	add	r2, r3, #36	; 0x24
100008d8:	e24b3030 	sub	r3, fp, #48	; 0x30
100008dc:	e1a00002 	mov	r0, r2
100008e0:	e1a01003 	mov	r1, r3
100008e4:	e3a0200c 	mov	r2, #12
100008e8:	ebfffead 	bl	100003a4 <BubbleSort>

				InitPosAngleCount_Evg = (b[0] + b[1] + b[2] + b[3] + b[4])/5;
100008ec:	e15b33b0 	ldrh	r3, [fp, #-48]	; 0xffffffd0
100008f0:	e1a02003 	mov	r2, r3
100008f4:	e15b32be 	ldrh	r3, [fp, #-46]	; 0xffffffd2
100008f8:	e0823003 	add	r3, r2, r3
100008fc:	e15b22bc 	ldrh	r2, [fp, #-44]	; 0xffffffd4
10000900:	e0833002 	add	r3, r3, r2
10000904:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
10000908:	e0833002 	add	r3, r3, r2
1000090c:	e15b22b8 	ldrh	r2, [fp, #-40]	; 0xffffffd8
10000910:	e0831002 	add	r1, r3, r2
10000914:	e3063667 	movw	r3, #26215	; 0x6667
10000918:	e3463666 	movt	r3, #26214	; 0x6666
1000091c:	e0c32391 	smull	r2, r3, r1, r3
10000920:	e1a020c3 	asr	r2, r3, #1
10000924:	e1a03fc1 	asr	r3, r1, #31
10000928:	e0633002 	rsb	r3, r3, r2
1000092c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
				InitPosAngleCount_Min = MATH_UINT16_T_ABS(b[0],InitPosAngleCount_Evg);
10000930:	e15b23b0 	ldrh	r2, [fp, #-48]	; 0xffffffd0
10000934:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
10000938:	e1a00002 	mov	r0, r2
1000093c:	e1a01003 	mov	r1, r3
10000940:	ebffff02 	bl	10000550 <MATH_UINT16_T_ABS>
10000944:	e1a03000 	mov	r3, r0
10000948:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
				InitPosAngleCount_Mid = MATH_UINT16_T_ABS(b[1],InitPosAngleCount_Evg);
1000094c:	e15b22be 	ldrh	r2, [fp, #-46]	; 0xffffffd2
10000950:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
10000954:	e1a00002 	mov	r0, r2
10000958:	e1a01003 	mov	r1, r3
1000095c:	ebfffefb 	bl	10000550 <MATH_UINT16_T_ABS>
10000960:	e1a03000 	mov	r3, r0
10000964:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
				InitPosAngleCount_Max = MATH_UINT16_T_ABS(b[2],InitPosAngleCount_Evg);
10000968:	e15b22bc 	ldrh	r2, [fp, #-44]	; 0xffffffd4
1000096c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
10000970:	e1a00002 	mov	r0, r2
10000974:	e1a01003 	mov	r1, r3
10000978:	ebfffef4 	bl	10000550 <MATH_UINT16_T_ABS>
1000097c:	e1a03000 	mov	r3, r0
10000980:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
				if( InitPosAngleCount_Min < InitPosAngleCount_Mid && InitPosAngleCount_Min < InitPosAngleCount_Max )
10000984:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
10000988:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
1000098c:	e1520003 	cmp	r2, r3
10000990:	2a000007 	bcs	100009b4 <INITPOSDET_Run+0x404>
10000994:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
10000998:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
1000099c:	e1520003 	cmp	r2, r3
100009a0:	2a000003 	bcs	100009b4 <INITPOSDET_Run+0x404>
				{
					obj->InitPosAngleCount = b[0];
100009a4:	e15b23b0 	ldrh	r2, [fp, #-48]	; 0xffffffd0
100009a8:	e51b300c 	ldr	r3, [fp, #-12]
100009ac:	e1c320b2 	strh	r2, [r3, #2]
100009b0:	ea000016 	b	10000a10 <INITPOSDET_Run+0x460>
				}
				else if( InitPosAngleCount_Mid < InitPosAngleCount_Min && InitPosAngleCount_Mid < InitPosAngleCount_Max )
100009b4:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
100009b8:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
100009bc:	e1520003 	cmp	r2, r3
100009c0:	2a000007 	bcs	100009e4 <INITPOSDET_Run+0x434>
100009c4:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
100009c8:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
100009cc:	e1520003 	cmp	r2, r3
100009d0:	2a000003 	bcs	100009e4 <INITPOSDET_Run+0x434>
				{
					obj->InitPosAngleCount = b[1];
100009d4:	e15b22be 	ldrh	r2, [fp, #-46]	; 0xffffffd2
100009d8:	e51b300c 	ldr	r3, [fp, #-12]
100009dc:	e1c320b2 	strh	r2, [r3, #2]
100009e0:	ea00000a 	b	10000a10 <INITPOSDET_Run+0x460>
				}
				else if( InitPosAngleCount_Max < InitPosAngleCount_Min && InitPosAngleCount_Max < InitPosAngleCount_Mid )
100009e4:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
100009e8:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
100009ec:	e1520003 	cmp	r2, r3
100009f0:	2a000006 	bcs	10000a10 <INITPOSDET_Run+0x460>
100009f4:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
100009f8:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
100009fc:	e1520003 	cmp	r2, r3
10000a00:	2a000002 	bcs	10000a10 <INITPOSDET_Run+0x460>
				{
					obj->InitPosAngleCount = b[2];
10000a04:	e15b22bc 	ldrh	r2, [fp, #-44]	; 0xffffffd4
10000a08:	e51b300c 	ldr	r3, [fp, #-12]
10000a0c:	e1c320b2 	strh	r2, [r3, #2]
				}
				
				obj->InitPosAngle = obj->InitPosAngleCount*obj->SubdivideAngle + obj->VolVecAngleOffset;
10000a10:	e51b300c 	ldr	r3, [fp, #-12]
10000a14:	e1d330b2 	ldrh	r3, [r3, #2]
10000a18:	ee073a90 	vmov	s15, r3
10000a1c:	eeb87ae7 	vcvt.f32.s32	s14, s15
10000a20:	e51b300c 	ldr	r3, [fp, #-12]
10000a24:	edd37a02 	vldr	s15, [r3, #8]
10000a28:	ee277a27 	vmul.f32	s14, s14, s15
10000a2c:	e51b300c 	ldr	r3, [fp, #-12]
10000a30:	edd37a05 	vldr	s15, [r3, #20]
10000a34:	ee777a27 	vadd.f32	s15, s14, s15
10000a38:	e51b300c 	ldr	r3, [fp, #-12]
10000a3c:	edc37a01 	vstr	s15, [r3, #4]
				obj->VolVecAngleOffset = obj->InitPosAngle - obj->SubdivideAngle - obj->SubdivideAngle;
10000a40:	e51b300c 	ldr	r3, [fp, #-12]
10000a44:	ed937a01 	vldr	s14, [r3, #4]
10000a48:	e51b300c 	ldr	r3, [fp, #-12]
10000a4c:	edd37a02 	vldr	s15, [r3, #8]
10000a50:	ee377a67 	vsub.f32	s14, s14, s15
10000a54:	e51b300c 	ldr	r3, [fp, #-12]
10000a58:	edd37a02 	vldr	s15, [r3, #8]
10000a5c:	ee777a67 	vsub.f32	s15, s14, s15
10000a60:	e51b300c 	ldr	r3, [fp, #-12]
10000a64:	edc37a05 	vstr	s15, [r3, #20]
				if( obj->VolVecAngleOffset > (1.0f) )
10000a68:	e51b300c 	ldr	r3, [fp, #-12]
10000a6c:	edd37a05 	vldr	s15, [r3, #20]
10000a70:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10000a74:	eef47ac7 	vcmpe.f32	s15, s14
10000a78:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10000a7c:	da000009 	ble	10000aa8 <INITPOSDET_Run+0x4f8>
					obj->VolVecAngleOffset -= (1.0f);
10000a80:	e51b300c 	ldr	r3, [fp, #-12]
10000a84:	edd37a05 	vldr	s15, [r3, #20]
10000a88:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10000a8c:	ee777ac7 	vsub.f32	s15, s15, s14
10000a90:	e51b300c 	ldr	r3, [fp, #-12]
10000a94:	edc37a05 	vstr	s15, [r3, #20]
10000a98:	ea00000e 	b	10000ad8 <INITPOSDET_Run+0x528>
10000a9c:	3e4ccccd 	.word	0x3e4ccccd
10000aa0:	3eaaaa9f 	.word	0x3eaaaa9f
10000aa4:	3c23d70a 	.word	0x3c23d70a
				else if( obj->VolVecAngleOffset < (-1.0f) )
10000aa8:	e51b300c 	ldr	r3, [fp, #-12]
10000aac:	edd37a05 	vldr	s15, [r3, #20]
10000ab0:	eebf7a00 	vmov.f32	s14, #240	; 0xf0
10000ab4:	eef47ac7 	vcmpe.f32	s15, s14
10000ab8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10000abc:	5a000005 	bpl	10000ad8 <INITPOSDET_Run+0x528>
					obj->VolVecAngleOffset += (1.0f);
10000ac0:	e51b300c 	ldr	r3, [fp, #-12]
10000ac4:	edd37a05 	vldr	s15, [r3, #20]
10000ac8:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10000acc:	ee777a87 	vadd.f32	s15, s15, s14
10000ad0:	e51b300c 	ldr	r3, [fp, #-12]
10000ad4:	edc37a05 	vstr	s15, [r3, #20]
				obj->SubdivideAngle = (obj->SubdivideAngle * (0.333333f));//(0.5f) Test:(1.0f)
10000ad8:	e51b300c 	ldr	r3, [fp, #-12]
10000adc:	edd37a02 	vldr	s15, [r3, #8]
10000ae0:	ed1f7a12 	vldr	s14, [pc, #-72]	; 10000aa0 <INITPOSDET_Run+0x4f0>
10000ae4:	ee677a87 	vmul.f32	s15, s15, s14
10000ae8:	e51b300c 	ldr	r3, [fp, #-12]
10000aec:	edc37a02 	vstr	s15, [r3, #8]
				if( obj->SubdivideAngle < (0.01f) )// 0.005f Test: 0.01f
10000af0:	e51b300c 	ldr	r3, [fp, #-12]
10000af4:	edd37a02 	vldr	s15, [r3, #8]
10000af8:	ed1f7a17 	vldr	s14, [pc, #-92]	; 10000aa4 <INITPOSDET_Run+0x4f4>
10000afc:	eef47ac7 	vcmpe.f32	s15, s14
10000b00:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10000b04:	5a000003 	bpl	10000b18 <INITPOSDET_Run+0x568>
				{
					obj->InitPosDetFlag = false;
10000b08:	e51b300c 	ldr	r3, [fp, #-12]
10000b0c:	e3a02000 	mov	r2, #0
10000b10:	e1c320b0 	strh	r2, [r3]
10000b14:	ea000012 	b	10000b64 <INITPOSDET_Run+0x5b4>
				}
				else
				{
					obj->IdEvgCount = 0;
10000b18:	e51b300c 	ldr	r3, [fp, #-12]
10000b1c:	e3a02000 	mov	r2, #0
10000b20:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
					for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
10000b24:	e3a03000 	mov	r3, #0
10000b28:	e14b30b6 	strh	r3, [fp, #-6]
10000b2c:	ea000009 	b	10000b58 <INITPOSDET_Run+0x5a8>
					{
						obj->IdEvg[i] = (0.0f);
10000b30:	e15b30b6 	ldrh	r3, [fp, #-6]
10000b34:	e51b200c 	ldr	r2, [fp, #-12]
10000b38:	e2833008 	add	r3, r3, #8
10000b3c:	e1a03103 	lsl	r3, r3, #2
10000b40:	e0823003 	add	r3, r2, r3
10000b44:	e3a02000 	mov	r2, #0
10000b48:	e5832004 	str	r2, [r3, #4]
					obj->InitPosDetFlag = false;
				}
				else
				{
					obj->IdEvgCount = 0;
					for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
10000b4c:	e15b30b6 	ldrh	r3, [fp, #-6]
10000b50:	e2833001 	add	r3, r3, #1
10000b54:	e14b30b6 	strh	r3, [fp, #-6]
10000b58:	e15b30b6 	ldrh	r3, [fp, #-6]
10000b5c:	e353000b 	cmp	r3, #11
10000b60:	9afffff2 	bls	10000b30 <INITPOSDET_Run+0x580>
//				obj->IdEvgCount = 0;
			}
		}
	}

	return;
10000b64:	e1a00000 	nop			; (mov r0, r0)
}
10000b68:	e24bd004 	sub	sp, fp, #4
10000b6c:	e8bd8800 	pop	{fp, pc}

10000b70 <INITPOSDET_VolVecAngleRun>:


void INITPOSDET_VolVecAngleRun(INITPOSDET_Handle handle)
{
10000b70:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000b74:	e28db000 	add	fp, sp, #0
10000b78:	e24dd014 	sub	sp, sp, #20
10000b7c:	e50b0010 	str	r0, [fp, #-16]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
10000b80:	e51b3010 	ldr	r3, [fp, #-16]
10000b84:	e50b3008 	str	r3, [fp, #-8]
	uint16_t count_temp = 0;
10000b88:	e3a03000 	mov	r3, #0
10000b8c:	e14b30ba 	strh	r3, [fp, #-10]

	if(obj->InitPosDetFlag)
10000b90:	e51b3008 	ldr	r3, [fp, #-8]
10000b94:	e1d330b0 	ldrh	r3, [r3]
10000b98:	e3530000 	cmp	r3, #0
10000b9c:	0a000069 	beq	10000d48 <INITPOSDET_VolVecAngleRun+0x1d8>
	{
		if( obj->VolVecAngleIntervalTime >= VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR )
10000ba0:	e51b3008 	ldr	r3, [fp, #-8]
10000ba4:	e1d331b8 	ldrh	r3, [r3, #24]
10000ba8:	e3530009 	cmp	r3, #9
10000bac:	9a000058 	bls	10000d14 <INITPOSDET_VolVecAngleRun+0x1a4>
		{
			if( obj->VolVecAngleCount < VOL_VEC_ANGLE_SCLAR )
10000bb0:	e51b3008 	ldr	r3, [fp, #-8]
10000bb4:	e1d330be 	ldrh	r3, [r3, #14]
10000bb8:	e3530017 	cmp	r3, #23
10000bbc:	8a000067 	bhi	10000d60 <INITPOSDET_VolVecAngleRun+0x1f0>
			{
				count_temp = obj->VolVecAngleCount / 2;
10000bc0:	e51b3008 	ldr	r3, [fp, #-8]
10000bc4:	e1d330be 	ldrh	r3, [r3, #14]
10000bc8:	e1a030a3 	lsr	r3, r3, #1
10000bcc:	e14b30ba 	strh	r3, [fp, #-10]
				obj->VolVecAngle = count_temp * obj->SubdivideAngle + obj->VolVecAngleOffset;
10000bd0:	e15b30ba 	ldrh	r3, [fp, #-10]
10000bd4:	ee073a90 	vmov	s15, r3
10000bd8:	eeb87ae7 	vcvt.f32.s32	s14, s15
10000bdc:	e51b3008 	ldr	r3, [fp, #-8]
10000be0:	edd37a02 	vldr	s15, [r3, #8]
10000be4:	ee277a27 	vmul.f32	s14, s14, s15
10000be8:	e51b3008 	ldr	r3, [fp, #-8]
10000bec:	edd37a05 	vldr	s15, [r3, #20]
10000bf0:	ee777a27 	vadd.f32	s15, s14, s15
10000bf4:	e51b3008 	ldr	r3, [fp, #-8]
10000bf8:	edc37a04 	vstr	s15, [r3, #16]
				obj->IdSampAngle = obj->VolVecAngle;
10000bfc:	e51b3008 	ldr	r3, [fp, #-8]
10000c00:	e5932010 	ldr	r2, [r3, #16]
10000c04:	e51b3008 	ldr	r3, [fp, #-8]
10000c08:	e583201c 	str	r2, [r3, #28]
				obj->IdSampAngleFlag = false;
10000c0c:	e51b3008 	ldr	r3, [fp, #-8]
10000c10:	e3a02000 	mov	r2, #0
10000c14:	e1c321ba 	strh	r2, [r3, #26]
				obj->IdSampAngleCount = count_temp;
10000c18:	e51b3008 	ldr	r3, [fp, #-8]
10000c1c:	e15b20ba 	ldrh	r2, [fp, #-10]
10000c20:	e1c322b0 	strh	r2, [r3, #32]
				if( obj->VolVecAngleCount %2 == 1 )
10000c24:	e51b3008 	ldr	r3, [fp, #-8]
10000c28:	e1d330be 	ldrh	r3, [r3, #14]
10000c2c:	e2033001 	and	r3, r3, #1
10000c30:	e6ff3073 	uxth	r3, r3
10000c34:	e3530000 	cmp	r3, #0
10000c38:	0a00000b 	beq	10000c6c <INITPOSDET_VolVecAngleRun+0xfc>
				{
					obj->VolVecAngle += (0.5f);
10000c3c:	e51b3008 	ldr	r3, [fp, #-8]
10000c40:	edd37a04 	vldr	s15, [r3, #16]
10000c44:	eeb67a00 	vmov.f32	s14, #96	; 0x60
10000c48:	ee777a87 	vadd.f32	s15, s15, s14
10000c4c:	e51b3008 	ldr	r3, [fp, #-8]
10000c50:	edc37a04 	vstr	s15, [r3, #16]
					obj->VolVecAngleIntervalTime = 1;
10000c54:	e51b3008 	ldr	r3, [fp, #-8]
10000c58:	e3a02001 	mov	r2, #1
10000c5c:	e1c321b8 	strh	r2, [r3, #24]
					obj->IdSampAngleFlag = true;
10000c60:	e51b3008 	ldr	r3, [fp, #-8]
10000c64:	e3a02001 	mov	r2, #1
10000c68:	e1c321ba 	strh	r2, [r3, #26]
				}
				if( obj->VolVecAngle > (1.0f) )
10000c6c:	e51b3008 	ldr	r3, [fp, #-8]
10000c70:	edd37a04 	vldr	s15, [r3, #16]
10000c74:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10000c78:	eef47ac7 	vcmpe.f32	s15, s14
10000c7c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10000c80:	da000006 	ble	10000ca0 <INITPOSDET_VolVecAngleRun+0x130>
					obj->VolVecAngle -= (1.0f);
10000c84:	e51b3008 	ldr	r3, [fp, #-8]
10000c88:	edd37a04 	vldr	s15, [r3, #16]
10000c8c:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10000c90:	ee777ac7 	vsub.f32	s15, s15, s14
10000c94:	e51b3008 	ldr	r3, [fp, #-8]
10000c98:	edc37a04 	vstr	s15, [r3, #16]
10000c9c:	ea00000b 	b	10000cd0 <INITPOSDET_VolVecAngleRun+0x160>
				else if( obj->VolVecAngle < (-1.0f) )
10000ca0:	e51b3008 	ldr	r3, [fp, #-8]
10000ca4:	edd37a04 	vldr	s15, [r3, #16]
10000ca8:	eebf7a00 	vmov.f32	s14, #240	; 0xf0
10000cac:	eef47ac7 	vcmpe.f32	s15, s14
10000cb0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10000cb4:	5a000005 	bpl	10000cd0 <INITPOSDET_VolVecAngleRun+0x160>
					obj->VolVecAngle += (1.0f);
10000cb8:	e51b3008 	ldr	r3, [fp, #-8]
10000cbc:	edd37a04 	vldr	s15, [r3, #16]
10000cc0:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10000cc4:	ee777a87 	vadd.f32	s15, s15, s14
10000cc8:	e51b3008 	ldr	r3, [fp, #-8]
10000ccc:	edc37a04 	vstr	s15, [r3, #16]

				obj->VolVecAngleCount++;
10000cd0:	e51b3008 	ldr	r3, [fp, #-8]
10000cd4:	e1d330be 	ldrh	r3, [r3, #14]
10000cd8:	e2833001 	add	r3, r3, #1
10000cdc:	e6ff2073 	uxth	r2, r3
10000ce0:	e51b3008 	ldr	r3, [fp, #-8]
10000ce4:	e1c320be 	strh	r2, [r3, #14]

				obj->VolVecAngleFlag = true;
10000ce8:	e51b3008 	ldr	r3, [fp, #-8]
10000cec:	e3a02001 	mov	r2, #1
10000cf0:	e1c320bc 	strh	r2, [r3, #12]

				if( obj->VolVecAngleCount >= VOL_VEC_ANGLE_SCLAR )
10000cf4:	e51b3008 	ldr	r3, [fp, #-8]
10000cf8:	e1d330be 	ldrh	r3, [r3, #14]
10000cfc:	e3530017 	cmp	r3, #23
10000d00:	9a000016 	bls	10000d60 <INITPOSDET_VolVecAngleRun+0x1f0>
				{
					obj->VolVecAngleCount=0;
10000d04:	e51b3008 	ldr	r3, [fp, #-8]
10000d08:	e3a02000 	mov	r2, #0
10000d0c:	e1c320be 	strh	r2, [r3, #14]
10000d10:	ea000012 	b	10000d60 <INITPOSDET_VolVecAngleRun+0x1f0>
				}
			}
		}
		else
		{
			obj->VolVecAngleIntervalTime++;
10000d14:	e51b3008 	ldr	r3, [fp, #-8]
10000d18:	e1d331b8 	ldrh	r3, [r3, #24]
10000d1c:	e2833001 	add	r3, r3, #1
10000d20:	e6ff2073 	uxth	r2, r3
10000d24:	e51b3008 	ldr	r3, [fp, #-8]
10000d28:	e1c321b8 	strh	r2, [r3, #24]
			obj->VolVecAngleFlag = false;
10000d2c:	e51b3008 	ldr	r3, [fp, #-8]
10000d30:	e3a02000 	mov	r2, #0
10000d34:	e1c320bc 	strh	r2, [r3, #12]
			obj->IdSampAngleFlag = false;
10000d38:	e51b3008 	ldr	r3, [fp, #-8]
10000d3c:	e3a02000 	mov	r2, #0
10000d40:	e1c321ba 	strh	r2, [r3, #26]
	else
	{
		obj->VolVecAngleFlag = false;
		obj->IdSampAngleFlag = false;
	}
	return;
10000d44:	ea000006 	b	10000d64 <INITPOSDET_VolVecAngleRun+0x1f4>
			obj->IdSampAngleFlag = false;
		}
	}
	else
	{
		obj->VolVecAngleFlag = false;
10000d48:	e51b3008 	ldr	r3, [fp, #-8]
10000d4c:	e3a02000 	mov	r2, #0
10000d50:	e1c320bc 	strh	r2, [r3, #12]
		obj->IdSampAngleFlag = false;
10000d54:	e51b3008 	ldr	r3, [fp, #-8]
10000d58:	e3a02000 	mov	r2, #0
10000d5c:	e1c321ba 	strh	r2, [r3, #26]
	}
	return;
10000d60:	e1a00000 	nop			; (mov r0, r0)
}
10000d64:	e24bd000 	sub	sp, fp, #0
10000d68:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000d6c:	e12fff1e 	bx	lr

10000d70 <MATH_sat>:
//! \param[in] in   The input value
//! \param[in] max  The maximum value allowed
//! \param[in] min  The minimum value allowed
//! \return    The saturated value
static inline float_t MATH_sat(const float_t in,const float_t max,const float_t min)
{
10000d70:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000d74:	e28db000 	add	fp, sp, #0
10000d78:	e24dd01c 	sub	sp, sp, #28
10000d7c:	ed0b0a04 	vstr	s0, [fp, #-16]
10000d80:	ed4b0a05 	vstr	s1, [fp, #-20]	; 0xffffffec
10000d84:	ed0b1a06 	vstr	s2, [fp, #-24]	; 0xffffffe8
  float_t out = in;
10000d88:	e51b3010 	ldr	r3, [fp, #-16]
10000d8c:	e50b3008 	str	r3, [fp, #-8]


  if(in < min)
10000d90:	ed1b7a04 	vldr	s14, [fp, #-16]
10000d94:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
10000d98:	eeb47ae7 	vcmpe.f32	s14, s15
10000d9c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10000da0:	5a000002 	bpl	10000db0 <MATH_sat+0x40>
    {
      out = min;
10000da4:	e51b3018 	ldr	r3, [fp, #-24]
10000da8:	e50b3008 	str	r3, [fp, #-8]
10000dac:	ea000006 	b	10000dcc <MATH_sat+0x5c>
    }
  else if(in > max)
10000db0:	ed1b7a04 	vldr	s14, [fp, #-16]
10000db4:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
10000db8:	eeb47ae7 	vcmpe.f32	s14, s15
10000dbc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10000dc0:	da000001 	ble	10000dcc <MATH_sat+0x5c>
    {
      out = max;
10000dc4:	e51b3014 	ldr	r3, [fp, #-20]
10000dc8:	e50b3008 	str	r3, [fp, #-8]
    }

  return(out);
10000dcc:	e51b3008 	ldr	r3, [fp, #-8]
10000dd0:	ee073a90 	vmov	s15, r3
} // end of MATH_sat() function
10000dd4:	eeb00a67 	vmov.f32	s0, s15
10000dd8:	e24bd000 	sub	sp, fp, #0
10000ddc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000de0:	e12fff1e 	bx	lr

10000de4 <PID_setFbackValue>:

//! \brief     Sets the feedback value in the PID controller
//! \param[in] handle      The PID controller handle
//! \param[in] fbackValue  The feedback value
static inline void PID_setFbackValue(PID_Handle handle,const float_t fbackValue)//! \Mod By Dl.K
{
10000de4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000de8:	e28db000 	add	fp, sp, #0
10000dec:	e24dd014 	sub	sp, sp, #20
10000df0:	e50b0010 	str	r0, [fp, #-16]
10000df4:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
10000df8:	e51b3010 	ldr	r3, [fp, #-16]
10000dfc:	e50b3008 	str	r3, [fp, #-8]

  obj->fbackValue = fbackValue;
10000e00:	e51b3008 	ldr	r3, [fp, #-8]
10000e04:	e51b2014 	ldr	r2, [fp, #-20]
10000e08:	e5832014 	str	r2, [r3, #20]

  return;
10000e0c:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setFbackValue() function
10000e10:	e24bd000 	sub	sp, fp, #0
10000e14:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000e18:	e12fff1e 	bx	lr

10000e1c <PID_setRefValue>:

//! \brief     Sets the reference value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] refValue   The reference value
static inline void PID_setRefValue(PID_Handle handle,const float_t refValue)//! \Mod By Dl.K
{
10000e1c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000e20:	e28db000 	add	fp, sp, #0
10000e24:	e24dd014 	sub	sp, sp, #20
10000e28:	e50b0010 	str	r0, [fp, #-16]
10000e2c:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
10000e30:	e51b3010 	ldr	r3, [fp, #-16]
10000e34:	e50b3008 	str	r3, [fp, #-8]

  obj->refValue = refValue;
10000e38:	e51b3008 	ldr	r3, [fp, #-8]
10000e3c:	e51b2014 	ldr	r2, [fp, #-20]
10000e40:	e5832010 	str	r2, [r3, #16]

  return;
10000e44:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setRefValue() function
10000e48:	e24bd000 	sub	sp, fp, #0
10000e4c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000e50:	e12fff1e 	bx	lr

10000e54 <PID_setUi>:

//! \brief     Sets the integrator start value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ui         The integral start value for the PID controller
static inline void PID_setUi(PID_Handle handle,const float_t Ui)//! \Mod By Dl.K
{
10000e54:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000e58:	e28db000 	add	fp, sp, #0
10000e5c:	e24dd014 	sub	sp, sp, #20
10000e60:	e50b0010 	str	r0, [fp, #-16]
10000e64:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
10000e68:	e51b3010 	ldr	r3, [fp, #-16]
10000e6c:	e50b3008 	str	r3, [fp, #-8]

  obj->Ui = Ui;
10000e70:	e51b3008 	ldr	r3, [fp, #-8]
10000e74:	e51b2014 	ldr	r2, [fp, #-20]
10000e78:	e583200c 	str	r2, [r3, #12]

  return;
10000e7c:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setUi() function
10000e80:	e24bd000 	sub	sp, fp, #0
10000e84:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000e88:	e12fff1e 	bx	lr

10000e8c <RMP_CNTL_InitPara>:

	return (obj->SetpointValue);
}

static inline void RMP_CNTL_InitPara(RMPCNTL_Handle handle)//! \Mod By Dl.K
{
10000e8c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000e90:	e28db000 	add	fp, sp, #0
10000e94:	e24dd014 	sub	sp, sp, #20
10000e98:	e50b0010 	str	r0, [fp, #-16]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
10000e9c:	e51b3010 	ldr	r3, [fp, #-16]
10000ea0:	e50b3008 	str	r3, [fp, #-8]

	obj->RampDelayCount = 0;
10000ea4:	e51b3008 	ldr	r3, [fp, #-8]
10000ea8:	e3a02000 	mov	r2, #0
10000eac:	e5832010 	str	r2, [r3, #16]
	obj->SetpointValue = (0.0f);
10000eb0:	e51b3008 	ldr	r3, [fp, #-8]
10000eb4:	e3a02000 	mov	r2, #0
10000eb8:	e5832014 	str	r2, [r3, #20]
	obj->EqualFlag = 0;
10000ebc:	e51b3008 	ldr	r3, [fp, #-8]
10000ec0:	e3a02000 	mov	r2, #0
10000ec4:	e5832018 	str	r2, [r3, #24]
	
	return ;
10000ec8:	e1a00000 	nop			; (mov r0, r0)
}
10000ecc:	e24bd000 	sub	sp, fp, #0
10000ed0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000ed4:	e12fff1e 	bx	lr

10000ed8 <DATA_RXD_Status>:
	
	return;
}

static inline uint8_t DATA_RXD_Status(DATA_RTXD_Handle handle)
{
10000ed8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000edc:	e28db000 	add	fp, sp, #0
10000ee0:	e24dd014 	sub	sp, sp, #20
10000ee4:	e50b0010 	str	r0, [fp, #-16]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
10000ee8:	e51b3010 	ldr	r3, [fp, #-16]
10000eec:	e50b3008 	str	r3, [fp, #-8]

	if( obj->data_rxd_num == DATA_RXD_SIZE )
10000ef0:	e51b3008 	ldr	r3, [fp, #-8]
10000ef4:	e5d33000 	ldrb	r3, [r3]
10000ef8:	e353000d 	cmp	r3, #13
10000efc:	1a000001 	bne	10000f08 <DATA_RXD_Status+0x30>
	{
		return false;
10000f00:	e3a03000 	mov	r3, #0
10000f04:	ea000000 	b	10000f0c <DATA_RXD_Status+0x34>
	}
	else return true;
10000f08:	e3a03001 	mov	r3, #1
}
10000f0c:	e1a00003 	mov	r0, r3
10000f10:	e24bd000 	sub	sp, fp, #0
10000f14:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000f18:	e12fff1e 	bx	lr

10000f1c <DATA_RXD_Run>:
	}
	else return true;
}

static inline void DATA_RXD_Run(DATA_RTXD_Handle handle, uint8_t value)
{
10000f1c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000f20:	e28db000 	add	fp, sp, #0
10000f24:	e24dd014 	sub	sp, sp, #20
10000f28:	e50b0010 	str	r0, [fp, #-16]
10000f2c:	e1a03001 	mov	r3, r1
10000f30:	e54b3011 	strb	r3, [fp, #-17]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
10000f34:	e51b3010 	ldr	r3, [fp, #-16]
10000f38:	e50b3008 	str	r3, [fp, #-8]

	if( obj->data_rxd_num < DATA_RXD_SIZE )
10000f3c:	e51b3008 	ldr	r3, [fp, #-8]
10000f40:	e5d33000 	ldrb	r3, [r3]
10000f44:	e353000c 	cmp	r3, #12
10000f48:	8a00000c 	bhi	10000f80 <DATA_RXD_Run+0x64>
	{
		obj->data_rxd[obj->data_rxd_num] =  value;
10000f4c:	e51b3008 	ldr	r3, [fp, #-8]
10000f50:	e5d33000 	ldrb	r3, [r3]
10000f54:	e1a02003 	mov	r2, r3
10000f58:	e51b3008 	ldr	r3, [fp, #-8]
10000f5c:	e0833002 	add	r3, r3, r2
10000f60:	e55b2011 	ldrb	r2, [fp, #-17]
10000f64:	e5c32001 	strb	r2, [r3, #1]
		obj->data_rxd_num++;
10000f68:	e51b3008 	ldr	r3, [fp, #-8]
10000f6c:	e5d33000 	ldrb	r3, [r3]
10000f70:	e2833001 	add	r3, r3, #1
10000f74:	e6ef2073 	uxtb	r2, r3
10000f78:	e51b3008 	ldr	r3, [fp, #-8]
10000f7c:	e5c32000 	strb	r2, [r3]
	}
	//else obj->data_rxd_num = 0;
	return;
10000f80:	e1a00000 	nop			; (mov r0, r0)
}
10000f84:	e24bd000 	sub	sp, fp, #0
10000f88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000f8c:	e12fff1e 	bx	lr

10000f90 <HAL_writePwmData>:

ERIC:  
*/

static inline void HAL_writePwmData(HAL_Handle handle,HAL_PwmData_t *pPwmData)
{
10000f90:	e92d4800 	push	{fp, lr}
10000f94:	e28db004 	add	fp, sp, #4
10000f98:	e24dd018 	sub	sp, sp, #24
10000f9c:	e50b0018 	str	r0, [fp, #-24]
10000fa0:	e50b101c 	str	r1, [fp, #-28]
  uint_least8_t cnt;
  float_t pwmData_neg;
  float_t pwmData_sat;
  float_t pwmData_sat_dc;

  for(cnt=0;cnt<3;cnt++)
10000fa4:	e3a03000 	mov	r3, #0
10000fa8:	e54b3005 	strb	r3, [fp, #-5]
10000fac:	ea000019 	b	10001018 <HAL_writePwmData+0x88>
	{
	  pwmData_neg = (pPwmData->Tabc.value[cnt]*(1.0f));//! \Attention : Dl.K
10000fb0:	e55b3005 	ldrb	r3, [fp, #-5]
10000fb4:	e51b201c 	ldr	r2, [fp, #-28]
10000fb8:	e1a03103 	lsl	r3, r3, #2
10000fbc:	e0823003 	add	r3, r2, r3
10000fc0:	e5933000 	ldr	r3, [r3]
10000fc4:	e50b300c 	str	r3, [fp, #-12]
	  pwmData_sat = MATH_sat(pwmData_neg,(1.0f),(-1.0f));
10000fc8:	ed1b0a03 	vldr	s0, [fp, #-12]
10000fcc:	eef70a00 	vmov.f32	s1, #112	; 0x70
10000fd0:	eebf1a00 	vmov.f32	s2, #240	; 0xf0
10000fd4:	ebffff65 	bl	10000d70 <MATH_sat>
10000fd8:	ed0b0a04 	vstr	s0, [fp, #-16]
	  pwmData_sat_dc = ( (pwmData_sat + (1.0f)) * (0.5f) );
10000fdc:	ed5b7a04 	vldr	s15, [fp, #-16]
10000fe0:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10000fe4:	ee777a87 	vadd.f32	s15, s15, s14
10000fe8:	eeb67a00 	vmov.f32	s14, #96	; 0x60
10000fec:	ee677a87 	vmul.f32	s15, s15, s14
10000ff0:	ed4b7a05 	vstr	s15, [fp, #-20]	; 0xffffffec
		pPwmData->Tabc.value[cnt] = pwmData_sat_dc;
10000ff4:	e55b3005 	ldrb	r3, [fp, #-5]
10000ff8:	e51b201c 	ldr	r2, [fp, #-28]
10000ffc:	e1a03103 	lsl	r3, r3, #2
10001000:	e0823003 	add	r3, r2, r3
10001004:	e51b2014 	ldr	r2, [fp, #-20]
10001008:	e5832000 	str	r2, [r3]
  uint_least8_t cnt;
  float_t pwmData_neg;
  float_t pwmData_sat;
  float_t pwmData_sat_dc;

  for(cnt=0;cnt<3;cnt++)
1000100c:	e55b3005 	ldrb	r3, [fp, #-5]
10001010:	e2833001 	add	r3, r3, #1
10001014:	e54b3005 	strb	r3, [fp, #-5]
10001018:	e55b3005 	ldrb	r3, [fp, #-5]
1000101c:	e3530002 	cmp	r3, #2
10001020:	9affffe2 	bls	10000fb0 <HAL_writePwmData+0x20>
	  pwmData_sat = MATH_sat(pwmData_neg,(1.0f),(-1.0f));
	  pwmData_sat_dc = ( (pwmData_sat + (1.0f)) * (0.5f) );
		pPwmData->Tabc.value[cnt] = pwmData_sat_dc;
	}

  return;
10001024:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_writePwmData() function
10001028:	e24bd004 	sub	sp, fp, #4
1000102c:	e8bd8800 	pop	{fp, pc}

10001030 <CTRL_getState>:

//! \brief     Gets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \return    The controller state
static inline CTRL_State_e CTRL_getState(CTRL_Handle handle)//! \Mod By Dl.K
{
10001030:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001034:	e28db000 	add	fp, sp, #0
10001038:	e24dd014 	sub	sp, sp, #20
1000103c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10001040:	e51b3010 	ldr	r3, [fp, #-16]
10001044:	e50b3008 	str	r3, [fp, #-8]

  return(obj->state);
10001048:	e51b3008 	ldr	r3, [fp, #-8]
1000104c:	e5d33008 	ldrb	r3, [r3, #8]
} // end of CTRL_getState() function
10001050:	e1a00003 	mov	r0, r3
10001054:	e24bd000 	sub	sp, fp, #0
10001058:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000105c:	e12fff1e 	bx	lr

10001060 <CTRL_isError>:

//! \brief     Determines if there is a controller error
//! \param[in] handle  The controller (CTRL) handle
//! \return    A boolean value denoting if there is a controller error (true) or not (false)
static inline bool CTRL_isError(CTRL_Handle handle)//! \Mod By Dl.K
{
10001060:	e92d4800 	push	{fp, lr}
10001064:	e28db004 	add	fp, sp, #4
10001068:	e24dd010 	sub	sp, sp, #16
1000106c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_State_e ctrlState = CTRL_getState(handle);
10001070:	e51b0010 	ldr	r0, [fp, #-16]
10001074:	ebffffed 	bl	10001030 <CTRL_getState>
10001078:	e1a03000 	mov	r3, r0
1000107c:	e54b3006 	strb	r3, [fp, #-6]
  bool state = false;
10001080:	e3a03000 	mov	r3, #0
10001084:	e54b3005 	strb	r3, [fp, #-5]


  // check for controller errors
  if(ctrlState == CTRL_State_Error)
10001088:	e55b3006 	ldrb	r3, [fp, #-6]
1000108c:	e3530000 	cmp	r3, #0
10001090:	1a000001 	bne	1000109c <CTRL_isError+0x3c>
    {
      state = true;
10001094:	e3a03001 	mov	r3, #1
10001098:	e54b3005 	strb	r3, [fp, #-5]
    }

  return(state);
1000109c:	e55b3005 	ldrb	r3, [fp, #-5]
} // end of CTRL_isError() function
100010a0:	e1a00003 	mov	r0, r3
100010a4:	e24bd004 	sub	sp, fp, #4
100010a8:	e8bd8800 	pop	{fp, pc}

100010ac <CTRL_setFlag_enableCtrl>:
//!             motor commissioning is performed and then subsequent times it is called the
//!             motor starts to run.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
100010ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100010b0:	e28db000 	add	fp, sp, #0
100010b4:	e24dd014 	sub	sp, sp, #20
100010b8:	e50b0010 	str	r0, [fp, #-16]
100010bc:	e1a03001 	mov	r3, r1
100010c0:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100010c4:	e51b3010 	ldr	r3, [fp, #-16]
100010c8:	e50b3008 	str	r3, [fp, #-8]

  obj->flag_enableCtrl = state;
100010cc:	e51b3008 	ldr	r3, [fp, #-8]
100010d0:	e55b2011 	ldrb	r2, [fp, #-17]
100010d4:	e5c321f4 	strb	r2, [r3, #500]	; 0x1f4

  return;
100010d8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setFlag_enableCtrl() function
100010dc:	e24bd000 	sub	sp, fp, #0
100010e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100010e4:	e12fff1e 	bx	lr

100010e8 <Motor_Ctrl_Init>:
CTRL_Obj gCtrl;
CTRL_Handle gCtrlHandle;


void Motor_Ctrl_Init(void)
{
100010e8:	e92d4800 	push	{fp, lr}
100010ec:	e28db004 	add	fp, sp, #4
	gHalHandle = HAL_init(&gHal, sizeof(gHal));
100010f0:	e30f0ca0 	movw	r0, #64672	; 0xfca0
100010f4:	e3410003 	movt	r0, #4099	; 0x1003
100010f8:	e3a01f42 	mov	r1, #264	; 0x108
100010fc:	eb0018b2 	bl	100073cc <HAL_init>
10001100:	e1a02000 	mov	r2, r0
10001104:	e30f395c 	movw	r3, #63836	; 0xf95c
10001108:	e3413003 	movt	r3, #4099	; 0x1003
1000110c:	e5832000 	str	r2, [r3]
	
	gCtrlHandle = CTRL_init(&gCtrl, sizeof(gCtrl));
10001110:	e30f0960 	movw	r0, #63840	; 0xf960
10001114:	e3410003 	movt	r0, #4099	; 0x1003
10001118:	e3a01d0d 	mov	r1, #832	; 0x340
1000111c:	eb0011cb 	bl	10005850 <CTRL_init>
10001120:	e1a02000 	mov	r2, r0
10001124:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001128:	e3413003 	movt	r3, #4099	; 0x1003
1000112c:	e5832000 	str	r2, [r3]
	
	USER_setParams(&gUserParams);
10001130:	e30f0dac 	movw	r0, #64940	; 0xfdac
10001134:	e3410003 	movt	r0, #4099	; 0x1003
10001138:	eb001aee 	bl	10007cf8 <USER_setParams>
	
	HAL_setParams(gHalHandle, &gUserParams);
1000113c:	e30f395c 	movw	r3, #63836	; 0xf95c
10001140:	e3413003 	movt	r3, #4099	; 0x1003
10001144:	e5933000 	ldr	r3, [r3]
10001148:	e1a00003 	mov	r0, r3
1000114c:	e30f1dac 	movw	r1, #64940	; 0xfdac
10001150:	e3411003 	movt	r1, #4099	; 0x1003
10001154:	eb0018dc 	bl	100074cc <HAL_setParams>
	
	CTRL_setParams(gCtrlHandle, &gUserParams);
10001158:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000115c:	e3413003 	movt	r3, #4099	; 0x1003
10001160:	e5933000 	ldr	r3, [r3]
10001164:	e1a00003 	mov	r0, r3
10001168:	e30f1dac 	movw	r1, #64940	; 0xfdac
1000116c:	e3411003 	movt	r1, #4099	; 0x1003
10001170:	eb001248 	bl	10005a98 <CTRL_setParams>
}
10001174:	e8bd8800 	pop	{fp, pc}

10001178 <Motor_Ctrl_State>:


uint8_t Motor_Ctrl_State(int8_t *cha_pt, int8_t *flag_pt)
{
10001178:	e92d4800 	push	{fp, lr}
1000117c:	e28db004 	add	fp, sp, #4
10001180:	e24dd010 	sub	sp, sp, #16
10001184:	e50b0010 	str	r0, [fp, #-16]
10001188:	e50b1014 	str	r1, [fp, #-20]
//			if(value!=0x00 || value!=0xF0)
//			{
//				gCtrlHandle->data_rtxd_handle->data_rxd[i] = value;
//			}
//		}
		if(DATA_RXD_Status(gCtrlHandle->data_rtxd_handle)&&*flag_pt==1)
1000118c:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001190:	e3413003 	movt	r3, #4099	; 0x1003
10001194:	e5933000 	ldr	r3, [r3]
10001198:	e5933260 	ldr	r3, [r3, #608]	; 0x260
1000119c:	e1a00003 	mov	r0, r3
100011a0:	ebffff4c 	bl	10000ed8 <DATA_RXD_Status>
100011a4:	e1a03000 	mov	r3, r0
100011a8:	e3530000 	cmp	r3, #0
100011ac:	0a00001f 	beq	10001230 <Motor_Ctrl_State+0xb8>
100011b0:	e51b3014 	ldr	r3, [fp, #-20]
100011b4:	e5d33000 	ldrb	r3, [r3]
100011b8:	e6af3073 	sxtb	r3, r3
100011bc:	e3530001 	cmp	r3, #1
100011c0:	1a00001a 	bne	10001230 <Motor_Ctrl_State+0xb8>
		{
			int8_t i;
			for(i=0;i<DATA_RXD_SIZE;i++)
100011c4:	e3a03000 	mov	r3, #0
100011c8:	e54b3005 	strb	r3, [fp, #-5]
100011cc:	ea000011 	b	10001218 <Motor_Ctrl_State+0xa0>
			{
				DATA_RXD_Run(gCtrlHandle->data_rtxd_handle,*cha_pt);
100011d0:	e30f3da8 	movw	r3, #64936	; 0xfda8
100011d4:	e3413003 	movt	r3, #4099	; 0x1003
100011d8:	e5933000 	ldr	r3, [r3]
100011dc:	e5932260 	ldr	r2, [r3, #608]	; 0x260
100011e0:	e51b3010 	ldr	r3, [fp, #-16]
100011e4:	e5d33000 	ldrb	r3, [r3]
100011e8:	e6ef3073 	uxtb	r3, r3
100011ec:	e1a00002 	mov	r0, r2
100011f0:	e1a01003 	mov	r1, r3
100011f4:	ebffff48 	bl	10000f1c <DATA_RXD_Run>
				cha_pt++;
100011f8:	e51b3010 	ldr	r3, [fp, #-16]
100011fc:	e2833001 	add	r3, r3, #1
10001200:	e50b3010 	str	r3, [fp, #-16]
//			}
//		}
		if(DATA_RXD_Status(gCtrlHandle->data_rtxd_handle)&&*flag_pt==1)
		{
			int8_t i;
			for(i=0;i<DATA_RXD_SIZE;i++)
10001204:	e55b3005 	ldrb	r3, [fp, #-5]
10001208:	e6ef3073 	uxtb	r3, r3
1000120c:	e2833001 	add	r3, r3, #1
10001210:	e6ef3073 	uxtb	r3, r3
10001214:	e54b3005 	strb	r3, [fp, #-5]
10001218:	e15b30d5 	ldrsb	r3, [fp, #-5]
1000121c:	e353000c 	cmp	r3, #12
10001220:	daffffea 	ble	100011d0 <Motor_Ctrl_State+0x58>
			{
				DATA_RXD_Run(gCtrlHandle->data_rtxd_handle,*cha_pt);
				cha_pt++;
			}
			*flag_pt=0;
10001224:	e51b3014 	ldr	r3, [fp, #-20]
10001228:	e3a02000 	mov	r2, #0
1000122c:	e5c32000 	strb	r2, [r3]
		}

		if(CTRL_isError(gCtrlHandle))
10001230:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001234:	e3413003 	movt	r3, #4099	; 0x1003
10001238:	e5933000 	ldr	r3, [r3]
1000123c:	e1a00003 	mov	r0, r3
10001240:	ebffff86 	bl	10001060 <CTRL_isError>
10001244:	e1a03000 	mov	r3, r0
10001248:	e3530000 	cmp	r3, #0
1000124c:	0a00000a 	beq	1000127c <Motor_Ctrl_State+0x104>
		  {
			// set the enable controller flag to false
			CTRL_setFlag_enableCtrl(gCtrlHandle,false);
10001250:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001254:	e3413003 	movt	r3, #4099	; 0x1003
10001258:	e5933000 	ldr	r3, [r3]
1000125c:	e1a00003 	mov	r0, r3
10001260:	e3a01000 	mov	r1, #0
10001264:	ebffff90 	bl	100010ac <CTRL_setFlag_enableCtrl>
			rt_kprintf("ctrl is error\r\n");
10001268:	e3020790 	movw	r0, #10128	; 0x2790
1000126c:	e3410003 	movt	r0, #4099	; 0x1003
10001270:	eb004a12 	bl	10013ac0 <rt_kprintf>
			// disable the PWM
				return false;
10001274:	e3a03000 	mov	r3, #0
10001278:	ea000111 	b	100016c4 <Motor_Ctrl_State+0x54c>
		  }
		else
		  {
			CTRL_State_e ctrlState = CTRL_getState(gCtrlHandle);
1000127c:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001280:	e3413003 	movt	r3, #4099	; 0x1003
10001284:	e5933000 	ldr	r3, [r3]
10001288:	e1a00003 	mov	r0, r3
1000128c:	ebffff67 	bl	10001030 <CTRL_getState>
10001290:	e1a03000 	mov	r3, r0
10001294:	e54b3006 	strb	r3, [fp, #-6]
			CTRL_State_e ctrlprevState = gCtrlHandle->prevState;
10001298:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000129c:	e3413003 	movt	r3, #4099	; 0x1003
100012a0:	e5933000 	ldr	r3, [r3]
100012a4:	e5d33009 	ldrb	r3, [r3, #9]
100012a8:	e54b3007 	strb	r3, [fp, #-7]
			if(ctrlState == CTRL_State_Idle)
100012ac:	e55b3006 	ldrb	r3, [fp, #-6]
100012b0:	e3530001 	cmp	r3, #1
100012b4:	1a000084 	bne	100014cc <Motor_Ctrl_State+0x354>
			{
				// disable the PWM
				if( ctrlprevState == CTRL_State_OpenLoop )
100012b8:	e55b3007 	ldrb	r3, [fp, #-7]
100012bc:	e3530006 	cmp	r3, #6
100012c0:	1a000009 	bne	100012ec <Motor_Ctrl_State+0x174>
				{
					
					rt_kprintf("CTRL_State_OpenLoop\r\n");
100012c4:	e30207a0 	movw	r0, #10144	; 0x27a0
100012c8:	e3410003 	movt	r0, #4099	; 0x1003
100012cc:	eb0049fb 	bl	10013ac0 <rt_kprintf>
					RMP_CNTL_InitPara( gCtrlHandle->rmpcntl_handle );
100012d0:	e30f3da8 	movw	r3, #64936	; 0xfda8
100012d4:	e3413003 	movt	r3, #4099	; 0x1003
100012d8:	e5933000 	ldr	r3, [r3]
100012dc:	e5933224 	ldr	r3, [r3, #548]	; 0x224
100012e0:	e1a00003 	mov	r0, r3
100012e4:	ebfffee8 	bl	10000e8c <RMP_CNTL_InitPara>
100012e8:	ea000075 	b	100014c4 <Motor_Ctrl_State+0x34c>
				}
				else if( ctrlprevState == CTRL_State_CurrentCloseLoop )
100012ec:	e55b3007 	ldrb	r3, [fp, #-7]
100012f0:	e3530008 	cmp	r3, #8
100012f4:	1a00002d 	bne	100013b0 <Motor_Ctrl_State+0x238>
				{
					rt_kprintf("CTRL_State_CurrentCloseLoop\r\n");
100012f8:	e30207b8 	movw	r0, #10168	; 0x27b8
100012fc:	e3410003 	movt	r0, #4099	; 0x1003
10001300:	eb0049ee 	bl	10013ac0 <rt_kprintf>
					PID_setUi(gCtrlHandle->pidHandle_Id,(0.0f));
10001304:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001308:	e3413003 	movt	r3, #4099	; 0x1003
1000130c:	e5933000 	ldr	r3, [r3]
10001310:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001314:	e1a00003 	mov	r0, r3
10001318:	ed9f0aec 	vldr	s0, [pc, #944]	; 100016d0 <Motor_Ctrl_State+0x558>
1000131c:	ebfffecc 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Id,(0.0f));
10001320:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001324:	e3413003 	movt	r3, #4099	; 0x1003
10001328:	e5933000 	ldr	r3, [r3]
1000132c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001330:	e1a00003 	mov	r0, r3
10001334:	ed9f0ae5 	vldr	s0, [pc, #916]	; 100016d0 <Motor_Ctrl_State+0x558>
10001338:	ebfffeb7 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Id,(0.0f));
1000133c:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001340:	e3413003 	movt	r3, #4099	; 0x1003
10001344:	e5933000 	ldr	r3, [r3]
10001348:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000134c:	e1a00003 	mov	r0, r3
10001350:	ed9f0ade 	vldr	s0, [pc, #888]	; 100016d0 <Motor_Ctrl_State+0x558>
10001354:	ebfffea2 	bl	10000de4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Iq,(0.0f));
10001358:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000135c:	e3413003 	movt	r3, #4099	; 0x1003
10001360:	e5933000 	ldr	r3, [r3]
10001364:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10001368:	e1a00003 	mov	r0, r3
1000136c:	ed9f0ad7 	vldr	s0, [pc, #860]	; 100016d0 <Motor_Ctrl_State+0x558>
10001370:	ebfffeb7 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Iq,(0.0f));
10001374:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001378:	e3413003 	movt	r3, #4099	; 0x1003
1000137c:	e5933000 	ldr	r3, [r3]
10001380:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10001384:	e1a00003 	mov	r0, r3
10001388:	ed9f0ad0 	vldr	s0, [pc, #832]	; 100016d0 <Motor_Ctrl_State+0x558>
1000138c:	ebfffea2 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Iq,(0.0f));
10001390:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001394:	e3413003 	movt	r3, #4099	; 0x1003
10001398:	e5933000 	ldr	r3, [r3]
1000139c:	e5933060 	ldr	r3, [r3, #96]	; 0x60
100013a0:	e1a00003 	mov	r0, r3
100013a4:	ed9f0ac9 	vldr	s0, [pc, #804]	; 100016d0 <Motor_Ctrl_State+0x558>
100013a8:	ebfffe8d 	bl	10000de4 <PID_setFbackValue>
100013ac:	ea000044 	b	100014c4 <Motor_Ctrl_State+0x34c>
				}
				else if( ctrlprevState == CTRL_State_SpeedCloseLoop )
100013b0:	e55b3007 	ldrb	r3, [fp, #-7]
100013b4:	e3530009 	cmp	r3, #9
100013b8:	1a000041 	bne	100014c4 <Motor_Ctrl_State+0x34c>
				{
					rt_kprintf("CTRL_State_SpeedCloseLoop\r\n");
100013bc:	e30207d8 	movw	r0, #10200	; 0x27d8
100013c0:	e3410003 	movt	r0, #4099	; 0x1003
100013c4:	eb0049bd 	bl	10013ac0 <rt_kprintf>
					PID_setUi(gCtrlHandle->pidHandle_spd,(0.0f));
100013c8:	e30f3da8 	movw	r3, #64936	; 0xfda8
100013cc:	e3413003 	movt	r3, #4099	; 0x1003
100013d0:	e5933000 	ldr	r3, [r3]
100013d4:	e5933084 	ldr	r3, [r3, #132]	; 0x84
100013d8:	e1a00003 	mov	r0, r3
100013dc:	ed9f0abb 	vldr	s0, [pc, #748]	; 100016d0 <Motor_Ctrl_State+0x558>
100013e0:	ebfffe9b 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_spd,(0.0f));
100013e4:	e30f3da8 	movw	r3, #64936	; 0xfda8
100013e8:	e3413003 	movt	r3, #4099	; 0x1003
100013ec:	e5933000 	ldr	r3, [r3]
100013f0:	e5933084 	ldr	r3, [r3, #132]	; 0x84
100013f4:	e1a00003 	mov	r0, r3
100013f8:	ed9f0ab4 	vldr	s0, [pc, #720]	; 100016d0 <Motor_Ctrl_State+0x558>
100013fc:	ebfffe86 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_spd,(0.0f));
10001400:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001404:	e3413003 	movt	r3, #4099	; 0x1003
10001408:	e5933000 	ldr	r3, [r3]
1000140c:	e5933084 	ldr	r3, [r3, #132]	; 0x84
10001410:	e1a00003 	mov	r0, r3
10001414:	ed9f0aad 	vldr	s0, [pc, #692]	; 100016d0 <Motor_Ctrl_State+0x558>
10001418:	ebfffe71 	bl	10000de4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Id,(0.0f));
1000141c:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001420:	e3413003 	movt	r3, #4099	; 0x1003
10001424:	e5933000 	ldr	r3, [r3]
10001428:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000142c:	e1a00003 	mov	r0, r3
10001430:	ed9f0aa6 	vldr	s0, [pc, #664]	; 100016d0 <Motor_Ctrl_State+0x558>
10001434:	ebfffe86 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Id,(0.0f));
10001438:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000143c:	e3413003 	movt	r3, #4099	; 0x1003
10001440:	e5933000 	ldr	r3, [r3]
10001444:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001448:	e1a00003 	mov	r0, r3
1000144c:	ed9f0a9f 	vldr	s0, [pc, #636]	; 100016d0 <Motor_Ctrl_State+0x558>
10001450:	ebfffe71 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Id,(0.0f));
10001454:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001458:	e3413003 	movt	r3, #4099	; 0x1003
1000145c:	e5933000 	ldr	r3, [r3]
10001460:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001464:	e1a00003 	mov	r0, r3
10001468:	ed9f0a98 	vldr	s0, [pc, #608]	; 100016d0 <Motor_Ctrl_State+0x558>
1000146c:	ebfffe5c 	bl	10000de4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Iq,(0.0f));
10001470:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001474:	e3413003 	movt	r3, #4099	; 0x1003
10001478:	e5933000 	ldr	r3, [r3]
1000147c:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10001480:	e1a00003 	mov	r0, r3
10001484:	ed9f0a91 	vldr	s0, [pc, #580]	; 100016d0 <Motor_Ctrl_State+0x558>
10001488:	ebfffe71 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Iq,(0.0f));
1000148c:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001490:	e3413003 	movt	r3, #4099	; 0x1003
10001494:	e5933000 	ldr	r3, [r3]
10001498:	e5933060 	ldr	r3, [r3, #96]	; 0x60
1000149c:	e1a00003 	mov	r0, r3
100014a0:	ed9f0a8a 	vldr	s0, [pc, #552]	; 100016d0 <Motor_Ctrl_State+0x558>
100014a4:	ebfffe5c 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Iq,(0.0f));
100014a8:	e30f3da8 	movw	r3, #64936	; 0xfda8
100014ac:	e3413003 	movt	r3, #4099	; 0x1003
100014b0:	e5933000 	ldr	r3, [r3]
100014b4:	e5933060 	ldr	r3, [r3, #96]	; 0x60
100014b8:	e1a00003 	mov	r0, r3
100014bc:	ed9f0a83 	vldr	s0, [pc, #524]	; 100016d0 <Motor_Ctrl_State+0x558>
100014c0:	ebfffe47 	bl	10000de4 <PID_setFbackValue>
				}
				return false;
100014c4:	e3a03000 	mov	r3, #0
100014c8:	ea00007d 	b	100016c4 <Motor_Ctrl_State+0x54c>
			}
			else if(ctrlState == CTRL_State_OffLine)
100014cc:	e55b3006 	ldrb	r3, [fp, #-6]
100014d0:	e3530002 	cmp	r3, #2
100014d4:	1a000079 	bne	100016c0 <Motor_Ctrl_State+0x548>
			{
				// enable the PWM
				if( ctrlprevState == CTRL_State_OpenLoop )
100014d8:	e55b3007 	ldrb	r3, [fp, #-7]
100014dc:	e3530006 	cmp	r3, #6
100014e0:	1a000006 	bne	10001500 <Motor_Ctrl_State+0x388>
				{
					RMP_CNTL_InitPara( gCtrlHandle->rmpcntl_handle );
100014e4:	e30f3da8 	movw	r3, #64936	; 0xfda8
100014e8:	e3413003 	movt	r3, #4099	; 0x1003
100014ec:	e5933000 	ldr	r3, [r3]
100014f0:	e5933224 	ldr	r3, [r3, #548]	; 0x224
100014f4:	e1a00003 	mov	r0, r3
100014f8:	ebfffe63 	bl	10000e8c <RMP_CNTL_InitPara>
100014fc:	ea00006f 	b	100016c0 <Motor_Ctrl_State+0x548>
				}
				else if( ctrlprevState == CTRL_State_CurrentCloseLoop )
10001500:	e55b3007 	ldrb	r3, [fp, #-7]
10001504:	e3530008 	cmp	r3, #8
10001508:	1a00002a 	bne	100015b8 <Motor_Ctrl_State+0x440>
				{
					PID_setUi(gCtrlHandle->pidHandle_Id,(0.0f));
1000150c:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001510:	e3413003 	movt	r3, #4099	; 0x1003
10001514:	e5933000 	ldr	r3, [r3]
10001518:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000151c:	e1a00003 	mov	r0, r3
10001520:	ed9f0a6a 	vldr	s0, [pc, #424]	; 100016d0 <Motor_Ctrl_State+0x558>
10001524:	ebfffe4a 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Id,(0.0f));
10001528:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000152c:	e3413003 	movt	r3, #4099	; 0x1003
10001530:	e5933000 	ldr	r3, [r3]
10001534:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001538:	e1a00003 	mov	r0, r3
1000153c:	ed9f0a63 	vldr	s0, [pc, #396]	; 100016d0 <Motor_Ctrl_State+0x558>
10001540:	ebfffe35 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Id,(0.0f));
10001544:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001548:	e3413003 	movt	r3, #4099	; 0x1003
1000154c:	e5933000 	ldr	r3, [r3]
10001550:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001554:	e1a00003 	mov	r0, r3
10001558:	ed9f0a5c 	vldr	s0, [pc, #368]	; 100016d0 <Motor_Ctrl_State+0x558>
1000155c:	ebfffe20 	bl	10000de4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Iq,(0.0f));
10001560:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001564:	e3413003 	movt	r3, #4099	; 0x1003
10001568:	e5933000 	ldr	r3, [r3]
1000156c:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10001570:	e1a00003 	mov	r0, r3
10001574:	ed9f0a55 	vldr	s0, [pc, #340]	; 100016d0 <Motor_Ctrl_State+0x558>
10001578:	ebfffe35 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Iq,(0.0f));
1000157c:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001580:	e3413003 	movt	r3, #4099	; 0x1003
10001584:	e5933000 	ldr	r3, [r3]
10001588:	e5933060 	ldr	r3, [r3, #96]	; 0x60
1000158c:	e1a00003 	mov	r0, r3
10001590:	ed9f0a4e 	vldr	s0, [pc, #312]	; 100016d0 <Motor_Ctrl_State+0x558>
10001594:	ebfffe20 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Iq,(0.0f));
10001598:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000159c:	e3413003 	movt	r3, #4099	; 0x1003
100015a0:	e5933000 	ldr	r3, [r3]
100015a4:	e5933060 	ldr	r3, [r3, #96]	; 0x60
100015a8:	e1a00003 	mov	r0, r3
100015ac:	ed9f0a47 	vldr	s0, [pc, #284]	; 100016d0 <Motor_Ctrl_State+0x558>
100015b0:	ebfffe0b 	bl	10000de4 <PID_setFbackValue>
100015b4:	ea000041 	b	100016c0 <Motor_Ctrl_State+0x548>
				}
				else if( ctrlprevState == CTRL_State_SpeedCloseLoop )
100015b8:	e55b3007 	ldrb	r3, [fp, #-7]
100015bc:	e3530009 	cmp	r3, #9
100015c0:	1a00003e 	bne	100016c0 <Motor_Ctrl_State+0x548>
				{
					PID_setUi(gCtrlHandle->pidHandle_spd,(0.0f));
100015c4:	e30f3da8 	movw	r3, #64936	; 0xfda8
100015c8:	e3413003 	movt	r3, #4099	; 0x1003
100015cc:	e5933000 	ldr	r3, [r3]
100015d0:	e5933084 	ldr	r3, [r3, #132]	; 0x84
100015d4:	e1a00003 	mov	r0, r3
100015d8:	ed9f0a3c 	vldr	s0, [pc, #240]	; 100016d0 <Motor_Ctrl_State+0x558>
100015dc:	ebfffe1c 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_spd,(0.0f));
100015e0:	e30f3da8 	movw	r3, #64936	; 0xfda8
100015e4:	e3413003 	movt	r3, #4099	; 0x1003
100015e8:	e5933000 	ldr	r3, [r3]
100015ec:	e5933084 	ldr	r3, [r3, #132]	; 0x84
100015f0:	e1a00003 	mov	r0, r3
100015f4:	ed9f0a35 	vldr	s0, [pc, #212]	; 100016d0 <Motor_Ctrl_State+0x558>
100015f8:	ebfffe07 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_spd,(0.0f));
100015fc:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001600:	e3413003 	movt	r3, #4099	; 0x1003
10001604:	e5933000 	ldr	r3, [r3]
10001608:	e5933084 	ldr	r3, [r3, #132]	; 0x84
1000160c:	e1a00003 	mov	r0, r3
10001610:	ed9f0a2e 	vldr	s0, [pc, #184]	; 100016d0 <Motor_Ctrl_State+0x558>
10001614:	ebfffdf2 	bl	10000de4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Id,(0.0f));
10001618:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000161c:	e3413003 	movt	r3, #4099	; 0x1003
10001620:	e5933000 	ldr	r3, [r3]
10001624:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001628:	e1a00003 	mov	r0, r3
1000162c:	ed9f0a27 	vldr	s0, [pc, #156]	; 100016d0 <Motor_Ctrl_State+0x558>
10001630:	ebfffe07 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Id,(0.0f));
10001634:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001638:	e3413003 	movt	r3, #4099	; 0x1003
1000163c:	e5933000 	ldr	r3, [r3]
10001640:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001644:	e1a00003 	mov	r0, r3
10001648:	ed9f0a20 	vldr	s0, [pc, #128]	; 100016d0 <Motor_Ctrl_State+0x558>
1000164c:	ebfffdf2 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Id,(0.0f));
10001650:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001654:	e3413003 	movt	r3, #4099	; 0x1003
10001658:	e5933000 	ldr	r3, [r3]
1000165c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10001660:	e1a00003 	mov	r0, r3
10001664:	ed9f0a19 	vldr	s0, [pc, #100]	; 100016d0 <Motor_Ctrl_State+0x558>
10001668:	ebfffddd 	bl	10000de4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Iq,(0.0f));
1000166c:	e30f3da8 	movw	r3, #64936	; 0xfda8
10001670:	e3413003 	movt	r3, #4099	; 0x1003
10001674:	e5933000 	ldr	r3, [r3]
10001678:	e5933060 	ldr	r3, [r3, #96]	; 0x60
1000167c:	e1a00003 	mov	r0, r3
10001680:	ed9f0a12 	vldr	s0, [pc, #72]	; 100016d0 <Motor_Ctrl_State+0x558>
10001684:	ebfffdf2 	bl	10000e54 <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Iq,(0.0f));
10001688:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000168c:	e3413003 	movt	r3, #4099	; 0x1003
10001690:	e5933000 	ldr	r3, [r3]
10001694:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10001698:	e1a00003 	mov	r0, r3
1000169c:	ed9f0a0b 	vldr	s0, [pc, #44]	; 100016d0 <Motor_Ctrl_State+0x558>
100016a0:	ebfffddd 	bl	10000e1c <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Iq,(0.0f));
100016a4:	e30f3da8 	movw	r3, #64936	; 0xfda8
100016a8:	e3413003 	movt	r3, #4099	; 0x1003
100016ac:	e5933000 	ldr	r3, [r3]
100016b0:	e5933060 	ldr	r3, [r3, #96]	; 0x60
100016b4:	e1a00003 	mov	r0, r3
100016b8:	ed9f0a04 	vldr	s0, [pc, #16]	; 100016d0 <Motor_Ctrl_State+0x558>
100016bc:	ebfffdc8 	bl	10000de4 <PID_setFbackValue>
//				// set the speed acceleration
//				CTRL_setMaxAccel_pu(ctrlHandle,_IQmpy(MAX_ACCEL_KRPMPS_SF,gMotorVars.MaxAccel_krpmps));
			}

		  }
			return true;
100016c0:	e3a03001 	mov	r3, #1
		}
}
100016c4:	e1a00003 	mov	r0, r3
100016c8:	e24bd004 	sub	sp, fp, #4
100016cc:	e8bd8800 	pop	{fp, pc}
100016d0:	00000000 	.word	0x00000000

100016d4 <Motor_Ctrl_Run>:

void Motor_Ctrl_Run(HAL_AdcData_t *pAdcData, HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)
{
100016d4:	e92d4800 	push	{fp, lr}
100016d8:	e28db004 	add	fp, sp, #4
100016dc:	e24dd018 	sub	sp, sp, #24
100016e0:	e50b0008 	str	r0, [fp, #-8]
100016e4:	e50b100c 	str	r1, [fp, #-12]
100016e8:	e50b2010 	str	r2, [fp, #-16]
  //HAL_readAdcData(gHalHandle,pAdcData);
	//HAL_readAdcDataWithOffsets();
  // run the controller
  
#if 1
  CTRL_run(gCtrlHandle,gHalHandle,pAdcData,pPwmData,pQepData);
100016ec:	e30f3da8 	movw	r3, #64936	; 0xfda8
100016f0:	e3413003 	movt	r3, #4099	; 0x1003
100016f4:	e5931000 	ldr	r1, [r3]
100016f8:	e30f395c 	movw	r3, #63836	; 0xf95c
100016fc:	e3413003 	movt	r3, #4099	; 0x1003
10001700:	e5932000 	ldr	r2, [r3]
10001704:	e51b3010 	ldr	r3, [fp, #-16]
10001708:	e58d3000 	str	r3, [sp]
1000170c:	e1a00001 	mov	r0, r1
10001710:	e1a01002 	mov	r1, r2
10001714:	e51b2008 	ldr	r2, [fp, #-8]
10001718:	e51b300c 	ldr	r3, [fp, #-12]
1000171c:	eb000f95 	bl	10005578 <CTRL_run>
//	pPwmData->Tabc.value[0] = -0.1f;
//	pPwmData->Tabc.value[1] = -0.0f;
//	pPwmData->Tabc.value[2] = 0.1f;
  // write the PWM compare values
  
  HAL_writePwmData(gHalHandle,pPwmData);
10001720:	e30f395c 	movw	r3, #63836	; 0xf95c
10001724:	e3413003 	movt	r3, #4099	; 0x1003
10001728:	e5933000 	ldr	r3, [r3]
1000172c:	e1a00003 	mov	r0, r3
10001730:	e51b100c 	ldr	r1, [fp, #-12]
10001734:	ebfffe15 	bl	10000f90 <HAL_writePwmData>
			//myprintf((char*)Get_DATA_TXD_Ptr(gCtrlHandle->data_rtxd_handle), 13);
		}		
	}
	else count_sci++;//! \Mod By Dl.K
	#endif
}
10001738:	e24bd004 	sub	sp, fp, #4
1000173c:	e8bd8800 	pop	{fp, pc}

10001740 <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
10001740:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001744:	e28db000 	add	fp, sp, #0
10001748:	e24dd014 	sub	sp, sp, #20
1000174c:	ed0b0a04 	vstr	s0, [fp, #-16]
  float_t out = in;
10001750:	e51b3010 	ldr	r3, [fp, #-16]
10001754:	e50b3008 	str	r3, [fp, #-8]


  if(in < 0.0f)
10001758:	ed5b7a04 	vldr	s15, [fp, #-16]
1000175c:	eef57ac0 	vcmpe.f32	s15, #0.0
10001760:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10001764:	5a000002 	bpl	10001774 <MATH_abs+0x34>
    {
      out = -in;
10001768:	ed5b7a04 	vldr	s15, [fp, #-16]
1000176c:	eef17a67 	vneg.f32	s15, s15
10001770:	ed4b7a02 	vstr	s15, [fp, #-8]
    }

  return(out);
10001774:	e51b3008 	ldr	r3, [fp, #-8]
10001778:	ee073a90 	vmov	s15, r3
} // end of MATH_abs() function
1000177c:	eeb00a67 	vmov.f32	s0, s15
10001780:	e24bd000 	sub	sp, fp, #0
10001784:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001788:	e12fff1e 	bx	lr

1000178c <Speed_UpdateElecTheta>:

	return;
}

static inline void Speed_UpdateElecTheta(SPEED_Handle handle)//! \Mod By Dl.K
{
1000178c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001790:	e28db000 	add	fp, sp, #0
10001794:	e24dd014 	sub	sp, sp, #20
10001798:	e50b0010 	str	r0, [fp, #-16]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
1000179c:	e51b3010 	ldr	r3, [fp, #-16]
100017a0:	e50b3008 	str	r3, [fp, #-8]

	obj->OldElecTheta = obj->ElecTheta;
100017a4:	e51b3008 	ldr	r3, [fp, #-8]
100017a8:	e5932000 	ldr	r2, [r3]
100017ac:	e51b3008 	ldr	r3, [fp, #-8]
100017b0:	e5832004 	str	r2, [r3, #4]

	return;
100017b4:	e1a00000 	nop			; (mov r0, r0)
}
100017b8:	e24bd000 	sub	sp, fp, #0
100017bc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100017c0:	e12fff1e 	bx	lr

100017c4 <Speed_UpdateTurnCount>:

static inline void Speed_UpdateTurnCount(SPEED_Handle handle)//! \Mod By Dl.K
{
100017c4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100017c8:	e28db000 	add	fp, sp, #0
100017cc:	e24dd014 	sub	sp, sp, #20
100017d0:	e50b0010 	str	r0, [fp, #-16]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
100017d4:	e51b3010 	ldr	r3, [fp, #-16]
100017d8:	e50b3008 	str	r3, [fp, #-8]

	obj->Oldturn_cnt = obj->turn_cnt;
100017dc:	e51b3008 	ldr	r3, [fp, #-8]
100017e0:	e593201c 	ldr	r2, [r3, #28]
100017e4:	e51b3008 	ldr	r3, [fp, #-8]
100017e8:	e5832020 	str	r2, [r3, #32]

	return;
100017ec:	e1a00000 	nop			; (mov r0, r0)
}
100017f0:	e24bd000 	sub	sp, fp, #0
100017f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100017f8:	e12fff1e 	bx	lr

100017fc <Speed_UpdateElecSpeed>:


static inline void Speed_UpdateElecSpeed(SPEED_Handle handle)//! \Mod By Dl.K
{
100017fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001800:	e28db000 	add	fp, sp, #0
10001804:	e24dd014 	sub	sp, sp, #20
10001808:	e50b0010 	str	r0, [fp, #-16]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
1000180c:	e51b3010 	ldr	r3, [fp, #-16]
10001810:	e50b3008 	str	r3, [fp, #-8]

	obj->OldElecSpeed = obj->ElecSpeed;
10001814:	e51b3008 	ldr	r3, [fp, #-8]
10001818:	e593200c 	ldr	r2, [r3, #12]
1000181c:	e51b3008 	ldr	r3, [fp, #-8]
10001820:	e5832010 	str	r2, [r3, #16]

	return;
10001824:	e1a00000 	nop			; (mov r0, r0)
}
10001828:	e24bd000 	sub	sp, fp, #0
1000182c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001830:	e12fff1e 	bx	lr

10001834 <Speed_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/Speed/Speed.h"

SPEED_Handle Speed_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
10001834:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001838:	e28db000 	add	fp, sp, #0
1000183c:	e24dd014 	sub	sp, sp, #20
10001840:	e50b0010 	str	r0, [fp, #-16]
10001844:	e50b1014 	str	r1, [fp, #-20]
	SPEED_Handle handle;

	if (numBytes < sizeof(SPEED_Obj))
10001848:	e51b3014 	ldr	r3, [fp, #-20]
1000184c:	e3530027 	cmp	r3, #39	; 0x27
10001850:	8a000001 	bhi	1000185c <Speed_Init+0x28>
		return((SPEED_Handle)NULL);
10001854:	e3a03000 	mov	r3, #0
10001858:	ea00001d 	b	100018d4 <Speed_Init+0xa0>

	// assign the handle
	handle = (SPEED_Handle)pMemory;
1000185c:	e51b3010 	ldr	r3, [fp, #-16]
10001860:	e50b3008 	str	r3, [fp, #-8]

	handle->ElecTheta = (0.0f);
10001864:	e51b3008 	ldr	r3, [fp, #-8]
10001868:	e3a02000 	mov	r2, #0
1000186c:	e5832000 	str	r2, [r3]
	handle->OldElecTheta = (0.0f);
10001870:	e51b3008 	ldr	r3, [fp, #-8]
10001874:	e3a02000 	mov	r2, #0
10001878:	e5832004 	str	r2, [r3, #4]
	handle->ElecThetaChagTimeRatio = (0.0f);// Real:1/(T) PU:1/(T)/SpeedBaseFreq
1000187c:	e51b3008 	ldr	r3, [fp, #-8]
10001880:	e3a02000 	mov	r2, #0
10001884:	e5832008 	str	r2, [r3, #8]
	handle->ElecSpeed = (0.0f);
10001888:	e51b3008 	ldr	r3, [fp, #-8]
1000188c:	e3a02000 	mov	r2, #0
10001890:	e583200c 	str	r2, [r3, #12]
	handle->OldElecSpeed = (0.0f);
10001894:	e51b3008 	ldr	r3, [fp, #-8]
10001898:	e3a02000 	mov	r2, #0
1000189c:	e5832010 	str	r2, [r3, #16]
	handle->ElecFilterSpeed = (0.0f);
100018a0:	e51b3008 	ldr	r3, [fp, #-8]
100018a4:	e3a02000 	mov	r2, #0
100018a8:	e5832018 	str	r2, [r3, #24]
	handle->ElecFilterSpeedRatio = (0.0f);// 1/(1+2*pi*Fc*Ts)
100018ac:	e51b3008 	ldr	r3, [fp, #-8]
100018b0:	e3a02000 	mov	r2, #0
100018b4:	e5832014 	str	r2, [r3, #20]
	handle->Oldturn_cnt = 0;
100018b8:	e51b3008 	ldr	r3, [fp, #-8]
100018bc:	e3a02000 	mov	r2, #0
100018c0:	e5832020 	str	r2, [r3, #32]
	handle->turn_cnt = 0;
100018c4:	e51b3008 	ldr	r3, [fp, #-8]
100018c8:	e3a02000 	mov	r2, #0
100018cc:	e583201c 	str	r2, [r3, #28]
	return(handle);
100018d0:	e51b3008 	ldr	r3, [fp, #-8]
}
100018d4:	e1a00003 	mov	r0, r3
100018d8:	e24bd000 	sub	sp, fp, #0
100018dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100018e0:	e12fff1e 	bx	lr

100018e4 <Speed_Run>:

void Speed_Run(SPEED_Handle handle)
{
100018e4:	e92d4800 	push	{fp, lr}
100018e8:	e28db004 	add	fp, sp, #4
100018ec:	e24dd010 	sub	sp, sp, #16
100018f0:	e50b0010 	str	r0, [fp, #-16]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
100018f4:	e51b3010 	ldr	r3, [fp, #-16]
100018f8:	e50b3008 	str	r3, [fp, #-8]

	Speed_UpdateElecSpeed( obj );
100018fc:	e51b0008 	ldr	r0, [fp, #-8]
10001900:	ebffffbd 	bl	100017fc <Speed_UpdateElecSpeed>
	// Need to Change the Time between Elec And OldElec According to Speed
	// 1kHz:1ms ElecSpeed:500Hz RealSpeed:125Hz@4poles, 2kHz:0.5ms ElecSpeed:500Hz RealSpeed:125Hz@4poles,
	if(obj->turn_cnt == obj->Oldturn_cnt)
10001904:	e51b3008 	ldr	r3, [fp, #-8]
10001908:	e593201c 	ldr	r2, [r3, #28]
1000190c:	e51b3008 	ldr	r3, [fp, #-8]
10001910:	e5933020 	ldr	r3, [r3, #32]
10001914:	e1520003 	cmp	r2, r3
10001918:	1a00000a 	bne	10001948 <Speed_Run+0x64>
	{
		//obj->ElecFilterSpeedRatio = obj->OldElecTheta;
		obj->ElecSpeed = obj->ElecThetaChagTimeRatio * (obj->ElecTheta - obj->OldElecTheta) * (-1);
1000191c:	e51b3008 	ldr	r3, [fp, #-8]
10001920:	ed937a02 	vldr	s14, [r3, #8]
10001924:	e51b3008 	ldr	r3, [fp, #-8]
10001928:	edd36a01 	vldr	s13, [r3, #4]
1000192c:	e51b3008 	ldr	r3, [fp, #-8]
10001930:	edd37a00 	vldr	s15, [r3]
10001934:	ee767ae7 	vsub.f32	s15, s13, s15
10001938:	ee677a27 	vmul.f32	s15, s14, s15
1000193c:	e51b3008 	ldr	r3, [fp, #-8]
10001940:	edc37a03 	vstr	s15, [r3, #12]
10001944:	ea000025 	b	100019e0 <Speed_Run+0xfc>
	}
	else if(MATH_abs(obj->turn_cnt - obj->Oldturn_cnt) < 1000)
10001948:	e51b3008 	ldr	r3, [fp, #-8]
1000194c:	e593201c 	ldr	r2, [r3, #28]
10001950:	e51b3008 	ldr	r3, [fp, #-8]
10001954:	e5933020 	ldr	r3, [r3, #32]
10001958:	e0633002 	rsb	r3, r3, r2
1000195c:	ee073a90 	vmov	s15, r3
10001960:	eef87ae7 	vcvt.f32.s32	s15, s15
10001964:	eeb00a67 	vmov.f32	s0, s15
10001968:	ebffff74 	bl	10001740 <MATH_abs>
1000196c:	eeb07a40 	vmov.f32	s14, s0
10001970:	eddf7a39 	vldr	s15, [pc, #228]	; 10001a5c <Speed_Run+0x178>
10001974:	eeb47ae7 	vcmpe.f32	s14, s15
10001978:	eef1fa10 	vmrs	APSR_nzcv, fpscr
1000197c:	5a000013 	bpl	100019d0 <Speed_Run+0xec>
	{
		obj->ElecSpeed = obj->ElecThetaChagTimeRatio * (-1) * ((obj->ElecTheta - obj->OldElecTheta) - 4 * (obj->turn_cnt - obj->Oldturn_cnt));//ElecThetaChagTimeRatio:1250
10001980:	e51b3008 	ldr	r3, [fp, #-8]
10001984:	ed937a02 	vldr	s14, [r3, #8]
10001988:	e51b3008 	ldr	r3, [fp, #-8]
1000198c:	e593201c 	ldr	r2, [r3, #28]
10001990:	e51b3008 	ldr	r3, [fp, #-8]
10001994:	e5933020 	ldr	r3, [r3, #32]
10001998:	e0633002 	rsb	r3, r3, r2
1000199c:	e1a03103 	lsl	r3, r3, #2
100019a0:	ee073a90 	vmov	s15, r3
100019a4:	eef86ae7 	vcvt.f32.s32	s13, s15
100019a8:	e51b3008 	ldr	r3, [fp, #-8]
100019ac:	ed936a01 	vldr	s12, [r3, #4]
100019b0:	e51b3008 	ldr	r3, [fp, #-8]
100019b4:	edd37a00 	vldr	s15, [r3]
100019b8:	ee767a67 	vsub.f32	s15, s12, s15
100019bc:	ee767aa7 	vadd.f32	s15, s13, s15
100019c0:	ee677a27 	vmul.f32	s15, s14, s15
100019c4:	e51b3008 	ldr	r3, [fp, #-8]
100019c8:	edc37a03 	vstr	s15, [r3, #12]
100019cc:	ea000003 	b	100019e0 <Speed_Run+0xfc>
	}
	else
		obj->ElecSpeed = obj->ElecSpeed;
100019d0:	e51b3008 	ldr	r3, [fp, #-8]
100019d4:	e593200c 	ldr	r2, [r3, #12]
100019d8:	e51b3008 	ldr	r3, [fp, #-8]
100019dc:	e583200c 	str	r2, [r3, #12]
	else
	{
		obj->ElecSpeed = ( obj->ElecThetaChagTimeRatio * (obj->ElecTheta - obj->OldElecTheta) );
	}
	#endif
	obj->OldElecSpeed = obj->ElecFilterSpeed;
100019e0:	e51b3008 	ldr	r3, [fp, #-8]
100019e4:	e5932018 	ldr	r2, [r3, #24]
100019e8:	e51b3008 	ldr	r3, [fp, #-8]
100019ec:	e5832010 	str	r2, [r3, #16]
	obj->spd_test = obj->ElecSpeed;
100019f0:	e51b3008 	ldr	r3, [fp, #-8]
100019f4:	e593200c 	ldr	r2, [r3, #12]
100019f8:	e51b3008 	ldr	r3, [fp, #-8]
100019fc:	e5832024 	str	r2, [r3, #36]	; 0x24
	// Need to Change the Time between ElecSpeed And OldElecSpeed According to Acceleration
	// 1.0f@10ms:0.1f@1ms=>FreqRespose100HzORTimeRespose10ms:0~1.0f(800Hz) And the FilterFreq must 10x;
	if( MATH_abs(obj->ElecFilterSpeed - obj->OldElecSpeed) > (20.0f) )
10001a00:	e51b3008 	ldr	r3, [fp, #-8]
10001a04:	ed937a06 	vldr	s14, [r3, #24]
10001a08:	e51b3008 	ldr	r3, [fp, #-8]
10001a0c:	edd37a04 	vldr	s15, [r3, #16]
10001a10:	ee777a67 	vsub.f32	s15, s14, s15
10001a14:	eeb00a67 	vmov.f32	s0, s15
10001a18:	ebffff48 	bl	10001740 <MATH_abs>
10001a1c:	eeb07a40 	vmov.f32	s14, s0
10001a20:	eef37a04 	vmov.f32	s15, #52	; 0x34
10001a24:	eeb47ae7 	vcmpe.f32	s14, s15
10001a28:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10001a2c:	da000003 	ble	10001a40 <Speed_Run+0x15c>
	{
		obj->ElecFilterSpeed = obj->OldElecSpeed;
10001a30:	e51b3008 	ldr	r3, [fp, #-8]
10001a34:	e5932010 	ldr	r2, [r3, #16]
10001a38:	e51b3008 	ldr	r3, [fp, #-8]
10001a3c:	e5832018 	str	r2, [r3, #24]
		
		//
	}
//	else
//	{
		Speed_UpdateTurnCount(obj);
10001a40:	e51b0008 	ldr	r0, [fp, #-8]
10001a44:	ebffff5e 	bl	100017c4 <Speed_UpdateTurnCount>

		Speed_UpdateElecTheta(obj);
10001a48:	e51b0008 	ldr	r0, [fp, #-8]
10001a4c:	ebffff4e 	bl	1000178c <Speed_UpdateElecTheta>

//	obj->ElecFilterSpeed = (obj->ElecSpeed * ((1.0f)-obj->ElecFilterSpeedRatio)) + (obj->ElecFilterSpeed * obj->ElecFilterSpeedRatio);

//	obj->ElecFilterSpeed = MATH_sat(obj->ElecFilterSpeed, (2.0f), (-2.0f));

	return;
10001a50:	e1a00000 	nop			; (mov r0, r0)
}
10001a54:	e24bd004 	sub	sp, fp, #4
10001a58:	e8bd8800 	pop	{fp, pc}
10001a5c:	447a0000 	.word	0x447a0000

10001a60 <CLARKE_init>:

// **************************************************************************
// the functions

CLARKE_Handle CLARKE_init(void *pMemory,const size_t numBytes)
{
10001a60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001a64:	e28db000 	add	fp, sp, #0
10001a68:	e24dd014 	sub	sp, sp, #20
10001a6c:	e50b0010 	str	r0, [fp, #-16]
10001a70:	e50b1014 	str	r1, [fp, #-20]
  CLARKE_Handle handle;

  if(numBytes < sizeof(CLARKE_Obj))
10001a74:	e51b3014 	ldr	r3, [fp, #-20]
10001a78:	e353000b 	cmp	r3, #11
10001a7c:	8a000001 	bhi	10001a88 <CLARKE_init+0x28>
    return((CLARKE_Handle)NULL);
10001a80:	e3a03000 	mov	r3, #0
10001a84:	ea000002 	b	10001a94 <CLARKE_init+0x34>

  // assign the handle
  handle = (CLARKE_Handle)pMemory;
10001a88:	e51b3010 	ldr	r3, [fp, #-16]
10001a8c:	e50b3008 	str	r3, [fp, #-8]

  return(handle);
10001a90:	e51b3008 	ldr	r3, [fp, #-8]
} // end of CLARKE_init() function
10001a94:	e1a00003 	mov	r0, r3
10001a98:	e24bd000 	sub	sp, fp, #0
10001a9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001aa0:	e12fff1e 	bx	lr
10001aa4:	00000000 	andeq	r0, r0, r0

10001aa8 <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
10001aa8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001aac:	e28db000 	add	fp, sp, #0
10001ab0:	e24dd014 	sub	sp, sp, #20
10001ab4:	ed0b0a04 	vstr	s0, [fp, #-16]
  float_t out = in;
10001ab8:	e51b3010 	ldr	r3, [fp, #-16]
10001abc:	e50b3008 	str	r3, [fp, #-8]


  if(in < 0.0f)
10001ac0:	ed5b7a04 	vldr	s15, [fp, #-16]
10001ac4:	eef57ac0 	vcmpe.f32	s15, #0.0
10001ac8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10001acc:	5a000002 	bpl	10001adc <MATH_abs+0x34>
    {
      out = -in;
10001ad0:	ed5b7a04 	vldr	s15, [fp, #-16]
10001ad4:	eef17a67 	vneg.f32	s15, s15
10001ad8:	ed4b7a02 	vstr	s15, [fp, #-8]
    }

  return(out);
10001adc:	e51b3008 	ldr	r3, [fp, #-8]
10001ae0:	ee073a90 	vmov	s15, r3
} // end of MATH_abs() function
10001ae4:	eeb00a67 	vmov.f32	s0, s15
10001ae8:	e24bd000 	sub	sp, fp, #0
10001aec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001af0:	e12fff1e 	bx	lr

10001af4 <MATH_sat>:
//! \param[in] in   The input value
//! \param[in] max  The maximum value allowed
//! \param[in] min  The minimum value allowed
//! \return    The saturated value
static inline float_t MATH_sat(const float_t in,const float_t max,const float_t min)
{
10001af4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001af8:	e28db000 	add	fp, sp, #0
10001afc:	e24dd01c 	sub	sp, sp, #28
10001b00:	ed0b0a04 	vstr	s0, [fp, #-16]
10001b04:	ed4b0a05 	vstr	s1, [fp, #-20]	; 0xffffffec
10001b08:	ed0b1a06 	vstr	s2, [fp, #-24]	; 0xffffffe8
  float_t out = in;
10001b0c:	e51b3010 	ldr	r3, [fp, #-16]
10001b10:	e50b3008 	str	r3, [fp, #-8]


  if(in < min)
10001b14:	ed1b7a04 	vldr	s14, [fp, #-16]
10001b18:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
10001b1c:	eeb47ae7 	vcmpe.f32	s14, s15
10001b20:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10001b24:	5a000002 	bpl	10001b34 <MATH_sat+0x40>
    {
      out = min;
10001b28:	e51b3018 	ldr	r3, [fp, #-24]
10001b2c:	e50b3008 	str	r3, [fp, #-8]
10001b30:	ea000006 	b	10001b50 <MATH_sat+0x5c>
    }
  else if(in > max)
10001b34:	ed1b7a04 	vldr	s14, [fp, #-16]
10001b38:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
10001b3c:	eeb47ae7 	vcmpe.f32	s14, s15
10001b40:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10001b44:	da000001 	ble	10001b50 <MATH_sat+0x5c>
    {
      out = max;
10001b48:	e51b3014 	ldr	r3, [fp, #-20]
10001b4c:	e50b3008 	str	r3, [fp, #-8]
    }

  return(out);
10001b50:	e51b3008 	ldr	r3, [fp, #-8]
10001b54:	ee073a90 	vmov	s15, r3
} // end of MATH_sat() function
10001b58:	eeb00a67 	vmov.f32	s0, s15
10001b5c:	e24bd000 	sub	sp, fp, #0
10001b60:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001b64:	e12fff1e 	bx	lr

10001b68 <CLARKE_run>:
//! \brief     Runs the Clarke transform module for three inputs
//! \param[in] handle  The Clarke transform handle
//! \param[in] pInVec        The pointer to the input vector
//! \param[in] pOutVec       The pointer to the output vector
static inline void CLARKE_run(CLARKE_Handle handle,const MATH_vec3 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
10001b68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001b6c:	e28db000 	add	fp, sp, #0
10001b70:	e24dd024 	sub	sp, sp, #36	; 0x24
10001b74:	e50b0018 	str	r0, [fp, #-24]
10001b78:	e50b101c 	str	r1, [fp, #-28]
10001b7c:	e50b2020 	str	r2, [fp, #-32]
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
10001b80:	e51b3018 	ldr	r3, [fp, #-24]
10001b84:	e50b3008 	str	r3, [fp, #-8]

  uint_least8_t numSensors = obj->numSensors;//numSensors=3
10001b88:	e51b3008 	ldr	r3, [fp, #-8]
10001b8c:	e5d33008 	ldrb	r3, [r3, #8]
10001b90:	e54b3009 	strb	r3, [fp, #-9]

  float_t alpha_sf = obj->alpha_sf;//1/3
10001b94:	e51b3008 	ldr	r3, [fp, #-8]
10001b98:	e5933000 	ldr	r3, [r3]
10001b9c:	e50b3010 	str	r3, [fp, #-16]
  float_t beta_sf = obj->beta_sf;//  1/sqrt(3)
10001ba0:	e51b3008 	ldr	r3, [fp, #-8]
10001ba4:	e5933004 	ldr	r3, [r3, #4]
10001ba8:	e50b3014 	str	r3, [fp, #-20]


  if(numSensors == 3)
10001bac:	e55b3009 	ldrb	r3, [fp, #-9]
10001bb0:	e3530003 	cmp	r3, #3
10001bb4:	1a000016 	bne	10001c14 <CLARKE_run+0xac>
    {
      pOutVec->value[0] = ( (2.0f*(pInVec->value[0]) - (pInVec->value[1] + pInVec->value[2])) * alpha_sf );
10001bb8:	e51b301c 	ldr	r3, [fp, #-28]
10001bbc:	edd37a00 	vldr	s15, [r3]
10001bc0:	ee377aa7 	vadd.f32	s14, s15, s15
10001bc4:	e51b301c 	ldr	r3, [fp, #-28]
10001bc8:	edd36a01 	vldr	s13, [r3, #4]
10001bcc:	e51b301c 	ldr	r3, [fp, #-28]
10001bd0:	edd37a02 	vldr	s15, [r3, #8]
10001bd4:	ee767aa7 	vadd.f32	s15, s13, s15
10001bd8:	ee377a67 	vsub.f32	s14, s14, s15
10001bdc:	ed5b7a04 	vldr	s15, [fp, #-16]
10001be0:	ee677a27 	vmul.f32	s15, s14, s15
10001be4:	e51b3020 	ldr	r3, [fp, #-32]
10001be8:	edc37a00 	vstr	s15, [r3]
      pOutVec->value[1] = (pInVec->value[1] - pInVec->value[2] * beta_sf);
10001bec:	e51b301c 	ldr	r3, [fp, #-28]
10001bf0:	ed937a01 	vldr	s14, [r3, #4]
10001bf4:	e51b301c 	ldr	r3, [fp, #-28]
10001bf8:	edd36a02 	vldr	s13, [r3, #8]
10001bfc:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
10001c00:	ee667aa7 	vmul.f32	s15, s13, s15
10001c04:	ee777a67 	vsub.f32	s15, s14, s15
10001c08:	e51b3020 	ldr	r3, [fp, #-32]
10001c0c:	edc37a01 	vstr	s15, [r3, #4]
10001c10:	ea000012 	b	10001c60 <CLARKE_run+0xf8>
    }
  else if(numSensors == 2)
10001c14:	e55b3009 	ldrb	r3, [fp, #-9]
10001c18:	e3530002 	cmp	r3, #2
10001c1c:	1a00000f 	bne	10001c60 <CLARKE_run+0xf8>
    {
      pOutVec->value[0] = (pInVec->value[0] * alpha_sf);
10001c20:	e51b301c 	ldr	r3, [fp, #-28]
10001c24:	ed937a00 	vldr	s14, [r3]
10001c28:	ed5b7a04 	vldr	s15, [fp, #-16]
10001c2c:	ee677a27 	vmul.f32	s15, s14, s15
10001c30:	e51b3020 	ldr	r3, [fp, #-32]
10001c34:	edc37a00 	vstr	s15, [r3]
      pOutVec->value[1] = ( (pInVec->value[0] + 2.0f*(pInVec->value[1])) * beta_sf );
10001c38:	e51b301c 	ldr	r3, [fp, #-28]
10001c3c:	ed937a00 	vldr	s14, [r3]
10001c40:	e51b301c 	ldr	r3, [fp, #-28]
10001c44:	edd37a01 	vldr	s15, [r3, #4]
10001c48:	ee777aa7 	vadd.f32	s15, s15, s15
10001c4c:	ee377a27 	vadd.f32	s14, s14, s15
10001c50:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
10001c54:	ee677a27 	vmul.f32	s15, s14, s15
10001c58:	e51b3020 	ldr	r3, [fp, #-32]
10001c5c:	edc37a01 	vstr	s15, [r3, #4]
    }

  return;
10001c60:	e1a00000 	nop			; (mov r0, r0)
} // end of CLARKE_run() function
10001c64:	e24bd000 	sub	sp, fp, #0
10001c68:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001c6c:	e12fff1e 	bx	lr

10001c70 <CLARKE_setNumSensors>:

//! \brief     Sets the number of sensors
//! \param[in] handle  The Clarke transform handle
//! \param[in] numSensors    The number of sensors
static inline void CLARKE_setNumSensors(CLARKE_Handle handle,const uint_least8_t numSensors)//! \Mod By Dl.K
{
10001c70:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001c74:	e28db000 	add	fp, sp, #0
10001c78:	e24dd014 	sub	sp, sp, #20
10001c7c:	e50b0010 	str	r0, [fp, #-16]
10001c80:	e1a03001 	mov	r3, r1
10001c84:	e54b3011 	strb	r3, [fp, #-17]
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
10001c88:	e51b3010 	ldr	r3, [fp, #-16]
10001c8c:	e50b3008 	str	r3, [fp, #-8]

  obj->numSensors = numSensors;
10001c90:	e51b3008 	ldr	r3, [fp, #-8]
10001c94:	e55b2011 	ldrb	r2, [fp, #-17]
10001c98:	e5c32008 	strb	r2, [r3, #8]

  return;
10001c9c:	e1a00000 	nop			; (mov r0, r0)
} // end of CLARKE_setNumSensors() function
10001ca0:	e24bd000 	sub	sp, fp, #0
10001ca4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001ca8:	e12fff1e 	bx	lr

10001cac <CLARKE_setScaleFactors>:
//! \brief     Sets the scale factors
//! \param[in] handle  The Clarke transform handle
//! \param[in] alpha_sf      The scale factor for the alpha voltage
//! \param[in] beta_sf       The scale factor for the beta voltage
static inline void CLARKE_setScaleFactors(CLARKE_Handle handle,const float_t alpha_sf,const float_t beta_sf)//! \Mod By Dl.K
{
10001cac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001cb0:	e28db000 	add	fp, sp, #0
10001cb4:	e24dd01c 	sub	sp, sp, #28
10001cb8:	e50b0010 	str	r0, [fp, #-16]
10001cbc:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
10001cc0:	ed4b0a06 	vstr	s1, [fp, #-24]	; 0xffffffe8
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
10001cc4:	e51b3010 	ldr	r3, [fp, #-16]
10001cc8:	e50b3008 	str	r3, [fp, #-8]


  obj->alpha_sf = alpha_sf;
10001ccc:	e51b3008 	ldr	r3, [fp, #-8]
10001cd0:	e51b2014 	ldr	r2, [fp, #-20]
10001cd4:	e5832000 	str	r2, [r3]
  obj->beta_sf = beta_sf;
10001cd8:	e51b3008 	ldr	r3, [fp, #-8]
10001cdc:	e51b2018 	ldr	r2, [fp, #-24]
10001ce0:	e5832004 	str	r2, [r3, #4]

  return;
10001ce4:	e1a00000 	nop			; (mov r0, r0)
} // end of CLARKE_setScaleFactors() function
10001ce8:	e24bd000 	sub	sp, fp, #0
10001cec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001cf0:	e12fff1e 	bx	lr

10001cf4 <PARK_run>:
//! \brief     Runs the Park transform module
//! \param[in] handle  The Park transform handle
//! \param[in] pInVec      The pointer to the input vector
//! \param[in] pOutVec     The pointer to the output vector
static inline void PARK_run(PARK_Handle handle,const MATH_vec2 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
10001cf4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001cf8:	e28db000 	add	fp, sp, #0
10001cfc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
10001d00:	e50b0020 	str	r0, [fp, #-32]
10001d04:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10001d08:	e50b2028 	str	r2, [fp, #-40]	; 0x28
  PARK_Obj *obj = (PARK_Obj *)handle;
10001d0c:	e51b3020 	ldr	r3, [fp, #-32]
10001d10:	e50b3008 	str	r3, [fp, #-8]

  float_t sinTh = obj->sinTh;
10001d14:	e51b3008 	ldr	r3, [fp, #-8]
10001d18:	e5933000 	ldr	r3, [r3]
10001d1c:	e50b300c 	str	r3, [fp, #-12]
  float_t cosTh = obj->cosTh;
10001d20:	e51b3008 	ldr	r3, [fp, #-8]
10001d24:	e5933004 	ldr	r3, [r3, #4]
10001d28:	e50b3010 	str	r3, [fp, #-16]

  float_t value_0 = pInVec->value[0];
10001d2c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10001d30:	e5933000 	ldr	r3, [r3]
10001d34:	e50b3014 	str	r3, [fp, #-20]
  float_t value_1 = pInVec->value[1];
10001d38:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10001d3c:	e5933004 	ldr	r3, [r3, #4]
10001d40:	e50b3018 	str	r3, [fp, #-24]


  pOutVec->value[0] = (value_0*cosTh) + (value_1*sinTh);
10001d44:	ed1b7a05 	vldr	s14, [fp, #-20]	; 0xffffffec
10001d48:	ed5b7a04 	vldr	s15, [fp, #-16]
10001d4c:	ee277a27 	vmul.f32	s14, s14, s15
10001d50:	ed5b6a06 	vldr	s13, [fp, #-24]	; 0xffffffe8
10001d54:	ed5b7a03 	vldr	s15, [fp, #-12]
10001d58:	ee667aa7 	vmul.f32	s15, s13, s15
10001d5c:	ee777a27 	vadd.f32	s15, s14, s15
10001d60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10001d64:	edc37a00 	vstr	s15, [r3]
  pOutVec->value[1] = (value_1*cosTh) - (value_0*sinTh);
10001d68:	ed1b7a06 	vldr	s14, [fp, #-24]	; 0xffffffe8
10001d6c:	ed5b7a04 	vldr	s15, [fp, #-16]
10001d70:	ee277a27 	vmul.f32	s14, s14, s15
10001d74:	ed5b6a05 	vldr	s13, [fp, #-20]	; 0xffffffec
10001d78:	ed5b7a03 	vldr	s15, [fp, #-12]
10001d7c:	ee667aa7 	vmul.f32	s15, s13, s15
10001d80:	ee777a67 	vsub.f32	s15, s14, s15
10001d84:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10001d88:	edc37a01 	vstr	s15, [r3, #4]

  return;
10001d8c:	e1a00000 	nop			; (mov r0, r0)
} // end of PARK_run() function
10001d90:	e24bd000 	sub	sp, fp, #0
10001d94:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001d98:	e12fff1e 	bx	lr

10001d9c <PARK_setPhasor>:

//! \brief     Sets the cosine/sine phasor for the inverse Park transform
//! \param[in] handle   The Park transform handle
//! \param[in] pPhasor      The pointer to the cosine/sine phasor, pu
static inline void PARK_setPhasor(PARK_Handle handle,const MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
10001d9c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001da0:	e28db000 	add	fp, sp, #0
10001da4:	e24dd014 	sub	sp, sp, #20
10001da8:	e50b0010 	str	r0, [fp, #-16]
10001dac:	e50b1014 	str	r1, [fp, #-20]
  PARK_Obj *obj = (PARK_Obj *)handle;
10001db0:	e51b3010 	ldr	r3, [fp, #-16]
10001db4:	e50b3008 	str	r3, [fp, #-8]

  obj->cosTh = pPhasor->value[0];
10001db8:	e51b3014 	ldr	r3, [fp, #-20]
10001dbc:	e5932000 	ldr	r2, [r3]
10001dc0:	e51b3008 	ldr	r3, [fp, #-8]
10001dc4:	e5832004 	str	r2, [r3, #4]
  obj->sinTh = pPhasor->value[1];
10001dc8:	e51b3014 	ldr	r3, [fp, #-20]
10001dcc:	e5932004 	ldr	r2, [r3, #4]
10001dd0:	e51b3008 	ldr	r3, [fp, #-8]
10001dd4:	e5832000 	str	r2, [r3]

  return;
10001dd8:	e1a00000 	nop			; (mov r0, r0)
} // end of PARK_setPhasor() function
10001ddc:	e24bd000 	sub	sp, fp, #0
10001de0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001de4:	e12fff1e 	bx	lr

10001de8 <IPARK_run>:
//! \brief     Runs the inverse Park transform module
//! \param[in] handle  The inverse Park transform handle
//! \param[in] pInVec       The pointer to the input vector
//! \param[in] pOutVec      The pointer to the output vector
static inline void IPARK_run(IPARK_Handle handle,const MATH_vec2 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
10001de8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001dec:	e28db000 	add	fp, sp, #0
10001df0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
10001df4:	e50b0020 	str	r0, [fp, #-32]
10001df8:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10001dfc:	e50b2028 	str	r2, [fp, #-40]	; 0x28
  IPARK_Obj *obj = (IPARK_Obj *)handle;
10001e00:	e51b3020 	ldr	r3, [fp, #-32]
10001e04:	e50b3008 	str	r3, [fp, #-8]

  float_t sinTh = obj->sinTh;
10001e08:	e51b3008 	ldr	r3, [fp, #-8]
10001e0c:	e5933000 	ldr	r3, [r3]
10001e10:	e50b300c 	str	r3, [fp, #-12]
  float_t cosTh = obj->cosTh;
10001e14:	e51b3008 	ldr	r3, [fp, #-8]
10001e18:	e5933004 	ldr	r3, [r3, #4]
10001e1c:	e50b3010 	str	r3, [fp, #-16]

  float_t value_0 = pInVec->value[0];
10001e20:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10001e24:	e5933000 	ldr	r3, [r3]
10001e28:	e50b3014 	str	r3, [fp, #-20]
  float_t value_1 = pInVec->value[1];
10001e2c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10001e30:	e5933004 	ldr	r3, [r3, #4]
10001e34:	e50b3018 	str	r3, [fp, #-24]


  pOutVec->value[0] = (value_0*cosTh) - (value_1*sinTh);
10001e38:	ed1b7a05 	vldr	s14, [fp, #-20]	; 0xffffffec
10001e3c:	ed5b7a04 	vldr	s15, [fp, #-16]
10001e40:	ee277a27 	vmul.f32	s14, s14, s15
10001e44:	ed5b6a06 	vldr	s13, [fp, #-24]	; 0xffffffe8
10001e48:	ed5b7a03 	vldr	s15, [fp, #-12]
10001e4c:	ee667aa7 	vmul.f32	s15, s13, s15
10001e50:	ee777a67 	vsub.f32	s15, s14, s15
10001e54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10001e58:	edc37a00 	vstr	s15, [r3]
  pOutVec->value[1] = (value_1*cosTh) + (value_0*sinTh);
10001e5c:	ed1b7a06 	vldr	s14, [fp, #-24]	; 0xffffffe8
10001e60:	ed5b7a04 	vldr	s15, [fp, #-16]
10001e64:	ee277a27 	vmul.f32	s14, s14, s15
10001e68:	ed5b6a05 	vldr	s13, [fp, #-20]	; 0xffffffec
10001e6c:	ed5b7a03 	vldr	s15, [fp, #-12]
10001e70:	ee667aa7 	vmul.f32	s15, s13, s15
10001e74:	ee777a27 	vadd.f32	s15, s14, s15
10001e78:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10001e7c:	edc37a01 	vstr	s15, [r3, #4]

  return;
10001e80:	e1a00000 	nop			; (mov r0, r0)
} // end of IPARK_run() function
10001e84:	e24bd000 	sub	sp, fp, #0
10001e88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001e8c:	e12fff1e 	bx	lr

10001e90 <IPARK_setPhasor>:

//! \brief     Sets the cosine/sine phasor for the inverse Park transform
//! \param[in] handle   The inverse Park transform handle
//! \param[in] pPhasor  The pointer to the cosine/sine phasor, pu
static inline void IPARK_setPhasor(IPARK_Handle handle,const MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
10001e90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001e94:	e28db000 	add	fp, sp, #0
10001e98:	e24dd014 	sub	sp, sp, #20
10001e9c:	e50b0010 	str	r0, [fp, #-16]
10001ea0:	e50b1014 	str	r1, [fp, #-20]
  IPARK_Obj *obj = (IPARK_Obj *)handle;
10001ea4:	e51b3010 	ldr	r3, [fp, #-16]
10001ea8:	e50b3008 	str	r3, [fp, #-8]

  obj->cosTh = pPhasor->value[0];
10001eac:	e51b3014 	ldr	r3, [fp, #-20]
10001eb0:	e5932000 	ldr	r2, [r3]
10001eb4:	e51b3008 	ldr	r3, [fp, #-8]
10001eb8:	e5832004 	str	r2, [r3, #4]
  obj->sinTh = pPhasor->value[1];
10001ebc:	e51b3014 	ldr	r3, [fp, #-20]
10001ec0:	e5932004 	ldr	r2, [r3, #4]
10001ec4:	e51b3008 	ldr	r3, [fp, #-8]
10001ec8:	e5832000 	str	r2, [r3]

  return;
10001ecc:	e1a00000 	nop			; (mov r0, r0)
} // end of IPARK_setPhasor() function
10001ed0:	e24bd000 	sub	sp, fp, #0
10001ed4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001ed8:	e12fff1e 	bx	lr

10001edc <FILTER_FO_run>:
//!
//! \param[in] handle      The filter handle
//! \param[in] inputValue  The input value to filter
//! \return    The output value from the filter
static inline float_t FILTER_FO_run(FILTER_FO_Handle handle,const float_t inputValue)
{
10001edc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001ee0:	e28db000 	add	fp, sp, #0
10001ee4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
10001ee8:	e50b0028 	str	r0, [fp, #-40]	; 0x28
10001eec:	ed0b0a0b 	vstr	s0, [fp, #-44]	; 0xffffffd4
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
10001ef0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10001ef4:	e50b3008 	str	r3, [fp, #-8]

  float a1 = obj->a1;
10001ef8:	e51b3008 	ldr	r3, [fp, #-8]
10001efc:	e5933000 	ldr	r3, [r3]
10001f00:	e50b300c 	str	r3, [fp, #-12]
  float b0 = obj->b0;
10001f04:	e51b3008 	ldr	r3, [fp, #-8]
10001f08:	e5933004 	ldr	r3, [r3, #4]
10001f0c:	e50b3010 	str	r3, [fp, #-16]
  float b1 = obj->b1;
10001f10:	e51b3008 	ldr	r3, [fp, #-8]
10001f14:	e5933008 	ldr	r3, [r3, #8]
10001f18:	e50b3014 	str	r3, [fp, #-20]
  float x1 = obj->x1;
10001f1c:	e51b3008 	ldr	r3, [fp, #-8]
10001f20:	e593300c 	ldr	r3, [r3, #12]
10001f24:	e50b3018 	str	r3, [fp, #-24]
  float y1 = obj->y1;
10001f28:	e51b3008 	ldr	r3, [fp, #-8]
10001f2c:	e5933010 	ldr	r3, [r3, #16]
10001f30:	e50b301c 	str	r3, [fp, #-28]


  // compute the output
  //settestpin();

  float y0 = (b0 * inputValue) + (b1 * x1) - (a1 * y1);
10001f34:	ed1b7a04 	vldr	s14, [fp, #-16]
10001f38:	ed5b7a0b 	vldr	s15, [fp, #-44]	; 0xffffffd4
10001f3c:	ee277a27 	vmul.f32	s14, s14, s15
10001f40:	ed5b6a05 	vldr	s13, [fp, #-20]	; 0xffffffec
10001f44:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
10001f48:	ee667aa7 	vmul.f32	s15, s13, s15
10001f4c:	ee377a27 	vadd.f32	s14, s14, s15
10001f50:	ed5b6a03 	vldr	s13, [fp, #-12]
10001f54:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
10001f58:	ee667aa7 	vmul.f32	s15, s13, s15
10001f5c:	ee777a67 	vsub.f32	s15, s14, s15
10001f60:	ed4b7a08 	vstr	s15, [fp, #-32]	; 0xffffffe0
  //double y0 = 0;
  //cleartestpin();


  // store values for next time
  obj->x1 = inputValue;
10001f64:	e51b3008 	ldr	r3, [fp, #-8]
10001f68:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
10001f6c:	e583200c 	str	r2, [r3, #12]
  obj->y1 = (float_t)y0;
10001f70:	e51b3008 	ldr	r3, [fp, #-8]
10001f74:	e51b2020 	ldr	r2, [fp, #-32]
10001f78:	e5832010 	str	r2, [r3, #16]

  return((float_t)y0);
10001f7c:	e51b3020 	ldr	r3, [fp, #-32]
10001f80:	ee073a90 	vmov	s15, r3
} // end of FILTER_FO_run() function
10001f84:	eeb00a67 	vmov.f32	s0, s15
10001f88:	e24bd000 	sub	sp, fp, #0
10001f8c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001f90:	e12fff1e 	bx	lr

10001f94 <OFFSET_run>:
//!            x -> The ADC measurement
//!
//! \param[in] handle  The offset handle
//! \param[in] inputValue    The input value to offset filter
static inline void OFFSET_run(OFFSET_Handle handle,const float_t inputValue)
{
10001f94:	e92d4800 	push	{fp, lr}
10001f98:	e28db004 	add	fp, sp, #4
10001f9c:	e24dd010 	sub	sp, sp, #16
10001fa0:	e50b0010 	str	r0, [fp, #-16]
10001fa4:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
10001fa8:	e51b3010 	ldr	r3, [fp, #-16]
10001fac:	e50b3008 	str	r3, [fp, #-8]

  obj->value = FILTER_FO_run(obj->filterHandle,inputValue);
10001fb0:	e51b3008 	ldr	r3, [fp, #-8]
10001fb4:	e593301c 	ldr	r3, [r3, #28]
10001fb8:	e1a00003 	mov	r0, r3
10001fbc:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10001fc0:	ebffffc5 	bl	10001edc <FILTER_FO_run>
10001fc4:	eef07a40 	vmov.f32	s15, s0
10001fc8:	e51b3008 	ldr	r3, [fp, #-8]
10001fcc:	edc37a00 	vstr	s15, [r3]

  return;
10001fd0:	e1a00000 	nop			; (mov r0, r0)
} // end of OFFSET_run() function
10001fd4:	e24bd004 	sub	sp, fp, #4
10001fd8:	e8bd8800 	pop	{fp, pc}

10001fdc <PID_run>:
//! \param[in] handle      The PID controller handle
//! \param[in] refValue    The reference value to the controller
//! \param[in] fbackValue  The feedback value to the controller
//! \param[in] pOutValue   The pointer to the controller output value
static inline void PID_run(PID_Handle handle,const float_t refValue,const float_t fbackValue,float_t *pOutValue)//! \Mod By Dl.K
{
10001fdc:	e92d4800 	push	{fp, lr}
10001fe0:	e28db004 	add	fp, sp, #4
10001fe4:	e24dd020 	sub	sp, sp, #32
10001fe8:	e50b0018 	str	r0, [fp, #-24]
10001fec:	ed0b0a07 	vstr	s0, [fp, #-28]	; 0xffffffe4
10001ff0:	ed4b0a08 	vstr	s1, [fp, #-32]	; 0xffffffe0
10001ff4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
  PID_Obj *obj = (PID_Obj *)handle;
10001ff8:	e51b3018 	ldr	r3, [fp, #-24]
10001ffc:	e50b3008 	str	r3, [fp, #-8]

  float_t Error;
  float_t Up,Ui;


  Error = refValue - fbackValue;
10002000:	ed1b7a07 	vldr	s14, [fp, #-28]	; 0xffffffe4
10002004:	ed5b7a08 	vldr	s15, [fp, #-32]	; 0xffffffe0
10002008:	ee777a67 	vsub.f32	s15, s14, s15
1000200c:	ed4b7a03 	vstr	s15, [fp, #-12]

  Ui = obj->Ui;                                                  // load the previous integral output
10002010:	e51b3008 	ldr	r3, [fp, #-8]
10002014:	e593300c 	ldr	r3, [r3, #12]
10002018:	e50b3010 	str	r3, [fp, #-16]
  Up = (obj->Kp * Error);                                    // Compute the proportional output
1000201c:	e51b3008 	ldr	r3, [fp, #-8]
10002020:	ed937a00 	vldr	s14, [r3]
10002024:	ed5b7a03 	vldr	s15, [fp, #-12]
10002028:	ee677a27 	vmul.f32	s15, s14, s15
1000202c:	ed4b7a05 	vstr	s15, [fp, #-20]	; 0xffffffec
  Ui = MATH_sat(Ui + (obj->Ki * Up), obj->outMax, obj->outMin);  // Compute the integral output
10002030:	e51b3008 	ldr	r3, [fp, #-8]
10002034:	ed937a01 	vldr	s14, [r3, #4]
10002038:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
1000203c:	ee277a27 	vmul.f32	s14, s14, s15
10002040:	ed5b7a04 	vldr	s15, [fp, #-16]
10002044:	ee776a27 	vadd.f32	s13, s14, s15
10002048:	e51b3008 	ldr	r3, [fp, #-8]
1000204c:	ed937a07 	vldr	s14, [r3, #28]
10002050:	e51b3008 	ldr	r3, [fp, #-8]
10002054:	edd37a06 	vldr	s15, [r3, #24]
10002058:	eeb00a66 	vmov.f32	s0, s13
1000205c:	eef00a47 	vmov.f32	s1, s14
10002060:	eeb01a67 	vmov.f32	s2, s15
10002064:	ebfffea2 	bl	10001af4 <MATH_sat>
10002068:	ed0b0a04 	vstr	s0, [fp, #-16]

  obj->Ui = Ui;                                                  // store the intetral output
1000206c:	e51b3008 	ldr	r3, [fp, #-8]
10002070:	e51b2010 	ldr	r2, [fp, #-16]
10002074:	e583200c 	str	r2, [r3, #12]
  obj->refValue = refValue;
10002078:	e51b3008 	ldr	r3, [fp, #-8]
1000207c:	e51b201c 	ldr	r2, [fp, #-28]
10002080:	e5832010 	str	r2, [r3, #16]
  obj->fbackValue = fbackValue;
10002084:	e51b3008 	ldr	r3, [fp, #-8]
10002088:	e51b2020 	ldr	r2, [fp, #-32]
1000208c:	e5832014 	str	r2, [r3, #20]

  *pOutValue = MATH_sat(Up + Ui, obj->outMax, obj->outMin);          // Saturate the output
10002090:	ed1b7a05 	vldr	s14, [fp, #-20]	; 0xffffffec
10002094:	ed5b7a04 	vldr	s15, [fp, #-16]
10002098:	ee776a27 	vadd.f32	s13, s14, s15
1000209c:	e51b3008 	ldr	r3, [fp, #-8]
100020a0:	ed937a07 	vldr	s14, [r3, #28]
100020a4:	e51b3008 	ldr	r3, [fp, #-8]
100020a8:	edd37a06 	vldr	s15, [r3, #24]
100020ac:	eeb00a66 	vmov.f32	s0, s13
100020b0:	eef00a47 	vmov.f32	s1, s14
100020b4:	eeb01a67 	vmov.f32	s2, s15
100020b8:	ebfffe8d 	bl	10001af4 <MATH_sat>
100020bc:	eef07a40 	vmov.f32	s15, s0
100020c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100020c4:	edc37a00 	vstr	s15, [r3]

  return;
100020c8:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_run() function
100020cc:	e24bd004 	sub	sp, fp, #4
100020d0:	e8bd8800 	pop	{fp, pc}

100020d4 <PID_run_spd>:
//! \param[in] handle      The PID controller handle
//! \param[in] refValue    The reference value to the controller
//! \param[in] fbackValue  The feedback value to the controller
//! \param[in] pOutValue   The pointer to the controller output value
static inline void PID_run_spd(PID_Handle handle,const float_t refValue,const float_t fbackValue,float_t *pOutValue)//! \Mod By Dl.K
{
100020d4:	e92d4800 	push	{fp, lr}
100020d8:	e28db004 	add	fp, sp, #4
100020dc:	e24dd020 	sub	sp, sp, #32
100020e0:	e50b0018 	str	r0, [fp, #-24]
100020e4:	ed0b0a07 	vstr	s0, [fp, #-28]	; 0xffffffe4
100020e8:	ed4b0a08 	vstr	s1, [fp, #-32]	; 0xffffffe0
100020ec:	e50b1024 	str	r1, [fp, #-36]	; 0x24
  PID_Obj *obj = (PID_Obj *)handle;
100020f0:	e51b3018 	ldr	r3, [fp, #-24]
100020f4:	e50b3008 	str	r3, [fp, #-8]

  float_t Error;
  float_t Up,Ui;

  Error = refValue - fbackValue;
100020f8:	ed1b7a07 	vldr	s14, [fp, #-28]	; 0xffffffe4
100020fc:	ed5b7a08 	vldr	s15, [fp, #-32]	; 0xffffffe0
10002100:	ee777a67 	vsub.f32	s15, s14, s15
10002104:	ed4b7a03 	vstr	s15, [fp, #-12]

  Ui = obj->Ui;                                                     // load the previous integral output
10002108:	e51b3008 	ldr	r3, [fp, #-8]
1000210c:	e593300c 	ldr	r3, [r3, #12]
10002110:	e50b3010 	str	r3, [fp, #-16]
  Up = (obj->Kp * Error);                                       // Compute the proportional output
10002114:	e51b3008 	ldr	r3, [fp, #-8]
10002118:	ed937a00 	vldr	s14, [r3]
1000211c:	ed5b7a03 	vldr	s15, [fp, #-12]
10002120:	ee677a27 	vmul.f32	s15, s14, s15
10002124:	ed4b7a05 	vstr	s15, [fp, #-20]	; 0xffffffec
  Ui = MATH_sat(Ui + (obj->Ki * Error), obj->outMax, obj->outMin);  // Compute the integral output
10002128:	e51b3008 	ldr	r3, [fp, #-8]
1000212c:	ed937a01 	vldr	s14, [r3, #4]
10002130:	ed5b7a03 	vldr	s15, [fp, #-12]
10002134:	ee277a27 	vmul.f32	s14, s14, s15
10002138:	ed5b7a04 	vldr	s15, [fp, #-16]
1000213c:	ee776a27 	vadd.f32	s13, s14, s15
10002140:	e51b3008 	ldr	r3, [fp, #-8]
10002144:	ed937a07 	vldr	s14, [r3, #28]
10002148:	e51b3008 	ldr	r3, [fp, #-8]
1000214c:	edd37a06 	vldr	s15, [r3, #24]
10002150:	eeb00a66 	vmov.f32	s0, s13
10002154:	eef00a47 	vmov.f32	s1, s14
10002158:	eeb01a67 	vmov.f32	s2, s15
1000215c:	ebfffe64 	bl	10001af4 <MATH_sat>
10002160:	ed0b0a04 	vstr	s0, [fp, #-16]

  obj->Ui = Ui;                                                     // store the intetral output
10002164:	e51b3008 	ldr	r3, [fp, #-8]
10002168:	e51b2010 	ldr	r2, [fp, #-16]
1000216c:	e583200c 	str	r2, [r3, #12]
  obj->refValue = refValue;
10002170:	e51b3008 	ldr	r3, [fp, #-8]
10002174:	e51b201c 	ldr	r2, [fp, #-28]
10002178:	e5832010 	str	r2, [r3, #16]
  obj->fbackValue = fbackValue;
1000217c:	e51b3008 	ldr	r3, [fp, #-8]
10002180:	e51b2020 	ldr	r2, [fp, #-32]
10002184:	e5832014 	str	r2, [r3, #20]

  *pOutValue = MATH_sat(Up + Ui, obj->outMax, obj->outMin);             // Saturate the output
10002188:	ed1b7a05 	vldr	s14, [fp, #-20]	; 0xffffffec
1000218c:	ed5b7a04 	vldr	s15, [fp, #-16]
10002190:	ee776a27 	vadd.f32	s13, s14, s15
10002194:	e51b3008 	ldr	r3, [fp, #-8]
10002198:	ed937a07 	vldr	s14, [r3, #28]
1000219c:	e51b3008 	ldr	r3, [fp, #-8]
100021a0:	edd37a06 	vldr	s15, [r3, #24]
100021a4:	eeb00a66 	vmov.f32	s0, s13
100021a8:	eef00a47 	vmov.f32	s1, s14
100021ac:	eeb01a67 	vmov.f32	s2, s15
100021b0:	ebfffe4f 	bl	10001af4 <MATH_sat>
100021b4:	eef07a40 	vmov.f32	s15, s0
100021b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100021bc:	edc37a00 	vstr	s15, [r3]

  return;
100021c0:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_run_spd() function
100021c4:	e24bd004 	sub	sp, fp, #4
100021c8:	e8bd8800 	pop	{fp, pc}

100021cc <PID_setGains>:
//! \param[in] handle  The PID controller handle
//! \param[in] Kp      The proportional gain for the PID controller
//! \param[in] Ki      The integrator gain for the PID controller
//! \param[in] Kd      The derivative gain for the PID controller
static inline void PID_setGains(PID_Handle handle,const float_t Kp,const float_t Ki,const float_t Kd)//! \Mod By Dl.K
{
100021cc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100021d0:	e28db000 	add	fp, sp, #0
100021d4:	e24dd01c 	sub	sp, sp, #28
100021d8:	e50b0010 	str	r0, [fp, #-16]
100021dc:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
100021e0:	ed4b0a06 	vstr	s1, [fp, #-24]	; 0xffffffe8
100021e4:	ed0b1a07 	vstr	s2, [fp, #-28]	; 0xffffffe4
  PID_Obj *obj = (PID_Obj *)handle;
100021e8:	e51b3010 	ldr	r3, [fp, #-16]
100021ec:	e50b3008 	str	r3, [fp, #-8]

  obj->Kp = Kp;
100021f0:	e51b3008 	ldr	r3, [fp, #-8]
100021f4:	e51b2014 	ldr	r2, [fp, #-20]
100021f8:	e5832000 	str	r2, [r3]
  obj->Ki = Ki;
100021fc:	e51b3008 	ldr	r3, [fp, #-8]
10002200:	e51b2018 	ldr	r2, [fp, #-24]
10002204:	e5832004 	str	r2, [r3, #4]
  obj->Kd = Kd;
10002208:	e51b3008 	ldr	r3, [fp, #-8]
1000220c:	e51b201c 	ldr	r2, [fp, #-28]
10002210:	e5832008 	str	r2, [r3, #8]

  return;
10002214:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setGains() function
10002218:	e24bd000 	sub	sp, fp, #0
1000221c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002220:	e12fff1e 	bx	lr

10002224 <PID_setKi>:

//! \brief     Sets the integral gain in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ki      The integral gain for the PID controller
static inline void PID_setKi(PID_Handle handle,const float_t Ki)//! \Mod By Dl.K
{
10002224:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002228:	e28db000 	add	fp, sp, #0
1000222c:	e24dd014 	sub	sp, sp, #20
10002230:	e50b0010 	str	r0, [fp, #-16]
10002234:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
10002238:	e51b3010 	ldr	r3, [fp, #-16]
1000223c:	e50b3008 	str	r3, [fp, #-8]

  obj->Ki = Ki;
10002240:	e51b3008 	ldr	r3, [fp, #-8]
10002244:	e51b2014 	ldr	r2, [fp, #-20]
10002248:	e5832004 	str	r2, [r3, #4]

  return;
1000224c:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setKi() function
10002250:	e24bd000 	sub	sp, fp, #0
10002254:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002258:	e12fff1e 	bx	lr

1000225c <PID_setKp>:

//! \brief     Sets the proportional gain in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Kp      The proportional gain for the PID controller
static inline void PID_setKp(PID_Handle handle,const float_t Kp)//! \Mod By Dl.K
{
1000225c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002260:	e28db000 	add	fp, sp, #0
10002264:	e24dd014 	sub	sp, sp, #20
10002268:	e50b0010 	str	r0, [fp, #-16]
1000226c:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
10002270:	e51b3010 	ldr	r3, [fp, #-16]
10002274:	e50b3008 	str	r3, [fp, #-8]

  obj->Kp = Kp;
10002278:	e51b3008 	ldr	r3, [fp, #-8]
1000227c:	e51b2014 	ldr	r2, [fp, #-20]
10002280:	e5832000 	str	r2, [r3]

  return;
10002284:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setKp() function
10002288:	e24bd000 	sub	sp, fp, #0
1000228c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002290:	e12fff1e 	bx	lr

10002294 <PID_setMinMax>:
//! \brief     Sets the minimum and maximum output value allowed in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] outMin  The minimum output value allowed
//! \param[in] outMax  The maximum output value allowed
static inline void PID_setMinMax(PID_Handle handle,const float_t outMin,const float_t outMax)//! \Mod By Dl.K
{
10002294:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002298:	e28db000 	add	fp, sp, #0
1000229c:	e24dd01c 	sub	sp, sp, #28
100022a0:	e50b0010 	str	r0, [fp, #-16]
100022a4:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
100022a8:	ed4b0a06 	vstr	s1, [fp, #-24]	; 0xffffffe8
  PID_Obj *obj = (PID_Obj *)handle;
100022ac:	e51b3010 	ldr	r3, [fp, #-16]
100022b0:	e50b3008 	str	r3, [fp, #-8]

  obj->outMin = outMin;
100022b4:	e51b3008 	ldr	r3, [fp, #-8]
100022b8:	e51b2014 	ldr	r2, [fp, #-20]
100022bc:	e5832018 	str	r2, [r3, #24]
  obj->outMax = outMax;
100022c0:	e51b3008 	ldr	r3, [fp, #-8]
100022c4:	e51b2018 	ldr	r2, [fp, #-24]
100022c8:	e583201c 	str	r2, [r3, #28]

  return;
100022cc:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setMinMax() function
100022d0:	e24bd000 	sub	sp, fp, #0
100022d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100022d8:	e12fff1e 	bx	lr

100022dc <PID_setUi>:

//! \brief     Sets the integrator start value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ui         The integral start value for the PID controller
static inline void PID_setUi(PID_Handle handle,const float_t Ui)//! \Mod By Dl.K
{
100022dc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100022e0:	e28db000 	add	fp, sp, #0
100022e4:	e24dd014 	sub	sp, sp, #20
100022e8:	e50b0010 	str	r0, [fp, #-16]
100022ec:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
100022f0:	e51b3010 	ldr	r3, [fp, #-16]
100022f4:	e50b3008 	str	r3, [fp, #-8]

  obj->Ui = Ui;
100022f8:	e51b3008 	ldr	r3, [fp, #-8]
100022fc:	e51b2014 	ldr	r2, [fp, #-20]
10002300:	e583200c 	str	r2, [r3, #12]

  return;
10002304:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setUi() function
10002308:	e24bd000 	sub	sp, fp, #0
1000230c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002310:	e12fff1e 	bx	lr

10002314 <SVGEN_run>:
//! \brief	Implements a SVM that saturates at the level of MaxModulation.
//! \param[in] handle  The space vector generator (SVGEN) handle
//! \param[in] pVab    The pointer to the a/b voltages
//! \param[in] pT      The pointer to the pwm duty cycle time durations
static inline void SVGEN_run(SVGEN_Handle handle,const MATH_vec2 *pVab,MATH_vec3 *pT)//! \Mod By Dl.K
{
10002314:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002318:	e28db000 	add	fp, sp, #0
1000231c:	e24dd034 	sub	sp, sp, #52	; 0x34
10002320:	e50b0028 	str	r0, [fp, #-40]	; 0x28
10002324:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
10002328:	e50b2030 	str	r2, [fp, #-48]	; 0x30

  float_t Vmax,Vmin,Vcom;
  float_t Va,Vb,Vc;
  float_t Va_tmp = -(pVab->value[0]*0.5f);
1000232c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10002330:	edd37a00 	vldr	s15, [r3]
10002334:	eeb67a00 	vmov.f32	s14, #96	; 0x60
10002338:	ee677a87 	vmul.f32	s15, s15, s14
1000233c:	eef17a67 	vneg.f32	s15, s15
10002340:	ed4b7a04 	vstr	s15, [fp, #-16]
  float_t Vb_tmp = (SVGEN_SQRT3_OVER_2 * pVab->value[1]);
10002344:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10002348:	edd37a01 	vldr	s15, [r3, #4]
1000234c:	ed9f7a46 	vldr	s14, [pc, #280]	; 1000246c <SVGEN_run+0x158>
10002350:	ee677a87 	vmul.f32	s15, s15, s14
10002354:	ed4b7a05 	vstr	s15, [fp, #-20]	; 0xffffffec
  
  Va = pVab->value[0];  //alpha
10002358:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1000235c:	e5933000 	ldr	r3, [r3]
10002360:	e50b3018 	str	r3, [fp, #-24]
  Vb = Va_tmp + Vb_tmp; //-0.5*alpha + sqrt(3)/2 * beta;
10002364:	ed1b7a04 	vldr	s14, [fp, #-16]
10002368:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
1000236c:	ee777a27 	vadd.f32	s15, s14, s15
10002370:	ed4b7a07 	vstr	s15, [fp, #-28]	; 0xffffffe4
  Vc = Va_tmp - Vb_tmp; //-0.5*alpha - sqrt(3)/2 * beta;
10002374:	ed1b7a04 	vldr	s14, [fp, #-16]
10002378:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
1000237c:	ee777a67 	vsub.f32	s15, s14, s15
10002380:	ed4b7a08 	vstr	s15, [fp, #-32]	; 0xffffffe0
	
  Vmax=0;
10002384:	e3a03000 	mov	r3, #0
10002388:	e50b3008 	str	r3, [fp, #-8]
  Vmin=0;
1000238c:	e3a03000 	mov	r3, #0
10002390:	e50b300c 	str	r3, [fp, #-12]

  // find order Vmin,Vmid,Vmax
  if (Va > Vb)			
10002394:	ed1b7a06 	vldr	s14, [fp, #-24]	; 0xffffffe8
10002398:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
1000239c:	eeb47ae7 	vcmpe.f32	s14, s15
100023a0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100023a4:	da000004 	ble	100023bc <SVGEN_run+0xa8>
  {
    Vmax = Va;
100023a8:	e51b3018 	ldr	r3, [fp, #-24]
100023ac:	e50b3008 	str	r3, [fp, #-8]
    Vmin = Vb;
100023b0:	e51b301c 	ldr	r3, [fp, #-28]
100023b4:	e50b300c 	str	r3, [fp, #-12]
100023b8:	ea000003 	b	100023cc <SVGEN_run+0xb8>
  }
  else
  {
    Vmax = Vb;
100023bc:	e51b301c 	ldr	r3, [fp, #-28]
100023c0:	e50b3008 	str	r3, [fp, #-8]
    Vmin = Va;
100023c4:	e51b3018 	ldr	r3, [fp, #-24]
100023c8:	e50b300c 	str	r3, [fp, #-12]
  }

  if (Vc > Vmax)
100023cc:	ed1b7a08 	vldr	s14, [fp, #-32]	; 0xffffffe0
100023d0:	ed5b7a02 	vldr	s15, [fp, #-8]
100023d4:	eeb47ae7 	vcmpe.f32	s14, s15
100023d8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100023dc:	da000002 	ble	100023ec <SVGEN_run+0xd8>
  {
    Vmax = Vc;
100023e0:	e51b3020 	ldr	r3, [fp, #-32]
100023e4:	e50b3008 	str	r3, [fp, #-8]
100023e8:	ea000006 	b	10002408 <SVGEN_run+0xf4>
  }
  else if (Vc < Vmin)
100023ec:	ed1b7a08 	vldr	s14, [fp, #-32]	; 0xffffffe0
100023f0:	ed5b7a03 	vldr	s15, [fp, #-12]
100023f4:	eeb47ae7 	vcmpe.f32	s14, s15
100023f8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100023fc:	5a000001 	bpl	10002408 <SVGEN_run+0xf4>
  {
    Vmin = Vc;
10002400:	e51b3020 	ldr	r3, [fp, #-32]
10002404:	e50b300c 	str	r3, [fp, #-12]
  }
		
  Vcom = ( (Vmax+Vmin) * (0.5f));
10002408:	ed1b7a02 	vldr	s14, [fp, #-8]
1000240c:	ed5b7a03 	vldr	s15, [fp, #-12]
10002410:	ee777a27 	vadd.f32	s15, s14, s15
10002414:	eeb67a00 	vmov.f32	s14, #96	; 0x60
10002418:	ee677a87 	vmul.f32	s15, s15, s14
1000241c:	ed4b7a09 	vstr	s15, [fp, #-36]	; 0xffffffdc

  // Subtract common-mode term to achieve SV modulation
  pT->value[0] = (Va - Vcom);
10002420:	ed1b7a06 	vldr	s14, [fp, #-24]	; 0xffffffe8
10002424:	ed5b7a09 	vldr	s15, [fp, #-36]	; 0xffffffdc
10002428:	ee777a67 	vsub.f32	s15, s14, s15
1000242c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10002430:	edc37a00 	vstr	s15, [r3]
  pT->value[1] = (Vb - Vcom);
10002434:	ed1b7a07 	vldr	s14, [fp, #-28]	; 0xffffffe4
10002438:	ed5b7a09 	vldr	s15, [fp, #-36]	; 0xffffffdc
1000243c:	ee777a67 	vsub.f32	s15, s14, s15
10002440:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10002444:	edc37a01 	vstr	s15, [r3, #4]
  pT->value[2] = (Vc - Vcom);
10002448:	ed1b7a08 	vldr	s14, [fp, #-32]	; 0xffffffe0
1000244c:	ed5b7a09 	vldr	s15, [fp, #-36]	; 0xffffffdc
10002450:	ee777a67 	vsub.f32	s15, s14, s15
10002454:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10002458:	edc37a02 	vstr	s15, [r3, #8]
  
  return;
1000245c:	e1a00000 	nop			; (mov r0, r0)
} // end of SVGEN_run() function
10002460:	e24bd000 	sub	sp, fp, #0
10002464:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002468:	e12fff1e 	bx	lr
1000246c:	3f5db3d7 	.word	0x3f5db3d7

10002470 <SVGEN_setMaxModulation>:

//! \brief     Sets the maximum modulation in the space vector generator module
//! \param[in] handle         The space vector generator (SVGEN) handle
//! \param[in] maxModulation  The maximum modulation
static inline void SVGEN_setMaxModulation(SVGEN_Handle handle,const float_t maxModulation)
{
10002470:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002474:	e28db000 	add	fp, sp, #0
10002478:	e24dd014 	sub	sp, sp, #20
1000247c:	e50b0010 	str	r0, [fp, #-16]
10002480:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  SVGEN_Obj *obj = (SVGEN_Obj *)handle;
10002484:	e51b3010 	ldr	r3, [fp, #-16]
10002488:	e50b300c 	str	r3, [fp, #-12]
  float_t maxMod = maxModulation;
1000248c:	e51b3014 	ldr	r3, [fp, #-20]
10002490:	e50b3008 	str	r3, [fp, #-8]

  if(maxMod > SVGEN_4_OVER_3)
10002494:	ed5b7a02 	vldr	s15, [fp, #-8]
10002498:	ed9f7a13 	vldr	s14, [pc, #76]	; 100024ec <SVGEN_setMaxModulation+0x7c>
1000249c:	eef47ac7 	vcmpe.f32	s15, s14
100024a0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100024a4:	da000003 	ble	100024b8 <SVGEN_setMaxModulation+0x48>
      maxMod = SVGEN_4_OVER_3;
100024a8:	e30a3aab 	movw	r3, #43691	; 0xaaab
100024ac:	e3433faa 	movt	r3, #16298	; 0x3faa
100024b0:	e50b3008 	str	r3, [fp, #-8]
100024b4:	ea000005 	b	100024d0 <SVGEN_setMaxModulation+0x60>
  else if(maxMod < (0.0f))
100024b8:	ed5b7a02 	vldr	s15, [fp, #-8]
100024bc:	eef57ac0 	vcmpe.f32	s15, #0.0
100024c0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100024c4:	5a000001 	bpl	100024d0 <SVGEN_setMaxModulation+0x60>
      maxMod = (0.0f);
100024c8:	e3a03000 	mov	r3, #0
100024cc:	e50b3008 	str	r3, [fp, #-8]

  obj->maxModulation = maxMod;
100024d0:	e51b300c 	ldr	r3, [fp, #-12]
100024d4:	e51b2008 	ldr	r2, [fp, #-8]
100024d8:	e5832000 	str	r2, [r3]

  return;
100024dc:	e1a00000 	nop			; (mov r0, r0)
} // end of SVGEN_setMaxModulation() function
100024e0:	e24bd000 	sub	sp, fp, #0
100024e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100024e8:	e12fff1e 	bx	lr
100024ec:	3faaaaab 	.word	0x3faaaaab

100024f0 <TRAJ_getIntValue>:

//! \brief     Gets the intermediate value for the trajectory
//! \param[in] handle  The trajectory (TRAJ) handle
//! \return    The intermediate value
static inline float_t TRAJ_getIntValue(TRAJ_Handle handle)
{
100024f0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100024f4:	e28db000 	add	fp, sp, #0
100024f8:	e24dd014 	sub	sp, sp, #20
100024fc:	e50b0010 	str	r0, [fp, #-16]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
10002500:	e51b3010 	ldr	r3, [fp, #-16]
10002504:	e50b3008 	str	r3, [fp, #-8]

  return(obj->intValue);
10002508:	e51b3008 	ldr	r3, [fp, #-8]
1000250c:	e5933004 	ldr	r3, [r3, #4]
10002510:	ee073a90 	vmov	s15, r3
} // end of TRAJ_getIntValue() function
10002514:	eeb00a67 	vmov.f32	s0, s15
10002518:	e24bd000 	sub	sp, fp, #0
1000251c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002520:	e12fff1e 	bx	lr

10002524 <TRAJ_getTargetValue>:

//! \brief     Gets the target value for the trajectory
//! \param[in] handle  The trajectory (TRAJ) handle
//! \return    The target value
static inline float_t TRAJ_getTargetValue(TRAJ_Handle handle)
{
10002524:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002528:	e28db000 	add	fp, sp, #0
1000252c:	e24dd014 	sub	sp, sp, #20
10002530:	e50b0010 	str	r0, [fp, #-16]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
10002534:	e51b3010 	ldr	r3, [fp, #-16]
10002538:	e50b3008 	str	r3, [fp, #-8]

  return(obj->targetValue);
1000253c:	e51b3008 	ldr	r3, [fp, #-8]
10002540:	e5933000 	ldr	r3, [r3]
10002544:	ee073a90 	vmov	s15, r3
} // end of TRAJ_getTargetValue() function
10002548:	eeb00a67 	vmov.f32	s0, s15
1000254c:	e24bd000 	sub	sp, fp, #0
10002550:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002554:	e12fff1e 	bx	lr

10002558 <TRAJ_setIntValue>:

//! \brief     Sets the intermediate value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] intValue  The intermediate value
static inline void TRAJ_setIntValue(TRAJ_Handle handle,const float_t intValue)
{
10002558:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000255c:	e28db000 	add	fp, sp, #0
10002560:	e24dd014 	sub	sp, sp, #20
10002564:	e50b0010 	str	r0, [fp, #-16]
10002568:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
1000256c:	e51b3010 	ldr	r3, [fp, #-16]
10002570:	e50b3008 	str	r3, [fp, #-8]

  obj->intValue = intValue;
10002574:	e51b3008 	ldr	r3, [fp, #-8]
10002578:	e51b2014 	ldr	r2, [fp, #-20]
1000257c:	e5832004 	str	r2, [r3, #4]

  return;
10002580:	e1a00000 	nop			; (mov r0, r0)
} // end of TRAJ_setIntValue() function
10002584:	e24bd000 	sub	sp, fp, #0
10002588:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000258c:	e12fff1e 	bx	lr

10002590 <TRAJ_setMaxDelta>:

//! \brief     Sets the maximum delta value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] maxDelta  The maximum delta value
static inline void TRAJ_setMaxDelta(TRAJ_Handle handle,const float_t maxDelta)
{
10002590:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002594:	e28db000 	add	fp, sp, #0
10002598:	e24dd014 	sub	sp, sp, #20
1000259c:	e50b0010 	str	r0, [fp, #-16]
100025a0:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
100025a4:	e51b3010 	ldr	r3, [fp, #-16]
100025a8:	e50b3008 	str	r3, [fp, #-8]

  obj->maxDelta = maxDelta;
100025ac:	e51b3008 	ldr	r3, [fp, #-8]
100025b0:	e51b2014 	ldr	r2, [fp, #-20]
100025b4:	e5832010 	str	r2, [r3, #16]

  return;
100025b8:	e1a00000 	nop			; (mov r0, r0)
} // end of TRAJ_setMaxDelta() function
100025bc:	e24bd000 	sub	sp, fp, #0
100025c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100025c4:	e12fff1e 	bx	lr

100025c8 <TRAJ_setMaxValue>:

//! \brief     Sets the maximum value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] maxValue  The maximum value
static inline void TRAJ_setMaxValue(TRAJ_Handle handle,const float_t maxValue)
{
100025c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100025cc:	e28db000 	add	fp, sp, #0
100025d0:	e24dd014 	sub	sp, sp, #20
100025d4:	e50b0010 	str	r0, [fp, #-16]
100025d8:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
100025dc:	e51b3010 	ldr	r3, [fp, #-16]
100025e0:	e50b3008 	str	r3, [fp, #-8]

  obj->maxValue = maxValue;
100025e4:	e51b3008 	ldr	r3, [fp, #-8]
100025e8:	e51b2014 	ldr	r2, [fp, #-20]
100025ec:	e583200c 	str	r2, [r3, #12]

  return;
100025f0:	e1a00000 	nop			; (mov r0, r0)
} // end of TRAJ_setMaxValue() function
100025f4:	e24bd000 	sub	sp, fp, #0
100025f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100025fc:	e12fff1e 	bx	lr

10002600 <TRAJ_setMinValue>:

//! \brief     Sets the minimum value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] minValue  The minimum value
static inline void TRAJ_setMinValue(TRAJ_Handle handle,const float_t minValue)
{
10002600:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002604:	e28db000 	add	fp, sp, #0
10002608:	e24dd014 	sub	sp, sp, #20
1000260c:	e50b0010 	str	r0, [fp, #-16]
10002610:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
10002614:	e51b3010 	ldr	r3, [fp, #-16]
10002618:	e50b3008 	str	r3, [fp, #-8]

  obj->minValue = minValue;
1000261c:	e51b3008 	ldr	r3, [fp, #-8]
10002620:	e51b2014 	ldr	r2, [fp, #-20]
10002624:	e5832008 	str	r2, [r3, #8]

  return;
10002628:	e1a00000 	nop			; (mov r0, r0)
} // end of TRAJ_setMinValue() function
1000262c:	e24bd000 	sub	sp, fp, #0
10002630:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002634:	e12fff1e 	bx	lr

10002638 <TRAJ_setTargetValue>:

//! \brief     Sets the target value for the trajectory
//! \param[in] handle       The trajectory (TRAJ) handle
//! \param[in] targetValue  The target value
static inline void TRAJ_setTargetValue(TRAJ_Handle handle,const float_t targetValue)
{
10002638:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000263c:	e28db000 	add	fp, sp, #0
10002640:	e24dd014 	sub	sp, sp, #20
10002644:	e50b0010 	str	r0, [fp, #-16]
10002648:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
1000264c:	e51b3010 	ldr	r3, [fp, #-16]
10002650:	e50b3008 	str	r3, [fp, #-8]

  obj->targetValue = targetValue;
10002654:	e51b3008 	ldr	r3, [fp, #-8]
10002658:	e51b2014 	ldr	r2, [fp, #-20]
1000265c:	e5832000 	str	r2, [r3]

  return;
10002660:	e1a00000 	nop			; (mov r0, r0)
} // end of TRAJ_setTargetValue() function
10002664:	e24bd000 	sub	sp, fp, #0
10002668:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000266c:	e12fff1e 	bx	lr

10002670 <RMP_CNTL_SetRampDelayMax>:
// the functions

extern RMPCNTL_Handle RMP_CNTL_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K

static inline void RMP_CNTL_SetRampDelayMax(RMPCNTL_Handle handle, const uint_least32_t value)//! \Mod By Dl.K
{
10002670:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002674:	e28db000 	add	fp, sp, #0
10002678:	e24dd014 	sub	sp, sp, #20
1000267c:	e50b0010 	str	r0, [fp, #-16]
10002680:	e50b1014 	str	r1, [fp, #-20]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
10002684:	e51b3010 	ldr	r3, [fp, #-16]
10002688:	e50b3008 	str	r3, [fp, #-8]

	obj->RampDelayMax = value;
1000268c:	e51b3008 	ldr	r3, [fp, #-8]
10002690:	e51b2014 	ldr	r2, [fp, #-20]
10002694:	e5832004 	str	r2, [r3, #4]

	return;
10002698:	e1a00000 	nop			; (mov r0, r0)
}
1000269c:	e24bd000 	sub	sp, fp, #0
100026a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100026a4:	e12fff1e 	bx	lr

100026a8 <RMP_CNTL_SetTargetValue>:

static inline void RMP_CNTL_SetTargetValue(RMPCNTL_Handle handle, const float_t target_value)//! \Mod By Dl.K
{
100026a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100026ac:	e28db000 	add	fp, sp, #0
100026b0:	e24dd014 	sub	sp, sp, #20
100026b4:	e50b0010 	str	r0, [fp, #-16]
100026b8:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
100026bc:	e51b3010 	ldr	r3, [fp, #-16]
100026c0:	e50b3008 	str	r3, [fp, #-8]

	obj->TargetValue = target_value;
100026c4:	e51b3008 	ldr	r3, [fp, #-8]
100026c8:	e51b2014 	ldr	r2, [fp, #-20]
100026cc:	e5832000 	str	r2, [r3]

	return;
100026d0:	e1a00000 	nop			; (mov r0, r0)
}
100026d4:	e24bd000 	sub	sp, fp, #0
100026d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100026dc:	e12fff1e 	bx	lr

100026e0 <RMP_CNTL_GetFreq>:

static inline float_t RMP_CNTL_GetFreq(RMPCNTL_Handle handle)//! \Mod By Dl.K
{
100026e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100026e4:	e28db000 	add	fp, sp, #0
100026e8:	e24dd014 	sub	sp, sp, #20
100026ec:	e50b0010 	str	r0, [fp, #-16]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
100026f0:	e51b3010 	ldr	r3, [fp, #-16]
100026f4:	e50b3008 	str	r3, [fp, #-8]

	return (obj->SetpointValue);
100026f8:	e51b3008 	ldr	r3, [fp, #-8]
100026fc:	e5933014 	ldr	r3, [r3, #20]
10002700:	ee073a90 	vmov	s15, r3
}
10002704:	eeb00a67 	vmov.f32	s0, s15
10002708:	e24bd000 	sub	sp, fp, #0
1000270c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002710:	e12fff1e 	bx	lr

10002714 <RMP_CNTL_Run>:
	
	return ;
}

static inline void RMP_CNTL_Run(RMPCNTL_Handle handle)//! \Mod By Dl.K
{
10002714:	e92d4800 	push	{fp, lr}
10002718:	e28db004 	add	fp, sp, #4
1000271c:	e24dd010 	sub	sp, sp, #16
10002720:	e50b0010 	str	r0, [fp, #-16]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
10002724:	e51b3010 	ldr	r3, [fp, #-16]
10002728:	e50b3008 	str	r3, [fp, #-8]

	float_t tmp;

	tmp = obj->TargetValue - obj->SetpointValue;
1000272c:	e51b3008 	ldr	r3, [fp, #-8]
10002730:	ed937a00 	vldr	s14, [r3]
10002734:	e51b3008 	ldr	r3, [fp, #-8]
10002738:	edd37a05 	vldr	s15, [r3, #20]
1000273c:	ee777a67 	vsub.f32	s15, s14, s15
10002740:	ed4b7a03 	vstr	s15, [fp, #-12]

	if (MATH_abs(tmp) > (0.00305f))
10002744:	ed1b0a03 	vldr	s0, [fp, #-12]
10002748:	ebfffcd6 	bl	10001aa8 <MATH_abs>
1000274c:	eeb07a40 	vmov.f32	s14, s0
10002750:	eddf7a44 	vldr	s15, [pc, #272]	; 10002868 <RMP_CNTL_Run+0x154>
10002754:	eeb47ae7 	vcmpe.f32	s14, s15
10002758:	eef1fa10 	vmrs	APSR_nzcv, fpscr
1000275c:	da00003b 	ble	10002850 <RMP_CNTL_Run+0x13c>
	{
		obj->RampDelayCount += 1;
10002760:	e51b3008 	ldr	r3, [fp, #-8]
10002764:	e5933010 	ldr	r3, [r3, #16]
10002768:	e2832001 	add	r2, r3, #1
1000276c:	e51b3008 	ldr	r3, [fp, #-8]
10002770:	e5832010 	str	r2, [r3, #16]
		if (obj->RampDelayCount >= obj->RampDelayMax)
10002774:	e51b3008 	ldr	r3, [fp, #-8]
10002778:	e5932010 	ldr	r2, [r3, #16]
1000277c:	e51b3008 	ldr	r3, [fp, #-8]
10002780:	e5933004 	ldr	r3, [r3, #4]
10002784:	e1520003 	cmp	r2, r3
10002788:	3a000033 	bcc	1000285c <RMP_CNTL_Run+0x148>
		{
			if (obj->TargetValue >= obj->SetpointValue)
1000278c:	e51b3008 	ldr	r3, [fp, #-8]
10002790:	ed937a00 	vldr	s14, [r3]
10002794:	e51b3008 	ldr	r3, [fp, #-8]
10002798:	edd37a05 	vldr	s15, [r3, #20]
1000279c:	eeb47ae7 	vcmpe.f32	s14, s15
100027a0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100027a4:	ba000014 	blt	100027fc <RMP_CNTL_Run+0xe8>
			{
				obj->SetpointValue += (0.00305f);        // 0.0000305 is resolution(1/2^15) of Q15
100027a8:	e51b3008 	ldr	r3, [fp, #-8]
100027ac:	edd37a05 	vldr	s15, [r3, #20]
100027b0:	ed9f7a2c 	vldr	s14, [pc, #176]	; 10002868 <RMP_CNTL_Run+0x154>
100027b4:	ee777a87 	vadd.f32	s15, s15, s14
100027b8:	e51b3008 	ldr	r3, [fp, #-8]
100027bc:	edc37a05 	vstr	s15, [r3, #20]
				if (obj->SetpointValue > obj->RampHighLimit)
100027c0:	e51b3008 	ldr	r3, [fp, #-8]
100027c4:	ed937a05 	vldr	s14, [r3, #20]
100027c8:	e51b3008 	ldr	r3, [fp, #-8]
100027cc:	edd37a03 	vldr	s15, [r3, #12]
100027d0:	eeb47ae7 	vcmpe.f32	s14, s15
100027d4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100027d8:	da000003 	ble	100027ec <RMP_CNTL_Run+0xd8>
					obj->SetpointValue = obj->RampHighLimit;
100027dc:	e51b3008 	ldr	r3, [fp, #-8]
100027e0:	e593200c 	ldr	r2, [r3, #12]
100027e4:	e51b3008 	ldr	r3, [fp, #-8]
100027e8:	e5832014 	str	r2, [r3, #20]
				obj->RampDelayCount = 0;
100027ec:	e51b3008 	ldr	r3, [fp, #-8]
100027f0:	e3a02000 	mov	r2, #0
100027f4:	e5832010 	str	r2, [r3, #16]
100027f8:	ea000017 	b	1000285c <RMP_CNTL_Run+0x148>
			}
			else
			{
				obj->SetpointValue -= (0.00305f);        // 0.0000305 is resolution of Q15
100027fc:	e51b3008 	ldr	r3, [fp, #-8]
10002800:	edd37a05 	vldr	s15, [r3, #20]
10002804:	ed9f7a17 	vldr	s14, [pc, #92]	; 10002868 <RMP_CNTL_Run+0x154>
10002808:	ee777ac7 	vsub.f32	s15, s15, s14
1000280c:	e51b3008 	ldr	r3, [fp, #-8]
10002810:	edc37a05 	vstr	s15, [r3, #20]
				if (obj->SetpointValue < obj->RampLowLimit)
10002814:	e51b3008 	ldr	r3, [fp, #-8]
10002818:	ed937a05 	vldr	s14, [r3, #20]
1000281c:	e51b3008 	ldr	r3, [fp, #-8]
10002820:	edd37a02 	vldr	s15, [r3, #8]
10002824:	eeb47ae7 	vcmpe.f32	s14, s15
10002828:	eef1fa10 	vmrs	APSR_nzcv, fpscr
1000282c:	5a000003 	bpl	10002840 <RMP_CNTL_Run+0x12c>
					obj->SetpointValue = obj->RampLowLimit;
10002830:	e51b3008 	ldr	r3, [fp, #-8]
10002834:	e5932008 	ldr	r2, [r3, #8]
10002838:	e51b3008 	ldr	r3, [fp, #-8]
1000283c:	e5832014 	str	r2, [r3, #20]
				obj->RampDelayCount = 0;
10002840:	e51b3008 	ldr	r3, [fp, #-8]
10002844:	e3a02000 	mov	r2, #0
10002848:	e5832010 	str	r2, [r3, #16]
			}
		}
	}
	else  obj->EqualFlag = 0x7FFFFFFF;
	return;
1000284c:	ea000003 	b	10002860 <RMP_CNTL_Run+0x14c>
					obj->SetpointValue = obj->RampLowLimit;
				obj->RampDelayCount = 0;
			}
		}
	}
	else  obj->EqualFlag = 0x7FFFFFFF;
10002850:	e51b3008 	ldr	r3, [fp, #-8]
10002854:	e3e02102 	mvn	r2, #-2147483648	; 0x80000000
10002858:	e5832018 	str	r2, [r3, #24]
	return;
1000285c:	e1a00000 	nop			; (mov r0, r0)
}
10002860:	e24bd004 	sub	sp, fp, #4
10002864:	e8bd8800 	pop	{fp, pc}
10002868:	3b47e282 	.word	0x3b47e282

1000286c <RAMPGEN_GetAngleOut>:
// the functions

extern RAMPGEN_Handle RAMPGEN_Init(void *pMemory, const size_t numBytes);

static inline float_t RAMPGEN_GetAngleOut(RAMPGEN_Handle handle)//! \Mod By Dl.K
{
1000286c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002870:	e28db000 	add	fp, sp, #0
10002874:	e24dd014 	sub	sp, sp, #20
10002878:	e50b0010 	str	r0, [fp, #-16]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
1000287c:	e51b3010 	ldr	r3, [fp, #-16]
10002880:	e50b3008 	str	r3, [fp, #-8]

	return (obj->Out);
10002884:	e51b3008 	ldr	r3, [fp, #-8]
10002888:	e5933010 	ldr	r3, [r3, #16]
1000288c:	ee073a90 	vmov	s15, r3
}
10002890:	eeb00a67 	vmov.f32	s0, s15
10002894:	e24bd000 	sub	sp, fp, #0
10002898:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000289c:	e12fff1e 	bx	lr

100028a0 <RAMPGEN_SetFreq>:

static inline void RAMPGEN_SetFreq(RAMPGEN_Handle handle, const float_t freq)//! \Mod By Dl.K
{
100028a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100028a4:	e28db000 	add	fp, sp, #0
100028a8:	e24dd014 	sub	sp, sp, #20
100028ac:	e50b0010 	str	r0, [fp, #-16]
100028b0:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
100028b4:	e51b3010 	ldr	r3, [fp, #-16]
100028b8:	e50b3008 	str	r3, [fp, #-8]

	obj->Freq = freq;
100028bc:	e51b3008 	ldr	r3, [fp, #-8]
100028c0:	e51b2014 	ldr	r2, [fp, #-20]
100028c4:	e5832000 	str	r2, [r3]

	return;
100028c8:	e1a00000 	nop			; (mov r0, r0)
}
100028cc:	e24bd000 	sub	sp, fp, #0
100028d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100028d4:	e12fff1e 	bx	lr

100028d8 <RAMPGEN_SetStepAngleMax>:

static inline void RAMPGEN_SetStepAngleMax(RAMPGEN_Handle handle, const float_t step_angle_max)//! \Mod By Dl.K
{
100028d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100028dc:	e28db000 	add	fp, sp, #0
100028e0:	e24dd014 	sub	sp, sp, #20
100028e4:	e50b0010 	str	r0, [fp, #-16]
100028e8:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
100028ec:	e51b3010 	ldr	r3, [fp, #-16]
100028f0:	e50b3008 	str	r3, [fp, #-8]

	obj->StepAngleMax = step_angle_max;
100028f4:	e51b3008 	ldr	r3, [fp, #-8]
100028f8:	e51b2014 	ldr	r2, [fp, #-20]
100028fc:	e5832004 	str	r2, [r3, #4]

	return;
10002900:	e1a00000 	nop			; (mov r0, r0)
}
10002904:	e24bd000 	sub	sp, fp, #0
10002908:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000290c:	e12fff1e 	bx	lr

10002910 <RAMPGEN_SetAngleOffset>:

static inline void RAMPGEN_SetAngleOffset(RAMPGEN_Handle handle, const float_t offset)//! \Mod By Dl.K
{
10002910:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002914:	e28db000 	add	fp, sp, #0
10002918:	e24dd014 	sub	sp, sp, #20
1000291c:	e50b0010 	str	r0, [fp, #-16]
10002920:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
10002924:	e51b3010 	ldr	r3, [fp, #-16]
10002928:	e50b3008 	str	r3, [fp, #-8]

	obj->Offset = offset;
1000292c:	e51b3008 	ldr	r3, [fp, #-8]
10002930:	e51b2014 	ldr	r2, [fp, #-20]
10002934:	e5832014 	str	r2, [r3, #20]

	return;
10002938:	e1a00000 	nop			; (mov r0, r0)
}
1000293c:	e24bd000 	sub	sp, fp, #0
10002940:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002944:	e12fff1e 	bx	lr

10002948 <RAMPGEN_Run>:

static inline void RAMPGEN_Run(RAMPGEN_Handle handle)//! \Mod By Dl.K
{
10002948:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000294c:	e28db000 	add	fp, sp, #0
10002950:	e24dd014 	sub	sp, sp, #20
10002954:	e50b0010 	str	r0, [fp, #-16]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
10002958:	e51b3010 	ldr	r3, [fp, #-16]
1000295c:	e50b3008 	str	r3, [fp, #-8]

	// Compute the angle rate
	//obj->Angle += (obj->StepAngleMax * obj->Freq);
	obj->Angle += (0.00008 * obj->Freq);
10002960:	e51b3008 	ldr	r3, [fp, #-8]
10002964:	edd37a02 	vldr	s15, [r3, #8]
10002968:	eef71ae7 	vcvt.f64.f32	d17, s15
1000296c:	e51b3008 	ldr	r3, [fp, #-8]
10002970:	edd37a00 	vldr	s15, [r3]
10002974:	eef70ae7 	vcvt.f64.f32	d16, s15
10002978:	eddf2b46 	vldr	d18, [pc, #280]	; 10002a98 <RAMPGEN_Run+0x150>
1000297c:	ee600ba2 	vmul.f64	d16, d16, d18
10002980:	ee710ba0 	vadd.f64	d16, d17, d16
10002984:	eef77be0 	vcvt.f32.f64	s15, d16
10002988:	e51b3008 	ldr	r3, [fp, #-8]
1000298c:	edc37a02 	vstr	s15, [r3, #8]

	// Saturate the angle rate within (-1,1)        
	if (obj->Angle>(1.0f))
10002990:	e51b3008 	ldr	r3, [fp, #-8]
10002994:	edd37a02 	vldr	s15, [r3, #8]
10002998:	eeb77a00 	vmov.f32	s14, #112	; 0x70
1000299c:	eef47ac7 	vcmpe.f32	s15, s14
100029a0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100029a4:	da000006 	ble	100029c4 <RAMPGEN_Run+0x7c>
		obj->Angle -= (1.0f);
100029a8:	e51b3008 	ldr	r3, [fp, #-8]
100029ac:	edd37a02 	vldr	s15, [r3, #8]
100029b0:	eeb77a00 	vmov.f32	s14, #112	; 0x70
100029b4:	ee777ac7 	vsub.f32	s15, s15, s14
100029b8:	e51b3008 	ldr	r3, [fp, #-8]
100029bc:	edc37a02 	vstr	s15, [r3, #8]
100029c0:	ea00000b 	b	100029f4 <RAMPGEN_Run+0xac>
	else if (obj->Angle<(-1.0f))
100029c4:	e51b3008 	ldr	r3, [fp, #-8]
100029c8:	edd37a02 	vldr	s15, [r3, #8]
100029cc:	eebf7a00 	vmov.f32	s14, #240	; 0xf0
100029d0:	eef47ac7 	vcmpe.f32	s15, s14
100029d4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
100029d8:	5a000005 	bpl	100029f4 <RAMPGEN_Run+0xac>
		obj->Angle += (1.0f);
100029dc:	e51b3008 	ldr	r3, [fp, #-8]
100029e0:	edd37a02 	vldr	s15, [r3, #8]
100029e4:	eeb77a00 	vmov.f32	s14, #112	; 0x70
100029e8:	ee777a87 	vadd.f32	s15, s15, s14
100029ec:	e51b3008 	ldr	r3, [fp, #-8]
100029f0:	edc37a02 	vstr	s15, [r3, #8]

	// Compute the ramp output
	obj->Out = (obj->Angle * obj->Gain) + obj->Offset;//offset 0.75,gain 1.0
100029f4:	e51b3008 	ldr	r3, [fp, #-8]
100029f8:	ed937a02 	vldr	s14, [r3, #8]
100029fc:	e51b3008 	ldr	r3, [fp, #-8]
10002a00:	edd37a03 	vldr	s15, [r3, #12]
10002a04:	ee277a27 	vmul.f32	s14, s14, s15
10002a08:	e51b3008 	ldr	r3, [fp, #-8]
10002a0c:	edd37a05 	vldr	s15, [r3, #20]
10002a10:	ee777a27 	vadd.f32	s15, s14, s15
10002a14:	e51b3008 	ldr	r3, [fp, #-8]
10002a18:	edc37a04 	vstr	s15, [r3, #16]

	// Saturate the ramp output within (-1,1)     
	if (obj->Out>(1.0f))
10002a1c:	e51b3008 	ldr	r3, [fp, #-8]
10002a20:	edd37a04 	vldr	s15, [r3, #16]
10002a24:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10002a28:	eef47ac7 	vcmpe.f32	s15, s14
10002a2c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10002a30:	da000006 	ble	10002a50 <RAMPGEN_Run+0x108>
		obj->Out -= (1.0f);
10002a34:	e51b3008 	ldr	r3, [fp, #-8]
10002a38:	edd37a04 	vldr	s15, [r3, #16]
10002a3c:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10002a40:	ee777ac7 	vsub.f32	s15, s15, s14
10002a44:	e51b3008 	ldr	r3, [fp, #-8]
10002a48:	edc37a04 	vstr	s15, [r3, #16]
10002a4c:	ea00000c 	b	10002a84 <RAMPGEN_Run+0x13c>
	else if (obj->Out<(-1.0f))
10002a50:	e51b3008 	ldr	r3, [fp, #-8]
10002a54:	edd37a04 	vldr	s15, [r3, #16]
10002a58:	eebf7a00 	vmov.f32	s14, #240	; 0xf0
10002a5c:	eef47ac7 	vcmpe.f32	s15, s14
10002a60:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10002a64:	4a000000 	bmi	10002a6c <RAMPGEN_Run+0x124>
		obj->Out += (1.0f);

	return;
10002a68:	ea000006 	b	10002a88 <RAMPGEN_Run+0x140>

	// Saturate the ramp output within (-1,1)     
	if (obj->Out>(1.0f))
		obj->Out -= (1.0f);
	else if (obj->Out<(-1.0f))
		obj->Out += (1.0f);
10002a6c:	e51b3008 	ldr	r3, [fp, #-8]
10002a70:	edd37a04 	vldr	s15, [r3, #16]
10002a74:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10002a78:	ee777a87 	vadd.f32	s15, s15, s14
10002a7c:	e51b3008 	ldr	r3, [fp, #-8]
10002a80:	edc37a04 	vstr	s15, [r3, #16]

	return;
10002a84:	e1a00000 	nop			; (mov r0, r0)
}
10002a88:	e24bd000 	sub	sp, fp, #0
10002a8c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002a90:	e12fff1e 	bx	lr
10002a94:	e320f000 	nop	{0}
10002a98:	88e368f1 	.word	0x88e368f1
10002a9c:	3f14f8b5 	.word	0x3f14f8b5

10002aa0 <INITPOSDET_GetInitPosAngle>:
// the functions

extern INITPOSDET_Handle INITPOSDET_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K

static inline float_t INITPOSDET_GetInitPosAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
10002aa0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002aa4:	e28db000 	add	fp, sp, #0
10002aa8:	e24dd014 	sub	sp, sp, #20
10002aac:	e50b0010 	str	r0, [fp, #-16]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
10002ab0:	e51b3010 	ldr	r3, [fp, #-16]
10002ab4:	e50b3008 	str	r3, [fp, #-8]

	return (obj->InitPosAngle);
10002ab8:	e51b3008 	ldr	r3, [fp, #-8]
10002abc:	e5933004 	ldr	r3, [r3, #4]
10002ac0:	ee073a90 	vmov	s15, r3
}
10002ac4:	eeb00a67 	vmov.f32	s0, s15
10002ac8:	e24bd000 	sub	sp, fp, #0
10002acc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002ad0:	e12fff1e 	bx	lr

10002ad4 <INITPOSDET_GetVolVecAngleFlag>:

static inline uint16_t INITPOSDET_GetVolVecAngleFlag(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
10002ad4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002ad8:	e28db000 	add	fp, sp, #0
10002adc:	e24dd014 	sub	sp, sp, #20
10002ae0:	e50b0010 	str	r0, [fp, #-16]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
10002ae4:	e51b3010 	ldr	r3, [fp, #-16]
10002ae8:	e50b3008 	str	r3, [fp, #-8]

	return (obj->VolVecAngleFlag);
10002aec:	e51b3008 	ldr	r3, [fp, #-8]
10002af0:	e1d330bc 	ldrh	r3, [r3, #12]
}
10002af4:	e1a00003 	mov	r0, r3
10002af8:	e24bd000 	sub	sp, fp, #0
10002afc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002b00:	e12fff1e 	bx	lr

10002b04 <INITPOSDET_GetVolVecAngle>:

static inline float_t INITPOSDET_GetVolVecAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
10002b04:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002b08:	e28db000 	add	fp, sp, #0
10002b0c:	e24dd014 	sub	sp, sp, #20
10002b10:	e50b0010 	str	r0, [fp, #-16]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
10002b14:	e51b3010 	ldr	r3, [fp, #-16]
10002b18:	e50b3008 	str	r3, [fp, #-8]

	return (obj->VolVecAngle);
10002b1c:	e51b3008 	ldr	r3, [fp, #-8]
10002b20:	e5933010 	ldr	r3, [r3, #16]
10002b24:	ee073a90 	vmov	s15, r3
}
10002b28:	eeb00a67 	vmov.f32	s0, s15
10002b2c:	e24bd000 	sub	sp, fp, #0
10002b30:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002b34:	e12fff1e 	bx	lr

10002b38 <INITPOSDET_GetIdSampAngle>:

static inline float_t INITPOSDET_GetIdSampAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
10002b38:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002b3c:	e28db000 	add	fp, sp, #0
10002b40:	e24dd014 	sub	sp, sp, #20
10002b44:	e50b0010 	str	r0, [fp, #-16]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
10002b48:	e51b3010 	ldr	r3, [fp, #-16]
10002b4c:	e50b3008 	str	r3, [fp, #-8]

	return (obj->IdSampAngle);
10002b50:	e51b3008 	ldr	r3, [fp, #-8]
10002b54:	e593301c 	ldr	r3, [r3, #28]
10002b58:	ee073a90 	vmov	s15, r3
}
10002b5c:	eeb00a67 	vmov.f32	s0, s15
10002b60:	e24bd000 	sub	sp, fp, #0
10002b64:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002b68:	e12fff1e 	bx	lr

10002b6c <INITPOSDET_GetIdSampAngleFlag>:

static inline uint16_t INITPOSDET_GetIdSampAngleFlag(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
10002b6c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002b70:	e28db000 	add	fp, sp, #0
10002b74:	e24dd014 	sub	sp, sp, #20
10002b78:	e50b0010 	str	r0, [fp, #-16]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
10002b7c:	e51b3010 	ldr	r3, [fp, #-16]
10002b80:	e50b3008 	str	r3, [fp, #-8]

	return (obj->IdSampAngleFlag);
10002b84:	e51b3008 	ldr	r3, [fp, #-8]
10002b88:	e1d331ba 	ldrh	r3, [r3, #26]
}
10002b8c:	e1a00003 	mov	r0, r3
10002b90:	e24bd000 	sub	sp, fp, #0
10002b94:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002b98:	e12fff1e 	bx	lr

10002b9c <Speed_SetTurnCount>:
// the functions
extern SPEED_Handle Speed_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K


static inline void Speed_SetTurnCount(SPEED_Handle handle, int turn_cnt)//! \Mod By Dl.K
{
10002b9c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002ba0:	e28db000 	add	fp, sp, #0
10002ba4:	e24dd014 	sub	sp, sp, #20
10002ba8:	e50b0010 	str	r0, [fp, #-16]
10002bac:	e50b1014 	str	r1, [fp, #-20]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
10002bb0:	e51b3010 	ldr	r3, [fp, #-16]
10002bb4:	e50b3008 	str	r3, [fp, #-8]
	obj->turn_cnt = turn_cnt;
10002bb8:	e51b3008 	ldr	r3, [fp, #-8]
10002bbc:	e51b2014 	ldr	r2, [fp, #-20]
10002bc0:	e583201c 	str	r2, [r3, #28]

	return;
10002bc4:	e1a00000 	nop			; (mov r0, r0)
}
10002bc8:	e24bd000 	sub	sp, fp, #0
10002bcc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002bd0:	e12fff1e 	bx	lr

10002bd4 <Speed_SetElecTheta>:
static inline void Speed_SetElecTheta(SPEED_Handle handle, float_t theta)//! \Mod By Dl.K
{
10002bd4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002bd8:	e28db000 	add	fp, sp, #0
10002bdc:	e24dd014 	sub	sp, sp, #20
10002be0:	e50b0010 	str	r0, [fp, #-16]
10002be4:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
	SPEED_Obj *obj = (SPEED_Obj *)handle;
10002be8:	e51b3010 	ldr	r3, [fp, #-16]
10002bec:	e50b3008 	str	r3, [fp, #-8]
	obj->ElecTheta = theta;
10002bf0:	e51b3008 	ldr	r3, [fp, #-8]
10002bf4:	e51b2014 	ldr	r2, [fp, #-20]
10002bf8:	e5832000 	str	r2, [r3]

	return;
10002bfc:	e1a00000 	nop			; (mov r0, r0)
}
10002c00:	e24bd000 	sub	sp, fp, #0
10002c04:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002c08:	e12fff1e 	bx	lr

10002c0c <Speed_SetElecFilterSpeedRatio>:

static inline void Speed_SetElecFilterSpeedRatio(SPEED_Handle handle, float_t ratio)//! \Mod By Dl.K
{
10002c0c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002c10:	e28db000 	add	fp, sp, #0
10002c14:	e24dd014 	sub	sp, sp, #20
10002c18:	e50b0010 	str	r0, [fp, #-16]
10002c1c:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
	SPEED_Obj *obj = (SPEED_Obj *)handle;
10002c20:	e51b3010 	ldr	r3, [fp, #-16]
10002c24:	e50b3008 	str	r3, [fp, #-8]

	obj->ElecFilterSpeedRatio = ratio;
10002c28:	e51b3008 	ldr	r3, [fp, #-8]
10002c2c:	e51b2014 	ldr	r2, [fp, #-20]
10002c30:	e5832014 	str	r2, [r3, #20]

	return;
10002c34:	e1a00000 	nop			; (mov r0, r0)
}
10002c38:	e24bd000 	sub	sp, fp, #0
10002c3c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002c40:	e12fff1e 	bx	lr

10002c44 <Speed_SetElecThetaChagTimeRatio>:

static inline void Speed_SetElecThetaChagTimeRatio(SPEED_Handle handle, float_t ratio)//! \Mod By Dl.K
{
10002c44:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002c48:	e28db000 	add	fp, sp, #0
10002c4c:	e24dd014 	sub	sp, sp, #20
10002c50:	e50b0010 	str	r0, [fp, #-16]
10002c54:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
	SPEED_Obj *obj = (SPEED_Obj *)handle;
10002c58:	e51b3010 	ldr	r3, [fp, #-16]
10002c5c:	e50b3008 	str	r3, [fp, #-8]

	obj->ElecThetaChagTimeRatio = ratio;
10002c60:	e51b3008 	ldr	r3, [fp, #-8]
10002c64:	e51b2014 	ldr	r2, [fp, #-20]
10002c68:	e5832008 	str	r2, [r3, #8]

	return;
10002c6c:	e1a00000 	nop			; (mov r0, r0)
}
10002c70:	e24bd000 	sub	sp, fp, #0
10002c74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002c78:	e12fff1e 	bx	lr

10002c7c <Speed_UpdateElecTheta>:

static inline void Speed_UpdateElecTheta(SPEED_Handle handle)//! \Mod By Dl.K
{
10002c7c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002c80:	e28db000 	add	fp, sp, #0
10002c84:	e24dd014 	sub	sp, sp, #20
10002c88:	e50b0010 	str	r0, [fp, #-16]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
10002c8c:	e51b3010 	ldr	r3, [fp, #-16]
10002c90:	e50b3008 	str	r3, [fp, #-8]

	obj->OldElecTheta = obj->ElecTheta;
10002c94:	e51b3008 	ldr	r3, [fp, #-8]
10002c98:	e5932000 	ldr	r2, [r3]
10002c9c:	e51b3008 	ldr	r3, [fp, #-8]
10002ca0:	e5832004 	str	r2, [r3, #4]

	return;
10002ca4:	e1a00000 	nop			; (mov r0, r0)
}
10002ca8:	e24bd000 	sub	sp, fp, #0
10002cac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002cb0:	e12fff1e 	bx	lr

10002cb4 <Speed_GetElecSpeed>:

	return;
}

static inline float_t Speed_GetElecSpeed(SPEED_Handle handle)//! \Mod By Dl.K
{
10002cb4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002cb8:	e28db000 	add	fp, sp, #0
10002cbc:	e24dd014 	sub	sp, sp, #20
10002cc0:	e50b0010 	str	r0, [fp, #-16]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
10002cc4:	e51b3010 	ldr	r3, [fp, #-16]
10002cc8:	e50b3008 	str	r3, [fp, #-8]

	return( obj->ElecSpeed );
10002ccc:	e51b3008 	ldr	r3, [fp, #-8]
10002cd0:	e593300c 	ldr	r3, [r3, #12]
10002cd4:	ee073a90 	vmov	s15, r3
}
10002cd8:	eeb00a67 	vmov.f32	s0, s15
10002cdc:	e24bd000 	sub	sp, fp, #0
10002ce0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002ce4:	e12fff1e 	bx	lr

10002ce8 <HAL_runOffsetEst>:
//!             speed performance of the motor drive.
//! \param[in]  handle    The hardware abstraction layer (HAL) handle
//! \param[in]  pAdcData  The pointer to the ADC data

static inline void HAL_runOffsetEst(HAL_Handle handle,const HAL_AdcData_t *pAdcData)
{
10002ce8:	e92d4800 	push	{fp, lr}
10002cec:	e28db004 	add	fp, sp, #4
10002cf0:	e24dd010 	sub	sp, sp, #16
10002cf4:	e50b0010 	str	r0, [fp, #-16]
10002cf8:	e50b1014 	str	r1, [fp, #-20]
  	unsigned char cnt;
  	HAL_Obj *obj = (HAL_Obj *)handle;
10002cfc:	e51b3010 	ldr	r3, [fp, #-16]
10002d00:	e50b300c 	str	r3, [fp, #-12]


  // estimate the current offsets
  	for(cnt=0;cnt<obj->numCurrentSensors;cnt++)
10002d04:	e3a03000 	mov	r3, #0
10002d08:	e54b3005 	strb	r3, [fp, #-5]
10002d0c:	ea00000d 	b	10002d48 <HAL_runOffsetEst+0x60>
    {
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
10002d10:	e55b2005 	ldrb	r2, [fp, #-5]
10002d14:	e51b300c 	ldr	r3, [fp, #-12]
10002d18:	e7931102 	ldr	r1, [r3, r2, lsl #2]
10002d1c:	e55b3005 	ldrb	r3, [fp, #-5]
10002d20:	e51b2014 	ldr	r2, [fp, #-20]
10002d24:	e1a03103 	lsl	r3, r3, #2
10002d28:	e0823003 	add	r3, r2, r3
10002d2c:	edd37a00 	vldr	s15, [r3]
10002d30:	e1a00001 	mov	r0, r1
10002d34:	eeb00a67 	vmov.f32	s0, s15
10002d38:	ebfffc95 	bl	10001f94 <OFFSET_run>
  	unsigned char cnt;
  	HAL_Obj *obj = (HAL_Obj *)handle;


  // estimate the current offsets
  	for(cnt=0;cnt<obj->numCurrentSensors;cnt++)
10002d3c:	e55b3005 	ldrb	r3, [fp, #-5]
10002d40:	e2833001 	add	r3, r3, #1
10002d44:	e54b3005 	strb	r3, [fp, #-5]
10002d48:	e51b300c 	ldr	r3, [fp, #-12]
10002d4c:	e5d33104 	ldrb	r3, [r3, #260]	; 0x104
10002d50:	e55b2005 	ldrb	r2, [fp, #-5]
10002d54:	e1520003 	cmp	r2, r3
10002d58:	3affffec 	bcc	10002d10 <HAL_runOffsetEst+0x28>
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
    }


  // estimate the voltage offsets
  	for(cnt=0;cnt<obj->numVoltageSensors;cnt++)
10002d5c:	e3a03000 	mov	r3, #0
10002d60:	e54b3005 	strb	r3, [fp, #-5]
10002d64:	ea000011 	b	10002db0 <HAL_runOffsetEst+0xc8>
    {
    	OFFSET_run(obj->offsetHandle_V[cnt],pAdcData->V.value[cnt]);
10002d68:	e55b3005 	ldrb	r3, [fp, #-5]
10002d6c:	e51b200c 	ldr	r2, [fp, #-12]
10002d70:	e283301a 	add	r3, r3, #26
10002d74:	e1a03103 	lsl	r3, r3, #2
10002d78:	e0823003 	add	r3, r2, r3
10002d7c:	e5931004 	ldr	r1, [r3, #4]
10002d80:	e55b3005 	ldrb	r3, [fp, #-5]
10002d84:	e51b2014 	ldr	r2, [fp, #-20]
10002d88:	e2833002 	add	r3, r3, #2
10002d8c:	e1a03103 	lsl	r3, r3, #2
10002d90:	e0823003 	add	r3, r2, r3
10002d94:	edd37a01 	vldr	s15, [r3, #4]
10002d98:	e1a00001 	mov	r0, r1
10002d9c:	eeb00a67 	vmov.f32	s0, s15
10002da0:	ebfffc7b 	bl	10001f94 <OFFSET_run>
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
    }


  // estimate the voltage offsets
  	for(cnt=0;cnt<obj->numVoltageSensors;cnt++)
10002da4:	e55b3005 	ldrb	r3, [fp, #-5]
10002da8:	e2833001 	add	r3, r3, #1
10002dac:	e54b3005 	strb	r3, [fp, #-5]
10002db0:	e51b300c 	ldr	r3, [fp, #-12]
10002db4:	e5d33105 	ldrb	r3, [r3, #261]	; 0x105
10002db8:	e55b2005 	ldrb	r2, [fp, #-5]
10002dbc:	e1520003 	cmp	r2, r3
10002dc0:	3affffe8 	bcc	10002d68 <HAL_runOffsetEst+0x80>
    {
    	OFFSET_run(obj->offsetHandle_V[cnt],pAdcData->V.value[cnt]);
    }

  	return;
10002dc4:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_runOffsetEst() function
10002dc8:	e24bd004 	sub	sp, fp, #4
10002dcc:	e8bd8800 	pop	{fp, pc}

10002dd0 <CTRL_getCount_isr>:

//! \brief      Gets the isr count
//! \param[in]  handle  The controller (CTRL) handle
//! \return    The isr count
static inline uint_least16_t CTRL_getCount_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
10002dd0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002dd4:	e28db000 	add	fp, sp, #0
10002dd8:	e24dd014 	sub	sp, sp, #20
10002ddc:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002de0:	e51b3010 	ldr	r3, [fp, #-16]
10002de4:	e50b3008 	str	r3, [fp, #-8]

  return(obj->counter_isr);
10002de8:	e51b3008 	ldr	r3, [fp, #-8]
10002dec:	e2833f7b 	add	r3, r3, #492	; 0x1ec
10002df0:	e2833002 	add	r3, r3, #2
10002df4:	e1d330b0 	ldrh	r3, [r3]
} // end of CTRL_getCount_isr() function
10002df8:	e1a00003 	mov	r0, r3
10002dfc:	e24bd000 	sub	sp, fp, #0
10002e00:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002e04:	e12fff1e 	bx	lr

10002e08 <CTRL_getCount_state>:

//! \brief      Gets the state count 
//! \param[in]  handle  The controller (CTRL) handle
//! \return     The state count
static inline uint_least32_t CTRL_getCount_state(CTRL_Handle handle)//! \Mod By Dl.K
{
10002e08:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002e0c:	e28db000 	add	fp, sp, #0
10002e10:	e24dd014 	sub	sp, sp, #20
10002e14:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002e18:	e51b3010 	ldr	r3, [fp, #-16]
10002e1c:	e50b3008 	str	r3, [fp, #-8]

  return(obj->counter_state);
10002e20:	e51b3008 	ldr	r3, [fp, #-8]
10002e24:	e5933148 	ldr	r3, [r3, #328]	; 0x148
} // end of CTRL_getCount_state() function
10002e28:	e1a00003 	mov	r0, r3
10002e2c:	e24bd000 	sub	sp, fp, #0
10002e30:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002e34:	e12fff1e 	bx	lr

10002e38 <CTRL_getCount_traj>:

//! \brief      Gets the trajectory loop count
//! \param[in]  handle  The controller (CTRL) handle
//! \return     The trajectory loop count
static inline uint_least16_t CTRL_getCount_traj(CTRL_Handle handle)//! \Mod By Dl.K
{
10002e38:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002e3c:	e28db000 	add	fp, sp, #0
10002e40:	e24dd014 	sub	sp, sp, #20
10002e44:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002e48:	e51b3010 	ldr	r3, [fp, #-16]
10002e4c:	e50b3008 	str	r3, [fp, #-8]

  return(obj->counter_traj);
10002e50:	e51b3008 	ldr	r3, [fp, #-8]
10002e54:	e2833e1f 	add	r3, r3, #496	; 0x1f0
10002e58:	e2833002 	add	r3, r3, #2
10002e5c:	e1d330b0 	ldrh	r3, [r3]
} // end of CTRL_getCount_traj() function
10002e60:	e1a00003 	mov	r0, r3
10002e64:	e24bd000 	sub	sp, fp, #0
10002e68:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002e6c:	e12fff1e 	bx	lr

10002e70 <CTRL_getFlag_enableCtrl>:

//! \brief     Gets the enable controller flag value from the estimator
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable controller flag value
static inline bool CTRL_getFlag_enableCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
10002e70:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002e74:	e28db000 	add	fp, sp, #0
10002e78:	e24dd014 	sub	sp, sp, #20
10002e7c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002e80:	e51b3010 	ldr	r3, [fp, #-16]
10002e84:	e50b3008 	str	r3, [fp, #-8]

  return(obj->flag_enableCtrl);
10002e88:	e51b3008 	ldr	r3, [fp, #-8]
10002e8c:	e5d331f4 	ldrb	r3, [r3, #500]	; 0x1f4
} // end of CTRL_getFlag_enableCtrl() function
10002e90:	e1a00003 	mov	r0, r3
10002e94:	e24bd000 	sub	sp, fp, #0
10002e98:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002e9c:	e12fff1e 	bx	lr

10002ea0 <CTRL_getFlag_enableCurrentCtrl>:

//! \brief     Gets the enable current controllers flag value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable current controller flag value
static inline bool CTRL_getFlag_enableCurrentCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
10002ea0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002ea4:	e28db000 	add	fp, sp, #0
10002ea8:	e24dd014 	sub	sp, sp, #20
10002eac:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002eb0:	e51b3010 	ldr	r3, [fp, #-16]
10002eb4:	e50b3008 	str	r3, [fp, #-8]

  return(obj->flag_enableCurrentCtrl);
10002eb8:	e51b3008 	ldr	r3, [fp, #-8]
10002ebc:	e5d33220 	ldrb	r3, [r3, #544]	; 0x220
} // end of CTRL_getFlag_enableCurrentCtrl() function
10002ec0:	e1a00003 	mov	r0, r3
10002ec4:	e24bd000 	sub	sp, fp, #0
10002ec8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002ecc:	e12fff1e 	bx	lr

10002ed0 <CTRL_getFlag_enableOffset>:

//! \brief     Gets the enable offset flag value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable offset flag value
static inline bool CTRL_getFlag_enableOffset(CTRL_Handle handle)//! \Mod By Dl.K
{
10002ed0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002ed4:	e28db000 	add	fp, sp, #0
10002ed8:	e24dd014 	sub	sp, sp, #20
10002edc:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002ee0:	e51b3010 	ldr	r3, [fp, #-16]
10002ee4:	e50b3008 	str	r3, [fp, #-8]

  return(obj->flag_enableOffset);
10002ee8:	e51b3008 	ldr	r3, [fp, #-8]
10002eec:	e5d331f7 	ldrb	r3, [r3, #503]	; 0x1f7
} // end of CTRL_getFlag_enableOffset() function
10002ef0:	e1a00003 	mov	r0, r3
10002ef4:	e24bd000 	sub	sp, fp, #0
10002ef8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002efc:	e12fff1e 	bx	lr

10002f00 <CTRL_getFlag_enableSpeedCtrl>:

//! \brief     Gets the enable speed control flag value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable speed control flag value
static inline bool CTRL_getFlag_enableSpeedCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
10002f00:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002f04:	e28db000 	add	fp, sp, #0
10002f08:	e24dd014 	sub	sp, sp, #20
10002f0c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002f10:	e51b3010 	ldr	r3, [fp, #-16]
10002f14:	e50b3008 	str	r3, [fp, #-8]

  return(obj->flag_enableSpeedCtrl);
10002f18:	e51b3008 	ldr	r3, [fp, #-8]
10002f1c:	e5d331f8 	ldrb	r3, [r3, #504]	; 0x1f8
} // end of CTRL_getFlag_enableSpeedCtrl() function
10002f20:	e1a00003 	mov	r0, r3
10002f24:	e24bd000 	sub	sp, fp, #0
10002f28:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002f2c:	e12fff1e 	bx	lr

10002f30 <CTRL_getFlag_enableUserMotorParams>:

//! \brief     Gets the enable user motor parameters flag value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable user motor parameters flag value
static inline bool CTRL_getFlag_enableUserMotorParams(CTRL_Handle handle)//! \Mod By Dl.K
{
10002f30:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002f34:	e28db000 	add	fp, sp, #0
10002f38:	e24dd014 	sub	sp, sp, #20
10002f3c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002f40:	e51b3010 	ldr	r3, [fp, #-16]
10002f44:	e50b3008 	str	r3, [fp, #-8]

  return(obj->flag_enableUserMotorParams);
10002f48:	e51b3008 	ldr	r3, [fp, #-8]
10002f4c:	e5d331f9 	ldrb	r3, [r3, #505]	; 0x1f9
} // end of CTRL_getFlag_enableUserMotorParams() function
10002f50:	e1a00003 	mov	r0, r3
10002f54:	e24bd000 	sub	sp, fp, #0
10002f58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002f5c:	e12fff1e 	bx	lr

10002f60 <CTRL_getIab_in_addr>:

//! \brief     Gets the alpha/beta current input vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The alpha/beta current input vector memory address
static inline MATH_vec2 *CTRL_getIab_in_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
10002f60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002f64:	e28db000 	add	fp, sp, #0
10002f68:	e24dd014 	sub	sp, sp, #20
10002f6c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002f70:	e51b3010 	ldr	r3, [fp, #-16]
10002f74:	e50b3008 	str	r3, [fp, #-8]

  return(&(obj->Iab_in));
10002f78:	e51b3008 	ldr	r3, [fp, #-8]
10002f7c:	e2833f5a 	add	r3, r3, #360	; 0x168
} // end of CTRL_getIab_in_addr() function
10002f80:	e1a00003 	mov	r0, r3
10002f84:	e24bd000 	sub	sp, fp, #0
10002f88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002f8c:	e12fff1e 	bx	lr

10002f90 <CTRL_getId_in_pu>:

//! \brief     Gets the direct current input value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct current input value, pu
static inline float_t CTRL_getId_in_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
10002f90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002f94:	e28db000 	add	fp, sp, #0
10002f98:	e24dd014 	sub	sp, sp, #20
10002f9c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002fa0:	e51b3010 	ldr	r3, [fp, #-16]
10002fa4:	e50b3008 	str	r3, [fp, #-8]

  return(obj->Idq_in.value[0]);
10002fa8:	e51b3008 	ldr	r3, [fp, #-8]
10002fac:	e5933178 	ldr	r3, [r3, #376]	; 0x178
10002fb0:	ee073a90 	vmov	s15, r3
} // end of CTRL_getId_in_pu() function
10002fb4:	eeb00a67 	vmov.f32	s0, s15
10002fb8:	e24bd000 	sub	sp, fp, #0
10002fbc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002fc0:	e12fff1e 	bx	lr

10002fc4 <CTRL_getId_ref_pu>:

//! \brief     Gets the direct current (Id) reference value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct current reference value, pu
static inline float_t CTRL_getId_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
10002fc4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002fc8:	e28db000 	add	fp, sp, #0
10002fcc:	e24dd014 	sub	sp, sp, #20
10002fd0:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10002fd4:	e51b3010 	ldr	r3, [fp, #-16]
10002fd8:	e50b3008 	str	r3, [fp, #-8]

  return(obj->Idq_ref.value[0]);
10002fdc:	e51b3008 	ldr	r3, [fp, #-8]
10002fe0:	e59331d8 	ldr	r3, [r3, #472]	; 0x1d8
10002fe4:	ee073a90 	vmov	s15, r3
} // end of CTRL_getId_ref_pu() function
10002fe8:	eeb00a67 	vmov.f32	s0, s15
10002fec:	e24bd000 	sub	sp, fp, #0
10002ff0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10002ff4:	e12fff1e 	bx	lr

10002ff8 <CTRL_getIdq_in_addr>:

//! \brief     Gets the direct/quadrature current input vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct/quadrature current input vector memory address
static inline MATH_vec2 *CTRL_getIdq_in_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
10002ff8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10002ffc:	e28db000 	add	fp, sp, #0
10003000:	e24dd014 	sub	sp, sp, #20
10003004:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003008:	e51b3010 	ldr	r3, [fp, #-16]
1000300c:	e50b3008 	str	r3, [fp, #-8]

  return(&(obj->Idq_in));
10003010:	e51b3008 	ldr	r3, [fp, #-8]
10003014:	e2833f5e 	add	r3, r3, #376	; 0x178
} // end of CTRL_getIdq_in_addr() function
10003018:	e1a00003 	mov	r0, r3
1000301c:	e24bd000 	sub	sp, fp, #0
10003020:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003024:	e12fff1e 	bx	lr

10003028 <CTRL_getIdRated_pu>:

//! \brief     Gets the Id rated current value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The Id rated current value, pu
static inline float_t CTRL_getIdRated_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
10003028:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000302c:	e28db000 	add	fp, sp, #0
10003030:	e24dd014 	sub	sp, sp, #20
10003034:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003038:	e51b3010 	ldr	r3, [fp, #-16]
1000303c:	e50b3008 	str	r3, [fp, #-8]

  return(obj->IdRated);
10003040:	e51b3008 	ldr	r3, [fp, #-8]
10003044:	e59331e0 	ldr	r3, [r3, #480]	; 0x1e0
10003048:	ee073a90 	vmov	s15, r3
} // end of CTRL_getIdRated_pu() function
1000304c:	eeb00a67 	vmov.f32	s0, s15
10003050:	e24bd000 	sub	sp, fp, #0
10003054:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003058:	e12fff1e 	bx	lr

1000305c <CTRL_getIq_in_pu>:

//! \brief     Gets the quadrature current input value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature current input value, pu
static inline float_t CTRL_getIq_in_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
1000305c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003060:	e28db000 	add	fp, sp, #0
10003064:	e24dd014 	sub	sp, sp, #20
10003068:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000306c:	e51b3010 	ldr	r3, [fp, #-16]
10003070:	e50b3008 	str	r3, [fp, #-8]

  return(obj->Idq_in.value[1]);
10003074:	e51b3008 	ldr	r3, [fp, #-8]
10003078:	e593317c 	ldr	r3, [r3, #380]	; 0x17c
1000307c:	ee073a90 	vmov	s15, r3
} // end of CTRL_getIq_in_pu() function
10003080:	eeb00a67 	vmov.f32	s0, s15
10003084:	e24bd000 	sub	sp, fp, #0
10003088:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000308c:	e12fff1e 	bx	lr

10003090 <CTRL_getIq_ref_pu>:

//! \brief     Gets the quadrature current (Iq) reference value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature current reference value, pu
static inline float_t CTRL_getIq_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
10003090:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003094:	e28db000 	add	fp, sp, #0
10003098:	e24dd014 	sub	sp, sp, #20
1000309c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100030a0:	e51b3010 	ldr	r3, [fp, #-16]
100030a4:	e50b3008 	str	r3, [fp, #-8]

  return(obj->Idq_ref.value[1]);
100030a8:	e51b3008 	ldr	r3, [fp, #-8]
100030ac:	e59331dc 	ldr	r3, [r3, #476]	; 0x1dc
100030b0:	ee073a90 	vmov	s15, r3
} // end of CTRL_getIq_ref_pu() function
100030b4:	eeb00a67 	vmov.f32	s0, s15
100030b8:	e24bd000 	sub	sp, fp, #0
100030bc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100030c0:	e12fff1e 	bx	lr

100030c4 <CTRL_getKi>:
//! \brief     Gets the integral gain (Ki) value from the specified controller
//! \param[in] handle    The controller (CTRL) handle
//! \param[in] ctrlType  The controller type
//! \return    The Ki value
static inline float_t CTRL_getKi(CTRL_Handle handle,const CTRL_Type_e ctrlType)//! \Mod By Dl.K
{
100030c4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100030c8:	e28db000 	add	fp, sp, #0
100030cc:	e24dd014 	sub	sp, sp, #20
100030d0:	e50b0010 	str	r0, [fp, #-16]
100030d4:	e1a03001 	mov	r3, r1
100030d8:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100030dc:	e51b3010 	ldr	r3, [fp, #-16]
100030e0:	e50b300c 	str	r3, [fp, #-12]
  float_t Ki = (0.0f);
100030e4:	e3a03000 	mov	r3, #0
100030e8:	e50b3008 	str	r3, [fp, #-8]

  if(ctrlType == CTRL_Type_PID_spd)
100030ec:	e55b3011 	ldrb	r3, [fp, #-17]
100030f0:	e3530000 	cmp	r3, #0
100030f4:	1a000003 	bne	10003108 <CTRL_getKi+0x44>
    {
      Ki = obj->Ki_spd;
100030f8:	e51b300c 	ldr	r3, [fp, #-12]
100030fc:	e59331bc 	ldr	r3, [r3, #444]	; 0x1bc
10003100:	e50b3008 	str	r3, [fp, #-8]
10003104:	ea00000c 	b	1000313c <CTRL_getKi+0x78>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
10003108:	e55b3011 	ldrb	r3, [fp, #-17]
1000310c:	e3530001 	cmp	r3, #1
10003110:	1a000003 	bne	10003124 <CTRL_getKi+0x60>
    {
      Ki = obj->Ki_Id;
10003114:	e51b300c 	ldr	r3, [fp, #-12]
10003118:	e59331b4 	ldr	r3, [r3, #436]	; 0x1b4
1000311c:	e50b3008 	str	r3, [fp, #-8]
10003120:	ea000005 	b	1000313c <CTRL_getKi+0x78>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
10003124:	e55b3011 	ldrb	r3, [fp, #-17]
10003128:	e3530002 	cmp	r3, #2
1000312c:	1a000002 	bne	1000313c <CTRL_getKi+0x78>
    {
      Ki = obj->Ki_Iq;
10003130:	e51b300c 	ldr	r3, [fp, #-12]
10003134:	e59331b8 	ldr	r3, [r3, #440]	; 0x1b8
10003138:	e50b3008 	str	r3, [fp, #-8]
    }

  return(Ki);
1000313c:	e51b3008 	ldr	r3, [fp, #-8]
10003140:	ee073a90 	vmov	s15, r3
} // end of CTRL_getKi() function
10003144:	eeb00a67 	vmov.f32	s0, s15
10003148:	e24bd000 	sub	sp, fp, #0
1000314c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003150:	e12fff1e 	bx	lr

10003154 <CTRL_getKd>:
//! \brief     Gets the derivative gain (Kd) value from the specified controller
//! \param[in] handle    The controller (CTRL) handle
//! \param[in] ctrlType  The controller type
//! \return    The Kd value
static inline float_t CTRL_getKd(CTRL_Handle handle,const CTRL_Type_e ctrlType)//! \Mod By Dl.K
{
10003154:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003158:	e28db000 	add	fp, sp, #0
1000315c:	e24dd014 	sub	sp, sp, #20
10003160:	e50b0010 	str	r0, [fp, #-16]
10003164:	e1a03001 	mov	r3, r1
10003168:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000316c:	e51b3010 	ldr	r3, [fp, #-16]
10003170:	e50b300c 	str	r3, [fp, #-12]
  float_t Kd = (0.0f);
10003174:	e3a03000 	mov	r3, #0
10003178:	e50b3008 	str	r3, [fp, #-8]

  if(ctrlType == CTRL_Type_PID_spd)
1000317c:	e55b3011 	ldrb	r3, [fp, #-17]
10003180:	e3530000 	cmp	r3, #0
10003184:	1a000003 	bne	10003198 <CTRL_getKd+0x44>
    {
      Kd = obj->Kd_spd;
10003188:	e51b300c 	ldr	r3, [fp, #-12]
1000318c:	e59331c8 	ldr	r3, [r3, #456]	; 0x1c8
10003190:	e50b3008 	str	r3, [fp, #-8]
10003194:	ea00000c 	b	100031cc <CTRL_getKd+0x78>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
10003198:	e55b3011 	ldrb	r3, [fp, #-17]
1000319c:	e3530001 	cmp	r3, #1
100031a0:	1a000003 	bne	100031b4 <CTRL_getKd+0x60>
    {
      Kd = obj->Kd_Id;
100031a4:	e51b300c 	ldr	r3, [fp, #-12]
100031a8:	e59331c0 	ldr	r3, [r3, #448]	; 0x1c0
100031ac:	e50b3008 	str	r3, [fp, #-8]
100031b0:	ea000005 	b	100031cc <CTRL_getKd+0x78>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
100031b4:	e55b3011 	ldrb	r3, [fp, #-17]
100031b8:	e3530002 	cmp	r3, #2
100031bc:	1a000002 	bne	100031cc <CTRL_getKd+0x78>
    {
      Kd = obj->Kd_Iq;
100031c0:	e51b300c 	ldr	r3, [fp, #-12]
100031c4:	e59331c4 	ldr	r3, [r3, #452]	; 0x1c4
100031c8:	e50b3008 	str	r3, [fp, #-8]
    }

  return(Kd);
100031cc:	e51b3008 	ldr	r3, [fp, #-8]
100031d0:	ee073a90 	vmov	s15, r3
} // end of CTRL_getKd() function
100031d4:	eeb00a67 	vmov.f32	s0, s15
100031d8:	e24bd000 	sub	sp, fp, #0
100031dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100031e0:	e12fff1e 	bx	lr

100031e4 <CTRL_getKp>:
//! \brief     Gets the proportional gain (Kp) value from the specified controller
//! \param[in] handle    The controller (CTRL) handle
//! \param[in] ctrlType  The controller type
//! \return    The Kp value
static inline float_t CTRL_getKp(CTRL_Handle handle,const CTRL_Type_e ctrlType)//! \Mod By Dl.K
{
100031e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100031e8:	e28db000 	add	fp, sp, #0
100031ec:	e24dd014 	sub	sp, sp, #20
100031f0:	e50b0010 	str	r0, [fp, #-16]
100031f4:	e1a03001 	mov	r3, r1
100031f8:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100031fc:	e51b3010 	ldr	r3, [fp, #-16]
10003200:	e50b300c 	str	r3, [fp, #-12]
  float_t Kp = (0.0f);
10003204:	e3a03000 	mov	r3, #0
10003208:	e50b3008 	str	r3, [fp, #-8]

  if(ctrlType == CTRL_Type_PID_spd)
1000320c:	e55b3011 	ldrb	r3, [fp, #-17]
10003210:	e3530000 	cmp	r3, #0
10003214:	1a000003 	bne	10003228 <CTRL_getKp+0x44>
    {
      Kp = obj->Kp_spd;
10003218:	e51b300c 	ldr	r3, [fp, #-12]
1000321c:	e59331b0 	ldr	r3, [r3, #432]	; 0x1b0
10003220:	e50b3008 	str	r3, [fp, #-8]
10003224:	ea00000c 	b	1000325c <CTRL_getKp+0x78>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
10003228:	e55b3011 	ldrb	r3, [fp, #-17]
1000322c:	e3530001 	cmp	r3, #1
10003230:	1a000003 	bne	10003244 <CTRL_getKp+0x60>
    {
      Kp = obj->Kp_Id;
10003234:	e51b300c 	ldr	r3, [fp, #-12]
10003238:	e59331a8 	ldr	r3, [r3, #424]	; 0x1a8
1000323c:	e50b3008 	str	r3, [fp, #-8]
10003240:	ea000005 	b	1000325c <CTRL_getKp+0x78>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
10003244:	e55b3011 	ldrb	r3, [fp, #-17]
10003248:	e3530002 	cmp	r3, #2
1000324c:	1a000002 	bne	1000325c <CTRL_getKp+0x78>
    {
      Kp = obj->Kp_Iq;
10003250:	e51b300c 	ldr	r3, [fp, #-12]
10003254:	e59331ac 	ldr	r3, [r3, #428]	; 0x1ac
10003258:	e50b3008 	str	r3, [fp, #-8]
    }

  return(Kp);
1000325c:	e51b3008 	ldr	r3, [fp, #-8]
10003260:	ee073a90 	vmov	s15, r3
} // end of CTRL_getKp() function
10003264:	eeb00a67 	vmov.f32	s0, s15
10003268:	e24bd000 	sub	sp, fp, #0
1000326c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003270:	e12fff1e 	bx	lr

10003274 <CTRL_getNumCtrlTicksPerTrajTick>:

//! \brief     Gets the number of controller clock ticks per trajectory clock tick
//! \param[in] handle  The controller (CTRL) handle
//! \return    The number of controller clock ticks per trajectory clock tick
static inline uint_least16_t CTRL_getNumCtrlTicksPerTrajTick(CTRL_Handle handle)//! \Mod By Dl.K
{
10003274:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003278:	e28db000 	add	fp, sp, #0
1000327c:	e24dd014 	sub	sp, sp, #20
10003280:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003284:	e51b3010 	ldr	r3, [fp, #-16]
10003288:	e50b3008 	str	r3, [fp, #-8]
  
  return(obj->numCtrlTicksPerTrajTick);
1000328c:	e51b3008 	ldr	r3, [fp, #-8]
10003290:	e2833e15 	add	r3, r3, #336	; 0x150
10003294:	e2833002 	add	r3, r3, #2
10003298:	e1d330b0 	ldrh	r3, [r3]
} // end of CTRL_getNumCtrlTicksPerTrajTick() function
1000329c:	e1a00003 	mov	r0, r3
100032a0:	e24bd000 	sub	sp, fp, #0
100032a4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100032a8:	e12fff1e 	bx	lr

100032ac <CTRL_getNumIsrTicksPerCtrlTick>:

//! \brief     Gets the number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
//! \param[in] handle  The controller (CTRL) handle
//! \return    The number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
static inline uint_least16_t CTRL_getNumIsrTicksPerCtrlTick(CTRL_Handle handle)//! \Mod By Dl.K
{
100032ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100032b0:	e28db000 	add	fp, sp, #0
100032b4:	e24dd014 	sub	sp, sp, #20
100032b8:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100032bc:	e51b3010 	ldr	r3, [fp, #-16]
100032c0:	e50b3008 	str	r3, [fp, #-8]
  
  return(obj->numIsrTicksPerCtrlTick);
100032c4:	e51b3008 	ldr	r3, [fp, #-8]
100032c8:	e2833f53 	add	r3, r3, #332	; 0x14c
100032cc:	e1d330b0 	ldrh	r3, [r3]
} // end of CTRL_getNumIsrTicksPerCtrlTick() function
100032d0:	e1a00003 	mov	r0, r3
100032d4:	e24bd000 	sub	sp, fp, #0
100032d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100032dc:	e12fff1e 	bx	lr

100032e0 <CTRL_getSpd_max_pu>:

//! \brief     Gets the maximum speed value from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The maximum speed value, pu
static inline float_t CTRL_getSpd_max_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
100032e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100032e4:	e28db000 	add	fp, sp, #0
100032e8:	e24dd014 	sub	sp, sp, #20
100032ec:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100032f0:	e51b3010 	ldr	r3, [fp, #-16]
100032f4:	e50b3008 	str	r3, [fp, #-8]

  return(obj->spd_max);
100032f8:	e51b3008 	ldr	r3, [fp, #-8]
100032fc:	e59331e8 	ldr	r3, [r3, #488]	; 0x1e8
10003300:	ee073a90 	vmov	s15, r3
} // end of CTRL_getSpd_max_pu() function
10003304:	eeb00a67 	vmov.f32	s0, s15
10003308:	e24bd000 	sub	sp, fp, #0
1000330c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003310:	e12fff1e 	bx	lr

10003314 <CTRL_getSpd_out_addr>:

//! \brief     Gets the output speed memory address from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed memory address
static inline float_t *CTRL_getSpd_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
10003314:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003318:	e28db000 	add	fp, sp, #0
1000331c:	e24dd014 	sub	sp, sp, #20
10003320:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003324:	e51b3010 	ldr	r3, [fp, #-16]
10003328:	e50b3008 	str	r3, [fp, #-8]

  return(&(obj->spd_out));
1000332c:	e51b3008 	ldr	r3, [fp, #-8]
10003330:	e2833f62 	add	r3, r3, #392	; 0x188
} // end of CTRL_getSpd_out_addr() function
10003334:	e1a00003 	mov	r0, r3
10003338:	e24bd000 	sub	sp, fp, #0
1000333c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003340:	e12fff1e 	bx	lr

10003344 <CTRL_getSpd_out_pu>:

//! \brief     Gets the output speed value from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed value, pu
static inline float_t CTRL_getSpd_out_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
10003344:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003348:	e28db000 	add	fp, sp, #0
1000334c:	e24dd014 	sub	sp, sp, #20
10003350:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003354:	e51b3010 	ldr	r3, [fp, #-16]
10003358:	e50b3008 	str	r3, [fp, #-8]

  return(obj->spd_out);
1000335c:	e51b3008 	ldr	r3, [fp, #-8]
10003360:	e5933188 	ldr	r3, [r3, #392]	; 0x188
10003364:	ee073a90 	vmov	s15, r3
} // end of CTRL_getSpd_out_pu() function
10003368:	eeb00a67 	vmov.f32	s0, s15
1000336c:	e24bd000 	sub	sp, fp, #0
10003370:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003374:	e12fff1e 	bx	lr

10003378 <CTRL_getSpd_ref_pu>:

//! \brief     Gets the output speed reference value from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed reference value, pu
static inline float_t CTRL_getSpd_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
10003378:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000337c:	e28db000 	add	fp, sp, #0
10003380:	e24dd014 	sub	sp, sp, #20
10003384:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003388:	e51b3010 	ldr	r3, [fp, #-16]
1000338c:	e50b3008 	str	r3, [fp, #-8]

  return(obj->spd_ref);
10003390:	e51b3008 	ldr	r3, [fp, #-8]
10003394:	e59331e4 	ldr	r3, [r3, #484]	; 0x1e4
10003398:	ee073a90 	vmov	s15, r3
} // end of CTRL_getSpd_ref_pu() function
1000339c:	eeb00a67 	vmov.f32	s0, s15
100033a0:	e24bd000 	sub	sp, fp, #0
100033a4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100033a8:	e12fff1e 	bx	lr

100033ac <CTRL_getState>:

//! \brief     Gets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \return    The controller state
static inline CTRL_State_e CTRL_getState(CTRL_Handle handle)//! \Mod By Dl.K
{
100033ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100033b0:	e28db000 	add	fp, sp, #0
100033b4:	e24dd014 	sub	sp, sp, #20
100033b8:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100033bc:	e51b3010 	ldr	r3, [fp, #-16]
100033c0:	e50b3008 	str	r3, [fp, #-8]

  return(obj->state);
100033c4:	e51b3008 	ldr	r3, [fp, #-8]
100033c8:	e5d33008 	ldrb	r3, [r3, #8]
} // end of CTRL_getState() function
100033cc:	e1a00003 	mov	r0, r3
100033d0:	e24bd000 	sub	sp, fp, #0
100033d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100033d8:	e12fff1e 	bx	lr

100033dc <CTRL_getVab_out_addr>:

//! \brief     Gets the alpha/beta voltage output vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The alpha/beta voltage output vector memory address
static inline MATH_vec2 *CTRL_getVab_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
100033dc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100033e0:	e28db000 	add	fp, sp, #0
100033e4:	e24dd014 	sub	sp, sp, #20
100033e8:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100033ec:	e51b3010 	ldr	r3, [fp, #-16]
100033f0:	e50b3008 	str	r3, [fp, #-8]

  return(&(obj->Vab_out));
100033f4:	e51b3008 	ldr	r3, [fp, #-8]
100033f8:	e2833f63 	add	r3, r3, #396	; 0x18c
} // end of CTRL_getVab_out_addr() function
100033fc:	e1a00003 	mov	r0, r3
10003400:	e24bd000 	sub	sp, fp, #0
10003404:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003408:	e12fff1e 	bx	lr

1000340c <CTRL_getVd_out_addr>:

//! \brief     Gets the direct voltage output value memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct voltage output value memory address
static inline float_t *CTRL_getVd_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
1000340c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003410:	e28db000 	add	fp, sp, #0
10003414:	e24dd014 	sub	sp, sp, #20
10003418:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000341c:	e51b3010 	ldr	r3, [fp, #-16]
10003420:	e50b3008 	str	r3, [fp, #-8]

  return(&(obj->Vdq_out.value[0]));
10003424:	e51b3008 	ldr	r3, [fp, #-8]
10003428:	e2833f65 	add	r3, r3, #404	; 0x194
} // end of CTRL_getVd_out_addr() function
1000342c:	e1a00003 	mov	r0, r3
10003430:	e24bd000 	sub	sp, fp, #0
10003434:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003438:	e12fff1e 	bx	lr

1000343c <CTRL_getVdq_out_addr>:

//! \brief     Gets the direct/quadrature voltage output vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct/quadrature voltage output vector memory address
static inline MATH_vec2 *CTRL_getVdq_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
1000343c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003440:	e28db000 	add	fp, sp, #0
10003444:	e24dd014 	sub	sp, sp, #20
10003448:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000344c:	e51b3010 	ldr	r3, [fp, #-16]
10003450:	e50b3008 	str	r3, [fp, #-8]

  return(&(obj->Vdq_out));
10003454:	e51b3008 	ldr	r3, [fp, #-8]
10003458:	e2833f65 	add	r3, r3, #404	; 0x194
} // end of CTRL_getVdq_out_pu() function
1000345c:	e1a00003 	mov	r0, r3
10003460:	e24bd000 	sub	sp, fp, #0
10003464:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003468:	e12fff1e 	bx	lr

1000346c <CTRL_getVq_out_addr>:

//! \brief     Gets the quadrature voltage output value memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature voltage output value memory address
static inline float_t *CTRL_getVq_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
1000346c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003470:	e28db000 	add	fp, sp, #0
10003474:	e24dd014 	sub	sp, sp, #20
10003478:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000347c:	e51b3010 	ldr	r3, [fp, #-16]
10003480:	e50b3008 	str	r3, [fp, #-8]

  return(&(obj->Vdq_out.value[1]));
10003484:	e51b3008 	ldr	r3, [fp, #-8]
10003488:	e2833f66 	add	r3, r3, #408	; 0x198
} // end of CTRL_getVq_out_addr() function
1000348c:	e1a00003 	mov	r0, r3
10003490:	e24bd000 	sub	sp, fp, #0
10003494:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003498:	e12fff1e 	bx	lr

1000349c <CTRL_getVq_out_pu>:

//! \brief     Gets the quadrature voltage output value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature voltage output value, pu
static inline float_t CTRL_getVq_out_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
1000349c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100034a0:	e28db000 	add	fp, sp, #0
100034a4:	e24dd014 	sub	sp, sp, #20
100034a8:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100034ac:	e51b3010 	ldr	r3, [fp, #-16]
100034b0:	e50b3008 	str	r3, [fp, #-8]

  return(obj->Vdq_out.value[1]);
100034b4:	e51b3008 	ldr	r3, [fp, #-8]
100034b8:	e5933198 	ldr	r3, [r3, #408]	; 0x198
100034bc:	ee073a90 	vmov	s15, r3
} // end of CTRL_getVq_out_pu() function
100034c0:	eeb00a67 	vmov.f32	s0, s15
100034c4:	e24bd000 	sub	sp, fp, #0
100034c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100034cc:	e12fff1e 	bx	lr

100034d0 <CTRL_getWaitTime>:
//! \brief     Gets the wait time for a given state
//! \param[in] handle     The controller (CTRL) handle
//! \param[in] ctrlState  The controller state
//! \return    The wait time, controller clock counts
static inline uint_least32_t CTRL_getWaitTime(CTRL_Handle handle,const CTRL_State_e ctrlState)//! \Mod By Dl.K
{
100034d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100034d4:	e28db000 	add	fp, sp, #0
100034d8:	e24dd014 	sub	sp, sp, #20
100034dc:	e50b0010 	str	r0, [fp, #-16]
100034e0:	e1a03001 	mov	r3, r1
100034e4:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100034e8:	e51b3010 	ldr	r3, [fp, #-16]
100034ec:	e50b3008 	str	r3, [fp, #-8]

  return(obj->waitTimes[ctrlState]);
100034f0:	e55b2011 	ldrb	r2, [fp, #-17]
100034f4:	e51b3008 	ldr	r3, [fp, #-8]
100034f8:	e2822048 	add	r2, r2, #72	; 0x48
100034fc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
} // end of CTRL_getWaitTime() function
10003500:	e1a00003 	mov	r0, r3
10003504:	e24bd000 	sub	sp, fp, #0
10003508:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000350c:	e12fff1e 	bx	lr

10003510 <CTRL_incrCounter_current>:


//! \brief     Increments the current counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_current(CTRL_Handle handle)//! \Mod By Dl.K
{
10003510:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003514:	e28db000 	add	fp, sp, #0
10003518:	e24dd014 	sub	sp, sp, #20
1000351c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003520:	e51b3010 	ldr	r3, [fp, #-16]
10003524:	e50b3008 	str	r3, [fp, #-8]

  uint_least16_t count = obj->counter_current;
10003528:	e51b3008 	ldr	r3, [fp, #-8]
1000352c:	e2833f7b 	add	r3, r3, #492	; 0x1ec
10003530:	e1d330b0 	ldrh	r3, [r3]
10003534:	e14b30ba 	strh	r3, [fp, #-10]

  // increment the count
  count++;
10003538:	e15b30ba 	ldrh	r3, [fp, #-10]
1000353c:	e2833001 	add	r3, r3, #1
10003540:	e14b30ba 	strh	r3, [fp, #-10]

  // save the count value
  obj->counter_current = count;
10003544:	e51b3008 	ldr	r3, [fp, #-8]
10003548:	e2833f7b 	add	r3, r3, #492	; 0x1ec
1000354c:	e15b20ba 	ldrh	r2, [fp, #-10]
10003550:	e1c320b0 	strh	r2, [r3]

  return;
10003554:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_incrCounter_current() function
10003558:	e24bd000 	sub	sp, fp, #0
1000355c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003560:	e12fff1e 	bx	lr

10003564 <CTRL_incrCounter_isr>:


//! \brief     Increments the isr counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
10003564:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003568:	e28db000 	add	fp, sp, #0
1000356c:	e24dd014 	sub	sp, sp, #20
10003570:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003574:	e51b3010 	ldr	r3, [fp, #-16]
10003578:	e50b3008 	str	r3, [fp, #-8]

  uint_least16_t count = obj->counter_isr;
1000357c:	e51b3008 	ldr	r3, [fp, #-8]
10003580:	e2833f7b 	add	r3, r3, #492	; 0x1ec
10003584:	e2833002 	add	r3, r3, #2
10003588:	e1d330b0 	ldrh	r3, [r3]
1000358c:	e14b30ba 	strh	r3, [fp, #-10]

  // increment the count
  count++;
10003590:	e15b30ba 	ldrh	r3, [fp, #-10]
10003594:	e2833001 	add	r3, r3, #1
10003598:	e14b30ba 	strh	r3, [fp, #-10]

  // save the count value
  obj->counter_isr = count;
1000359c:	e51b3008 	ldr	r3, [fp, #-8]
100035a0:	e2833f7b 	add	r3, r3, #492	; 0x1ec
100035a4:	e2833002 	add	r3, r3, #2
100035a8:	e15b20ba 	ldrh	r2, [fp, #-10]
100035ac:	e1c320b0 	strh	r2, [r3]

  return;
100035b0:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_incrCounter_isr() function
100035b4:	e24bd000 	sub	sp, fp, #0
100035b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100035bc:	e12fff1e 	bx	lr

100035c0 <CTRL_incrCounter_speed>:


//! \brief     Increments the speed counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_speed(CTRL_Handle handle)//! \Mod By Dl.K
{
100035c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100035c4:	e28db000 	add	fp, sp, #0
100035c8:	e24dd014 	sub	sp, sp, #20
100035cc:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100035d0:	e51b3010 	ldr	r3, [fp, #-16]
100035d4:	e50b3008 	str	r3, [fp, #-8]

  uint_least16_t count = obj->counter_speed;
100035d8:	e51b3008 	ldr	r3, [fp, #-8]
100035dc:	e2833e1f 	add	r3, r3, #496	; 0x1f0
100035e0:	e1d330b0 	ldrh	r3, [r3]
100035e4:	e14b30ba 	strh	r3, [fp, #-10]

  // increment the count
  count++;
100035e8:	e15b30ba 	ldrh	r3, [fp, #-10]
100035ec:	e2833001 	add	r3, r3, #1
100035f0:	e14b30ba 	strh	r3, [fp, #-10]

  // save the count value
  obj->counter_speed = count;
100035f4:	e51b3008 	ldr	r3, [fp, #-8]
100035f8:	e2833e1f 	add	r3, r3, #496	; 0x1f0
100035fc:	e15b20ba 	ldrh	r2, [fp, #-10]
10003600:	e1c320b0 	strh	r2, [r3]

  return;
10003604:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_incrCounter_speed() function
10003608:	e24bd000 	sub	sp, fp, #0
1000360c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003610:	e12fff1e 	bx	lr

10003614 <CTRL_incrCounter_state>:


//! \brief     Increments the state counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_state(CTRL_Handle handle)//! \Mod By Dl.K
{
10003614:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003618:	e28db000 	add	fp, sp, #0
1000361c:	e24dd014 	sub	sp, sp, #20
10003620:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003624:	e51b3010 	ldr	r3, [fp, #-16]
10003628:	e50b3008 	str	r3, [fp, #-8]

  uint_least32_t count = obj->counter_state;
1000362c:	e51b3008 	ldr	r3, [fp, #-8]
10003630:	e5933148 	ldr	r3, [r3, #328]	; 0x148
10003634:	e50b300c 	str	r3, [fp, #-12]

  // increment the count
  count++;
10003638:	e51b300c 	ldr	r3, [fp, #-12]
1000363c:	e2833001 	add	r3, r3, #1
10003640:	e50b300c 	str	r3, [fp, #-12]

  // save the count value
  obj->counter_state = count;
10003644:	e51b3008 	ldr	r3, [fp, #-8]
10003648:	e51b200c 	ldr	r2, [fp, #-12]
1000364c:	e5832148 	str	r2, [r3, #328]	; 0x148

  return;
10003650:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_incrCounter_state() function
10003654:	e24bd000 	sub	sp, fp, #0
10003658:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000365c:	e12fff1e 	bx	lr

10003660 <CTRL_incrCounter_traj>:


//! \brief     Increments the trajectory counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_traj(CTRL_Handle handle)//! \Mod By Dl.K
{
10003660:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003664:	e28db000 	add	fp, sp, #0
10003668:	e24dd014 	sub	sp, sp, #20
1000366c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003670:	e51b3010 	ldr	r3, [fp, #-16]
10003674:	e50b3008 	str	r3, [fp, #-8]

  uint_least16_t count = obj->counter_traj;
10003678:	e51b3008 	ldr	r3, [fp, #-8]
1000367c:	e2833e1f 	add	r3, r3, #496	; 0x1f0
10003680:	e2833002 	add	r3, r3, #2
10003684:	e1d330b0 	ldrh	r3, [r3]
10003688:	e14b30ba 	strh	r3, [fp, #-10]

  // increment the count
  count++;
1000368c:	e15b30ba 	ldrh	r3, [fp, #-10]
10003690:	e2833001 	add	r3, r3, #1
10003694:	e14b30ba 	strh	r3, [fp, #-10]

  // save the count value
  obj->counter_traj = count;
10003698:	e51b3008 	ldr	r3, [fp, #-8]
1000369c:	e2833e1f 	add	r3, r3, #496	; 0x1f0
100036a0:	e2833002 	add	r3, r3, #2
100036a4:	e15b20ba 	ldrh	r2, [fp, #-10]
100036a8:	e1c320b0 	strh	r2, [r3]

  return;
100036ac:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_incrCounter_traj() function
100036b0:	e24bd000 	sub	sp, fp, #0
100036b4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100036b8:	e12fff1e 	bx	lr

100036bc <CTRL_resetCounter_current>:


//! \brief     Resets the current counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_current(CTRL_Handle handle)//! \Mod By Dl.K
{
100036bc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100036c0:	e28db000 	add	fp, sp, #0
100036c4:	e24dd014 	sub	sp, sp, #20
100036c8:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100036cc:	e51b3010 	ldr	r3, [fp, #-16]
100036d0:	e50b3008 	str	r3, [fp, #-8]

  obj->counter_current = 0;
100036d4:	e51b3008 	ldr	r3, [fp, #-8]
100036d8:	e2833f7b 	add	r3, r3, #492	; 0x1ec
100036dc:	e3a02000 	mov	r2, #0
100036e0:	e1c320b0 	strh	r2, [r3]

  return;
100036e4:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_resetCounter_current() function
100036e8:	e24bd000 	sub	sp, fp, #0
100036ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100036f0:	e12fff1e 	bx	lr

100036f4 <CTRL_resetCounter_isr>:


//! \brief     Resets the isr counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
100036f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100036f8:	e28db000 	add	fp, sp, #0
100036fc:	e24dd014 	sub	sp, sp, #20
10003700:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003704:	e51b3010 	ldr	r3, [fp, #-16]
10003708:	e50b3008 	str	r3, [fp, #-8]

  obj->counter_isr = 1;
1000370c:	e51b3008 	ldr	r3, [fp, #-8]
10003710:	e2833f7b 	add	r3, r3, #492	; 0x1ec
10003714:	e2833002 	add	r3, r3, #2
10003718:	e3a02001 	mov	r2, #1
1000371c:	e1c320b0 	strh	r2, [r3]

  return;
10003720:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_resetCounter_isr() function
10003724:	e24bd000 	sub	sp, fp, #0
10003728:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000372c:	e12fff1e 	bx	lr

10003730 <CTRL_resetCounter_speed>:


//! \brief     Resets the speed counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_speed(CTRL_Handle handle)//! \Mod By Dl.K
{
10003730:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003734:	e28db000 	add	fp, sp, #0
10003738:	e24dd014 	sub	sp, sp, #20
1000373c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003740:	e51b3010 	ldr	r3, [fp, #-16]
10003744:	e50b3008 	str	r3, [fp, #-8]

  obj->counter_speed = 0;
10003748:	e51b3008 	ldr	r3, [fp, #-8]
1000374c:	e2833e1f 	add	r3, r3, #496	; 0x1f0
10003750:	e3a02000 	mov	r2, #0
10003754:	e1c320b0 	strh	r2, [r3]

  return;
10003758:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_resetCounter_speed() function
1000375c:	e24bd000 	sub	sp, fp, #0
10003760:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003764:	e12fff1e 	bx	lr

10003768 <CTRL_resetCounter_state>:


//! \brief     Resets the state counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_state(CTRL_Handle handle)//! \Mod By Dl.K
{
10003768:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000376c:	e28db000 	add	fp, sp, #0
10003770:	e24dd014 	sub	sp, sp, #20
10003774:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003778:	e51b3010 	ldr	r3, [fp, #-16]
1000377c:	e50b3008 	str	r3, [fp, #-8]

  obj->counter_state = 0;
10003780:	e51b3008 	ldr	r3, [fp, #-8]
10003784:	e3a02000 	mov	r2, #0
10003788:	e5832148 	str	r2, [r3, #328]	; 0x148

  return;
1000378c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_resetCounter_state() function
10003790:	e24bd000 	sub	sp, fp, #0
10003794:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003798:	e12fff1e 	bx	lr

1000379c <CTRL_resetCounter_traj>:


//! \brief     Resets the trajectory counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_traj(CTRL_Handle handle)//! \Mod By Dl.K
{
1000379c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100037a0:	e28db000 	add	fp, sp, #0
100037a4:	e24dd014 	sub	sp, sp, #20
100037a8:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100037ac:	e51b3010 	ldr	r3, [fp, #-16]
100037b0:	e50b3008 	str	r3, [fp, #-8]

  obj->counter_traj = 0;
100037b4:	e51b3008 	ldr	r3, [fp, #-8]
100037b8:	e2833e1f 	add	r3, r3, #496	; 0x1f0
100037bc:	e2833002 	add	r3, r3, #2
100037c0:	e3a02000 	mov	r2, #0
100037c4:	e1c320b0 	strh	r2, [r3]

  return;
100037c8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_resetCounter_traj() function
100037cc:	e24bd000 	sub	sp, fp, #0
100037d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100037d4:	e12fff1e 	bx	lr

100037d8 <CTRL_runTraj>:


//! \brief     Runs the trajectory
//! \param[in] handle   The controller (CTRL) handle
static inline void CTRL_runTraj(CTRL_Handle handle)
{
100037d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100037dc:	e28db000 	add	fp, sp, #0
100037e0:	e24dd00c 	sub	sp, sp, #12
100037e4:	e50b0008 	str	r0, [fp, #-8]
}
100037e8:	e24bd000 	sub	sp, fp, #0
100037ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100037f0:	e12fff1e 	bx	lr

100037f4 <CTRL_setAngle_pu>:

//! \brief      Sets the angle value, pu
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  angle_pu  The angle value, pu
static inline void CTRL_setAngle_pu(CTRL_Handle handle,const float_t angle_pu)//! \Mod By Dl.K
{
100037f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100037f8:	e28db000 	add	fp, sp, #0
100037fc:	e24dd014 	sub	sp, sp, #20
10003800:	e50b0010 	str	r0, [fp, #-16]
10003804:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003808:	e51b3010 	ldr	r3, [fp, #-16]
1000380c:	e50b3008 	str	r3, [fp, #-8]

  obj->angle_pu = angle_pu;
10003810:	e51b3008 	ldr	r3, [fp, #-8]
10003814:	e51b2014 	ldr	r2, [fp, #-20]
10003818:	e5832210 	str	r2, [r3, #528]	; 0x210

  return;
1000381c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setAngle_pu() function
10003820:	e24bd000 	sub	sp, fp, #0
10003824:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003828:	e12fff1e 	bx	lr

1000382c <CTRL_setCtrlFreq_Hz>:

//! \brief      Sets the controller frequency
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  ctrlFreq_Hz  The controller frequency, Hz
static inline void CTRL_setCtrlFreq_Hz(CTRL_Handle handle,const uint_least32_t ctrlFreq_Hz)//! \Mod By Dl.K
{
1000382c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003830:	e28db000 	add	fp, sp, #0
10003834:	e24dd014 	sub	sp, sp, #20
10003838:	e50b0010 	str	r0, [fp, #-16]
1000383c:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003840:	e51b3010 	ldr	r3, [fp, #-16]
10003844:	e50b3008 	str	r3, [fp, #-8]

  obj->ctrlFreq_Hz = ctrlFreq_Hz;
10003848:	e51b3008 	ldr	r3, [fp, #-8]
1000384c:	e51b2014 	ldr	r2, [fp, #-20]
10003850:	e5832154 	str	r2, [r3, #340]	; 0x154

  return;
10003854:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setCtrlFreq_Hz() function
10003858:	e24bd000 	sub	sp, fp, #0
1000385c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003860:	e12fff1e 	bx	lr

10003864 <CTRL_setCtrlPeriod_sec>:

//! \brief      Sets the controller execution period
//! \param[in]  handle          The controller (CTRL) handle
//! \param[in]  ctrlPeriod_sec  The controller execution period, sec
static inline void CTRL_setCtrlPeriod_sec(CTRL_Handle handle,const float_t ctrlPeriod_sec)//! \Mod By Dl.K
{
10003864:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003868:	e28db000 	add	fp, sp, #0
1000386c:	e24dd014 	sub	sp, sp, #20
10003870:	e50b0010 	str	r0, [fp, #-16]
10003874:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003878:	e51b3010 	ldr	r3, [fp, #-16]
1000387c:	e50b3008 	str	r3, [fp, #-8]

  obj->ctrlPeriod_sec = ctrlPeriod_sec;
10003880:	e51b3008 	ldr	r3, [fp, #-8]
10003884:	e51b2014 	ldr	r2, [fp, #-20]
10003888:	e5832160 	str	r2, [r3, #352]	; 0x160

  return;
1000388c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setCtrlPeriod_sec() function
10003890:	e24bd000 	sub	sp, fp, #0
10003894:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003898:	e12fff1e 	bx	lr

1000389c <CTRL_setErrorCode>:

//! \brief      Sets the error code in the controller
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  errorCode   The error code
static inline void CTRL_setErrorCode(CTRL_Handle handle,const CTRL_ErrorCode_e errorCode)//! \Mod By Dl.K
{
1000389c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100038a0:	e28db000 	add	fp, sp, #0
100038a4:	e24dd014 	sub	sp, sp, #20
100038a8:	e50b0010 	str	r0, [fp, #-16]
100038ac:	e1a03001 	mov	r3, r1
100038b0:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100038b4:	e51b3010 	ldr	r3, [fp, #-16]
100038b8:	e50b3008 	str	r3, [fp, #-8]

  obj->errorCode = errorCode;
100038bc:	e51b3008 	ldr	r3, [fp, #-8]
100038c0:	e55b2011 	ldrb	r2, [fp, #-17]
100038c4:	e5c3200a 	strb	r2, [r3, #10]

  return;
100038c8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setErrorCode() function
100038cc:	e24bd000 	sub	sp, fp, #0
100038d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100038d4:	e12fff1e 	bx	lr

100038d8 <CTRL_setEstParams>:
//! \details    Copies all scale factors that are defined in the file user.h and used
//!             by CTRL into the CTRL object.
//! \param[in]  estHandle    The estimator (EST) handle
//! \param[in]  pUserParams  The pointer to the user parameters
static inline void CTRL_setEstParams(EST_Handle estHandle,USER_Params *pUserParams)
{
100038d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100038dc:	e28db000 	add	fp, sp, #0
100038e0:	e24dd00c 	sub	sp, sp, #12
100038e4:	e50b0008 	str	r0, [fp, #-8]
100038e8:	e50b100c 	str	r1, [fp, #-12]
}
100038ec:	e24bd000 	sub	sp, fp, #0
100038f0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100038f4:	e12fff1e 	bx	lr

100038f8 <CTRL_setFlag_enableCtrl>:
//!             motor commissioning is performed and then subsequent times it is called the
//!             motor starts to run.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
100038f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100038fc:	e28db000 	add	fp, sp, #0
10003900:	e24dd014 	sub	sp, sp, #20
10003904:	e50b0010 	str	r0, [fp, #-16]
10003908:	e1a03001 	mov	r3, r1
1000390c:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003910:	e51b3010 	ldr	r3, [fp, #-16]
10003914:	e50b3008 	str	r3, [fp, #-8]

  obj->flag_enableCtrl = state;
10003918:	e51b3008 	ldr	r3, [fp, #-8]
1000391c:	e55b2011 	ldrb	r2, [fp, #-17]
10003920:	e5c321f4 	strb	r2, [r3, #500]	; 0x1f4

  return;
10003924:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setFlag_enableCtrl() function
10003928:	e24bd000 	sub	sp, fp, #0
1000392c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003930:	e12fff1e 	bx	lr

10003934 <CTRL_setFlag_enableCurrentCtrl>:

//! \brief     Sets the enable current controllers flag value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] state   The desired state
static inline void CTRL_setFlag_enableCurrentCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
10003934:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003938:	e28db000 	add	fp, sp, #0
1000393c:	e24dd014 	sub	sp, sp, #20
10003940:	e50b0010 	str	r0, [fp, #-16]
10003944:	e1a03001 	mov	r3, r1
10003948:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000394c:	e51b3010 	ldr	r3, [fp, #-16]
10003950:	e50b3008 	str	r3, [fp, #-8]

  obj->flag_enableCurrentCtrl = state;
10003954:	e51b3008 	ldr	r3, [fp, #-8]
10003958:	e55b2011 	ldrb	r2, [fp, #-17]
1000395c:	e5c32220 	strb	r2, [r3, #544]	; 0x220

  return;
10003960:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setFlag_enableCurrentCtrl() function
10003964:	e24bd000 	sub	sp, fp, #0
10003968:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000396c:	e12fff1e 	bx	lr

10003970 <CTRL_setFlag_enableDcBusComp>:
//! \details    The DC bus compensation algorithm will compensate the Iq and Id PI controller's
//!             proportional gains for DC bus variations.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableDcBusComp(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
10003970:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003974:	e28db000 	add	fp, sp, #0
10003978:	e24dd014 	sub	sp, sp, #20
1000397c:	e50b0010 	str	r0, [fp, #-16]
10003980:	e1a03001 	mov	r3, r1
10003984:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003988:	e51b3010 	ldr	r3, [fp, #-16]
1000398c:	e50b3008 	str	r3, [fp, #-8]

  obj->flag_enableDcBusComp = state;
10003990:	e51b3008 	ldr	r3, [fp, #-8]
10003994:	e55b2011 	ldrb	r2, [fp, #-17]
10003998:	e5c321f5 	strb	r2, [r3, #501]	; 0x1f5

  return;
1000399c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setFlag_enableDcBusComp() function
100039a0:	e24bd000 	sub	sp, fp, #0
100039a4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100039a8:	e12fff1e 	bx	lr

100039ac <CTRL_setFlag_enablePowerWarp>:
//!             levels so that the least amount of power is used according to the load on
//!             the motor.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enablePowerWarp(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
100039ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100039b0:	e28db000 	add	fp, sp, #0
100039b4:	e24dd014 	sub	sp, sp, #20
100039b8:	e50b0010 	str	r0, [fp, #-16]
100039bc:	e1a03001 	mov	r3, r1
100039c0:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100039c4:	e51b3010 	ldr	r3, [fp, #-16]
100039c8:	e50b3008 	str	r3, [fp, #-8]

  obj->flag_enablePowerWarp = state;
100039cc:	e51b3008 	ldr	r3, [fp, #-8]
100039d0:	e55b2011 	ldrb	r2, [fp, #-17]
100039d4:	e5c321f6 	strb	r2, [r3, #502]	; 0x1f6

  return;
100039d8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setFlag_enablePowerWarp() function
100039dc:	e24bd000 	sub	sp, fp, #0
100039e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100039e4:	e12fff1e 	bx	lr

100039e8 <CTRL_setFlag_enableOffset>:

//! \brief      Sets the enable offset flag value in the estimator
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableOffset(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
100039e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100039ec:	e28db000 	add	fp, sp, #0
100039f0:	e24dd014 	sub	sp, sp, #20
100039f4:	e50b0010 	str	r0, [fp, #-16]
100039f8:	e1a03001 	mov	r3, r1
100039fc:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003a00:	e51b3010 	ldr	r3, [fp, #-16]
10003a04:	e50b3008 	str	r3, [fp, #-8]

  obj->flag_enableOffset = state;
10003a08:	e51b3008 	ldr	r3, [fp, #-8]
10003a0c:	e55b2011 	ldrb	r2, [fp, #-17]
10003a10:	e5c321f7 	strb	r2, [r3, #503]	; 0x1f7

  return;
10003a14:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setFlag_enableOffset() function
10003a18:	e24bd000 	sub	sp, fp, #0
10003a1c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003a20:	e12fff1e 	bx	lr

10003a24 <CTRL_setFlag_enableSpeedCtrl>:

//! \brief      Sets the enable speed control value in the estimator
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableSpeedCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
10003a24:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003a28:	e28db000 	add	fp, sp, #0
10003a2c:	e24dd014 	sub	sp, sp, #20
10003a30:	e50b0010 	str	r0, [fp, #-16]
10003a34:	e1a03001 	mov	r3, r1
10003a38:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003a3c:	e51b3010 	ldr	r3, [fp, #-16]
10003a40:	e50b3008 	str	r3, [fp, #-8]

  obj->flag_enableSpeedCtrl = state;
10003a44:	e51b3008 	ldr	r3, [fp, #-8]
10003a48:	e55b2011 	ldrb	r2, [fp, #-17]
10003a4c:	e5c321f8 	strb	r2, [r3, #504]	; 0x1f8

  return;
10003a50:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setFlag_enableSpeedCtrl() function
10003a54:	e24bd000 	sub	sp, fp, #0
10003a58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003a5c:	e12fff1e 	bx	lr

10003a60 <CTRL_setFlag_enableUserMotorParams>:
//!             in user.h are used instead of performing a motor commissioning at
//!             startup.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableUserMotorParams(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
10003a60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003a64:	e28db000 	add	fp, sp, #0
10003a68:	e24dd014 	sub	sp, sp, #20
10003a6c:	e50b0010 	str	r0, [fp, #-16]
10003a70:	e1a03001 	mov	r3, r1
10003a74:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003a78:	e51b3010 	ldr	r3, [fp, #-16]
10003a7c:	e50b3008 	str	r3, [fp, #-8]

  obj->flag_enableUserMotorParams = state;
10003a80:	e51b3008 	ldr	r3, [fp, #-8]
10003a84:	e55b2011 	ldrb	r2, [fp, #-17]
10003a88:	e5c321f9 	strb	r2, [r3, #505]	; 0x1f9

  return;
10003a8c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setFlag_enableUserMotorParams() function
10003a90:	e24bd000 	sub	sp, fp, #0
10003a94:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003a98:	e12fff1e 	bx	lr

10003a9c <CTRL_setIab_in_pu>:

//! \brief      Sets the alpha/beta current (Iab) input vector values in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  pIab_in_pu  The vector of the alpha/beta current input vector values, pu
static inline void CTRL_setIab_in_pu(CTRL_Handle handle,const MATH_vec2 *pIab_in_pu)//! \Mod By Dl.K
{
10003a9c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003aa0:	e28db000 	add	fp, sp, #0
10003aa4:	e24dd014 	sub	sp, sp, #20
10003aa8:	e50b0010 	str	r0, [fp, #-16]
10003aac:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003ab0:	e51b3010 	ldr	r3, [fp, #-16]
10003ab4:	e50b3008 	str	r3, [fp, #-8]

  obj->Iab_in.value[0] = pIab_in_pu->value[0];
10003ab8:	e51b3014 	ldr	r3, [fp, #-20]
10003abc:	e5932000 	ldr	r2, [r3]
10003ac0:	e51b3008 	ldr	r3, [fp, #-8]
10003ac4:	e5832168 	str	r2, [r3, #360]	; 0x168
  obj->Iab_in.value[1] = pIab_in_pu->value[1];
10003ac8:	e51b3014 	ldr	r3, [fp, #-20]
10003acc:	e5932004 	ldr	r2, [r3, #4]
10003ad0:	e51b3008 	ldr	r3, [fp, #-8]
10003ad4:	e583216c 	str	r2, [r3, #364]	; 0x16c

  return;
10003ad8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setIab_in_pu() function
10003adc:	e24bd000 	sub	sp, fp, #0
10003ae0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003ae4:	e12fff1e 	bx	lr

10003ae8 <CTRL_setIdq_in_pu>:

//! \brief      Sets the direct/quadrature current (Idq) input vector values in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  pIdq_in_pu  The vector of the direct/quadrature current input vector values, pu
static inline void CTRL_setIdq_in_pu(CTRL_Handle handle,const MATH_vec2 *pIdq_in_pu)//! \Mod By Dl.K
{
10003ae8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003aec:	e28db000 	add	fp, sp, #0
10003af0:	e24dd014 	sub	sp, sp, #20
10003af4:	e50b0010 	str	r0, [fp, #-16]
10003af8:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003afc:	e51b3010 	ldr	r3, [fp, #-16]
10003b00:	e50b3008 	str	r3, [fp, #-8]

  obj->Idq_in.value[0] = pIdq_in_pu->value[0];
10003b04:	e51b3014 	ldr	r3, [fp, #-20]
10003b08:	e5932000 	ldr	r2, [r3]
10003b0c:	e51b3008 	ldr	r3, [fp, #-8]
10003b10:	e5832178 	str	r2, [r3, #376]	; 0x178
  obj->Idq_in.value[1] = pIdq_in_pu->value[1];
10003b14:	e51b3014 	ldr	r3, [fp, #-20]
10003b18:	e5932004 	ldr	r2, [r3, #4]
10003b1c:	e51b3008 	ldr	r3, [fp, #-8]
10003b20:	e583217c 	str	r2, [r3, #380]	; 0x17c

  return;
10003b24:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setIdq_in_pu() function
10003b28:	e24bd000 	sub	sp, fp, #0
10003b2c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003b30:	e12fff1e 	bx	lr

10003b34 <CTRL_setIdq_offset_pu>:

//! \brief     Sets the direct/quadrature current (Idq) offset vector values in the controller
//! \param[in] handle          The controller (CTRL) handle
//! \param[in] pIdq_offset_pu  The vector of the direct/quadrature current offset vector values, pu
static inline void CTRL_setIdq_offset_pu(CTRL_Handle handle,const MATH_vec2 *pIdq_offset_pu)//! \Mod By Dl.K
{
10003b34:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003b38:	e28db000 	add	fp, sp, #0
10003b3c:	e24dd014 	sub	sp, sp, #20
10003b40:	e50b0010 	str	r0, [fp, #-16]
10003b44:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003b48:	e51b3010 	ldr	r3, [fp, #-16]
10003b4c:	e50b3008 	str	r3, [fp, #-8]

  obj->Idq_offset_pu.value[0] = pIdq_offset_pu->value[0];
10003b50:	e51b3014 	ldr	r3, [fp, #-20]
10003b54:	e5932000 	ldr	r2, [r3]
10003b58:	e51b3008 	ldr	r3, [fp, #-8]
10003b5c:	e58321fc 	str	r2, [r3, #508]	; 0x1fc
  obj->Idq_offset_pu.value[1] = pIdq_offset_pu->value[1];
10003b60:	e51b3014 	ldr	r3, [fp, #-20]
10003b64:	e5932004 	ldr	r2, [r3, #4]
10003b68:	e51b3008 	ldr	r3, [fp, #-8]
10003b6c:	e5832200 	str	r2, [r3, #512]	; 0x200

  return;
10003b70:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setIdq_offset_pu() function
10003b74:	e24bd000 	sub	sp, fp, #0
10003b78:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003b7c:	e12fff1e 	bx	lr

10003b80 <CTRL_setIdq_ref_pu>:

//! \brief      Sets the direct/quadrature current (Idq) reference vector values in the controller
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  pIdq_ref_pu  The vector of the direct/quadrature current reference vector values, pu
static inline void CTRL_setIdq_ref_pu(CTRL_Handle handle,const MATH_vec2 *pIdq_ref_pu)//! \Mod By Dl.K
{
10003b80:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003b84:	e28db000 	add	fp, sp, #0
10003b88:	e24dd014 	sub	sp, sp, #20
10003b8c:	e50b0010 	str	r0, [fp, #-16]
10003b90:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003b94:	e51b3010 	ldr	r3, [fp, #-16]
10003b98:	e50b3008 	str	r3, [fp, #-8]

  obj->Idq_ref.value[0] = pIdq_ref_pu->value[0];
10003b9c:	e51b3014 	ldr	r3, [fp, #-20]
10003ba0:	e5932000 	ldr	r2, [r3]
10003ba4:	e51b3008 	ldr	r3, [fp, #-8]
10003ba8:	e58321d8 	str	r2, [r3, #472]	; 0x1d8
  obj->Idq_ref.value[1] = pIdq_ref_pu->value[1];
10003bac:	e51b3014 	ldr	r3, [fp, #-20]
10003bb0:	e5932004 	ldr	r2, [r3, #4]
10003bb4:	e51b3008 	ldr	r3, [fp, #-8]
10003bb8:	e58321dc 	str	r2, [r3, #476]	; 0x1dc

  return;
10003bbc:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setIdq_ref_pu() function
10003bc0:	e24bd000 	sub	sp, fp, #0
10003bc4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003bc8:	e12fff1e 	bx	lr

10003bcc <CTRL_setIdRated_pu>:

//! \brief      Sets the Id rated current value in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  IdRated_pu  The Id rated current value, pu
static inline void CTRL_setIdRated_pu(CTRL_Handle handle,const float_t IdRated_pu)//! \Mod By Dl.K
{
10003bcc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003bd0:	e28db000 	add	fp, sp, #0
10003bd4:	e24dd014 	sub	sp, sp, #20
10003bd8:	e50b0010 	str	r0, [fp, #-16]
10003bdc:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003be0:	e51b3010 	ldr	r3, [fp, #-16]
10003be4:	e50b3008 	str	r3, [fp, #-8]

  obj->IdRated = IdRated_pu;
10003be8:	e51b3008 	ldr	r3, [fp, #-8]
10003bec:	e51b2014 	ldr	r2, [fp, #-20]
10003bf0:	e58321e0 	str	r2, [r3, #480]	; 0x1e0

  return;
10003bf4:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setIdRated_pu() function
10003bf8:	e24bd000 	sub	sp, fp, #0
10003bfc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003c00:	e12fff1e 	bx	lr

10003c04 <CTRL_setKd>:
//! \brief      Sets the derivative gain (Kd) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Kd        The Kd value
static inline void CTRL_setKd(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Kd)//! \Mod By Dl.K
{
10003c04:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003c08:	e28db000 	add	fp, sp, #0
10003c0c:	e24dd01c 	sub	sp, sp, #28
10003c10:	e50b0010 	str	r0, [fp, #-16]
10003c14:	e1a03001 	mov	r3, r1
10003c18:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
10003c1c:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003c20:	e51b3010 	ldr	r3, [fp, #-16]
10003c24:	e50b3008 	str	r3, [fp, #-8]

  if(ctrlType == CTRL_Type_PID_spd)
10003c28:	e55b3011 	ldrb	r3, [fp, #-17]
10003c2c:	e3530000 	cmp	r3, #0
10003c30:	1a000003 	bne	10003c44 <CTRL_setKd+0x40>
    {
      obj->Kd_spd = Kd;
10003c34:	e51b3008 	ldr	r3, [fp, #-8]
10003c38:	e51b2018 	ldr	r2, [fp, #-24]
10003c3c:	e58321c8 	str	r2, [r3, #456]	; 0x1c8
10003c40:	ea00000c 	b	10003c78 <CTRL_setKd+0x74>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
10003c44:	e55b3011 	ldrb	r3, [fp, #-17]
10003c48:	e3530001 	cmp	r3, #1
10003c4c:	1a000003 	bne	10003c60 <CTRL_setKd+0x5c>
    {
      obj->Kd_Id = Kd;
10003c50:	e51b3008 	ldr	r3, [fp, #-8]
10003c54:	e51b2018 	ldr	r2, [fp, #-24]
10003c58:	e58321c0 	str	r2, [r3, #448]	; 0x1c0
10003c5c:	ea000005 	b	10003c78 <CTRL_setKd+0x74>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
10003c60:	e55b3011 	ldrb	r3, [fp, #-17]
10003c64:	e3530002 	cmp	r3, #2
10003c68:	1a000002 	bne	10003c78 <CTRL_setKd+0x74>
    {
      obj->Kd_Iq = Kd;
10003c6c:	e51b3008 	ldr	r3, [fp, #-8]
10003c70:	e51b2018 	ldr	r2, [fp, #-24]
10003c74:	e58321c4 	str	r2, [r3, #452]	; 0x1c4
    }

  return;
10003c78:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setKd() function
10003c7c:	e24bd000 	sub	sp, fp, #0
10003c80:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003c84:	e12fff1e 	bx	lr

10003c88 <CTRL_setKi>:
//! \brief      Sets the integral gain (Ki) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Ki        The Ki value
static inline void CTRL_setKi(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Ki)//! \Mod By Dl.K
{
10003c88:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003c8c:	e28db000 	add	fp, sp, #0
10003c90:	e24dd01c 	sub	sp, sp, #28
10003c94:	e50b0010 	str	r0, [fp, #-16]
10003c98:	e1a03001 	mov	r3, r1
10003c9c:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
10003ca0:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003ca4:	e51b3010 	ldr	r3, [fp, #-16]
10003ca8:	e50b3008 	str	r3, [fp, #-8]

  if(ctrlType == CTRL_Type_PID_spd)
10003cac:	e55b3011 	ldrb	r3, [fp, #-17]
10003cb0:	e3530000 	cmp	r3, #0
10003cb4:	1a000003 	bne	10003cc8 <CTRL_setKi+0x40>
    {
      obj->Ki_spd = Ki;
10003cb8:	e51b3008 	ldr	r3, [fp, #-8]
10003cbc:	e51b2018 	ldr	r2, [fp, #-24]
10003cc0:	e58321bc 	str	r2, [r3, #444]	; 0x1bc
10003cc4:	ea00000c 	b	10003cfc <CTRL_setKi+0x74>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
10003cc8:	e55b3011 	ldrb	r3, [fp, #-17]
10003ccc:	e3530001 	cmp	r3, #1
10003cd0:	1a000003 	bne	10003ce4 <CTRL_setKi+0x5c>
    {
      obj->Ki_Id = Ki;
10003cd4:	e51b3008 	ldr	r3, [fp, #-8]
10003cd8:	e51b2018 	ldr	r2, [fp, #-24]
10003cdc:	e58321b4 	str	r2, [r3, #436]	; 0x1b4
10003ce0:	ea000005 	b	10003cfc <CTRL_setKi+0x74>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
10003ce4:	e55b3011 	ldrb	r3, [fp, #-17]
10003ce8:	e3530002 	cmp	r3, #2
10003cec:	1a000002 	bne	10003cfc <CTRL_setKi+0x74>
    {
      obj->Ki_Iq = Ki;
10003cf0:	e51b3008 	ldr	r3, [fp, #-8]
10003cf4:	e51b2018 	ldr	r2, [fp, #-24]
10003cf8:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
    }

  return;
10003cfc:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setKi() function
10003d00:	e24bd000 	sub	sp, fp, #0
10003d04:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003d08:	e12fff1e 	bx	lr

10003d0c <CTRL_setKp>:
//! \brief      Sets the proportional gain (Kp) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Kp        The Kp value
static inline void CTRL_setKp(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Kp)//! \Mod By Dl.K
{
10003d0c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003d10:	e28db000 	add	fp, sp, #0
10003d14:	e24dd01c 	sub	sp, sp, #28
10003d18:	e50b0010 	str	r0, [fp, #-16]
10003d1c:	e1a03001 	mov	r3, r1
10003d20:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
10003d24:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003d28:	e51b3010 	ldr	r3, [fp, #-16]
10003d2c:	e50b3008 	str	r3, [fp, #-8]

  if(ctrlType == CTRL_Type_PID_spd)
10003d30:	e55b3011 	ldrb	r3, [fp, #-17]
10003d34:	e3530000 	cmp	r3, #0
10003d38:	1a000003 	bne	10003d4c <CTRL_setKp+0x40>
    {
      obj->Kp_spd = Kp;
10003d3c:	e51b3008 	ldr	r3, [fp, #-8]
10003d40:	e51b2018 	ldr	r2, [fp, #-24]
10003d44:	e58321b0 	str	r2, [r3, #432]	; 0x1b0
10003d48:	ea00000c 	b	10003d80 <CTRL_setKp+0x74>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
10003d4c:	e55b3011 	ldrb	r3, [fp, #-17]
10003d50:	e3530001 	cmp	r3, #1
10003d54:	1a000003 	bne	10003d68 <CTRL_setKp+0x5c>
    {
      obj->Kp_Id = Kp;
10003d58:	e51b3008 	ldr	r3, [fp, #-8]
10003d5c:	e51b2018 	ldr	r2, [fp, #-24]
10003d60:	e58321a8 	str	r2, [r3, #424]	; 0x1a8
10003d64:	ea000005 	b	10003d80 <CTRL_setKp+0x74>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
10003d68:	e55b3011 	ldrb	r3, [fp, #-17]
10003d6c:	e3530002 	cmp	r3, #2
10003d70:	1a000002 	bne	10003d80 <CTRL_setKp+0x74>
    {
      obj->Kp_Iq = Kp;
10003d74:	e51b3008 	ldr	r3, [fp, #-8]
10003d78:	e51b2018 	ldr	r2, [fp, #-24]
10003d7c:	e58321ac 	str	r2, [r3, #428]	; 0x1ac
    }

  return;
10003d80:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setKp() function
10003d84:	e24bd000 	sub	sp, fp, #0
10003d88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003d8c:	e12fff1e 	bx	lr

10003d90 <CTRL_setLhf>:

//! \brief      Sets the high frequency inductance (Lhf) value in the controller
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  Lhf     The Lhf value
static inline void CTRL_setLhf(CTRL_Handle handle,const float_t Lhf)//! \Mod By Dl.K
{
10003d90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003d94:	e28db000 	add	fp, sp, #0
10003d98:	e24dd014 	sub	sp, sp, #20
10003d9c:	e50b0010 	str	r0, [fp, #-16]
10003da0:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003da4:	e51b3010 	ldr	r3, [fp, #-16]
10003da8:	e50b3008 	str	r3, [fp, #-8]

  obj->Lhf = Lhf;
10003dac:	e51b3008 	ldr	r3, [fp, #-8]
10003db0:	e51b2014 	ldr	r2, [fp, #-20]
10003db4:	e58321a0 	str	r2, [r3, #416]	; 0x1a0

  return;
10003db8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setLhf() function
10003dbc:	e24bd000 	sub	sp, fp, #0
10003dc0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003dc4:	e12fff1e 	bx	lr

10003dc8 <CTRL_setMaxVsMag_pu>:

//! \brief      Sets the maximum voltage vector in the controller
//! \param[in]  handle        The controller (CTRL) handle
//! \param[in]  maxVsMag      The maximum voltage vector (value betwen 0 and 4/3)
static inline void CTRL_setMaxVsMag_pu(CTRL_Handle handle,const float_t maxVsMag)//! \Mod By Dl.K
{
10003dc8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003dcc:	e28db000 	add	fp, sp, #0
10003dd0:	e24dd014 	sub	sp, sp, #20
10003dd4:	e50b0010 	str	r0, [fp, #-16]
10003dd8:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003ddc:	e51b3010 	ldr	r3, [fp, #-16]
10003de0:	e50b3008 	str	r3, [fp, #-8]

  obj->maxVsMag_pu = maxVsMag;
10003de4:	e51b3008 	ldr	r3, [fp, #-8]
10003de8:	e51b2014 	ldr	r2, [fp, #-20]
10003dec:	e5832164 	str	r2, [r3, #356]	; 0x164

  return;
10003df0:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setmaxVsMag_pu() function
10003df4:	e24bd000 	sub	sp, fp, #0
10003df8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003dfc:	e12fff1e 	bx	lr

10003e00 <CTRL_setMotorParams>:
                                const float_t ratedFlux,
                                const float_t Ls_d,
                                const float_t Ls_q,
                                const float_t Rr,
                                const float_t Rs)//! \Mod By Dl.K
{
10003e00:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003e04:	e28db000 	add	fp, sp, #0
10003e08:	e24dd02c 	sub	sp, sp, #44	; 0x2c
10003e0c:	e50b0010 	str	r0, [fp, #-16]
10003e10:	e1a03002 	mov	r3, r2
10003e14:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
10003e18:	ed4b0a07 	vstr	s1, [fp, #-28]	; 0xffffffe4
10003e1c:	ed0b1a08 	vstr	s2, [fp, #-32]	; 0xffffffe0
10003e20:	ed4b1a09 	vstr	s3, [fp, #-36]	; 0xffffffdc
10003e24:	ed0b2a0a 	vstr	s4, [fp, #-40]	; 0xffffffd8
10003e28:	e1a02001 	mov	r2, r1
10003e2c:	e54b2011 	strb	r2, [fp, #-17]
10003e30:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003e34:	e51b3010 	ldr	r3, [fp, #-16]
10003e38:	e50b3008 	str	r3, [fp, #-8]

  obj->motorParams.type = motorType;
10003e3c:	e51b3008 	ldr	r3, [fp, #-8]
10003e40:	e55b2011 	ldrb	r2, [fp, #-17]
10003e44:	e5c32104 	strb	r2, [r3, #260]	; 0x104
  obj->motorParams.numPolePairs = numPolePairs;
10003e48:	e51b3008 	ldr	r3, [fp, #-8]
10003e4c:	e2833f41 	add	r3, r3, #260	; 0x104
10003e50:	e2833002 	add	r3, r3, #2
10003e54:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
10003e58:	e1c320b0 	strh	r2, [r3]
  obj->motorParams.ratedFlux_VpHz = ratedFlux;
10003e5c:	e51b3008 	ldr	r3, [fp, #-8]
10003e60:	e51b2018 	ldr	r2, [fp, #-24]
10003e64:	e583211c 	str	r2, [r3, #284]	; 0x11c
  obj->motorParams.Ls_d_H = Ls_d;
10003e68:	e51b3008 	ldr	r3, [fp, #-8]
10003e6c:	e51b201c 	ldr	r2, [fp, #-28]
10003e70:	e583210c 	str	r2, [r3, #268]	; 0x10c
  obj->motorParams.Ls_q_H = Ls_q;
10003e74:	e51b3008 	ldr	r3, [fp, #-8]
10003e78:	e51b2020 	ldr	r2, [fp, #-32]
10003e7c:	e5832110 	str	r2, [r3, #272]	; 0x110
  obj->motorParams.Rr_Ohm = Rr;
10003e80:	e51b3008 	ldr	r3, [fp, #-8]
10003e84:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10003e88:	e5832114 	str	r2, [r3, #276]	; 0x114
  obj->motorParams.Rs_Ohm = Rs;
10003e8c:	e51b3008 	ldr	r3, [fp, #-8]
10003e90:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10003e94:	e5832118 	str	r2, [r3, #280]	; 0x118

  return;
10003e98:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setMotorParams() function
10003e9c:	e24bd000 	sub	sp, fp, #0
10003ea0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003ea4:	e12fff1e 	bx	lr

10003ea8 <CTRL_setNumCtrlTicksPerCurrentTick>:
//! \brief     Sets the number of controller clock ticks per current controller clock tick
//! \param[in] handle                      The controller (CTRL) handle
//! \param[in] numCtrlTicksPerCurrentTick  The number of controller clock ticks per estimator clock tick
static inline void CTRL_setNumCtrlTicksPerCurrentTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerCurrentTick)//! \Mod By Dl.K
{
10003ea8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003eac:	e28db000 	add	fp, sp, #0
10003eb0:	e24dd014 	sub	sp, sp, #20
10003eb4:	e50b0010 	str	r0, [fp, #-16]
10003eb8:	e1a03001 	mov	r3, r1
10003ebc:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003ec0:	e51b3010 	ldr	r3, [fp, #-16]
10003ec4:	e50b3008 	str	r3, [fp, #-8]

  obj->numCtrlTicksPerCurrentTick = numCtrlTicksPerCurrentTick;
10003ec8:	e51b3008 	ldr	r3, [fp, #-8]
10003ecc:	e2833f53 	add	r3, r3, #332	; 0x14c
10003ed0:	e2833002 	add	r3, r3, #2
10003ed4:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
10003ed8:	e1c320b0 	strh	r2, [r3]

  return;
10003edc:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setNumCtrlTicksPerCurrentTick() function
10003ee0:	e24bd000 	sub	sp, fp, #0
10003ee4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003ee8:	e12fff1e 	bx	lr

10003eec <CTRL_setNumCtrlTicksPerSpeedTick>:
//! \brief     Sets the number of controller clock ticks per speed controller clock tick
//! \param[in] handle                    The controller (CTRL) handle
//! \param[in] numCtrlTicksPerSpeedTick  The number of controller clock ticks per speed clock tick
static inline void CTRL_setNumCtrlTicksPerSpeedTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerSpeedTick)//! \Mod By Dl.K
{
10003eec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003ef0:	e28db000 	add	fp, sp, #0
10003ef4:	e24dd014 	sub	sp, sp, #20
10003ef8:	e50b0010 	str	r0, [fp, #-16]
10003efc:	e1a03001 	mov	r3, r1
10003f00:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003f04:	e51b3010 	ldr	r3, [fp, #-16]
10003f08:	e50b3008 	str	r3, [fp, #-8]

  obj->numCtrlTicksPerSpeedTick = numCtrlTicksPerSpeedTick;
10003f0c:	e51b3008 	ldr	r3, [fp, #-8]
10003f10:	e2833e15 	add	r3, r3, #336	; 0x150
10003f14:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
10003f18:	e1c320b0 	strh	r2, [r3]

  return;
10003f1c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setNumCtrlTicksPerSpeedTick() function
10003f20:	e24bd000 	sub	sp, fp, #0
10003f24:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003f28:	e12fff1e 	bx	lr

10003f2c <CTRL_setNumCtrlTicksPerTrajTick>:
//! \brief     Sets the number of controller clock ticks per trajectory clock tick
//! \param[in] handle                   The controller (CTRL) handle
//! \param[in] numCtrlTicksPerTrajTick  The number of controller clock ticks per trajectory clock tick
static inline void CTRL_setNumCtrlTicksPerTrajTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerTrajTick)//! \Mod By Dl.K
{
10003f2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003f30:	e28db000 	add	fp, sp, #0
10003f34:	e24dd014 	sub	sp, sp, #20
10003f38:	e50b0010 	str	r0, [fp, #-16]
10003f3c:	e1a03001 	mov	r3, r1
10003f40:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003f44:	e51b3010 	ldr	r3, [fp, #-16]
10003f48:	e50b3008 	str	r3, [fp, #-8]

  obj->numCtrlTicksPerTrajTick = numCtrlTicksPerTrajTick;
10003f4c:	e51b3008 	ldr	r3, [fp, #-8]
10003f50:	e2833e15 	add	r3, r3, #336	; 0x150
10003f54:	e2833002 	add	r3, r3, #2
10003f58:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
10003f5c:	e1c320b0 	strh	r2, [r3]

  return;
10003f60:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setNumCtrlTicksPerTrajTick() function
10003f64:	e24bd000 	sub	sp, fp, #0
10003f68:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003f6c:	e12fff1e 	bx	lr

10003f70 <CTRL_setNumIsrTicksPerCtrlTick>:
//! \brief     Sets the number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
//! \param[in] handle                  The controller (CTRL) handle
//! \param[in] numIsrTicksPerCtrlTick  The number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
static inline void CTRL_setNumIsrTicksPerCtrlTick(CTRL_Handle handle,
                                           const uint_least16_t numIsrTicksPerCtrlTick)//! \Mod By Dl.K
{
10003f70:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003f74:	e28db000 	add	fp, sp, #0
10003f78:	e24dd014 	sub	sp, sp, #20
10003f7c:	e50b0010 	str	r0, [fp, #-16]
10003f80:	e1a03001 	mov	r3, r1
10003f84:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003f88:	e51b3010 	ldr	r3, [fp, #-16]
10003f8c:	e50b3008 	str	r3, [fp, #-8]

  obj->numIsrTicksPerCtrlTick = numIsrTicksPerCtrlTick;
10003f90:	e51b3008 	ldr	r3, [fp, #-8]
10003f94:	e2833f53 	add	r3, r3, #332	; 0x14c
10003f98:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
10003f9c:	e1c320b0 	strh	r2, [r3]

  return;
10003fa0:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setNumIsrTicksPerCtrlTick() function
10003fa4:	e24bd000 	sub	sp, fp, #0
10003fa8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003fac:	e12fff1e 	bx	lr

10003fb0 <CTRL_setRhf>:

//! \brief     Sets the high frequency resistance (Rhf) value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] Rhf     The Rhf value
static inline void CTRL_setRhf(CTRL_Handle handle,const float_t Rhf)//! \Mod By Dl.K
{
10003fb0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003fb4:	e28db000 	add	fp, sp, #0
10003fb8:	e24dd014 	sub	sp, sp, #20
10003fbc:	e50b0010 	str	r0, [fp, #-16]
10003fc0:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003fc4:	e51b3010 	ldr	r3, [fp, #-16]
10003fc8:	e50b3008 	str	r3, [fp, #-8]

  obj->Rhf = Rhf;
10003fcc:	e51b3008 	ldr	r3, [fp, #-8]
10003fd0:	e51b2014 	ldr	r2, [fp, #-20]
10003fd4:	e583219c 	str	r2, [r3, #412]	; 0x19c

  return;
10003fd8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setRhf() function
10003fdc:	e24bd000 	sub	sp, fp, #0
10003fe0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10003fe4:	e12fff1e 	bx	lr

10003fe8 <CTRL_setRoverL>:

//! \brief     Sets the R/L value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] RoverL  The R/L value
static inline void CTRL_setRoverL(CTRL_Handle handle,const float_t RoverL)//! \Mod By Dl.K
{
10003fe8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10003fec:	e28db000 	add	fp, sp, #0
10003ff0:	e24dd014 	sub	sp, sp, #20
10003ff4:	e50b0010 	str	r0, [fp, #-16]
10003ff8:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10003ffc:	e51b3010 	ldr	r3, [fp, #-16]
10004000:	e50b3008 	str	r3, [fp, #-8]

  obj->RoverL = RoverL;
10004004:	e51b3008 	ldr	r3, [fp, #-8]
10004008:	e51b2014 	ldr	r2, [fp, #-20]
1000400c:	e58321a4 	str	r2, [r3, #420]	; 0x1a4

  return;
10004010:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setRoverL() function
10004014:	e24bd000 	sub	sp, fp, #0
10004018:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000401c:	e12fff1e 	bx	lr

10004020 <CTRL_setSpeed_fb_pu>:

//! \brief     Sets the feedback speed value in the controller
//! \param[in] handle       The controller (CTRL) handle
//! \param[in] speed_fb_pu  The feedback speed value, pu
static inline void CTRL_setSpeed_fb_pu(CTRL_Handle handle,const float_t speed_fb_pu)//! \Mod By Dl.K
{
10004020:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004024:	e28db000 	add	fp, sp, #0
10004028:	e24dd014 	sub	sp, sp, #20
1000402c:	e50b0010 	str	r0, [fp, #-16]
10004030:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10004034:	e51b3010 	ldr	r3, [fp, #-16]
10004038:	e50b3008 	str	r3, [fp, #-8]

  obj->speed_fb_pu = speed_fb_pu;
1000403c:	e51b3008 	ldr	r3, [fp, #-8]
10004040:	e51b2014 	ldr	r2, [fp, #-20]
10004044:	e5832218 	str	r2, [r3, #536]	; 0x218

  return;
10004048:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setSpeed_fb_pu() function
1000404c:	e24bd000 	sub	sp, fp, #0
10004050:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004054:	e12fff1e 	bx	lr

10004058 <CTRL_setSpd_max_pu>:

//! \brief     Sets the maximum speed value in the controller
//! \param[in] handle     The controller (CTRL) handle
//! \param[in] maxSpd_pu  The maximum speed value, pu
static inline void CTRL_setSpd_max_pu(CTRL_Handle handle,const float_t maxSpd_pu)//! \Mod By Dl.K
{
10004058:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000405c:	e28db000 	add	fp, sp, #0
10004060:	e24dd014 	sub	sp, sp, #20
10004064:	e50b0010 	str	r0, [fp, #-16]
10004068:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000406c:	e51b3010 	ldr	r3, [fp, #-16]
10004070:	e50b3008 	str	r3, [fp, #-8]

  obj->spd_max = maxSpd_pu;
10004074:	e51b3008 	ldr	r3, [fp, #-8]
10004078:	e51b2014 	ldr	r2, [fp, #-20]
1000407c:	e58321e8 	str	r2, [r3, #488]	; 0x1e8

  return;
10004080:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setSpd_max_pu() function
10004084:	e24bd000 	sub	sp, fp, #0
10004088:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000408c:	e12fff1e 	bx	lr

10004090 <CTRL_setSpd_out_pu>:

//! \brief     Sets the output speed value in the controller
//! \param[in] handle      The controller (CTRL) handle
//! \param[in] spd_out_pu  The output speed value, pu
static inline void CTRL_setSpd_out_pu(CTRL_Handle handle,const float_t spd_out_pu)//! \Mod By Dl.K
{
10004090:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004094:	e28db000 	add	fp, sp, #0
10004098:	e24dd014 	sub	sp, sp, #20
1000409c:	e50b0010 	str	r0, [fp, #-16]
100040a0:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100040a4:	e51b3010 	ldr	r3, [fp, #-16]
100040a8:	e50b3008 	str	r3, [fp, #-8]

  obj->spd_out = spd_out_pu;
100040ac:	e51b3008 	ldr	r3, [fp, #-8]
100040b0:	e51b2014 	ldr	r2, [fp, #-20]
100040b4:	e5832188 	str	r2, [r3, #392]	; 0x188

  return;
100040b8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setSpd_out_pu() function
100040bc:	e24bd000 	sub	sp, fp, #0
100040c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100040c4:	e12fff1e 	bx	lr

100040c8 <CTRL_setSpeed_outMax_pu>:

//! \brief      Sets the maximum output value for the speed controller
//! \param[in]  handle           The controller (CTRL) handle
//! \param[in]  speed_outMax_pu  The maximum output value for the speed controller
static inline void CTRL_setSpeed_outMax_pu(CTRL_Handle handle,const float_t speed_outMax_pu)//! \Mod By Dl.K
{
100040c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100040cc:	e28db000 	add	fp, sp, #0
100040d0:	e24dd014 	sub	sp, sp, #20
100040d4:	e50b0010 	str	r0, [fp, #-16]
100040d8:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100040dc:	e51b3010 	ldr	r3, [fp, #-16]
100040e0:	e50b3008 	str	r3, [fp, #-8]

  obj->speed_outMax_pu = speed_outMax_pu;
100040e4:	e51b3008 	ldr	r3, [fp, #-8]
100040e8:	e51b2014 	ldr	r2, [fp, #-20]
100040ec:	e583221c 	str	r2, [r3, #540]	; 0x21c

  return;
100040f0:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setSpeed_outMax_pu() function
100040f4:	e24bd000 	sub	sp, fp, #0
100040f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100040fc:	e12fff1e 	bx	lr

10004100 <CTRL_setSpeed_ref_pu>:

//! \brief     Sets the output speed reference value in the controller
//! \param[in] handle        The controller (CTRL) handle
//! \param[in] speed_ref_pu  The output speed reference value, pu
static inline void CTRL_setSpeed_ref_pu(CTRL_Handle handle,const float_t speed_ref_pu)//! \Mod By Dl.K
{
10004100:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004104:	e28db000 	add	fp, sp, #0
10004108:	e24dd014 	sub	sp, sp, #20
1000410c:	e50b0010 	str	r0, [fp, #-16]
10004110:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10004114:	e51b3010 	ldr	r3, [fp, #-16]
10004118:	e50b3008 	str	r3, [fp, #-8]

  obj->speed_ref_pu = speed_ref_pu;
1000411c:	e51b3008 	ldr	r3, [fp, #-8]
10004120:	e51b2014 	ldr	r2, [fp, #-20]
10004124:	e5832214 	str	r2, [r3, #532]	; 0x214

  return;
10004128:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setSpeed_ref_pu() function
1000412c:	e24bd000 	sub	sp, fp, #0
10004130:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004134:	e12fff1e 	bx	lr

10004138 <CTRL_setState>:

//! \brief     Sets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] state       The new state
static inline void CTRL_setState(CTRL_Handle handle,const CTRL_State_e state)//! \Mod By Dl.K
{
10004138:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000413c:	e28db000 	add	fp, sp, #0
10004140:	e24dd014 	sub	sp, sp, #20
10004144:	e50b0010 	str	r0, [fp, #-16]
10004148:	e1a03001 	mov	r3, r1
1000414c:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10004150:	e51b3010 	ldr	r3, [fp, #-16]
10004154:	e50b3008 	str	r3, [fp, #-8]

  obj->prevState = obj->state;
10004158:	e51b3008 	ldr	r3, [fp, #-8]
1000415c:	e5d32008 	ldrb	r2, [r3, #8]
10004160:	e51b3008 	ldr	r3, [fp, #-8]
10004164:	e5c32009 	strb	r2, [r3, #9]
  obj->state = state;
10004168:	e51b3008 	ldr	r3, [fp, #-8]
1000416c:	e55b2011 	ldrb	r2, [fp, #-17]
10004170:	e5c32008 	strb	r2, [r3, #8]

  return;
10004174:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setState() function
10004178:	e24bd000 	sub	sp, fp, #0
1000417c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004180:	e12fff1e 	bx	lr

10004184 <CTRL_setTrajFreq_Hz>:

//! \brief      Sets the trajectory execution frequency
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  trajFreq_Hz  The trajectory execution frequency, Hz
static inline void CTRL_setTrajFreq_Hz(CTRL_Handle handle,const uint_least32_t trajFreq_Hz)//! \Mod By Dl.K
{
10004184:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004188:	e28db000 	add	fp, sp, #0
1000418c:	e24dd014 	sub	sp, sp, #20
10004190:	e50b0010 	str	r0, [fp, #-16]
10004194:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10004198:	e51b3010 	ldr	r3, [fp, #-16]
1000419c:	e50b3008 	str	r3, [fp, #-8]

  obj->trajFreq_Hz = trajFreq_Hz;
100041a0:	e51b3008 	ldr	r3, [fp, #-8]
100041a4:	e51b2014 	ldr	r2, [fp, #-20]
100041a8:	e5832158 	str	r2, [r3, #344]	; 0x158

  return;
100041ac:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setTrajFreq_Hz() function
100041b0:	e24bd000 	sub	sp, fp, #0
100041b4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100041b8:	e12fff1e 	bx	lr

100041bc <CTRL_setTrajPeriod_sec>:

//! \brief      Sets the trajectory execution period
//! \param[in]  handle          The controller (CTRL) handle
//! \param[in]  trajPeriod_sec  The trajectory execution period, sec
static inline void CTRL_setTrajPeriod_sec(CTRL_Handle handle,const float_t trajPeriod_sec)//! \Mod By Dl.K
{
100041bc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100041c0:	e28db000 	add	fp, sp, #0
100041c4:	e24dd014 	sub	sp, sp, #20
100041c8:	e50b0010 	str	r0, [fp, #-16]
100041cc:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100041d0:	e51b3010 	ldr	r3, [fp, #-16]
100041d4:	e50b3008 	str	r3, [fp, #-8]

  obj->trajPeriod_sec = trajPeriod_sec;
100041d8:	e51b3008 	ldr	r3, [fp, #-8]
100041dc:	e51b2014 	ldr	r2, [fp, #-20]
100041e0:	e583215c 	str	r2, [r3, #348]	; 0x15c

  return;
100041e4:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setTrajPeriod_sec() function
100041e8:	e24bd000 	sub	sp, fp, #0
100041ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100041f0:	e12fff1e 	bx	lr

100041f4 <CTRL_setupEstIdleState>:


//! \brief Sets up the controller and trajectory generator for the estimator idle state
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_setupEstIdleState(CTRL_Handle handle)
{
100041f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100041f8:	e28db000 	add	fp, sp, #0
100041fc:	e24dd00c 	sub	sp, sp, #12
10004200:	e50b0008 	str	r0, [fp, #-8]
}
10004204:	e24bd000 	sub	sp, fp, #0
10004208:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000420c:	e12fff1e 	bx	lr

10004210 <CTRL_setupEstOnLineState>:


//! \brief     Sets up the controller and trajectory generator for the estimator online state
//! \param[in] handle   The controller (CTRL) handle
static inline void CTRL_setupEstOnLineState(CTRL_Handle handle)
{
10004210:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004214:	e28db000 	add	fp, sp, #0
10004218:	e24dd00c 	sub	sp, sp, #12
1000421c:	e50b0008 	str	r0, [fp, #-8]
}
10004220:	e24bd000 	sub	sp, fp, #0
10004224:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004228:	e12fff1e 	bx	lr

1000422c <CTRL_setUserMotorParams>:


//! \brief Sets the controller and estimator with motor parameters from the user.h file
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_setUserMotorParams(CTRL_Handle handle)
{
1000422c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004230:	e28db000 	add	fp, sp, #0
10004234:	e24dd00c 	sub	sp, sp, #12
10004238:	e50b0008 	str	r0, [fp, #-8]
}
1000423c:	e24bd000 	sub	sp, fp, #0
10004240:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004244:	e12fff1e 	bx	lr

10004248 <CTRL_setVab_in_pu>:

//! \brief     Sets the alpha/beta voltage input vector values in the controller
//! \param[in] handle      The controller (CTRL) handle
//! \param[in] pVab_in_pu  The vector of alpha/beta voltage input vector values, pu
static inline void CTRL_setVab_in_pu(CTRL_Handle handle,const MATH_vec2 *pVab_in_pu)//! \Mod By Dl.K
{
10004248:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000424c:	e28db000 	add	fp, sp, #0
10004250:	e24dd014 	sub	sp, sp, #20
10004254:	e50b0010 	str	r0, [fp, #-16]
10004258:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000425c:	e51b3010 	ldr	r3, [fp, #-16]
10004260:	e50b3008 	str	r3, [fp, #-8]

  obj->Vab_in.value[0] = pVab_in_pu->value[0];
10004264:	e51b3014 	ldr	r3, [fp, #-20]
10004268:	e5932000 	ldr	r2, [r3]
1000426c:	e51b3008 	ldr	r3, [fp, #-8]
10004270:	e5832180 	str	r2, [r3, #384]	; 0x180
  obj->Vab_in.value[1] = pVab_in_pu->value[1];
10004274:	e51b3014 	ldr	r3, [fp, #-20]
10004278:	e5932004 	ldr	r2, [r3, #4]
1000427c:	e51b3008 	ldr	r3, [fp, #-8]
10004280:	e5832184 	str	r2, [r3, #388]	; 0x184

  return;
10004284:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setVab_in_pu() function
10004288:	e24bd000 	sub	sp, fp, #0
1000428c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004290:	e12fff1e 	bx	lr

10004294 <CTRL_setVab_out_pu>:

//! \brief     Sets the alpha/beta current output vector values in the controller
//! \param[in] handle       The controller (CTRL) handle
//! \param[in] pVab_out_pu  The vector of alpha/beta current output vector values, pu
static inline void CTRL_setVab_out_pu(CTRL_Handle handle,const MATH_vec2 *pVab_out_pu)//! \Mod By Dl.K
{
10004294:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004298:	e28db000 	add	fp, sp, #0
1000429c:	e24dd014 	sub	sp, sp, #20
100042a0:	e50b0010 	str	r0, [fp, #-16]
100042a4:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100042a8:	e51b3010 	ldr	r3, [fp, #-16]
100042ac:	e50b3008 	str	r3, [fp, #-8]

  obj->Vab_out.value[0] = pVab_out_pu->value[0];
100042b0:	e51b3014 	ldr	r3, [fp, #-20]
100042b4:	e5932000 	ldr	r2, [r3]
100042b8:	e51b3008 	ldr	r3, [fp, #-8]
100042bc:	e583218c 	str	r2, [r3, #396]	; 0x18c
  obj->Vab_out.value[1] = pVab_out_pu->value[1];
100042c0:	e51b3014 	ldr	r3, [fp, #-20]
100042c4:	e5932004 	ldr	r2, [r3, #4]
100042c8:	e51b3008 	ldr	r3, [fp, #-8]
100042cc:	e5832190 	str	r2, [r3, #400]	; 0x190

  return;
100042d0:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setVab_out_pu() function
100042d4:	e24bd000 	sub	sp, fp, #0
100042d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100042dc:	e12fff1e 	bx	lr

100042e0 <CTRL_setVdq_offset_pu>:

//! \brief     Sets the direct/quadrature voltage (Vdq) offset vector values in the controller
//! \param[in] handle          The controller (CTRL) handle
//! \param[in] pVdq_offset_pu  The vector of the direct/quadrature voltage offset vector values, pu
static inline void CTRL_setVdq_offset_pu(CTRL_Handle handle,const MATH_vec2 *pVdq_offset_pu)//! \Mod By Dl.K
{
100042e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100042e4:	e28db000 	add	fp, sp, #0
100042e8:	e24dd014 	sub	sp, sp, #20
100042ec:	e50b0010 	str	r0, [fp, #-16]
100042f0:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100042f4:	e51b3010 	ldr	r3, [fp, #-16]
100042f8:	e50b3008 	str	r3, [fp, #-8]

  obj->Vdq_offset_pu.value[0] = pVdq_offset_pu->value[0];
100042fc:	e51b3014 	ldr	r3, [fp, #-20]
10004300:	e5932000 	ldr	r2, [r3]
10004304:	e51b3008 	ldr	r3, [fp, #-8]
10004308:	e5832204 	str	r2, [r3, #516]	; 0x204
  obj->Vdq_offset_pu.value[1] = pVdq_offset_pu->value[1];
1000430c:	e51b3014 	ldr	r3, [fp, #-20]
10004310:	e5932004 	ldr	r2, [r3, #4]
10004314:	e51b3008 	ldr	r3, [fp, #-8]
10004318:	e5832208 	str	r2, [r3, #520]	; 0x208

  return;
1000431c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setVdq_offset_pu() function
10004320:	e24bd000 	sub	sp, fp, #0
10004324:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004328:	e12fff1e 	bx	lr

1000432c <CTRL_setVdq_out_pu>:

//! \brief     Sets the direct/quadrature voltage output vector values in the controller
//! \param[in] handle       The controller (CTRL) handle
//! \param[in] pVdq_out_pu  The vector of direct/quadrature voltage output vector values, pu
static inline void CTRL_setVdq_out_pu(CTRL_Handle handle,const MATH_vec2 *pVdq_out_pu)//! \Mod By Dl.K
{
1000432c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004330:	e28db000 	add	fp, sp, #0
10004334:	e24dd014 	sub	sp, sp, #20
10004338:	e50b0010 	str	r0, [fp, #-16]
1000433c:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10004340:	e51b3010 	ldr	r3, [fp, #-16]
10004344:	e50b3008 	str	r3, [fp, #-8]

  obj->Vdq_out.value[0] = pVdq_out_pu->value[0];
10004348:	e51b3014 	ldr	r3, [fp, #-20]
1000434c:	e5932000 	ldr	r2, [r3]
10004350:	e51b3008 	ldr	r3, [fp, #-8]
10004354:	e5832194 	str	r2, [r3, #404]	; 0x194
  obj->Vdq_out.value[1] = pVdq_out_pu->value[1];
10004358:	e51b3014 	ldr	r3, [fp, #-20]
1000435c:	e5932004 	ldr	r2, [r3, #4]
10004360:	e51b3008 	ldr	r3, [fp, #-8]
10004364:	e5832198 	str	r2, [r3, #408]	; 0x198

  return;
10004368:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setVdq_out_pu() function
1000436c:	e24bd000 	sub	sp, fp, #0
10004370:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004374:	e12fff1e 	bx	lr

10004378 <CTRL_setupCtrl>:


//! \brief     Sets up the controllers
//! \param[in] handle   The controller (CTRL) handle
static inline void CTRL_setupCtrl(CTRL_Handle handle)
{
10004378:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000437c:	e28db000 	add	fp, sp, #0
10004380:	e24dd00c 	sub	sp, sp, #12
10004384:	e50b0008 	str	r0, [fp, #-8]
}
10004388:	e24bd000 	sub	sp, fp, #0
1000438c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004390:	e12fff1e 	bx	lr

10004394 <CTRL_setupTraj>:


//! \brief     Sets up the trajectory (TRAJ) object
//! \param[in] handle   The controller (CTRL) handle
static inline void CTRL_setupTraj(CTRL_Handle handle)
{
10004394:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004398:	e28db000 	add	fp, sp, #0
1000439c:	e24dd00c 	sub	sp, sp, #12
100043a0:	e50b0008 	str	r0, [fp, #-8]
}
100043a4:	e24bd000 	sub	sp, fp, #0
100043a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100043ac:	e12fff1e 	bx	lr

100043b0 <CTRL_checkForErrors>:


//! \brief      Checks for any controller errors and, if found, sets the controller state to the error state
//! \param[in]  handle  The controller (CTRL) handle
static inline void CTRL_checkForErrors(CTRL_Handle handle)//! \Mod By Dl.K
{
100043b0:	e92d4800 	push	{fp, lr}
100043b4:	e28db004 	add	fp, sp, #4
100043b8:	e24dd010 	sub	sp, sp, #16
100043bc:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100043c0:	e51b3010 	ldr	r3, [fp, #-16]
100043c4:	e50b3008 	str	r3, [fp, #-8]

  // check for estimator errors
  if(EST_isError(obj->estHandle))
100043c8:	e51b3008 	ldr	r3, [fp, #-8]
100043cc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100043d0:	e1a00003 	mov	r0, r3
100043d4:	eb0009d0 	bl	10006b1c <EST_isError>
100043d8:	e1a03000 	mov	r3, r0
100043dc:	e3530000 	cmp	r3, #0
100043e0:	0a000005 	beq	100043fc <CTRL_checkForErrors+0x4c>
    {
      // set the next controller state
      CTRL_setState(handle,CTRL_State_Error);
100043e4:	e51b0010 	ldr	r0, [fp, #-16]
100043e8:	e3a01000 	mov	r1, #0
100043ec:	ebffff51 	bl	10004138 <CTRL_setState>

      // set the error code
      CTRL_setErrorCode(handle,CTRL_ErrorCode_EstError);
100043f0:	e51b0010 	ldr	r0, [fp, #-16]
100043f4:	e3a01002 	mov	r1, #2
100043f8:	ebfffd27 	bl	1000389c <CTRL_setErrorCode>
    }

  return;
100043fc:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_checkForErrors() function
10004400:	e24bd004 	sub	sp, fp, #4
10004404:	e8bd8800 	pop	{fp, pc}

10004408 <CTRL_computePhasor>:

//! \brief      Computes a phasor for a given angle
//! \param[in]  angle_pu  The angle, pu
//! \param[out] pPhasor   The pointer to the phasor vector values
static inline void CTRL_computePhasor(const float_t angle_pu,MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
10004408:	e92d4800 	push	{fp, lr}
1000440c:	e28db004 	add	fp, sp, #4
10004410:	e24dd008 	sub	sp, sp, #8
10004414:	ed0b0a02 	vstr	s0, [fp, #-8]
10004418:	e50b000c 	str	r0, [fp, #-12]

  pPhasor->value[0] = cosf(angle_pu);
1000441c:	ed1b0a02 	vldr	s0, [fp, #-8]
10004420:	fa00b07e 	blx	10030620 <cosf>
10004424:	eef07a40 	vmov.f32	s15, s0
10004428:	e51b300c 	ldr	r3, [fp, #-12]
1000442c:	edc37a00 	vstr	s15, [r3]
  pPhasor->value[1] = sinf(angle_pu);
10004430:	ed1b0a02 	vldr	s0, [fp, #-8]
10004434:	fa00b09b 	blx	100306a8 <sinf>
10004438:	eef07a40 	vmov.f32	s15, s0
1000443c:	e51b300c 	ldr	r3, [fp, #-12]
10004440:	edc37a01 	vstr	s15, [r3, #4]

  return;
10004444:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_computePhasor() function
10004448:	e24bd004 	sub	sp, fp, #4
1000444c:	e8bd8800 	pop	{fp, pc}

10004450 <CTRL_doCurrentCtrl>:

//! \brief      Determines if the current controllers should be run
//! \param[in]  handle  The controller (CTRL) handle
//! \return     The value denoting that the current controllers should be run (true) or not (false)
static inline bool CTRL_doCurrentCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
10004450:	e92d4800 	push	{fp, lr}
10004454:	e28db004 	add	fp, sp, #4
10004458:	e24dd010 	sub	sp, sp, #16
1000445c:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10004460:	e51b3010 	ldr	r3, [fp, #-16]
10004464:	e50b300c 	str	r3, [fp, #-12]
  bool result = false;
10004468:	e3a03000 	mov	r3, #0
1000446c:	e54b3005 	strb	r3, [fp, #-5]

  if(CTRL_getFlag_enableCurrentCtrl(handle) && (obj->counter_current >= obj->numCtrlTicksPerCurrentTick))
10004470:	e51b0010 	ldr	r0, [fp, #-16]
10004474:	ebfffa89 	bl	10002ea0 <CTRL_getFlag_enableCurrentCtrl>
10004478:	e1a03000 	mov	r3, r0
1000447c:	e3530000 	cmp	r3, #0
10004480:	0a00000a 	beq	100044b0 <CTRL_doCurrentCtrl+0x60>
10004484:	e51b300c 	ldr	r3, [fp, #-12]
10004488:	e2833f7b 	add	r3, r3, #492	; 0x1ec
1000448c:	e1d320b0 	ldrh	r2, [r3]
10004490:	e51b300c 	ldr	r3, [fp, #-12]
10004494:	e2833f53 	add	r3, r3, #332	; 0x14c
10004498:	e2833002 	add	r3, r3, #2
1000449c:	e1d330b0 	ldrh	r3, [r3]
100044a0:	e1520003 	cmp	r2, r3
100044a4:	3a000001 	bcc	100044b0 <CTRL_doCurrentCtrl+0x60>
  {
    result = true;
100044a8:	e3a03001 	mov	r3, #1
100044ac:	e54b3005 	strb	r3, [fp, #-5]
  }

  return(result);
100044b0:	e55b3005 	ldrb	r3, [fp, #-5]
} // end of CTRL_doCurrentCtrl() function
100044b4:	e1a00003 	mov	r0, r3
100044b8:	e24bd004 	sub	sp, fp, #4
100044bc:	e8bd8800 	pop	{fp, pc}

100044c0 <CTRL_doSpeedCtrl>:

//! \brief     Determines if the speed controller should be executed
//! \param[in] handle  The controller (CTRL) handle
//! \return    A boolean value denoting if the speed controller should be executed (true) or not (false)
static inline bool CTRL_doSpeedCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
100044c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100044c4:	e28db000 	add	fp, sp, #0
100044c8:	e24dd014 	sub	sp, sp, #20
100044cc:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100044d0:	e51b3010 	ldr	r3, [fp, #-16]
100044d4:	e50b300c 	str	r3, [fp, #-12]
  bool result = false;
100044d8:	e3a03000 	mov	r3, #0
100044dc:	e54b3005 	strb	r3, [fp, #-5]

  if((obj->counter_speed >= obj->numCtrlTicksPerSpeedTick))
100044e0:	e51b300c 	ldr	r3, [fp, #-12]
100044e4:	e2833e1f 	add	r3, r3, #496	; 0x1f0
100044e8:	e1d320b0 	ldrh	r2, [r3]
100044ec:	e51b300c 	ldr	r3, [fp, #-12]
100044f0:	e2833e15 	add	r3, r3, #336	; 0x150
100044f4:	e1d330b0 	ldrh	r3, [r3]
100044f8:	e1520003 	cmp	r2, r3
100044fc:	3a000001 	bcc	10004508 <CTRL_doSpeedCtrl+0x48>
  {
    result = true;
10004500:	e3a03001 	mov	r3, #1
10004504:	e54b3005 	strb	r3, [fp, #-5]
  }

  return(result);
10004508:	e55b3005 	ldrb	r3, [fp, #-5]
} // end of CTRL_doSpeedCtrl() function
1000450c:	e1a00003 	mov	r0, r3
10004510:	e24bd000 	sub	sp, fp, #0
10004514:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004518:	e12fff1e 	bx	lr

1000451c <CTRL_runOffLine>:
//! \param[in]  pAdcData   The pointer to the ADC data
//! \param[out] pPwmData   The pointer to the PWM data

static inline void CTRL_runOffLine(CTRL_Handle handle,HAL_Handle halHandle,
                            const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
1000451c:	e92d4800 	push	{fp, lr}
10004520:	e28db004 	add	fp, sp, #4
10004524:	e24dd010 	sub	sp, sp, #16
10004528:	e50b0008 	str	r0, [fp, #-8]
1000452c:	e50b100c 	str	r1, [fp, #-12]
10004530:	e50b2010 	str	r2, [fp, #-16]
10004534:	e50b3014 	str	r3, [fp, #-20]

	// run offset estimation
	//settestpin();
	HAL_runOffsetEst(halHandle,pAdcData);
10004538:	e51b000c 	ldr	r0, [fp, #-12]
1000453c:	e51b1010 	ldr	r1, [fp, #-16]
10004540:	ebfff9e8 	bl	10002ce8 <HAL_runOffsetEst>
	//cleartestpin();
  
	Speed_SetElecTheta(handle->Speed_handle,0.0f);
10004544:	e51b3008 	ldr	r3, [fp, #-8]
10004548:	e59332e8 	ldr	r3, [r3, #744]	; 0x2e8
1000454c:	e1a00003 	mov	r0, r3
10004550:	ed9f0a1c 	vldr	s0, [pc, #112]	; 100045c8 <CTRL_runOffLine+0xac>
10004554:	ebfff99e 	bl	10002bd4 <Speed_SetElecTheta>
	Speed_UpdateElecTheta(handle->Speed_handle);
10004558:	e51b3008 	ldr	r3, [fp, #-8]
1000455c:	e59332e8 	ldr	r3, [r3, #744]	; 0x2e8
10004560:	e1a00003 	mov	r0, r3
10004564:	ebfff9c4 	bl	10002c7c <Speed_UpdateElecTheta>
	
	// create PWM data
	pPwmData->Tabc.value[0] = (0.0f);
10004568:	e51b3014 	ldr	r3, [fp, #-20]
1000456c:	e3a02000 	mov	r2, #0
10004570:	e5832000 	str	r2, [r3]
	pPwmData->Tabc.value[1] = (0.0f);
10004574:	e51b3014 	ldr	r3, [fp, #-20]
10004578:	e3a02000 	mov	r2, #0
1000457c:	e5832004 	str	r2, [r3, #4]
	pPwmData->Tabc.value[2] = (0.0f);
10004580:	e51b3014 	ldr	r3, [fp, #-20]
10004584:	e3a02000 	mov	r2, #0
10004588:	e5832008 	str	r2, [r3, #8]

	handle->MntValue.value[0] = halHandle->offset_I[0].value;
1000458c:	e51b300c 	ldr	r3, [fp, #-12]
10004590:	e593200c 	ldr	r2, [r3, #12]
10004594:	e51b3008 	ldr	r3, [fp, #-8]
10004598:	e583232c 	str	r2, [r3, #812]	; 0x32c
	handle->MntValue.value[1] = halHandle->offset_I[1].value;
1000459c:	e51b300c 	ldr	r3, [fp, #-12]
100045a0:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
100045a4:	e51b3008 	ldr	r3, [fp, #-8]
100045a8:	e5832330 	str	r2, [r3, #816]	; 0x330
	handle->MntValue.value[2] = halHandle->offset_I[2].value;
100045ac:	e51b300c 	ldr	r3, [fp, #-12]
100045b0:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
100045b4:	e51b3008 	ldr	r3, [fp, #-8]
100045b8:	e5832334 	str	r2, [r3, #820]	; 0x334
  return;
100045bc:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_runOffLine() function
100045c0:	e24bd004 	sub	sp, fp, #4
100045c4:	e8bd8800 	pop	{fp, pc}
100045c8:	00000000 	.word	0x00000000

100045cc <CTRL_runInitDete_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runInitDete_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
100045cc:	e92d4830 	push	{r4, r5, fp, lr}
100045d0:	e28db00c 	add	fp, sp, #12
100045d4:	e24dd028 	sub	sp, sp, #40	; 0x28
100045d8:	e50b0028 	str	r0, [fp, #-40]	; 0x28
100045dc:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
100045e0:	e50b2030 	str	r2, [fp, #-48]	; 0x30
100045e4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	//! \Mod By Dl.K Dynamic Stator Initial Position Detection
	CTRL_Obj *obj = (CTRL_Obj *)handle;
100045e8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100045ec:	e50b3010 	str	r3, [fp, #-16]
	static uint16_t flag=true;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0.0f,0.0f};
100045f0:	e3a03000 	mov	r3, #0
100045f4:	e50b3020 	str	r3, [fp, #-32]
100045f8:	e3a03000 	mov	r3, #0
100045fc:	e50b301c 	str	r3, [fp, #-28]
	Speed_SetElecTheta(obj->Speed_handle,0.0f);
	Speed_UpdateElecTheta(obj->Speed_handle);

	#endif
	// compute the sin/cos phasor
	CTRL_computePhasor(obj->AngleRef * MATH_TWO_PI,&phasor);//angleref = 0
10004600:	e51b3010 	ldr	r3, [fp, #-16]
10004604:	edd37aca 	vldr	s15, [r3, #808]	; 0x328
10004608:	ed9f7a4d 	vldr	s14, [pc, #308]	; 10004744 <CTRL_runInitDete_User+0x178>
1000460c:	ee677a87 	vmul.f32	s15, s15, s14
10004610:	e24b3018 	sub	r3, fp, #24
10004614:	eeb00a67 	vmov.f32	s0, s15
10004618:	e1a00003 	mov	r0, r3
1000461c:	ebffff79 	bl	10004408 <CTRL_computePhasor>
	// set
	if( flag==true )
10004620:	e3063800 	movw	r3, #26624	; 0x6800
10004624:	e3413003 	movt	r3, #4099	; 0x1003
10004628:	e1d330b0 	ldrh	r3, [r3]
1000462c:	e3530001 	cmp	r3, #1
10004630:	1a000005 	bne	1000464c <CTRL_runInitDete_User+0x80>
	{
		vdq.value[0] = (55.0f);
10004634:	e3a03000 	mov	r3, #0
10004638:	e344325c 	movt	r3, #16988	; 0x425c
1000463c:	e50b3020 	str	r3, [fp, #-32]
		vdq.value[1] = (0.0f);
10004640:	e3a03000 	mov	r3, #0
10004644:	e50b301c 	str	r3, [fp, #-28]
10004648:	ea000003 	b	1000465c <CTRL_runInitDete_User+0x90>
	}
	else
	{
		vdq.value[0] = (0.0f);
1000464c:	e3a03000 	mov	r3, #0
10004650:	e50b3020 	str	r3, [fp, #-32]
		vdq.value[1] = (0.0f);
10004654:	e3a03000 	mov	r3, #0
10004658:	e50b301c 	str	r3, [fp, #-28]
	}
	CTRL_setVdq_out_pu(obj,&vdq);
1000465c:	e24b3020 	sub	r3, fp, #32
10004660:	e51b0010 	ldr	r0, [fp, #-16]
10004664:	e1a01003 	mov	r1, r3
10004668:	ebffff2f 	bl	1000432c <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
1000466c:	e51b3010 	ldr	r3, [fp, #-16]
10004670:	e59320a8 	ldr	r2, [r3, #168]	; 0xa8
10004674:	e24b3018 	sub	r3, fp, #24
10004678:	e1a00002 	mov	r0, r2
1000467c:	e1a01003 	mov	r1, r3
10004680:	ebfff602 	bl	10001e90 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
10004684:	e51b3010 	ldr	r3, [fp, #-16]
10004688:	e59340a8 	ldr	r4, [r3, #168]	; 0xa8
1000468c:	e51b0010 	ldr	r0, [fp, #-16]
10004690:	ebfffb69 	bl	1000343c <CTRL_getVdq_out_addr>
10004694:	e1a05000 	mov	r5, r0
10004698:	e51b0010 	ldr	r0, [fp, #-16]
1000469c:	ebfffb4e 	bl	100033dc <CTRL_getVab_out_addr>
100046a0:	e1a03000 	mov	r3, r0
100046a4:	e1a00004 	mov	r0, r4
100046a8:	e1a01005 	mov	r1, r5
100046ac:	e1a02003 	mov	r2, r3
100046b0:	ebfff5cc 	bl	10001de8 <IPARK_run>

	obj->Vab_out.value[0] = (obj->Vab_out.value[0]/570);
100046b4:	e51b3010 	ldr	r3, [fp, #-16]
100046b8:	edd37a63 	vldr	s15, [r3, #396]	; 0x18c
100046bc:	ed9f7a21 	vldr	s14, [pc, #132]	; 10004748 <CTRL_runInitDete_User+0x17c>
100046c0:	eec77a87 	vdiv.f32	s15, s15, s14
100046c4:	e51b3010 	ldr	r3, [fp, #-16]
100046c8:	edc37a63 	vstr	s15, [r3, #396]	; 0x18c
	obj->Vab_out.value[1] = (obj->Vab_out.value[1]/570);
100046cc:	e51b3010 	ldr	r3, [fp, #-16]
100046d0:	edd37a64 	vldr	s15, [r3, #400]	; 0x190
100046d4:	ed9f7a1b 	vldr	s14, [pc, #108]	; 10004748 <CTRL_runInitDete_User+0x17c>
100046d8:	eec77a87 	vdiv.f32	s15, s15, s14
100046dc:	e51b3010 	ldr	r3, [fp, #-16]
100046e0:	edc37a64 	vstr	s15, [r3, #400]	; 0x190

	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(handle),&(pPwmData->Tabc));
100046e4:	e51b3010 	ldr	r3, [fp, #-16]
100046e8:	e59340b4 	ldr	r4, [r3, #180]	; 0xb4
100046ec:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
100046f0:	ebfffb39 	bl	100033dc <CTRL_getVab_out_addr>
100046f4:	e1a02000 	mov	r2, r0
100046f8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
100046fc:	e1a00004 	mov	r0, r4
10004700:	e1a01002 	mov	r1, r2
10004704:	e1a02003 	mov	r2, r3
10004708:	ebfff701 	bl	10002314 <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
1000470c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004710:	e5932000 	ldr	r2, [r3]
10004714:	e51b3010 	ldr	r3, [fp, #-16]
10004718:	e5832314 	str	r2, [r3, #788]	; 0x314
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
1000471c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004720:	e5932004 	ldr	r2, [r3, #4]
10004724:	e51b3010 	ldr	r3, [fp, #-16]
10004728:	e5832318 	str	r2, [r3, #792]	; 0x318
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
1000472c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004730:	e5932008 	ldr	r2, [r3, #8]
10004734:	e51b3010 	ldr	r3, [fp, #-16]
10004738:	e583231c 	str	r2, [r3, #796]	; 0x31c
}
1000473c:	e24bd00c 	sub	sp, fp, #12
10004740:	e8bd8830 	pop	{r4, r5, fp, pc}
10004744:	40c90fdb 	.word	0x40c90fdb
10004748:	440e8000 	.word	0x440e8000

1000474c <CTRL_runStaticStatorInitDete_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runStaticStatorInitDete_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
1000474c:	e92d4830 	push	{r4, r5, fp, lr}
10004750:	e28db00c 	add	fp, sp, #12
10004754:	e24dd028 	sub	sp, sp, #40	; 0x28
10004758:	e50b0028 	str	r0, [fp, #-40]	; 0x28
1000475c:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
10004760:	e50b2030 	str	r2, [fp, #-48]	; 0x30
10004764:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	//! \Mod By Dl.K Static Stator Initial Position Detection
	CTRL_Obj *obj = (CTRL_Obj *)handle;
10004768:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000476c:	e50b3010 	str	r3, [fp, #-16]
	float_t angle_pu;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0.0f,0.0f};
10004770:	e3a03000 	mov	r3, #0
10004774:	e50b3024 	str	r3, [fp, #-36]	; 0x24
10004778:	e3a03000 	mov	r3, #0
1000477c:	e50b3020 	str	r3, [fp, #-32]
	static uint16_t sInitPosDetTick = 5,sInitPosDetSclar = 5;

	//GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_32);

	if( INITPOSDET_GetIdSampAngleFlag(obj->InitPosDet_handle) &&
10004780:	e51b3010 	ldr	r3, [fp, #-16]
10004784:	e5933284 	ldr	r3, [r3, #644]	; 0x284
10004788:	e1a00003 	mov	r0, r3
1000478c:	ebfff8f6 	bl	10002b6c <INITPOSDET_GetIdSampAngleFlag>
10004790:	e1a03000 	mov	r3, r0
10004794:	e3530000 	cmp	r3, #0
10004798:	0a000054 	beq	100048f0 <CTRL_runStaticStatorInitDete_User+0x1a4>
			sInitPosDetTick==4 )
1000479c:	e3063802 	movw	r3, #26626	; 0x6802
100047a0:	e3413003 	movt	r3, #4099	; 0x1003
100047a4:	e1d330b0 	ldrh	r3, [r3]
	MATH_vec2 vdq = {0.0f,0.0f};
	static uint16_t sInitPosDetTick = 5,sInitPosDetSclar = 5;

	//GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_32);

	if( INITPOSDET_GetIdSampAngleFlag(obj->InitPosDet_handle) &&
100047a8:	e3530004 	cmp	r3, #4
100047ac:	1a00004f 	bne	100048f0 <CTRL_runStaticStatorInitDete_User+0x1a4>
			sInitPosDetTick==4 )
	{
//		GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_43);

		obj->MntValue.value[0] = pAdcData->I.value[0];
100047b0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100047b4:	e5932000 	ldr	r2, [r3]
100047b8:	e51b3010 	ldr	r3, [fp, #-16]
100047bc:	e583232c 	str	r2, [r3, #812]	; 0x32c
		obj->MntValue.value[1] = pAdcData->I.value[1];
100047c0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100047c4:	e5932004 	ldr	r2, [r3, #4]
100047c8:	e51b3010 	ldr	r3, [fp, #-16]
100047cc:	e5832330 	str	r2, [r3, #816]	; 0x330
		obj->MntValue.value[2] = pAdcData->I.value[2];
100047d0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100047d4:	e5932008 	ldr	r2, [r3, #8]
100047d8:	e51b3010 	ldr	r3, [fp, #-16]
100047dc:	e5832334 	str	r2, [r3, #820]	; 0x334

		// run Clarke transform on current
		CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(obj));
100047e0:	e51b3010 	ldr	r3, [fp, #-16]
100047e4:	e593500c 	ldr	r5, [r3, #12]
100047e8:	e51b4030 	ldr	r4, [fp, #-48]	; 0x30
100047ec:	e51b0010 	ldr	r0, [fp, #-16]
100047f0:	ebfff9da 	bl	10002f60 <CTRL_getIab_in_addr>
100047f4:	e1a03000 	mov	r3, r0
100047f8:	e1a00005 	mov	r0, r5
100047fc:	e1a01004 	mov	r1, r4
10004800:	e1a02003 	mov	r2, r3
10004804:	ebfff4d7 	bl	10001b68 <CLARKE_run>

		// generate the motor electrical angle
		angle_pu = INITPOSDET_GetIdSampAngle(obj->InitPosDet_handle);
10004808:	e51b3010 	ldr	r3, [fp, #-16]
1000480c:	e5933284 	ldr	r3, [r3, #644]	; 0x284
10004810:	e1a00003 	mov	r0, r3
10004814:	ebfff8c7 	bl	10002b38 <INITPOSDET_GetIdSampAngle>
10004818:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
1000481c:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
10004820:	ed9f7a9f 	vldr	s14, [pc, #636]	; 10004aa4 <CTRL_runStaticStatorInitDete_User+0x358>
10004824:	ee677a87 	vmul.f32	s15, s15, s14
10004828:	e24b301c 	sub	r3, fp, #28
1000482c:	eeb00a67 	vmov.f32	s0, s15
10004830:	e1a00003 	mov	r0, r3
10004834:	ebfffef3 	bl	10004408 <CTRL_computePhasor>

		// set the phasor in the Park transform
		PARK_setPhasor(obj->parkHandle,&phasor);
10004838:	e51b3010 	ldr	r3, [fp, #-16]
1000483c:	e5932030 	ldr	r2, [r3, #48]	; 0x30
10004840:	e24b301c 	sub	r3, fp, #28
10004844:	e1a00002 	mov	r0, r2
10004848:	e1a01003 	mov	r1, r3
1000484c:	ebfff552 	bl	10001d9c <PARK_setPhasor>

		// run the Park transform
		PARK_run(obj->parkHandle,CTRL_getIab_in_addr(obj),CTRL_getIdq_in_addr(obj));
10004850:	e51b3010 	ldr	r3, [fp, #-16]
10004854:	e5934030 	ldr	r4, [r3, #48]	; 0x30
10004858:	e51b0010 	ldr	r0, [fp, #-16]
1000485c:	ebfff9bf 	bl	10002f60 <CTRL_getIab_in_addr>
10004860:	e1a05000 	mov	r5, r0
10004864:	e51b0010 	ldr	r0, [fp, #-16]
10004868:	ebfff9e2 	bl	10002ff8 <CTRL_getIdq_in_addr>
1000486c:	e1a03000 	mov	r3, r0
10004870:	e1a00004 	mov	r0, r4
10004874:	e1a01005 	mov	r1, r5
10004878:	e1a02003 	mov	r2, r3
1000487c:	ebfff51c 	bl	10001cf4 <PARK_run>

		INITPOSDET_Run(obj->InitPosDet_handle,CTRL_getId_in_pu(obj));
10004880:	e51b3010 	ldr	r3, [fp, #-16]
10004884:	e5934284 	ldr	r4, [r3, #644]	; 0x284
10004888:	e51b0010 	ldr	r0, [fp, #-16]
1000488c:	ebfff9bf 	bl	10002f90 <CTRL_getId_in_pu>
10004890:	eef07a40 	vmov.f32	s15, s0
10004894:	e1a00004 	mov	r0, r4
10004898:	eeb00a67 	vmov.f32	s0, s15
1000489c:	ebffef43 	bl	100005b0 <INITPOSDET_Run>

		obj->angle_offset_pu = - INITPOSDET_GetInitPosAngle(obj->InitPosDet_handle);
100048a0:	e51b3010 	ldr	r3, [fp, #-16]
100048a4:	e5933284 	ldr	r3, [r3, #644]	; 0x284
100048a8:	e1a00003 	mov	r0, r3
100048ac:	ebfff87b 	bl	10002aa0 <INITPOSDET_GetInitPosAngle>
100048b0:	eef07a40 	vmov.f32	s15, s0
100048b4:	eef17a67 	vneg.f32	s15, s15
100048b8:	e51b3010 	ldr	r3, [fp, #-16]
100048bc:	edc37a83 	vstr	s15, [r3, #524]	; 0x20c
		
		Speed_SetElecTheta(obj->Speed_handle,-obj->angle_offset_pu);
100048c0:	e51b3010 	ldr	r3, [fp, #-16]
100048c4:	e59322e8 	ldr	r2, [r3, #744]	; 0x2e8
100048c8:	e51b3010 	ldr	r3, [fp, #-16]
100048cc:	edd37a83 	vldr	s15, [r3, #524]	; 0x20c
100048d0:	eef17a67 	vneg.f32	s15, s15
100048d4:	e1a00002 	mov	r0, r2
100048d8:	eeb00a67 	vmov.f32	s0, s15
100048dc:	ebfff8bc 	bl	10002bd4 <Speed_SetElecTheta>
		Speed_UpdateElecTheta(obj->Speed_handle);
100048e0:	e51b3010 	ldr	r3, [fp, #-16]
100048e4:	e59332e8 	ldr	r3, [r3, #744]	; 0x2e8
100048e8:	e1a00003 	mov	r0, r3
100048ec:	ebfff8e2 	bl	10002c7c <Speed_UpdateElecTheta>
//		GPIO_setLow(halHandle->gpioHandle,GPIO_Number_43);
	}

	if(sInitPosDetTick>=sInitPosDetSclar)
100048f0:	e3063802 	movw	r3, #26626	; 0x6802
100048f4:	e3413003 	movt	r3, #4099	; 0x1003
100048f8:	e1d320b0 	ldrh	r2, [r3]
100048fc:	e3063804 	movw	r3, #26628	; 0x6804
10004900:	e3413003 	movt	r3, #4099	; 0x1003
10004904:	e1d330b0 	ldrh	r3, [r3]
10004908:	e1520003 	cmp	r2, r3
1000490c:	3a000008 	bcc	10004934 <CTRL_runStaticStatorInitDete_User+0x1e8>
	{
		sInitPosDetTick=1;
10004910:	e3063802 	movw	r3, #26626	; 0x6802
10004914:	e3413003 	movt	r3, #4099	; 0x1003
10004918:	e3a02001 	mov	r2, #1
1000491c:	e1c320b0 	strh	r2, [r3]
		INITPOSDET_VolVecAngleRun(obj->InitPosDet_handle);
10004920:	e51b3010 	ldr	r3, [fp, #-16]
10004924:	e5933284 	ldr	r3, [r3, #644]	; 0x284
10004928:	e1a00003 	mov	r0, r3
1000492c:	ebfff08f 	bl	10000b70 <INITPOSDET_VolVecAngleRun>
10004930:	ea000007 	b	10004954 <CTRL_runStaticStatorInitDete_User+0x208>
	}
	else sInitPosDetTick++;
10004934:	e3063802 	movw	r3, #26626	; 0x6802
10004938:	e3413003 	movt	r3, #4099	; 0x1003
1000493c:	e1d330b0 	ldrh	r3, [r3]
10004940:	e2833001 	add	r3, r3, #1
10004944:	e6ff2073 	uxth	r2, r3
10004948:	e3063802 	movw	r3, #26626	; 0x6802
1000494c:	e3413003 	movt	r3, #4099	; 0x1003
10004950:	e1c320b0 	strh	r2, [r3]

	// set
	if( INITPOSDET_GetVolVecAngleFlag(obj->InitPosDet_handle) )
10004954:	e51b3010 	ldr	r3, [fp, #-16]
10004958:	e5933284 	ldr	r3, [r3, #644]	; 0x284
1000495c:	e1a00003 	mov	r0, r3
10004960:	ebfff85b 	bl	10002ad4 <INITPOSDET_GetVolVecAngleFlag>
10004964:	e1a03000 	mov	r3, r0
10004968:	e3530000 	cmp	r3, #0
1000496c:	0a000011 	beq	100049b8 <CTRL_runStaticStatorInitDete_User+0x26c>
	{
		vdq.value[0] = obj->VdqRef.value[0];
10004970:	e51b3010 	ldr	r3, [fp, #-16]
10004974:	e5933320 	ldr	r3, [r3, #800]	; 0x320
10004978:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		vdq.value[1] = (0.0f);
1000497c:	e3a03000 	mov	r3, #0
10004980:	e50b3020 	str	r3, [fp, #-32]

		// generate the motor electrical angle
		angle_pu = INITPOSDET_GetVolVecAngle(obj->InitPosDet_handle);
10004984:	e51b3010 	ldr	r3, [fp, #-16]
10004988:	e5933284 	ldr	r3, [r3, #644]	; 0x284
1000498c:	e1a00003 	mov	r0, r3
10004990:	ebfff85b 	bl	10002b04 <INITPOSDET_GetVolVecAngle>
10004994:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
10004998:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
1000499c:	ed9f7a40 	vldr	s14, [pc, #256]	; 10004aa4 <CTRL_runStaticStatorInitDete_User+0x358>
100049a0:	ee677a87 	vmul.f32	s15, s15, s14
100049a4:	e24b301c 	sub	r3, fp, #28
100049a8:	eeb00a67 	vmov.f32	s0, s15
100049ac:	e1a00003 	mov	r0, r3
100049b0:	ebfffe94 	bl	10004408 <CTRL_computePhasor>
100049b4:	ea00000c 	b	100049ec <CTRL_runStaticStatorInitDete_User+0x2a0>
	}
	else
	{
		vdq.value[0] = (0.0f);
100049b8:	e3a03000 	mov	r3, #0
100049bc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		vdq.value[1] = (0.0f);
100049c0:	e3a03000 	mov	r3, #0
100049c4:	e50b3020 	str	r3, [fp, #-32]

		// generate the motor electrical angle
		angle_pu = (0.0f);
100049c8:	e3a03000 	mov	r3, #0
100049cc:	e50b3014 	str	r3, [fp, #-20]

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
100049d0:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
100049d4:	ed9f7a32 	vldr	s14, [pc, #200]	; 10004aa4 <CTRL_runStaticStatorInitDete_User+0x358>
100049d8:	ee677a87 	vmul.f32	s15, s15, s14
100049dc:	e24b301c 	sub	r3, fp, #28
100049e0:	eeb00a67 	vmov.f32	s0, s15
100049e4:	e1a00003 	mov	r0, r3
100049e8:	ebfffe86 	bl	10004408 <CTRL_computePhasor>
	}
	CTRL_setVdq_out_pu(obj,&vdq);
100049ec:	e24b3024 	sub	r3, fp, #36	; 0x24
100049f0:	e51b0010 	ldr	r0, [fp, #-16]
100049f4:	e1a01003 	mov	r1, r3
100049f8:	ebfffe4b 	bl	1000432c <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
100049fc:	e51b3010 	ldr	r3, [fp, #-16]
10004a00:	e59320a8 	ldr	r2, [r3, #168]	; 0xa8
10004a04:	e24b301c 	sub	r3, fp, #28
10004a08:	e1a00002 	mov	r0, r2
10004a0c:	e1a01003 	mov	r1, r3
10004a10:	ebfff51e 	bl	10001e90 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
10004a14:	e51b3010 	ldr	r3, [fp, #-16]
10004a18:	e59340a8 	ldr	r4, [r3, #168]	; 0xa8
10004a1c:	e51b0010 	ldr	r0, [fp, #-16]
10004a20:	ebfffa85 	bl	1000343c <CTRL_getVdq_out_addr>
10004a24:	e1a05000 	mov	r5, r0
10004a28:	e51b0010 	ldr	r0, [fp, #-16]
10004a2c:	ebfffa6a 	bl	100033dc <CTRL_getVab_out_addr>
10004a30:	e1a03000 	mov	r3, r0
10004a34:	e1a00004 	mov	r0, r4
10004a38:	e1a01005 	mov	r1, r5
10004a3c:	e1a02003 	mov	r2, r3
10004a40:	ebfff4e8 	bl	10001de8 <IPARK_run>

	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(obj),&(pPwmData->Tabc));
10004a44:	e51b3010 	ldr	r3, [fp, #-16]
10004a48:	e59340b4 	ldr	r4, [r3, #180]	; 0xb4
10004a4c:	e51b0010 	ldr	r0, [fp, #-16]
10004a50:	ebfffa61 	bl	100033dc <CTRL_getVab_out_addr>
10004a54:	e1a02000 	mov	r2, r0
10004a58:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004a5c:	e1a00004 	mov	r0, r4
10004a60:	e1a01002 	mov	r1, r2
10004a64:	e1a02003 	mov	r2, r3
10004a68:	ebfff629 	bl	10002314 <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
10004a6c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004a70:	e5932000 	ldr	r2, [r3]
10004a74:	e51b3010 	ldr	r3, [fp, #-16]
10004a78:	e5832314 	str	r2, [r3, #788]	; 0x314
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
10004a7c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004a80:	e5932004 	ldr	r2, [r3, #4]
10004a84:	e51b3010 	ldr	r3, [fp, #-16]
10004a88:	e5832318 	str	r2, [r3, #792]	; 0x318
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
10004a8c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004a90:	e5932008 	ldr	r2, [r3, #8]
10004a94:	e51b3010 	ldr	r3, [fp, #-16]
10004a98:	e583231c 	str	r2, [r3, #796]	; 0x31c

	//GPIO_setLow(halHandle->gpioHandle,GPIO_Number_32);
}
10004a9c:	e24bd00c 	sub	sp, fp, #12
10004aa0:	e8bd8830 	pop	{r4, r5, fp, pc}
10004aa4:	40c90fdb 	.word	0x40c90fdb

10004aa8 <CTRL_runOpenLoop_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runOpenLoop_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
10004aa8:	e92d4830 	push	{r4, r5, fp, lr}
10004aac:	e28db00c 	add	fp, sp, #12
10004ab0:	e24dd028 	sub	sp, sp, #40	; 0x28
10004ab4:	e50b0028 	str	r0, [fp, #-40]	; 0x28
10004ab8:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
10004abc:	e50b2030 	str	r2, [fp, #-48]	; 0x30
10004ac0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	CTRL_Obj *obj = (CTRL_Obj *)handle;
10004ac4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004ac8:	e50b3010 	str	r3, [fp, #-16]
	int16_t angle_temp_pu;
	float_t angle_pu;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0,0};
10004acc:	e3a03000 	mov	r3, #0
10004ad0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
10004ad4:	e3a03000 	mov	r3, #0
10004ad8:	e50b3020 	str	r3, [fp, #-32]

	// run Clarke transform on current
	//CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(handle));

	RMP_CNTL_SetTargetValue(obj->rmpcntl_handle,CTRL_getSpd_ref_pu(obj));//
10004adc:	e51b3010 	ldr	r3, [fp, #-16]
10004ae0:	e5934224 	ldr	r4, [r3, #548]	; 0x224
10004ae4:	e51b0010 	ldr	r0, [fp, #-16]
10004ae8:	ebfffa22 	bl	10003378 <CTRL_getSpd_ref_pu>
10004aec:	eef07a40 	vmov.f32	s15, s0
10004af0:	e1a00004 	mov	r0, r4
10004af4:	eeb00a67 	vmov.f32	s0, s15
10004af8:	ebfff6ea 	bl	100026a8 <RMP_CNTL_SetTargetValue>
	RMP_CNTL_Run(obj->rmpcntl_handle);
10004afc:	e51b3010 	ldr	r3, [fp, #-16]
10004b00:	e5933224 	ldr	r3, [r3, #548]	; 0x224
10004b04:	e1a00003 	mov	r0, r3
10004b08:	ebfff701 	bl	10002714 <RMP_CNTL_Run>

	RAMPGEN_SetFreq(obj->rampgen_handle,RMP_CNTL_GetFreq(obj->rmpcntl_handle));
10004b0c:	e51b3010 	ldr	r3, [fp, #-16]
10004b10:	e5934244 	ldr	r4, [r3, #580]	; 0x244
10004b14:	e51b3010 	ldr	r3, [fp, #-16]
10004b18:	e5933224 	ldr	r3, [r3, #548]	; 0x224
10004b1c:	e1a00003 	mov	r0, r3
10004b20:	ebfff6ee 	bl	100026e0 <RMP_CNTL_GetFreq>
10004b24:	eef07a40 	vmov.f32	s15, s0
10004b28:	e1a00004 	mov	r0, r4
10004b2c:	eeb00a67 	vmov.f32	s0, s15
10004b30:	ebfff75a 	bl	100028a0 <RAMPGEN_SetFreq>
	RAMPGEN_Run(obj->rampgen_handle);//
10004b34:	e51b3010 	ldr	r3, [fp, #-16]
10004b38:	e5933244 	ldr	r3, [r3, #580]	; 0x244
10004b3c:	e1a00003 	mov	r0, r3
10004b40:	ebfff780 	bl	10002948 <RAMPGEN_Run>

	// generate the motor electrical angle
	angle_pu = RAMPGEN_GetAngleOut(obj->rampgen_handle);
10004b44:	e51b3010 	ldr	r3, [fp, #-16]
10004b48:	e5933244 	ldr	r3, [r3, #580]	; 0x244
10004b4c:	e1a00003 	mov	r0, r3
10004b50:	ebfff745 	bl	1000286c <RAMPGEN_GetAngleOut>
10004b54:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec

	// compute the sin/cos phasor
	CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
10004b58:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
10004b5c:	ed9f7a51 	vldr	s14, [pc, #324]	; 10004ca8 <CTRL_runOpenLoop_User+0x200>
10004b60:	ee677a87 	vmul.f32	s15, s15, s14
10004b64:	e24b301c 	sub	r3, fp, #28
10004b68:	eeb00a67 	vmov.f32	s0, s15
10004b6c:	e1a00003 	mov	r0, r3
10004b70:	ebfffe24 	bl	10004408 <CTRL_computePhasor>
		Speed_SetElecTheta(obj->Speed_handle, angle_pu * MATH_TWO_PI);
		Speed_Run(obj->Speed_handle);
	}
	#endif 
	// set
	vdq.value[0] = (0.0f);
10004b74:	e3a03000 	mov	r3, #0
10004b78:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	vdq.value[1] = ((45.0f)* RMP_CNTL_GetFreq(obj->rmpcntl_handle));//ESTUN: (10.0), PHASE: (15.0)
10004b7c:	e51b3010 	ldr	r3, [fp, #-16]
10004b80:	e5933224 	ldr	r3, [r3, #548]	; 0x224
10004b84:	e1a00003 	mov	r0, r3
10004b88:	ebfff6d4 	bl	100026e0 <RMP_CNTL_GetFreq>
10004b8c:	eeb07a40 	vmov.f32	s14, s0
10004b90:	eddf7a45 	vldr	s15, [pc, #276]	; 10004cac <CTRL_runOpenLoop_User+0x204>
10004b94:	ee677a27 	vmul.f32	s15, s14, s15
10004b98:	ed4b7a08 	vstr	s15, [fp, #-32]	; 0xffffffe0
	if( vdq.value[1] > (45.0f) )
10004b9c:	ed5b7a08 	vldr	s15, [fp, #-32]	; 0xffffffe0
10004ba0:	ed9f7a41 	vldr	s14, [pc, #260]	; 10004cac <CTRL_runOpenLoop_User+0x204>
10004ba4:	eef47ac7 	vcmpe.f32	s15, s14
10004ba8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10004bac:	da000002 	ble	10004bbc <CTRL_runOpenLoop_User+0x114>
	{
		vdq.value[1] = (45.0f);
10004bb0:	e3a03000 	mov	r3, #0
10004bb4:	e3443234 	movt	r3, #16948	; 0x4234
10004bb8:	e50b3020 	str	r3, [fp, #-32]
	}
	CTRL_setVdq_out_pu(obj,&vdq);
10004bbc:	e24b3024 	sub	r3, fp, #36	; 0x24
10004bc0:	e51b0010 	ldr	r0, [fp, #-16]
10004bc4:	e1a01003 	mov	r1, r3
10004bc8:	ebfffdd7 	bl	1000432c <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
10004bcc:	e51b3010 	ldr	r3, [fp, #-16]
10004bd0:	e59320a8 	ldr	r2, [r3, #168]	; 0xa8
10004bd4:	e24b301c 	sub	r3, fp, #28
10004bd8:	e1a00002 	mov	r0, r2
10004bdc:	e1a01003 	mov	r1, r3
10004be0:	ebfff4aa 	bl	10001e90 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
10004be4:	e51b3010 	ldr	r3, [fp, #-16]
10004be8:	e59340a8 	ldr	r4, [r3, #168]	; 0xa8
10004bec:	e51b0010 	ldr	r0, [fp, #-16]
10004bf0:	ebfffa11 	bl	1000343c <CTRL_getVdq_out_addr>
10004bf4:	e1a05000 	mov	r5, r0
10004bf8:	e51b0010 	ldr	r0, [fp, #-16]
10004bfc:	ebfff9f6 	bl	100033dc <CTRL_getVab_out_addr>
10004c00:	e1a03000 	mov	r3, r0
10004c04:	e1a00004 	mov	r0, r4
10004c08:	e1a01005 	mov	r1, r5
10004c0c:	e1a02003 	mov	r2, r3
10004c10:	ebfff474 	bl	10001de8 <IPARK_run>
	
	//oneOverDcBus = EST_getOneOverDcBus_pu(estHandle);
	//obj->Vab_out.value[0] = (obj->Vab_out.value[0] * oneOverDcBus);
	//obj->Vab_out.value[1] = (obj->Vab_out.value[1] * oneOverDcBus);
	// run the space Vector Generator (SVGEN) module
	obj->Vab_out.value[0] = (obj->Vab_out.value[0]/570);
10004c14:	e51b3010 	ldr	r3, [fp, #-16]
10004c18:	edd37a63 	vldr	s15, [r3, #396]	; 0x18c
10004c1c:	ed9f7a23 	vldr	s14, [pc, #140]	; 10004cb0 <CTRL_runOpenLoop_User+0x208>
10004c20:	eec77a87 	vdiv.f32	s15, s15, s14
10004c24:	e51b3010 	ldr	r3, [fp, #-16]
10004c28:	edc37a63 	vstr	s15, [r3, #396]	; 0x18c
	obj->Vab_out.value[1] = (obj->Vab_out.value[1]/570);
10004c2c:	e51b3010 	ldr	r3, [fp, #-16]
10004c30:	edd37a64 	vldr	s15, [r3, #400]	; 0x190
10004c34:	ed9f7a1d 	vldr	s14, [pc, #116]	; 10004cb0 <CTRL_runOpenLoop_User+0x208>
10004c38:	eec77a87 	vdiv.f32	s15, s15, s14
10004c3c:	e51b3010 	ldr	r3, [fp, #-16]
10004c40:	edc37a64 	vstr	s15, [r3, #400]	; 0x190
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(obj),&(pPwmData->Tabc));
10004c44:	e51b3010 	ldr	r3, [fp, #-16]
10004c48:	e59340b4 	ldr	r4, [r3, #180]	; 0xb4
10004c4c:	e51b0010 	ldr	r0, [fp, #-16]
10004c50:	ebfff9e1 	bl	100033dc <CTRL_getVab_out_addr>
10004c54:	e1a02000 	mov	r2, r0
10004c58:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004c5c:	e1a00004 	mov	r0, r4
10004c60:	e1a01002 	mov	r1, r2
10004c64:	e1a02003 	mov	r2, r3
10004c68:	ebfff5a9 	bl	10002314 <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
10004c6c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004c70:	e5932000 	ldr	r2, [r3]
10004c74:	e51b3010 	ldr	r3, [fp, #-16]
10004c78:	e5832314 	str	r2, [r3, #788]	; 0x314
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
10004c7c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004c80:	e5932004 	ldr	r2, [r3, #4]
10004c84:	e51b3010 	ldr	r3, [fp, #-16]
10004c88:	e5832318 	str	r2, [r3, #792]	; 0x318
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
10004c8c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004c90:	e5932008 	ldr	r2, [r3, #8]
10004c94:	e51b3010 	ldr	r3, [fp, #-16]
10004c98:	e583231c 	str	r2, [r3, #796]	; 0x31c

 return;
10004c9c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_runOnLine_User() function
10004ca0:	e24bd00c 	sub	sp, fp, #12
10004ca4:	e8bd8830 	pop	{r4, r5, fp, pc}
10004ca8:	40c90fdb 	.word	0x40c90fdb
10004cac:	42340000 	.word	0x42340000
10004cb0:	440e8000 	.word	0x440e8000

10004cb4 <CTRL_runOnLine_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runOnLine_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
10004cb4:	e92d4830 	push	{r4, r5, fp, lr}
10004cb8:	e28db00c 	add	fp, sp, #12
10004cbc:	e24dd060 	sub	sp, sp, #96	; 0x60
10004cc0:	e50b0060 	str	r0, [fp, #-96]	; 0x60
10004cc4:	e50b1064 	str	r1, [fp, #-100]	; 0x64
10004cc8:	e50b2068 	str	r2, [fp, #-104]	; 0x68
10004ccc:	e50b306c 	str	r3, [fp, #-108]	; 0x6c

	CTRL_Obj *obj = (CTRL_Obj *)handle;
10004cd0:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
10004cd4:	e50b3018 	str	r3, [fp, #-24]
	int16_t angle_temp_pu;
	float_t angle_pu, temp;
	static int i = 0;
	MATH_vec2 phasor;
	
	if(i == 0)
10004cd8:	e30c3000 	movw	r3, #49152	; 0xc000
10004cdc:	e3413003 	movt	r3, #4099	; 0x1003
10004ce0:	e5933000 	ldr	r3, [r3]
10004ce4:	e3530000 	cmp	r3, #0
10004ce8:	1a00000a 	bne	10004d18 <CTRL_runOnLine_User+0x64>
	{
		halHandle->qep_bias = pQepData->qep_cnt;
10004cec:	e59b3004 	ldr	r3, [fp, #4]
10004cf0:	e5932000 	ldr	r2, [r3]
10004cf4:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10004cf8:	e58320f8 	str	r2, [r3, #248]	; 0xf8
		i++;
10004cfc:	e30c3000 	movw	r3, #49152	; 0xc000
10004d00:	e3413003 	movt	r3, #4099	; 0x1003
10004d04:	e5933000 	ldr	r3, [r3]
10004d08:	e2832001 	add	r2, r3, #1
10004d0c:	e30c3000 	movw	r3, #49152	; 0xc000
10004d10:	e3413003 	movt	r3, #4099	; 0x1003
10004d14:	e5832000 	str	r2, [r3]
	}
	temp = pQepData->qep_cnt - halHandle->qep_bias;
10004d18:	e59b3004 	ldr	r3, [fp, #4]
10004d1c:	ed937a00 	vldr	s14, [r3]
10004d20:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10004d24:	edd37a3e 	vldr	s15, [r3, #248]	; 0xf8
10004d28:	ee777a67 	vsub.f32	s15, s14, s15
10004d2c:	ed4b7a04 	vstr	s15, [fp, #-16]
	if(temp < 0)
10004d30:	ed5b7a04 	vldr	s15, [fp, #-16]
10004d34:	eef57ac0 	vcmpe.f32	s15, #0.0
10004d38:	eef1fa10 	vmrs	APSR_nzcv, fpscr
10004d3c:	5a000007 	bpl	10004d60 <CTRL_runOnLine_User+0xac>
		temp = pQepData->qep_cnt + (ENCODER_PPR * 4 * 4) - halHandle->qep_bias;
10004d40:	e59b3004 	ldr	r3, [fp, #4]
10004d44:	ed937a00 	vldr	s14, [r3]
10004d48:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10004d4c:	edd37a3e 	vldr	s15, [r3, #248]	; 0xf8
10004d50:	ee777a67 	vsub.f32	s15, s14, s15
10004d54:	ed9f7ac8 	vldr	s14, [pc, #800]	; 1000507c <CTRL_runOnLine_User+0x3c8>
10004d58:	ee777a87 	vadd.f32	s15, s15, s14
10004d5c:	ed4b7a04 	vstr	s15, [fp, #-16]
	
	//angle_pu = temp / (ENCODER_PPR * 4) + 0.5f;
	angle_pu = (-1.0f) * temp / (ENCODER_PPR * 4) + 0.5;
10004d60:	ed5b7a04 	vldr	s15, [fp, #-16]
10004d64:	eef17a67 	vneg.f32	s15, s15
10004d68:	ed9f7ac4 	vldr	s14, [pc, #784]	; 10005080 <CTRL_runOnLine_User+0x3cc>
10004d6c:	eec77a87 	vdiv.f32	s15, s15, s14
10004d70:	eeb67a00 	vmov.f32	s14, #96	; 0x60
10004d74:	ee777a87 	vadd.f32	s15, s15, s14
10004d78:	ed4b7a07 	vstr	s15, [fp, #-28]	; 0xffffffe4
	obj->temp = angle_pu;
10004d7c:	e51b3018 	ldr	r3, [fp, #-24]
10004d80:	e51b201c 	ldr	r2, [fp, #-28]
10004d84:	e5832338 	str	r2, [r3, #824]	; 0x338
	//	obj->angle_pu = angle_pu;

	// run Clarke transform on current
	CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(handle));
10004d88:	e51b3018 	ldr	r3, [fp, #-24]
10004d8c:	e593500c 	ldr	r5, [r3, #12]
10004d90:	e51b4068 	ldr	r4, [fp, #-104]	; 0x68
10004d94:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004d98:	ebfff870 	bl	10002f60 <CTRL_getIab_in_addr>
10004d9c:	e1a03000 	mov	r3, r0
10004da0:	e1a00005 	mov	r0, r5
10004da4:	e1a01004 	mov	r1, r4
10004da8:	e1a02003 	mov	r2, r3
10004dac:	ebfff36d 	bl	10001b68 <CLARKE_run>


		// compute the sin/cos phasor
	CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
10004db0:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
10004db4:	ed9f7ab2 	vldr	s14, [pc, #712]	; 10005084 <CTRL_runOnLine_User+0x3d0>
10004db8:	ee677a87 	vmul.f32	s15, s15, s14
10004dbc:	e24b305c 	sub	r3, fp, #92	; 0x5c
10004dc0:	eeb00a67 	vmov.f32	s0, s15
10004dc4:	e1a00003 	mov	r0, r3
10004dc8:	ebfffd8e 	bl	10004408 <CTRL_computePhasor>


	// set the phasor in the Park transform
	PARK_setPhasor(obj->parkHandle,&phasor);
10004dcc:	e51b3018 	ldr	r3, [fp, #-24]
10004dd0:	e5932030 	ldr	r2, [r3, #48]	; 0x30
10004dd4:	e24b305c 	sub	r3, fp, #92	; 0x5c
10004dd8:	e1a00002 	mov	r0, r2
10004ddc:	e1a01003 	mov	r1, r3
10004de0:	ebfff3ed 	bl	10001d9c <PARK_setPhasor>


	// run the Park transform
	PARK_run(obj->parkHandle,CTRL_getIab_in_addr(handle),CTRL_getIdq_in_addr(handle));
10004de4:	e51b3018 	ldr	r3, [fp, #-24]
10004de8:	e5934030 	ldr	r4, [r3, #48]	; 0x30
10004dec:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004df0:	ebfff85a 	bl	10002f60 <CTRL_getIab_in_addr>
10004df4:	e1a05000 	mov	r5, r0
10004df8:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004dfc:	ebfff87d 	bl	10002ff8 <CTRL_getIdq_in_addr>
10004e00:	e1a03000 	mov	r3, r0
10004e04:	e1a00004 	mov	r0, r4
10004e08:	e1a01005 	mov	r1, r5
10004e0c:	e1a02003 	mov	r2, r3
10004e10:	ebfff3b7 	bl	10001cf4 <PARK_run>


	// when appropriate, run the PID speed controller
	if(CTRL_doSpeedCtrl(handle))
10004e14:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004e18:	ebfffda8 	bl	100044c0 <CTRL_doSpeedCtrl>
10004e1c:	e1a03000 	mov	r3, r0
10004e20:	e3530000 	cmp	r3, #0
10004e24:	0a000042 	beq	10004f34 <CTRL_runOnLine_User+0x280>
	{
//		float_t refValue = TRAJ_getIntValue(obj->trajHandle_spd);
//		float_t fbackValue = EST_getFm_pu(obj->estHandle);
//		float_t outMax = TRAJ_getIntValue(obj->trajHandle_spdMax);
//		float_t outMin = -outMax;
		float_t refValue = CTRL_getSpd_ref_pu(obj);//=5.0
10004e28:	e51b0018 	ldr	r0, [fp, #-24]
10004e2c:	ebfff951 	bl	10003378 <CTRL_getSpd_ref_pu>
10004e30:	ed0b0a08 	vstr	s0, [fp, #-32]	; 0xffffffe0
		float_t fbackValue = (0.0f);
10004e34:	e3a03000 	mov	r3, #0
10004e38:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		float_t outMax = (1.0f);
10004e3c:	e3a035fe 	mov	r3, #1065353216	; 0x3f800000
10004e40:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		float_t outMin = -outMax;
10004e44:	ed5b7a0a 	vldr	s15, [fp, #-40]	; 0xffffffd8
10004e48:	eef17a67 	vneg.f32	s15, s15
10004e4c:	ed4b7a0b 	vstr	s15, [fp, #-44]	; 0xffffffd4
		float_t Kp_Spd = CTRL_getKp(handle,CTRL_Type_PID_spd);
10004e50:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004e54:	e3a01000 	mov	r1, #0
10004e58:	ebfff8e1 	bl	100031e4 <CTRL_getKp>
10004e5c:	ed0b0a0c 	vstr	s0, [fp, #-48]	; 0xffffffd0
		float_t Ki_Spd = CTRL_getKi(handle,CTRL_Type_PID_spd);
10004e60:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004e64:	e3a01000 	mov	r1, #0
10004e68:	ebfff895 	bl	100030c4 <CTRL_getKi>
10004e6c:	ed0b0a0d 	vstr	s0, [fp, #-52]	; 0xffffffcc

		// reset the speed count
		CTRL_resetCounter_speed(handle);
10004e70:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004e74:	ebfffa2d 	bl	10003730 <CTRL_resetCounter_speed>

		Speed_SetElecTheta(obj->Speed_handle, angle_pu);
10004e78:	e51b3018 	ldr	r3, [fp, #-24]
10004e7c:	e59332e8 	ldr	r3, [r3, #744]	; 0x2e8
10004e80:	e1a00003 	mov	r0, r3
10004e84:	ed1b0a07 	vldr	s0, [fp, #-28]	; 0xffffffe4
10004e88:	ebfff751 	bl	10002bd4 <Speed_SetElecTheta>
		
		Speed_SetTurnCount(obj->Speed_handle, pQepData->turn_cnt);
10004e8c:	e51b3018 	ldr	r3, [fp, #-24]
10004e90:	e59322e8 	ldr	r2, [r3, #744]	; 0x2e8
10004e94:	e59b3004 	ldr	r3, [fp, #4]
10004e98:	e5933004 	ldr	r3, [r3, #4]
10004e9c:	e1a00002 	mov	r0, r2
10004ea0:	e1a01003 	mov	r1, r3
10004ea4:	ebfff73c 	bl	10002b9c <Speed_SetTurnCount>
		Speed_Run(obj->Speed_handle);
10004ea8:	e51b3018 	ldr	r3, [fp, #-24]
10004eac:	e59332e8 	ldr	r3, [r3, #744]	; 0x2e8
10004eb0:	e1a00003 	mov	r0, r3
10004eb4:	ebfff28a 	bl	100018e4 <Speed_Run>
		fbackValue = Speed_GetElecSpeed(obj->Speed_handle);
10004eb8:	e51b3018 	ldr	r3, [fp, #-24]
10004ebc:	e59332e8 	ldr	r3, [r3, #744]	; 0x2e8
10004ec0:	e1a00003 	mov	r0, r3
10004ec4:	ebfff77a 	bl	10002cb4 <Speed_GetElecSpeed>
10004ec8:	ed0b0a09 	vstr	s0, [fp, #-36]	; 0xffffffdc

		PID_setKp(obj->pidHandle_spd,Kp_Spd);
10004ecc:	e51b3018 	ldr	r3, [fp, #-24]
10004ed0:	e5933084 	ldr	r3, [r3, #132]	; 0x84
10004ed4:	e1a00003 	mov	r0, r3
10004ed8:	ed1b0a0c 	vldr	s0, [fp, #-48]	; 0xffffffd0
10004edc:	ebfff4de 	bl	1000225c <PID_setKp>
		PID_setKi(obj->pidHandle_spd,Ki_Spd);
10004ee0:	e51b3018 	ldr	r3, [fp, #-24]
10004ee4:	e5933084 	ldr	r3, [r3, #132]	; 0x84
10004ee8:	e1a00003 	mov	r0, r3
10004eec:	ed1b0a0d 	vldr	s0, [fp, #-52]	; 0xffffffcc
10004ef0:	ebfff4cb 	bl	10002224 <PID_setKi>

		PID_setMinMax(obj->pidHandle_spd,outMin,outMax);
10004ef4:	e51b3018 	ldr	r3, [fp, #-24]
10004ef8:	e5933084 	ldr	r3, [r3, #132]	; 0x84
10004efc:	e1a00003 	mov	r0, r3
10004f00:	ed1b0a0b 	vldr	s0, [fp, #-44]	; 0xffffffd4
10004f04:	ed5b0a0a 	vldr	s1, [fp, #-40]	; 0xffffffd8
10004f08:	ebfff4e1 	bl	10002294 <PID_setMinMax>

		PID_run_spd(obj->pidHandle_spd,refValue,fbackValue,CTRL_getSpd_out_addr(handle));
10004f0c:	e51b3018 	ldr	r3, [fp, #-24]
10004f10:	e5934084 	ldr	r4, [r3, #132]	; 0x84
10004f14:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004f18:	ebfff8fd 	bl	10003314 <CTRL_getSpd_out_addr>
10004f1c:	e1a03000 	mov	r3, r0
10004f20:	e1a00004 	mov	r0, r4
10004f24:	ed1b0a08 	vldr	s0, [fp, #-32]	; 0xffffffe0
10004f28:	ed5b0a09 	vldr	s1, [fp, #-36]	; 0xffffffdc
10004f2c:	e1a01003 	mov	r1, r3
10004f30:	ebfff467 	bl	100020d4 <PID_run_spd>
	}


	// when appropriate, run the PID Id and Iq controllers
	if(CTRL_doCurrentCtrl(handle))
10004f34:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004f38:	ebfffd44 	bl	10004450 <CTRL_doCurrentCtrl>
10004f3c:	e1a03000 	mov	r3, r0
10004f40:	e3530000 	cmp	r3, #0
10004f44:	0a00006f 	beq	10005108 <CTRL_runOnLine_User+0x454>
	{
		float_t Kp_Id = CTRL_getKp(handle,CTRL_Type_PID_Id);
10004f48:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004f4c:	e3a01001 	mov	r1, #1
10004f50:	ebfff8a3 	bl	100031e4 <CTRL_getKp>
10004f54:	ed0b0a0e 	vstr	s0, [fp, #-56]	; 0xffffffc8
		float_t Kp_Iq = CTRL_getKp(handle,CTRL_Type_PID_Iq);
10004f58:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004f5c:	e3a01002 	mov	r1, #2
10004f60:	ebfff89f 	bl	100031e4 <CTRL_getKp>
10004f64:	ed0b0a0f 	vstr	s0, [fp, #-60]	; 0xffffffc4
		float_t Ki_Id = CTRL_getKi(handle,CTRL_Type_PID_Id);
10004f68:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004f6c:	e3a01001 	mov	r1, #1
10004f70:	ebfff853 	bl	100030c4 <CTRL_getKi>
10004f74:	ed0b0a10 	vstr	s0, [fp, #-64]	; 0xffffffc0
		float_t Ki_Iq = CTRL_getKi(handle,CTRL_Type_PID_Iq);
10004f78:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004f7c:	e3a01002 	mov	r1, #2
10004f80:	ebfff84f 	bl	100030c4 <CTRL_getKi>
10004f84:	ed0b0a11 	vstr	s0, [fp, #-68]	; 0xffffffbc
		float_t outMin,outMax;


//		// read max voltage vector to set proper limits to current controllers
//		float_t maxVsMag = CTRL_getMaxVsMag_pu(handle);
		float_t maxVsMag = (15.0f);
10004f88:	e3a03000 	mov	r3, #0
10004f8c:	e3443170 	movt	r3, #16752	; 0x4170
10004f90:	e50b3048 	str	r3, [fp, #-72]	; 0x48


		// reset the current count
		CTRL_resetCounter_current(handle);
10004f94:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004f98:	ebfff9c7 	bl	100036bc <CTRL_resetCounter_current>
//		if(CTRL_getFlag_enableDcBusComp(handle))
//		{
//			Kp_Id = (Kp_Id*EST_getOneOverDcBus_pu(obj->estHandle));
//		}

		PID_setKp(obj->pidHandle_Id,Kp_Id);
10004f9c:	e51b3018 	ldr	r3, [fp, #-24]
10004fa0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10004fa4:	e1a00003 	mov	r0, r3
10004fa8:	ed1b0a0e 	vldr	s0, [fp, #-56]	; 0xffffffc8
10004fac:	ebfff4aa 	bl	1000225c <PID_setKp>
		PID_setKi(obj->pidHandle_Id,Ki_Id);
10004fb0:	e51b3018 	ldr	r3, [fp, #-24]
10004fb4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10004fb8:	e1a00003 	mov	r0, r3
10004fbc:	ed1b0a10 	vldr	s0, [fp, #-64]	; 0xffffffc0
10004fc0:	ebfff497 	bl	10002224 <PID_setKi>

//		// compute the reference value
//		refValue = TRAJ_getIntValue(obj->trajHandle_Id) + CTRL_getId_ref_pu(handle);
		refValue = CTRL_getId_ref_pu(handle);//=0
10004fc4:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004fc8:	ebfff7fd 	bl	10002fc4 <CTRL_getId_ref_pu>
10004fcc:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec

//		// update the Id reference value
//		EST_updateId_ref_pu(obj->estHandle,&refValue);

		// get the feedback value
		fbackValue = CTRL_getId_in_pu(handle);
10004fd0:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10004fd4:	ebfff7ed 	bl	10002f90 <CTRL_getId_in_pu>
10004fd8:	ed0b0a13 	vstr	s0, [fp, #-76]	; 0xffffffb4

		// set minimum and maximum for Id controller output
		outMax = maxVsMag;
10004fdc:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10004fe0:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		outMin = -outMax;
10004fe4:	ed5b7a14 	vldr	s15, [fp, #-80]	; 0xffffffb0
10004fe8:	eef17a67 	vneg.f32	s15, s15
10004fec:	ed4b7a15 	vstr	s15, [fp, #-84]	; 0xffffffac

		// set the minimum and maximum values
		PID_setMinMax(obj->pidHandle_Id,outMin,outMax);
10004ff0:	e51b3018 	ldr	r3, [fp, #-24]
10004ff4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10004ff8:	e1a00003 	mov	r0, r3
10004ffc:	ed1b0a15 	vldr	s0, [fp, #-84]	; 0xffffffac
10005000:	ed5b0a14 	vldr	s1, [fp, #-80]	; 0xffffffb0
10005004:	ebfff4a2 	bl	10002294 <PID_setMinMax>

		// run the Id PID controller
		PID_run(obj->pidHandle_Id,refValue,fbackValue,CTRL_getVd_out_addr(handle));
10005008:	e51b3018 	ldr	r3, [fp, #-24]
1000500c:	e593403c 	ldr	r4, [r3, #60]	; 0x3c
10005010:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005014:	ebfff8fc 	bl	1000340c <CTRL_getVd_out_addr>
10005018:	e1a03000 	mov	r3, r0
1000501c:	e1a00004 	mov	r0, r4
10005020:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10005024:	ed5b0a13 	vldr	s1, [fp, #-76]	; 0xffffffb4
10005028:	e1a01003 	mov	r1, r3
1000502c:	ebfff3ea 	bl	10001fdc <PID_run>
//		if(CTRL_getFlag_enableDcBusComp(handle))
//		{
//			Kp_Iq = (Kp_Iq*EST_getOneOverDcBus_pu(obj->estHandle));
//		}

		PID_setKp(obj->pidHandle_Iq,Kp_Iq);
10005030:	e51b3018 	ldr	r3, [fp, #-24]
10005034:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10005038:	e1a00003 	mov	r0, r3
1000503c:	ed1b0a0f 	vldr	s0, [fp, #-60]	; 0xffffffc4
10005040:	ebfff485 	bl	1000225c <PID_setKp>
		PID_setKi(obj->pidHandle_Iq,Ki_Iq);
10005044:	e51b3018 	ldr	r3, [fp, #-24]
10005048:	e5933060 	ldr	r3, [r3, #96]	; 0x60
1000504c:	e1a00003 	mov	r0, r3
10005050:	ed1b0a11 	vldr	s0, [fp, #-68]	; 0xffffffbc
10005054:	ebfff472 	bl	10002224 <PID_setKi>

		// get the reference value
		if(CTRL_getFlag_enableSpeedCtrl(handle))
10005058:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
1000505c:	ebfff7a7 	bl	10002f00 <CTRL_getFlag_enableSpeedCtrl>
10005060:	e1a03000 	mov	r3, r0
10005064:	e3530000 	cmp	r3, #0
10005068:	0a000007 	beq	1000508c <CTRL_runOnLine_User+0x3d8>
		{
			refValue = CTRL_getSpd_out_pu(handle);
1000506c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005070:	ebfff8b3 	bl	10003344 <CTRL_getSpd_out_pu>
10005074:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
10005078:	ea000006 	b	10005098 <CTRL_runOnLine_User+0x3e4>
1000507c:	461c4000 	.word	0x461c4000
10005080:	451c4000 	.word	0x451c4000
10005084:	40c90fdb 	.word	0x40c90fdb
10005088:	440e8000 	.word	0x440e8000
		}
		else
		{
		// get the Iq reference value
			refValue = CTRL_getIq_ref_pu(handle);
1000508c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005090:	ebfff7fe 	bl	10003090 <CTRL_getIq_ref_pu>
10005094:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
		}

		// get the feedback value
		fbackValue = CTRL_getIq_in_pu(handle);
10005098:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
1000509c:	ebfff7ee 	bl	1000305c <CTRL_getIq_in_pu>
100050a0:	ed0b0a13 	vstr	s0, [fp, #-76]	; 0xffffffb4
		obj->temp_iq = fbackValue;
100050a4:	e51b3018 	ldr	r3, [fp, #-24]
100050a8:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
100050ac:	e583233c 	str	r2, [r3, #828]	; 0x33c

//		// set minimum and maximum for Id controller output
//		outMax = sqrtf((maxVsMag*maxVsMag) - (CTRL_getVd_out_pu(handle)*CTRL_getVd_out_pu(handle)));
//		outMin = -outMax;
		outMax = (50.0f);
100050b0:	e3a03000 	mov	r3, #0
100050b4:	e3443248 	movt	r3, #16968	; 0x4248
100050b8:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		outMin = -outMax;
100050bc:	ed5b7a14 	vldr	s15, [fp, #-80]	; 0xffffffb0
100050c0:	eef17a67 	vneg.f32	s15, s15
100050c4:	ed4b7a15 	vstr	s15, [fp, #-84]	; 0xffffffac

		// set the minimum and maximum values
		PID_setMinMax(obj->pidHandle_Iq,outMin,outMax);
100050c8:	e51b3018 	ldr	r3, [fp, #-24]
100050cc:	e5933060 	ldr	r3, [r3, #96]	; 0x60
100050d0:	e1a00003 	mov	r0, r3
100050d4:	ed1b0a15 	vldr	s0, [fp, #-84]	; 0xffffffac
100050d8:	ed5b0a14 	vldr	s1, [fp, #-80]	; 0xffffffb0
100050dc:	ebfff46c 	bl	10002294 <PID_setMinMax>

		// run the Iq PID controller
		PID_run(obj->pidHandle_Iq,refValue,fbackValue,CTRL_getVq_out_addr(handle));
100050e0:	e51b3018 	ldr	r3, [fp, #-24]
100050e4:	e5934060 	ldr	r4, [r3, #96]	; 0x60
100050e8:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
100050ec:	ebfff8de 	bl	1000346c <CTRL_getVq_out_addr>
100050f0:	e1a03000 	mov	r3, r0
100050f4:	e1a00004 	mov	r0, r4
100050f8:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
100050fc:	ed5b0a13 	vldr	s1, [fp, #-76]	; 0xffffffb4
10005100:	e1a01003 	mov	r1, r3
10005104:	ebfff3b4 	bl	10001fdc <PID_run>
//		CTRL_computePhasor(angleComp_pu * MATH_TWO_PI,&phasor);
//	}


	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
10005108:	e51b3018 	ldr	r3, [fp, #-24]
1000510c:	e59320a8 	ldr	r2, [r3, #168]	; 0xa8
10005110:	e24b305c 	sub	r3, fp, #92	; 0x5c
10005114:	e1a00002 	mov	r0, r2
10005118:	e1a01003 	mov	r1, r3
1000511c:	ebfff35b 	bl	10001e90 <IPARK_setPhasor>


	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(handle),CTRL_getVab_out_addr(handle));
10005120:	e51b3018 	ldr	r3, [fp, #-24]
10005124:	e59340a8 	ldr	r4, [r3, #168]	; 0xa8
10005128:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
1000512c:	ebfff8c2 	bl	1000343c <CTRL_getVdq_out_addr>
10005130:	e1a05000 	mov	r5, r0
10005134:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005138:	ebfff8a7 	bl	100033dc <CTRL_getVab_out_addr>
1000513c:	e1a03000 	mov	r3, r0
10005140:	e1a00004 	mov	r0, r4
10005144:	e1a01005 	mov	r1, r5
10005148:	e1a02003 	mov	r2, r3
1000514c:	ebfff325 	bl	10001de8 <IPARK_run>
	obj->Vab_out.value[0] = (obj->Vab_out.value[0]/570);
10005150:	e51b3018 	ldr	r3, [fp, #-24]
10005154:	edd37a63 	vldr	s15, [r3, #396]	; 0x18c
10005158:	ed1f7a36 	vldr	s14, [pc, #-216]	; 10005088 <CTRL_runOnLine_User+0x3d4>
1000515c:	eec77a87 	vdiv.f32	s15, s15, s14
10005160:	e51b3018 	ldr	r3, [fp, #-24]
10005164:	edc37a63 	vstr	s15, [r3, #396]	; 0x18c
	obj->Vab_out.value[1] = (obj->Vab_out.value[1]/570);
10005168:	e51b3018 	ldr	r3, [fp, #-24]
1000516c:	edd37a64 	vldr	s15, [r3, #400]	; 0x190
10005170:	ed1f7a3c 	vldr	s14, [pc, #-240]	; 10005088 <CTRL_runOnLine_User+0x3d4>
10005174:	eec77a87 	vdiv.f32	s15, s15, s14
10005178:	e51b3018 	ldr	r3, [fp, #-24]
1000517c:	edc37a64 	vstr	s15, [r3, #400]	; 0x190


	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(handle),&(pPwmData->Tabc));
10005180:	e51b3018 	ldr	r3, [fp, #-24]
10005184:	e59340b4 	ldr	r4, [r3, #180]	; 0xb4
10005188:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
1000518c:	ebfff892 	bl	100033dc <CTRL_getVab_out_addr>
10005190:	e1a02000 	mov	r2, r0
10005194:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
10005198:	e1a00004 	mov	r0, r4
1000519c:	e1a01002 	mov	r1, r2
100051a0:	e1a02003 	mov	r2, r3
100051a4:	ebfff45a 	bl	10002314 <SVGEN_run>


	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
100051a8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
100051ac:	e5932000 	ldr	r2, [r3]
100051b0:	e51b3018 	ldr	r3, [fp, #-24]
100051b4:	e5832314 	str	r2, [r3, #788]	; 0x314
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
100051b8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
100051bc:	e5932004 	ldr	r2, [r3, #4]
100051c0:	e51b3018 	ldr	r3, [fp, #-24]
100051c4:	e5832318 	str	r2, [r3, #792]	; 0x318
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
100051c8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
100051cc:	e5932008 	ldr	r2, [r3, #8]
100051d0:	e51b3018 	ldr	r3, [fp, #-24]
100051d4:	e583231c 	str	r2, [r3, #796]	; 0x31c
	//	DATA_LOG_Run(obj->datalog_handle);

	obj->MntValue.value[0] = Speed_GetElecSpeed(obj->Speed_handle);
100051d8:	e51b3018 	ldr	r3, [fp, #-24]
100051dc:	e59332e8 	ldr	r3, [r3, #744]	; 0x2e8
100051e0:	e1a00003 	mov	r0, r3
100051e4:	ebfff6b2 	bl	10002cb4 <Speed_GetElecSpeed>
100051e8:	eef07a40 	vmov.f32	s15, s0
100051ec:	e51b3018 	ldr	r3, [fp, #-24]
100051f0:	edc37acb 	vstr	s15, [r3, #812]	; 0x32c
	obj->MntValue.value[1] = angle_pu;
100051f4:	e51b3018 	ldr	r3, [fp, #-24]
100051f8:	e51b201c 	ldr	r2, [fp, #-28]
100051fc:	e5832330 	str	r2, [r3, #816]	; 0x330
	obj->MntValue.value[2] = CTRL_getVq_out_pu(handle);
10005200:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005204:	ebfff8a4 	bl	1000349c <CTRL_getVq_out_pu>
10005208:	eef07a40 	vmov.f32	s15, s0
1000520c:	e51b3018 	ldr	r3, [fp, #-24]
10005210:	edc37acd 	vstr	s15, [r3, #820]	; 0x334

return;
10005214:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_runOnLine_User() function
10005218:	e24bd00c 	sub	sp, fp, #12
1000521c:	e8bd8830 	pop	{r4, r5, fp, pc}

10005220 <CTRL_getGains>:
// **************************************************************************
// the function prototypes

void CTRL_getGains(CTRL_Handle handle,const CTRL_Type_e ctrlType,
                   float_t *pKp,float_t *pKi,float_t *pKd)
{
10005220:	e92d4800 	push	{fp, lr}
10005224:	e28db004 	add	fp, sp, #4
10005228:	e24dd010 	sub	sp, sp, #16
1000522c:	e50b0008 	str	r0, [fp, #-8]
10005230:	e50b2010 	str	r2, [fp, #-16]
10005234:	e50b3014 	str	r3, [fp, #-20]
10005238:	e1a03001 	mov	r3, r1
1000523c:	e54b3009 	strb	r3, [fp, #-9]

  *pKp = CTRL_getKp(handle,ctrlType);
10005240:	e55b3009 	ldrb	r3, [fp, #-9]
10005244:	e51b0008 	ldr	r0, [fp, #-8]
10005248:	e1a01003 	mov	r1, r3
1000524c:	ebfff7e4 	bl	100031e4 <CTRL_getKp>
10005250:	eef07a40 	vmov.f32	s15, s0
10005254:	e51b3010 	ldr	r3, [fp, #-16]
10005258:	edc37a00 	vstr	s15, [r3]
  *pKi = CTRL_getKi(handle,ctrlType);
1000525c:	e55b3009 	ldrb	r3, [fp, #-9]
10005260:	e51b0008 	ldr	r0, [fp, #-8]
10005264:	e1a01003 	mov	r1, r3
10005268:	ebfff795 	bl	100030c4 <CTRL_getKi>
1000526c:	eef07a40 	vmov.f32	s15, s0
10005270:	e51b3014 	ldr	r3, [fp, #-20]
10005274:	edc37a00 	vstr	s15, [r3]
  *pKd = CTRL_getKd(handle,ctrlType);
10005278:	e55b3009 	ldrb	r3, [fp, #-9]
1000527c:	e51b0008 	ldr	r0, [fp, #-8]
10005280:	e1a01003 	mov	r1, r3
10005284:	ebfff7b2 	bl	10003154 <CTRL_getKd>
10005288:	eef07a40 	vmov.f32	s15, s0
1000528c:	e59b3004 	ldr	r3, [fp, #4]
10005290:	edc37a00 	vstr	s15, [r3]

  return;    
10005294:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getGains() function
10005298:	e24bd004 	sub	sp, fp, #4
1000529c:	e8bd8800 	pop	{fp, pc}

100052a0 <CTRL_getIab_filt_pu>:


void CTRL_getIab_filt_pu(CTRL_Handle handle,MATH_vec2 *pIab_filt_pu)
{
100052a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100052a4:	e28db000 	add	fp, sp, #0
100052a8:	e24dd014 	sub	sp, sp, #20
100052ac:	e50b0010 	str	r0, [fp, #-16]
100052b0:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100052b4:	e51b3010 	ldr	r3, [fp, #-16]
100052b8:	e50b3008 	str	r3, [fp, #-8]

  pIab_filt_pu->value[0] = obj->Iab_filt.value[0];
100052bc:	e51b3008 	ldr	r3, [fp, #-8]
100052c0:	e5932170 	ldr	r2, [r3, #368]	; 0x170
100052c4:	e51b3014 	ldr	r3, [fp, #-20]
100052c8:	e5832000 	str	r2, [r3]
  pIab_filt_pu->value[1] = obj->Iab_filt.value[1];
100052cc:	e51b3008 	ldr	r3, [fp, #-8]
100052d0:	e5932174 	ldr	r2, [r3, #372]	; 0x174
100052d4:	e51b3014 	ldr	r3, [fp, #-20]
100052d8:	e5832004 	str	r2, [r3, #4]

  return;
100052dc:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getIab_filt_pu() function
100052e0:	e24bd000 	sub	sp, fp, #0
100052e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100052e8:	e12fff1e 	bx	lr

100052ec <CTRL_getIab_in_pu>:


void CTRL_getIab_in_pu(CTRL_Handle handle,MATH_vec2 *pIab_in_pu)
{
100052ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100052f0:	e28db000 	add	fp, sp, #0
100052f4:	e24dd014 	sub	sp, sp, #20
100052f8:	e50b0010 	str	r0, [fp, #-16]
100052fc:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10005300:	e51b3010 	ldr	r3, [fp, #-16]
10005304:	e50b3008 	str	r3, [fp, #-8]

  pIab_in_pu->value[0] = obj->Iab_in.value[0];
10005308:	e51b3008 	ldr	r3, [fp, #-8]
1000530c:	e5932168 	ldr	r2, [r3, #360]	; 0x168
10005310:	e51b3014 	ldr	r3, [fp, #-20]
10005314:	e5832000 	str	r2, [r3]
  pIab_in_pu->value[1] = obj->Iab_in.value[1];
10005318:	e51b3008 	ldr	r3, [fp, #-8]
1000531c:	e593216c 	ldr	r2, [r3, #364]	; 0x16c
10005320:	e51b3014 	ldr	r3, [fp, #-20]
10005324:	e5832004 	str	r2, [r3, #4]

  return;
10005328:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getIab_in_pu() function
1000532c:	e24bd000 	sub	sp, fp, #0
10005330:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10005334:	e12fff1e 	bx	lr

10005338 <CTRL_getIdq_in_pu>:


void CTRL_getIdq_in_pu(CTRL_Handle handle,MATH_vec2 *pIdq_in_pu)
{
10005338:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000533c:	e28db000 	add	fp, sp, #0
10005340:	e24dd014 	sub	sp, sp, #20
10005344:	e50b0010 	str	r0, [fp, #-16]
10005348:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000534c:	e51b3010 	ldr	r3, [fp, #-16]
10005350:	e50b3008 	str	r3, [fp, #-8]

  pIdq_in_pu->value[0] = obj->Idq_in.value[0];
10005354:	e51b3008 	ldr	r3, [fp, #-8]
10005358:	e5932178 	ldr	r2, [r3, #376]	; 0x178
1000535c:	e51b3014 	ldr	r3, [fp, #-20]
10005360:	e5832000 	str	r2, [r3]
  pIdq_in_pu->value[1] = obj->Idq_in.value[1];
10005364:	e51b3008 	ldr	r3, [fp, #-8]
10005368:	e593217c 	ldr	r2, [r3, #380]	; 0x17c
1000536c:	e51b3014 	ldr	r3, [fp, #-20]
10005370:	e5832004 	str	r2, [r3, #4]

  return;
10005374:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getIdq_in_pu() function
10005378:	e24bd000 	sub	sp, fp, #0
1000537c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10005380:	e12fff1e 	bx	lr

10005384 <CTRL_getIdq_ref_pu>:


void CTRL_getIdq_ref_pu(CTRL_Handle handle,MATH_vec2 *pIdq_ref_pu)
{
10005384:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10005388:	e28db000 	add	fp, sp, #0
1000538c:	e24dd014 	sub	sp, sp, #20
10005390:	e50b0010 	str	r0, [fp, #-16]
10005394:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10005398:	e51b3010 	ldr	r3, [fp, #-16]
1000539c:	e50b3008 	str	r3, [fp, #-8]

  pIdq_ref_pu->value[0] = obj->Idq_ref.value[0];
100053a0:	e51b3008 	ldr	r3, [fp, #-8]
100053a4:	e59321d8 	ldr	r2, [r3, #472]	; 0x1d8
100053a8:	e51b3014 	ldr	r3, [fp, #-20]
100053ac:	e5832000 	str	r2, [r3]
  pIdq_ref_pu->value[1] = obj->Idq_ref.value[1];
100053b0:	e51b3008 	ldr	r3, [fp, #-8]
100053b4:	e59321dc 	ldr	r2, [r3, #476]	; 0x1dc
100053b8:	e51b3014 	ldr	r3, [fp, #-20]
100053bc:	e5832004 	str	r2, [r3, #4]

  return;
100053c0:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getIdq_ref_pu() function
100053c4:	e24bd000 	sub	sp, fp, #0
100053c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100053cc:	e12fff1e 	bx	lr

100053d0 <CTRL_getMagCurrent_pu>:


float_t CTRL_getMagCurrent_pu(CTRL_Handle handle)
{
100053d0:	e92d4800 	push	{fp, lr}
100053d4:	e28db004 	add	fp, sp, #4
100053d8:	e24dd008 	sub	sp, sp, #8
100053dc:	e50b0008 	str	r0, [fp, #-8]

  return(CTRL_getIdRated_pu(handle));
100053e0:	e51b0008 	ldr	r0, [fp, #-8]
100053e4:	ebfff70f 	bl	10003028 <CTRL_getIdRated_pu>
100053e8:	eef07a40 	vmov.f32	s15, s0
} // end of CTRL_getMagCurrent_pu() function
100053ec:	eeb00a67 	vmov.f32	s0, s15
100053f0:	e24bd004 	sub	sp, fp, #4
100053f4:	e8bd8800 	pop	{fp, pc}

100053f8 <CTRL_getMaximumSpeed_pu>:


float_t CTRL_getMaximumSpeed_pu(CTRL_Handle handle)
{
100053f8:	e92d4800 	push	{fp, lr}
100053fc:	e28db004 	add	fp, sp, #4
10005400:	e24dd008 	sub	sp, sp, #8
10005404:	e50b0008 	str	r0, [fp, #-8]

  return(CTRL_getSpd_max_pu(handle));
10005408:	e51b0008 	ldr	r0, [fp, #-8]
1000540c:	ebfff7b3 	bl	100032e0 <CTRL_getSpd_max_pu>
10005410:	eef07a40 	vmov.f32	s15, s0
} // end of CTRL_getMaximumSpeed_pu() function
10005414:	eeb00a67 	vmov.f32	s0, s15
10005418:	e24bd004 	sub	sp, fp, #4
1000541c:	e8bd8800 	pop	{fp, pc}

10005420 <CTRL_getVab_in_pu>:


void CTRL_getVab_in_pu(CTRL_Handle handle,MATH_vec2 *pVab_in_pu)
{
10005420:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10005424:	e28db000 	add	fp, sp, #0
10005428:	e24dd014 	sub	sp, sp, #20
1000542c:	e50b0010 	str	r0, [fp, #-16]
10005430:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10005434:	e51b3010 	ldr	r3, [fp, #-16]
10005438:	e50b3008 	str	r3, [fp, #-8]

  pVab_in_pu->value[0] = obj->Vab_in.value[0];
1000543c:	e51b3008 	ldr	r3, [fp, #-8]
10005440:	e5932180 	ldr	r2, [r3, #384]	; 0x180
10005444:	e51b3014 	ldr	r3, [fp, #-20]
10005448:	e5832000 	str	r2, [r3]
  pVab_in_pu->value[1] = obj->Vab_in.value[1];
1000544c:	e51b3008 	ldr	r3, [fp, #-8]
10005450:	e5932184 	ldr	r2, [r3, #388]	; 0x184
10005454:	e51b3014 	ldr	r3, [fp, #-20]
10005458:	e5832004 	str	r2, [r3, #4]

  return;
1000545c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getVab_in_pu() function
10005460:	e24bd000 	sub	sp, fp, #0
10005464:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10005468:	e12fff1e 	bx	lr

1000546c <CTRL_getVab_out_pu>:


void CTRL_getVab_out_pu(CTRL_Handle handle,MATH_vec2 *pVab_out_pu)
{
1000546c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10005470:	e28db000 	add	fp, sp, #0
10005474:	e24dd014 	sub	sp, sp, #20
10005478:	e50b0010 	str	r0, [fp, #-16]
1000547c:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10005480:	e51b3010 	ldr	r3, [fp, #-16]
10005484:	e50b3008 	str	r3, [fp, #-8]

  pVab_out_pu->value[0] = obj->Vab_out.value[0];
10005488:	e51b3008 	ldr	r3, [fp, #-8]
1000548c:	e593218c 	ldr	r2, [r3, #396]	; 0x18c
10005490:	e51b3014 	ldr	r3, [fp, #-20]
10005494:	e5832000 	str	r2, [r3]
  pVab_out_pu->value[1] = obj->Vab_out.value[1];
10005498:	e51b3008 	ldr	r3, [fp, #-8]
1000549c:	e5932190 	ldr	r2, [r3, #400]	; 0x190
100054a0:	e51b3014 	ldr	r3, [fp, #-20]
100054a4:	e5832004 	str	r2, [r3, #4]

  return;
100054a8:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getVab_out_pu() function
100054ac:	e24bd000 	sub	sp, fp, #0
100054b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100054b4:	e12fff1e 	bx	lr

100054b8 <CTRL_getVdq_out_pu>:


void CTRL_getVdq_out_pu(CTRL_Handle handle,MATH_vec2 *pVdq_out_pu)
{
100054b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100054bc:	e28db000 	add	fp, sp, #0
100054c0:	e24dd014 	sub	sp, sp, #20
100054c4:	e50b0010 	str	r0, [fp, #-16]
100054c8:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100054cc:	e51b3010 	ldr	r3, [fp, #-16]
100054d0:	e50b3008 	str	r3, [fp, #-8]

  pVdq_out_pu->value[0] = obj->Vdq_out.value[0];
100054d4:	e51b3008 	ldr	r3, [fp, #-8]
100054d8:	e5932194 	ldr	r2, [r3, #404]	; 0x194
100054dc:	e51b3014 	ldr	r3, [fp, #-20]
100054e0:	e5832000 	str	r2, [r3]
  pVdq_out_pu->value[1] = obj->Vdq_out.value[1];
100054e4:	e51b3008 	ldr	r3, [fp, #-8]
100054e8:	e5932198 	ldr	r2, [r3, #408]	; 0x198
100054ec:	e51b3014 	ldr	r3, [fp, #-20]
100054f0:	e5832004 	str	r2, [r3, #4]

  return;
100054f4:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getVdq_out_pu() function
100054f8:	e24bd000 	sub	sp, fp, #0
100054fc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10005500:	e12fff1e 	bx	lr

10005504 <CTRL_getWaitTimes>:


void CTRL_getWaitTimes(CTRL_Handle handle,uint_least32_t *pWaitTimes)
{
10005504:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10005508:	e28db000 	add	fp, sp, #0
1000550c:	e24dd014 	sub	sp, sp, #20
10005510:	e50b0010 	str	r0, [fp, #-16]
10005514:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10005518:	e51b3010 	ldr	r3, [fp, #-16]
1000551c:	e50b300c 	str	r3, [fp, #-12]
  uint_least16_t stateCnt;

  for(stateCnt=0;stateCnt<CTRL_numStates;stateCnt++)
10005520:	e3a03000 	mov	r3, #0
10005524:	e14b30b6 	strh	r3, [fp, #-6]
10005528:	ea00000b 	b	1000555c <CTRL_getWaitTimes+0x58>
    {
      pWaitTimes[stateCnt] = obj->waitTimes[stateCnt];
1000552c:	e15b30b6 	ldrh	r3, [fp, #-6]
10005530:	e1a03103 	lsl	r3, r3, #2
10005534:	e51b2014 	ldr	r2, [fp, #-20]
10005538:	e0823003 	add	r3, r2, r3
1000553c:	e15b10b6 	ldrh	r1, [fp, #-6]
10005540:	e51b200c 	ldr	r2, [fp, #-12]
10005544:	e2811048 	add	r1, r1, #72	; 0x48
10005548:	e7922101 	ldr	r2, [r2, r1, lsl #2]
1000554c:	e5832000 	str	r2, [r3]
void CTRL_getWaitTimes(CTRL_Handle handle,uint_least32_t *pWaitTimes)
{
  CTRL_Obj *obj = (CTRL_Obj *)handle;
  uint_least16_t stateCnt;

  for(stateCnt=0;stateCnt<CTRL_numStates;stateCnt++)
10005550:	e15b30b6 	ldrh	r3, [fp, #-6]
10005554:	e2833001 	add	r3, r3, #1
10005558:	e14b30b6 	strh	r3, [fp, #-6]
1000555c:	e15b30b6 	ldrh	r3, [fp, #-6]
10005560:	e3530009 	cmp	r3, #9
10005564:	9afffff0 	bls	1000552c <CTRL_getWaitTimes+0x28>
    {
      pWaitTimes[stateCnt] = obj->waitTimes[stateCnt];
    }

  return;
10005568:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_getWaitTimes() function
1000556c:	e24bd000 	sub	sp, fp, #0
10005570:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10005574:	e12fff1e 	bx	lr

10005578 <CTRL_run>:

void CTRL_run(CTRL_Handle handle,HAL_Handle halHandle,
              const HAL_AdcData_t *pAdcData,
              HAL_PwmData_t *pPwmData,
							HAL_QepData_t *pQepData)
{
10005578:	e92d4800 	push	{fp, lr}
1000557c:	e28db004 	add	fp, sp, #4
10005580:	e24dd020 	sub	sp, sp, #32
10005584:	e50b0010 	str	r0, [fp, #-16]
10005588:	e50b1014 	str	r1, [fp, #-20]
1000558c:	e50b2018 	str	r2, [fp, #-24]
10005590:	e50b301c 	str	r3, [fp, #-28]
	uint_least16_t count_isr = CTRL_getCount_isr(handle);
10005594:	e51b0010 	ldr	r0, [fp, #-16]
10005598:	ebfff60c 	bl	10002dd0 <CTRL_getCount_isr>
1000559c:	e1a03000 	mov	r3, r0
100055a0:	e14b30b6 	strh	r3, [fp, #-6]
	uint_least16_t numIsrTicksPerCtrlTick = CTRL_getNumIsrTicksPerCtrlTick(handle);
100055a4:	e51b0010 	ldr	r0, [fp, #-16]
100055a8:	ebfff73f 	bl	100032ac <CTRL_getNumIsrTicksPerCtrlTick>
100055ac:	e1a03000 	mov	r3, r0
100055b0:	e14b30b8 	strh	r3, [fp, #-8]

	// if needed, run the controller
	if(count_isr >= numIsrTicksPerCtrlTick)
100055b4:	e15b20b6 	ldrh	r2, [fp, #-6]
100055b8:	e15b30b8 	ldrh	r3, [fp, #-8]
100055bc:	e1520003 	cmp	r2, r3
100055c0:	3a00006c 	bcc	10005778 <CTRL_run+0x200>
	{
		CTRL_State_e ctrlState = CTRL_getState(handle);
100055c4:	e51b0010 	ldr	r0, [fp, #-16]
100055c8:	ebfff777 	bl	100033ac <CTRL_getState>
100055cc:	e1a03000 	mov	r3, r0
100055d0:	e54b3009 	strb	r3, [fp, #-9]

		// reset the isr count
		CTRL_resetCounter_isr(handle);
100055d4:	e51b0010 	ldr	r0, [fp, #-16]
100055d8:	ebfff845 	bl	100036f4 <CTRL_resetCounter_isr>

		// increment the state counter
		//CTRL_incrCounter_state(handle);

		// increment the trajectory count
		CTRL_incrCounter_traj(handle);
100055dc:	e51b0010 	ldr	r0, [fp, #-16]
100055e0:	ebfff81e 	bl	10003660 <CTRL_incrCounter_traj>
		// run the appropriate controller
		if(ctrlState == CTRL_State_Error)
100055e4:	e55b3009 	ldrb	r3, [fp, #-9]
100055e8:	e3530000 	cmp	r3, #0
100055ec:	0a000060 	beq	10005774 <CTRL_run+0x1fc>
		{
			// run the Error controller
			
		}
		else if(ctrlState == CTRL_State_Idle)
100055f0:	e55b3009 	ldrb	r3, [fp, #-9]
100055f4:	e3530001 	cmp	r3, #1
100055f8:	1a000007 	bne	1000561c <CTRL_run+0xa4>
		{
			// run the Idle controller
			CTRL_runOffLine(handle,halHandle,pAdcData,pPwmData,pQepData);
100055fc:	e59b3004 	ldr	r3, [fp, #4]
10005600:	e58d3000 	str	r3, [sp]
10005604:	e51b0010 	ldr	r0, [fp, #-16]
10005608:	e51b1014 	ldr	r1, [fp, #-20]
1000560c:	e51b2018 	ldr	r2, [fp, #-24]
10005610:	e51b301c 	ldr	r3, [fp, #-28]
10005614:	ebfffbc0 	bl	1000451c <CTRL_runOffLine>
10005618:	ea000055 	b	10005774 <CTRL_run+0x1fc>
		}
		else if(ctrlState == CTRL_State_OffLine)
1000561c:	e55b3009 	ldrb	r3, [fp, #-9]
10005620:	e3530002 	cmp	r3, #2
10005624:	1a000007 	bne	10005648 <CTRL_run+0xd0>
		{
			// run the offline controller
			CTRL_runOffLine(handle,halHandle,pAdcData,pPwmData,pQepData);
10005628:	e59b3004 	ldr	r3, [fp, #4]
1000562c:	e58d3000 	str	r3, [sp]
10005630:	e51b0010 	ldr	r0, [fp, #-16]
10005634:	e51b1014 	ldr	r1, [fp, #-20]
10005638:	e51b2018 	ldr	r2, [fp, #-24]
1000563c:	e51b301c 	ldr	r3, [fp, #-28]
10005640:	ebfffbb5 	bl	1000451c <CTRL_runOffLine>
10005644:	ea00004a 	b	10005774 <CTRL_run+0x1fc>
		}
		else if(ctrlState == CTRL_State_InitDete)
10005648:	e55b3009 	ldrb	r3, [fp, #-9]
1000564c:	e3530004 	cmp	r3, #4
10005650:	1a000007 	bne	10005674 <CTRL_run+0xfc>
		{
			// run the InitDete controller
			CTRL_runInitDete_User(handle,halHandle,pAdcData,pPwmData,pQepData);
10005654:	e59b3004 	ldr	r3, [fp, #4]
10005658:	e58d3000 	str	r3, [sp]
1000565c:	e51b0010 	ldr	r0, [fp, #-16]
10005660:	e51b1014 	ldr	r1, [fp, #-20]
10005664:	e51b2018 	ldr	r2, [fp, #-24]
10005668:	e51b301c 	ldr	r3, [fp, #-28]
1000566c:	ebfffbd6 	bl	100045cc <CTRL_runInitDete_User>
10005670:	ea00003f 	b	10005774 <CTRL_run+0x1fc>
		}
		else if(ctrlState == CTRL_State_StaticStatorInitDete)
10005674:	e55b3009 	ldrb	r3, [fp, #-9]
10005678:	e3530005 	cmp	r3, #5
1000567c:	1a000007 	bne	100056a0 <CTRL_run+0x128>
		{
			// run the StaticStatorInitDete controller
			CTRL_runStaticStatorInitDete_User(handle,halHandle,pAdcData,pPwmData,pQepData);
10005680:	e59b3004 	ldr	r3, [fp, #4]
10005684:	e58d3000 	str	r3, [sp]
10005688:	e51b0010 	ldr	r0, [fp, #-16]
1000568c:	e51b1014 	ldr	r1, [fp, #-20]
10005690:	e51b2018 	ldr	r2, [fp, #-24]
10005694:	e51b301c 	ldr	r3, [fp, #-28]
10005698:	ebfffc2b 	bl	1000474c <CTRL_runStaticStatorInitDete_User>
1000569c:	ea000034 	b	10005774 <CTRL_run+0x1fc>
		}
		else if(ctrlState == CTRL_State_OpenLoop)
100056a0:	e55b3009 	ldrb	r3, [fp, #-9]
100056a4:	e3530006 	cmp	r3, #6
100056a8:	1a000009 	bne	100056d4 <CTRL_run+0x15c>
		{
			// increment the speed count
			CTRL_incrCounter_speed(handle);
100056ac:	e51b0010 	ldr	r0, [fp, #-16]
100056b0:	ebfff7c2 	bl	100035c0 <CTRL_incrCounter_speed>

			CTRL_runOpenLoop_User(handle,halHandle,pAdcData,pPwmData,pQepData);
100056b4:	e59b3004 	ldr	r3, [fp, #4]
100056b8:	e58d3000 	str	r3, [sp]
100056bc:	e51b0010 	ldr	r0, [fp, #-16]
100056c0:	e51b1014 	ldr	r1, [fp, #-20]
100056c4:	e51b2018 	ldr	r2, [fp, #-24]
100056c8:	e51b301c 	ldr	r3, [fp, #-28]
100056cc:	ebfffcf5 	bl	10004aa8 <CTRL_runOpenLoop_User>
100056d0:	ea000027 	b	10005774 <CTRL_run+0x1fc>
			//rt_kprintf("o");
		}
		else if(ctrlState == CTRL_State_OnLine || ctrlState == CTRL_State_CurrentCloseLoop || ctrlState == CTRL_State_SpeedCloseLoop )
100056d4:	e55b3009 	ldrb	r3, [fp, #-9]
100056d8:	e3530007 	cmp	r3, #7
100056dc:	0a000005 	beq	100056f8 <CTRL_run+0x180>
100056e0:	e55b3009 	ldrb	r3, [fp, #-9]
100056e4:	e3530008 	cmp	r3, #8
100056e8:	0a000002 	beq	100056f8 <CTRL_run+0x180>
100056ec:	e55b3009 	ldrb	r3, [fp, #-9]
100056f0:	e3530009 	cmp	r3, #9
100056f4:	1a00001e 	bne	10005774 <CTRL_run+0x1fc>
		{
			//CTRL_Obj *obj = (CTRL_Obj *)handle;

			// increment the current count
			CTRL_incrCounter_current(handle);
100056f8:	e51b0010 	ldr	r0, [fp, #-16]
100056fc:	ebfff783 	bl	10003510 <CTRL_incrCounter_current>

			// increment the speed count
			CTRL_incrCounter_speed(handle);
10005700:	e51b0010 	ldr	r0, [fp, #-16]
10005704:	ebfff7ad 	bl	100035c0 <CTRL_incrCounter_speed>

			if( ctrlState == CTRL_State_CurrentCloseLoop )
10005708:	e55b3009 	ldrb	r3, [fp, #-9]
1000570c:	e3530008 	cmp	r3, #8
10005710:	1a000006 	bne	10005730 <CTRL_run+0x1b8>
			{
				CTRL_setFlag_enableCurrentCtrl(handle,true);
10005714:	e51b0010 	ldr	r0, [fp, #-16]
10005718:	e3a01001 	mov	r1, #1
1000571c:	ebfff884 	bl	10003934 <CTRL_setFlag_enableCurrentCtrl>
				CTRL_setFlag_enableSpeedCtrl(handle,false);
10005720:	e51b0010 	ldr	r0, [fp, #-16]
10005724:	e3a01000 	mov	r1, #0
10005728:	ebfff8bd 	bl	10003a24 <CTRL_setFlag_enableSpeedCtrl>
1000572c:	ea000008 	b	10005754 <CTRL_run+0x1dc>
			}
			else if( ctrlState == CTRL_State_SpeedCloseLoop )
10005730:	e55b3009 	ldrb	r3, [fp, #-9]
10005734:	e3530009 	cmp	r3, #9
10005738:	1a000005 	bne	10005754 <CTRL_run+0x1dc>
			{
				CTRL_setFlag_enableCurrentCtrl(handle,true);
1000573c:	e51b0010 	ldr	r0, [fp, #-16]
10005740:	e3a01001 	mov	r1, #1
10005744:	ebfff87a 	bl	10003934 <CTRL_setFlag_enableCurrentCtrl>
				CTRL_setFlag_enableSpeedCtrl(handle,true);
10005748:	e51b0010 	ldr	r0, [fp, #-16]
1000574c:	e3a01001 	mov	r1, #1
10005750:	ebfff8b3 	bl	10003a24 <CTRL_setFlag_enableSpeedCtrl>
			}
			//if(EST_getState(obj->estHandle) >= EST_State_MotorIdentified)
			//{
				// run the online controller
				CTRL_runOnLine_User(handle,halHandle,pAdcData,pPwmData,pQepData);
10005754:	e59b3004 	ldr	r3, [fp, #4]
10005758:	e58d3000 	str	r3, [sp]
1000575c:	e51b0010 	ldr	r0, [fp, #-16]
10005760:	e51b1014 	ldr	r1, [fp, #-20]
10005764:	e51b2018 	ldr	r2, [fp, #-24]
10005768:	e51b301c 	ldr	r3, [fp, #-28]
1000576c:	ebfffd50 	bl	10004cb4 <CTRL_runOnLine_User>
10005770:	ea000002 	b	10005780 <CTRL_run+0x208>
10005774:	ea000001 	b	10005780 <CTRL_run+0x208>

	}
	else
	{
		// increment the isr count
		CTRL_incrCounter_isr(handle);
10005778:	e51b0010 	ldr	r0, [fp, #-16]
1000577c:	ebfff778 	bl	10003564 <CTRL_incrCounter_isr>
	}

  return;
10005780:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_run() function
10005784:	e24bd004 	sub	sp, fp, #4
10005788:	e8bd8800 	pop	{fp, pc}

1000578c <CTRL_setGains>:


void CTRL_setGains(CTRL_Handle handle,const CTRL_Type_e ctrlType,
                   const float_t Kp,const float_t Ki,const float_t Kd)
{
1000578c:	e92d4800 	push	{fp, lr}
10005790:	e28db004 	add	fp, sp, #4
10005794:	e24dd018 	sub	sp, sp, #24
10005798:	e50b0008 	str	r0, [fp, #-8]
1000579c:	e1a03001 	mov	r3, r1
100057a0:	ed0b0a04 	vstr	s0, [fp, #-16]
100057a4:	ed4b0a05 	vstr	s1, [fp, #-20]	; 0xffffffec
100057a8:	ed0b1a06 	vstr	s2, [fp, #-24]	; 0xffffffe8
100057ac:	e54b3009 	strb	r3, [fp, #-9]

  CTRL_setKp(handle,ctrlType,Kp);
100057b0:	e55b3009 	ldrb	r3, [fp, #-9]
100057b4:	e51b0008 	ldr	r0, [fp, #-8]
100057b8:	e1a01003 	mov	r1, r3
100057bc:	ed1b0a04 	vldr	s0, [fp, #-16]
100057c0:	ebfff951 	bl	10003d0c <CTRL_setKp>
  CTRL_setKi(handle,ctrlType,Ki);
100057c4:	e55b3009 	ldrb	r3, [fp, #-9]
100057c8:	e51b0008 	ldr	r0, [fp, #-8]
100057cc:	e1a01003 	mov	r1, r3
100057d0:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
100057d4:	ebfff92b 	bl	10003c88 <CTRL_setKi>
  CTRL_setKd(handle,ctrlType,Kd);
100057d8:	e55b3009 	ldrb	r3, [fp, #-9]
100057dc:	e51b0008 	ldr	r0, [fp, #-8]
100057e0:	e1a01003 	mov	r1, r3
100057e4:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
100057e8:	ebfff905 	bl	10003c04 <CTRL_setKd>

  return;    
100057ec:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setGains() function
100057f0:	e24bd004 	sub	sp, fp, #4
100057f4:	e8bd8800 	pop	{fp, pc}

100057f8 <CTRL_setMagCurrent_pu>:


void CTRL_setMagCurrent_pu(CTRL_Handle handle,const float_t magCurrent_pu)
{
100057f8:	e92d4800 	push	{fp, lr}
100057fc:	e28db004 	add	fp, sp, #4
10005800:	e24dd008 	sub	sp, sp, #8
10005804:	e50b0008 	str	r0, [fp, #-8]
10005808:	ed0b0a03 	vstr	s0, [fp, #-12]

  CTRL_setIdRated_pu(handle,magCurrent_pu);
1000580c:	e51b0008 	ldr	r0, [fp, #-8]
10005810:	ed1b0a03 	vldr	s0, [fp, #-12]
10005814:	ebfff8ec 	bl	10003bcc <CTRL_setIdRated_pu>

  return;    
10005818:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setMagCurrent_pu() function
1000581c:	e24bd004 	sub	sp, fp, #4
10005820:	e8bd8800 	pop	{fp, pc}

10005824 <CTRL_setMaximumSpeed_pu>:


void CTRL_setMaximumSpeed_pu(CTRL_Handle handle,const float_t maxSpeed_pu)
{
10005824:	e92d4800 	push	{fp, lr}
10005828:	e28db004 	add	fp, sp, #4
1000582c:	e24dd008 	sub	sp, sp, #8
10005830:	e50b0008 	str	r0, [fp, #-8]
10005834:	ed0b0a03 	vstr	s0, [fp, #-12]

  CTRL_setSpd_max_pu(handle,maxSpeed_pu);
10005838:	e51b0008 	ldr	r0, [fp, #-8]
1000583c:	ed1b0a03 	vldr	s0, [fp, #-12]
10005840:	ebfffa04 	bl	10004058 <CTRL_setSpd_max_pu>

  return;    
10005844:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setMaximumSpeed_pu() function
10005848:	e24bd004 	sub	sp, fp, #4
1000584c:	e8bd8800 	pop	{fp, pc}

10005850 <CTRL_init>:


CTRL_Handle CTRL_init(void *pMemory, const size_t numBytes)
{
10005850:	e92d4800 	push	{fp, lr}
10005854:	e28db004 	add	fp, sp, #4
10005858:	e24dd010 	sub	sp, sp, #16
1000585c:	e50b0010 	str	r0, [fp, #-16]
10005860:	e50b1014 	str	r1, [fp, #-20]
	CTRL_Handle handle;
	CTRL_Obj *obj;


	if (numBytes < sizeof(CTRL_Obj))
10005864:	e51b3014 	ldr	r3, [fp, #-20]
10005868:	e3530d0d 	cmp	r3, #832	; 0x340
1000586c:	2a000001 	bcs	10005878 <CTRL_init+0x28>
		return((CTRL_Handle)NULL);
10005870:	e3a03000 	mov	r3, #0
10005874:	ea000084 	b	10005a8c <CTRL_init+0x23c>


	// assign the handle
	handle = (CTRL_Handle)pMemory;
10005878:	e51b3010 	ldr	r3, [fp, #-16]
1000587c:	e50b3008 	str	r3, [fp, #-8]


	// assign the object
	obj = (CTRL_Obj *)handle;
10005880:	e51b3008 	ldr	r3, [fp, #-8]
10005884:	e50b300c 	str	r3, [fp, #-12]


	obj->clarkeHandle_I = CLARKE_init(&obj->clarke_I, sizeof(obj->clarke_I));
10005888:	e51b300c 	ldr	r3, [fp, #-12]
1000588c:	e2833010 	add	r3, r3, #16
10005890:	e1a00003 	mov	r0, r3
10005894:	e3a0100c 	mov	r1, #12
10005898:	ebfff070 	bl	10001a60 <CLARKE_init>
1000589c:	e1a02000 	mov	r2, r0
100058a0:	e51b300c 	ldr	r3, [fp, #-12]
100058a4:	e583200c 	str	r2, [r3, #12]
	obj->clarkeHandle_V = CLARKE_init(&obj->clarke_V, sizeof(obj->clarke_V));
100058a8:	e51b300c 	ldr	r3, [fp, #-12]
100058ac:	e2833020 	add	r3, r3, #32
100058b0:	e1a00003 	mov	r0, r3
100058b4:	e3a0100c 	mov	r1, #12
100058b8:	ebfff068 	bl	10001a60 <CLARKE_init>
100058bc:	e1a02000 	mov	r2, r0
100058c0:	e51b300c 	ldr	r3, [fp, #-12]
100058c4:	e583201c 	str	r2, [r3, #28]


	obj->parkHandle = PARK_init(&obj->park, sizeof(obj->park));
100058c8:	e51b300c 	ldr	r3, [fp, #-12]
100058cc:	e2833034 	add	r3, r3, #52	; 0x34
100058d0:	e1a00003 	mov	r0, r3
100058d4:	e3a01008 	mov	r1, #8
100058d8:	eb000814 	bl	10007930 <PARK_init>
100058dc:	e1a02000 	mov	r2, r0
100058e0:	e51b300c 	ldr	r3, [fp, #-12]
100058e4:	e5832030 	str	r2, [r3, #48]	; 0x30


	// initialize the Id PI controller module
	obj->pidHandle_Id = PID_init(&obj->pid_Id, sizeof(obj->pid_Id));
100058e8:	e51b300c 	ldr	r3, [fp, #-12]
100058ec:	e2833040 	add	r3, r3, #64	; 0x40
100058f0:	e1a00003 	mov	r0, r3
100058f4:	e3a01020 	mov	r1, #32
100058f8:	eb000847 	bl	10007a1c <PID_init>
100058fc:	e1a02000 	mov	r2, r0
10005900:	e51b300c 	ldr	r3, [fp, #-12]
10005904:	e583203c 	str	r2, [r3, #60]	; 0x3c


	// initialize the Iq PI controller module
	obj->pidHandle_Iq = PID_init(&obj->pid_Iq, sizeof(obj->pid_Iq));
10005908:	e51b300c 	ldr	r3, [fp, #-12]
1000590c:	e2833064 	add	r3, r3, #100	; 0x64
10005910:	e1a00003 	mov	r0, r3
10005914:	e3a01020 	mov	r1, #32
10005918:	eb00083f 	bl	10007a1c <PID_init>
1000591c:	e1a02000 	mov	r2, r0
10005920:	e51b300c 	ldr	r3, [fp, #-12]
10005924:	e5832060 	str	r2, [r3, #96]	; 0x60


	// initialize the speed PI controller module
	obj->pidHandle_spd = PID_init(&obj->pid_spd, sizeof(obj->pid_spd));
10005928:	e51b300c 	ldr	r3, [fp, #-12]
1000592c:	e2833088 	add	r3, r3, #136	; 0x88
10005930:	e1a00003 	mov	r0, r3
10005934:	e3a01020 	mov	r1, #32
10005938:	eb000837 	bl	10007a1c <PID_init>
1000593c:	e1a02000 	mov	r2, r0
10005940:	e51b300c 	ldr	r3, [fp, #-12]
10005944:	e5832084 	str	r2, [r3, #132]	; 0x84

	
	obj->iparkHandle = IPARK_init(&obj->ipark, sizeof(obj->ipark));
10005948:	e51b300c 	ldr	r3, [fp, #-12]
1000594c:	e28330ac 	add	r3, r3, #172	; 0xac
10005950:	e1a00003 	mov	r0, r3
10005954:	e3a01008 	mov	r1, #8
10005958:	eb000778 	bl	10007740 <IPARK_init>
1000595c:	e1a02000 	mov	r2, r0
10005960:	e51b300c 	ldr	r3, [fp, #-12]
10005964:	e58320a8 	str	r2, [r3, #168]	; 0xa8


	obj->svgenHandle = SVGEN_init(&obj->svgen, sizeof(obj->svgen)); 
10005968:	e51b300c 	ldr	r3, [fp, #-12]
1000596c:	e28330b8 	add	r3, r3, #184	; 0xb8
10005970:	e1a00003 	mov	r0, r3
10005974:	e3a01004 	mov	r1, #4
10005978:	eb00088c 	bl	10007bb0 <SVGEN_init>
1000597c:	e1a02000 	mov	r2, r0
10005980:	e51b300c 	ldr	r3, [fp, #-12]
10005984:	e58320b4 	str	r2, [r3, #180]	; 0xb4


	obj->trajHandle_Id = TRAJ_init(&obj->traj_Id, sizeof(obj->traj_Id));
10005988:	e51b300c 	ldr	r3, [fp, #-12]
1000598c:	e28330c0 	add	r3, r3, #192	; 0xc0
10005990:	e1a00003 	mov	r0, r3
10005994:	e3a01014 	mov	r1, #20
10005998:	eb00089d 	bl	10007c14 <TRAJ_init>
1000599c:	e1a02000 	mov	r2, r0
100059a0:	e51b300c 	ldr	r3, [fp, #-12]
100059a4:	e58320bc 	str	r2, [r3, #188]	; 0xbc


	obj->trajHandle_spd = TRAJ_init(&obj->traj_spd, sizeof(obj->traj_spd));
100059a8:	e51b300c 	ldr	r3, [fp, #-12]
100059ac:	e28330d8 	add	r3, r3, #216	; 0xd8
100059b0:	e1a00003 	mov	r0, r3
100059b4:	e3a01014 	mov	r1, #20
100059b8:	eb000895 	bl	10007c14 <TRAJ_init>
100059bc:	e1a02000 	mov	r2, r0
100059c0:	e51b300c 	ldr	r3, [fp, #-12]
100059c4:	e58320d4 	str	r2, [r3, #212]	; 0xd4


	obj->trajHandle_spdMax = TRAJ_init(&obj->traj_spdMax, sizeof(obj->traj_spdMax));
100059c8:	e51b300c 	ldr	r3, [fp, #-12]
100059cc:	e28330f0 	add	r3, r3, #240	; 0xf0
100059d0:	e1a00003 	mov	r0, r3
100059d4:	e3a01014 	mov	r1, #20
100059d8:	eb00088d 	bl	10007c14 <TRAJ_init>
100059dc:	e1a02000 	mov	r2, r0
100059e0:	e51b300c 	ldr	r3, [fp, #-12]
100059e4:	e58320ec 	str	r2, [r3, #236]	; 0xec


	obj->rmpcntl_handle = RMP_CNTL_Init(&obj->rmpcntl, sizeof(obj->rmpcntl));
100059e8:	e51b300c 	ldr	r3, [fp, #-12]
100059ec:	e2833f8a 	add	r3, r3, #552	; 0x228
100059f0:	e1a00003 	mov	r0, r3
100059f4:	e3a0101c 	mov	r1, #28
100059f8:	eb000844 	bl	10007b10 <RMP_CNTL_Init>
100059fc:	e1a02000 	mov	r2, r0
10005a00:	e51b300c 	ldr	r3, [fp, #-12]
10005a04:	e5832224 	str	r2, [r3, #548]	; 0x224


	obj->rampgen_handle = RAMPGEN_Init(&obj->rampgen, sizeof(obj->rampgen));
10005a08:	e51b300c 	ldr	r3, [fp, #-12]
10005a0c:	e2833f92 	add	r3, r3, #584	; 0x248
10005a10:	e1a00003 	mov	r0, r3
10005a14:	e3a01018 	mov	r1, #24
10005a18:	eb000819 	bl	10007a84 <RAMPGEN_Init>
10005a1c:	e1a02000 	mov	r2, r0
10005a20:	e51b300c 	ldr	r3, [fp, #-12]
10005a24:	e5832244 	str	r2, [r3, #580]	; 0x244


	obj->data_rtxd_handle = DATA_RTXD_Init(&obj->data_rtxd, sizeof(obj->data_rtxd));
10005a28:	e51b300c 	ldr	r3, [fp, #-12]
10005a2c:	e2833f99 	add	r3, r3, #612	; 0x264
10005a30:	e1a00003 	mov	r0, r3
10005a34:	e3a0101e 	mov	r1, #30
10005a38:	eb0003c7 	bl	1000695c <DATA_RTXD_Init>
10005a3c:	e1a02000 	mov	r2, r0
10005a40:	e51b300c 	ldr	r3, [fp, #-12]
10005a44:	e5832260 	str	r2, [r3, #608]	; 0x260


	obj->InitPosDet_handle = INITPOSDET_Init(&obj->InitPosDet, sizeof(obj->InitPosDet));
10005a48:	e51b300c 	ldr	r3, [fp, #-12]
10005a4c:	e2833fa2 	add	r3, r3, #648	; 0x288
10005a50:	e1a00003 	mov	r0, r3
10005a54:	e3a01060 	mov	r1, #96	; 0x60
10005a58:	ebffea01 	bl	10000264 <INITPOSDET_Init>
10005a5c:	e1a02000 	mov	r2, r0
10005a60:	e51b300c 	ldr	r3, [fp, #-12]
10005a64:	e5832284 	str	r2, [r3, #644]	; 0x284


	obj->Speed_handle = Speed_Init(&obj->Speed, sizeof(obj->Speed));
10005a68:	e51b300c 	ldr	r3, [fp, #-12]
10005a6c:	e2833fbb 	add	r3, r3, #748	; 0x2ec
10005a70:	e1a00003 	mov	r0, r3
10005a74:	e3a01028 	mov	r1, #40	; 0x28
10005a78:	ebffef6d 	bl	10001834 <Speed_Init>
10005a7c:	e1a02000 	mov	r2, r0
10005a80:	e51b300c 	ldr	r3, [fp, #-12]
10005a84:	e58322e8 	str	r2, [r3, #744]	; 0x2e8


	return(handle);
10005a88:	e51b3008 	ldr	r3, [fp, #-8]
} // end of CTRL_init() function
10005a8c:	e1a00003 	mov	r0, r3
10005a90:	e24bd004 	sub	sp, fp, #4
10005a94:	e8bd8800 	pop	{fp, pc}

10005a98 <CTRL_setParams>:


void CTRL_setParams(CTRL_Handle handle,USER_Params *pUserParams)
{
10005a98:	e92d4810 	push	{r4, fp, lr}
10005a9c:	e28db008 	add	fp, sp, #8
10005aa0:	e24dd05c 	sub	sp, sp, #92	; 0x5c
10005aa4:	e50b0060 	str	r0, [fp, #-96]	; 0x60
10005aa8:	e50b1064 	str	r1, [fp, #-100]	; 0x64
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10005aac:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
10005ab0:	e50b3010 	str	r3, [fp, #-16]

  float_t Kp,Ki,Kd;
  float_t outMin,outMax;
  float_t maxModulation;

  MATH_vec2 Iab_out_pu = {(0.0f),(0.0f)};
10005ab4:	e3a03000 	mov	r3, #0
10005ab8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
10005abc:	e3a03000 	mov	r3, #0
10005ac0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  MATH_vec2 Idq_out_pu = {(0.0f),(0.0f)};
10005ac4:	e3a03000 	mov	r3, #0
10005ac8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
10005acc:	e3a03000 	mov	r3, #0
10005ad0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  MATH_vec2 Idq_ref_pu = {(0.0f),(0.8f)};
10005ad4:	e3a03000 	mov	r3, #0
10005ad8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
10005adc:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10005ae0:	e3433f4c 	movt	r3, #16204	; 0x3f4c
10005ae4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
  MATH_vec2 Vab_in_pu  = {(0.0f),(0.0f)};
10005ae8:	e3a03000 	mov	r3, #0
10005aec:	e50b3048 	str	r3, [fp, #-72]	; 0x48
10005af0:	e3a03000 	mov	r3, #0
10005af4:	e50b3044 	str	r3, [fp, #-68]	; 0x44
  MATH_vec2 Vab_out_pu = {(0.0f),(0.0f)};
10005af8:	e3a03000 	mov	r3, #0
10005afc:	e50b3050 	str	r3, [fp, #-80]	; 0x50
10005b00:	e3a03000 	mov	r3, #0
10005b04:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
  MATH_vec2 Vdq_out_pu = {(0.0f),(0.0f)};
10005b08:	e3a03000 	mov	r3, #0
10005b0c:	e50b3058 	str	r3, [fp, #-88]	; 0x58
10005b10:	e3a03000 	mov	r3, #0
10005b14:	e50b3054 	str	r3, [fp, #-84]	; 0x54


  // assign the motor type
  CTRL_setMotorParams(handle,pUserParams->motor_type,
10005b18:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b1c:	e5d31064 	ldrb	r1, [r3, #100]	; 0x64
10005b20:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b24:	e1d326b6 	ldrh	r2, [r3, #102]	; 0x66
10005b28:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b2c:	edd35a1a 	vldr	s11, [r3, #104]	; 0x68
10005b30:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b34:	ed936a1d 	vldr	s12, [r3, #116]	; 0x74
10005b38:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b3c:	edd36a1e 	vldr	s13, [r3, #120]	; 0x78
10005b40:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b44:	ed937a1b 	vldr	s14, [r3, #108]	; 0x6c
10005b48:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b4c:	edd37a1c 	vldr	s15, [r3, #112]	; 0x70
10005b50:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005b54:	eeb00a65 	vmov.f32	s0, s11
10005b58:	eef00a46 	vmov.f32	s1, s12
10005b5c:	eeb01a66 	vmov.f32	s2, s13
10005b60:	eef01a47 	vmov.f32	s3, s14
10005b64:	eeb02a67 	vmov.f32	s4, s15
10005b68:	ebfff8a4 	bl	10003e00 <CTRL_setMotorParams>
                      pUserParams->motor_Rr,
                      pUserParams->motor_Rs);


  // assign other controller parameters
  CTRL_setNumIsrTicksPerCtrlTick(handle,pUserParams->numIsrTicksPerCtrlTick);
10005b6c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b70:	e1d330bc 	ldrh	r3, [r3, #12]
10005b74:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005b78:	e1a01003 	mov	r1, r3
10005b7c:	ebfff8fb 	bl	10003f70 <CTRL_setNumIsrTicksPerCtrlTick>
  CTRL_setNumCtrlTicksPerCurrentTick(handle,pUserParams->numCtrlTicksPerCurrentTick);
10005b80:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b84:	e1d330be 	ldrh	r3, [r3, #14]
10005b88:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005b8c:	e1a01003 	mov	r1, r3
10005b90:	ebfff8c4 	bl	10003ea8 <CTRL_setNumCtrlTicksPerCurrentTick>
  CTRL_setNumCtrlTicksPerSpeedTick(handle,pUserParams->numCtrlTicksPerSpeedTick);
10005b94:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005b98:	e1d331b2 	ldrh	r3, [r3, #18]
10005b9c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005ba0:	e1a01003 	mov	r1, r3
10005ba4:	ebfff8d0 	bl	10003eec <CTRL_setNumCtrlTicksPerSpeedTick>
  CTRL_setNumCtrlTicksPerTrajTick(handle,pUserParams->numCtrlTicksPerTrajTick);
10005ba8:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005bac:	e1d331b4 	ldrh	r3, [r3, #20]
10005bb0:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005bb4:	e1a01003 	mov	r1, r3
10005bb8:	ebfff8db 	bl	10003f2c <CTRL_setNumCtrlTicksPerTrajTick>

  CTRL_setCtrlFreq_Hz(handle,pUserParams->ctrlFreq_Hz);
10005bbc:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005bc0:	e5933150 	ldr	r3, [r3, #336]	; 0x150
10005bc4:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005bc8:	e1a01003 	mov	r1, r3
10005bcc:	ebfff716 	bl	1000382c <CTRL_setCtrlFreq_Hz>
  CTRL_setTrajFreq_Hz(handle,pUserParams->trajFreq_Hz);
10005bd0:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005bd4:	edd37a57 	vldr	s15, [r3, #348]	; 0x15c
10005bd8:	eefc7ae7 	vcvt.u32.f32	s15, s15
10005bdc:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005be0:	ee171a90 	vmov	r1, s15
10005be4:	ebfff966 	bl	10004184 <CTRL_setTrajFreq_Hz>
  CTRL_setTrajPeriod_sec(handle,(1.0/pUserParams->trajFreq_Hz));
10005be8:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005bec:	edd37a57 	vldr	s15, [r3, #348]	; 0x15c
10005bf0:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10005bf4:	eec77a27 	vdiv.f32	s15, s14, s15
10005bf8:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005bfc:	eeb00a67 	vmov.f32	s0, s15
10005c00:	ebfff96d 	bl	100041bc <CTRL_setTrajPeriod_sec>

  CTRL_setCtrlPeriod_sec(handle,pUserParams->ctrlPeriod_sec);
10005c04:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005c08:	edd37a58 	vldr	s15, [r3, #352]	; 0x160
10005c0c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005c10:	eeb00a67 	vmov.f32	s0, s15
10005c14:	ebfff712 	bl	10003864 <CTRL_setCtrlPeriod_sec>

  CTRL_setMaxVsMag_pu(handle,(pUserParams->maxVsMag_pu));
10005c18:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005c1c:	edd37a17 	vldr	s15, [r3, #92]	; 0x5c
10005c20:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005c24:	eeb00a67 	vmov.f32	s0, s15
10005c28:	ebfff866 	bl	10003dc8 <CTRL_setMaxVsMag_pu>

  CTRL_setIab_in_pu(handle,&Iab_out_pu);
10005c2c:	e24b3030 	sub	r3, fp, #48	; 0x30
10005c30:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005c34:	e1a01003 	mov	r1, r3
10005c38:	ebfff797 	bl	10003a9c <CTRL_setIab_in_pu>
  CTRL_setIdq_in_pu(handle,&Idq_out_pu);
10005c3c:	e24b3038 	sub	r3, fp, #56	; 0x38
10005c40:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005c44:	e1a01003 	mov	r1, r3
10005c48:	ebfff7a6 	bl	10003ae8 <CTRL_setIdq_in_pu>
  CTRL_setIdq_ref_pu(handle,&Idq_ref_pu);
10005c4c:	e24b3040 	sub	r3, fp, #64	; 0x40
10005c50:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005c54:	e1a01003 	mov	r1, r3
10005c58:	ebfff7c8 	bl	10003b80 <CTRL_setIdq_ref_pu>

  CTRL_setIdRated_pu(handle,(pUserParams->IdRated/pUserParams->iqFullScaleCurrent_A));
10005c5c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005c60:	ed937a24 	vldr	s14, [r3, #144]	; 0x90
10005c64:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005c68:	edd37a00 	vldr	s15, [r3]
10005c6c:	eec77a27 	vdiv.f32	s15, s14, s15
10005c70:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005c74:	eeb00a67 	vmov.f32	s0, s15
10005c78:	ebfff7d3 	bl	10003bcc <CTRL_setIdRated_pu>

  CTRL_setVab_in_pu(handle,&Vab_in_pu);
10005c7c:	e24b3048 	sub	r3, fp, #72	; 0x48
10005c80:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005c84:	e1a01003 	mov	r1, r3
10005c88:	ebfff96e 	bl	10004248 <CTRL_setVab_in_pu>
  CTRL_setVab_out_pu(handle,&Vab_out_pu);
10005c8c:	e24b3050 	sub	r3, fp, #80	; 0x50
10005c90:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005c94:	e1a01003 	mov	r1, r3
10005c98:	ebfff97d 	bl	10004294 <CTRL_setVab_out_pu>
  CTRL_setVdq_out_pu(handle,&Vdq_out_pu);
10005c9c:	e24b3058 	sub	r3, fp, #88	; 0x58
10005ca0:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005ca4:	e1a01003 	mov	r1, r3
10005ca8:	ebfff99f 	bl	1000432c <CTRL_setVdq_out_pu>

  CTRL_setSpd_out_pu(handle,(0.0f));
10005cac:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005cb0:	ed9f0afd 	vldr	s0, [pc, #1012]	; 100060ac <CTRL_setParams+0x614>
10005cb4:	ebfff8f5 	bl	10004090 <CTRL_setSpd_out_pu>

  CTRL_setRhf(handle,0.0f);
10005cb8:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005cbc:	ed9f0afa 	vldr	s0, [pc, #1000]	; 100060ac <CTRL_setParams+0x614>
10005cc0:	ebfff8ba 	bl	10003fb0 <CTRL_setRhf>
  CTRL_setLhf(handle,0.0f);
10005cc4:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005cc8:	ed9f0af7 	vldr	s0, [pc, #988]	; 100060ac <CTRL_setParams+0x614>
10005ccc:	ebfff82f 	bl	10003d90 <CTRL_setLhf>
  CTRL_setRoverL(handle,0.0f);
10005cd0:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005cd4:	ed9f0af4 	vldr	s0, [pc, #976]	; 100060ac <CTRL_setParams+0x614>
10005cd8:	ebfff8c2 	bl	10003fe8 <CTRL_setRoverL>


  // reset the counters
  CTRL_resetCounter_current(handle);
10005cdc:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005ce0:	ebfff675 	bl	100036bc <CTRL_resetCounter_current>
  CTRL_resetCounter_isr(handle);
10005ce4:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005ce8:	ebfff681 	bl	100036f4 <CTRL_resetCounter_isr>
  CTRL_resetCounter_speed(handle);
10005cec:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005cf0:	ebfff68e 	bl	10003730 <CTRL_resetCounter_speed>
  CTRL_resetCounter_state(handle);
10005cf4:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005cf8:	ebfff69a 	bl	10003768 <CTRL_resetCounter_state>
  CTRL_resetCounter_traj(handle);
10005cfc:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d00:	ebfff6a5 	bl	1000379c <CTRL_resetCounter_traj>


  // set the wait times for each state
  CTRL_setWaitTimes(handle,&pUserParams->ctrlWaitTime[0]);
10005d04:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005d08:	e28330a4 	add	r3, r3, #164	; 0xa4
10005d0c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d10:	e1a01003 	mov	r1, r3
10005d14:	eb000221 	bl	100065a0 <CTRL_setWaitTimes>


  // set flags
  CTRL_setFlag_enablePowerWarp(handle,false);
10005d18:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d1c:	e3a01000 	mov	r1, #0
10005d20:	ebfff721 	bl	100039ac <CTRL_setFlag_enablePowerWarp>
  CTRL_setFlag_enableCtrl(handle,false);
10005d24:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d28:	e3a01000 	mov	r1, #0
10005d2c:	ebfff6f1 	bl	100038f8 <CTRL_setFlag_enableCtrl>
  CTRL_setFlag_enableOffset(handle,true);
10005d30:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d34:	e3a01001 	mov	r1, #1
10005d38:	ebfff72a 	bl	100039e8 <CTRL_setFlag_enableOffset>
  CTRL_setFlag_enableSpeedCtrl(handle,false);
10005d3c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d40:	e3a01000 	mov	r1, #0
10005d44:	ebfff736 	bl	10003a24 <CTRL_setFlag_enableSpeedCtrl>
  CTRL_setFlag_enableCurrentCtrl(handle,false);
10005d48:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d4c:	e3a01000 	mov	r1, #0
10005d50:	ebfff6f7 	bl	10003934 <CTRL_setFlag_enableCurrentCtrl>
  CTRL_setFlag_enableUserMotorParams(handle,false);
10005d54:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d58:	e3a01000 	mov	r1, #0
10005d5c:	ebfff73f 	bl	10003a60 <CTRL_setFlag_enableUserMotorParams>
  CTRL_setFlag_enableDcBusComp(handle,true);
10005d60:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d64:	e3a01001 	mov	r1, #1
10005d68:	ebfff700 	bl	10003970 <CTRL_setFlag_enableDcBusComp>


  // initialize the controller error code
  CTRL_setErrorCode(handle,CTRL_ErrorCode_NoError);
10005d6c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d70:	e3a01000 	mov	r1, #0
10005d74:	ebfff6c8 	bl	1000389c <CTRL_setErrorCode>


  // set the default controller state
  CTRL_setState(handle,CTRL_State_Idle);
10005d78:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d7c:	e3a01001 	mov	r1, #1
10005d80:	ebfff8ec 	bl	10004138 <CTRL_setState>


  // set the number of current sensors
  CTRL_setupClarke_I(handle,pUserParams->numCurrentSensors);
10005d84:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10005d88:	e5d33016 	ldrb	r3, [r3, #22]
10005d8c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005d90:	e1a01003 	mov	r1, r3
10005d94:	eb000167 	bl	10006338 <CTRL_setupClarke_I>
  // set the number of voltage sensors
  //CTRL_setupClarke_V(handle,pUserParams->numVoltageSensors);


  // set the default Id PID controller parameters
  Kp = 2.0f;//(0.1f);
10005d98:	e3a03101 	mov	r3, #1073741824	; 0x40000000
10005d9c:	e50b3014 	str	r3, [fp, #-20]
  Ki = 0.2f;//(pUserParams->ctrlPeriod_sec/0.004f);
10005da0:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10005da4:	e3433e4c 	movt	r3, #15948	; 0x3e4c
10005da8:	e50b3018 	str	r3, [fp, #-24]
  Kd = (0.0f);
10005dac:	e3a03000 	mov	r3, #0
10005db0:	e50b301c 	str	r3, [fp, #-28]
  outMin = (-0.95f);
10005db4:	e3033333 	movw	r3, #13107	; 0x3333
10005db8:	e34b3f73 	movt	r3, #49011	; 0xbf73
10005dbc:	e50b3020 	str	r3, [fp, #-32]
  outMax = (0.95f);
10005dc0:	e3033333 	movw	r3, #13107	; 0x3333
10005dc4:	e3433f73 	movt	r3, #16243	; 0x3f73
10005dc8:	e50b3024 	str	r3, [fp, #-36]	; 0x24

  PID_setGains(obj->pidHandle_Id,Kp,Ki,Kd);
10005dcc:	e51b3010 	ldr	r3, [fp, #-16]
10005dd0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10005dd4:	e1a00003 	mov	r0, r3
10005dd8:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10005ddc:	ed5b0a06 	vldr	s1, [fp, #-24]	; 0xffffffe8
10005de0:	ed1b1a07 	vldr	s2, [fp, #-28]	; 0xffffffe4
10005de4:	ebfff0f8 	bl	100021cc <PID_setGains>
  PID_setUi(obj->pidHandle_Id,(0.0f));
10005de8:	e51b3010 	ldr	r3, [fp, #-16]
10005dec:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10005df0:	e1a00003 	mov	r0, r3
10005df4:	ed9f0aac 	vldr	s0, [pc, #688]	; 100060ac <CTRL_setParams+0x614>
10005df8:	ebfff137 	bl	100022dc <PID_setUi>
  PID_setMinMax(obj->pidHandle_Id,outMin,outMax);
10005dfc:	e51b3010 	ldr	r3, [fp, #-16]
10005e00:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10005e04:	e1a00003 	mov	r0, r3
10005e08:	ed1b0a08 	vldr	s0, [fp, #-32]	; 0xffffffe0
10005e0c:	ed5b0a09 	vldr	s1, [fp, #-36]	; 0xffffffdc
10005e10:	ebfff11f 	bl	10002294 <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_Id,Kp,Ki,Kd);
10005e14:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005e18:	e3a01001 	mov	r1, #1
10005e1c:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10005e20:	ed5b0a06 	vldr	s1, [fp, #-24]	; 0xffffffe8
10005e24:	ed1b1a07 	vldr	s2, [fp, #-28]	; 0xffffffe4
10005e28:	ebfffe57 	bl	1000578c <CTRL_setGains>


  // set the default the Iq PID controller parameters
  Kp = 0.1f;//(0.1f);
10005e2c:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10005e30:	e3433dcc 	movt	r3, #15820	; 0x3dcc
10005e34:	e50b3014 	str	r3, [fp, #-20]
  Ki = 0.02f;//(pUserParams->ctrlPeriod_sec/0.004f);
10005e38:	e30d370a 	movw	r3, #55050	; 0xd70a
10005e3c:	e3433ca3 	movt	r3, #15523	; 0x3ca3
10005e40:	e50b3018 	str	r3, [fp, #-24]
  Kd = (0.0f);
10005e44:	e3a03000 	mov	r3, #0
10005e48:	e50b301c 	str	r3, [fp, #-28]
  outMin = (-0.95f);
10005e4c:	e3033333 	movw	r3, #13107	; 0x3333
10005e50:	e34b3f73 	movt	r3, #49011	; 0xbf73
10005e54:	e50b3020 	str	r3, [fp, #-32]
  outMax = (0.95f);
10005e58:	e3033333 	movw	r3, #13107	; 0x3333
10005e5c:	e3433f73 	movt	r3, #16243	; 0x3f73
10005e60:	e50b3024 	str	r3, [fp, #-36]	; 0x24

  PID_setGains(obj->pidHandle_Iq,Kp,Ki,Kd);
10005e64:	e51b3010 	ldr	r3, [fp, #-16]
10005e68:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10005e6c:	e1a00003 	mov	r0, r3
10005e70:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10005e74:	ed5b0a06 	vldr	s1, [fp, #-24]	; 0xffffffe8
10005e78:	ed1b1a07 	vldr	s2, [fp, #-28]	; 0xffffffe4
10005e7c:	ebfff0d2 	bl	100021cc <PID_setGains>
  PID_setUi(obj->pidHandle_Iq,(0.0f));
10005e80:	e51b3010 	ldr	r3, [fp, #-16]
10005e84:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10005e88:	e1a00003 	mov	r0, r3
10005e8c:	ed9f0a86 	vldr	s0, [pc, #536]	; 100060ac <CTRL_setParams+0x614>
10005e90:	ebfff111 	bl	100022dc <PID_setUi>
  PID_setMinMax(obj->pidHandle_Iq,outMin,outMax);
10005e94:	e51b3010 	ldr	r3, [fp, #-16]
10005e98:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10005e9c:	e1a00003 	mov	r0, r3
10005ea0:	ed1b0a08 	vldr	s0, [fp, #-32]	; 0xffffffe0
10005ea4:	ed5b0a09 	vldr	s1, [fp, #-36]	; 0xffffffdc
10005ea8:	ebfff0f9 	bl	10002294 <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_Iq,Kp,Ki,Kd);
10005eac:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005eb0:	e3a01002 	mov	r1, #2
10005eb4:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10005eb8:	ed5b0a06 	vldr	s1, [fp, #-24]	; 0xffffffe8
10005ebc:	ed1b1a07 	vldr	s2, [fp, #-28]	; 0xffffffe4
10005ec0:	ebfffe31 	bl	1000578c <CTRL_setGains>


  // set the default speed PID controller parameters
  Kp = 0.1f;//(0.02f*pUserParams->maxCurrent*pUserParams->iqFullScaleFreq_Hz/pUserParams->iqFullScaleCurrent_A);
10005ec4:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10005ec8:	e3433dcc 	movt	r3, #15820	; 0x3dcc
10005ecc:	e50b3014 	str	r3, [fp, #-20]
  Ki = 0.01f;//(2.0f*pUserParams->maxCurrent*pUserParams->iqFullScaleFreq_Hz*pUserParams->ctrlPeriod_sec/pUserParams->iqFullScaleCurrent_A);
10005ed0:	e30d370a 	movw	r3, #55050	; 0xd70a
10005ed4:	e3433c23 	movt	r3, #15395	; 0x3c23
10005ed8:	e50b3018 	str	r3, [fp, #-24]
  Kd = (0.0f);
10005edc:	e3a03000 	mov	r3, #0
10005ee0:	e50b301c 	str	r3, [fp, #-28]
  outMin = (-1.0f);
10005ee4:	e3a03000 	mov	r3, #0
10005ee8:	e34b3f80 	movt	r3, #49024	; 0xbf80
10005eec:	e50b3020 	str	r3, [fp, #-32]
  outMax = (1.0f);
10005ef0:	e3a035fe 	mov	r3, #1065353216	; 0x3f800000
10005ef4:	e50b3024 	str	r3, [fp, #-36]	; 0x24

  PID_setGains(obj->pidHandle_spd,Kp,Ki,Kd);
10005ef8:	e51b3010 	ldr	r3, [fp, #-16]
10005efc:	e5933084 	ldr	r3, [r3, #132]	; 0x84
10005f00:	e1a00003 	mov	r0, r3
10005f04:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10005f08:	ed5b0a06 	vldr	s1, [fp, #-24]	; 0xffffffe8
10005f0c:	ed1b1a07 	vldr	s2, [fp, #-28]	; 0xffffffe4
10005f10:	ebfff0ad 	bl	100021cc <PID_setGains>
  PID_setUi(obj->pidHandle_spd,(0.0f));
10005f14:	e51b3010 	ldr	r3, [fp, #-16]
10005f18:	e5933084 	ldr	r3, [r3, #132]	; 0x84
10005f1c:	e1a00003 	mov	r0, r3
10005f20:	ed9f0a61 	vldr	s0, [pc, #388]	; 100060ac <CTRL_setParams+0x614>
10005f24:	ebfff0ec 	bl	100022dc <PID_setUi>
  PID_setMinMax(obj->pidHandle_spd,outMin,outMax);
10005f28:	e51b3010 	ldr	r3, [fp, #-16]
10005f2c:	e5933084 	ldr	r3, [r3, #132]	; 0x84
10005f30:	e1a00003 	mov	r0, r3
10005f34:	ed1b0a08 	vldr	s0, [fp, #-32]	; 0xffffffe0
10005f38:	ed5b0a09 	vldr	s1, [fp, #-36]	; 0xffffffdc
10005f3c:	ebfff0d4 	bl	10002294 <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_spd,Kp,Ki,Kd);
10005f40:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005f44:	e3a01000 	mov	r1, #0
10005f48:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10005f4c:	ed5b0a06 	vldr	s1, [fp, #-24]	; 0xffffffe8
10005f50:	ed1b1a07 	vldr	s2, [fp, #-28]	; 0xffffffe4
10005f54:	ebfffe0c 	bl	1000578c <CTRL_setGains>


  // set the speed reference
  CTRL_setSpd_ref_pu(handle,(5.00f));
10005f58:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10005f5c:	eeb10a04 	vmov.f32	s0, #20
10005f60:	eb0000b2 	bl	10006230 <CTRL_setSpd_ref_pu>


  // set the default Id current trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_Id,(0.0f));
10005f64:	e51b3010 	ldr	r3, [fp, #-16]
10005f68:	e59330bc 	ldr	r3, [r3, #188]	; 0xbc
10005f6c:	e1a00003 	mov	r0, r3
10005f70:	ed9f0a4d 	vldr	s0, [pc, #308]	; 100060ac <CTRL_setParams+0x614>
10005f74:	ebfff177 	bl	10002558 <TRAJ_setIntValue>
  TRAJ_setTargetValue(obj->trajHandle_Id,(0.0f));
10005f78:	e51b3010 	ldr	r3, [fp, #-16]
10005f7c:	e59330bc 	ldr	r3, [r3, #188]	; 0xbc
10005f80:	e1a00003 	mov	r0, r3
10005f84:	ed9f0a48 	vldr	s0, [pc, #288]	; 100060ac <CTRL_setParams+0x614>
10005f88:	ebfff1aa 	bl	10002638 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_Id,(0.0f));
10005f8c:	e51b3010 	ldr	r3, [fp, #-16]
10005f90:	e59330bc 	ldr	r3, [r3, #188]	; 0xbc
10005f94:	e1a00003 	mov	r0, r3
10005f98:	ed9f0a43 	vldr	s0, [pc, #268]	; 100060ac <CTRL_setParams+0x614>
10005f9c:	ebfff197 	bl	10002600 <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_Id,(0.0f));
10005fa0:	e51b3010 	ldr	r3, [fp, #-16]
10005fa4:	e59330bc 	ldr	r3, [r3, #188]	; 0xbc
10005fa8:	e1a00003 	mov	r0, r3
10005fac:	ed9f0a3e 	vldr	s0, [pc, #248]	; 100060ac <CTRL_setParams+0x614>
10005fb0:	ebfff184 	bl	100025c8 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_Id,(0.0f));
10005fb4:	e51b3010 	ldr	r3, [fp, #-16]
10005fb8:	e59330bc 	ldr	r3, [r3, #188]	; 0xbc
10005fbc:	e1a00003 	mov	r0, r3
10005fc0:	ed9f0a39 	vldr	s0, [pc, #228]	; 100060ac <CTRL_setParams+0x614>
10005fc4:	ebfff171 	bl	10002590 <TRAJ_setMaxDelta>


  // set the default the speed trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_spd,(0.0f));
10005fc8:	e51b3010 	ldr	r3, [fp, #-16]
10005fcc:	e59330d4 	ldr	r3, [r3, #212]	; 0xd4
10005fd0:	e1a00003 	mov	r0, r3
10005fd4:	ed9f0a34 	vldr	s0, [pc, #208]	; 100060ac <CTRL_setParams+0x614>
10005fd8:	ebfff15e 	bl	10002558 <TRAJ_setIntValue>
  TRAJ_setTargetValue(obj->trajHandle_spd,(0.0f));
10005fdc:	e51b3010 	ldr	r3, [fp, #-16]
10005fe0:	e59330d4 	ldr	r3, [r3, #212]	; 0xd4
10005fe4:	e1a00003 	mov	r0, r3
10005fe8:	ed9f0a2f 	vldr	s0, [pc, #188]	; 100060ac <CTRL_setParams+0x614>
10005fec:	ebfff191 	bl	10002638 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_spd,(0.0f));
10005ff0:	e51b3010 	ldr	r3, [fp, #-16]
10005ff4:	e59330d4 	ldr	r3, [r3, #212]	; 0xd4
10005ff8:	e1a00003 	mov	r0, r3
10005ffc:	ed9f0a2a 	vldr	s0, [pc, #168]	; 100060ac <CTRL_setParams+0x614>
10006000:	ebfff17e 	bl	10002600 <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_spd,(0.0f));
10006004:	e51b3010 	ldr	r3, [fp, #-16]
10006008:	e59330d4 	ldr	r3, [r3, #212]	; 0xd4
1000600c:	e1a00003 	mov	r0, r3
10006010:	ed9f0a25 	vldr	s0, [pc, #148]	; 100060ac <CTRL_setParams+0x614>
10006014:	ebfff16b 	bl	100025c8 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_spd,(0.0f));
10006018:	e51b3010 	ldr	r3, [fp, #-16]
1000601c:	e59330d4 	ldr	r3, [r3, #212]	; 0xd4
10006020:	e1a00003 	mov	r0, r3
10006024:	ed9f0a20 	vldr	s0, [pc, #128]	; 100060ac <CTRL_setParams+0x614>
10006028:	ebfff158 	bl	10002590 <TRAJ_setMaxDelta>


  // set the default maximum speed trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_spdMax,(0.0f));
1000602c:	e51b3010 	ldr	r3, [fp, #-16]
10006030:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
10006034:	e1a00003 	mov	r0, r3
10006038:	ed9f0a1b 	vldr	s0, [pc, #108]	; 100060ac <CTRL_setParams+0x614>
1000603c:	ebfff145 	bl	10002558 <TRAJ_setIntValue>
  TRAJ_setTargetValue(obj->trajHandle_spdMax,(0.0f));
10006040:	e51b3010 	ldr	r3, [fp, #-16]
10006044:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
10006048:	e1a00003 	mov	r0, r3
1000604c:	ed9f0a16 	vldr	s0, [pc, #88]	; 100060ac <CTRL_setParams+0x614>
10006050:	ebfff178 	bl	10002638 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_spdMax,(0.0f)); // not used
10006054:	e51b3010 	ldr	r3, [fp, #-16]
10006058:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
1000605c:	e1a00003 	mov	r0, r3
10006060:	ed9f0a11 	vldr	s0, [pc, #68]	; 100060ac <CTRL_setParams+0x614>
10006064:	ebfff165 	bl	10002600 <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_spdMax,(0.0f)); // not used
10006068:	e51b3010 	ldr	r3, [fp, #-16]
1000606c:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
10006070:	e1a00003 	mov	r0, r3
10006074:	ed9f0a0c 	vldr	s0, [pc, #48]	; 100060ac <CTRL_setParams+0x614>
10006078:	ebfff152 	bl	100025c8 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_spdMax,(0.0f)); // not used
1000607c:	e51b3010 	ldr	r3, [fp, #-16]
10006080:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
10006084:	e1a00003 	mov	r0, r3
10006088:	ed9f0a07 	vldr	s0, [pc, #28]	; 100060ac <CTRL_setParams+0x614>
1000608c:	ebfff13f 	bl	10002590 <TRAJ_setMaxDelta>

  
  // set the default estimator parameters
  CTRL_setEstParams(obj->estHandle,pUserParams);
10006090:	e51b3010 	ldr	r3, [fp, #-16]
10006094:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10006098:	e1a00003 	mov	r0, r3
1000609c:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
100060a0:	ebfff60c 	bl	100038d8 <CTRL_setEstParams>


  // set the maximum modulation for the SVGEN module
  maxModulation = SVGEN_4_OVER_3;
100060a4:	e30a3aab 	movw	r3, #43691	; 0xaaab
100060a8:	ea000001 	b	100060b4 <CTRL_setParams+0x61c>
100060ac:	00000000 	.word	0x00000000
100060b0:	441d0000 	.word	0x441d0000
100060b4:	e3433faa 	movt	r3, #16298	; 0x3faa
100060b8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
  SVGEN_setMaxModulation(obj->svgenHandle,maxModulation);
100060bc:	e51b3010 	ldr	r3, [fp, #-16]
100060c0:	e59330b4 	ldr	r3, [r3, #180]	; 0xb4
100060c4:	e1a00003 	mov	r0, r3
100060c8:	ed1b0a0a 	vldr	s0, [fp, #-40]	; 0xffffffd8
100060cc:	ebfff0e7 	bl	10002470 <SVGEN_setMaxModulation>

	obj->angle_offset_pu = 0.0f;
100060d0:	e51b3010 	ldr	r3, [fp, #-16]
100060d4:	e3a02000 	mov	r2, #0
100060d8:	e583220c 	str	r2, [r3, #524]	; 0x20c

  //! \Mod By Dl.K
  RMP_CNTL_SetRampDelayMax(obj->rmpcntl_handle, 600);
100060dc:	e51b3010 	ldr	r3, [fp, #-16]
100060e0:	e5933224 	ldr	r3, [r3, #548]	; 0x224
100060e4:	e1a00003 	mov	r0, r3
100060e8:	e3a01f96 	mov	r1, #600	; 0x258
100060ec:	ebfff15f 	bl	10002670 <RMP_CNTL_SetRampDelayMax>

  RAMPGEN_SetStepAngleMax(obj->rampgen_handle,(pUserParams->ctrlPeriod_sec*pUserParams->iqFullScaleFreq_Hz));
100060f0:	e51b3010 	ldr	r3, [fp, #-16]
100060f4:	e5932244 	ldr	r2, [r3, #580]	; 0x244
100060f8:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
100060fc:	ed937a58 	vldr	s14, [r3, #352]	; 0x160
10006100:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10006104:	edd37a02 	vldr	s15, [r3, #8]
10006108:	ee677a27 	vmul.f32	s15, s14, s15
1000610c:	e1a00002 	mov	r0, r2
10006110:	eeb00a67 	vmov.f32	s0, s15
10006114:	ebfff1ef 	bl	100028d8 <RAMPGEN_SetStepAngleMax>
  RAMPGEN_SetAngleOffset(obj->rampgen_handle,(0.75f));
10006118:	e51b3010 	ldr	r3, [fp, #-16]
1000611c:	e5933244 	ldr	r3, [r3, #580]	; 0x244
10006120:	e1a00003 	mov	r0, r3
10006124:	eeb60a08 	vmov.f32	s0, #104	; 0x68
10006128:	ebfff1f8 	bl	10002910 <RAMPGEN_SetAngleOffset>

	// fc100Hz=>Need:FreqRespose10HzORTimeRespose100ms:0~1.0f(800Hz)
  Speed_SetElecFilterSpeedRatio(obj->Speed_handle, ( 1.0f/(1.0f+2.0f*3.14f*100.0f*pUserParams->numCtrlTicksPerSpeedTick/pUserParams->ctrlFreq_Hz) ) );
1000612c:	e51b3010 	ldr	r3, [fp, #-16]
10006130:	e59322e8 	ldr	r2, [r3, #744]	; 0x2e8
10006134:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10006138:	e1d331b2 	ldrh	r3, [r3, #18]
1000613c:	ee073a90 	vmov	s15, r3
10006140:	eef87ae7 	vcvt.f32.s32	s15, s15
10006144:	ed1f7a27 	vldr	s14, [pc, #-156]	; 100060b0 <CTRL_setParams+0x618>
10006148:	ee277a87 	vmul.f32	s14, s15, s14
1000614c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10006150:	e5933150 	ldr	r3, [r3, #336]	; 0x150
10006154:	ee073a90 	vmov	s15, r3
10006158:	eef87a67 	vcvt.f32.u32	s15, s15
1000615c:	eec77a27 	vdiv.f32	s15, s14, s15
10006160:	eeb77a00 	vmov.f32	s14, #112	; 0x70
10006164:	ee777a87 	vadd.f32	s15, s15, s14
10006168:	eeb77a00 	vmov.f32	s14, #112	; 0x70
1000616c:	eec77a27 	vdiv.f32	s15, s14, s15
10006170:	e1a00002 	mov	r0, r2
10006174:	eeb00a67 	vmov.f32	s0, s15
10006178:	ebfff2a3 	bl	10002c0c <Speed_SetElecFilterSpeedRatio>
  Speed_SetElecThetaChagTimeRatio(obj->Speed_handle, ( pUserParams->ctrlFreq_Hz/( pUserParams->numCtrlTicksPerSpeedTick) ) );//ctrlFreq_Hz:12500 numCtrlTicksPerSpeedTick:10
1000617c:	e51b3010 	ldr	r3, [fp, #-16]
10006180:	e59342e8 	ldr	r4, [r3, #744]	; 0x2e8
10006184:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10006188:	e5932150 	ldr	r2, [r3, #336]	; 0x150
1000618c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10006190:	e1d331b2 	ldrh	r3, [r3, #18]
10006194:	e1a00002 	mov	r0, r2
10006198:	e1a01003 	mov	r1, r3
1000619c:	fa00a307 	blx	1002edc0 <__aeabi_uidiv>
100061a0:	e1a03000 	mov	r3, r0
100061a4:	ee073a90 	vmov	s15, r3
100061a8:	eef87a67 	vcvt.f32.u32	s15, s15
100061ac:	e1a00004 	mov	r0, r4
100061b0:	eeb00a67 	vmov.f32	s0, s15
100061b4:	ebfff2a2 	bl	10002c44 <Speed_SetElecThetaChagTimeRatio>

  obj->Tabc.value[0]=(0.0f);
100061b8:	e51b3010 	ldr	r3, [fp, #-16]
100061bc:	e3a02000 	mov	r2, #0
100061c0:	e5832314 	str	r2, [r3, #788]	; 0x314
  obj->Tabc.value[1]=(0.0f);
100061c4:	e51b3010 	ldr	r3, [fp, #-16]
100061c8:	e3a02000 	mov	r2, #0
100061cc:	e5832318 	str	r2, [r3, #792]	; 0x318
  obj->Tabc.value[2]=(0.0f);
100061d0:	e51b3010 	ldr	r3, [fp, #-16]
100061d4:	e3a02000 	mov	r2, #0
100061d8:	e583231c 	str	r2, [r3, #796]	; 0x31c

  obj->VdqRef.value[0]=(0.0f);
100061dc:	e51b3010 	ldr	r3, [fp, #-16]
100061e0:	e3a02000 	mov	r2, #0
100061e4:	e5832320 	str	r2, [r3, #800]	; 0x320
  obj->VdqRef.value[1]=(0.0f);
100061e8:	e51b3010 	ldr	r3, [fp, #-16]
100061ec:	e3a02000 	mov	r2, #0
100061f0:	e5832324 	str	r2, [r3, #804]	; 0x324

  obj->AngleRef=(0.0f);
100061f4:	e51b3010 	ldr	r3, [fp, #-16]
100061f8:	e3a02000 	mov	r2, #0
100061fc:	e5832328 	str	r2, [r3, #808]	; 0x328

  obj->MntValue.value[0]=(0.0f);
10006200:	e51b3010 	ldr	r3, [fp, #-16]
10006204:	e3a02000 	mov	r2, #0
10006208:	e583232c 	str	r2, [r3, #812]	; 0x32c
  obj->MntValue.value[1]=(0.0f);
1000620c:	e51b3010 	ldr	r3, [fp, #-16]
10006210:	e3a02000 	mov	r2, #0
10006214:	e5832330 	str	r2, [r3, #816]	; 0x330
  obj->MntValue.value[2]=(0.0f);
10006218:	e51b3010 	ldr	r3, [fp, #-16]
1000621c:	e3a02000 	mov	r2, #0
10006220:	e5832334 	str	r2, [r3, #820]	; 0x334
  //! \Mod By Dl.K

  return;
10006224:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setParams() function
10006228:	e24bd008 	sub	sp, fp, #8
1000622c:	e8bd8810 	pop	{r4, fp, pc}

10006230 <CTRL_setSpd_ref_pu>:


void CTRL_setSpd_ref_pu(CTRL_Handle handle,const float_t spd_ref_pu)
{
10006230:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006234:	e28db000 	add	fp, sp, #0
10006238:	e24dd014 	sub	sp, sp, #20
1000623c:	e50b0010 	str	r0, [fp, #-16]
10006240:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10006244:	e51b3010 	ldr	r3, [fp, #-16]
10006248:	e50b3008 	str	r3, [fp, #-8]

  obj->spd_ref = spd_ref_pu;
1000624c:	e51b3008 	ldr	r3, [fp, #-8]
10006250:	e51b2014 	ldr	r2, [fp, #-20]
10006254:	e58321e4 	str	r2, [r3, #484]	; 0x1e4

  return;
10006258:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setSpd_ref_pu() function
1000625c:	e24bd000 	sub	sp, fp, #0
10006260:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006264:	e12fff1e 	bx	lr

10006268 <CTRL_setSpd_ref_krpm>:


void CTRL_setSpd_ref_krpm(CTRL_Handle handle,const float_t spd_ref_krpm)
{
10006268:	e92d4800 	push	{fp, lr}
1000626c:	e28db004 	add	fp, sp, #4
10006270:	e24dd018 	sub	sp, sp, #24
10006274:	e50b0018 	str	r0, [fp, #-24]
10006278:	ed0b0a07 	vstr	s0, [fp, #-28]	; 0xffffffe4
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000627c:	e51b3018 	ldr	r3, [fp, #-24]
10006280:	e50b3008 	str	r3, [fp, #-8]

  float_t krpm_to_pu_sf = EST_get_krpm_to_pu_sf(obj->estHandle);
10006284:	e51b3008 	ldr	r3, [fp, #-8]
10006288:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000628c:	e1a00003 	mov	r0, r3
10006290:	eb000217 	bl	10006af4 <EST_get_krpm_to_pu_sf>
10006294:	ed0b0a03 	vstr	s0, [fp, #-12]

  float_t spd_ref_pu = (spd_ref_krpm*krpm_to_pu_sf);
10006298:	ed1b7a07 	vldr	s14, [fp, #-28]	; 0xffffffe4
1000629c:	ed5b7a03 	vldr	s15, [fp, #-12]
100062a0:	ee677a27 	vmul.f32	s15, s14, s15
100062a4:	ed4b7a04 	vstr	s15, [fp, #-16]

  obj->spd_ref = spd_ref_pu;
100062a8:	e51b3008 	ldr	r3, [fp, #-8]
100062ac:	e51b2010 	ldr	r2, [fp, #-16]
100062b0:	e58321e4 	str	r2, [r3, #484]	; 0x1e4

  return;
100062b4:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setSpd_ref_krpm() function
100062b8:	e24bd004 	sub	sp, fp, #4
100062bc:	e8bd8800 	pop	{fp, pc}

100062c0 <CTRL_setup>:


void CTRL_setup(CTRL_Handle handle)
{
100062c0:	e92d4800 	push	{fp, lr}
100062c4:	e28db004 	add	fp, sp, #4
100062c8:	e24dd018 	sub	sp, sp, #24
100062cc:	e50b0018 	str	r0, [fp, #-24]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100062d0:	e51b3018 	ldr	r3, [fp, #-24]
100062d4:	e50b3008 	str	r3, [fp, #-8]

  uint_least16_t count_traj = CTRL_getCount_traj(handle);
100062d8:	e51b0018 	ldr	r0, [fp, #-24]
100062dc:	ebfff2d5 	bl	10002e38 <CTRL_getCount_traj>
100062e0:	e1a03000 	mov	r3, r0
100062e4:	e14b30ba 	strh	r3, [fp, #-10]
  uint_least16_t numCtrlTicksPerTrajTick = CTRL_getNumCtrlTicksPerTrajTick(handle);
100062e8:	e51b0018 	ldr	r0, [fp, #-24]
100062ec:	ebfff3e0 	bl	10003274 <CTRL_getNumCtrlTicksPerTrajTick>
100062f0:	e1a03000 	mov	r3, r0
100062f4:	e14b30bc 	strh	r3, [fp, #-12]


  // as needed, update the trajectory
  if(count_traj >= numCtrlTicksPerTrajTick)
100062f8:	e15b20ba 	ldrh	r2, [fp, #-10]
100062fc:	e15b30bc 	ldrh	r3, [fp, #-12]
10006300:	e1520003 	cmp	r2, r3
10006304:	3a000008 	bcc	1000632c <CTRL_setup+0x6c>
    {
      float_t intValue_Id = TRAJ_getIntValue(obj->trajHandle_Id);
10006308:	e51b3008 	ldr	r3, [fp, #-8]
1000630c:	e59330bc 	ldr	r3, [r3, #188]	; 0xbc
10006310:	e1a00003 	mov	r0, r3
10006314:	ebfff075 	bl	100024f0 <TRAJ_getIntValue>
10006318:	ed0b0a04 	vstr	s0, [fp, #-16]

      // reset the trajectory count
      CTRL_resetCounter_traj(handle);
1000631c:	e51b0018 	ldr	r0, [fp, #-24]
10006320:	ebfff51d 	bl	1000379c <CTRL_resetCounter_traj>

      // run the trajectories
      CTRL_runTraj(handle);
10006324:	e51b0018 	ldr	r0, [fp, #-24]
10006328:	ebfff52a 	bl	100037d8 <CTRL_runTraj>
    } // end of if(gFlag_traj) block

  return;
1000632c:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setup() function
10006330:	e24bd004 	sub	sp, fp, #4
10006334:	e8bd8800 	pop	{fp, pc}

10006338 <CTRL_setupClarke_I>:


void CTRL_setupClarke_I(CTRL_Handle handle,uint_least8_t numCurrentSensors)
{
10006338:	e92d4800 	push	{fp, lr}
1000633c:	e28db004 	add	fp, sp, #4
10006340:	e24dd018 	sub	sp, sp, #24
10006344:	e50b0018 	str	r0, [fp, #-24]
10006348:	e1a03001 	mov	r3, r1
1000634c:	e54b3019 	strb	r3, [fp, #-25]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10006350:	e51b3018 	ldr	r3, [fp, #-24]
10006354:	e50b3010 	str	r3, [fp, #-16]
  float_t alpha_sf,beta_sf;
  

  // initialize the Clarke transform module for current
  if(numCurrentSensors == 3)
10006358:	e55b3019 	ldrb	r3, [fp, #-25]
1000635c:	e3530003 	cmp	r3, #3
10006360:	1a000006 	bne	10006380 <CTRL_setupClarke_I+0x48>
    {
      alpha_sf = (MATH_ONE_OVER_THREE);
10006364:	e30a3aab 	movw	r3, #43691	; 0xaaab
10006368:	e3433eaa 	movt	r3, #16042	; 0x3eaa
1000636c:	e50b3008 	str	r3, [fp, #-8]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
10006370:	e30c3d3a 	movw	r3, #52538	; 0xcd3a
10006374:	e3433f13 	movt	r3, #16147	; 0x3f13
10006378:	e50b300c 	str	r3, [fp, #-12]
1000637c:	ea00000c 	b	100063b4 <CTRL_setupClarke_I+0x7c>
    }
  else if(numCurrentSensors == 2)
10006380:	e55b3019 	ldrb	r3, [fp, #-25]
10006384:	e3530002 	cmp	r3, #2
10006388:	1a000005 	bne	100063a4 <CTRL_setupClarke_I+0x6c>
    {
      alpha_sf = (1.0);
1000638c:	e3a035fe 	mov	r3, #1065353216	; 0x3f800000
10006390:	e50b3008 	str	r3, [fp, #-8]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
10006394:	e30c3d3a 	movw	r3, #52538	; 0xcd3a
10006398:	e3433f13 	movt	r3, #16147	; 0x3f13
1000639c:	e50b300c 	str	r3, [fp, #-12]
100063a0:	ea000003 	b	100063b4 <CTRL_setupClarke_I+0x7c>
    }
  else 
    {
      alpha_sf = (0.0);
100063a4:	e3a03000 	mov	r3, #0
100063a8:	e50b3008 	str	r3, [fp, #-8]
      beta_sf = (0.0);
100063ac:	e3a03000 	mov	r3, #0
100063b0:	e50b300c 	str	r3, [fp, #-12]
    }

  // set the parameters
  CLARKE_setScaleFactors(obj->clarkeHandle_I,alpha_sf,beta_sf);
100063b4:	e51b3010 	ldr	r3, [fp, #-16]
100063b8:	e593300c 	ldr	r3, [r3, #12]
100063bc:	e1a00003 	mov	r0, r3
100063c0:	ed1b0a02 	vldr	s0, [fp, #-8]
100063c4:	ed5b0a03 	vldr	s1, [fp, #-12]
100063c8:	ebffee37 	bl	10001cac <CLARKE_setScaleFactors>
  CLARKE_setNumSensors(obj->clarkeHandle_I,numCurrentSensors);
100063cc:	e51b3010 	ldr	r3, [fp, #-16]
100063d0:	e593200c 	ldr	r2, [r3, #12]
100063d4:	e55b3019 	ldrb	r3, [fp, #-25]
100063d8:	e1a00002 	mov	r0, r2
100063dc:	e1a01003 	mov	r1, r3
100063e0:	ebffee22 	bl	10001c70 <CLARKE_setNumSensors>

  return;
100063e4:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setupClarke_I() function
100063e8:	e24bd004 	sub	sp, fp, #4
100063ec:	e8bd8800 	pop	{fp, pc}

100063f0 <CTRL_setupClarke_V>:


void CTRL_setupClarke_V(CTRL_Handle handle,uint_least8_t numVoltageSensors)
{
100063f0:	e92d4800 	push	{fp, lr}
100063f4:	e28db004 	add	fp, sp, #4
100063f8:	e24dd018 	sub	sp, sp, #24
100063fc:	e50b0018 	str	r0, [fp, #-24]
10006400:	e1a03001 	mov	r3, r1
10006404:	e54b3019 	strb	r3, [fp, #-25]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10006408:	e51b3018 	ldr	r3, [fp, #-24]
1000640c:	e50b3010 	str	r3, [fp, #-16]
  float_t alpha_sf,beta_sf;
  

  // initialize the Clarke transform module for current
  if(numVoltageSensors == 3)
10006410:	e55b3019 	ldrb	r3, [fp, #-25]
10006414:	e3530003 	cmp	r3, #3
10006418:	1a000006 	bne	10006438 <CTRL_setupClarke_V+0x48>
    {
      alpha_sf = (MATH_ONE_OVER_THREE);
1000641c:	e30a3aab 	movw	r3, #43691	; 0xaaab
10006420:	e3433eaa 	movt	r3, #16042	; 0x3eaa
10006424:	e50b3008 	str	r3, [fp, #-8]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
10006428:	e30c3d3a 	movw	r3, #52538	; 0xcd3a
1000642c:	e3433f13 	movt	r3, #16147	; 0x3f13
10006430:	e50b300c 	str	r3, [fp, #-12]
10006434:	ea000003 	b	10006448 <CTRL_setupClarke_V+0x58>
    }
 else 
    {
      alpha_sf = (0.0);
10006438:	e3a03000 	mov	r3, #0
1000643c:	e50b3008 	str	r3, [fp, #-8]
      beta_sf = (0.0);
10006440:	e3a03000 	mov	r3, #0
10006444:	e50b300c 	str	r3, [fp, #-12]
    }

  // set the parameters
  CLARKE_setScaleFactors(obj->clarkeHandle_V,alpha_sf,beta_sf);
10006448:	e51b3010 	ldr	r3, [fp, #-16]
1000644c:	e593301c 	ldr	r3, [r3, #28]
10006450:	e1a00003 	mov	r0, r3
10006454:	ed1b0a02 	vldr	s0, [fp, #-8]
10006458:	ed5b0a03 	vldr	s1, [fp, #-12]
1000645c:	ebffee12 	bl	10001cac <CLARKE_setScaleFactors>
  CLARKE_setNumSensors(obj->clarkeHandle_V,numVoltageSensors);
10006460:	e51b3010 	ldr	r3, [fp, #-16]
10006464:	e593201c 	ldr	r2, [r3, #28]
10006468:	e55b3019 	ldrb	r3, [fp, #-25]
1000646c:	e1a00002 	mov	r0, r2
10006470:	e1a01003 	mov	r1, r3
10006474:	ebffedfd 	bl	10001c70 <CLARKE_setNumSensors>

  return;
10006478:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setupClarke_V() function
1000647c:	e24bd004 	sub	sp, fp, #4
10006480:	e8bd8800 	pop	{fp, pc}

10006484 <CTRL_setup_user>:
                     const float_t speed_outMax_pu,
                     const MATH_vec2 *pIdq_offset_pu,
                     const MATH_vec2 *pVdq_offset_pu,
                     const bool flag_enableSpeedCtrl,
                     const bool flag_enableCurrentCtrl)
{
10006484:	e92d4800 	push	{fp, lr}
10006488:	e28db004 	add	fp, sp, #4
1000648c:	e24dd028 	sub	sp, sp, #40	; 0x28
10006490:	e50b0010 	str	r0, [fp, #-16]
10006494:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
10006498:	ed4b0a06 	vstr	s1, [fp, #-24]	; 0xffffffe8
1000649c:	ed0b1a07 	vstr	s2, [fp, #-28]	; 0xffffffe4
100064a0:	ed4b1a08 	vstr	s3, [fp, #-32]	; 0xffffffe0
100064a4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
100064a8:	e50b2028 	str	r2, [fp, #-40]	; 0x28
100064ac:	e54b3029 	strb	r3, [fp, #-41]	; 0x29
  CTRL_State_e ctrlState = CTRL_getState(handle);
100064b0:	e51b0010 	ldr	r0, [fp, #-16]
100064b4:	ebfff3bc 	bl	100033ac <CTRL_getState>
100064b8:	e1a03000 	mov	r3, r0
100064bc:	e54b3005 	strb	r3, [fp, #-5]
  uint_least16_t count_traj = CTRL_getCount_traj(handle);
100064c0:	e51b0010 	ldr	r0, [fp, #-16]
100064c4:	ebfff25b 	bl	10002e38 <CTRL_getCount_traj>
100064c8:	e1a03000 	mov	r3, r0
100064cc:	e14b30b8 	strh	r3, [fp, #-8]
  uint_least16_t numCtrlTicksPerTrajTick = CTRL_getNumCtrlTicksPerTrajTick(handle);
100064d0:	e51b0010 	ldr	r0, [fp, #-16]
100064d4:	ebfff366 	bl	10003274 <CTRL_getNumCtrlTicksPerTrajTick>
100064d8:	e1a03000 	mov	r3, r0
100064dc:	e14b30ba 	strh	r3, [fp, #-10]


  // increment the state counter
  CTRL_incrCounter_state(handle);
100064e0:	e51b0010 	ldr	r0, [fp, #-16]
100064e4:	ebfff44a 	bl	10003614 <CTRL_incrCounter_state>

  // increment the trajectory count
  CTRL_incrCounter_traj(handle);
100064e8:	e51b0010 	ldr	r0, [fp, #-16]
100064ec:	ebfff45b 	bl	10003660 <CTRL_incrCounter_traj>

  // run the appropriate controller
  if(ctrlState == CTRL_State_OnLine)
100064f0:	e55b3005 	ldrb	r3, [fp, #-5]
100064f4:	e3530007 	cmp	r3, #7
100064f8:	1a000003 	bne	1000650c <CTRL_setup_user+0x88>
  {
    // increment the current count
    CTRL_incrCounter_current(handle);
100064fc:	e51b0010 	ldr	r0, [fp, #-16]
10006500:	ebfff402 	bl	10003510 <CTRL_incrCounter_current>

    // increment the speed count
    CTRL_incrCounter_speed(handle);
10006504:	e51b0010 	ldr	r0, [fp, #-16]
10006508:	ebfff42c 	bl	100035c0 <CTRL_incrCounter_speed>
  }

  // as needed, update the trajectory
  if(count_traj >= numCtrlTicksPerTrajTick)
1000650c:	e15b20b8 	ldrh	r2, [fp, #-8]
10006510:	e15b30ba 	ldrh	r3, [fp, #-10]
10006514:	e1520003 	cmp	r2, r3
10006518:	3a000003 	bcc	1000652c <CTRL_setup_user+0xa8>
  {
    // reset the trajectory count
    CTRL_resetCounter_traj(handle);
1000651c:	e51b0010 	ldr	r0, [fp, #-16]
10006520:	ebfff49d 	bl	1000379c <CTRL_resetCounter_traj>

    // run the trajectories
    CTRL_runTraj(handle);
10006524:	e51b0010 	ldr	r0, [fp, #-16]
10006528:	ebfff4aa 	bl	100037d8 <CTRL_runTraj>
  } // end of if(gFlag_traj) block


  CTRL_setAngle_pu(handle,angle_pu);
1000652c:	e51b0010 	ldr	r0, [fp, #-16]
10006530:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10006534:	ebfff4ae 	bl	100037f4 <CTRL_setAngle_pu>
  CTRL_setSpeed_ref_pu(handle,speed_ref_pu);
10006538:	e51b0010 	ldr	r0, [fp, #-16]
1000653c:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
10006540:	ebfff6ee 	bl	10004100 <CTRL_setSpeed_ref_pu>
  CTRL_setSpeed_fb_pu(handle,speed_fb_pu);
10006544:	e51b0010 	ldr	r0, [fp, #-16]
10006548:	ed1b0a07 	vldr	s0, [fp, #-28]	; 0xffffffe4
1000654c:	ebfff6b3 	bl	10004020 <CTRL_setSpeed_fb_pu>
  CTRL_setSpeed_outMax_pu(handle,speed_outMax_pu);
10006550:	e51b0010 	ldr	r0, [fp, #-16]
10006554:	ed1b0a08 	vldr	s0, [fp, #-32]	; 0xffffffe0
10006558:	ebfff6da 	bl	100040c8 <CTRL_setSpeed_outMax_pu>

  CTRL_setIdq_offset_pu(handle,pIdq_offset_pu);
1000655c:	e51b0010 	ldr	r0, [fp, #-16]
10006560:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
10006564:	ebfff572 	bl	10003b34 <CTRL_setIdq_offset_pu>
  CTRL_setVdq_offset_pu(handle,pVdq_offset_pu);
10006568:	e51b0010 	ldr	r0, [fp, #-16]
1000656c:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
10006570:	ebfff75a 	bl	100042e0 <CTRL_setVdq_offset_pu>

  CTRL_setFlag_enableSpeedCtrl(handle,flag_enableSpeedCtrl);
10006574:	e55b3029 	ldrb	r3, [fp, #-41]	; 0x29
10006578:	e51b0010 	ldr	r0, [fp, #-16]
1000657c:	e1a01003 	mov	r1, r3
10006580:	ebfff527 	bl	10003a24 <CTRL_setFlag_enableSpeedCtrl>
  CTRL_setFlag_enableCurrentCtrl(handle,flag_enableCurrentCtrl);
10006584:	e5db3004 	ldrb	r3, [fp, #4]
10006588:	e51b0010 	ldr	r0, [fp, #-16]
1000658c:	e1a01003 	mov	r1, r3
10006590:	ebfff4e7 	bl	10003934 <CTRL_setFlag_enableCurrentCtrl>


  return;
10006594:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setup_user() function
10006598:	e24bd004 	sub	sp, fp, #4
1000659c:	e8bd8800 	pop	{fp, pc}

100065a0 <CTRL_setWaitTimes>:


void CTRL_setWaitTimes(CTRL_Handle handle,const uint_least32_t *pWaitTimes)
{
100065a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100065a4:	e28db000 	add	fp, sp, #0
100065a8:	e24dd014 	sub	sp, sp, #20
100065ac:	e50b0010 	str	r0, [fp, #-16]
100065b0:	e50b1014 	str	r1, [fp, #-20]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100065b4:	e51b3010 	ldr	r3, [fp, #-16]
100065b8:	e50b300c 	str	r3, [fp, #-12]
  uint_least16_t stateCnt;

  for(stateCnt=0;stateCnt<CTRL_numStates;stateCnt++)
100065bc:	e3a03000 	mov	r3, #0
100065c0:	e14b30b6 	strh	r3, [fp, #-6]
100065c4:	ea00000b 	b	100065f8 <CTRL_setWaitTimes+0x58>
    {
      obj->waitTimes[stateCnt] = pWaitTimes[stateCnt];
100065c8:	e15b20b6 	ldrh	r2, [fp, #-6]
100065cc:	e15b30b6 	ldrh	r3, [fp, #-6]
100065d0:	e1a03103 	lsl	r3, r3, #2
100065d4:	e51b1014 	ldr	r1, [fp, #-20]
100065d8:	e0813003 	add	r3, r1, r3
100065dc:	e5931000 	ldr	r1, [r3]
100065e0:	e51b300c 	ldr	r3, [fp, #-12]
100065e4:	e2822048 	add	r2, r2, #72	; 0x48
100065e8:	e7831102 	str	r1, [r3, r2, lsl #2]
void CTRL_setWaitTimes(CTRL_Handle handle,const uint_least32_t *pWaitTimes)
{
  CTRL_Obj *obj = (CTRL_Obj *)handle;
  uint_least16_t stateCnt;

  for(stateCnt=0;stateCnt<CTRL_numStates;stateCnt++)
100065ec:	e15b30b6 	ldrh	r3, [fp, #-6]
100065f0:	e2833001 	add	r3, r3, #1
100065f4:	e14b30b6 	strh	r3, [fp, #-6]
100065f8:	e15b30b6 	ldrh	r3, [fp, #-6]
100065fc:	e3530009 	cmp	r3, #9
10006600:	9afffff0 	bls	100065c8 <CTRL_setWaitTimes+0x28>
    {
      obj->waitTimes[stateCnt] = pWaitTimes[stateCnt];
    }

  return;
10006604:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setWaitTimes() function
10006608:	e24bd000 	sub	sp, fp, #0
1000660c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006610:	e12fff1e 	bx	lr

10006614 <CTRL_updateState>:


bool CTRL_updateState(CTRL_Handle handle)
{
10006614:	e92d4800 	push	{fp, lr}
10006618:	e28db004 	add	fp, sp, #4
1000661c:	e24dd030 	sub	sp, sp, #48	; 0x30
10006620:	e50b0030 	str	r0, [fp, #-48]	; 0x30
  CTRL_State_e ctrlState = CTRL_getState(handle);
10006624:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006628:	ebfff35f 	bl	100033ac <CTRL_getState>
1000662c:	e1a03000 	mov	r3, r0
10006630:	e54b3006 	strb	r3, [fp, #-6]
  bool flag_enableCtrl = CTRL_getFlag_enableCtrl(handle);
10006634:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006638:	ebfff20c 	bl	10002e70 <CTRL_getFlag_enableCtrl>
1000663c:	e1a03000 	mov	r3, r0
10006640:	e54b3007 	strb	r3, [fp, #-7]
  bool stateChanged = false;
10006644:	e3a03000 	mov	r3, #0
10006648:	e54b3005 	strb	r3, [fp, #-5]


  if(flag_enableCtrl)
1000664c:	e55b3007 	ldrb	r3, [fp, #-7]
10006650:	e3530000 	cmp	r3, #0
10006654:	0a00008f 	beq	10006898 <CTRL_updateState+0x284>
    {
      uint_least32_t waitTime = CTRL_getWaitTime(handle,ctrlState);
10006658:	e55b3006 	ldrb	r3, [fp, #-6]
1000665c:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006660:	e1a01003 	mov	r1, r3
10006664:	ebfff399 	bl	100034d0 <CTRL_getWaitTime>
10006668:	e50b000c 	str	r0, [fp, #-12]
      uint_least32_t counter_ctrlState = CTRL_getCount_state(handle);
1000666c:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006670:	ebfff1e4 	bl	10002e08 <CTRL_getCount_state>
10006674:	e50b0010 	str	r0, [fp, #-16]


      // check for errors
      CTRL_checkForErrors(handle);
10006678:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
1000667c:	ebfff74b 	bl	100043b0 <CTRL_checkForErrors>


      if(counter_ctrlState >= waitTime)
10006680:	e51b2010 	ldr	r2, [fp, #-16]
10006684:	e51b300c 	ldr	r3, [fp, #-12]
10006688:	e1520003 	cmp	r2, r3
1000668c:	3a000080 	bcc	10006894 <CTRL_updateState+0x280>
        {
          // reset the counter
          CTRL_resetCounter_state(handle);
10006690:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006694:	ebfff433 	bl	10003768 <CTRL_resetCounter_state>


          if(ctrlState == CTRL_State_OnLine)
10006698:	e55b3006 	ldrb	r3, [fp, #-6]
1000669c:	e3530007 	cmp	r3, #7
100066a0:	1a00003a 	bne	10006790 <CTRL_updateState+0x17c>
            {
              CTRL_Obj *obj = (CTRL_Obj *)handle;
100066a4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100066a8:	e50b3014 	str	r3, [fp, #-20]
              float_t Id_target = TRAJ_getTargetValue(obj->trajHandle_Id);
100066ac:	e51b3014 	ldr	r3, [fp, #-20]
100066b0:	e59330bc 	ldr	r3, [r3, #188]	; 0xbc
100066b4:	e1a00003 	mov	r0, r3
100066b8:	ebffef99 	bl	10002524 <TRAJ_getTargetValue>
100066bc:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8

              // update the estimator state
              bool flag_estStateChanged = EST_updateState(obj->estHandle,Id_target);
100066c0:	e51b3014 	ldr	r3, [fp, #-20]
100066c4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100066c8:	e1a00003 	mov	r0, r3
100066cc:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
100066d0:	eb000175 	bl	10006cac <EST_updateState>
100066d4:	e1a03000 	mov	r3, r0
100066d8:	e54b3019 	strb	r3, [fp, #-25]

              if(flag_estStateChanged)
100066dc:	e55b3019 	ldrb	r3, [fp, #-25]
100066e0:	e3530000 	cmp	r3, #0
100066e4:	0a000003 	beq	100066f8 <CTRL_updateState+0xe4>
                {
                  // setup the controller
                  CTRL_setupCtrl(handle);
100066e8:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
100066ec:	ebfff721 	bl	10004378 <CTRL_setupCtrl>

                  // setup the trajectory
                  CTRL_setupTraj(handle);
100066f0:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
100066f4:	ebfff726 	bl	10004394 <CTRL_setupTraj>
                }

              if(EST_isOnLine(obj->estHandle))
100066f8:	e51b3014 	ldr	r3, [fp, #-20]
100066fc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10006700:	e1a00003 	mov	r0, r3
10006704:	eb000128 	bl	10006bac <EST_isOnLine>
10006708:	e1a03000 	mov	r3, r0
1000670c:	e3530000 	cmp	r3, #0
10006710:	0a000001 	beq	1000671c <CTRL_updateState+0x108>
                {
                  // setup the estimator for online state
                  CTRL_setupEstOnLineState(handle);
10006714:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006718:	ebfff6bc 	bl	10004210 <CTRL_setupEstOnLineState>
                }

              if(EST_isLockRotor(obj->estHandle) || 
1000671c:	e51b3014 	ldr	r3, [fp, #-20]
10006720:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10006724:	e1a00003 	mov	r0, r3
10006728:	eb00010d 	bl	10006b64 <EST_isLockRotor>
1000672c:	e1a03000 	mov	r3, r0
10006730:	e3530000 	cmp	r3, #0
10006734:	1a00000d 	bne	10006770 <CTRL_updateState+0x15c>
                 (EST_isIdle(obj->estHandle) && EST_isMotorIdentified(obj->estHandle)))
10006738:	e51b3014 	ldr	r3, [fp, #-20]
1000673c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10006740:	e1a00003 	mov	r0, r3
10006744:	eb0000fd 	bl	10006b40 <EST_isIdle>
10006748:	e1a03000 	mov	r3, r0
                {
                  // setup the estimator for online state
                  CTRL_setupEstOnLineState(handle);
                }

              if(EST_isLockRotor(obj->estHandle) || 
1000674c:	e3530000 	cmp	r3, #0
10006750:	0a00000d 	beq	1000678c <CTRL_updateState+0x178>
                 (EST_isIdle(obj->estHandle) && EST_isMotorIdentified(obj->estHandle)))
10006754:	e51b3014 	ldr	r3, [fp, #-20]
10006758:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000675c:	e1a00003 	mov	r0, r3
10006760:	eb000108 	bl	10006b88 <EST_isMotorIdentified>
10006764:	e1a03000 	mov	r3, r0
10006768:	e3530000 	cmp	r3, #0
1000676c:	0a000006 	beq	1000678c <CTRL_updateState+0x178>
                {
                  // set the enable controller flag to false
                  CTRL_setFlag_enableCtrl(handle,false);
10006770:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006774:	e3a01000 	mov	r1, #0
10006778:	ebfff45e 	bl	100038f8 <CTRL_setFlag_enableCtrl>

                  // set the next controller state
                  CTRL_setState(handle,CTRL_State_Idle);
1000677c:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006780:	e3a01001 	mov	r1, #1
10006784:	ebfff66b 	bl	10004138 <CTRL_setState>
10006788:	ea000041 	b	10006894 <CTRL_updateState+0x280>
1000678c:	ea000040 	b	10006894 <CTRL_updateState+0x280>
                }
            }
          else if(ctrlState == CTRL_State_OffLine)
10006790:	e55b3006 	ldrb	r3, [fp, #-6]
10006794:	e3530002 	cmp	r3, #2
10006798:	1a000003 	bne	100067ac <CTRL_updateState+0x198>
            {
              // set the next controller state
              CTRL_setState(handle,CTRL_State_OnLine);
1000679c:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
100067a0:	e3a01007 	mov	r1, #7
100067a4:	ebfff663 	bl	10004138 <CTRL_setState>
100067a8:	ea000039 	b	10006894 <CTRL_updateState+0x280>
            }
          else if(ctrlState == CTRL_State_Idle)
100067ac:	e55b3006 	ldrb	r3, [fp, #-6]
100067b0:	e3530001 	cmp	r3, #1
100067b4:	1a000036 	bne	10006894 <CTRL_updateState+0x280>
            {
              CTRL_Obj *obj = (CTRL_Obj *)handle;
100067b8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100067bc:	e50b3020 	str	r3, [fp, #-32]
              bool  flag_enableUserMotorParams = CTRL_getFlag_enableUserMotorParams(handle);
100067c0:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
100067c4:	ebfff1d9 	bl	10002f30 <CTRL_getFlag_enableUserMotorParams>
100067c8:	e1a03000 	mov	r3, r0
100067cc:	e54b3021 	strb	r3, [fp, #-33]	; 0x21

              if(flag_enableUserMotorParams)
100067d0:	e55b3021 	ldrb	r3, [fp, #-33]	; 0x21
100067d4:	e3530000 	cmp	r3, #0
100067d8:	0a000001 	beq	100067e4 <CTRL_updateState+0x1d0>
                {
                  // initialize the motor parameters using values from the user.h file
                  CTRL_setUserMotorParams(handle);
100067dc:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
100067e0:	ebfff691 	bl	1000422c <CTRL_setUserMotorParams>
                }

              if(EST_isIdle(obj->estHandle))
100067e4:	e51b3020 	ldr	r3, [fp, #-32]
100067e8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100067ec:	e1a00003 	mov	r0, r3
100067f0:	eb0000d2 	bl	10006b40 <EST_isIdle>
100067f4:	e1a03000 	mov	r3, r0
100067f8:	e3530000 	cmp	r3, #0
100067fc:	0a000019 	beq	10006868 <CTRL_updateState+0x254>
                {
                  // setup the estimator for idle state
                  CTRL_setupEstIdleState(handle);
10006800:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006804:	ebfff67a 	bl	100041f4 <CTRL_setupEstIdleState>

                  if(EST_isMotorIdentified(obj->estHandle))
10006808:	e51b3020 	ldr	r3, [fp, #-32]
1000680c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10006810:	e1a00003 	mov	r0, r3
10006814:	eb0000db 	bl	10006b88 <EST_isMotorIdentified>
10006818:	e1a03000 	mov	r3, r0
1000681c:	e3530000 	cmp	r3, #0
10006820:	0a00000c 	beq	10006858 <CTRL_updateState+0x244>
                    {
                      if(CTRL_getFlag_enableOffset(handle))
10006824:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006828:	ebfff1a8 	bl	10002ed0 <CTRL_getFlag_enableOffset>
1000682c:	e1a03000 	mov	r3, r0
10006830:	e3530000 	cmp	r3, #0
10006834:	0a000003 	beq	10006848 <CTRL_updateState+0x234>
                        {
                          // set the next controller state
                          CTRL_setState(handle,CTRL_State_OffLine);
10006838:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
1000683c:	e3a01002 	mov	r1, #2
10006840:	ebfff63c 	bl	10004138 <CTRL_setState>
10006844:	ea000012 	b	10006894 <CTRL_updateState+0x280>
                        }
                      else
                        {
                          // set the next controller state
                          CTRL_setState(handle,CTRL_State_OnLine);
10006848:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
1000684c:	e3a01007 	mov	r1, #7
10006850:	ebfff638 	bl	10004138 <CTRL_setState>
10006854:	ea00000e 	b	10006894 <CTRL_updateState+0x280>
                        }
                    }
                  else
                    {
                      // set the next controller state
                      CTRL_setState(handle,CTRL_State_OffLine);
10006858:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
1000685c:	e3a01002 	mov	r1, #2
10006860:	ebfff634 	bl	10004138 <CTRL_setState>
10006864:	ea00002e 	b	10006924 <CTRL_updateState+0x310>
                    }
                }
              else if(EST_isLockRotor(obj->estHandle))
10006868:	e51b3020 	ldr	r3, [fp, #-32]
1000686c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10006870:	e1a00003 	mov	r0, r3
10006874:	eb0000ba 	bl	10006b64 <EST_isLockRotor>
10006878:	e1a03000 	mov	r3, r0
1000687c:	e3530000 	cmp	r3, #0
10006880:	0a000003 	beq	10006894 <CTRL_updateState+0x280>
                {
                  // set the next controller state
                  CTRL_setState(handle,CTRL_State_OnLine);
10006884:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006888:	e3a01007 	mov	r1, #7
1000688c:	ebfff629 	bl	10004138 <CTRL_setState>
10006890:	ea000023 	b	10006924 <CTRL_updateState+0x310>
10006894:	ea000022 	b	10006924 <CTRL_updateState+0x310>
            }
        }  // if(counter_ctrlState >= waitTime) loop
    } 
  else
    {
      CTRL_Obj *obj = (CTRL_Obj *)handle;
10006898:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1000689c:	e50b3028 	str	r3, [fp, #-40]	; 0x28

      // set the next controller state
      CTRL_setState(handle,CTRL_State_Idle);
100068a0:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
100068a4:	e3a01001 	mov	r1, #1
100068a8:	ebfff622 	bl	10004138 <CTRL_setState>

      // set the estimator to idle
      if(!EST_isLockRotor(obj->estHandle))
100068ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100068b0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100068b4:	e1a00003 	mov	r0, r3
100068b8:	eb0000a9 	bl	10006b64 <EST_isLockRotor>
100068bc:	e1a03000 	mov	r3, r0
100068c0:	e2233001 	eor	r3, r3, #1
100068c4:	e6ef3073 	uxtb	r3, r3
100068c8:	e3530000 	cmp	r3, #0
100068cc:	0a000014 	beq	10006924 <CTRL_updateState+0x310>
        {
          if(EST_isMotorIdentified(obj->estHandle))
100068d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100068d4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100068d8:	e1a00003 	mov	r0, r3
100068dc:	eb0000a9 	bl	10006b88 <EST_isMotorIdentified>
100068e0:	e1a03000 	mov	r3, r0
100068e4:	e3530000 	cmp	r3, #0
100068e8:	0a000004 	beq	10006900 <CTRL_updateState+0x2ec>
            {
              EST_setIdle(obj->estHandle);
100068ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100068f0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100068f4:	e1a00003 	mov	r0, r3
100068f8:	eb0000c0 	bl	10006c00 <EST_setIdle>
100068fc:	ea000008 	b	10006924 <CTRL_updateState+0x310>
            }
          else
            {
              EST_setIdle_all(obj->estHandle);
10006900:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10006904:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10006908:	e1a00003 	mov	r0, r3
1000690c:	eb0000c3 	bl	10006c20 <EST_setIdle_all>

              EST_setRs_pu(obj->estHandle,(0.0));
10006910:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10006914:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10006918:	e1a00003 	mov	r0, r3
1000691c:	ed9f0a0d 	vldr	s0, [pc, #52]	; 10006958 <CTRL_updateState+0x344>
10006920:	eb0000cf 	bl	10006c64 <EST_setRs_pu>
        }
    }


  // check to see if the state changed
  if(ctrlState != CTRL_getState(handle))
10006924:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
10006928:	ebfff29f 	bl	100033ac <CTRL_getState>
1000692c:	e1a03000 	mov	r3, r0
10006930:	e1a02003 	mov	r2, r3
10006934:	e55b3006 	ldrb	r3, [fp, #-6]
10006938:	e1530002 	cmp	r3, r2
1000693c:	0a000001 	beq	10006948 <CTRL_updateState+0x334>
    {
      stateChanged = true;
10006940:	e3a03001 	mov	r3, #1
10006944:	e54b3005 	strb	r3, [fp, #-5]
    }

  return(stateChanged);
10006948:	e55b3005 	ldrb	r3, [fp, #-5]
} // end of CTRL_updateState() function
1000694c:	e1a00003 	mov	r0, r3
10006950:	e24bd004 	sub	sp, fp, #4
10006954:	e8bd8800 	pop	{fp, pc}
10006958:	00000000 	.word	0x00000000

1000695c <DATA_RTXD_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/data_rtxd/data_rtxd.h"

DATA_RTXD_Handle DATA_RTXD_Init(void *pMemory, const size_t numBytes)
{
1000695c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006960:	e28db000 	add	fp, sp, #0
10006964:	e24dd014 	sub	sp, sp, #20
10006968:	e50b0010 	str	r0, [fp, #-16]
1000696c:	e50b1014 	str	r1, [fp, #-20]
	DATA_RTXD_Handle handle;
	uint8_t i;

	if (numBytes < sizeof(DATA_RTXD_Obj))
10006970:	e51b3014 	ldr	r3, [fp, #-20]
10006974:	e353001d 	cmp	r3, #29
10006978:	8a000001 	bhi	10006984 <DATA_RTXD_Init+0x28>
		return((DATA_RTXD_Handle)NULL);
1000697c:	e3a03000 	mov	r3, #0
10006980:	ea000027 	b	10006a24 <DATA_RTXD_Init+0xc8>

	// assign the handle
	handle = (DATA_RTXD_Handle)pMemory;
10006984:	e51b3010 	ldr	r3, [fp, #-16]
10006988:	e50b300c 	str	r3, [fp, #-12]

	handle->data_rxd_num = 0;
1000698c:	e51b300c 	ldr	r3, [fp, #-12]
10006990:	e3a02000 	mov	r2, #0
10006994:	e5c32000 	strb	r2, [r3]
	for (i = 0; i<DATA_RXD_SIZE; i++)
10006998:	e3a03000 	mov	r3, #0
1000699c:	e54b3005 	strb	r3, [fp, #-5]
100069a0:	ea000007 	b	100069c4 <DATA_RTXD_Init+0x68>
	{
		handle->data_rxd[i] = 0;
100069a4:	e55b3005 	ldrb	r3, [fp, #-5]
100069a8:	e51b200c 	ldr	r2, [fp, #-12]
100069ac:	e0823003 	add	r3, r2, r3
100069b0:	e3a02000 	mov	r2, #0
100069b4:	e5c32001 	strb	r2, [r3, #1]

	// assign the handle
	handle = (DATA_RTXD_Handle)pMemory;

	handle->data_rxd_num = 0;
	for (i = 0; i<DATA_RXD_SIZE; i++)
100069b8:	e55b3005 	ldrb	r3, [fp, #-5]
100069bc:	e2833001 	add	r3, r3, #1
100069c0:	e54b3005 	strb	r3, [fp, #-5]
100069c4:	e55b3005 	ldrb	r3, [fp, #-5]
100069c8:	e353000c 	cmp	r3, #12
100069cc:	9afffff4 	bls	100069a4 <DATA_RTXD_Init+0x48>
	{
		handle->data_rxd[i] = 0;
	}

	handle->data_txd_num = DATA_TXD_SIZE;
100069d0:	e51b300c 	ldr	r3, [fp, #-12]
100069d4:	e3a0200d 	mov	r2, #13
100069d8:	e5c3200e 	strb	r2, [r3, #14]
	for (i = 0; i<DATA_TXD_SIZE; i++)
100069dc:	e3a03000 	mov	r3, #0
100069e0:	e54b3005 	strb	r3, [fp, #-5]
100069e4:	ea000007 	b	10006a08 <DATA_RTXD_Init+0xac>
	{
		handle->data_txd[i] = 0;
100069e8:	e55b3005 	ldrb	r3, [fp, #-5]
100069ec:	e51b200c 	ldr	r2, [fp, #-12]
100069f0:	e0823003 	add	r3, r2, r3
100069f4:	e3a02000 	mov	r2, #0
100069f8:	e5c3200f 	strb	r2, [r3, #15]
	{
		handle->data_rxd[i] = 0;
	}

	handle->data_txd_num = DATA_TXD_SIZE;
	for (i = 0; i<DATA_TXD_SIZE; i++)
100069fc:	e55b3005 	ldrb	r3, [fp, #-5]
10006a00:	e2833001 	add	r3, r3, #1
10006a04:	e54b3005 	strb	r3, [fp, #-5]
10006a08:	e55b3005 	ldrb	r3, [fp, #-5]
10006a0c:	e353000c 	cmp	r3, #12
10006a10:	9afffff4 	bls	100069e8 <DATA_RTXD_Init+0x8c>
	{
		handle->data_txd[i] = 0;
	}

	handle->time = 0;
10006a14:	e51b300c 	ldr	r3, [fp, #-12]
10006a18:	e3a02000 	mov	r2, #0
10006a1c:	e1c321bc 	strh	r2, [r3, #28]

	return(handle);
10006a20:	e51b300c 	ldr	r3, [fp, #-12]

}
10006a24:	e1a00003 	mov	r0, r3
10006a28:	e24bd000 	sub	sp, fp, #0
10006a2c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006a30:	e12fff1e 	bx	lr

10006a34 <EST_doCurrentCtrl>:

//! \brief     Determines if current control should be performed during motor identification
//! \param[in] handle  The estimator (EST) handle
//! \return    A boolean value denoting whether (true) or not (false) to perform current control
extern bool EST_doCurrentCtrl(EST_Handle handle)
{
10006a34:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006a38:	e28db000 	add	fp, sp, #0
10006a3c:	e24dd00c 	sub	sp, sp, #12
10006a40:	e50b0008 	str	r0, [fp, #-8]
	return 1;
10006a44:	e3a03001 	mov	r3, #1
}
10006a48:	e1a00003 	mov	r0, r3
10006a4c:	e24bd000 	sub	sp, fp, #0
10006a50:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006a54:	e12fff1e 	bx	lr

10006a58 <EST_doSpeedCtrl>:

//! \brief     Determines if speed control should be performed during motor identification
//! \param[in] handle  The estimator (EST) handle
//! \return    A boolean value denoting whether (true) or not (false) to perform speed control
extern bool EST_doSpeedCtrl(EST_Handle handle)
{
10006a58:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006a5c:	e28db000 	add	fp, sp, #0
10006a60:	e24dd00c 	sub	sp, sp, #12
10006a64:	e50b0008 	str	r0, [fp, #-8]
	return 1;
10006a68:	e3a03001 	mov	r3, #1
}
10006a6c:	e1a00003 	mov	r0, r3
10006a70:	e24bd000 	sub	sp, fp, #0
10006a74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006a78:	e12fff1e 	bx	lr

10006a7c <EST_getAngle_pu>:
//! float_t Rotor_Flux_Angle_pu = EST_getAngle_pu(handle);
//! \endcode
//! \param[in] handle  The estimator (EST) handle
//! \return    The angle value, pu, in IQ24.
extern float_t EST_getAngle_pu(EST_Handle handle)
{
10006a7c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006a80:	e28db000 	add	fp, sp, #0
10006a84:	e24dd00c 	sub	sp, sp, #12
10006a88:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006a8c:	e3a03000 	mov	r3, #0
10006a90:	ee073a90 	vmov	s15, r3
}
10006a94:	eeb00a67 	vmov.f32	s0, s15
10006a98:	e24bd000 	sub	sp, fp, #0
10006a9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006aa0:	e12fff1e 	bx	lr

10006aa4 <EST_getDcBus_pu>:
//! float_t Vbus_kV = _IQmpy(Vbus_pu,Vbus_pu_to_kV_sf);
//! \endcode
//! \param[in] handle  The estimator (EST) handle
//! \return    The DC bus value, pu
extern float_t EST_getDcBus_pu(EST_Handle handle)
{
10006aa4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006aa8:	e28db000 	add	fp, sp, #0
10006aac:	e24dd00c 	sub	sp, sp, #12
10006ab0:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006ab4:	e3a03000 	mov	r3, #0
10006ab8:	ee073a90 	vmov	s15, r3
}
10006abc:	eeb00a67 	vmov.f32	s0, s15
10006ac0:	e24bd000 	sub	sp, fp, #0
10006ac4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006ac8:	e12fff1e 	bx	lr

10006acc <EST_getForceAngleDelta_pu>:
//! \endcode
//! \note      Note that kHz is prefered to avoid overflow of IQ24 variables.
//! \param[in] handle  The estimator (EST) handle
//! \return    The force angle delta, pu. Minimum value of _IQ(0.0) and maximum of _IQ(1.0).
extern float_t EST_getForceAngleDelta_pu(EST_Handle handle)
{
10006acc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006ad0:	e28db000 	add	fp, sp, #0
10006ad4:	e24dd00c 	sub	sp, sp, #12
10006ad8:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006adc:	e3a03000 	mov	r3, #0
10006ae0:	ee073a90 	vmov	s15, r3
}
10006ae4:	eeb00a67 	vmov.f32	s0, s15
10006ae8:	e24bd000 	sub	sp, fp, #0
10006aec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006af0:	e12fff1e 	bx	lr

10006af4 <EST_get_krpm_to_pu_sf>:
//! float_t Speed_pu = _IQmpy(Speed_krpm,Speed_krpm_to_pu_sf);
//! \endcode
//! \param[in] handle  The estimator (EST) handle
//! \return    The krpm to pu scale factor. This value is in IQ24.
extern float_t EST_get_krpm_to_pu_sf(EST_Handle handle)
{
10006af4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006af8:	e28db000 	add	fp, sp, #0
10006afc:	e24dd00c 	sub	sp, sp, #12
10006b00:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006b04:	e3a03000 	mov	r3, #0
10006b08:	ee073a90 	vmov	s15, r3
}
10006b0c:	eeb00a67 	vmov.f32	s0, s15
10006b10:	e24bd000 	sub	sp, fp, #0
10006b14:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006b18:	e12fff1e 	bx	lr

10006b1c <EST_isError>:

//! \brief     Determines if there is an estimator error
//! \param[in] handle  The estimator (EST) handle
//! \return    A boolean value denoting if there is an estimator error (true) or not (false)
extern bool EST_isError(EST_Handle handle)
{
10006b1c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006b20:	e28db000 	add	fp, sp, #0
10006b24:	e24dd00c 	sub	sp, sp, #12
10006b28:	e50b0008 	str	r0, [fp, #-8]
	return 1;
10006b2c:	e3a03001 	mov	r3, #1
}
10006b30:	e1a00003 	mov	r0, r3
10006b34:	e24bd000 	sub	sp, fp, #0
10006b38:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006b3c:	e12fff1e 	bx	lr

10006b40 <EST_isIdle>:

//! \brief     Determines if the estimator is idle
//! \param[in] handle  The estimator (EST) handle
//! \return    A boolean value denoting if the estimator is idle (true) or not (false)
extern bool EST_isIdle(EST_Handle handle)
{
10006b40:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006b44:	e28db000 	add	fp, sp, #0
10006b48:	e24dd00c 	sub	sp, sp, #12
10006b4c:	e50b0008 	str	r0, [fp, #-8]
	return 1;
10006b50:	e3a03001 	mov	r3, #1
}
10006b54:	e1a00003 	mov	r0, r3
10006b58:	e24bd000 	sub	sp, fp, #0
10006b5c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006b60:	e12fff1e 	bx	lr

10006b64 <EST_isLockRotor>:

//! \brief     Determines if the estimator is waiting for the rotor to be locked
//! \param[in] handle  The estimator (EST) handle
//! \return    A boolean value denoting if the estimator is waiting for the rotor to be locked (true) or not (false)
extern bool EST_isLockRotor(EST_Handle handle)
{
10006b64:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006b68:	e28db000 	add	fp, sp, #0
10006b6c:	e24dd00c 	sub	sp, sp, #12
10006b70:	e50b0008 	str	r0, [fp, #-8]
	return 1;
10006b74:	e3a03001 	mov	r3, #1
}
10006b78:	e1a00003 	mov	r0, r3
10006b7c:	e24bd000 	sub	sp, fp, #0
10006b80:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006b84:	e12fff1e 	bx	lr

10006b88 <EST_isMotorIdentified>:

//! \brief     Determines if the motor has been identified
//! \param[in] handle  The estimator (EST) handle
//! \return    A boolean value denoting if the motor is identified (true) or not (false)
extern bool EST_isMotorIdentified(EST_Handle handle)
{
10006b88:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006b8c:	e28db000 	add	fp, sp, #0
10006b90:	e24dd00c 	sub	sp, sp, #12
10006b94:	e50b0008 	str	r0, [fp, #-8]
	return 1;
10006b98:	e3a03001 	mov	r3, #1
}
10006b9c:	e1a00003 	mov	r0, r3
10006ba0:	e24bd000 	sub	sp, fp, #0
10006ba4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006ba8:	e12fff1e 	bx	lr

10006bac <EST_isOnLine>:

//! \brief     Determines if the estimator is ready for online control
//! \param[in] handle  The estimator (EST) handle
//! \return    A boolean value denoting if the estimator is ready for online control (true) or not (false)
extern bool EST_isOnLine(EST_Handle handle)
{
10006bac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006bb0:	e28db000 	add	fp, sp, #0
10006bb4:	e24dd00c 	sub	sp, sp, #12
10006bb8:	e50b0008 	str	r0, [fp, #-8]
	return 1;
10006bbc:	e3a03001 	mov	r3, #1
}
10006bc0:	e1a00003 	mov	r0, r3
10006bc4:	e24bd000 	sub	sp, fp, #0
10006bc8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006bcc:	e12fff1e 	bx	lr

10006bd0 <EST_run>:
extern void EST_run(EST_Handle handle,
	const MATH_vec2 *pIab_pu,
	const MATH_vec2 *pVab_pu,
	const float_t dcBus_pu,
	const float_t speed_ref_pu)
{
10006bd0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006bd4:	e28db000 	add	fp, sp, #0
10006bd8:	e24dd01c 	sub	sp, sp, #28
10006bdc:	e50b0008 	str	r0, [fp, #-8]
10006be0:	e50b100c 	str	r1, [fp, #-12]
10006be4:	e50b2010 	str	r2, [fp, #-16]
10006be8:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
10006bec:	ed4b0a06 	vstr	s1, [fp, #-24]	; 0xffffffe8
	return ;
10006bf0:	e1a00000 	nop			; (mov r0, r0)
}
10006bf4:	e24bd000 	sub	sp, fp, #0
10006bf8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006bfc:	e12fff1e 	bx	lr

10006c00 <EST_setIdle>:


//! \brief     Sets the estimator to idle
//! \param[in] handle  The estimator (EST) handle
extern void EST_setIdle(EST_Handle handle)
{
10006c00:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006c04:	e28db000 	add	fp, sp, #0
10006c08:	e24dd00c 	sub	sp, sp, #12
10006c0c:	e50b0008 	str	r0, [fp, #-8]
	return ;
10006c10:	e1a00000 	nop			; (mov r0, r0)
}
10006c14:	e24bd000 	sub	sp, fp, #0
10006c18:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006c1c:	e12fff1e 	bx	lr

10006c20 <EST_setIdle_all>:


//! \brief     Sets the estimator and all of the subordinate estimators to idle
//! \param[in] handle    The estimator (EST) handle
extern void EST_setIdle_all(EST_Handle handle)
{
10006c20:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006c24:	e28db000 	add	fp, sp, #0
10006c28:	e24dd00c 	sub	sp, sp, #12
10006c2c:	e50b0008 	str	r0, [fp, #-8]
	return ;
10006c30:	e1a00000 	nop			; (mov r0, r0)
}
10006c34:	e24bd000 	sub	sp, fp, #0
10006c38:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006c3c:	e12fff1e 	bx	lr

10006c40 <EST_setId_ref_pu>:

//! \brief     Sets the direct current (Id) reference value in the estimator in per unit (pu), IQ24.
//! \param[in] handle     The estimator (EST) handle
//! \param[in] Id_ref_pu  The Id reference value, pu
extern void EST_setId_ref_pu(EST_Handle handle, const float_t Id_ref_pu)
{
10006c40:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006c44:	e28db000 	add	fp, sp, #0
10006c48:	e24dd00c 	sub	sp, sp, #12
10006c4c:	e50b0008 	str	r0, [fp, #-8]
10006c50:	ed0b0a03 	vstr	s0, [fp, #-12]
	return ;
10006c54:	e1a00000 	nop			; (mov r0, r0)
}
10006c58:	e24bd000 	sub	sp, fp, #0
10006c5c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006c60:	e12fff1e 	bx	lr

10006c64 <EST_setRs_pu>:

//! \brief     Sets the stator resistance value used in the estimator in per unit (pu), IQ30.
//! \param[in] handle   The estimator (EST) handle
//! \param[in] Rs_pu    The stator resistance value, pu
extern void EST_setRs_pu(EST_Handle handle, const float_t Rs_pu)
{
10006c64:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006c68:	e28db000 	add	fp, sp, #0
10006c6c:	e24dd00c 	sub	sp, sp, #12
10006c70:	e50b0008 	str	r0, [fp, #-8]
10006c74:	ed0b0a03 	vstr	s0, [fp, #-12]
	return ;
10006c78:	e1a00000 	nop			; (mov r0, r0)
}
10006c7c:	e24bd000 	sub	sp, fp, #0
10006c80:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006c84:	e12fff1e 	bx	lr

10006c88 <EST_updateId_ref_pu>:

//! \brief     Updates the Id reference value used for online stator resistance estimation in per unit (pu), IQ24.
//! \param[in] handle      The estimator (EST) handle
//! \param[in] pId_ref_pu  The pointer to the Id reference value, pu
extern void EST_updateId_ref_pu(EST_Handle handle, float_t *pId_ref_pu)
{
10006c88:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006c8c:	e28db000 	add	fp, sp, #0
10006c90:	e24dd00c 	sub	sp, sp, #12
10006c94:	e50b0008 	str	r0, [fp, #-8]
10006c98:	e50b100c 	str	r1, [fp, #-12]
	return ;
10006c9c:	e1a00000 	nop			; (mov r0, r0)
}
10006ca0:	e24bd000 	sub	sp, fp, #0
10006ca4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006ca8:	e12fff1e 	bx	lr

10006cac <EST_updateState>:
//! \brief      Updates the estimator state
//! \param[in]  handle        The estimator (EST) handle
//! \param[in]  Id_target_pu  The target Id current during each estimator state, pu IQ24
//! \return     A boolean value denoting if the state has changed (true) or not (false)
extern bool EST_updateState(EST_Handle handle, const float_t Id_target_pu)
{
10006cac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006cb0:	e28db000 	add	fp, sp, #0
10006cb4:	e24dd00c 	sub	sp, sp, #12
10006cb8:	e50b0008 	str	r0, [fp, #-8]
10006cbc:	ed0b0a03 	vstr	s0, [fp, #-12]
	return 1;
10006cc0:	e3a03001 	mov	r3, #1
}
10006cc4:	e1a00003 	mov	r0, r3
10006cc8:	e24bd000 	sub	sp, fp, #0
10006ccc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006cd0:	e12fff1e 	bx	lr

10006cd4 <EST_useZeroIq_ref>:

//! \brief     Determines if a zero Iq current reference should be used in the controller
//! \param[in] handle  The estimator (EST) handle
//! \return    A boolean value denoting if a zero Iq current reference should be used (true) or not (false)
extern bool EST_useZeroIq_ref(EST_Handle handle)
{
10006cd4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006cd8:	e28db000 	add	fp, sp, #0
10006cdc:	e24dd00c 	sub	sp, sp, #12
10006ce0:	e50b0008 	str	r0, [fp, #-8]
	return 1;
10006ce4:	e3a03001 	mov	r3, #1
}
10006ce8:	e1a00003 	mov	r0, r3
10006cec:	e24bd000 	sub	sp, fp, #0
10006cf0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006cf4:	e12fff1e 	bx	lr

10006cf8 <EST_getFlux_pu>:
//! Flux_VpHz = _IQmpy(Flux_pu, gFlux_pu_to_VpHz_sf);
//! \endcode
//! \param[in] handle  The estimator (EST) handle
//! \return    The flux value, pu
extern float_t EST_getFlux_pu(EST_Handle handle)
{
10006cf8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006cfc:	e28db000 	add	fp, sp, #0
10006d00:	e24dd00c 	sub	sp, sp, #12
10006d04:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006d08:	e3a03000 	mov	r3, #0
10006d0c:	ee073a90 	vmov	s15, r3
}
10006d10:	eeb00a67 	vmov.f32	s0, s15
10006d14:	e24bd000 	sub	sp, fp, #0
10006d18:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006d1c:	e12fff1e 	bx	lr

10006d20 <EST_getLs_d_H>:
{
	return 0;
}
#else
extern float_t EST_getLs_d_H(EST_Handle handle)
{
10006d20:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006d24:	e28db000 	add	fp, sp, #0
10006d28:	e24dd00c 	sub	sp, sp, #12
10006d2c:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006d30:	e3a03000 	mov	r3, #0
10006d34:	ee073a90 	vmov	s15, r3
}
10006d38:	eeb00a67 	vmov.f32	s0, s15
10006d3c:	e24bd000 	sub	sp, fp, #0
10006d40:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006d44:	e12fff1e 	bx	lr

10006d48 <EST_getLs_d_pu>:
//! float_t Ls_d_H = _IQmpy(Ls_d_pu, pu_to_h_sf);
//! \endcode
//! \param[in] handle  The estimator (EST) handle
//! \return    The direct stator inductance value, pu
extern float_t EST_getLs_d_pu(EST_Handle handle)
{
10006d48:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006d4c:	e28db000 	add	fp, sp, #0
10006d50:	e24dd00c 	sub	sp, sp, #12
10006d54:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006d58:	e3a03000 	mov	r3, #0
10006d5c:	ee073a90 	vmov	s15, r3
}
10006d60:	eeb00a67 	vmov.f32	s0, s15
10006d64:	e24bd000 	sub	sp, fp, #0
10006d68:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006d6c:	e12fff1e 	bx	lr

10006d70 <EST_getLs_q_H>:
{
	return 0;
}
#else
extern float_t EST_getLs_q_H(EST_Handle handle)
{
10006d70:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006d74:	e28db000 	add	fp, sp, #0
10006d78:	e24dd00c 	sub	sp, sp, #12
10006d7c:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006d80:	e3a03000 	mov	r3, #0
10006d84:	ee073a90 	vmov	s15, r3
}
10006d88:	eeb00a67 	vmov.f32	s0, s15
10006d8c:	e24bd000 	sub	sp, fp, #0
10006d90:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006d94:	e12fff1e 	bx	lr

10006d98 <EST_getLs_q_pu>:
//! float_t Ls_q_H = _IQmpy(Ls_q_pu, pu_to_h_sf);
//! \endcode
//! \param[in] handle  The estimator (EST) handle
//! \return    The stator inductance value, pu
extern float_t EST_getLs_q_pu(EST_Handle handle)
{
10006d98:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006d9c:	e28db000 	add	fp, sp, #0
10006da0:	e24dd00c 	sub	sp, sp, #12
10006da4:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006da8:	e3a03000 	mov	r3, #0
10006dac:	ee073a90 	vmov	s15, r3
}
10006db0:	eeb00a67 	vmov.f32	s0, s15
10006db4:	e24bd000 	sub	sp, fp, #0
10006db8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006dbc:	e12fff1e 	bx	lr

10006dc0 <EST_getRs_Ohm>:
{
	return 0;
}
#else
extern float_t EST_getRs_Ohm(EST_Handle handle)
{
10006dc0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006dc4:	e28db000 	add	fp, sp, #0
10006dc8:	e24dd00c 	sub	sp, sp, #12
10006dcc:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006dd0:	e3a03000 	mov	r3, #0
10006dd4:	ee073a90 	vmov	s15, r3
}
10006dd8:	eeb00a67 	vmov.f32	s0, s15
10006ddc:	e24bd000 	sub	sp, fp, #0
10006de0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006de4:	e12fff1e 	bx	lr

10006de8 <EST_getFm_pu>:
//! float_t Speed_kRPM = _IQmpy(Mechanical_Freq_kHz,khz_to_krpm_sf);
//! \endcode
//! \param[in] handle  The estimator (EST) handle
//! \return    The mechanical frequency, pu
extern float_t EST_getFm_pu(EST_Handle handle)
{
10006de8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006dec:	e28db000 	add	fp, sp, #0
10006df0:	e24dd00c 	sub	sp, sp, #12
10006df4:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006df8:	e3a03000 	mov	r3, #0
10006dfc:	ee073a90 	vmov	s15, r3
}
10006e00:	eeb00a67 	vmov.f32	s0, s15
10006e04:	e24bd000 	sub	sp, fp, #0
10006e08:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006e0c:	e12fff1e 	bx	lr

10006e10 <EST_getOneOverDcBus_pu>:

//! \brief     Gets the inverse of the DC bus voltage in per unit (pu), IQ24.
//! \param[in] handle  The estimator (EST) handle
//! \return    The inverse of the DC bus voltage, pu
extern float_t EST_getOneOverDcBus_pu(EST_Handle handle)
{
10006e10:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006e14:	e28db000 	add	fp, sp, #0
10006e18:	e24dd00c 	sub	sp, sp, #12
10006e1c:	e50b0008 	str	r0, [fp, #-8]
	return 0.0;
10006e20:	e3a03000 	mov	r3, #0
10006e24:	ee073a90 	vmov	s15, r3
}
10006e28:	eeb00a67 	vmov.f32	s0, s15
10006e2c:	e24bd000 	sub	sp, fp, #0
10006e30:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006e34:	e12fff1e 	bx	lr

10006e38 <EST_setIq_ref_pu>:

//! \brief     Sets the quadrature current (Iq) reference value in the estimator in per unit (pu), IQ24.
//! \param[in] handle     The estimator (EST) handle
//! \param[in] Iq_ref_pu  The Iq reference value, pu
extern void EST_setIq_ref_pu(EST_Handle handle,const float_t Iq_ref_pu)
{
10006e38:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006e3c:	e28db000 	add	fp, sp, #0
10006e40:	e24dd00c 	sub	sp, sp, #12
10006e44:	e50b0008 	str	r0, [fp, #-8]
10006e48:	ed0b0a03 	vstr	s0, [fp, #-12]
	return;
10006e4c:	e1a00000 	nop			; (mov r0, r0)
}
10006e50:	e24bd000 	sub	sp, fp, #0
10006e54:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006e58:	e12fff1e 	bx	lr

10006e5c <FILTER_FO_getDenCoeffs>:
// **************************************************************************
// the functions


void FILTER_FO_getDenCoeffs(FILTER_FO_Handle handle,float_t *pa1)
{
10006e5c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006e60:	e28db000 	add	fp, sp, #0
10006e64:	e24dd014 	sub	sp, sp, #20
10006e68:	e50b0010 	str	r0, [fp, #-16]
10006e6c:	e50b1014 	str	r1, [fp, #-20]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
10006e70:	e51b3010 	ldr	r3, [fp, #-16]
10006e74:	e50b3008 	str	r3, [fp, #-8]


  *pa1 = obj->a1;
10006e78:	e51b3008 	ldr	r3, [fp, #-8]
10006e7c:	e5932000 	ldr	r2, [r3]
10006e80:	e51b3014 	ldr	r3, [fp, #-20]
10006e84:	e5832000 	str	r2, [r3]

  return;
10006e88:	e1a00000 	nop			; (mov r0, r0)
} // end of FILTER_FO_getDenCoeffs() function
10006e8c:	e24bd000 	sub	sp, fp, #0
10006e90:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006e94:	e12fff1e 	bx	lr

10006e98 <FILTER_FO_getInitialConditions>:


void FILTER_FO_getInitialConditions(FILTER_FO_Handle handle,float_t *px1,float_t *py1)
{
10006e98:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006e9c:	e28db000 	add	fp, sp, #0
10006ea0:	e24dd01c 	sub	sp, sp, #28
10006ea4:	e50b0010 	str	r0, [fp, #-16]
10006ea8:	e50b1014 	str	r1, [fp, #-20]
10006eac:	e50b2018 	str	r2, [fp, #-24]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
10006eb0:	e51b3010 	ldr	r3, [fp, #-16]
10006eb4:	e50b3008 	str	r3, [fp, #-8]


  *px1 = obj->x1;
10006eb8:	e51b3008 	ldr	r3, [fp, #-8]
10006ebc:	e593200c 	ldr	r2, [r3, #12]
10006ec0:	e51b3014 	ldr	r3, [fp, #-20]
10006ec4:	e5832000 	str	r2, [r3]

  *py1 = obj->y1;
10006ec8:	e51b3008 	ldr	r3, [fp, #-8]
10006ecc:	e5932010 	ldr	r2, [r3, #16]
10006ed0:	e51b3018 	ldr	r3, [fp, #-24]
10006ed4:	e5832000 	str	r2, [r3]

  return;
10006ed8:	e1a00000 	nop			; (mov r0, r0)
} // end of FILTER_FO_getInitialConditions() function
10006edc:	e24bd000 	sub	sp, fp, #0
10006ee0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006ee4:	e12fff1e 	bx	lr

10006ee8 <FILTER_FO_getNumCoeffs>:


void FILTER_FO_getNumCoeffs(FILTER_FO_Handle handle,float_t *pb0,float_t *pb1)
{
10006ee8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006eec:	e28db000 	add	fp, sp, #0
10006ef0:	e24dd01c 	sub	sp, sp, #28
10006ef4:	e50b0010 	str	r0, [fp, #-16]
10006ef8:	e50b1014 	str	r1, [fp, #-20]
10006efc:	e50b2018 	str	r2, [fp, #-24]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
10006f00:	e51b3010 	ldr	r3, [fp, #-16]
10006f04:	e50b3008 	str	r3, [fp, #-8]


  *pb0 = obj->b0;
10006f08:	e51b3008 	ldr	r3, [fp, #-8]
10006f0c:	e5932004 	ldr	r2, [r3, #4]
10006f10:	e51b3014 	ldr	r3, [fp, #-20]
10006f14:	e5832000 	str	r2, [r3]
  *pb1 = obj->b1;
10006f18:	e51b3008 	ldr	r3, [fp, #-8]
10006f1c:	e5932008 	ldr	r2, [r3, #8]
10006f20:	e51b3018 	ldr	r3, [fp, #-24]
10006f24:	e5832000 	str	r2, [r3]

  return;
10006f28:	e1a00000 	nop			; (mov r0, r0)
} // end of FILTER_FO_getNumCoeffs() function
10006f2c:	e24bd000 	sub	sp, fp, #0
10006f30:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006f34:	e12fff1e 	bx	lr

10006f38 <FILTER_FO_init>:


FILTER_FO_Handle FILTER_FO_init(void *pMemory,const size_t numBytes)
{
10006f38:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006f3c:	e28db000 	add	fp, sp, #0
10006f40:	e24dd014 	sub	sp, sp, #20
10006f44:	e50b0010 	str	r0, [fp, #-16]
10006f48:	e50b1014 	str	r1, [fp, #-20]
  FILTER_FO_Handle handle;


  if(numBytes < sizeof(FILTER_FO_Obj))
10006f4c:	e51b3014 	ldr	r3, [fp, #-20]
10006f50:	e3530013 	cmp	r3, #19
10006f54:	8a000001 	bhi	10006f60 <FILTER_FO_init+0x28>
    return((FILTER_FO_Handle)NULL);
10006f58:	e3a03000 	mov	r3, #0
10006f5c:	ea000002 	b	10006f6c <FILTER_FO_init+0x34>

  // assign the handle
  handle = (FILTER_FO_Handle)pMemory;
10006f60:	e51b3010 	ldr	r3, [fp, #-16]
10006f64:	e50b3008 	str	r3, [fp, #-8]

  return(handle);
10006f68:	e51b3008 	ldr	r3, [fp, #-8]
} // end of FILTER_FO_init() function
10006f6c:	e1a00003 	mov	r0, r3
10006f70:	e24bd000 	sub	sp, fp, #0
10006f74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006f78:	e12fff1e 	bx	lr

10006f7c <FILTER_FO_setDenCoeffs>:


void FILTER_FO_setDenCoeffs(FILTER_FO_Handle handle,const float_t a1)
{
10006f7c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006f80:	e28db000 	add	fp, sp, #0
10006f84:	e24dd014 	sub	sp, sp, #20
10006f88:	e50b0010 	str	r0, [fp, #-16]
10006f8c:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
10006f90:	e51b3010 	ldr	r3, [fp, #-16]
10006f94:	e50b3008 	str	r3, [fp, #-8]


  obj->a1 = a1;
10006f98:	e51b3008 	ldr	r3, [fp, #-8]
10006f9c:	e51b2014 	ldr	r2, [fp, #-20]
10006fa0:	e5832000 	str	r2, [r3]

  return;
10006fa4:	e1a00000 	nop			; (mov r0, r0)
} // end of FILTER_FO_setDenCoeffs() function
10006fa8:	e24bd000 	sub	sp, fp, #0
10006fac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006fb0:	e12fff1e 	bx	lr

10006fb4 <FILTER_FO_setInitialConditions>:


void FILTER_FO_setInitialConditions(FILTER_FO_Handle handle,const float_t x1,const float_t y1)
{
10006fb4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006fb8:	e28db000 	add	fp, sp, #0
10006fbc:	e24dd01c 	sub	sp, sp, #28
10006fc0:	e50b0010 	str	r0, [fp, #-16]
10006fc4:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
10006fc8:	ed4b0a06 	vstr	s1, [fp, #-24]	; 0xffffffe8
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
10006fcc:	e51b3010 	ldr	r3, [fp, #-16]
10006fd0:	e50b3008 	str	r3, [fp, #-8]


  obj->x1 = x1;
10006fd4:	e51b3008 	ldr	r3, [fp, #-8]
10006fd8:	e51b2014 	ldr	r2, [fp, #-20]
10006fdc:	e583200c 	str	r2, [r3, #12]

  obj->y1 = y1;
10006fe0:	e51b3008 	ldr	r3, [fp, #-8]
10006fe4:	e51b2018 	ldr	r2, [fp, #-24]
10006fe8:	e5832010 	str	r2, [r3, #16]

  return;
10006fec:	e1a00000 	nop			; (mov r0, r0)
} // end of FILTER_FO_setInitialConditions() function
10006ff0:	e24bd000 	sub	sp, fp, #0
10006ff4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006ff8:	e12fff1e 	bx	lr

10006ffc <FILTER_FO_setNumCoeffs>:


void FILTER_FO_setNumCoeffs(FILTER_FO_Handle handle,const float_t b0,const float_t b1)
{
10006ffc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007000:	e28db000 	add	fp, sp, #0
10007004:	e24dd01c 	sub	sp, sp, #28
10007008:	e50b0010 	str	r0, [fp, #-16]
1000700c:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
10007010:	ed4b0a06 	vstr	s1, [fp, #-24]	; 0xffffffe8
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
10007014:	e51b3010 	ldr	r3, [fp, #-16]
10007018:	e50b3008 	str	r3, [fp, #-8]


  obj->b0 = b0;
1000701c:	e51b3008 	ldr	r3, [fp, #-8]
10007020:	e51b2014 	ldr	r2, [fp, #-20]
10007024:	e5832004 	str	r2, [r3, #4]
  obj->b1 = b1;
10007028:	e51b3008 	ldr	r3, [fp, #-8]
1000702c:	e51b2018 	ldr	r2, [fp, #-24]
10007030:	e5832008 	str	r2, [r3, #8]

  return;
10007034:	e1a00000 	nop			; (mov r0, r0)
} // end of FILTER_FO_setNumCoeffs() function
10007038:	e24bd000 	sub	sp, fp, #0
1000703c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007040:	e12fff1e 	bx	lr

10007044 <HAL_getNumCurrentSensors>:

//! \brief     Gets the number of current sensors
//! \param[in] handle  The hardware abstraction layer (HAL) handle
//! \return    The number of current sensors
static inline uint_least8_t HAL_getNumCurrentSensors(HAL_Handle handle)
{
10007044:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007048:	e28db000 	add	fp, sp, #0
1000704c:	e24dd014 	sub	sp, sp, #20
10007050:	e50b0010 	str	r0, [fp, #-16]
  HAL_Obj *obj = (HAL_Obj *)handle;
10007054:	e51b3010 	ldr	r3, [fp, #-16]
10007058:	e50b3008 	str	r3, [fp, #-8]
  

  return(obj->numCurrentSensors);
1000705c:	e51b3008 	ldr	r3, [fp, #-8]
10007060:	e5d33104 	ldrb	r3, [r3, #260]	; 0x104
} // end of HAL_getNumCurrentSensors() function
10007064:	e1a00003 	mov	r0, r3
10007068:	e24bd000 	sub	sp, fp, #0
1000706c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007070:	e12fff1e 	bx	lr

10007074 <HAL_getNumVoltageSensors>:

//! \brief     Gets the number of voltage sensors
//! \param[in] handle  The hardware abstraction layer (HAL) handle
//! \return    The number of voltage sensors
static inline uint_least8_t HAL_getNumVoltageSensors(HAL_Handle handle)
{
10007074:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007078:	e28db000 	add	fp, sp, #0
1000707c:	e24dd014 	sub	sp, sp, #20
10007080:	e50b0010 	str	r0, [fp, #-16]
  HAL_Obj *obj = (HAL_Obj *)handle;
10007084:	e51b3010 	ldr	r3, [fp, #-16]
10007088:	e50b3008 	str	r3, [fp, #-8]
  

  return(obj->numVoltageSensors);
1000708c:	e51b3008 	ldr	r3, [fp, #-8]
10007090:	e5d33105 	ldrb	r3, [r3, #261]	; 0x105
} // end of HAL_getNumVoltageSensors() function
10007094:	e1a00003 	mov	r0, r3
10007098:	e24bd000 	sub	sp, fp, #0
1000709c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100070a0:	e12fff1e 	bx	lr

100070a4 <HAL_setBias>:
//! \param[in] bias          The ADC bias value
static inline void HAL_setBias(HAL_Handle handle,
                               const HAL_SensorType_e sensorType,
                               uint_least8_t sensorNumber,
                               const float_t bias)//! \Mod By Dl.K
{
100070a4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100070a8:	e28db000 	add	fp, sp, #0
100070ac:	e24dd01c 	sub	sp, sp, #28
100070b0:	e50b0010 	str	r0, [fp, #-16]
100070b4:	e1a03001 	mov	r3, r1
100070b8:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
100070bc:	e54b3011 	strb	r3, [fp, #-17]
100070c0:	e1a03002 	mov	r3, r2
100070c4:	e54b3012 	strb	r3, [fp, #-18]
  HAL_Obj *obj = (HAL_Obj *)handle;
100070c8:	e51b3010 	ldr	r3, [fp, #-16]
100070cc:	e50b3008 	str	r3, [fp, #-8]


  if(sensorType == HAL_SensorType_Current)
100070d0:	e55b3011 	ldrb	r3, [fp, #-17]
100070d4:	e3530000 	cmp	r3, #0
100070d8:	1a000007 	bne	100070fc <HAL_setBias+0x58>
    {
      obj->adcBias.I.value[sensorNumber] = bias;
100070dc:	e55b3012 	ldrb	r3, [fp, #-18]
100070e0:	e51b2008 	ldr	r2, [fp, #-8]
100070e4:	e2833036 	add	r3, r3, #54	; 0x36
100070e8:	e1a03103 	lsl	r3, r3, #2
100070ec:	e0823003 	add	r3, r2, r3
100070f0:	e51b2018 	ldr	r2, [fp, #-24]
100070f4:	e5832000 	str	r2, [r3]
100070f8:	ea000009 	b	10007124 <HAL_setBias+0x80>
    }
  else if(sensorType == HAL_SensorType_Voltage)
100070fc:	e55b3011 	ldrb	r3, [fp, #-17]
10007100:	e3530001 	cmp	r3, #1
10007104:	1a000006 	bne	10007124 <HAL_setBias+0x80>
    {
      obj->adcBias.V.value[sensorNumber] = bias;
10007108:	e55b3012 	ldrb	r3, [fp, #-18]
1000710c:	e51b2008 	ldr	r2, [fp, #-8]
10007110:	e2833038 	add	r3, r3, #56	; 0x38
10007114:	e1a03103 	lsl	r3, r3, #2
10007118:	e0823003 	add	r3, r2, r3
1000711c:	e51b2018 	ldr	r2, [fp, #-24]
10007120:	e5832004 	str	r2, [r3, #4]
    }

  return;
10007124:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setBias() function
10007128:	e24bd000 	sub	sp, fp, #0
1000712c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007130:	e12fff1e 	bx	lr

10007134 <HAL_setCurrentScaleFactor>:

//! \brief     Sets the current scale factor in the hardware abstraction layer
//! \param[in] handle      The hardware abstraction layer (HAL) handle
//! \param[in] current_sf  The current scale factor
static inline void HAL_setCurrentScaleFactor(HAL_Handle handle,const float_t current_sf)//! \Mod By Dl.K
{
10007134:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007138:	e28db000 	add	fp, sp, #0
1000713c:	e24dd014 	sub	sp, sp, #20
10007140:	e50b0010 	str	r0, [fp, #-16]
10007144:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  HAL_Obj *obj = (HAL_Obj *)handle;
10007148:	e51b3010 	ldr	r3, [fp, #-16]
1000714c:	e50b3008 	str	r3, [fp, #-8]
  

  obj->current_sf = current_sf;
10007150:	e51b3008 	ldr	r3, [fp, #-8]
10007154:	e51b2014 	ldr	r2, [fp, #-20]
10007158:	e58320fc 	str	r2, [r3, #252]	; 0xfc

  return;
1000715c:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setCurrentScaleFactor() function
10007160:	e24bd000 	sub	sp, fp, #0
10007164:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007168:	e12fff1e 	bx	lr

1000716c <HAL_setNumCurrentSensors>:

//! \brief     Sets the number of current sensors
//! \param[in] handle             The hardware abstraction layer (HAL) handle
//! \param[in] numCurrentSensors  The number of current sensors
static inline void HAL_setNumCurrentSensors(HAL_Handle handle,const uint_least8_t numCurrentSensors)
{
1000716c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007170:	e28db000 	add	fp, sp, #0
10007174:	e24dd014 	sub	sp, sp, #20
10007178:	e50b0010 	str	r0, [fp, #-16]
1000717c:	e1a03001 	mov	r3, r1
10007180:	e54b3011 	strb	r3, [fp, #-17]
  HAL_Obj *obj = (HAL_Obj *)handle;
10007184:	e51b3010 	ldr	r3, [fp, #-16]
10007188:	e50b3008 	str	r3, [fp, #-8]
  

  obj->numCurrentSensors = numCurrentSensors;
1000718c:	e51b3008 	ldr	r3, [fp, #-8]
10007190:	e55b2011 	ldrb	r2, [fp, #-17]
10007194:	e5c32104 	strb	r2, [r3, #260]	; 0x104

  return;
10007198:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setNumCurrentSensors() function
1000719c:	e24bd000 	sub	sp, fp, #0
100071a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100071a4:	e12fff1e 	bx	lr

100071a8 <HAL_setNumVoltageSensors>:

//! \brief     Sets the number of voltage sensors
//! \param[in] handle             The hardware abstraction layer (HAL) handle
//! \param[in] numVoltageSensors  The number of voltage sensors
static inline void HAL_setNumVoltageSensors(HAL_Handle handle,const uint_least8_t numVoltageSensors)
{
100071a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100071ac:	e28db000 	add	fp, sp, #0
100071b0:	e24dd014 	sub	sp, sp, #20
100071b4:	e50b0010 	str	r0, [fp, #-16]
100071b8:	e1a03001 	mov	r3, r1
100071bc:	e54b3011 	strb	r3, [fp, #-17]
  HAL_Obj *obj = (HAL_Obj *)handle;
100071c0:	e51b3010 	ldr	r3, [fp, #-16]
100071c4:	e50b3008 	str	r3, [fp, #-8]
  

  obj->numVoltageSensors = numVoltageSensors;
100071c8:	e51b3008 	ldr	r3, [fp, #-8]
100071cc:	e55b2011 	ldrb	r2, [fp, #-17]
100071d0:	e5c32105 	strb	r2, [r3, #261]	; 0x105

  return;
100071d4:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setNumVoltageSensors() function
100071d8:	e24bd000 	sub	sp, fp, #0
100071dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100071e0:	e12fff1e 	bx	lr

100071e4 <HAL_setOffsetBeta_lp_pu>:
//! \param[in] beta_lp_pu    The value used to set the low pass filter pole, pu
static inline void HAL_setOffsetBeta_lp_pu(HAL_Handle handle,
                                           const HAL_SensorType_e sensorType,
                                           const uint_least8_t sensorNumber,
                                           const float_t beta_lp_pu)//! \Mod By Dl.K
{
100071e4:	e92d4800 	push	{fp, lr}
100071e8:	e28db004 	add	fp, sp, #4
100071ec:	e24dd018 	sub	sp, sp, #24
100071f0:	e50b0010 	str	r0, [fp, #-16]
100071f4:	e1a03001 	mov	r3, r1
100071f8:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
100071fc:	e54b3011 	strb	r3, [fp, #-17]
10007200:	e1a03002 	mov	r3, r2
10007204:	e54b3012 	strb	r3, [fp, #-18]
  HAL_Obj *obj = (HAL_Obj *)handle;
10007208:	e51b3010 	ldr	r3, [fp, #-16]
1000720c:	e50b3008 	str	r3, [fp, #-8]

  if(sensorType == HAL_SensorType_Current)
10007210:	e55b3011 	ldrb	r3, [fp, #-17]
10007214:	e3530000 	cmp	r3, #0
10007218:	1a000006 	bne	10007238 <HAL_setOffsetBeta_lp_pu+0x54>
    {
      OFFSET_setBeta(obj->offsetHandle_I[sensorNumber],beta_lp_pu);
1000721c:	e55b2012 	ldrb	r2, [fp, #-18]
10007220:	e51b3008 	ldr	r3, [fp, #-8]
10007224:	e7933102 	ldr	r3, [r3, r2, lsl #2]
10007228:	e1a00003 	mov	r0, r3
1000722c:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
10007230:	eb000180 	bl	10007838 <OFFSET_setBeta>
10007234:	ea00000b 	b	10007268 <HAL_setOffsetBeta_lp_pu+0x84>
    }
  else if(sensorType == HAL_SensorType_Voltage)
10007238:	e55b3011 	ldrb	r3, [fp, #-17]
1000723c:	e3530001 	cmp	r3, #1
10007240:	1a000008 	bne	10007268 <HAL_setOffsetBeta_lp_pu+0x84>
    {
      OFFSET_setBeta(obj->offsetHandle_V[sensorNumber],beta_lp_pu);
10007244:	e55b3012 	ldrb	r3, [fp, #-18]
10007248:	e51b2008 	ldr	r2, [fp, #-8]
1000724c:	e283301a 	add	r3, r3, #26
10007250:	e1a03103 	lsl	r3, r3, #2
10007254:	e0823003 	add	r3, r2, r3
10007258:	e5933004 	ldr	r3, [r3, #4]
1000725c:	e1a00003 	mov	r0, r3
10007260:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
10007264:	eb000173 	bl	10007838 <OFFSET_setBeta>
    }

  return;
10007268:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setOffsetBeta_lp_pu() function
1000726c:	e24bd004 	sub	sp, fp, #4
10007270:	e8bd8800 	pop	{fp, pc}

10007274 <HAL_setOffsetInitCond>:
//! \param[in] initCond      The initial condition value
static inline void HAL_setOffsetInitCond(HAL_Handle handle,
                                         const HAL_SensorType_e sensorType,
                                         const uint_least8_t sensorNumber,
                                         const float_t initCond)//! \Mod By Dl.K
{
10007274:	e92d4800 	push	{fp, lr}
10007278:	e28db004 	add	fp, sp, #4
1000727c:	e24dd018 	sub	sp, sp, #24
10007280:	e50b0010 	str	r0, [fp, #-16]
10007284:	e1a03001 	mov	r3, r1
10007288:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
1000728c:	e54b3011 	strb	r3, [fp, #-17]
10007290:	e1a03002 	mov	r3, r2
10007294:	e54b3012 	strb	r3, [fp, #-18]
  HAL_Obj *obj = (HAL_Obj *)handle;
10007298:	e51b3010 	ldr	r3, [fp, #-16]
1000729c:	e50b3008 	str	r3, [fp, #-8]

  if(sensorType == HAL_SensorType_Current)
100072a0:	e55b3011 	ldrb	r3, [fp, #-17]
100072a4:	e3530000 	cmp	r3, #0
100072a8:	1a000006 	bne	100072c8 <HAL_setOffsetInitCond+0x54>
    {
      OFFSET_setInitCond(obj->offsetHandle_I[sensorNumber],initCond);
100072ac:	e55b2012 	ldrb	r2, [fp, #-18]
100072b0:	e51b3008 	ldr	r3, [fp, #-8]
100072b4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
100072b8:	e1a00003 	mov	r0, r3
100072bc:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
100072c0:	eb000179 	bl	100078ac <OFFSET_setInitCond>
100072c4:	ea00000b 	b	100072f8 <HAL_setOffsetInitCond+0x84>
    }
  else if(sensorType == HAL_SensorType_Voltage)
100072c8:	e55b3011 	ldrb	r3, [fp, #-17]
100072cc:	e3530001 	cmp	r3, #1
100072d0:	1a000008 	bne	100072f8 <HAL_setOffsetInitCond+0x84>
    {
      OFFSET_setInitCond(obj->offsetHandle_V[sensorNumber],initCond);
100072d4:	e55b3012 	ldrb	r3, [fp, #-18]
100072d8:	e51b2008 	ldr	r2, [fp, #-8]
100072dc:	e283301a 	add	r3, r3, #26
100072e0:	e1a03103 	lsl	r3, r3, #2
100072e4:	e0823003 	add	r3, r2, r3
100072e8:	e5933004 	ldr	r3, [r3, #4]
100072ec:	e1a00003 	mov	r0, r3
100072f0:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
100072f4:	eb00016c 	bl	100078ac <OFFSET_setInitCond>
    }

  return;
100072f8:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setOffsetInitCond() function
100072fc:	e24bd004 	sub	sp, fp, #4
10007300:	e8bd8800 	pop	{fp, pc}

10007304 <HAL_setOffsetValue>:
//! \param[in] value         The initial offset value
static inline void HAL_setOffsetValue(HAL_Handle handle,
                                      const HAL_SensorType_e sensorType,
                                      const uint_least8_t sensorNumber,
                                      const float_t value)//! \Mod By Dl.K
{
10007304:	e92d4800 	push	{fp, lr}
10007308:	e28db004 	add	fp, sp, #4
1000730c:	e24dd018 	sub	sp, sp, #24
10007310:	e50b0010 	str	r0, [fp, #-16]
10007314:	e1a03001 	mov	r3, r1
10007318:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
1000731c:	e54b3011 	strb	r3, [fp, #-17]
10007320:	e1a03002 	mov	r3, r2
10007324:	e54b3012 	strb	r3, [fp, #-18]
  HAL_Obj *obj = (HAL_Obj *)handle;
10007328:	e51b3010 	ldr	r3, [fp, #-16]
1000732c:	e50b3008 	str	r3, [fp, #-8]

  if(sensorType == HAL_SensorType_Current)
10007330:	e55b3011 	ldrb	r3, [fp, #-17]
10007334:	e3530000 	cmp	r3, #0
10007338:	1a000006 	bne	10007358 <HAL_setOffsetValue+0x54>
    {
      OFFSET_setOffset(obj->offsetHandle_I[sensorNumber],value);
1000733c:	e55b2012 	ldrb	r2, [fp, #-18]
10007340:	e51b3008 	ldr	r3, [fp, #-8]
10007344:	e7933102 	ldr	r3, [r3, r2, lsl #2]
10007348:	e1a00003 	mov	r0, r3
1000734c:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
10007350:	eb000168 	bl	100078f8 <OFFSET_setOffset>
10007354:	ea00000b 	b	10007388 <HAL_setOffsetValue+0x84>
    }
  else if(sensorType == HAL_SensorType_Voltage)
10007358:	e55b3011 	ldrb	r3, [fp, #-17]
1000735c:	e3530001 	cmp	r3, #1
10007360:	1a000008 	bne	10007388 <HAL_setOffsetValue+0x84>
    {
      OFFSET_setOffset(obj->offsetHandle_V[sensorNumber],value);
10007364:	e55b3012 	ldrb	r3, [fp, #-18]
10007368:	e51b2008 	ldr	r2, [fp, #-8]
1000736c:	e283301a 	add	r3, r3, #26
10007370:	e1a03103 	lsl	r3, r3, #2
10007374:	e0823003 	add	r3, r2, r3
10007378:	e5933004 	ldr	r3, [r3, #4]
1000737c:	e1a00003 	mov	r0, r3
10007380:	ed1b0a06 	vldr	s0, [fp, #-24]	; 0xffffffe8
10007384:	eb00015b 	bl	100078f8 <OFFSET_setOffset>
    }

  return;
10007388:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setOffsetValue() function
1000738c:	e24bd004 	sub	sp, fp, #4
10007390:	e8bd8800 	pop	{fp, pc}

10007394 <HAL_setVoltageScaleFactor>:

//! \brief     Sets the voltage scale factor in the hardware abstraction layer
//! \param[in] handle      The hardware abstraction layer (HAL) handle
//! \param[in] voltage_sf  The voltage scale factor
static inline void HAL_setVoltageScaleFactor(HAL_Handle handle,const float_t voltage_sf)//! \Mod By Dl.K
{
10007394:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007398:	e28db000 	add	fp, sp, #0
1000739c:	e24dd014 	sub	sp, sp, #20
100073a0:	e50b0010 	str	r0, [fp, #-16]
100073a4:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  HAL_Obj *obj = (HAL_Obj *)handle;
100073a8:	e51b3010 	ldr	r3, [fp, #-16]
100073ac:	e50b3008 	str	r3, [fp, #-8]
  
  obj->voltage_sf = voltage_sf;
100073b0:	e51b3008 	ldr	r3, [fp, #-8]
100073b4:	e51b2014 	ldr	r2, [fp, #-20]
100073b8:	e5832100 	str	r2, [r3, #256]	; 0x100

  return;
100073bc:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setVoltageScaleFactor() function
100073c0:	e24bd000 	sub	sp, fp, #0
100073c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100073c8:	e12fff1e 	bx	lr

100073cc <HAL_init>:

// **************************************************************************
// the functions

HAL_Handle HAL_init(void *pMemory,const size_t numBytes)
{
100073cc:	e92d4810 	push	{r4, fp, lr}
100073d0:	e28db008 	add	fp, sp, #8
100073d4:	e24dd01c 	sub	sp, sp, #28
100073d8:	e50b0020 	str	r0, [fp, #-32]
100073dc:	e50b1024 	str	r1, [fp, #-36]	; 0x24
  uint_least8_t cnt;
  HAL_Handle handle;
  HAL_Obj *obj;


  if(numBytes < sizeof(HAL_Obj))
100073e0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100073e4:	e3530f42 	cmp	r3, #264	; 0x108
100073e8:	2a000001 	bcs	100073f4 <HAL_init+0x28>
    return((HAL_Handle)NULL);
100073ec:	e3a03000 	mov	r3, #0
100073f0:	ea000032 	b	100074c0 <HAL_init+0xf4>


  // assign the handle
  handle = (HAL_Handle)pMemory;
100073f4:	e51b3020 	ldr	r3, [fp, #-32]
100073f8:	e50b3014 	str	r3, [fp, #-20]


  // assign the object
  obj = (HAL_Obj *)handle;
100073fc:	e51b3014 	ldr	r3, [fp, #-20]
10007400:	e50b3018 	str	r3, [fp, #-24]

  // initialize the current offset estimator handles
  for(cnt=0;cnt<USER_NUM_CURRENT_SENSORS;cnt++)
10007404:	e3a03000 	mov	r3, #0
10007408:	e54b300d 	strb	r3, [fp, #-13]
1000740c:	ea00000f 	b	10007450 <HAL_init+0x84>
    {
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
10007410:	e55b400d 	ldrb	r4, [fp, #-13]
10007414:	e55b300d 	ldrb	r3, [fp, #-13]
10007418:	e1a03283 	lsl	r3, r3, #5
1000741c:	e2833008 	add	r3, r3, #8
10007420:	e51b2018 	ldr	r2, [fp, #-24]
10007424:	e0823003 	add	r3, r2, r3
10007428:	e2833004 	add	r3, r3, #4
1000742c:	e1a00003 	mov	r0, r3
10007430:	e3a01020 	mov	r1, #32
10007434:	eb0000e5 	bl	100077d0 <OFFSET_init>
10007438:	e1a02000 	mov	r2, r0
1000743c:	e51b3018 	ldr	r3, [fp, #-24]
10007440:	e7832104 	str	r2, [r3, r4, lsl #2]

  // assign the object
  obj = (HAL_Obj *)handle;

  // initialize the current offset estimator handles
  for(cnt=0;cnt<USER_NUM_CURRENT_SENSORS;cnt++)
10007444:	e55b300d 	ldrb	r3, [fp, #-13]
10007448:	e2833001 	add	r3, r3, #1
1000744c:	e54b300d 	strb	r3, [fp, #-13]
10007450:	e55b300d 	ldrb	r3, [fp, #-13]
10007454:	e3530002 	cmp	r3, #2
10007458:	9affffec 	bls	10007410 <HAL_init+0x44>
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
    }


  // initialize the voltage offset estimator handles
  for(cnt=0;cnt<USER_NUM_VOLTAGE_SENSORS;cnt++)
1000745c:	e3a03000 	mov	r3, #0
10007460:	e54b300d 	strb	r3, [fp, #-13]
10007464:	ea000011 	b	100074b0 <HAL_init+0xe4>
    {
      obj->offsetHandle_V[cnt] = OFFSET_init(&obj->offset_V[cnt],sizeof(obj->offset_V[cnt]));
10007468:	e55b400d 	ldrb	r4, [fp, #-13]
1000746c:	e55b300d 	ldrb	r3, [fp, #-13]
10007470:	e1a03283 	lsl	r3, r3, #5
10007474:	e2833078 	add	r3, r3, #120	; 0x78
10007478:	e51b2018 	ldr	r2, [fp, #-24]
1000747c:	e0823003 	add	r3, r2, r3
10007480:	e1a00003 	mov	r0, r3
10007484:	e3a01020 	mov	r1, #32
10007488:	eb0000d0 	bl	100077d0 <OFFSET_init>
1000748c:	e1a01000 	mov	r1, r0
10007490:	e51b2018 	ldr	r2, [fp, #-24]
10007494:	e284301a 	add	r3, r4, #26
10007498:	e1a03103 	lsl	r3, r3, #2
1000749c:	e0823003 	add	r3, r2, r3
100074a0:	e5831004 	str	r1, [r3, #4]
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
    }


  // initialize the voltage offset estimator handles
  for(cnt=0;cnt<USER_NUM_VOLTAGE_SENSORS;cnt++)
100074a4:	e55b300d 	ldrb	r3, [fp, #-13]
100074a8:	e2833001 	add	r3, r3, #1
100074ac:	e54b300d 	strb	r3, [fp, #-13]
100074b0:	e55b300d 	ldrb	r3, [fp, #-13]
100074b4:	e3530002 	cmp	r3, #2
100074b8:	9affffea 	bls	10007468 <HAL_init+0x9c>
    {
      obj->offsetHandle_V[cnt] = OFFSET_init(&obj->offset_V[cnt],sizeof(obj->offset_V[cnt]));
    }


  return(handle);
100074bc:	e51b3014 	ldr	r3, [fp, #-20]
} // end of HAL_init() function
100074c0:	e1a00003 	mov	r0, r3
100074c4:	e24bd008 	sub	sp, fp, #8
100074c8:	e8bd8810 	pop	{r4, fp, pc}

100074cc <HAL_setParams>:


void HAL_setParams(HAL_Handle handle,const USER_Params *pUserParams)
{
100074cc:	e92d4800 	push	{fp, lr}
100074d0:	e28db004 	add	fp, sp, #4
100074d4:	e24dd018 	sub	sp, sp, #24
100074d8:	e50b0018 	str	r0, [fp, #-24]
100074dc:	e50b101c 	str	r1, [fp, #-28]
  uint_least8_t cnt;
//  HAL_Obj *obj = (HAL_Obj *)handle;
	float_t beta_lp_pu = (pUserParams->offsetPole_rps/(float_t)pUserParams->ctrlFreq_Hz);//! \Mod By Dl.K
100074e0:	e51b301c 	ldr	r3, [fp, #-28]
100074e4:	ed937a06 	vldr	s14, [r3, #24]
100074e8:	e51b301c 	ldr	r3, [fp, #-28]
100074ec:	e5933150 	ldr	r3, [r3, #336]	; 0x150
100074f0:	ee073a90 	vmov	s15, r3
100074f4:	eef87a67 	vcvt.f32.u32	s15, s15
100074f8:	eec77a27 	vdiv.f32	s15, s14, s15
100074fc:	ed4b7a03 	vstr	s15, [fp, #-12]

  HAL_setNumCurrentSensors(handle,pUserParams->numCurrentSensors);
10007500:	e51b301c 	ldr	r3, [fp, #-28]
10007504:	e5d33016 	ldrb	r3, [r3, #22]
10007508:	e51b0018 	ldr	r0, [fp, #-24]
1000750c:	e1a01003 	mov	r1, r3
10007510:	ebffff15 	bl	1000716c <HAL_setNumCurrentSensors>
  HAL_setNumVoltageSensors(handle,pUserParams->numVoltageSensors);
10007514:	e51b301c 	ldr	r3, [fp, #-28]
10007518:	e5d33017 	ldrb	r3, [r3, #23]
1000751c:	e51b0018 	ldr	r0, [fp, #-24]
10007520:	e1a01003 	mov	r1, r3
10007524:	ebffff1f 	bl	100071a8 <HAL_setNumVoltageSensors>


  for(cnt=0;cnt<HAL_getNumCurrentSensors(handle);cnt++)
10007528:	e3a03000 	mov	r3, #0
1000752c:	e54b3005 	strb	r3, [fp, #-5]
10007530:	ea000014 	b	10007588 <HAL_setParams+0xbc>
	{
	  HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Current,cnt,beta_lp_pu);
10007534:	e55b3005 	ldrb	r3, [fp, #-5]
10007538:	e51b0018 	ldr	r0, [fp, #-24]
1000753c:	e3a01000 	mov	r1, #0
10007540:	e1a02003 	mov	r2, r3
10007544:	ed1b0a03 	vldr	s0, [fp, #-12]
10007548:	ebffff25 	bl	100071e4 <HAL_setOffsetBeta_lp_pu>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
1000754c:	e55b3005 	ldrb	r3, [fp, #-5]
10007550:	e51b0018 	ldr	r0, [fp, #-24]
10007554:	e3a01000 	mov	r1, #0
10007558:	e1a02003 	mov	r2, r3
1000755c:	ed9f0a74 	vldr	s0, [pc, #464]	; 10007734 <HAL_setParams+0x268>
10007560:	ebffff43 	bl	10007274 <HAL_setOffsetInitCond>
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
10007564:	e55b3005 	ldrb	r3, [fp, #-5]
10007568:	e51b0018 	ldr	r0, [fp, #-24]
1000756c:	e3a01000 	mov	r1, #0
10007570:	e1a02003 	mov	r2, r3
10007574:	ed9f0a6e 	vldr	s0, [pc, #440]	; 10007734 <HAL_setParams+0x268>
10007578:	ebffff61 	bl	10007304 <HAL_setOffsetValue>

  HAL_setNumCurrentSensors(handle,pUserParams->numCurrentSensors);
  HAL_setNumVoltageSensors(handle,pUserParams->numVoltageSensors);


  for(cnt=0;cnt<HAL_getNumCurrentSensors(handle);cnt++)
1000757c:	e55b3005 	ldrb	r3, [fp, #-5]
10007580:	e2833001 	add	r3, r3, #1
10007584:	e54b3005 	strb	r3, [fp, #-5]
10007588:	e51b0018 	ldr	r0, [fp, #-24]
1000758c:	ebfffeac 	bl	10007044 <HAL_getNumCurrentSensors>
10007590:	e1a03000 	mov	r3, r0
10007594:	e1a02003 	mov	r2, r3
10007598:	e55b3005 	ldrb	r3, [fp, #-5]
1000759c:	e1530002 	cmp	r3, r2
100075a0:	3affffe3 	bcc	10007534 <HAL_setParams+0x68>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
	}//! \Mod By Dl.K


  for(cnt=0;cnt<HAL_getNumVoltageSensors(handle);cnt++)
100075a4:	e3a03000 	mov	r3, #0
100075a8:	e54b3005 	strb	r3, [fp, #-5]
100075ac:	ea000014 	b	10007604 <HAL_setParams+0x138>
    {
      HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Voltage,cnt,beta_lp_pu);
100075b0:	e55b3005 	ldrb	r3, [fp, #-5]
100075b4:	e51b0018 	ldr	r0, [fp, #-24]
100075b8:	e3a01001 	mov	r1, #1
100075bc:	e1a02003 	mov	r2, r3
100075c0:	ed1b0a03 	vldr	s0, [fp, #-12]
100075c4:	ebffff06 	bl	100071e4 <HAL_setOffsetBeta_lp_pu>
      HAL_setOffsetInitCond(handle,HAL_SensorType_Voltage,cnt,(0.0f));
100075c8:	e55b3005 	ldrb	r3, [fp, #-5]
100075cc:	e51b0018 	ldr	r0, [fp, #-24]
100075d0:	e3a01001 	mov	r1, #1
100075d4:	e1a02003 	mov	r2, r3
100075d8:	ed9f0a55 	vldr	s0, [pc, #340]	; 10007734 <HAL_setParams+0x268>
100075dc:	ebffff24 	bl	10007274 <HAL_setOffsetInitCond>
      HAL_setOffsetValue(handle,HAL_SensorType_Voltage,cnt,(0.0f));
100075e0:	e55b3005 	ldrb	r3, [fp, #-5]
100075e4:	e51b0018 	ldr	r0, [fp, #-24]
100075e8:	e3a01001 	mov	r1, #1
100075ec:	e1a02003 	mov	r2, r3
100075f0:	ed9f0a4f 	vldr	s0, [pc, #316]	; 10007734 <HAL_setParams+0x268>
100075f4:	ebffff42 	bl	10007304 <HAL_setOffsetValue>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
	}//! \Mod By Dl.K


  for(cnt=0;cnt<HAL_getNumVoltageSensors(handle);cnt++)
100075f8:	e55b3005 	ldrb	r3, [fp, #-5]
100075fc:	e2833001 	add	r3, r3, #1
10007600:	e54b3005 	strb	r3, [fp, #-5]
10007604:	e51b0018 	ldr	r0, [fp, #-24]
10007608:	ebfffe99 	bl	10007074 <HAL_getNumVoltageSensors>
1000760c:	e1a03000 	mov	r3, r0
10007610:	e1a02003 	mov	r2, r3
10007614:	e55b3005 	ldrb	r3, [fp, #-5]
10007618:	e1530002 	cmp	r3, r2
1000761c:	3affffe3 	bcc	100075b0 <HAL_setParams+0xe4>
      HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Voltage,cnt,beta_lp_pu);
      HAL_setOffsetInitCond(handle,HAL_SensorType_Voltage,cnt,(0.0f));
      HAL_setOffsetValue(handle,HAL_SensorType_Voltage,cnt,(0.0f));
    }//! \Mod By Dl.K

	  HAL_setBias(handle,HAL_SensorType_Current,0,((I_A_offset)*(pUserParams->current_sf)));
10007620:	e51b301c 	ldr	r3, [fp, #-28]
10007624:	edd37a15 	vldr	s15, [r3, #84]	; 0x54
10007628:	ed9f7a42 	vldr	s14, [pc, #264]	; 10007738 <HAL_setParams+0x26c>
1000762c:	ee677a87 	vmul.f32	s15, s15, s14
10007630:	e51b0018 	ldr	r0, [fp, #-24]
10007634:	e3a01000 	mov	r1, #0
10007638:	e3a02000 	mov	r2, #0
1000763c:	eeb00a67 	vmov.f32	s0, s15
10007640:	ebfffe97 	bl	100070a4 <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Current,1,((I_B_offset)*(pUserParams->current_sf)));
10007644:	e51b301c 	ldr	r3, [fp, #-28]
10007648:	edd37a15 	vldr	s15, [r3, #84]	; 0x54
1000764c:	ed9f7a39 	vldr	s14, [pc, #228]	; 10007738 <HAL_setParams+0x26c>
10007650:	ee677a87 	vmul.f32	s15, s15, s14
10007654:	e51b0018 	ldr	r0, [fp, #-24]
10007658:	e3a01000 	mov	r1, #0
1000765c:	e3a02001 	mov	r2, #1
10007660:	eeb00a67 	vmov.f32	s0, s15
10007664:	ebfffe8e 	bl	100070a4 <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Current,2,((I_C_offset)*(pUserParams->current_sf)));
10007668:	e51b301c 	ldr	r3, [fp, #-28]
1000766c:	edd37a15 	vldr	s15, [r3, #84]	; 0x54
10007670:	ed9f7a30 	vldr	s14, [pc, #192]	; 10007738 <HAL_setParams+0x26c>
10007674:	ee677a87 	vmul.f32	s15, s15, s14
10007678:	e51b0018 	ldr	r0, [fp, #-24]
1000767c:	e3a01000 	mov	r1, #0
10007680:	e3a02002 	mov	r2, #2
10007684:	eeb00a67 	vmov.f32	s0, s15
10007688:	ebfffe85 	bl	100070a4 <HAL_setBias>


   float_t current_sf = (pUserParams->current_sf);//! \Mod By Dl.K
1000768c:	e51b301c 	ldr	r3, [fp, #-28]
10007690:	e5933054 	ldr	r3, [r3, #84]	; 0x54
10007694:	e50b3010 	str	r3, [fp, #-16]
  HAL_setCurrentScaleFactor(handle,current_sf);
10007698:	e51b0018 	ldr	r0, [fp, #-24]
1000769c:	ed1b0a04 	vldr	s0, [fp, #-16]
100076a0:	ebfffea3 	bl	10007134 <HAL_setCurrentScaleFactor>
 

	  HAL_setBias(handle,HAL_SensorType_Voltage,0,((V_A_offset)*(pUserParams->voltage_sf)));
100076a4:	e51b301c 	ldr	r3, [fp, #-28]
100076a8:	edd37a14 	vldr	s15, [r3, #80]	; 0x50
100076ac:	ed9f7a22 	vldr	s14, [pc, #136]	; 1000773c <HAL_setParams+0x270>
100076b0:	ee677a87 	vmul.f32	s15, s15, s14
100076b4:	e51b0018 	ldr	r0, [fp, #-24]
100076b8:	e3a01001 	mov	r1, #1
100076bc:	e3a02000 	mov	r2, #0
100076c0:	eeb00a67 	vmov.f32	s0, s15
100076c4:	ebfffe76 	bl	100070a4 <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Voltage,1,((V_B_offset)*(pUserParams->voltage_sf)));
100076c8:	e51b301c 	ldr	r3, [fp, #-28]
100076cc:	edd37a14 	vldr	s15, [r3, #80]	; 0x50
100076d0:	ed9f7a19 	vldr	s14, [pc, #100]	; 1000773c <HAL_setParams+0x270>
100076d4:	ee677a87 	vmul.f32	s15, s15, s14
100076d8:	e51b0018 	ldr	r0, [fp, #-24]
100076dc:	e3a01001 	mov	r1, #1
100076e0:	e3a02001 	mov	r2, #1
100076e4:	eeb00a67 	vmov.f32	s0, s15
100076e8:	ebfffe6d 	bl	100070a4 <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Voltage,2,((V_C_offset)*(pUserParams->voltage_sf)));
100076ec:	e51b301c 	ldr	r3, [fp, #-28]
100076f0:	edd37a14 	vldr	s15, [r3, #80]	; 0x50
100076f4:	ed9f7a10 	vldr	s14, [pc, #64]	; 1000773c <HAL_setParams+0x270>
100076f8:	ee677a87 	vmul.f32	s15, s15, s14
100076fc:	e51b0018 	ldr	r0, [fp, #-24]
10007700:	e3a01001 	mov	r1, #1
10007704:	e3a02002 	mov	r2, #2
10007708:	eeb00a67 	vmov.f32	s0, s15
1000770c:	ebfffe64 	bl	100070a4 <HAL_setBias>


	float_t voltage_sf = (pUserParams->voltage_sf);//! \Mod By Dl.K
10007710:	e51b301c 	ldr	r3, [fp, #-28]
10007714:	e5933050 	ldr	r3, [r3, #80]	; 0x50
10007718:	e50b3014 	str	r3, [fp, #-20]
  HAL_setVoltageScaleFactor(handle,voltage_sf);
1000771c:	e51b0018 	ldr	r0, [fp, #-24]
10007720:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
10007724:	ebffff1a 	bl	10007394 <HAL_setVoltageScaleFactor>
 
 return;
10007728:	e1a00000 	nop			; (mov r0, r0)
} // end of HAL_setParams() function
1000772c:	e24bd004 	sub	sp, fp, #4
10007730:	e8bd8800 	pop	{fp, pc}
10007734:	00000000 	.word	0x00000000
10007738:	3f41f06f 	.word	0x3f41f06f
1000773c:	3f14f206 	.word	0x3f14f206

10007740 <IPARK_init>:

// **************************************************************************
// the functions

IPARK_Handle IPARK_init(void *pMemory,const size_t numBytes)
{
10007740:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007744:	e28db000 	add	fp, sp, #0
10007748:	e24dd014 	sub	sp, sp, #20
1000774c:	e50b0010 	str	r0, [fp, #-16]
10007750:	e50b1014 	str	r1, [fp, #-20]
  IPARK_Handle handle;

  if(numBytes < sizeof(IPARK_Obj))
10007754:	e51b3014 	ldr	r3, [fp, #-20]
10007758:	e3530007 	cmp	r3, #7
1000775c:	8a000001 	bhi	10007768 <IPARK_init+0x28>
    return((IPARK_Handle)NULL);
10007760:	e3a03000 	mov	r3, #0
10007764:	ea000002 	b	10007774 <IPARK_init+0x34>

  // assign the handle
  handle = (IPARK_Handle)pMemory;
10007768:	e51b3010 	ldr	r3, [fp, #-16]
1000776c:	e50b3008 	str	r3, [fp, #-8]

  return(handle);
10007770:	e51b3008 	ldr	r3, [fp, #-8]
} // end of IPARK_init() function
10007774:	e1a00003 	mov	r0, r3
10007778:	e24bd000 	sub	sp, fp, #0
1000777c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007780:	e12fff1e 	bx	lr

10007784 <OFFSET_getBeta>:
// **************************************************************************
// the functions


float_t OFFSET_getBeta(OFFSET_Handle handle)
{
10007784:	e92d4800 	push	{fp, lr}
10007788:	e28db004 	add	fp, sp, #4
1000778c:	e24dd018 	sub	sp, sp, #24
10007790:	e50b0018 	str	r0, [fp, #-24]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
10007794:	e51b3018 	ldr	r3, [fp, #-24]
10007798:	e50b3008 	str	r3, [fp, #-8]
  float_t b0;
  float_t b1;

  FILTER_FO_getNumCoeffs(obj->filterHandle,&b0,&b1);
1000779c:	e51b3008 	ldr	r3, [fp, #-8]
100077a0:	e593101c 	ldr	r1, [r3, #28]
100077a4:	e24b200c 	sub	r2, fp, #12
100077a8:	e24b3010 	sub	r3, fp, #16
100077ac:	e1a00001 	mov	r0, r1
100077b0:	e1a01002 	mov	r1, r2
100077b4:	e1a02003 	mov	r2, r3
100077b8:	ebfffdca 	bl	10006ee8 <FILTER_FO_getNumCoeffs>

  return(b0);
100077bc:	e51b300c 	ldr	r3, [fp, #-12]
100077c0:	ee073a90 	vmov	s15, r3
} // end of OFFSET_getBeta() function
100077c4:	eeb00a67 	vmov.f32	s0, s15
100077c8:	e24bd004 	sub	sp, fp, #4
100077cc:	e8bd8800 	pop	{fp, pc}

100077d0 <OFFSET_init>:


OFFSET_Handle OFFSET_init(void *pMemory,const size_t numBytes)
{
100077d0:	e92d4800 	push	{fp, lr}
100077d4:	e28db004 	add	fp, sp, #4
100077d8:	e24dd010 	sub	sp, sp, #16
100077dc:	e50b0010 	str	r0, [fp, #-16]
100077e0:	e50b1014 	str	r1, [fp, #-20]
  OFFSET_Handle handle;
  OFFSET_Obj *obj;

  if(numBytes < sizeof(OFFSET_Obj))
100077e4:	e51b3014 	ldr	r3, [fp, #-20]
100077e8:	e353001f 	cmp	r3, #31
100077ec:	8a000001 	bhi	100077f8 <OFFSET_init+0x28>
    return((OFFSET_Handle)NULL);
100077f0:	e3a03000 	mov	r3, #0
100077f4:	ea00000c 	b	1000782c <OFFSET_init+0x5c>

  // assign the handle
  handle = (OFFSET_Handle)pMemory;
100077f8:	e51b3010 	ldr	r3, [fp, #-16]
100077fc:	e50b3008 	str	r3, [fp, #-8]
  obj = (OFFSET_Obj *)handle;
10007800:	e51b3008 	ldr	r3, [fp, #-8]
10007804:	e50b300c 	str	r3, [fp, #-12]

  obj->filterHandle = FILTER_FO_init(&(obj->filter),sizeof(obj->filter));
10007808:	e51b300c 	ldr	r3, [fp, #-12]
1000780c:	e2833008 	add	r3, r3, #8
10007810:	e1a00003 	mov	r0, r3
10007814:	e3a01014 	mov	r1, #20
10007818:	ebfffdc6 	bl	10006f38 <FILTER_FO_init>
1000781c:	e1a02000 	mov	r2, r0
10007820:	e51b300c 	ldr	r3, [fp, #-12]
10007824:	e583201c 	str	r2, [r3, #28]

  return(handle);
10007828:	e51b3008 	ldr	r3, [fp, #-8]
} // end of OFFSET_init() function
1000782c:	e1a00003 	mov	r0, r3
10007830:	e24bd004 	sub	sp, fp, #4
10007834:	e8bd8800 	pop	{fp, pc}

10007838 <OFFSET_setBeta>:


void OFFSET_setBeta(OFFSET_Handle handle,const float_t beta)
{
10007838:	e92d4800 	push	{fp, lr}
1000783c:	e28db004 	add	fp, sp, #4
10007840:	e24dd018 	sub	sp, sp, #24
10007844:	e50b0018 	str	r0, [fp, #-24]
10007848:	ed0b0a07 	vstr	s0, [fp, #-28]	; 0xffffffe4
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
1000784c:	e51b3018 	ldr	r3, [fp, #-24]
10007850:	e50b3008 	str	r3, [fp, #-8]
  float_t a1 = (beta - (1.0f));
10007854:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
10007858:	eeb77a00 	vmov.f32	s14, #112	; 0x70
1000785c:	ee777ac7 	vsub.f32	s15, s15, s14
10007860:	ed4b7a03 	vstr	s15, [fp, #-12]
  float_t b0 = beta;
10007864:	e51b301c 	ldr	r3, [fp, #-28]
10007868:	e50b3010 	str	r3, [fp, #-16]
  float_t b1 = 0;
1000786c:	e3a03000 	mov	r3, #0
10007870:	e50b3014 	str	r3, [fp, #-20]

  FILTER_FO_setDenCoeffs(obj->filterHandle,a1);
10007874:	e51b3008 	ldr	r3, [fp, #-8]
10007878:	e593301c 	ldr	r3, [r3, #28]
1000787c:	e1a00003 	mov	r0, r3
10007880:	ed1b0a03 	vldr	s0, [fp, #-12]
10007884:	ebfffdbc 	bl	10006f7c <FILTER_FO_setDenCoeffs>
  FILTER_FO_setNumCoeffs(obj->filterHandle,b0,b1);
10007888:	e51b3008 	ldr	r3, [fp, #-8]
1000788c:	e593301c 	ldr	r3, [r3, #28]
10007890:	e1a00003 	mov	r0, r3
10007894:	ed1b0a04 	vldr	s0, [fp, #-16]
10007898:	ed5b0a05 	vldr	s1, [fp, #-20]	; 0xffffffec
1000789c:	ebfffdd6 	bl	10006ffc <FILTER_FO_setNumCoeffs>

  return;
100078a0:	e1a00000 	nop			; (mov r0, r0)
} // end of OFFSET_setBeta() function
100078a4:	e24bd004 	sub	sp, fp, #4
100078a8:	e8bd8800 	pop	{fp, pc}

100078ac <OFFSET_setInitCond>:


void OFFSET_setInitCond(OFFSET_Handle handle,const float_t initCond)
{
100078ac:	e92d4800 	push	{fp, lr}
100078b0:	e28db004 	add	fp, sp, #4
100078b4:	e24dd010 	sub	sp, sp, #16
100078b8:	e50b0010 	str	r0, [fp, #-16]
100078bc:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
100078c0:	e51b3010 	ldr	r3, [fp, #-16]
100078c4:	e50b3008 	str	r3, [fp, #-8]

  FILTER_FO_setInitialConditions(obj->filterHandle,initCond,initCond);
100078c8:	e51b3008 	ldr	r3, [fp, #-8]
100078cc:	e593301c 	ldr	r3, [r3, #28]
100078d0:	e1a00003 	mov	r0, r3
100078d4:	ed1b0a05 	vldr	s0, [fp, #-20]	; 0xffffffec
100078d8:	ed5b0a05 	vldr	s1, [fp, #-20]	; 0xffffffec
100078dc:	ebfffdb4 	bl	10006fb4 <FILTER_FO_setInitialConditions>
  obj->value = initCond;
100078e0:	e51b3008 	ldr	r3, [fp, #-8]
100078e4:	e51b2014 	ldr	r2, [fp, #-20]
100078e8:	e5832000 	str	r2, [r3]

  return;
100078ec:	e1a00000 	nop			; (mov r0, r0)
} // end of OFFSET_setInitCond() function
100078f0:	e24bd004 	sub	sp, fp, #4
100078f4:	e8bd8800 	pop	{fp, pc}

100078f8 <OFFSET_setOffset>:


void OFFSET_setOffset(OFFSET_Handle handle, float_t offsetValue)
{
100078f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100078fc:	e28db000 	add	fp, sp, #0
10007900:	e24dd014 	sub	sp, sp, #20
10007904:	e50b0010 	str	r0, [fp, #-16]
10007908:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
1000790c:	e51b3010 	ldr	r3, [fp, #-16]
10007910:	e50b3008 	str	r3, [fp, #-8]

  obj->value = offsetValue;
10007914:	e51b3008 	ldr	r3, [fp, #-8]
10007918:	e51b2014 	ldr	r2, [fp, #-20]
1000791c:	e5832000 	str	r2, [r3]

  return;
10007920:	e1a00000 	nop			; (mov r0, r0)
} // end of OFFSET_setOffset() function
10007924:	e24bd000 	sub	sp, fp, #0
10007928:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000792c:	e12fff1e 	bx	lr

10007930 <PARK_init>:

// **************************************************************************
// the functions

PARK_Handle PARK_init(void *pMemory,const size_t numBytes)
{
10007930:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007934:	e28db000 	add	fp, sp, #0
10007938:	e24dd014 	sub	sp, sp, #20
1000793c:	e50b0010 	str	r0, [fp, #-16]
10007940:	e50b1014 	str	r1, [fp, #-20]
  PARK_Handle handle;

  if(numBytes < sizeof(PARK_Obj))
10007944:	e51b3014 	ldr	r3, [fp, #-20]
10007948:	e3530007 	cmp	r3, #7
1000794c:	8a000001 	bhi	10007958 <PARK_init+0x28>
    return((PARK_Handle)NULL);
10007950:	e3a03000 	mov	r3, #0
10007954:	ea000002 	b	10007964 <PARK_init+0x34>

  // assign the handle
  handle = (PARK_Handle)pMemory;
10007958:	e51b3010 	ldr	r3, [fp, #-16]
1000795c:	e50b3008 	str	r3, [fp, #-8]

  return(handle);
10007960:	e51b3008 	ldr	r3, [fp, #-8]
} // end of PARK_init() function
10007964:	e1a00003 	mov	r0, r3
10007968:	e24bd000 	sub	sp, fp, #0
1000796c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007970:	e12fff1e 	bx	lr

10007974 <PID_setFbackValue>:

//! \brief     Sets the feedback value in the PID controller
//! \param[in] handle      The PID controller handle
//! \param[in] fbackValue  The feedback value
static inline void PID_setFbackValue(PID_Handle handle,const float_t fbackValue)//! \Mod By Dl.K
{
10007974:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007978:	e28db000 	add	fp, sp, #0
1000797c:	e24dd014 	sub	sp, sp, #20
10007980:	e50b0010 	str	r0, [fp, #-16]
10007984:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
10007988:	e51b3010 	ldr	r3, [fp, #-16]
1000798c:	e50b3008 	str	r3, [fp, #-8]

  obj->fbackValue = fbackValue;
10007990:	e51b3008 	ldr	r3, [fp, #-8]
10007994:	e51b2014 	ldr	r2, [fp, #-20]
10007998:	e5832014 	str	r2, [r3, #20]

  return;
1000799c:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setFbackValue() function
100079a0:	e24bd000 	sub	sp, fp, #0
100079a4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100079a8:	e12fff1e 	bx	lr

100079ac <PID_setRefValue>:

//! \brief     Sets the reference value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] refValue   The reference value
static inline void PID_setRefValue(PID_Handle handle,const float_t refValue)//! \Mod By Dl.K
{
100079ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100079b0:	e28db000 	add	fp, sp, #0
100079b4:	e24dd014 	sub	sp, sp, #20
100079b8:	e50b0010 	str	r0, [fp, #-16]
100079bc:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
100079c0:	e51b3010 	ldr	r3, [fp, #-16]
100079c4:	e50b3008 	str	r3, [fp, #-8]

  obj->refValue = refValue;
100079c8:	e51b3008 	ldr	r3, [fp, #-8]
100079cc:	e51b2014 	ldr	r2, [fp, #-20]
100079d0:	e5832010 	str	r2, [r3, #16]

  return;
100079d4:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setRefValue() function
100079d8:	e24bd000 	sub	sp, fp, #0
100079dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100079e0:	e12fff1e 	bx	lr

100079e4 <PID_setUi>:

//! \brief     Sets the integrator start value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ui         The integral start value for the PID controller
static inline void PID_setUi(PID_Handle handle,const float_t Ui)//! \Mod By Dl.K
{
100079e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100079e8:	e28db000 	add	fp, sp, #0
100079ec:	e24dd014 	sub	sp, sp, #20
100079f0:	e50b0010 	str	r0, [fp, #-16]
100079f4:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
100079f8:	e51b3010 	ldr	r3, [fp, #-16]
100079fc:	e50b3008 	str	r3, [fp, #-8]

  obj->Ui = Ui;
10007a00:	e51b3008 	ldr	r3, [fp, #-8]
10007a04:	e51b2014 	ldr	r2, [fp, #-20]
10007a08:	e583200c 	str	r2, [r3, #12]

  return;
10007a0c:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setUi() function
10007a10:	e24bd000 	sub	sp, fp, #0
10007a14:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007a18:	e12fff1e 	bx	lr

10007a1c <PID_init>:

// **************************************************************************
// the functions

PID_Handle PID_init(void *pMemory,const size_t numBytes)
{
10007a1c:	e92d4800 	push	{fp, lr}
10007a20:	e28db004 	add	fp, sp, #4
10007a24:	e24dd010 	sub	sp, sp, #16
10007a28:	e50b0010 	str	r0, [fp, #-16]
10007a2c:	e50b1014 	str	r1, [fp, #-20]
  PID_Handle handle;


  if(numBytes < sizeof(PID_Obj))
10007a30:	e51b3014 	ldr	r3, [fp, #-20]
10007a34:	e353001f 	cmp	r3, #31
10007a38:	8a000001 	bhi	10007a44 <PID_init+0x28>
    return((PID_Handle)NULL);
10007a3c:	e3a03000 	mov	r3, #0
10007a40:	ea00000b 	b	10007a74 <PID_init+0x58>

  // assign the handle
  handle = (PID_Handle)pMemory;
10007a44:	e51b3010 	ldr	r3, [fp, #-16]
10007a48:	e50b3008 	str	r3, [fp, #-8]

  // set some defaults
  PID_setUi(handle,(0.0f));
10007a4c:	e51b0008 	ldr	r0, [fp, #-8]
10007a50:	ed9f0a0a 	vldr	s0, [pc, #40]	; 10007a80 <PID_init+0x64>
10007a54:	ebffffe2 	bl	100079e4 <PID_setUi>
  PID_setRefValue(handle,(0.0f));
10007a58:	e51b0008 	ldr	r0, [fp, #-8]
10007a5c:	ed9f0a07 	vldr	s0, [pc, #28]	; 10007a80 <PID_init+0x64>
10007a60:	ebffffd1 	bl	100079ac <PID_setRefValue>
  PID_setFbackValue(handle,(0.0f));
10007a64:	e51b0008 	ldr	r0, [fp, #-8]
10007a68:	ed9f0a04 	vldr	s0, [pc, #16]	; 10007a80 <PID_init+0x64>
10007a6c:	ebffffc0 	bl	10007974 <PID_setFbackValue>

  return(handle);
10007a70:	e51b3008 	ldr	r3, [fp, #-8]
} // end of PID_init() function
10007a74:	e1a00003 	mov	r0, r3
10007a78:	e24bd004 	sub	sp, fp, #4
10007a7c:	e8bd8800 	pop	{fp, pc}
10007a80:	00000000 	.word	0x00000000

10007a84 <RAMPGEN_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/rampgen/rampgen.h"

RAMPGEN_Handle RAMPGEN_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
10007a84:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007a88:	e28db000 	add	fp, sp, #0
10007a8c:	e24dd014 	sub	sp, sp, #20
10007a90:	e50b0010 	str	r0, [fp, #-16]
10007a94:	e50b1014 	str	r1, [fp, #-20]
	RAMPGEN_Handle handle;

	if (numBytes < sizeof(RAMPGEN_Obj))
10007a98:	e51b3014 	ldr	r3, [fp, #-20]
10007a9c:	e3530017 	cmp	r3, #23
10007aa0:	8a000001 	bhi	10007aac <RAMPGEN_Init+0x28>
		return((RAMPGEN_Handle)NULL);
10007aa4:	e3a03000 	mov	r3, #0
10007aa8:	ea000014 	b	10007b00 <RAMPGEN_Init+0x7c>

	// assign the handle
	handle = (RAMPGEN_Handle)pMemory;
10007aac:	e51b3010 	ldr	r3, [fp, #-16]
10007ab0:	e50b3008 	str	r3, [fp, #-8]

	handle->Freq = (0.0);
10007ab4:	e51b3008 	ldr	r3, [fp, #-8]
10007ab8:	e3a02000 	mov	r2, #0
10007abc:	e5832000 	str	r2, [r3]
	handle->StepAngleMax = (0.0);
10007ac0:	e51b3008 	ldr	r3, [fp, #-8]
10007ac4:	e3a02000 	mov	r2, #0
10007ac8:	e5832004 	str	r2, [r3, #4]
	handle->Angle = (0.0);
10007acc:	e51b3008 	ldr	r3, [fp, #-8]
10007ad0:	e3a02000 	mov	r2, #0
10007ad4:	e5832008 	str	r2, [r3, #8]
	handle->Gain = (1.0);
10007ad8:	e51b3008 	ldr	r3, [fp, #-8]
10007adc:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
10007ae0:	e583200c 	str	r2, [r3, #12]
	handle->Out = (0.0);
10007ae4:	e51b3008 	ldr	r3, [fp, #-8]
10007ae8:	e3a02000 	mov	r2, #0
10007aec:	e5832010 	str	r2, [r3, #16]
	handle->Offset = (0.75);
10007af0:	e51b3008 	ldr	r3, [fp, #-8]
10007af4:	e3a025fd 	mov	r2, #1061158912	; 0x3f400000
10007af8:	e5832014 	str	r2, [r3, #20]

	return(handle);
10007afc:	e51b3008 	ldr	r3, [fp, #-8]
}
10007b00:	e1a00003 	mov	r0, r3
10007b04:	e24bd000 	sub	sp, fp, #0
10007b08:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007b0c:	e12fff1e 	bx	lr

10007b10 <RMP_CNTL_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/rmp_cntl/rmp_cntl.h"

RMPCNTL_Handle RMP_CNTL_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
10007b10:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007b14:	e28db000 	add	fp, sp, #0
10007b18:	e24dd014 	sub	sp, sp, #20
10007b1c:	e50b0010 	str	r0, [fp, #-16]
10007b20:	e50b1014 	str	r1, [fp, #-20]
	RMPCNTL_Handle handle;

	if (numBytes < sizeof(RMPCNTL_Obj))
10007b24:	e51b3014 	ldr	r3, [fp, #-20]
10007b28:	e353001b 	cmp	r3, #27
10007b2c:	8a000001 	bhi	10007b38 <RMP_CNTL_Init+0x28>
		return((RMPCNTL_Handle)NULL);
10007b30:	e3a03000 	mov	r3, #0
10007b34:	ea000019 	b	10007ba0 <RMP_CNTL_Init+0x90>

	// assign the handle
	handle = (RMPCNTL_Handle)pMemory;
10007b38:	e51b3010 	ldr	r3, [fp, #-16]
10007b3c:	e50b3008 	str	r3, [fp, #-8]

	handle->TargetValue = (0.0f);
10007b40:	e51b3008 	ldr	r3, [fp, #-8]
10007b44:	e3a02000 	mov	r2, #0
10007b48:	e5832000 	str	r2, [r3]
	handle->RampDelayMax = 150;
10007b4c:	e51b3008 	ldr	r3, [fp, #-8]
10007b50:	e3a02096 	mov	r2, #150	; 0x96
10007b54:	e5832004 	str	r2, [r3, #4]
	handle->RampLowLimit = (-10.0f);
10007b58:	e51b3008 	ldr	r3, [fp, #-8]
10007b5c:	e3a02000 	mov	r2, #0
10007b60:	e34c2120 	movt	r2, #49440	; 0xc120
10007b64:	e5832008 	str	r2, [r3, #8]
	handle->RampHighLimit = (10.0f);
10007b68:	e51b3008 	ldr	r3, [fp, #-8]
10007b6c:	e3a02000 	mov	r2, #0
10007b70:	e3442120 	movt	r2, #16672	; 0x4120
10007b74:	e583200c 	str	r2, [r3, #12]
	handle->RampDelayCount = 0;
10007b78:	e51b3008 	ldr	r3, [fp, #-8]
10007b7c:	e3a02000 	mov	r2, #0
10007b80:	e5832010 	str	r2, [r3, #16]
	handle->SetpointValue = (0.0f);
10007b84:	e51b3008 	ldr	r3, [fp, #-8]
10007b88:	e3a02000 	mov	r2, #0
10007b8c:	e5832014 	str	r2, [r3, #20]
	handle->EqualFlag = 0;
10007b90:	e51b3008 	ldr	r3, [fp, #-8]
10007b94:	e3a02000 	mov	r2, #0
10007b98:	e5832018 	str	r2, [r3, #24]

	return(handle);
10007b9c:	e51b3008 	ldr	r3, [fp, #-8]
}
10007ba0:	e1a00003 	mov	r0, r3
10007ba4:	e24bd000 	sub	sp, fp, #0
10007ba8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007bac:	e12fff1e 	bx	lr

10007bb0 <SVGEN_init>:

// **************************************************************************
// the functions

SVGEN_Handle SVGEN_init(void *pMemory,const size_t numBytes)
{
10007bb0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007bb4:	e28db000 	add	fp, sp, #0
10007bb8:	e24dd014 	sub	sp, sp, #20
10007bbc:	e50b0010 	str	r0, [fp, #-16]
10007bc0:	e50b1014 	str	r1, [fp, #-20]
  SVGEN_Handle svgenHandle;


  if(numBytes < sizeof(SVGEN_Obj))
10007bc4:	e51b3014 	ldr	r3, [fp, #-20]
10007bc8:	e3530003 	cmp	r3, #3
10007bcc:	8a000001 	bhi	10007bd8 <SVGEN_init+0x28>
    return((SVGEN_Handle)NULL);
10007bd0:	e3a03000 	mov	r3, #0
10007bd4:	ea000002 	b	10007be4 <SVGEN_init+0x34>

  // assign the handle
  svgenHandle = (SVGEN_Handle)pMemory;
10007bd8:	e51b3010 	ldr	r3, [fp, #-16]
10007bdc:	e50b3008 	str	r3, [fp, #-8]

  return(svgenHandle);
10007be0:	e51b3008 	ldr	r3, [fp, #-8]
} // end of SVGEN_init() function
10007be4:	e1a00003 	mov	r0, r3
10007be8:	e24bd000 	sub	sp, fp, #0
10007bec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007bf0:	e12fff1e 	bx	lr

10007bf4 <SVGEN_setup>:


void SVGEN_setup(SVGEN_Handle svgenHandle)
{
10007bf4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007bf8:	e28db000 	add	fp, sp, #0
10007bfc:	e24dd00c 	sub	sp, sp, #12
10007c00:	e50b0008 	str	r0, [fp, #-8]
//  SVGEN_Obj *svgen = (SVGEN_Obj *)svgenHandle;

  return;
10007c04:	e1a00000 	nop			; (mov r0, r0)
} // end of SVGEN_setup() function
10007c08:	e24bd000 	sub	sp, fp, #0
10007c0c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007c10:	e12fff1e 	bx	lr

10007c14 <TRAJ_init>:

// **************************************************************************
// the functions

TRAJ_Handle TRAJ_init(void *pMemory,const size_t numBytes)
{
10007c14:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007c18:	e28db000 	add	fp, sp, #0
10007c1c:	e24dd014 	sub	sp, sp, #20
10007c20:	e50b0010 	str	r0, [fp, #-16]
10007c24:	e50b1014 	str	r1, [fp, #-20]
  TRAJ_Handle handle;


  if(numBytes < sizeof(TRAJ_Obj))
10007c28:	e51b3014 	ldr	r3, [fp, #-20]
10007c2c:	e3530013 	cmp	r3, #19
10007c30:	8a000001 	bhi	10007c3c <TRAJ_init+0x28>
    return((TRAJ_Handle)NULL);
10007c34:	e3a03000 	mov	r3, #0
10007c38:	ea000002 	b	10007c48 <TRAJ_init+0x34>

  // assign the handle
  handle = (TRAJ_Handle)pMemory;
10007c3c:	e51b3010 	ldr	r3, [fp, #-16]
10007c40:	e50b3008 	str	r3, [fp, #-8]

  return(handle);
10007c44:	e51b3008 	ldr	r3, [fp, #-8]
} // end of TRAJ_init() function
10007c48:	e1a00003 	mov	r0, r3
10007c4c:	e24bd000 	sub	sp, fp, #0
10007c50:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007c54:	e12fff1e 	bx	lr

10007c58 <PID_getFbackValue>:

//! \brief     Gets the feedback value in the PID controller
//! \param[in] handle  The PID controller handle
//! \return    The feedback value in the PID controller
static inline float_t PID_getFbackValue(PID_Handle handle)//! \Mod By Dl.K
{
10007c58:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007c5c:	e28db000 	add	fp, sp, #0
10007c60:	e24dd014 	sub	sp, sp, #20
10007c64:	e50b0010 	str	r0, [fp, #-16]
  PID_Obj *obj = (PID_Obj *)handle;
10007c68:	e51b3010 	ldr	r3, [fp, #-16]
10007c6c:	e50b3008 	str	r3, [fp, #-8]

  return(obj->fbackValue);
10007c70:	e51b3008 	ldr	r3, [fp, #-8]
10007c74:	e5933014 	ldr	r3, [r3, #20]
10007c78:	ee073a90 	vmov	s15, r3
} // end of PID_getFbackValue() function
10007c7c:	eeb00a67 	vmov.f32	s0, s15
10007c80:	e24bd000 	sub	sp, fp, #0
10007c84:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007c88:	e12fff1e 	bx	lr

10007c8c <PID_setKi>:

//! \brief     Sets the integral gain in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ki      The integral gain for the PID controller
static inline void PID_setKi(PID_Handle handle,const float_t Ki)//! \Mod By Dl.K
{
10007c8c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007c90:	e28db000 	add	fp, sp, #0
10007c94:	e24dd014 	sub	sp, sp, #20
10007c98:	e50b0010 	str	r0, [fp, #-16]
10007c9c:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  PID_Obj *obj = (PID_Obj *)handle;
10007ca0:	e51b3010 	ldr	r3, [fp, #-16]
10007ca4:	e50b3008 	str	r3, [fp, #-8]

  obj->Ki = Ki;
10007ca8:	e51b3008 	ldr	r3, [fp, #-8]
10007cac:	e51b2014 	ldr	r2, [fp, #-20]
10007cb0:	e5832004 	str	r2, [r3, #4]

  return;
10007cb4:	e1a00000 	nop			; (mov r0, r0)
} // end of PID_setKi() function
10007cb8:	e24bd000 	sub	sp, fp, #0
10007cbc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007cc0:	e12fff1e 	bx	lr

10007cc4 <CTRL_getCtrlPeriod_sec>:

//! \brief      Gets the controller execution period
//! \param[in]  handle  The controller (CTRL) handle
//! \return     The controller execution period, sec
static inline float_t CTRL_getCtrlPeriod_sec(CTRL_Handle handle)//! \Mod By Dl.K
{
10007cc4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007cc8:	e28db000 	add	fp, sp, #0
10007ccc:	e24dd014 	sub	sp, sp, #20
10007cd0:	e50b0010 	str	r0, [fp, #-16]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10007cd4:	e51b3010 	ldr	r3, [fp, #-16]
10007cd8:	e50b3008 	str	r3, [fp, #-8]

  return(obj->ctrlPeriod_sec);
10007cdc:	e51b3008 	ldr	r3, [fp, #-8]
10007ce0:	e5933160 	ldr	r3, [r3, #352]	; 0x160
10007ce4:	ee073a90 	vmov	s15, r3
} // end of CTRL_getCtrlPeriod_sec() function
10007ce8:	eeb00a67 	vmov.f32	s0, s15
10007cec:	e24bd000 	sub	sp, fp, #0
10007cf0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007cf4:	e12fff1e 	bx	lr

10007cf8 <USER_setParams>:
// **************************************************************************
// the functions


void USER_setParams(USER_Params *pUserParams)
{
10007cf8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007cfc:	e28db000 	add	fp, sp, #0
10007d00:	e24dd00c 	sub	sp, sp, #12
10007d04:	e50b0008 	str	r0, [fp, #-8]
  pUserParams->iqFullScaleCurrent_A = USER_IQ_FULL_SCALE_CURRENT_A;
10007d08:	e51b3008 	ldr	r3, [fp, #-8]
10007d0c:	e3a02000 	mov	r2, #0
10007d10:	e3442348 	movt	r2, #17224	; 0x4348
10007d14:	e5832000 	str	r2, [r3]
  pUserParams->iqFullScaleVoltage_V = USER_IQ_FULL_SCALE_VOLTAGE_V;
10007d18:	e51b3008 	ldr	r3, [fp, #-8]
10007d1c:	e3a02000 	mov	r2, #0
10007d20:	e34424c8 	movt	r2, #17608	; 0x44c8
10007d24:	e5832004 	str	r2, [r3, #4]

  pUserParams->iqFullScaleFreq_Hz = USER_IQ_FULL_SCALE_FREQ_Hz;
10007d28:	e51b3008 	ldr	r3, [fp, #-8]
10007d2c:	e3a02000 	mov	r2, #0
10007d30:	e344235c 	movt	r2, #17244	; 0x435c
10007d34:	e5832008 	str	r2, [r3, #8]

  pUserParams->numIsrTicksPerCtrlTick = USER_NUM_ISR_TICKS_PER_CTRL_TICK;
10007d38:	e51b3008 	ldr	r3, [fp, #-8]
10007d3c:	e3a02001 	mov	r2, #1
10007d40:	e1c320bc 	strh	r2, [r3, #12]
  pUserParams->numCtrlTicksPerCurrentTick = USER_NUM_CTRL_TICKS_PER_CURRENT_TICK;
10007d44:	e51b3008 	ldr	r3, [fp, #-8]
10007d48:	e3a02001 	mov	r2, #1
10007d4c:	e1c320be 	strh	r2, [r3, #14]
  pUserParams->numCtrlTicksPerEstTick = USER_NUM_CTRL_TICKS_PER_EST_TICK;
10007d50:	e51b3008 	ldr	r3, [fp, #-8]
10007d54:	e3a02001 	mov	r2, #1
10007d58:	e1c321b0 	strh	r2, [r3, #16]
  pUserParams->numCtrlTicksPerSpeedTick = USER_NUM_CTRL_TICKS_PER_SPEED_TICK;
10007d5c:	e51b3008 	ldr	r3, [fp, #-8]
10007d60:	e3a0200a 	mov	r2, #10
10007d64:	e1c321b2 	strh	r2, [r3, #18]
  pUserParams->numCtrlTicksPerTrajTick = USER_NUM_CTRL_TICKS_PER_TRAJ_TICK;
10007d68:	e51b3008 	ldr	r3, [fp, #-8]
10007d6c:	e3a0200a 	mov	r2, #10
10007d70:	e1c321b4 	strh	r2, [r3, #20]

  pUserParams->numCurrentSensors = USER_NUM_CURRENT_SENSORS;
10007d74:	e51b3008 	ldr	r3, [fp, #-8]
10007d78:	e3a02003 	mov	r2, #3
10007d7c:	e5c32016 	strb	r2, [r3, #22]
  pUserParams->numVoltageSensors = USER_NUM_VOLTAGE_SENSORS;
10007d80:	e51b3008 	ldr	r3, [fp, #-8]
10007d84:	e3a02003 	mov	r2, #3
10007d88:	e5c32017 	strb	r2, [r3, #23]

  pUserParams->offsetPole_rps = USER_OFFSET_POLE_rps;
10007d8c:	e51b3008 	ldr	r3, [fp, #-8]
10007d90:	e3a02000 	mov	r2, #0
10007d94:	e34421a0 	movt	r2, #16800	; 0x41a0
10007d98:	e5832018 	str	r2, [r3, #24]
  pUserParams->fluxPole_rps = USER_FLUX_POLE_rps;
10007d9c:	e51b3008 	ldr	r3, [fp, #-8]
10007da0:	e3a02000 	mov	r2, #0
10007da4:	e34422c8 	movt	r2, #17096	; 0x42c8
10007da8:	e583201c 	str	r2, [r3, #28]

  pUserParams->zeroSpeedLimit = USER_ZEROSPEEDLIMIT;
10007dac:	e51b3008 	ldr	r3, [fp, #-8]
10007db0:	e30f2209 	movw	r2, #61961	; 0xf209
10007db4:	e3432b94 	movt	r2, #15252	; 0x3b94
10007db8:	e5832020 	str	r2, [r3, #32]

  pUserParams->forceAngleFreq_Hz = USER_FORCE_ANGLE_FREQ_Hz;
10007dbc:	e51b3008 	ldr	r3, [fp, #-8]
10007dc0:	e30f2fff 	movw	r2, #65535	; 0xffff
10007dc4:	e3432f7f 	movt	r2, #16255	; 0x3f7f
10007dc8:	e5832024 	str	r2, [r3, #36]	; 0x24

  pUserParams->maxAccel_Hzps = USER_MAX_ACCEL_Hzps;
10007dcc:	e51b3008 	ldr	r3, [fp, #-8]
10007dd0:	e3a02000 	mov	r2, #0
10007dd4:	e34421a0 	movt	r2, #16800	; 0x41a0
10007dd8:	e5832028 	str	r2, [r3, #40]	; 0x28

  pUserParams->maxAccel_est_Hzps = USER_MAX_ACCEL_EST_Hzps;
10007ddc:	e51b3008 	ldr	r3, [fp, #-8]
10007de0:	e3a02000 	mov	r2, #0
10007de4:	e34420a0 	movt	r2, #16544	; 0x40a0
10007de8:	e583202c 	str	r2, [r3, #44]	; 0x2c

  pUserParams->directionPole_rps = USER_DIRECTION_POLE_rps;
10007dec:	e51b3008 	ldr	r3, [fp, #-8]
10007df0:	e3a02000 	mov	r2, #0
10007df4:	e34420c0 	movt	r2, #16576	; 0x40c0
10007df8:	e5832030 	str	r2, [r3, #48]	; 0x30

  pUserParams->speedPole_rps = USER_SPEED_POLE_rps;
10007dfc:	e51b3008 	ldr	r3, [fp, #-8]
10007e00:	e3a02000 	mov	r2, #0
10007e04:	e34422c8 	movt	r2, #17096	; 0x42c8
10007e08:	e5832034 	str	r2, [r3, #52]	; 0x34

  pUserParams->dcBusPole_rps = USER_DCBUS_POLE_rps;
10007e0c:	e51b3008 	ldr	r3, [fp, #-8]
10007e10:	e3a02000 	mov	r2, #0
10007e14:	e34422c8 	movt	r2, #17096	; 0x42c8
10007e18:	e5832038 	str	r2, [r3, #56]	; 0x38

  pUserParams->fluxFraction = USER_FLUX_FRACTION;
10007e1c:	e51b3008 	ldr	r3, [fp, #-8]
10007e20:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
10007e24:	e583203c 	str	r2, [r3, #60]	; 0x3c

  pUserParams->indEst_speedMaxFraction = USER_SPEEDMAX_FRACTION_FOR_L_IDENT;
10007e28:	e51b3008 	ldr	r3, [fp, #-8]
10007e2c:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
10007e30:	e5832040 	str	r2, [r3, #64]	; 0x40

  pUserParams->powerWarpGain = USER_POWERWARP_GAIN;
10007e34:	e51b3008 	ldr	r3, [fp, #-8]
10007e38:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
10007e3c:	e5832044 	str	r2, [r3, #68]	; 0x44

  pUserParams->systemFreq_MHz = USER_SYSTEM_FREQ_MHz;
10007e40:	e51b3008 	ldr	r3, [fp, #-8]
10007e44:	e3a0205a 	mov	r2, #90	; 0x5a
10007e48:	e1c324b8 	strh	r2, [r3, #72]	; 0x48

  pUserParams->pwmPeriod_usec = USER_PWM_PERIOD_usec;
10007e4c:	e51b3008 	ldr	r3, [fp, #-8]
10007e50:	e3a02000 	mov	r2, #0
10007e54:	e34422a0 	movt	r2, #17056	; 0x42a0
10007e58:	e583204c 	str	r2, [r3, #76]	; 0x4c

  pUserParams->voltage_sf = USER_VOLTAGE_SF;
10007e5c:	e51b3008 	ldr	r3, [fp, #-8]
10007e60:	e30a2e6f 	movw	r2, #44655	; 0xae6f
10007e64:	e3432fac 	movt	r2, #16300	; 0x3fac
10007e68:	e5832050 	str	r2, [r3, #80]	; 0x50

  pUserParams->current_sf = USER_CURRENT_SF;
10007e6c:	e51b3008 	ldr	r3, [fp, #-8]
10007e70:	e3a02000 	mov	r2, #0
10007e74:	e3432f84 	movt	r2, #16260	; 0x3f84
10007e78:	e5832054 	str	r2, [r3, #84]	; 0x54

  pUserParams->voltageFilterPole_rps = USER_VOLTAGE_FILTER_POLE_rps;
10007e7c:	e51b3008 	ldr	r3, [fp, #-8]
10007e80:	e3012e15 	movw	r2, #7701	; 0x1e15
10007e84:	e344258e 	movt	r2, #17806	; 0x458e
10007e88:	e5832058 	str	r2, [r3, #88]	; 0x58

  pUserParams->maxVsMag_pu = USER_MAX_VS_MAG_PU;
10007e8c:	e51b3008 	ldr	r3, [fp, #-8]
10007e90:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
10007e94:	e583205c 	str	r2, [r3, #92]	; 0x5c

  pUserParams->estKappa = USER_EST_KAPPAQ;
10007e98:	e51b3008 	ldr	r3, [fp, #-8]
10007e9c:	e3a025ff 	mov	r2, #1069547520	; 0x3fc00000
10007ea0:	e5832060 	str	r2, [r3, #96]	; 0x60

  pUserParams->motor_type = USER_MOTOR_TYPE;
10007ea4:	e51b3008 	ldr	r3, [fp, #-8]
10007ea8:	e3a02001 	mov	r2, #1
10007eac:	e5c32064 	strb	r2, [r3, #100]	; 0x64
  pUserParams->motor_numPolePairs = USER_MOTOR_NUM_POLE_PAIRS;
10007eb0:	e51b3008 	ldr	r3, [fp, #-8]
10007eb4:	e3a02004 	mov	r2, #4
10007eb8:	e1c326b6 	strh	r2, [r3, #102]	; 0x66
  pUserParams->motor_ratedFlux = USER_MOTOR_RATED_FLUX;
10007ebc:	e51b3008 	ldr	r3, [fp, #-8]
10007ec0:	e30e2bee 	movw	r2, #60398	; 0xebee
10007ec4:	e3432dc0 	movt	r2, #15808	; 0x3dc0
10007ec8:	e5832068 	str	r2, [r3, #104]	; 0x68
  pUserParams->motor_Rr = USER_MOTOR_Rr;
10007ecc:	e51b3008 	ldr	r3, [fp, #-8]
10007ed0:	e30f2df4 	movw	r2, #65012	; 0xfdf4
10007ed4:	e3442088 	movt	r2, #16520	; 0x4088
10007ed8:	e583206c 	str	r2, [r3, #108]	; 0x6c
  pUserParams->motor_Rs = USER_MOTOR_Rs;
10007edc:	e51b3008 	ldr	r3, [fp, #-8]
10007ee0:	e30224dd 	movw	r2, #9437	; 0x24dd
10007ee4:	e3442112 	movt	r2, #16658	; 0x4112
10007ee8:	e5832070 	str	r2, [r3, #112]	; 0x70
  pUserParams->motor_Ls_d = USER_MOTOR_Ls_d;
10007eec:	e51b3008 	ldr	r3, [fp, #-8]
10007ef0:	e30e2ec3 	movw	r2, #61123	; 0xeec3
10007ef4:	e343291e 	movt	r2, #14622	; 0x391e
10007ef8:	e5832074 	str	r2, [r3, #116]	; 0x74
  pUserParams->motor_Ls_q = USER_MOTOR_Ls_q;
10007efc:	e51b3008 	ldr	r3, [fp, #-8]
10007f00:	e30d23c2 	movw	r2, #54210	; 0xd3c2
10007f04:	e3432a16 	movt	r2, #14870	; 0x3a16
10007f08:	e5832078 	str	r2, [r3, #120]	; 0x78

  pUserParams->maxCurrent_resEst = USER_MOTOR_RES_EST_CURRENT;
10007f0c:	e51b3008 	ldr	r3, [fp, #-8]
10007f10:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
10007f14:	e5832080 	str	r2, [r3, #128]	; 0x80
  pUserParams->maxCurrent_indEst = USER_MOTOR_IND_EST_CURRENT;
10007f18:	e51b3008 	ldr	r3, [fp, #-8]
10007f1c:	e3a02000 	mov	r2, #0
10007f20:	e34b2f80 	movt	r2, #49024	; 0xbf80
10007f24:	e5832084 	str	r2, [r3, #132]	; 0x84
  pUserParams->maxCurrent = USER_MOTOR_MAX_CURRENT;
10007f28:	e51b3008 	ldr	r3, [fp, #-8]
10007f2c:	e3a02000 	mov	r2, #0
10007f30:	e3442060 	movt	r2, #16480	; 0x4060
10007f34:	e583207c 	str	r2, [r3, #124]	; 0x7c

  pUserParams->maxCurrentSlope = USER_MAX_CURRENT_SLOPE;
10007f38:	e51b3008 	ldr	r3, [fp, #-8]
10007f3c:	e30327bd 	movw	r2, #14269	; 0x37bd
10007f40:	e3432686 	movt	r2, #13958	; 0x3686
10007f44:	e5832088 	str	r2, [r3, #136]	; 0x88
  pUserParams->maxCurrentSlope_powerWarp = USER_MAX_CURRENT_SLOPE_POWERWARP;
10007f48:	e51b3008 	ldr	r3, [fp, #-8]
10007f4c:	e3a02efb 	mov	r2, #4016	; 0xfb0
10007f50:	e34325a1 	movt	r2, #13729	; 0x35a1
10007f54:	e583208c 	str	r2, [r3, #140]	; 0x8c

  pUserParams->IdRated = USER_MOTOR_MAGNETIZING_CURRENT;
10007f58:	e51b3008 	ldr	r3, [fp, #-8]
10007f5c:	e3a02000 	mov	r2, #0
10007f60:	e5832090 	str	r2, [r3, #144]	; 0x90
  pUserParams->IdRatedFraction_ratedFlux = USER_IDRATED_FRACTION_FOR_RATED_FLUX;
10007f64:	e51b3008 	ldr	r3, [fp, #-8]
10007f68:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
10007f6c:	e5832098 	str	r2, [r3, #152]	; 0x98
  pUserParams->IdRatedFraction_indEst = USER_IDRATED_FRACTION_FOR_L_IDENT;
10007f70:	e51b3008 	ldr	r3, [fp, #-8]
10007f74:	e3a025fe 	mov	r2, #1065353216	; 0x3f800000
10007f78:	e5832094 	str	r2, [r3, #148]	; 0x94
  pUserParams->IdRated_delta = USER_IDRATED_DELTA;
10007f7c:	e51b3008 	ldr	r3, [fp, #-8]
10007f80:	e30c25ac 	movw	r2, #50604	; 0xc5ac
10007f84:	e34327a7 	movt	r2, #14247	; 0x37a7
10007f88:	e583209c 	str	r2, [r3, #156]	; 0x9c

  pUserParams->fluxEstFreq_Hz = USER_MOTOR_FLUX_EST_FREQ_Hz;
10007f8c:	e51b3008 	ldr	r3, [fp, #-8]
10007f90:	e3a02000 	mov	r2, #0
10007f94:	e34421a0 	movt	r2, #16800	; 0x41a0
10007f98:	e58320a0 	str	r2, [r3, #160]	; 0xa0
  pUserParams->ctrlWaitTime[CTRL_State_Error]         = 0;
10007f9c:	e51b3008 	ldr	r3, [fp, #-8]
10007fa0:	e3a02000 	mov	r2, #0
10007fa4:	e58320a4 	str	r2, [r3, #164]	; 0xa4
  pUserParams->ctrlWaitTime[CTRL_State_Idle]          = 0;
10007fa8:	e51b3008 	ldr	r3, [fp, #-8]
10007fac:	e3a02000 	mov	r2, #0
10007fb0:	e58320a8 	str	r2, [r3, #168]	; 0xa8
  pUserParams->ctrlWaitTime[CTRL_State_OffLine]       = (uint_least32_t)( 5.0f * USER_CTRL_FREQ_Hz);
10007fb4:	e51b3008 	ldr	r3, [fp, #-8]
10007fb8:	e30f2424 	movw	r2, #62500	; 0xf424
10007fbc:	e58320ac 	str	r2, [r3, #172]	; 0xac
  pUserParams->ctrlWaitTime[CTRL_State_OnLine]        = 0;
10007fc0:	e51b3008 	ldr	r3, [fp, #-8]
10007fc4:	e3a02000 	mov	r2, #0
10007fc8:	e58320c0 	str	r2, [r3, #192]	; 0xc0

  pUserParams->estWaitTime[EST_State_Error]           = 0;
10007fcc:	e51b3008 	ldr	r3, [fp, #-8]
10007fd0:	e3a02000 	mov	r2, #0
10007fd4:	e58320cc 	str	r2, [r3, #204]	; 0xcc
  pUserParams->estWaitTime[EST_State_Idle]            = 0;
10007fd8:	e51b3008 	ldr	r3, [fp, #-8]
10007fdc:	e3a02000 	mov	r2, #0
10007fe0:	e58320d0 	str	r2, [r3, #208]	; 0xd0
  pUserParams->estWaitTime[EST_State_RoverL]          = (uint_least32_t)( 8.0f * USER_EST_FREQ_Hz);
10007fe4:	e51b2008 	ldr	r2, [fp, #-8]
10007fe8:	e30836a0 	movw	r3, #34464	; 0x86a0
10007fec:	e3403001 	movt	r3, #1
10007ff0:	e58230d4 	str	r3, [r2, #212]	; 0xd4
  pUserParams->estWaitTime[EST_State_Rs]              = 0;
10007ff4:	e51b3008 	ldr	r3, [fp, #-8]
10007ff8:	e3a02000 	mov	r2, #0
10007ffc:	e58320d8 	str	r2, [r3, #216]	; 0xd8
  pUserParams->estWaitTime[EST_State_RampUp]          = (uint_least32_t)((5.0f + USER_MOTOR_FLUX_EST_FREQ_Hz / USER_MAX_ACCEL_EST_Hzps) * USER_EST_FREQ_Hz);
10008000:	e51b2008 	ldr	r2, [fp, #-8]
10008004:	e30b3774 	movw	r3, #46964	; 0xb774
10008008:	e3403001 	movt	r3, #1
1000800c:	e58230dc 	str	r3, [r2, #220]	; 0xdc
  pUserParams->estWaitTime[EST_State_IdRated]         = (uint_least32_t)(30.0f * USER_EST_FREQ_Hz);
10008010:	e51b2008 	ldr	r2, [fp, #-8]
10008014:	e30b38d8 	movw	r3, #47320	; 0xb8d8
10008018:	e3403005 	movt	r3, #5
1000801c:	e58230e0 	str	r3, [r2, #224]	; 0xe0
  pUserParams->estWaitTime[EST_State_RatedFlux_OL]    = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
10008020:	e51b3008 	ldr	r3, [fp, #-8]
10008024:	e30029c4 	movw	r2, #2500	; 0x9c4
10008028:	e58320e4 	str	r2, [r3, #228]	; 0xe4
  pUserParams->estWaitTime[EST_State_RatedFlux]       = 0;
1000802c:	e51b3008 	ldr	r3, [fp, #-8]
10008030:	e3a02000 	mov	r2, #0
10008034:	e58320e8 	str	r2, [r3, #232]	; 0xe8
  pUserParams->estWaitTime[EST_State_RampDown]        = (uint_least32_t)( 2.0f * USER_EST_FREQ_Hz);
10008038:	e51b3008 	ldr	r3, [fp, #-8]
1000803c:	e30621a8 	movw	r2, #25000	; 0x61a8
10008040:	e58320ec 	str	r2, [r3, #236]	; 0xec
  pUserParams->estWaitTime[EST_State_LockRotor]       = 0;
10008044:	e51b3008 	ldr	r3, [fp, #-8]
10008048:	e3a02000 	mov	r2, #0
1000804c:	e58320f0 	str	r2, [r3, #240]	; 0xf0
  pUserParams->estWaitTime[EST_State_Ls]              = 0;
10008050:	e51b3008 	ldr	r3, [fp, #-8]
10008054:	e3a02000 	mov	r2, #0
10008058:	e58320f4 	str	r2, [r3, #244]	; 0xf4
  pUserParams->estWaitTime[EST_State_Rr]              = (uint_least32_t)(20.0f * USER_EST_FREQ_Hz);
1000805c:	e51b2008 	ldr	r2, [fp, #-8]
10008060:	e30d3090 	movw	r3, #53392	; 0xd090
10008064:	e3403003 	movt	r3, #3
10008068:	e58230f8 	str	r3, [r2, #248]	; 0xf8
  pUserParams->estWaitTime[EST_State_MotorIdentified] = 0;
1000806c:	e51b3008 	ldr	r3, [fp, #-8]
10008070:	e3a02000 	mov	r2, #0
10008074:	e58320fc 	str	r2, [r3, #252]	; 0xfc
  pUserParams->estWaitTime[EST_State_OnLine]          = 0;
10008078:	e51b3008 	ldr	r3, [fp, #-8]
1000807c:	e3a02000 	mov	r2, #0
10008080:	e5832100 	str	r2, [r3, #256]	; 0x100

  pUserParams->FluxWaitTime[EST_Flux_State_Error]     = 0;
10008084:	e51b3008 	ldr	r3, [fp, #-8]
10008088:	e3a02000 	mov	r2, #0
1000808c:	e5832104 	str	r2, [r3, #260]	; 0x104
  pUserParams->FluxWaitTime[EST_Flux_State_Idle]      = 0;
10008090:	e51b3008 	ldr	r3, [fp, #-8]
10008094:	e3a02000 	mov	r2, #0
10008098:	e5832108 	str	r2, [r3, #264]	; 0x108
  pUserParams->FluxWaitTime[EST_Flux_State_CL1]       = (uint_least32_t)(10.0f * USER_EST_FREQ_Hz);
1000809c:	e51b2008 	ldr	r2, [fp, #-8]
100080a0:	e30e3848 	movw	r3, #59464	; 0xe848
100080a4:	e3403001 	movt	r3, #1
100080a8:	e582310c 	str	r3, [r2, #268]	; 0x10c
  pUserParams->FluxWaitTime[EST_Flux_State_CL2]       = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
100080ac:	e51b3008 	ldr	r3, [fp, #-8]
100080b0:	e30029c4 	movw	r2, #2500	; 0x9c4
100080b4:	e5832110 	str	r2, [r3, #272]	; 0x110
  pUserParams->FluxWaitTime[EST_Flux_State_Fine]      = (uint_least32_t)( 4.0f * USER_EST_FREQ_Hz);
100080b8:	e51b3008 	ldr	r3, [fp, #-8]
100080bc:	e30c2350 	movw	r2, #50000	; 0xc350
100080c0:	e5832114 	str	r2, [r3, #276]	; 0x114
  pUserParams->FluxWaitTime[EST_Flux_State_Done]      = 0;
100080c4:	e51b3008 	ldr	r3, [fp, #-8]
100080c8:	e3a02000 	mov	r2, #0
100080cc:	e5832118 	str	r2, [r3, #280]	; 0x118

  pUserParams->LsWaitTime[EST_Ls_State_Error]        = 0;
100080d0:	e51b3008 	ldr	r3, [fp, #-8]
100080d4:	e3a02000 	mov	r2, #0
100080d8:	e583211c 	str	r2, [r3, #284]	; 0x11c
  pUserParams->LsWaitTime[EST_Ls_State_Idle]         = 0;
100080dc:	e51b3008 	ldr	r3, [fp, #-8]
100080e0:	e3a02000 	mov	r2, #0
100080e4:	e5832120 	str	r2, [r3, #288]	; 0x120
  pUserParams->LsWaitTime[EST_Ls_State_RampUp]       = (uint_least32_t)( 3.0f * USER_EST_FREQ_Hz);
100080e8:	e51b3008 	ldr	r3, [fp, #-8]
100080ec:	e309227c 	movw	r2, #37500	; 0x927c
100080f0:	e5832124 	str	r2, [r3, #292]	; 0x124
  pUserParams->LsWaitTime[EST_Ls_State_Init]         = (uint_least32_t)( 3.0f * USER_EST_FREQ_Hz);
100080f4:	e51b3008 	ldr	r3, [fp, #-8]
100080f8:	e309227c 	movw	r2, #37500	; 0x927c
100080fc:	e5832128 	str	r2, [r3, #296]	; 0x128
  pUserParams->LsWaitTime[EST_Ls_State_Coarse]       = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
10008100:	e51b3008 	ldr	r3, [fp, #-8]
10008104:	e30029c4 	movw	r2, #2500	; 0x9c4
10008108:	e583212c 	str	r2, [r3, #300]	; 0x12c
  pUserParams->LsWaitTime[EST_Ls_State_Fine]         = (uint_least32_t)(30.0f * USER_EST_FREQ_Hz);
1000810c:	e51b2008 	ldr	r2, [fp, #-8]
10008110:	e30b38d8 	movw	r3, #47320	; 0xb8d8
10008114:	e3403005 	movt	r3, #5
10008118:	e5823130 	str	r3, [r2, #304]	; 0x130
  pUserParams->LsWaitTime[EST_Ls_State_Done]         = 0;
1000811c:	e51b3008 	ldr	r3, [fp, #-8]
10008120:	e3a02000 	mov	r2, #0
10008124:	e5832134 	str	r2, [r3, #308]	; 0x134

  pUserParams->RsWaitTime[EST_Rs_State_Error]        = 0;
10008128:	e51b3008 	ldr	r3, [fp, #-8]
1000812c:	e3a02000 	mov	r2, #0
10008130:	e5832138 	str	r2, [r3, #312]	; 0x138
  pUserParams->RsWaitTime[EST_Rs_State_Idle]         = 0;
10008134:	e51b3008 	ldr	r3, [fp, #-8]
10008138:	e3a02000 	mov	r2, #0
1000813c:	e583213c 	str	r2, [r3, #316]	; 0x13c
  pUserParams->RsWaitTime[EST_Rs_State_RampUp]       = (uint_least32_t)( 1.0f * USER_EST_FREQ_Hz);
10008140:	e51b3008 	ldr	r3, [fp, #-8]
10008144:	e30320d4 	movw	r2, #12500	; 0x30d4
10008148:	e5832140 	str	r2, [r3, #320]	; 0x140
  pUserParams->RsWaitTime[EST_Rs_State_Coarse]       = (uint_least32_t)( 2.0f * USER_EST_FREQ_Hz);
1000814c:	e51b3008 	ldr	r3, [fp, #-8]
10008150:	e30621a8 	movw	r2, #25000	; 0x61a8
10008154:	e5832144 	str	r2, [r3, #324]	; 0x144
  pUserParams->RsWaitTime[EST_Rs_State_Fine]         = (uint_least32_t)( 7.0f * USER_EST_FREQ_Hz);
10008158:	e51b2008 	ldr	r2, [fp, #-8]
1000815c:	e30535cc 	movw	r3, #21964	; 0x55cc
10008160:	e3403001 	movt	r3, #1
10008164:	e5823148 	str	r3, [r2, #328]	; 0x148
  pUserParams->RsWaitTime[EST_Rs_State_Done]         = 0;
10008168:	e51b3008 	ldr	r3, [fp, #-8]
1000816c:	e3a02000 	mov	r2, #0
10008170:	e583214c 	str	r2, [r3, #332]	; 0x14c
  pUserParams->ctrlFreq_Hz = USER_CTRL_FREQ_Hz;//USER_CTRL_FREQ_Hz:12500
10008174:	e51b3008 	ldr	r3, [fp, #-8]
10008178:	e30320d4 	movw	r2, #12500	; 0x30d4
1000817c:	e5832150 	str	r2, [r3, #336]	; 0x150

  pUserParams->estFreq_Hz = USER_EST_FREQ_Hz;
10008180:	e51b3008 	ldr	r3, [fp, #-8]
10008184:	e30320d4 	movw	r2, #12500	; 0x30d4
10008188:	e5832154 	str	r2, [r3, #340]	; 0x154

  pUserParams->RoverL_estFreq_Hz = USER_R_OVER_L_EST_FREQ_Hz;
1000818c:	e51b3008 	ldr	r3, [fp, #-8]
10008190:	e3a02f4b 	mov	r2, #300	; 0x12c
10008194:	e5832158 	str	r2, [r3, #344]	; 0x158

  pUserParams->trajFreq_Hz = USER_TRAJ_FREQ_Hz;
10008198:	e51b3008 	ldr	r3, [fp, #-8]
1000819c:	e3a02901 	mov	r2, #16384	; 0x4000
100081a0:	e344249c 	movt	r2, #17564	; 0x449c
100081a4:	e583215c 	str	r2, [r3, #348]	; 0x15c

  pUserParams->ctrlPeriod_sec = USER_CTRL_PERIOD_sec;
100081a8:	e51b3008 	ldr	r3, [fp, #-8]
100081ac:	e30c25ac 	movw	r2, #50604	; 0xc5ac
100081b0:	e34328a7 	movt	r2, #14503	; 0x38a7
100081b4:	e5832160 	str	r2, [r3, #352]	; 0x160

  pUserParams->maxNegativeIdCurrent_a = USER_MAX_NEGATIVE_ID_REF_CURRENT_A;
100081b8:	e51b3008 	ldr	r3, [fp, #-8]
100081bc:	e3a02000 	mov	r2, #0
100081c0:	e34b2fe0 	movt	r2, #49120	; 0xbfe0
100081c4:	e5832164 	str	r2, [r3, #356]	; 0x164
} // end of USER_setParams() function
100081c8:	e24bd000 	sub	sp, fp, #0
100081cc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100081d0:	e12fff1e 	bx	lr

100081d4 <USER_checkForErrors>:


void USER_checkForErrors(USER_Params *pUserParams)
{
100081d4:	e92d4800 	push	{fp, lr}
100081d8:	e28db004 	add	fp, sp, #4
100081dc:	e24dd008 	sub	sp, sp, #8
100081e0:	e50b0008 	str	r0, [fp, #-8]
  USER_setErrorCode(pUserParams, USER_ErrorCode_NoError);
100081e4:	e51b0008 	ldr	r0, [fp, #-8]
100081e8:	e3a01000 	mov	r1, #0
100081ec:	eb00001e 	bl	1000826c <USER_setErrorCode>

  if((USER_MOTOR_RATED_FLUX > 0.0f) && (USER_MOTOR_TYPE == MOTOR_Type_Pm))
    {
      if(USER_IQ_FULL_SCALE_VOLTAGE_V >= ((float_t)USER_EST_FREQ_Hz * USER_MOTOR_RATED_FLUX * 0.7f))
        {
          USER_setErrorCode(pUserParams, USER_ErrorCode_iqFullScaleVoltage_V_High);
100081f0:	e51b0008 	ldr	r0, [fp, #-8]
100081f4:	e3a01003 	mov	r1, #3
100081f8:	eb00001b 	bl	1000826c <USER_setErrorCode>
    (USER_IQ_FULL_SCALE_FREQ_Hz <= ((float_t)USER_MOTOR_NUM_POLE_PAIRS * 1000.0f / (60.0f * 128.0f))) ||
    (USER_IQ_FULL_SCALE_FREQ_Hz < (USER_MAX_ACCEL_Hzps / ((float_t)USER_TRAJ_FREQ_Hz))) ||
    (USER_IQ_FULL_SCALE_FREQ_Hz < (USER_MAX_ACCEL_EST_Hzps / ((float_t)USER_TRAJ_FREQ_Hz))) ||
    (USER_IQ_FULL_SCALE_FREQ_Hz < ((float_t)USER_R_OVER_L_EST_FREQ_Hz)))
    {
	  USER_setErrorCode(pUserParams, USER_ErrorCode_iqFullScaleFreq_Hz_Low);
100081fc:	e51b0008 	ldr	r0, [fp, #-8]
10008200:	e3a01006 	mov	r1, #6
10008204:	eb000018 	bl	1000826c <USER_setErrorCode>
          USER_setErrorCode(pUserParams, USER_ErrorCode_motor_ratedFlux_High);
        }

      if(USER_MOTOR_RATED_FLUX < (USER_IQ_FULL_SCALE_VOLTAGE_V / (float_t)USER_EST_FREQ_Hz / 0.7f))
        {
          USER_setErrorCode(pUserParams, USER_ErrorCode_motor_ratedFlux_Low);
10008208:	e51b0008 	ldr	r0, [fp, #-8]
1000820c:	e3a01041 	mov	r1, #65	; 0x41
10008210:	eb000015 	bl	1000826c <USER_setErrorCode>

  if(USER_MOTOR_TYPE == MOTOR_Type_Pm)
    {
      if(USER_MOTOR_Rr > 0.0f)
        {
          USER_setErrorCode(pUserParams, USER_ErrorCode_motor_Rr_High);
10008214:	e51b0008 	ldr	r0, [fp, #-8]
10008218:	e3a01042 	mov	r1, #66	; 0x42
1000821c:	eb000012 	bl	1000826c <USER_setErrorCode>
  if((USER_MOTOR_Rs != 0.0f) && (USER_MOTOR_Ls_d != 0.0f) && (USER_MOTOR_Ls_q != 0.0f))
    {
      if(((float_t)USER_CTRL_FREQ_Hz <= (USER_MOTOR_Rs / (USER_MOTOR_Ls_d + 1e-9f))) ||
        ((float_t)USER_CTRL_FREQ_Hz <= (USER_MOTOR_Rs / (USER_MOTOR_Ls_q + 1e-9f))))
        {
          USER_setErrorCode(pUserParams, USER_ErrorCode_ctrlFreq_Hz_Low);
10008220:	e51b0008 	ldr	r0, [fp, #-8]
10008224:	e3a0105f 	mov	r1, #95	; 0x5f
10008228:	eb00000f 	bl	1000826c <USER_setErrorCode>
      USER_setErrorCode(pUserParams, USER_ErrorCode_estFreq_Hz_Low);
    }

  if(USER_R_OVER_L_EST_FREQ_Hz > USER_IQ_FULL_SCALE_FREQ_Hz)
    {
      USER_setErrorCode(pUserParams, USER_ErrorCode_RoverL_estFreq_Hz_High);
1000822c:	e51b0008 	ldr	r0, [fp, #-8]
10008230:	e3a01062 	mov	r1, #98	; 0x62
10008234:	eb00000c 	bl	1000826c <USER_setErrorCode>
  if(USER_MAX_NEGATIVE_ID_REF_CURRENT_A < (-USER_MOTOR_MAX_CURRENT))
    {
      USER_setErrorCode(pUserParams, USER_ErrorCode_maxNegativeIdCurrent_a_Low);
    }

  return;
10008238:	e1a00000 	nop			; (mov r0, r0)
} // end of USER_checkForErrors() function
1000823c:	e24bd004 	sub	sp, fp, #4
10008240:	e8bd8800 	pop	{fp, pc}

10008244 <USER_getErrorCode>:


USER_ErrorCode_e USER_getErrorCode(USER_Params *pUserParams)
{
10008244:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008248:	e28db000 	add	fp, sp, #0
1000824c:	e24dd00c 	sub	sp, sp, #12
10008250:	e50b0008 	str	r0, [fp, #-8]
  return(pUserParams->errorCode);
10008254:	e51b3008 	ldr	r3, [fp, #-8]
10008258:	e5d33168 	ldrb	r3, [r3, #360]	; 0x168
} // end of USER_getErrorCode() function
1000825c:	e1a00003 	mov	r0, r3
10008260:	e24bd000 	sub	sp, fp, #0
10008264:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008268:	e12fff1e 	bx	lr

1000826c <USER_setErrorCode>:


void USER_setErrorCode(USER_Params *pUserParams,const USER_ErrorCode_e errorCode)
{
1000826c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008270:	e28db000 	add	fp, sp, #0
10008274:	e24dd00c 	sub	sp, sp, #12
10008278:	e50b0008 	str	r0, [fp, #-8]
1000827c:	e1a03001 	mov	r3, r1
10008280:	e54b3009 	strb	r3, [fp, #-9]
  pUserParams->errorCode = errorCode;
10008284:	e51b3008 	ldr	r3, [fp, #-8]
10008288:	e55b2009 	ldrb	r2, [fp, #-9]
1000828c:	e5c32168 	strb	r2, [r3, #360]	; 0x168

  return;
10008290:	e1a00000 	nop			; (mov r0, r0)
} // end of USER_setErrorCode() function
10008294:	e24bd000 	sub	sp, fp, #0
10008298:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000829c:	e12fff1e 	bx	lr

100082a0 <USER_softwareUpdate1p6>:


void USER_softwareUpdate1p6(CTRL_Handle handle)
{
100082a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100082a4:	e28db000 	add	fp, sp, #0
100082a8:	e24dd00c 	sub	sp, sp, #12
100082ac:	e50b0008 	str	r0, [fp, #-8]
//  // store the results
//  EST_setLs_d_pu(obj->estHandle,Ls_d_pu);
//  EST_setLs_q_pu(obj->estHandle,Ls_q_pu);
//  EST_setLs_qFmt(obj->estHandle,Ls_qFmt);

  return;
100082b0:	e1a00000 	nop			; (mov r0, r0)
} // end of softwareUpdate1p6() function
100082b4:	e24bd000 	sub	sp, fp, #0
100082b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100082bc:	e12fff1e 	bx	lr

100082c0 <USER_calcPIgains>:


void USER_calcPIgains(CTRL_Handle handle)
{
100082c0:	e92d4800 	push	{fp, lr}
100082c4:	e28db004 	add	fp, sp, #4
100082c8:	e24dd040 	sub	sp, sp, #64	; 0x40
100082cc:	e50b0040 	str	r0, [fp, #-64]	; 0x40
  CTRL_Obj *obj = (CTRL_Obj *)handle;
100082d0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100082d4:	e50b3008 	str	r3, [fp, #-8]
  float_t fullScaleCurrent = USER_IQ_FULL_SCALE_CURRENT_A;
100082d8:	e3a03000 	mov	r3, #0
100082dc:	e3443348 	movt	r3, #17224	; 0x4348
100082e0:	e50b300c 	str	r3, [fp, #-12]
  float_t fullScaleVoltage = USER_IQ_FULL_SCALE_VOLTAGE_V;
100082e4:	e3a03000 	mov	r3, #0
100082e8:	e34434c8 	movt	r3, #17608	; 0x44c8
100082ec:	e50b3010 	str	r3, [fp, #-16]
  float_t ctrlPeriod_sec = CTRL_getCtrlPeriod_sec(handle);
100082f0:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
100082f4:	ebfffe72 	bl	10007cc4 <CTRL_getCtrlPeriod_sec>
100082f8:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  Ls_q = *((float_t *)&tmp);

  tmp = EST_getRs_Ohm(obj->estHandle);
  Rs = *((float_t *)&tmp);
#else
  Ls_d = EST_getLs_d_H(obj->estHandle);
100082fc:	e51b3008 	ldr	r3, [fp, #-8]
10008300:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10008304:	e1a00003 	mov	r0, r3
10008308:	ebfffa84 	bl	10006d20 <EST_getLs_d_H>
1000830c:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8

  Ls_q = EST_getLs_q_H(obj->estHandle);
10008310:	e51b3008 	ldr	r3, [fp, #-8]
10008314:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10008318:	e1a00003 	mov	r0, r3
1000831c:	ebfffa93 	bl	10006d70 <EST_getLs_q_H>
10008320:	ed0b0a07 	vstr	s0, [fp, #-28]	; 0xffffffe4

  Rs = EST_getRs_Ohm(obj->estHandle);
10008324:	e51b3008 	ldr	r3, [fp, #-8]
10008328:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000832c:	e1a00003 	mov	r0, r3
10008330:	ebfffaa2 	bl	10006dc0 <EST_getRs_Ohm>
10008334:	ed0b0a08 	vstr	s0, [fp, #-32]	; 0xffffffe0
#endif

  RoverLs_d = Rs/Ls_d;
10008338:	ed1b7a08 	vldr	s14, [fp, #-32]	; 0xffffffe0
1000833c:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
10008340:	eec77a27 	vdiv.f32	s15, s14, s15
10008344:	ed4b7a09 	vstr	s15, [fp, #-36]	; 0xffffffdc
  Kp_Id = ((0.25f*Ls_d*fullScaleCurrent)/(ctrlPeriod_sec*fullScaleVoltage));
10008348:	ed1b7a06 	vldr	s14, [fp, #-24]	; 0xffffffe8
1000834c:	ed5b7a03 	vldr	s15, [fp, #-12]
10008350:	ee677a27 	vmul.f32	s15, s14, s15
10008354:	eeb57a00 	vmov.f32	s14, #80	; 0x50
10008358:	ee277a87 	vmul.f32	s14, s15, s14
1000835c:	ed5b6a05 	vldr	s13, [fp, #-20]	; 0xffffffec
10008360:	ed5b7a04 	vldr	s15, [fp, #-16]
10008364:	ee667aa7 	vmul.f32	s15, s13, s15
10008368:	eec77a27 	vdiv.f32	s15, s14, s15
1000836c:	ed4b7a0a 	vstr	s15, [fp, #-40]	; 0xffffffd8
  Ki_Id = (RoverLs_d*ctrlPeriod_sec);
10008370:	ed1b7a09 	vldr	s14, [fp, #-36]	; 0xffffffdc
10008374:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
10008378:	ee677a27 	vmul.f32	s15, s14, s15
1000837c:	ed4b7a0b 	vstr	s15, [fp, #-44]	; 0xffffffd4

  RoverLs_q = Rs/Ls_q;
10008380:	ed1b7a08 	vldr	s14, [fp, #-32]	; 0xffffffe0
10008384:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
10008388:	eec77a27 	vdiv.f32	s15, s14, s15
1000838c:	ed4b7a0c 	vstr	s15, [fp, #-48]	; 0xffffffd0
  Kp_Iq = ((0.25f*Ls_q*fullScaleCurrent)/(ctrlPeriod_sec*fullScaleVoltage));
10008390:	ed1b7a07 	vldr	s14, [fp, #-28]	; 0xffffffe4
10008394:	ed5b7a03 	vldr	s15, [fp, #-12]
10008398:	ee677a27 	vmul.f32	s15, s14, s15
1000839c:	eeb57a00 	vmov.f32	s14, #80	; 0x50
100083a0:	ee277a87 	vmul.f32	s14, s15, s14
100083a4:	ed5b6a05 	vldr	s13, [fp, #-20]	; 0xffffffec
100083a8:	ed5b7a04 	vldr	s15, [fp, #-16]
100083ac:	ee667aa7 	vmul.f32	s15, s13, s15
100083b0:	eec77a27 	vdiv.f32	s15, s14, s15
100083b4:	ed4b7a0d 	vstr	s15, [fp, #-52]	; 0xffffffcc
  Ki_Iq = (RoverLs_q*ctrlPeriod_sec);
100083b8:	ed1b7a0c 	vldr	s14, [fp, #-48]	; 0xffffffd0
100083bc:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
100083c0:	ee677a27 	vmul.f32	s15, s14, s15
100083c4:	ed4b7a0e 	vstr	s15, [fp, #-56]	; 0xffffffc8

  Kd = (0.0f);
100083c8:	e3a03000 	mov	r3, #0
100083cc:	e50b303c 	str	r3, [fp, #-60]	; 0x3c

  // set the Id controller gains
  PID_setKi(obj->pidHandle_Id,Ki_Id);
100083d0:	e51b3008 	ldr	r3, [fp, #-8]
100083d4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
100083d8:	e1a00003 	mov	r0, r3
100083dc:	ed1b0a0b 	vldr	s0, [fp, #-44]	; 0xffffffd4
100083e0:	ebfffe29 	bl	10007c8c <PID_setKi>
  CTRL_setGains(handle,CTRL_Type_PID_Id,Kp_Id,Ki_Id,Kd);
100083e4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
100083e8:	e3a01001 	mov	r1, #1
100083ec:	ed1b0a0a 	vldr	s0, [fp, #-40]	; 0xffffffd8
100083f0:	ed5b0a0b 	vldr	s1, [fp, #-44]	; 0xffffffd4
100083f4:	ed1b1a0f 	vldr	s2, [fp, #-60]	; 0xffffffc4
100083f8:	ebfff4e3 	bl	1000578c <CTRL_setGains>

  // set the Iq controller gains
  PID_setKi(obj->pidHandle_Iq,Ki_Iq);
100083fc:	e51b3008 	ldr	r3, [fp, #-8]
10008400:	e5933060 	ldr	r3, [r3, #96]	; 0x60
10008404:	e1a00003 	mov	r0, r3
10008408:	ed1b0a0e 	vldr	s0, [fp, #-56]	; 0xffffffc8
1000840c:	ebfffe1e 	bl	10007c8c <PID_setKi>
  CTRL_setGains(handle,CTRL_Type_PID_Iq,Kp_Iq,Ki_Iq,Kd);
10008410:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
10008414:	e3a01002 	mov	r1, #2
10008418:	ed1b0a0d 	vldr	s0, [fp, #-52]	; 0xffffffcc
1000841c:	ed5b0a0e 	vldr	s1, [fp, #-56]	; 0xffffffc8
10008420:	ed1b1a0f 	vldr	s2, [fp, #-60]	; 0xffffffc4
10008424:	ebfff4d8 	bl	1000578c <CTRL_setGains>

  return;
10008428:	e1a00000 	nop			; (mov r0, r0)
} // end of calcPIgains() function
1000842c:	e24bd004 	sub	sp, fp, #4
10008430:	e8bd8800 	pop	{fp, pc}

10008434 <USER_computeTorque_Ls_Id_Iq_pu_to_Nm_sf>:


//! \brief     Computes the scale factor needed to convert from torque created by Ld, Lq, Id and Iq, from per unit to Nm
//!
float_t USER_computeTorque_Ls_Id_Iq_pu_to_Nm_sf(void)
{
10008434:	e92d4800 	push	{fp, lr}
10008438:	ed2d8b02 	vpush	{d8}
1000843c:	e28db00c 	add	fp, sp, #12
10008440:	e24dd010 	sub	sp, sp, #16
  float_t FullScaleInductance = (USER_IQ_FULL_SCALE_VOLTAGE_V/(USER_IQ_FULL_SCALE_CURRENT_A*USER_VOLTAGE_FILTER_POLE_rps));
10008444:	e30931dc 	movw	r3, #37340	; 0x91dc
10008448:	e3433ae6 	movt	r3, #15078	; 0x3ae6
1000844c:	e50b3010 	str	r3, [fp, #-16]
  float_t FullScaleCurrent = (USER_IQ_FULL_SCALE_CURRENT_A);
10008450:	e3a03000 	mov	r3, #0
10008454:	e3443348 	movt	r3, #17224	; 0x4348
10008458:	e50b3014 	str	r3, [fp, #-20]
  float_t lShift = ceil(log(USER_MOTOR_Ls_d/(0.7f*FullScaleInductance))/log(2.0f));
1000845c:	ed9f7a23 	vldr	s14, [pc, #140]	; 100084f0 <USER_computeTorque_Ls_Id_Iq_pu_to_Nm_sf+0xbc>
10008460:	ed5b7a04 	vldr	s15, [fp, #-16]
10008464:	eec77a27 	vdiv.f32	s15, s14, s15
10008468:	eef70ae7 	vcvt.f64.f32	d16, s15
1000846c:	eeb00b60 	vmov.f64	d0, d16
10008470:	fa00a0af 	blx	10030734 <log>
10008474:	eef01b40 	vmov.f64	d17, d0
10008478:	eddf0b1a 	vldr	d16, [pc, #104]	; 100084e8 <USER_computeTorque_Ls_Id_Iq_pu_to_Nm_sf+0xb4>
1000847c:	eec10ba0 	vdiv.f64	d16, d17, d16
10008480:	eeb00b60 	vmov.f64	d0, d16
10008484:	fa00a01f 	blx	10030508 <ceil>
10008488:	eef00b40 	vmov.f64	d16, d0
1000848c:	eef77be0 	vcvt.f32.f64	s15, d16
10008490:	ed4b7a06 	vstr	s15, [fp, #-24]	; 0xffffffe8

  return((FullScaleInductance*FullScaleCurrent*FullScaleCurrent*USER_MOTOR_NUM_POLE_PAIRS*1.5f*pow(2.0f,lShift)));
10008494:	ed1b7a04 	vldr	s14, [fp, #-16]
10008498:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
1000849c:	ee277a27 	vmul.f32	s14, s14, s15
100084a0:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
100084a4:	ee677a27 	vmul.f32	s15, s14, s15
100084a8:	eeb17a08 	vmov.f32	s14, #24
100084ac:	ee677a87 	vmul.f32	s15, s15, s14
100084b0:	eeb78ae7 	vcvt.f64.f32	d8, s15
100084b4:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
100084b8:	eef70ae7 	vcvt.f64.f32	d16, s15
100084bc:	eeb00b00 	vmov.f64	d0, #0
100084c0:	eeb01b60 	vmov.f64	d1, d16
100084c4:	fa00a0d9 	blx	10030830 <pow>
100084c8:	eef00b40 	vmov.f64	d16, d0
100084cc:	ee680b20 	vmul.f64	d16, d8, d16
100084d0:	eef77be0 	vcvt.f32.f64	s15, d16
} // end of USER_computeTorque_Ls_Id_Iq_pu_to_Nm_sf() function
100084d4:	eeb00a67 	vmov.f32	s0, s15
100084d8:	e24bd00c 	sub	sp, fp, #12
100084dc:	ecbd8b02 	vpop	{d8}
100084e0:	e8bd8800 	pop	{fp, pc}
100084e4:	e320f000 	nop	{0}
100084e8:	fefa39ef 	.word	0xfefa39ef
100084ec:	3fe62e42 	.word	0x3fe62e42
100084f0:	39630bf2 	.word	0x39630bf2

100084f4 <USER_computeTorque_Flux_Iq_pu_to_Nm_sf>:


//! \brief     Computes the scale factor needed to convert from torque created by flux and Iq, from per unit to Nm
//!
float_t USER_computeTorque_Flux_Iq_pu_to_Nm_sf(void)
{
100084f4:	e92d4800 	push	{fp, lr}
100084f8:	ed2d8b02 	vpush	{d8}
100084fc:	e28db00c 	add	fp, sp, #12
10008500:	e24dd010 	sub	sp, sp, #16
  float_t FullScaleFlux = (USER_IQ_FULL_SCALE_VOLTAGE_V/(float_t)USER_EST_FREQ_Hz);
10008504:	e301326f 	movw	r3, #4719	; 0x126f
10008508:	e3433e03 	movt	r3, #15875	; 0x3e03
1000850c:	e50b3010 	str	r3, [fp, #-16]
  float_t FullScaleCurrent = (USER_IQ_FULL_SCALE_CURRENT_A);
10008510:	e3a03000 	mov	r3, #0
10008514:	e3443348 	movt	r3, #17224	; 0x4348
10008518:	e50b3014 	str	r3, [fp, #-20]
  float_t maxFlux = (USER_MOTOR_RATED_FLUX*((USER_MOTOR_TYPE==MOTOR_Type_Induction)?0.05f:0.7f));
1000851c:	e3003b8d 	movw	r3, #2957	; 0xb8d
10008520:	e3433d87 	movt	r3, #15751	; 0x3d87
10008524:	e50b3018 	str	r3, [fp, #-24]
  float_t lShift = -ceil(log(FullScaleFlux/maxFlux)/log(2.0f));
10008528:	ed1b7a04 	vldr	s14, [fp, #-16]
1000852c:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
10008530:	eec77a27 	vdiv.f32	s15, s14, s15
10008534:	eef70ae7 	vcvt.f64.f32	d16, s15
10008538:	eeb00b60 	vmov.f64	d0, d16
1000853c:	fa00a07c 	blx	10030734 <log>
10008540:	eef01b40 	vmov.f64	d17, d0
10008544:	eddf0b1b 	vldr	d16, [pc, #108]	; 100085b8 <USER_computeTorque_Flux_Iq_pu_to_Nm_sf+0xc4>
10008548:	eec10ba0 	vdiv.f64	d16, d17, d16
1000854c:	eeb00b60 	vmov.f64	d0, d16
10008550:	fa009fec 	blx	10030508 <ceil>
10008554:	eef00b40 	vmov.f64	d16, d0
10008558:	eef77be0 	vcvt.f32.f64	s15, d16
1000855c:	eef17a67 	vneg.f32	s15, s15
10008560:	ed4b7a07 	vstr	s15, [fp, #-28]	; 0xffffffe4

  return((FullScaleFlux/(2.0f*MATH_PI)*FullScaleCurrent*USER_MOTOR_NUM_POLE_PAIRS*1.5f*pow(2.0f,lShift)));
10008564:	ed5b7a04 	vldr	s15, [fp, #-16]
10008568:	ed9f7a14 	vldr	s14, [pc, #80]	; 100085c0 <USER_computeTorque_Flux_Iq_pu_to_Nm_sf+0xcc>
1000856c:	ee877a87 	vdiv.f32	s14, s15, s14
10008570:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
10008574:	ee677a27 	vmul.f32	s15, s14, s15
10008578:	eeb17a08 	vmov.f32	s14, #24
1000857c:	ee677a87 	vmul.f32	s15, s15, s14
10008580:	eeb78ae7 	vcvt.f64.f32	d8, s15
10008584:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
10008588:	eef70ae7 	vcvt.f64.f32	d16, s15
1000858c:	eeb00b00 	vmov.f64	d0, #0
10008590:	eeb01b60 	vmov.f64	d1, d16
10008594:	fa00a0a5 	blx	10030830 <pow>
10008598:	eef00b40 	vmov.f64	d16, d0
1000859c:	ee680b20 	vmul.f64	d16, d8, d16
100085a0:	eef77be0 	vcvt.f32.f64	s15, d16
} // end of USER_computeTorque_Flux_Iq_pu_to_Nm_sf() function
100085a4:	eeb00a67 	vmov.f32	s0, s15
100085a8:	e24bd00c 	sub	sp, fp, #12
100085ac:	ecbd8b02 	vpop	{d8}
100085b0:	e8bd8800 	pop	{fp, pc}
100085b4:	e320f000 	nop	{0}
100085b8:	fefa39ef 	.word	0xfefa39ef
100085bc:	3fe62e42 	.word	0x3fe62e42
100085c0:	40c90fdb 	.word	0x40c90fdb

100085c4 <USER_computeFlux_pu_to_Wb_sf>:


//! \brief     Computes the scale factor needed to convert from per unit to Wb
//!
float_t USER_computeFlux_pu_to_Wb_sf(void)
{
100085c4:	e92d4800 	push	{fp, lr}
100085c8:	ed2d8b02 	vpush	{d8}
100085cc:	e28db00c 	add	fp, sp, #12
100085d0:	e24dd010 	sub	sp, sp, #16
  float_t FullScaleFlux = (USER_IQ_FULL_SCALE_VOLTAGE_V/(float_t)USER_EST_FREQ_Hz);
100085d4:	e301326f 	movw	r3, #4719	; 0x126f
100085d8:	e3433e03 	movt	r3, #15875	; 0x3e03
100085dc:	e50b3010 	str	r3, [fp, #-16]
  float_t maxFlux = (USER_MOTOR_RATED_FLUX*((USER_MOTOR_TYPE==MOTOR_Type_Induction)?0.05f:0.7f));
100085e0:	e3003b8d 	movw	r3, #2957	; 0xb8d
100085e4:	e3433d87 	movt	r3, #15751	; 0x3d87
100085e8:	e50b3014 	str	r3, [fp, #-20]
  float_t lShift = -ceil(log(FullScaleFlux/maxFlux)/log(2.0f));
100085ec:	ed1b7a04 	vldr	s14, [fp, #-16]
100085f0:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
100085f4:	eec77a27 	vdiv.f32	s15, s14, s15
100085f8:	eef70ae7 	vcvt.f64.f32	d16, s15
100085fc:	eeb00b60 	vmov.f64	d0, d16
10008600:	fa00a04b 	blx	10030734 <log>
10008604:	eef01b40 	vmov.f64	d17, d0
10008608:	eddf0b16 	vldr	d16, [pc, #88]	; 10008668 <USER_computeFlux_pu_to_Wb_sf+0xa4>
1000860c:	eec10ba0 	vdiv.f64	d16, d17, d16
10008610:	eeb00b60 	vmov.f64	d0, d16
10008614:	fa009fbb 	blx	10030508 <ceil>
10008618:	eef00b40 	vmov.f64	d16, d0
1000861c:	eef77be0 	vcvt.f32.f64	s15, d16
10008620:	eef17a67 	vneg.f32	s15, s15
10008624:	ed4b7a06 	vstr	s15, [fp, #-24]	; 0xffffffe8

  return((FullScaleFlux/(2.0f*MATH_PI)*pow(2.0f,lShift)));
10008628:	ed5b7a04 	vldr	s15, [fp, #-16]
1000862c:	ed9f7a0f 	vldr	s14, [pc, #60]	; 10008670 <USER_computeFlux_pu_to_Wb_sf+0xac>
10008630:	eec77a87 	vdiv.f32	s15, s15, s14
10008634:	eeb78ae7 	vcvt.f64.f32	d8, s15
10008638:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
1000863c:	eef70ae7 	vcvt.f64.f32	d16, s15
10008640:	eeb00b00 	vmov.f64	d0, #0
10008644:	eeb01b60 	vmov.f64	d1, d16
10008648:	fa00a078 	blx	10030830 <pow>
1000864c:	eef00b40 	vmov.f64	d16, d0
10008650:	ee680b20 	vmul.f64	d16, d8, d16
10008654:	eef77be0 	vcvt.f32.f64	s15, d16
} // end of USER_computeFlux_pu_to_Wb_sf() function
10008658:	eeb00a67 	vmov.f32	s0, s15
1000865c:	e24bd00c 	sub	sp, fp, #12
10008660:	ecbd8b02 	vpop	{d8}
10008664:	e8bd8800 	pop	{fp, pc}
10008668:	fefa39ef 	.word	0xfefa39ef
1000866c:	3fe62e42 	.word	0x3fe62e42
10008670:	40c90fdb 	.word	0x40c90fdb

10008674 <USER_computeFlux_pu_to_VpHz_sf>:


//! \brief     Computes the scale factor needed to convert from per unit to V/Hz
//!
float_t USER_computeFlux_pu_to_VpHz_sf(void)
{
10008674:	e92d4800 	push	{fp, lr}
10008678:	ed2d8b02 	vpush	{d8}
1000867c:	e28db00c 	add	fp, sp, #12
10008680:	e24dd010 	sub	sp, sp, #16
  float_t FullScaleFlux = (USER_IQ_FULL_SCALE_VOLTAGE_V/(float_t)USER_EST_FREQ_Hz);
10008684:	e301326f 	movw	r3, #4719	; 0x126f
10008688:	e3433e03 	movt	r3, #15875	; 0x3e03
1000868c:	e50b3010 	str	r3, [fp, #-16]
  float_t maxFlux = (USER_MOTOR_RATED_FLUX*((USER_MOTOR_TYPE==MOTOR_Type_Induction)?0.05f:0.7f));
10008690:	e3003b8d 	movw	r3, #2957	; 0xb8d
10008694:	e3433d87 	movt	r3, #15751	; 0x3d87
10008698:	e50b3014 	str	r3, [fp, #-20]
  float_t lShift = -ceil(log(FullScaleFlux/maxFlux)/log(2.0));
1000869c:	ed1b7a04 	vldr	s14, [fp, #-16]
100086a0:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
100086a4:	eec77a27 	vdiv.f32	s15, s14, s15
100086a8:	eef70ae7 	vcvt.f64.f32	d16, s15
100086ac:	eeb00b60 	vmov.f64	d0, d16
100086b0:	fa00a01f 	blx	10030734 <log>
100086b4:	eef01b40 	vmov.f64	d17, d0
100086b8:	eddf0b14 	vldr	d16, [pc, #80]	; 10008710 <USER_computeFlux_pu_to_VpHz_sf+0x9c>
100086bc:	eec10ba0 	vdiv.f64	d16, d17, d16
100086c0:	eeb00b60 	vmov.f64	d0, d16
100086c4:	fa009f8f 	blx	10030508 <ceil>
100086c8:	eef00b40 	vmov.f64	d16, d0
100086cc:	eef77be0 	vcvt.f32.f64	s15, d16
100086d0:	eef17a67 	vneg.f32	s15, s15
100086d4:	ed4b7a06 	vstr	s15, [fp, #-24]	; 0xffffffe8

  return((FullScaleFlux*pow(2.0f,lShift)));
100086d8:	ed5b7a04 	vldr	s15, [fp, #-16]
100086dc:	eeb78ae7 	vcvt.f64.f32	d8, s15
100086e0:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
100086e4:	eef70ae7 	vcvt.f64.f32	d16, s15
100086e8:	eeb00b00 	vmov.f64	d0, #0
100086ec:	eeb01b60 	vmov.f64	d1, d16
100086f0:	fa00a04e 	blx	10030830 <pow>
100086f4:	eef00b40 	vmov.f64	d16, d0
100086f8:	ee680b20 	vmul.f64	d16, d8, d16
100086fc:	eef77be0 	vcvt.f32.f64	s15, d16
} // end of USER_computeFlux_pu_to_VpHz_sf() function
10008700:	eeb00a67 	vmov.f32	s0, s15
10008704:	e24bd00c 	sub	sp, fp, #12
10008708:	ecbd8b02 	vpop	{d8}
1000870c:	e8bd8800 	pop	{fp, pc}
10008710:	fefa39ef 	.word	0xfefa39ef
10008714:	3fe62e42 	.word	0x3fe62e42

10008718 <USER_computeFlux>:


//! \brief     Computes Flux in Wb or V/Hz depending on the scale factor sent as parameter
//!
float_t USER_computeFlux(CTRL_Handle handle, const float_t sf)
{
10008718:	e92d4800 	push	{fp, lr}
1000871c:	e28db004 	add	fp, sp, #4
10008720:	e24dd010 	sub	sp, sp, #16
10008724:	e50b0010 	str	r0, [fp, #-16]
10008728:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000872c:	e51b3010 	ldr	r3, [fp, #-16]
10008730:	e50b3008 	str	r3, [fp, #-8]

  return((EST_getFlux_pu(obj->estHandle)*sf));
10008734:	e51b3008 	ldr	r3, [fp, #-8]
10008738:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000873c:	e1a00003 	mov	r0, r3
10008740:	ebfff96c 	bl	10006cf8 <EST_getFlux_pu>
10008744:	eeb07a40 	vmov.f32	s14, s0
10008748:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
1000874c:	ee677a27 	vmul.f32	s15, s14, s15
} // end of USER_computeFlux() function
10008750:	eeb00a67 	vmov.f32	s0, s15
10008754:	e24bd004 	sub	sp, fp, #4
10008758:	e8bd8800 	pop	{fp, pc}

1000875c <USER_computeTorque_Nm>:


//! \brief     Computes Torque in Nm
//!
float_t USER_computeTorque_Nm(CTRL_Handle handle, const float_t torque_Flux_sf, const float_t torque_Ls_sf)
{
1000875c:	e92d4800 	push	{fp, lr}
10008760:	ed2d8b02 	vpush	{d8}
10008764:	e28db00c 	add	fp, sp, #12
10008768:	e24dd030 	sub	sp, sp, #48	; 0x30
1000876c:	e50b0030 	str	r0, [fp, #-48]	; 0x30
10008770:	ed0b0a0d 	vstr	s0, [fp, #-52]	; 0xffffffcc
10008774:	ed4b0a0e 	vstr	s1, [fp, #-56]	; 0xffffffc8
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10008778:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1000877c:	e50b3010 	str	r3, [fp, #-16]

  float_t Flux_pu = EST_getFlux_pu(obj->estHandle);
10008780:	e51b3010 	ldr	r3, [fp, #-16]
10008784:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10008788:	e1a00003 	mov	r0, r3
1000878c:	ebfff959 	bl	10006cf8 <EST_getFlux_pu>
10008790:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  float_t Id_pu = PID_getFbackValue(obj->pidHandle_Id);
10008794:	e51b3010 	ldr	r3, [fp, #-16]
10008798:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000879c:	e1a00003 	mov	r0, r3
100087a0:	ebfffd2c 	bl	10007c58 <PID_getFbackValue>
100087a4:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
  float_t Iq_pu = PID_getFbackValue(obj->pidHandle_Iq);
100087a8:	e51b3010 	ldr	r3, [fp, #-16]
100087ac:	e5933060 	ldr	r3, [r3, #96]	; 0x60
100087b0:	e1a00003 	mov	r0, r3
100087b4:	ebfffd27 	bl	10007c58 <PID_getFbackValue>
100087b8:	ed0b0a07 	vstr	s0, [fp, #-28]	; 0xffffffe4
  float_t Ld_minus_Lq_pu = (EST_getLs_d_pu(obj->estHandle) - EST_getLs_q_pu(obj->estHandle));//????
100087bc:	e51b3010 	ldr	r3, [fp, #-16]
100087c0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100087c4:	e1a00003 	mov	r0, r3
100087c8:	ebfff95e 	bl	10006d48 <EST_getLs_d_pu>
100087cc:	eeb08a40 	vmov.f32	s16, s0
100087d0:	e51b3010 	ldr	r3, [fp, #-16]
100087d4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100087d8:	e1a00003 	mov	r0, r3
100087dc:	ebfff96d 	bl	10006d98 <EST_getLs_q_pu>
100087e0:	eef07a40 	vmov.f32	s15, s0
100087e4:	ee787a67 	vsub.f32	s15, s16, s15
100087e8:	ed4b7a08 	vstr	s15, [fp, #-32]	; 0xffffffe0
  float_t Torque_Flux_Iq_Nm = ((Flux_pu * Iq_pu) * torque_Flux_sf);
100087ec:	ed1b7a05 	vldr	s14, [fp, #-20]	; 0xffffffec
100087f0:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
100087f4:	ee277a27 	vmul.f32	s14, s14, s15
100087f8:	ed5b7a0d 	vldr	s15, [fp, #-52]	; 0xffffffcc
100087fc:	ee677a27 	vmul.f32	s15, s14, s15
10008800:	ed4b7a09 	vstr	s15, [fp, #-36]	; 0xffffffdc
  float_t Torque_Ls_Id_Iq_Nm = (((Ld_minus_Lq_pu * Id_pu) * Iq_pu) * torque_Ls_sf);
10008804:	ed1b7a08 	vldr	s14, [fp, #-32]	; 0xffffffe0
10008808:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
1000880c:	ee277a27 	vmul.f32	s14, s14, s15
10008810:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
10008814:	ee277a27 	vmul.f32	s14, s14, s15
10008818:	ed5b7a0e 	vldr	s15, [fp, #-56]	; 0xffffffc8
1000881c:	ee677a27 	vmul.f32	s15, s14, s15
10008820:	ed4b7a0a 	vstr	s15, [fp, #-40]	; 0xffffffd8
  float_t Torque_Nm = Torque_Flux_Iq_Nm + Torque_Ls_Id_Iq_Nm;
10008824:	ed1b7a09 	vldr	s14, [fp, #-36]	; 0xffffffdc
10008828:	ed5b7a0a 	vldr	s15, [fp, #-40]	; 0xffffffd8
1000882c:	ee777a27 	vadd.f32	s15, s14, s15
10008830:	ed4b7a0b 	vstr	s15, [fp, #-44]	; 0xffffffd4

  return(Torque_Nm);
10008834:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10008838:	ee073a90 	vmov	s15, r3
} // end of USER_computeTorque_Nm() function
1000883c:	eeb00a67 	vmov.f32	s0, s15
10008840:	e24bd00c 	sub	sp, fp, #12
10008844:	ecbd8b02 	vpop	{d8}
10008848:	e8bd8800 	pop	{fp, pc}

1000884c <USER_computeTorque_lbin>:


//! \brief     Computes Torque in Nm
//!
float_t USER_computeTorque_lbin(CTRL_Handle handle, const float_t torque_Flux_sf, const float_t torque_Ls_sf)
{
1000884c:	e92d4800 	push	{fp, lr}
10008850:	ed2d8b02 	vpush	{d8}
10008854:	e28db00c 	add	fp, sp, #12
10008858:	e24dd030 	sub	sp, sp, #48	; 0x30
1000885c:	e50b0030 	str	r0, [fp, #-48]	; 0x30
10008860:	ed0b0a0d 	vstr	s0, [fp, #-52]	; 0xffffffcc
10008864:	ed4b0a0e 	vstr	s1, [fp, #-56]	; 0xffffffc8
  CTRL_Obj *obj = (CTRL_Obj *)handle;
10008868:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1000886c:	e50b3010 	str	r3, [fp, #-16]

  float_t Flux_pu = EST_getFlux_pu(obj->estHandle);
10008870:	e51b3010 	ldr	r3, [fp, #-16]
10008874:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10008878:	e1a00003 	mov	r0, r3
1000887c:	ebfff91d 	bl	10006cf8 <EST_getFlux_pu>
10008880:	ed0b0a05 	vstr	s0, [fp, #-20]	; 0xffffffec
  float_t Id_pu = PID_getFbackValue(obj->pidHandle_Id);
10008884:	e51b3010 	ldr	r3, [fp, #-16]
10008888:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000888c:	e1a00003 	mov	r0, r3
10008890:	ebfffcf0 	bl	10007c58 <PID_getFbackValue>
10008894:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
  float_t Iq_pu = PID_getFbackValue(obj->pidHandle_Iq);
10008898:	e51b3010 	ldr	r3, [fp, #-16]
1000889c:	e5933060 	ldr	r3, [r3, #96]	; 0x60
100088a0:	e1a00003 	mov	r0, r3
100088a4:	ebfffceb 	bl	10007c58 <PID_getFbackValue>
100088a8:	ed0b0a07 	vstr	s0, [fp, #-28]	; 0xffffffe4
  float_t Ld_minus_Lq_pu = (EST_getLs_d_pu(obj->estHandle)-EST_getLs_q_pu(obj->estHandle));//????
100088ac:	e51b3010 	ldr	r3, [fp, #-16]
100088b0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100088b4:	e1a00003 	mov	r0, r3
100088b8:	ebfff922 	bl	10006d48 <EST_getLs_d_pu>
100088bc:	eeb08a40 	vmov.f32	s16, s0
100088c0:	e51b3010 	ldr	r3, [fp, #-16]
100088c4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100088c8:	e1a00003 	mov	r0, r3
100088cc:	ebfff931 	bl	10006d98 <EST_getLs_q_pu>
100088d0:	eef07a40 	vmov.f32	s15, s0
100088d4:	ee787a67 	vsub.f32	s15, s16, s15
100088d8:	ed4b7a08 	vstr	s15, [fp, #-32]	; 0xffffffe0
  float_t Torque_Flux_Iq_Nm = ((Flux_pu * Iq_pu) * torque_Flux_sf);
100088dc:	ed1b7a05 	vldr	s14, [fp, #-20]	; 0xffffffec
100088e0:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
100088e4:	ee277a27 	vmul.f32	s14, s14, s15
100088e8:	ed5b7a0d 	vldr	s15, [fp, #-52]	; 0xffffffcc
100088ec:	ee677a27 	vmul.f32	s15, s14, s15
100088f0:	ed4b7a09 	vstr	s15, [fp, #-36]	; 0xffffffdc
  float_t Torque_Ls_Id_Iq_Nm = (((Ld_minus_Lq_pu * Id_pu) * Iq_pu) * torque_Ls_sf);
100088f4:	ed1b7a08 	vldr	s14, [fp, #-32]	; 0xffffffe0
100088f8:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
100088fc:	ee277a27 	vmul.f32	s14, s14, s15
10008900:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
10008904:	ee277a27 	vmul.f32	s14, s14, s15
10008908:	ed5b7a0e 	vldr	s15, [fp, #-56]	; 0xffffffc8
1000890c:	ee677a27 	vmul.f32	s15, s14, s15
10008910:	ed4b7a0a 	vstr	s15, [fp, #-40]	; 0xffffffd8
  float_t Torque_Nm = Torque_Flux_Iq_Nm + Torque_Ls_Id_Iq_Nm;
10008914:	ed1b7a09 	vldr	s14, [fp, #-36]	; 0xffffffdc
10008918:	ed5b7a0a 	vldr	s15, [fp, #-40]	; 0xffffffd8
1000891c:	ee777a27 	vadd.f32	s15, s14, s15
10008920:	ed4b7a0b 	vstr	s15, [fp, #-44]	; 0xffffffd4

  return((Torque_Nm * (MATH_Nm_TO_lbin_SF)));
10008924:	ed5b7a0b 	vldr	s15, [fp, #-44]	; 0xffffffd4
10008928:	ed9f7a04 	vldr	s14, [pc, #16]	; 10008940 <USER_computeTorque_lbin+0xf4>
1000892c:	ee677a87 	vmul.f32	s15, s15, s14
} // end of USER_computeTorque_lbin() function
10008930:	eeb00a67 	vmov.f32	s0, s15
10008934:	e24bd00c 	sub	sp, fp, #12
10008938:	ecbd8b02 	vpop	{d8}
1000893c:	e8bd8800 	pop	{fp, pc}
10008940:	410d9ca8 	.word	0x410d9ca8

10008944 <PWMEnable>:
/***************************** Include Files *******************************/
#include "mypwm.h"


extern unsigned char PWMEnable(PWM_HandleTypeDef *pwm)
{
10008944:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008948:	e28db000 	add	fp, sp, #0
1000894c:	e24dd00c 	sub	sp, sp, #12
10008950:	e50b0008 	str	r0, [fp, #-8]
	if(pwm == NULL)
10008954:	e51b3008 	ldr	r3, [fp, #-8]
10008958:	e3530000 	cmp	r3, #0
1000895c:	1a000001 	bne	10008968 <PWMEnable+0x24>
	{
		return MYIP_ERROR;
10008960:	e3a03000 	mov	r3, #0
10008964:	ea000013 	b	100089b8 <PWMEnable+0x74>
	}
	if(pwm->state == MYIP_STATE_READY)
10008968:	e51b3008 	ldr	r3, [fp, #-8]
1000896c:	e5d33018 	ldrb	r3, [r3, #24]
10008970:	e3530002 	cmp	r3, #2
10008974:	1a00000e 	bne	100089b4 <PWMEnable+0x70>
	{
		pwm->state = MYIP_STATE_BUSY;
10008978:	e51b3008 	ldr	r3, [fp, #-8]
1000897c:	e3a02001 	mov	r2, #1
10008980:	e5c32018 	strb	r2, [r3, #24]
		pwm->Instance->ctrl_reg |= 0x7; 
10008984:	e51b3008 	ldr	r3, [fp, #-8]
10008988:	e5933000 	ldr	r3, [r3]
1000898c:	e51b2008 	ldr	r2, [fp, #-8]
10008990:	e5922000 	ldr	r2, [r2]
10008994:	e5922014 	ldr	r2, [r2, #20]
10008998:	e3822007 	orr	r2, r2, #7
1000899c:	e5832014 	str	r2, [r3, #20]
		pwm->state = MYIP_STATE_READY;
100089a0:	e51b3008 	ldr	r3, [fp, #-8]
100089a4:	e3a02002 	mov	r2, #2
100089a8:	e5c32018 	strb	r2, [r3, #24]
		return MYIP_SUCCESS;
100089ac:	e3a03001 	mov	r3, #1
100089b0:	ea000000 	b	100089b8 <PWMEnable+0x74>
	}
	return MYIP_BUSY;
100089b4:	e3a03002 	mov	r3, #2
	
}
100089b8:	e1a00003 	mov	r0, r3
100089bc:	e24bd000 	sub	sp, fp, #0
100089c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100089c4:	e12fff1e 	bx	lr

100089c8 <PWMSetduty>:
extern char PWMSetduty(PWM_HandleTypeDef *pwm,duty_HandleTypeDef *duty)
{
100089c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100089cc:	e28db000 	add	fp, sp, #0
100089d0:	e24dd00c 	sub	sp, sp, #12
100089d4:	e50b0008 	str	r0, [fp, #-8]
100089d8:	e50b100c 	str	r1, [fp, #-12]
	if(pwm == NULL)
100089dc:	e51b3008 	ldr	r3, [fp, #-8]
100089e0:	e3530000 	cmp	r3, #0
100089e4:	1a000001 	bne	100089f0 <PWMSetduty+0x28>
	{
		return MYIP_ERROR;
100089e8:	e3a03000 	mov	r3, #0
100089ec:	ea000020 	b	10008a74 <PWMSetduty+0xac>
	}
	
	if(duty == NULL)
100089f0:	e51b300c 	ldr	r3, [fp, #-12]
100089f4:	e3530000 	cmp	r3, #0
100089f8:	1a000001 	bne	10008a04 <PWMSetduty+0x3c>
	{
		return MYIP_ERROR;
100089fc:	e3a03000 	mov	r3, #0
10008a00:	ea00001b 	b	10008a74 <PWMSetduty+0xac>
		
	}
	if(pwm->state == MYIP_STATE_READY)
10008a04:	e51b3008 	ldr	r3, [fp, #-8]
10008a08:	e5d33018 	ldrb	r3, [r3, #24]
10008a0c:	e3530002 	cmp	r3, #2
10008a10:	1a000016 	bne	10008a70 <PWMSetduty+0xa8>
	{
	
		pwm->state = MYIP_STATE_BUSY;
10008a14:	e51b3008 	ldr	r3, [fp, #-8]
10008a18:	e3a02001 	mov	r2, #1
10008a1c:	e5c32018 	strb	r2, [r3, #24]
		pwm->Instance->pwm0_duty_reg = PWMDUTY(duty->pwm0_duty);
10008a20:	e51b3008 	ldr	r3, [fp, #-8]
10008a24:	e5933000 	ldr	r3, [r3]
10008a28:	e51b200c 	ldr	r2, [fp, #-12]
10008a2c:	e1d220b0 	ldrh	r2, [r2]
10008a30:	e5832000 	str	r2, [r3]
		pwm->Instance->pwm1_duty_reg = PWMDUTY(duty->pwm1_duty);
10008a34:	e51b3008 	ldr	r3, [fp, #-8]
10008a38:	e5933000 	ldr	r3, [r3]
10008a3c:	e51b200c 	ldr	r2, [fp, #-12]
10008a40:	e1d220b2 	ldrh	r2, [r2, #2]
10008a44:	e5832004 	str	r2, [r3, #4]
		pwm->Instance->pwm2_duty_reg = PWMDUTY(duty->pwm2_duty);
10008a48:	e51b3008 	ldr	r3, [fp, #-8]
10008a4c:	e5933000 	ldr	r3, [r3]
10008a50:	e51b200c 	ldr	r2, [fp, #-12]
10008a54:	e1d220b4 	ldrh	r2, [r2, #4]
10008a58:	e5832008 	str	r2, [r3, #8]
		pwm->state = MYIP_STATE_READY;
10008a5c:	e51b3008 	ldr	r3, [fp, #-8]
10008a60:	e3a02002 	mov	r2, #2
10008a64:	e5c32018 	strb	r2, [r3, #24]
		
		return MYIP_SUCCESS;
10008a68:	e3a03001 	mov	r3, #1
10008a6c:	ea000000 	b	10008a74 <PWMSetduty+0xac>
	}
	return MYIP_BUSY;
10008a70:	e3a03002 	mov	r3, #2
}
10008a74:	e1a00003 	mov	r0, r3
10008a78:	e24bd000 	sub	sp, fp, #0
10008a7c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008a80:	e12fff1e 	bx	lr

10008a84 <PWMSetDeadzone>:

extern char PWMSetDeadzone(PWM_HandleTypeDef *pwm,unsigned long *deadzone)
{
10008a84:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008a88:	e28db000 	add	fp, sp, #0
10008a8c:	e24dd00c 	sub	sp, sp, #12
10008a90:	e50b0008 	str	r0, [fp, #-8]
10008a94:	e50b100c 	str	r1, [fp, #-12]
	if(pwm == NULL)
10008a98:	e51b3008 	ldr	r3, [fp, #-8]
10008a9c:	e3530000 	cmp	r3, #0
10008aa0:	1a000001 	bne	10008aac <PWMSetDeadzone+0x28>
	{
		return MYIP_ERROR;
10008aa4:	e3a03000 	mov	r3, #0
10008aa8:	ea000015 	b	10008b04 <PWMSetDeadzone+0x80>
	}
	
	if(pwm->state == MYIP_STATE_READY)
10008aac:	e51b3008 	ldr	r3, [fp, #-8]
10008ab0:	e5d33018 	ldrb	r3, [r3, #24]
10008ab4:	e3530002 	cmp	r3, #2
10008ab8:	1a000010 	bne	10008b00 <PWMSetDeadzone+0x7c>
	{
	
		pwm->state = MYIP_STATE_BUSY;
10008abc:	e51b3008 	ldr	r3, [fp, #-8]
10008ac0:	e3a02001 	mov	r2, #1
10008ac4:	e5c32018 	strb	r2, [r3, #24]
		pwm->Instance->dead_zone_reg = DEADZONE(*deadzone/2);
10008ac8:	e51b3008 	ldr	r3, [fp, #-8]
10008acc:	e5931000 	ldr	r1, [r3]
10008ad0:	e51b300c 	ldr	r3, [fp, #-12]
10008ad4:	e5932000 	ldr	r2, [r3]
10008ad8:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10008adc:	e34c3ccc 	movt	r3, #52428	; 0xcccc
10008ae0:	e0832392 	umull	r2, r3, r2, r3
10008ae4:	e1a03223 	lsr	r3, r3, #4
10008ae8:	e581300c 	str	r3, [r1, #12]
		pwm->state = MYIP_STATE_READY;
10008aec:	e51b3008 	ldr	r3, [fp, #-8]
10008af0:	e3a02002 	mov	r2, #2
10008af4:	e5c32018 	strb	r2, [r3, #24]
		return MYIP_SUCCESS;
10008af8:	e3a03001 	mov	r3, #1
10008afc:	ea000000 	b	10008b04 <PWMSetDeadzone+0x80>
	}
	
	return MYIP_BUSY;
10008b00:	e3a03002 	mov	r3, #2
}
10008b04:	e1a00003 	mov	r0, r3
10008b08:	e24bd000 	sub	sp, fp, #0
10008b0c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008b10:	e12fff1e 	bx	lr

10008b14 <PWMSetclk>:

extern char PWMSetclk(PWM_HandleTypeDef *pwm,unsigned long *clk)
{
10008b14:	e92d4810 	push	{r4, fp, lr}
10008b18:	e28db008 	add	fp, sp, #8
10008b1c:	e24dd00c 	sub	sp, sp, #12
10008b20:	e50b0010 	str	r0, [fp, #-16]
10008b24:	e50b1014 	str	r1, [fp, #-20]
	if(pwm == NULL)
10008b28:	e51b3010 	ldr	r3, [fp, #-16]
10008b2c:	e3530000 	cmp	r3, #0
10008b30:	1a000001 	bne	10008b3c <PWMSetclk+0x28>
	{
		return MYIP_ERROR;
10008b34:	e3a03000 	mov	r3, #0
10008b38:	ea000017 	b	10008b9c <PWMSetclk+0x88>
	}
	
	if(pwm->state == MYIP_STATE_READY)
10008b3c:	e51b3010 	ldr	r3, [fp, #-16]
10008b40:	e5d33018 	ldrb	r3, [r3, #24]
10008b44:	e3530002 	cmp	r3, #2
10008b48:	1a000012 	bne	10008b98 <PWMSetclk+0x84>
	{
	
		pwm->state = MYIP_STATE_BUSY;
10008b4c:	e51b3010 	ldr	r3, [fp, #-16]
10008b50:	e3a02001 	mov	r2, #1
10008b54:	e5c32018 	strb	r2, [r3, #24]
		pwm->Instance->divider_reg = CLKDIV(*clk);
10008b58:	e51b3010 	ldr	r3, [fp, #-16]
10008b5c:	e5934000 	ldr	r4, [r3]
10008b60:	e51b3014 	ldr	r3, [fp, #-20]
10008b64:	e5933000 	ldr	r3, [r3]
10008b68:	e1a03083 	lsl	r3, r3, #1
10008b6c:	e3a00ce1 	mov	r0, #57600	; 0xe100
10008b70:	e34005f5 	movt	r0, #1525	; 0x5f5
10008b74:	e1a01003 	mov	r1, r3
10008b78:	fa009890 	blx	1002edc0 <__aeabi_uidiv>
10008b7c:	e1a03000 	mov	r3, r0
10008b80:	e5843010 	str	r3, [r4, #16]
		pwm->state = MYIP_STATE_READY;
10008b84:	e51b3010 	ldr	r3, [fp, #-16]
10008b88:	e3a02002 	mov	r2, #2
10008b8c:	e5c32018 	strb	r2, [r3, #24]
		return MYIP_SUCCESS;
10008b90:	e3a03001 	mov	r3, #1
10008b94:	ea000000 	b	10008b9c <PWMSetclk+0x88>
	}
	
	return MYIP_BUSY;
10008b98:	e3a03002 	mov	r3, #2
}
10008b9c:	e1a00003 	mov	r0, r3
10008ba0:	e24bd008 	sub	sp, fp, #8
10008ba4:	e8bd8810 	pop	{r4, fp, pc}

10008ba8 <PWMDisable>:

extern unsigned char PWMDisable(PWM_HandleTypeDef *pwm)
{
10008ba8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008bac:	e28db000 	add	fp, sp, #0
10008bb0:	e24dd00c 	sub	sp, sp, #12
10008bb4:	e50b0008 	str	r0, [fp, #-8]
	if(pwm == NULL)
10008bb8:	e51b3008 	ldr	r3, [fp, #-8]
10008bbc:	e3530000 	cmp	r3, #0
10008bc0:	1a000001 	bne	10008bcc <PWMDisable+0x24>
	{
		return MYIP_ERROR;
10008bc4:	e3a03000 	mov	r3, #0
10008bc8:	ea000013 	b	10008c1c <PWMDisable+0x74>
	}
	if(pwm->state == MYIP_STATE_READY)
10008bcc:	e51b3008 	ldr	r3, [fp, #-8]
10008bd0:	e5d33018 	ldrb	r3, [r3, #24]
10008bd4:	e3530002 	cmp	r3, #2
10008bd8:	1a00000e 	bne	10008c18 <PWMDisable+0x70>
	{
		pwm->state = MYIP_STATE_BUSY;
10008bdc:	e51b3008 	ldr	r3, [fp, #-8]
10008be0:	e3a02001 	mov	r2, #1
10008be4:	e5c32018 	strb	r2, [r3, #24]
		pwm->Instance->ctrl_reg &= 0xffffffff8; 
10008be8:	e51b3008 	ldr	r3, [fp, #-8]
10008bec:	e5933000 	ldr	r3, [r3]
10008bf0:	e51b2008 	ldr	r2, [fp, #-8]
10008bf4:	e5922000 	ldr	r2, [r2]
10008bf8:	e5922014 	ldr	r2, [r2, #20]
10008bfc:	e3c22007 	bic	r2, r2, #7
10008c00:	e5832014 	str	r2, [r3, #20]
		pwm->state = MYIP_STATE_READY;
10008c04:	e51b3008 	ldr	r3, [fp, #-8]
10008c08:	e3a02002 	mov	r2, #2
10008c0c:	e5c32018 	strb	r2, [r3, #24]
		return MYIP_SUCCESS;
10008c10:	e3a03001 	mov	r3, #1
10008c14:	ea000000 	b	10008c1c <PWMDisable+0x74>
	}
	//rt_kprintf("PWMDisable busy\r\n");
	return MYIP_BUSY;
10008c18:	e3a03002 	mov	r3, #2
}
10008c1c:	e1a00003 	mov	r0, r3
10008c20:	e24bd000 	sub	sp, fp, #0
10008c24:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008c28:	e12fff1e 	bx	lr

__attribute__((weak)) void PWM_MSP_Init(PWM_HandleTypeDef *pwm)
{
10008c2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008c30:	e28db000 	add	fp, sp, #0
10008c34:	e24dd00c 	sub	sp, sp, #12
10008c38:	e50b0008 	str	r0, [fp, #-8]
}
10008c3c:	e24bd000 	sub	sp, fp, #0
10008c40:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008c44:	e12fff1e 	bx	lr

10008c48 <PWM_Init>:

extern char PWM_Init(PWM_HandleTypeDef *pwm)
{
10008c48:	e92d4800 	push	{fp, lr}
10008c4c:	e28db004 	add	fp, sp, #4
10008c50:	e24dd008 	sub	sp, sp, #8
10008c54:	e50b0008 	str	r0, [fp, #-8]
	if(pwm == NULL)
10008c58:	e51b3008 	ldr	r3, [fp, #-8]
10008c5c:	e3530000 	cmp	r3, #0
10008c60:	1a000001 	bne	10008c6c <PWM_Init+0x24>
	{
		return MYIP_ERROR;
10008c64:	e3a03000 	mov	r3, #0
10008c68:	ea00003b 	b	10008d5c <PWM_Init+0x114>
	}
	if(pwm->state == MYIP_STATE_RESET)
10008c6c:	e51b3008 	ldr	r3, [fp, #-8]
10008c70:	e5d33018 	ldrb	r3, [r3, #24]
10008c74:	e3530000 	cmp	r3, #0
10008c78:	1a000004 	bne	10008c90 <PWM_Init+0x48>
	{
		PWM_MSP_Init(pwm);
10008c7c:	e51b0008 	ldr	r0, [fp, #-8]
10008c80:	eb0007ed 	bl	1000ac3c <PWM_MSP_Init>
		pwm->state = MYIP_STATE_READY;
10008c84:	e51b3008 	ldr	r3, [fp, #-8]
10008c88:	e3a02002 	mov	r2, #2
10008c8c:	e5c32018 	strb	r2, [r3, #24]
	}
	while(PWMDisable(pwm) != MYIP_SUCCESS);
10008c90:	e1a00000 	nop			; (mov r0, r0)
10008c94:	e51b0008 	ldr	r0, [fp, #-8]
10008c98:	ebffffc2 	bl	10008ba8 <PWMDisable>
10008c9c:	e1a03000 	mov	r3, r0
10008ca0:	e3530001 	cmp	r3, #1
10008ca4:	1afffffa 	bne	10008c94 <PWM_Init+0x4c>
	
	while(PWMSetclk( pwm,&pwm->Init.clk) != MYIP_SUCCESS);
10008ca8:	e1a00000 	nop			; (mov r0, r0)
10008cac:	e51b3008 	ldr	r3, [fp, #-8]
10008cb0:	e2833010 	add	r3, r3, #16
10008cb4:	e51b0008 	ldr	r0, [fp, #-8]
10008cb8:	e1a01003 	mov	r1, r3
10008cbc:	ebffff94 	bl	10008b14 <PWMSetclk>
10008cc0:	e1a03000 	mov	r3, r0
10008cc4:	e3530001 	cmp	r3, #1
10008cc8:	1afffff7 	bne	10008cac <PWM_Init+0x64>
	while(PWMSetDeadzone( pwm,&pwm->Init.dead_ns) != MYIP_SUCCESS);
10008ccc:	e1a00000 	nop			; (mov r0, r0)
10008cd0:	e51b3008 	ldr	r3, [fp, #-8]
10008cd4:	e283300c 	add	r3, r3, #12
10008cd8:	e51b0008 	ldr	r0, [fp, #-8]
10008cdc:	e1a01003 	mov	r1, r3
10008ce0:	ebffff67 	bl	10008a84 <PWMSetDeadzone>
10008ce4:	e1a03000 	mov	r3, r0
10008ce8:	e3530001 	cmp	r3, #1
10008cec:	1afffff7 	bne	10008cd0 <PWM_Init+0x88>
	while(PWMSetduty( pwm,&pwm->Init.pwmduty) != MYIP_SUCCESS);
10008cf0:	e1a00000 	nop			; (mov r0, r0)
10008cf4:	e51b3008 	ldr	r3, [fp, #-8]
10008cf8:	e2833004 	add	r3, r3, #4
10008cfc:	e51b0008 	ldr	r0, [fp, #-8]
10008d00:	e1a01003 	mov	r1, r3
10008d04:	ebffff2f 	bl	100089c8 <PWMSetduty>
10008d08:	e1a03000 	mov	r3, r0
10008d0c:	e3530001 	cmp	r3, #1
10008d10:	1afffff7 	bne	10008cf4 <PWM_Init+0xac>
	
	if(pwm->Init.pwmstate == 1)
10008d14:	e51b3008 	ldr	r3, [fp, #-8]
10008d18:	e5d33014 	ldrb	r3, [r3, #20]
10008d1c:	e3530001 	cmp	r3, #1
10008d20:	1a000006 	bne	10008d40 <PWM_Init+0xf8>
		while(PWMEnable(pwm) != MYIP_SUCCESS);
10008d24:	e1a00000 	nop			; (mov r0, r0)
10008d28:	e51b0008 	ldr	r0, [fp, #-8]
10008d2c:	ebffff04 	bl	10008944 <PWMEnable>
10008d30:	e1a03000 	mov	r3, r0
10008d34:	e3530001 	cmp	r3, #1
10008d38:	1afffffa 	bne	10008d28 <PWM_Init+0xe0>
10008d3c:	ea000005 	b	10008d58 <PWM_Init+0x110>
	else
		while(PWMDisable(pwm) != MYIP_SUCCESS);
10008d40:	e1a00000 	nop			; (mov r0, r0)
10008d44:	e51b0008 	ldr	r0, [fp, #-8]
10008d48:	ebffff96 	bl	10008ba8 <PWMDisable>
10008d4c:	e1a03000 	mov	r3, r0
10008d50:	e3530001 	cmp	r3, #1
10008d54:	1afffffa 	bne	10008d44 <PWM_Init+0xfc>
		
	return MYIP_SUCCESS;
10008d58:	e3a03001 	mov	r3, #1
}
10008d5c:	e1a00003 	mov	r0, r3
10008d60:	e24bd004 	sub	sp, fp, #4
10008d64:	e8bd8800 	pop	{fp, pc}

10008d68 <__errno>:
}
#endif

__attribute__((weak)) sint32 *
__errno (void)
{
10008d68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008d6c:	e28db000 	add	fp, sp, #0
  return &_REENT->_errno;
10008d70:	e3063db8 	movw	r3, #28088	; 0x6db8
10008d74:	e3413003 	movt	r3, #4099	; 0x1003
10008d78:	e5933000 	ldr	r3, [r3]
}
10008d7c:	e1a00003 	mov	r0, r3
10008d80:	e24bd000 	sub	sp, fp, #0
10008d84:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008d88:	e12fff1e 	bx	lr

10008d8c <Xil_In8>:
*
* @note		None.
*
******************************************************************************/
u8 Xil_In8(INTPTR Addr)
{
10008d8c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008d90:	e28db000 	add	fp, sp, #0
10008d94:	e24dd00c 	sub	sp, sp, #12
10008d98:	e50b0008 	str	r0, [fp, #-8]
	return *(volatile u8 *) Addr;
10008d9c:	e51b3008 	ldr	r3, [fp, #-8]
10008da0:	e5d33000 	ldrb	r3, [r3]
10008da4:	e6ef3073 	uxtb	r3, r3
}
10008da8:	e1a00003 	mov	r0, r3
10008dac:	e24bd000 	sub	sp, fp, #0
10008db0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008db4:	e12fff1e 	bx	lr

10008db8 <Xil_In16>:
*
* @note		None.
*
******************************************************************************/
u16 Xil_In16(INTPTR Addr)
{
10008db8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008dbc:	e28db000 	add	fp, sp, #0
10008dc0:	e24dd00c 	sub	sp, sp, #12
10008dc4:	e50b0008 	str	r0, [fp, #-8]
	return *(volatile u16 *) Addr;
10008dc8:	e51b3008 	ldr	r3, [fp, #-8]
10008dcc:	e1d330b0 	ldrh	r3, [r3]
10008dd0:	e6ff3073 	uxth	r3, r3
}
10008dd4:	e1a00003 	mov	r0, r3
10008dd8:	e24bd000 	sub	sp, fp, #0
10008ddc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008de0:	e12fff1e 	bx	lr

10008de4 <Xil_In32>:
*
* @note		None.
*
******************************************************************************/
u32 Xil_In32(INTPTR Addr)
{
10008de4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008de8:	e28db000 	add	fp, sp, #0
10008dec:	e24dd00c 	sub	sp, sp, #12
10008df0:	e50b0008 	str	r0, [fp, #-8]
	return *(volatile u32 *) Addr;
10008df4:	e51b3008 	ldr	r3, [fp, #-8]
10008df8:	e5933000 	ldr	r3, [r3]
}
10008dfc:	e1a00003 	mov	r0, r3
10008e00:	e24bd000 	sub	sp, fp, #0
10008e04:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008e08:	e12fff1e 	bx	lr

10008e0c <Xil_Out8>:
*
* @note		None.
*
******************************************************************************/
void Xil_Out8(INTPTR Addr, u8 Value)
{
10008e0c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008e10:	e28db000 	add	fp, sp, #0
10008e14:	e24dd014 	sub	sp, sp, #20
10008e18:	e50b0010 	str	r0, [fp, #-16]
10008e1c:	e1a03001 	mov	r3, r1
10008e20:	e54b3011 	strb	r3, [fp, #-17]
	u8 *LocalAddr = (u8 *)Addr;
10008e24:	e51b3010 	ldr	r3, [fp, #-16]
10008e28:	e50b3008 	str	r3, [fp, #-8]
	*LocalAddr = Value;
10008e2c:	e51b3008 	ldr	r3, [fp, #-8]
10008e30:	e55b2011 	ldrb	r2, [fp, #-17]
10008e34:	e5c32000 	strb	r2, [r3]
}
10008e38:	e24bd000 	sub	sp, fp, #0
10008e3c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008e40:	e12fff1e 	bx	lr

10008e44 <Xil_Out16>:
*
* @note		None.
*
******************************************************************************/
void Xil_Out16(INTPTR Addr, u16 Value)
{
10008e44:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008e48:	e28db000 	add	fp, sp, #0
10008e4c:	e24dd014 	sub	sp, sp, #20
10008e50:	e50b0010 	str	r0, [fp, #-16]
10008e54:	e1a03001 	mov	r3, r1
10008e58:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
	u16 *LocalAddr = (u16 *)Addr;
10008e5c:	e51b3010 	ldr	r3, [fp, #-16]
10008e60:	e50b3008 	str	r3, [fp, #-8]
	*LocalAddr = Value;
10008e64:	e51b3008 	ldr	r3, [fp, #-8]
10008e68:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
10008e6c:	e1c320b0 	strh	r2, [r3]
}
10008e70:	e24bd000 	sub	sp, fp, #0
10008e74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008e78:	e12fff1e 	bx	lr

10008e7c <Xil_Out32>:
*
* @note		None.
*
******************************************************************************/
void Xil_Out32(INTPTR Addr, u32 Value)
{
10008e7c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008e80:	e28db000 	add	fp, sp, #0
10008e84:	e24dd014 	sub	sp, sp, #20
10008e88:	e50b0010 	str	r0, [fp, #-16]
10008e8c:	e50b1014 	str	r1, [fp, #-20]
	u32 *LocalAddr = (u32 *)Addr;
10008e90:	e51b3010 	ldr	r3, [fp, #-16]
10008e94:	e50b3008 	str	r3, [fp, #-8]
	*LocalAddr = Value;
10008e98:	e51b3008 	ldr	r3, [fp, #-8]
10008e9c:	e51b2014 	ldr	r2, [fp, #-20]
10008ea0:	e5832000 	str	r2, [r3]
}
10008ea4:	e24bd000 	sub	sp, fp, #0
10008ea8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008eac:	e12fff1e 	bx	lr

10008eb0 <Xil_In16BE>:
*
* @note		None.
*
******************************************************************************/
u16 Xil_In16BE(INTPTR Addr)
{
10008eb0:	e92d4800 	push	{fp, lr}
10008eb4:	e28db004 	add	fp, sp, #4
10008eb8:	e24dd010 	sub	sp, sp, #16
10008ebc:	e50b0010 	str	r0, [fp, #-16]
	u16 temp;
	u16 result;

	temp = Xil_In16(Addr);
10008ec0:	e51b0010 	ldr	r0, [fp, #-16]
10008ec4:	ebffffbb 	bl	10008db8 <Xil_In16>
10008ec8:	e1a03000 	mov	r3, r0
10008ecc:	e14b30b6 	strh	r3, [fp, #-6]

	result = Xil_EndianSwap16(temp);
10008ed0:	e15b30b6 	ldrh	r3, [fp, #-6]
10008ed4:	e1a00003 	mov	r0, r3
10008ed8:	eb000031 	bl	10008fa4 <Xil_EndianSwap16>
10008edc:	e1a03000 	mov	r3, r0
10008ee0:	e14b30b8 	strh	r3, [fp, #-8]

	return result;
10008ee4:	e15b30b8 	ldrh	r3, [fp, #-8]
}
10008ee8:	e1a00003 	mov	r0, r3
10008eec:	e24bd004 	sub	sp, fp, #4
10008ef0:	e8bd8800 	pop	{fp, pc}

10008ef4 <Xil_In32BE>:
*
* @note		None.
*
******************************************************************************/
u32 Xil_In32BE(INTPTR Addr)
{
10008ef4:	e92d4800 	push	{fp, lr}
10008ef8:	e28db004 	add	fp, sp, #4
10008efc:	e24dd010 	sub	sp, sp, #16
10008f00:	e50b0010 	str	r0, [fp, #-16]
	u32 temp;
	u32 result;

	temp = Xil_In32(Addr);
10008f04:	e51b0010 	ldr	r0, [fp, #-16]
10008f08:	ebffffb5 	bl	10008de4 <Xil_In32>
10008f0c:	e50b0008 	str	r0, [fp, #-8]

	result = Xil_EndianSwap32(temp);
10008f10:	e51b0008 	ldr	r0, [fp, #-8]
10008f14:	eb000031 	bl	10008fe0 <Xil_EndianSwap32>
10008f18:	e50b000c 	str	r0, [fp, #-12]

	return result;
10008f1c:	e51b300c 	ldr	r3, [fp, #-12]
}
10008f20:	e1a00003 	mov	r0, r3
10008f24:	e24bd004 	sub	sp, fp, #4
10008f28:	e8bd8800 	pop	{fp, pc}

10008f2c <Xil_Out16BE>:
*
* @note		None.
*
******************************************************************************/
void Xil_Out16BE(INTPTR Addr, u16 Value)
{
10008f2c:	e92d4800 	push	{fp, lr}
10008f30:	e28db004 	add	fp, sp, #4
10008f34:	e24dd010 	sub	sp, sp, #16
10008f38:	e50b0010 	str	r0, [fp, #-16]
10008f3c:	e1a03001 	mov	r3, r1
10008f40:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
	u16 temp;

	temp = Xil_EndianSwap16(Value);
10008f44:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
10008f48:	e1a00003 	mov	r0, r3
10008f4c:	eb000014 	bl	10008fa4 <Xil_EndianSwap16>
10008f50:	e1a03000 	mov	r3, r0
10008f54:	e14b30b6 	strh	r3, [fp, #-6]

    Xil_Out16(Addr, temp);
10008f58:	e15b30b6 	ldrh	r3, [fp, #-6]
10008f5c:	e51b0010 	ldr	r0, [fp, #-16]
10008f60:	e1a01003 	mov	r1, r3
10008f64:	ebffffb6 	bl	10008e44 <Xil_Out16>
}
10008f68:	e24bd004 	sub	sp, fp, #4
10008f6c:	e8bd8800 	pop	{fp, pc}

10008f70 <Xil_Out32BE>:
*
* @note		None.
*
******************************************************************************/
void Xil_Out32BE(INTPTR Addr, u32 Value)
{
10008f70:	e92d4800 	push	{fp, lr}
10008f74:	e28db004 	add	fp, sp, #4
10008f78:	e24dd010 	sub	sp, sp, #16
10008f7c:	e50b0010 	str	r0, [fp, #-16]
10008f80:	e50b1014 	str	r1, [fp, #-20]
	u32 temp;

	temp = Xil_EndianSwap32(Value);
10008f84:	e51b0014 	ldr	r0, [fp, #-20]
10008f88:	eb000014 	bl	10008fe0 <Xil_EndianSwap32>
10008f8c:	e50b0008 	str	r0, [fp, #-8]

    Xil_Out32(Addr, temp);
10008f90:	e51b0010 	ldr	r0, [fp, #-16]
10008f94:	e51b1008 	ldr	r1, [fp, #-8]
10008f98:	ebffffb7 	bl	10008e7c <Xil_Out32>
}
10008f9c:	e24bd004 	sub	sp, fp, #4
10008fa0:	e8bd8800 	pop	{fp, pc}

10008fa4 <Xil_EndianSwap16>:
*
* @note		None.
*
******************************************************************************/
u16 Xil_EndianSwap16(u16 Data)
{
10008fa4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008fa8:	e28db000 	add	fp, sp, #0
10008fac:	e24dd00c 	sub	sp, sp, #12
10008fb0:	e1a03000 	mov	r3, r0
10008fb4:	e14b30b6 	strh	r3, [fp, #-6]
	return (u16) (((Data & 0xFF00U) >> 8U) | ((Data & 0x00FFU) << 8U));
10008fb8:	e15b30b6 	ldrh	r3, [fp, #-6]
10008fbc:	e1a02403 	lsl	r2, r3, #8
10008fc0:	e6ff3073 	uxth	r3, r3
10008fc4:	e1a03423 	lsr	r3, r3, #8
10008fc8:	e1823003 	orr	r3, r2, r3
10008fcc:	e6ff3073 	uxth	r3, r3
}
10008fd0:	e1a00003 	mov	r0, r3
10008fd4:	e24bd000 	sub	sp, fp, #0
10008fd8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008fdc:	e12fff1e 	bx	lr

10008fe0 <Xil_EndianSwap32>:
*
* @note		None.
*
******************************************************************************/
u32 Xil_EndianSwap32(u32 Data)
{
10008fe0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008fe4:	e28db000 	add	fp, sp, #0
10008fe8:	e24dd014 	sub	sp, sp, #20
10008fec:	e50b0010 	str	r0, [fp, #-16]
	u16 LoWord;
	u16 HiWord;

	/* get each of the half words from the 32 bit word */

	LoWord = (u16) (Data & 0x0000FFFFU);
10008ff0:	e51b3010 	ldr	r3, [fp, #-16]
10008ff4:	e14b30b6 	strh	r3, [fp, #-6]
	HiWord = (u16) ((Data & 0xFFFF0000U) >> 16U);
10008ff8:	e51b3010 	ldr	r3, [fp, #-16]
10008ffc:	e1a03823 	lsr	r3, r3, #16
10009000:	e14b30b8 	strh	r3, [fp, #-8]

	/* byte swap each of the 16 bit half words */

	LoWord = (((LoWord & 0xFF00U) >> 8U) | ((LoWord & 0x00FFU) << 8U));
10009004:	e15b30b6 	ldrh	r3, [fp, #-6]
10009008:	e1a02403 	lsl	r2, r3, #8
1000900c:	e6ff3073 	uxth	r3, r3
10009010:	e1a03423 	lsr	r3, r3, #8
10009014:	e1823003 	orr	r3, r2, r3
10009018:	e14b30b6 	strh	r3, [fp, #-6]
	HiWord = (((HiWord & 0xFF00U) >> 8U) | ((HiWord & 0x00FFU) << 8U));
1000901c:	e15b30b8 	ldrh	r3, [fp, #-8]
10009020:	e1a02403 	lsl	r2, r3, #8
10009024:	e6ff3073 	uxth	r3, r3
10009028:	e1a03423 	lsr	r3, r3, #8
1000902c:	e1823003 	orr	r3, r2, r3
10009030:	e14b30b8 	strh	r3, [fp, #-8]

	/* swap the half words before returning the value */

	return ((((u32)LoWord) << (u32)16U) | (u32)HiWord);
10009034:	e15b30b6 	ldrh	r3, [fp, #-6]
10009038:	e1a02803 	lsl	r2, r3, #16
1000903c:	e15b30b8 	ldrh	r3, [fp, #-8]
10009040:	e1823003 	orr	r3, r2, r3
}
10009044:	e1a00003 	mov	r0, r3
10009048:	e24bd000 	sub	sp, fp, #0
1000904c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009050:	e12fff1e 	bx	lr
10009054:	00000000 	andeq	r0, r0, r0

10009058 <motor_ctl>:
int vb[260];
int spd[260];
unsigned int j=0;

static void motor_ctl(struct hw_adc_device *pdev)
{
10009058:	e92d4800 	push	{fp, lr}
1000905c:	e28db004 	add	fp, sp, #4
10009060:	e24dd088 	sub	sp, sp, #136	; 0x88
10009064:	e50b0088 	str	r0, [fp, #-136]	; 0x88
	static unsigned int cnt_p = 0,cnt_n = 0;
	rt_device_t device_qep;
	Qep_ValueTypeDef qep_data;
	device_qep = rt_device_find("qep1");
10009068:	e30207f4 	movw	r0, #10228	; 0x27f4
1000906c:	e3410003 	movt	r0, #4099	; 0x1003
10009070:	eb001577 	bl	1000e654 <rt_device_find>
10009074:	e50b0008 	str	r0, [fp, #-8]
	
	static unsigned int i = 0;
	if(gCtrl.state != 1)
10009078:	e30f3960 	movw	r3, #63840	; 0xf960
1000907c:	e3413003 	movt	r3, #4099	; 0x1003
10009080:	e5d33008 	ldrb	r3, [r3, #8]
10009084:	e3530001 	cmp	r3, #1
10009088:	0a000006 	beq	100090a8 <motor_ctl+0x50>
	{
		j++;
1000908c:	e30c3004 	movw	r3, #49156	; 0xc004
10009090:	e3413003 	movt	r3, #4099	; 0x1003
10009094:	e5933000 	ldr	r3, [r3]
10009098:	e2832001 	add	r2, r3, #1
1000909c:	e30c3004 	movw	r3, #49156	; 0xc004
100090a0:	e3413003 	movt	r3, #4099	; 0x1003
100090a4:	e5832000 	str	r2, [r3]
	}
	if(device_qep != NULL)
100090a8:	e51b3008 	ldr	r3, [fp, #-8]
100090ac:	e3530000 	cmp	r3, #0
100090b0:	0a000036 	beq	10009190 <motor_ctl+0x138>
	{
		rt_device_read(device_qep,0,&qep_data,0);
100090b4:	e24b3018 	sub	r3, fp, #24
100090b8:	e51b0008 	ldr	r0, [fp, #-8]
100090bc:	e3a01000 	mov	r1, #0
100090c0:	e1a02003 	mov	r2, r3
100090c4:	e3a03000 	mov	r3, #0
100090c8:	eb001662 	bl	1000ea58 <rt_device_read>
		cnt_p = cnt_n;
100090cc:	e30c3008 	movw	r3, #49160	; 0xc008
100090d0:	e3413003 	movt	r3, #4099	; 0x1003
100090d4:	e5932000 	ldr	r2, [r3]
100090d8:	e30c300c 	movw	r3, #49164	; 0xc00c
100090dc:	e3413003 	movt	r3, #4099	; 0x1003
100090e0:	e5832000 	str	r2, [r3]
		cnt_n = qep_data.cnt;
100090e4:	e51b3014 	ldr	r3, [fp, #-20]
100090e8:	e1a02003 	mov	r2, r3
100090ec:	e30c3008 	movw	r3, #49160	; 0xc008
100090f0:	e3413003 	movt	r3, #4099	; 0x1003
100090f4:	e5832000 	str	r2, [r3]


		for(i = 0; i < 125; i++)
100090f8:	e30c3010 	movw	r3, #49168	; 0xc010
100090fc:	e3413003 	movt	r3, #4099	; 0x1003
10009100:	e3a02000 	mov	r2, #0
10009104:	e5832000 	str	r2, [r3]
10009108:	ea000013 	b	1000915c <motor_ctl+0x104>
		{
			t_array[i] = t_array[i + 1];
1000910c:	e30c3010 	movw	r3, #49168	; 0xc010
10009110:	e3413003 	movt	r3, #4099	; 0x1003
10009114:	e5932000 	ldr	r2, [r3]
10009118:	e30c3010 	movw	r3, #49168	; 0xc010
1000911c:	e3413003 	movt	r3, #4099	; 0x1003
10009120:	e5933000 	ldr	r3, [r3]
10009124:	e2831001 	add	r1, r3, #1
10009128:	e3003b50 	movw	r3, #2896	; 0xb50
1000912c:	e3413004 	movt	r3, #4100	; 0x1004
10009130:	e7931101 	ldr	r1, [r3, r1, lsl #2]
10009134:	e3003b50 	movw	r3, #2896	; 0xb50
10009138:	e3413004 	movt	r3, #4100	; 0x1004
1000913c:	e7831102 	str	r1, [r3, r2, lsl #2]
		rt_device_read(device_qep,0,&qep_data,0);
		cnt_p = cnt_n;
		cnt_n = qep_data.cnt;


		for(i = 0; i < 125; i++)
10009140:	e30c3010 	movw	r3, #49168	; 0xc010
10009144:	e3413003 	movt	r3, #4099	; 0x1003
10009148:	e5933000 	ldr	r3, [r3]
1000914c:	e2832001 	add	r2, r3, #1
10009150:	e30c3010 	movw	r3, #49168	; 0xc010
10009154:	e3413003 	movt	r3, #4099	; 0x1003
10009158:	e5832000 	str	r2, [r3]
1000915c:	e30c3010 	movw	r3, #49168	; 0xc010
10009160:	e3413003 	movt	r3, #4099	; 0x1003
10009164:	e5933000 	ldr	r3, [r3]
10009168:	e353007c 	cmp	r3, #124	; 0x7c
1000916c:	9affffe6 	bls	1000910c <motor_ctl+0xb4>
		{
			t_array[i] = t_array[i + 1];
			//turn_array[i] = turn_array[i + 1];
		}
		t_array[i] = qep_data.cnt;
10009170:	e30c3010 	movw	r3, #49168	; 0xc010
10009174:	e3413003 	movt	r3, #4099	; 0x1003
10009178:	e5932000 	ldr	r2, [r3]
1000917c:	e51b3014 	ldr	r3, [fp, #-20]
10009180:	e1a01003 	mov	r1, r3
10009184:	e3003b50 	movw	r3, #2896	; 0xb50
10009188:	e3413004 	movt	r3, #4100	; 0x1004
1000918c:	e7831102 	str	r1, [r3, r2, lsl #2]
	static HAL_PwmData_t sHal_PwmData;
	static HAL_QepData_t sHal_QepData;

	rt_device_t device_adc;
	QIEMW_ADC_HandleTypeDef adcvalue;
	device_adc = rt_device_find("adc1");
10009190:	e30207fc 	movw	r0, #10236	; 0x27fc
10009194:	e3410003 	movt	r0, #4099	; 0x1003
10009198:	eb00152d 	bl	1000e654 <rt_device_find>
1000919c:	e50b000c 	str	r0, [fp, #-12]
	rt_device_read (device_adc,
100091a0:	e24b307c 	sub	r3, fp, #124	; 0x7c
100091a4:	e51b000c 	ldr	r0, [fp, #-12]
100091a8:	e3a01000 	mov	r1, #0
100091ac:	e1a02003 	mov	r2, r3
100091b0:	e3a03000 	mov	r3, #0
100091b4:	eb001627 	bl	1000ea58 <rt_device_read>
                          0,
                          &adcvalue,
                          0);
	
	sHal_AdcData.I.value[0] = adcvalue.PhaseA.qI_value/3276.8-3.3;//IV  control board voltage
100091b8:	e15b37b4 	ldrh	r3, [fp, #-116]	; 0xffffff8c
100091bc:	e6bf3073 	sxth	r3, r3
100091c0:	ee073a90 	vmov	s15, r3
100091c4:	eef80be7 	vcvt.f64.s32	d16, s15
100091c8:	eddf1bc2 	vldr	d17, [pc, #776]	; 100094d8 <motor_ctl+0x480>
100091cc:	eec00ba1 	vdiv.f64	d16, d16, d17
100091d0:	eddf1bc2 	vldr	d17, [pc, #776]	; 100094e0 <motor_ctl+0x488>
100091d4:	ee700be1 	vsub.f64	d16, d16, d17
100091d8:	eef77be0 	vcvt.f32.f64	s15, d16
100091dc:	e30c3014 	movw	r3, #49172	; 0xc014
100091e0:	e3413003 	movt	r3, #4099	; 0x1003
100091e4:	edc37a00 	vstr	s15, [r3]
	sHal_AdcData.I.value[1] = adcvalue.PhaseB.qI_value/3276.8-3.3;//IW
100091e8:	e15b36b6 	ldrh	r3, [fp, #-102]	; 0xffffff9a
100091ec:	e6bf3073 	sxth	r3, r3
100091f0:	ee073a90 	vmov	s15, r3
100091f4:	eef80be7 	vcvt.f64.s32	d16, s15
100091f8:	eddf1bb6 	vldr	d17, [pc, #728]	; 100094d8 <motor_ctl+0x480>
100091fc:	eec00ba1 	vdiv.f64	d16, d16, d17
10009200:	eddf1bb6 	vldr	d17, [pc, #728]	; 100094e0 <motor_ctl+0x488>
10009204:	ee700be1 	vsub.f64	d16, d16, d17
10009208:	eef77be0 	vcvt.f32.f64	s15, d16
1000920c:	e30c3014 	movw	r3, #49172	; 0xc014
10009210:	e3413003 	movt	r3, #4099	; 0x1003
10009214:	edc37a01 	vstr	s15, [r3, #4]
	sHal_AdcData.I.value[2] = adcvalue.PhaseC.qI_value/3276.8-3.3;//IU
10009218:	e15b35b8 	ldrh	r3, [fp, #-88]	; 0xffffffa8
1000921c:	e6bf3073 	sxth	r3, r3
10009220:	ee073a90 	vmov	s15, r3
10009224:	eef80be7 	vcvt.f64.s32	d16, s15
10009228:	eddf1baa 	vldr	d17, [pc, #680]	; 100094d8 <motor_ctl+0x480>
1000922c:	eec00ba1 	vdiv.f64	d16, d16, d17
10009230:	eddf1baa 	vldr	d17, [pc, #680]	; 100094e0 <motor_ctl+0x488>
10009234:	ee700be1 	vsub.f64	d16, d16, d17
10009238:	eef77be0 	vcvt.f32.f64	s15, d16
1000923c:	e30c3014 	movw	r3, #49172	; 0xc014
10009240:	e3413003 	movt	r3, #4099	; 0x1003
10009244:	edc37a02 	vstr	s15, [r3, #8]
	sHal_AdcData.V.value[0] = adcvalue.PhaseA.qV_value;//VUV
10009248:	e15b37b2 	ldrh	r3, [fp, #-114]	; 0xffffff8e
1000924c:	e6bf3073 	sxth	r3, r3
10009250:	ee073a90 	vmov	s15, r3
10009254:	eef87ae7 	vcvt.f32.s32	s15, s15
10009258:	e30c3014 	movw	r3, #49172	; 0xc014
1000925c:	e3413003 	movt	r3, #4099	; 0x1003
10009260:	edc37a03 	vstr	s15, [r3, #12]
	sHal_AdcData.V.value[1] = adcvalue.PhaseB.qV_value;//VVW
10009264:	e15b36b4 	ldrh	r3, [fp, #-100]	; 0xffffff9c
10009268:	e6bf3073 	sxth	r3, r3
1000926c:	ee073a90 	vmov	s15, r3
10009270:	eef87ae7 	vcvt.f32.s32	s15, s15
10009274:	e30c3014 	movw	r3, #49172	; 0xc014
10009278:	e3413003 	movt	r3, #4099	; 0x1003
1000927c:	edc37a04 	vstr	s15, [r3, #16]
	//sHal_AdcData.V.value[2] = -adcvalue.PhaseA.qV_value - adcvalue.PhaseB.qV_value;
	sHal_AdcData.VdcBus = adcvalue.BUS.qV_value * 2.37 / 10000;//VDC
10009280:	e15b34be 	ldrh	r3, [fp, #-78]	; 0xffffffb2
10009284:	e6bf3073 	sxth	r3, r3
10009288:	ee073a90 	vmov	s15, r3
1000928c:	eef80be7 	vcvt.f64.s32	d16, s15
10009290:	eddf1b94 	vldr	d17, [pc, #592]	; 100094e8 <motor_ctl+0x490>
10009294:	ee600ba1 	vmul.f64	d16, d16, d17
10009298:	eddf1b94 	vldr	d17, [pc, #592]	; 100094f0 <motor_ctl+0x498>
1000929c:	eec00ba1 	vdiv.f64	d16, d16, d17
100092a0:	eef77be0 	vcvt.f32.f64	s15, d16
100092a4:	e30c3014 	movw	r3, #49172	; 0xc014
100092a8:	e3413003 	movt	r3, #4099	; 0x1003
100092ac:	edc37a06 	vstr	s15, [r3, #24]

	rt_device_read(device_qep,0,&qep_data,0);
100092b0:	e24b3018 	sub	r3, fp, #24
100092b4:	e51b0008 	ldr	r0, [fp, #-8]
100092b8:	e3a01000 	mov	r1, #0
100092bc:	e1a02003 	mov	r2, r3
100092c0:	e3a03000 	mov	r3, #0
100092c4:	eb0015e3 	bl	1000ea58 <rt_device_read>
	sHal_QepData.qep_cnt = qep_data.cnt;
100092c8:	e51b3014 	ldr	r3, [fp, #-20]
100092cc:	ee073a90 	vmov	s15, r3
100092d0:	eef87ae7 	vcvt.f32.s32	s15, s15
100092d4:	e30c3034 	movw	r3, #49204	; 0xc034
100092d8:	e3413003 	movt	r3, #4099	; 0x1003
100092dc:	edc37a00 	vstr	s15, [r3]
	sHal_QepData.turn_cnt = qep_data.turn;
100092e0:	e51b3018 	ldr	r3, [fp, #-24]
100092e4:	e1a02003 	mov	r2, r3
100092e8:	e30c3034 	movw	r3, #49204	; 0xc034
100092ec:	e3413003 	movt	r3, #4099	; 0x1003
100092f0:	e5832004 	str	r2, [r3, #4]
	sHal_AdcData.I.value[0] = sHal_AdcData.I.value[0] * 8.77;//IV real current
100092f4:	e30c3014 	movw	r3, #49172	; 0xc014
100092f8:	e3413003 	movt	r3, #4099	; 0x1003
100092fc:	edd37a00 	vldr	s15, [r3]
10009300:	eef70ae7 	vcvt.f64.f32	d16, s15
10009304:	eddf1b7b 	vldr	d17, [pc, #492]	; 100094f8 <motor_ctl+0x4a0>
10009308:	ee600ba1 	vmul.f64	d16, d16, d17
1000930c:	eef77be0 	vcvt.f32.f64	s15, d16
10009310:	e30c3014 	movw	r3, #49172	; 0xc014
10009314:	e3413003 	movt	r3, #4099	; 0x1003
10009318:	edc37a00 	vstr	s15, [r3]
	sHal_AdcData.I.value[1] = sHal_AdcData.I.value[1] * 8.77;//IW
1000931c:	e30c3014 	movw	r3, #49172	; 0xc014
10009320:	e3413003 	movt	r3, #4099	; 0x1003
10009324:	edd37a01 	vldr	s15, [r3, #4]
10009328:	eef70ae7 	vcvt.f64.f32	d16, s15
1000932c:	eddf1b71 	vldr	d17, [pc, #452]	; 100094f8 <motor_ctl+0x4a0>
10009330:	ee600ba1 	vmul.f64	d16, d16, d17
10009334:	eef77be0 	vcvt.f32.f64	s15, d16
10009338:	e30c3014 	movw	r3, #49172	; 0xc014
1000933c:	e3413003 	movt	r3, #4099	; 0x1003
10009340:	edc37a01 	vstr	s15, [r3, #4]
	sHal_AdcData.I.value[2] = sHal_AdcData.I.value[2] * 8.77;//IU
10009344:	e30c3014 	movw	r3, #49172	; 0xc014
10009348:	e3413003 	movt	r3, #4099	; 0x1003
1000934c:	edd37a02 	vldr	s15, [r3, #8]
10009350:	eef70ae7 	vcvt.f64.f32	d16, s15
10009354:	eddf1b67 	vldr	d17, [pc, #412]	; 100094f8 <motor_ctl+0x4a0>
10009358:	ee600ba1 	vmul.f64	d16, d16, d17
1000935c:	eef77be0 	vcvt.f32.f64	s15, d16
10009360:	e30c3014 	movw	r3, #49172	; 0xc014
10009364:	e3413003 	movt	r3, #4099	; 0x1003
10009368:	edc37a02 	vstr	s15, [r3, #8]
	sHal_AdcData.VdcBus = sHal_AdcData.VdcBus * 195.5;//real bus voltage
1000936c:	e30c3014 	movw	r3, #49172	; 0xc014
10009370:	e3413003 	movt	r3, #4099	; 0x1003
10009374:	edd37a06 	vldr	s15, [r3, #24]
10009378:	ed9f7a60 	vldr	s14, [pc, #384]	; 10009500 <motor_ctl+0x4a8>
1000937c:	ee677a87 	vmul.f32	s15, s15, s14
10009380:	e30c3014 	movw	r3, #49172	; 0xc014
10009384:	e3413003 	movt	r3, #4099	; 0x1003
10009388:	edc37a06 	vstr	s15, [r3, #24]
	
	
	sHal_AdcData.I.value[0] = sHal_AdcData.I.value[0] - gHal.adcBias.I.value[0];//
1000938c:	e30c3014 	movw	r3, #49172	; 0xc014
10009390:	e3413003 	movt	r3, #4099	; 0x1003
10009394:	ed937a00 	vldr	s14, [r3]
10009398:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000939c:	e3413003 	movt	r3, #4099	; 0x1003
100093a0:	edd37a36 	vldr	s15, [r3, #216]	; 0xd8
100093a4:	ee777a67 	vsub.f32	s15, s14, s15
100093a8:	e30c3014 	movw	r3, #49172	; 0xc014
100093ac:	e3413003 	movt	r3, #4099	; 0x1003
100093b0:	edc37a00 	vstr	s15, [r3]
	sHal_AdcData.I.value[1] = sHal_AdcData.I.value[1] - gHal.adcBias.I.value[1];
100093b4:	e30c3014 	movw	r3, #49172	; 0xc014
100093b8:	e3413003 	movt	r3, #4099	; 0x1003
100093bc:	ed937a01 	vldr	s14, [r3, #4]
100093c0:	e30f3ca0 	movw	r3, #64672	; 0xfca0
100093c4:	e3413003 	movt	r3, #4099	; 0x1003
100093c8:	edd37a37 	vldr	s15, [r3, #220]	; 0xdc
100093cc:	ee777a67 	vsub.f32	s15, s14, s15
100093d0:	e30c3014 	movw	r3, #49172	; 0xc014
100093d4:	e3413003 	movt	r3, #4099	; 0x1003
100093d8:	edc37a01 	vstr	s15, [r3, #4]
	sHal_AdcData.I.value[2] = sHal_AdcData.I.value[2] - gHal.adcBias.I.value[2];
100093dc:	e30c3014 	movw	r3, #49172	; 0xc014
100093e0:	e3413003 	movt	r3, #4099	; 0x1003
100093e4:	ed937a02 	vldr	s14, [r3, #8]
100093e8:	e30f3ca0 	movw	r3, #64672	; 0xfca0
100093ec:	e3413003 	movt	r3, #4099	; 0x1003
100093f0:	edd37a38 	vldr	s15, [r3, #224]	; 0xe0
100093f4:	ee777a67 	vsub.f32	s15, s14, s15
100093f8:	e30c3014 	movw	r3, #49172	; 0xc014
100093fc:	e3413003 	movt	r3, #4099	; 0x1003
10009400:	edc37a02 	vstr	s15, [r3, #8]
	Motor_Ctrl_Run(&sHal_AdcData, &sHal_PwmData, &sHal_QepData);
10009404:	e30c0014 	movw	r0, #49172	; 0xc014
10009408:	e3410003 	movt	r0, #4099	; 0x1003
1000940c:	e30c103c 	movw	r1, #49212	; 0xc03c
10009410:	e3411003 	movt	r1, #4099	; 0x1003
10009414:	e30c2034 	movw	r2, #49204	; 0xc034
10009418:	e3412003 	movt	r2, #4099	; 0x1003
1000941c:	ebffe0ac 	bl	100016d4 <Motor_Ctrl_Run>

	rt_device_t device_pwm;
	duty_HandleTypeDef dutyhandle;
	
	device_pwm = rt_device_find("pwm1");
10009420:	e3020804 	movw	r0, #10244	; 0x2804
10009424:	e3410003 	movt	r0, #4099	; 0x1003
10009428:	eb001489 	bl	1000e654 <rt_device_find>
1000942c:	e50b0010 	str	r0, [fp, #-16]
	dutyhandle.pwm0_duty = sHal_PwmData.Tabc.value[0]*(float)TRIANGLETOP;
10009430:	e30c303c 	movw	r3, #49212	; 0xc03c
10009434:	e3413003 	movt	r3, #4099	; 0x1003
10009438:	edd37a00 	vldr	s15, [r3]
1000943c:	ed9f7a30 	vldr	s14, [pc, #192]	; 10009504 <motor_ctl+0x4ac>
10009440:	ee677a87 	vmul.f32	s15, s15, s14
10009444:	eefc7ae7 	vcvt.u32.f32	s15, s15
10009448:	ed4b7a23 	vstr	s15, [fp, #-140]	; 0xffffff74
1000944c:	e15b38bc 	ldrh	r3, [fp, #-140]	; 0xffffff74
10009450:	e6ff3073 	uxth	r3, r3
10009454:	e14b38b4 	strh	r3, [fp, #-132]	; 0xffffff7c
	dutyhandle.pwm1_duty = sHal_PwmData.Tabc.value[1]*(float)TRIANGLETOP;
10009458:	e30c303c 	movw	r3, #49212	; 0xc03c
1000945c:	e3413003 	movt	r3, #4099	; 0x1003
10009460:	edd37a01 	vldr	s15, [r3, #4]
10009464:	ed9f7a26 	vldr	s14, [pc, #152]	; 10009504 <motor_ctl+0x4ac>
10009468:	ee677a87 	vmul.f32	s15, s15, s14
1000946c:	eefc7ae7 	vcvt.u32.f32	s15, s15
10009470:	ed4b7a23 	vstr	s15, [fp, #-140]	; 0xffffff74
10009474:	e15b38bc 	ldrh	r3, [fp, #-140]	; 0xffffff74
10009478:	e6ff3073 	uxth	r3, r3
1000947c:	e14b38b2 	strh	r3, [fp, #-130]	; 0xffffff7e
	dutyhandle.pwm2_duty = sHal_PwmData.Tabc.value[2]*(float)TRIANGLETOP;
10009480:	e30c303c 	movw	r3, #49212	; 0xc03c
10009484:	e3413003 	movt	r3, #4099	; 0x1003
10009488:	edd37a02 	vldr	s15, [r3, #8]
1000948c:	ed9f7a1c 	vldr	s14, [pc, #112]	; 10009504 <motor_ctl+0x4ac>
10009490:	ee677a87 	vmul.f32	s15, s15, s14
10009494:	eefc7ae7 	vcvt.u32.f32	s15, s15
10009498:	ed4b7a23 	vstr	s15, [fp, #-140]	; 0xffffff74
1000949c:	e15b38bc 	ldrh	r3, [fp, #-140]	; 0xffffff74
100094a0:	e6ff3073 	uxth	r3, r3
100094a4:	e14b38b0 	strh	r3, [fp, #-128]	; 0xffffff80
	#if 1
	static int xi = 0;
	xi++;
100094a8:	e30c3048 	movw	r3, #49224	; 0xc048
100094ac:	e3413003 	movt	r3, #4099	; 0x1003
100094b0:	e5933000 	ldr	r3, [r3]
100094b4:	e2832001 	add	r2, r3, #1
100094b8:	e30c3048 	movw	r3, #49224	; 0xc048
100094bc:	e3413003 	movt	r3, #4099	; 0x1003
100094c0:	e5832000 	str	r2, [r3]
	//if(xi > 100)
	//{
		for(i = 0; i < 259; i++)
100094c4:	e30c3010 	movw	r3, #49168	; 0xc010
100094c8:	e3413003 	movt	r3, #4099	; 0x1003
100094cc:	e3a02000 	mov	r2, #0
100094d0:	e5832000 	str	r2, [r3]
100094d4:	ea000089 	b	10009700 <motor_ctl+0x6a8>
100094d8:	9999999a 	.word	0x9999999a
100094dc:	40a99999 	.word	0x40a99999
100094e0:	66666666 	.word	0x66666666
100094e4:	400a6666 	.word	0x400a6666
100094e8:	8f5c28f6 	.word	0x8f5c28f6
100094ec:	4002f5c2 	.word	0x4002f5c2
100094f0:	00000000 	.word	0x00000000
100094f4:	40c38800 	.word	0x40c38800
100094f8:	70a3d70a 	.word	0x70a3d70a
100094fc:	40218a3d 	.word	0x40218a3d
10009500:	43438000 	.word	0x43438000
10009504:	457a0000 	.word	0x457a0000
10009508:	447a0000 	.word	0x447a0000
1000950c:	461c4000 	.word	0x461c4000
		{
			pwm0[i] = pwm0[i + 1];
10009510:	e30c3010 	movw	r3, #49168	; 0xc010
10009514:	e3413003 	movt	r3, #4099	; 0x1003
10009518:	e5932000 	ldr	r2, [r3]
1000951c:	e30c3010 	movw	r3, #49168	; 0xc010
10009520:	e3413003 	movt	r3, #4099	; 0x1003
10009524:	e5933000 	ldr	r3, [r3]
10009528:	e2831001 	add	r1, r3, #1
1000952c:	e3013570 	movw	r3, #5488	; 0x1570
10009530:	e3413004 	movt	r3, #4100	; 0x1004
10009534:	e7931101 	ldr	r1, [r3, r1, lsl #2]
10009538:	e3013570 	movw	r3, #5488	; 0x1570
1000953c:	e3413004 	movt	r3, #4100	; 0x1004
10009540:	e7831102 	str	r1, [r3, r2, lsl #2]
			pwm1[i] = pwm1[i + 1];
10009544:	e30c3010 	movw	r3, #49168	; 0xc010
10009548:	e3413003 	movt	r3, #4099	; 0x1003
1000954c:	e5932000 	ldr	r2, [r3]
10009550:	e30c3010 	movw	r3, #49168	; 0xc010
10009554:	e3413003 	movt	r3, #4099	; 0x1003
10009558:	e5933000 	ldr	r3, [r3]
1000955c:	e2831001 	add	r1, r3, #1
10009560:	e30f3f18 	movw	r3, #65304	; 0xff18
10009564:	e3413003 	movt	r3, #4099	; 0x1003
10009568:	e7931101 	ldr	r1, [r3, r1, lsl #2]
1000956c:	e30f3f18 	movw	r3, #65304	; 0xff18
10009570:	e3413003 	movt	r3, #4099	; 0x1003
10009574:	e7831102 	str	r1, [r3, r2, lsl #2]
			pwm2[i] = pwm2[i + 1];
10009578:	e30c3010 	movw	r3, #49168	; 0xc010
1000957c:	e3413003 	movt	r3, #4099	; 0x1003
10009580:	e5932000 	ldr	r2, [r3]
10009584:	e30c3010 	movw	r3, #49168	; 0xc010
10009588:	e3413003 	movt	r3, #4099	; 0x1003
1000958c:	e5933000 	ldr	r3, [r3]
10009590:	e2831001 	add	r1, r3, #1
10009594:	e3003328 	movw	r3, #808	; 0x328
10009598:	e3413004 	movt	r3, #4100	; 0x1004
1000959c:	e7931101 	ldr	r1, [r3, r1, lsl #2]
100095a0:	e3003328 	movw	r3, #808	; 0x328
100095a4:	e3413004 	movt	r3, #4100	; 0x1004
100095a8:	e7831102 	str	r1, [r3, r2, lsl #2]
			point[i] = point[i + 1];
100095ac:	e30c3010 	movw	r3, #49168	; 0xc010
100095b0:	e3413003 	movt	r3, #4099	; 0x1003
100095b4:	e5932000 	ldr	r2, [r3]
100095b8:	e30c3010 	movw	r3, #49168	; 0xc010
100095bc:	e3413003 	movt	r3, #4099	; 0x1003
100095c0:	e5933000 	ldr	r3, [r3]
100095c4:	e2831001 	add	r1, r3, #1
100095c8:	e3003d48 	movw	r3, #3400	; 0xd48
100095cc:	e3413004 	movt	r3, #4100	; 0x1004
100095d0:	e7931101 	ldr	r1, [r3, r1, lsl #2]
100095d4:	e3003d48 	movw	r3, #3400	; 0xd48
100095d8:	e3413004 	movt	r3, #4100	; 0x1004
100095dc:	e7831102 	str	r1, [r3, r2, lsl #2]
			angleout[i] = angleout[i + 1];
100095e0:	e30c3010 	movw	r3, #49168	; 0xc010
100095e4:	e3413003 	movt	r3, #4099	; 0x1003
100095e8:	e5932000 	ldr	r2, [r3]
100095ec:	e30c3010 	movw	r3, #49168	; 0xc010
100095f0:	e3413003 	movt	r3, #4099	; 0x1003
100095f4:	e5933000 	ldr	r3, [r3]
100095f8:	e2831001 	add	r1, r3, #1
100095fc:	e30231a0 	movw	r3, #8608	; 0x21a0
10009600:	e3413004 	movt	r3, #4100	; 0x1004
10009604:	e7931101 	ldr	r1, [r3, r1, lsl #2]
10009608:	e30231a0 	movw	r3, #8608	; 0x21a0
1000960c:	e3413004 	movt	r3, #4100	; 0x1004
10009610:	e7831102 	str	r1, [r3, r2, lsl #2]
			angle[i] = angle[i + 1];
10009614:	e30c3010 	movw	r3, #49168	; 0xc010
10009618:	e3413003 	movt	r3, #4099	; 0x1003
1000961c:	e5932000 	ldr	r2, [r3]
10009620:	e30c3010 	movw	r3, #49168	; 0xc010
10009624:	e3413003 	movt	r3, #4099	; 0x1003
10009628:	e5933000 	ldr	r3, [r3]
1000962c:	e2831001 	add	r1, r3, #1
10009630:	e3013d90 	movw	r3, #7568	; 0x1d90
10009634:	e3413004 	movt	r3, #4100	; 0x1004
10009638:	e7931101 	ldr	r1, [r3, r1, lsl #2]
1000963c:	e3013d90 	movw	r3, #7568	; 0x1d90
10009640:	e3413004 	movt	r3, #4100	; 0x1004
10009644:	e7831102 	str	r1, [r3, r2, lsl #2]
			va[i] = va[i + 1];
10009648:	e30c3010 	movw	r3, #49168	; 0xc010
1000964c:	e3413003 	movt	r3, #4099	; 0x1003
10009650:	e5932000 	ldr	r2, [r3]
10009654:	e30c3010 	movw	r3, #49168	; 0xc010
10009658:	e3413003 	movt	r3, #4099	; 0x1003
1000965c:	e5933000 	ldr	r3, [r3]
10009660:	e2831001 	add	r1, r3, #1
10009664:	e3013980 	movw	r3, #6528	; 0x1980
10009668:	e3413004 	movt	r3, #4100	; 0x1004
1000966c:	e7931101 	ldr	r1, [r3, r1, lsl #2]
10009670:	e3013980 	movw	r3, #6528	; 0x1980
10009674:	e3413004 	movt	r3, #4100	; 0x1004
10009678:	e7831102 	str	r1, [r3, r2, lsl #2]
			vb[i] = vb[i + 1];
1000967c:	e30c3010 	movw	r3, #49168	; 0xc010
10009680:	e3413003 	movt	r3, #4099	; 0x1003
10009684:	e5932000 	ldr	r2, [r3]
10009688:	e30c3010 	movw	r3, #49168	; 0xc010
1000968c:	e3413003 	movt	r3, #4099	; 0x1003
10009690:	e5933000 	ldr	r3, [r3]
10009694:	e2831001 	add	r1, r3, #1
10009698:	e3003738 	movw	r3, #1848	; 0x738
1000969c:	e3413004 	movt	r3, #4100	; 0x1004
100096a0:	e7931101 	ldr	r1, [r3, r1, lsl #2]
100096a4:	e3003738 	movw	r3, #1848	; 0x738
100096a8:	e3413004 	movt	r3, #4100	; 0x1004
100096ac:	e7831102 	str	r1, [r3, r2, lsl #2]
			spd[i] = spd[i + 1];
100096b0:	e30c3010 	movw	r3, #49168	; 0xc010
100096b4:	e3413003 	movt	r3, #4099	; 0x1003
100096b8:	e5932000 	ldr	r2, [r3]
100096bc:	e30c3010 	movw	r3, #49168	; 0xc010
100096c0:	e3413003 	movt	r3, #4099	; 0x1003
100096c4:	e5933000 	ldr	r3, [r3]
100096c8:	e2831001 	add	r1, r3, #1
100096cc:	e3013158 	movw	r3, #4440	; 0x1158
100096d0:	e3413004 	movt	r3, #4100	; 0x1004
100096d4:	e7931101 	ldr	r1, [r3, r1, lsl #2]
100096d8:	e3013158 	movw	r3, #4440	; 0x1158
100096dc:	e3413004 	movt	r3, #4100	; 0x1004
100096e0:	e7831102 	str	r1, [r3, r2, lsl #2]
	#if 1
	static int xi = 0;
	xi++;
	//if(xi > 100)
	//{
		for(i = 0; i < 259; i++)
100096e4:	e30c3010 	movw	r3, #49168	; 0xc010
100096e8:	e3413003 	movt	r3, #4099	; 0x1003
100096ec:	e5933000 	ldr	r3, [r3]
100096f0:	e2832001 	add	r2, r3, #1
100096f4:	e30c3010 	movw	r3, #49168	; 0xc010
100096f8:	e3413003 	movt	r3, #4099	; 0x1003
100096fc:	e5832000 	str	r2, [r3]
10009700:	e30c3010 	movw	r3, #49168	; 0xc010
10009704:	e3413003 	movt	r3, #4099	; 0x1003
10009708:	e5933000 	ldr	r3, [r3]
1000970c:	e3002102 	movw	r2, #258	; 0x102
10009710:	e1530002 	cmp	r3, r2
10009714:	9affff7d 	bls	10009510 <motor_ctl+0x4b8>
			va[i] = va[i + 1];
			vb[i] = vb[i + 1];
			spd[i] = spd[i + 1];
		}
		
		pwm0[i] = dutyhandle.pwm0_duty;
10009718:	e30c3010 	movw	r3, #49168	; 0xc010
1000971c:	e3413003 	movt	r3, #4099	; 0x1003
10009720:	e5932000 	ldr	r2, [r3]
10009724:	e15b38b4 	ldrh	r3, [fp, #-132]	; 0xffffff7c
10009728:	e1a01003 	mov	r1, r3
1000972c:	e3013570 	movw	r3, #5488	; 0x1570
10009730:	e3413004 	movt	r3, #4100	; 0x1004
10009734:	e7831102 	str	r1, [r3, r2, lsl #2]
		pwm1[i] = dutyhandle.pwm1_duty;
10009738:	e30c3010 	movw	r3, #49168	; 0xc010
1000973c:	e3413003 	movt	r3, #4099	; 0x1003
10009740:	e5932000 	ldr	r2, [r3]
10009744:	e15b38b2 	ldrh	r3, [fp, #-130]	; 0xffffff7e
10009748:	e1a01003 	mov	r1, r3
1000974c:	e30f3f18 	movw	r3, #65304	; 0xff18
10009750:	e3413003 	movt	r3, #4099	; 0x1003
10009754:	e7831102 	str	r1, [r3, r2, lsl #2]
		//pwm2[i] = dutyhandle.pwm2_duty;
		pwm2[i] = sHal_QepData.qep_cnt;
10009758:	e30c3010 	movw	r3, #49168	; 0xc010
1000975c:	e3413003 	movt	r3, #4099	; 0x1003
10009760:	e5932000 	ldr	r2, [r3]
10009764:	e30c3034 	movw	r3, #49204	; 0xc034
10009768:	e3413003 	movt	r3, #4099	; 0x1003
1000976c:	edd37a00 	vldr	s15, [r3]
10009770:	eefd7ae7 	vcvt.s32.f32	s15, s15
10009774:	ee171a90 	vmov	r1, s15
10009778:	e3003328 	movw	r3, #808	; 0x328
1000977c:	e3413004 	movt	r3, #4100	; 0x1004
10009780:	e7831102 	str	r1, [r3, r2, lsl #2]
		//point[i] = gCtrl.rampgen.Freq * (float)10000 * (float)1000;
		//point[i] = gCtrl.Speed_handle->ElecSpeed * (float)10000;
		point[i] = gCtrl.temp * 1000;
10009784:	e30c3010 	movw	r3, #49168	; 0xc010
10009788:	e3413003 	movt	r3, #4099	; 0x1003
1000978c:	e5932000 	ldr	r2, [r3]
10009790:	e30f3960 	movw	r3, #63840	; 0xf960
10009794:	e3413003 	movt	r3, #4099	; 0x1003
10009798:	edd37ace 	vldr	s15, [r3, #824]	; 0x338
1000979c:	ed1f7aa7 	vldr	s14, [pc, #-668]	; 10009508 <motor_ctl+0x4b0>
100097a0:	ee677a87 	vmul.f32	s15, s15, s14
100097a4:	eefd7ae7 	vcvt.s32.f32	s15, s15
100097a8:	ee171a90 	vmov	r1, s15
100097ac:	e3003d48 	movw	r3, #3400	; 0xd48
100097b0:	e3413004 	movt	r3, #4100	; 0x1004
100097b4:	e7831102 	str	r1, [r3, r2, lsl #2]
		//angleout[i] = gCtrl.rampgen.Out * (float)10000 * (float)10000 * (float)10;
		angleout[i] = gCtrl.Vdq_out.value[1] * 1000;
100097b8:	e30c3010 	movw	r3, #49168	; 0xc010
100097bc:	e3413003 	movt	r3, #4099	; 0x1003
100097c0:	e5932000 	ldr	r2, [r3]
100097c4:	e30f3960 	movw	r3, #63840	; 0xf960
100097c8:	e3413003 	movt	r3, #4099	; 0x1003
100097cc:	edd37a66 	vldr	s15, [r3, #408]	; 0x198
100097d0:	ed1f7ab4 	vldr	s14, [pc, #-720]	; 10009508 <motor_ctl+0x4b0>
100097d4:	ee677a87 	vmul.f32	s15, s15, s14
100097d8:	eefd7ae7 	vcvt.s32.f32	s15, s15
100097dc:	ee171a90 	vmov	r1, s15
100097e0:	e30231a0 	movw	r3, #8608	; 0x21a0
100097e4:	e3413004 	movt	r3, #4100	; 0x1004
100097e8:	e7831102 	str	r1, [r3, r2, lsl #2]
		//angle[i] = gCtrl.rampgen.Angle * (float)10000 * (float)10000 * (float)10;
		angle[i] = sHal_AdcData.I.value[0]*1000;
100097ec:	e30c3010 	movw	r3, #49168	; 0xc010
100097f0:	e3413003 	movt	r3, #4099	; 0x1003
100097f4:	e5932000 	ldr	r2, [r3]
100097f8:	e30c3014 	movw	r3, #49172	; 0xc014
100097fc:	e3413003 	movt	r3, #4099	; 0x1003
10009800:	edd37a00 	vldr	s15, [r3]
10009804:	ed1f7ac1 	vldr	s14, [pc, #-772]	; 10009508 <motor_ctl+0x4b0>
10009808:	ee677a87 	vmul.f32	s15, s15, s14
1000980c:	eefd7ae7 	vcvt.s32.f32	s15, s15
10009810:	ee171a90 	vmov	r1, s15
10009814:	e3013d90 	movw	r3, #7568	; 0x1d90
10009818:	e3413004 	movt	r3, #4100	; 0x1004
1000981c:	e7831102 	str	r1, [r3, r2, lsl #2]
		//va[i] = gCtrl.Vab_out.value[0] * (float)10000 * (float)10000 * (float)10;
		va[i] = sHal_AdcData.I.value[1]*1000;
10009820:	e30c3010 	movw	r3, #49168	; 0xc010
10009824:	e3413003 	movt	r3, #4099	; 0x1003
10009828:	e5932000 	ldr	r2, [r3]
1000982c:	e30c3014 	movw	r3, #49172	; 0xc014
10009830:	e3413003 	movt	r3, #4099	; 0x1003
10009834:	edd37a01 	vldr	s15, [r3, #4]
10009838:	ed1f7ace 	vldr	s14, [pc, #-824]	; 10009508 <motor_ctl+0x4b0>
1000983c:	ee677a87 	vmul.f32	s15, s15, s14
10009840:	eefd7ae7 	vcvt.s32.f32	s15, s15
10009844:	ee171a90 	vmov	r1, s15
10009848:	e3013980 	movw	r3, #6528	; 0x1980
1000984c:	e3413004 	movt	r3, #4100	; 0x1004
10009850:	e7831102 	str	r1, [r3, r2, lsl #2]
		//vb[i] = gCtrl.Vab_out.value[1] * (float)10000 * (float)10000 * (float)10;
		vb[i] = sHal_AdcData.I.value[2]*1000;
10009854:	e30c3010 	movw	r3, #49168	; 0xc010
10009858:	e3413003 	movt	r3, #4099	; 0x1003
1000985c:	e5932000 	ldr	r2, [r3]
10009860:	e30c3014 	movw	r3, #49172	; 0xc014
10009864:	e3413003 	movt	r3, #4099	; 0x1003
10009868:	edd37a02 	vldr	s15, [r3, #8]
1000986c:	ed1f7adb 	vldr	s14, [pc, #-876]	; 10009508 <motor_ctl+0x4b0>
10009870:	ee677a87 	vmul.f32	s15, s15, s14
10009874:	eefd7ae7 	vcvt.s32.f32	s15, s15
10009878:	ee171a90 	vmov	r1, s15
1000987c:	e3003738 	movw	r3, #1848	; 0x738
10009880:	e3413004 	movt	r3, #4100	; 0x1004
10009884:	e7831102 	str	r1, [r3, r2, lsl #2]
		spd[i] = gCtrl.Speed.spd_test * 10000;
10009888:	e30c3010 	movw	r3, #49168	; 0xc010
1000988c:	e3413003 	movt	r3, #4099	; 0x1003
10009890:	e5932000 	ldr	r2, [r3]
10009894:	e30f3960 	movw	r3, #63840	; 0xf960
10009898:	e3413003 	movt	r3, #4099	; 0x1003
1000989c:	edd37ac4 	vldr	s15, [r3, #784]	; 0x310
100098a0:	ed1f7ae7 	vldr	s14, [pc, #-924]	; 1000950c <motor_ctl+0x4b4>
100098a4:	ee677a87 	vmul.f32	s15, s15, s14
100098a8:	eefd7ae7 	vcvt.s32.f32	s15, s15
100098ac:	ee171a90 	vmov	r1, s15
100098b0:	e3013158 	movw	r3, #4440	; 0x1158
100098b4:	e3413004 	movt	r3, #4100	; 0x1004
100098b8:	e7831102 	str	r1, [r3, r2, lsl #2]
		//spd[i] =  gCtrl.temp_iq * 10000;
		xi = 0;
100098bc:	e30c3048 	movw	r3, #49224	; 0xc048
100098c0:	e3413003 	movt	r3, #4099	; 0x1003
100098c4:	e3a02000 	mov	r2, #0
100098c8:	e5832000 	str	r2, [r3]
	//}
	#endif
	//rt_kprintf("%x,%x,%x\r\n",dutyhandle.pwm0_duty,dutyhandle.pwm1_duty,dutyhandle.pwm2_duty );
	rt_device_control(device_pwm,CMD_PWMSETDUTY,&dutyhandle);
100098cc:	e24b3084 	sub	r3, fp, #132	; 0x84
100098d0:	e51b0010 	ldr	r0, [fp, #-16]
100098d4:	e3a01003 	mov	r1, #3
100098d8:	e1a02003 	mov	r2, r3
100098dc:	eb0014b3 	bl	1000ebb0 <rt_device_control>
	#endif
}
100098e0:	e24bd004 	sub	sp, fp, #4
100098e4:	e8bd8800 	pop	{fp, pc}

100098e8 <adc_intr>:

static void adc_intr(int irqno, void *param)
{
100098e8:	e92d4800 	push	{fp, lr}
100098ec:	e28db004 	add	fp, sp, #4
100098f0:	e24dd010 	sub	sp, sp, #16
100098f4:	e50b0010 	str	r0, [fp, #-16]
100098f8:	e50b1014 	str	r1, [fp, #-20]
    struct hw_adc_device *pdev = (struct hw_adc_device *)param;
100098fc:	e51b3014 	ldr	r3, [fp, #-20]
10009900:	e50b3008 	str	r3, [fp, #-8]
	unsigned long temp;

	pdev->adchandle.Local_Instance->ctrl_reg.intr_time = 1;
10009904:	e51b3008 	ldr	r3, [fp, #-8]
10009908:	e5933000 	ldr	r3, [r3]
1000990c:	e5932020 	ldr	r2, [r3, #32]
10009910:	e3822002 	orr	r2, r2, #2
10009914:	e5832020 	str	r2, [r3, #32]
	pdev->adchandle.Local_Instance->ctrl_reg.intr_clr = 1; //CLR and forbid int
10009918:	e51b3008 	ldr	r3, [fp, #-8]
1000991c:	e5933000 	ldr	r3, [r3]
10009920:	e5932020 	ldr	r2, [r3, #32]
10009924:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
10009928:	e5832020 	str	r2, [r3, #32]

	motor_ctl(pdev);
1000992c:	e51b0008 	ldr	r0, [fp, #-8]
10009930:	ebfffdc8 	bl	10009058 <motor_ctl>

	pdev->adchandle.Local_Instance->ctrl_reg.intr_clr = 0; //enable int
10009934:	e51b3008 	ldr	r3, [fp, #-8]
10009938:	e5933000 	ldr	r3, [r3]
1000993c:	e5932020 	ldr	r2, [r3, #32]
10009940:	e3c22102 	bic	r2, r2, #-2147483648	; 0x80000000
10009944:	e5832020 	str	r2, [r3, #32]
	pdev->adchandle.Local_Instance->ctrl_reg.intr_time = 0;
10009948:	e51b3008 	ldr	r3, [fp, #-8]
1000994c:	e5933000 	ldr	r3, [r3]
10009950:	e5932020 	ldr	r2, [r3, #32]
10009954:	e3c22002 	bic	r2, r2, #2
10009958:	e5832020 	str	r2, [r3, #32]
}
1000995c:	e24bd004 	sub	sp, fp, #4
10009960:	e8bd8800 	pop	{fp, pc}

10009964 <ad_delay_us>:


static void ad_delay_us(unsigned int us)
{
10009964:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009968:	e28db000 	add	fp, sp, #0
1000996c:	e24dd014 	sub	sp, sp, #20
10009970:	e50b0010 	str	r0, [fp, #-16]
    volatile unsigned int len;
    for (; us > 0; us --)
10009974:	ea00000b 	b	100099a8 <ad_delay_us+0x44>
        for (len = 0; len < 20; len++ );
10009978:	e3a03000 	mov	r3, #0
1000997c:	e50b3008 	str	r3, [fp, #-8]
10009980:	ea000002 	b	10009990 <ad_delay_us+0x2c>
10009984:	e51b3008 	ldr	r3, [fp, #-8]
10009988:	e2833001 	add	r3, r3, #1
1000998c:	e50b3008 	str	r3, [fp, #-8]
10009990:	e51b3008 	ldr	r3, [fp, #-8]
10009994:	e3530013 	cmp	r3, #19
10009998:	9afffff9 	bls	10009984 <ad_delay_us+0x20>


static void ad_delay_us(unsigned int us)
{
    volatile unsigned int len;
    for (; us > 0; us --)
1000999c:	e51b3010 	ldr	r3, [fp, #-16]
100099a0:	e2433001 	sub	r3, r3, #1
100099a4:	e50b3010 	str	r3, [fp, #-16]
100099a8:	e51b3010 	ldr	r3, [fp, #-16]
100099ac:	e3530000 	cmp	r3, #0
100099b0:	1afffff0 	bne	10009978 <ad_delay_us+0x14>
        for (len = 0; len < 20; len++ );
}
100099b4:	e24bd000 	sub	sp, fp, #0
100099b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100099bc:	e12fff1e 	bx	lr

100099c0 <adc_setos>:

void adc_setos(struct hw_adc_device *pdev,unsigned char os)
{
100099c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100099c4:	e28db000 	add	fp, sp, #0
100099c8:	e24dd00c 	sub	sp, sp, #12
100099cc:	e50b0008 	str	r0, [fp, #-8]
100099d0:	e1a03001 	mov	r3, r1
100099d4:	e54b3009 	strb	r3, [fp, #-9]
	pdev->adchandle.Local_Instance->ctrl_reg.ad_os = os;
100099d8:	e51b3008 	ldr	r3, [fp, #-8]
100099dc:	e5933000 	ldr	r3, [r3]
100099e0:	e55b2009 	ldrb	r2, [fp, #-9]
100099e4:	e1a02282 	lsl	r2, r2, #5
100099e8:	e6af2072 	sxtb	r2, r2
100099ec:	e1a022c2 	asr	r2, r2, #5
100099f0:	e6ef2072 	uxtb	r2, r2
100099f4:	e2022007 	and	r2, r2, #7
100099f8:	e1a02102 	lsl	r2, r2, #2
100099fc:	e5931020 	ldr	r1, [r3, #32]
10009a00:	e3c1101c 	bic	r1, r1, #28
10009a04:	e1812002 	orr	r2, r1, r2
10009a08:	e5832020 	str	r2, [r3, #32]
}
10009a0c:	e24bd000 	sub	sp, fp, #0
10009a10:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009a14:	e12fff1e 	bx	lr

10009a18 <adc_rst>:
void adc_rst(struct hw_adc_device *pdev)
{
10009a18:	e92d4800 	push	{fp, lr}
10009a1c:	e28db004 	add	fp, sp, #4
10009a20:	e24dd008 	sub	sp, sp, #8
10009a24:	e50b0008 	str	r0, [fp, #-8]
	pdev->adchandle.Local_Instance->ctrl_reg.ad_rst = 1;
10009a28:	e51b3008 	ldr	r3, [fp, #-8]
10009a2c:	e5933000 	ldr	r3, [r3]
10009a30:	e5932020 	ldr	r2, [r3, #32]
10009a34:	e3822001 	orr	r2, r2, #1
10009a38:	e5832020 	str	r2, [r3, #32]
	ad_delay_us(100);
10009a3c:	e3a00064 	mov	r0, #100	; 0x64
10009a40:	ebffffc7 	bl	10009964 <ad_delay_us>
	pdev->adchandle.Local_Instance->ctrl_reg.ad_rst = 0;
10009a44:	e51b3008 	ldr	r3, [fp, #-8]
10009a48:	e5933000 	ldr	r3, [r3]
10009a4c:	e5932020 	ldr	r2, [r3, #32]
10009a50:	e3c22001 	bic	r2, r2, #1
10009a54:	e5832020 	str	r2, [r3, #32]
}
10009a58:	e24bd004 	sub	sp, fp, #4
10009a5c:	e8bd8800 	pop	{fp, pc}

10009a60 <adc_configure>:


static rt_err_t adc_configure(struct rt_adc_device *adcdev, struct adc_configure *cfg)
{
10009a60:	e92d4800 	push	{fp, lr}
10009a64:	e28db004 	add	fp, sp, #4
10009a68:	e24dd010 	sub	sp, sp, #16
10009a6c:	e50b0010 	str	r0, [fp, #-16]
10009a70:	e50b1014 	str	r1, [fp, #-20]
	struct hw_adc_device *pdev = adcdev->parent.user_data;
10009a74:	e51b3010 	ldr	r3, [fp, #-16]
10009a78:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10009a7c:	e50b3008 	str	r3, [fp, #-8]
	adc_rst(pdev);
10009a80:	e51b0008 	ldr	r0, [fp, #-8]
10009a84:	ebffffe3 	bl	10009a18 <adc_rst>
	adc_setos(pdev,OVERSAMPLE_2);
10009a88:	e51b0008 	ldr	r0, [fp, #-8]
10009a8c:	e3a01001 	mov	r1, #1
10009a90:	ebffffca 	bl	100099c0 <adc_setos>
	
	pdev->adchandle.Local_Instance->ctrl_reg.convst = 0;
10009a94:	e51b3008 	ldr	r3, [fp, #-8]
10009a98:	e5933000 	ldr	r3, [r3]
10009a9c:	e5932020 	ldr	r2, [r3, #32]
10009aa0:	e3c22020 	bic	r2, r2, #32
10009aa4:	e5832020 	str	r2, [r3, #32]
	
	pdev->adchandle.Local_Instance->ctrl_reg.intr_clr = 1;
10009aa8:	e51b3008 	ldr	r3, [fp, #-8]
10009aac:	e5933000 	ldr	r3, [r3]
10009ab0:	e5932020 	ldr	r2, [r3, #32]
10009ab4:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
10009ab8:	e5832020 	str	r2, [r3, #32]
	
	rt_kprintf("adc init complete\r\n");
10009abc:	e302080c 	movw	r0, #10252	; 0x280c
10009ac0:	e3410003 	movt	r0, #4099	; 0x1003
10009ac4:	eb0027fd 	bl	10013ac0 <rt_kprintf>
	
    return RT_EOK;
10009ac8:	e3a03000 	mov	r3, #0
}
10009acc:	e1a00003 	mov	r0, r3
10009ad0:	e24bd004 	sub	sp, fp, #4
10009ad4:	e8bd8800 	pop	{fp, pc}

10009ad8 <adc_convst>:

static void adc_convst(struct hw_adc_device *pdev)
{
10009ad8:	e92d4800 	push	{fp, lr}
10009adc:	e28db004 	add	fp, sp, #4
10009ae0:	e24dd008 	sub	sp, sp, #8
10009ae4:	e50b0008 	str	r0, [fp, #-8]
	pdev->adchandle.Local_Instance->ctrl_reg.convst = 1;
10009ae8:	e51b3008 	ldr	r3, [fp, #-8]
10009aec:	e5933000 	ldr	r3, [r3]
10009af0:	e5932020 	ldr	r2, [r3, #32]
10009af4:	e3822020 	orr	r2, r2, #32
10009af8:	e5832020 	str	r2, [r3, #32]
	ad_delay_us(1);
10009afc:	e3a00001 	mov	r0, #1
10009b00:	ebffff97 	bl	10009964 <ad_delay_us>
	pdev->adchandle.Local_Instance->ctrl_reg.convst = 0;
10009b04:	e51b3008 	ldr	r3, [fp, #-8]
10009b08:	e5933000 	ldr	r3, [r3]
10009b0c:	e5932020 	ldr	r2, [r3, #32]
10009b10:	e3c22020 	bic	r2, r2, #32
10009b14:	e5832020 	str	r2, [r3, #32]

}
10009b18:	e24bd004 	sub	sp, fp, #4
10009b1c:	e8bd8800 	pop	{fp, pc}

10009b20 <adc_control>:

static rt_err_t adc_control(struct rt_adc_device *adcdev, int cmd, void *arg)
{
10009b20:	e92d4800 	push	{fp, lr}
10009b24:	e28db004 	add	fp, sp, #4
10009b28:	e24dd018 	sub	sp, sp, #24
10009b2c:	e50b0010 	str	r0, [fp, #-16]
10009b30:	e50b1014 	str	r1, [fp, #-20]
10009b34:	e50b2018 	str	r2, [fp, #-24]
    struct hw_adc_device *pdev;
	unsigned int *temp;
	unsigned long temp1;

    RT_ASSERT(adcdev != RT_NULL);
10009b38:	e51b3010 	ldr	r3, [fp, #-16]
10009b3c:	e3530000 	cmp	r3, #0
10009b40:	1a000005 	bne	10009b5c <adc_control+0x3c>
10009b44:	e3020820 	movw	r0, #10272	; 0x2820
10009b48:	e3410003 	movt	r0, #4099	; 0x1003
10009b4c:	e302184c 	movw	r1, #10316	; 0x284c
10009b50:	e3411003 	movt	r1, #4099	; 0x1003
10009b54:	e3a020e8 	mov	r2, #232	; 0xe8
10009b58:	eb002895 	bl	10013db4 <rt_assert_handler>

    pdev = adcdev->parent.user_data;
10009b5c:	e51b3010 	ldr	r3, [fp, #-16]
10009b60:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10009b64:	e50b3008 	str	r3, [fp, #-8]

    switch (cmd)
10009b68:	e51b3014 	ldr	r3, [fp, #-20]
10009b6c:	e2433001 	sub	r3, r3, #1
10009b70:	e3530004 	cmp	r3, #4
10009b74:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10009b78:	ea000033 	b	10009c4c <adc_control+0x12c>
10009b7c:	10009ba8 	.word	0x10009ba8
10009b80:	10009b90 	.word	0x10009b90
10009b84:	10009c04 	.word	0x10009c04
10009b88:	10009c1c 	.word	0x10009c1c
10009b8c:	10009c40 	.word	0x10009c40
    {
	case CMD_INTDISABLE:
		//rt_hw_interrupt_mask(pdev->adchandle.irq_nr);
		
		pdev->adchandle.Local_Instance->ctrl_reg.intr_clr = 1;
10009b90:	e51b3008 	ldr	r3, [fp, #-8]
10009b94:	e5933000 	ldr	r3, [r3]
10009b98:	e5932020 	ldr	r2, [r3, #32]
10009b9c:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
10009ba0:	e5832020 	str	r2, [r3, #32]

		break;
10009ba4:	ea000029 	b	10009c50 <adc_control+0x130>
	case CMD_INTENABLE:
		
		pdev->adchandle.Local_Instance->ctrl_reg.intr_clr = 0;
10009ba8:	e51b3008 	ldr	r3, [fp, #-8]
10009bac:	e5933000 	ldr	r3, [r3]
10009bb0:	e5932020 	ldr	r2, [r3, #32]
10009bb4:	e3c22102 	bic	r2, r2, #-2147483648	; 0x80000000
10009bb8:	e5832020 	str	r2, [r3, #32]
		
		rt_hw_interrupt_clear(pdev->adchandle.irq_nr);
10009bbc:	e51b3008 	ldr	r3, [fp, #-8]
10009bc0:	e5d33004 	ldrb	r3, [r3, #4]
10009bc4:	e1a00003 	mov	r0, r3
10009bc8:	eb003c4a 	bl	10018cf8 <rt_hw_interrupt_clear>
		rt_hw_interrupt_install(pdev->adchandle.irq_nr,adc_intr,pdev, "adc_intr");
10009bcc:	e51b3008 	ldr	r3, [fp, #-8]
10009bd0:	e5d33004 	ldrb	r3, [r3, #4]
10009bd4:	e1a00003 	mov	r0, r3
10009bd8:	e30918e8 	movw	r1, #39144	; 0x98e8
10009bdc:	e3411000 	movt	r1, #4096	; 0x1000
10009be0:	e51b2008 	ldr	r2, [fp, #-8]
10009be4:	e3023834 	movw	r3, #10292	; 0x2834
10009be8:	e3413003 	movt	r3, #4099	; 0x1003
10009bec:	eb003bfe 	bl	10018bec <rt_hw_interrupt_install>
		
		//arm_gic_set_cpu(0, pdev->adchandle.irq_nr, 1 << rt_cpu_get_smp_id());
		rt_hw_interrupt_umask(pdev->adchandle.irq_nr);
10009bf0:	e51b3008 	ldr	r3, [fp, #-8]
10009bf4:	e5d33004 	ldrb	r3, [r3, #4]
10009bf8:	e1a00003 	mov	r0, r3
10009bfc:	eb003bf1 	bl	10018bc8 <rt_hw_interrupt_umask>

		break;
10009c00:	ea000012 	b	10009c50 <adc_control+0x130>
	case CMD_RST:
		pdev->adchandle.Local_Instance->ctrl_reg.ad_rst = 1;
10009c04:	e51b3008 	ldr	r3, [fp, #-8]
10009c08:	e5933000 	ldr	r3, [r3]
10009c0c:	e5932020 	ldr	r2, [r3, #32]
10009c10:	e3822001 	orr	r2, r2, #1
10009c14:	e5832020 	str	r2, [r3, #32]
		break;
10009c18:	ea00000c 	b	10009c50 <adc_control+0x130>
	case CMD_CFG:
		temp = arg;
10009c1c:	e51b3018 	ldr	r3, [fp, #-24]
10009c20:	e50b300c 	str	r3, [fp, #-12]
		adc_setos(pdev,*temp);
10009c24:	e51b300c 	ldr	r3, [fp, #-12]
10009c28:	e5933000 	ldr	r3, [r3]
10009c2c:	e6ef3073 	uxtb	r3, r3
10009c30:	e51b0008 	ldr	r0, [fp, #-8]
10009c34:	e1a01003 	mov	r1, r3
10009c38:	ebffff60 	bl	100099c0 <adc_setos>
		break;
10009c3c:	ea000003 	b	10009c50 <adc_control+0x130>
	case CMD_CONVST:
		adc_convst(pdev);
10009c40:	e51b0008 	ldr	r0, [fp, #-8]
10009c44:	ebffffa3 	bl	10009ad8 <adc_convst>
		break;
10009c48:	ea000000 	b	10009c50 <adc_control+0x130>
	default: 
			break;
10009c4c:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
10009c50:	e3a03000 	mov	r3, #0
}
10009c54:	e1a00003 	mov	r0, r3
10009c58:	e24bd004 	sub	sp, fp, #4
10009c5c:	e8bd8800 	pop	{fp, pc}

10009c60 <adc_getValue>:
**VDC,TEMP = VIN
*/


static QIEMW_ADC_HandleTypeDef adc_getValue(struct rt_adc_device *adcdev)
{
10009c60:	e92d4800 	push	{fp, lr}
10009c64:	e28db004 	add	fp, sp, #4
10009c68:	e24dd070 	sub	sp, sp, #112	; 0x70
10009c6c:	e50b0070 	str	r0, [fp, #-112]	; 0x70
10009c70:	e50b1074 	str	r1, [fp, #-116]	; 0x74
    struct hw_adc_device *pdev;
	QIEMW_ADC_HandleTypeDef adcvalue;


    RT_ASSERT(adcdev != RT_NULL);
10009c74:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
10009c78:	e3530000 	cmp	r3, #0
10009c7c:	1a000005 	bne	10009c98 <adc_getValue+0x38>
10009c80:	e3020820 	movw	r0, #10272	; 0x2820
10009c84:	e3410003 	movt	r0, #4099	; 0x1003
10009c88:	e3021858 	movw	r1, #10328	; 0x2858
10009c8c:	e3411003 	movt	r1, #4099	; 0x1003
10009c90:	e300211d 	movw	r2, #285	; 0x11d
10009c94:	eb002846 	bl	10013db4 <rt_assert_handler>

    pdev = adcdev->parent.user_data;
10009c98:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
10009c9c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10009ca0:	e50b3008 	str	r3, [fp, #-8]

	while(pdev->adchandle.Local_Instance->state_reg & 0x1 == 0);
10009ca4:	e1a00000 	nop			; (mov r0, r0)
10009ca8:	e51b3008 	ldr	r3, [fp, #-8]
10009cac:	e5933000 	ldr	r3, [r3]
10009cb0:	e5933024 	ldr	r3, [r3, #36]	; 0x24

	pdev->adchandle.Local_Instance->ctrl_reg.intr_clr = 1;
10009cb4:	e51b3008 	ldr	r3, [fp, #-8]
10009cb8:	e5933000 	ldr	r3, [r3]
10009cbc:	e5932020 	ldr	r2, [r3, #32]
10009cc0:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
10009cc4:	e5832020 	str	r2, [r3, #32]

	adcvalue.PhaseA.qI_value = pdev->adchandle.Local_Instance->data1_reg;//IV
10009cc8:	e51b3008 	ldr	r3, [fp, #-8]
10009ccc:	e5933000 	ldr	r3, [r3]
10009cd0:	e5933000 	ldr	r3, [r3]
10009cd4:	e6ff3073 	uxth	r3, r3
10009cd8:	e14b36b4 	strh	r3, [fp, #-100]	; 0xffffff9c
	adcvalue.PhaseB.qI_value = pdev->adchandle.Local_Instance->data2_reg;//IW
10009cdc:	e51b3008 	ldr	r3, [fp, #-8]
10009ce0:	e5933000 	ldr	r3, [r3]
10009ce4:	e5933004 	ldr	r3, [r3, #4]
10009ce8:	e6ff3073 	uxth	r3, r3
10009cec:	e14b35b6 	strh	r3, [fp, #-86]	; 0xffffffaa
	adcvalue.PhaseC.qI_value = pdev->adchandle.Local_Instance->data3_reg;//IU
10009cf0:	e51b3008 	ldr	r3, [fp, #-8]
10009cf4:	e5933000 	ldr	r3, [r3]
10009cf8:	e5933008 	ldr	r3, [r3, #8]
10009cfc:	e6ff3073 	uxth	r3, r3
10009d00:	e14b34b8 	strh	r3, [fp, #-72]	; 0xffffffb8
	adcvalue.BUS.qV_value = pdev->adchandle.Local_Instance->data4_reg;//VDC
10009d04:	e51b3008 	ldr	r3, [fp, #-8]
10009d08:	e5933000 	ldr	r3, [r3]
10009d0c:	e593300c 	ldr	r3, [r3, #12]
10009d10:	e6ff3073 	uxth	r3, r3
10009d14:	e14b33be 	strh	r3, [fp, #-62]	; 0xffffffc2
	adcvalue.Temp.TEMP_value = pdev->adchandle.Local_Instance->data5_reg;//TEMP
10009d18:	e51b3008 	ldr	r3, [fp, #-8]
10009d1c:	e5933000 	ldr	r3, [r3]
10009d20:	e5933010 	ldr	r3, [r3, #16]
10009d24:	e6ff3073 	uxth	r3, r3
10009d28:	e14b31b0 	strh	r3, [fp, #-16]
	adcvalue.PhaseA.qV_value = pdev->adchandle.Local_Instance->data6_reg;//VUV
10009d2c:	e51b3008 	ldr	r3, [fp, #-8]
10009d30:	e5933000 	ldr	r3, [r3]
10009d34:	e5933014 	ldr	r3, [r3, #20]
10009d38:	e6ff3073 	uxth	r3, r3
10009d3c:	e14b36b2 	strh	r3, [fp, #-98]	; 0xffffff9e
	adcvalue.PhaseB.qV_value = pdev->adchandle.Local_Instance->data7_reg;//VVW
10009d40:	e51b3008 	ldr	r3, [fp, #-8]
10009d44:	e5933000 	ldr	r3, [r3]
10009d48:	e5933018 	ldr	r3, [r3, #24]
10009d4c:	e6ff3073 	uxth	r3, r3
10009d50:	e14b35b4 	strh	r3, [fp, #-84]	; 0xffffffac
	
	pdev->adchandle.Local_Instance->ctrl_reg.intr_clr = 0;
10009d54:	e51b3008 	ldr	r3, [fp, #-8]
10009d58:	e5933000 	ldr	r3, [r3]
10009d5c:	e5932020 	ldr	r2, [r3, #32]
10009d60:	e3c22102 	bic	r2, r2, #-2147483648	; 0x80000000
10009d64:	e5832020 	str	r2, [r3, #32]

	return adcvalue;
10009d68:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
10009d6c:	e1a01003 	mov	r1, r3
10009d70:	e24b306c 	sub	r3, fp, #108	; 0x6c
10009d74:	e3a02064 	mov	r2, #100	; 0x64
10009d78:	e1a00001 	mov	r0, r1
10009d7c:	e1a01003 	mov	r1, r3
10009d80:	fa00955b 	blx	1002f2f4 <memcpy>
}
10009d84:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
10009d88:	e24bd004 	sub	sp, fp, #4
10009d8c:	e8bd8800 	pop	{fp, pc}

10009d90 <ADC_MSP_Init>:
    adc_control,
    adc_getValue,
};

void ADC_MSP_Init(ADC_HandleTypeDef *adc)
{
10009d90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009d94:	e28db000 	add	fp, sp, #0
10009d98:	e24dd00c 	sub	sp, sp, #12
10009d9c:	e50b0008 	str	r0, [fp, #-8]
}
10009da0:	e24bd000 	sub	sp, fp, #0
10009da4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009da8:	e12fff1e 	bx	lr

10009dac <adc_hw_init>:




int adc_hw_init(void)
{
10009dac:	e92d4800 	push	{fp, lr}
10009db0:	e28db004 	add	fp, sp, #4

	struct adc_configure adc_config = RT_ADC_CONFIG_DEFAULT;
	adc_device1.config = adc_config;
	adc_device1.ops = &_adc_ops;
10009db4:	e30235b4 	movw	r3, #9652	; 0x25b4
10009db8:	e3413004 	movt	r3, #4100	; 0x1004
10009dbc:	e3022840 	movw	r2, #10304	; 0x2840
10009dc0:	e3412003 	movt	r2, #4099	; 0x1003
10009dc4:	e583203c 	str	r2, [r3, #60]	; 0x3c
	
	adc_handle.Local_Instance = ADC_LOCAL_BASEADDR;
10009dc8:	e3002b48 	movw	r2, #2888	; 0xb48
10009dcc:	e3412004 	movt	r2, #4100	; 0x1004
10009dd0:	e3a03000 	mov	r3, #0
10009dd4:	e34433c0 	movt	r3, #17344	; 0x43c0
10009dd8:	e5823000 	str	r3, [r2]
	adc_handle.irq_nr = CPU1_IRQ_ID;
10009ddc:	e3003b48 	movw	r3, #2888	; 0xb48
10009de0:	e3413004 	movt	r3, #4100	; 0x1004
10009de4:	e3a0201f 	mov	r2, #31
10009de8:	e5c32004 	strb	r2, [r3, #4]
	//adc_handle.irq_nr = CPU1_FIQ_ID;

	adc_hw_device1.adchandle= adc_handle;
10009dec:	e3012568 	movw	r2, #5480	; 0x1568
10009df0:	e3412004 	movt	r2, #4100	; 0x1004
10009df4:	e3003b48 	movw	r3, #2888	; 0xb48
10009df8:	e3413004 	movt	r3, #4100	; 0x1004
10009dfc:	e8930003 	ldm	r3, {r0, r1}
10009e00:	e8820003 	stm	r2, {r0, r1}

	rt_hw_adc_register(&adc_device1, "adc1",
10009e04:	e30205b4 	movw	r0, #9652	; 0x25b4
10009e08:	e3410004 	movt	r0, #4100	; 0x1004
10009e0c:	e30217fc 	movw	r1, #10236	; 0x27fc
10009e10:	e3411003 	movt	r1, #4099	; 0x1003
10009e14:	e3a02001 	mov	r2, #1
10009e18:	e3013568 	movw	r3, #5480	; 0x1568
10009e1c:	e3413004 	movt	r3, #4100	; 0x1004
10009e20:	eb00008f 	bl	1000a064 <rt_hw_adc_register>
                          RT_DEVICE_FLAG_RDONLY,
                          &adc_hw_device1);

	return 0;
10009e24:	e3a03000 	mov	r3, #0

}
10009e28:	e1a00003 	mov	r0, r3
10009e2c:	e8bd8800 	pop	{fp, pc}

10009e30 <rt_adc_init>:
#include <rtdevice.h>
#include "adc.h"


static rt_err_t rt_adc_init(struct rt_device *dev)
{
10009e30:	e92d4800 	push	{fp, lr}
10009e34:	e28db004 	add	fp, sp, #4
10009e38:	e24dd010 	sub	sp, sp, #16
10009e3c:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
10009e40:	e3a03000 	mov	r3, #0
10009e44:	e50b3008 	str	r3, [fp, #-8]
    struct rt_adc_device *adcdev;

    RT_ASSERT(dev != RT_NULL);
10009e48:	e51b3010 	ldr	r3, [fp, #-16]
10009e4c:	e3530000 	cmp	r3, #0
10009e50:	1a000005 	bne	10009e6c <rt_adc_init+0x3c>
10009e54:	e3020868 	movw	r0, #10344	; 0x2868
10009e58:	e3410003 	movt	r0, #4099	; 0x1003
10009e5c:	e30218a0 	movw	r1, #10400	; 0x28a0
10009e60:	e3411003 	movt	r1, #4099	; 0x1003
10009e64:	e3a0200e 	mov	r2, #14
10009e68:	eb0027d1 	bl	10013db4 <rt_assert_handler>
    adcdev = (struct rt_adc_device *)dev;
10009e6c:	e51b3010 	ldr	r3, [fp, #-16]
10009e70:	e50b300c 	str	r3, [fp, #-12]

    /* apply configuration */
    if (adcdev->ops->configure)
10009e74:	e51b300c 	ldr	r3, [fp, #-12]
10009e78:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10009e7c:	e5933000 	ldr	r3, [r3]
10009e80:	e3530000 	cmp	r3, #0
10009e84:	0a000008 	beq	10009eac <rt_adc_init+0x7c>
        result = adcdev->ops->configure(adcdev, &adcdev->config);
10009e88:	e51b300c 	ldr	r3, [fp, #-12]
10009e8c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10009e90:	e5933000 	ldr	r3, [r3]
10009e94:	e51b200c 	ldr	r2, [fp, #-12]
10009e98:	e2822040 	add	r2, r2, #64	; 0x40
10009e9c:	e51b000c 	ldr	r0, [fp, #-12]
10009ea0:	e1a01002 	mov	r1, r2
10009ea4:	e12fff33 	blx	r3
10009ea8:	e50b0008 	str	r0, [fp, #-8]
	//rt_kprintf("%x\r\n", result);
    return result;
10009eac:	e51b3008 	ldr	r3, [fp, #-8]
}
10009eb0:	e1a00003 	mov	r0, r3
10009eb4:	e24bd004 	sub	sp, fp, #4
10009eb8:	e8bd8800 	pop	{fp, pc}

10009ebc <rt_adc_open>:

static rt_err_t rt_adc_open(struct rt_device *dev, rt_uint16_t oflag)
{
10009ebc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009ec0:	e28db000 	add	fp, sp, #0
10009ec4:	e24dd014 	sub	sp, sp, #20
10009ec8:	e50b0010 	str	r0, [fp, #-16]
10009ecc:	e1a03001 	mov	r3, r1
10009ed0:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    rt_err_t result = RT_EOK;
10009ed4:	e3a03000 	mov	r3, #0
10009ed8:	e50b3008 	str	r3, [fp, #-8]
	
	return result;
10009edc:	e51b3008 	ldr	r3, [fp, #-8]
}
10009ee0:	e1a00003 	mov	r0, r3
10009ee4:	e24bd000 	sub	sp, fp, #0
10009ee8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009eec:	e12fff1e 	bx	lr

10009ef0 <rt_adc_close>:

static rt_err_t rt_adc_close(struct rt_device *dev)
{
10009ef0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009ef4:	e28db000 	add	fp, sp, #0
10009ef8:	e24dd014 	sub	sp, sp, #20
10009efc:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
10009f00:	e3a03000 	mov	r3, #0
10009f04:	e50b3008 	str	r3, [fp, #-8]

    return result;
10009f08:	e51b3008 	ldr	r3, [fp, #-8]
}
10009f0c:	e1a00003 	mov	r0, r3
10009f10:	e24bd000 	sub	sp, fp, #0
10009f14:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009f18:	e12fff1e 	bx	lr

10009f1c <rt_adc_control>:
static rt_err_t rt_adc_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
10009f1c:	e92d4800 	push	{fp, lr}
10009f20:	e28db004 	add	fp, sp, #4
10009f24:	e24dd018 	sub	sp, sp, #24
10009f28:	e50b0010 	str	r0, [fp, #-16]
10009f2c:	e1a03001 	mov	r3, r1
10009f30:	e50b2018 	str	r2, [fp, #-24]
10009f34:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_adc_device *adcdev;

    RT_ASSERT(dev != RT_NULL);
10009f38:	e51b3010 	ldr	r3, [fp, #-16]
10009f3c:	e3530000 	cmp	r3, #0
10009f40:	1a000005 	bne	10009f5c <rt_adc_control+0x40>
10009f44:	e3020868 	movw	r0, #10344	; 0x2868
10009f48:	e3410003 	movt	r0, #4099	; 0x1003
10009f4c:	e30218ac 	movw	r1, #10412	; 0x28ac
10009f50:	e3411003 	movt	r1, #4099	; 0x1003
10009f54:	e3a0202b 	mov	r2, #43	; 0x2b
10009f58:	eb002795 	bl	10013db4 <rt_assert_handler>
    adcdev = (struct rt_adc_device *)dev;
10009f5c:	e51b3010 	ldr	r3, [fp, #-16]
10009f60:	e50b3008 	str	r3, [fp, #-8]

    /* control device */
    adcdev->ops->control(adcdev, cmd, args);
10009f64:	e51b3008 	ldr	r3, [fp, #-8]
10009f68:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10009f6c:	e5933004 	ldr	r3, [r3, #4]
10009f70:	e55b2011 	ldrb	r2, [fp, #-17]
10009f74:	e51b0008 	ldr	r0, [fp, #-8]
10009f78:	e1a01002 	mov	r1, r2
10009f7c:	e51b2018 	ldr	r2, [fp, #-24]
10009f80:	e12fff33 	blx	r3

    return RT_EOK;
10009f84:	e3a03000 	mov	r3, #0
}
10009f88:	e1a00003 	mov	r0, r3
10009f8c:	e24bd004 	sub	sp, fp, #4
10009f90:	e8bd8800 	pop	{fp, pc}

10009f94 <rt_adc_read>:
static rt_size_t rt_adc_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)

{
10009f94:	e92d4800 	push	{fp, lr}
10009f98:	e28db004 	add	fp, sp, #4
10009f9c:	e24dd0e8 	sub	sp, sp, #232	; 0xe8
10009fa0:	e50b0078 	str	r0, [fp, #-120]	; 0x78
10009fa4:	e50b107c 	str	r1, [fp, #-124]	; 0x7c
10009fa8:	e50b2080 	str	r2, [fp, #-128]	; 0x80
10009fac:	e50b3084 	str	r3, [fp, #-132]	; 0x84
    struct rt_adc_device *adcdev;
	QIEMW_ADC_HandleTypeDef *padcvalue,adcvalue;

    RT_ASSERT(dev != RT_NULL);
10009fb0:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
10009fb4:	e3530000 	cmp	r3, #0
10009fb8:	1a000005 	bne	10009fd4 <rt_adc_read+0x40>
10009fbc:	e3020868 	movw	r0, #10344	; 0x2868
10009fc0:	e3410003 	movt	r0, #4099	; 0x1003
10009fc4:	e30218bc 	movw	r1, #10428	; 0x28bc
10009fc8:	e3411003 	movt	r1, #4099	; 0x1003
10009fcc:	e3a0203d 	mov	r2, #61	; 0x3d
10009fd0:	eb002777 	bl	10013db4 <rt_assert_handler>
    adcdev = (struct rt_adc_device *)dev;
10009fd4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
10009fd8:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(buffer != RT_NULL);
10009fdc:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
10009fe0:	e3530000 	cmp	r3, #0
10009fe4:	1a000005 	bne	1000a000 <rt_adc_read+0x6c>
10009fe8:	e3020878 	movw	r0, #10360	; 0x2878
10009fec:	e3410003 	movt	r0, #4099	; 0x1003
10009ff0:	e30218bc 	movw	r1, #10428	; 0x28bc
10009ff4:	e3411003 	movt	r1, #4099	; 0x1003
10009ff8:	e3a02040 	mov	r2, #64	; 0x40
10009ffc:	eb00276c 	bl	10013db4 <rt_assert_handler>
    padcvalue = (QIEMW_ADC_HandleTypeDef *)buffer;
1000a000:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
1000a004:	e50b300c 	str	r3, [fp, #-12]
	
	adcvalue = adcdev->ops->getAdcValue(adcdev);
1000a008:	e51b3008 	ldr	r3, [fp, #-8]
1000a00c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000a010:	e5933008 	ldr	r3, [r3, #8]
1000a014:	e24b20ec 	sub	r2, fp, #236	; 0xec
1000a018:	e1a00002 	mov	r0, r2
1000a01c:	e51b1008 	ldr	r1, [fp, #-8]
1000a020:	e12fff33 	blx	r3
1000a024:	e24b2070 	sub	r2, fp, #112	; 0x70
1000a028:	e24b30ec 	sub	r3, fp, #236	; 0xec
1000a02c:	e3a0c064 	mov	ip, #100	; 0x64
1000a030:	e1a00002 	mov	r0, r2
1000a034:	e1a01003 	mov	r1, r3
1000a038:	e1a0200c 	mov	r2, ip
1000a03c:	fa0094ac 	blx	1002f2f4 <memcpy>

	memcpy(padcvalue,&adcvalue,sizeof(QIEMW_ADC_HandleTypeDef));
1000a040:	e24b3070 	sub	r3, fp, #112	; 0x70
1000a044:	e51b000c 	ldr	r0, [fp, #-12]
1000a048:	e1a01003 	mov	r1, r3
1000a04c:	e3a02064 	mov	r2, #100	; 0x64
1000a050:	fa0094a7 	blx	1002f2f4 <memcpy>
	
    return 1;
1000a054:	e3a03001 	mov	r3, #1
}
1000a058:	e1a00003 	mov	r0, r3
1000a05c:	e24bd004 	sub	sp, fp, #4
1000a060:	e8bd8800 	pop	{fp, pc}

1000a064 <rt_hw_adc_register>:

rt_err_t rt_hw_adc_register(struct rt_adc_device *adcdev,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
1000a064:	e92d4800 	push	{fp, lr}
1000a068:	e28db004 	add	fp, sp, #4
1000a06c:	e24dd018 	sub	sp, sp, #24
1000a070:	e50b0010 	str	r0, [fp, #-16]
1000a074:	e50b1014 	str	r1, [fp, #-20]
1000a078:	e50b2018 	str	r2, [fp, #-24]
1000a07c:	e50b301c 	str	r3, [fp, #-28]
    struct rt_device *device;
    RT_ASSERT(adcdev != RT_NULL);
1000a080:	e51b3010 	ldr	r3, [fp, #-16]
1000a084:	e3530000 	cmp	r3, #0
1000a088:	1a000005 	bne	1000a0a4 <rt_hw_adc_register+0x40>
1000a08c:	e302088c 	movw	r0, #10380	; 0x288c
1000a090:	e3410003 	movt	r0, #4099	; 0x1003
1000a094:	e30218c8 	movw	r1, #10440	; 0x28c8
1000a098:	e3411003 	movt	r1, #4099	; 0x1003
1000a09c:	e3a02050 	mov	r2, #80	; 0x50
1000a0a0:	eb002743 	bl	10013db4 <rt_assert_handler>

    device = &(adcdev->parent);
1000a0a4:	e51b3010 	ldr	r3, [fp, #-16]
1000a0a8:	e50b3008 	str	r3, [fp, #-8]

    device->type        = RT_Device_Class_Miscellaneous;
1000a0ac:	e51b3008 	ldr	r3, [fp, #-8]
1000a0b0:	e3a02012 	mov	r2, #18
1000a0b4:	e5c32010 	strb	r2, [r3, #16]
    device->rx_indicate = RT_NULL;
1000a0b8:	e51b3008 	ldr	r3, [fp, #-8]
1000a0bc:	e3a02000 	mov	r2, #0
1000a0c0:	e5832018 	str	r2, [r3, #24]
    device->tx_complete = RT_NULL;
1000a0c4:	e51b3008 	ldr	r3, [fp, #-8]
1000a0c8:	e3a02000 	mov	r2, #0
1000a0cc:	e583201c 	str	r2, [r3, #28]

    device->init        = rt_adc_init;
1000a0d0:	e51b2008 	ldr	r2, [fp, #-8]
1000a0d4:	e3093e30 	movw	r3, #40496	; 0x9e30
1000a0d8:	e3413000 	movt	r3, #4096	; 0x1000
1000a0dc:	e5823020 	str	r3, [r2, #32]
    device->open        = rt_adc_open;
1000a0e0:	e51b2008 	ldr	r2, [fp, #-8]
1000a0e4:	e3093ebc 	movw	r3, #40636	; 0x9ebc
1000a0e8:	e3413000 	movt	r3, #4096	; 0x1000
1000a0ec:	e5823024 	str	r3, [r2, #36]	; 0x24
    device->close       = rt_adc_close;
1000a0f0:	e51b2008 	ldr	r2, [fp, #-8]
1000a0f4:	e3093ef0 	movw	r3, #40688	; 0x9ef0
1000a0f8:	e3413000 	movt	r3, #4096	; 0x1000
1000a0fc:	e5823028 	str	r3, [r2, #40]	; 0x28
    device->control     = rt_adc_control;
1000a100:	e51b2008 	ldr	r2, [fp, #-8]
1000a104:	e3093f1c 	movw	r3, #40732	; 0x9f1c
1000a108:	e3413000 	movt	r3, #4096	; 0x1000
1000a10c:	e5823034 	str	r3, [r2, #52]	; 0x34
    device->read        = rt_adc_read;
1000a110:	e51b2008 	ldr	r2, [fp, #-8]
1000a114:	e3093f94 	movw	r3, #40852	; 0x9f94
1000a118:	e3413000 	movt	r3, #4096	; 0x1000
1000a11c:	e582302c 	str	r3, [r2, #44]	; 0x2c
    device->user_data   = data;
1000a120:	e51b3008 	ldr	r3, [fp, #-8]
1000a124:	e51b201c 	ldr	r2, [fp, #-28]
1000a128:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* register a character device */
    return rt_device_register(device, name, flag);
1000a12c:	e51b3018 	ldr	r3, [fp, #-24]
1000a130:	e6ff3073 	uxth	r3, r3
1000a134:	e51b0008 	ldr	r0, [fp, #-8]
1000a138:	e51b1014 	ldr	r1, [fp, #-20]
1000a13c:	e1a02003 	mov	r2, r3
1000a140:	eb001106 	bl	1000e560 <rt_device_register>
1000a144:	e1a03000 	mov	r3, r0
}
1000a148:	e1a00003 	mov	r0, r3
1000a14c:	e24bd004 	sub	sp, fp, #4
1000a150:	e8bd8800 	pop	{fp, pc}

1000a154 <rt_hw_timer_isr>:

#define PRIVATE_TIMER_BASE            0xF8F00600
#define PRIVATE_TIMER                ((ptimer_reg_t*)PRIVATE_TIMER_BASE)

static void rt_hw_timer_isr(int vector, void *param)
{
1000a154:	e92d4800 	push	{fp, lr}
1000a158:	e28db004 	add	fp, sp, #4
1000a15c:	e24dd008 	sub	sp, sp, #8
1000a160:	e50b0008 	str	r0, [fp, #-8]
1000a164:	e50b100c 	str	r1, [fp, #-12]
    rt_tick_increase();
1000a168:	eb00108c 	bl	1000e3a0 <rt_tick_increase>
    /* clear interrupt */
    PRIVATE_TIMER->ISR = PRIVATE_TIMER_ISR_EVENT_FLAG_MASK;
1000a16c:	e3a03c06 	mov	r3, #1536	; 0x600
1000a170:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a174:	e3a02001 	mov	r2, #1
1000a178:	e583200c 	str	r2, [r3, #12]
}
1000a17c:	e24bd004 	sub	sp, fp, #4
1000a180:	e8bd8800 	pop	{fp, pc}

1000a184 <rt_hw_timer_init>:

int rt_hw_timer_init(void)
{
1000a184:	e92d4800 	push	{fp, lr}
1000a188:	e28db004 	add	fp, sp, #4
1000a18c:	e24dd008 	sub	sp, sp, #8
    PRIVATE_TIMER->CONTROL &= ~PRIVATE_TIMER_CONTROL_ENABLE_MASK;
1000a190:	e3a03c06 	mov	r3, #1536	; 0x600
1000a194:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a198:	e3a02c06 	mov	r2, #1536	; 0x600
1000a19c:	e34f28f0 	movt	r2, #63728	; 0xf8f0
1000a1a0:	e5922008 	ldr	r2, [r2, #8]
1000a1a4:	e3c22001 	bic	r2, r2, #1
1000a1a8:	e5832008 	str	r2, [r3, #8]
    {
        /* Clear the prescaler. */
        rt_uint32_t ctrl = PRIVATE_TIMER->CONTROL;
1000a1ac:	e3a03c06 	mov	r3, #1536	; 0x600
1000a1b0:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a1b4:	e5933008 	ldr	r3, [r3, #8]
1000a1b8:	e50b3008 	str	r3, [fp, #-8]
        ctrl &= ~PRIVATE_TIMER_CONTROL_PRESCALER_MASK;
1000a1bc:	e51b3008 	ldr	r3, [fp, #-8]
1000a1c0:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
1000a1c4:	e50b3008 	str	r3, [fp, #-8]
        PRIVATE_TIMER->CONTROL = ctrl;
1000a1c8:	e3a03c06 	mov	r3, #1536	; 0x600
1000a1cc:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a1d0:	e51b2008 	ldr	r2, [fp, #-8]
1000a1d4:	e5832008 	str	r2, [r3, #8]
    }
    /* The processor timer is always clocked at 1/2 CPU frequency(CPU_3x2x). */
    PRIVATE_TIMER->COUNTER = APU_FREQ/2/RT_TICK_PER_SECOND;
1000a1d8:	e3a03c06 	mov	r3, #1536	; 0x600
1000a1dc:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a1e0:	e3012615 	movw	r2, #5653	; 0x1615
1000a1e4:	e3402005 	movt	r2, #5
1000a1e8:	e5832004 	str	r2, [r3, #4]
    /* Set reload value. */
    PRIVATE_TIMER->LOAD = APU_FREQ/2/RT_TICK_PER_SECOND;
1000a1ec:	e3a03c06 	mov	r3, #1536	; 0x600
1000a1f0:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a1f4:	e3012615 	movw	r2, #5653	; 0x1615
1000a1f8:	e3402005 	movt	r2, #5
1000a1fc:	e5832000 	str	r2, [r3]
    PRIVATE_TIMER->CONTROL |= PRIVATE_TIMER_CONTROL_AUTO_RELOAD_MASK;
1000a200:	e3a03c06 	mov	r3, #1536	; 0x600
1000a204:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a208:	e3a02c06 	mov	r2, #1536	; 0x600
1000a20c:	e34f28f0 	movt	r2, #63728	; 0xf8f0
1000a210:	e5922008 	ldr	r2, [r2, #8]
1000a214:	e3822002 	orr	r2, r2, #2
1000a218:	e5832008 	str	r2, [r3, #8]

    PRIVATE_TIMER->CONTROL |= PRIVATE_TIMER_CONTROL_IRQ_ENABLE_MASK;
1000a21c:	e3a03c06 	mov	r3, #1536	; 0x600
1000a220:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a224:	e3a02c06 	mov	r2, #1536	; 0x600
1000a228:	e34f28f0 	movt	r2, #63728	; 0xf8f0
1000a22c:	e5922008 	ldr	r2, [r2, #8]
1000a230:	e3822004 	orr	r2, r2, #4
1000a234:	e5832008 	str	r2, [r3, #8]
    PRIVATE_TIMER->ISR = PRIVATE_TIMER_ISR_EVENT_FLAG_MASK;
1000a238:	e3a03c06 	mov	r3, #1536	; 0x600
1000a23c:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a240:	e3a02001 	mov	r2, #1
1000a244:	e583200c 	str	r2, [r3, #12]

    rt_hw_interrupt_install(IRQ_Zynq7000_PTIMER, rt_hw_timer_isr, RT_NULL, "tick");
1000a248:	e3a0001d 	mov	r0, #29
1000a24c:	e30a1154 	movw	r1, #41300	; 0xa154
1000a250:	e3411000 	movt	r1, #4096	; 0x1000
1000a254:	e3a02000 	mov	r2, #0
1000a258:	e30238dc 	movw	r3, #10460	; 0x28dc
1000a25c:	e3413003 	movt	r3, #4099	; 0x1003
1000a260:	eb003a61 	bl	10018bec <rt_hw_interrupt_install>
    rt_hw_interrupt_umask(IRQ_Zynq7000_PTIMER);
1000a264:	e3a0001d 	mov	r0, #29
1000a268:	eb003a56 	bl	10018bc8 <rt_hw_interrupt_umask>

    PRIVATE_TIMER->CONTROL |= PRIVATE_TIMER_CONTROL_ENABLE_MASK;
1000a26c:	e3a03c06 	mov	r3, #1536	; 0x600
1000a270:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000a274:	e3a02c06 	mov	r2, #1536	; 0x600
1000a278:	e34f28f0 	movt	r2, #63728	; 0xf8f0
1000a27c:	e5922008 	ldr	r2, [r2, #8]
1000a280:	e3822001 	orr	r2, r2, #1
1000a284:	e5832008 	str	r2, [r3, #8]

    return 0;
1000a288:	e3a03000 	mov	r3, #0
}
1000a28c:	e1a00003 	mov	r0, r3
1000a290:	e24bd004 	sub	sp, fp, #4
1000a294:	e8bd8800 	pop	{fp, pc}

1000a298 <rt_hw_board_init>:
INIT_BOARD_EXPORT(rt_hw_timer_init);

void rt_hw_board_init()
{
1000a298:	e92d4800 	push	{fp, lr}
1000a29c:	e28db004 	add	fp, sp, #4
    rt_components_board_init();
1000a2a0:	eb001086 	bl	1000e4c0 <rt_components_board_init>
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
1000a2a4:	e30208e4 	movw	r0, #10468	; 0x28e4
1000a2a8:	e3410003 	movt	r0, #4099	; 0x1003
1000a2ac:	eb0025d9 	bl	10013a18 <rt_console_set_device>
}
1000a2b0:	e8bd8800 	pop	{fp, pc}

1000a2b4 <motor_misc_intr>:
{
	Misc_HandleTypeDef motor_mischandle;

};
static void motor_misc_intr(int irqno, void *param)
{
1000a2b4:	e92d4800 	push	{fp, lr}
1000a2b8:	e28db004 	add	fp, sp, #4
1000a2bc:	e24dd018 	sub	sp, sp, #24
1000a2c0:	e50b0018 	str	r0, [fp, #-24]
1000a2c4:	e50b101c 	str	r1, [fp, #-28]
	
    struct hw_motor_misc_device *pdev = (struct hw_motor_misc_device *)param;
1000a2c8:	e51b301c 	ldr	r3, [fp, #-28]
1000a2cc:	e50b3008 	str	r3, [fp, #-8]
	unsigned long motor_miscvalue;
	rt_device_t device;
	
	device = rt_device_find("pwm1");
1000a2d0:	e30208ec 	movw	r0, #10476	; 0x28ec
1000a2d4:	e3410003 	movt	r0, #4099	; 0x1003
1000a2d8:	eb0010dd 	bl	1000e654 <rt_device_find>
1000a2dc:	e50b000c 	str	r0, [fp, #-12]
	rt_device_control(device,CMD_PWMDISABLE,NULL);
1000a2e0:	e51b000c 	ldr	r0, [fp, #-12]
1000a2e4:	e3a01002 	mov	r1, #2
1000a2e8:	e3a02000 	mov	r2, #0
1000a2ec:	eb00122f 	bl	1000ebb0 <rt_device_control>
	rt_device_close(device);
1000a2f0:	e51b000c 	ldr	r0, [fp, #-12]
1000a2f4:	eb0011a0 	bl	1000e97c <rt_device_close>
	
	device = rt_device_find("adc1");
1000a2f8:	e30208f4 	movw	r0, #10484	; 0x28f4
1000a2fc:	e3410003 	movt	r0, #4099	; 0x1003
1000a300:	eb0010d3 	bl	1000e654 <rt_device_find>
1000a304:	e50b000c 	str	r0, [fp, #-12]
	rt_device_close(device);
1000a308:	e51b000c 	ldr	r0, [fp, #-12]
1000a30c:	eb00119a 	bl	1000e97c <rt_device_close>
	
	device = rt_device_find("qep1");
1000a310:	e30208fc 	movw	r0, #10492	; 0x28fc
1000a314:	e3410003 	movt	r0, #4099	; 0x1003
1000a318:	eb0010cd 	bl	1000e654 <rt_device_find>
1000a31c:	e50b000c 	str	r0, [fp, #-12]
	rt_device_control(device,CMD_QEPDISABLE,NULL);
1000a320:	e51b000c 	ldr	r0, [fp, #-12]
1000a324:	e3a01002 	mov	r1, #2
1000a328:	e3a02000 	mov	r2, #0
1000a32c:	eb00121f 	bl	1000ebb0 <rt_device_control>
	rt_device_close(device);
1000a330:	e51b000c 	ldr	r0, [fp, #-12]
1000a334:	eb001190 	bl	1000e97c <rt_device_close>
	
	motor_miscvalue = pdev->motor_mischandle.Local_Instance->intr_state_reg;
1000a338:	e51b3008 	ldr	r3, [fp, #-8]
1000a33c:	e5933000 	ldr	r3, [r3]
1000a340:	e593300c 	ldr	r3, [r3, #12]
1000a344:	e50b3010 	str	r3, [fp, #-16]
	if((motor_miscvalue & TZ1_FAULT) == TZ1_FAULT)
1000a348:	e51b3010 	ldr	r3, [fp, #-16]
1000a34c:	e2033001 	and	r3, r3, #1
1000a350:	e3530000 	cmp	r3, #0
1000a354:	0a000002 	beq	1000a364 <motor_misc_intr+0xb0>
	{
		rt_kprintf("TZ1 fault\r\n");
1000a358:	e3020904 	movw	r0, #10500	; 0x2904
1000a35c:	e3410003 	movt	r0, #4099	; 0x1003
1000a360:	eb0025d6 	bl	10013ac0 <rt_kprintf>
	}
	if((motor_miscvalue & TZ2_FAULT) == TZ2_FAULT)
1000a364:	e51b3010 	ldr	r3, [fp, #-16]
1000a368:	e2033002 	and	r3, r3, #2
1000a36c:	e3530000 	cmp	r3, #0
1000a370:	0a000002 	beq	1000a380 <motor_misc_intr+0xcc>
	{
		rt_kprintf("TZ2 fault\r\n");
1000a374:	e3020910 	movw	r0, #10512	; 0x2910
1000a378:	e3410003 	movt	r0, #4099	; 0x1003
1000a37c:	eb0025cf 	bl	10013ac0 <rt_kprintf>
	}
	if((motor_miscvalue & VOE_FAULT) == VOE_FAULT)
1000a380:	e51b3010 	ldr	r3, [fp, #-16]
1000a384:	e2033004 	and	r3, r3, #4
1000a388:	e3530000 	cmp	r3, #0
1000a38c:	0a000002 	beq	1000a39c <motor_misc_intr+0xe8>
	{
		rt_kprintf("VOE fault\r\n");
1000a390:	e302091c 	movw	r0, #10524	; 0x291c
1000a394:	e3410003 	movt	r0, #4099	; 0x1003
1000a398:	eb0025c8 	bl	10013ac0 <rt_kprintf>
	}
	if((motor_miscvalue & SC_FAULT) == SC_FAULT)
1000a39c:	e51b3010 	ldr	r3, [fp, #-16]
1000a3a0:	e2033008 	and	r3, r3, #8
1000a3a4:	e3530000 	cmp	r3, #0
1000a3a8:	0a000002 	beq	1000a3b8 <motor_misc_intr+0x104>
	{
		rt_kprintf("SC fault\r\n");
1000a3ac:	e3020928 	movw	r0, #10536	; 0x2928
1000a3b0:	e3410003 	movt	r0, #4099	; 0x1003
1000a3b4:	eb0025c1 	bl	10013ac0 <rt_kprintf>
	}
	if((motor_miscvalue & EA_FAULT) == EA_FAULT)
1000a3b8:	e51b3010 	ldr	r3, [fp, #-16]
1000a3bc:	e2033010 	and	r3, r3, #16
1000a3c0:	e3530000 	cmp	r3, #0
1000a3c4:	0a000002 	beq	1000a3d4 <motor_misc_intr+0x120>
	{
		rt_kprintf("EA fault\r\n");
1000a3c8:	e3020934 	movw	r0, #10548	; 0x2934
1000a3cc:	e3410003 	movt	r0, #4099	; 0x1003
1000a3d0:	eb0025ba 	bl	10013ac0 <rt_kprintf>
	}
	if((motor_miscvalue & EB_FAULT) == EB_FAULT)
1000a3d4:	e51b3010 	ldr	r3, [fp, #-16]
1000a3d8:	e2033020 	and	r3, r3, #32
1000a3dc:	e3530000 	cmp	r3, #0
1000a3e0:	0a000002 	beq	1000a3f0 <motor_misc_intr+0x13c>
	{
		rt_kprintf("EB fault\r\n");
1000a3e4:	e3020940 	movw	r0, #10560	; 0x2940
1000a3e8:	e3410003 	movt	r0, #4099	; 0x1003
1000a3ec:	eb0025b3 	bl	10013ac0 <rt_kprintf>
	}
	
	device = rt_device_find("motor_misc1");
1000a3f0:	e302094c 	movw	r0, #10572	; 0x294c
1000a3f4:	e3410003 	movt	r0, #4099	; 0x1003
1000a3f8:	eb001095 	bl	1000e654 <rt_device_find>
1000a3fc:	e50b000c 	str	r0, [fp, #-12]
	rt_device_control(device,CMD_MISC_CLR_RLY,NULL);
1000a400:	e51b000c 	ldr	r0, [fp, #-12]
1000a404:	e3a0100a 	mov	r1, #10
1000a408:	e3a02000 	mov	r2, #0
1000a40c:	eb0011e7 	bl	1000ebb0 <rt_device_control>
	rt_device_control(device,CMD_MISC_INTDISABLE,NULL);
1000a410:	e51b000c 	ldr	r0, [fp, #-12]
1000a414:	e3a01002 	mov	r1, #2
1000a418:	e3a02000 	mov	r2, #0
1000a41c:	eb0011e3 	bl	1000ebb0 <rt_device_control>
	rt_device_close(device);
1000a420:	e51b000c 	ldr	r0, [fp, #-12]
1000a424:	eb001154 	bl	1000e97c <rt_device_close>
	
    rt_kprintf("shutdown...\n");
1000a428:	e3020958 	movw	r0, #10584	; 0x2958
1000a42c:	e3410003 	movt	r0, #4099	; 0x1003
1000a430:	eb0025a2 	bl	10013ac0 <rt_kprintf>
    rt_hw_interrupt_disable();
1000a434:	eb003c7d 	bl	10019630 <rt_hw_interrupt_disable>
	pdev->motor_mischandle.Local_Instance->intr_ctrl_reg.clr_flag = 1;
1000a438:	e51b3008 	ldr	r3, [fp, #-8]
1000a43c:	e5933000 	ldr	r3, [r3]
1000a440:	e5932010 	ldr	r2, [r3, #16]
1000a444:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
1000a448:	e5832010 	str	r2, [r3, #16]
	while(1);
1000a44c:	eafffffe 	b	1000a44c <motor_misc_intr+0x198>

1000a450 <motor_misc_configure>:
}



static rt_err_t motor_misc_configure(struct rt_motor_misc_device *motor_miscdev, struct motor_misc_configure *cfg)
{
1000a450:	e92d4800 	push	{fp, lr}
1000a454:	e28db004 	add	fp, sp, #4
1000a458:	e24dd010 	sub	sp, sp, #16
1000a45c:	e50b0010 	str	r0, [fp, #-16]
1000a460:	e50b1014 	str	r1, [fp, #-20]
	struct hw_motor_misc_device *pdev;

	
    RT_ASSERT(motor_miscdev != RT_NULL);
1000a464:	e51b3010 	ldr	r3, [fp, #-16]
1000a468:	e3530000 	cmp	r3, #0
1000a46c:	1a000005 	bne	1000a488 <motor_misc_configure+0x38>
1000a470:	e3020968 	movw	r0, #10600	; 0x2968
1000a474:	e3410003 	movt	r0, #4099	; 0x1003
1000a478:	e30219d8 	movw	r1, #10712	; 0x29d8
1000a47c:	e3411003 	movt	r1, #4099	; 0x1003
1000a480:	e3a02059 	mov	r2, #89	; 0x59
1000a484:	eb00264a 	bl	10013db4 <rt_assert_handler>
	pdev = motor_miscdev->parent.user_data;
1000a488:	e51b3010 	ldr	r3, [fp, #-16]
1000a48c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000a490:	e50b3008 	str	r3, [fp, #-8]

	
	pdev->motor_mischandle.Local_Instance->break_duty_reg = motor_miscdev->config.breakduty;
1000a494:	e51b3008 	ldr	r3, [fp, #-8]
1000a498:	e5933000 	ldr	r3, [r3]
1000a49c:	e51b2010 	ldr	r2, [fp, #-16]
1000a4a0:	e5922044 	ldr	r2, [r2, #68]	; 0x44
1000a4a4:	e5832004 	str	r2, [r3, #4]
	pdev->motor_mischandle.Local_Instance->fan_duty_reg = motor_miscdev->config.fanduty;
1000a4a8:	e51b3008 	ldr	r3, [fp, #-8]
1000a4ac:	e5933000 	ldr	r3, [r3]
1000a4b0:	e51b2010 	ldr	r2, [fp, #-16]
1000a4b4:	e5922048 	ldr	r2, [r2, #72]	; 0x48
1000a4b8:	e5832008 	str	r2, [r3, #8]
	pdev->motor_mischandle.Local_Instance->intr_ctrl_reg.clr_flag = motor_miscdev->config.clrflag;
1000a4bc:	e51b3008 	ldr	r3, [fp, #-8]
1000a4c0:	e5933000 	ldr	r3, [r3]
1000a4c4:	e51b2010 	ldr	r2, [fp, #-16]
1000a4c8:	e5d22042 	ldrb	r2, [r2, #66]	; 0x42
1000a4cc:	e6ef2072 	uxtb	r2, r2
1000a4d0:	e1a02382 	lsl	r2, r2, #7
1000a4d4:	e6af2072 	sxtb	r2, r2
1000a4d8:	e1a023c2 	asr	r2, r2, #7
1000a4dc:	e6ef2072 	uxtb	r2, r2
1000a4e0:	e1a02f82 	lsl	r2, r2, #31
1000a4e4:	e5931010 	ldr	r1, [r3, #16]
1000a4e8:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
1000a4ec:	e1812002 	orr	r2, r1, r2
1000a4f0:	e5832010 	str	r2, [r3, #16]
	pdev->motor_mischandle.Local_Instance->pwm_ctrl_reg.break_en = motor_miscdev->config.pwmen;
1000a4f4:	e51b3008 	ldr	r3, [fp, #-8]
1000a4f8:	e5933000 	ldr	r3, [r3]
1000a4fc:	e51b2010 	ldr	r2, [fp, #-16]
1000a500:	e5d22040 	ldrb	r2, [r2, #64]	; 0x40
1000a504:	e6ef2072 	uxtb	r2, r2
1000a508:	e1a02382 	lsl	r2, r2, #7
1000a50c:	e6af2072 	sxtb	r2, r2
1000a510:	e1a023c2 	asr	r2, r2, #7
1000a514:	e6ef2072 	uxtb	r2, r2
1000a518:	e2022001 	and	r2, r2, #1
1000a51c:	e5931000 	ldr	r1, [r3]
1000a520:	e3c11001 	bic	r1, r1, #1
1000a524:	e1812002 	orr	r2, r1, r2
1000a528:	e5832000 	str	r2, [r3]
	pdev->motor_mischandle.Local_Instance->pwm_ctrl_reg.fan_en = motor_miscdev->config.fanen;
1000a52c:	e51b3008 	ldr	r3, [fp, #-8]
1000a530:	e5933000 	ldr	r3, [r3]
1000a534:	e51b2010 	ldr	r2, [fp, #-16]
1000a538:	e5d22041 	ldrb	r2, [r2, #65]	; 0x41
1000a53c:	e6ef2072 	uxtb	r2, r2
1000a540:	e1a02382 	lsl	r2, r2, #7
1000a544:	e6af2072 	sxtb	r2, r2
1000a548:	e1a023c2 	asr	r2, r2, #7
1000a54c:	e6ef2072 	uxtb	r2, r2
1000a550:	e2022001 	and	r2, r2, #1
1000a554:	e1a02082 	lsl	r2, r2, #1
1000a558:	e5931000 	ldr	r1, [r3]
1000a55c:	e3c11002 	bic	r1, r1, #2
1000a560:	e1812002 	orr	r2, r1, r2
1000a564:	e5832000 	str	r2, [r3]
	
	rt_kprintf("motor_misc init complete\r\n");
1000a568:	e3020984 	movw	r0, #10628	; 0x2984
1000a56c:	e3410003 	movt	r0, #4099	; 0x1003
1000a570:	eb002552 	bl	10013ac0 <rt_kprintf>
	
    return RT_EOK;
1000a574:	e3a03000 	mov	r3, #0
}
1000a578:	e1a00003 	mov	r0, r3
1000a57c:	e24bd004 	sub	sp, fp, #4
1000a580:	e8bd8800 	pop	{fp, pc}

1000a584 <motor_misc_delay_us>:

static void motor_misc_delay_us(unsigned int us)
{
1000a584:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000a588:	e28db000 	add	fp, sp, #0
1000a58c:	e24dd014 	sub	sp, sp, #20
1000a590:	e50b0010 	str	r0, [fp, #-16]
    volatile unsigned int len;
    for (; us > 0; us --)
1000a594:	ea00000b 	b	1000a5c8 <motor_misc_delay_us+0x44>
        for (len = 0; len < 20; len++ );
1000a598:	e3a03000 	mov	r3, #0
1000a59c:	e50b3008 	str	r3, [fp, #-8]
1000a5a0:	ea000002 	b	1000a5b0 <motor_misc_delay_us+0x2c>
1000a5a4:	e51b3008 	ldr	r3, [fp, #-8]
1000a5a8:	e2833001 	add	r3, r3, #1
1000a5ac:	e50b3008 	str	r3, [fp, #-8]
1000a5b0:	e51b3008 	ldr	r3, [fp, #-8]
1000a5b4:	e3530013 	cmp	r3, #19
1000a5b8:	9afffff9 	bls	1000a5a4 <motor_misc_delay_us+0x20>
}

static void motor_misc_delay_us(unsigned int us)
{
    volatile unsigned int len;
    for (; us > 0; us --)
1000a5bc:	e51b3010 	ldr	r3, [fp, #-16]
1000a5c0:	e2433001 	sub	r3, r3, #1
1000a5c4:	e50b3010 	str	r3, [fp, #-16]
1000a5c8:	e51b3010 	ldr	r3, [fp, #-16]
1000a5cc:	e3530000 	cmp	r3, #0
1000a5d0:	1afffff0 	bne	1000a598 <motor_misc_delay_us+0x14>
        for (len = 0; len < 20; len++ );
}
1000a5d4:	e24bd000 	sub	sp, fp, #0
1000a5d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000a5dc:	e12fff1e 	bx	lr

1000a5e0 <motor_misc_control>:

static rt_err_t motor_misc_control(struct rt_motor_misc_device *motor_miscdev, int cmd, void *arg)
{
1000a5e0:	e92d4810 	push	{r4, fp, lr}
1000a5e4:	e28db008 	add	fp, sp, #8
1000a5e8:	e24dd024 	sub	sp, sp, #36	; 0x24
1000a5ec:	e50b0020 	str	r0, [fp, #-32]
1000a5f0:	e50b1024 	str	r1, [fp, #-36]	; 0x24
1000a5f4:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    struct hw_motor_misc_device *pdev;
	unsigned int *temp;
	unsigned long motor_miscvalue;

    RT_ASSERT(motor_miscdev != RT_NULL);
1000a5f8:	e51b3020 	ldr	r3, [fp, #-32]
1000a5fc:	e3530000 	cmp	r3, #0
1000a600:	1a000005 	bne	1000a61c <motor_misc_control+0x3c>
1000a604:	e3020968 	movw	r0, #10600	; 0x2968
1000a608:	e3410003 	movt	r0, #4099	; 0x1003
1000a60c:	e30219f0 	movw	r1, #10736	; 0x29f0
1000a610:	e3411003 	movt	r1, #4099	; 0x1003
1000a614:	e3a02075 	mov	r2, #117	; 0x75
1000a618:	eb0025e5 	bl	10013db4 <rt_assert_handler>

    pdev = motor_miscdev->parent.user_data;
1000a61c:	e51b3020 	ldr	r3, [fp, #-32]
1000a620:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000a624:	e50b3010 	str	r3, [fp, #-16]

    switch (cmd)
1000a628:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000a62c:	e2433001 	sub	r3, r3, #1
1000a630:	e3530009 	cmp	r3, #9
1000a634:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1000a638:	ea000089 	b	1000a864 <motor_misc_control+0x284>
1000a63c:	1000a67c 	.word	0x1000a67c
1000a640:	1000a664 	.word	0x1000a664
1000a644:	1000a734 	.word	0x1000a734
1000a648:	1000a754 	.word	0x1000a754
1000a64c:	1000a774 	.word	0x1000a774
1000a650:	1000a7b8 	.word	0x1000a7b8
1000a654:	1000a864 	.word	0x1000a864
1000a658:	1000a800 	.word	0x1000a800
1000a65c:	1000a834 	.word	0x1000a834
1000a660:	1000a84c 	.word	0x1000a84c
    {
	case CMD_MISC_INTDISABLE:
		//rt_hw_interrupt_mask(pdev->motor_mischandle.irq_nr);
		
		pdev->motor_mischandle.Local_Instance->intr_ctrl_reg.clr_flag = 1;
1000a664:	e51b3010 	ldr	r3, [fp, #-16]
1000a668:	e5933000 	ldr	r3, [r3]
1000a66c:	e5932010 	ldr	r2, [r3, #16]
1000a670:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
1000a674:	e5832010 	str	r2, [r3, #16]

		break;
1000a678:	ea00007a 	b	1000a868 <motor_misc_control+0x288>
	case CMD_MISC_INTENABLE:
		rt_hw_interrupt_mask(pdev->motor_mischandle.irq_nr);
1000a67c:	e51b3010 	ldr	r3, [fp, #-16]
1000a680:	e5d33004 	ldrb	r3, [r3, #4]
1000a684:	e1a00003 	mov	r0, r3
1000a688:	eb003945 	bl	10018ba4 <rt_hw_interrupt_mask>
		pdev->motor_mischandle.Local_Instance->intr_ctrl_reg.clr_flag = 0;
1000a68c:	e51b3010 	ldr	r3, [fp, #-16]
1000a690:	e5933000 	ldr	r3, [r3]
1000a694:	e5932010 	ldr	r2, [r3, #16]
1000a698:	e3c22102 	bic	r2, r2, #-2147483648	; 0x80000000
1000a69c:	e5832010 	str	r2, [r3, #16]
		
		motor_miscvalue = pdev->motor_mischandle.Local_Instance->intr_state_reg;
1000a6a0:	e51b3010 	ldr	r3, [fp, #-16]
1000a6a4:	e5933000 	ldr	r3, [r3]
1000a6a8:	e593300c 	ldr	r3, [r3, #12]
1000a6ac:	e50b3014 	str	r3, [fp, #-20]
		rt_kprintf("isrstate: %x\r\n",motor_miscvalue);
1000a6b0:	e30209a0 	movw	r0, #10656	; 0x29a0
1000a6b4:	e3410003 	movt	r0, #4099	; 0x1003
1000a6b8:	e51b1014 	ldr	r1, [fp, #-20]
1000a6bc:	eb0024ff 	bl	10013ac0 <rt_kprintf>
		rt_hw_interrupt_clear(pdev->motor_mischandle.irq_nr);
1000a6c0:	e51b3010 	ldr	r3, [fp, #-16]
1000a6c4:	e5d33004 	ldrb	r3, [r3, #4]
1000a6c8:	e1a00003 	mov	r0, r3
1000a6cc:	eb003989 	bl	10018cf8 <rt_hw_interrupt_clear>
		rt_hw_interrupt_install(pdev->motor_mischandle.irq_nr,motor_misc_intr,pdev, "motor_misc_intr");
1000a6d0:	e51b3010 	ldr	r3, [fp, #-16]
1000a6d4:	e5d33004 	ldrb	r3, [r3, #4]
1000a6d8:	e1a00003 	mov	r0, r3
1000a6dc:	e30a12b4 	movw	r1, #41652	; 0xa2b4
1000a6e0:	e3411000 	movt	r1, #4096	; 0x1000
1000a6e4:	e51b2010 	ldr	r2, [fp, #-16]
1000a6e8:	e30239b0 	movw	r3, #10672	; 0x29b0
1000a6ec:	e3413003 	movt	r3, #4099	; 0x1003
1000a6f0:	eb00393d 	bl	10018bec <rt_hw_interrupt_install>
		
		arm_gic_set_cpu(0, pdev->motor_mischandle.irq_nr, 1 << rt_cpu_get_smp_id());
1000a6f4:	e51b3010 	ldr	r3, [fp, #-16]
1000a6f8:	e5d33004 	ldrb	r3, [r3, #4]
1000a6fc:	e1a04003 	mov	r4, r3
1000a700:	eb003bf0 	bl	100196c8 <rt_cpu_get_smp_id>
1000a704:	e1a02000 	mov	r2, r0
1000a708:	e3a03001 	mov	r3, #1
1000a70c:	e1a03213 	lsl	r3, r3, r2
1000a710:	e3a00000 	mov	r0, #0
1000a714:	e1a01004 	mov	r1, r4
1000a718:	e1a02003 	mov	r2, r3
1000a71c:	eb003678 	bl	10018104 <arm_gic_set_cpu>
		rt_hw_interrupt_umask(pdev->motor_mischandle.irq_nr);
1000a720:	e51b3010 	ldr	r3, [fp, #-16]
1000a724:	e5d33004 	ldrb	r3, [r3, #4]
1000a728:	e1a00003 	mov	r0, r3
1000a72c:	eb003925 	bl	10018bc8 <rt_hw_interrupt_umask>
		

		break;
1000a730:	ea00004c 	b	1000a868 <motor_misc_control+0x288>

	case CMD_MISC_SET_BREAK_DUTY:

		temp = arg;
1000a734:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000a738:	e50b3018 	str	r3, [fp, #-24]
		pdev->motor_mischandle.Local_Instance->break_duty_reg = *temp;
1000a73c:	e51b3010 	ldr	r3, [fp, #-16]
1000a740:	e5933000 	ldr	r3, [r3]
1000a744:	e51b2018 	ldr	r2, [fp, #-24]
1000a748:	e5922000 	ldr	r2, [r2]
1000a74c:	e5832004 	str	r2, [r3, #4]

		break;
1000a750:	ea000044 	b	1000a868 <motor_misc_control+0x288>

	case CMD_MISC_SET_FAN_DUTY: 
		temp = arg;
1000a754:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000a758:	e50b3018 	str	r3, [fp, #-24]
		pdev->motor_mischandle.Local_Instance->fan_duty_reg = *temp;
1000a75c:	e51b3010 	ldr	r3, [fp, #-16]
1000a760:	e5933000 	ldr	r3, [r3]
1000a764:	e51b2018 	ldr	r2, [fp, #-24]
1000a768:	e5922000 	ldr	r2, [r2]
1000a76c:	e5832008 	str	r2, [r3, #8]
		break;
1000a770:	ea00003c 	b	1000a868 <motor_misc_control+0x288>

	case CMD_MISC_BREAKEN: 
		temp = arg;
1000a774:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000a778:	e50b3018 	str	r3, [fp, #-24]
		pdev->motor_mischandle.Local_Instance->pwm_ctrl_reg.break_en = *temp;
1000a77c:	e51b3010 	ldr	r3, [fp, #-16]
1000a780:	e5933000 	ldr	r3, [r3]
1000a784:	e51b2018 	ldr	r2, [fp, #-24]
1000a788:	e5922000 	ldr	r2, [r2]
1000a78c:	e6ef2072 	uxtb	r2, r2
1000a790:	e1a02382 	lsl	r2, r2, #7
1000a794:	e6af2072 	sxtb	r2, r2
1000a798:	e1a023c2 	asr	r2, r2, #7
1000a79c:	e6ef2072 	uxtb	r2, r2
1000a7a0:	e2022001 	and	r2, r2, #1
1000a7a4:	e5931000 	ldr	r1, [r3]
1000a7a8:	e3c11001 	bic	r1, r1, #1
1000a7ac:	e1812002 	orr	r2, r1, r2
1000a7b0:	e5832000 	str	r2, [r3]
		break;
1000a7b4:	ea00002b 	b	1000a868 <motor_misc_control+0x288>

	case CMD_MISC_FANEN:
		temp = arg;
1000a7b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000a7bc:	e50b3018 	str	r3, [fp, #-24]
		pdev->motor_mischandle.Local_Instance->pwm_ctrl_reg.fan_en = *temp;
1000a7c0:	e51b3010 	ldr	r3, [fp, #-16]
1000a7c4:	e5933000 	ldr	r3, [r3]
1000a7c8:	e51b2018 	ldr	r2, [fp, #-24]
1000a7cc:	e5922000 	ldr	r2, [r2]
1000a7d0:	e6ef2072 	uxtb	r2, r2
1000a7d4:	e1a02382 	lsl	r2, r2, #7
1000a7d8:	e6af2072 	sxtb	r2, r2
1000a7dc:	e1a023c2 	asr	r2, r2, #7
1000a7e0:	e6ef2072 	uxtb	r2, r2
1000a7e4:	e2022001 	and	r2, r2, #1
1000a7e8:	e1a02082 	lsl	r2, r2, #1
1000a7ec:	e5931000 	ldr	r1, [r3]
1000a7f0:	e3c11002 	bic	r1, r1, #2
1000a7f4:	e1812002 	orr	r2, r1, r2
1000a7f8:	e5832000 	str	r2, [r3]
		break;
1000a7fc:	ea000019 	b	1000a868 <motor_misc_control+0x288>

	case CMD_MISC_CLR_FLAG:
		pdev->motor_mischandle.Local_Instance->intr_ctrl_reg.clr_flag = 1;
1000a800:	e51b3010 	ldr	r3, [fp, #-16]
1000a804:	e5933000 	ldr	r3, [r3]
1000a808:	e5932010 	ldr	r2, [r3, #16]
1000a80c:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
1000a810:	e5832010 	str	r2, [r3, #16]
		motor_misc_delay_us(1);
1000a814:	e3a00001 	mov	r0, #1
1000a818:	ebffff59 	bl	1000a584 <motor_misc_delay_us>
		pdev->motor_mischandle.Local_Instance->intr_ctrl_reg.clr_flag = 0;
1000a81c:	e51b3010 	ldr	r3, [fp, #-16]
1000a820:	e5933000 	ldr	r3, [r3]
1000a824:	e5932010 	ldr	r2, [r3, #16]
1000a828:	e3c22102 	bic	r2, r2, #-2147483648	; 0x80000000
1000a82c:	e5832010 	str	r2, [r3, #16]
		break;
1000a830:	ea00000c 	b	1000a868 <motor_misc_control+0x288>
	case CMD_MISC_SET_RLY:
		pdev->motor_mischandle.Local_Instance->pwm_ctrl_reg.RLY = 1;
1000a834:	e51b3010 	ldr	r3, [fp, #-16]
1000a838:	e5933000 	ldr	r3, [r3]
1000a83c:	e5932000 	ldr	r2, [r3]
1000a840:	e3822004 	orr	r2, r2, #4
1000a844:	e5832000 	str	r2, [r3]
		break;
1000a848:	ea000006 	b	1000a868 <motor_misc_control+0x288>
	case CMD_MISC_CLR_RLY:
		pdev->motor_mischandle.Local_Instance->pwm_ctrl_reg.RLY = 0;
1000a84c:	e51b3010 	ldr	r3, [fp, #-16]
1000a850:	e5933000 	ldr	r3, [r3]
1000a854:	e5932000 	ldr	r2, [r3]
1000a858:	e3c22004 	bic	r2, r2, #4
1000a85c:	e5832000 	str	r2, [r3]
		break;
1000a860:	ea000000 	b	1000a868 <motor_misc_control+0x288>
	default: 
			break;
1000a864:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
1000a868:	e3a03000 	mov	r3, #0
}
1000a86c:	e1a00003 	mov	r0, r3
1000a870:	e24bd008 	sub	sp, fp, #8
1000a874:	e8bd8810 	pop	{r4, fp, pc}

1000a878 <motor_misc_getState>:
**VDC,TEMP = VIN
*/


static unsigned long motor_misc_getState(struct rt_motor_misc_device *motor_miscdev)
{
1000a878:	e92d4800 	push	{fp, lr}
1000a87c:	e28db004 	add	fp, sp, #4
1000a880:	e24dd010 	sub	sp, sp, #16
1000a884:	e50b0010 	str	r0, [fp, #-16]
    struct hw_motor_misc_device *pdev;
	unsigned long motor_miscvalue;


    RT_ASSERT(motor_miscdev != RT_NULL);
1000a888:	e51b3010 	ldr	r3, [fp, #-16]
1000a88c:	e3530000 	cmp	r3, #0
1000a890:	1a000005 	bne	1000a8ac <motor_misc_getState+0x34>
1000a894:	e3020968 	movw	r0, #10600	; 0x2968
1000a898:	e3410003 	movt	r0, #4099	; 0x1003
1000a89c:	e3021a04 	movw	r1, #10756	; 0x2a04
1000a8a0:	e3411003 	movt	r1, #4099	; 0x1003
1000a8a4:	e3a020c5 	mov	r2, #197	; 0xc5
1000a8a8:	eb002541 	bl	10013db4 <rt_assert_handler>

    pdev = motor_miscdev->parent.user_data;
1000a8ac:	e51b3010 	ldr	r3, [fp, #-16]
1000a8b0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000a8b4:	e50b3008 	str	r3, [fp, #-8]


	motor_miscvalue = pdev->motor_mischandle.Local_Instance->intr_state_reg;
1000a8b8:	e51b3008 	ldr	r3, [fp, #-8]
1000a8bc:	e5933000 	ldr	r3, [r3]
1000a8c0:	e593300c 	ldr	r3, [r3, #12]
1000a8c4:	e50b300c 	str	r3, [fp, #-12]
	

	return motor_miscvalue;
1000a8c8:	e51b300c 	ldr	r3, [fp, #-12]
}
1000a8cc:	e1a00003 	mov	r0, r3
1000a8d0:	e24bd004 	sub	sp, fp, #4
1000a8d4:	e8bd8800 	pop	{fp, pc}

1000a8d8 <motor_misc_hw_init>:
    motor_misc_getState,
};


int motor_misc_hw_init(void)
{
1000a8d8:	e92d4800 	push	{fp, lr}
1000a8dc:	e28db004 	add	fp, sp, #4
1000a8e0:	e24dd010 	sub	sp, sp, #16

	struct motor_misc_configure motor_misc_config = RT_MISC_CONFIG_DEFAULT;
1000a8e4:	e30239cc 	movw	r3, #10700	; 0x29cc
1000a8e8:	e3413003 	movt	r3, #4099	; 0x1003
1000a8ec:	e24bc010 	sub	ip, fp, #16
1000a8f0:	e8930007 	ldm	r3, {r0, r1, r2}
1000a8f4:	e88c0007 	stm	ip, {r0, r1, r2}
	motor_misc_device1.config = motor_misc_config;
1000a8f8:	e30237fc 	movw	r3, #10236	; 0x27fc
1000a8fc:	e3413004 	movt	r3, #4100	; 0x1004
1000a900:	e2833040 	add	r3, r3, #64	; 0x40
1000a904:	e24b2010 	sub	r2, fp, #16
1000a908:	e8920007 	ldm	r2, {r0, r1, r2}
1000a90c:	e8830007 	stm	r3, {r0, r1, r2}
	motor_misc_device1.ops = &_motor_misc_ops;
1000a910:	e30237fc 	movw	r3, #10236	; 0x27fc
1000a914:	e3413004 	movt	r3, #4100	; 0x1004
1000a918:	e30229c0 	movw	r2, #10688	; 0x29c0
1000a91c:	e3412003 	movt	r2, #4099	; 0x1003
1000a920:	e583203c 	str	r2, [r3, #60]	; 0x3c
	
	motor_misc_handle.Local_Instance = MOTOR_MISC_LOCAL_BASEADDR;
1000a924:	e30227ec 	movw	r2, #10220	; 0x27ec
1000a928:	e3412004 	movt	r2, #4100	; 0x1004
1000a92c:	e3a03000 	mov	r3, #0
1000a930:	e34433c4 	movt	r3, #17348	; 0x43c4
1000a934:	e5823000 	str	r3, [r2]
	motor_misc_handle.irq_nr = CPU1_IRQF2P0_ID;
1000a938:	e30237ec 	movw	r3, #10220	; 0x27ec
1000a93c:	e3413004 	movt	r3, #4100	; 0x1004
1000a940:	e3a0203d 	mov	r2, #61	; 0x3d
1000a944:	e5c32004 	strb	r2, [r3, #4]

	motor_misc_hw_device1.motor_mischandle= motor_misc_handle;
1000a948:	e30227f4 	movw	r2, #10228	; 0x27f4
1000a94c:	e3412004 	movt	r2, #4100	; 0x1004
1000a950:	e30237ec 	movw	r3, #10220	; 0x27ec
1000a954:	e3413004 	movt	r3, #4100	; 0x1004
1000a958:	e8930003 	ldm	r3, {r0, r1}
1000a95c:	e8820003 	stm	r2, {r0, r1}

	rt_hw_motor_misc_register(&motor_misc_device1, "motor_misc1",
1000a960:	e30207fc 	movw	r0, #10236	; 0x27fc
1000a964:	e3410004 	movt	r0, #4100	; 0x1004
1000a968:	e302194c 	movw	r1, #10572	; 0x294c
1000a96c:	e3411003 	movt	r1, #4099	; 0x1003
1000a970:	e3a02001 	mov	r2, #1
1000a974:	e30237f4 	movw	r3, #10228	; 0x27f4
1000a978:	e3413004 	movt	r3, #4100	; 0x1004
1000a97c:	eb000351 	bl	1000b6c8 <rt_hw_motor_misc_register>
                          RT_DEVICE_FLAG_RDONLY,
                          &motor_misc_hw_device1);

	return 0;
1000a980:	e3a03000 	mov	r3, #0

}
1000a984:	e1a00003 	mov	r0, r3
1000a988:	e24bd004 	sub	sp, fp, #4
1000a98c:	e8bd8800 	pop	{fp, pc}

1000a990 <PWMOutputsEnable>:
	PWM_HandleTypeDef pwm;

};

static void PWMOutputsEnable(PWM_HandleTypeDef *pwm)
{
1000a990:	e92d4800 	push	{fp, lr}
1000a994:	e28db004 	add	fp, sp, #4
1000a998:	e24dd008 	sub	sp, sp, #8
1000a99c:	e50b0008 	str	r0, [fp, #-8]
	while(PWMEnable(pwm) != MYIP_SUCCESS);
1000a9a0:	e1a00000 	nop			; (mov r0, r0)
1000a9a4:	e51b0008 	ldr	r0, [fp, #-8]
1000a9a8:	ebfff7e5 	bl	10008944 <PWMEnable>
1000a9ac:	e1a03000 	mov	r3, r0
1000a9b0:	e3530001 	cmp	r3, #1
1000a9b4:	1afffffa 	bne	1000a9a4 <PWMOutputsEnable+0x14>
}
1000a9b8:	e24bd004 	sub	sp, fp, #4
1000a9bc:	e8bd8800 	pop	{fp, pc}

1000a9c0 <PWMOutputsDisable>:

static void PWMOutputsDisable(PWM_HandleTypeDef *pwm)
{
1000a9c0:	e92d4800 	push	{fp, lr}
1000a9c4:	e28db004 	add	fp, sp, #4
1000a9c8:	e24dd008 	sub	sp, sp, #8
1000a9cc:	e50b0008 	str	r0, [fp, #-8]
	while(PWMDisable(pwm)!= MYIP_SUCCESS);
1000a9d0:	e1a00000 	nop			; (mov r0, r0)
1000a9d4:	e51b0008 	ldr	r0, [fp, #-8]
1000a9d8:	ebfff872 	bl	10008ba8 <PWMDisable>
1000a9dc:	e1a03000 	mov	r3, r0
1000a9e0:	e3530001 	cmp	r3, #1
1000a9e4:	1afffffa 	bne	1000a9d4 <PWMOutputsDisable+0x14>

}
1000a9e8:	e24bd004 	sub	sp, fp, #4
1000a9ec:	e8bd8800 	pop	{fp, pc}

1000a9f0 <SetDutyCycles>:

static void SetDutyCycles(PWM_HandleTypeDef *pwm, duty_HandleTypeDef *duty)
{
1000a9f0:	e92d4800 	push	{fp, lr}
1000a9f4:	e28db004 	add	fp, sp, #4
1000a9f8:	e24dd008 	sub	sp, sp, #8
1000a9fc:	e50b0008 	str	r0, [fp, #-8]
1000aa00:	e50b100c 	str	r1, [fp, #-12]
	while(PWMSetduty(pwm,duty)!= MYIP_SUCCESS);
1000aa04:	e1a00000 	nop			; (mov r0, r0)
1000aa08:	e51b0008 	ldr	r0, [fp, #-8]
1000aa0c:	e51b100c 	ldr	r1, [fp, #-12]
1000aa10:	ebfff7ec 	bl	100089c8 <PWMSetduty>
1000aa14:	e1a03000 	mov	r3, r0
1000aa18:	e3530001 	cmp	r3, #1
1000aa1c:	1afffff9 	bne	1000aa08 <SetDutyCycles+0x18>
}
1000aa20:	e24bd004 	sub	sp, fp, #4
1000aa24:	e8bd8800 	pop	{fp, pc}

1000aa28 <pwm_configure>:

static rt_err_t pwm_configure(struct rt_pwm_device *pwmdev, struct pwm_configure *cfg)
{
1000aa28:	e92d4800 	push	{fp, lr}
1000aa2c:	e28db004 	add	fp, sp, #4
1000aa30:	e24dd018 	sub	sp, sp, #24
1000aa34:	e50b0010 	str	r0, [fp, #-16]
1000aa38:	e50b1014 	str	r1, [fp, #-20]
	uint32_t mr;
	struct hw_pwm_device *pdev = pwmdev->parent.user_data;
1000aa3c:	e51b3010 	ldr	r3, [fp, #-16]
1000aa40:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000aa44:	e50b3008 	str	r3, [fp, #-8]
	
	pdev->pwm.state = MYIP_STATE_RESET;
1000aa48:	e51b3008 	ldr	r3, [fp, #-8]
1000aa4c:	e3a02000 	mov	r2, #0
1000aa50:	e5c32018 	strb	r2, [r3, #24]
	pdev->pwm.Init.clk = cfg->clk_hz;
1000aa54:	e51b3014 	ldr	r3, [fp, #-20]
1000aa58:	e5932000 	ldr	r2, [r3]
1000aa5c:	e51b3008 	ldr	r3, [fp, #-8]
1000aa60:	e5832010 	str	r2, [r3, #16]
	pdev->pwm.Init.dead_ns = cfg->deadzone_ns;
1000aa64:	e51b3014 	ldr	r3, [fp, #-20]
1000aa68:	e5932004 	ldr	r2, [r3, #4]
1000aa6c:	e51b3008 	ldr	r3, [fp, #-8]
1000aa70:	e583200c 	str	r2, [r3, #12]
	pdev->pwm.Init.pwmduty.pwm0_duty = cfg->pwm0_duty;
1000aa74:	e51b3014 	ldr	r3, [fp, #-20]
1000aa78:	e5933008 	ldr	r3, [r3, #8]
1000aa7c:	e6ff2073 	uxth	r2, r3
1000aa80:	e51b3008 	ldr	r3, [fp, #-8]
1000aa84:	e1c320b4 	strh	r2, [r3, #4]
	pdev->pwm.Init.pwmduty.pwm1_duty = cfg->pwm1_duty;
1000aa88:	e51b3014 	ldr	r3, [fp, #-20]
1000aa8c:	e593300c 	ldr	r3, [r3, #12]
1000aa90:	e6ff2073 	uxth	r2, r3
1000aa94:	e51b3008 	ldr	r3, [fp, #-8]
1000aa98:	e1c320b6 	strh	r2, [r3, #6]
	pdev->pwm.Init.pwmduty.pwm2_duty = cfg->pwm2_duty;
1000aa9c:	e51b3014 	ldr	r3, [fp, #-20]
1000aaa0:	e5933010 	ldr	r3, [r3, #16]
1000aaa4:	e6ff2073 	uxth	r2, r3
1000aaa8:	e51b3008 	ldr	r3, [fp, #-8]
1000aaac:	e1c320b8 	strh	r2, [r3, #8]
	pdev->pwm.Init.pwmstate = PWM_DISABLE;
1000aab0:	e51b3008 	ldr	r3, [fp, #-8]
1000aab4:	e3a02000 	mov	r2, #0
1000aab8:	e5c32014 	strb	r2, [r3, #20]
	
	PWM_Init(&pdev->pwm);
1000aabc:	e51b3008 	ldr	r3, [fp, #-8]
1000aac0:	e1a00003 	mov	r0, r3
1000aac4:	ebfff85f 	bl	10008c48 <PWM_Init>
	rt_kprintf("******pwm init*********************\r\n");
1000aac8:	e3020a18 	movw	r0, #10776	; 0x2a18
1000aacc:	e3410003 	movt	r0, #4099	; 0x1003
1000aad0:	eb0023fa 	bl	10013ac0 <rt_kprintf>
	rt_kprintf("clk=%d,deadzone=%d,pwm0duty=%d,pwm1duty=%d,pwm2duty=%d\r\n",\
1000aad4:	e51b3014 	ldr	r3, [fp, #-20]
1000aad8:	e5931000 	ldr	r1, [r3]
1000aadc:	e51b3014 	ldr	r3, [fp, #-20]
1000aae0:	e593e004 	ldr	lr, [r3, #4]
1000aae4:	e51b3014 	ldr	r3, [fp, #-20]
1000aae8:	e593c008 	ldr	ip, [r3, #8]
1000aaec:	e51b3014 	ldr	r3, [fp, #-20]
1000aaf0:	e593200c 	ldr	r2, [r3, #12]
1000aaf4:	e51b3014 	ldr	r3, [fp, #-20]
1000aaf8:	e5933010 	ldr	r3, [r3, #16]
1000aafc:	e58d2000 	str	r2, [sp]
1000ab00:	e58d3004 	str	r3, [sp, #4]
1000ab04:	e3020a40 	movw	r0, #10816	; 0x2a40
1000ab08:	e3410003 	movt	r0, #4099	; 0x1003
1000ab0c:	e1a0200e 	mov	r2, lr
1000ab10:	e1a0300c 	mov	r3, ip
1000ab14:	eb0023e9 	bl	10013ac0 <rt_kprintf>
		cfg->clk_hz,cfg->deadzone_ns,cfg->pwm0_duty,cfg->pwm1_duty,cfg->pwm2_duty);
	
	rt_kprintf("******end*********************\r\n");
1000ab18:	e3020a7c 	movw	r0, #10876	; 0x2a7c
1000ab1c:	e3410003 	movt	r0, #4099	; 0x1003
1000ab20:	eb0023e6 	bl	10013ac0 <rt_kprintf>
    return RT_EOK;
1000ab24:	e3a03000 	mov	r3, #0
}
1000ab28:	e1a00003 	mov	r0, r3
1000ab2c:	e24bd004 	sub	sp, fp, #4
1000ab30:	e8bd8800 	pop	{fp, pc}

1000ab34 <pwm_control>:
static rt_err_t pwm_control(struct rt_pwm_device *pwmdev, int cmd, void *arg)
{
1000ab34:	e92d4800 	push	{fp, lr}
1000ab38:	e28db004 	add	fp, sp, #4
1000ab3c:	e24dd018 	sub	sp, sp, #24
1000ab40:	e50b0010 	str	r0, [fp, #-16]
1000ab44:	e50b1014 	str	r1, [fp, #-20]
1000ab48:	e50b2018 	str	r2, [fp, #-24]
    struct hw_pwm_device *pdev;
	duty_HandleTypeDef *duty;

    RT_ASSERT(pwmdev != RT_NULL);
1000ab4c:	e51b3010 	ldr	r3, [fp, #-16]
1000ab50:	e3530000 	cmp	r3, #0
1000ab54:	1a000005 	bne	1000ab70 <pwm_control+0x3c>
1000ab58:	e3020aa0 	movw	r0, #10912	; 0x2aa0
1000ab5c:	e3410003 	movt	r0, #4099	; 0x1003
1000ab60:	e3021aec 	movw	r1, #10988	; 0x2aec
1000ab64:	e3411003 	movt	r1, #4099	; 0x1003
1000ab68:	e3a0203a 	mov	r2, #58	; 0x3a
1000ab6c:	eb002490 	bl	10013db4 <rt_assert_handler>

    pdev = pwmdev->parent.user_data;
1000ab70:	e51b3010 	ldr	r3, [fp, #-16]
1000ab74:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000ab78:	e50b3008 	str	r3, [fp, #-8]

    switch (cmd)
1000ab7c:	e51b3014 	ldr	r3, [fp, #-20]
1000ab80:	e2433001 	sub	r3, r3, #1
1000ab84:	e3530004 	cmp	r3, #4
1000ab88:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1000ab8c:	ea000025 	b	1000ac28 <pwm_control+0xf4>
1000ab90:	1000aba4 	.word	0x1000aba4
1000ab94:	1000abb4 	.word	0x1000abb4
1000ab98:	1000abc4 	.word	0x1000abc4
1000ab9c:	1000abe0 	.word	0x1000abe0
1000aba0:	1000ac04 	.word	0x1000ac04
    {
    case CMD_PWMEN:
		PWMOutputsEnable(&pdev->pwm);
1000aba4:	e51b3008 	ldr	r3, [fp, #-8]
1000aba8:	e1a00003 	mov	r0, r3
1000abac:	ebffff77 	bl	1000a990 <PWMOutputsEnable>
        break;
1000abb0:	ea00001d 	b	1000ac2c <pwm_control+0xf8>

    case CMD_PWMDISABLE:
		PWMOutputsDisable(&pdev->pwm);
1000abb4:	e51b3008 	ldr	r3, [fp, #-8]
1000abb8:	e1a00003 	mov	r0, r3
1000abbc:	ebffff7f 	bl	1000a9c0 <PWMOutputsDisable>
        break;
1000abc0:	ea000019 	b	1000ac2c <pwm_control+0xf8>
		
	case CMD_PWMSETDUTY:
		duty = arg;
1000abc4:	e51b3018 	ldr	r3, [fp, #-24]
1000abc8:	e50b300c 	str	r3, [fp, #-12]
		SetDutyCycles(&pdev->pwm,duty);
1000abcc:	e51b3008 	ldr	r3, [fp, #-8]
1000abd0:	e1a00003 	mov	r0, r3
1000abd4:	e51b100c 	ldr	r1, [fp, #-12]
1000abd8:	ebffff84 	bl	1000a9f0 <SetDutyCycles>

		break;
1000abdc:	ea000012 	b	1000ac2c <pwm_control+0xf8>

	case CMD_PWMSETDEADZONE:
		while(PWMSetDeadzone(&pdev->pwm,arg) != MYIP_SUCCESS);
1000abe0:	e1a00000 	nop			; (mov r0, r0)
1000abe4:	e51b3008 	ldr	r3, [fp, #-8]
1000abe8:	e1a00003 	mov	r0, r3
1000abec:	e51b1018 	ldr	r1, [fp, #-24]
1000abf0:	ebfff7a3 	bl	10008a84 <PWMSetDeadzone>
1000abf4:	e1a03000 	mov	r3, r0
1000abf8:	e3530001 	cmp	r3, #1
1000abfc:	1afffff8 	bne	1000abe4 <pwm_control+0xb0>


		break;
1000ac00:	ea000009 	b	1000ac2c <pwm_control+0xf8>
	case CMD_PWMSETCLK:
		while(PWMSetclk(&pdev->pwm,arg) != MYIP_SUCCESS);
1000ac04:	e1a00000 	nop			; (mov r0, r0)
1000ac08:	e51b3008 	ldr	r3, [fp, #-8]
1000ac0c:	e1a00003 	mov	r0, r3
1000ac10:	e51b1018 	ldr	r1, [fp, #-24]
1000ac14:	ebfff7be 	bl	10008b14 <PWMSetclk>
1000ac18:	e1a03000 	mov	r3, r0
1000ac1c:	e3530001 	cmp	r3, #1
1000ac20:	1afffff8 	bne	1000ac08 <pwm_control+0xd4>

		break;
1000ac24:	ea000000 	b	1000ac2c <pwm_control+0xf8>
	default: 
			break;
1000ac28:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
1000ac2c:	e3a03000 	mov	r3, #0
}
1000ac30:	e1a00003 	mov	r0, r3
1000ac34:	e24bd004 	sub	sp, fp, #4
1000ac38:	e8bd8800 	pop	{fp, pc}

1000ac3c <PWM_MSP_Init>:
    pwm_configure,
    pwm_control,
};

void PWM_MSP_Init(PWM_HandleTypeDef *pwm)
{
1000ac3c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ac40:	e28db000 	add	fp, sp, #0
1000ac44:	e24dd00c 	sub	sp, sp, #12
1000ac48:	e50b0008 	str	r0, [fp, #-8]
}
1000ac4c:	e24bd000 	sub	sp, fp, #0
1000ac50:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ac54:	e12fff1e 	bx	lr

1000ac58 <pwm_hw_init>:




int pwm_hw_init(void)
{
1000ac58:	e92d4800 	push	{fp, lr}
1000ac5c:	e28db004 	add	fp, sp, #4
1000ac60:	e24dd018 	sub	sp, sp, #24

	struct pwm_configure pwm_config = RT_PWM_CONFIG_DEFAULT;
1000ac64:	e3023ac4 	movw	r3, #10948	; 0x2ac4
1000ac68:	e3413003 	movt	r3, #4099	; 0x1003
1000ac6c:	e24bc018 	sub	ip, fp, #24
1000ac70:	e1a0e003 	mov	lr, r3
1000ac74:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
1000ac78:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
1000ac7c:	e59e3000 	ldr	r3, [lr]
1000ac80:	e58c3000 	str	r3, [ip]
	pwm_device1.config = pwm_config;
1000ac84:	e3023864 	movw	r3, #10340	; 0x2864
1000ac88:	e3413004 	movt	r3, #4100	; 0x1004
1000ac8c:	e283c040 	add	ip, r3, #64	; 0x40
1000ac90:	e24be018 	sub	lr, fp, #24
1000ac94:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
1000ac98:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
1000ac9c:	e59e3000 	ldr	r3, [lr]
1000aca0:	e58c3000 	str	r3, [ip]
	pwm_device1.ops = &_pwm_ops;
1000aca4:	e3023864 	movw	r3, #10340	; 0x2864
1000aca8:	e3413004 	movt	r3, #4100	; 0x1004
1000acac:	e3022ab4 	movw	r2, #10932	; 0x2ab4
1000acb0:	e3412003 	movt	r2, #4099	; 0x1003
1000acb4:	e583203c 	str	r2, [r3, #60]	; 0x3c
	
	pwm_handle.Instance = MYPWM_BASEADDR;
1000acb8:	e3022848 	movw	r2, #10312	; 0x2848
1000acbc:	e3412004 	movt	r2, #4100	; 0x1004
1000acc0:	e3a03000 	mov	r3, #0
1000acc4:	e34433c1 	movt	r3, #17345	; 0x43c1
1000acc8:	e5823000 	str	r3, [r2]

	pwm_hw_device1.pwm = pwm_handle;
1000accc:	e30228b8 	movw	r2, #10424	; 0x28b8
1000acd0:	e3412004 	movt	r2, #4100	; 0x1004
1000acd4:	e3023848 	movw	r3, #10312	; 0x2848
1000acd8:	e3413004 	movt	r3, #4100	; 0x1004
1000acdc:	e1a0c002 	mov	ip, r2
1000ace0:	e1a0e003 	mov	lr, r3
1000ace4:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
1000ace8:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
1000acec:	e89e0007 	ldm	lr, {r0, r1, r2}
1000acf0:	e88c0007 	stm	ip, {r0, r1, r2}

	rt_hw_pwm_register(&pwm_device1, "pwm1",
1000acf4:	e3020864 	movw	r0, #10340	; 0x2864
1000acf8:	e3410004 	movt	r0, #4100	; 0x1004
1000acfc:	e3021abc 	movw	r1, #10940	; 0x2abc
1000ad00:	e3411003 	movt	r1, #4099	; 0x1003
1000ad04:	e3a02000 	mov	r2, #0
1000ad08:	e30238b8 	movw	r3, #10424	; 0x28b8
1000ad0c:	e3413004 	movt	r3, #4100	; 0x1004
1000ad10:	eb0003fe 	bl	1000bd10 <rt_hw_pwm_register>
                          NULL,
                          &pwm_hw_device1);
	return 0;
1000ad14:	e3a03000 	mov	r3, #0

}
1000ad18:	e1a00003 	mov	r0, r3
1000ad1c:	e24bd004 	sub	sp, fp, #4
1000ad20:	e8bd8800 	pop	{fp, pc}

1000ad24 <pwm_config_init>:
INIT_BOARD_EXPORT(pwm_hw_init);


int pwm_config_init(void)
{
1000ad24:	e92d4800 	push	{fp, lr}
1000ad28:	e28db004 	add	fp, sp, #4
1000ad2c:	e24dd008 	sub	sp, sp, #8
	rt_device_t device;

	//rt_kprintf("pwm init\r\n");
	device = rt_device_find("pwm1");
1000ad30:	e3020abc 	movw	r0, #10940	; 0x2abc
1000ad34:	e3410003 	movt	r0, #4099	; 0x1003
1000ad38:	eb000e45 	bl	1000e654 <rt_device_find>
1000ad3c:	e50b0008 	str	r0, [fp, #-8]
	if(device == NULL) printf("device not found \r\n");
1000ad40:	e51b3008 	ldr	r3, [fp, #-8]
1000ad44:	e3530000 	cmp	r3, #0
1000ad48:	1a000002 	bne	1000ad58 <pwm_config_init+0x34>
1000ad4c:	e3020ad8 	movw	r0, #10968	; 0x2ad8
1000ad50:	e3410003 	movt	r0, #4099	; 0x1003
1000ad54:	fa0091e8 	blx	1002f4fc <puts>
	rt_device_open(device,NULL);
1000ad58:	e51b0008 	ldr	r0, [fp, #-8]
1000ad5c:	e3a01000 	mov	r1, #0
1000ad60:	eb000e9f 	bl	1000e7e4 <rt_device_open>
	
	rt_device_init(device);
1000ad64:	e51b0008 	ldr	r0, [fp, #-8]
1000ad68:	eb000e6c 	bl	1000e720 <rt_device_init>
	
	rt_device_close(device);
1000ad6c:	e51b0008 	ldr	r0, [fp, #-8]
1000ad70:	eb000f01 	bl	1000e97c <rt_device_close>
	return 0;
1000ad74:	e3a03000 	mov	r3, #0
}
1000ad78:	e1a00003 	mov	r0, r3
1000ad7c:	e24bd004 	sub	sp, fp, #4
1000ad80:	e8bd8800 	pop	{fp, pc}

1000ad84 <qepEnable>:
	Qep_HandleTypeDef qep;

};

static void qepEnable(Qep_HandleTypeDef *qep)
{
1000ad84:	e92d4800 	push	{fp, lr}
1000ad88:	e28db004 	add	fp, sp, #4
1000ad8c:	e24dd008 	sub	sp, sp, #8
1000ad90:	e50b0008 	str	r0, [fp, #-8]
	while(qep_enable(qep) != MYIP_SUCCESS);
1000ad94:	e1a00000 	nop			; (mov r0, r0)
1000ad98:	e51b0008 	ldr	r0, [fp, #-8]
1000ad9c:	eb0002c4 	bl	1000b8b4 <qep_enable>
1000ada0:	e1a03000 	mov	r3, r0
1000ada4:	e3530001 	cmp	r3, #1
1000ada8:	1afffffa 	bne	1000ad98 <qepEnable+0x14>
}
1000adac:	e24bd004 	sub	sp, fp, #4
1000adb0:	e8bd8800 	pop	{fp, pc}

1000adb4 <qepDisable>:

static void qepDisable(Qep_HandleTypeDef *qep)
{
1000adb4:	e92d4800 	push	{fp, lr}
1000adb8:	e28db004 	add	fp, sp, #4
1000adbc:	e24dd008 	sub	sp, sp, #8
1000adc0:	e50b0008 	str	r0, [fp, #-8]
	while(qep_disable(qep)!= MYIP_SUCCESS);
1000adc4:	e1a00000 	nop			; (mov r0, r0)
1000adc8:	e51b0008 	ldr	r0, [fp, #-8]
1000adcc:	eb0002dd 	bl	1000b948 <qep_disable>
1000add0:	e1a03000 	mov	r3, r0
1000add4:	e3530001 	cmp	r3, #1
1000add8:	1afffffa 	bne	1000adc8 <qepDisable+0x14>

}
1000addc:	e24bd004 	sub	sp, fp, #4
1000ade0:	e8bd8800 	pop	{fp, pc}

1000ade4 <qepSetMod>:


static void qepSetMod(Qep_HandleTypeDef *qep,unsigned int mod)
{
1000ade4:	e92d4800 	push	{fp, lr}
1000ade8:	e28db004 	add	fp, sp, #4
1000adec:	e24dd008 	sub	sp, sp, #8
1000adf0:	e50b0008 	str	r0, [fp, #-8]
1000adf4:	e50b100c 	str	r1, [fp, #-12]
	while(qep_set_mode(qep,mod)!= MYIP_SUCCESS);
1000adf8:	e1a00000 	nop			; (mov r0, r0)
1000adfc:	e51b0008 	ldr	r0, [fp, #-8]
1000ae00:	e51b100c 	ldr	r1, [fp, #-12]
1000ae04:	eb0002f4 	bl	1000b9dc <qep_set_mode>
1000ae08:	e1a03000 	mov	r3, r0
1000ae0c:	e3530001 	cmp	r3, #1
1000ae10:	1afffff9 	bne	1000adfc <qepSetMod+0x18>

}
1000ae14:	e24bd004 	sub	sp, fp, #4
1000ae18:	e8bd8800 	pop	{fp, pc}

1000ae1c <qepSetPeriod>:

static void qepSetPeriod(Qep_HandleTypeDef *qep,unsigned int period)
{
1000ae1c:	e92d4800 	push	{fp, lr}
1000ae20:	e28db004 	add	fp, sp, #4
1000ae24:	e24dd008 	sub	sp, sp, #8
1000ae28:	e50b0008 	str	r0, [fp, #-8]
1000ae2c:	e50b100c 	str	r1, [fp, #-12]
	while(qep_set_period(qep,period)!= MYIP_SUCCESS);
1000ae30:	e1a00000 	nop			; (mov r0, r0)
1000ae34:	e51b0008 	ldr	r0, [fp, #-8]
1000ae38:	e51b100c 	ldr	r1, [fp, #-12]
1000ae3c:	eb00027d 	bl	1000b838 <qep_set_period>
1000ae40:	e1a03000 	mov	r3, r0
1000ae44:	e3530001 	cmp	r3, #1
1000ae48:	1afffff9 	bne	1000ae34 <qepSetPeriod+0x18>

}
1000ae4c:	e24bd004 	sub	sp, fp, #4
1000ae50:	e8bd8800 	pop	{fp, pc}

1000ae54 <qep_configure>:


static rt_err_t qep_configure(struct rt_qep_device *qepdev, struct qep_configure *cfg)
{
1000ae54:	e92d4800 	push	{fp, lr}
1000ae58:	e28db004 	add	fp, sp, #4
1000ae5c:	e24dd010 	sub	sp, sp, #16
1000ae60:	e50b0010 	str	r0, [fp, #-16]
1000ae64:	e50b1014 	str	r1, [fp, #-20]
	uint32_t mr;
	struct hw_qep_device *pdev = qepdev->parent.user_data;
1000ae68:	e51b3010 	ldr	r3, [fp, #-16]
1000ae6c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000ae70:	e50b3008 	str	r3, [fp, #-8]
	
	pdev->qep.state = MYIP_STATE_RESET;
1000ae74:	e51b3008 	ldr	r3, [fp, #-8]
1000ae78:	e3a02000 	mov	r2, #0
1000ae7c:	e5832010 	str	r2, [r3, #16]
	pdev->qep.init.mod= cfg->mod;
1000ae80:	e51b3014 	ldr	r3, [fp, #-20]
1000ae84:	e5932000 	ldr	r2, [r3]
1000ae88:	e51b3008 	ldr	r3, [fp, #-8]
1000ae8c:	e5832004 	str	r2, [r3, #4]
	pdev->qep.init.period= cfg->period;
1000ae90:	e51b3014 	ldr	r3, [fp, #-20]
1000ae94:	e5932004 	ldr	r2, [r3, #4]
1000ae98:	e51b3008 	ldr	r3, [fp, #-8]
1000ae9c:	e5832008 	str	r2, [r3, #8]
	//rt_kprintf("addr = %x\r\n",&pdev->qep);
	QEP_Init(&pdev->qep);
1000aea0:	e51b3008 	ldr	r3, [fp, #-8]
1000aea4:	e1a00003 	mov	r0, r3
1000aea8:	eb000300 	bl	1000bab0 <QEP_Init>
	rt_kprintf("*****************qep init*****************\r\n");
1000aeac:	e3020af8 	movw	r0, #11000	; 0x2af8
1000aeb0:	e3410003 	movt	r0, #4099	; 0x1003
1000aeb4:	eb002301 	bl	10013ac0 <rt_kprintf>
	rt_kprintf("mod=%d,period = %d\r\n",cfg->mod,cfg->period);
1000aeb8:	e51b3014 	ldr	r3, [fp, #-20]
1000aebc:	e5932000 	ldr	r2, [r3]
1000aec0:	e51b3014 	ldr	r3, [fp, #-20]
1000aec4:	e5933004 	ldr	r3, [r3, #4]
1000aec8:	e3020b28 	movw	r0, #11048	; 0x2b28
1000aecc:	e3410003 	movt	r0, #4099	; 0x1003
1000aed0:	e1a01002 	mov	r1, r2
1000aed4:	e1a02003 	mov	r2, r3
1000aed8:	eb0022f8 	bl	10013ac0 <rt_kprintf>
	rt_kprintf("*****************end*****************\r\n");
1000aedc:	e3020b40 	movw	r0, #11072	; 0x2b40
1000aee0:	e3410003 	movt	r0, #4099	; 0x1003
1000aee4:	eb0022f5 	bl	10013ac0 <rt_kprintf>
    return RT_EOK;
1000aee8:	e3a03000 	mov	r3, #0
}
1000aeec:	e1a00003 	mov	r0, r3
1000aef0:	e24bd004 	sub	sp, fp, #4
1000aef4:	e8bd8800 	pop	{fp, pc}

1000aef8 <qep_control>:
static rt_err_t qep_control(struct rt_qep_device *qepdev, int cmd, void *arg)
{
1000aef8:	e92d4800 	push	{fp, lr}
1000aefc:	e28db004 	add	fp, sp, #4
1000af00:	e24dd018 	sub	sp, sp, #24
1000af04:	e50b0010 	str	r0, [fp, #-16]
1000af08:	e50b1014 	str	r1, [fp, #-20]
1000af0c:	e50b2018 	str	r2, [fp, #-24]
    struct hw_qep_device *pdev;
	unsigned int *temp;

    RT_ASSERT(qepdev != RT_NULL);
1000af10:	e51b3010 	ldr	r3, [fp, #-16]
1000af14:	e3530000 	cmp	r3, #0
1000af18:	1a000005 	bne	1000af34 <qep_control+0x3c>
1000af1c:	e3020b68 	movw	r0, #11112	; 0x2b68
1000af20:	e3410003 	movt	r0, #4099	; 0x1003
1000af24:	e3021bb0 	movw	r1, #11184	; 0x2bb0
1000af28:	e3411003 	movt	r1, #4099	; 0x1003
1000af2c:	e3a0203d 	mov	r2, #61	; 0x3d
1000af30:	eb00239f 	bl	10013db4 <rt_assert_handler>

    pdev = qepdev->parent.user_data;
1000af34:	e51b3010 	ldr	r3, [fp, #-16]
1000af38:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000af3c:	e50b3008 	str	r3, [fp, #-8]

    switch (cmd)
1000af40:	e51b3014 	ldr	r3, [fp, #-20]
1000af44:	e2433001 	sub	r3, r3, #1
1000af48:	e3530003 	cmp	r3, #3
1000af4c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1000af50:	ea00001d 	b	1000afcc <qep_control+0xd4>
1000af54:	1000af64 	.word	0x1000af64
1000af58:	1000af74 	.word	0x1000af74
1000af5c:	1000af84 	.word	0x1000af84
1000af60:	1000afa8 	.word	0x1000afa8
    {
    case CMD_QEPEN:
		qepEnable(&pdev->qep);
1000af64:	e51b3008 	ldr	r3, [fp, #-8]
1000af68:	e1a00003 	mov	r0, r3
1000af6c:	ebffff84 	bl	1000ad84 <qepEnable>
        break;
1000af70:	ea000016 	b	1000afd0 <qep_control+0xd8>

    case CMD_QEPDISABLE:
		qepDisable(&pdev->qep);
1000af74:	e51b3008 	ldr	r3, [fp, #-8]
1000af78:	e1a00003 	mov	r0, r3
1000af7c:	ebffff8c 	bl	1000adb4 <qepDisable>
        break;
1000af80:	ea000012 	b	1000afd0 <qep_control+0xd8>
		
	case CMD_QEPSETMOD:
		temp = arg;
1000af84:	e51b3018 	ldr	r3, [fp, #-24]
1000af88:	e50b300c 	str	r3, [fp, #-12]
		qepSetMod(&pdev->qep,*temp);
1000af8c:	e51b2008 	ldr	r2, [fp, #-8]
1000af90:	e51b300c 	ldr	r3, [fp, #-12]
1000af94:	e5933000 	ldr	r3, [r3]
1000af98:	e1a00002 	mov	r0, r2
1000af9c:	e1a01003 	mov	r1, r3
1000afa0:	ebffff8f 	bl	1000ade4 <qepSetMod>
		break;
1000afa4:	ea000009 	b	1000afd0 <qep_control+0xd8>

	case CMD_QEPSETPERIOD:
		temp =arg;
1000afa8:	e51b3018 	ldr	r3, [fp, #-24]
1000afac:	e50b300c 	str	r3, [fp, #-12]
		qepSetPeriod(&pdev->qep,*temp);
1000afb0:	e51b2008 	ldr	r2, [fp, #-8]
1000afb4:	e51b300c 	ldr	r3, [fp, #-12]
1000afb8:	e5933000 	ldr	r3, [r3]
1000afbc:	e1a00002 	mov	r0, r2
1000afc0:	e1a01003 	mov	r1, r3
1000afc4:	ebffff94 	bl	1000ae1c <qepSetPeriod>
		break;
1000afc8:	ea000000 	b	1000afd0 <qep_control+0xd8>
	default: 
			break;
1000afcc:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
1000afd0:	e3a03000 	mov	r3, #0
}
1000afd4:	e1a00003 	mov	r0, r3
1000afd8:	e24bd004 	sub	sp, fp, #4
1000afdc:	e8bd8800 	pop	{fp, pc}

1000afe0 <qep_getvalue>:


Qep_ValueTypeDef qep_getvalue(struct rt_qep_device *qepdev)
{
1000afe0:	e92d4800 	push	{fp, lr}
1000afe4:	e28db004 	add	fp, sp, #4
1000afe8:	e24dd018 	sub	sp, sp, #24
1000afec:	e50b0018 	str	r0, [fp, #-24]
1000aff0:	e50b101c 	str	r1, [fp, #-28]
    struct hw_qep_device *pdev;
	Qep_ValueTypeDef data;
	
    RT_ASSERT(qepdev != RT_NULL);
1000aff4:	e51b301c 	ldr	r3, [fp, #-28]
1000aff8:	e3530000 	cmp	r3, #0
1000affc:	1a000005 	bne	1000b018 <qep_getvalue+0x38>
1000b000:	e3020b68 	movw	r0, #11112	; 0x2b68
1000b004:	e3410003 	movt	r0, #4099	; 0x1003
1000b008:	e3021bbc 	movw	r1, #11196	; 0x2bbc
1000b00c:	e3411003 	movt	r1, #4099	; 0x1003
1000b010:	e3a02061 	mov	r2, #97	; 0x61
1000b014:	eb002366 	bl	10013db4 <rt_assert_handler>
    pdev = qepdev->parent.user_data;
1000b018:	e51b301c 	ldr	r3, [fp, #-28]
1000b01c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000b020:	e50b3008 	str	r3, [fp, #-8]
	data.cnt = qep_read_cnt(&pdev->qep);
1000b024:	e51b3008 	ldr	r3, [fp, #-8]
1000b028:	e1a00003 	mov	r0, r3
1000b02c:	eb0001e1 	bl	1000b7b8 <qep_read_cnt>
1000b030:	e1a03000 	mov	r3, r0
1000b034:	e50b300c 	str	r3, [fp, #-12]
	data.turn = qep_read_turn(&pdev->qep);
1000b038:	e51b3008 	ldr	r3, [fp, #-8]
1000b03c:	e1a00003 	mov	r0, r3
1000b040:	eb0001ec 	bl	1000b7f8 <qep_read_turn>
1000b044:	e1a03000 	mov	r3, r0
1000b048:	e50b3010 	str	r3, [fp, #-16]
	
	return data;
1000b04c:	e51b3018 	ldr	r3, [fp, #-24]
1000b050:	e1a02003 	mov	r2, r3
1000b054:	e24b3010 	sub	r3, fp, #16
1000b058:	e8930003 	ldm	r3, {r0, r1}
1000b05c:	e8820003 	stm	r2, {r0, r1}
	
}
1000b060:	e51b0018 	ldr	r0, [fp, #-24]
1000b064:	e24bd004 	sub	sp, fp, #4
1000b068:	e8bd8800 	pop	{fp, pc}

1000b06c <QEP_MSP_Init>:
    qep_control,
    qep_getvalue,
};

void QEP_MSP_Init(Qep_HandleTypeDef *qep)
{
1000b06c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000b070:	e28db000 	add	fp, sp, #0
1000b074:	e24dd00c 	sub	sp, sp, #12
1000b078:	e50b0008 	str	r0, [fp, #-8]
}
1000b07c:	e24bd000 	sub	sp, fp, #0
1000b080:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000b084:	e12fff1e 	bx	lr

1000b088 <qep_hw_init>:




int qep_hw_init(void)
{
1000b088:	e92d4800 	push	{fp, lr}
1000b08c:	e28db004 	add	fp, sp, #4
1000b090:	e24dd010 	sub	sp, sp, #16

	struct qep_configure qep_config = RT_QEP_CONFIG_DEFAULT;
1000b094:	e3023b90 	movw	r3, #11152	; 0x2b90
1000b098:	e3413003 	movt	r3, #4099	; 0x1003
1000b09c:	e24bc010 	sub	ip, fp, #16
1000b0a0:	e8930007 	ldm	r3, {r0, r1, r2}
1000b0a4:	e88c0007 	stm	ip, {r0, r1, r2}
	qep_device1.config = qep_config;
1000b0a8:	e30238fc 	movw	r3, #10492	; 0x28fc
1000b0ac:	e3413004 	movt	r3, #4100	; 0x1004
1000b0b0:	e2833040 	add	r3, r3, #64	; 0x40
1000b0b4:	e24b2010 	sub	r2, fp, #16
1000b0b8:	e8920007 	ldm	r2, {r0, r1, r2}
1000b0bc:	e8830007 	stm	r3, {r0, r1, r2}
	qep_device1.ops = &_qep_ops;
1000b0c0:	e30238fc 	movw	r3, #10492	; 0x28fc
1000b0c4:	e3413004 	movt	r3, #4100	; 0x1004
1000b0c8:	e3022b7c 	movw	r2, #11132	; 0x2b7c
1000b0cc:	e3412003 	movt	r2, #4099	; 0x1003
1000b0d0:	e583203c 	str	r2, [r3, #60]	; 0x3c
	
	qep_handle.Instance = MYQEP_BASEADDR;
1000b0d4:	e30228e8 	movw	r2, #10472	; 0x28e8
1000b0d8:	e3412004 	movt	r2, #4100	; 0x1004
1000b0dc:	e3a03000 	mov	r3, #0
1000b0e0:	e34433c3 	movt	r3, #17347	; 0x43c3
1000b0e4:	e5823000 	str	r3, [r2]
	qep_handle.state = MYIP_STATE_RESET;
1000b0e8:	e30238e8 	movw	r3, #10472	; 0x28e8
1000b0ec:	e3413004 	movt	r3, #4100	; 0x1004
1000b0f0:	e3a02000 	mov	r2, #0
1000b0f4:	e5832010 	str	r2, [r3, #16]

	qep_hw_device1.qep = qep_handle;
1000b0f8:	e30228d4 	movw	r2, #10452	; 0x28d4
1000b0fc:	e3412004 	movt	r2, #4100	; 0x1004
1000b100:	e30238e8 	movw	r3, #10472	; 0x28e8
1000b104:	e3413004 	movt	r3, #4100	; 0x1004
1000b108:	e1a0c002 	mov	ip, r2
1000b10c:	e1a0e003 	mov	lr, r3
1000b110:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
1000b114:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
1000b118:	e59e3000 	ldr	r3, [lr]
1000b11c:	e58c3000 	str	r3, [ip]

	rt_hw_qep_register(&qep_device1, "qep1",
1000b120:	e30208fc 	movw	r0, #10492	; 0x28fc
1000b124:	e3410004 	movt	r0, #4100	; 0x1004
1000b128:	e3021b88 	movw	r1, #11144	; 0x2b88
1000b12c:	e3411003 	movt	r1, #4099	; 0x1003
1000b130:	e3a02000 	mov	r2, #0
1000b134:	e30238d4 	movw	r3, #10452	; 0x28d4
1000b138:	e3413004 	movt	r3, #4100	; 0x1004
1000b13c:	eb0003b1 	bl	1000c008 <rt_hw_qep_register>
                          NULL,
                          &qep_hw_device1);

	return 0;
1000b140:	e3a03000 	mov	r3, #0

}
1000b144:	e1a00003 	mov	r0, r3
1000b148:	e24bd004 	sub	sp, fp, #4
1000b14c:	e8bd8800 	pop	{fp, pc}

1000b150 <qep_config_init>:
INIT_BOARD_EXPORT(qep_hw_init);


int qep_config_init(void)
{
1000b150:	e92d4800 	push	{fp, lr}
1000b154:	e28db004 	add	fp, sp, #4
1000b158:	e24dd008 	sub	sp, sp, #8
	rt_device_t device;

	device = rt_device_find("qep1");
1000b15c:	e3020b88 	movw	r0, #11144	; 0x2b88
1000b160:	e3410003 	movt	r0, #4099	; 0x1003
1000b164:	eb000d3a 	bl	1000e654 <rt_device_find>
1000b168:	e50b0008 	str	r0, [fp, #-8]
	if(device == NULL) printf("device not found \r\n");
1000b16c:	e51b3008 	ldr	r3, [fp, #-8]
1000b170:	e3530000 	cmp	r3, #0
1000b174:	1a000002 	bne	1000b184 <qep_config_init+0x34>
1000b178:	e3020b9c 	movw	r0, #11164	; 0x2b9c
1000b17c:	e3410003 	movt	r0, #4099	; 0x1003
1000b180:	fa0090dd 	blx	1002f4fc <puts>
	rt_device_open(device,NULL);
1000b184:	e51b0008 	ldr	r0, [fp, #-8]
1000b188:	e3a01000 	mov	r1, #0
1000b18c:	eb000d94 	bl	1000e7e4 <rt_device_open>
	rt_device_init(device);
1000b190:	e51b0008 	ldr	r0, [fp, #-8]
1000b194:	eb000d61 	bl	1000e720 <rt_device_init>
	rt_device_close(device);
1000b198:	e51b0008 	ldr	r0, [fp, #-8]
1000b19c:	eb000df6 	bl	1000e97c <rt_device_close>
	return 0;
1000b1a0:	e3a03000 	mov	r3, #0
}
1000b1a4:	e1a00003 	mov	r0, r3
1000b1a8:	e24bd004 	sub	sp, fp, #4
1000b1ac:	e8bd8800 	pop	{fp, pc}

1000b1b0 <sharemem_configure>:

};


static rt_err_t sharemem_configure(struct rt_sharemem_device *sharememdev, struct sharemem_configure *cfg)
{
1000b1b0:	e92d4800 	push	{fp, lr}
1000b1b4:	e28db004 	add	fp, sp, #4
1000b1b8:	e24dd010 	sub	sp, sp, #16
1000b1bc:	e50b0010 	str	r0, [fp, #-16]
1000b1c0:	e50b1014 	str	r1, [fp, #-20]
	struct hw_sharemem_device *pdev;

	
    RT_ASSERT(sharememdev != RT_NULL);
1000b1c4:	e51b3010 	ldr	r3, [fp, #-16]
1000b1c8:	e3530000 	cmp	r3, #0
1000b1cc:	1a000005 	bne	1000b1e8 <sharemem_configure+0x38>
1000b1d0:	e3020bcc 	movw	r0, #11212	; 0x2bcc
1000b1d4:	e3410003 	movt	r0, #4099	; 0x1003
1000b1d8:	e3021c30 	movw	r1, #11312	; 0x2c30
1000b1dc:	e3411003 	movt	r1, #4099	; 0x1003
1000b1e0:	e3a02020 	mov	r2, #32
1000b1e4:	eb0022f2 	bl	10013db4 <rt_assert_handler>
	pdev = sharememdev->parent.user_data;
1000b1e8:	e51b3010 	ldr	r3, [fp, #-16]
1000b1ec:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000b1f0:	e50b3008 	str	r3, [fp, #-8]
	
	pdev->sharememhandle.Local_Instance->readposition = sharememdev->config.readposition;
1000b1f4:	e51b3008 	ldr	r3, [fp, #-8]
1000b1f8:	e5933000 	ldr	r3, [r3]
1000b1fc:	e51b2010 	ldr	r2, [fp, #-16]
1000b200:	e5922040 	ldr	r2, [r2, #64]	; 0x40
1000b204:	e5832000 	str	r2, [r3]
	pdev->sharememhandle.Local_Instance->writeposition = sharememdev->config.writeposition;
1000b208:	e51b3008 	ldr	r3, [fp, #-8]
1000b20c:	e5933000 	ldr	r3, [r3]
1000b210:	e51b2010 	ldr	r2, [fp, #-16]
1000b214:	e5922044 	ldr	r2, [r2, #68]	; 0x44
1000b218:	e5832004 	str	r2, [r3, #4]
	pdev->sharememhandle.Local_Instance->maxlength = sharememdev->config.maxlength;
1000b21c:	e51b3008 	ldr	r3, [fp, #-8]
1000b220:	e5933000 	ldr	r3, [r3]
1000b224:	e51b2010 	ldr	r2, [fp, #-16]
1000b228:	e5922048 	ldr	r2, [r2, #72]	; 0x48
1000b22c:	e5832008 	str	r2, [r3, #8]
	
	rt_kprintf("sharemem init complete\r\n");
1000b230:	e3020be4 	movw	r0, #11236	; 0x2be4
1000b234:	e3410003 	movt	r0, #4099	; 0x1003
1000b238:	eb002220 	bl	10013ac0 <rt_kprintf>
	
    return RT_EOK;
1000b23c:	e3a03000 	mov	r3, #0
}
1000b240:	e1a00003 	mov	r0, r3
1000b244:	e24bd004 	sub	sp, fp, #4
1000b248:	e8bd8800 	pop	{fp, pc}

1000b24c <sharemem_writemem>:



static unsigned long sharemem_writemem(struct rt_sharemem_device *sharememdev, char * data,int size)
{
1000b24c:	e92d4800 	push	{fp, lr}
1000b250:	e28db004 	add	fp, sp, #4
1000b254:	e24dd028 	sub	sp, sp, #40	; 0x28
1000b258:	e50b0020 	str	r0, [fp, #-32]
1000b25c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
1000b260:	e50b2028 	str	r2, [fp, #-40]	; 0x28
	int writeposition;
	int maxlength;
	char *p;
	int i;

    RT_ASSERT(sharememdev != RT_NULL);
1000b264:	e51b3020 	ldr	r3, [fp, #-32]
1000b268:	e3530000 	cmp	r3, #0
1000b26c:	1a000005 	bne	1000b288 <sharemem_writemem+0x3c>
1000b270:	e3020bcc 	movw	r0, #11212	; 0x2bcc
1000b274:	e3410003 	movt	r0, #4099	; 0x1003
1000b278:	e3021c44 	movw	r1, #11332	; 0x2c44
1000b27c:	e3411003 	movt	r1, #4099	; 0x1003
1000b280:	e3a02037 	mov	r2, #55	; 0x37
1000b284:	eb0022ca 	bl	10013db4 <rt_assert_handler>

    pdev = sharememdev->parent.user_data;
1000b288:	e51b3020 	ldr	r3, [fp, #-32]
1000b28c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000b290:	e50b3014 	str	r3, [fp, #-20]

	readposition = pdev->sharememhandle.Local_Instance->readposition;
1000b294:	e51b3014 	ldr	r3, [fp, #-20]
1000b298:	e5933000 	ldr	r3, [r3]
1000b29c:	e5933000 	ldr	r3, [r3]
1000b2a0:	e50b3018 	str	r3, [fp, #-24]
	writeposition = pdev->sharememhandle.Local_Instance->writeposition;
1000b2a4:	e51b3014 	ldr	r3, [fp, #-20]
1000b2a8:	e5933000 	ldr	r3, [r3]
1000b2ac:	e5933004 	ldr	r3, [r3, #4]
1000b2b0:	e50b3008 	str	r3, [fp, #-8]
	maxlength = pdev->sharememhandle.Local_Instance->maxlength;
1000b2b4:	e51b3014 	ldr	r3, [fp, #-20]
1000b2b8:	e5933000 	ldr	r3, [r3]
1000b2bc:	e5933008 	ldr	r3, [r3, #8]
1000b2c0:	e50b301c 	str	r3, [fp, #-28]

	p = writeposition + pdev->sharememhandle.Local_Instance + sizeof(sharememhead_TyepDef);
1000b2c4:	e51b3014 	ldr	r3, [fp, #-20]
1000b2c8:	e5932000 	ldr	r2, [r3]
1000b2cc:	e51b3008 	ldr	r3, [fp, #-8]
1000b2d0:	e1a03103 	lsl	r3, r3, #2
1000b2d4:	e1a01103 	lsl	r1, r3, #2
1000b2d8:	e0633001 	rsb	r3, r3, r1
1000b2dc:	e2833090 	add	r3, r3, #144	; 0x90
1000b2e0:	e0823003 	add	r3, r2, r3
1000b2e4:	e50b300c 	str	r3, [fp, #-12]
	maxlength = maxlength + pdev->sharememhandle.Local_Instance + sizeof(sharememhead_TyepDef);
1000b2e8:	e51b3014 	ldr	r3, [fp, #-20]
1000b2ec:	e5932000 	ldr	r2, [r3]
1000b2f0:	e51b301c 	ldr	r3, [fp, #-28]
1000b2f4:	e1a03103 	lsl	r3, r3, #2
1000b2f8:	e1a01103 	lsl	r1, r3, #2
1000b2fc:	e0633001 	rsb	r3, r3, r1
1000b300:	e2833090 	add	r3, r3, #144	; 0x90
1000b304:	e0823003 	add	r3, r2, r3
1000b308:	e50b301c 	str	r3, [fp, #-28]

	rt_kprintf("base:%x,head:%x,point:%x\r\n",pdev->sharememhandle.Local_Instance,sizeof(sharememhead_TyepDef),p);
1000b30c:	e51b3014 	ldr	r3, [fp, #-20]
1000b310:	e5933000 	ldr	r3, [r3]
1000b314:	e3020c00 	movw	r0, #11264	; 0x2c00
1000b318:	e3410003 	movt	r0, #4099	; 0x1003
1000b31c:	e1a01003 	mov	r1, r3
1000b320:	e3a0200c 	mov	r2, #12
1000b324:	e51b300c 	ldr	r3, [fp, #-12]
1000b328:	eb0021e4 	bl	10013ac0 <rt_kprintf>
	for(i = 0;i < size;i++)
1000b32c:	e3a03000 	mov	r3, #0
1000b330:	e50b3010 	str	r3, [fp, #-16]
1000b334:	ea00001d 	b	1000b3b0 <sharemem_writemem+0x164>
	{
		if((p + i) >= maxlength )
1000b338:	e51b3010 	ldr	r3, [fp, #-16]
1000b33c:	e51b200c 	ldr	r2, [fp, #-12]
1000b340:	e0822003 	add	r2, r2, r3
1000b344:	e51b301c 	ldr	r3, [fp, #-28]
1000b348:	e1520003 	cmp	r2, r3
1000b34c:	3a00000c 	bcc	1000b384 <sharemem_writemem+0x138>
		{
				writeposition = 0;
1000b350:	e3a03000 	mov	r3, #0
1000b354:	e50b3008 	str	r3, [fp, #-8]
				p = writeposition + pdev->sharememhandle.Local_Instance + sizeof(sharememhead_TyepDef);
1000b358:	e51b3014 	ldr	r3, [fp, #-20]
1000b35c:	e5932000 	ldr	r2, [r3]
1000b360:	e51b3008 	ldr	r3, [fp, #-8]
1000b364:	e1a03103 	lsl	r3, r3, #2
1000b368:	e1a01103 	lsl	r1, r3, #2
1000b36c:	e0633001 	rsb	r3, r3, r1
1000b370:	e2833090 	add	r3, r3, #144	; 0x90
1000b374:	e0823003 	add	r3, r2, r3
1000b378:	e50b300c 	str	r3, [fp, #-12]
				i = 0;
1000b37c:	e3a03000 	mov	r3, #0
1000b380:	e50b3010 	str	r3, [fp, #-16]
		}
		
		*(p + i) = *(data + i); 
1000b384:	e51b3010 	ldr	r3, [fp, #-16]
1000b388:	e51b200c 	ldr	r2, [fp, #-12]
1000b38c:	e0823003 	add	r3, r2, r3
1000b390:	e51b2010 	ldr	r2, [fp, #-16]
1000b394:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
1000b398:	e0812002 	add	r2, r1, r2
1000b39c:	e5d22000 	ldrb	r2, [r2]
1000b3a0:	e5c32000 	strb	r2, [r3]

	p = writeposition + pdev->sharememhandle.Local_Instance + sizeof(sharememhead_TyepDef);
	maxlength = maxlength + pdev->sharememhandle.Local_Instance + sizeof(sharememhead_TyepDef);

	rt_kprintf("base:%x,head:%x,point:%x\r\n",pdev->sharememhandle.Local_Instance,sizeof(sharememhead_TyepDef),p);
	for(i = 0;i < size;i++)
1000b3a4:	e51b3010 	ldr	r3, [fp, #-16]
1000b3a8:	e2833001 	add	r3, r3, #1
1000b3ac:	e50b3010 	str	r3, [fp, #-16]
1000b3b0:	e51b2010 	ldr	r2, [fp, #-16]
1000b3b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000b3b8:	e1520003 	cmp	r2, r3
1000b3bc:	baffffdd 	blt	1000b338 <sharemem_writemem+0xec>
				i = 0;
		}
		
		*(p + i) = *(data + i); 
	}
	pdev->sharememhandle.Local_Instance->writeposition = i + writeposition;
1000b3c0:	e51b3014 	ldr	r3, [fp, #-20]
1000b3c4:	e5933000 	ldr	r3, [r3]
1000b3c8:	e51b1010 	ldr	r1, [fp, #-16]
1000b3cc:	e51b2008 	ldr	r2, [fp, #-8]
1000b3d0:	e0812002 	add	r2, r1, r2
1000b3d4:	e5832004 	str	r2, [r3, #4]

	return RT_EOK;
1000b3d8:	e3a03000 	mov	r3, #0
}
1000b3dc:	e1a00003 	mov	r0, r3
1000b3e0:	e24bd004 	sub	sp, fp, #4
1000b3e4:	e8bd8800 	pop	{fp, pc}

1000b3e8 <sharemem_hw_init>:
    sharemem_writemem,
};


int sharemem_hw_init(void)
{
1000b3e8:	e92d4800 	push	{fp, lr}
1000b3ec:	e28db004 	add	fp, sp, #4
1000b3f0:	e24dd010 	sub	sp, sp, #16

	
	struct sharemem_configure sharemem_config = RT_SHAREMEM_CONFIG_DEFAULT;
1000b3f4:	e3a03000 	mov	r3, #0
1000b3f8:	e50b3010 	str	r3, [fp, #-16]
1000b3fc:	e3a03000 	mov	r3, #0
1000b400:	e50b300c 	str	r3, [fp, #-12]
1000b404:	e3a03a06 	mov	r3, #24576	; 0x6000
1000b408:	e50b3008 	str	r3, [fp, #-8]
	sharemem_device1.config = sharemem_config;
1000b40c:	e3023948 	movw	r3, #10568	; 0x2948
1000b410:	e3413004 	movt	r3, #4100	; 0x1004
1000b414:	e2833040 	add	r3, r3, #64	; 0x40
1000b418:	e24b2010 	sub	r2, fp, #16
1000b41c:	e8920007 	ldm	r2, {r0, r1, r2}
1000b420:	e8830007 	stm	r3, {r0, r1, r2}
	
	sharemem_device1.ops = &_sharemem_ops;
1000b424:	e3023948 	movw	r3, #10568	; 0x2948
1000b428:	e3413004 	movt	r3, #4100	; 0x1004
1000b42c:	e3022c1c 	movw	r2, #11292	; 0x2c1c
1000b430:	e3412003 	movt	r2, #4099	; 0x1003
1000b434:	e583203c 	str	r2, [r3, #60]	; 0x3c
	
	sharemem_handle.Local_Instance = SHAREMEMHEAD_BASEADDR;
1000b438:	e302299c 	movw	r2, #10652	; 0x299c
1000b43c:	e3412004 	movt	r2, #4100	; 0x1004
1000b440:	e3a03000 	mov	r3, #0
1000b444:	e34f3fff 	movt	r3, #65535	; 0xffff
1000b448:	e5823000 	str	r3, [r2]
	//sharemem_handle.irq_nr = CPU1_IRQF2P0_ID;

	sharemem_hw_device1.sharememhandle= sharemem_handle;
1000b44c:	e3022994 	movw	r2, #10644	; 0x2994
1000b450:	e3412004 	movt	r2, #4100	; 0x1004
1000b454:	e302399c 	movw	r3, #10652	; 0x299c
1000b458:	e3413004 	movt	r3, #4100	; 0x1004
1000b45c:	e8930003 	ldm	r3, {r0, r1}
1000b460:	e8820003 	stm	r2, {r0, r1}

	rt_hw_sharemem_register(&sharemem_device1, "sharemem1",
1000b464:	e3020948 	movw	r0, #10568	; 0x2948
1000b468:	e3410004 	movt	r0, #4100	; 0x1004
1000b46c:	e3021c24 	movw	r1, #11300	; 0x2c24
1000b470:	e3411003 	movt	r1, #4099	; 0x1003
1000b474:	e3a02002 	mov	r2, #2
1000b478:	e3023994 	movw	r3, #10644	; 0x2994
1000b47c:	e3413004 	movt	r3, #4100	; 0x1004
1000b480:	eb00038a 	bl	1000c2b0 <rt_hw_sharemem_register>
                          RT_DEVICE_FLAG_WRONLY,
                          &sharemem_hw_device1);

	return 0;
1000b484:	e3a03000 	mov	r3, #0

}
1000b488:	e1a00003 	mov	r0, r3
1000b48c:	e24bd004 	sub	sp, fp, #4
1000b490:	e8bd8800 	pop	{fp, pc}

1000b494 <rt_motor_misc_init>:
#include <rtdevice.h>
#include "motor_misc.h"


static rt_err_t rt_motor_misc_init(struct rt_device *dev)
{
1000b494:	e92d4800 	push	{fp, lr}
1000b498:	e28db004 	add	fp, sp, #4
1000b49c:	e24dd010 	sub	sp, sp, #16
1000b4a0:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000b4a4:	e3a03000 	mov	r3, #0
1000b4a8:	e50b3008 	str	r3, [fp, #-8]
    struct rt_motor_misc_device *motor_miscdev;

    RT_ASSERT(dev != RT_NULL);
1000b4ac:	e51b3010 	ldr	r3, [fp, #-16]
1000b4b0:	e3530000 	cmp	r3, #0
1000b4b4:	1a000005 	bne	1000b4d0 <rt_motor_misc_init+0x3c>
1000b4b8:	e3020c58 	movw	r0, #11352	; 0x2c58
1000b4bc:	e3410003 	movt	r0, #4099	; 0x1003
1000b4c0:	e3021c98 	movw	r1, #11416	; 0x2c98
1000b4c4:	e3411003 	movt	r1, #4099	; 0x1003
1000b4c8:	e3a0200e 	mov	r2, #14
1000b4cc:	eb002238 	bl	10013db4 <rt_assert_handler>
    motor_miscdev = (struct rt_motor_misc_device *)dev;
1000b4d0:	e51b3010 	ldr	r3, [fp, #-16]
1000b4d4:	e50b300c 	str	r3, [fp, #-12]

    /* apply configuration */
    if (motor_miscdev->ops->configure)
1000b4d8:	e51b300c 	ldr	r3, [fp, #-12]
1000b4dc:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000b4e0:	e5933000 	ldr	r3, [r3]
1000b4e4:	e3530000 	cmp	r3, #0
1000b4e8:	0a000008 	beq	1000b510 <rt_motor_misc_init+0x7c>
        result = motor_miscdev->ops->configure(motor_miscdev, &motor_miscdev->config);
1000b4ec:	e51b300c 	ldr	r3, [fp, #-12]
1000b4f0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000b4f4:	e5933000 	ldr	r3, [r3]
1000b4f8:	e51b200c 	ldr	r2, [fp, #-12]
1000b4fc:	e2822040 	add	r2, r2, #64	; 0x40
1000b500:	e51b000c 	ldr	r0, [fp, #-12]
1000b504:	e1a01002 	mov	r1, r2
1000b508:	e12fff33 	blx	r3
1000b50c:	e50b0008 	str	r0, [fp, #-8]
    return result;
1000b510:	e51b3008 	ldr	r3, [fp, #-8]
}
1000b514:	e1a00003 	mov	r0, r3
1000b518:	e24bd004 	sub	sp, fp, #4
1000b51c:	e8bd8800 	pop	{fp, pc}

1000b520 <rt_motor_misc_open>:

static rt_err_t rt_motor_misc_open(struct rt_device *dev, rt_uint16_t oflag)
{
1000b520:	e92d4800 	push	{fp, lr}
1000b524:	e28db004 	add	fp, sp, #4
1000b528:	e24dd010 	sub	sp, sp, #16
1000b52c:	e50b0010 	str	r0, [fp, #-16]
1000b530:	e1a03001 	mov	r3, r1
1000b534:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    rt_err_t result = RT_EOK;
1000b538:	e3a03000 	mov	r3, #0
1000b53c:	e50b3008 	str	r3, [fp, #-8]
    struct rt_motor_misc_device *motor_miscdev;

    RT_ASSERT(dev != RT_NULL);
1000b540:	e51b3010 	ldr	r3, [fp, #-16]
1000b544:	e3530000 	cmp	r3, #0
1000b548:	1a000005 	bne	1000b564 <rt_motor_misc_open+0x44>
1000b54c:	e3020c58 	movw	r0, #11352	; 0x2c58
1000b550:	e3410003 	movt	r0, #4099	; 0x1003
1000b554:	e3021cac 	movw	r1, #11436	; 0x2cac
1000b558:	e3411003 	movt	r1, #4099	; 0x1003
1000b55c:	e3a0201c 	mov	r2, #28
1000b560:	eb002213 	bl	10013db4 <rt_assert_handler>
    motor_miscdev = (struct rt_motor_misc_device *)dev;
1000b564:	e51b3010 	ldr	r3, [fp, #-16]
1000b568:	e50b300c 	str	r3, [fp, #-12]
	//result = motor_miscdev->ops->control(motor_miscdev,CMD_INTENABLE,0);
	
	return result;
1000b56c:	e51b3008 	ldr	r3, [fp, #-8]
}
1000b570:	e1a00003 	mov	r0, r3
1000b574:	e24bd004 	sub	sp, fp, #4
1000b578:	e8bd8800 	pop	{fp, pc}

1000b57c <rt_motor_misc_close>:

static rt_err_t rt_motor_misc_close(struct rt_device *dev)
{
1000b57c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000b580:	e28db000 	add	fp, sp, #0
1000b584:	e24dd014 	sub	sp, sp, #20
1000b588:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000b58c:	e3a03000 	mov	r3, #0
1000b590:	e50b3008 	str	r3, [fp, #-8]

    return result;
1000b594:	e51b3008 	ldr	r3, [fp, #-8]
}
1000b598:	e1a00003 	mov	r0, r3
1000b59c:	e24bd000 	sub	sp, fp, #0
1000b5a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000b5a4:	e12fff1e 	bx	lr

1000b5a8 <rt_motor_misc_control>:
static rt_err_t rt_motor_misc_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
1000b5a8:	e92d4800 	push	{fp, lr}
1000b5ac:	e28db004 	add	fp, sp, #4
1000b5b0:	e24dd018 	sub	sp, sp, #24
1000b5b4:	e50b0010 	str	r0, [fp, #-16]
1000b5b8:	e1a03001 	mov	r3, r1
1000b5bc:	e50b2018 	str	r2, [fp, #-24]
1000b5c0:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_motor_misc_device *motor_miscdev;

    RT_ASSERT(dev != RT_NULL);
1000b5c4:	e51b3010 	ldr	r3, [fp, #-16]
1000b5c8:	e3530000 	cmp	r3, #0
1000b5cc:	1a000005 	bne	1000b5e8 <rt_motor_misc_control+0x40>
1000b5d0:	e3020c58 	movw	r0, #11352	; 0x2c58
1000b5d4:	e3410003 	movt	r0, #4099	; 0x1003
1000b5d8:	e3021cc0 	movw	r1, #11456	; 0x2cc0
1000b5dc:	e3411003 	movt	r1, #4099	; 0x1003
1000b5e0:	e3a0202f 	mov	r2, #47	; 0x2f
1000b5e4:	eb0021f2 	bl	10013db4 <rt_assert_handler>
    motor_miscdev = (struct rt_motor_misc_device *)dev;
1000b5e8:	e51b3010 	ldr	r3, [fp, #-16]
1000b5ec:	e50b3008 	str	r3, [fp, #-8]

    /* control device */
    motor_miscdev->ops->control(motor_miscdev, cmd, args);
1000b5f0:	e51b3008 	ldr	r3, [fp, #-8]
1000b5f4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000b5f8:	e5933004 	ldr	r3, [r3, #4]
1000b5fc:	e55b2011 	ldrb	r2, [fp, #-17]
1000b600:	e51b0008 	ldr	r0, [fp, #-8]
1000b604:	e1a01002 	mov	r1, r2
1000b608:	e51b2018 	ldr	r2, [fp, #-24]
1000b60c:	e12fff33 	blx	r3

    return RT_EOK;
1000b610:	e3a03000 	mov	r3, #0
}
1000b614:	e1a00003 	mov	r0, r3
1000b618:	e24bd004 	sub	sp, fp, #4
1000b61c:	e8bd8800 	pop	{fp, pc}

1000b620 <rt_motor_misc_read>:
static rt_size_t rt_motor_misc_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)

{
1000b620:	e92d4800 	push	{fp, lr}
1000b624:	e28db004 	add	fp, sp, #4
1000b628:	e24dd020 	sub	sp, sp, #32
1000b62c:	e50b0018 	str	r0, [fp, #-24]
1000b630:	e50b101c 	str	r1, [fp, #-28]
1000b634:	e50b2020 	str	r2, [fp, #-32]
1000b638:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    struct rt_motor_misc_device *motor_miscdev;
	unsigned long *pmotor_miscvalue,motor_miscvalue;

    RT_ASSERT(dev != RT_NULL);
1000b63c:	e51b3018 	ldr	r3, [fp, #-24]
1000b640:	e3530000 	cmp	r3, #0
1000b644:	1a000005 	bne	1000b660 <rt_motor_misc_read+0x40>
1000b648:	e3020c58 	movw	r0, #11352	; 0x2c58
1000b64c:	e3410003 	movt	r0, #4099	; 0x1003
1000b650:	e3021cd8 	movw	r1, #11480	; 0x2cd8
1000b654:	e3411003 	movt	r1, #4099	; 0x1003
1000b658:	e3a02041 	mov	r2, #65	; 0x41
1000b65c:	eb0021d4 	bl	10013db4 <rt_assert_handler>
    motor_miscdev = (struct rt_motor_misc_device *)dev;
1000b660:	e51b3018 	ldr	r3, [fp, #-24]
1000b664:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(buffer != RT_NULL);
1000b668:	e51b3020 	ldr	r3, [fp, #-32]
1000b66c:	e3530000 	cmp	r3, #0
1000b670:	1a000005 	bne	1000b68c <rt_motor_misc_read+0x6c>
1000b674:	e3020c68 	movw	r0, #11368	; 0x2c68
1000b678:	e3410003 	movt	r0, #4099	; 0x1003
1000b67c:	e3021cd8 	movw	r1, #11480	; 0x2cd8
1000b680:	e3411003 	movt	r1, #4099	; 0x1003
1000b684:	e3a02044 	mov	r2, #68	; 0x44
1000b688:	eb0021c9 	bl	10013db4 <rt_assert_handler>
    pmotor_miscvalue = (unsigned long *)buffer;
1000b68c:	e51b3020 	ldr	r3, [fp, #-32]
1000b690:	e50b300c 	str	r3, [fp, #-12]
	
	motor_miscvalue = motor_miscdev->ops->getIntrState(motor_miscdev);
1000b694:	e51b3008 	ldr	r3, [fp, #-8]
1000b698:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000b69c:	e5933008 	ldr	r3, [r3, #8]
1000b6a0:	e51b0008 	ldr	r0, [fp, #-8]
1000b6a4:	e12fff33 	blx	r3
1000b6a8:	e50b0010 	str	r0, [fp, #-16]

	*pmotor_miscvalue = motor_miscvalue;
1000b6ac:	e51b300c 	ldr	r3, [fp, #-12]
1000b6b0:	e51b2010 	ldr	r2, [fp, #-16]
1000b6b4:	e5832000 	str	r2, [r3]
	
    return 1;
1000b6b8:	e3a03001 	mov	r3, #1
}
1000b6bc:	e1a00003 	mov	r0, r3
1000b6c0:	e24bd004 	sub	sp, fp, #4
1000b6c4:	e8bd8800 	pop	{fp, pc}

1000b6c8 <rt_hw_motor_misc_register>:

rt_err_t rt_hw_motor_misc_register(struct rt_motor_misc_device *motor_miscdev,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
1000b6c8:	e92d4800 	push	{fp, lr}
1000b6cc:	e28db004 	add	fp, sp, #4
1000b6d0:	e24dd018 	sub	sp, sp, #24
1000b6d4:	e50b0010 	str	r0, [fp, #-16]
1000b6d8:	e50b1014 	str	r1, [fp, #-20]
1000b6dc:	e50b2018 	str	r2, [fp, #-24]
1000b6e0:	e50b301c 	str	r3, [fp, #-28]
    struct rt_device *device;
    RT_ASSERT(motor_miscdev != RT_NULL);
1000b6e4:	e51b3010 	ldr	r3, [fp, #-16]
1000b6e8:	e3530000 	cmp	r3, #0
1000b6ec:	1a000005 	bne	1000b708 <rt_hw_motor_misc_register+0x40>
1000b6f0:	e3020c7c 	movw	r0, #11388	; 0x2c7c
1000b6f4:	e3410003 	movt	r0, #4099	; 0x1003
1000b6f8:	e3021cec 	movw	r1, #11500	; 0x2cec
1000b6fc:	e3411003 	movt	r1, #4099	; 0x1003
1000b700:	e3a02054 	mov	r2, #84	; 0x54
1000b704:	eb0021aa 	bl	10013db4 <rt_assert_handler>

    device = &(motor_miscdev->parent);
1000b708:	e51b3010 	ldr	r3, [fp, #-16]
1000b70c:	e50b3008 	str	r3, [fp, #-8]

    device->type        = RT_Device_Class_Miscellaneous;
1000b710:	e51b3008 	ldr	r3, [fp, #-8]
1000b714:	e3a02012 	mov	r2, #18
1000b718:	e5c32010 	strb	r2, [r3, #16]
    device->rx_indicate = RT_NULL;
1000b71c:	e51b3008 	ldr	r3, [fp, #-8]
1000b720:	e3a02000 	mov	r2, #0
1000b724:	e5832018 	str	r2, [r3, #24]
    device->tx_complete = RT_NULL;
1000b728:	e51b3008 	ldr	r3, [fp, #-8]
1000b72c:	e3a02000 	mov	r2, #0
1000b730:	e583201c 	str	r2, [r3, #28]

    device->init        = rt_motor_misc_init;
1000b734:	e51b2008 	ldr	r2, [fp, #-8]
1000b738:	e30b3494 	movw	r3, #46228	; 0xb494
1000b73c:	e3413000 	movt	r3, #4096	; 0x1000
1000b740:	e5823020 	str	r3, [r2, #32]
    device->open        = rt_motor_misc_open;
1000b744:	e51b2008 	ldr	r2, [fp, #-8]
1000b748:	e30b3520 	movw	r3, #46368	; 0xb520
1000b74c:	e3413000 	movt	r3, #4096	; 0x1000
1000b750:	e5823024 	str	r3, [r2, #36]	; 0x24
    device->close       = rt_motor_misc_close;
1000b754:	e51b2008 	ldr	r2, [fp, #-8]
1000b758:	e30b357c 	movw	r3, #46460	; 0xb57c
1000b75c:	e3413000 	movt	r3, #4096	; 0x1000
1000b760:	e5823028 	str	r3, [r2, #40]	; 0x28
    device->control     = rt_motor_misc_control;
1000b764:	e51b2008 	ldr	r2, [fp, #-8]
1000b768:	e30b35a8 	movw	r3, #46504	; 0xb5a8
1000b76c:	e3413000 	movt	r3, #4096	; 0x1000
1000b770:	e5823034 	str	r3, [r2, #52]	; 0x34
    device->read        = rt_motor_misc_read;
1000b774:	e51b2008 	ldr	r2, [fp, #-8]
1000b778:	e30b3620 	movw	r3, #46624	; 0xb620
1000b77c:	e3413000 	movt	r3, #4096	; 0x1000
1000b780:	e582302c 	str	r3, [r2, #44]	; 0x2c
    device->user_data   = data;
1000b784:	e51b3008 	ldr	r3, [fp, #-8]
1000b788:	e51b201c 	ldr	r2, [fp, #-28]
1000b78c:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* register a character device */
    return rt_device_register(device, name, flag);
1000b790:	e51b3018 	ldr	r3, [fp, #-24]
1000b794:	e6ff3073 	uxth	r3, r3
1000b798:	e51b0008 	ldr	r0, [fp, #-8]
1000b79c:	e51b1014 	ldr	r1, [fp, #-20]
1000b7a0:	e1a02003 	mov	r2, r3
1000b7a4:	eb000b6d 	bl	1000e560 <rt_device_register>
1000b7a8:	e1a03000 	mov	r3, r0
}
1000b7ac:	e1a00003 	mov	r0, r3
1000b7b0:	e24bd004 	sub	sp, fp, #4
1000b7b4:	e8bd8800 	pop	{fp, pc}

1000b7b8 <qep_read_cnt>:
/***************************** Include Files *******************************/
#include "myqep.h"


int qep_read_cnt(Qep_HandleTypeDef *qep_handle)
{
1000b7b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000b7bc:	e28db000 	add	fp, sp, #0
1000b7c0:	e24dd00c 	sub	sp, sp, #12
1000b7c4:	e50b0008 	str	r0, [fp, #-8]
	if(qep_handle == NULL)
1000b7c8:	e51b3008 	ldr	r3, [fp, #-8]
1000b7cc:	e3530000 	cmp	r3, #0
1000b7d0:	1a000001 	bne	1000b7dc <qep_read_cnt+0x24>
	{
		return MYIP_ERROR;
1000b7d4:	e3a03000 	mov	r3, #0
1000b7d8:	ea000002 	b	1000b7e8 <qep_read_cnt+0x30>
	}
	return qep_handle->Instance->cnt_eg;
1000b7dc:	e51b3008 	ldr	r3, [fp, #-8]
1000b7e0:	e5933000 	ldr	r3, [r3]
1000b7e4:	e5933000 	ldr	r3, [r3]
}
1000b7e8:	e1a00003 	mov	r0, r3
1000b7ec:	e24bd000 	sub	sp, fp, #0
1000b7f0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000b7f4:	e12fff1e 	bx	lr

1000b7f8 <qep_read_turn>:

int qep_read_turn(Qep_HandleTypeDef *qep_handle)
{
1000b7f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000b7fc:	e28db000 	add	fp, sp, #0
1000b800:	e24dd00c 	sub	sp, sp, #12
1000b804:	e50b0008 	str	r0, [fp, #-8]
	if(qep_handle == NULL)
1000b808:	e51b3008 	ldr	r3, [fp, #-8]
1000b80c:	e3530000 	cmp	r3, #0
1000b810:	1a000001 	bne	1000b81c <qep_read_turn+0x24>
	{
		return MYIP_ERROR;
1000b814:	e3a03000 	mov	r3, #0
1000b818:	ea000002 	b	1000b828 <qep_read_turn+0x30>
	}

	return qep_handle->Instance->turn_cnt_reg;
1000b81c:	e51b3008 	ldr	r3, [fp, #-8]
1000b820:	e5933000 	ldr	r3, [r3]
1000b824:	e593300c 	ldr	r3, [r3, #12]
}
1000b828:	e1a00003 	mov	r0, r3
1000b82c:	e24bd000 	sub	sp, fp, #0
1000b830:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000b834:	e12fff1e 	bx	lr

1000b838 <qep_set_period>:

int qep_set_period(Qep_HandleTypeDef *qep_handle,unsigned int period)
{
1000b838:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000b83c:	e28db000 	add	fp, sp, #0
1000b840:	e24dd00c 	sub	sp, sp, #12
1000b844:	e50b0008 	str	r0, [fp, #-8]
1000b848:	e50b100c 	str	r1, [fp, #-12]
	if(qep_handle == NULL)
1000b84c:	e51b3008 	ldr	r3, [fp, #-8]
1000b850:	e3530000 	cmp	r3, #0
1000b854:	1a000001 	bne	1000b860 <qep_set_period+0x28>
	{
		return MYIP_ERROR;
1000b858:	e3a03000 	mov	r3, #0
1000b85c:	ea000010 	b	1000b8a4 <qep_set_period+0x6c>
	}
	if(qep_handle->state == MYIP_STATE_READY)
1000b860:	e51b3008 	ldr	r3, [fp, #-8]
1000b864:	e5933010 	ldr	r3, [r3, #16]
1000b868:	e3530002 	cmp	r3, #2
1000b86c:	1a00000b 	bne	1000b8a0 <qep_set_period+0x68>
	{
		qep_handle->state = MYIP_STATE_BUSY;
1000b870:	e51b3008 	ldr	r3, [fp, #-8]
1000b874:	e3a02001 	mov	r2, #1
1000b878:	e5832010 	str	r2, [r3, #16]
		
		qep_handle->Instance->turn_reg = period;
1000b87c:	e51b3008 	ldr	r3, [fp, #-8]
1000b880:	e5933000 	ldr	r3, [r3]
1000b884:	e51b200c 	ldr	r2, [fp, #-12]
1000b888:	e5832004 	str	r2, [r3, #4]
		qep_handle->state = MYIP_STATE_READY;
1000b88c:	e51b3008 	ldr	r3, [fp, #-8]
1000b890:	e3a02002 	mov	r2, #2
1000b894:	e5832010 	str	r2, [r3, #16]
		return MYIP_SUCCESS;
1000b898:	e3a03001 	mov	r3, #1
1000b89c:	ea000000 	b	1000b8a4 <qep_set_period+0x6c>
	}
	return MYIP_BUSY;
1000b8a0:	e3a03002 	mov	r3, #2
}
1000b8a4:	e1a00003 	mov	r0, r3
1000b8a8:	e24bd000 	sub	sp, fp, #0
1000b8ac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000b8b0:	e12fff1e 	bx	lr

1000b8b4 <qep_enable>:

int qep_enable(Qep_HandleTypeDef *qep_handle)
{
1000b8b4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000b8b8:	e28db000 	add	fp, sp, #0
1000b8bc:	e24dd014 	sub	sp, sp, #20
1000b8c0:	e50b0010 	str	r0, [fp, #-16]
	unsigned int temp;

	if(qep_handle == NULL)
1000b8c4:	e51b3010 	ldr	r3, [fp, #-16]
1000b8c8:	e3530000 	cmp	r3, #0
1000b8cc:	1a000001 	bne	1000b8d8 <qep_enable+0x24>
	{
		return MYIP_ERROR;
1000b8d0:	e3a03000 	mov	r3, #0
1000b8d4:	ea000017 	b	1000b938 <qep_enable+0x84>
	}
	if(qep_handle->state == MYIP_STATE_READY)
1000b8d8:	e51b3010 	ldr	r3, [fp, #-16]
1000b8dc:	e5933010 	ldr	r3, [r3, #16]
1000b8e0:	e3530002 	cmp	r3, #2
1000b8e4:	1a000012 	bne	1000b934 <qep_enable+0x80>
	{
		qep_handle->state = MYIP_STATE_BUSY;
1000b8e8:	e51b3010 	ldr	r3, [fp, #-16]
1000b8ec:	e3a02001 	mov	r2, #1
1000b8f0:	e5832010 	str	r2, [r3, #16]
		temp = qep_handle->Instance->ctrl_reg;
1000b8f4:	e51b3010 	ldr	r3, [fp, #-16]
1000b8f8:	e5933000 	ldr	r3, [r3]
1000b8fc:	e5933008 	ldr	r3, [r3, #8]
1000b900:	e50b3008 	str	r3, [fp, #-8]
		temp |= 0x80000000;
1000b904:	e51b3008 	ldr	r3, [fp, #-8]
1000b908:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
1000b90c:	e50b3008 	str	r3, [fp, #-8]
		qep_handle->Instance->ctrl_reg = temp;
1000b910:	e51b3010 	ldr	r3, [fp, #-16]
1000b914:	e5933000 	ldr	r3, [r3]
1000b918:	e51b2008 	ldr	r2, [fp, #-8]
1000b91c:	e5832008 	str	r2, [r3, #8]
		qep_handle->state = MYIP_STATE_READY;
1000b920:	e51b3010 	ldr	r3, [fp, #-16]
1000b924:	e3a02002 	mov	r2, #2
1000b928:	e5832010 	str	r2, [r3, #16]
		return MYIP_SUCCESS;
1000b92c:	e3a03001 	mov	r3, #1
1000b930:	ea000000 	b	1000b938 <qep_enable+0x84>
	}
	return MYIP_BUSY;
1000b934:	e3a03002 	mov	r3, #2
		
}
1000b938:	e1a00003 	mov	r0, r3
1000b93c:	e24bd000 	sub	sp, fp, #0
1000b940:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000b944:	e12fff1e 	bx	lr

1000b948 <qep_disable>:

unsigned char qep_disable(Qep_HandleTypeDef *qep_handle)
{
1000b948:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000b94c:	e28db000 	add	fp, sp, #0
1000b950:	e24dd014 	sub	sp, sp, #20
1000b954:	e50b0010 	str	r0, [fp, #-16]
	unsigned int temp;

	if(qep_handle == NULL)
1000b958:	e51b3010 	ldr	r3, [fp, #-16]
1000b95c:	e3530000 	cmp	r3, #0
1000b960:	1a000001 	bne	1000b96c <qep_disable+0x24>
	{
		return MYIP_ERROR;
1000b964:	e3a03000 	mov	r3, #0
1000b968:	ea000017 	b	1000b9cc <qep_disable+0x84>
	}
	if(qep_handle->state == MYIP_STATE_READY)
1000b96c:	e51b3010 	ldr	r3, [fp, #-16]
1000b970:	e5933010 	ldr	r3, [r3, #16]
1000b974:	e3530002 	cmp	r3, #2
1000b978:	1a000012 	bne	1000b9c8 <qep_disable+0x80>
	{
		qep_handle->state = MYIP_STATE_BUSY;
1000b97c:	e51b3010 	ldr	r3, [fp, #-16]
1000b980:	e3a02001 	mov	r2, #1
1000b984:	e5832010 	str	r2, [r3, #16]
		temp = qep_handle->Instance->ctrl_reg;
1000b988:	e51b3010 	ldr	r3, [fp, #-16]
1000b98c:	e5933000 	ldr	r3, [r3]
1000b990:	e5933008 	ldr	r3, [r3, #8]
1000b994:	e50b3008 	str	r3, [fp, #-8]
		temp &= 0x7fffffff;
1000b998:	e51b3008 	ldr	r3, [fp, #-8]
1000b99c:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
1000b9a0:	e50b3008 	str	r3, [fp, #-8]
		qep_handle->Instance->ctrl_reg = temp;
1000b9a4:	e51b3010 	ldr	r3, [fp, #-16]
1000b9a8:	e5933000 	ldr	r3, [r3]
1000b9ac:	e51b2008 	ldr	r2, [fp, #-8]
1000b9b0:	e5832008 	str	r2, [r3, #8]
		qep_handle->state = MYIP_STATE_READY;
1000b9b4:	e51b3010 	ldr	r3, [fp, #-16]
1000b9b8:	e3a02002 	mov	r2, #2
1000b9bc:	e5832010 	str	r2, [r3, #16]
		return MYIP_SUCCESS;
1000b9c0:	e3a03001 	mov	r3, #1
1000b9c4:	ea000000 	b	1000b9cc <qep_disable+0x84>
	}
	return MYIP_BUSY;
1000b9c8:	e3a03002 	mov	r3, #2
}
1000b9cc:	e1a00003 	mov	r0, r3
1000b9d0:	e24bd000 	sub	sp, fp, #0
1000b9d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000b9d8:	e12fff1e 	bx	lr

1000b9dc <qep_set_mode>:

int qep_set_mode(Qep_HandleTypeDef *qep_handle, unsigned int mod)
{
1000b9dc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000b9e0:	e28db000 	add	fp, sp, #0
1000b9e4:	e24dd014 	sub	sp, sp, #20
1000b9e8:	e50b0010 	str	r0, [fp, #-16]
1000b9ec:	e50b1014 	str	r1, [fp, #-20]
	unsigned int temp;

	if(qep_handle == NULL)
1000b9f0:	e51b3010 	ldr	r3, [fp, #-16]
1000b9f4:	e3530000 	cmp	r3, #0
1000b9f8:	1a000001 	bne	1000ba04 <qep_set_mode+0x28>
	{
		return MYIP_ERROR;
1000b9fc:	e3a03000 	mov	r3, #0
1000ba00:	ea000026 	b	1000baa0 <qep_set_mode+0xc4>
	}
	
	if(mod != QEP_MOD1 && mod != QEP_MOD2 && mod != QEP_MOD3)
1000ba04:	e51b3014 	ldr	r3, [fp, #-20]
1000ba08:	e3530001 	cmp	r3, #1
1000ba0c:	0a000007 	beq	1000ba30 <qep_set_mode+0x54>
1000ba10:	e51b3014 	ldr	r3, [fp, #-20]
1000ba14:	e3530002 	cmp	r3, #2
1000ba18:	0a000004 	beq	1000ba30 <qep_set_mode+0x54>
1000ba1c:	e51b3014 	ldr	r3, [fp, #-20]
1000ba20:	e3530003 	cmp	r3, #3
1000ba24:	0a000001 	beq	1000ba30 <qep_set_mode+0x54>
	{
		return MYIP_ERROR;
1000ba28:	e3a03000 	mov	r3, #0
1000ba2c:	ea00001b 	b	1000baa0 <qep_set_mode+0xc4>
	}

	
	if(qep_handle->state == MYIP_STATE_READY)
1000ba30:	e51b3010 	ldr	r3, [fp, #-16]
1000ba34:	e5933010 	ldr	r3, [r3, #16]
1000ba38:	e3530002 	cmp	r3, #2
1000ba3c:	1a000016 	bne	1000ba9c <qep_set_mode+0xc0>
	{
		qep_handle->state = MYIP_STATE_BUSY;
1000ba40:	e51b3010 	ldr	r3, [fp, #-16]
1000ba44:	e3a02001 	mov	r2, #1
1000ba48:	e5832010 	str	r2, [r3, #16]
		temp = qep_handle->Instance->ctrl_reg;
1000ba4c:	e51b3010 	ldr	r3, [fp, #-16]
1000ba50:	e5933000 	ldr	r3, [r3]
1000ba54:	e5933008 	ldr	r3, [r3, #8]
1000ba58:	e50b3008 	str	r3, [fp, #-8]
		temp &= 0xfffffffc;
1000ba5c:	e51b3008 	ldr	r3, [fp, #-8]
1000ba60:	e3c33003 	bic	r3, r3, #3
1000ba64:	e50b3008 	str	r3, [fp, #-8]
		temp |= mod;
1000ba68:	e51b2008 	ldr	r2, [fp, #-8]
1000ba6c:	e51b3014 	ldr	r3, [fp, #-20]
1000ba70:	e1823003 	orr	r3, r2, r3
1000ba74:	e50b3008 	str	r3, [fp, #-8]
		qep_handle->Instance->ctrl_reg = temp;
1000ba78:	e51b3010 	ldr	r3, [fp, #-16]
1000ba7c:	e5933000 	ldr	r3, [r3]
1000ba80:	e51b2008 	ldr	r2, [fp, #-8]
1000ba84:	e5832008 	str	r2, [r3, #8]
		qep_handle->state = MYIP_STATE_READY;
1000ba88:	e51b3010 	ldr	r3, [fp, #-16]
1000ba8c:	e3a02002 	mov	r2, #2
1000ba90:	e5832010 	str	r2, [r3, #16]
		return MYIP_SUCCESS;
1000ba94:	e3a03001 	mov	r3, #1
1000ba98:	ea000000 	b	1000baa0 <qep_set_mode+0xc4>
	}
	return MYIP_BUSY;
1000ba9c:	e3a03002 	mov	r3, #2
}
1000baa0:	e1a00003 	mov	r0, r3
1000baa4:	e24bd000 	sub	sp, fp, #0
1000baa8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000baac:	e12fff1e 	bx	lr

1000bab0 <QEP_Init>:

extern char QEP_Init(Qep_HandleTypeDef *qep_handle)
{
1000bab0:	e92d4800 	push	{fp, lr}
1000bab4:	e28db004 	add	fp, sp, #4
1000bab8:	e24dd008 	sub	sp, sp, #8
1000babc:	e50b0008 	str	r0, [fp, #-8]
	if(qep_handle == NULL)
1000bac0:	e51b3008 	ldr	r3, [fp, #-8]
1000bac4:	e3530000 	cmp	r3, #0
1000bac8:	1a000001 	bne	1000bad4 <QEP_Init+0x24>
	{
		return MYIP_ERROR;
1000bacc:	e3a03000 	mov	r3, #0
1000bad0:	ea000032 	b	1000bba0 <QEP_Init+0xf0>
	}
	if(qep_handle->state == MYIP_STATE_RESET)
1000bad4:	e51b3008 	ldr	r3, [fp, #-8]
1000bad8:	e5933010 	ldr	r3, [r3, #16]
1000badc:	e3530000 	cmp	r3, #0
1000bae0:	1a000004 	bne	1000baf8 <QEP_Init+0x48>
	{
		QEP_MSP_Init(qep_handle);
1000bae4:	e51b0008 	ldr	r0, [fp, #-8]
1000bae8:	ebfffd5f 	bl	1000b06c <QEP_MSP_Init>
		qep_handle->state = MYIP_STATE_READY;
1000baec:	e51b3008 	ldr	r3, [fp, #-8]
1000baf0:	e3a02002 	mov	r2, #2
1000baf4:	e5832010 	str	r2, [r3, #16]
	}
	while(qep_disable(qep_handle) != MYIP_SUCCESS);
1000baf8:	e1a00000 	nop			; (mov r0, r0)
1000bafc:	e51b0008 	ldr	r0, [fp, #-8]
1000bb00:	ebffff90 	bl	1000b948 <qep_disable>
1000bb04:	e1a03000 	mov	r3, r0
1000bb08:	e3530001 	cmp	r3, #1
1000bb0c:	1afffffa 	bne	1000bafc <QEP_Init+0x4c>
	while(qep_set_period( qep_handle,qep_handle->init.period) != MYIP_SUCCESS);
1000bb10:	e1a00000 	nop			; (mov r0, r0)
1000bb14:	e51b3008 	ldr	r3, [fp, #-8]
1000bb18:	e5933008 	ldr	r3, [r3, #8]
1000bb1c:	e51b0008 	ldr	r0, [fp, #-8]
1000bb20:	e1a01003 	mov	r1, r3
1000bb24:	ebffff43 	bl	1000b838 <qep_set_period>
1000bb28:	e1a03000 	mov	r3, r0
1000bb2c:	e3530001 	cmp	r3, #1
1000bb30:	1afffff7 	bne	1000bb14 <QEP_Init+0x64>
	while(qep_set_mode( qep_handle,qep_handle->init.mod) != MYIP_SUCCESS);
1000bb34:	e1a00000 	nop			; (mov r0, r0)
1000bb38:	e51b3008 	ldr	r3, [fp, #-8]
1000bb3c:	e5933004 	ldr	r3, [r3, #4]
1000bb40:	e51b0008 	ldr	r0, [fp, #-8]
1000bb44:	e1a01003 	mov	r1, r3
1000bb48:	ebffffa3 	bl	1000b9dc <qep_set_mode>
1000bb4c:	e1a03000 	mov	r3, r0
1000bb50:	e3530001 	cmp	r3, #1
1000bb54:	1afffff7 	bne	1000bb38 <QEP_Init+0x88>
	if(qep_handle->init.qepstate == 1)
1000bb58:	e51b3008 	ldr	r3, [fp, #-8]
1000bb5c:	e593300c 	ldr	r3, [r3, #12]
1000bb60:	e3530001 	cmp	r3, #1
1000bb64:	1a000006 	bne	1000bb84 <QEP_Init+0xd4>
		while(qep_enable(qep_handle) != MYIP_SUCCESS);
1000bb68:	e1a00000 	nop			; (mov r0, r0)
1000bb6c:	e51b0008 	ldr	r0, [fp, #-8]
1000bb70:	ebffff4f 	bl	1000b8b4 <qep_enable>
1000bb74:	e1a03000 	mov	r3, r0
1000bb78:	e3530001 	cmp	r3, #1
1000bb7c:	1afffffa 	bne	1000bb6c <QEP_Init+0xbc>
1000bb80:	ea000005 	b	1000bb9c <QEP_Init+0xec>
	else
		while(qep_disable(qep_handle) != MYIP_SUCCESS);
1000bb84:	e1a00000 	nop			; (mov r0, r0)
1000bb88:	e51b0008 	ldr	r0, [fp, #-8]
1000bb8c:	ebffff6d 	bl	1000b948 <qep_disable>
1000bb90:	e1a03000 	mov	r3, r0
1000bb94:	e3530001 	cmp	r3, #1
1000bb98:	1afffffa 	bne	1000bb88 <QEP_Init+0xd8>
		
	return MYIP_SUCCESS;
1000bb9c:	e3a03001 	mov	r3, #1
}
1000bba0:	e1a00003 	mov	r0, r3
1000bba4:	e24bd004 	sub	sp, fp, #4
1000bba8:	e8bd8800 	pop	{fp, pc}

1000bbac <rt_pwm_init>:
#include <rtdevice.h>
#include "drv_pwm.h"


static rt_err_t rt_pwm_init(struct rt_device *dev)
{
1000bbac:	e92d4800 	push	{fp, lr}
1000bbb0:	e28db004 	add	fp, sp, #4
1000bbb4:	e24dd010 	sub	sp, sp, #16
1000bbb8:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000bbbc:	e3a03000 	mov	r3, #0
1000bbc0:	e50b3008 	str	r3, [fp, #-8]
    struct rt_pwm_device *pwmdev;

    RT_ASSERT(dev != RT_NULL);
1000bbc4:	e51b3010 	ldr	r3, [fp, #-16]
1000bbc8:	e3530000 	cmp	r3, #0
1000bbcc:	1a000005 	bne	1000bbe8 <rt_pwm_init+0x3c>
1000bbd0:	e3020d08 	movw	r0, #11528	; 0x2d08
1000bbd4:	e3410003 	movt	r0, #4099	; 0x1003
1000bbd8:	e3021d30 	movw	r1, #11568	; 0x2d30
1000bbdc:	e3411003 	movt	r1, #4099	; 0x1003
1000bbe0:	e3a0200e 	mov	r2, #14
1000bbe4:	eb002072 	bl	10013db4 <rt_assert_handler>
    pwmdev = (struct rt_pwm_device *)dev;
1000bbe8:	e51b3010 	ldr	r3, [fp, #-16]
1000bbec:	e50b300c 	str	r3, [fp, #-12]
	
    /* apply configuration */
    if (pwmdev->ops->configure)
1000bbf0:	e51b300c 	ldr	r3, [fp, #-12]
1000bbf4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000bbf8:	e5933000 	ldr	r3, [r3]
1000bbfc:	e3530000 	cmp	r3, #0
1000bc00:	0a000008 	beq	1000bc28 <rt_pwm_init+0x7c>
        result = pwmdev->ops->configure(pwmdev, &pwmdev->config);
1000bc04:	e51b300c 	ldr	r3, [fp, #-12]
1000bc08:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000bc0c:	e5933000 	ldr	r3, [r3]
1000bc10:	e51b200c 	ldr	r2, [fp, #-12]
1000bc14:	e2822040 	add	r2, r2, #64	; 0x40
1000bc18:	e51b000c 	ldr	r0, [fp, #-12]
1000bc1c:	e1a01002 	mov	r1, r2
1000bc20:	e12fff33 	blx	r3
1000bc24:	e50b0008 	str	r0, [fp, #-8]
	rt_kprintf("%x\r\n", result);
1000bc28:	e3020d18 	movw	r0, #11544	; 0x2d18
1000bc2c:	e3410003 	movt	r0, #4099	; 0x1003
1000bc30:	e51b1008 	ldr	r1, [fp, #-8]
1000bc34:	eb001fa1 	bl	10013ac0 <rt_kprintf>
    return result;
1000bc38:	e51b3008 	ldr	r3, [fp, #-8]
}
1000bc3c:	e1a00003 	mov	r0, r3
1000bc40:	e24bd004 	sub	sp, fp, #4
1000bc44:	e8bd8800 	pop	{fp, pc}

1000bc48 <rt_pwm_open>:

static rt_err_t rt_pwm_open(struct rt_device *dev, rt_uint16_t oflag)
{
1000bc48:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000bc4c:	e28db000 	add	fp, sp, #0
1000bc50:	e24dd00c 	sub	sp, sp, #12
1000bc54:	e50b0008 	str	r0, [fp, #-8]
1000bc58:	e1a03001 	mov	r3, r1
1000bc5c:	e14b30ba 	strh	r3, [fp, #-10]

	return RT_EOK;
1000bc60:	e3a03000 	mov	r3, #0
}
1000bc64:	e1a00003 	mov	r0, r3
1000bc68:	e24bd000 	sub	sp, fp, #0
1000bc6c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000bc70:	e12fff1e 	bx	lr

1000bc74 <rt_pwm_close>:

static rt_err_t rt_pwm_close(struct rt_device *dev)
{
1000bc74:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000bc78:	e28db000 	add	fp, sp, #0
1000bc7c:	e24dd00c 	sub	sp, sp, #12
1000bc80:	e50b0008 	str	r0, [fp, #-8]

    return RT_EOK;
1000bc84:	e3a03000 	mov	r3, #0
}
1000bc88:	e1a00003 	mov	r0, r3
1000bc8c:	e24bd000 	sub	sp, fp, #0
1000bc90:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000bc94:	e12fff1e 	bx	lr

1000bc98 <rt_pwm_control>:
static rt_err_t rt_pwm_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
1000bc98:	e92d4800 	push	{fp, lr}
1000bc9c:	e28db004 	add	fp, sp, #4
1000bca0:	e24dd018 	sub	sp, sp, #24
1000bca4:	e50b0010 	str	r0, [fp, #-16]
1000bca8:	e1a03001 	mov	r3, r1
1000bcac:	e50b2018 	str	r2, [fp, #-24]
1000bcb0:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_pwm_device *pwmdev;

    RT_ASSERT(dev != RT_NULL);
1000bcb4:	e51b3010 	ldr	r3, [fp, #-16]
1000bcb8:	e3530000 	cmp	r3, #0
1000bcbc:	1a000005 	bne	1000bcd8 <rt_pwm_control+0x40>
1000bcc0:	e3020d08 	movw	r0, #11528	; 0x2d08
1000bcc4:	e3410003 	movt	r0, #4099	; 0x1003
1000bcc8:	e3021d3c 	movw	r1, #11580	; 0x2d3c
1000bccc:	e3411003 	movt	r1, #4099	; 0x1003
1000bcd0:	e3a02029 	mov	r2, #41	; 0x29
1000bcd4:	eb002036 	bl	10013db4 <rt_assert_handler>
    pwmdev = (struct rt_pwm_device *)dev;
1000bcd8:	e51b3010 	ldr	r3, [fp, #-16]
1000bcdc:	e50b3008 	str	r3, [fp, #-8]

    /* control device */
    pwmdev->ops->control(pwmdev, cmd, args);
1000bce0:	e51b3008 	ldr	r3, [fp, #-8]
1000bce4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000bce8:	e5933004 	ldr	r3, [r3, #4]
1000bcec:	e55b2011 	ldrb	r2, [fp, #-17]
1000bcf0:	e51b0008 	ldr	r0, [fp, #-8]
1000bcf4:	e1a01002 	mov	r1, r2
1000bcf8:	e51b2018 	ldr	r2, [fp, #-24]
1000bcfc:	e12fff33 	blx	r3

    return RT_EOK;
1000bd00:	e3a03000 	mov	r3, #0
}
1000bd04:	e1a00003 	mov	r0, r3
1000bd08:	e24bd004 	sub	sp, fp, #4
1000bd0c:	e8bd8800 	pop	{fp, pc}

1000bd10 <rt_hw_pwm_register>:

rt_err_t rt_hw_pwm_register(struct rt_pwm_device *pwm,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
1000bd10:	e92d4800 	push	{fp, lr}
1000bd14:	e28db004 	add	fp, sp, #4
1000bd18:	e24dd018 	sub	sp, sp, #24
1000bd1c:	e50b0010 	str	r0, [fp, #-16]
1000bd20:	e50b1014 	str	r1, [fp, #-20]
1000bd24:	e50b2018 	str	r2, [fp, #-24]
1000bd28:	e50b301c 	str	r3, [fp, #-28]
    struct rt_device *device;
    RT_ASSERT(pwm != RT_NULL);
1000bd2c:	e51b3010 	ldr	r3, [fp, #-16]
1000bd30:	e3530000 	cmp	r3, #0
1000bd34:	1a000005 	bne	1000bd50 <rt_hw_pwm_register+0x40>
1000bd38:	e3020d20 	movw	r0, #11552	; 0x2d20
1000bd3c:	e3410003 	movt	r0, #4099	; 0x1003
1000bd40:	e3021d4c 	movw	r1, #11596	; 0x2d4c
1000bd44:	e3411003 	movt	r1, #4099	; 0x1003
1000bd48:	e3a02039 	mov	r2, #57	; 0x39
1000bd4c:	eb002018 	bl	10013db4 <rt_assert_handler>

    device = &(pwm->parent);
1000bd50:	e51b3010 	ldr	r3, [fp, #-16]
1000bd54:	e50b3008 	str	r3, [fp, #-8]

    device->type        = RT_Device_Class_Miscellaneous;
1000bd58:	e51b3008 	ldr	r3, [fp, #-8]
1000bd5c:	e3a02012 	mov	r2, #18
1000bd60:	e5c32010 	strb	r2, [r3, #16]
    device->rx_indicate = RT_NULL;
1000bd64:	e51b3008 	ldr	r3, [fp, #-8]
1000bd68:	e3a02000 	mov	r2, #0
1000bd6c:	e5832018 	str	r2, [r3, #24]
    device->tx_complete = RT_NULL;
1000bd70:	e51b3008 	ldr	r3, [fp, #-8]
1000bd74:	e3a02000 	mov	r2, #0
1000bd78:	e583201c 	str	r2, [r3, #28]

    device->init        = rt_pwm_init;
1000bd7c:	e51b2008 	ldr	r2, [fp, #-8]
1000bd80:	e30b3bac 	movw	r3, #48044	; 0xbbac
1000bd84:	e3413000 	movt	r3, #4096	; 0x1000
1000bd88:	e5823020 	str	r3, [r2, #32]
    device->open        = rt_pwm_open;
1000bd8c:	e51b2008 	ldr	r2, [fp, #-8]
1000bd90:	e30b3c48 	movw	r3, #48200	; 0xbc48
1000bd94:	e3413000 	movt	r3, #4096	; 0x1000
1000bd98:	e5823024 	str	r3, [r2, #36]	; 0x24
    device->close       = rt_pwm_close;
1000bd9c:	e51b2008 	ldr	r2, [fp, #-8]
1000bda0:	e30b3c74 	movw	r3, #48244	; 0xbc74
1000bda4:	e3413000 	movt	r3, #4096	; 0x1000
1000bda8:	e5823028 	str	r3, [r2, #40]	; 0x28
    device->control     = rt_pwm_control;
1000bdac:	e51b2008 	ldr	r2, [fp, #-8]
1000bdb0:	e30b3c98 	movw	r3, #48280	; 0xbc98
1000bdb4:	e3413000 	movt	r3, #4096	; 0x1000
1000bdb8:	e5823034 	str	r3, [r2, #52]	; 0x34
    device->user_data   = data;
1000bdbc:	e51b3008 	ldr	r3, [fp, #-8]
1000bdc0:	e51b201c 	ldr	r2, [fp, #-28]
1000bdc4:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* register a character device */
    return rt_device_register(device, name, flag);
1000bdc8:	e51b3018 	ldr	r3, [fp, #-24]
1000bdcc:	e6ff3073 	uxth	r3, r3
1000bdd0:	e51b0008 	ldr	r0, [fp, #-8]
1000bdd4:	e51b1014 	ldr	r1, [fp, #-20]
1000bdd8:	e1a02003 	mov	r2, r3
1000bddc:	eb0009df 	bl	1000e560 <rt_device_register>
1000bde0:	e1a03000 	mov	r3, r0
}
1000bde4:	e1a00003 	mov	r0, r3
1000bde8:	e24bd004 	sub	sp, fp, #4
1000bdec:	e8bd8800 	pop	{fp, pc}

1000bdf0 <rt_qep_init>:
#include <rtdevice.h>
#include "drv_qep.h"


static rt_err_t rt_qep_init(struct rt_device *dev)
{
1000bdf0:	e92d4800 	push	{fp, lr}
1000bdf4:	e28db004 	add	fp, sp, #4
1000bdf8:	e24dd010 	sub	sp, sp, #16
1000bdfc:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000be00:	e3a03000 	mov	r3, #0
1000be04:	e50b3008 	str	r3, [fp, #-8]
    struct rt_qep_device *qepdev;

    RT_ASSERT(dev != RT_NULL);
1000be08:	e51b3010 	ldr	r3, [fp, #-16]
1000be0c:	e3530000 	cmp	r3, #0
1000be10:	1a000005 	bne	1000be2c <rt_qep_init+0x3c>
1000be14:	e3020d60 	movw	r0, #11616	; 0x2d60
1000be18:	e3410003 	movt	r0, #4099	; 0x1003
1000be1c:	e3021d94 	movw	r1, #11668	; 0x2d94
1000be20:	e3411003 	movt	r1, #4099	; 0x1003
1000be24:	e3a0200e 	mov	r2, #14
1000be28:	eb001fe1 	bl	10013db4 <rt_assert_handler>
    qepdev = (struct rt_qep_device *)dev;
1000be2c:	e51b3010 	ldr	r3, [fp, #-16]
1000be30:	e50b300c 	str	r3, [fp, #-12]

    /* apply configuration */
    if (qepdev->ops->configure)
1000be34:	e51b300c 	ldr	r3, [fp, #-12]
1000be38:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000be3c:	e5933000 	ldr	r3, [r3]
1000be40:	e3530000 	cmp	r3, #0
1000be44:	0a000008 	beq	1000be6c <rt_qep_init+0x7c>
        result = qepdev->ops->configure(qepdev, &qepdev->config);
1000be48:	e51b300c 	ldr	r3, [fp, #-12]
1000be4c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000be50:	e5933000 	ldr	r3, [r3]
1000be54:	e51b200c 	ldr	r2, [fp, #-12]
1000be58:	e2822040 	add	r2, r2, #64	; 0x40
1000be5c:	e51b000c 	ldr	r0, [fp, #-12]
1000be60:	e1a01002 	mov	r1, r2
1000be64:	e12fff33 	blx	r3
1000be68:	e50b0008 	str	r0, [fp, #-8]
	//rt_kprintf("qep init\r\n");
    return result;
1000be6c:	e51b3008 	ldr	r3, [fp, #-8]
}
1000be70:	e1a00003 	mov	r0, r3
1000be74:	e24bd004 	sub	sp, fp, #4
1000be78:	e8bd8800 	pop	{fp, pc}

1000be7c <rt_qep_open>:

static rt_err_t rt_qep_open(struct rt_device *dev, rt_uint16_t oflag)
{
1000be7c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000be80:	e28db000 	add	fp, sp, #0
1000be84:	e24dd00c 	sub	sp, sp, #12
1000be88:	e50b0008 	str	r0, [fp, #-8]
1000be8c:	e1a03001 	mov	r3, r1
1000be90:	e14b30ba 	strh	r3, [fp, #-10]
    return RT_EOK;
1000be94:	e3a03000 	mov	r3, #0
}
1000be98:	e1a00003 	mov	r0, r3
1000be9c:	e24bd000 	sub	sp, fp, #0
1000bea0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000bea4:	e12fff1e 	bx	lr

1000bea8 <rt_qep_close>:

static rt_err_t rt_qep_close(struct rt_device *dev)
{
1000bea8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000beac:	e28db000 	add	fp, sp, #0
1000beb0:	e24dd00c 	sub	sp, sp, #12
1000beb4:	e50b0008 	str	r0, [fp, #-8]

    return RT_EOK;
1000beb8:	e3a03000 	mov	r3, #0
}
1000bebc:	e1a00003 	mov	r0, r3
1000bec0:	e24bd000 	sub	sp, fp, #0
1000bec4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000bec8:	e12fff1e 	bx	lr

1000becc <rt_qep_control>:
static rt_err_t rt_qep_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
1000becc:	e92d4800 	push	{fp, lr}
1000bed0:	e28db004 	add	fp, sp, #4
1000bed4:	e24dd018 	sub	sp, sp, #24
1000bed8:	e50b0010 	str	r0, [fp, #-16]
1000bedc:	e1a03001 	mov	r3, r1
1000bee0:	e50b2018 	str	r2, [fp, #-24]
1000bee4:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_qep_device *qepdev;

    RT_ASSERT(dev != RT_NULL);
1000bee8:	e51b3010 	ldr	r3, [fp, #-16]
1000beec:	e3530000 	cmp	r3, #0
1000bef0:	1a000005 	bne	1000bf0c <rt_qep_control+0x40>
1000bef4:	e3020d60 	movw	r0, #11616	; 0x2d60
1000bef8:	e3410003 	movt	r0, #4099	; 0x1003
1000befc:	e3021da0 	movw	r1, #11680	; 0x2da0
1000bf00:	e3411003 	movt	r1, #4099	; 0x1003
1000bf04:	e3a02028 	mov	r2, #40	; 0x28
1000bf08:	eb001fa9 	bl	10013db4 <rt_assert_handler>
    qepdev = (struct rt_qep_device *)dev;
1000bf0c:	e51b3010 	ldr	r3, [fp, #-16]
1000bf10:	e50b3008 	str	r3, [fp, #-8]

    /* control device */
    qepdev->ops->control(qepdev, cmd, args);
1000bf14:	e51b3008 	ldr	r3, [fp, #-8]
1000bf18:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000bf1c:	e5933004 	ldr	r3, [r3, #4]
1000bf20:	e55b2011 	ldrb	r2, [fp, #-17]
1000bf24:	e51b0008 	ldr	r0, [fp, #-8]
1000bf28:	e1a01002 	mov	r1, r2
1000bf2c:	e51b2018 	ldr	r2, [fp, #-24]
1000bf30:	e12fff33 	blx	r3

    return RT_EOK;
1000bf34:	e3a03000 	mov	r3, #0
}
1000bf38:	e1a00003 	mov	r0, r3
1000bf3c:	e24bd004 	sub	sp, fp, #4
1000bf40:	e8bd8800 	pop	{fp, pc}

1000bf44 <rt_qep_read>:
static rt_size_t rt_qep_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)
{
1000bf44:	e92d4800 	push	{fp, lr}
1000bf48:	e28db004 	add	fp, sp, #4
1000bf4c:	e24dd028 	sub	sp, sp, #40	; 0x28
1000bf50:	e50b0018 	str	r0, [fp, #-24]
1000bf54:	e50b101c 	str	r1, [fp, #-28]
1000bf58:	e50b2020 	str	r2, [fp, #-32]
1000bf5c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	struct rt_qep_device *qepdev;
	Qep_ValueTypeDef *pqepvalue,qepvalue;

	RT_ASSERT(dev != RT_NULL);
1000bf60:	e51b3018 	ldr	r3, [fp, #-24]
1000bf64:	e3530000 	cmp	r3, #0
1000bf68:	1a000005 	bne	1000bf84 <rt_qep_read+0x40>
1000bf6c:	e3020d60 	movw	r0, #11616	; 0x2d60
1000bf70:	e3410003 	movt	r0, #4099	; 0x1003
1000bf74:	e3021db0 	movw	r1, #11696	; 0x2db0
1000bf78:	e3411003 	movt	r1, #4099	; 0x1003
1000bf7c:	e3a02038 	mov	r2, #56	; 0x38
1000bf80:	eb001f8b 	bl	10013db4 <rt_assert_handler>
	qepdev = (struct rt_qep_device *)dev;
1000bf84:	e51b3018 	ldr	r3, [fp, #-24]
1000bf88:	e50b3008 	str	r3, [fp, #-8]

	RT_ASSERT(buffer != RT_NULL);
1000bf8c:	e51b3020 	ldr	r3, [fp, #-32]
1000bf90:	e3530000 	cmp	r3, #0
1000bf94:	1a000005 	bne	1000bfb0 <rt_qep_read+0x6c>
1000bf98:	e3020d70 	movw	r0, #11632	; 0x2d70
1000bf9c:	e3410003 	movt	r0, #4099	; 0x1003
1000bfa0:	e3021db0 	movw	r1, #11696	; 0x2db0
1000bfa4:	e3411003 	movt	r1, #4099	; 0x1003
1000bfa8:	e3a0203b 	mov	r2, #59	; 0x3b
1000bfac:	eb001f80 	bl	10013db4 <rt_assert_handler>
	pqepvalue = (Qep_HandleTypeDef *)buffer;
1000bfb0:	e51b3020 	ldr	r3, [fp, #-32]
1000bfb4:	e50b300c 	str	r3, [fp, #-12]
	
	qepvalue = qepdev->ops->getQepValue(qepdev);
1000bfb8:	e51b3008 	ldr	r3, [fp, #-8]
1000bfbc:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000bfc0:	e5933008 	ldr	r3, [r3, #8]
1000bfc4:	e24b202c 	sub	r2, fp, #44	; 0x2c
1000bfc8:	e1a00002 	mov	r0, r2
1000bfcc:	e51b1008 	ldr	r1, [fp, #-8]
1000bfd0:	e12fff33 	blx	r3
1000bfd4:	e24b3014 	sub	r3, fp, #20
1000bfd8:	e24b202c 	sub	r2, fp, #44	; 0x2c
1000bfdc:	e8920003 	ldm	r2, {r0, r1}
1000bfe0:	e8830003 	stm	r3, {r0, r1}
	
	memcpy(pqepvalue,&qepvalue,sizeof(Qep_ValueTypeDef));
1000bfe4:	e24b3014 	sub	r3, fp, #20
1000bfe8:	e51b000c 	ldr	r0, [fp, #-12]
1000bfec:	e1a01003 	mov	r1, r3
1000bff0:	e3a02008 	mov	r2, #8
1000bff4:	fa008cbe 	blx	1002f2f4 <memcpy>
	
	return 1;
1000bff8:	e3a03001 	mov	r3, #1
}
1000bffc:	e1a00003 	mov	r0, r3
1000c000:	e24bd004 	sub	sp, fp, #4
1000c004:	e8bd8800 	pop	{fp, pc}

1000c008 <rt_hw_qep_register>:

rt_err_t rt_hw_qep_register(struct rt_qep_device *qep,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
1000c008:	e92d4800 	push	{fp, lr}
1000c00c:	e28db004 	add	fp, sp, #4
1000c010:	e24dd018 	sub	sp, sp, #24
1000c014:	e50b0010 	str	r0, [fp, #-16]
1000c018:	e50b1014 	str	r1, [fp, #-20]
1000c01c:	e50b2018 	str	r2, [fp, #-24]
1000c020:	e50b301c 	str	r3, [fp, #-28]
    struct rt_device *device;
    RT_ASSERT(qep != RT_NULL);
1000c024:	e51b3010 	ldr	r3, [fp, #-16]
1000c028:	e3530000 	cmp	r3, #0
1000c02c:	1a000005 	bne	1000c048 <rt_hw_qep_register+0x40>
1000c030:	e3020d84 	movw	r0, #11652	; 0x2d84
1000c034:	e3410003 	movt	r0, #4099	; 0x1003
1000c038:	e3021dbc 	movw	r1, #11708	; 0x2dbc
1000c03c:	e3411003 	movt	r1, #4099	; 0x1003
1000c040:	e3a0204c 	mov	r2, #76	; 0x4c
1000c044:	eb001f5a 	bl	10013db4 <rt_assert_handler>

    device = &(qep->parent);
1000c048:	e51b3010 	ldr	r3, [fp, #-16]
1000c04c:	e50b3008 	str	r3, [fp, #-8]

    device->type        = RT_Device_Class_Miscellaneous;
1000c050:	e51b3008 	ldr	r3, [fp, #-8]
1000c054:	e3a02012 	mov	r2, #18
1000c058:	e5c32010 	strb	r2, [r3, #16]
    device->rx_indicate = RT_NULL;
1000c05c:	e51b3008 	ldr	r3, [fp, #-8]
1000c060:	e3a02000 	mov	r2, #0
1000c064:	e5832018 	str	r2, [r3, #24]
    device->tx_complete = RT_NULL;
1000c068:	e51b3008 	ldr	r3, [fp, #-8]
1000c06c:	e3a02000 	mov	r2, #0
1000c070:	e583201c 	str	r2, [r3, #28]

    device->init        = rt_qep_init;
1000c074:	e51b2008 	ldr	r2, [fp, #-8]
1000c078:	e30b3df0 	movw	r3, #48624	; 0xbdf0
1000c07c:	e3413000 	movt	r3, #4096	; 0x1000
1000c080:	e5823020 	str	r3, [r2, #32]
    device->open        = rt_qep_open;
1000c084:	e51b2008 	ldr	r2, [fp, #-8]
1000c088:	e30b3e7c 	movw	r3, #48764	; 0xbe7c
1000c08c:	e3413000 	movt	r3, #4096	; 0x1000
1000c090:	e5823024 	str	r3, [r2, #36]	; 0x24
    device->close       = rt_qep_close;
1000c094:	e51b2008 	ldr	r2, [fp, #-8]
1000c098:	e30b3ea8 	movw	r3, #48808	; 0xbea8
1000c09c:	e3413000 	movt	r3, #4096	; 0x1000
1000c0a0:	e5823028 	str	r3, [r2, #40]	; 0x28
    device->control     = rt_qep_control;
1000c0a4:	e51b2008 	ldr	r2, [fp, #-8]
1000c0a8:	e30b3ecc 	movw	r3, #48844	; 0xbecc
1000c0ac:	e3413000 	movt	r3, #4096	; 0x1000
1000c0b0:	e5823034 	str	r3, [r2, #52]	; 0x34
	device->read        = rt_qep_read;
1000c0b4:	e51b2008 	ldr	r2, [fp, #-8]
1000c0b8:	e30b3f44 	movw	r3, #48964	; 0xbf44
1000c0bc:	e3413000 	movt	r3, #4096	; 0x1000
1000c0c0:	e582302c 	str	r3, [r2, #44]	; 0x2c
    device->user_data   = data;
1000c0c4:	e51b3008 	ldr	r3, [fp, #-8]
1000c0c8:	e51b201c 	ldr	r2, [fp, #-28]
1000c0cc:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* register a character device */
    return rt_device_register(device, name, flag);
1000c0d0:	e51b3018 	ldr	r3, [fp, #-24]
1000c0d4:	e6ff3073 	uxth	r3, r3
1000c0d8:	e51b0008 	ldr	r0, [fp, #-8]
1000c0dc:	e51b1014 	ldr	r1, [fp, #-20]
1000c0e0:	e1a02003 	mov	r2, r3
1000c0e4:	eb00091d 	bl	1000e560 <rt_device_register>
1000c0e8:	e1a03000 	mov	r3, r0
}
1000c0ec:	e1a00003 	mov	r0, r3
1000c0f0:	e24bd004 	sub	sp, fp, #4
1000c0f4:	e8bd8800 	pop	{fp, pc}

1000c0f8 <rt_sharemem_init>:
#include <rtdevice.h>
#include "sharemem.h"


static rt_err_t rt_sharemem_init(struct rt_device *dev)
{
1000c0f8:	e92d4800 	push	{fp, lr}
1000c0fc:	e28db004 	add	fp, sp, #4
1000c100:	e24dd010 	sub	sp, sp, #16
1000c104:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000c108:	e3a03000 	mov	r3, #0
1000c10c:	e50b3008 	str	r3, [fp, #-8]
    struct rt_sharemem_device *sharememdev;

    RT_ASSERT(dev != RT_NULL);
1000c110:	e51b3010 	ldr	r3, [fp, #-16]
1000c114:	e3530000 	cmp	r3, #0
1000c118:	1a000005 	bne	1000c134 <rt_sharemem_init+0x3c>
1000c11c:	e3020dd0 	movw	r0, #11728	; 0x2dd0
1000c120:	e3410003 	movt	r0, #4099	; 0x1003
1000c124:	e3021e0c 	movw	r1, #11788	; 0x2e0c
1000c128:	e3411003 	movt	r1, #4099	; 0x1003
1000c12c:	e3a0200d 	mov	r2, #13
1000c130:	eb001f1f 	bl	10013db4 <rt_assert_handler>
    sharememdev = (struct rt_sharemem_device *)dev;
1000c134:	e51b3010 	ldr	r3, [fp, #-16]
1000c138:	e50b300c 	str	r3, [fp, #-12]

    /* apply configuration */
    if (sharememdev->ops->configure)
1000c13c:	e51b300c 	ldr	r3, [fp, #-12]
1000c140:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000c144:	e5933000 	ldr	r3, [r3]
1000c148:	e3530000 	cmp	r3, #0
1000c14c:	0a000008 	beq	1000c174 <rt_sharemem_init+0x7c>
        result = sharememdev->ops->configure(sharememdev, &sharememdev->config);
1000c150:	e51b300c 	ldr	r3, [fp, #-12]
1000c154:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000c158:	e5933000 	ldr	r3, [r3]
1000c15c:	e51b200c 	ldr	r2, [fp, #-12]
1000c160:	e2822040 	add	r2, r2, #64	; 0x40
1000c164:	e51b000c 	ldr	r0, [fp, #-12]
1000c168:	e1a01002 	mov	r1, r2
1000c16c:	e12fff33 	blx	r3
1000c170:	e50b0008 	str	r0, [fp, #-8]
    return result;
1000c174:	e51b3008 	ldr	r3, [fp, #-8]
}
1000c178:	e1a00003 	mov	r0, r3
1000c17c:	e24bd004 	sub	sp, fp, #4
1000c180:	e8bd8800 	pop	{fp, pc}

1000c184 <rt_sharemem_open>:

static rt_err_t rt_sharemem_open(struct rt_device *dev, rt_uint16_t oflag)
{
1000c184:	e92d4800 	push	{fp, lr}
1000c188:	e28db004 	add	fp, sp, #4
1000c18c:	e24dd010 	sub	sp, sp, #16
1000c190:	e50b0010 	str	r0, [fp, #-16]
1000c194:	e1a03001 	mov	r3, r1
1000c198:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    rt_err_t result = RT_EOK;
1000c19c:	e3a03000 	mov	r3, #0
1000c1a0:	e50b3008 	str	r3, [fp, #-8]
    struct rt_sharemem_device *sharememdev;

    RT_ASSERT(dev != RT_NULL);
1000c1a4:	e51b3010 	ldr	r3, [fp, #-16]
1000c1a8:	e3530000 	cmp	r3, #0
1000c1ac:	1a000005 	bne	1000c1c8 <rt_sharemem_open+0x44>
1000c1b0:	e3020dd0 	movw	r0, #11728	; 0x2dd0
1000c1b4:	e3410003 	movt	r0, #4099	; 0x1003
1000c1b8:	e3021e20 	movw	r1, #11808	; 0x2e20
1000c1bc:	e3411003 	movt	r1, #4099	; 0x1003
1000c1c0:	e3a0201b 	mov	r2, #27
1000c1c4:	eb001efa 	bl	10013db4 <rt_assert_handler>
    sharememdev = (struct rt_sharemem_device *)dev;
1000c1c8:	e51b3010 	ldr	r3, [fp, #-16]
1000c1cc:	e50b300c 	str	r3, [fp, #-12]
	//result = sharememdev->ops->control(sharememdev,CMD_INTENABLE,0);
	
	return result;
1000c1d0:	e51b3008 	ldr	r3, [fp, #-8]
}
1000c1d4:	e1a00003 	mov	r0, r3
1000c1d8:	e24bd004 	sub	sp, fp, #4
1000c1dc:	e8bd8800 	pop	{fp, pc}

1000c1e0 <rt_sharemem_close>:

static rt_err_t rt_sharemem_close(struct rt_device *dev)
{
1000c1e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000c1e4:	e28db000 	add	fp, sp, #0
1000c1e8:	e24dd014 	sub	sp, sp, #20
1000c1ec:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000c1f0:	e3a03000 	mov	r3, #0
1000c1f4:	e50b3008 	str	r3, [fp, #-8]

    return result;
1000c1f8:	e51b3008 	ldr	r3, [fp, #-8]
}
1000c1fc:	e1a00003 	mov	r0, r3
1000c200:	e24bd000 	sub	sp, fp, #0
1000c204:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000c208:	e12fff1e 	bx	lr

1000c20c <rt_sharemem_write>:
static rt_size_t rt_sharemem_write(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)

{
1000c20c:	e92d4800 	push	{fp, lr}
1000c210:	e28db004 	add	fp, sp, #4
1000c214:	e24dd018 	sub	sp, sp, #24
1000c218:	e50b0010 	str	r0, [fp, #-16]
1000c21c:	e50b1014 	str	r1, [fp, #-20]
1000c220:	e50b2018 	str	r2, [fp, #-24]
1000c224:	e50b301c 	str	r3, [fp, #-28]
    rt_err_t result = RT_EOK;
1000c228:	e3a03000 	mov	r3, #0
1000c22c:	e50b3008 	str	r3, [fp, #-8]
	struct rt_sharemem_device *sharememdev;

    RT_ASSERT(dev != RT_NULL);
1000c230:	e51b3010 	ldr	r3, [fp, #-16]
1000c234:	e3530000 	cmp	r3, #0
1000c238:	1a000005 	bne	1000c254 <rt_sharemem_write+0x48>
1000c23c:	e3020dd0 	movw	r0, #11728	; 0x2dd0
1000c240:	e3410003 	movt	r0, #4099	; 0x1003
1000c244:	e3021e34 	movw	r1, #11828	; 0x2e34
1000c248:	e3411003 	movt	r1, #4099	; 0x1003
1000c24c:	e3a02033 	mov	r2, #51	; 0x33
1000c250:	eb001ed7 	bl	10013db4 <rt_assert_handler>
    sharememdev = (struct rt_sharemem_device *)dev;
1000c254:	e51b3010 	ldr	r3, [fp, #-16]
1000c258:	e50b300c 	str	r3, [fp, #-12]

    RT_ASSERT(buffer != RT_NULL);
1000c25c:	e51b3018 	ldr	r3, [fp, #-24]
1000c260:	e3530000 	cmp	r3, #0
1000c264:	1a000005 	bne	1000c280 <rt_sharemem_write+0x74>
1000c268:	e3020de0 	movw	r0, #11744	; 0x2de0
1000c26c:	e3410003 	movt	r0, #4099	; 0x1003
1000c270:	e3021e34 	movw	r1, #11828	; 0x2e34
1000c274:	e3411003 	movt	r1, #4099	; 0x1003
1000c278:	e3a02036 	mov	r2, #54	; 0x36
1000c27c:	eb001ecc 	bl	10013db4 <rt_assert_handler>
	
	result = sharememdev->ops->writemem(sharememdev,buffer,size);
1000c280:	e51b300c 	ldr	r3, [fp, #-12]
1000c284:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000c288:	e5933004 	ldr	r3, [r3, #4]
1000c28c:	e51b201c 	ldr	r2, [fp, #-28]
1000c290:	e51b000c 	ldr	r0, [fp, #-12]
1000c294:	e51b1018 	ldr	r1, [fp, #-24]
1000c298:	e12fff33 	blx	r3
1000c29c:	e50b0008 	str	r0, [fp, #-8]
	
    return result;
1000c2a0:	e51b3008 	ldr	r3, [fp, #-8]
}
1000c2a4:	e1a00003 	mov	r0, r3
1000c2a8:	e24bd004 	sub	sp, fp, #4
1000c2ac:	e8bd8800 	pop	{fp, pc}

1000c2b0 <rt_hw_sharemem_register>:

rt_err_t rt_hw_sharemem_register(struct rt_sharemem_device *sharememdev,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
1000c2b0:	e92d4800 	push	{fp, lr}
1000c2b4:	e28db004 	add	fp, sp, #4
1000c2b8:	e24dd018 	sub	sp, sp, #24
1000c2bc:	e50b0010 	str	r0, [fp, #-16]
1000c2c0:	e50b1014 	str	r1, [fp, #-20]
1000c2c4:	e50b2018 	str	r2, [fp, #-24]
1000c2c8:	e50b301c 	str	r3, [fp, #-28]
    struct rt_device *device;
    RT_ASSERT(sharememdev != RT_NULL);
1000c2cc:	e51b3010 	ldr	r3, [fp, #-16]
1000c2d0:	e3530000 	cmp	r3, #0
1000c2d4:	1a000005 	bne	1000c2f0 <rt_hw_sharemem_register+0x40>
1000c2d8:	e3020df4 	movw	r0, #11764	; 0x2df4
1000c2dc:	e3410003 	movt	r0, #4099	; 0x1003
1000c2e0:	e3021e48 	movw	r1, #11848	; 0x2e48
1000c2e4:	e3411003 	movt	r1, #4099	; 0x1003
1000c2e8:	e3a02043 	mov	r2, #67	; 0x43
1000c2ec:	eb001eb0 	bl	10013db4 <rt_assert_handler>

    device = &(sharememdev->parent);
1000c2f0:	e51b3010 	ldr	r3, [fp, #-16]
1000c2f4:	e50b3008 	str	r3, [fp, #-8]

    device->type        = RT_Device_Class_Miscellaneous;
1000c2f8:	e51b3008 	ldr	r3, [fp, #-8]
1000c2fc:	e3a02012 	mov	r2, #18
1000c300:	e5c32010 	strb	r2, [r3, #16]
    device->rx_indicate = RT_NULL;
1000c304:	e51b3008 	ldr	r3, [fp, #-8]
1000c308:	e3a02000 	mov	r2, #0
1000c30c:	e5832018 	str	r2, [r3, #24]
    device->tx_complete = RT_NULL;
1000c310:	e51b3008 	ldr	r3, [fp, #-8]
1000c314:	e3a02000 	mov	r2, #0
1000c318:	e583201c 	str	r2, [r3, #28]

    device->init        = rt_sharemem_init;
1000c31c:	e51b2008 	ldr	r2, [fp, #-8]
1000c320:	e30c30f8 	movw	r3, #49400	; 0xc0f8
1000c324:	e3413000 	movt	r3, #4096	; 0x1000
1000c328:	e5823020 	str	r3, [r2, #32]
    device->open        = rt_sharemem_open;
1000c32c:	e51b2008 	ldr	r2, [fp, #-8]
1000c330:	e30c3184 	movw	r3, #49540	; 0xc184
1000c334:	e3413000 	movt	r3, #4096	; 0x1000
1000c338:	e5823024 	str	r3, [r2, #36]	; 0x24
    device->close       = rt_sharemem_close;
1000c33c:	e51b2008 	ldr	r2, [fp, #-8]
1000c340:	e30c31e0 	movw	r3, #49632	; 0xc1e0
1000c344:	e3413000 	movt	r3, #4096	; 0x1000
1000c348:	e5823028 	str	r3, [r2, #40]	; 0x28
    device->write        = rt_sharemem_write;
1000c34c:	e51b2008 	ldr	r2, [fp, #-8]
1000c350:	e30c320c 	movw	r3, #49676	; 0xc20c
1000c354:	e3413000 	movt	r3, #4096	; 0x1000
1000c358:	e5823030 	str	r3, [r2, #48]	; 0x30
    device->user_data   = data;
1000c35c:	e51b3008 	ldr	r3, [fp, #-8]
1000c360:	e51b201c 	ldr	r2, [fp, #-28]
1000c364:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* register a character device */
    return rt_device_register(device, name, flag);
1000c368:	e51b3018 	ldr	r3, [fp, #-24]
1000c36c:	e6ff3073 	uxth	r3, r3
1000c370:	e51b0008 	ldr	r0, [fp, #-8]
1000c374:	e51b1014 	ldr	r1, [fp, #-20]
1000c378:	e1a02003 	mov	r2, r3
1000c37c:	eb000877 	bl	1000e560 <rt_device_register>
1000c380:	e1a03000 	mov	r3, r0
}
1000c384:	e1a00003 	mov	r0, r3
1000c388:	e24bd004 	sub	sp, fp, #4
1000c38c:	e8bd8800 	pop	{fp, pc}

1000c390 <UartEnable>:
            UART->ISR = (UART_IXR_RXOVR | UART_IXR_RXFULL); \
        }                                                   \
    } while(0)

static void UartEnable(UART_Registers* uart)
{
1000c390:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000c394:	e28db000 	add	fp, sp, #0
1000c398:	e24dd014 	sub	sp, sp, #20
1000c39c:	e50b0010 	str	r0, [fp, #-16]
	uint32_t tmp = uart->CR;
1000c3a0:	e51b3010 	ldr	r3, [fp, #-16]
1000c3a4:	e5933000 	ldr	r3, [r3]
1000c3a8:	e50b3008 	str	r3, [fp, #-8]
	tmp &= ~UART_CR_EN_DIS_MASK;
1000c3ac:	e51b3008 	ldr	r3, [fp, #-8]
1000c3b0:	e3c3303c 	bic	r3, r3, #60	; 0x3c
1000c3b4:	e50b3008 	str	r3, [fp, #-8]
	tmp |= (UART_CR_TX_EN | UART_CR_RX_EN);
1000c3b8:	e51b3008 	ldr	r3, [fp, #-8]
1000c3bc:	e3833014 	orr	r3, r3, #20
1000c3c0:	e50b3008 	str	r3, [fp, #-8]

	uart->CR = tmp;
1000c3c4:	e51b3010 	ldr	r3, [fp, #-16]
1000c3c8:	e51b2008 	ldr	r2, [fp, #-8]
1000c3cc:	e5832000 	str	r2, [r3]
}
1000c3d0:	e24bd000 	sub	sp, fp, #0
1000c3d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000c3d8:	e12fff1e 	bx	lr

1000c3dc <UartDisable>:

static void UartDisable(UART_Registers* uart)
{
1000c3dc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000c3e0:	e28db000 	add	fp, sp, #0
1000c3e4:	e24dd014 	sub	sp, sp, #20
1000c3e8:	e50b0010 	str	r0, [fp, #-16]
	uint32_t tmp = uart->CR;
1000c3ec:	e51b3010 	ldr	r3, [fp, #-16]
1000c3f0:	e5933000 	ldr	r3, [r3]
1000c3f4:	e50b3008 	str	r3, [fp, #-8]
	tmp &= ~UART_CR_EN_DIS_MASK;
1000c3f8:	e51b3008 	ldr	r3, [fp, #-8]
1000c3fc:	e3c3303c 	bic	r3, r3, #60	; 0x3c
1000c400:	e50b3008 	str	r3, [fp, #-8]
	tmp |= (UART_CR_TX_DIS | UART_CR_RX_DIS);
1000c404:	e51b3008 	ldr	r3, [fp, #-8]
1000c408:	e3833028 	orr	r3, r3, #40	; 0x28
1000c40c:	e50b3008 	str	r3, [fp, #-8]
	uart->CR = tmp;
1000c410:	e51b3010 	ldr	r3, [fp, #-16]
1000c414:	e51b2008 	ldr	r2, [fp, #-8]
1000c418:	e5832000 	str	r2, [r3]
}
1000c41c:	e24bd000 	sub	sp, fp, #0
1000c420:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000c424:	e12fff1e 	bx	lr

1000c428 <UartResetTXRXLogic>:

static void UartResetTXRXLogic(UART_Registers* uart)
{
1000c428:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000c42c:	e28db000 	add	fp, sp, #0
1000c430:	e24dd00c 	sub	sp, sp, #12
1000c434:	e50b0008 	str	r0, [fp, #-8]
	uart->CR |= 0x03;
1000c438:	e51b3008 	ldr	r3, [fp, #-8]
1000c43c:	e5933000 	ldr	r3, [r3]
1000c440:	e3832003 	orr	r2, r3, #3
1000c444:	e51b3008 	ldr	r3, [fp, #-8]
1000c448:	e5832000 	str	r2, [r3]
    while (uart->CR & 0x03)
1000c44c:	e1a00000 	nop			; (mov r0, r0)
1000c450:	e51b3008 	ldr	r3, [fp, #-8]
1000c454:	e5933000 	ldr	r3, [r3]
1000c458:	e2033003 	and	r3, r3, #3
1000c45c:	e3530000 	cmp	r3, #0
1000c460:	1afffffa 	bne	1000c450 <UartResetTXRXLogic+0x28>
        ;
}
1000c464:	e24bd000 	sub	sp, fp, #0
1000c468:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000c46c:	e12fff1e 	bx	lr

1000c470 <rt_hw_uart_isr>:

/* RT-Thread UART interface */
#define XZYNQUART_MASTER  (100000000)

static void rt_hw_uart_isr(int irqno, void *param)
{
1000c470:	e92d4800 	push	{fp, lr}
1000c474:	e28db004 	add	fp, sp, #4
1000c478:	e24dd010 	sub	sp, sp, #16
1000c47c:	e50b0010 	str	r0, [fp, #-16]
1000c480:	e50b1014 	str	r1, [fp, #-20]
    struct rt_serial_device *serial = (struct rt_serial_device *)param;
1000c484:	e51b3014 	ldr	r3, [fp, #-20]
1000c488:	e50b3008 	str	r3, [fp, #-8]

    rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_IND);
1000c48c:	e51b0008 	ldr	r0, [fp, #-8]
1000c490:	e3a01001 	mov	r1, #1
1000c494:	eb00576c 	bl	1002224c <rt_hw_serial_isr>
}
1000c498:	e24bd004 	sub	sp, fp, #4
1000c49c:	e8bd8800 	pop	{fp, pc}

1000c4a0 <serial_setbrg>:
void serial_setbrg(unsigned int *baudgen,unsigned int *bauddiv)
{
1000c4a0:	e92d4800 	push	{fp, lr}
1000c4a4:	e28db004 	add	fp, sp, #4
1000c4a8:	e24dd020 	sub	sp, sp, #32
1000c4ac:	e50b0020 	str	r0, [fp, #-32]
1000c4b0:	e50b1024 	str	r1, [fp, #-36]	; 0x24
	/*              master clock
	 * Baud rate = ---------------
	 *              bgen*(bdiv+1)
	 */
	long baud = BAUD_RATE_115200;
1000c4b4:	e3a03cc2 	mov	r3, #49664	; 0xc200
1000c4b8:	e3403001 	movt	r3, #1
1000c4bc:	e50b3014 	str	r3, [fp, #-20]

	/* Variables to vary. */
	unsigned int bdiv, bgen;

	/* Calculation results. */
	long calc_baud = 0;
1000c4c0:	e3a03000 	mov	r3, #0
1000c4c4:	e50b3018 	str	r3, [fp, #-24]
	unsigned int calc_bauderror;

	/* Find acceptable values for baud generation. */
	for (bdiv = 4; bdiv < 255; bdiv++) {
1000c4c8:	e3a03004 	mov	r3, #4
1000c4cc:	e50b3008 	str	r3, [fp, #-8]
1000c4d0:	ea000038 	b	1000c5b8 <serial_setbrg+0x118>

		bgen = XZYNQUART_MASTER / (baud * (bdiv + 1));
1000c4d4:	e51b3008 	ldr	r3, [fp, #-8]
1000c4d8:	e2833001 	add	r3, r3, #1
1000c4dc:	e51b2014 	ldr	r2, [fp, #-20]
1000c4e0:	e0030392 	mul	r3, r2, r3
1000c4e4:	e3a00ce1 	mov	r0, #57600	; 0xe100
1000c4e8:	e34005f5 	movt	r0, #1525	; 0x5f5
1000c4ec:	e1a01003 	mov	r1, r3
1000c4f0:	fa008a32 	blx	1002edc0 <__aeabi_uidiv>
1000c4f4:	e1a03000 	mov	r3, r0
1000c4f8:	e50b300c 	str	r3, [fp, #-12]
		if (bgen < 2 || bgen > 65535)
1000c4fc:	e51b300c 	ldr	r3, [fp, #-12]
1000c500:	e3530001 	cmp	r3, #1
1000c504:	9a000002 	bls	1000c514 <serial_setbrg+0x74>
1000c508:	e51b300c 	ldr	r3, [fp, #-12]
1000c50c:	e3530801 	cmp	r3, #65536	; 0x10000
1000c510:	3a000000 	bcc	1000c518 <serial_setbrg+0x78>
			continue;
1000c514:	ea000024 	b	1000c5ac <serial_setbrg+0x10c>

		calc_baud = XZYNQUART_MASTER / (bgen * (bdiv + 1));
1000c518:	e51b3008 	ldr	r3, [fp, #-8]
1000c51c:	e2833001 	add	r3, r3, #1
1000c520:	e51b200c 	ldr	r2, [fp, #-12]
1000c524:	e0030392 	mul	r3, r2, r3
1000c528:	e3a00ce1 	mov	r0, #57600	; 0xe100
1000c52c:	e34005f5 	movt	r0, #1525	; 0x5f5
1000c530:	e1a01003 	mov	r1, r3
1000c534:	fa008a21 	blx	1002edc0 <__aeabi_uidiv>
1000c538:	e1a03000 	mov	r3, r0
1000c53c:	e50b3018 	str	r3, [fp, #-24]

		/* Use first calculated baudrate with an acceptable
		 * (<3%) error.
		 */
		if (baud > calc_baud)
1000c540:	e51b2014 	ldr	r2, [fp, #-20]
1000c544:	e51b3018 	ldr	r3, [fp, #-24]
1000c548:	e1520003 	cmp	r2, r3
1000c54c:	da000004 	ble	1000c564 <serial_setbrg+0xc4>
			calc_bauderror = baud - calc_baud;
1000c550:	e51b2014 	ldr	r2, [fp, #-20]
1000c554:	e51b3018 	ldr	r3, [fp, #-24]
1000c558:	e0633002 	rsb	r3, r3, r2
1000c55c:	e50b3010 	str	r3, [fp, #-16]
1000c560:	ea000003 	b	1000c574 <serial_setbrg+0xd4>
		else
			calc_bauderror = calc_baud - baud;
1000c564:	e51b2018 	ldr	r2, [fp, #-24]
1000c568:	e51b3014 	ldr	r3, [fp, #-20]
1000c56c:	e0633002 	rsb	r3, r3, r2
1000c570:	e50b3010 	str	r3, [fp, #-16]
		if ( ((calc_bauderror * 100) / baud) < 3 )
1000c574:	e51b3010 	ldr	r3, [fp, #-16]
1000c578:	e1a03103 	lsl	r3, r3, #2
1000c57c:	e1a02103 	lsl	r2, r3, #2
1000c580:	e0833002 	add	r3, r3, r2
1000c584:	e1a02103 	lsl	r2, r3, #2
1000c588:	e0832002 	add	r2, r3, r2
1000c58c:	e51b3014 	ldr	r3, [fp, #-20]
1000c590:	e1a00002 	mov	r0, r2
1000c594:	e1a01003 	mov	r1, r3
1000c598:	fa008a08 	blx	1002edc0 <__aeabi_uidiv>
1000c59c:	e1a03000 	mov	r3, r0
1000c5a0:	e3530002 	cmp	r3, #2
1000c5a4:	8a000000 	bhi	1000c5ac <serial_setbrg+0x10c>
			break;
1000c5a8:	ea000005 	b	1000c5c4 <serial_setbrg+0x124>
	/* Calculation results. */
	long calc_baud = 0;
	unsigned int calc_bauderror;

	/* Find acceptable values for baud generation. */
	for (bdiv = 4; bdiv < 255; bdiv++) {
1000c5ac:	e51b3008 	ldr	r3, [fp, #-8]
1000c5b0:	e2833001 	add	r3, r3, #1
1000c5b4:	e50b3008 	str	r3, [fp, #-8]
1000c5b8:	e51b3008 	ldr	r3, [fp, #-8]
1000c5bc:	e35300fe 	cmp	r3, #254	; 0xfe
1000c5c0:	9affffc3 	bls	1000c4d4 <serial_setbrg+0x34>
		if ( ((calc_bauderror * 100) / baud) < 3 )
			break;

	}

	*baudgen = bdiv;
1000c5c4:	e51b3020 	ldr	r3, [fp, #-32]
1000c5c8:	e51b2008 	ldr	r2, [fp, #-8]
1000c5cc:	e5832000 	str	r2, [r3]
	*bauddiv = bgen;
1000c5d0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000c5d4:	e51b200c 	ldr	r2, [fp, #-12]
1000c5d8:	e5832000 	str	r2, [r3]
}
1000c5dc:	e24bd004 	sub	sp, fp, #4
1000c5e0:	e8bd8800 	pop	{fp, pc}

1000c5e4 <uart_configure>:

static rt_err_t uart_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
{
1000c5e4:	e92d4800 	push	{fp, lr}
1000c5e8:	e28db004 	add	fp, sp, #4
1000c5ec:	e24dd018 	sub	sp, sp, #24
1000c5f0:	e50b0018 	str	r0, [fp, #-24]
1000c5f4:	e50b101c 	str	r1, [fp, #-28]
    uint32_t mr;
    struct hw_uart_device *pdev = serial->parent.user_data;
1000c5f8:	e51b3018 	ldr	r3, [fp, #-24]
1000c5fc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000c600:	e50b300c 	str	r3, [fp, #-12]
    UART_Registers *uart = pdev->uart;
1000c604:	e51b300c 	ldr	r3, [fp, #-12]
1000c608:	e5933000 	ldr	r3, [r3]
1000c60c:	e50b3010 	str	r3, [fp, #-16]

    /* unlock SLCR */
    __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UNLOCK) = 0xDF0D;
1000c610:	e3a03008 	mov	r3, #8
1000c614:	e34f3800 	movt	r3, #63488	; 0xf800
1000c618:	e30d2f0d 	movw	r2, #57101	; 0xdf0d
1000c61c:	e5832000 	str	r2, [r3]

    /* no loopback */
    __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_MIO_LOOPBACK) &= ~(1 << 1);
1000c620:	e3003804 	movw	r3, #2052	; 0x804
1000c624:	e34f3800 	movt	r3, #63488	; 0xf800
1000c628:	e3002804 	movw	r2, #2052	; 0x804
1000c62c:	e34f2800 	movt	r2, #63488	; 0xf800
1000c630:	e5922000 	ldr	r2, [r2]
1000c634:	e3c22002 	bic	r2, r2, #2
1000c638:	e5832000 	str	r2, [r3]

    if (uart == (void*)Zynq7000_UART0_BASE)
1000c63c:	e51b3010 	ldr	r3, [fp, #-16]
1000c640:	e353020e 	cmp	r3, #-536870912	; 0xe0000000
1000c644:	1a000016 	bne	1000c6a4 <uart_configure+0xc0>
    {
        /* enable the coresponding AMBA Peripheral Clock */
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_APER_CLK_CTRL) |= 1 << 20;
1000c648:	e3a03f4b 	mov	r3, #300	; 0x12c
1000c64c:	e34f3800 	movt	r3, #63488	; 0xf800
1000c650:	e3a02f4b 	mov	r2, #300	; 0x12c
1000c654:	e34f2800 	movt	r2, #63488	; 0xf800
1000c658:	e5922000 	ldr	r2, [r2]
1000c65c:	e3822601 	orr	r2, r2, #1048576	; 0x100000
1000c660:	e5832000 	str	r2, [r3]
        /* enable uart clock. Divider 0x14 gives 50MHZ ref clock on IO PLL input. */
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UART_CLK_CTRL) |= (0xa << 8) | 0x01;
1000c664:	e3a02f55 	mov	r2, #340	; 0x154
1000c668:	e34f2800 	movt	r2, #63488	; 0xf800
1000c66c:	e3a03f55 	mov	r3, #340	; 0x154
1000c670:	e34f3800 	movt	r3, #63488	; 0xf800
1000c674:	e5933000 	ldr	r3, [r3]
1000c678:	e3833c0a 	orr	r3, r3, #2560	; 0xa00
1000c67c:	e3833001 	orr	r3, r3, #1
1000c680:	e5823000 	str	r3, [r2]
        /* deassert the AMBA clock and software reset */
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UART_RST_CTRL) &= ~((0x01 << 2)|(0x01 << 0));
1000c684:	e3a03f8a 	mov	r3, #552	; 0x228
1000c688:	e34f3800 	movt	r3, #63488	; 0xf800
1000c68c:	e3a02f8a 	mov	r2, #552	; 0x228
1000c690:	e34f2800 	movt	r2, #63488	; 0xf800
1000c694:	e5922000 	ldr	r2, [r2]
1000c698:	e3c22005 	bic	r2, r2, #5
1000c69c:	e5832000 	str	r2, [r3]
1000c6a0:	ea00001d 	b	1000c71c <uart_configure+0x138>
    }
    else if (uart == (void*)Zynq7000_UART1_BASE)
1000c6a4:	e51b2010 	ldr	r2, [fp, #-16]
1000c6a8:	e3a03a01 	mov	r3, #4096	; 0x1000
1000c6ac:	e34e3000 	movt	r3, #57344	; 0xe000
1000c6b0:	e1520003 	cmp	r2, r3
1000c6b4:	1a000016 	bne	1000c714 <uart_configure+0x130>
    {
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_APER_CLK_CTRL) |= 1 << 21;
1000c6b8:	e3a03f4b 	mov	r3, #300	; 0x12c
1000c6bc:	e34f3800 	movt	r3, #63488	; 0xf800
1000c6c0:	e3a02f4b 	mov	r2, #300	; 0x12c
1000c6c4:	e34f2800 	movt	r2, #63488	; 0xf800
1000c6c8:	e5922000 	ldr	r2, [r2]
1000c6cc:	e3822602 	orr	r2, r2, #2097152	; 0x200000
1000c6d0:	e5832000 	str	r2, [r3]
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UART_CLK_CTRL) |= (0x14 << 8) | 0x02;
1000c6d4:	e3a02f55 	mov	r2, #340	; 0x154
1000c6d8:	e34f2800 	movt	r2, #63488	; 0xf800
1000c6dc:	e3a03f55 	mov	r3, #340	; 0x154
1000c6e0:	e34f3800 	movt	r3, #63488	; 0xf800
1000c6e4:	e5933000 	ldr	r3, [r3]
1000c6e8:	e3833b05 	orr	r3, r3, #5120	; 0x1400
1000c6ec:	e3833002 	orr	r3, r3, #2
1000c6f0:	e5823000 	str	r3, [r2]
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UART_RST_CTRL) &= ~((0x01 << 3)|(0x01 << 1));
1000c6f4:	e3a03f8a 	mov	r3, #552	; 0x228
1000c6f8:	e34f3800 	movt	r3, #63488	; 0xf800
1000c6fc:	e3a02f8a 	mov	r2, #552	; 0x228
1000c700:	e34f2800 	movt	r2, #63488	; 0xf800
1000c704:	e5922000 	ldr	r2, [r2]
1000c708:	e3c2200a 	bic	r2, r2, #10
1000c70c:	e5832000 	str	r2, [r3]
1000c710:	ea000001 	b	1000c71c <uart_configure+0x138>
    }
    else
        return -RT_ERROR;
1000c714:	e3e03000 	mvn	r3, #0
1000c718:	ea00007b 	b	1000c90c <uart_configure+0x328>

    UartDisable(uart);
1000c71c:	e51b0010 	ldr	r0, [fp, #-16]
1000c720:	ebffff2d 	bl	1000c3dc <UartDisable>
    UartResetTXRXLogic(uart);
1000c724:	e51b0010 	ldr	r0, [fp, #-16]
1000c728:	ebffff3e 	bl	1000c428 <UartResetTXRXLogic>
    UartEnable(uart);
1000c72c:	e51b0010 	ldr	r0, [fp, #-16]
1000c730:	ebffff16 	bl	1000c390 <UartEnable>

    mr = uart->MR & ~(UART_MR_CHARLEN_MASK |
1000c734:	e51b3010 	ldr	r3, [fp, #-16]
1000c738:	e5933004 	ldr	r3, [r3, #4]
1000c73c:	e3c330be 	bic	r3, r3, #190	; 0xbe
1000c740:	e50b3008 	str	r3, [fp, #-8]
                      UART_MR_STOPMODE_MASK |
                      UART_MR_PARITY_MASK);

    if (cfg->stop_bits == STOP_BITS_2)
1000c744:	e51b301c 	ldr	r3, [fp, #-28]
1000c748:	e5d33004 	ldrb	r3, [r3, #4]
1000c74c:	e2033030 	and	r3, r3, #48	; 0x30
1000c750:	e6ef3073 	uxtb	r3, r3
1000c754:	e3530010 	cmp	r3, #16
1000c758:	1a000003 	bne	1000c76c <uart_configure+0x188>
        mr |= UART_MR_STOPMODE_2_BIT;
1000c75c:	e51b3008 	ldr	r3, [fp, #-8]
1000c760:	e3833080 	orr	r3, r3, #128	; 0x80
1000c764:	e50b3008 	str	r3, [fp, #-8]
1000c768:	ea000007 	b	1000c78c <uart_configure+0x1a8>
    else if (cfg->stop_bits == STOP_BITS_1)
1000c76c:	e51b301c 	ldr	r3, [fp, #-28]
1000c770:	e5d33004 	ldrb	r3, [r3, #4]
1000c774:	e2033030 	and	r3, r3, #48	; 0x30
1000c778:	e6ef3073 	uxtb	r3, r3
1000c77c:	e3530000 	cmp	r3, #0
1000c780:	0a000001 	beq	1000c78c <uart_configure+0x1a8>
        mr |= UART_MR_STOPMODE_1_BIT;
    else
        return -RT_ERROR;
1000c784:	e3e03000 	mvn	r3, #0
1000c788:	ea00005f 	b	1000c90c <uart_configure+0x328>

    if (cfg->parity == PARITY_EVEN)
1000c78c:	e51b301c 	ldr	r3, [fp, #-28]
1000c790:	e5d33004 	ldrb	r3, [r3, #4]
1000c794:	e3c3303f 	bic	r3, r3, #63	; 0x3f
1000c798:	e6ef3073 	uxtb	r3, r3
1000c79c:	e3530080 	cmp	r3, #128	; 0x80
1000c7a0:	0a000015 	beq	1000c7fc <uart_configure+0x218>
        mr |= UART_MR_PARITY_EVEN;
    else if (cfg->parity == PARITY_ODD)
1000c7a4:	e51b301c 	ldr	r3, [fp, #-28]
1000c7a8:	e5d33004 	ldrb	r3, [r3, #4]
1000c7ac:	e3c3303f 	bic	r3, r3, #63	; 0x3f
1000c7b0:	e6ef3073 	uxtb	r3, r3
1000c7b4:	e3530040 	cmp	r3, #64	; 0x40
1000c7b8:	1a000003 	bne	1000c7cc <uart_configure+0x1e8>
        mr |= UART_MR_PARITY_ODD;
1000c7bc:	e51b3008 	ldr	r3, [fp, #-8]
1000c7c0:	e3833008 	orr	r3, r3, #8
1000c7c4:	e50b3008 	str	r3, [fp, #-8]
1000c7c8:	ea00000b 	b	1000c7fc <uart_configure+0x218>
    else if (cfg->parity == PARITY_NONE)
1000c7cc:	e51b301c 	ldr	r3, [fp, #-28]
1000c7d0:	e5d33004 	ldrb	r3, [r3, #4]
1000c7d4:	e3c3303f 	bic	r3, r3, #63	; 0x3f
1000c7d8:	e6ef3073 	uxtb	r3, r3
1000c7dc:	e3530000 	cmp	r3, #0
1000c7e0:	1a000003 	bne	1000c7f4 <uart_configure+0x210>
        mr |= UART_MR_PARITY_NONE;
1000c7e4:	e51b3008 	ldr	r3, [fp, #-8]
1000c7e8:	e3833020 	orr	r3, r3, #32
1000c7ec:	e50b3008 	str	r3, [fp, #-8]
1000c7f0:	ea000001 	b	1000c7fc <uart_configure+0x218>
    else
        return -1;
1000c7f4:	e3e03000 	mvn	r3, #0
1000c7f8:	ea000043 	b	1000c90c <uart_configure+0x328>

    if (cfg->data_bits == DATA_BITS_8)
1000c7fc:	e51b301c 	ldr	r3, [fp, #-28]
1000c800:	e5d33004 	ldrb	r3, [r3, #4]
1000c804:	e203300f 	and	r3, r3, #15
1000c808:	e6ef3073 	uxtb	r3, r3
1000c80c:	e3530008 	cmp	r3, #8
1000c810:	0a000015 	beq	1000c86c <uart_configure+0x288>
        mr |= UART_MR_CHARLEN_8_BIT;
    else if (cfg->data_bits == DATA_BITS_7)
1000c814:	e51b301c 	ldr	r3, [fp, #-28]
1000c818:	e5d33004 	ldrb	r3, [r3, #4]
1000c81c:	e203300f 	and	r3, r3, #15
1000c820:	e6ef3073 	uxtb	r3, r3
1000c824:	e3530007 	cmp	r3, #7
1000c828:	1a000003 	bne	1000c83c <uart_configure+0x258>
        mr |= UART_MR_CHARLEN_7_BIT;
1000c82c:	e51b3008 	ldr	r3, [fp, #-8]
1000c830:	e3833004 	orr	r3, r3, #4
1000c834:	e50b3008 	str	r3, [fp, #-8]
1000c838:	ea00000b 	b	1000c86c <uart_configure+0x288>
    else if (cfg->data_bits == DATA_BITS_6)
1000c83c:	e51b301c 	ldr	r3, [fp, #-28]
1000c840:	e5d33004 	ldrb	r3, [r3, #4]
1000c844:	e203300f 	and	r3, r3, #15
1000c848:	e6ef3073 	uxtb	r3, r3
1000c84c:	e3530006 	cmp	r3, #6
1000c850:	1a000003 	bne	1000c864 <uart_configure+0x280>
        mr |= UART_MR_CHARLEN_6_BIT;
1000c854:	e51b3008 	ldr	r3, [fp, #-8]
1000c858:	e3833006 	orr	r3, r3, #6
1000c85c:	e50b3008 	str	r3, [fp, #-8]
1000c860:	ea000001 	b	1000c86c <uart_configure+0x288>
    else
        return -RT_ERROR;
1000c864:	e3e03000 	mvn	r3, #0
1000c868:	ea000027 	b	1000c90c <uart_configure+0x328>

	uart->MR = mr;
1000c86c:	e51b3010 	ldr	r3, [fp, #-16]
1000c870:	e51b2008 	ldr	r2, [fp, #-8]
1000c874:	e5832004 	str	r2, [r3, #4]

    uart->TXWM = 8;
1000c878:	e51b3010 	ldr	r3, [fp, #-16]
1000c87c:	e3a02008 	mov	r2, #8
1000c880:	e5832044 	str	r2, [r3, #68]	; 0x44
    uart->RXWM = 1;
1000c884:	e51b3010 	ldr	r3, [fp, #-16]
1000c888:	e3a02001 	mov	r2, #1
1000c88c:	e5832020 	str	r2, [r3, #32]

    if (cfg->baud_rate == BAUD_RATE_115200)
1000c890:	e51b301c 	ldr	r3, [fp, #-28]
1000c894:	e5932000 	ldr	r2, [r3]
1000c898:	e3a03cc2 	mov	r3, #49664	; 0xc200
1000c89c:	e3403001 	movt	r3, #1
1000c8a0:	e1520003 	cmp	r2, r3
1000c8a4:	1a000006 	bne	1000c8c4 <uart_configure+0x2e0>
    {
		#if 1
		uart->BAUDGEN = UART_BAUDGEN_115200;
1000c8a8:	e51b3010 	ldr	r3, [fp, #-16]
1000c8ac:	e3a0203e 	mov	r2, #62	; 0x3e
1000c8b0:	e5832018 	str	r2, [r3, #24]
        uart->BAUDDIV = UART_BAUDDIV_115200;
1000c8b4:	e51b3010 	ldr	r3, [fp, #-16]
1000c8b8:	e3a0200d 	mov	r2, #13
1000c8bc:	e5832034 	str	r2, [r3, #52]	; 0x34
1000c8c0:	ea000005 	b	1000c8dc <uart_configure+0x2f8>
		#endif 
		//serial_setbrg(&(uart->BAUDGEN),&(uart->BAUDDIV));
    }
    else
    {
        rt_kprintf("baudrate %d not implemented yet\n", cfg->baud_rate);
1000c8c4:	e51b301c 	ldr	r3, [fp, #-28]
1000c8c8:	e5933000 	ldr	r3, [r3]
1000c8cc:	e3020e60 	movw	r0, #11872	; 0x2e60
1000c8d0:	e3410003 	movt	r0, #4099	; 0x1003
1000c8d4:	e1a01003 	mov	r1, r3
1000c8d8:	eb001c78 	bl	10013ac0 <rt_kprintf>
    }

    /* disable all interrupts */
    uart->IDR = UART_IXR_MASK;
1000c8dc:	e51b3010 	ldr	r3, [fp, #-16]
1000c8e0:	e30023ff 	movw	r2, #1023	; 0x3ff
1000c8e4:	e583200c 	str	r2, [r3, #12]

    /* configure the pin */
    *(pdev->txmio) = TX_MIO_PIN_MODE;
1000c8e8:	e51b300c 	ldr	r3, [fp, #-12]
1000c8ec:	e593300c 	ldr	r3, [r3, #12]
1000c8f0:	e30223e0 	movw	r2, #9184	; 0x23e0
1000c8f4:	e5832000 	str	r2, [r3]
    *(pdev->rxmio) = RX_MIO_PIN_MODE;
1000c8f8:	e51b300c 	ldr	r3, [fp, #-12]
1000c8fc:	e5933008 	ldr	r3, [r3, #8]
1000c900:	e30323e0 	movw	r2, #13280	; 0x33e0
1000c904:	e5832000 	str	r2, [r3]

    return RT_EOK;
1000c908:	e3a03000 	mov	r3, #0
}
1000c90c:	e1a00003 	mov	r0, r3
1000c910:	e24bd004 	sub	sp, fp, #4
1000c914:	e8bd8800 	pop	{fp, pc}

1000c918 <uart_control>:

static rt_err_t uart_control(struct rt_serial_device *serial, int cmd, void *arg)
{
1000c918:	e92d4810 	push	{r4, fp, lr}
1000c91c:	e28db008 	add	fp, sp, #8
1000c920:	e24dd01c 	sub	sp, sp, #28
1000c924:	e50b0018 	str	r0, [fp, #-24]
1000c928:	e50b101c 	str	r1, [fp, #-28]
1000c92c:	e50b2020 	str	r2, [fp, #-32]
    struct hw_uart_device *pdev;

    RT_ASSERT(serial != RT_NULL);
1000c930:	e51b3018 	ldr	r3, [fp, #-24]
1000c934:	e3530000 	cmp	r3, #0
1000c938:	1a000005 	bne	1000c954 <uart_control+0x3c>
1000c93c:	e3020e84 	movw	r0, #11908	; 0x2e84
1000c940:	e3410003 	movt	r0, #4099	; 0x1003
1000c944:	e3021ebc 	movw	r1, #11964	; 0x2ebc
1000c948:	e3411003 	movt	r1, #4099	; 0x1003
1000c94c:	e3a020ef 	mov	r2, #239	; 0xef
1000c950:	eb001d17 	bl	10013db4 <rt_assert_handler>

    pdev = serial->parent.user_data;
1000c954:	e51b3018 	ldr	r3, [fp, #-24]
1000c958:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000c95c:	e50b3010 	str	r3, [fp, #-16]

    switch (cmd)
1000c960:	e51b301c 	ldr	r3, [fp, #-28]
1000c964:	e3530010 	cmp	r3, #16
1000c968:	0a000009 	beq	1000c994 <uart_control+0x7c>
1000c96c:	e3530011 	cmp	r3, #17
1000c970:	1a000028 	bne	1000ca18 <uart_control+0x100>
    {
    case RT_DEVICE_CTRL_CLR_INT:
        /* disable rx irq */
        Zynq7000_UART_INT_DISABLE(pdev->uart);
1000c974:	e51b3010 	ldr	r3, [fp, #-16]
1000c978:	e5933000 	ldr	r3, [r3]
1000c97c:	e51b2010 	ldr	r2, [fp, #-16]
1000c980:	e5922000 	ldr	r2, [r2]
1000c984:	e5922008 	ldr	r2, [r2, #8]
1000c988:	e3c22005 	bic	r2, r2, #5
1000c98c:	e5832008 	str	r2, [r3, #8]
        break;
1000c990:	ea000020 	b	1000ca18 <uart_control+0x100>

    case RT_DEVICE_CTRL_SET_INT:
        /* enable rx irq */
        Zynq7000_UART_INT_ENABLE(pdev->uart);
1000c994:	e51b3010 	ldr	r3, [fp, #-16]
1000c998:	e5933000 	ldr	r3, [r3]
1000c99c:	e51b2010 	ldr	r2, [fp, #-16]
1000c9a0:	e5922000 	ldr	r2, [r2]
1000c9a4:	e5922008 	ldr	r2, [r2, #8]
1000c9a8:	e3822005 	orr	r2, r2, #5
1000c9ac:	e5832008 	str	r2, [r3, #8]
        rt_hw_interrupt_install(pdev->irqno, rt_hw_uart_isr, serial, "uart");
1000c9b0:	e51b3010 	ldr	r3, [fp, #-16]
1000c9b4:	e5933004 	ldr	r3, [r3, #4]
1000c9b8:	e1a00003 	mov	r0, r3
1000c9bc:	e30c1470 	movw	r1, #50288	; 0xc470
1000c9c0:	e3411000 	movt	r1, #4096	; 0x1000
1000c9c4:	e51b2018 	ldr	r2, [fp, #-24]
1000c9c8:	e3023e98 	movw	r3, #11928	; 0x2e98
1000c9cc:	e3413003 	movt	r3, #4099	; 0x1003
1000c9d0:	eb003085 	bl	10018bec <rt_hw_interrupt_install>
        /* set the interrupt to this cpu */
        arm_gic_set_cpu(0, pdev->irqno, 1 << rt_cpu_get_smp_id());
1000c9d4:	e51b3010 	ldr	r3, [fp, #-16]
1000c9d8:	e5933004 	ldr	r3, [r3, #4]
1000c9dc:	e1a04003 	mov	r4, r3
1000c9e0:	eb003338 	bl	100196c8 <rt_cpu_get_smp_id>
1000c9e4:	e1a03000 	mov	r3, r0
1000c9e8:	e1a02003 	mov	r2, r3
1000c9ec:	e3a03001 	mov	r3, #1
1000c9f0:	e1a03213 	lsl	r3, r3, r2
1000c9f4:	e3a00000 	mov	r0, #0
1000c9f8:	e1a01004 	mov	r1, r4
1000c9fc:	e1a02003 	mov	r2, r3
1000ca00:	eb002dbf 	bl	10018104 <arm_gic_set_cpu>
        rt_hw_interrupt_umask(pdev->irqno);
1000ca04:	e51b3010 	ldr	r3, [fp, #-16]
1000ca08:	e5933004 	ldr	r3, [r3, #4]
1000ca0c:	e1a00003 	mov	r0, r3
1000ca10:	eb00306c 	bl	10018bc8 <rt_hw_interrupt_umask>
        break;
1000ca14:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
1000ca18:	e3a03000 	mov	r3, #0
}
1000ca1c:	e1a00003 	mov	r0, r3
1000ca20:	e24bd008 	sub	sp, fp, #8
1000ca24:	e8bd8810 	pop	{r4, fp, pc}

1000ca28 <uart_putc>:

static int uart_putc(struct rt_serial_device *serial, char c)
{
1000ca28:	e92d4800 	push	{fp, lr}
1000ca2c:	e28db004 	add	fp, sp, #4
1000ca30:	e24dd010 	sub	sp, sp, #16
1000ca34:	e50b0010 	str	r0, [fp, #-16]
1000ca38:	e1a03001 	mov	r3, r1
1000ca3c:	e54b3011 	strb	r3, [fp, #-17]
    struct hw_uart_device *dev;

    RT_ASSERT(serial != RT_NULL);
1000ca40:	e51b3010 	ldr	r3, [fp, #-16]
1000ca44:	e3530000 	cmp	r3, #0
1000ca48:	1a000005 	bne	1000ca64 <uart_putc+0x3c>
1000ca4c:	e3020e84 	movw	r0, #11908	; 0x2e84
1000ca50:	e3410003 	movt	r0, #4099	; 0x1003
1000ca54:	e3021ecc 	movw	r1, #11980	; 0x2ecc
1000ca58:	e3411003 	movt	r1, #4099	; 0x1003
1000ca5c:	e300210b 	movw	r2, #267	; 0x10b
1000ca60:	eb001cd3 	bl	10013db4 <rt_assert_handler>
    dev = (struct hw_uart_device *)serial->parent.user_data;
1000ca64:	e51b3010 	ldr	r3, [fp, #-16]
1000ca68:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000ca6c:	e50b3008 	str	r3, [fp, #-8]

    Zynq7000_UART_SENDCHAR(dev->uart, c);
1000ca70:	e1a00000 	nop			; (mov r0, r0)
1000ca74:	e51b3008 	ldr	r3, [fp, #-8]
1000ca78:	e5933000 	ldr	r3, [r3]
1000ca7c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000ca80:	e2033010 	and	r3, r3, #16
1000ca84:	e3530000 	cmp	r3, #0
1000ca88:	1afffff9 	bne	1000ca74 <uart_putc+0x4c>
1000ca8c:	e51b3008 	ldr	r3, [fp, #-8]
1000ca90:	e5933000 	ldr	r3, [r3]
1000ca94:	e55b2011 	ldrb	r2, [fp, #-17]
1000ca98:	e5832030 	str	r2, [r3, #48]	; 0x30

    return 1;
1000ca9c:	e3a03001 	mov	r3, #1
}
1000caa0:	e1a00003 	mov	r0, r3
1000caa4:	e24bd004 	sub	sp, fp, #4
1000caa8:	e8bd8800 	pop	{fp, pc}

1000caac <uart_getc>:

static int uart_getc(struct rt_serial_device *serial)
{
1000caac:	e92d4800 	push	{fp, lr}
1000cab0:	e28db004 	add	fp, sp, #4
1000cab4:	e24dd010 	sub	sp, sp, #16
1000cab8:	e50b0010 	str	r0, [fp, #-16]
    int ch;
    struct hw_uart_device *dev;

    RT_ASSERT(serial != RT_NULL);
1000cabc:	e51b3010 	ldr	r3, [fp, #-16]
1000cac0:	e3530000 	cmp	r3, #0
1000cac4:	1a000005 	bne	1000cae0 <uart_getc+0x34>
1000cac8:	e3020e84 	movw	r0, #11908	; 0x2e84
1000cacc:	e3410003 	movt	r0, #4099	; 0x1003
1000cad0:	e3021ed8 	movw	r1, #11992	; 0x2ed8
1000cad4:	e3411003 	movt	r1, #4099	; 0x1003
1000cad8:	e3a02f46 	mov	r2, #280	; 0x118
1000cadc:	eb001cb4 	bl	10013db4 <rt_assert_handler>
    dev = (struct hw_uart_device *)serial->parent.user_data;
1000cae0:	e51b3010 	ldr	r3, [fp, #-16]
1000cae4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000cae8:	e50b300c 	str	r3, [fp, #-12]

    ch = -1;
1000caec:	e3e03000 	mvn	r3, #0
1000caf0:	e50b3008 	str	r3, [fp, #-8]
    Zynq7000_UART_GETCHAR(dev->uart, ch);
1000caf4:	e51b300c 	ldr	r3, [fp, #-12]
1000caf8:	e5933000 	ldr	r3, [r3]
1000cafc:	e5933014 	ldr	r3, [r3, #20]
1000cb00:	e2033001 	and	r3, r3, #1
1000cb04:	e3530000 	cmp	r3, #0
1000cb08:	0a000008 	beq	1000cb30 <uart_getc+0x84>
1000cb0c:	e51b300c 	ldr	r3, [fp, #-12]
1000cb10:	e5933000 	ldr	r3, [r3]
1000cb14:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1000cb18:	e6ef3073 	uxtb	r3, r3
1000cb1c:	e50b3008 	str	r3, [fp, #-8]
1000cb20:	e51b300c 	ldr	r3, [fp, #-12]
1000cb24:	e5933000 	ldr	r3, [r3]
1000cb28:	e3a02005 	mov	r2, #5
1000cb2c:	e5832014 	str	r2, [r3, #20]

    return ch;
1000cb30:	e51b3008 	ldr	r3, [fp, #-8]
}
1000cb34:	e1a00003 	mov	r0, r3
1000cb38:	e24bd004 	sub	sp, fp, #4
1000cb3c:	e8bd8800 	pop	{fp, pc}

1000cb40 <rt_hw_uart_init>:

static struct rt_serial_device _serial0;
static struct rt_serial_device _serial1;

int rt_hw_uart_init(void)
{
1000cb40:	e92d4800 	push	{fp, lr}
1000cb44:	e28db004 	add	fp, sp, #4
1000cb48:	e24dd008 	sub	sp, sp, #8
    struct serial_configure config;

    config.baud_rate = BAUD_RATE_115200;
1000cb4c:	e3a03cc2 	mov	r3, #49664	; 0xc200
1000cb50:	e3403001 	movt	r3, #1
1000cb54:	e50b300c 	str	r3, [fp, #-12]
    config.bit_order = BIT_ORDER_LSB;
1000cb58:	e55b3007 	ldrb	r3, [fp, #-7]
1000cb5c:	e7c0301f 	bfc	r3, #0, #1
1000cb60:	e54b3007 	strb	r3, [fp, #-7]
    config.data_bits = DATA_BITS_8;
1000cb64:	e55b3008 	ldrb	r3, [fp, #-8]
1000cb68:	e3a02008 	mov	r2, #8
1000cb6c:	e7c33012 	bfi	r3, r2, #0, #4
1000cb70:	e54b3008 	strb	r3, [fp, #-8]
    config.parity    = PARITY_NONE;
1000cb74:	e55b3008 	ldrb	r3, [fp, #-8]
1000cb78:	e7c7331f 	bfc	r3, #6, #2
1000cb7c:	e54b3008 	strb	r3, [fp, #-8]
    config.stop_bits = STOP_BITS_1;
1000cb80:	e55b3008 	ldrb	r3, [fp, #-8]
1000cb84:	e7c5321f 	bfc	r3, #4, #2
1000cb88:	e54b3008 	strb	r3, [fp, #-8]
    config.invert    = NRZ_NORMAL;
1000cb8c:	e55b3007 	ldrb	r3, [fp, #-7]
1000cb90:	e7c1309f 	bfc	r3, #1, #1
1000cb94:	e54b3007 	strb	r3, [fp, #-7]
	config.bufsz     = RT_SERIAL_RB_BUFSZ;
1000cb98:	e51b3008 	ldr	r3, [fp, #-8]
1000cb9c:	e3a02040 	mov	r2, #64	; 0x40
1000cba0:	e7d93512 	bfi	r3, r2, #10, #16
1000cba4:	e50b3008 	str	r3, [fp, #-8]

    _serial0.ops    = &_uart_ops;
1000cba8:	e30c304c 	movw	r3, #49228	; 0xc04c
1000cbac:	e3413003 	movt	r3, #4099	; 0x1003
1000cbb0:	e3022ea0 	movw	r2, #11936	; 0x2ea0
1000cbb4:	e3412003 	movt	r2, #4099	; 0x1003
1000cbb8:	e583203c 	str	r2, [r3, #60]	; 0x3c
    _serial0.config = config;
1000cbbc:	e30c304c 	movw	r3, #49228	; 0xc04c
1000cbc0:	e3413003 	movt	r3, #4099	; 0x1003
1000cbc4:	e2833040 	add	r3, r3, #64	; 0x40
1000cbc8:	e24b200c 	sub	r2, fp, #12
1000cbcc:	e8920003 	ldm	r2, {r0, r1}
1000cbd0:	e8830003 	stm	r3, {r0, r1}


    /* register uart device */
    rt_hw_serial_register(&_serial0, "uart0",
1000cbd4:	e30c004c 	movw	r0, #49228	; 0xc04c
1000cbd8:	e3410003 	movt	r0, #4099	; 0x1003
1000cbdc:	e3021eb4 	movw	r1, #11956	; 0x2eb4
1000cbe0:	e3411003 	movt	r1, #4099	; 0x1003
1000cbe4:	e3002103 	movw	r2, #259	; 0x103
1000cbe8:	e3063808 	movw	r3, #26632	; 0x6808
1000cbec:	e3413003 	movt	r3, #4099	; 0x1003
1000cbf0:	eb005555 	bl	1002214c <rt_hw_serial_register>
    _serial1.config = config;
    rt_hw_serial_register(&_serial1, "uart1",
                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
                          &_uart_device1);
	#endif
    return 0;
1000cbf4:	e3a03000 	mov	r3, #0
}
1000cbf8:	e1a00003 	mov	r0, r3
1000cbfc:	e24bd004 	sub	sp, fp, #4
1000cc00:	e8bd8800 	pop	{fp, pc}

1000cc04 <rt_vbus_do_init>:
extern XScuGic ScuGic1_InstancePtr;

struct rt_vbus_ring rt_vbus_rings[2] SECTION("vbus_ring");

int rt_vbus_do_init(void)
{
1000cc04:	e92d4800 	push	{fp, lr}
1000cc08:	e28db004 	add	fp, sp, #4
    return rt_vbus_init(&rt_vbus_rings[0], &rt_vbus_rings[1]);
1000cc0c:	e3060dc4 	movw	r0, #28100	; 0x6dc4
1000cc10:	e3410003 	movt	r0, #4099	; 0x1003
1000cc14:	e59f100c 	ldr	r1, [pc, #12]	; 1000cc28 <rt_vbus_do_init+0x24>
1000cc18:	eb003db8 	bl	1001c300 <rt_vbus_init>
1000cc1c:	e1a03000 	mov	r3, r0
}
1000cc20:	e1a00003 	mov	r0, r3
1000cc24:	e8bd8800 	pop	{fp, pc}
1000cc28:	100372d0 	.word	0x100372d0

1000cc2c <vbus_sfi_handler>:
INIT_COMPONENT_EXPORT(rt_vbus_do_init);

static void vbus_sfi_handler(void *CallBackRef)
{
1000cc2c:	e92d4800 	push	{fp, lr}
1000cc30:	e28db004 	add	fp, sp, #4
1000cc34:	e24dd008 	sub	sp, sp, #8
1000cc38:	e50b0008 	str	r0, [fp, #-8]
	
	rt_kprintf("in the vbus_sfi_handler\r\n");
1000cc3c:	e3020ee4 	movw	r0, #12004	; 0x2ee4
1000cc40:	e3410003 	movt	r0, #4099	; 0x1003
1000cc44:	eb001b9d 	bl	10013ac0 <rt_kprintf>
	rt_vbus_isr(CPU1_VBUS_SFI_ID, CallBackRef);
1000cc48:	e3a0000e 	mov	r0, #14
1000cc4c:	e51b1008 	ldr	r1, [fp, #-8]
1000cc50:	eb003d96 	bl	1001c2b0 <rt_vbus_isr>
}
1000cc54:	e24bd004 	sub	sp, fp, #4
1000cc58:	e8bd8800 	pop	{fp, pc}

1000cc5c <rt_vbus_hw_init>:


int rt_vbus_hw_init(void)
{
1000cc5c:	e92d4800 	push	{fp, lr}
1000cc60:	e28db004 	add	fp, sp, #4
	#if 0
	XScuGic_Connect(&ScuGic1_InstancePtr, CPU1_VBUS_SFI_ID,vbus_sfi_handler, &ScuGic1_InstancePtr);
	XScuGic_Enable(&ScuGic1_InstancePtr, CPU1_VBUS_SFI_ID);
	#endif
	rt_hw_interrupt_clear(CPU1_VBUS_SFI_ID);
1000cc64:	e3a0000e 	mov	r0, #14
1000cc68:	eb003022 	bl	10018cf8 <rt_hw_interrupt_clear>
	rt_hw_interrupt_install(CPU1_VBUS_SFI_ID,vbus_sfi_handler,(void *)0, "vbus_sfi");
1000cc6c:	e3a0000e 	mov	r0, #14
1000cc70:	e30c1c2c 	movw	r1, #52268	; 0xcc2c
1000cc74:	e3411000 	movt	r1, #4096	; 0x1000
1000cc78:	e3a02000 	mov	r2, #0
1000cc7c:	e3023f00 	movw	r3, #12032	; 0x2f00
1000cc80:	e3413003 	movt	r3, #4099	; 0x1003
1000cc84:	eb002fd8 	bl	10018bec <rt_hw_interrupt_install>
	
	arm_gic_set_cpu(0, CPU1_VBUS_SFI_ID, 1 << rt_cpu_get_smp_id());
1000cc88:	eb00328e 	bl	100196c8 <rt_cpu_get_smp_id>
1000cc8c:	e1a02000 	mov	r2, r0
1000cc90:	e3a03001 	mov	r3, #1
1000cc94:	e1a03213 	lsl	r3, r3, r2
1000cc98:	e3a00000 	mov	r0, #0
1000cc9c:	e3a0100e 	mov	r1, #14
1000cca0:	e1a02003 	mov	r2, r3
1000cca4:	eb002d16 	bl	10018104 <arm_gic_set_cpu>
	rt_hw_interrupt_umask(CPU1_VBUS_SFI_ID);
1000cca8:	e3a0000e 	mov	r0, #14
1000ccac:	eb002fc5 	bl	10018bc8 <rt_hw_interrupt_umask>


	rt_kprintf("the CPU ID is %d\r\n", rt_cpu_get_smp_id());
1000ccb0:	eb003284 	bl	100196c8 <rt_cpu_get_smp_id>
1000ccb4:	e1a03000 	mov	r3, r0
1000ccb8:	e3020f0c 	movw	r0, #12044	; 0x2f0c
1000ccbc:	e3410003 	movt	r0, #4099	; 0x1003
1000ccc0:	e1a01003 	mov	r1, r3
1000ccc4:	eb001b7d 	bl	10013ac0 <rt_kprintf>

    return 0;
1000ccc8:	e3a03000 	mov	r3, #0
}
1000cccc:	e1a00003 	mov	r0, r3
1000ccd0:	e8bd8800 	pop	{fp, pc}

1000ccd4 <rt_vbus_hw_eoi>:

int rt_vbus_hw_eoi(int irqnr, void *param)
{
1000ccd4:	e92d4800 	push	{fp, lr}
1000ccd8:	e28db004 	add	fp, sp, #4
1000ccdc:	e24dd008 	sub	sp, sp, #8
1000cce0:	e50b0008 	str	r0, [fp, #-8]
1000cce4:	e50b100c 	str	r1, [fp, #-12]
    /* Nothing to do here as we cleared the interrupt in IRQHandler. */
	rt_kprintf(" in the rt_vbus_hw_eoi\r\n");
1000cce8:	e3020f20 	movw	r0, #12064	; 0x2f20
1000ccec:	e3410003 	movt	r0, #4099	; 0x1003
1000ccf0:	eb001b72 	bl	10013ac0 <rt_kprintf>
    return 0;
1000ccf4:	e3a03000 	mov	r3, #0
}
1000ccf8:	e1a00003 	mov	r0, r3
1000ccfc:	e24bd004 	sub	sp, fp, #4
1000cd00:	e8bd8800 	pop	{fp, pc}
1000cd04:	00000000 	andeq	r0, r0, r0

1000cd08 <CTRL_setState>:

//! \brief     Sets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] state       The new state
static inline void CTRL_setState(CTRL_Handle handle,const CTRL_State_e state)//! \Mod By Dl.K
{
1000cd08:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000cd0c:	e28db000 	add	fp, sp, #0
1000cd10:	e24dd014 	sub	sp, sp, #20
1000cd14:	e50b0010 	str	r0, [fp, #-16]
1000cd18:	e1a03001 	mov	r3, r1
1000cd1c:	e54b3011 	strb	r3, [fp, #-17]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
1000cd20:	e51b3010 	ldr	r3, [fp, #-16]
1000cd24:	e50b3008 	str	r3, [fp, #-8]

  obj->prevState = obj->state;
1000cd28:	e51b3008 	ldr	r3, [fp, #-8]
1000cd2c:	e5d32008 	ldrb	r2, [r3, #8]
1000cd30:	e51b3008 	ldr	r3, [fp, #-8]
1000cd34:	e5c32009 	strb	r2, [r3, #9]
  obj->state = state;
1000cd38:	e51b3008 	ldr	r3, [fp, #-8]
1000cd3c:	e55b2011 	ldrb	r2, [fp, #-17]
1000cd40:	e5c32008 	strb	r2, [r3, #8]

  return;
1000cd44:	e1a00000 	nop			; (mov r0, r0)
} // end of CTRL_setState() function
1000cd48:	e24bd000 	sub	sp, fp, #0
1000cd4c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000cd50:	e12fff1e 	bx	lr

1000cd54 <state>:
#include "AD7606_drv.h"


extern CTRL_Handle gCtrlHandle;
long state(int argc,char**argv)
{
1000cd54:	e92d4800 	push	{fp, lr}
1000cd58:	e28db004 	add	fp, sp, #4
1000cd5c:	e24dd008 	sub	sp, sp, #8
1000cd60:	e50b0008 	str	r0, [fp, #-8]
1000cd64:	e50b100c 	str	r1, [fp, #-12]
	if(strcmp(argv[1], "0") == 0)
1000cd68:	e51b300c 	ldr	r3, [fp, #-12]
1000cd6c:	e2833004 	add	r3, r3, #4
1000cd70:	e5933000 	ldr	r3, [r3]
1000cd74:	e1a00003 	mov	r0, r3
1000cd78:	e3021f44 	movw	r1, #12100	; 0x2f44
1000cd7c:	e3411003 	movt	r1, #4099	; 0x1003
1000cd80:	fa00879e 	blx	1002ec00 <strcmp>
1000cd84:	e1a03000 	mov	r3, r0
1000cd88:	e3530000 	cmp	r3, #0
1000cd8c:	1a000009 	bne	1000cdb8 <state+0x64>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_Error);
1000cd90:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000cd94:	e3413003 	movt	r3, #4099	; 0x1003
1000cd98:	e5933000 	ldr	r3, [r3]
1000cd9c:	e1a00003 	mov	r0, r3
1000cda0:	e3a01000 	mov	r1, #0
1000cda4:	ebffffd7 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_Error\r\n");
1000cda8:	e3020f48 	movw	r0, #12104	; 0x2f48
1000cdac:	e3410003 	movt	r0, #4099	; 0x1003
1000cdb0:	eb001b42 	bl	10013ac0 <rt_kprintf>
1000cdb4:	ea00009e 	b	1000d034 <state+0x2e0>
	}
	else if(strcmp(argv[1], "1") == 0)
1000cdb8:	e51b300c 	ldr	r3, [fp, #-12]
1000cdbc:	e2833004 	add	r3, r3, #4
1000cdc0:	e5933000 	ldr	r3, [r3]
1000cdc4:	e1a00003 	mov	r0, r3
1000cdc8:	e3021f5c 	movw	r1, #12124	; 0x2f5c
1000cdcc:	e3411003 	movt	r1, #4099	; 0x1003
1000cdd0:	fa00878a 	blx	1002ec00 <strcmp>
1000cdd4:	e1a03000 	mov	r3, r0
1000cdd8:	e3530000 	cmp	r3, #0
1000cddc:	1a000009 	bne	1000ce08 <state+0xb4>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_Idle);
1000cde0:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000cde4:	e3413003 	movt	r3, #4099	; 0x1003
1000cde8:	e5933000 	ldr	r3, [r3]
1000cdec:	e1a00003 	mov	r0, r3
1000cdf0:	e3a01001 	mov	r1, #1
1000cdf4:	ebffffc3 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_Idle\r\n");
1000cdf8:	e3020f60 	movw	r0, #12128	; 0x2f60
1000cdfc:	e3410003 	movt	r0, #4099	; 0x1003
1000ce00:	eb001b2e 	bl	10013ac0 <rt_kprintf>
1000ce04:	ea00008a 	b	1000d034 <state+0x2e0>
	}
	else if(strcmp(argv[1], "2") == 0)
1000ce08:	e51b300c 	ldr	r3, [fp, #-12]
1000ce0c:	e2833004 	add	r3, r3, #4
1000ce10:	e5933000 	ldr	r3, [r3]
1000ce14:	e1a00003 	mov	r0, r3
1000ce18:	e3021f74 	movw	r1, #12148	; 0x2f74
1000ce1c:	e3411003 	movt	r1, #4099	; 0x1003
1000ce20:	fa008776 	blx	1002ec00 <strcmp>
1000ce24:	e1a03000 	mov	r3, r0
1000ce28:	e3530000 	cmp	r3, #0
1000ce2c:	1a000009 	bne	1000ce58 <state+0x104>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_OffLine);
1000ce30:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000ce34:	e3413003 	movt	r3, #4099	; 0x1003
1000ce38:	e5933000 	ldr	r3, [r3]
1000ce3c:	e1a00003 	mov	r0, r3
1000ce40:	e3a01002 	mov	r1, #2
1000ce44:	ebffffaf 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_OffLine\r\n");
1000ce48:	e3020f78 	movw	r0, #12152	; 0x2f78
1000ce4c:	e3410003 	movt	r0, #4099	; 0x1003
1000ce50:	eb001b1a 	bl	10013ac0 <rt_kprintf>
1000ce54:	ea000076 	b	1000d034 <state+0x2e0>
	}	
	else if(strcmp(argv[1], "3") == 0)
1000ce58:	e51b300c 	ldr	r3, [fp, #-12]
1000ce5c:	e2833004 	add	r3, r3, #4
1000ce60:	e5933000 	ldr	r3, [r3]
1000ce64:	e1a00003 	mov	r0, r3
1000ce68:	e3021f90 	movw	r1, #12176	; 0x2f90
1000ce6c:	e3411003 	movt	r1, #4099	; 0x1003
1000ce70:	fa008762 	blx	1002ec00 <strcmp>
1000ce74:	e1a03000 	mov	r3, r0
1000ce78:	e3530000 	cmp	r3, #0
1000ce7c:	1a000009 	bne	1000cea8 <state+0x154>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_InitDete);
1000ce80:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000ce84:	e3413003 	movt	r3, #4099	; 0x1003
1000ce88:	e5933000 	ldr	r3, [r3]
1000ce8c:	e1a00003 	mov	r0, r3
1000ce90:	e3a01004 	mov	r1, #4
1000ce94:	ebffff9b 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_InitDete\r\n");
1000ce98:	e3020f94 	movw	r0, #12180	; 0x2f94
1000ce9c:	e3410003 	movt	r0, #4099	; 0x1003
1000cea0:	eb001b06 	bl	10013ac0 <rt_kprintf>
1000cea4:	ea000062 	b	1000d034 <state+0x2e0>
	}	
	else if(strcmp(argv[1], "4") == 0)
1000cea8:	e51b300c 	ldr	r3, [fp, #-12]
1000ceac:	e2833004 	add	r3, r3, #4
1000ceb0:	e5933000 	ldr	r3, [r3]
1000ceb4:	e1a00003 	mov	r0, r3
1000ceb8:	e3021fac 	movw	r1, #12204	; 0x2fac
1000cebc:	e3411003 	movt	r1, #4099	; 0x1003
1000cec0:	fa00874e 	blx	1002ec00 <strcmp>
1000cec4:	e1a03000 	mov	r3, r0
1000cec8:	e3530000 	cmp	r3, #0
1000cecc:	1a000009 	bne	1000cef8 <state+0x1a4>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_StaticStatorInitDete);
1000ced0:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000ced4:	e3413003 	movt	r3, #4099	; 0x1003
1000ced8:	e5933000 	ldr	r3, [r3]
1000cedc:	e1a00003 	mov	r0, r3
1000cee0:	e3a01005 	mov	r1, #5
1000cee4:	ebffff87 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_StaticStatorInitDete\r\n");
1000cee8:	e3020fb0 	movw	r0, #12208	; 0x2fb0
1000ceec:	e3410003 	movt	r0, #4099	; 0x1003
1000cef0:	eb001af2 	bl	10013ac0 <rt_kprintf>
1000cef4:	ea00004e 	b	1000d034 <state+0x2e0>
	}
	else if(strcmp(argv[1], "5") == 0)
1000cef8:	e51b300c 	ldr	r3, [fp, #-12]
1000cefc:	e2833004 	add	r3, r3, #4
1000cf00:	e5933000 	ldr	r3, [r3]
1000cf04:	e1a00003 	mov	r0, r3
1000cf08:	e3021fd4 	movw	r1, #12244	; 0x2fd4
1000cf0c:	e3411003 	movt	r1, #4099	; 0x1003
1000cf10:	fa00873a 	blx	1002ec00 <strcmp>
1000cf14:	e1a03000 	mov	r3, r0
1000cf18:	e3530000 	cmp	r3, #0
1000cf1c:	1a000009 	bne	1000cf48 <state+0x1f4>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_OpenLoop);
1000cf20:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000cf24:	e3413003 	movt	r3, #4099	; 0x1003
1000cf28:	e5933000 	ldr	r3, [r3]
1000cf2c:	e1a00003 	mov	r0, r3
1000cf30:	e3a01006 	mov	r1, #6
1000cf34:	ebffff73 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_OpenLoop\r\n");
1000cf38:	e3020fd8 	movw	r0, #12248	; 0x2fd8
1000cf3c:	e3410003 	movt	r0, #4099	; 0x1003
1000cf40:	eb001ade 	bl	10013ac0 <rt_kprintf>
1000cf44:	ea00003a 	b	1000d034 <state+0x2e0>
	}
	else if(strcmp(argv[1], "6") == 0)
1000cf48:	e51b300c 	ldr	r3, [fp, #-12]
1000cf4c:	e2833004 	add	r3, r3, #4
1000cf50:	e5933000 	ldr	r3, [r3]
1000cf54:	e1a00003 	mov	r0, r3
1000cf58:	e3021ff0 	movw	r1, #12272	; 0x2ff0
1000cf5c:	e3411003 	movt	r1, #4099	; 0x1003
1000cf60:	fa008726 	blx	1002ec00 <strcmp>
1000cf64:	e1a03000 	mov	r3, r0
1000cf68:	e3530000 	cmp	r3, #0
1000cf6c:	1a000009 	bne	1000cf98 <state+0x244>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_OnLine);
1000cf70:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000cf74:	e3413003 	movt	r3, #4099	; 0x1003
1000cf78:	e5933000 	ldr	r3, [r3]
1000cf7c:	e1a00003 	mov	r0, r3
1000cf80:	e3a01007 	mov	r1, #7
1000cf84:	ebffff5f 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_OnLine\r\n");
1000cf88:	e3020ff4 	movw	r0, #12276	; 0x2ff4
1000cf8c:	e3410003 	movt	r0, #4099	; 0x1003
1000cf90:	eb001aca 	bl	10013ac0 <rt_kprintf>
1000cf94:	ea000026 	b	1000d034 <state+0x2e0>
	}
	else if(strcmp(argv[1], "7") == 0)
1000cf98:	e51b300c 	ldr	r3, [fp, #-12]
1000cf9c:	e2833004 	add	r3, r3, #4
1000cfa0:	e5933000 	ldr	r3, [r3]
1000cfa4:	e1a00003 	mov	r0, r3
1000cfa8:	e3031008 	movw	r1, #12296	; 0x3008
1000cfac:	e3411003 	movt	r1, #4099	; 0x1003
1000cfb0:	fa008712 	blx	1002ec00 <strcmp>
1000cfb4:	e1a03000 	mov	r3, r0
1000cfb8:	e3530000 	cmp	r3, #0
1000cfbc:	1a000009 	bne	1000cfe8 <state+0x294>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_CurrentCloseLoop);
1000cfc0:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000cfc4:	e3413003 	movt	r3, #4099	; 0x1003
1000cfc8:	e5933000 	ldr	r3, [r3]
1000cfcc:	e1a00003 	mov	r0, r3
1000cfd0:	e3a01008 	mov	r1, #8
1000cfd4:	ebffff4b 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_CurrentCloseLoop\r\n");
1000cfd8:	e303000c 	movw	r0, #12300	; 0x300c
1000cfdc:	e3410003 	movt	r0, #4099	; 0x1003
1000cfe0:	eb001ab6 	bl	10013ac0 <rt_kprintf>
1000cfe4:	ea000012 	b	1000d034 <state+0x2e0>
	}
	else if(strcmp(argv[1], "8") == 0)
1000cfe8:	e51b300c 	ldr	r3, [fp, #-12]
1000cfec:	e2833004 	add	r3, r3, #4
1000cff0:	e5933000 	ldr	r3, [r3]
1000cff4:	e1a00003 	mov	r0, r3
1000cff8:	e303102c 	movw	r1, #12332	; 0x302c
1000cffc:	e3411003 	movt	r1, #4099	; 0x1003
1000d000:	fa0086fe 	blx	1002ec00 <strcmp>
1000d004:	e1a03000 	mov	r3, r0
1000d008:	e3530000 	cmp	r3, #0
1000d00c:	1a000008 	bne	1000d034 <state+0x2e0>
	{
		CTRL_setState(gCtrlHandle,CTRL_State_SpeedCloseLoop);
1000d010:	e30f3da8 	movw	r3, #64936	; 0xfda8
1000d014:	e3413003 	movt	r3, #4099	; 0x1003
1000d018:	e5933000 	ldr	r3, [r3]
1000d01c:	e1a00003 	mov	r0, r3
1000d020:	e3a01009 	mov	r1, #9
1000d024:	ebffff37 	bl	1000cd08 <CTRL_setState>
		rt_kprintf("CTRL_State_SpeedCloseLoop\r\n");
1000d028:	e3030030 	movw	r0, #12336	; 0x3030
1000d02c:	e3410003 	movt	r0, #4099	; 0x1003
1000d030:	eb001aa2 	bl	10013ac0 <rt_kprintf>
	}
	//rt_device_close(device);

}
1000d034:	e1a00003 	mov	r0, r3
1000d038:	e24bd004 	sub	sp, fp, #4
1000d03c:	e8bd8800 	pop	{fp, pc}

1000d040 <pwmtest>:
MSH_CMD_EXPORT(state, state);
#include "drv_pwm.h"
//#include "xadc_drv.h"

long pwmtest(int argc,char**argv)
{
1000d040:	e92d4800 	push	{fp, lr}
1000d044:	e28db004 	add	fp, sp, #4
1000d048:	e24dd038 	sub	sp, sp, #56	; 0x38
1000d04c:	e50b0030 	str	r0, [fp, #-48]	; 0x30
1000d050:	e50b1034 	str	r1, [fp, #-52]	; 0x34
	unsigned long clk,duty,deadtime;
	rt_device_t device;
	duty_HandleTypeDef dutyhandle;

	//Xil_Out32((0x43c40000) + (16), 0x80000000);
	rt_kprintf("pwm start\r\n");
1000d054:	e303004c 	movw	r0, #12364	; 0x304c
1000d058:	e3410003 	movt	r0, #4099	; 0x1003
1000d05c:	eb001a97 	bl	10013ac0 <rt_kprintf>
	device = rt_device_find("pwm1");
1000d060:	e3030058 	movw	r0, #12376	; 0x3058
1000d064:	e3410003 	movt	r0, #4099	; 0x1003
1000d068:	eb000579 	bl	1000e654 <rt_device_find>
1000d06c:	e50b0008 	str	r0, [fp, #-8]
	//rt_device_open(device,NULL);
	rt_device_control(device,CMD_PWMEN,NULL);
1000d070:	e51b0008 	ldr	r0, [fp, #-8]
1000d074:	e3a01001 	mov	r1, #1
1000d078:	e3a02000 	mov	r2, #0
1000d07c:	eb0006cb 	bl	1000ebb0 <rt_device_control>
	ctrl_reg = Xil_In32((MYPWM_BASEADDR) + (CTRL_REG));
1000d080:	e3a00014 	mov	r0, #20
1000d084:	e34403c1 	movt	r0, #17345	; 0x43c1
1000d088:	ebffef55 	bl	10008de4 <Xil_In32>
1000d08c:	e1a03000 	mov	r3, r0
1000d090:	e50b300c 	str	r3, [fp, #-12]
	clkdiv_reg = Xil_In32((MYPWM_BASEADDR) + (DIVIDER_REG));
1000d094:	e3a00010 	mov	r0, #16
1000d098:	e34403c1 	movt	r0, #17345	; 0x43c1
1000d09c:	ebffef50 	bl	10008de4 <Xil_In32>
1000d0a0:	e1a03000 	mov	r3, r0
1000d0a4:	e50b3010 	str	r3, [fp, #-16]
	pwm0_duty_reg = Xil_In32((MYPWM_BASEADDR) + (PWM0_DUTY_REG));
1000d0a8:	e3a00000 	mov	r0, #0
1000d0ac:	e34403c1 	movt	r0, #17345	; 0x43c1
1000d0b0:	ebffef4b 	bl	10008de4 <Xil_In32>
1000d0b4:	e1a03000 	mov	r3, r0
1000d0b8:	e50b3014 	str	r3, [fp, #-20]
	rt_kprintf("ctrl %d\r\nclkdiv %d \r\n pwm0duty %d\r\n",ctrl_reg,clkdiv_reg,pwm0_duty_reg);
1000d0bc:	e3030060 	movw	r0, #12384	; 0x3060
1000d0c0:	e3410003 	movt	r0, #4099	; 0x1003
1000d0c4:	e51b100c 	ldr	r1, [fp, #-12]
1000d0c8:	e51b2010 	ldr	r2, [fp, #-16]
1000d0cc:	e51b3014 	ldr	r3, [fp, #-20]
1000d0d0:	eb001a7a 	bl	10013ac0 <rt_kprintf>
	if(argv[1] != NULL)
1000d0d4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000d0d8:	e2833004 	add	r3, r3, #4
1000d0dc:	e5933000 	ldr	r3, [r3]
1000d0e0:	e3530000 	cmp	r3, #0
1000d0e4:	0a000029 	beq	1000d190 <pwmtest+0x150>
	{
		if(strcmp(argv[1], "en") == 0)
1000d0e8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000d0ec:	e2833004 	add	r3, r3, #4
1000d0f0:	e5933000 	ldr	r3, [r3]
1000d0f4:	e1a00003 	mov	r0, r3
1000d0f8:	e3031084 	movw	r1, #12420	; 0x3084
1000d0fc:	e3411003 	movt	r1, #4099	; 0x1003
1000d100:	fa0086be 	blx	1002ec00 <strcmp>
1000d104:	e1a03000 	mov	r3, r0
1000d108:	e3530000 	cmp	r3, #0
1000d10c:	1a000004 	bne	1000d124 <pwmtest+0xe4>
		{
			rt_device_control(device,CMD_PWMEN,NULL);
1000d110:	e51b0008 	ldr	r0, [fp, #-8]
1000d114:	e3a01001 	mov	r1, #1
1000d118:	e3a02000 	mov	r2, #0
1000d11c:	eb0006a3 	bl	1000ebb0 <rt_device_control>
1000d120:	ea00001a 	b	1000d190 <pwmtest+0x150>
		}
		else if(strcmp(argv[1], "dis") == 0)
1000d124:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000d128:	e2833004 	add	r3, r3, #4
1000d12c:	e5933000 	ldr	r3, [r3]
1000d130:	e1a00003 	mov	r0, r3
1000d134:	e3031088 	movw	r1, #12424	; 0x3088
1000d138:	e3411003 	movt	r1, #4099	; 0x1003
1000d13c:	fa0086af 	blx	1002ec00 <strcmp>
1000d140:	e1a03000 	mov	r3, r0
1000d144:	e3530000 	cmp	r3, #0
1000d148:	1a000004 	bne	1000d160 <pwmtest+0x120>
		{
			rt_device_control(device,CMD_PWMDISABLE,NULL);
1000d14c:	e51b0008 	ldr	r0, [fp, #-8]
1000d150:	e3a01002 	mov	r1, #2
1000d154:	e3a02000 	mov	r2, #0
1000d158:	eb000694 	bl	1000ebb0 <rt_device_control>
1000d15c:	ea00000b 	b	1000d190 <pwmtest+0x150>
		}
		else
		{
			clk = atoi(argv[1]);
1000d160:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000d164:	e2833004 	add	r3, r3, #4
1000d168:	e5933000 	ldr	r3, [r3]
1000d16c:	e1a00003 	mov	r0, r3
1000d170:	fa00885d 	blx	1002f2ec <atoi>
1000d174:	e1a03000 	mov	r3, r0
1000d178:	e50b3020 	str	r3, [fp, #-32]
			rt_device_control(device,CMD_PWMSETCLK,&clk);
1000d17c:	e24b3020 	sub	r3, fp, #32
1000d180:	e51b0008 	ldr	r0, [fp, #-8]
1000d184:	e3a01005 	mov	r1, #5
1000d188:	e1a02003 	mov	r2, r3
1000d18c:	eb000687 	bl	1000ebb0 <rt_device_control>
		}
	}
	if(argv[2] != NULL)
1000d190:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000d194:	e2833008 	add	r3, r3, #8
1000d198:	e5933000 	ldr	r3, [r3]
1000d19c:	e3530000 	cmp	r3, #0
1000d1a0:	0a000038 	beq	1000d288 <pwmtest+0x248>
	{
		duty = atoi(argv[2]);
1000d1a4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000d1a8:	e2833008 	add	r3, r3, #8
1000d1ac:	e5933000 	ldr	r3, [r3]
1000d1b0:	e1a00003 	mov	r0, r3
1000d1b4:	fa00884c 	blx	1002f2ec <atoi>
1000d1b8:	e1a03000 	mov	r3, r0
1000d1bc:	e50b3018 	str	r3, [fp, #-24]
		dutyhandle.pwm0_duty = duty * TRIANGLETOP / 1000;
1000d1c0:	e51b1018 	ldr	r1, [fp, #-24]
1000d1c4:	e1a02001 	mov	r2, r1
1000d1c8:	e1a03102 	lsl	r3, r2, #2
1000d1cc:	e1a02003 	mov	r2, r3
1000d1d0:	e1a03282 	lsl	r3, r2, #5
1000d1d4:	e0623003 	rsb	r3, r2, r3
1000d1d8:	e0833001 	add	r3, r3, r1
1000d1dc:	e1a03283 	lsl	r3, r3, #5
1000d1e0:	e1a02003 	mov	r2, r3
1000d1e4:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000d1e8:	e3413062 	movt	r3, #4194	; 0x1062
1000d1ec:	e0832392 	umull	r2, r3, r2, r3
1000d1f0:	e1a03323 	lsr	r3, r3, #6
1000d1f4:	e6ff3073 	uxth	r3, r3
1000d1f8:	e14b32bc 	strh	r3, [fp, #-44]	; 0xffffffd4
		dutyhandle.pwm1_duty = duty * TRIANGLETOP / 1000;
1000d1fc:	e51b1018 	ldr	r1, [fp, #-24]
1000d200:	e1a02001 	mov	r2, r1
1000d204:	e1a03102 	lsl	r3, r2, #2
1000d208:	e1a02003 	mov	r2, r3
1000d20c:	e1a03282 	lsl	r3, r2, #5
1000d210:	e0623003 	rsb	r3, r2, r3
1000d214:	e0833001 	add	r3, r3, r1
1000d218:	e1a03283 	lsl	r3, r3, #5
1000d21c:	e1a02003 	mov	r2, r3
1000d220:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000d224:	e3413062 	movt	r3, #4194	; 0x1062
1000d228:	e0832392 	umull	r2, r3, r2, r3
1000d22c:	e1a03323 	lsr	r3, r3, #6
1000d230:	e6ff3073 	uxth	r3, r3
1000d234:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
		dutyhandle.pwm2_duty = duty * TRIANGLETOP / 1000;
1000d238:	e51b1018 	ldr	r1, [fp, #-24]
1000d23c:	e1a02001 	mov	r2, r1
1000d240:	e1a03102 	lsl	r3, r2, #2
1000d244:	e1a02003 	mov	r2, r3
1000d248:	e1a03282 	lsl	r3, r2, #5
1000d24c:	e0623003 	rsb	r3, r2, r3
1000d250:	e0833001 	add	r3, r3, r1
1000d254:	e1a03283 	lsl	r3, r3, #5
1000d258:	e1a02003 	mov	r2, r3
1000d25c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000d260:	e3413062 	movt	r3, #4194	; 0x1062
1000d264:	e0832392 	umull	r2, r3, r2, r3
1000d268:	e1a03323 	lsr	r3, r3, #6
1000d26c:	e6ff3073 	uxth	r3, r3
1000d270:	e14b32b8 	strh	r3, [fp, #-40]	; 0xffffffd8
		rt_device_control(device,CMD_PWMSETDUTY,&dutyhandle);
1000d274:	e24b302c 	sub	r3, fp, #44	; 0x2c
1000d278:	e51b0008 	ldr	r0, [fp, #-8]
1000d27c:	e3a01003 	mov	r1, #3
1000d280:	e1a02003 	mov	r2, r3
1000d284:	eb000649 	bl	1000ebb0 <rt_device_control>
	}

	if(argv[3] != NULL)
1000d288:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000d28c:	e283300c 	add	r3, r3, #12
1000d290:	e5933000 	ldr	r3, [r3]
1000d294:	e3530000 	cmp	r3, #0
1000d298:	0a00000b 	beq	1000d2cc <pwmtest+0x28c>
	{
		deadtime = atoi(argv[3]);
1000d29c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000d2a0:	e283300c 	add	r3, r3, #12
1000d2a4:	e5933000 	ldr	r3, [r3]
1000d2a8:	e1a00003 	mov	r0, r3
1000d2ac:	fa00880e 	blx	1002f2ec <atoi>
1000d2b0:	e1a03000 	mov	r3, r0
1000d2b4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		
		rt_device_control(device,CMD_PWMSETDEADZONE,&deadtime);
1000d2b8:	e24b3024 	sub	r3, fp, #36	; 0x24
1000d2bc:	e51b0008 	ldr	r0, [fp, #-8]
1000d2c0:	e3a01004 	mov	r1, #4
1000d2c4:	e1a02003 	mov	r2, r3
1000d2c8:	eb000638 	bl	1000ebb0 <rt_device_control>
	}
	ctrl_reg = Xil_In32((MYPWM_BASEADDR) + (CTRL_REG));
1000d2cc:	e3a00014 	mov	r0, #20
1000d2d0:	e34403c1 	movt	r0, #17345	; 0x43c1
1000d2d4:	ebffeec2 	bl	10008de4 <Xil_In32>
1000d2d8:	e1a03000 	mov	r3, r0
1000d2dc:	e50b300c 	str	r3, [fp, #-12]
	clkdiv_reg = Xil_In32((MYPWM_BASEADDR) + (DIVIDER_REG));
1000d2e0:	e3a00010 	mov	r0, #16
1000d2e4:	e34403c1 	movt	r0, #17345	; 0x43c1
1000d2e8:	ebffeebd 	bl	10008de4 <Xil_In32>
1000d2ec:	e1a03000 	mov	r3, r0
1000d2f0:	e50b3010 	str	r3, [fp, #-16]
	pwm0_duty_reg = Xil_In32((MYPWM_BASEADDR) + (PWM0_DUTY_REG));
1000d2f4:	e3a00000 	mov	r0, #0
1000d2f8:	e34403c1 	movt	r0, #17345	; 0x43c1
1000d2fc:	ebffeeb8 	bl	10008de4 <Xil_In32>
1000d300:	e1a03000 	mov	r3, r0
1000d304:	e50b3014 	str	r3, [fp, #-20]
	deadtime_reg = Xil_In32((MYPWM_BASEADDR) + (DEAD_ZONE_REG));
1000d308:	e3a0000c 	mov	r0, #12
1000d30c:	e34403c1 	movt	r0, #17345	; 0x43c1
1000d310:	ebffeeb3 	bl	10008de4 <Xil_In32>
1000d314:	e1a03000 	mov	r3, r0
1000d318:	e50b301c 	str	r3, [fp, #-28]
	rt_kprintf("ctrl %d\r\nclkdiv %d \r\n pwm0duty %d\r\n deadtime ns %d\r\n",ctrl_reg,clkdiv_reg,pwm0_duty_reg,deadtime_reg);
1000d31c:	e51b301c 	ldr	r3, [fp, #-28]
1000d320:	e58d3000 	str	r3, [sp]
1000d324:	e303008c 	movw	r0, #12428	; 0x308c
1000d328:	e3410003 	movt	r0, #4099	; 0x1003
1000d32c:	e51b100c 	ldr	r1, [fp, #-12]
1000d330:	e51b2010 	ldr	r2, [fp, #-16]
1000d334:	e51b3014 	ldr	r3, [fp, #-20]
1000d338:	eb0019e0 	bl	10013ac0 <rt_kprintf>
	
	//rt_device_close(device);
}
1000d33c:	e1a00003 	mov	r0, r3
1000d340:	e24bd004 	sub	sp, fp, #4
1000d344:	e8bd8800 	pop	{fp, pc}

1000d348 <adctest>:
FINSH_FUNCTION_EXPORT(pwmtest, pwmtest clk duty deadtime);
MSH_CMD_EXPORT(pwmtest,pwmtest clk duty deadtime);

long adctest(int argc,char**argv)
{
1000d348:	e92d4800 	push	{fp, lr}
1000d34c:	e28db004 	add	fp, sp, #4
1000d350:	e24dd080 	sub	sp, sp, #128	; 0x80
1000d354:	e50b0080 	str	r0, [fp, #-128]	; 0x80
1000d358:	e50b1084 	str	r1, [fp, #-132]	; 0x84
	unsigned long temp;
	static unsigned char rst = 0;
	
	float tempa,tempb,tempc;
	
	device = rt_device_find("adc1");
1000d35c:	e30300c4 	movw	r0, #12484	; 0x30c4
1000d360:	e3410003 	movt	r0, #4099	; 0x1003
1000d364:	eb0004ba 	bl	1000e654 <rt_device_find>
1000d368:	e50b0008 	str	r0, [fp, #-8]
		rst++;
		
		rt_device_close(device);
	}
	#endif
	if(strcmp(argv[1], "en") == 0)
1000d36c:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
1000d370:	e2833004 	add	r3, r3, #4
1000d374:	e5933000 	ldr	r3, [r3]
1000d378:	e1a00003 	mov	r0, r3
1000d37c:	e3031084 	movw	r1, #12420	; 0x3084
1000d380:	e3411003 	movt	r1, #4099	; 0x1003
1000d384:	fa00861d 	blx	1002ec00 <strcmp>
1000d388:	e1a03000 	mov	r3, r0
1000d38c:	e3530000 	cmp	r3, #0
1000d390:	1a000082 	bne	1000d5a0 <adctest+0x258>
	{
		rt_kprintf("adc test\r\n");
1000d394:	e30300cc 	movw	r0, #12492	; 0x30cc
1000d398:	e3410003 	movt	r0, #4099	; 0x1003
1000d39c:	eb0019c7 	bl	10013ac0 <rt_kprintf>
		
		rt_device_control(device,CMD_INTDISABLE,0);
1000d3a0:	e51b0008 	ldr	r0, [fp, #-8]
1000d3a4:	e3a01002 	mov	r1, #2
1000d3a8:	e3a02000 	mov	r2, #0
1000d3ac:	eb0005ff 	bl	1000ebb0 <rt_device_control>
		//rt_device_open(device,RT_DEVICE_FLAG_RDONLY);
		rt_device_control(device,CMD_CONVST,0);
1000d3b0:	e51b0008 	ldr	r0, [fp, #-8]
1000d3b4:	e3a01005 	mov	r1, #5
1000d3b8:	e3a02000 	mov	r2, #0
1000d3bc:	eb0005fb 	bl	1000ebb0 <rt_device_control>
		rt_device_read (device,
1000d3c0:	e24b3078 	sub	r3, fp, #120	; 0x78
1000d3c4:	e51b0008 	ldr	r0, [fp, #-8]
1000d3c8:	e3a01000 	mov	r1, #0
1000d3cc:	e1a02003 	mov	r2, r3
1000d3d0:	e3a03000 	mov	r3, #0
1000d3d4:	eb00059f 	bl	1000ea58 <rt_device_read>
	                          &adcvalue,
	                          0);
		
		//adcvalue2 = Xil_In32((0x43c40000) + (0x0));
		
		tempa = adcvalue.PhaseA.qI_value / 3276.8 - 3.3;//IV 
1000d3d8:	e15b37b0 	ldrh	r3, [fp, #-112]	; 0xffffff90
1000d3dc:	e6bf3073 	sxth	r3, r3
1000d3e0:	ee073a90 	vmov	s15, r3
1000d3e4:	eef80be7 	vcvt.f64.s32	d16, s15
1000d3e8:	eddf1b80 	vldr	d17, [pc, #512]	; 1000d5f0 <adctest+0x2a8>
1000d3ec:	eec00ba1 	vdiv.f64	d16, d16, d17
1000d3f0:	eddf1b80 	vldr	d17, [pc, #512]	; 1000d5f8 <adctest+0x2b0>
1000d3f4:	ee700be1 	vsub.f64	d16, d16, d17
1000d3f8:	eef77be0 	vcvt.f32.f64	s15, d16
1000d3fc:	ed4b7a03 	vstr	s15, [fp, #-12]
		tempb = adcvalue.PhaseB.qI_value / 3276.8 - 3.3;//IW
1000d400:	e15b36b2 	ldrh	r3, [fp, #-98]	; 0xffffff9e
1000d404:	e6bf3073 	sxth	r3, r3
1000d408:	ee073a90 	vmov	s15, r3
1000d40c:	eef80be7 	vcvt.f64.s32	d16, s15
1000d410:	eddf1b76 	vldr	d17, [pc, #472]	; 1000d5f0 <adctest+0x2a8>
1000d414:	eec00ba1 	vdiv.f64	d16, d16, d17
1000d418:	eddf1b76 	vldr	d17, [pc, #472]	; 1000d5f8 <adctest+0x2b0>
1000d41c:	ee700be1 	vsub.f64	d16, d16, d17
1000d420:	eef77be0 	vcvt.f32.f64	s15, d16
1000d424:	ed4b7a04 	vstr	s15, [fp, #-16]
		tempc = adcvalue.PhaseC.qI_value / 3276.8 - 3.3;//IU
1000d428:	e15b35b4 	ldrh	r3, [fp, #-84]	; 0xffffffac
1000d42c:	e6bf3073 	sxth	r3, r3
1000d430:	ee073a90 	vmov	s15, r3
1000d434:	eef80be7 	vcvt.f64.s32	d16, s15
1000d438:	eddf1b6c 	vldr	d17, [pc, #432]	; 1000d5f0 <adctest+0x2a8>
1000d43c:	eec00ba1 	vdiv.f64	d16, d16, d17
1000d440:	eddf1b6c 	vldr	d17, [pc, #432]	; 1000d5f8 <adctest+0x2b0>
1000d444:	ee700be1 	vsub.f64	d16, d16, d17
1000d448:	eef77be0 	vcvt.f32.f64	s15, d16
1000d44c:	ed4b7a05 	vstr	s15, [fp, #-20]	; 0xffffffec

		tempa = tempa * 8.77;//IV 
1000d450:	ed5b7a03 	vldr	s15, [fp, #-12]
1000d454:	eef70ae7 	vcvt.f64.f32	d16, s15
1000d458:	eddf1b68 	vldr	d17, [pc, #416]	; 1000d600 <adctest+0x2b8>
1000d45c:	ee600ba1 	vmul.f64	d16, d16, d17
1000d460:	eef77be0 	vcvt.f32.f64	s15, d16
1000d464:	ed4b7a03 	vstr	s15, [fp, #-12]
		tempb = tempb * 8.77;//IW
1000d468:	ed5b7a04 	vldr	s15, [fp, #-16]
1000d46c:	eef70ae7 	vcvt.f64.f32	d16, s15
1000d470:	eddf1b62 	vldr	d17, [pc, #392]	; 1000d600 <adctest+0x2b8>
1000d474:	ee600ba1 	vmul.f64	d16, d16, d17
1000d478:	eef77be0 	vcvt.f32.f64	s15, d16
1000d47c:	ed4b7a04 	vstr	s15, [fp, #-16]
		tempc = tempc * 8.77;//IU	
1000d480:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
1000d484:	eef70ae7 	vcvt.f64.f32	d16, s15
1000d488:	eddf1b5c 	vldr	d17, [pc, #368]	; 1000d600 <adctest+0x2b8>
1000d48c:	ee600ba1 	vmul.f64	d16, d16, d17
1000d490:	eef77be0 	vcvt.f32.f64	s15, d16
1000d494:	ed4b7a05 	vstr	s15, [fp, #-20]	; 0xffffffec

		rt_kprintf("phase a %x\r\n",adcvalue.PhaseA.qI_value);
1000d498:	e15b37b0 	ldrh	r3, [fp, #-112]	; 0xffffff90
1000d49c:	e6bf3073 	sxth	r3, r3
1000d4a0:	e30300d8 	movw	r0, #12504	; 0x30d8
1000d4a4:	e3410003 	movt	r0, #4099	; 0x1003
1000d4a8:	e1a01003 	mov	r1, r3
1000d4ac:	eb001983 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase b %x\r\n",adcvalue.PhaseB.qI_value);
1000d4b0:	e15b36b2 	ldrh	r3, [fp, #-98]	; 0xffffff9e
1000d4b4:	e6bf3073 	sxth	r3, r3
1000d4b8:	e30300e8 	movw	r0, #12520	; 0x30e8
1000d4bc:	e3410003 	movt	r0, #4099	; 0x1003
1000d4c0:	e1a01003 	mov	r1, r3
1000d4c4:	eb00197d 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase C %x\r\n",adcvalue.PhaseC.qI_value);
1000d4c8:	e15b35b4 	ldrh	r3, [fp, #-84]	; 0xffffffac
1000d4cc:	e6bf3073 	sxth	r3, r3
1000d4d0:	e30300f8 	movw	r0, #12536	; 0x30f8
1000d4d4:	e3410003 	movt	r0, #4099	; 0x1003
1000d4d8:	e1a01003 	mov	r1, r3
1000d4dc:	eb001977 	bl	10013ac0 <rt_kprintf>
		
		
		rt_kprintf("phase a %d\r\n",(int)(tempa * 1000));
1000d4e0:	ed5b7a03 	vldr	s15, [fp, #-12]
1000d4e4:	ed9f7a47 	vldr	s14, [pc, #284]	; 1000d608 <adctest+0x2c0>
1000d4e8:	ee677a87 	vmul.f32	s15, s15, s14
1000d4ec:	eefd7ae7 	vcvt.s32.f32	s15, s15
1000d4f0:	e3030108 	movw	r0, #12552	; 0x3108
1000d4f4:	e3410003 	movt	r0, #4099	; 0x1003
1000d4f8:	ee171a90 	vmov	r1, s15
1000d4fc:	eb00196f 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase b %d\r\n",(int)(tempb * 1000));
1000d500:	ed5b7a04 	vldr	s15, [fp, #-16]
1000d504:	ed9f7a3f 	vldr	s14, [pc, #252]	; 1000d608 <adctest+0x2c0>
1000d508:	ee677a87 	vmul.f32	s15, s15, s14
1000d50c:	eefd7ae7 	vcvt.s32.f32	s15, s15
1000d510:	e3030118 	movw	r0, #12568	; 0x3118
1000d514:	e3410003 	movt	r0, #4099	; 0x1003
1000d518:	ee171a90 	vmov	r1, s15
1000d51c:	eb001967 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase C %d\r\n",(int)(tempc * 1000));
1000d520:	ed5b7a05 	vldr	s15, [fp, #-20]	; 0xffffffec
1000d524:	ed9f7a37 	vldr	s14, [pc, #220]	; 1000d608 <adctest+0x2c0>
1000d528:	ee677a87 	vmul.f32	s15, s15, s14
1000d52c:	eefd7ae7 	vcvt.s32.f32	s15, s15
1000d530:	e3030128 	movw	r0, #12584	; 0x3128
1000d534:	e3410003 	movt	r0, #4099	; 0x1003
1000d538:	ee171a90 	vmov	r1, s15
1000d53c:	eb00195f 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("BUS V %d\r\n",adcvalue.BUS.qV_value);
1000d540:	e15b34ba 	ldrh	r3, [fp, #-74]	; 0xffffffb6
1000d544:	e6bf3073 	sxth	r3, r3
1000d548:	e3030138 	movw	r0, #12600	; 0x3138
1000d54c:	e3410003 	movt	r0, #4099	; 0x1003
1000d550:	e1a01003 	mov	r1, r3
1000d554:	eb001959 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("Temp %d\r\n",adcvalue.Temp.TEMP_value);
1000d558:	e15b31bc 	ldrh	r3, [fp, #-28]	; 0xffffffe4
1000d55c:	e6bf3073 	sxth	r3, r3
1000d560:	e3030144 	movw	r0, #12612	; 0x3144
1000d564:	e3410003 	movt	r0, #4099	; 0x1003
1000d568:	e1a01003 	mov	r1, r3
1000d56c:	eb001953 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase AV %d\r\n",adcvalue.PhaseA.qV_value);
1000d570:	e15b36be 	ldrh	r3, [fp, #-110]	; 0xffffff92
1000d574:	e6bf3073 	sxth	r3, r3
1000d578:	e3030150 	movw	r0, #12624	; 0x3150
1000d57c:	e3410003 	movt	r0, #4099	; 0x1003
1000d580:	e1a01003 	mov	r1, r3
1000d584:	eb00194d 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase BV %d\r\n",adcvalue.PhaseB.qV_value);
1000d588:	e15b36b0 	ldrh	r3, [fp, #-96]	; 0xffffffa0
1000d58c:	e6bf3073 	sxth	r3, r3
1000d590:	e3030160 	movw	r0, #12640	; 0x3160
1000d594:	e3410003 	movt	r0, #4099	; 0x1003
1000d598:	e1a01003 	mov	r1, r3
1000d59c:	eb001947 	bl	10013ac0 <rt_kprintf>

		//rt_device_close(device);
	}
	if(strcmp(argv[1], "close") == 0)
1000d5a0:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
1000d5a4:	e2833004 	add	r3, r3, #4
1000d5a8:	e5933000 	ldr	r3, [r3]
1000d5ac:	e1a00003 	mov	r0, r3
1000d5b0:	e3031170 	movw	r1, #12656	; 0x3170
1000d5b4:	e3411003 	movt	r1, #4099	; 0x1003
1000d5b8:	fa008590 	blx	1002ec00 <strcmp>
1000d5bc:	e1a03000 	mov	r3, r0
1000d5c0:	e3530000 	cmp	r3, #0
1000d5c4:	1a000006 	bne	1000d5e4 <adctest+0x29c>
	{
		
		//rt_device_open(device,RT_DEVICE_FLAG_RDONLY);
		rt_kprintf("adc close\r\n");
1000d5c8:	e3030178 	movw	r0, #12664	; 0x3178
1000d5cc:	e3410003 	movt	r0, #4099	; 0x1003
1000d5d0:	eb00193a 	bl	10013ac0 <rt_kprintf>
		device = rt_device_find("adc1");
1000d5d4:	e30300c4 	movw	r0, #12484	; 0x30c4
1000d5d8:	e3410003 	movt	r0, #4099	; 0x1003
1000d5dc:	eb00041c 	bl	1000e654 <rt_device_find>
1000d5e0:	e50b0008 	str	r0, [fp, #-8]
		//rt_device_close(device);
	}
}
1000d5e4:	e1a00003 	mov	r0, r3
1000d5e8:	e24bd004 	sub	sp, fp, #4
1000d5ec:	e8bd8800 	pop	{fp, pc}
1000d5f0:	9999999a 	.word	0x9999999a
1000d5f4:	40a99999 	.word	0x40a99999
1000d5f8:	66666666 	.word	0x66666666
1000d5fc:	400a6666 	.word	0x400a6666
1000d600:	70a3d70a 	.word	0x70a3d70a
1000d604:	40218a3d 	.word	0x40218a3d
1000d608:	447a0000 	.word	0x447a0000

1000d60c <qeptest>:
#include "drv_qep.h"
extern int speed;
extern unsigned int t_array[1000];

long qeptest(int argc,char**argv)
{
1000d60c:	e92d4800 	push	{fp, lr}
1000d610:	e28db004 	add	fp, sp, #4
1000d614:	e24dd018 	sub	sp, sp, #24
1000d618:	e50b0018 	str	r0, [fp, #-24]
1000d61c:	e50b101c 	str	r1, [fp, #-28]
	unsigned long ctrl_reg;
	rt_device_t device;
	Qep_ValueTypeDef qep_data;

	rt_kprintf("qep start\r\n");
1000d620:	e3030184 	movw	r0, #12676	; 0x3184
1000d624:	e3410003 	movt	r0, #4099	; 0x1003
1000d628:	eb001924 	bl	10013ac0 <rt_kprintf>
	device = rt_device_find("qep1");
1000d62c:	e3030190 	movw	r0, #12688	; 0x3190
1000d630:	e3410003 	movt	r0, #4099	; 0x1003
1000d634:	eb000406 	bl	1000e654 <rt_device_find>
1000d638:	e50b0008 	str	r0, [fp, #-8]
	//rt_device_open(device,NULL);
	ctrl_reg = Xil_In32((MYQEP_BASEADDR) + (MYQEP_CTRL_REG));
1000d63c:	e3a00008 	mov	r0, #8
1000d640:	e34403c3 	movt	r0, #17347	; 0x43c3
1000d644:	ebffede6 	bl	10008de4 <Xil_In32>
1000d648:	e1a03000 	mov	r3, r0
1000d64c:	e50b300c 	str	r3, [fp, #-12]
	rt_kprintf("ctrl %x\r\n",ctrl_reg);
1000d650:	e3030198 	movw	r0, #12696	; 0x3198
1000d654:	e3410003 	movt	r0, #4099	; 0x1003
1000d658:	e51b100c 	ldr	r1, [fp, #-12]
1000d65c:	eb001917 	bl	10013ac0 <rt_kprintf>
	rt_kprintf("period = %x",Xil_In32((MYQEP_BASEADDR) + (MYQEP_TURN_REG)));
1000d660:	e3a00004 	mov	r0, #4
1000d664:	e34403c3 	movt	r0, #17347	; 0x43c3
1000d668:	ebffeddd 	bl	10008de4 <Xil_In32>
1000d66c:	e1a03000 	mov	r3, r0
1000d670:	e30301a4 	movw	r0, #12708	; 0x31a4
1000d674:	e3410003 	movt	r0, #4099	; 0x1003
1000d678:	e1a01003 	mov	r1, r3
1000d67c:	eb00190f 	bl	10013ac0 <rt_kprintf>
	if(argv[1] != NULL)
1000d680:	e51b301c 	ldr	r3, [fp, #-28]
1000d684:	e2833004 	add	r3, r3, #4
1000d688:	e5933000 	ldr	r3, [r3]
1000d68c:	e3530000 	cmp	r3, #0
1000d690:	0a000073 	beq	1000d864 <qeptest+0x258>
	{
		if(strcmp(argv[1], "en") == 0)
1000d694:	e51b301c 	ldr	r3, [fp, #-28]
1000d698:	e2833004 	add	r3, r3, #4
1000d69c:	e5933000 	ldr	r3, [r3]
1000d6a0:	e1a00003 	mov	r0, r3
1000d6a4:	e3031084 	movw	r1, #12420	; 0x3084
1000d6a8:	e3411003 	movt	r1, #4099	; 0x1003
1000d6ac:	fa008553 	blx	1002ec00 <strcmp>
1000d6b0:	e1a03000 	mov	r3, r0
1000d6b4:	e3530000 	cmp	r3, #0
1000d6b8:	1a00000d 	bne	1000d6f4 <qeptest+0xe8>
		{
			rt_device_control(device,CMD_QEPEN,NULL);
1000d6bc:	e51b0008 	ldr	r0, [fp, #-8]
1000d6c0:	e3a01001 	mov	r1, #1
1000d6c4:	e3a02000 	mov	r2, #0
1000d6c8:	eb000538 	bl	1000ebb0 <rt_device_control>
			
			ctrl_reg = Xil_In32((MYQEP_BASEADDR) + (MYQEP_CTRL_REG));
1000d6cc:	e3a00008 	mov	r0, #8
1000d6d0:	e34403c3 	movt	r0, #17347	; 0x43c3
1000d6d4:	ebffedc2 	bl	10008de4 <Xil_In32>
1000d6d8:	e1a03000 	mov	r3, r0
1000d6dc:	e50b300c 	str	r3, [fp, #-12]
			rt_kprintf("ctrl %x\r\n",ctrl_reg);
1000d6e0:	e3030198 	movw	r0, #12696	; 0x3198
1000d6e4:	e3410003 	movt	r0, #4099	; 0x1003
1000d6e8:	e51b100c 	ldr	r1, [fp, #-12]
1000d6ec:	eb0018f3 	bl	10013ac0 <rt_kprintf>
1000d6f0:	ea00005b 	b	1000d864 <qeptest+0x258>
		}
		else if(strcmp(argv[1], "dis") == 0)
1000d6f4:	e51b301c 	ldr	r3, [fp, #-28]
1000d6f8:	e2833004 	add	r3, r3, #4
1000d6fc:	e5933000 	ldr	r3, [r3]
1000d700:	e1a00003 	mov	r0, r3
1000d704:	e3031088 	movw	r1, #12424	; 0x3088
1000d708:	e3411003 	movt	r1, #4099	; 0x1003
1000d70c:	fa00853b 	blx	1002ec00 <strcmp>
1000d710:	e1a03000 	mov	r3, r0
1000d714:	e3530000 	cmp	r3, #0
1000d718:	1a00000d 	bne	1000d754 <qeptest+0x148>
		{
			rt_device_control(device,CMD_QEPDISABLE,NULL);
1000d71c:	e51b0008 	ldr	r0, [fp, #-8]
1000d720:	e3a01002 	mov	r1, #2
1000d724:	e3a02000 	mov	r2, #0
1000d728:	eb000520 	bl	1000ebb0 <rt_device_control>
			
			ctrl_reg = Xil_In32((MYQEP_BASEADDR) + (MYQEP_CTRL_REG));
1000d72c:	e3a00008 	mov	r0, #8
1000d730:	e34403c3 	movt	r0, #17347	; 0x43c3
1000d734:	ebffedaa 	bl	10008de4 <Xil_In32>
1000d738:	e1a03000 	mov	r3, r0
1000d73c:	e50b300c 	str	r3, [fp, #-12]
			rt_kprintf("ctrl %x\r\n",ctrl_reg);
1000d740:	e3030198 	movw	r0, #12696	; 0x3198
1000d744:	e3410003 	movt	r0, #4099	; 0x1003
1000d748:	e51b100c 	ldr	r1, [fp, #-12]
1000d74c:	eb0018db 	bl	10013ac0 <rt_kprintf>
1000d750:	ea000043 	b	1000d864 <qeptest+0x258>
		}
		else if(strcmp(argv[1], "read") == 0)
1000d754:	e51b301c 	ldr	r3, [fp, #-28]
1000d758:	e2833004 	add	r3, r3, #4
1000d75c:	e5933000 	ldr	r3, [r3]
1000d760:	e1a00003 	mov	r0, r3
1000d764:	e30311b0 	movw	r1, #12720	; 0x31b0
1000d768:	e3411003 	movt	r1, #4099	; 0x1003
1000d76c:	fa008523 	blx	1002ec00 <strcmp>
1000d770:	e1a03000 	mov	r3, r0
1000d774:	e3530000 	cmp	r3, #0
1000d778:	1a000039 	bne	1000d864 <qeptest+0x258>
		{
			rt_device_read(device,0,&qep_data,0);
1000d77c:	e24b3014 	sub	r3, fp, #20
1000d780:	e51b0008 	ldr	r0, [fp, #-8]
1000d784:	e3a01000 	mov	r1, #0
1000d788:	e1a02003 	mov	r2, r3
1000d78c:	e3a03000 	mov	r3, #0
1000d790:	eb0004b0 	bl	1000ea58 <rt_device_read>
			
			rt_kprintf("cnt= %x\r\nturn = %x\r\n",qep_data.cnt,qep_data.turn);
1000d794:	e51b2010 	ldr	r2, [fp, #-16]
1000d798:	e51b3014 	ldr	r3, [fp, #-20]
1000d79c:	e30301b8 	movw	r0, #12728	; 0x31b8
1000d7a0:	e3410003 	movt	r0, #4099	; 0x1003
1000d7a4:	e1a01002 	mov	r1, r2
1000d7a8:	e1a02003 	mov	r2, r3
1000d7ac:	eb0018c3 	bl	10013ac0 <rt_kprintf>
			if(t_array[125] > t_array[0])
1000d7b0:	e3003b50 	movw	r3, #2896	; 0xb50
1000d7b4:	e3413004 	movt	r3, #4100	; 0x1004
1000d7b8:	e59321f4 	ldr	r2, [r3, #500]	; 0x1f4
1000d7bc:	e3003b50 	movw	r3, #2896	; 0xb50
1000d7c0:	e3413004 	movt	r3, #4100	; 0x1004
1000d7c4:	e5933000 	ldr	r3, [r3]
1000d7c8:	e1520003 	cmp	r2, r3
1000d7cc:	9a000012 	bls	1000d81c <qeptest+0x210>
			{
				speed = (t_array[125] - t_array[0]);
1000d7d0:	e3003b50 	movw	r3, #2896	; 0xb50
1000d7d4:	e3413004 	movt	r3, #4100	; 0x1004
1000d7d8:	e59321f4 	ldr	r2, [r3, #500]	; 0x1f4
1000d7dc:	e3003b50 	movw	r3, #2896	; 0xb50
1000d7e0:	e3413004 	movt	r3, #4100	; 0x1004
1000d7e4:	e5933000 	ldr	r3, [r3]
1000d7e8:	e0633002 	rsb	r3, r3, r2
1000d7ec:	e1a02003 	mov	r2, r3
1000d7f0:	e30235b0 	movw	r3, #9648	; 0x25b0
1000d7f4:	e3413004 	movt	r3, #4100	; 0x1004
1000d7f8:	e5832000 	str	r2, [r3]
				rt_kprintf("forwardspeed = %d\r\n",speed);// Mechanics:10000, t:10ms, x/10000/10ms:mechanical speed
1000d7fc:	e30235b0 	movw	r3, #9648	; 0x25b0
1000d800:	e3413004 	movt	r3, #4100	; 0x1004
1000d804:	e5933000 	ldr	r3, [r3]
1000d808:	e30301d0 	movw	r0, #12752	; 0x31d0
1000d80c:	e3410003 	movt	r0, #4099	; 0x1003
1000d810:	e1a01003 	mov	r1, r3
1000d814:	eb0018a9 	bl	10013ac0 <rt_kprintf>
1000d818:	ea000011 	b	1000d864 <qeptest+0x258>
			}
			else
			{
				speed = (t_array[0] - t_array[125]);
1000d81c:	e3003b50 	movw	r3, #2896	; 0xb50
1000d820:	e3413004 	movt	r3, #4100	; 0x1004
1000d824:	e5932000 	ldr	r2, [r3]
1000d828:	e3003b50 	movw	r3, #2896	; 0xb50
1000d82c:	e3413004 	movt	r3, #4100	; 0x1004
1000d830:	e59331f4 	ldr	r3, [r3, #500]	; 0x1f4
1000d834:	e0633002 	rsb	r3, r3, r2
1000d838:	e1a02003 	mov	r2, r3
1000d83c:	e30235b0 	movw	r3, #9648	; 0x25b0
1000d840:	e3413004 	movt	r3, #4100	; 0x1004
1000d844:	e5832000 	str	r2, [r3]
				rt_kprintf("reversespeed = %d\r\n",speed);
1000d848:	e30235b0 	movw	r3, #9648	; 0x25b0
1000d84c:	e3413004 	movt	r3, #4100	; 0x1004
1000d850:	e5933000 	ldr	r3, [r3]
1000d854:	e30301e4 	movw	r0, #12772	; 0x31e4
1000d858:	e3410003 	movt	r0, #4099	; 0x1003
1000d85c:	e1a01003 	mov	r1, r3
1000d860:	eb001896 	bl	10013ac0 <rt_kprintf>
			}
		}
		
	}
	//rt_device_close(device);
}
1000d864:	e1a00003 	mov	r0, r3
1000d868:	e24bd004 	sub	sp, fp, #4
1000d86c:	e8bd8800 	pop	{fp, pc}

1000d870 <mmtest>:

#include "motor_misc.h"
#include "drv_motor_misc.h"

long mmtest(int argc,char**argv)
{
1000d870:	e92d4800 	push	{fp, lr}
1000d874:	e28db004 	add	fp, sp, #4
1000d878:	e24dd010 	sub	sp, sp, #16
1000d87c:	e50b0010 	str	r0, [fp, #-16]
1000d880:	e50b1014 	str	r1, [fp, #-20]
	rt_device_t device;
	device = rt_device_find("motor_misc1");
1000d884:	e30301f8 	movw	r0, #12792	; 0x31f8
1000d888:	e3410003 	movt	r0, #4099	; 0x1003
1000d88c:	eb000370 	bl	1000e654 <rt_device_find>
1000d890:	e50b0008 	str	r0, [fp, #-8]
	unsigned long intrstate;
	unsigned int temp;
	
	if(strcmp(argv[1], "en") == 0)
1000d894:	e51b3014 	ldr	r3, [fp, #-20]
1000d898:	e2833004 	add	r3, r3, #4
1000d89c:	e5933000 	ldr	r3, [r3]
1000d8a0:	e1a00003 	mov	r0, r3
1000d8a4:	e3031084 	movw	r1, #12420	; 0x3084
1000d8a8:	e3411003 	movt	r1, #4099	; 0x1003
1000d8ac:	fa0084d3 	blx	1002ec00 <strcmp>
1000d8b0:	e1a03000 	mov	r3, r0
1000d8b4:	e3530000 	cmp	r3, #0
1000d8b8:	1a000022 	bne	1000d948 <mmtest+0xd8>
	{
		//rt_device_open(device,NULL);
		//rt_device_read(device,0,&intrstate,0);
		//rt_kprintf("intr state: %x\r\n",intrstate);
		temp = 100;
1000d8bc:	e3a03064 	mov	r3, #100	; 0x64
1000d8c0:	e50b300c 	str	r3, [fp, #-12]
		rt_device_control(device,CMD_MISC_SET_BREAK_DUTY,&temp);
1000d8c4:	e24b300c 	sub	r3, fp, #12
1000d8c8:	e51b0008 	ldr	r0, [fp, #-8]
1000d8cc:	e3a01003 	mov	r1, #3
1000d8d0:	e1a02003 	mov	r2, r3
1000d8d4:	eb0004b5 	bl	1000ebb0 <rt_device_control>
		temp = 5000;
1000d8d8:	e3013388 	movw	r3, #5000	; 0x1388
1000d8dc:	e50b300c 	str	r3, [fp, #-12]
		rt_device_control(device,CMD_MISC_SET_FAN_DUTY,&temp);
1000d8e0:	e24b300c 	sub	r3, fp, #12
1000d8e4:	e51b0008 	ldr	r0, [fp, #-8]
1000d8e8:	e3a01004 	mov	r1, #4
1000d8ec:	e1a02003 	mov	r2, r3
1000d8f0:	eb0004ae 	bl	1000ebb0 <rt_device_control>
		temp = 1;
1000d8f4:	e3a03001 	mov	r3, #1
1000d8f8:	e50b300c 	str	r3, [fp, #-12]
		rt_device_control(device,CMD_MISC_BREAKEN,&temp);
1000d8fc:	e24b300c 	sub	r3, fp, #12
1000d900:	e51b0008 	ldr	r0, [fp, #-8]
1000d904:	e3a01005 	mov	r1, #5
1000d908:	e1a02003 	mov	r2, r3
1000d90c:	eb0004a7 	bl	1000ebb0 <rt_device_control>
		temp = 1;
1000d910:	e3a03001 	mov	r3, #1
1000d914:	e50b300c 	str	r3, [fp, #-12]
		rt_device_control(device,CMD_MISC_FANEN,&temp);
1000d918:	e24b300c 	sub	r3, fp, #12
1000d91c:	e51b0008 	ldr	r0, [fp, #-8]
1000d920:	e3a01006 	mov	r1, #6
1000d924:	e1a02003 	mov	r2, r3
1000d928:	eb0004a0 	bl	1000ebb0 <rt_device_control>
		temp = 1;
1000d92c:	e3a03001 	mov	r3, #1
1000d930:	e50b300c 	str	r3, [fp, #-12]
		//rt_device_control(device,CMD_MISC_CLR_FLAG,&temp);
		
		rt_device_control(device,CMD_MISC_INTENABLE,NULL);
1000d934:	e51b0008 	ldr	r0, [fp, #-8]
1000d938:	e3a01001 	mov	r1, #1
1000d93c:	e3a02000 	mov	r2, #0
1000d940:	eb00049a 	bl	1000ebb0 <rt_device_control>
1000d944:	ea00002a 	b	1000d9f4 <mmtest+0x184>
		
		//rt_device_close(device);
		
	}
	else if(strcmp(argv[1], "dis") == 0)
1000d948:	e51b3014 	ldr	r3, [fp, #-20]
1000d94c:	e2833004 	add	r3, r3, #4
1000d950:	e5933000 	ldr	r3, [r3]
1000d954:	e1a00003 	mov	r0, r3
1000d958:	e3031088 	movw	r1, #12424	; 0x3088
1000d95c:	e3411003 	movt	r1, #4099	; 0x1003
1000d960:	fa0084a6 	blx	1002ec00 <strcmp>
1000d964:	e1a03000 	mov	r3, r0
1000d968:	e3530000 	cmp	r3, #0
1000d96c:	1a000020 	bne	1000d9f4 <mmtest+0x184>
	{
		
		//rt_device_open(device,NULL);
		temp = 0;
1000d970:	e3a03000 	mov	r3, #0
1000d974:	e50b300c 	str	r3, [fp, #-12]
		rt_device_control(device,CMD_MISC_INTDISABLE,NULL);
1000d978:	e51b0008 	ldr	r0, [fp, #-8]
1000d97c:	e3a01002 	mov	r1, #2
1000d980:	e3a02000 	mov	r2, #0
1000d984:	eb000489 	bl	1000ebb0 <rt_device_control>
		rt_device_control(device,CMD_MISC_SET_BREAK_DUTY,&temp);
1000d988:	e24b300c 	sub	r3, fp, #12
1000d98c:	e51b0008 	ldr	r0, [fp, #-8]
1000d990:	e3a01003 	mov	r1, #3
1000d994:	e1a02003 	mov	r2, r3
1000d998:	eb000484 	bl	1000ebb0 <rt_device_control>
		rt_device_control(device,CMD_MISC_BREAKEN,&temp);
1000d99c:	e24b300c 	sub	r3, fp, #12
1000d9a0:	e51b0008 	ldr	r0, [fp, #-8]
1000d9a4:	e3a01005 	mov	r1, #5
1000d9a8:	e1a02003 	mov	r2, r3
1000d9ac:	eb00047f 	bl	1000ebb0 <rt_device_control>
		rt_device_control(device,CMD_MISC_FANEN,&temp);
1000d9b0:	e24b300c 	sub	r3, fp, #12
1000d9b4:	e51b0008 	ldr	r0, [fp, #-8]
1000d9b8:	e3a01006 	mov	r1, #6
1000d9bc:	e1a02003 	mov	r2, r3
1000d9c0:	eb00047a 	bl	1000ebb0 <rt_device_control>
		rt_device_control(device,CMD_MISC_SET_FAN_DUTY,&temp);
1000d9c4:	e24b300c 	sub	r3, fp, #12
1000d9c8:	e51b0008 	ldr	r0, [fp, #-8]
1000d9cc:	e3a01004 	mov	r1, #4
1000d9d0:	e1a02003 	mov	r2, r3
1000d9d4:	eb000475 	bl	1000ebb0 <rt_device_control>
		rt_device_control(device,CMD_MISC_CLR_FLAG,NULL);
1000d9d8:	e51b0008 	ldr	r0, [fp, #-8]
1000d9dc:	e3a01008 	mov	r1, #8
1000d9e0:	e3a02000 	mov	r2, #0
1000d9e4:	eb000471 	bl	1000ebb0 <rt_device_control>
		
		//rt_device_close(device);
		rt_kprintf("close\r\n");
1000d9e8:	e3030204 	movw	r0, #12804	; 0x3204
1000d9ec:	e3410003 	movt	r0, #4099	; 0x1003
1000d9f0:	eb001832 	bl	10013ac0 <rt_kprintf>
	}

}
1000d9f4:	e1a00003 	mov	r0, r3
1000d9f8:	e24bd004 	sub	sp, fp, #4
1000d9fc:	e8bd8800 	pop	{fp, pc}

1000da00 <rlytest>:
FINSH_FUNCTION_EXPORT(mmtest, mmtest en dis);
MSH_CMD_EXPORT(mmtest, mmtest en dis);

long rlytest(int argc,char**argv)
{
1000da00:	e92d4800 	push	{fp, lr}
1000da04:	e28db004 	add	fp, sp, #4
1000da08:	e24dd010 	sub	sp, sp, #16
1000da0c:	e50b0010 	str	r0, [fp, #-16]
1000da10:	e50b1014 	str	r1, [fp, #-20]
	rt_device_t device;
	device = rt_device_find("motor_misc1");
1000da14:	e30301f8 	movw	r0, #12792	; 0x31f8
1000da18:	e3410003 	movt	r0, #4099	; 0x1003
1000da1c:	eb00030c 	bl	1000e654 <rt_device_find>
1000da20:	e50b0008 	str	r0, [fp, #-8]
	unsigned long intrstate;
	unsigned int temp;
	//rt_device_open(device,NULL);
	if(strcmp(argv[1], "set") == 0)
1000da24:	e51b3014 	ldr	r3, [fp, #-20]
1000da28:	e2833004 	add	r3, r3, #4
1000da2c:	e5933000 	ldr	r3, [r3]
1000da30:	e1a00003 	mov	r0, r3
1000da34:	e303120c 	movw	r1, #12812	; 0x320c
1000da38:	e3411003 	movt	r1, #4099	; 0x1003
1000da3c:	fa00846f 	blx	1002ec00 <strcmp>
1000da40:	e1a03000 	mov	r3, r0
1000da44:	e3530000 	cmp	r3, #0
1000da48:	1a000004 	bne	1000da60 <rlytest+0x60>
	{
		rt_device_control(device,CMD_MISC_SET_RLY,NULL);
1000da4c:	e51b0008 	ldr	r0, [fp, #-8]
1000da50:	e3a01009 	mov	r1, #9
1000da54:	e3a02000 	mov	r2, #0
1000da58:	eb000454 	bl	1000ebb0 <rt_device_control>
1000da5c:	ea00000d 	b	1000da98 <rlytest+0x98>
		
	}
	else if(strcmp(argv[1], "clr") == 0)
1000da60:	e51b3014 	ldr	r3, [fp, #-20]
1000da64:	e2833004 	add	r3, r3, #4
1000da68:	e5933000 	ldr	r3, [r3]
1000da6c:	e1a00003 	mov	r0, r3
1000da70:	e3031210 	movw	r1, #12816	; 0x3210
1000da74:	e3411003 	movt	r1, #4099	; 0x1003
1000da78:	fa008460 	blx	1002ec00 <strcmp>
1000da7c:	e1a03000 	mov	r3, r0
1000da80:	e3530000 	cmp	r3, #0
1000da84:	1a000003 	bne	1000da98 <rlytest+0x98>
	{
		rt_device_control(device,CMD_MISC_CLR_RLY,NULL);
1000da88:	e51b0008 	ldr	r0, [fp, #-8]
1000da8c:	e3a0100a 	mov	r1, #10
1000da90:	e3a02000 	mov	r2, #0
1000da94:	eb000445 	bl	1000ebb0 <rt_device_control>
	}
	//rt_device_close(device);
	return 0;
1000da98:	e3a03000 	mov	r3, #0
}
1000da9c:	e1a00003 	mov	r0, r3
1000daa0:	e24bd004 	sub	sp, fp, #4
1000daa4:	e8bd8800 	pop	{fp, pc}

1000daa8 <sharememtest>:
FINSH_FUNCTION_EXPORT(rlytest, rlytest set clr);
MSH_CMD_EXPORT(rlytest, rlytest set clr);

long sharememtest(int argc,char**argv)
{
1000daa8:	e92d4810 	push	{r4, fp, lr}
1000daac:	e28db008 	add	fp, sp, #8
1000dab0:	e24dd01c 	sub	sp, sp, #28
1000dab4:	e50b0020 	str	r0, [fp, #-32]
1000dab8:	e50b1024 	str	r1, [fp, #-36]	; 0x24
	rt_device_t device;
	device = rt_device_find("sharemem1");
1000dabc:	e3030214 	movw	r0, #12820	; 0x3214
1000dac0:	e3410003 	movt	r0, #4099	; 0x1003
1000dac4:	eb0002e2 	bl	1000e654 <rt_device_find>
1000dac8:	e50b0014 	str	r0, [fp, #-20]
	rt_device_open(device,NULL);
1000dacc:	e51b0014 	ldr	r0, [fp, #-20]
1000dad0:	e3a01000 	mov	r1, #0
1000dad4:	eb000342 	bl	1000e7e4 <rt_device_open>
	int *p,i;
	if(argc > 0)
1000dad8:	e51b3020 	ldr	r3, [fp, #-32]
1000dadc:	e3530000 	cmp	r3, #0
1000dae0:	da000032 	ble	1000dbb0 <sharememtest+0x108>
	{
		p = rt_malloc(argc-1);
1000dae4:	e51b3020 	ldr	r3, [fp, #-32]
1000dae8:	e2433001 	sub	r3, r3, #1
1000daec:	e1a00003 	mov	r0, r3
1000daf0:	eb0019e7 	bl	10014294 <rt_malloc>
1000daf4:	e50b0018 	str	r0, [fp, #-24]
		if(p != NULL)
1000daf8:	e51b3018 	ldr	r3, [fp, #-24]
1000dafc:	e3530000 	cmp	r3, #0
1000db00:	0a00002a 	beq	1000dbb0 <sharememtest+0x108>
		{
			for(i = 0; i < argc-1; i++)
1000db04:	e3a03000 	mov	r3, #0
1000db08:	e50b3010 	str	r3, [fp, #-16]
1000db0c:	ea000019 	b	1000db78 <sharememtest+0xd0>
			{
				*(p+i) = atoi(argv[i+1]);
1000db10:	e51b3010 	ldr	r3, [fp, #-16]
1000db14:	e1a03103 	lsl	r3, r3, #2
1000db18:	e51b2018 	ldr	r2, [fp, #-24]
1000db1c:	e0824003 	add	r4, r2, r3
1000db20:	e51b3010 	ldr	r3, [fp, #-16]
1000db24:	e2833001 	add	r3, r3, #1
1000db28:	e1a03103 	lsl	r3, r3, #2
1000db2c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1000db30:	e0823003 	add	r3, r2, r3
1000db34:	e5933000 	ldr	r3, [r3]
1000db38:	e1a00003 	mov	r0, r3
1000db3c:	fa0085ea 	blx	1002f2ec <atoi>
1000db40:	e1a03000 	mov	r3, r0
1000db44:	e5843000 	str	r3, [r4]
				rt_kprintf("%x \r\n",*(p+i));
1000db48:	e51b3010 	ldr	r3, [fp, #-16]
1000db4c:	e1a03103 	lsl	r3, r3, #2
1000db50:	e51b2018 	ldr	r2, [fp, #-24]
1000db54:	e0823003 	add	r3, r2, r3
1000db58:	e5933000 	ldr	r3, [r3]
1000db5c:	e3030220 	movw	r0, #12832	; 0x3220
1000db60:	e3410003 	movt	r0, #4099	; 0x1003
1000db64:	e1a01003 	mov	r1, r3
1000db68:	eb0017d4 	bl	10013ac0 <rt_kprintf>
	if(argc > 0)
	{
		p = rt_malloc(argc-1);
		if(p != NULL)
		{
			for(i = 0; i < argc-1; i++)
1000db6c:	e51b3010 	ldr	r3, [fp, #-16]
1000db70:	e2833001 	add	r3, r3, #1
1000db74:	e50b3010 	str	r3, [fp, #-16]
1000db78:	e51b3020 	ldr	r3, [fp, #-32]
1000db7c:	e2432001 	sub	r2, r3, #1
1000db80:	e51b3010 	ldr	r3, [fp, #-16]
1000db84:	e1520003 	cmp	r2, r3
1000db88:	caffffe0 	bgt	1000db10 <sharememtest+0x68>
			{
				*(p+i) = atoi(argv[i+1]);
				rt_kprintf("%x \r\n",*(p+i));
			}
			rt_device_write(device,0,p,4*(argc-1));
1000db8c:	e51b3020 	ldr	r3, [fp, #-32]
1000db90:	e2433001 	sub	r3, r3, #1
1000db94:	e1a03103 	lsl	r3, r3, #2
1000db98:	e51b0014 	ldr	r0, [fp, #-20]
1000db9c:	e3a01000 	mov	r1, #0
1000dba0:	e51b2018 	ldr	r2, [fp, #-24]
1000dba4:	eb0003d6 	bl	1000eb04 <rt_device_write>
			rt_free(p);
1000dba8:	e51b0018 	ldr	r0, [fp, #-24]
1000dbac:	eb001bd3 	bl	10014b00 <rt_free>
		}
	}
	return 0;
1000dbb0:	e3a03000 	mov	r3, #0
}
1000dbb4:	e1a00003 	mov	r0, r3
1000dbb8:	e24bd008 	sub	sp, fp, #8
1000dbbc:	e8bd8810 	pop	{r4, fp, pc}

1000dbc0 <Motor_Hardware_Init>:
#define SLEEPTIME(ms) (((ms)/1000)*RT_TICK_PER_SECOND)
extern HAL_Obj gHal;

#define USER_MOTORTASK_PRIORITY (10)
static void Motor_Hardware_Init(void)
{
1000dbc0:	e92d4800 	push	{fp, lr}
1000dbc4:	e28db004 	add	fp, sp, #4
1000dbc8:	e24dd088 	sub	sp, sp, #136	; 0x88
	rt_device_t device_pwm,device_qep,device_misc,device_adc;
	unsigned int temp;
	QIEMW_ADC_HandleTypeDef adcvalue;
	float tempa,tempb,tempc;

	device_misc = rt_device_find("motor_misc1");
1000dbcc:	e30301f8 	movw	r0, #12792	; 0x31f8
1000dbd0:	e3410003 	movt	r0, #4099	; 0x1003
1000dbd4:	eb00029e 	bl	1000e654 <rt_device_find>
1000dbd8:	e50b000c 	str	r0, [fp, #-12]
	rt_device_open(device_misc,NULL);
1000dbdc:	e51b000c 	ldr	r0, [fp, #-12]
1000dbe0:	e3a01000 	mov	r1, #0
1000dbe4:	eb0002fe 	bl	1000e7e4 <rt_device_open>
	temp = 100;
1000dbe8:	e3a03064 	mov	r3, #100	; 0x64
1000dbec:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	rt_device_control(device_misc,CMD_MISC_SET_BREAK_DUTY,&temp);
1000dbf0:	e24b3028 	sub	r3, fp, #40	; 0x28
1000dbf4:	e51b000c 	ldr	r0, [fp, #-12]
1000dbf8:	e3a01003 	mov	r1, #3
1000dbfc:	e1a02003 	mov	r2, r3
1000dc00:	eb0003ea 	bl	1000ebb0 <rt_device_control>
	temp = 5000;
1000dc04:	e3013388 	movw	r3, #5000	; 0x1388
1000dc08:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	rt_device_control(device_misc,CMD_MISC_SET_FAN_DUTY,&temp);
1000dc0c:	e24b3028 	sub	r3, fp, #40	; 0x28
1000dc10:	e51b000c 	ldr	r0, [fp, #-12]
1000dc14:	e3a01004 	mov	r1, #4
1000dc18:	e1a02003 	mov	r2, r3
1000dc1c:	eb0003e3 	bl	1000ebb0 <rt_device_control>
	temp = 1;
1000dc20:	e3a03001 	mov	r3, #1
1000dc24:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	rt_device_control(device_misc,CMD_MISC_BREAKEN,&temp);
1000dc28:	e24b3028 	sub	r3, fp, #40	; 0x28
1000dc2c:	e51b000c 	ldr	r0, [fp, #-12]
1000dc30:	e3a01005 	mov	r1, #5
1000dc34:	e1a02003 	mov	r2, r3
1000dc38:	eb0003dc 	bl	1000ebb0 <rt_device_control>
	temp = 1;
1000dc3c:	e3a03001 	mov	r3, #1
1000dc40:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	rt_device_control(device_misc,CMD_MISC_FANEN,&temp);
1000dc44:	e24b3028 	sub	r3, fp, #40	; 0x28
1000dc48:	e51b000c 	ldr	r0, [fp, #-12]
1000dc4c:	e3a01006 	mov	r1, #6
1000dc50:	e1a02003 	mov	r2, r3
1000dc54:	eb0003d5 	bl	1000ebb0 <rt_device_control>
	temp = 1;
1000dc58:	e3a03001 	mov	r3, #1
1000dc5c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	rt_device_control(device_misc,CMD_MISC_INTENABLE,NULL);
1000dc60:	e51b000c 	ldr	r0, [fp, #-12]
1000dc64:	e3a01001 	mov	r1, #1
1000dc68:	e3a02000 	mov	r2, #0
1000dc6c:	eb0003cf 	bl	1000ebb0 <rt_device_control>
	
	device_pwm = rt_device_find("pwm1");
1000dc70:	e3030058 	movw	r0, #12376	; 0x3058
1000dc74:	e3410003 	movt	r0, #4099	; 0x1003
1000dc78:	eb000275 	bl	1000e654 <rt_device_find>
1000dc7c:	e50b0010 	str	r0, [fp, #-16]
	rt_device_open(device_pwm,NULL);
1000dc80:	e51b0010 	ldr	r0, [fp, #-16]
1000dc84:	e3a01000 	mov	r1, #0
1000dc88:	eb0002d5 	bl	1000e7e4 <rt_device_open>
	rt_device_control(device_pwm,CMD_PWMEN,NULL);
1000dc8c:	e51b0010 	ldr	r0, [fp, #-16]
1000dc90:	e3a01001 	mov	r1, #1
1000dc94:	e3a02000 	mov	r2, #0
1000dc98:	eb0003c4 	bl	1000ebb0 <rt_device_control>
	
	device_qep = rt_device_find("qep1");
1000dc9c:	e3030190 	movw	r0, #12688	; 0x3190
1000dca0:	e3410003 	movt	r0, #4099	; 0x1003
1000dca4:	eb00026a 	bl	1000e654 <rt_device_find>
1000dca8:	e50b0014 	str	r0, [fp, #-20]
	rt_device_open(device_qep,NULL);
1000dcac:	e51b0014 	ldr	r0, [fp, #-20]
1000dcb0:	e3a01000 	mov	r1, #0
1000dcb4:	eb0002ca 	bl	1000e7e4 <rt_device_open>
	rt_device_control(device_qep,CMD_QEPEN,NULL);
1000dcb8:	e51b0014 	ldr	r0, [fp, #-20]
1000dcbc:	e3a01001 	mov	r1, #1
1000dcc0:	e3a02000 	mov	r2, #0
1000dcc4:	eb0003b9 	bl	1000ebb0 <rt_device_control>


	rt_device_control(device_misc,CMD_MISC_SET_RLY,NULL);
1000dcc8:	e51b000c 	ldr	r0, [fp, #-12]
1000dccc:	e3a01009 	mov	r1, #9
1000dcd0:	e3a02000 	mov	r2, #0
1000dcd4:	eb0003b5 	bl	1000ebb0 <rt_device_control>

	
	device_adc = rt_device_find("adc1");
1000dcd8:	e30300c4 	movw	r0, #12484	; 0x30c4
1000dcdc:	e3410003 	movt	r0, #4099	; 0x1003
1000dce0:	eb00025b 	bl	1000e654 <rt_device_find>
1000dce4:	e50b0018 	str	r0, [fp, #-24]
	rt_device_open(device_adc,NULL);
1000dce8:	e51b0018 	ldr	r0, [fp, #-24]
1000dcec:	e3a01000 	mov	r1, #0
1000dcf0:	eb0002bb 	bl	1000e7e4 <rt_device_open>
	
	rt_device_control(device_adc,CMD_INTDISABLE,0);
1000dcf4:	e51b0018 	ldr	r0, [fp, #-24]
1000dcf8:	e3a01002 	mov	r1, #2
1000dcfc:	e3a02000 	mov	r2, #0
1000dd00:	eb0003aa 	bl	1000ebb0 <rt_device_control>
	int i = 10;
1000dd04:	e3a0300a 	mov	r3, #10
1000dd08:	e50b3008 	str	r3, [fp, #-8]
	while(i--)
1000dd0c:	ea00007b 	b	1000df00 <Motor_Hardware_Init+0x340>
	{
		rt_device_control(device_adc,CMD_CONVST,0);
1000dd10:	e51b0018 	ldr	r0, [fp, #-24]
1000dd14:	e3a01005 	mov	r1, #5
1000dd18:	e3a02000 	mov	r2, #0
1000dd1c:	eb0003a3 	bl	1000ebb0 <rt_device_control>
		rt_device_read (device_adc,
1000dd20:	e24b308c 	sub	r3, fp, #140	; 0x8c
1000dd24:	e51b0018 	ldr	r0, [fp, #-24]
1000dd28:	e3a01000 	mov	r1, #0
1000dd2c:	e1a02003 	mov	r2, r3
1000dd30:	e3a03000 	mov	r3, #0
1000dd34:	eb000347 	bl	1000ea58 <rt_device_read>
							  0,
							  &adcvalue,
							  0);


		tempa = adcvalue.PhaseA.qI_value / 3276.8 - 3.3;//IV 
1000dd38:	e15b38b4 	ldrh	r3, [fp, #-132]	; 0xffffff7c
1000dd3c:	e6bf3073 	sxth	r3, r3
1000dd40:	ee073a90 	vmov	s15, r3
1000dd44:	eef80be7 	vcvt.f64.s32	d16, s15
1000dd48:	eddf1bb0 	vldr	d17, [pc, #704]	; 1000e010 <Motor_Hardware_Init+0x450>
1000dd4c:	eec00ba1 	vdiv.f64	d16, d16, d17
1000dd50:	eddf1bb0 	vldr	d17, [pc, #704]	; 1000e018 <Motor_Hardware_Init+0x458>
1000dd54:	ee700be1 	vsub.f64	d16, d16, d17
1000dd58:	eef77be0 	vcvt.f32.f64	s15, d16
1000dd5c:	ed4b7a07 	vstr	s15, [fp, #-28]	; 0xffffffe4
		tempb = adcvalue.PhaseB.qI_value / 3276.8 - 3.3;//IW
1000dd60:	e15b37b6 	ldrh	r3, [fp, #-118]	; 0xffffff8a
1000dd64:	e6bf3073 	sxth	r3, r3
1000dd68:	ee073a90 	vmov	s15, r3
1000dd6c:	eef80be7 	vcvt.f64.s32	d16, s15
1000dd70:	eddf1ba6 	vldr	d17, [pc, #664]	; 1000e010 <Motor_Hardware_Init+0x450>
1000dd74:	eec00ba1 	vdiv.f64	d16, d16, d17
1000dd78:	eddf1ba6 	vldr	d17, [pc, #664]	; 1000e018 <Motor_Hardware_Init+0x458>
1000dd7c:	ee700be1 	vsub.f64	d16, d16, d17
1000dd80:	eef77be0 	vcvt.f32.f64	s15, d16
1000dd84:	ed4b7a08 	vstr	s15, [fp, #-32]	; 0xffffffe0
		tempc = adcvalue.PhaseC.qI_value / 3276.8 - 3.3;//IU
1000dd88:	e15b36b8 	ldrh	r3, [fp, #-104]	; 0xffffff98
1000dd8c:	e6bf3073 	sxth	r3, r3
1000dd90:	ee073a90 	vmov	s15, r3
1000dd94:	eef80be7 	vcvt.f64.s32	d16, s15
1000dd98:	eddf1b9c 	vldr	d17, [pc, #624]	; 1000e010 <Motor_Hardware_Init+0x450>
1000dd9c:	eec00ba1 	vdiv.f64	d16, d16, d17
1000dda0:	eddf1b9c 	vldr	d17, [pc, #624]	; 1000e018 <Motor_Hardware_Init+0x458>
1000dda4:	ee700be1 	vsub.f64	d16, d16, d17
1000dda8:	eef77be0 	vcvt.f32.f64	s15, d16
1000ddac:	ed4b7a09 	vstr	s15, [fp, #-36]	; 0xffffffdc

		tempa = tempa * 8.77;//IV 
1000ddb0:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
1000ddb4:	eef70ae7 	vcvt.f64.f32	d16, s15
1000ddb8:	eddf1b98 	vldr	d17, [pc, #608]	; 1000e020 <Motor_Hardware_Init+0x460>
1000ddbc:	ee600ba1 	vmul.f64	d16, d16, d17
1000ddc0:	eef77be0 	vcvt.f32.f64	s15, d16
1000ddc4:	ed4b7a07 	vstr	s15, [fp, #-28]	; 0xffffffe4
		tempb = tempb * 8.77;//IW
1000ddc8:	ed5b7a08 	vldr	s15, [fp, #-32]	; 0xffffffe0
1000ddcc:	eef70ae7 	vcvt.f64.f32	d16, s15
1000ddd0:	eddf1b92 	vldr	d17, [pc, #584]	; 1000e020 <Motor_Hardware_Init+0x460>
1000ddd4:	ee600ba1 	vmul.f64	d16, d16, d17
1000ddd8:	eef77be0 	vcvt.f32.f64	s15, d16
1000dddc:	ed4b7a08 	vstr	s15, [fp, #-32]	; 0xffffffe0
		tempc = tempc * 8.77;//IU	
1000dde0:	ed5b7a09 	vldr	s15, [fp, #-36]	; 0xffffffdc
1000dde4:	eef70ae7 	vcvt.f64.f32	d16, s15
1000dde8:	eddf1b8c 	vldr	d17, [pc, #560]	; 1000e020 <Motor_Hardware_Init+0x460>
1000ddec:	ee600ba1 	vmul.f64	d16, d16, d17
1000ddf0:	eef77be0 	vcvt.f32.f64	s15, d16
1000ddf4:	ed4b7a09 	vstr	s15, [fp, #-36]	; 0xffffffdc

		gHal.adcBias.I.value[0] += tempa;//IV 
1000ddf8:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000ddfc:	e3413003 	movt	r3, #4099	; 0x1003
1000de00:	ed937a36 	vldr	s14, [r3, #216]	; 0xd8
1000de04:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
1000de08:	ee777a27 	vadd.f32	s15, s14, s15
1000de0c:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000de10:	e3413003 	movt	r3, #4099	; 0x1003
1000de14:	edc37a36 	vstr	s15, [r3, #216]	; 0xd8
		gHal.adcBias.I.value[1] += tempb;//IW
1000de18:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000de1c:	e3413003 	movt	r3, #4099	; 0x1003
1000de20:	ed937a37 	vldr	s14, [r3, #220]	; 0xdc
1000de24:	ed5b7a08 	vldr	s15, [fp, #-32]	; 0xffffffe0
1000de28:	ee777a27 	vadd.f32	s15, s14, s15
1000de2c:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000de30:	e3413003 	movt	r3, #4099	; 0x1003
1000de34:	edc37a37 	vstr	s15, [r3, #220]	; 0xdc
		gHal.adcBias.I.value[2] += tempc;//IU
1000de38:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000de3c:	e3413003 	movt	r3, #4099	; 0x1003
1000de40:	ed937a38 	vldr	s14, [r3, #224]	; 0xe0
1000de44:	ed5b7a09 	vldr	s15, [fp, #-36]	; 0xffffffdc
1000de48:	ee777a27 	vadd.f32	s15, s14, s15
1000de4c:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000de50:	e3413003 	movt	r3, #4099	; 0x1003
1000de54:	edc37a38 	vstr	s15, [r3, #224]	; 0xe0
		
		rt_kprintf("phase a %x\r\n",adcvalue.PhaseA.qI_value);
1000de58:	e15b38b4 	ldrh	r3, [fp, #-132]	; 0xffffff7c
1000de5c:	e6bf3073 	sxth	r3, r3
1000de60:	e30300d8 	movw	r0, #12504	; 0x30d8
1000de64:	e3410003 	movt	r0, #4099	; 0x1003
1000de68:	e1a01003 	mov	r1, r3
1000de6c:	eb001713 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase b %x\r\n",adcvalue.PhaseB.qI_value);
1000de70:	e15b37b6 	ldrh	r3, [fp, #-118]	; 0xffffff8a
1000de74:	e6bf3073 	sxth	r3, r3
1000de78:	e30300e8 	movw	r0, #12520	; 0x30e8
1000de7c:	e3410003 	movt	r0, #4099	; 0x1003
1000de80:	e1a01003 	mov	r1, r3
1000de84:	eb00170d 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase C %x\r\n",adcvalue.PhaseC.qI_value);
1000de88:	e15b36b8 	ldrh	r3, [fp, #-104]	; 0xffffff98
1000de8c:	e6bf3073 	sxth	r3, r3
1000de90:	e30300f8 	movw	r0, #12536	; 0x30f8
1000de94:	e3410003 	movt	r0, #4099	; 0x1003
1000de98:	e1a01003 	mov	r1, r3
1000de9c:	eb001707 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase a %d\r\n",tempa * 1000);
1000dea0:	ed5b7a07 	vldr	s15, [fp, #-28]	; 0xffffffe4
1000dea4:	ed9f7a5f 	vldr	s14, [pc, #380]	; 1000e028 <Motor_Hardware_Init+0x468>
1000dea8:	ee677a87 	vmul.f32	s15, s15, s14
1000deac:	eef70ae7 	vcvt.f64.f32	d16, s15
1000deb0:	e3030108 	movw	r0, #12552	; 0x3108
1000deb4:	e3410003 	movt	r0, #4099	; 0x1003
1000deb8:	ec532b30 	vmov	r2, r3, d16
1000debc:	eb0016ff 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase b %d\r\n",tempb * 1000);
1000dec0:	ed5b7a08 	vldr	s15, [fp, #-32]	; 0xffffffe0
1000dec4:	ed9f7a57 	vldr	s14, [pc, #348]	; 1000e028 <Motor_Hardware_Init+0x468>
1000dec8:	ee677a87 	vmul.f32	s15, s15, s14
1000decc:	eef70ae7 	vcvt.f64.f32	d16, s15
1000ded0:	e3030118 	movw	r0, #12568	; 0x3118
1000ded4:	e3410003 	movt	r0, #4099	; 0x1003
1000ded8:	ec532b30 	vmov	r2, r3, d16
1000dedc:	eb0016f7 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("phase C %d\r\n",tempc * 1000);
1000dee0:	ed5b7a09 	vldr	s15, [fp, #-36]	; 0xffffffdc
1000dee4:	ed9f7a4f 	vldr	s14, [pc, #316]	; 1000e028 <Motor_Hardware_Init+0x468>
1000dee8:	ee677a87 	vmul.f32	s15, s15, s14
1000deec:	eef70ae7 	vcvt.f64.f32	d16, s15
1000def0:	e3030128 	movw	r0, #12584	; 0x3128
1000def4:	e3410003 	movt	r0, #4099	; 0x1003
1000def8:	ec532b30 	vmov	r2, r3, d16
1000defc:	eb0016ef 	bl	10013ac0 <rt_kprintf>
	device_adc = rt_device_find("adc1");
	rt_device_open(device_adc,NULL);
	
	rt_device_control(device_adc,CMD_INTDISABLE,0);
	int i = 10;
	while(i--)
1000df00:	e51b3008 	ldr	r3, [fp, #-8]
1000df04:	e2432001 	sub	r2, r3, #1
1000df08:	e50b2008 	str	r2, [fp, #-8]
1000df0c:	e3530000 	cmp	r3, #0
1000df10:	1affff7e 	bne	1000dd10 <Motor_Hardware_Init+0x150>
		gHal.adcBias.I.value[1] = gHal.adcBias.I.value[1] * 8.77;//IW
		gHal.adcBias.I.value[2] = gHal.adcBias.I.value[2] * 8.77;//IU
		#endif
	}

	gHal.adcBias.I.value[0] = gHal.adcBias.I.value[0] / 10;
1000df14:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000df18:	e3413003 	movt	r3, #4099	; 0x1003
1000df1c:	edd37a36 	vldr	s15, [r3, #216]	; 0xd8
1000df20:	eeb27a04 	vmov.f32	s14, #36	; 0x24
1000df24:	eec77a87 	vdiv.f32	s15, s15, s14
1000df28:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000df2c:	e3413003 	movt	r3, #4099	; 0x1003
1000df30:	edc37a36 	vstr	s15, [r3, #216]	; 0xd8
	gHal.adcBias.I.value[1] = gHal.adcBias.I.value[1] / 10;
1000df34:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000df38:	e3413003 	movt	r3, #4099	; 0x1003
1000df3c:	edd37a37 	vldr	s15, [r3, #220]	; 0xdc
1000df40:	eeb27a04 	vmov.f32	s14, #36	; 0x24
1000df44:	eec77a87 	vdiv.f32	s15, s15, s14
1000df48:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000df4c:	e3413003 	movt	r3, #4099	; 0x1003
1000df50:	edc37a37 	vstr	s15, [r3, #220]	; 0xdc
	gHal.adcBias.I.value[2] = gHal.adcBias.I.value[2] / 10;
1000df54:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000df58:	e3413003 	movt	r3, #4099	; 0x1003
1000df5c:	edd37a38 	vldr	s15, [r3, #224]	; 0xe0
1000df60:	eeb27a04 	vmov.f32	s14, #36	; 0x24
1000df64:	eec77a87 	vdiv.f32	s15, s15, s14
1000df68:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000df6c:	e3413003 	movt	r3, #4099	; 0x1003
1000df70:	edc37a38 	vstr	s15, [r3, #224]	; 0xe0

	i = gHal.adcBias.I.value[0] * 1000;
1000df74:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000df78:	e3413003 	movt	r3, #4099	; 0x1003
1000df7c:	edd37a36 	vldr	s15, [r3, #216]	; 0xd8
1000df80:	ed9f7a28 	vldr	s14, [pc, #160]	; 1000e028 <Motor_Hardware_Init+0x468>
1000df84:	ee677a87 	vmul.f32	s15, s15, s14
1000df88:	eefd7ae7 	vcvt.s32.f32	s15, s15
1000df8c:	ee173a90 	vmov	r3, s15
1000df90:	e50b3008 	str	r3, [fp, #-8]
	rt_kprintf("phase a bias %d\r\n",i);
1000df94:	e3030228 	movw	r0, #12840	; 0x3228
1000df98:	e3410003 	movt	r0, #4099	; 0x1003
1000df9c:	e51b1008 	ldr	r1, [fp, #-8]
1000dfa0:	eb0016c6 	bl	10013ac0 <rt_kprintf>
	rt_kprintf("phase b bias %d\r\n",gHal.adcBias.I.value[1] * 1000);
1000dfa4:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000dfa8:	e3413003 	movt	r3, #4099	; 0x1003
1000dfac:	edd37a37 	vldr	s15, [r3, #220]	; 0xdc
1000dfb0:	ed9f7a1c 	vldr	s14, [pc, #112]	; 1000e028 <Motor_Hardware_Init+0x468>
1000dfb4:	ee677a87 	vmul.f32	s15, s15, s14
1000dfb8:	eef70ae7 	vcvt.f64.f32	d16, s15
1000dfbc:	e303023c 	movw	r0, #12860	; 0x323c
1000dfc0:	e3410003 	movt	r0, #4099	; 0x1003
1000dfc4:	ec532b30 	vmov	r2, r3, d16
1000dfc8:	eb0016bc 	bl	10013ac0 <rt_kprintf>
	rt_kprintf("phase C bias %d\r\n",gHal.adcBias.I.value[2] * 1000);
1000dfcc:	e30f3ca0 	movw	r3, #64672	; 0xfca0
1000dfd0:	e3413003 	movt	r3, #4099	; 0x1003
1000dfd4:	edd37a38 	vldr	s15, [r3, #224]	; 0xe0
1000dfd8:	ed9f7a12 	vldr	s14, [pc, #72]	; 1000e028 <Motor_Hardware_Init+0x468>
1000dfdc:	ee677a87 	vmul.f32	s15, s15, s14
1000dfe0:	eef70ae7 	vcvt.f64.f32	d16, s15
1000dfe4:	e3030250 	movw	r0, #12880	; 0x3250
1000dfe8:	e3410003 	movt	r0, #4099	; 0x1003
1000dfec:	ec532b30 	vmov	r2, r3, d16
1000dff0:	eb0016b2 	bl	10013ac0 <rt_kprintf>

	
	rt_device_control(device_adc,CMD_INTENABLE,0);
1000dff4:	e51b0018 	ldr	r0, [fp, #-24]
1000dff8:	e3a01001 	mov	r1, #1
1000dffc:	e3a02000 	mov	r2, #0
1000e000:	eb0002ea 	bl	1000ebb0 <rt_device_control>

}
1000e004:	e24bd004 	sub	sp, fp, #4
1000e008:	e8bd8800 	pop	{fp, pc}
1000e00c:	e320f000 	nop	{0}
1000e010:	9999999a 	.word	0x9999999a
1000e014:	40a99999 	.word	0x40a99999
1000e018:	66666666 	.word	0x66666666
1000e01c:	400a6666 	.word	0x400a6666
1000e020:	70a3d70a 	.word	0x70a3d70a
1000e024:	40218a3d 	.word	0x40218a3d
1000e028:	447a0000 	.word	0x447a0000

1000e02c <USER_MotorTask_entry>:
extern int vb[260];
extern unsigned int j;
extern int spd[260];

void USER_MotorTask_entry(void *parameter)
{
1000e02c:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
1000e030:	e28db014 	add	fp, sp, #20
1000e034:	e24dd028 	sub	sp, sp, #40	; 0x28
1000e038:	e50b0020 	str	r0, [fp, #-32]
	
	Motor_Ctrl_Init();
1000e03c:	ebffcc29 	bl	100010e8 <Motor_Ctrl_Init>
	Motor_Hardware_Init();
1000e040:	ebfffede 	bl	1000dbc0 <Motor_Hardware_Init>
	rt_device_t device;

	
	device = rt_device_find("pwm1");
1000e044:	e3030058 	movw	r0, #12376	; 0x3058
1000e048:	e3410003 	movt	r0, #4099	; 0x1003
1000e04c:	eb000180 	bl	1000e654 <rt_device_find>
1000e050:	e50b001c 	str	r0, [fp, #-28]
	//stm32_hw_QEP_init();
	while(1)
	{
		//rt_kprintf("state: %d\r\n", gCtrl.state);

		if(j > 260)
1000e054:	e30c3004 	movw	r3, #49156	; 0xc004
1000e058:	e3413003 	movt	r3, #4099	; 0x1003
1000e05c:	e5933000 	ldr	r3, [r3]
1000e060:	e3530f41 	cmp	r3, #260	; 0x104
1000e064:	9a00003e 	bls	1000e164 <USER_MotorTask_entry+0x138>
		{

		j = 0;
1000e068:	e30c3004 	movw	r3, #49156	; 0xc004
1000e06c:	e3413003 	movt	r3, #4099	; 0x1003
1000e070:	e3a02000 	mov	r2, #0
1000e074:	e5832000 	str	r2, [r3]
		//rt_device_open(device,NULL);
		//rt_device_control(device,CMD_PWMDISABLE,NULL);
			int i=0;
1000e078:	e3a03000 	mov	r3, #0
1000e07c:	e50b3018 	str	r3, [fp, #-24]
			
			for(i = 0; i < 260;i++)
1000e080:	e3a03000 	mov	r3, #0
1000e084:	e50b3018 	str	r3, [fp, #-24]
1000e088:	ea000032 	b	1000e158 <USER_MotorTask_entry+0x12c>
			{
				rt_kprintf("0: %5d;1: %5d;2: %5d;p: %8d;ao: %9d;a: %9d;va: %9d;vb: %10d;spd: %5d\r\n",pwm0[i],pwm1[i],pwm2[i],point[i],angleout[i],angle[i],va[i],vb[i],spd[i]);
1000e08c:	e3013570 	movw	r3, #5488	; 0x1570
1000e090:	e3413004 	movt	r3, #4100	; 0x1004
1000e094:	e51b2018 	ldr	r2, [fp, #-24]
1000e098:	e7937102 	ldr	r7, [r3, r2, lsl #2]
1000e09c:	e30f3f18 	movw	r3, #65304	; 0xff18
1000e0a0:	e3413003 	movt	r3, #4099	; 0x1003
1000e0a4:	e51b2018 	ldr	r2, [fp, #-24]
1000e0a8:	e7936102 	ldr	r6, [r3, r2, lsl #2]
1000e0ac:	e3003328 	movw	r3, #808	; 0x328
1000e0b0:	e3413004 	movt	r3, #4100	; 0x1004
1000e0b4:	e51b2018 	ldr	r2, [fp, #-24]
1000e0b8:	e7935102 	ldr	r5, [r3, r2, lsl #2]
1000e0bc:	e3003d48 	movw	r3, #3400	; 0xd48
1000e0c0:	e3413004 	movt	r3, #4100	; 0x1004
1000e0c4:	e51b2018 	ldr	r2, [fp, #-24]
1000e0c8:	e793e102 	ldr	lr, [r3, r2, lsl #2]
1000e0cc:	e30231a0 	movw	r3, #8608	; 0x21a0
1000e0d0:	e3413004 	movt	r3, #4100	; 0x1004
1000e0d4:	e51b2018 	ldr	r2, [fp, #-24]
1000e0d8:	e793c102 	ldr	ip, [r3, r2, lsl #2]
1000e0dc:	e3013d90 	movw	r3, #7568	; 0x1d90
1000e0e0:	e3413004 	movt	r3, #4100	; 0x1004
1000e0e4:	e51b2018 	ldr	r2, [fp, #-24]
1000e0e8:	e7930102 	ldr	r0, [r3, r2, lsl #2]
1000e0ec:	e3013980 	movw	r3, #6528	; 0x1980
1000e0f0:	e3413004 	movt	r3, #4100	; 0x1004
1000e0f4:	e51b2018 	ldr	r2, [fp, #-24]
1000e0f8:	e7931102 	ldr	r1, [r3, r2, lsl #2]
1000e0fc:	e3003738 	movw	r3, #1848	; 0x738
1000e100:	e3413004 	movt	r3, #4100	; 0x1004
1000e104:	e51b2018 	ldr	r2, [fp, #-24]
1000e108:	e7932102 	ldr	r2, [r3, r2, lsl #2]
1000e10c:	e3013158 	movw	r3, #4440	; 0x1158
1000e110:	e3413004 	movt	r3, #4100	; 0x1004
1000e114:	e51b4018 	ldr	r4, [fp, #-24]
1000e118:	e7933104 	ldr	r3, [r3, r4, lsl #2]
1000e11c:	e58de000 	str	lr, [sp]
1000e120:	e58dc004 	str	ip, [sp, #4]
1000e124:	e58d0008 	str	r0, [sp, #8]
1000e128:	e58d100c 	str	r1, [sp, #12]
1000e12c:	e58d2010 	str	r2, [sp, #16]
1000e130:	e58d3014 	str	r3, [sp, #20]
1000e134:	e3030264 	movw	r0, #12900	; 0x3264
1000e138:	e3410003 	movt	r0, #4099	; 0x1003
1000e13c:	e1a01007 	mov	r1, r7
1000e140:	e1a02006 	mov	r2, r6
1000e144:	e1a03005 	mov	r3, r5
1000e148:	eb00165c 	bl	10013ac0 <rt_kprintf>
		j = 0;
		//rt_device_open(device,NULL);
		//rt_device_control(device,CMD_PWMDISABLE,NULL);
			int i=0;
			
			for(i = 0; i < 260;i++)
1000e14c:	e51b3018 	ldr	r3, [fp, #-24]
1000e150:	e2833001 	add	r3, r3, #1
1000e154:	e50b3018 	str	r3, [fp, #-24]
1000e158:	e51b3018 	ldr	r3, [fp, #-24]
1000e15c:	e3530f41 	cmp	r3, #260	; 0x104
1000e160:	baffffc9 	blt	1000e08c <USER_MotorTask_entry+0x60>
		if(myscanf((char *)a) == RT_EOK)
		{
			gFlag = 1;
		}
		#endif
		rt_thread_sleep(1000);
1000e164:	e3a00ffa 	mov	r0, #1000	; 0x3e8
1000e168:	eb0022dc 	bl	10016ce0 <rt_thread_sleep>
	}
1000e16c:	eaffffb8 	b	1000e054 <USER_MotorTask_entry+0x28>

1000e170 <USER_MotorTask_init>:




int USER_MotorTask_init()
{
1000e170:	e92d4800 	push	{fp, lr}
1000e174:	e28db004 	add	fp, sp, #4
1000e178:	e24dd010 	sub	sp, sp, #16
    rt_thread_t tid;
	
	tid = rt_thread_create("Motor",
1000e17c:	e3a0300a 	mov	r3, #10
1000e180:	e58d3000 	str	r3, [sp]
1000e184:	e3a03014 	mov	r3, #20
1000e188:	e58d3004 	str	r3, [sp, #4]
1000e18c:	e30302ac 	movw	r0, #12972	; 0x32ac
1000e190:	e3410003 	movt	r0, #4099	; 0x1003
1000e194:	e30e102c 	movw	r1, #57388	; 0xe02c
1000e198:	e3411000 	movt	r1, #4096	; 0x1000
1000e19c:	e3a02000 	mov	r2, #0
1000e1a0:	e3a03b01 	mov	r3, #1024	; 0x400
1000e1a4:	eb002251 	bl	10016af0 <rt_thread_create>
1000e1a8:	e50b0008 	str	r0, [fp, #-8]
                           USER_MotorTask_entry, RT_NULL,
                           1024, USER_MOTORTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
1000e1ac:	e51b3008 	ldr	r3, [fp, #-8]
1000e1b0:	e3530000 	cmp	r3, #0
1000e1b4:	0a000001 	beq	1000e1c0 <USER_MotorTask_init+0x50>
1000e1b8:	e51b0008 	ldr	r0, [fp, #-8]
1000e1bc:	eb0021f0 	bl	10016984 <rt_thread_startup>

    return 0;
1000e1c0:	e3a03000 	mov	r3, #0
}
1000e1c4:	e1a00003 	mov	r0, r3
1000e1c8:	e24bd004 	sub	sp, fp, #4
1000e1cc:	e8bd8800 	pop	{fp, pc}

1000e1d0 <rt_init_thread_entry>:
#include <finsh.h>
#include "userconf.h"

/* thread phase init */
static void rt_init_thread_entry(void *parameter)
{
1000e1d0:	e92d4800 	push	{fp, lr}
1000e1d4:	e28db004 	add	fp, sp, #4
1000e1d8:	e24dd008 	sub	sp, sp, #8
1000e1dc:	e50b0008 	str	r0, [fp, #-8]
    /* do component initialization */
	static int i = 0;
    rt_components_init();
1000e1e0:	eb0000ca 	bl	1000e510 <rt_components_init>
    rt_kprintf("running on cpu %d\n",
               rt_cpu_get_smp_id() & 0x0f);
1000e1e4:	eb002d37 	bl	100196c8 <rt_cpu_get_smp_id>
1000e1e8:	e1a03000 	mov	r3, r0
static void rt_init_thread_entry(void *parameter)
{
    /* do component initialization */
	static int i = 0;
    rt_components_init();
    rt_kprintf("running on cpu %d\n",
1000e1ec:	e203300f 	and	r3, r3, #15
1000e1f0:	e30302b4 	movw	r0, #12980	; 0x32b4
1000e1f4:	e3410003 	movt	r0, #4099	; 0x1003
1000e1f8:	e1a01003 	mov	r1, r3
1000e1fc:	eb00162f 	bl	10013ac0 <rt_kprintf>
		rt_kprintf("hello world %d\r\n", i++);
		rt_thread_delay(1000);
    	/* add your initialization here */
	}
	#endif
}
1000e200:	e24bd004 	sub	sp, fp, #4
1000e204:	e8bd8800 	pop	{fp, pc}

1000e208 <rt_application_init>:

int rt_application_init()
{
1000e208:	e92d4800 	push	{fp, lr}
1000e20c:	e28db004 	add	fp, sp, #4
1000e210:	e24dd010 	sub	sp, sp, #16
    rt_thread_t tid;

    tid = rt_thread_create("init", rt_init_thread_entry, RT_NULL, 2048,
1000e214:	e3a0300a 	mov	r3, #10
1000e218:	e58d3000 	str	r3, [sp]
1000e21c:	e3a03014 	mov	r3, #20
1000e220:	e58d3004 	str	r3, [sp, #4]
1000e224:	e30302c8 	movw	r0, #13000	; 0x32c8
1000e228:	e3410003 	movt	r0, #4099	; 0x1003
1000e22c:	e30e11d0 	movw	r1, #57808	; 0xe1d0
1000e230:	e3411000 	movt	r1, #4096	; 0x1000
1000e234:	e3a02000 	mov	r2, #0
1000e238:	e3a03b02 	mov	r3, #2048	; 0x800
1000e23c:	eb00222b 	bl	10016af0 <rt_thread_create>
1000e240:	e50b0008 	str	r0, [fp, #-8]
                            RT_THREAD_PRIORITY_MAX/3, 20);
    if (tid != RT_NULL)
1000e244:	e51b3008 	ldr	r3, [fp, #-8]
1000e248:	e3530000 	cmp	r3, #0
1000e24c:	0a000001 	beq	1000e258 <rt_application_init+0x50>
        rt_thread_startup(tid);
1000e250:	e51b0008 	ldr	r0, [fp, #-8]
1000e254:	eb0021ca 	bl	10016984 <rt_thread_startup>

    return 0;
1000e258:	e3a03000 	mov	r3, #0
}
1000e25c:	e1a00003 	mov	r0, r3
1000e260:	e24bd004 	sub	sp, fp, #4
1000e264:	e8bd8800 	pop	{fp, pc}

1000e268 <SFItest>:
#include "xscugic.h"

//extern XScuGic ScuGic1_InstancePtr;

long SFItest(void)
{
1000e268:	e92d4800 	push	{fp, lr}
1000e26c:	e28db004 	add	fp, sp, #4
	rt_kprintf("send a sfi\r\n");
1000e270:	e30302d0 	movw	r0, #13008	; 0x32d0
1000e274:	e3410003 	movt	r0, #4099	; 0x1003
1000e278:	eb001610 	bl	10013ac0 <rt_kprintf>
	//rt_kprintf("%d\r\n",ScuGic1_InstancePtr.IsReady);
	
	//XScuGic_SoftwareIntr(&ScuGic1_InstancePtr, 15,XPAR_CPU_ID);
//	arm_gic_trigger(0,0, 6);
	
	arm_gic_trigger(0,XPAR_CPU_ID, CPU0_VBUS_SFI_ID);
1000e27c:	e3a00000 	mov	r0, #0
1000e280:	e3a01001 	mov	r1, #1
1000e284:	e3a0200f 	mov	r2, #15
1000e288:	eb002992 	bl	100188d8 <arm_gic_trigger>

	return RT_EOK;
1000e28c:	e3a03000 	mov	r3, #0
}
1000e290:	e1a00003 	mov	r0, r3
1000e294:	e8bd8800 	pop	{fp, pc}

1000e298 <enable_fpu>:

#include <board.h>

extern int rt_application_init(void);
void enable_fpu()
{
1000e298:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e29c:	e28db000 	add	fp, sp, #0
	/*Set bits [11:10] of the NSACR for access to CP10 and CP11 from both Secure and
	Non-secure states:*/
	asm volatile ("MRC p15, 0, r0, c1, c1, 2\n\t");
1000e2a0:	ee110f51 	mrc	15, 0, r0, cr1, cr1, {2}
	asm volatile("ORR r0, r0, #3<<10\n\t");
1000e2a4:	e3800b03 	orr	r0, r0, #3072	; 0xc00
	asm volatile("MCR p15, 0, r0, c1, c1, 2\n");
1000e2a8:	ee010f51 	mcr	15, 0, r0, cr1, cr1, {2}

	/*Set the CPACR for access to CP10 and CP11:*/
	asm volatile("LDR r0, =(0xF << 20)\n");
1000e2ac:	e3a0060f 	mov	r0, #15728640	; 0xf00000
	asm volatile("MCR p15, 0, r0, c1, c0, 2\n");
1000e2b0:	ee010f50 	mcr	15, 0, r0, cr1, cr0, {2}
	
	/*Set the FPEXC EN bit to enable the FPU:*/
	asm volatile("MOV r3, #0x40000000\n");
1000e2b4:	e3a03101 	mov	r3, #1073741824	; 0x40000000
	asm volatile("VMSR FPEXC, r3\n");
1000e2b8:	eee83a10 	vmsr	fpexc, r3
}
1000e2bc:	e24bd000 	sub	sp, fp, #0
1000e2c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e2c4:	e12fff1e 	bx	lr

1000e2c8 <rtthread_startup>:

/**
 * This function will startup RT-Thread RTOS.
 */
void rtthread_startup(void)
{
1000e2c8:	e92d4800 	push	{fp, lr}
1000e2cc:	e28db004 	add	fp, sp, #4
    rt_hw_mmu_init();
1000e2d0:	eb002b5d 	bl	1001904c <rt_hw_mmu_init>

    /* initialzie hardware interrupt */
    rt_hw_interrupt_init();
1000e2d4:	eb002a01 	bl	10018ae0 <rt_hw_interrupt_init>

	enable_fpu();
1000e2d8:	ebffffee 	bl	1000e298 <enable_fpu>

    /* initialize board */
    rt_hw_board_init();
1000e2dc:	ebffefed 	bl	1000a298 <rt_hw_board_init>

    /* show RT-Thread version */
    rt_show_version();
1000e2e0:	eb0011ff 	bl	10012ae4 <rt_show_version>

    /* initialize memory system */
#ifdef RT_USING_HEAP
    rt_system_heap_init(HEAP_BEGIN, HEAP_END);
1000e2e4:	e30309ac 	movw	r0, #14764	; 0x39ac
1000e2e8:	e3410004 	movt	r0, #4100	; 0x1004
1000e2ec:	e3a01202 	mov	r1, #536870912	; 0x20000000
1000e2f0:	eb001767 	bl	10014094 <rt_system_heap_init>
#endif

    /* initialize scheduler system */
    rt_system_scheduler_init();
1000e2f4:	eb001f74 	bl	100160cc <rt_system_scheduler_init>

    /* initialize system timer */
    rt_system_timer_init();
1000e2f8:	eb002631 	bl	10017bc4 <rt_system_timer_init>

    /* initialize soft timer thread */
    rt_system_timer_thread_init();
1000e2fc:	eb002645 	bl	10017c18 <rt_system_timer_thread_init>

    /* initialize application */
    rt_application_init();
1000e300:	ebffffc0 	bl	1000e208 <rt_application_init>

    /* initialize idle thread */
    rt_thread_idle_init();
1000e304:	eb0002fe 	bl	1000ef04 <rt_thread_idle_init>

    /* start scheduler */
    rt_system_scheduler_start();
1000e308:	eb001f90 	bl	10016150 <rt_system_scheduler_start>

    /* never reach here */
    return ;
1000e30c:	e1a00000 	nop			; (mov r0, r0)
}
1000e310:	e8bd8800 	pop	{fp, pc}

1000e314 <main>:

int main(void)
{
1000e314:	e92d4800 	push	{fp, lr}
1000e318:	e28db004 	add	fp, sp, #4
    /* disable interrupt first */
    rt_hw_interrupt_disable();
1000e31c:	eb002cc3 	bl	10019630 <rt_hw_interrupt_disable>

    /* invoke rtthread_startup */
    rtthread_startup();
1000e320:	ebffffe8 	bl	1000e2c8 <rtthread_startup>

    return 0;
1000e324:	e3a03000 	mov	r3, #0
}
1000e328:	e1a00003 	mov	r0, r3
1000e32c:	e8bd8800 	pop	{fp, pc}

1000e330 <rt_system_tick_init>:
 *
 * @deprecated since 1.1.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_tick_init(void)
{
1000e330:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e334:	e28db000 	add	fp, sp, #0
}
1000e338:	e24bd000 	sub	sp, fp, #0
1000e33c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e340:	e12fff1e 	bx	lr

1000e344 <rt_tick_get>:
 * This function will return current tick from operating system startup
 *
 * @return current tick
 */
rt_tick_t rt_tick_get(void)
{
1000e344:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e348:	e28db000 	add	fp, sp, #0
    /* return the global tick */
    return rt_tick;
1000e34c:	e30c30ec 	movw	r3, #49388	; 0xc0ec
1000e350:	e3413003 	movt	r3, #4099	; 0x1003
1000e354:	e5933000 	ldr	r3, [r3]
}
1000e358:	e1a00003 	mov	r0, r3
1000e35c:	e24bd000 	sub	sp, fp, #0
1000e360:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e364:	e12fff1e 	bx	lr

1000e368 <rt_tick_set>:

/**
 * This function will set current tick
 */
void rt_tick_set(rt_tick_t tick)
{
1000e368:	e92d4800 	push	{fp, lr}
1000e36c:	e28db004 	add	fp, sp, #4
1000e370:	e24dd010 	sub	sp, sp, #16
1000e374:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t level;

    level = rt_hw_interrupt_disable();
1000e378:	eb002cac 	bl	10019630 <rt_hw_interrupt_disable>
1000e37c:	e50b0008 	str	r0, [fp, #-8]
    rt_tick = tick;
1000e380:	e30c30ec 	movw	r3, #49388	; 0xc0ec
1000e384:	e3413003 	movt	r3, #4099	; 0x1003
1000e388:	e51b2010 	ldr	r2, [fp, #-16]
1000e38c:	e5832000 	str	r2, [r3]
    rt_hw_interrupt_enable(level);
1000e390:	e51b0008 	ldr	r0, [fp, #-8]
1000e394:	eb002ca9 	bl	10019640 <rt_hw_interrupt_enable>
}
1000e398:	e24bd004 	sub	sp, fp, #4
1000e39c:	e8bd8800 	pop	{fp, pc}

1000e3a0 <rt_tick_increase>:
/**
 * This function will notify kernel there is one tick passed. Normally,
 * this function is invoked by clock ISR.
 */
void rt_tick_increase(void)
{
1000e3a0:	e92d4800 	push	{fp, lr}
1000e3a4:	e28db004 	add	fp, sp, #4
1000e3a8:	e24dd008 	sub	sp, sp, #8
    struct rt_thread *thread;

    /* increase the global tick */
    ++ rt_tick;
1000e3ac:	e30c30ec 	movw	r3, #49388	; 0xc0ec
1000e3b0:	e3413003 	movt	r3, #4099	; 0x1003
1000e3b4:	e5933000 	ldr	r3, [r3]
1000e3b8:	e2832001 	add	r2, r3, #1
1000e3bc:	e30c30ec 	movw	r3, #49388	; 0xc0ec
1000e3c0:	e3413003 	movt	r3, #4099	; 0x1003
1000e3c4:	e5832000 	str	r2, [r3]

    /* check time slice */
    thread = rt_thread_self();
1000e3c8:	eb002164 	bl	10016960 <rt_thread_self>
1000e3cc:	e50b0008 	str	r0, [fp, #-8]

    -- thread->remaining_tick;
1000e3d0:	e51b3008 	ldr	r3, [fp, #-8]
1000e3d4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
1000e3d8:	e2432001 	sub	r2, r3, #1
1000e3dc:	e51b3008 	ldr	r3, [fp, #-8]
1000e3e0:	e5832044 	str	r2, [r3, #68]	; 0x44
    if (thread->remaining_tick == 0)
1000e3e4:	e51b3008 	ldr	r3, [fp, #-8]
1000e3e8:	e5933044 	ldr	r3, [r3, #68]	; 0x44
1000e3ec:	e3530000 	cmp	r3, #0
1000e3f0:	1a000004 	bne	1000e408 <rt_tick_increase+0x68>
    {
        /* change to initialized tick */
        thread->remaining_tick = thread->init_tick;
1000e3f4:	e51b3008 	ldr	r3, [fp, #-8]
1000e3f8:	e5932040 	ldr	r2, [r3, #64]	; 0x40
1000e3fc:	e51b3008 	ldr	r3, [fp, #-8]
1000e400:	e5832044 	str	r2, [r3, #68]	; 0x44

        /* yield */
        rt_thread_yield();
1000e404:	eb002208 	bl	10016c2c <rt_thread_yield>
    }

    /* check timer */
    rt_timer_check();
1000e408:	eb002599 	bl	10017a74 <rt_timer_check>
}
1000e40c:	e24bd004 	sub	sp, fp, #4
1000e410:	e8bd8800 	pop	{fp, pc}

1000e414 <rt_tick_from_millisecond>:
 * @param ms the specified millisecond
 *
 * @return the calculated tick
 */
rt_tick_t rt_tick_from_millisecond(rt_uint32_t ms)
{
1000e414:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e418:	e28db000 	add	fp, sp, #0
1000e41c:	e24dd00c 	sub	sp, sp, #12
1000e420:	e50b0008 	str	r0, [fp, #-8]
    /* return the calculated tick */
    return (RT_TICK_PER_SECOND * ms + 999) / 1000;
1000e424:	e51b1008 	ldr	r1, [fp, #-8]
1000e428:	e1a02001 	mov	r2, r1
1000e42c:	e1a03102 	lsl	r3, r2, #2
1000e430:	e1a02003 	mov	r2, r3
1000e434:	e1a03282 	lsl	r3, r2, #5
1000e438:	e0623003 	rsb	r3, r2, r3
1000e43c:	e0833001 	add	r3, r3, r1
1000e440:	e1a03183 	lsl	r3, r3, #3
1000e444:	e2833ff9 	add	r3, r3, #996	; 0x3e4
1000e448:	e2833003 	add	r3, r3, #3
1000e44c:	e3042dd3 	movw	r2, #19923	; 0x4dd3
1000e450:	e3412062 	movt	r2, #4194	; 0x1062
1000e454:	e0832293 	umull	r2, r3, r3, r2
1000e458:	e1a03323 	lsr	r3, r3, #6
}
1000e45c:	e1a00003 	mov	r0, r3
1000e460:	e24bd000 	sub	sp, fp, #0
1000e464:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e468:	e12fff1e 	bx	lr

1000e46c <rti_start>:
 * ...
 * INIT_APP_EXPORT(fn);
 * etc. 
 */
static int rti_start(void)
{
1000e46c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e470:	e28db000 	add	fp, sp, #0
    return 0;
1000e474:	e3a03000 	mov	r3, #0
}
1000e478:	e1a00003 	mov	r0, r3
1000e47c:	e24bd000 	sub	sp, fp, #0
1000e480:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e484:	e12fff1e 	bx	lr

1000e488 <rti_board_end>:
INIT_EXPORT(rti_start, "0");

static int rti_board_end(void)
{
1000e488:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e48c:	e28db000 	add	fp, sp, #0
    return 0;
1000e490:	e3a03000 	mov	r3, #0
}
1000e494:	e1a00003 	mov	r0, r3
1000e498:	e24bd000 	sub	sp, fp, #0
1000e49c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e4a0:	e12fff1e 	bx	lr

1000e4a4 <rti_end>:
INIT_EXPORT(rti_board_end, "1.end");

static int rti_end(void)
{
1000e4a4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e4a8:	e28db000 	add	fp, sp, #0
	return 0;
1000e4ac:	e3a03000 	mov	r3, #0
}
1000e4b0:	e1a00003 	mov	r0, r3
1000e4b4:	e24bd000 	sub	sp, fp, #0
1000e4b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e4bc:	e12fff1e 	bx	lr

1000e4c0 <rt_components_board_init>:

/**
 * RT-Thread Components Initialization for board
 */
void rt_components_board_init(void)
{
1000e4c0:	e92d4800 	push	{fp, lr}
1000e4c4:	e28db004 	add	fp, sp, #4
1000e4c8:	e24dd008 	sub	sp, sp, #8
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
1000e4cc:	e302374c 	movw	r3, #10060	; 0x274c
1000e4d0:	e3413003 	movt	r3, #4099	; 0x1003
1000e4d4:	e50b3008 	str	r3, [fp, #-8]
1000e4d8:	ea000005 	b	1000e4f4 <rt_components_board_init+0x34>
    {
        (*fn_ptr)();
1000e4dc:	e51b3008 	ldr	r3, [fp, #-8]
1000e4e0:	e5933000 	ldr	r3, [r3]
1000e4e4:	e12fff33 	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
1000e4e8:	e51b3008 	ldr	r3, [fp, #-8]
1000e4ec:	e2833004 	add	r3, r3, #4
1000e4f0:	e50b3008 	str	r3, [fp, #-8]
1000e4f4:	e51b2008 	ldr	r2, [fp, #-8]
1000e4f8:	e302376c 	movw	r3, #10092	; 0x276c
1000e4fc:	e3413003 	movt	r3, #4099	; 0x1003
1000e500:	e1520003 	cmp	r2, r3
1000e504:	3afffff4 	bcc	1000e4dc <rt_components_board_init+0x1c>
    {
        (*fn_ptr)();
    }
#endif
}
1000e508:	e24bd004 	sub	sp, fp, #4
1000e50c:	e8bd8800 	pop	{fp, pc}

1000e510 <rt_components_init>:

/**
 * RT-Thread Components Initialization
 */
void rt_components_init(void)
{
1000e510:	e92d4800 	push	{fp, lr}
1000e514:	e28db004 	add	fp, sp, #4
1000e518:	e24dd008 	sub	sp, sp, #8
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
1000e51c:	e302376c 	movw	r3, #10092	; 0x276c
1000e520:	e3413003 	movt	r3, #4099	; 0x1003
1000e524:	e50b3008 	str	r3, [fp, #-8]
1000e528:	ea000005 	b	1000e544 <rt_components_init+0x34>
    {
        (*fn_ptr)();
1000e52c:	e51b3008 	ldr	r3, [fp, #-8]
1000e530:	e5933000 	ldr	r3, [r3]
1000e534:	e12fff33 	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
1000e538:	e51b3008 	ldr	r3, [fp, #-8]
1000e53c:	e2833004 	add	r3, r3, #4
1000e540:	e50b3008 	str	r3, [fp, #-8]
1000e544:	e51b2008 	ldr	r2, [fp, #-8]
1000e548:	e3023788 	movw	r3, #10120	; 0x2788
1000e54c:	e3413003 	movt	r3, #4099	; 0x1003
1000e550:	e1520003 	cmp	r2, r3
1000e554:	3afffff4 	bcc	1000e52c <rt_components_init+0x1c>
			}
		}
	}
#endif

}
1000e558:	e24bd004 	sub	sp, fp, #4
1000e55c:	e8bd8800 	pop	{fp, pc}

1000e560 <rt_device_register>:
 * @return the error code, RT_EOK on initialization successfully.
 */
rt_err_t rt_device_register(rt_device_t dev,
                            const char *name,
                            rt_uint16_t flags)
{
1000e560:	e92d4800 	push	{fp, lr}
1000e564:	e28db004 	add	fp, sp, #4
1000e568:	e24dd010 	sub	sp, sp, #16
1000e56c:	e50b0008 	str	r0, [fp, #-8]
1000e570:	e50b100c 	str	r1, [fp, #-12]
1000e574:	e1a03002 	mov	r3, r2
1000e578:	e14b30be 	strh	r3, [fp, #-14]
    if (dev == RT_NULL)
1000e57c:	e51b3008 	ldr	r3, [fp, #-8]
1000e580:	e3530000 	cmp	r3, #0
1000e584:	1a000001 	bne	1000e590 <rt_device_register+0x30>
        return -RT_ERROR;
1000e588:	e3e03000 	mvn	r3, #0
1000e58c:	ea000012 	b	1000e5dc <rt_device_register+0x7c>

    if (rt_device_find(name) != RT_NULL)
1000e590:	e51b000c 	ldr	r0, [fp, #-12]
1000e594:	eb00002e 	bl	1000e654 <rt_device_find>
1000e598:	e1a03000 	mov	r3, r0
1000e59c:	e3530000 	cmp	r3, #0
1000e5a0:	0a000001 	beq	1000e5ac <rt_device_register+0x4c>
        return -RT_ERROR;
1000e5a4:	e3e03000 	mvn	r3, #0
1000e5a8:	ea00000b 	b	1000e5dc <rt_device_register+0x7c>

    rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
1000e5ac:	e51b3008 	ldr	r3, [fp, #-8]
1000e5b0:	e1a00003 	mov	r0, r3
1000e5b4:	e3a01007 	mov	r1, #7
1000e5b8:	e51b200c 	ldr	r2, [fp, #-12]
1000e5bc:	eb001cfc 	bl	100159b4 <rt_object_init>
    dev->flag = flags;
1000e5c0:	e51b3008 	ldr	r3, [fp, #-8]
1000e5c4:	e15b20be 	ldrh	r2, [fp, #-14]
1000e5c8:	e1c321b2 	strh	r2, [r3, #18]
    dev->ref_count = 0;
1000e5cc:	e51b3008 	ldr	r3, [fp, #-8]
1000e5d0:	e3a02000 	mov	r2, #0
1000e5d4:	e5c32016 	strb	r2, [r3, #22]

    return RT_EOK;
1000e5d8:	e3a03000 	mov	r3, #0
}
1000e5dc:	e1a00003 	mov	r0, r3
1000e5e0:	e24bd004 	sub	sp, fp, #4
1000e5e4:	e8bd8800 	pop	{fp, pc}

1000e5e8 <rt_device_unregister>:
 * @param dev the pointer of device driver structure
 *
 * @return the error code, RT_EOK on successfully.
 */
rt_err_t rt_device_unregister(rt_device_t dev)
{
1000e5e8:	e92d4800 	push	{fp, lr}
1000e5ec:	e28db004 	add	fp, sp, #4
1000e5f0:	e24dd008 	sub	sp, sp, #8
1000e5f4:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(dev != RT_NULL);
1000e5f8:	e51b3008 	ldr	r3, [fp, #-8]
1000e5fc:	e3530000 	cmp	r3, #0
1000e600:	1a000005 	bne	1000e61c <rt_device_unregister+0x34>
1000e604:	e30302e0 	movw	r0, #13024	; 0x32e0
1000e608:	e3410003 	movt	r0, #4099	; 0x1003
1000e60c:	e303133c 	movw	r1, #13116	; 0x333c
1000e610:	e3411003 	movt	r1, #4099	; 0x1003
1000e614:	e3a02046 	mov	r2, #70	; 0x46
1000e618:	eb0015e5 	bl	10013db4 <rt_assert_handler>

    rt_object_detach(&(dev->parent));
1000e61c:	e51b3008 	ldr	r3, [fp, #-8]
1000e620:	e1a00003 	mov	r0, r3
1000e624:	eb001d11 	bl	10015a70 <rt_object_detach>

    return RT_EOK;
1000e628:	e3a03000 	mov	r3, #0
}
1000e62c:	e1a00003 	mov	r0, r3
1000e630:	e24bd004 	sub	sp, fp, #4
1000e634:	e8bd8800 	pop	{fp, pc}

1000e638 <rt_device_init_all>:
 *
 * @deprecated since 1.2.x, this function is not needed because the initialization 
 *             of a device is performed when applicaiton opens it.
 */
rt_err_t rt_device_init_all(void)
{
1000e638:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e63c:	e28db000 	add	fp, sp, #0
    return RT_EOK;
1000e640:	e3a03000 	mov	r3, #0
}
1000e644:	e1a00003 	mov	r0, r3
1000e648:	e24bd000 	sub	sp, fp, #0
1000e64c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e650:	e12fff1e 	bx	lr

1000e654 <rt_device_find>:
 * @param name the device driver's name
 *
 * @return the registered device driver on successful, or RT_NULL on failure.
 */
rt_device_t rt_device_find(const char *name)
{
1000e654:	e92d4800 	push	{fp, lr}
1000e658:	e28db004 	add	fp, sp, #4
1000e65c:	e24dd018 	sub	sp, sp, #24
1000e660:	e50b0018 	str	r0, [fp, #-24]
    struct rt_object_information *information;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
1000e664:	eb0020bd 	bl	10016960 <rt_thread_self>
1000e668:	e1a03000 	mov	r3, r0
1000e66c:	e3530000 	cmp	r3, #0
1000e670:	0a000000 	beq	1000e678 <rt_device_find+0x24>
        rt_enter_critical();
1000e674:	eb001f71 	bl	10016440 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
1000e678:	e59f309c 	ldr	r3, [pc, #156]	; 1000e71c <rt_device_find+0xc8>
1000e67c:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
1000e680:	e51b300c 	ldr	r3, [fp, #-12]
1000e684:	e5933004 	ldr	r3, [r3, #4]
1000e688:	e50b3008 	str	r3, [fp, #-8]
1000e68c:	ea000014 	b	1000e6e4 <rt_device_find+0x90>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
1000e690:	e51b3008 	ldr	r3, [fp, #-8]
1000e694:	e2433008 	sub	r3, r3, #8
1000e698:	e50b3010 	str	r3, [fp, #-16]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
1000e69c:	e51b3010 	ldr	r3, [fp, #-16]
1000e6a0:	e1a00003 	mov	r0, r3
1000e6a4:	e51b1018 	ldr	r1, [fp, #-24]
1000e6a8:	e3a02006 	mov	r2, #6
1000e6ac:	eb00109a 	bl	1001291c <rt_strncmp>
1000e6b0:	e1a03000 	mov	r3, r0
1000e6b4:	e3530000 	cmp	r3, #0
1000e6b8:	1a000006 	bne	1000e6d8 <rt_device_find+0x84>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
1000e6bc:	eb0020a7 	bl	10016960 <rt_thread_self>
1000e6c0:	e1a03000 	mov	r3, r0
1000e6c4:	e3530000 	cmp	r3, #0
1000e6c8:	0a000000 	beq	1000e6d0 <rt_device_find+0x7c>
                rt_exit_critical();
1000e6cc:	eb001f6d 	bl	10016488 <rt_exit_critical>

            return (rt_device_t)object;
1000e6d0:	e51b3010 	ldr	r3, [fp, #-16]
1000e6d4:	ea00000d 	b	1000e710 <rt_device_find+0xbc>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
1000e6d8:	e51b3008 	ldr	r3, [fp, #-8]
1000e6dc:	e5933000 	ldr	r3, [r3]
1000e6e0:	e50b3008 	str	r3, [fp, #-8]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
1000e6e4:	e51b300c 	ldr	r3, [fp, #-12]
1000e6e8:	e2832004 	add	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
1000e6ec:	e51b3008 	ldr	r3, [fp, #-8]
1000e6f0:	e1520003 	cmp	r2, r3
1000e6f4:	1affffe5 	bne	1000e690 <rt_device_find+0x3c>
            return (rt_device_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
1000e6f8:	eb002098 	bl	10016960 <rt_thread_self>
1000e6fc:	e1a03000 	mov	r3, r0
1000e700:	e3530000 	cmp	r3, #0
1000e704:	0a000000 	beq	1000e70c <rt_device_find+0xb8>
        rt_exit_critical();
1000e708:	eb001f5e 	bl	10016488 <rt_exit_critical>

    /* not found */
    return RT_NULL;
1000e70c:	e3a03000 	mov	r3, #0
}
1000e710:	e1a00003 	mov	r0, r3
1000e714:	e24bd004 	sub	sp, fp, #4
1000e718:	e8bd8800 	pop	{fp, pc}
1000e71c:	100368e8 	.word	0x100368e8

1000e720 <rt_device_init>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_init(rt_device_t dev)
{
1000e720:	e92d4800 	push	{fp, lr}
1000e724:	e28db004 	add	fp, sp, #4
1000e728:	e24dd010 	sub	sp, sp, #16
1000e72c:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000e730:	e3a03000 	mov	r3, #0
1000e734:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
1000e738:	e51b3010 	ldr	r3, [fp, #-16]
1000e73c:	e3530000 	cmp	r3, #0
1000e740:	1a000005 	bne	1000e75c <rt_device_init+0x3c>
1000e744:	e30302e0 	movw	r0, #13024	; 0x32e0
1000e748:	e3410003 	movt	r0, #4099	; 0x1003
1000e74c:	e3031354 	movw	r1, #13140	; 0x3354
1000e750:	e3411003 	movt	r1, #4099	; 0x1003
1000e754:	e3a02093 	mov	r2, #147	; 0x93
1000e758:	eb001595 	bl	10013db4 <rt_assert_handler>

    /* get device init handler */
    if (dev->init != RT_NULL)
1000e75c:	e51b3010 	ldr	r3, [fp, #-16]
1000e760:	e5933020 	ldr	r3, [r3, #32]
1000e764:	e3530000 	cmp	r3, #0
1000e768:	0a000019 	beq	1000e7d4 <rt_device_init+0xb4>
    {
        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
1000e76c:	e51b3010 	ldr	r3, [fp, #-16]
1000e770:	e1d331b2 	ldrh	r3, [r3, #18]
1000e774:	e2033010 	and	r3, r3, #16
1000e778:	e3530000 	cmp	r3, #0
1000e77c:	1a000014 	bne	1000e7d4 <rt_device_init+0xb4>
        {
            result = dev->init(dev);
1000e780:	e51b3010 	ldr	r3, [fp, #-16]
1000e784:	e5933020 	ldr	r3, [r3, #32]
1000e788:	e51b0010 	ldr	r0, [fp, #-16]
1000e78c:	e12fff33 	blx	r3
1000e790:	e50b0008 	str	r0, [fp, #-8]
            if (result != RT_EOK)
1000e794:	e51b3008 	ldr	r3, [fp, #-8]
1000e798:	e3530000 	cmp	r3, #0
1000e79c:	0a000006 	beq	1000e7bc <rt_device_init+0x9c>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
1000e7a0:	e51b3010 	ldr	r3, [fp, #-16]
        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
1000e7a4:	e30302f0 	movw	r0, #13040	; 0x32f0
1000e7a8:	e3410003 	movt	r0, #4099	; 0x1003
1000e7ac:	e1a01003 	mov	r1, r3
1000e7b0:	e51b2008 	ldr	r2, [fp, #-8]
1000e7b4:	eb0014c1 	bl	10013ac0 <rt_kprintf>
1000e7b8:	ea000005 	b	1000e7d4 <rt_device_init+0xb4>
                           dev->parent.name, result);
            }
            else
            {
                dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
1000e7bc:	e51b3010 	ldr	r3, [fp, #-16]
1000e7c0:	e1d331b2 	ldrh	r3, [r3, #18]
1000e7c4:	e3833010 	orr	r3, r3, #16
1000e7c8:	e6ff2073 	uxth	r2, r3
1000e7cc:	e51b3010 	ldr	r3, [fp, #-16]
1000e7d0:	e1c321b2 	strh	r2, [r3, #18]
            }
        }
    }

    return result;
1000e7d4:	e51b3008 	ldr	r3, [fp, #-8]
}
1000e7d8:	e1a00003 	mov	r0, r3
1000e7dc:	e24bd004 	sub	sp, fp, #4
1000e7e0:	e8bd8800 	pop	{fp, pc}

1000e7e4 <rt_device_open>:
 * @param oflag the flags for device open
 *
 * @return the result
 */
rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
{
1000e7e4:	e92d4800 	push	{fp, lr}
1000e7e8:	e28db004 	add	fp, sp, #4
1000e7ec:	e24dd010 	sub	sp, sp, #16
1000e7f0:	e50b0010 	str	r0, [fp, #-16]
1000e7f4:	e1a03001 	mov	r3, r1
1000e7f8:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    rt_err_t result = RT_EOK;
1000e7fc:	e3a03000 	mov	r3, #0
1000e800:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
1000e804:	e51b3010 	ldr	r3, [fp, #-16]
1000e808:	e3530000 	cmp	r3, #0
1000e80c:	1a000005 	bne	1000e828 <rt_device_open+0x44>
1000e810:	e30302e0 	movw	r0, #13024	; 0x32e0
1000e814:	e3410003 	movt	r0, #4099	; 0x1003
1000e818:	e3031364 	movw	r1, #13156	; 0x3364
1000e81c:	e3411003 	movt	r1, #4099	; 0x1003
1000e820:	e3a020b6 	mov	r2, #182	; 0xb6
1000e824:	eb001562 	bl	10013db4 <rt_assert_handler>
	
    /* if device is not initialized, initialize it. */
    if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
1000e828:	e51b3010 	ldr	r3, [fp, #-16]
1000e82c:	e1d331b2 	ldrh	r3, [r3, #18]
1000e830:	e2033010 	and	r3, r3, #16
1000e834:	e3530000 	cmp	r3, #0
1000e838:	1a000019 	bne	1000e8a4 <rt_device_open+0xc0>
    {
        if (dev->init != RT_NULL)
1000e83c:	e51b3010 	ldr	r3, [fp, #-16]
1000e840:	e5933020 	ldr	r3, [r3, #32]
1000e844:	e3530000 	cmp	r3, #0
1000e848:	0a00000f 	beq	1000e88c <rt_device_open+0xa8>
        {
            result = dev->init(dev);
1000e84c:	e51b3010 	ldr	r3, [fp, #-16]
1000e850:	e5933020 	ldr	r3, [r3, #32]
1000e854:	e51b0010 	ldr	r0, [fp, #-16]
1000e858:	e12fff33 	blx	r3
1000e85c:	e50b0008 	str	r0, [fp, #-8]
            if (result != RT_EOK)
1000e860:	e51b3008 	ldr	r3, [fp, #-8]
1000e864:	e3530000 	cmp	r3, #0
1000e868:	0a000007 	beq	1000e88c <rt_device_open+0xa8>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
1000e86c:	e51b3010 	ldr	r3, [fp, #-16]
        if (dev->init != RT_NULL)
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
1000e870:	e30302f0 	movw	r0, #13040	; 0x32f0
1000e874:	e3410003 	movt	r0, #4099	; 0x1003
1000e878:	e1a01003 	mov	r1, r3
1000e87c:	e51b2008 	ldr	r2, [fp, #-8]
1000e880:	eb00148e 	bl	10013ac0 <rt_kprintf>
                           dev->parent.name, result);

                return result;
1000e884:	e51b3008 	ldr	r3, [fp, #-8]
1000e888:	ea000038 	b	1000e970 <rt_device_open+0x18c>
            }
        }

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
1000e88c:	e51b3010 	ldr	r3, [fp, #-16]
1000e890:	e1d331b2 	ldrh	r3, [r3, #18]
1000e894:	e3833010 	orr	r3, r3, #16
1000e898:	e6ff2073 	uxth	r2, r3
1000e89c:	e51b3010 	ldr	r3, [fp, #-16]
1000e8a0:	e1c321b2 	strh	r2, [r3, #18]
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
1000e8a4:	e51b3010 	ldr	r3, [fp, #-16]
1000e8a8:	e1d331b2 	ldrh	r3, [r3, #18]
1000e8ac:	e2033008 	and	r3, r3, #8
1000e8b0:	e3530000 	cmp	r3, #0
1000e8b4:	0a000006 	beq	1000e8d4 <rt_device_open+0xf0>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
1000e8b8:	e51b3010 	ldr	r3, [fp, #-16]
1000e8bc:	e1d331b4 	ldrh	r3, [r3, #20]
1000e8c0:	e2033008 	and	r3, r3, #8

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
1000e8c4:	e3530000 	cmp	r3, #0
1000e8c8:	0a000001 	beq	1000e8d4 <rt_device_open+0xf0>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
    {
        return -RT_EBUSY;
1000e8cc:	e3e03006 	mvn	r3, #6
1000e8d0:	ea000026 	b	1000e970 <rt_device_open+0x18c>
    }

    /* call device open interface */
    if (dev->open != RT_NULL)
1000e8d4:	e51b3010 	ldr	r3, [fp, #-16]
1000e8d8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1000e8dc:	e3530000 	cmp	r3, #0
1000e8e0:	0a000006 	beq	1000e900 <rt_device_open+0x11c>
    {
        result = dev->open(dev, oflag);
1000e8e4:	e51b3010 	ldr	r3, [fp, #-16]
1000e8e8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1000e8ec:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
1000e8f0:	e51b0010 	ldr	r0, [fp, #-16]
1000e8f4:	e1a01002 	mov	r1, r2
1000e8f8:	e12fff33 	blx	r3
1000e8fc:	e50b0008 	str	r0, [fp, #-8]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
1000e900:	e51b3008 	ldr	r3, [fp, #-8]
1000e904:	e3530000 	cmp	r3, #0
1000e908:	0a000002 	beq	1000e918 <rt_device_open+0x134>
1000e90c:	e51b3008 	ldr	r3, [fp, #-8]
1000e910:	e3730006 	cmn	r3, #6
1000e914:	1a000014 	bne	1000e96c <rt_device_open+0x188>
    {
        dev->open_flag = oflag | RT_DEVICE_OFLAG_OPEN;
1000e918:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
1000e91c:	e3833008 	orr	r3, r3, #8
1000e920:	e6ff2073 	uxth	r2, r3
1000e924:	e51b3010 	ldr	r3, [fp, #-16]
1000e928:	e1c321b4 	strh	r2, [r3, #20]

        dev->ref_count++;
1000e92c:	e51b3010 	ldr	r3, [fp, #-16]
1000e930:	e5d33016 	ldrb	r3, [r3, #22]
1000e934:	e2833001 	add	r3, r3, #1
1000e938:	e6ef2073 	uxtb	r2, r3
1000e93c:	e51b3010 	ldr	r3, [fp, #-16]
1000e940:	e5c32016 	strb	r2, [r3, #22]
        /* don't let bad things happen silently. If you are bitten by this assert,
         * please set the ref_count to a bigger type. */
        RT_ASSERT(dev->ref_count != 0);
1000e944:	e51b3010 	ldr	r3, [fp, #-16]
1000e948:	e5d33016 	ldrb	r3, [r3, #22]
1000e94c:	e3530000 	cmp	r3, #0
1000e950:	1a000005 	bne	1000e96c <rt_device_open+0x188>
1000e954:	e3030328 	movw	r0, #13096	; 0x3328
1000e958:	e3410003 	movt	r0, #4099	; 0x1003
1000e95c:	e3031364 	movw	r1, #13156	; 0x3364
1000e960:	e3411003 	movt	r1, #4099	; 0x1003
1000e964:	e3a020df 	mov	r2, #223	; 0xdf
1000e968:	eb001511 	bl	10013db4 <rt_assert_handler>
    }

    return result;
1000e96c:	e51b3008 	ldr	r3, [fp, #-8]
}
1000e970:	e1a00003 	mov	r0, r3
1000e974:	e24bd004 	sub	sp, fp, #4
1000e978:	e8bd8800 	pop	{fp, pc}

1000e97c <rt_device_close>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_close(rt_device_t dev)
{
1000e97c:	e92d4800 	push	{fp, lr}
1000e980:	e28db004 	add	fp, sp, #4
1000e984:	e24dd010 	sub	sp, sp, #16
1000e988:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000e98c:	e3a03000 	mov	r3, #0
1000e990:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
1000e994:	e51b3010 	ldr	r3, [fp, #-16]
1000e998:	e3530000 	cmp	r3, #0
1000e99c:	1a000005 	bne	1000e9b8 <rt_device_close+0x3c>
1000e9a0:	e30302e0 	movw	r0, #13024	; 0x32e0
1000e9a4:	e3410003 	movt	r0, #4099	; 0x1003
1000e9a8:	e3031374 	movw	r1, #13172	; 0x3374
1000e9ac:	e3411003 	movt	r1, #4099	; 0x1003
1000e9b0:	e3a020f1 	mov	r2, #241	; 0xf1
1000e9b4:	eb0014fe 	bl	10013db4 <rt_assert_handler>

    if (dev->ref_count == 0)
1000e9b8:	e51b3010 	ldr	r3, [fp, #-16]
1000e9bc:	e5d33016 	ldrb	r3, [r3, #22]
1000e9c0:	e3530000 	cmp	r3, #0
1000e9c4:	1a000001 	bne	1000e9d0 <rt_device_close+0x54>
        return -RT_ERROR;
1000e9c8:	e3e03000 	mvn	r3, #0
1000e9cc:	ea00001e 	b	1000ea4c <rt_device_close+0xd0>

    dev->ref_count--;
1000e9d0:	e51b3010 	ldr	r3, [fp, #-16]
1000e9d4:	e5d33016 	ldrb	r3, [r3, #22]
1000e9d8:	e2433001 	sub	r3, r3, #1
1000e9dc:	e6ef2073 	uxtb	r2, r3
1000e9e0:	e51b3010 	ldr	r3, [fp, #-16]
1000e9e4:	e5c32016 	strb	r2, [r3, #22]

    if (dev->ref_count != 0)
1000e9e8:	e51b3010 	ldr	r3, [fp, #-16]
1000e9ec:	e5d33016 	ldrb	r3, [r3, #22]
1000e9f0:	e3530000 	cmp	r3, #0
1000e9f4:	0a000001 	beq	1000ea00 <rt_device_close+0x84>
        return RT_EOK;
1000e9f8:	e3a03000 	mov	r3, #0
1000e9fc:	ea000012 	b	1000ea4c <rt_device_close+0xd0>

    /* call device close interface */
    if (dev->close != RT_NULL)
1000ea00:	e51b3010 	ldr	r3, [fp, #-16]
1000ea04:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1000ea08:	e3530000 	cmp	r3, #0
1000ea0c:	0a000004 	beq	1000ea24 <rt_device_close+0xa8>
    {
        result = dev->close(dev);
1000ea10:	e51b3010 	ldr	r3, [fp, #-16]
1000ea14:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1000ea18:	e51b0010 	ldr	r0, [fp, #-16]
1000ea1c:	e12fff33 	blx	r3
1000ea20:	e50b0008 	str	r0, [fp, #-8]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
1000ea24:	e51b3008 	ldr	r3, [fp, #-8]
1000ea28:	e3530000 	cmp	r3, #0
1000ea2c:	0a000002 	beq	1000ea3c <rt_device_close+0xc0>
1000ea30:	e51b3008 	ldr	r3, [fp, #-8]
1000ea34:	e3730006 	cmn	r3, #6
1000ea38:	1a000002 	bne	1000ea48 <rt_device_close+0xcc>
        dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
1000ea3c:	e51b3010 	ldr	r3, [fp, #-16]
1000ea40:	e3a02000 	mov	r2, #0
1000ea44:	e1c321b4 	strh	r2, [r3, #20]

    return result;
1000ea48:	e51b3008 	ldr	r3, [fp, #-8]
}
1000ea4c:	e1a00003 	mov	r0, r3
1000ea50:	e24bd004 	sub	sp, fp, #4
1000ea54:	e8bd8800 	pop	{fp, pc}

1000ea58 <rt_device_read>:
 */
rt_size_t rt_device_read(rt_device_t dev,
                         rt_off_t    pos,
                         void       *buffer,
                         rt_size_t   size)
{
1000ea58:	e92d4800 	push	{fp, lr}
1000ea5c:	e28db004 	add	fp, sp, #4
1000ea60:	e24dd010 	sub	sp, sp, #16
1000ea64:	e50b0008 	str	r0, [fp, #-8]
1000ea68:	e50b100c 	str	r1, [fp, #-12]
1000ea6c:	e50b2010 	str	r2, [fp, #-16]
1000ea70:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(dev != RT_NULL);
1000ea74:	e51b3008 	ldr	r3, [fp, #-8]
1000ea78:	e3530000 	cmp	r3, #0
1000ea7c:	1a000005 	bne	1000ea98 <rt_device_read+0x40>
1000ea80:	e30302e0 	movw	r0, #13024	; 0x32e0
1000ea84:	e3410003 	movt	r0, #4099	; 0x1003
1000ea88:	e3031384 	movw	r1, #13188	; 0x3384
1000ea8c:	e3411003 	movt	r1, #4099	; 0x1003
1000ea90:	e300211a 	movw	r2, #282	; 0x11a
1000ea94:	eb0014c6 	bl	10013db4 <rt_assert_handler>

    if (dev->ref_count == 0)
1000ea98:	e51b3008 	ldr	r3, [fp, #-8]
1000ea9c:	e5d33016 	ldrb	r3, [r3, #22]
1000eaa0:	e3530000 	cmp	r3, #0
1000eaa4:	1a000003 	bne	1000eab8 <rt_device_read+0x60>
    {
        rt_set_errno(-RT_ERROR);
1000eaa8:	e3e00000 	mvn	r0, #0
1000eaac:	eb000db6 	bl	1001218c <rt_set_errno>
        return 0;
1000eab0:	e3a03000 	mov	r3, #0
1000eab4:	ea00000f 	b	1000eaf8 <rt_device_read+0xa0>
    }

    /* call device read interface */
    if (dev->read != RT_NULL)
1000eab8:	e51b3008 	ldr	r3, [fp, #-8]
1000eabc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000eac0:	e3530000 	cmp	r3, #0
1000eac4:	0a000008 	beq	1000eaec <rt_device_read+0x94>
    {
        return dev->read(dev, pos, buffer, size);
1000eac8:	e51b3008 	ldr	r3, [fp, #-8]
1000eacc:	e593c02c 	ldr	ip, [r3, #44]	; 0x2c
1000ead0:	e51b0008 	ldr	r0, [fp, #-8]
1000ead4:	e51b100c 	ldr	r1, [fp, #-12]
1000ead8:	e51b2010 	ldr	r2, [fp, #-16]
1000eadc:	e51b3014 	ldr	r3, [fp, #-20]
1000eae0:	e12fff3c 	blx	ip
1000eae4:	e1a03000 	mov	r3, r0
1000eae8:	ea000002 	b	1000eaf8 <rt_device_read+0xa0>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
1000eaec:	e3e00005 	mvn	r0, #5
1000eaf0:	eb000da5 	bl	1001218c <rt_set_errno>

    return 0;
1000eaf4:	e3a03000 	mov	r3, #0
}
1000eaf8:	e1a00003 	mov	r0, r3
1000eafc:	e24bd004 	sub	sp, fp, #4
1000eb00:	e8bd8800 	pop	{fp, pc}

1000eb04 <rt_device_write>:
 */
rt_size_t rt_device_write(rt_device_t dev,
                          rt_off_t    pos,
                          const void *buffer,
                          rt_size_t   size)
{
1000eb04:	e92d4800 	push	{fp, lr}
1000eb08:	e28db004 	add	fp, sp, #4
1000eb0c:	e24dd010 	sub	sp, sp, #16
1000eb10:	e50b0008 	str	r0, [fp, #-8]
1000eb14:	e50b100c 	str	r1, [fp, #-12]
1000eb18:	e50b2010 	str	r2, [fp, #-16]
1000eb1c:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(dev != RT_NULL);
1000eb20:	e51b3008 	ldr	r3, [fp, #-8]
1000eb24:	e3530000 	cmp	r3, #0
1000eb28:	1a000005 	bne	1000eb44 <rt_device_write+0x40>
1000eb2c:	e30302e0 	movw	r0, #13024	; 0x32e0
1000eb30:	e3410003 	movt	r0, #4099	; 0x1003
1000eb34:	e3031394 	movw	r1, #13204	; 0x3394
1000eb38:	e3411003 	movt	r1, #4099	; 0x1003
1000eb3c:	e3a02d05 	mov	r2, #320	; 0x140
1000eb40:	eb00149b 	bl	10013db4 <rt_assert_handler>

    if (dev->ref_count == 0)
1000eb44:	e51b3008 	ldr	r3, [fp, #-8]
1000eb48:	e5d33016 	ldrb	r3, [r3, #22]
1000eb4c:	e3530000 	cmp	r3, #0
1000eb50:	1a000003 	bne	1000eb64 <rt_device_write+0x60>
    {
        rt_set_errno(-RT_ERROR);
1000eb54:	e3e00000 	mvn	r0, #0
1000eb58:	eb000d8b 	bl	1001218c <rt_set_errno>
        return 0;
1000eb5c:	e3a03000 	mov	r3, #0
1000eb60:	ea00000f 	b	1000eba4 <rt_device_write+0xa0>
    }

    /* call device write interface */
    if (dev->write != RT_NULL)
1000eb64:	e51b3008 	ldr	r3, [fp, #-8]
1000eb68:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1000eb6c:	e3530000 	cmp	r3, #0
1000eb70:	0a000008 	beq	1000eb98 <rt_device_write+0x94>
    {
        return dev->write(dev, pos, buffer, size);
1000eb74:	e51b3008 	ldr	r3, [fp, #-8]
1000eb78:	e593c030 	ldr	ip, [r3, #48]	; 0x30
1000eb7c:	e51b0008 	ldr	r0, [fp, #-8]
1000eb80:	e51b100c 	ldr	r1, [fp, #-12]
1000eb84:	e51b2010 	ldr	r2, [fp, #-16]
1000eb88:	e51b3014 	ldr	r3, [fp, #-20]
1000eb8c:	e12fff3c 	blx	ip
1000eb90:	e1a03000 	mov	r3, r0
1000eb94:	ea000002 	b	1000eba4 <rt_device_write+0xa0>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
1000eb98:	e3e00005 	mvn	r0, #5
1000eb9c:	eb000d7a 	bl	1001218c <rt_set_errno>

    return 0;
1000eba0:	e3a03000 	mov	r3, #0
}
1000eba4:	e1a00003 	mov	r0, r3
1000eba8:	e24bd004 	sub	sp, fp, #4
1000ebac:	e8bd8800 	pop	{fp, pc}

1000ebb0 <rt_device_control>:
 * @param arg the argument of command
 *
 * @return the result
 */
rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
{
1000ebb0:	e92d4800 	push	{fp, lr}
1000ebb4:	e28db004 	add	fp, sp, #4
1000ebb8:	e24dd010 	sub	sp, sp, #16
1000ebbc:	e50b0008 	str	r0, [fp, #-8]
1000ebc0:	e1a03001 	mov	r3, r1
1000ebc4:	e50b2010 	str	r2, [fp, #-16]
1000ebc8:	e54b3009 	strb	r3, [fp, #-9]
    RT_ASSERT(dev != RT_NULL);
1000ebcc:	e51b3008 	ldr	r3, [fp, #-8]
1000ebd0:	e3530000 	cmp	r3, #0
1000ebd4:	1a000005 	bne	1000ebf0 <rt_device_control+0x40>
1000ebd8:	e30302e0 	movw	r0, #13024	; 0x32e0
1000ebdc:	e3410003 	movt	r0, #4099	; 0x1003
1000ebe0:	e30313a4 	movw	r1, #13220	; 0x33a4
1000ebe4:	e3411003 	movt	r1, #4099	; 0x1003
1000ebe8:	e3a02e16 	mov	r2, #352	; 0x160
1000ebec:	eb001470 	bl	10013db4 <rt_assert_handler>

    /* call device write interface */
    if (dev->control != RT_NULL)
1000ebf0:	e51b3008 	ldr	r3, [fp, #-8]
1000ebf4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
1000ebf8:	e3530000 	cmp	r3, #0
1000ebfc:	0a000008 	beq	1000ec24 <rt_device_control+0x74>
    {
        return dev->control(dev, cmd, arg);
1000ec00:	e51b3008 	ldr	r3, [fp, #-8]
1000ec04:	e5933034 	ldr	r3, [r3, #52]	; 0x34
1000ec08:	e55b2009 	ldrb	r2, [fp, #-9]
1000ec0c:	e51b0008 	ldr	r0, [fp, #-8]
1000ec10:	e1a01002 	mov	r1, r2
1000ec14:	e51b2010 	ldr	r2, [fp, #-16]
1000ec18:	e12fff33 	blx	r3
1000ec1c:	e1a03000 	mov	r3, r0
1000ec20:	ea000000 	b	1000ec28 <rt_device_control+0x78>
    }

    return RT_EOK;
1000ec24:	e3a03000 	mov	r3, #0
}
1000ec28:	e1a00003 	mov	r0, r3
1000ec2c:	e24bd004 	sub	sp, fp, #4
1000ec30:	e8bd8800 	pop	{fp, pc}

1000ec34 <rt_device_set_rx_indicate>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_rx_indicate(rt_device_t dev,
                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
{
1000ec34:	e92d4800 	push	{fp, lr}
1000ec38:	e28db004 	add	fp, sp, #4
1000ec3c:	e24dd008 	sub	sp, sp, #8
1000ec40:	e50b0008 	str	r0, [fp, #-8]
1000ec44:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(dev != RT_NULL);
1000ec48:	e51b3008 	ldr	r3, [fp, #-8]
1000ec4c:	e3530000 	cmp	r3, #0
1000ec50:	1a000005 	bne	1000ec6c <rt_device_set_rx_indicate+0x38>
1000ec54:	e30302e0 	movw	r0, #13024	; 0x32e0
1000ec58:	e3410003 	movt	r0, #4099	; 0x1003
1000ec5c:	e30313b8 	movw	r1, #13240	; 0x33b8
1000ec60:	e3411003 	movt	r1, #4099	; 0x1003
1000ec64:	e3002179 	movw	r2, #377	; 0x179
1000ec68:	eb001451 	bl	10013db4 <rt_assert_handler>

    dev->rx_indicate = rx_ind;
1000ec6c:	e51b3008 	ldr	r3, [fp, #-8]
1000ec70:	e51b200c 	ldr	r2, [fp, #-12]
1000ec74:	e5832018 	str	r2, [r3, #24]

    return RT_EOK;
1000ec78:	e3a03000 	mov	r3, #0
}
1000ec7c:	e1a00003 	mov	r0, r3
1000ec80:	e24bd004 	sub	sp, fp, #4
1000ec84:	e8bd8800 	pop	{fp, pc}

1000ec88 <rt_device_set_tx_complete>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_tx_complete(rt_device_t dev,
                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer))
{
1000ec88:	e92d4800 	push	{fp, lr}
1000ec8c:	e28db004 	add	fp, sp, #4
1000ec90:	e24dd008 	sub	sp, sp, #8
1000ec94:	e50b0008 	str	r0, [fp, #-8]
1000ec98:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(dev != RT_NULL);
1000ec9c:	e51b3008 	ldr	r3, [fp, #-8]
1000eca0:	e3530000 	cmp	r3, #0
1000eca4:	1a000005 	bne	1000ecc0 <rt_device_set_tx_complete+0x38>
1000eca8:	e30302e0 	movw	r0, #13024	; 0x32e0
1000ecac:	e3410003 	movt	r0, #4099	; 0x1003
1000ecb0:	e30313d4 	movw	r1, #13268	; 0x33d4
1000ecb4:	e3411003 	movt	r1, #4099	; 0x1003
1000ecb8:	e300218e 	movw	r2, #398	; 0x18e
1000ecbc:	eb00143c 	bl	10013db4 <rt_assert_handler>

    dev->tx_complete = tx_done;
1000ecc0:	e51b3008 	ldr	r3, [fp, #-8]
1000ecc4:	e51b200c 	ldr	r2, [fp, #-12]
1000ecc8:	e583201c 	str	r2, [r3, #28]

    return RT_EOK;
1000eccc:	e3a03000 	mov	r3, #0
}
1000ecd0:	e1a00003 	mov	r0, r3
1000ecd4:	e24bd004 	sub	sp, fp, #4
1000ecd8:	e8bd8800 	pop	{fp, pc}

1000ecdc <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
1000ecdc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ece0:	e28db000 	add	fp, sp, #0
1000ece4:	e24dd00c 	sub	sp, sp, #12
1000ece8:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
1000ecec:	e51b3008 	ldr	r3, [fp, #-8]
1000ecf0:	e5933000 	ldr	r3, [r3]
1000ecf4:	e51b2008 	ldr	r2, [fp, #-8]
1000ecf8:	e5922004 	ldr	r2, [r2, #4]
1000ecfc:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
1000ed00:	e51b3008 	ldr	r3, [fp, #-8]
1000ed04:	e5933004 	ldr	r3, [r3, #4]
1000ed08:	e51b2008 	ldr	r2, [fp, #-8]
1000ed0c:	e5922000 	ldr	r2, [r2]
1000ed10:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
1000ed14:	e51b3008 	ldr	r3, [fp, #-8]
1000ed18:	e51b2008 	ldr	r2, [fp, #-8]
1000ed1c:	e5832004 	str	r2, [r3, #4]
1000ed20:	e51b3008 	ldr	r3, [fp, #-8]
1000ed24:	e5932004 	ldr	r2, [r3, #4]
1000ed28:	e51b3008 	ldr	r3, [fp, #-8]
1000ed2c:	e5832000 	str	r2, [r3]
}
1000ed30:	e24bd000 	sub	sp, fp, #0
1000ed34:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ed38:	e12fff1e 	bx	lr

1000ed3c <rt_thread_idle_sethook>:
 * @param hook the specified hook function
 *
 * @note the hook function must be simple and never be blocked or suspend.
 */
void rt_thread_idle_sethook(void (*hook)(void))
{
1000ed3c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ed40:	e28db000 	add	fp, sp, #0
1000ed44:	e24dd00c 	sub	sp, sp, #12
1000ed48:	e50b0008 	str	r0, [fp, #-8]
    rt_thread_idle_hook = hook;
1000ed4c:	e30c3368 	movw	r3, #50024	; 0xc368
1000ed50:	e3413003 	movt	r3, #4099	; 0x1003
1000ed54:	e51b2008 	ldr	r2, [fp, #-8]
1000ed58:	e5832000 	str	r2, [r3]
}
1000ed5c:	e24bd000 	sub	sp, fp, #0
1000ed60:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ed64:	e12fff1e 	bx	lr

1000ed68 <_has_defunct_thread>:
#endif

/* Return whether there is defunctional thread to be deleted. */
rt_inline int _has_defunct_thread(void)
{
1000ed68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ed6c:	e28db000 	add	fp, sp, #0
1000ed70:	e24dd00c 	sub	sp, sp, #12
     * So the compiler has a good reason that the rt_thread_defunct list does
     * not change within rt_thread_idle_excute thus optimize the "while" loop
     * into a "if".
     *
     * So add the volatile qualifier here. */
    const volatile rt_list_t *l = (const volatile rt_list_t*)&rt_thread_defunct;
1000ed74:	e3023ac4 	movw	r3, #10948	; 0x2ac4
1000ed78:	e3413004 	movt	r3, #4100	; 0x1004
1000ed7c:	e50b3008 	str	r3, [fp, #-8]

    return l->next != l;
1000ed80:	e51b3008 	ldr	r3, [fp, #-8]
1000ed84:	e5932000 	ldr	r2, [r3]
1000ed88:	e51b3008 	ldr	r3, [fp, #-8]
1000ed8c:	e1520003 	cmp	r2, r3
1000ed90:	13a03001 	movne	r3, #1
1000ed94:	03a03000 	moveq	r3, #0
1000ed98:	e6ef3073 	uxtb	r3, r3
}
1000ed9c:	e1a00003 	mov	r0, r3
1000eda0:	e24bd000 	sub	sp, fp, #0
1000eda4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000eda8:	e12fff1e 	bx	lr

1000edac <rt_thread_idle_excute>:
 * @ingroup Thread
 *
 * This function will perform system background job when system idle.
 */
void rt_thread_idle_excute(void)
{
1000edac:	e92d4800 	push	{fp, lr}
1000edb0:	e28db004 	add	fp, sp, #4
1000edb4:	e24dd010 	sub	sp, sp, #16
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
1000edb8:	ea00003c 	b	1000eeb0 <rt_thread_idle_excute+0x104>
        rt_base_t lock;
        rt_thread_t thread;
#ifdef RT_USING_MODULE
        rt_module_t module = RT_NULL;
#endif
        RT_DEBUG_NOT_IN_INTERRUPT;
1000edbc:	eb002a1b 	bl	10019630 <rt_hw_interrupt_disable>
1000edc0:	e50b0008 	str	r0, [fp, #-8]
1000edc4:	eb000ccd 	bl	10012100 <rt_interrupt_get_nest>
1000edc8:	e1a03000 	mov	r3, r0
1000edcc:	e3530000 	cmp	r3, #0
1000edd0:	0a00000a 	beq	1000ee00 <rt_thread_idle_excute+0x54>
1000edd4:	e30303f0 	movw	r0, #13296	; 0x33f0
1000edd8:	e3410003 	movt	r0, #4099	; 0x1003
1000eddc:	e3031420 	movw	r1, #13344	; 0x3420
1000ede0:	e3411003 	movt	r1, #4099	; 0x1003
1000ede4:	eb001335 	bl	10013ac0 <rt_kprintf>
1000ede8:	e3030414 	movw	r0, #13332	; 0x3414
1000edec:	e3410003 	movt	r0, #4099	; 0x1003
1000edf0:	e3031420 	movw	r1, #13344	; 0x3420
1000edf4:	e3411003 	movt	r1, #4099	; 0x1003
1000edf8:	e3a0205e 	mov	r2, #94	; 0x5e
1000edfc:	eb0013ec 	bl	10013db4 <rt_assert_handler>
1000ee00:	e51b0008 	ldr	r0, [fp, #-8]
1000ee04:	eb002a0d 	bl	10019640 <rt_hw_interrupt_enable>

        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
1000ee08:	eb002a08 	bl	10019630 <rt_hw_interrupt_disable>
1000ee0c:	e50b000c 	str	r0, [fp, #-12]

        /* re-check whether list is empty */
        if (_has_defunct_thread())
1000ee10:	ebffffd4 	bl	1000ed68 <_has_defunct_thread>
1000ee14:	e1a03000 	mov	r3, r0
1000ee18:	e3530000 	cmp	r3, #0
1000ee1c:	0a000018 	beq	1000ee84 <rt_thread_idle_excute+0xd8>
        {
            /* get defunct thread */
            thread = rt_list_entry(rt_thread_defunct.next,
1000ee20:	e3023ac4 	movw	r3, #10948	; 0x2ac4
1000ee24:	e3413004 	movt	r3, #4100	; 0x1004
1000ee28:	e5933000 	ldr	r3, [r3]
1000ee2c:	e2433010 	sub	r3, r3, #16
1000ee30:	e50b3010 	str	r3, [fp, #-16]
                /* detach module's main thread */
                module->module_thread = RT_NULL;
            }
#endif
            /* remove defunct thread */
            rt_list_remove(&(thread->tlist));
1000ee34:	e51b3010 	ldr	r3, [fp, #-16]
1000ee38:	e2833010 	add	r3, r3, #16
1000ee3c:	e1a00003 	mov	r0, r3
1000ee40:	ebffffa5 	bl	1000ecdc <rt_list_remove>
            /* invoke thread cleanup */
            if (thread->cleanup != RT_NULL)
1000ee44:	e51b3010 	ldr	r3, [fp, #-16]
1000ee48:	e5933070 	ldr	r3, [r3, #112]	; 0x70
1000ee4c:	e3530000 	cmp	r3, #0
1000ee50:	0a000003 	beq	1000ee64 <rt_thread_idle_excute+0xb8>
                thread->cleanup(thread);
1000ee54:	e51b3010 	ldr	r3, [fp, #-16]
1000ee58:	e5933070 	ldr	r3, [r3, #112]	; 0x70
1000ee5c:	e51b0010 	ldr	r0, [fp, #-16]
1000ee60:	e12fff33 	blx	r3

            /* if it's a system object, not delete it */
            if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
1000ee64:	e51b0010 	ldr	r0, [fp, #-16]
1000ee68:	eb001b9d 	bl	10015ce4 <rt_object_is_systemobject>
1000ee6c:	e1a03000 	mov	r3, r0
1000ee70:	e3530001 	cmp	r3, #1
1000ee74:	1a000005 	bne	1000ee90 <rt_thread_idle_excute+0xe4>
            {
                /* enable interrupt */
                rt_hw_interrupt_enable(lock);
1000ee78:	e51b000c 	ldr	r0, [fp, #-12]
1000ee7c:	eb0029ef 	bl	10019640 <rt_hw_interrupt_enable>

                return;
1000ee80:	ea00000e 	b	1000eec0 <rt_thread_idle_excute+0x114>
            }
        }
        else
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(lock);
1000ee84:	e51b000c 	ldr	r0, [fp, #-12]
1000ee88:	eb0029ec 	bl	10019640 <rt_hw_interrupt_enable>

            /* may the defunct thread list is removed by others, just return */
            return;
1000ee8c:	ea00000b 	b	1000eec0 <rt_thread_idle_excute+0x114>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
1000ee90:	e51b000c 	ldr	r0, [fp, #-12]
1000ee94:	eb0029e9 	bl	10019640 <rt_hw_interrupt_enable>
        if (thread->flags & RT_OBJECT_FLAG_MODULE)
            rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
        else
#endif
        /* release thread's stack */
        RT_KERNEL_FREE(thread->stack_addr);
1000ee98:	e51b3010 	ldr	r3, [fp, #-16]
1000ee9c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1000eea0:	e1a00003 	mov	r0, r3
1000eea4:	eb001715 	bl	10014b00 <rt_free>
        /* delete thread object */
        rt_object_delete((rt_object_t)thread);
1000eea8:	e51b0010 	ldr	r0, [fp, #-16]
1000eeac:	eb001b5d 	bl	10015c28 <rt_object_delete>
 */
void rt_thread_idle_excute(void)
{
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
1000eeb0:	ebffffac 	bl	1000ed68 <_has_defunct_thread>
1000eeb4:	e1a03000 	mov	r3, r0
1000eeb8:	e3530000 	cmp	r3, #0
1000eebc:	1affffbe 	bne	1000edbc <rt_thread_idle_excute+0x10>
            if (module->nref == 0)
                rt_module_destroy(module);
        }
#endif
    }
}
1000eec0:	e24bd004 	sub	sp, fp, #4
1000eec4:	e8bd8800 	pop	{fp, pc}

1000eec8 <rt_thread_idle_entry>:

static void rt_thread_idle_entry(void *parameter)
{
1000eec8:	e92d4800 	push	{fp, lr}
1000eecc:	e28db004 	add	fp, sp, #4
1000eed0:	e24dd008 	sub	sp, sp, #8
1000eed4:	e50b0008 	str	r0, [fp, #-8]
    while (1)
    {
        #ifdef RT_USING_HOOK
        if (rt_thread_idle_hook != RT_NULL)
1000eed8:	e30c3368 	movw	r3, #50024	; 0xc368
1000eedc:	e3413003 	movt	r3, #4099	; 0x1003
1000eee0:	e5933000 	ldr	r3, [r3]
1000eee4:	e3530000 	cmp	r3, #0
1000eee8:	0a000003 	beq	1000eefc <rt_thread_idle_entry+0x34>
            rt_thread_idle_hook();
1000eeec:	e30c3368 	movw	r3, #50024	; 0xc368
1000eef0:	e3413003 	movt	r3, #4099	; 0x1003
1000eef4:	e5933000 	ldr	r3, [r3]
1000eef8:	e12fff33 	blx	r3
        #endif

        rt_thread_idle_excute();
1000eefc:	ebffffaa 	bl	1000edac <rt_thread_idle_excute>
    }
1000ef00:	eafffff4 	b	1000eed8 <rt_thread_idle_entry+0x10>

1000ef04 <rt_thread_idle_init>:
 * This function will initialize idle thread, then start it.
 *
 * @note this function must be invoked when system init.
 */
void rt_thread_idle_init(void)
{
1000ef04:	e92d4800 	push	{fp, lr}
1000ef08:	e28db004 	add	fp, sp, #4
1000ef0c:	e24dd010 	sub	sp, sp, #16
    /* initialize thread */
    rt_thread_init(&idle,
1000ef10:	e30c3168 	movw	r3, #49512	; 0xc168
1000ef14:	e3413003 	movt	r3, #4099	; 0x1003
1000ef18:	e58d3000 	str	r3, [sp]
1000ef1c:	e3a03c02 	mov	r3, #512	; 0x200
1000ef20:	e58d3004 	str	r3, [sp, #4]
1000ef24:	e3a0301f 	mov	r3, #31
1000ef28:	e58d3008 	str	r3, [sp, #8]
1000ef2c:	e3a03020 	mov	r3, #32
1000ef30:	e58d300c 	str	r3, [sp, #12]
1000ef34:	e30c00f0 	movw	r0, #49392	; 0xc0f0
1000ef38:	e3410003 	movt	r0, #4099	; 0x1003
1000ef3c:	e3031418 	movw	r1, #13336	; 0x3418
1000ef40:	e3411003 	movt	r1, #4099	; 0x1003
1000ef44:	e30e2ec8 	movw	r2, #61128	; 0xeec8
1000ef48:	e3412000 	movt	r2, #4096	; 0x1000
1000ef4c:	e3a03000 	mov	r3, #0
1000ef50:	eb001e54 	bl	100168a8 <rt_thread_init>
                   sizeof(rt_thread_stack),
                   RT_THREAD_PRIORITY_MAX - 1,
                   32);

    /* startup */
    rt_thread_startup(&idle);
1000ef54:	e30c00f0 	movw	r0, #49392	; 0xc0f0
1000ef58:	e3410003 	movt	r0, #4099	; 0x1003
1000ef5c:	eb001e88 	bl	10016984 <rt_thread_startup>
}
1000ef60:	e24bd004 	sub	sp, fp, #4
1000ef64:	e8bd8800 	pop	{fp, pc}

1000ef68 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
1000ef68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ef6c:	e28db000 	add	fp, sp, #0
1000ef70:	e24dd00c 	sub	sp, sp, #12
1000ef74:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
1000ef78:	e51b3008 	ldr	r3, [fp, #-8]
1000ef7c:	e51b2008 	ldr	r2, [fp, #-8]
1000ef80:	e5832004 	str	r2, [r3, #4]
1000ef84:	e51b3008 	ldr	r3, [fp, #-8]
1000ef88:	e5932004 	ldr	r2, [r3, #4]
1000ef8c:	e51b3008 	ldr	r3, [fp, #-8]
1000ef90:	e5832000 	str	r2, [r3]
}
1000ef94:	e24bd000 	sub	sp, fp, #0
1000ef98:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ef9c:	e12fff1e 	bx	lr

1000efa0 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
1000efa0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000efa4:	e28db000 	add	fp, sp, #0
1000efa8:	e24dd00c 	sub	sp, sp, #12
1000efac:	e50b0008 	str	r0, [fp, #-8]
1000efb0:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
1000efb4:	e51b3008 	ldr	r3, [fp, #-8]
1000efb8:	e5933004 	ldr	r3, [r3, #4]
1000efbc:	e51b200c 	ldr	r2, [fp, #-12]
1000efc0:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
1000efc4:	e51b3008 	ldr	r3, [fp, #-8]
1000efc8:	e5932004 	ldr	r2, [r3, #4]
1000efcc:	e51b300c 	ldr	r3, [fp, #-12]
1000efd0:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
1000efd4:	e51b3008 	ldr	r3, [fp, #-8]
1000efd8:	e51b200c 	ldr	r2, [fp, #-12]
1000efdc:	e5832004 	str	r2, [r3, #4]
    n->next = l;
1000efe0:	e51b300c 	ldr	r3, [fp, #-12]
1000efe4:	e51b2008 	ldr	r2, [fp, #-8]
1000efe8:	e5832000 	str	r2, [r3]
}
1000efec:	e24bd000 	sub	sp, fp, #0
1000eff0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000eff4:	e12fff1e 	bx	lr

1000eff8 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
1000eff8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000effc:	e28db000 	add	fp, sp, #0
1000f000:	e24dd00c 	sub	sp, sp, #12
1000f004:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
1000f008:	e51b3008 	ldr	r3, [fp, #-8]
1000f00c:	e5932000 	ldr	r2, [r3]
1000f010:	e51b3008 	ldr	r3, [fp, #-8]
1000f014:	e1520003 	cmp	r2, r3
1000f018:	03a03001 	moveq	r3, #1
1000f01c:	13a03000 	movne	r3, #0
1000f020:	e6ef3073 	uxtb	r3, r3
}
1000f024:	e1a00003 	mov	r0, r3
1000f028:	e24bd000 	sub	sp, fp, #0
1000f02c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000f030:	e12fff1e 	bx	lr

1000f034 <rt_ipc_object_init>:
 * @param ipc the IPC object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
{
1000f034:	e92d4800 	push	{fp, lr}
1000f038:	e28db004 	add	fp, sp, #4
1000f03c:	e24dd008 	sub	sp, sp, #8
1000f040:	e50b0008 	str	r0, [fp, #-8]
    /* init ipc object */
    rt_list_init(&(ipc->suspend_thread));
1000f044:	e51b3008 	ldr	r3, [fp, #-8]
1000f048:	e2833010 	add	r3, r3, #16
1000f04c:	e1a00003 	mov	r0, r3
1000f050:	ebffffc4 	bl	1000ef68 <rt_list_init>

    return RT_EOK;
1000f054:	e3a03000 	mov	r3, #0
}
1000f058:	e1a00003 	mov	r0, r3
1000f05c:	e24bd004 	sub	sp, fp, #4
1000f060:	e8bd8800 	pop	{fp, pc}

1000f064 <rt_ipc_list_suspend>:
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
                                       struct rt_thread *thread,
                                       rt_uint8_t        flag)
{
1000f064:	e92d4800 	push	{fp, lr}
1000f068:	e28db004 	add	fp, sp, #4
1000f06c:	e24dd018 	sub	sp, sp, #24
1000f070:	e50b0010 	str	r0, [fp, #-16]
1000f074:	e50b1014 	str	r1, [fp, #-20]
1000f078:	e1a03002 	mov	r3, r2
1000f07c:	e54b3015 	strb	r3, [fp, #-21]
    /* suspend thread */
    rt_thread_suspend(thread);
1000f080:	e51b0014 	ldr	r0, [fp, #-20]
1000f084:	eb001f97 	bl	10016ee8 <rt_thread_suspend>

    switch (flag)
1000f088:	e55b3015 	ldrb	r3, [fp, #-21]
1000f08c:	e3530000 	cmp	r3, #0
1000f090:	0a000002 	beq	1000f0a0 <rt_ipc_list_suspend+0x3c>
1000f094:	e3530001 	cmp	r3, #1
1000f098:	0a000006 	beq	1000f0b8 <rt_ipc_list_suspend+0x54>
1000f09c:	ea00002c 	b	1000f154 <rt_ipc_list_suspend+0xf0>
    {
    case RT_IPC_FLAG_FIFO:
        rt_list_insert_before(list, &(thread->tlist));
1000f0a0:	e51b3014 	ldr	r3, [fp, #-20]
1000f0a4:	e2833010 	add	r3, r3, #16
1000f0a8:	e51b0010 	ldr	r0, [fp, #-16]
1000f0ac:	e1a01003 	mov	r1, r3
1000f0b0:	ebffffba 	bl	1000efa0 <rt_list_insert_before>
        break;
1000f0b4:	ea000026 	b	1000f154 <rt_ipc_list_suspend+0xf0>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
1000f0b8:	e51b3010 	ldr	r3, [fp, #-16]
1000f0bc:	e5933000 	ldr	r3, [r3]
1000f0c0:	e50b3008 	str	r3, [fp, #-8]
1000f0c4:	ea000013 	b	1000f118 <rt_ipc_list_suspend+0xb4>
            {
                sthread = rt_list_entry(n, struct rt_thread, tlist);
1000f0c8:	e51b3008 	ldr	r3, [fp, #-8]
1000f0cc:	e2433010 	sub	r3, r3, #16
1000f0d0:	e50b300c 	str	r3, [fp, #-12]

                /* find out */
                if (thread->current_priority < sthread->current_priority)
1000f0d4:	e51b3014 	ldr	r3, [fp, #-20]
1000f0d8:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
1000f0dc:	e51b300c 	ldr	r3, [fp, #-12]
1000f0e0:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
1000f0e4:	e1520003 	cmp	r2, r3
1000f0e8:	2a000007 	bcs	1000f10c <rt_ipc_list_suspend+0xa8>
                {
                    /* insert this thread before the sthread */
                    rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
1000f0ec:	e51b300c 	ldr	r3, [fp, #-12]
1000f0f0:	e2832010 	add	r2, r3, #16
1000f0f4:	e51b3014 	ldr	r3, [fp, #-20]
1000f0f8:	e2833010 	add	r3, r3, #16
1000f0fc:	e1a00002 	mov	r0, r2
1000f100:	e1a01003 	mov	r1, r3
1000f104:	ebffffa5 	bl	1000efa0 <rt_list_insert_before>
                    break;
1000f108:	ea000006 	b	1000f128 <rt_ipc_list_suspend+0xc4>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
1000f10c:	e51b3008 	ldr	r3, [fp, #-8]
1000f110:	e5933000 	ldr	r3, [r3]
1000f114:	e50b3008 	str	r3, [fp, #-8]
1000f118:	e51b2008 	ldr	r2, [fp, #-8]
1000f11c:	e51b3010 	ldr	r3, [fp, #-16]
1000f120:	e1520003 	cmp	r2, r3
1000f124:	1affffe7 	bne	1000f0c8 <rt_ipc_list_suspend+0x64>

            /*
             * not found a suitable position,
             * append to the end of suspend_thread list
             */
            if (n == list)
1000f128:	e51b2008 	ldr	r2, [fp, #-8]
1000f12c:	e51b3010 	ldr	r3, [fp, #-16]
1000f130:	e1520003 	cmp	r2, r3
1000f134:	1a000005 	bne	1000f150 <rt_ipc_list_suspend+0xec>
                rt_list_insert_before(list, &(thread->tlist));
1000f138:	e51b3014 	ldr	r3, [fp, #-20]
1000f13c:	e2833010 	add	r3, r3, #16
1000f140:	e51b0010 	ldr	r0, [fp, #-16]
1000f144:	e1a01003 	mov	r1, r3
1000f148:	ebffff94 	bl	1000efa0 <rt_list_insert_before>
        }
        break;
1000f14c:	eaffffff 	b	1000f150 <rt_ipc_list_suspend+0xec>
1000f150:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
1000f154:	e3a03000 	mov	r3, #0
}
1000f158:	e1a00003 	mov	r0, r3
1000f15c:	e24bd004 	sub	sp, fp, #4
1000f160:	e8bd8800 	pop	{fp, pc}

1000f164 <rt_ipc_list_resume>:
 * @param list the thread list
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
{
1000f164:	e92d4800 	push	{fp, lr}
1000f168:	e28db004 	add	fp, sp, #4
1000f16c:	e24dd010 	sub	sp, sp, #16
1000f170:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;

    /* get thread entry */
    thread = rt_list_entry(list->next, struct rt_thread, tlist);
1000f174:	e51b3010 	ldr	r3, [fp, #-16]
1000f178:	e5933000 	ldr	r3, [r3]
1000f17c:	e2433010 	sub	r3, r3, #16
1000f180:	e50b3008 	str	r3, [fp, #-8]

    RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));

    /* resume it */
    rt_thread_resume(thread);
1000f184:	e51b0008 	ldr	r0, [fp, #-8]
1000f188:	eb001f7a 	bl	10016f78 <rt_thread_resume>

    return RT_EOK;
1000f18c:	e3a03000 	mov	r3, #0
}
1000f190:	e1a00003 	mov	r0, r3
1000f194:	e24bd004 	sub	sp, fp, #4
1000f198:	e8bd8800 	pop	{fp, pc}

1000f19c <rt_ipc_list_resume_all>:
 * @param list of the threads to resume
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
{
1000f19c:	e92d4810 	push	{r4, fp, lr}
1000f1a0:	e28db008 	add	fp, sp, #8
1000f1a4:	e24dd014 	sub	sp, sp, #20
1000f1a8:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
1000f1ac:	ea00000e 	b	1000f1ec <rt_ipc_list_resume_all+0x50>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
1000f1b0:	eb00291e 	bl	10019630 <rt_hw_interrupt_disable>
1000f1b4:	e1a03000 	mov	r3, r0
1000f1b8:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(list->next, struct rt_thread, tlist);
1000f1bc:	e51b3018 	ldr	r3, [fp, #-24]
1000f1c0:	e5933000 	ldr	r3, [r3]
1000f1c4:	e2433010 	sub	r3, r3, #16
1000f1c8:	e50b3010 	str	r3, [fp, #-16]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
1000f1cc:	e51b3010 	ldr	r3, [fp, #-16]
1000f1d0:	e3e02000 	mvn	r2, #0
1000f1d4:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
1000f1d8:	e51b0010 	ldr	r0, [fp, #-16]
1000f1dc:	eb001f65 	bl	10016f78 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
1000f1e0:	e1a03004 	mov	r3, r4
1000f1e4:	e1a00003 	mov	r0, r3
1000f1e8:	eb002914 	bl	10019640 <rt_hw_interrupt_enable>
{
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
1000f1ec:	e51b0018 	ldr	r0, [fp, #-24]
1000f1f0:	ebffff80 	bl	1000eff8 <rt_list_isempty>
1000f1f4:	e1a03000 	mov	r3, r0
1000f1f8:	e3530000 	cmp	r3, #0
1000f1fc:	0affffeb 	beq	1000f1b0 <rt_ipc_list_resume_all+0x14>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    return RT_EOK;
1000f200:	e3a03000 	mov	r3, #0
}
1000f204:	e1a00003 	mov	r0, r3
1000f208:	e24bd008 	sub	sp, fp, #8
1000f20c:	e8bd8810 	pop	{r4, fp, pc}

1000f210 <rt_sem_init>:
 */
rt_err_t rt_sem_init(rt_sem_t    sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
{
1000f210:	e92d4800 	push	{fp, lr}
1000f214:	e28db004 	add	fp, sp, #4
1000f218:	e24dd010 	sub	sp, sp, #16
1000f21c:	e50b0008 	str	r0, [fp, #-8]
1000f220:	e50b100c 	str	r1, [fp, #-12]
1000f224:	e50b2010 	str	r2, [fp, #-16]
1000f228:	e54b3011 	strb	r3, [fp, #-17]
    RT_ASSERT(sem != RT_NULL);
1000f22c:	e51b3008 	ldr	r3, [fp, #-8]
1000f230:	e3530000 	cmp	r3, #0
1000f234:	1a000005 	bne	1000f250 <rt_sem_init+0x40>
1000f238:	e3030438 	movw	r0, #13368	; 0x3438
1000f23c:	e3410003 	movt	r0, #4099	; 0x1003
1000f240:	e3031510 	movw	r1, #13584	; 0x3510
1000f244:	e3411003 	movt	r1, #4099	; 0x1003
1000f248:	e3a020d8 	mov	r2, #216	; 0xd8
1000f24c:	eb0012d8 	bl	10013db4 <rt_assert_handler>

    /* init object */
    rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
1000f250:	e51b3008 	ldr	r3, [fp, #-8]
1000f254:	e1a00003 	mov	r0, r3
1000f258:	e3a01001 	mov	r1, #1
1000f25c:	e51b200c 	ldr	r2, [fp, #-12]
1000f260:	eb0019d3 	bl	100159b4 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
1000f264:	e51b3008 	ldr	r3, [fp, #-8]
1000f268:	e1a00003 	mov	r0, r3
1000f26c:	ebffff70 	bl	1000f034 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
1000f270:	e51b3010 	ldr	r3, [fp, #-16]
1000f274:	e6ff2073 	uxth	r2, r3
1000f278:	e51b3008 	ldr	r3, [fp, #-8]
1000f27c:	e1c321b8 	strh	r2, [r3, #24]

    /* set parent */
    sem->parent.parent.flag = flag;
1000f280:	e51b3008 	ldr	r3, [fp, #-8]
1000f284:	e55b2011 	ldrb	r2, [fp, #-17]
1000f288:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
1000f28c:	e3a03000 	mov	r3, #0
}
1000f290:	e1a00003 	mov	r0, r3
1000f294:	e24bd004 	sub	sp, fp, #4
1000f298:	e8bd8800 	pop	{fp, pc}

1000f29c <rt_sem_detach>:
 * @return the operation status, RT_EOK on successful
 *
 * @see rt_sem_delete
 */
rt_err_t rt_sem_detach(rt_sem_t sem)
{
1000f29c:	e92d4800 	push	{fp, lr}
1000f2a0:	e28db004 	add	fp, sp, #4
1000f2a4:	e24dd008 	sub	sp, sp, #8
1000f2a8:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(sem != RT_NULL);
1000f2ac:	e51b3008 	ldr	r3, [fp, #-8]
1000f2b0:	e3530000 	cmp	r3, #0
1000f2b4:	1a000005 	bne	1000f2d0 <rt_sem_detach+0x34>
1000f2b8:	e3030438 	movw	r0, #13368	; 0x3438
1000f2bc:	e3410003 	movt	r0, #4099	; 0x1003
1000f2c0:	e303151c 	movw	r1, #13596	; 0x351c
1000f2c4:	e3411003 	movt	r1, #4099	; 0x1003
1000f2c8:	e3a020f5 	mov	r2, #245	; 0xf5
1000f2cc:	eb0012b8 	bl	10013db4 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
1000f2d0:	e51b3008 	ldr	r3, [fp, #-8]
1000f2d4:	e2833010 	add	r3, r3, #16
1000f2d8:	e1a00003 	mov	r0, r3
1000f2dc:	ebffffae 	bl	1000f19c <rt_ipc_list_resume_all>

    /* detach semaphore object */
    rt_object_detach(&(sem->parent.parent));
1000f2e0:	e51b3008 	ldr	r3, [fp, #-8]
1000f2e4:	e1a00003 	mov	r0, r3
1000f2e8:	eb0019e0 	bl	10015a70 <rt_object_detach>

    return RT_EOK;
1000f2ec:	e3a03000 	mov	r3, #0
}
1000f2f0:	e1a00003 	mov	r0, r3
1000f2f4:	e24bd004 	sub	sp, fp, #4
1000f2f8:	e8bd8800 	pop	{fp, pc}

1000f2fc <rt_sem_create>:
 * @return the created semaphore, RT_NULL on error happen
 *
 * @see rt_sem_init
 */
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
{
1000f2fc:	e92d4800 	push	{fp, lr}
1000f300:	e28db004 	add	fp, sp, #4
1000f304:	e24dd018 	sub	sp, sp, #24
1000f308:	e50b0010 	str	r0, [fp, #-16]
1000f30c:	e50b1014 	str	r1, [fp, #-20]
1000f310:	e1a03002 	mov	r3, r2
1000f314:	e54b3015 	strb	r3, [fp, #-21]
    rt_sem_t sem;

    RT_DEBUG_NOT_IN_INTERRUPT;
1000f318:	eb0028c4 	bl	10019630 <rt_hw_interrupt_disable>
1000f31c:	e50b0008 	str	r0, [fp, #-8]
1000f320:	eb000b76 	bl	10012100 <rt_interrupt_get_nest>
1000f324:	e1a03000 	mov	r3, r0
1000f328:	e3530000 	cmp	r3, #0
1000f32c:	0a00000a 	beq	1000f35c <rt_sem_create+0x60>
1000f330:	e3030448 	movw	r0, #13384	; 0x3448
1000f334:	e3410003 	movt	r0, #4099	; 0x1003
1000f338:	e303152c 	movw	r1, #13612	; 0x352c
1000f33c:	e3411003 	movt	r1, #4099	; 0x1003
1000f340:	eb0011de 	bl	10013ac0 <rt_kprintf>
1000f344:	e303046c 	movw	r0, #13420	; 0x346c
1000f348:	e3410003 	movt	r0, #4099	; 0x1003
1000f34c:	e303152c 	movw	r1, #13612	; 0x352c
1000f350:	e3411003 	movt	r1, #4099	; 0x1003
1000f354:	e3002111 	movw	r2, #273	; 0x111
1000f358:	eb001295 	bl	10013db4 <rt_assert_handler>
1000f35c:	e51b0008 	ldr	r0, [fp, #-8]
1000f360:	eb0028b6 	bl	10019640 <rt_hw_interrupt_enable>

    /* allocate object */
    sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
1000f364:	e3a00001 	mov	r0, #1
1000f368:	e51b1010 	ldr	r1, [fp, #-16]
1000f36c:	eb0019e0 	bl	10015af4 <rt_object_allocate>
1000f370:	e50b000c 	str	r0, [fp, #-12]
    if (sem == RT_NULL)
1000f374:	e51b300c 	ldr	r3, [fp, #-12]
1000f378:	e3530000 	cmp	r3, #0
1000f37c:	1a000001 	bne	1000f388 <rt_sem_create+0x8c>
        return sem;
1000f380:	e51b300c 	ldr	r3, [fp, #-12]
1000f384:	ea00000a 	b	1000f3b4 <rt_sem_create+0xb8>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
1000f388:	e51b300c 	ldr	r3, [fp, #-12]
1000f38c:	e1a00003 	mov	r0, r3
1000f390:	ebffff27 	bl	1000f034 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
1000f394:	e51b3014 	ldr	r3, [fp, #-20]
1000f398:	e6ff2073 	uxth	r2, r3
1000f39c:	e51b300c 	ldr	r3, [fp, #-12]
1000f3a0:	e1c321b8 	strh	r2, [r3, #24]

    /* set parent */
    sem->parent.parent.flag = flag;
1000f3a4:	e51b300c 	ldr	r3, [fp, #-12]
1000f3a8:	e55b2015 	ldrb	r2, [fp, #-21]
1000f3ac:	e5c32007 	strb	r2, [r3, #7]

    return sem;
1000f3b0:	e51b300c 	ldr	r3, [fp, #-12]
}
1000f3b4:	e1a00003 	mov	r0, r3
1000f3b8:	e24bd004 	sub	sp, fp, #4
1000f3bc:	e8bd8800 	pop	{fp, pc}

1000f3c0 <rt_sem_delete>:
 * @return the error code
 *
 * @see rt_sem_detach
 */
rt_err_t rt_sem_delete(rt_sem_t sem)
{
1000f3c0:	e92d4800 	push	{fp, lr}
1000f3c4:	e28db004 	add	fp, sp, #4
1000f3c8:	e24dd010 	sub	sp, sp, #16
1000f3cc:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
1000f3d0:	eb002896 	bl	10019630 <rt_hw_interrupt_disable>
1000f3d4:	e50b0008 	str	r0, [fp, #-8]
1000f3d8:	eb000b48 	bl	10012100 <rt_interrupt_get_nest>
1000f3dc:	e1a03000 	mov	r3, r0
1000f3e0:	e3530000 	cmp	r3, #0
1000f3e4:	0a00000a 	beq	1000f414 <rt_sem_delete+0x54>
1000f3e8:	e3030448 	movw	r0, #13384	; 0x3448
1000f3ec:	e3410003 	movt	r0, #4099	; 0x1003
1000f3f0:	e303153c 	movw	r1, #13628	; 0x353c
1000f3f4:	e3411003 	movt	r1, #4099	; 0x1003
1000f3f8:	eb0011b0 	bl	10013ac0 <rt_kprintf>
1000f3fc:	e303046c 	movw	r0, #13420	; 0x346c
1000f400:	e3410003 	movt	r0, #4099	; 0x1003
1000f404:	e303153c 	movw	r1, #13628	; 0x353c
1000f408:	e3411003 	movt	r1, #4099	; 0x1003
1000f40c:	e3a02e13 	mov	r2, #304	; 0x130
1000f410:	eb001267 	bl	10013db4 <rt_assert_handler>
1000f414:	e51b0008 	ldr	r0, [fp, #-8]
1000f418:	eb002888 	bl	10019640 <rt_hw_interrupt_enable>

    RT_ASSERT(sem != RT_NULL);
1000f41c:	e51b3010 	ldr	r3, [fp, #-16]
1000f420:	e3530000 	cmp	r3, #0
1000f424:	1a000005 	bne	1000f440 <rt_sem_delete+0x80>
1000f428:	e3030438 	movw	r0, #13368	; 0x3438
1000f42c:	e3410003 	movt	r0, #4099	; 0x1003
1000f430:	e303153c 	movw	r1, #13628	; 0x353c
1000f434:	e3411003 	movt	r1, #4099	; 0x1003
1000f438:	e3002132 	movw	r2, #306	; 0x132
1000f43c:	eb00125c 	bl	10013db4 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
1000f440:	e51b3010 	ldr	r3, [fp, #-16]
1000f444:	e2833010 	add	r3, r3, #16
1000f448:	e1a00003 	mov	r0, r3
1000f44c:	ebffff52 	bl	1000f19c <rt_ipc_list_resume_all>

    /* delete semaphore object */
    rt_object_delete(&(sem->parent.parent));
1000f450:	e51b3010 	ldr	r3, [fp, #-16]
1000f454:	e1a00003 	mov	r0, r3
1000f458:	eb0019f2 	bl	10015c28 <rt_object_delete>

    return RT_EOK;
1000f45c:	e3a03000 	mov	r3, #0
}
1000f460:	e1a00003 	mov	r0, r3
1000f464:	e24bd004 	sub	sp, fp, #4
1000f468:	e8bd8800 	pop	{fp, pc}

1000f46c <rt_sem_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
{
1000f46c:	e92d4810 	push	{r4, fp, lr}
1000f470:	e28db008 	add	fp, sp, #8
1000f474:	e24dd01c 	sub	sp, sp, #28
1000f478:	e50b0020 	str	r0, [fp, #-32]
1000f47c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_base_t temp;
    struct rt_thread *thread;

    RT_ASSERT(sem != RT_NULL);
1000f480:	e51b3020 	ldr	r3, [fp, #-32]
1000f484:	e3530000 	cmp	r3, #0
1000f488:	1a000005 	bne	1000f4a4 <rt_sem_take+0x38>
1000f48c:	e3030438 	movw	r0, #13368	; 0x3438
1000f490:	e3410003 	movt	r0, #4099	; 0x1003
1000f494:	e303154c 	movw	r1, #13644	; 0x354c
1000f498:	e3411003 	movt	r1, #4099	; 0x1003
1000f49c:	e300214d 	movw	r2, #333	; 0x14d
1000f4a0:	eb001243 	bl	10013db4 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
1000f4a4:	e30239b4 	movw	r3, #10676	; 0x29b4
1000f4a8:	e3413004 	movt	r3, #4100	; 0x1004
1000f4ac:	e5933000 	ldr	r3, [r3]
1000f4b0:	e3530000 	cmp	r3, #0
1000f4b4:	0a000005 	beq	1000f4d0 <rt_sem_take+0x64>
1000f4b8:	e30239b4 	movw	r3, #10676	; 0x29b4
1000f4bc:	e3413004 	movt	r3, #4100	; 0x1004
1000f4c0:	e5933000 	ldr	r3, [r3]
1000f4c4:	e51b2020 	ldr	r2, [fp, #-32]
1000f4c8:	e1a00002 	mov	r0, r2
1000f4cc:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
1000f4d0:	eb002856 	bl	10019630 <rt_hw_interrupt_disable>
1000f4d4:	e1a04000 	mov	r4, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (sem->value > 0)
1000f4d8:	e51b3020 	ldr	r3, [fp, #-32]
1000f4dc:	e1d331b8 	ldrh	r3, [r3, #24]
1000f4e0:	e3530000 	cmp	r3, #0
1000f4e4:	0a000008 	beq	1000f50c <rt_sem_take+0xa0>
    {
        /* semaphore is available */
        sem->value --;
1000f4e8:	e51b3020 	ldr	r3, [fp, #-32]
1000f4ec:	e1d331b8 	ldrh	r3, [r3, #24]
1000f4f0:	e2433001 	sub	r3, r3, #1
1000f4f4:	e6ff2073 	uxth	r2, r3
1000f4f8:	e51b3020 	ldr	r3, [fp, #-32]
1000f4fc:	e1c321b8 	strh	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
1000f500:	e1a00004 	mov	r0, r4
1000f504:	eb00284d 	bl	10019640 <rt_hw_interrupt_enable>
1000f508:	ea000051 	b	1000f654 <rt_sem_take+0x1e8>
    }
    else
    {
        /* no waiting, return with timeout */
        if (time == 0)
1000f50c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000f510:	e3530000 	cmp	r3, #0
1000f514:	1a000003 	bne	1000f528 <rt_sem_take+0xbc>
        {
            rt_hw_interrupt_enable(temp);
1000f518:	e1a00004 	mov	r0, r4
1000f51c:	eb002847 	bl	10019640 <rt_hw_interrupt_enable>

            return -RT_ETIMEOUT;
1000f520:	e3e03001 	mvn	r3, #1
1000f524:	ea000056 	b	1000f684 <rt_sem_take+0x218>
        }
        else
        {
            /* current context checking */
            RT_DEBUG_IN_THREAD_CONTEXT;
1000f528:	eb002840 	bl	10019630 <rt_hw_interrupt_disable>
1000f52c:	e50b0010 	str	r0, [fp, #-16]
1000f530:	eb001d0a 	bl	10016960 <rt_thread_self>
1000f534:	e1a03000 	mov	r3, r0
1000f538:	e3530000 	cmp	r3, #0
1000f53c:	1a00000a 	bne	1000f56c <rt_sem_take+0x100>
1000f540:	e3030470 	movw	r0, #13424	; 0x3470
1000f544:	e3410003 	movt	r0, #4099	; 0x1003
1000f548:	e303154c 	movw	r1, #13644	; 0x354c
1000f54c:	e3411003 	movt	r1, #4099	; 0x1003
1000f550:	eb00115a 	bl	10013ac0 <rt_kprintf>
1000f554:	e303046c 	movw	r0, #13420	; 0x346c
1000f558:	e3410003 	movt	r0, #4099	; 0x1003
1000f55c:	e303154c 	movw	r1, #13644	; 0x354c
1000f560:	e3411003 	movt	r1, #4099	; 0x1003
1000f564:	e300216d 	movw	r2, #365	; 0x16d
1000f568:	eb001211 	bl	10013db4 <rt_assert_handler>
1000f56c:	eb00282f 	bl	10019630 <rt_hw_interrupt_disable>
1000f570:	e50b0014 	str	r0, [fp, #-20]
1000f574:	eb000ae1 	bl	10012100 <rt_interrupt_get_nest>
1000f578:	e1a03000 	mov	r3, r0
1000f57c:	e3530000 	cmp	r3, #0
1000f580:	0a00000a 	beq	1000f5b0 <rt_sem_take+0x144>
1000f584:	e3030448 	movw	r0, #13384	; 0x3448
1000f588:	e3410003 	movt	r0, #4099	; 0x1003
1000f58c:	e303154c 	movw	r1, #13644	; 0x354c
1000f590:	e3411003 	movt	r1, #4099	; 0x1003
1000f594:	eb001149 	bl	10013ac0 <rt_kprintf>
1000f598:	e303046c 	movw	r0, #13420	; 0x346c
1000f59c:	e3410003 	movt	r0, #4099	; 0x1003
1000f5a0:	e303154c 	movw	r1, #13644	; 0x354c
1000f5a4:	e3411003 	movt	r1, #4099	; 0x1003
1000f5a8:	e300216d 	movw	r2, #365	; 0x16d
1000f5ac:	eb001200 	bl	10013db4 <rt_assert_handler>
1000f5b0:	e51b0014 	ldr	r0, [fp, #-20]
1000f5b4:	eb002821 	bl	10019640 <rt_hw_interrupt_enable>
1000f5b8:	e51b0010 	ldr	r0, [fp, #-16]
1000f5bc:	eb00281f 	bl	10019640 <rt_hw_interrupt_enable>

            /* semaphore is unavailable, push to suspend list */
            /* get current thread */
            thread = rt_thread_self();
1000f5c0:	eb001ce6 	bl	10016960 <rt_thread_self>
1000f5c4:	e50b0018 	str	r0, [fp, #-24]

            /* reset thread error number */
            thread->error = RT_EOK;
1000f5c8:	e51b3018 	ldr	r3, [fp, #-24]
1000f5cc:	e3a02000 	mov	r2, #0
1000f5d0:	e583202c 	str	r2, [r3, #44]	; 0x2c

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
                                        thread->name));

            /* suspend thread */
            rt_ipc_list_suspend(&(sem->parent.suspend_thread),
1000f5d4:	e51b3020 	ldr	r3, [fp, #-32]
1000f5d8:	e2832010 	add	r2, r3, #16
1000f5dc:	e51b3020 	ldr	r3, [fp, #-32]
1000f5e0:	e5d33007 	ldrb	r3, [r3, #7]
1000f5e4:	e1a00002 	mov	r0, r2
1000f5e8:	e51b1018 	ldr	r1, [fp, #-24]
1000f5ec:	e1a02003 	mov	r2, r3
1000f5f0:	ebfffe9b 	bl	1000f064 <rt_ipc_list_suspend>
                                thread,
                                sem->parent.parent.flag);

            /* has waiting time, start thread timer */
            if (time > 0)
1000f5f4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000f5f8:	e3530000 	cmp	r3, #0
1000f5fc:	da00000a 	ble	1000f62c <rt_sem_take+0x1c0>
            {
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                            thread->name));

                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
1000f600:	e51b3018 	ldr	r3, [fp, #-24]
1000f604:	e2832048 	add	r2, r3, #72	; 0x48
1000f608:	e24b3024 	sub	r3, fp, #36	; 0x24
1000f60c:	e1a00002 	mov	r0, r2
1000f610:	e3a01000 	mov	r1, #0
1000f614:	e1a02003 	mov	r2, r3
1000f618:	eb0020e1 	bl	100179a4 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &time);
                rt_timer_start(&(thread->thread_timer));
1000f61c:	e51b3018 	ldr	r3, [fp, #-24]
1000f620:	e2833048 	add	r3, r3, #72	; 0x48
1000f624:	e1a00003 	mov	r0, r3
1000f628:	eb001fe7 	bl	100175cc <rt_timer_start>
            }

            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
1000f62c:	e1a00004 	mov	r0, r4
1000f630:	eb002802 	bl	10019640 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
1000f634:	eb001ada 	bl	100161a4 <rt_schedule>

            if (thread->error != RT_EOK)
1000f638:	e51b3018 	ldr	r3, [fp, #-24]
1000f63c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000f640:	e3530000 	cmp	r3, #0
1000f644:	0a000002 	beq	1000f654 <rt_sem_take+0x1e8>
            {
                return thread->error;
1000f648:	e51b3018 	ldr	r3, [fp, #-24]
1000f64c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000f650:	ea00000b 	b	1000f684 <rt_sem_take+0x218>
            }
        }
    }

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
1000f654:	e30239b0 	movw	r3, #10672	; 0x29b0
1000f658:	e3413004 	movt	r3, #4100	; 0x1004
1000f65c:	e5933000 	ldr	r3, [r3]
1000f660:	e3530000 	cmp	r3, #0
1000f664:	0a000005 	beq	1000f680 <rt_sem_take+0x214>
1000f668:	e30239b0 	movw	r3, #10672	; 0x29b0
1000f66c:	e3413004 	movt	r3, #4100	; 0x1004
1000f670:	e5933000 	ldr	r3, [r3]
1000f674:	e51b2020 	ldr	r2, [fp, #-32]
1000f678:	e1a00002 	mov	r0, r2
1000f67c:	e12fff33 	blx	r3

    return RT_EOK;
1000f680:	e3a03000 	mov	r3, #0
}
1000f684:	e1a00003 	mov	r0, r3
1000f688:	e24bd008 	sub	sp, fp, #8
1000f68c:	e8bd8810 	pop	{r4, fp, pc}

1000f690 <rt_sem_trytake>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_trytake(rt_sem_t sem)
{
1000f690:	e92d4800 	push	{fp, lr}
1000f694:	e28db004 	add	fp, sp, #4
1000f698:	e24dd008 	sub	sp, sp, #8
1000f69c:	e50b0008 	str	r0, [fp, #-8]
    return rt_sem_take(sem, 0);
1000f6a0:	e51b0008 	ldr	r0, [fp, #-8]
1000f6a4:	e3a01000 	mov	r1, #0
1000f6a8:	ebffff6f 	bl	1000f46c <rt_sem_take>
1000f6ac:	e1a03000 	mov	r3, r0
}
1000f6b0:	e1a00003 	mov	r0, r3
1000f6b4:	e24bd004 	sub	sp, fp, #4
1000f6b8:	e8bd8800 	pop	{fp, pc}

1000f6bc <rt_sem_release>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_release(rt_sem_t sem)
{
1000f6bc:	e92d4830 	push	{r4, r5, fp, lr}
1000f6c0:	e28db00c 	add	fp, sp, #12
1000f6c4:	e24dd008 	sub	sp, sp, #8
1000f6c8:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;
    register rt_bool_t need_schedule;

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
1000f6cc:	e30239ac 	movw	r3, #10668	; 0x29ac
1000f6d0:	e3413004 	movt	r3, #4100	; 0x1004
1000f6d4:	e5933000 	ldr	r3, [r3]
1000f6d8:	e3530000 	cmp	r3, #0
1000f6dc:	0a000005 	beq	1000f6f8 <rt_sem_release+0x3c>
1000f6e0:	e30239ac 	movw	r3, #10668	; 0x29ac
1000f6e4:	e3413004 	movt	r3, #4100	; 0x1004
1000f6e8:	e5933000 	ldr	r3, [r3]
1000f6ec:	e51b2010 	ldr	r2, [fp, #-16]
1000f6f0:	e1a00002 	mov	r0, r2
1000f6f4:	e12fff33 	blx	r3

    need_schedule = RT_FALSE;
1000f6f8:	e3a04000 	mov	r4, #0

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
1000f6fc:	eb0027cb 	bl	10019630 <rt_hw_interrupt_disable>
1000f700:	e1a05000 	mov	r5, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (!rt_list_isempty(&sem->parent.suspend_thread))
1000f704:	e51b3010 	ldr	r3, [fp, #-16]
1000f708:	e2833010 	add	r3, r3, #16
1000f70c:	e1a00003 	mov	r0, r3
1000f710:	ebfffe38 	bl	1000eff8 <rt_list_isempty>
1000f714:	e1a03000 	mov	r3, r0
1000f718:	e3530000 	cmp	r3, #0
1000f71c:	1a000005 	bne	1000f738 <rt_sem_release+0x7c>
    {
        /* resume the suspended thread */
        rt_ipc_list_resume(&(sem->parent.suspend_thread));
1000f720:	e51b3010 	ldr	r3, [fp, #-16]
1000f724:	e2833010 	add	r3, r3, #16
1000f728:	e1a00003 	mov	r0, r3
1000f72c:	ebfffe8c 	bl	1000f164 <rt_ipc_list_resume>
        need_schedule = RT_TRUE;
1000f730:	e3a04001 	mov	r4, #1
1000f734:	ea000005 	b	1000f750 <rt_sem_release+0x94>
    }
    else
        sem->value ++; /* increase value */
1000f738:	e51b3010 	ldr	r3, [fp, #-16]
1000f73c:	e1d331b8 	ldrh	r3, [r3, #24]
1000f740:	e2833001 	add	r3, r3, #1
1000f744:	e6ff2073 	uxth	r2, r3
1000f748:	e51b3010 	ldr	r3, [fp, #-16]
1000f74c:	e1c321b8 	strh	r2, [r3, #24]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
1000f750:	e1a00005 	mov	r0, r5
1000f754:	eb0027b9 	bl	10019640 <rt_hw_interrupt_enable>

    /* resume a thread, re-schedule */
    if (need_schedule == RT_TRUE)
1000f758:	e3540001 	cmp	r4, #1
1000f75c:	1a000000 	bne	1000f764 <rt_sem_release+0xa8>
        rt_schedule();
1000f760:	eb001a8f 	bl	100161a4 <rt_schedule>

    return RT_EOK;
1000f764:	e3a03000 	mov	r3, #0
}
1000f768:	e1a00003 	mov	r0, r3
1000f76c:	e24bd00c 	sub	sp, fp, #12
1000f770:	e8bd8830 	pop	{r4, r5, fp, pc}

1000f774 <rt_sem_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg)
{
1000f774:	e92d4800 	push	{fp, lr}
1000f778:	e28db004 	add	fp, sp, #4
1000f77c:	e24dd018 	sub	sp, sp, #24
1000f780:	e50b0010 	str	r0, [fp, #-16]
1000f784:	e1a03001 	mov	r3, r1
1000f788:	e50b2018 	str	r2, [fp, #-24]
1000f78c:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    RT_ASSERT(sem != RT_NULL);
1000f790:	e51b3010 	ldr	r3, [fp, #-16]
1000f794:	e3530000 	cmp	r3, #0
1000f798:	1a000005 	bne	1000f7b4 <rt_sem_control+0x40>
1000f79c:	e3030438 	movw	r0, #13368	; 0x3438
1000f7a0:	e3410003 	movt	r0, #4099	; 0x1003
1000f7a4:	e3031558 	movw	r1, #13656	; 0x3558
1000f7a8:	e3411003 	movt	r1, #4099	; 0x1003
1000f7ac:	e3a02f79 	mov	r2, #484	; 0x1e4
1000f7b0:	eb00117f 	bl	10013db4 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
1000f7b4:	e55b3011 	ldrb	r3, [fp, #-17]
1000f7b8:	e3530001 	cmp	r3, #1
1000f7bc:	1a000012 	bne	1000f80c <rt_sem_control+0x98>
    {
        rt_uint32_t value;

        /* get value */
        value = (rt_uint32_t)arg;
1000f7c0:	e51b3018 	ldr	r3, [fp, #-24]
1000f7c4:	e50b3008 	str	r3, [fp, #-8]
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
1000f7c8:	eb002798 	bl	10019630 <rt_hw_interrupt_disable>
1000f7cc:	e1a03000 	mov	r3, r0
1000f7d0:	e50b300c 	str	r3, [fp, #-12]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&sem->parent.suspend_thread);
1000f7d4:	e51b3010 	ldr	r3, [fp, #-16]
1000f7d8:	e2833010 	add	r3, r3, #16
1000f7dc:	e1a00003 	mov	r0, r3
1000f7e0:	ebfffe6d 	bl	1000f19c <rt_ipc_list_resume_all>

        /* set new value */
        sem->value = (rt_uint16_t)value;
1000f7e4:	e51b3008 	ldr	r3, [fp, #-8]
1000f7e8:	e6ff2073 	uxth	r2, r3
1000f7ec:	e51b3010 	ldr	r3, [fp, #-16]
1000f7f0:	e1c321b8 	strh	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
1000f7f4:	e51b300c 	ldr	r3, [fp, #-12]
1000f7f8:	e1a00003 	mov	r0, r3
1000f7fc:	eb00278f 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
1000f800:	eb001a67 	bl	100161a4 <rt_schedule>

        return RT_EOK;
1000f804:	e3a03000 	mov	r3, #0
1000f808:	ea000000 	b	1000f810 <rt_sem_control+0x9c>
    }

    return -RT_ERROR;
1000f80c:	e3e03000 	mvn	r3, #0
}
1000f810:	e1a00003 	mov	r0, r3
1000f814:	e24bd004 	sub	sp, fp, #4
1000f818:	e8bd8800 	pop	{fp, pc}

1000f81c <rt_mutex_init>:
 * @param flag the flag of mutex
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
{
1000f81c:	e92d4800 	push	{fp, lr}
1000f820:	e28db004 	add	fp, sp, #4
1000f824:	e24dd010 	sub	sp, sp, #16
1000f828:	e50b0008 	str	r0, [fp, #-8]
1000f82c:	e50b100c 	str	r1, [fp, #-12]
1000f830:	e1a03002 	mov	r3, r2
1000f834:	e54b300d 	strb	r3, [fp, #-13]
    RT_ASSERT(mutex != RT_NULL);
1000f838:	e51b3008 	ldr	r3, [fp, #-8]
1000f83c:	e3530000 	cmp	r3, #0
1000f840:	1a000005 	bne	1000f85c <rt_mutex_init+0x40>
1000f844:	e30304a8 	movw	r0, #13480	; 0x34a8
1000f848:	e3410003 	movt	r0, #4099	; 0x1003
1000f84c:	e3031568 	movw	r1, #13672	; 0x3568
1000f850:	e3411003 	movt	r1, #4099	; 0x1003
1000f854:	e300220f 	movw	r2, #527	; 0x20f
1000f858:	eb001155 	bl	10013db4 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
1000f85c:	e51b3008 	ldr	r3, [fp, #-8]
1000f860:	e1a00003 	mov	r0, r3
1000f864:	e3a01002 	mov	r1, #2
1000f868:	e51b200c 	ldr	r2, [fp, #-12]
1000f86c:	eb001850 	bl	100159b4 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
1000f870:	e51b3008 	ldr	r3, [fp, #-8]
1000f874:	e1a00003 	mov	r0, r3
1000f878:	ebfffded 	bl	1000f034 <rt_ipc_object_init>

    mutex->value = 1;
1000f87c:	e51b3008 	ldr	r3, [fp, #-8]
1000f880:	e3a02001 	mov	r2, #1
1000f884:	e1c321b8 	strh	r2, [r3, #24]
    mutex->owner = RT_NULL;
1000f888:	e51b3008 	ldr	r3, [fp, #-8]
1000f88c:	e3a02000 	mov	r2, #0
1000f890:	e583201c 	str	r2, [r3, #28]
    mutex->original_priority = 0xFF;
1000f894:	e51b3008 	ldr	r3, [fp, #-8]
1000f898:	e3e02000 	mvn	r2, #0
1000f89c:	e5c3201a 	strb	r2, [r3, #26]
    mutex->hold  = 0;
1000f8a0:	e51b3008 	ldr	r3, [fp, #-8]
1000f8a4:	e3a02000 	mov	r2, #0
1000f8a8:	e5c3201b 	strb	r2, [r3, #27]

    /* set flag */
    mutex->parent.parent.flag = flag;
1000f8ac:	e51b3008 	ldr	r3, [fp, #-8]
1000f8b0:	e55b200d 	ldrb	r2, [fp, #-13]
1000f8b4:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
1000f8b8:	e3a03000 	mov	r3, #0
}
1000f8bc:	e1a00003 	mov	r0, r3
1000f8c0:	e24bd004 	sub	sp, fp, #4
1000f8c4:	e8bd8800 	pop	{fp, pc}

1000f8c8 <rt_mutex_detach>:
 * @return the operation status, RT_EOK on successful
 *
 * @see rt_mutex_delete
 */
rt_err_t rt_mutex_detach(rt_mutex_t mutex)
{
1000f8c8:	e92d4800 	push	{fp, lr}
1000f8cc:	e28db004 	add	fp, sp, #4
1000f8d0:	e24dd008 	sub	sp, sp, #8
1000f8d4:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(mutex != RT_NULL);
1000f8d8:	e51b3008 	ldr	r3, [fp, #-8]
1000f8dc:	e3530000 	cmp	r3, #0
1000f8e0:	1a000005 	bne	1000f8fc <rt_mutex_detach+0x34>
1000f8e4:	e30304a8 	movw	r0, #13480	; 0x34a8
1000f8e8:	e3410003 	movt	r0, #4099	; 0x1003
1000f8ec:	e3031578 	movw	r1, #13688	; 0x3578
1000f8f0:	e3411003 	movt	r1, #4099	; 0x1003
1000f8f4:	e300222e 	movw	r2, #558	; 0x22e
1000f8f8:	eb00112d 	bl	10013db4 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
1000f8fc:	e51b3008 	ldr	r3, [fp, #-8]
1000f900:	e2833010 	add	r3, r3, #16
1000f904:	e1a00003 	mov	r0, r3
1000f908:	ebfffe23 	bl	1000f19c <rt_ipc_list_resume_all>

    /* detach semaphore object */
    rt_object_detach(&(mutex->parent.parent));
1000f90c:	e51b3008 	ldr	r3, [fp, #-8]
1000f910:	e1a00003 	mov	r0, r3
1000f914:	eb001855 	bl	10015a70 <rt_object_detach>

    return RT_EOK;
1000f918:	e3a03000 	mov	r3, #0
}
1000f91c:	e1a00003 	mov	r0, r3
1000f920:	e24bd004 	sub	sp, fp, #4
1000f924:	e8bd8800 	pop	{fp, pc}

1000f928 <rt_mutex_create>:
 * @return the created mutex, RT_NULL on error happen
 *
 * @see rt_mutex_init
 */
rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
{
1000f928:	e92d4800 	push	{fp, lr}
1000f92c:	e28db004 	add	fp, sp, #4
1000f930:	e24dd010 	sub	sp, sp, #16
1000f934:	e50b0010 	str	r0, [fp, #-16]
1000f938:	e1a03001 	mov	r3, r1
1000f93c:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_mutex *mutex;

    RT_DEBUG_NOT_IN_INTERRUPT;
1000f940:	eb00273a 	bl	10019630 <rt_hw_interrupt_disable>
1000f944:	e50b0008 	str	r0, [fp, #-8]
1000f948:	eb0009ec 	bl	10012100 <rt_interrupt_get_nest>
1000f94c:	e1a03000 	mov	r3, r0
1000f950:	e3530000 	cmp	r3, #0
1000f954:	0a00000a 	beq	1000f984 <rt_mutex_create+0x5c>
1000f958:	e3030448 	movw	r0, #13384	; 0x3448
1000f95c:	e3410003 	movt	r0, #4099	; 0x1003
1000f960:	e3031588 	movw	r1, #13704	; 0x3588
1000f964:	e3411003 	movt	r1, #4099	; 0x1003
1000f968:	eb001054 	bl	10013ac0 <rt_kprintf>
1000f96c:	e303046c 	movw	r0, #13420	; 0x346c
1000f970:	e3410003 	movt	r0, #4099	; 0x1003
1000f974:	e3031588 	movw	r1, #13704	; 0x3588
1000f978:	e3411003 	movt	r1, #4099	; 0x1003
1000f97c:	e3002249 	movw	r2, #585	; 0x249
1000f980:	eb00110b 	bl	10013db4 <rt_assert_handler>
1000f984:	e51b0008 	ldr	r0, [fp, #-8]
1000f988:	eb00272c 	bl	10019640 <rt_hw_interrupt_enable>

    /* allocate object */
    mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
1000f98c:	e3a00002 	mov	r0, #2
1000f990:	e51b1010 	ldr	r1, [fp, #-16]
1000f994:	eb001856 	bl	10015af4 <rt_object_allocate>
1000f998:	e50b000c 	str	r0, [fp, #-12]
    if (mutex == RT_NULL)
1000f99c:	e51b300c 	ldr	r3, [fp, #-12]
1000f9a0:	e3530000 	cmp	r3, #0
1000f9a4:	1a000001 	bne	1000f9b0 <rt_mutex_create+0x88>
        return mutex;
1000f9a8:	e51b300c 	ldr	r3, [fp, #-12]
1000f9ac:	ea000012 	b	1000f9fc <rt_mutex_create+0xd4>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
1000f9b0:	e51b300c 	ldr	r3, [fp, #-12]
1000f9b4:	e1a00003 	mov	r0, r3
1000f9b8:	ebfffd9d 	bl	1000f034 <rt_ipc_object_init>

    mutex->value              = 1;
1000f9bc:	e51b300c 	ldr	r3, [fp, #-12]
1000f9c0:	e3a02001 	mov	r2, #1
1000f9c4:	e1c321b8 	strh	r2, [r3, #24]
    mutex->owner              = RT_NULL;
1000f9c8:	e51b300c 	ldr	r3, [fp, #-12]
1000f9cc:	e3a02000 	mov	r2, #0
1000f9d0:	e583201c 	str	r2, [r3, #28]
    mutex->original_priority  = 0xFF;
1000f9d4:	e51b300c 	ldr	r3, [fp, #-12]
1000f9d8:	e3e02000 	mvn	r2, #0
1000f9dc:	e5c3201a 	strb	r2, [r3, #26]
    mutex->hold               = 0;
1000f9e0:	e51b300c 	ldr	r3, [fp, #-12]
1000f9e4:	e3a02000 	mov	r2, #0
1000f9e8:	e5c3201b 	strb	r2, [r3, #27]

    /* set flag */
    mutex->parent.parent.flag = flag;
1000f9ec:	e51b300c 	ldr	r3, [fp, #-12]
1000f9f0:	e55b2011 	ldrb	r2, [fp, #-17]
1000f9f4:	e5c32007 	strb	r2, [r3, #7]

    return mutex;
1000f9f8:	e51b300c 	ldr	r3, [fp, #-12]
}
1000f9fc:	e1a00003 	mov	r0, r3
1000fa00:	e24bd004 	sub	sp, fp, #4
1000fa04:	e8bd8800 	pop	{fp, pc}

1000fa08 <rt_mutex_delete>:
 * @return the error code
 *
 * @see rt_mutex_detach
 */
rt_err_t rt_mutex_delete(rt_mutex_t mutex)
{
1000fa08:	e92d4800 	push	{fp, lr}
1000fa0c:	e28db004 	add	fp, sp, #4
1000fa10:	e24dd010 	sub	sp, sp, #16
1000fa14:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
1000fa18:	eb002704 	bl	10019630 <rt_hw_interrupt_disable>
1000fa1c:	e50b0008 	str	r0, [fp, #-8]
1000fa20:	eb0009b6 	bl	10012100 <rt_interrupt_get_nest>
1000fa24:	e1a03000 	mov	r3, r0
1000fa28:	e3530000 	cmp	r3, #0
1000fa2c:	0a00000a 	beq	1000fa5c <rt_mutex_delete+0x54>
1000fa30:	e3030448 	movw	r0, #13384	; 0x3448
1000fa34:	e3410003 	movt	r0, #4099	; 0x1003
1000fa38:	e3031598 	movw	r1, #13720	; 0x3598
1000fa3c:	e3411003 	movt	r1, #4099	; 0x1003
1000fa40:	eb00101e 	bl	10013ac0 <rt_kprintf>
1000fa44:	e303046c 	movw	r0, #13420	; 0x346c
1000fa48:	e3410003 	movt	r0, #4099	; 0x1003
1000fa4c:	e3031598 	movw	r1, #13720	; 0x3598
1000fa50:	e3411003 	movt	r1, #4099	; 0x1003
1000fa54:	e300226a 	movw	r2, #618	; 0x26a
1000fa58:	eb0010d5 	bl	10013db4 <rt_assert_handler>
1000fa5c:	e51b0008 	ldr	r0, [fp, #-8]
1000fa60:	eb0026f6 	bl	10019640 <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
1000fa64:	e51b3010 	ldr	r3, [fp, #-16]
1000fa68:	e3530000 	cmp	r3, #0
1000fa6c:	1a000005 	bne	1000fa88 <rt_mutex_delete+0x80>
1000fa70:	e30304a8 	movw	r0, #13480	; 0x34a8
1000fa74:	e3410003 	movt	r0, #4099	; 0x1003
1000fa78:	e3031598 	movw	r1, #13720	; 0x3598
1000fa7c:	e3411003 	movt	r1, #4099	; 0x1003
1000fa80:	e3a02f9b 	mov	r2, #620	; 0x26c
1000fa84:	eb0010ca 	bl	10013db4 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
1000fa88:	e51b3010 	ldr	r3, [fp, #-16]
1000fa8c:	e2833010 	add	r3, r3, #16
1000fa90:	e1a00003 	mov	r0, r3
1000fa94:	ebfffdc0 	bl	1000f19c <rt_ipc_list_resume_all>

    /* delete semaphore object */
    rt_object_delete(&(mutex->parent.parent));
1000fa98:	e51b3010 	ldr	r3, [fp, #-16]
1000fa9c:	e1a00003 	mov	r0, r3
1000faa0:	eb001860 	bl	10015c28 <rt_object_delete>

    return RT_EOK;
1000faa4:	e3a03000 	mov	r3, #0
}
1000faa8:	e1a00003 	mov	r0, r3
1000faac:	e24bd004 	sub	sp, fp, #4
1000fab0:	e8bd8800 	pop	{fp, pc}

1000fab4 <rt_mutex_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
{
1000fab4:	e92d4810 	push	{r4, fp, lr}
1000fab8:	e28db008 	add	fp, sp, #8
1000fabc:	e24dd01c 	sub	sp, sp, #28
1000fac0:	e50b0020 	str	r0, [fp, #-32]
1000fac4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_base_t temp;
    struct rt_thread *thread;

    /* this function must not be used in interrupt even if time = 0 */
    RT_DEBUG_IN_THREAD_CONTEXT;
1000fac8:	eb0026d8 	bl	10019630 <rt_hw_interrupt_disable>
1000facc:	e50b0010 	str	r0, [fp, #-16]
1000fad0:	eb001ba2 	bl	10016960 <rt_thread_self>
1000fad4:	e1a03000 	mov	r3, r0
1000fad8:	e3530000 	cmp	r3, #0
1000fadc:	1a00000a 	bne	1000fb0c <rt_mutex_take+0x58>
1000fae0:	e3030470 	movw	r0, #13424	; 0x3470
1000fae4:	e3410003 	movt	r0, #4099	; 0x1003
1000fae8:	e30315a8 	movw	r1, #13736	; 0x35a8
1000faec:	e3411003 	movt	r1, #4099	; 0x1003
1000faf0:	eb000ff2 	bl	10013ac0 <rt_kprintf>
1000faf4:	e303046c 	movw	r0, #13420	; 0x346c
1000faf8:	e3410003 	movt	r0, #4099	; 0x1003
1000fafc:	e30315a8 	movw	r1, #13736	; 0x35a8
1000fb00:	e3411003 	movt	r1, #4099	; 0x1003
1000fb04:	e3a02fa2 	mov	r2, #648	; 0x288
1000fb08:	eb0010a9 	bl	10013db4 <rt_assert_handler>
1000fb0c:	eb0026c7 	bl	10019630 <rt_hw_interrupt_disable>
1000fb10:	e50b0014 	str	r0, [fp, #-20]
1000fb14:	eb000979 	bl	10012100 <rt_interrupt_get_nest>
1000fb18:	e1a03000 	mov	r3, r0
1000fb1c:	e3530000 	cmp	r3, #0
1000fb20:	0a00000a 	beq	1000fb50 <rt_mutex_take+0x9c>
1000fb24:	e3030448 	movw	r0, #13384	; 0x3448
1000fb28:	e3410003 	movt	r0, #4099	; 0x1003
1000fb2c:	e30315a8 	movw	r1, #13736	; 0x35a8
1000fb30:	e3411003 	movt	r1, #4099	; 0x1003
1000fb34:	eb000fe1 	bl	10013ac0 <rt_kprintf>
1000fb38:	e303046c 	movw	r0, #13420	; 0x346c
1000fb3c:	e3410003 	movt	r0, #4099	; 0x1003
1000fb40:	e30315a8 	movw	r1, #13736	; 0x35a8
1000fb44:	e3411003 	movt	r1, #4099	; 0x1003
1000fb48:	e3a02fa2 	mov	r2, #648	; 0x288
1000fb4c:	eb001098 	bl	10013db4 <rt_assert_handler>
1000fb50:	e51b0014 	ldr	r0, [fp, #-20]
1000fb54:	eb0026b9 	bl	10019640 <rt_hw_interrupt_enable>
1000fb58:	e51b0010 	ldr	r0, [fp, #-16]
1000fb5c:	eb0026b7 	bl	10019640 <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
1000fb60:	e51b3020 	ldr	r3, [fp, #-32]
1000fb64:	e3530000 	cmp	r3, #0
1000fb68:	1a000005 	bne	1000fb84 <rt_mutex_take+0xd0>
1000fb6c:	e30304a8 	movw	r0, #13480	; 0x34a8
1000fb70:	e3410003 	movt	r0, #4099	; 0x1003
1000fb74:	e30315a8 	movw	r1, #13736	; 0x35a8
1000fb78:	e3411003 	movt	r1, #4099	; 0x1003
1000fb7c:	e300228a 	movw	r2, #650	; 0x28a
1000fb80:	eb00108b 	bl	10013db4 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
1000fb84:	eb0026a9 	bl	10019630 <rt_hw_interrupt_disable>
1000fb88:	e1a04000 	mov	r4, r0

    /* get current thread */
    thread = rt_thread_self();
1000fb8c:	eb001b73 	bl	10016960 <rt_thread_self>
1000fb90:	e50b0018 	str	r0, [fp, #-24]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
1000fb94:	e30239b4 	movw	r3, #10676	; 0x29b4
1000fb98:	e3413004 	movt	r3, #4100	; 0x1004
1000fb9c:	e5933000 	ldr	r3, [r3]
1000fba0:	e3530000 	cmp	r3, #0
1000fba4:	0a000005 	beq	1000fbc0 <rt_mutex_take+0x10c>
1000fba8:	e30239b4 	movw	r3, #10676	; 0x29b4
1000fbac:	e3413004 	movt	r3, #4100	; 0x1004
1000fbb0:	e5933000 	ldr	r3, [r3]
1000fbb4:	e51b2020 	ldr	r2, [fp, #-32]
1000fbb8:	e1a00002 	mov	r0, r2
1000fbbc:	e12fff33 	blx	r3
    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    /* reset thread error */
    thread->error = RT_EOK;
1000fbc0:	e51b3018 	ldr	r3, [fp, #-24]
1000fbc4:	e3a02000 	mov	r2, #0
1000fbc8:	e583202c 	str	r2, [r3, #44]	; 0x2c

    if (mutex->owner == thread)
1000fbcc:	e51b3020 	ldr	r3, [fp, #-32]
1000fbd0:	e593201c 	ldr	r2, [r3, #28]
1000fbd4:	e51b3018 	ldr	r3, [fp, #-24]
1000fbd8:	e1520003 	cmp	r2, r3
1000fbdc:	1a000006 	bne	1000fbfc <rt_mutex_take+0x148>
    {
        /* it's the same thread */
        mutex->hold ++;
1000fbe0:	e51b3020 	ldr	r3, [fp, #-32]
1000fbe4:	e5d3301b 	ldrb	r3, [r3, #27]
1000fbe8:	e2833001 	add	r3, r3, #1
1000fbec:	e6ef2073 	uxtb	r2, r3
1000fbf0:	e51b3020 	ldr	r3, [fp, #-32]
1000fbf4:	e5c3201b 	strb	r2, [r3, #27]
1000fbf8:	ea000052 	b	1000fd48 <rt_mutex_take+0x294>
    else
    {
        /* The value of mutex is 1 in initial status. Therefore, if the
         * value is great than 0, it indicates the mutex is avaible.
         */
        if (mutex->value > 0)
1000fbfc:	e51b3020 	ldr	r3, [fp, #-32]
1000fc00:	e1d331b8 	ldrh	r3, [r3, #24]
1000fc04:	e3530000 	cmp	r3, #0
1000fc08:	0a000013 	beq	1000fc5c <rt_mutex_take+0x1a8>
        {
            /* mutex is available */
            mutex->value --;
1000fc0c:	e51b3020 	ldr	r3, [fp, #-32]
1000fc10:	e1d331b8 	ldrh	r3, [r3, #24]
1000fc14:	e2433001 	sub	r3, r3, #1
1000fc18:	e6ff2073 	uxth	r2, r3
1000fc1c:	e51b3020 	ldr	r3, [fp, #-32]
1000fc20:	e1c321b8 	strh	r2, [r3, #24]

            /* set mutex owner and original priority */
            mutex->owner             = thread;
1000fc24:	e51b3020 	ldr	r3, [fp, #-32]
1000fc28:	e51b2018 	ldr	r2, [fp, #-24]
1000fc2c:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = thread->current_priority;
1000fc30:	e51b3018 	ldr	r3, [fp, #-24]
1000fc34:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
1000fc38:	e51b3020 	ldr	r3, [fp, #-32]
1000fc3c:	e5c3201a 	strb	r2, [r3, #26]
            mutex->hold ++;
1000fc40:	e51b3020 	ldr	r3, [fp, #-32]
1000fc44:	e5d3301b 	ldrb	r3, [r3, #27]
1000fc48:	e2833001 	add	r3, r3, #1
1000fc4c:	e6ef2073 	uxtb	r2, r3
1000fc50:	e51b3020 	ldr	r3, [fp, #-32]
1000fc54:	e5c3201b 	strb	r2, [r3, #27]
1000fc58:	ea00003a 	b	1000fd48 <rt_mutex_take+0x294>
        }
        else
        {
            /* no waiting, return with timeout */
            if (time == 0)
1000fc5c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000fc60:	e3530000 	cmp	r3, #0
1000fc64:	1a000006 	bne	1000fc84 <rt_mutex_take+0x1d0>
            {
                /* set error as timeout */
                thread->error = -RT_ETIMEOUT;
1000fc68:	e51b3018 	ldr	r3, [fp, #-24]
1000fc6c:	e3e02001 	mvn	r2, #1
1000fc70:	e583202c 	str	r2, [r3, #44]	; 0x2c

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
1000fc74:	e1a00004 	mov	r0, r4
1000fc78:	eb002670 	bl	10019640 <rt_hw_interrupt_enable>

                return -RT_ETIMEOUT;
1000fc7c:	e3e03001 	mvn	r3, #1
1000fc80:	ea00003e 	b	1000fd80 <rt_mutex_take+0x2cc>
                /* mutex is unavailable, push to suspend list */
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
                                            thread->name));

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
1000fc84:	e51b3018 	ldr	r3, [fp, #-24]
1000fc88:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
1000fc8c:	e51b3020 	ldr	r3, [fp, #-32]
1000fc90:	e593301c 	ldr	r3, [r3, #28]
1000fc94:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
1000fc98:	e1520003 	cmp	r2, r3
1000fc9c:	2a000007 	bcs	1000fcc0 <rt_mutex_take+0x20c>
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
1000fca0:	e51b3020 	ldr	r3, [fp, #-32]
1000fca4:	e593201c 	ldr	r2, [r3, #28]
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
1000fca8:	e51b3018 	ldr	r3, [fp, #-24]
1000fcac:	e2833031 	add	r3, r3, #49	; 0x31

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
1000fcb0:	e1a00002 	mov	r0, r2
1000fcb4:	e3a01002 	mov	r1, #2
1000fcb8:	e1a02003 	mov	r2, r3
1000fcbc:	eb001c3f 	bl	10016dc0 <rt_thread_control>
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
                }

                /* suspend current thread */
                rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
1000fcc0:	e51b3020 	ldr	r3, [fp, #-32]
1000fcc4:	e2832010 	add	r2, r3, #16
1000fcc8:	e51b3020 	ldr	r3, [fp, #-32]
1000fccc:	e5d33007 	ldrb	r3, [r3, #7]
1000fcd0:	e1a00002 	mov	r0, r2
1000fcd4:	e51b1018 	ldr	r1, [fp, #-24]
1000fcd8:	e1a02003 	mov	r2, r3
1000fcdc:	ebfffce0 	bl	1000f064 <rt_ipc_list_suspend>
                                    thread,
                                    mutex->parent.parent.flag);

                /* has waiting time, start thread timer */
                if (time > 0)
1000fce0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000fce4:	e3530000 	cmp	r3, #0
1000fce8:	da00000a 	ble	1000fd18 <rt_mutex_take+0x264>
                    RT_DEBUG_LOG(RT_DEBUG_IPC,
                                 ("mutex_take: start the timer of thread:%s\n",
                                  thread->name));

                    /* reset the timeout of thread timer and start it */
                    rt_timer_control(&(thread->thread_timer),
1000fcec:	e51b3018 	ldr	r3, [fp, #-24]
1000fcf0:	e2832048 	add	r2, r3, #72	; 0x48
1000fcf4:	e24b3024 	sub	r3, fp, #36	; 0x24
1000fcf8:	e1a00002 	mov	r0, r2
1000fcfc:	e3a01000 	mov	r1, #0
1000fd00:	e1a02003 	mov	r2, r3
1000fd04:	eb001f26 	bl	100179a4 <rt_timer_control>
                                     RT_TIMER_CTRL_SET_TIME,
                                     &time);
                    rt_timer_start(&(thread->thread_timer));
1000fd08:	e51b3018 	ldr	r3, [fp, #-24]
1000fd0c:	e2833048 	add	r3, r3, #72	; 0x48
1000fd10:	e1a00003 	mov	r0, r3
1000fd14:	eb001e2c 	bl	100175cc <rt_timer_start>
                }

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
1000fd18:	e1a00004 	mov	r0, r4
1000fd1c:	eb002647 	bl	10019640 <rt_hw_interrupt_enable>

                /* do schedule */
                rt_schedule();
1000fd20:	eb00191f 	bl	100161a4 <rt_schedule>

                if (thread->error != RT_EOK)
1000fd24:	e51b3018 	ldr	r3, [fp, #-24]
1000fd28:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000fd2c:	e3530000 	cmp	r3, #0
1000fd30:	0a000002 	beq	1000fd40 <rt_mutex_take+0x28c>
                {
                    /* return error */
                    return thread->error;
1000fd34:	e51b3018 	ldr	r3, [fp, #-24]
1000fd38:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000fd3c:	ea00000f 	b	1000fd80 <rt_mutex_take+0x2cc>
                }
                else
                {
                    /* the mutex is taken successfully. */
                    /* disable interrupt */
                    temp = rt_hw_interrupt_disable();
1000fd40:	eb00263a 	bl	10019630 <rt_hw_interrupt_disable>
1000fd44:	e1a04000 	mov	r4, r0
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
1000fd48:	e1a00004 	mov	r0, r4
1000fd4c:	eb00263b 	bl	10019640 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
1000fd50:	e30239b0 	movw	r3, #10672	; 0x29b0
1000fd54:	e3413004 	movt	r3, #4100	; 0x1004
1000fd58:	e5933000 	ldr	r3, [r3]
1000fd5c:	e3530000 	cmp	r3, #0
1000fd60:	0a000005 	beq	1000fd7c <rt_mutex_take+0x2c8>
1000fd64:	e30239b0 	movw	r3, #10672	; 0x29b0
1000fd68:	e3413004 	movt	r3, #4100	; 0x1004
1000fd6c:	e5933000 	ldr	r3, [r3]
1000fd70:	e51b2020 	ldr	r2, [fp, #-32]
1000fd74:	e1a00002 	mov	r0, r2
1000fd78:	e12fff33 	blx	r3

    return RT_EOK;
1000fd7c:	e3a03000 	mov	r3, #0
}
1000fd80:	e1a00003 	mov	r0, r3
1000fd84:	e24bd008 	sub	sp, fp, #8
1000fd88:	e8bd8810 	pop	{r4, fp, pc}

1000fd8c <rt_mutex_release>:
 * @param mutex the mutex object
 *
 * @return the error code
 */
rt_err_t rt_mutex_release(rt_mutex_t mutex)
{
1000fd8c:	e92d4810 	push	{r4, fp, lr}
1000fd90:	e28db008 	add	fp, sp, #8
1000fd94:	e24dd01c 	sub	sp, sp, #28
1000fd98:	e50b0020 	str	r0, [fp, #-32]
    register rt_base_t temp;
    struct rt_thread *thread;
    rt_bool_t need_schedule;

    need_schedule = RT_FALSE;
1000fd9c:	e3a03000 	mov	r3, #0
1000fda0:	e50b3010 	str	r3, [fp, #-16]

    /* only thread could release mutex because we need test the ownership */
    RT_DEBUG_IN_THREAD_CONTEXT;
1000fda4:	eb002621 	bl	10019630 <rt_hw_interrupt_disable>
1000fda8:	e50b0014 	str	r0, [fp, #-20]
1000fdac:	eb001aeb 	bl	10016960 <rt_thread_self>
1000fdb0:	e1a03000 	mov	r3, r0
1000fdb4:	e3530000 	cmp	r3, #0
1000fdb8:	1a00000a 	bne	1000fde8 <rt_mutex_release+0x5c>
1000fdbc:	e3030470 	movw	r0, #13424	; 0x3470
1000fdc0:	e3410003 	movt	r0, #4099	; 0x1003
1000fdc4:	e30315b8 	movw	r1, #13752	; 0x35b8
1000fdc8:	e3411003 	movt	r1, #4099	; 0x1003
1000fdcc:	eb000f3b 	bl	10013ac0 <rt_kprintf>
1000fdd0:	e303046c 	movw	r0, #13420	; 0x346c
1000fdd4:	e3410003 	movt	r0, #4099	; 0x1003
1000fdd8:	e30315b8 	movw	r1, #13752	; 0x35b8
1000fddc:	e3411003 	movt	r1, #4099	; 0x1003
1000fde0:	e300230d 	movw	r2, #781	; 0x30d
1000fde4:	eb000ff2 	bl	10013db4 <rt_assert_handler>
1000fde8:	eb002610 	bl	10019630 <rt_hw_interrupt_disable>
1000fdec:	e50b0018 	str	r0, [fp, #-24]
1000fdf0:	eb0008c2 	bl	10012100 <rt_interrupt_get_nest>
1000fdf4:	e1a03000 	mov	r3, r0
1000fdf8:	e3530000 	cmp	r3, #0
1000fdfc:	0a00000a 	beq	1000fe2c <rt_mutex_release+0xa0>
1000fe00:	e3030448 	movw	r0, #13384	; 0x3448
1000fe04:	e3410003 	movt	r0, #4099	; 0x1003
1000fe08:	e30315b8 	movw	r1, #13752	; 0x35b8
1000fe0c:	e3411003 	movt	r1, #4099	; 0x1003
1000fe10:	eb000f2a 	bl	10013ac0 <rt_kprintf>
1000fe14:	e303046c 	movw	r0, #13420	; 0x346c
1000fe18:	e3410003 	movt	r0, #4099	; 0x1003
1000fe1c:	e30315b8 	movw	r1, #13752	; 0x35b8
1000fe20:	e3411003 	movt	r1, #4099	; 0x1003
1000fe24:	e300230d 	movw	r2, #781	; 0x30d
1000fe28:	eb000fe1 	bl	10013db4 <rt_assert_handler>
1000fe2c:	e51b0018 	ldr	r0, [fp, #-24]
1000fe30:	eb002602 	bl	10019640 <rt_hw_interrupt_enable>
1000fe34:	e51b0014 	ldr	r0, [fp, #-20]
1000fe38:	eb002600 	bl	10019640 <rt_hw_interrupt_enable>

    /* get current thread */
    thread = rt_thread_self();
1000fe3c:	eb001ac7 	bl	10016960 <rt_thread_self>
1000fe40:	e50b001c 	str	r0, [fp, #-28]

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
1000fe44:	eb0025f9 	bl	10019630 <rt_hw_interrupt_disable>
1000fe48:	e1a04000 	mov	r4, r0

    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
1000fe4c:	e30239ac 	movw	r3, #10668	; 0x29ac
1000fe50:	e3413004 	movt	r3, #4100	; 0x1004
1000fe54:	e5933000 	ldr	r3, [r3]
1000fe58:	e3530000 	cmp	r3, #0
1000fe5c:	0a000005 	beq	1000fe78 <rt_mutex_release+0xec>
1000fe60:	e30239ac 	movw	r3, #10668	; 0x29ac
1000fe64:	e3413004 	movt	r3, #4100	; 0x1004
1000fe68:	e5933000 	ldr	r3, [r3]
1000fe6c:	e51b2020 	ldr	r2, [fp, #-32]
1000fe70:	e1a00002 	mov	r0, r2
1000fe74:	e12fff33 	blx	r3

    /* mutex only can be released by owner */
    if (thread != mutex->owner)
1000fe78:	e51b3020 	ldr	r3, [fp, #-32]
1000fe7c:	e593201c 	ldr	r2, [r3, #28]
1000fe80:	e51b301c 	ldr	r3, [fp, #-28]
1000fe84:	e1520003 	cmp	r2, r3
1000fe88:	0a000006 	beq	1000fea8 <rt_mutex_release+0x11c>
    {
        thread->error = -RT_ERROR;
1000fe8c:	e51b301c 	ldr	r3, [fp, #-28]
1000fe90:	e3e02000 	mvn	r2, #0
1000fe94:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
1000fe98:	e1a00004 	mov	r0, r4
1000fe9c:	eb0025e7 	bl	10019640 <rt_hw_interrupt_enable>

        return -RT_ERROR;
1000fea0:	e3e03000 	mvn	r3, #0
1000fea4:	ea00004a 	b	1000ffd4 <rt_mutex_release+0x248>
    }

    /* decrease hold */
    mutex->hold --;
1000fea8:	e51b3020 	ldr	r3, [fp, #-32]
1000feac:	e5d3301b 	ldrb	r3, [r3, #27]
1000feb0:	e2433001 	sub	r3, r3, #1
1000feb4:	e6ef2073 	uxtb	r2, r3
1000feb8:	e51b3020 	ldr	r3, [fp, #-32]
1000febc:	e5c3201b 	strb	r2, [r3, #27]
    /* if no hold */
    if (mutex->hold == 0)
1000fec0:	e51b3020 	ldr	r3, [fp, #-32]
1000fec4:	e5d3301b 	ldrb	r3, [r3, #27]
1000fec8:	e3530000 	cmp	r3, #0
1000fecc:	1a000039 	bne	1000ffb8 <rt_mutex_release+0x22c>
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
1000fed0:	e51b3020 	ldr	r3, [fp, #-32]
1000fed4:	e5d3201a 	ldrb	r2, [r3, #26]
1000fed8:	e51b3020 	ldr	r3, [fp, #-32]
1000fedc:	e593301c 	ldr	r3, [r3, #28]
1000fee0:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
1000fee4:	e1520003 	cmp	r2, r3
1000fee8:	0a000007 	beq	1000ff0c <rt_mutex_release+0x180>
        {
            rt_thread_control(mutex->owner,
1000feec:	e51b3020 	ldr	r3, [fp, #-32]
1000fef0:	e593201c 	ldr	r2, [r3, #28]
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
1000fef4:	e51b3020 	ldr	r3, [fp, #-32]
1000fef8:	e283301a 	add	r3, r3, #26
    if (mutex->hold == 0)
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
        {
            rt_thread_control(mutex->owner,
1000fefc:	e1a00002 	mov	r0, r2
1000ff00:	e3a01002 	mov	r1, #2
1000ff04:	e1a02003 	mov	r2, r3
1000ff08:	eb001bac 	bl	10016dc0 <rt_thread_control>
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
        }

        /* wakeup suspended thread */
        if (!rt_list_isempty(&mutex->parent.suspend_thread))
1000ff0c:	e51b3020 	ldr	r3, [fp, #-32]
1000ff10:	e2833010 	add	r3, r3, #16
1000ff14:	e1a00003 	mov	r0, r3
1000ff18:	ebfffc36 	bl	1000eff8 <rt_list_isempty>
1000ff1c:	e1a03000 	mov	r3, r0
1000ff20:	e3530000 	cmp	r3, #0
1000ff24:	1a000017 	bne	1000ff88 <rt_mutex_release+0x1fc>
        {
            /* get suspended thread */
            thread = rt_list_entry(mutex->parent.suspend_thread.next,
1000ff28:	e51b3020 	ldr	r3, [fp, #-32]
1000ff2c:	e5933010 	ldr	r3, [r3, #16]
1000ff30:	e2433010 	sub	r3, r3, #16
1000ff34:	e50b301c 	str	r3, [fp, #-28]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
                                        thread->name));

            /* set new owner and priority */
            mutex->owner             = thread;
1000ff38:	e51b3020 	ldr	r3, [fp, #-32]
1000ff3c:	e51b201c 	ldr	r2, [fp, #-28]
1000ff40:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = thread->current_priority;
1000ff44:	e51b301c 	ldr	r3, [fp, #-28]
1000ff48:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
1000ff4c:	e51b3020 	ldr	r3, [fp, #-32]
1000ff50:	e5c3201a 	strb	r2, [r3, #26]
            mutex->hold ++;
1000ff54:	e51b3020 	ldr	r3, [fp, #-32]
1000ff58:	e5d3301b 	ldrb	r3, [r3, #27]
1000ff5c:	e2833001 	add	r3, r3, #1
1000ff60:	e6ef2073 	uxtb	r2, r3
1000ff64:	e51b3020 	ldr	r3, [fp, #-32]
1000ff68:	e5c3201b 	strb	r2, [r3, #27]

            /* resume thread */
            rt_ipc_list_resume(&(mutex->parent.suspend_thread));
1000ff6c:	e51b3020 	ldr	r3, [fp, #-32]
1000ff70:	e2833010 	add	r3, r3, #16
1000ff74:	e1a00003 	mov	r0, r3
1000ff78:	ebfffc79 	bl	1000f164 <rt_ipc_list_resume>

            need_schedule = RT_TRUE;
1000ff7c:	e3a03001 	mov	r3, #1
1000ff80:	e50b3010 	str	r3, [fp, #-16]
1000ff84:	ea00000b 	b	1000ffb8 <rt_mutex_release+0x22c>
        }
        else
        {
            /* increase value */
            mutex->value ++;
1000ff88:	e51b3020 	ldr	r3, [fp, #-32]
1000ff8c:	e1d331b8 	ldrh	r3, [r3, #24]
1000ff90:	e2833001 	add	r3, r3, #1
1000ff94:	e6ff2073 	uxth	r2, r3
1000ff98:	e51b3020 	ldr	r3, [fp, #-32]
1000ff9c:	e1c321b8 	strh	r2, [r3, #24]

            /* clear owner */
            mutex->owner             = RT_NULL;
1000ffa0:	e51b3020 	ldr	r3, [fp, #-32]
1000ffa4:	e3a02000 	mov	r2, #0
1000ffa8:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = 0xff;
1000ffac:	e51b3020 	ldr	r3, [fp, #-32]
1000ffb0:	e3e02000 	mvn	r2, #0
1000ffb4:	e5c3201a 	strb	r2, [r3, #26]
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
1000ffb8:	e1a00004 	mov	r0, r4
1000ffbc:	eb00259f 	bl	10019640 <rt_hw_interrupt_enable>

    /* perform a schedule */
    if (need_schedule == RT_TRUE)
1000ffc0:	e51b3010 	ldr	r3, [fp, #-16]
1000ffc4:	e3530001 	cmp	r3, #1
1000ffc8:	1a000000 	bne	1000ffd0 <rt_mutex_release+0x244>
        rt_schedule();
1000ffcc:	eb001874 	bl	100161a4 <rt_schedule>

    return RT_EOK;
1000ffd0:	e3a03000 	mov	r3, #0
}
1000ffd4:	e1a00003 	mov	r0, r3
1000ffd8:	e24bd008 	sub	sp, fp, #8
1000ffdc:	e8bd8810 	pop	{r4, fp, pc}

1000ffe0 <rt_mutex_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg)
{
1000ffe0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ffe4:	e28db000 	add	fp, sp, #0
1000ffe8:	e24dd014 	sub	sp, sp, #20
1000ffec:	e50b0008 	str	r0, [fp, #-8]
1000fff0:	e1a03001 	mov	r3, r1
1000fff4:	e50b2010 	str	r2, [fp, #-16]
1000fff8:	e54b3009 	strb	r3, [fp, #-9]
    return -RT_ERROR;
1000fffc:	e3e03000 	mvn	r3, #0
}
10010000:	e1a00003 	mov	r0, r3
10010004:	e24bd000 	sub	sp, fp, #0
10010008:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001000c:	e12fff1e 	bx	lr

10010010 <rt_event_init>:
 * @param flag the flag of event
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
{
10010010:	e92d4800 	push	{fp, lr}
10010014:	e28db004 	add	fp, sp, #4
10010018:	e24dd010 	sub	sp, sp, #16
1001001c:	e50b0008 	str	r0, [fp, #-8]
10010020:	e50b100c 	str	r1, [fp, #-12]
10010024:	e1a03002 	mov	r3, r2
10010028:	e54b300d 	strb	r3, [fp, #-13]
    RT_ASSERT(event != RT_NULL);
1001002c:	e51b3008 	ldr	r3, [fp, #-8]
10010030:	e3530000 	cmp	r3, #0
10010034:	1a000005 	bne	10010050 <rt_event_init+0x40>
10010038:	e30304bc 	movw	r0, #13500	; 0x34bc
1001003c:	e3410003 	movt	r0, #4099	; 0x1003
10010040:	e30315cc 	movw	r1, #13772	; 0x35cc
10010044:	e3411003 	movt	r1, #4099	; 0x1003
10010048:	e300237b 	movw	r2, #891	; 0x37b
1001004c:	eb000f58 	bl	10013db4 <rt_assert_handler>

    /* init object */
    rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
10010050:	e51b3008 	ldr	r3, [fp, #-8]
10010054:	e1a00003 	mov	r0, r3
10010058:	e3a01003 	mov	r1, #3
1001005c:	e51b200c 	ldr	r2, [fp, #-12]
10010060:	eb001653 	bl	100159b4 <rt_object_init>

    /* set parent flag */
    event->parent.parent.flag = flag;
10010064:	e51b3008 	ldr	r3, [fp, #-8]
10010068:	e55b200d 	ldrb	r2, [fp, #-13]
1001006c:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(event->parent));
10010070:	e51b3008 	ldr	r3, [fp, #-8]
10010074:	e1a00003 	mov	r0, r3
10010078:	ebfffbed 	bl	1000f034 <rt_ipc_object_init>

    /* init event */
    event->set = 0;
1001007c:	e51b3008 	ldr	r3, [fp, #-8]
10010080:	e3a02000 	mov	r2, #0
10010084:	e5832018 	str	r2, [r3, #24]

    return RT_EOK;
10010088:	e3a03000 	mov	r3, #0
}
1001008c:	e1a00003 	mov	r0, r3
10010090:	e24bd004 	sub	sp, fp, #4
10010094:	e8bd8800 	pop	{fp, pc}

10010098 <rt_event_detach>:
 * @param event the event object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_event_detach(rt_event_t event)
{
10010098:	e92d4800 	push	{fp, lr}
1001009c:	e28db004 	add	fp, sp, #4
100100a0:	e24dd008 	sub	sp, sp, #8
100100a4:	e50b0008 	str	r0, [fp, #-8]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
100100a8:	e51b3008 	ldr	r3, [fp, #-8]
100100ac:	e3530000 	cmp	r3, #0
100100b0:	1a000005 	bne	100100cc <rt_event_detach+0x34>
100100b4:	e30304bc 	movw	r0, #13500	; 0x34bc
100100b8:	e3410003 	movt	r0, #4099	; 0x1003
100100bc:	e30315dc 	movw	r1, #13788	; 0x35dc
100100c0:	e3411003 	movt	r1, #4099	; 0x1003
100100c4:	e3002397 	movw	r2, #919	; 0x397
100100c8:	eb000f39 	bl	10013db4 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(event->parent.suspend_thread));
100100cc:	e51b3008 	ldr	r3, [fp, #-8]
100100d0:	e2833010 	add	r3, r3, #16
100100d4:	e1a00003 	mov	r0, r3
100100d8:	ebfffc2f 	bl	1000f19c <rt_ipc_list_resume_all>

    /* detach event object */
    rt_object_detach(&(event->parent.parent));
100100dc:	e51b3008 	ldr	r3, [fp, #-8]
100100e0:	e1a00003 	mov	r0, r3
100100e4:	eb001661 	bl	10015a70 <rt_object_detach>

    return RT_EOK;
100100e8:	e3a03000 	mov	r3, #0
}
100100ec:	e1a00003 	mov	r0, r3
100100f0:	e24bd004 	sub	sp, fp, #4
100100f4:	e8bd8800 	pop	{fp, pc}

100100f8 <rt_event_create>:
 * @param flag the flag of event
 *
 * @return the created event, RT_NULL on error happen
 */
rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
{
100100f8:	e92d4800 	push	{fp, lr}
100100fc:	e28db004 	add	fp, sp, #4
10010100:	e24dd010 	sub	sp, sp, #16
10010104:	e50b0010 	str	r0, [fp, #-16]
10010108:	e1a03001 	mov	r3, r1
1001010c:	e54b3011 	strb	r3, [fp, #-17]
    rt_event_t event;

    RT_DEBUG_NOT_IN_INTERRUPT;
10010110:	eb002546 	bl	10019630 <rt_hw_interrupt_disable>
10010114:	e50b0008 	str	r0, [fp, #-8]
10010118:	eb0007f8 	bl	10012100 <rt_interrupt_get_nest>
1001011c:	e1a03000 	mov	r3, r0
10010120:	e3530000 	cmp	r3, #0
10010124:	0a00000a 	beq	10010154 <rt_event_create+0x5c>
10010128:	e3030448 	movw	r0, #13384	; 0x3448
1001012c:	e3410003 	movt	r0, #4099	; 0x1003
10010130:	e30315ec 	movw	r1, #13804	; 0x35ec
10010134:	e3411003 	movt	r1, #4099	; 0x1003
10010138:	eb000e60 	bl	10013ac0 <rt_kprintf>
1001013c:	e303046c 	movw	r0, #13420	; 0x346c
10010140:	e3410003 	movt	r0, #4099	; 0x1003
10010144:	e30315ec 	movw	r1, #13804	; 0x35ec
10010148:	e3411003 	movt	r1, #4099	; 0x1003
1001014c:	e3a02e3b 	mov	r2, #944	; 0x3b0
10010150:	eb000f17 	bl	10013db4 <rt_assert_handler>
10010154:	e51b0008 	ldr	r0, [fp, #-8]
10010158:	eb002538 	bl	10019640 <rt_hw_interrupt_enable>

    /* allocate object */
    event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
1001015c:	e3a00003 	mov	r0, #3
10010160:	e51b1010 	ldr	r1, [fp, #-16]
10010164:	eb001662 	bl	10015af4 <rt_object_allocate>
10010168:	e50b000c 	str	r0, [fp, #-12]
    if (event == RT_NULL)
1001016c:	e51b300c 	ldr	r3, [fp, #-12]
10010170:	e3530000 	cmp	r3, #0
10010174:	1a000001 	bne	10010180 <rt_event_create+0x88>
        return event;
10010178:	e51b300c 	ldr	r3, [fp, #-12]
1001017c:	ea000009 	b	100101a8 <rt_event_create+0xb0>

    /* set parent */
    event->parent.parent.flag = flag;
10010180:	e51b300c 	ldr	r3, [fp, #-12]
10010184:	e55b2011 	ldrb	r2, [fp, #-17]
10010188:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(event->parent));
1001018c:	e51b300c 	ldr	r3, [fp, #-12]
10010190:	e1a00003 	mov	r0, r3
10010194:	ebfffba6 	bl	1000f034 <rt_ipc_object_init>

    /* init event */
    event->set = 0;
10010198:	e51b300c 	ldr	r3, [fp, #-12]
1001019c:	e3a02000 	mov	r2, #0
100101a0:	e5832018 	str	r2, [r3, #24]

    return event;
100101a4:	e51b300c 	ldr	r3, [fp, #-12]
}
100101a8:	e1a00003 	mov	r0, r3
100101ac:	e24bd004 	sub	sp, fp, #4
100101b0:	e8bd8800 	pop	{fp, pc}

100101b4 <rt_event_delete>:
 * @param event the event object
 *
 * @return the error code
 */
rt_err_t rt_event_delete(rt_event_t event)
{
100101b4:	e92d4800 	push	{fp, lr}
100101b8:	e28db004 	add	fp, sp, #4
100101bc:	e24dd010 	sub	sp, sp, #16
100101c0:	e50b0010 	str	r0, [fp, #-16]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
100101c4:	e51b3010 	ldr	r3, [fp, #-16]
100101c8:	e3530000 	cmp	r3, #0
100101cc:	1a000005 	bne	100101e8 <rt_event_delete+0x34>
100101d0:	e30304bc 	movw	r0, #13500	; 0x34bc
100101d4:	e3410003 	movt	r0, #4099	; 0x1003
100101d8:	e30315fc 	movw	r1, #13820	; 0x35fc
100101dc:	e3411003 	movt	r1, #4099	; 0x1003
100101e0:	e30023ce 	movw	r2, #974	; 0x3ce
100101e4:	eb000ef2 	bl	10013db4 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
100101e8:	eb002510 	bl	10019630 <rt_hw_interrupt_disable>
100101ec:	e50b0008 	str	r0, [fp, #-8]
100101f0:	eb0007c2 	bl	10012100 <rt_interrupt_get_nest>
100101f4:	e1a03000 	mov	r3, r0
100101f8:	e3530000 	cmp	r3, #0
100101fc:	0a00000a 	beq	1001022c <rt_event_delete+0x78>
10010200:	e3030448 	movw	r0, #13384	; 0x3448
10010204:	e3410003 	movt	r0, #4099	; 0x1003
10010208:	e30315fc 	movw	r1, #13820	; 0x35fc
1001020c:	e3411003 	movt	r1, #4099	; 0x1003
10010210:	eb000e2a 	bl	10013ac0 <rt_kprintf>
10010214:	e303046c 	movw	r0, #13420	; 0x346c
10010218:	e3410003 	movt	r0, #4099	; 0x1003
1001021c:	e30315fc 	movw	r1, #13820	; 0x35fc
10010220:	e3411003 	movt	r1, #4099	; 0x1003
10010224:	e3a02e3d 	mov	r2, #976	; 0x3d0
10010228:	eb000ee1 	bl	10013db4 <rt_assert_handler>
1001022c:	e51b0008 	ldr	r0, [fp, #-8]
10010230:	eb002502 	bl	10019640 <rt_hw_interrupt_enable>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(event->parent.suspend_thread));
10010234:	e51b3010 	ldr	r3, [fp, #-16]
10010238:	e2833010 	add	r3, r3, #16
1001023c:	e1a00003 	mov	r0, r3
10010240:	ebfffbd5 	bl	1000f19c <rt_ipc_list_resume_all>

    /* delete event object */
    rt_object_delete(&(event->parent.parent));
10010244:	e51b3010 	ldr	r3, [fp, #-16]
10010248:	e1a00003 	mov	r0, r3
1001024c:	eb001675 	bl	10015c28 <rt_object_delete>

    return RT_EOK;
10010250:	e3a03000 	mov	r3, #0
}
10010254:	e1a00003 	mov	r0, r3
10010258:	e24bd004 	sub	sp, fp, #4
1001025c:	e8bd8800 	pop	{fp, pc}

10010260 <rt_event_send>:
 * @param set the event set
 *
 * @return the error code
 */
rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
{
10010260:	e92d4830 	push	{r4, r5, fp, lr}
10010264:	e28db00c 	add	fp, sp, #12
10010268:	e24dd018 	sub	sp, sp, #24
1001026c:	e50b0020 	str	r0, [fp, #-32]
10010270:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_ubase_t level;
    register rt_base_t status;
    rt_bool_t need_schedule;

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
10010274:	e51b3020 	ldr	r3, [fp, #-32]
10010278:	e3530000 	cmp	r3, #0
1001027c:	1a000005 	bne	10010298 <rt_event_send+0x38>
10010280:	e30304bc 	movw	r0, #13500	; 0x34bc
10010284:	e3410003 	movt	r0, #4099	; 0x1003
10010288:	e303160c 	movw	r1, #13836	; 0x360c
1001028c:	e3411003 	movt	r1, #4099	; 0x1003
10010290:	e30023ef 	movw	r2, #1007	; 0x3ef
10010294:	eb000ec6 	bl	10013db4 <rt_assert_handler>
    if (set == 0)
10010298:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1001029c:	e3530000 	cmp	r3, #0
100102a0:	1a000001 	bne	100102ac <rt_event_send+0x4c>
        return -RT_ERROR;
100102a4:	e3e03000 	mvn	r3, #0
100102a8:	ea00006b 	b	1001045c <rt_event_send+0x1fc>

    need_schedule = RT_FALSE;
100102ac:	e3a03000 	mov	r3, #0
100102b0:	e50b3014 	str	r3, [fp, #-20]
    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
100102b4:	e30239ac 	movw	r3, #10668	; 0x29ac
100102b8:	e3413004 	movt	r3, #4100	; 0x1004
100102bc:	e5933000 	ldr	r3, [r3]
100102c0:	e3530000 	cmp	r3, #0
100102c4:	0a000005 	beq	100102e0 <rt_event_send+0x80>
100102c8:	e30239ac 	movw	r3, #10668	; 0x29ac
100102cc:	e3413004 	movt	r3, #4100	; 0x1004
100102d0:	e5933000 	ldr	r3, [r3]
100102d4:	e51b2020 	ldr	r2, [fp, #-32]
100102d8:	e1a00002 	mov	r0, r2
100102dc:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100102e0:	eb0024d2 	bl	10019630 <rt_hw_interrupt_disable>
100102e4:	e1a03000 	mov	r3, r0
100102e8:	e1a05003 	mov	r5, r3

    /* set event */
    event->set |= set;
100102ec:	e51b3020 	ldr	r3, [fp, #-32]
100102f0:	e5932018 	ldr	r2, [r3, #24]
100102f4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100102f8:	e1822003 	orr	r2, r2, r3
100102fc:	e51b3020 	ldr	r3, [fp, #-32]
10010300:	e5832018 	str	r2, [r3, #24]

    if (!rt_list_isempty(&event->parent.suspend_thread))
10010304:	e51b3020 	ldr	r3, [fp, #-32]
10010308:	e2833010 	add	r3, r3, #16
1001030c:	e1a00003 	mov	r0, r3
10010310:	ebfffb38 	bl	1000eff8 <rt_list_isempty>
10010314:	e1a03000 	mov	r3, r0
10010318:	e3530000 	cmp	r3, #0
1001031c:	1a000046 	bne	1001043c <rt_event_send+0x1dc>
    {
        /* search thread list to resume thread */
        n = event->parent.suspend_thread.next;
10010320:	e51b3020 	ldr	r3, [fp, #-32]
10010324:	e5933010 	ldr	r3, [r3, #16]
10010328:	e50b3010 	str	r3, [fp, #-16]
        while (n != &(event->parent.suspend_thread))
1001032c:	ea00003d 	b	10010428 <rt_event_send+0x1c8>
        {
            /* get thread */
            thread = rt_list_entry(n, struct rt_thread, tlist);
10010330:	e51b3010 	ldr	r3, [fp, #-16]
10010334:	e2433010 	sub	r3, r3, #16
10010338:	e50b3018 	str	r3, [fp, #-24]

            status = -RT_ERROR;
1001033c:	e3e04000 	mvn	r4, #0
            if (thread->event_info & RT_EVENT_FLAG_AND)
10010340:	e51b3018 	ldr	r3, [fp, #-24]
10010344:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
10010348:	e2033001 	and	r3, r3, #1
1001034c:	e3530000 	cmp	r3, #0
10010350:	0a00000a 	beq	10010380 <rt_event_send+0x120>
            {
                if ((thread->event_set & event->set) == thread->event_set)
10010354:	e51b3018 	ldr	r3, [fp, #-24]
10010358:	e5932038 	ldr	r2, [r3, #56]	; 0x38
1001035c:	e51b3020 	ldr	r3, [fp, #-32]
10010360:	e5933018 	ldr	r3, [r3, #24]
10010364:	e0022003 	and	r2, r2, r3
10010368:	e51b3018 	ldr	r3, [fp, #-24]
1001036c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10010370:	e1520003 	cmp	r2, r3
10010374:	1a000015 	bne	100103d0 <rt_event_send+0x170>
                {
                    /* received an AND event */
                    status = RT_EOK;
10010378:	e3a04000 	mov	r4, #0
1001037c:	ea000013 	b	100103d0 <rt_event_send+0x170>
                }
            }
            else if (thread->event_info & RT_EVENT_FLAG_OR)
10010380:	e51b3018 	ldr	r3, [fp, #-24]
10010384:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
10010388:	e2033002 	and	r3, r3, #2
1001038c:	e3530000 	cmp	r3, #0
10010390:	0a00000e 	beq	100103d0 <rt_event_send+0x170>
            {
                if (thread->event_set & event->set)
10010394:	e51b3018 	ldr	r3, [fp, #-24]
10010398:	e5932038 	ldr	r2, [r3, #56]	; 0x38
1001039c:	e51b3020 	ldr	r3, [fp, #-32]
100103a0:	e5933018 	ldr	r3, [r3, #24]
100103a4:	e0033002 	and	r3, r3, r2
100103a8:	e3530000 	cmp	r3, #0
100103ac:	0a000007 	beq	100103d0 <rt_event_send+0x170>
                {
                    /* save recieved event set */
                    thread->event_set = thread->event_set & event->set;
100103b0:	e51b3018 	ldr	r3, [fp, #-24]
100103b4:	e5932038 	ldr	r2, [r3, #56]	; 0x38
100103b8:	e51b3020 	ldr	r3, [fp, #-32]
100103bc:	e5933018 	ldr	r3, [r3, #24]
100103c0:	e0022003 	and	r2, r2, r3
100103c4:	e51b3018 	ldr	r3, [fp, #-24]
100103c8:	e5832038 	str	r2, [r3, #56]	; 0x38

                    /* received an OR event */
                    status = RT_EOK;
100103cc:	e3a04000 	mov	r4, #0
                }
            }

            /* move node to the next */
            n = n->next;
100103d0:	e51b3010 	ldr	r3, [fp, #-16]
100103d4:	e5933000 	ldr	r3, [r3]
100103d8:	e50b3010 	str	r3, [fp, #-16]

            /* condition is satisfied, resume thread */
            if (status == RT_EOK)
100103dc:	e3540000 	cmp	r4, #0
100103e0:	1a000010 	bne	10010428 <rt_event_send+0x1c8>
            {
                /* clear event */
                if (thread->event_info & RT_EVENT_FLAG_CLEAR)
100103e4:	e51b3018 	ldr	r3, [fp, #-24]
100103e8:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
100103ec:	e2033004 	and	r3, r3, #4
100103f0:	e3530000 	cmp	r3, #0
100103f4:	0a000007 	beq	10010418 <rt_event_send+0x1b8>
                    event->set &= ~thread->event_set;
100103f8:	e51b3020 	ldr	r3, [fp, #-32]
100103fc:	e5932018 	ldr	r2, [r3, #24]
10010400:	e51b3018 	ldr	r3, [fp, #-24]
10010404:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10010408:	e1e03003 	mvn	r3, r3
1001040c:	e0022003 	and	r2, r2, r3
10010410:	e51b3020 	ldr	r3, [fp, #-32]
10010414:	e5832018 	str	r2, [r3, #24]

                /* resume thread, and thread list breaks out */
                rt_thread_resume(thread);
10010418:	e51b0018 	ldr	r0, [fp, #-24]
1001041c:	eb001ad5 	bl	10016f78 <rt_thread_resume>

                /* need do a scheduling */
                need_schedule = RT_TRUE;
10010420:	e3a03001 	mov	r3, #1
10010424:	e50b3014 	str	r3, [fp, #-20]

    if (!rt_list_isempty(&event->parent.suspend_thread))
    {
        /* search thread list to resume thread */
        n = event->parent.suspend_thread.next;
        while (n != &(event->parent.suspend_thread))
10010428:	e51b3020 	ldr	r3, [fp, #-32]
1001042c:	e2832010 	add	r2, r3, #16
10010430:	e51b3010 	ldr	r3, [fp, #-16]
10010434:	e1520003 	cmp	r2, r3
10010438:	1affffbc 	bne	10010330 <rt_event_send+0xd0>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
1001043c:	e1a03005 	mov	r3, r5
10010440:	e1a00003 	mov	r0, r3
10010444:	eb00247d 	bl	10019640 <rt_hw_interrupt_enable>

    /* do a schedule */
    if (need_schedule == RT_TRUE)
10010448:	e51b3014 	ldr	r3, [fp, #-20]
1001044c:	e3530001 	cmp	r3, #1
10010450:	1a000000 	bne	10010458 <rt_event_send+0x1f8>
        rt_schedule();
10010454:	eb001752 	bl	100161a4 <rt_schedule>

    return RT_EOK;
10010458:	e3a03000 	mov	r3, #0
}
1001045c:	e1a00003 	mov	r0, r3
10010460:	e24bd00c 	sub	sp, fp, #12
10010464:	e8bd8830 	pop	{r4, r5, fp, pc}

10010468 <rt_event_recv>:
rt_err_t rt_event_recv(rt_event_t   event,
                       rt_uint32_t  set,
                       rt_uint8_t   option,
                       rt_int32_t   timeout,
                       rt_uint32_t *recved)
{
10010468:	e92d4830 	push	{r4, r5, fp, lr}
1001046c:	e28db00c 	add	fp, sp, #12
10010470:	e24dd020 	sub	sp, sp, #32
10010474:	e50b0020 	str	r0, [fp, #-32]
10010478:	e50b1024 	str	r1, [fp, #-36]	; 0x24
1001047c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
10010480:	e1a03002 	mov	r3, r2
10010484:	e54b3025 	strb	r3, [fp, #-37]	; 0x25
    struct rt_thread *thread;
    register rt_ubase_t level;
    register rt_base_t status;

    RT_DEBUG_IN_THREAD_CONTEXT;
10010488:	eb002468 	bl	10019630 <rt_hw_interrupt_disable>
1001048c:	e50b0010 	str	r0, [fp, #-16]
10010490:	eb001932 	bl	10016960 <rt_thread_self>
10010494:	e1a03000 	mov	r3, r0
10010498:	e3530000 	cmp	r3, #0
1001049c:	1a00000a 	bne	100104cc <rt_event_recv+0x64>
100104a0:	e3030470 	movw	r0, #13424	; 0x3470
100104a4:	e3410003 	movt	r0, #4099	; 0x1003
100104a8:	e303161c 	movw	r1, #13852	; 0x361c
100104ac:	e3411003 	movt	r1, #4099	; 0x1003
100104b0:	eb000d82 	bl	10013ac0 <rt_kprintf>
100104b4:	e303046c 	movw	r0, #13420	; 0x346c
100104b8:	e3410003 	movt	r0, #4099	; 0x1003
100104bc:	e303161c 	movw	r1, #13852	; 0x361c
100104c0:	e3411003 	movt	r1, #4099	; 0x1003
100104c4:	e300244f 	movw	r2, #1103	; 0x44f
100104c8:	eb000e39 	bl	10013db4 <rt_assert_handler>
100104cc:	eb002457 	bl	10019630 <rt_hw_interrupt_disable>
100104d0:	e50b0014 	str	r0, [fp, #-20]
100104d4:	eb000709 	bl	10012100 <rt_interrupt_get_nest>
100104d8:	e1a03000 	mov	r3, r0
100104dc:	e3530000 	cmp	r3, #0
100104e0:	0a00000a 	beq	10010510 <rt_event_recv+0xa8>
100104e4:	e3030448 	movw	r0, #13384	; 0x3448
100104e8:	e3410003 	movt	r0, #4099	; 0x1003
100104ec:	e303161c 	movw	r1, #13852	; 0x361c
100104f0:	e3411003 	movt	r1, #4099	; 0x1003
100104f4:	eb000d71 	bl	10013ac0 <rt_kprintf>
100104f8:	e303046c 	movw	r0, #13420	; 0x346c
100104fc:	e3410003 	movt	r0, #4099	; 0x1003
10010500:	e303161c 	movw	r1, #13852	; 0x361c
10010504:	e3411003 	movt	r1, #4099	; 0x1003
10010508:	e300244f 	movw	r2, #1103	; 0x44f
1001050c:	eb000e28 	bl	10013db4 <rt_assert_handler>
10010510:	e51b0014 	ldr	r0, [fp, #-20]
10010514:	eb002449 	bl	10019640 <rt_hw_interrupt_enable>
10010518:	e51b0010 	ldr	r0, [fp, #-16]
1001051c:	eb002447 	bl	10019640 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
10010520:	e51b3020 	ldr	r3, [fp, #-32]
10010524:	e3530000 	cmp	r3, #0
10010528:	1a000005 	bne	10010544 <rt_event_recv+0xdc>
1001052c:	e30304bc 	movw	r0, #13500	; 0x34bc
10010530:	e3410003 	movt	r0, #4099	; 0x1003
10010534:	e303161c 	movw	r1, #13852	; 0x361c
10010538:	e3411003 	movt	r1, #4099	; 0x1003
1001053c:	e3002452 	movw	r2, #1106	; 0x452
10010540:	eb000e1b 	bl	10013db4 <rt_assert_handler>
    if (set == 0)
10010544:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10010548:	e3530000 	cmp	r3, #0
1001054c:	1a000001 	bne	10010558 <rt_event_recv+0xf0>
        return -RT_ERROR;
10010550:	e3e03000 	mvn	r3, #0
10010554:	ea00008b 	b	10010788 <rt_event_recv+0x320>

    /* init status */
    status = -RT_ERROR;
10010558:	e3e04000 	mvn	r4, #0
    /* get current thread */
    thread = rt_thread_self();
1001055c:	eb0018ff 	bl	10016960 <rt_thread_self>
10010560:	e50b0018 	str	r0, [fp, #-24]
    /* reset thread error */
    thread->error = RT_EOK;
10010564:	e51b3018 	ldr	r3, [fp, #-24]
10010568:	e3a02000 	mov	r2, #0
1001056c:	e583202c 	str	r2, [r3, #44]	; 0x2c

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
10010570:	e30239b4 	movw	r3, #10676	; 0x29b4
10010574:	e3413004 	movt	r3, #4100	; 0x1004
10010578:	e5933000 	ldr	r3, [r3]
1001057c:	e3530000 	cmp	r3, #0
10010580:	0a000005 	beq	1001059c <rt_event_recv+0x134>
10010584:	e30239b4 	movw	r3, #10676	; 0x29b4
10010588:	e3413004 	movt	r3, #4100	; 0x1004
1001058c:	e5933000 	ldr	r3, [r3]
10010590:	e51b2020 	ldr	r2, [fp, #-32]
10010594:	e1a00002 	mov	r0, r2
10010598:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
1001059c:	eb002423 	bl	10019630 <rt_hw_interrupt_disable>
100105a0:	e1a03000 	mov	r3, r0
100105a4:	e1a05003 	mov	r5, r3

    /* check event set */
    if (option & RT_EVENT_FLAG_AND)
100105a8:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
100105ac:	e2033001 	and	r3, r3, #1
100105b0:	e3530000 	cmp	r3, #0
100105b4:	0a000008 	beq	100105dc <rt_event_recv+0x174>
    {
        if ((event->set & set) == set)
100105b8:	e51b3020 	ldr	r3, [fp, #-32]
100105bc:	e5932018 	ldr	r2, [r3, #24]
100105c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100105c4:	e0022003 	and	r2, r2, r3
100105c8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100105cc:	e1520003 	cmp	r2, r3
100105d0:	1a000013 	bne	10010624 <rt_event_recv+0x1bc>
            status = RT_EOK;
100105d4:	e3a04000 	mov	r4, #0
100105d8:	ea000011 	b	10010624 <rt_event_recv+0x1bc>
    }
    else if (option & RT_EVENT_FLAG_OR)
100105dc:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
100105e0:	e2033002 	and	r3, r3, #2
100105e4:	e3530000 	cmp	r3, #0
100105e8:	0a000007 	beq	1001060c <rt_event_recv+0x1a4>
    {
        if (event->set & set)
100105ec:	e51b3020 	ldr	r3, [fp, #-32]
100105f0:	e5932018 	ldr	r2, [r3, #24]
100105f4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100105f8:	e0033002 	and	r3, r3, r2
100105fc:	e3530000 	cmp	r3, #0
10010600:	0a000007 	beq	10010624 <rt_event_recv+0x1bc>
            status = RT_EOK;
10010604:	e3a04000 	mov	r4, #0
10010608:	ea000005 	b	10010624 <rt_event_recv+0x1bc>
    }
    else
    {
        /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
        RT_ASSERT(0);
1001060c:	e303046c 	movw	r0, #13420	; 0x346c
10010610:	e3410003 	movt	r0, #4099	; 0x1003
10010614:	e303161c 	movw	r1, #13852	; 0x361c
10010618:	e3411003 	movt	r1, #4099	; 0x1003
1001061c:	e3a02e47 	mov	r2, #1136	; 0x470
10010620:	eb000de3 	bl	10013db4 <rt_assert_handler>
    }

    if (status == RT_EOK)
10010624:	e3540000 	cmp	r4, #0
10010628:	1a000011 	bne	10010674 <rt_event_recv+0x20c>
    {
        /* set received event */
        *recved = (event->set & set);
1001062c:	e51b3020 	ldr	r3, [fp, #-32]
10010630:	e5932018 	ldr	r2, [r3, #24]
10010634:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10010638:	e0022003 	and	r2, r2, r3
1001063c:	e59b3004 	ldr	r3, [fp, #4]
10010640:	e5832000 	str	r2, [r3]

        /* received event */
        if (option & RT_EVENT_FLAG_CLEAR)
10010644:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
10010648:	e2033004 	and	r3, r3, #4
1001064c:	e3530000 	cmp	r3, #0
10010650:	0a00003c 	beq	10010748 <rt_event_recv+0x2e0>
            event->set &= ~set;
10010654:	e51b3020 	ldr	r3, [fp, #-32]
10010658:	e5932018 	ldr	r2, [r3, #24]
1001065c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10010660:	e1e03003 	mvn	r3, r3
10010664:	e0022003 	and	r2, r2, r3
10010668:	e51b3020 	ldr	r3, [fp, #-32]
1001066c:	e5832018 	str	r2, [r3, #24]
10010670:	ea000034 	b	10010748 <rt_event_recv+0x2e0>
    }
    else if (timeout == 0)
10010674:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10010678:	e3530000 	cmp	r3, #0
1001067c:	1a000003 	bne	10010690 <rt_event_recv+0x228>
    {
        /* no waiting */
        thread->error = -RT_ETIMEOUT;
10010680:	e51b3018 	ldr	r3, [fp, #-24]
10010684:	e3e02001 	mvn	r2, #1
10010688:	e583202c 	str	r2, [r3, #44]	; 0x2c
1001068c:	ea00002d 	b	10010748 <rt_event_recv+0x2e0>
    }
    else
    {
        /* fill thread event info */
        thread->event_set  = set;
10010690:	e51b3018 	ldr	r3, [fp, #-24]
10010694:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10010698:	e5832038 	str	r2, [r3, #56]	; 0x38
        thread->event_info = option;
1001069c:	e51b3018 	ldr	r3, [fp, #-24]
100106a0:	e55b2025 	ldrb	r2, [fp, #-37]	; 0x25
100106a4:	e5c3203c 	strb	r2, [r3, #60]	; 0x3c

        /* put thread to suspended thread list */
        rt_ipc_list_suspend(&(event->parent.suspend_thread),
100106a8:	e51b3020 	ldr	r3, [fp, #-32]
100106ac:	e2832010 	add	r2, r3, #16
100106b0:	e51b3020 	ldr	r3, [fp, #-32]
100106b4:	e5d33007 	ldrb	r3, [r3, #7]
100106b8:	e1a00002 	mov	r0, r2
100106bc:	e51b1018 	ldr	r1, [fp, #-24]
100106c0:	e1a02003 	mov	r2, r3
100106c4:	ebfffa66 	bl	1000f064 <rt_ipc_list_suspend>
                            thread,
                            event->parent.parent.flag);

        /* if there is a waiting timeout, active thread timer */
        if (timeout > 0)
100106c8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
100106cc:	e3530000 	cmp	r3, #0
100106d0:	da00000a 	ble	10010700 <rt_event_recv+0x298>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
100106d4:	e51b3018 	ldr	r3, [fp, #-24]
100106d8:	e2832048 	add	r2, r3, #72	; 0x48
100106dc:	e24b302c 	sub	r3, fp, #44	; 0x2c
100106e0:	e1a00002 	mov	r0, r2
100106e4:	e3a01000 	mov	r1, #0
100106e8:	e1a02003 	mov	r2, r3
100106ec:	eb001cac 	bl	100179a4 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
100106f0:	e51b3018 	ldr	r3, [fp, #-24]
100106f4:	e2833048 	add	r3, r3, #72	; 0x48
100106f8:	e1a00003 	mov	r0, r3
100106fc:	eb001bb2 	bl	100175cc <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10010700:	e1a03005 	mov	r3, r5
10010704:	e1a00003 	mov	r0, r3
10010708:	eb0023cc 	bl	10019640 <rt_hw_interrupt_enable>

        /* do a schedule */
        rt_schedule();
1001070c:	eb0016a4 	bl	100161a4 <rt_schedule>

        if (thread->error != RT_EOK)
10010710:	e51b3018 	ldr	r3, [fp, #-24]
10010714:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10010718:	e3530000 	cmp	r3, #0
1001071c:	0a000002 	beq	1001072c <rt_event_recv+0x2c4>
        {
            /* return error */
            return thread->error;
10010720:	e51b3018 	ldr	r3, [fp, #-24]
10010724:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10010728:	ea000016 	b	10010788 <rt_event_recv+0x320>
        }

        /* received an event, disable interrupt to protect */
        level = rt_hw_interrupt_disable();
1001072c:	eb0023bf 	bl	10019630 <rt_hw_interrupt_disable>
10010730:	e1a03000 	mov	r3, r0
10010734:	e1a05003 	mov	r5, r3

        /* set received event */
        *recved = thread->event_set;
10010738:	e51b3018 	ldr	r3, [fp, #-24]
1001073c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
10010740:	e59b3004 	ldr	r3, [fp, #4]
10010744:	e5832000 	str	r2, [r3]
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10010748:	e1a03005 	mov	r3, r5
1001074c:	e1a00003 	mov	r0, r3
10010750:	eb0023ba 	bl	10019640 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
10010754:	e30239b0 	movw	r3, #10672	; 0x29b0
10010758:	e3413004 	movt	r3, #4100	; 0x1004
1001075c:	e5933000 	ldr	r3, [r3]
10010760:	e3530000 	cmp	r3, #0
10010764:	0a000005 	beq	10010780 <rt_event_recv+0x318>
10010768:	e30239b0 	movw	r3, #10672	; 0x29b0
1001076c:	e3413004 	movt	r3, #4100	; 0x1004
10010770:	e5933000 	ldr	r3, [r3]
10010774:	e51b2020 	ldr	r2, [fp, #-32]
10010778:	e1a00002 	mov	r0, r2
1001077c:	e12fff33 	blx	r3

    return thread->error;
10010780:	e51b3018 	ldr	r3, [fp, #-24]
10010784:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
}
10010788:	e1a00003 	mov	r0, r3
1001078c:	e24bd00c 	sub	sp, fp, #12
10010790:	e8bd8830 	pop	{r4, r5, fp, pc}

10010794 <rt_event_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg)
{
10010794:	e92d4800 	push	{fp, lr}
10010798:	e28db004 	add	fp, sp, #4
1001079c:	e24dd018 	sub	sp, sp, #24
100107a0:	e50b0010 	str	r0, [fp, #-16]
100107a4:	e1a03001 	mov	r3, r1
100107a8:	e50b2018 	str	r2, [fp, #-24]
100107ac:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    RT_ASSERT(event != RT_NULL);
100107b0:	e51b3010 	ldr	r3, [fp, #-16]
100107b4:	e3530000 	cmp	r3, #0
100107b8:	1a000005 	bne	100107d4 <rt_event_control+0x40>
100107bc:	e30304bc 	movw	r0, #13500	; 0x34bc
100107c0:	e3410003 	movt	r0, #4099	; 0x1003
100107c4:	e303162c 	movw	r1, #13868	; 0x362c
100107c8:	e3411003 	movt	r1, #4099	; 0x1003
100107cc:	e30024be 	movw	r2, #1214	; 0x4be
100107d0:	eb000d77 	bl	10013db4 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
100107d4:	e55b3011 	ldrb	r3, [fp, #-17]
100107d8:	e3530001 	cmp	r3, #1
100107dc:	1a00000f 	bne	10010820 <rt_event_control+0x8c>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
100107e0:	eb002392 	bl	10019630 <rt_hw_interrupt_disable>
100107e4:	e1a03000 	mov	r3, r0
100107e8:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&event->parent.suspend_thread);
100107ec:	e51b3010 	ldr	r3, [fp, #-16]
100107f0:	e2833010 	add	r3, r3, #16
100107f4:	e1a00003 	mov	r0, r3
100107f8:	ebfffa67 	bl	1000f19c <rt_ipc_list_resume_all>

        /* init event set */
        event->set = 0;
100107fc:	e51b3010 	ldr	r3, [fp, #-16]
10010800:	e3a02000 	mov	r2, #0
10010804:	e5832018 	str	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10010808:	e51b3008 	ldr	r3, [fp, #-8]
1001080c:	e1a00003 	mov	r0, r3
10010810:	eb00238a 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
10010814:	eb001662 	bl	100161a4 <rt_schedule>

        return RT_EOK;
10010818:	e3a03000 	mov	r3, #0
1001081c:	ea000000 	b	10010824 <rt_event_control+0x90>
    }

    return -RT_ERROR;
10010820:	e3e03000 	mvn	r3, #0
}
10010824:	e1a00003 	mov	r0, r3
10010828:	e24bd004 	sub	sp, fp, #4
1001082c:	e8bd8800 	pop	{fp, pc}

10010830 <rt_mb_init>:
rt_err_t rt_mb_init(rt_mailbox_t mb,
                    const char  *name,
                    void        *msgpool,
                    rt_size_t    size,
                    rt_uint8_t   flag)
{
10010830:	e92d4800 	push	{fp, lr}
10010834:	e28db004 	add	fp, sp, #4
10010838:	e24dd010 	sub	sp, sp, #16
1001083c:	e50b0008 	str	r0, [fp, #-8]
10010840:	e50b100c 	str	r1, [fp, #-12]
10010844:	e50b2010 	str	r2, [fp, #-16]
10010848:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(mb != RT_NULL);
1001084c:	e51b3008 	ldr	r3, [fp, #-8]
10010850:	e3530000 	cmp	r3, #0
10010854:	1a000005 	bne	10010870 <rt_mb_init+0x40>
10010858:	e30304d0 	movw	r0, #13520	; 0x34d0
1001085c:	e3410003 	movt	r0, #4099	; 0x1003
10010860:	e3031640 	movw	r1, #13888	; 0x3640
10010864:	e3411003 	movt	r1, #4099	; 0x1003
10010868:	e30024eb 	movw	r2, #1259	; 0x4eb
1001086c:	eb000d50 	bl	10013db4 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
10010870:	e51b3008 	ldr	r3, [fp, #-8]
10010874:	e1a00003 	mov	r0, r3
10010878:	e3a01004 	mov	r1, #4
1001087c:	e51b200c 	ldr	r2, [fp, #-12]
10010880:	eb00144b 	bl	100159b4 <rt_object_init>

    /* set parent flag */
    mb->parent.parent.flag = flag;
10010884:	e51b3008 	ldr	r3, [fp, #-8]
10010888:	e5db2004 	ldrb	r2, [fp, #4]
1001088c:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mb->parent));
10010890:	e51b3008 	ldr	r3, [fp, #-8]
10010894:	e1a00003 	mov	r0, r3
10010898:	ebfff9e5 	bl	1000f034 <rt_ipc_object_init>

    /* init mailbox */
    mb->msg_pool   = msgpool;
1001089c:	e51b3008 	ldr	r3, [fp, #-8]
100108a0:	e51b2010 	ldr	r2, [fp, #-16]
100108a4:	e5832018 	str	r2, [r3, #24]
    mb->size       = size;
100108a8:	e51b3014 	ldr	r3, [fp, #-20]
100108ac:	e6ff2073 	uxth	r2, r3
100108b0:	e51b3008 	ldr	r3, [fp, #-8]
100108b4:	e1c321bc 	strh	r2, [r3, #28]
    mb->entry      = 0;
100108b8:	e51b3008 	ldr	r3, [fp, #-8]
100108bc:	e3a02000 	mov	r2, #0
100108c0:	e1c321be 	strh	r2, [r3, #30]
    mb->in_offset  = 0;
100108c4:	e51b3008 	ldr	r3, [fp, #-8]
100108c8:	e3a02000 	mov	r2, #0
100108cc:	e1c322b0 	strh	r2, [r3, #32]
    mb->out_offset = 0;
100108d0:	e51b3008 	ldr	r3, [fp, #-8]
100108d4:	e3a02000 	mov	r2, #0
100108d8:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

    /* init an additional list of sender suspend thread */
    rt_list_init(&(mb->suspend_sender_thread));
100108dc:	e51b3008 	ldr	r3, [fp, #-8]
100108e0:	e2833024 	add	r3, r3, #36	; 0x24
100108e4:	e1a00003 	mov	r0, r3
100108e8:	ebfff99e 	bl	1000ef68 <rt_list_init>

    return RT_EOK;
100108ec:	e3a03000 	mov	r3, #0
}
100108f0:	e1a00003 	mov	r0, r3
100108f4:	e24bd004 	sub	sp, fp, #4
100108f8:	e8bd8800 	pop	{fp, pc}

100108fc <rt_mb_detach>:
 * @param mb the mailbox object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mb_detach(rt_mailbox_t mb)
{
100108fc:	e92d4800 	push	{fp, lr}
10010900:	e28db004 	add	fp, sp, #4
10010904:	e24dd008 	sub	sp, sp, #8
10010908:	e50b0008 	str	r0, [fp, #-8]
    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
1001090c:	e51b3008 	ldr	r3, [fp, #-8]
10010910:	e3530000 	cmp	r3, #0
10010914:	1a000005 	bne	10010930 <rt_mb_detach+0x34>
10010918:	e30304d0 	movw	r0, #13520	; 0x34d0
1001091c:	e3410003 	movt	r0, #4099	; 0x1003
10010920:	e303164c 	movw	r1, #13900	; 0x364c
10010924:	e3411003 	movt	r1, #4099	; 0x1003
10010928:	e300250e 	movw	r2, #1294	; 0x50e
1001092c:	eb000d20 	bl	10013db4 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
10010930:	e51b3008 	ldr	r3, [fp, #-8]
10010934:	e2833010 	add	r3, r3, #16
10010938:	e1a00003 	mov	r0, r3
1001093c:	ebfffa16 	bl	1000f19c <rt_ipc_list_resume_all>
    /* also resume all mailbox private suspended thread */
    rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
10010940:	e51b3008 	ldr	r3, [fp, #-8]
10010944:	e2833024 	add	r3, r3, #36	; 0x24
10010948:	e1a00003 	mov	r0, r3
1001094c:	ebfffa12 	bl	1000f19c <rt_ipc_list_resume_all>

    /* detach mailbox object */
    rt_object_detach(&(mb->parent.parent));
10010950:	e51b3008 	ldr	r3, [fp, #-8]
10010954:	e1a00003 	mov	r0, r3
10010958:	eb001444 	bl	10015a70 <rt_object_detach>

    return RT_EOK;
1001095c:	e3a03000 	mov	r3, #0
}
10010960:	e1a00003 	mov	r0, r3
10010964:	e24bd004 	sub	sp, fp, #4
10010968:	e8bd8800 	pop	{fp, pc}

1001096c <rt_mb_create>:
 * @param flag the flag of mailbox
 *
 * @return the created mailbox, RT_NULL on error happen
 */
rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
{
1001096c:	e92d4800 	push	{fp, lr}
10010970:	e28db004 	add	fp, sp, #4
10010974:	e24dd018 	sub	sp, sp, #24
10010978:	e50b0010 	str	r0, [fp, #-16]
1001097c:	e50b1014 	str	r1, [fp, #-20]
10010980:	e1a03002 	mov	r3, r2
10010984:	e54b3015 	strb	r3, [fp, #-21]
    rt_mailbox_t mb;

    RT_DEBUG_NOT_IN_INTERRUPT;
10010988:	eb002328 	bl	10019630 <rt_hw_interrupt_disable>
1001098c:	e50b0008 	str	r0, [fp, #-8]
10010990:	eb0005da 	bl	10012100 <rt_interrupt_get_nest>
10010994:	e1a03000 	mov	r3, r0
10010998:	e3530000 	cmp	r3, #0
1001099c:	0a00000a 	beq	100109cc <rt_mb_create+0x60>
100109a0:	e3030448 	movw	r0, #13384	; 0x3448
100109a4:	e3410003 	movt	r0, #4099	; 0x1003
100109a8:	e303165c 	movw	r1, #13916	; 0x365c
100109ac:	e3411003 	movt	r1, #4099	; 0x1003
100109b0:	eb000c42 	bl	10013ac0 <rt_kprintf>
100109b4:	e303046c 	movw	r0, #13420	; 0x346c
100109b8:	e3410003 	movt	r0, #4099	; 0x1003
100109bc:	e303165c 	movw	r1, #13916	; 0x365c
100109c0:	e3411003 	movt	r1, #4099	; 0x1003
100109c4:	e300252a 	movw	r2, #1322	; 0x52a
100109c8:	eb000cf9 	bl	10013db4 <rt_assert_handler>
100109cc:	e51b0008 	ldr	r0, [fp, #-8]
100109d0:	eb00231a 	bl	10019640 <rt_hw_interrupt_enable>

    /* allocate object */
    mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
100109d4:	e3a00004 	mov	r0, #4
100109d8:	e51b1010 	ldr	r1, [fp, #-16]
100109dc:	eb001444 	bl	10015af4 <rt_object_allocate>
100109e0:	e50b000c 	str	r0, [fp, #-12]
    if (mb == RT_NULL)
100109e4:	e51b300c 	ldr	r3, [fp, #-12]
100109e8:	e3530000 	cmp	r3, #0
100109ec:	1a000001 	bne	100109f8 <rt_mb_create+0x8c>
        return mb;
100109f0:	e51b300c 	ldr	r3, [fp, #-12]
100109f4:	ea000028 	b	10010a9c <rt_mb_create+0x130>

    /* set parent */
    mb->parent.parent.flag = flag;
100109f8:	e51b300c 	ldr	r3, [fp, #-12]
100109fc:	e55b2015 	ldrb	r2, [fp, #-21]
10010a00:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mb->parent));
10010a04:	e51b300c 	ldr	r3, [fp, #-12]
10010a08:	e1a00003 	mov	r0, r3
10010a0c:	ebfff988 	bl	1000f034 <rt_ipc_object_init>

    /* init mailbox */
    mb->size     = size;
10010a10:	e51b3014 	ldr	r3, [fp, #-20]
10010a14:	e6ff2073 	uxth	r2, r3
10010a18:	e51b300c 	ldr	r3, [fp, #-12]
10010a1c:	e1c321bc 	strh	r2, [r3, #28]
    mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
10010a20:	e51b300c 	ldr	r3, [fp, #-12]
10010a24:	e1d331bc 	ldrh	r3, [r3, #28]
10010a28:	e1a03103 	lsl	r3, r3, #2
10010a2c:	e1a00003 	mov	r0, r3
10010a30:	eb000e17 	bl	10014294 <rt_malloc>
10010a34:	e1a02000 	mov	r2, r0
10010a38:	e51b300c 	ldr	r3, [fp, #-12]
10010a3c:	e5832018 	str	r2, [r3, #24]
    if (mb->msg_pool == RT_NULL)
10010a40:	e51b300c 	ldr	r3, [fp, #-12]
10010a44:	e5933018 	ldr	r3, [r3, #24]
10010a48:	e3530000 	cmp	r3, #0
10010a4c:	1a000004 	bne	10010a64 <rt_mb_create+0xf8>
    {
        /* delete mailbox object */
        rt_object_delete(&(mb->parent.parent));
10010a50:	e51b300c 	ldr	r3, [fp, #-12]
10010a54:	e1a00003 	mov	r0, r3
10010a58:	eb001472 	bl	10015c28 <rt_object_delete>

        return RT_NULL;
10010a5c:	e3a03000 	mov	r3, #0
10010a60:	ea00000d 	b	10010a9c <rt_mb_create+0x130>
    }
    mb->entry      = 0;
10010a64:	e51b300c 	ldr	r3, [fp, #-12]
10010a68:	e3a02000 	mov	r2, #0
10010a6c:	e1c321be 	strh	r2, [r3, #30]
    mb->in_offset  = 0;
10010a70:	e51b300c 	ldr	r3, [fp, #-12]
10010a74:	e3a02000 	mov	r2, #0
10010a78:	e1c322b0 	strh	r2, [r3, #32]
    mb->out_offset = 0;
10010a7c:	e51b300c 	ldr	r3, [fp, #-12]
10010a80:	e3a02000 	mov	r2, #0
10010a84:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

    /* init an additional list of sender suspend thread */
    rt_list_init(&(mb->suspend_sender_thread));
10010a88:	e51b300c 	ldr	r3, [fp, #-12]
10010a8c:	e2833024 	add	r3, r3, #36	; 0x24
10010a90:	e1a00003 	mov	r0, r3
10010a94:	ebfff933 	bl	1000ef68 <rt_list_init>

    return mb;
10010a98:	e51b300c 	ldr	r3, [fp, #-12]
}
10010a9c:	e1a00003 	mov	r0, r3
10010aa0:	e24bd004 	sub	sp, fp, #4
10010aa4:	e8bd8800 	pop	{fp, pc}

10010aa8 <rt_mb_delete>:
 * @param mb the mailbox object
 *
 * @return the error code
 */
rt_err_t rt_mb_delete(rt_mailbox_t mb)
{
10010aa8:	e92d4800 	push	{fp, lr}
10010aac:	e28db004 	add	fp, sp, #4
10010ab0:	e24dd010 	sub	sp, sp, #16
10010ab4:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
10010ab8:	eb0022dc 	bl	10019630 <rt_hw_interrupt_disable>
10010abc:	e50b0008 	str	r0, [fp, #-8]
10010ac0:	eb00058e 	bl	10012100 <rt_interrupt_get_nest>
10010ac4:	e1a03000 	mov	r3, r0
10010ac8:	e3530000 	cmp	r3, #0
10010acc:	0a00000a 	beq	10010afc <rt_mb_delete+0x54>
10010ad0:	e3030448 	movw	r0, #13384	; 0x3448
10010ad4:	e3410003 	movt	r0, #4099	; 0x1003
10010ad8:	e303166c 	movw	r1, #13932	; 0x366c
10010adc:	e3411003 	movt	r1, #4099	; 0x1003
10010ae0:	eb000bf6 	bl	10013ac0 <rt_kprintf>
10010ae4:	e303046c 	movw	r0, #13420	; 0x346c
10010ae8:	e3410003 	movt	r0, #4099	; 0x1003
10010aec:	e303166c 	movw	r1, #13932	; 0x366c
10010af0:	e3411003 	movt	r1, #4099	; 0x1003
10010af4:	e3002555 	movw	r2, #1365	; 0x555
10010af8:	eb000cad 	bl	10013db4 <rt_assert_handler>
10010afc:	e51b0008 	ldr	r0, [fp, #-8]
10010b00:	eb0022ce 	bl	10019640 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
10010b04:	e51b3010 	ldr	r3, [fp, #-16]
10010b08:	e3530000 	cmp	r3, #0
10010b0c:	1a000005 	bne	10010b28 <rt_mb_delete+0x80>
10010b10:	e30304d0 	movw	r0, #13520	; 0x34d0
10010b14:	e3410003 	movt	r0, #4099	; 0x1003
10010b18:	e303166c 	movw	r1, #13932	; 0x366c
10010b1c:	e3411003 	movt	r1, #4099	; 0x1003
10010b20:	e3002558 	movw	r2, #1368	; 0x558
10010b24:	eb000ca2 	bl	10013db4 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
10010b28:	e51b3010 	ldr	r3, [fp, #-16]
10010b2c:	e2833010 	add	r3, r3, #16
10010b30:	e1a00003 	mov	r0, r3
10010b34:	ebfff998 	bl	1000f19c <rt_ipc_list_resume_all>

    /* also resume all mailbox private suspended thread */
    rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
10010b38:	e51b3010 	ldr	r3, [fp, #-16]
10010b3c:	e2833024 	add	r3, r3, #36	; 0x24
10010b40:	e1a00003 	mov	r0, r3
10010b44:	ebfff994 	bl	1000f19c <rt_ipc_list_resume_all>
        rt_module_free(mb->parent.parent.module_id, mb->msg_pool);
    else
#endif

    /* free mailbox pool */
    RT_KERNEL_FREE(mb->msg_pool);
10010b48:	e51b3010 	ldr	r3, [fp, #-16]
10010b4c:	e5933018 	ldr	r3, [r3, #24]
10010b50:	e1a00003 	mov	r0, r3
10010b54:	eb000fe9 	bl	10014b00 <rt_free>

    /* delete mailbox object */
    rt_object_delete(&(mb->parent.parent));
10010b58:	e51b3010 	ldr	r3, [fp, #-16]
10010b5c:	e1a00003 	mov	r0, r3
10010b60:	eb001430 	bl	10015c28 <rt_object_delete>

    return RT_EOK;
10010b64:	e3a03000 	mov	r3, #0
}
10010b68:	e1a00003 	mov	r0, r3
10010b6c:	e24bd004 	sub	sp, fp, #4
10010b70:	e8bd8800 	pop	{fp, pc}

10010b74 <rt_mb_send_wait>:
 * @return the error code
 */
rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
                         rt_uint32_t  value,
                         rt_int32_t   timeout)
{
10010b74:	e92d4810 	push	{r4, fp, lr}
10010b78:	e28db008 	add	fp, sp, #8
10010b7c:	e24dd024 	sub	sp, sp, #36	; 0x24
10010b80:	e50b0020 	str	r0, [fp, #-32]
10010b84:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10010b88:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    struct rt_thread *thread;
    register rt_ubase_t temp;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
10010b8c:	e51b3020 	ldr	r3, [fp, #-32]
10010b90:	e3530000 	cmp	r3, #0
10010b94:	1a000005 	bne	10010bb0 <rt_mb_send_wait+0x3c>
10010b98:	e30304d0 	movw	r0, #13520	; 0x34d0
10010b9c:	e3410003 	movt	r0, #4099	; 0x1003
10010ba0:	e303167c 	movw	r1, #13948	; 0x367c
10010ba4:	e3411003 	movt	r1, #4099	; 0x1003
10010ba8:	e3002585 	movw	r2, #1413	; 0x585
10010bac:	eb000c80 	bl	10013db4 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
10010bb0:	e3a03000 	mov	r3, #0
10010bb4:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
10010bb8:	eb001768 	bl	10016960 <rt_thread_self>
10010bbc:	e50b0014 	str	r0, [fp, #-20]

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
10010bc0:	e30239ac 	movw	r3, #10668	; 0x29ac
10010bc4:	e3413004 	movt	r3, #4100	; 0x1004
10010bc8:	e5933000 	ldr	r3, [r3]
10010bcc:	e3530000 	cmp	r3, #0
10010bd0:	0a000005 	beq	10010bec <rt_mb_send_wait+0x78>
10010bd4:	e30239ac 	movw	r3, #10668	; 0x29ac
10010bd8:	e3413004 	movt	r3, #4100	; 0x1004
10010bdc:	e5933000 	ldr	r3, [r3]
10010be0:	e51b2020 	ldr	r2, [fp, #-32]
10010be4:	e1a00002 	mov	r0, r2
10010be8:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10010bec:	eb00228f 	bl	10019630 <rt_hw_interrupt_disable>
10010bf0:	e1a03000 	mov	r3, r0
10010bf4:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mb->entry == mb->size && timeout == 0)
10010bf8:	e51b3020 	ldr	r3, [fp, #-32]
10010bfc:	e1d321be 	ldrh	r2, [r3, #30]
10010c00:	e51b3020 	ldr	r3, [fp, #-32]
10010c04:	e1d331bc 	ldrh	r3, [r3, #28]
10010c08:	e1520003 	cmp	r2, r3
10010c0c:	1a000007 	bne	10010c30 <rt_mb_send_wait+0xbc>
10010c10:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10010c14:	e3530000 	cmp	r3, #0
10010c18:	1a000004 	bne	10010c30 <rt_mb_send_wait+0xbc>
    {
        rt_hw_interrupt_enable(temp);
10010c1c:	e1a03004 	mov	r3, r4
10010c20:	e1a00003 	mov	r0, r3
10010c24:	eb002285 	bl	10019640 <rt_hw_interrupt_enable>

        return -RT_EFULL;
10010c28:	e3e03002 	mvn	r3, #2
10010c2c:	ea0000a1 	b	10010eb8 <rt_mb_send_wait+0x344>
    }

    /* mailbox is full */
    while (mb->entry == mb->size)
10010c30:	ea000068 	b	10010dd8 <rt_mb_send_wait+0x264>
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
10010c34:	e51b3014 	ldr	r3, [fp, #-20]
10010c38:	e3a02000 	mov	r2, #0
10010c3c:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
10010c40:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10010c44:	e3530000 	cmp	r3, #0
10010c48:	1a000004 	bne	10010c60 <rt_mb_send_wait+0xec>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
10010c4c:	e1a03004 	mov	r3, r4
10010c50:	e1a00003 	mov	r0, r3
10010c54:	eb002279 	bl	10019640 <rt_hw_interrupt_enable>

            return -RT_EFULL;
10010c58:	e3e03002 	mvn	r3, #2
10010c5c:	ea000095 	b	10010eb8 <rt_mb_send_wait+0x344>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
10010c60:	eb002272 	bl	10019630 <rt_hw_interrupt_disable>
10010c64:	e50b0018 	str	r0, [fp, #-24]
10010c68:	eb00173c 	bl	10016960 <rt_thread_self>
10010c6c:	e1a03000 	mov	r3, r0
10010c70:	e3530000 	cmp	r3, #0
10010c74:	1a00000a 	bne	10010ca4 <rt_mb_send_wait+0x130>
10010c78:	e3030470 	movw	r0, #13424	; 0x3470
10010c7c:	e3410003 	movt	r0, #4099	; 0x1003
10010c80:	e303167c 	movw	r1, #13948	; 0x367c
10010c84:	e3411003 	movt	r1, #4099	; 0x1003
10010c88:	eb000b8c 	bl	10013ac0 <rt_kprintf>
10010c8c:	e303046c 	movw	r0, #13420	; 0x346c
10010c90:	e3410003 	movt	r0, #4099	; 0x1003
10010c94:	e303167c 	movw	r1, #13948	; 0x367c
10010c98:	e3411003 	movt	r1, #4099	; 0x1003
10010c9c:	e30025a8 	movw	r2, #1448	; 0x5a8
10010ca0:	eb000c43 	bl	10013db4 <rt_assert_handler>
10010ca4:	eb002261 	bl	10019630 <rt_hw_interrupt_disable>
10010ca8:	e50b001c 	str	r0, [fp, #-28]
10010cac:	eb000513 	bl	10012100 <rt_interrupt_get_nest>
10010cb0:	e1a03000 	mov	r3, r0
10010cb4:	e3530000 	cmp	r3, #0
10010cb8:	0a00000a 	beq	10010ce8 <rt_mb_send_wait+0x174>
10010cbc:	e3030448 	movw	r0, #13384	; 0x3448
10010cc0:	e3410003 	movt	r0, #4099	; 0x1003
10010cc4:	e303167c 	movw	r1, #13948	; 0x367c
10010cc8:	e3411003 	movt	r1, #4099	; 0x1003
10010ccc:	eb000b7b 	bl	10013ac0 <rt_kprintf>
10010cd0:	e303046c 	movw	r0, #13420	; 0x346c
10010cd4:	e3410003 	movt	r0, #4099	; 0x1003
10010cd8:	e303167c 	movw	r1, #13948	; 0x367c
10010cdc:	e3411003 	movt	r1, #4099	; 0x1003
10010ce0:	e30025a8 	movw	r2, #1448	; 0x5a8
10010ce4:	eb000c32 	bl	10013db4 <rt_assert_handler>
10010ce8:	e51b001c 	ldr	r0, [fp, #-28]
10010cec:	eb002253 	bl	10019640 <rt_hw_interrupt_enable>
10010cf0:	e51b0018 	ldr	r0, [fp, #-24]
10010cf4:	eb002251 	bl	10019640 <rt_hw_interrupt_enable>
        /* suspend current thread */
        rt_ipc_list_suspend(&(mb->suspend_sender_thread),
10010cf8:	e51b3020 	ldr	r3, [fp, #-32]
10010cfc:	e2832024 	add	r2, r3, #36	; 0x24
10010d00:	e51b3020 	ldr	r3, [fp, #-32]
10010d04:	e5d33007 	ldrb	r3, [r3, #7]
10010d08:	e1a00002 	mov	r0, r2
10010d0c:	e51b1014 	ldr	r1, [fp, #-20]
10010d10:	e1a02003 	mov	r2, r3
10010d14:	ebfff8d2 	bl	1000f064 <rt_ipc_list_suspend>
                            thread,
                            mb->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
10010d18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10010d1c:	e3530000 	cmp	r3, #0
10010d20:	da00000c 	ble	10010d58 <rt_mb_send_wait+0x1e4>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
10010d24:	ebfff586 	bl	1000e344 <rt_tick_get>
10010d28:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
10010d2c:	e51b3014 	ldr	r3, [fp, #-20]
10010d30:	e2832048 	add	r2, r3, #72	; 0x48
10010d34:	e24b3028 	sub	r3, fp, #40	; 0x28
10010d38:	e1a00002 	mov	r0, r2
10010d3c:	e3a01000 	mov	r1, #0
10010d40:	e1a02003 	mov	r2, r3
10010d44:	eb001b16 	bl	100179a4 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10010d48:	e51b3014 	ldr	r3, [fp, #-20]
10010d4c:	e2833048 	add	r3, r3, #72	; 0x48
10010d50:	e1a00003 	mov	r0, r3
10010d54:	eb001a1c 	bl	100175cc <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10010d58:	e1a03004 	mov	r3, r4
10010d5c:	e1a00003 	mov	r0, r3
10010d60:	eb002236 	bl	10019640 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
10010d64:	eb00150e 	bl	100161a4 <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
10010d68:	e51b3014 	ldr	r3, [fp, #-20]
10010d6c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10010d70:	e3530000 	cmp	r3, #0
10010d74:	0a000002 	beq	10010d84 <rt_mb_send_wait+0x210>
        {
            /* return error */
            return thread->error;
10010d78:	e51b3014 	ldr	r3, [fp, #-20]
10010d7c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10010d80:	ea00004c 	b	10010eb8 <rt_mb_send_wait+0x344>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
10010d84:	eb002229 	bl	10019630 <rt_hw_interrupt_disable>
10010d88:	e1a03000 	mov	r3, r0
10010d8c:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
10010d90:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10010d94:	e3530000 	cmp	r3, #0
10010d98:	da00000e 	ble	10010dd8 <rt_mb_send_wait+0x264>
        {
            tick_delta = rt_tick_get() - tick_delta;
10010d9c:	ebfff568 	bl	1000e344 <rt_tick_get>
10010da0:	e1a02000 	mov	r2, r0
10010da4:	e51b3010 	ldr	r3, [fp, #-16]
10010da8:	e0633002 	rsb	r3, r3, r2
10010dac:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
10010db0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10010db4:	e1a02003 	mov	r2, r3
10010db8:	e51b3010 	ldr	r3, [fp, #-16]
10010dbc:	e0633002 	rsb	r3, r3, r2
10010dc0:	e50b3028 	str	r3, [fp, #-40]	; 0x28
            if (timeout < 0)
10010dc4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10010dc8:	e3530000 	cmp	r3, #0
10010dcc:	aa000001 	bge	10010dd8 <rt_mb_send_wait+0x264>
                timeout = 0;
10010dd0:	e3a03000 	mov	r3, #0
10010dd4:	e50b3028 	str	r3, [fp, #-40]	; 0x28

        return -RT_EFULL;
    }

    /* mailbox is full */
    while (mb->entry == mb->size)
10010dd8:	e51b3020 	ldr	r3, [fp, #-32]
10010ddc:	e1d321be 	ldrh	r2, [r3, #30]
10010de0:	e51b3020 	ldr	r3, [fp, #-32]
10010de4:	e1d331bc 	ldrh	r3, [r3, #28]
10010de8:	e1520003 	cmp	r2, r3
10010dec:	0affff90 	beq	10010c34 <rt_mb_send_wait+0xc0>
                timeout = 0;
        }
    }

    /* set ptr */
    mb->msg_pool[mb->in_offset] = value;
10010df0:	e51b3020 	ldr	r3, [fp, #-32]
10010df4:	e5932018 	ldr	r2, [r3, #24]
10010df8:	e51b3020 	ldr	r3, [fp, #-32]
10010dfc:	e1d332b0 	ldrh	r3, [r3, #32]
10010e00:	e1a03103 	lsl	r3, r3, #2
10010e04:	e0823003 	add	r3, r2, r3
10010e08:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10010e0c:	e5832000 	str	r2, [r3]
    /* increase input offset */
    ++ mb->in_offset;
10010e10:	e51b3020 	ldr	r3, [fp, #-32]
10010e14:	e1d332b0 	ldrh	r3, [r3, #32]
10010e18:	e2833001 	add	r3, r3, #1
10010e1c:	e6ff2073 	uxth	r2, r3
10010e20:	e51b3020 	ldr	r3, [fp, #-32]
10010e24:	e1c322b0 	strh	r2, [r3, #32]
    if (mb->in_offset >= mb->size)
10010e28:	e51b3020 	ldr	r3, [fp, #-32]
10010e2c:	e1d322b0 	ldrh	r2, [r3, #32]
10010e30:	e51b3020 	ldr	r3, [fp, #-32]
10010e34:	e1d331bc 	ldrh	r3, [r3, #28]
10010e38:	e1520003 	cmp	r2, r3
10010e3c:	3a000002 	bcc	10010e4c <rt_mb_send_wait+0x2d8>
        mb->in_offset = 0;
10010e40:	e51b3020 	ldr	r3, [fp, #-32]
10010e44:	e3a02000 	mov	r2, #0
10010e48:	e1c322b0 	strh	r2, [r3, #32]
    /* increase message entry */
    mb->entry ++;
10010e4c:	e51b3020 	ldr	r3, [fp, #-32]
10010e50:	e1d331be 	ldrh	r3, [r3, #30]
10010e54:	e2833001 	add	r3, r3, #1
10010e58:	e6ff2073 	uxth	r2, r3
10010e5c:	e51b3020 	ldr	r3, [fp, #-32]
10010e60:	e1c321be 	strh	r2, [r3, #30]

    /* resume suspended thread */
    if (!rt_list_isempty(&mb->parent.suspend_thread))
10010e64:	e51b3020 	ldr	r3, [fp, #-32]
10010e68:	e2833010 	add	r3, r3, #16
10010e6c:	e1a00003 	mov	r0, r3
10010e70:	ebfff860 	bl	1000eff8 <rt_list_isempty>
10010e74:	e1a03000 	mov	r3, r0
10010e78:	e3530000 	cmp	r3, #0
10010e7c:	1a000009 	bne	10010ea8 <rt_mb_send_wait+0x334>
    {
        rt_ipc_list_resume(&(mb->parent.suspend_thread));
10010e80:	e51b3020 	ldr	r3, [fp, #-32]
10010e84:	e2833010 	add	r3, r3, #16
10010e88:	e1a00003 	mov	r0, r3
10010e8c:	ebfff8b4 	bl	1000f164 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10010e90:	e1a03004 	mov	r3, r4
10010e94:	e1a00003 	mov	r0, r3
10010e98:	eb0021e8 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
10010e9c:	eb0014c0 	bl	100161a4 <rt_schedule>

        return RT_EOK;
10010ea0:	e3a03000 	mov	r3, #0
10010ea4:	ea000003 	b	10010eb8 <rt_mb_send_wait+0x344>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10010ea8:	e1a03004 	mov	r3, r4
10010eac:	e1a00003 	mov	r0, r3
10010eb0:	eb0021e2 	bl	10019640 <rt_hw_interrupt_enable>

    return RT_EOK;
10010eb4:	e3a03000 	mov	r3, #0
}
10010eb8:	e1a00003 	mov	r0, r3
10010ebc:	e24bd008 	sub	sp, fp, #8
10010ec0:	e8bd8810 	pop	{r4, fp, pc}

10010ec4 <rt_mb_send>:
 * @param value the mail
 *
 * @return the error code
 */
rt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value)
{
10010ec4:	e92d4800 	push	{fp, lr}
10010ec8:	e28db004 	add	fp, sp, #4
10010ecc:	e24dd008 	sub	sp, sp, #8
10010ed0:	e50b0008 	str	r0, [fp, #-8]
10010ed4:	e50b100c 	str	r1, [fp, #-12]
    return rt_mb_send_wait(mb, value, 0);
10010ed8:	e51b0008 	ldr	r0, [fp, #-8]
10010edc:	e51b100c 	ldr	r1, [fp, #-12]
10010ee0:	e3a02000 	mov	r2, #0
10010ee4:	ebffff22 	bl	10010b74 <rt_mb_send_wait>
10010ee8:	e1a03000 	mov	r3, r0
}
10010eec:	e1a00003 	mov	r0, r3
10010ef0:	e24bd004 	sub	sp, fp, #4
10010ef4:	e8bd8800 	pop	{fp, pc}

10010ef8 <rt_mb_recv>:
 * @param timeout the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)
{
10010ef8:	e92d4810 	push	{r4, fp, lr}
10010efc:	e28db008 	add	fp, sp, #8
10010f00:	e24dd024 	sub	sp, sp, #36	; 0x24
10010f04:	e50b0020 	str	r0, [fp, #-32]
10010f08:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10010f0c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    struct rt_thread *thread;
    register rt_ubase_t temp;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
10010f10:	e51b3020 	ldr	r3, [fp, #-32]
10010f14:	e3530000 	cmp	r3, #0
10010f18:	1a000005 	bne	10010f34 <rt_mb_recv+0x3c>
10010f1c:	e30304d0 	movw	r0, #13520	; 0x34d0
10010f20:	e3410003 	movt	r0, #4099	; 0x1003
10010f24:	e303168c 	movw	r1, #13964	; 0x368c
10010f28:	e3411003 	movt	r1, #4099	; 0x1003
10010f2c:	e3002616 	movw	r2, #1558	; 0x616
10010f30:	eb000b9f 	bl	10013db4 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
10010f34:	e3a03000 	mov	r3, #0
10010f38:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
10010f3c:	eb001687 	bl	10016960 <rt_thread_self>
10010f40:	e50b0014 	str	r0, [fp, #-20]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
10010f44:	e30239b4 	movw	r3, #10676	; 0x29b4
10010f48:	e3413004 	movt	r3, #4100	; 0x1004
10010f4c:	e5933000 	ldr	r3, [r3]
10010f50:	e3530000 	cmp	r3, #0
10010f54:	0a000005 	beq	10010f70 <rt_mb_recv+0x78>
10010f58:	e30239b4 	movw	r3, #10676	; 0x29b4
10010f5c:	e3413004 	movt	r3, #4100	; 0x1004
10010f60:	e5933000 	ldr	r3, [r3]
10010f64:	e51b2020 	ldr	r2, [fp, #-32]
10010f68:	e1a00002 	mov	r0, r2
10010f6c:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10010f70:	eb0021ae 	bl	10019630 <rt_hw_interrupt_disable>
10010f74:	e1a03000 	mov	r3, r0
10010f78:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mb->entry == 0 && timeout == 0)
10010f7c:	e51b3020 	ldr	r3, [fp, #-32]
10010f80:	e1d331be 	ldrh	r3, [r3, #30]
10010f84:	e3530000 	cmp	r3, #0
10010f88:	1a000007 	bne	10010fac <rt_mb_recv+0xb4>
10010f8c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10010f90:	e3530000 	cmp	r3, #0
10010f94:	1a000004 	bne	10010fac <rt_mb_recv+0xb4>
    {
        rt_hw_interrupt_enable(temp);
10010f98:	e1a03004 	mov	r3, r4
10010f9c:	e1a00003 	mov	r0, r3
10010fa0:	eb0021a6 	bl	10019640 <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
10010fa4:	e3e03001 	mvn	r3, #1
10010fa8:	ea0000b9 	b	10011294 <rt_mb_recv+0x39c>
    }

    /* mailbox is empty */
    while (mb->entry == 0)
10010fac:	ea00006b 	b	10011160 <rt_mb_recv+0x268>
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
10010fb0:	e51b3014 	ldr	r3, [fp, #-20]
10010fb4:	e3a02000 	mov	r2, #0
10010fb8:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
10010fbc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10010fc0:	e3530000 	cmp	r3, #0
10010fc4:	1a000007 	bne	10010fe8 <rt_mb_recv+0xf0>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
10010fc8:	e1a03004 	mov	r3, r4
10010fcc:	e1a00003 	mov	r0, r3
10010fd0:	eb00219a 	bl	10019640 <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
10010fd4:	e51b3014 	ldr	r3, [fp, #-20]
10010fd8:	e3e02001 	mvn	r2, #1
10010fdc:	e583202c 	str	r2, [r3, #44]	; 0x2c

            return -RT_ETIMEOUT;
10010fe0:	e3e03001 	mvn	r3, #1
10010fe4:	ea0000aa 	b	10011294 <rt_mb_recv+0x39c>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
10010fe8:	eb002190 	bl	10019630 <rt_hw_interrupt_disable>
10010fec:	e50b0018 	str	r0, [fp, #-24]
10010ff0:	eb00165a 	bl	10016960 <rt_thread_self>
10010ff4:	e1a03000 	mov	r3, r0
10010ff8:	e3530000 	cmp	r3, #0
10010ffc:	1a00000a 	bne	1001102c <rt_mb_recv+0x134>
10011000:	e3030470 	movw	r0, #13424	; 0x3470
10011004:	e3410003 	movt	r0, #4099	; 0x1003
10011008:	e303168c 	movw	r1, #13964	; 0x368c
1001100c:	e3411003 	movt	r1, #4099	; 0x1003
10011010:	eb000aaa 	bl	10013ac0 <rt_kprintf>
10011014:	e303046c 	movw	r0, #13420	; 0x346c
10011018:	e3410003 	movt	r0, #4099	; 0x1003
1001101c:	e303168c 	movw	r1, #13964	; 0x368c
10011020:	e3411003 	movt	r1, #4099	; 0x1003
10011024:	e300263b 	movw	r2, #1595	; 0x63b
10011028:	eb000b61 	bl	10013db4 <rt_assert_handler>
1001102c:	eb00217f 	bl	10019630 <rt_hw_interrupt_disable>
10011030:	e50b001c 	str	r0, [fp, #-28]
10011034:	eb000431 	bl	10012100 <rt_interrupt_get_nest>
10011038:	e1a03000 	mov	r3, r0
1001103c:	e3530000 	cmp	r3, #0
10011040:	0a00000a 	beq	10011070 <rt_mb_recv+0x178>
10011044:	e3030448 	movw	r0, #13384	; 0x3448
10011048:	e3410003 	movt	r0, #4099	; 0x1003
1001104c:	e303168c 	movw	r1, #13964	; 0x368c
10011050:	e3411003 	movt	r1, #4099	; 0x1003
10011054:	eb000a99 	bl	10013ac0 <rt_kprintf>
10011058:	e303046c 	movw	r0, #13420	; 0x346c
1001105c:	e3410003 	movt	r0, #4099	; 0x1003
10011060:	e303168c 	movw	r1, #13964	; 0x368c
10011064:	e3411003 	movt	r1, #4099	; 0x1003
10011068:	e300263b 	movw	r2, #1595	; 0x63b
1001106c:	eb000b50 	bl	10013db4 <rt_assert_handler>
10011070:	e51b001c 	ldr	r0, [fp, #-28]
10011074:	eb002171 	bl	10019640 <rt_hw_interrupt_enable>
10011078:	e51b0018 	ldr	r0, [fp, #-24]
1001107c:	eb00216f 	bl	10019640 <rt_hw_interrupt_enable>
        /* suspend current thread */
        rt_ipc_list_suspend(&(mb->parent.suspend_thread),
10011080:	e51b3020 	ldr	r3, [fp, #-32]
10011084:	e2832010 	add	r2, r3, #16
10011088:	e51b3020 	ldr	r3, [fp, #-32]
1001108c:	e5d33007 	ldrb	r3, [r3, #7]
10011090:	e1a00002 	mov	r0, r2
10011094:	e51b1014 	ldr	r1, [fp, #-20]
10011098:	e1a02003 	mov	r2, r3
1001109c:	ebfff7f0 	bl	1000f064 <rt_ipc_list_suspend>
                            thread,
                            mb->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
100110a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100110a4:	e3530000 	cmp	r3, #0
100110a8:	da00000c 	ble	100110e0 <rt_mb_recv+0x1e8>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
100110ac:	ebfff4a4 	bl	1000e344 <rt_tick_get>
100110b0:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
100110b4:	e51b3014 	ldr	r3, [fp, #-20]
100110b8:	e2832048 	add	r2, r3, #72	; 0x48
100110bc:	e24b3028 	sub	r3, fp, #40	; 0x28
100110c0:	e1a00002 	mov	r0, r2
100110c4:	e3a01000 	mov	r1, #0
100110c8:	e1a02003 	mov	r2, r3
100110cc:	eb001a34 	bl	100179a4 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
100110d0:	e51b3014 	ldr	r3, [fp, #-20]
100110d4:	e2833048 	add	r3, r3, #72	; 0x48
100110d8:	e1a00003 	mov	r0, r3
100110dc:	eb00193a 	bl	100175cc <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
100110e0:	e1a03004 	mov	r3, r4
100110e4:	e1a00003 	mov	r0, r3
100110e8:	eb002154 	bl	10019640 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
100110ec:	eb00142c 	bl	100161a4 <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
100110f0:	e51b3014 	ldr	r3, [fp, #-20]
100110f4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100110f8:	e3530000 	cmp	r3, #0
100110fc:	0a000002 	beq	1001110c <rt_mb_recv+0x214>
        {
            /* return error */
            return thread->error;
10011100:	e51b3014 	ldr	r3, [fp, #-20]
10011104:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10011108:	ea000061 	b	10011294 <rt_mb_recv+0x39c>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
1001110c:	eb002147 	bl	10019630 <rt_hw_interrupt_disable>
10011110:	e1a03000 	mov	r3, r0
10011114:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
10011118:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001111c:	e3530000 	cmp	r3, #0
10011120:	da00000e 	ble	10011160 <rt_mb_recv+0x268>
        {
            tick_delta = rt_tick_get() - tick_delta;
10011124:	ebfff486 	bl	1000e344 <rt_tick_get>
10011128:	e1a02000 	mov	r2, r0
1001112c:	e51b3010 	ldr	r3, [fp, #-16]
10011130:	e0633002 	rsb	r3, r3, r2
10011134:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
10011138:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001113c:	e1a02003 	mov	r2, r3
10011140:	e51b3010 	ldr	r3, [fp, #-16]
10011144:	e0633002 	rsb	r3, r3, r2
10011148:	e50b3028 	str	r3, [fp, #-40]	; 0x28
            if (timeout < 0)
1001114c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011150:	e3530000 	cmp	r3, #0
10011154:	aa000001 	bge	10011160 <rt_mb_recv+0x268>
                timeout = 0;
10011158:	e3a03000 	mov	r3, #0
1001115c:	e50b3028 	str	r3, [fp, #-40]	; 0x28

        return -RT_ETIMEOUT;
    }

    /* mailbox is empty */
    while (mb->entry == 0)
10011160:	e51b3020 	ldr	r3, [fp, #-32]
10011164:	e1d331be 	ldrh	r3, [r3, #30]
10011168:	e3530000 	cmp	r3, #0
1001116c:	0affff8f 	beq	10010fb0 <rt_mb_recv+0xb8>
                timeout = 0;
        }
    }

    /* fill ptr */
    *value = mb->msg_pool[mb->out_offset];
10011170:	e51b3020 	ldr	r3, [fp, #-32]
10011174:	e5932018 	ldr	r2, [r3, #24]
10011178:	e51b3020 	ldr	r3, [fp, #-32]
1001117c:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
10011180:	e1a03103 	lsl	r3, r3, #2
10011184:	e0823003 	add	r3, r2, r3
10011188:	e5932000 	ldr	r2, [r3]
1001118c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10011190:	e5832000 	str	r2, [r3]

    /* increase output offset */
    ++ mb->out_offset;
10011194:	e51b3020 	ldr	r3, [fp, #-32]
10011198:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
1001119c:	e2833001 	add	r3, r3, #1
100111a0:	e6ff2073 	uxth	r2, r3
100111a4:	e51b3020 	ldr	r3, [fp, #-32]
100111a8:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    if (mb->out_offset >= mb->size)
100111ac:	e51b3020 	ldr	r3, [fp, #-32]
100111b0:	e1d322b2 	ldrh	r2, [r3, #34]	; 0x22
100111b4:	e51b3020 	ldr	r3, [fp, #-32]
100111b8:	e1d331bc 	ldrh	r3, [r3, #28]
100111bc:	e1520003 	cmp	r2, r3
100111c0:	3a000002 	bcc	100111d0 <rt_mb_recv+0x2d8>
        mb->out_offset = 0;
100111c4:	e51b3020 	ldr	r3, [fp, #-32]
100111c8:	e3a02000 	mov	r2, #0
100111cc:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    /* decrease message entry */
    mb->entry --;
100111d0:	e51b3020 	ldr	r3, [fp, #-32]
100111d4:	e1d331be 	ldrh	r3, [r3, #30]
100111d8:	e2433001 	sub	r3, r3, #1
100111dc:	e6ff2073 	uxth	r2, r3
100111e0:	e51b3020 	ldr	r3, [fp, #-32]
100111e4:	e1c321be 	strh	r2, [r3, #30]

    /* resume suspended thread */
    if (!rt_list_isempty(&(mb->suspend_sender_thread)))
100111e8:	e51b3020 	ldr	r3, [fp, #-32]
100111ec:	e2833024 	add	r3, r3, #36	; 0x24
100111f0:	e1a00003 	mov	r0, r3
100111f4:	ebfff77f 	bl	1000eff8 <rt_list_isempty>
100111f8:	e1a03000 	mov	r3, r0
100111fc:	e3530000 	cmp	r3, #0
10011200:	1a000014 	bne	10011258 <rt_mb_recv+0x360>
    {
        rt_ipc_list_resume(&(mb->suspend_sender_thread));
10011204:	e51b3020 	ldr	r3, [fp, #-32]
10011208:	e2833024 	add	r3, r3, #36	; 0x24
1001120c:	e1a00003 	mov	r0, r3
10011210:	ebfff7d3 	bl	1000f164 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10011214:	e1a03004 	mov	r3, r4
10011218:	e1a00003 	mov	r0, r3
1001121c:	eb002107 	bl	10019640 <rt_hw_interrupt_enable>

        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
10011220:	e30239b0 	movw	r3, #10672	; 0x29b0
10011224:	e3413004 	movt	r3, #4100	; 0x1004
10011228:	e5933000 	ldr	r3, [r3]
1001122c:	e3530000 	cmp	r3, #0
10011230:	0a000005 	beq	1001124c <rt_mb_recv+0x354>
10011234:	e30239b0 	movw	r3, #10672	; 0x29b0
10011238:	e3413004 	movt	r3, #4100	; 0x1004
1001123c:	e5933000 	ldr	r3, [r3]
10011240:	e51b2020 	ldr	r2, [fp, #-32]
10011244:	e1a00002 	mov	r0, r2
10011248:	e12fff33 	blx	r3

        rt_schedule();
1001124c:	eb0013d4 	bl	100161a4 <rt_schedule>

        return RT_EOK;
10011250:	e3a03000 	mov	r3, #0
10011254:	ea00000e 	b	10011294 <rt_mb_recv+0x39c>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10011258:	e1a03004 	mov	r3, r4
1001125c:	e1a00003 	mov	r0, r3
10011260:	eb0020f6 	bl	10019640 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
10011264:	e30239b0 	movw	r3, #10672	; 0x29b0
10011268:	e3413004 	movt	r3, #4100	; 0x1004
1001126c:	e5933000 	ldr	r3, [r3]
10011270:	e3530000 	cmp	r3, #0
10011274:	0a000005 	beq	10011290 <rt_mb_recv+0x398>
10011278:	e30239b0 	movw	r3, #10672	; 0x29b0
1001127c:	e3413004 	movt	r3, #4100	; 0x1004
10011280:	e5933000 	ldr	r3, [r3]
10011284:	e51b2020 	ldr	r2, [fp, #-32]
10011288:	e1a00002 	mov	r0, r2
1001128c:	e12fff33 	blx	r3

    return RT_EOK;
10011290:	e3a03000 	mov	r3, #0
}
10011294:	e1a00003 	mov	r0, r3
10011298:	e24bd008 	sub	sp, fp, #8
1001129c:	e8bd8810 	pop	{r4, fp, pc}

100112a0 <rt_mb_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg)
{
100112a0:	e92d4800 	push	{fp, lr}
100112a4:	e28db004 	add	fp, sp, #4
100112a8:	e24dd018 	sub	sp, sp, #24
100112ac:	e50b0010 	str	r0, [fp, #-16]
100112b0:	e1a03001 	mov	r3, r1
100112b4:	e50b2018 	str	r2, [fp, #-24]
100112b8:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    RT_ASSERT(mb != RT_NULL);
100112bc:	e51b3010 	ldr	r3, [fp, #-16]
100112c0:	e3530000 	cmp	r3, #0
100112c4:	1a000005 	bne	100112e0 <rt_mb_control+0x40>
100112c8:	e30304d0 	movw	r0, #13520	; 0x34d0
100112cc:	e3410003 	movt	r0, #4099	; 0x1003
100112d0:	e3031698 	movw	r1, #13976	; 0x3698
100112d4:	e3411003 	movt	r1, #4099	; 0x1003
100112d8:	e3002699 	movw	r2, #1689	; 0x699
100112dc:	eb000ab4 	bl	10013db4 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
100112e0:	e55b3011 	ldrb	r3, [fp, #-17]
100112e4:	e3530001 	cmp	r3, #1
100112e8:	1a000019 	bne	10011354 <rt_mb_control+0xb4>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
100112ec:	eb0020cf 	bl	10019630 <rt_hw_interrupt_disable>
100112f0:	e1a03000 	mov	r3, r0
100112f4:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
100112f8:	e51b3010 	ldr	r3, [fp, #-16]
100112fc:	e2833010 	add	r3, r3, #16
10011300:	e1a00003 	mov	r0, r3
10011304:	ebfff7a4 	bl	1000f19c <rt_ipc_list_resume_all>
        /* also resume all mailbox private suspended thread */
        rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
10011308:	e51b3010 	ldr	r3, [fp, #-16]
1001130c:	e2833024 	add	r3, r3, #36	; 0x24
10011310:	e1a00003 	mov	r0, r3
10011314:	ebfff7a0 	bl	1000f19c <rt_ipc_list_resume_all>

        /* re-init mailbox */
        mb->entry      = 0;
10011318:	e51b3010 	ldr	r3, [fp, #-16]
1001131c:	e3a02000 	mov	r2, #0
10011320:	e1c321be 	strh	r2, [r3, #30]
        mb->in_offset  = 0;
10011324:	e51b3010 	ldr	r3, [fp, #-16]
10011328:	e3a02000 	mov	r2, #0
1001132c:	e1c322b0 	strh	r2, [r3, #32]
        mb->out_offset = 0;
10011330:	e51b3010 	ldr	r3, [fp, #-16]
10011334:	e3a02000 	mov	r2, #0
10011338:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
1001133c:	e51b3008 	ldr	r3, [fp, #-8]
10011340:	e1a00003 	mov	r0, r3
10011344:	eb0020bd 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
10011348:	eb001395 	bl	100161a4 <rt_schedule>

        return RT_EOK;
1001134c:	e3a03000 	mov	r3, #0
10011350:	ea000000 	b	10011358 <rt_mb_control+0xb8>
    }

    return -RT_ERROR;
10011354:	e3e03000 	mvn	r3, #0
}
10011358:	e1a00003 	mov	r0, r3
1001135c:	e24bd004 	sub	sp, fp, #4
10011360:	e8bd8800 	pop	{fp, pc}

10011364 <rt_mq_init>:
                    const char *name,
                    void       *msgpool,
                    rt_size_t   msg_size,
                    rt_size_t   pool_size,
                    rt_uint8_t  flag)
{
10011364:	e92d4810 	push	{r4, fp, lr}
10011368:	e28db008 	add	fp, sp, #8
1001136c:	e24dd01c 	sub	sp, sp, #28
10011370:	e50b0018 	str	r0, [fp, #-24]
10011374:	e50b101c 	str	r1, [fp, #-28]
10011378:	e50b2020 	str	r2, [fp, #-32]
1001137c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    struct rt_mq_message *head;
    register rt_base_t temp;

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
10011380:	e51b3018 	ldr	r3, [fp, #-24]
10011384:	e3530000 	cmp	r3, #0
10011388:	1a000005 	bne	100113a4 <rt_mq_init+0x40>
1001138c:	e30304e0 	movw	r0, #13536	; 0x34e0
10011390:	e3410003 	movt	r0, #4099	; 0x1003
10011394:	e30316a8 	movw	r1, #13992	; 0x36a8
10011398:	e3411003 	movt	r1, #4099	; 0x1003
1001139c:	e30026d5 	movw	r2, #1749	; 0x6d5
100113a0:	eb000a83 	bl	10013db4 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
100113a4:	e51b3018 	ldr	r3, [fp, #-24]
100113a8:	e1a00003 	mov	r0, r3
100113ac:	e3a01005 	mov	r1, #5
100113b0:	e51b201c 	ldr	r2, [fp, #-28]
100113b4:	eb00117e 	bl	100159b4 <rt_object_init>

    /* set parent flag */
    mq->parent.parent.flag = flag;
100113b8:	e51b3018 	ldr	r3, [fp, #-24]
100113bc:	e5db2008 	ldrb	r2, [fp, #8]
100113c0:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
100113c4:	e51b3018 	ldr	r3, [fp, #-24]
100113c8:	e1a00003 	mov	r0, r3
100113cc:	ebfff718 	bl	1000f034 <rt_ipc_object_init>

    /* set messasge pool */
    mq->msg_pool = msgpool;
100113d0:	e51b3018 	ldr	r3, [fp, #-24]
100113d4:	e51b2020 	ldr	r2, [fp, #-32]
100113d8:	e5832018 	str	r2, [r3, #24]

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
100113dc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100113e0:	e6ff3073 	uxth	r3, r3
100113e4:	e2833003 	add	r3, r3, #3
100113e8:	e6ff3073 	uxth	r3, r3
100113ec:	e3c33003 	bic	r3, r3, #3
100113f0:	e6ff2073 	uxth	r2, r3
100113f4:	e51b3018 	ldr	r3, [fp, #-24]
100113f8:	e1c321bc 	strh	r2, [r3, #28]
    mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
100113fc:	e51b3018 	ldr	r3, [fp, #-24]
10011400:	e1d331bc 	ldrh	r3, [r3, #28]
10011404:	e2833004 	add	r3, r3, #4
10011408:	e59b0004 	ldr	r0, [fp, #4]
1001140c:	e1a01003 	mov	r1, r3
10011410:	fa00766a 	blx	1002edc0 <__aeabi_uidiv>
10011414:	e1a03000 	mov	r3, r0
10011418:	e6ff2073 	uxth	r2, r3
1001141c:	e51b3018 	ldr	r3, [fp, #-24]
10011420:	e1c321be 	strh	r2, [r3, #30]

    /* init message list */
    mq->msg_queue_head = RT_NULL;
10011424:	e51b3018 	ldr	r3, [fp, #-24]
10011428:	e3a02000 	mov	r2, #0
1001142c:	e5832024 	str	r2, [r3, #36]	; 0x24
    mq->msg_queue_tail = RT_NULL;
10011430:	e51b3018 	ldr	r3, [fp, #-24]
10011434:	e3a02000 	mov	r2, #0
10011438:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
1001143c:	e51b3018 	ldr	r3, [fp, #-24]
10011440:	e3a02000 	mov	r2, #0
10011444:	e583202c 	str	r2, [r3, #44]	; 0x2c
    for (temp = 0; temp < mq->max_msgs; temp ++)
10011448:	e3a04000 	mov	r4, #0
1001144c:	ea000010 	b	10011494 <rt_mq_init+0x130>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
10011450:	e51b3018 	ldr	r3, [fp, #-24]
10011454:	e5932018 	ldr	r2, [r3, #24]
            temp * (mq->msg_size + sizeof(struct rt_mq_message)));
10011458:	e51b3018 	ldr	r3, [fp, #-24]
1001145c:	e1d331bc 	ldrh	r3, [r3, #28]
10011460:	e2833004 	add	r3, r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
10011464:	e1a01004 	mov	r1, r4
10011468:	e0030391 	mul	r3, r1, r3
1001146c:	e0823003 	add	r3, r2, r3
10011470:	e50b3010 	str	r3, [fp, #-16]
            temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
10011474:	e51b3018 	ldr	r3, [fp, #-24]
10011478:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1001147c:	e51b3010 	ldr	r3, [fp, #-16]
10011480:	e5832000 	str	r2, [r3]
        mq->msg_queue_free = head;
10011484:	e51b3018 	ldr	r3, [fp, #-24]
10011488:	e51b2010 	ldr	r2, [fp, #-16]
1001148c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
10011490:	e2844001 	add	r4, r4, #1
10011494:	e51b3018 	ldr	r3, [fp, #-24]
10011498:	e1d331be 	ldrh	r3, [r3, #30]
1001149c:	e1530004 	cmp	r3, r4
100114a0:	caffffea 	bgt	10011450 <rt_mq_init+0xec>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
100114a4:	e51b3018 	ldr	r3, [fp, #-24]
100114a8:	e3a02000 	mov	r2, #0
100114ac:	e1c322b0 	strh	r2, [r3, #32]

    return RT_EOK;
100114b0:	e3a03000 	mov	r3, #0
}
100114b4:	e1a00003 	mov	r0, r3
100114b8:	e24bd008 	sub	sp, fp, #8
100114bc:	e8bd8810 	pop	{r4, fp, pc}

100114c0 <rt_mq_detach>:
 * @param mq the message queue object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mq_detach(rt_mq_t mq)
{
100114c0:	e92d4800 	push	{fp, lr}
100114c4:	e28db004 	add	fp, sp, #4
100114c8:	e24dd008 	sub	sp, sp, #8
100114cc:	e50b0008 	str	r0, [fp, #-8]
    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
100114d0:	e51b3008 	ldr	r3, [fp, #-8]
100114d4:	e3530000 	cmp	r3, #0
100114d8:	1a000005 	bne	100114f4 <rt_mq_detach+0x34>
100114dc:	e30304e0 	movw	r0, #13536	; 0x34e0
100114e0:	e3410003 	movt	r0, #4099	; 0x1003
100114e4:	e30316b4 	movw	r1, #14004	; 0x36b4
100114e8:	e3411003 	movt	r1, #4099	; 0x1003
100114ec:	e3002706 	movw	r2, #1798	; 0x706
100114f0:	eb000a2f 	bl	10013db4 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&mq->parent.suspend_thread);
100114f4:	e51b3008 	ldr	r3, [fp, #-8]
100114f8:	e2833010 	add	r3, r3, #16
100114fc:	e1a00003 	mov	r0, r3
10011500:	ebfff725 	bl	1000f19c <rt_ipc_list_resume_all>

    /* detach message queue object */
    rt_object_detach(&(mq->parent.parent));
10011504:	e51b3008 	ldr	r3, [fp, #-8]
10011508:	e1a00003 	mov	r0, r3
1001150c:	eb001157 	bl	10015a70 <rt_object_detach>

    return RT_EOK;
10011510:	e3a03000 	mov	r3, #0
}
10011514:	e1a00003 	mov	r0, r3
10011518:	e24bd004 	sub	sp, fp, #4
1001151c:	e8bd8800 	pop	{fp, pc}

10011520 <rt_mq_create>:
 */
rt_mq_t rt_mq_create(const char *name,
                     rt_size_t   msg_size,
                     rt_size_t   max_msgs,
                     rt_uint8_t  flag)
{
10011520:	e92d4810 	push	{r4, fp, lr}
10011524:	e28db008 	add	fp, sp, #8
10011528:	e24dd024 	sub	sp, sp, #36	; 0x24
1001152c:	e50b0020 	str	r0, [fp, #-32]
10011530:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10011534:	e50b2028 	str	r2, [fp, #-40]	; 0x28
10011538:	e54b3029 	strb	r3, [fp, #-41]	; 0x29
    struct rt_messagequeue *mq;
    struct rt_mq_message *head;
    register rt_base_t temp;

    RT_DEBUG_NOT_IN_INTERRUPT;
1001153c:	eb00203b 	bl	10019630 <rt_hw_interrupt_disable>
10011540:	e50b0010 	str	r0, [fp, #-16]
10011544:	eb0002ed 	bl	10012100 <rt_interrupt_get_nest>
10011548:	e1a03000 	mov	r3, r0
1001154c:	e3530000 	cmp	r3, #0
10011550:	0a00000a 	beq	10011580 <rt_mq_create+0x60>
10011554:	e3030448 	movw	r0, #13384	; 0x3448
10011558:	e3410003 	movt	r0, #4099	; 0x1003
1001155c:	e30316c4 	movw	r1, #14020	; 0x36c4
10011560:	e3411003 	movt	r1, #4099	; 0x1003
10011564:	eb000955 	bl	10013ac0 <rt_kprintf>
10011568:	e303046c 	movw	r0, #13420	; 0x346c
1001156c:	e3410003 	movt	r0, #4099	; 0x1003
10011570:	e30316c4 	movw	r1, #14020	; 0x36c4
10011574:	e3411003 	movt	r1, #4099	; 0x1003
10011578:	e3002726 	movw	r2, #1830	; 0x726
1001157c:	eb000a0c 	bl	10013db4 <rt_assert_handler>
10011580:	e51b0010 	ldr	r0, [fp, #-16]
10011584:	eb00202d 	bl	10019640 <rt_hw_interrupt_enable>

    /* allocate object */
    mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
10011588:	e3a00005 	mov	r0, #5
1001158c:	e51b1020 	ldr	r1, [fp, #-32]
10011590:	eb001157 	bl	10015af4 <rt_object_allocate>
10011594:	e50b0014 	str	r0, [fp, #-20]
    if (mq == RT_NULL)
10011598:	e51b3014 	ldr	r3, [fp, #-20]
1001159c:	e3530000 	cmp	r3, #0
100115a0:	1a000001 	bne	100115ac <rt_mq_create+0x8c>
        return mq;
100115a4:	e51b3014 	ldr	r3, [fp, #-20]
100115a8:	ea000048 	b	100116d0 <rt_mq_create+0x1b0>

    /* set parent */
    mq->parent.parent.flag = flag;
100115ac:	e51b3014 	ldr	r3, [fp, #-20]
100115b0:	e55b2029 	ldrb	r2, [fp, #-41]	; 0x29
100115b4:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
100115b8:	e51b3014 	ldr	r3, [fp, #-20]
100115bc:	e1a00003 	mov	r0, r3
100115c0:	ebfff69b 	bl	1000f034 <rt_ipc_object_init>

    /* init message queue */

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
100115c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100115c8:	e6ff3073 	uxth	r3, r3
100115cc:	e2833003 	add	r3, r3, #3
100115d0:	e6ff3073 	uxth	r3, r3
100115d4:	e3c33003 	bic	r3, r3, #3
100115d8:	e6ff2073 	uxth	r2, r3
100115dc:	e51b3014 	ldr	r3, [fp, #-20]
100115e0:	e1c321bc 	strh	r2, [r3, #28]
    mq->max_msgs = max_msgs;
100115e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100115e8:	e6ff2073 	uxth	r2, r3
100115ec:	e51b3014 	ldr	r3, [fp, #-20]
100115f0:	e1c321be 	strh	r2, [r3, #30]

    /* allocate message pool */
    mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
100115f4:	e51b3014 	ldr	r3, [fp, #-20]
100115f8:	e1d331bc 	ldrh	r3, [r3, #28]
100115fc:	e2833004 	add	r3, r3, #4
10011600:	e51b2014 	ldr	r2, [fp, #-20]
10011604:	e1d221be 	ldrh	r2, [r2, #30]
10011608:	e0030392 	mul	r3, r2, r3
1001160c:	e1a00003 	mov	r0, r3
10011610:	eb000b1f 	bl	10014294 <rt_malloc>
10011614:	e1a02000 	mov	r2, r0
10011618:	e51b3014 	ldr	r3, [fp, #-20]
1001161c:	e5832018 	str	r2, [r3, #24]
    if (mq->msg_pool == RT_NULL)
10011620:	e51b3014 	ldr	r3, [fp, #-20]
10011624:	e5933018 	ldr	r3, [r3, #24]
10011628:	e3530000 	cmp	r3, #0
1001162c:	1a000003 	bne	10011640 <rt_mq_create+0x120>
    {
        rt_mq_delete(mq);
10011630:	e51b0014 	ldr	r0, [fp, #-20]
10011634:	eb000028 	bl	100116dc <rt_mq_delete>

        return RT_NULL;
10011638:	e3a03000 	mov	r3, #0
1001163c:	ea000023 	b	100116d0 <rt_mq_create+0x1b0>
    }

    /* init message list */
    mq->msg_queue_head = RT_NULL;
10011640:	e51b3014 	ldr	r3, [fp, #-20]
10011644:	e3a02000 	mov	r2, #0
10011648:	e5832024 	str	r2, [r3, #36]	; 0x24
    mq->msg_queue_tail = RT_NULL;
1001164c:	e51b3014 	ldr	r3, [fp, #-20]
10011650:	e3a02000 	mov	r2, #0
10011654:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
10011658:	e51b3014 	ldr	r3, [fp, #-20]
1001165c:	e3a02000 	mov	r2, #0
10011660:	e583202c 	str	r2, [r3, #44]	; 0x2c
    for (temp = 0; temp < mq->max_msgs; temp ++)
10011664:	e3a04000 	mov	r4, #0
10011668:	ea000010 	b	100116b0 <rt_mq_create+0x190>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
1001166c:	e51b3014 	ldr	r3, [fp, #-20]
10011670:	e5932018 	ldr	r2, [r3, #24]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
10011674:	e51b3014 	ldr	r3, [fp, #-20]
10011678:	e1d331bc 	ldrh	r3, [r3, #28]
1001167c:	e2833004 	add	r3, r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
10011680:	e1a01004 	mov	r1, r4
10011684:	e0030391 	mul	r3, r1, r3
10011688:	e0823003 	add	r3, r2, r3
1001168c:	e50b3018 	str	r3, [fp, #-24]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
10011690:	e51b3014 	ldr	r3, [fp, #-20]
10011694:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
10011698:	e51b3018 	ldr	r3, [fp, #-24]
1001169c:	e5832000 	str	r2, [r3]
        mq->msg_queue_free = head;
100116a0:	e51b3014 	ldr	r3, [fp, #-20]
100116a4:	e51b2018 	ldr	r2, [fp, #-24]
100116a8:	e583202c 	str	r2, [r3, #44]	; 0x2c
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
100116ac:	e2844001 	add	r4, r4, #1
100116b0:	e51b3014 	ldr	r3, [fp, #-20]
100116b4:	e1d331be 	ldrh	r3, [r3, #30]
100116b8:	e1530004 	cmp	r3, r4
100116bc:	caffffea 	bgt	1001166c <rt_mq_create+0x14c>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
100116c0:	e51b3014 	ldr	r3, [fp, #-20]
100116c4:	e3a02000 	mov	r2, #0
100116c8:	e1c322b0 	strh	r2, [r3, #32]

    return mq;
100116cc:	e51b3014 	ldr	r3, [fp, #-20]
}
100116d0:	e1a00003 	mov	r0, r3
100116d4:	e24bd008 	sub	sp, fp, #8
100116d8:	e8bd8810 	pop	{r4, fp, pc}

100116dc <rt_mq_delete>:
 * @param mq the message queue object
 *
 * @return the error code
 */
rt_err_t rt_mq_delete(rt_mq_t mq)
{
100116dc:	e92d4800 	push	{fp, lr}
100116e0:	e28db004 	add	fp, sp, #4
100116e4:	e24dd010 	sub	sp, sp, #16
100116e8:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
100116ec:	eb001fcf 	bl	10019630 <rt_hw_interrupt_disable>
100116f0:	e50b0008 	str	r0, [fp, #-8]
100116f4:	eb000281 	bl	10012100 <rt_interrupt_get_nest>
100116f8:	e1a03000 	mov	r3, r0
100116fc:	e3530000 	cmp	r3, #0
10011700:	0a00000a 	beq	10011730 <rt_mq_delete+0x54>
10011704:	e3030448 	movw	r0, #13384	; 0x3448
10011708:	e3410003 	movt	r0, #4099	; 0x1003
1001170c:	e30316d4 	movw	r1, #14036	; 0x36d4
10011710:	e3411003 	movt	r1, #4099	; 0x1003
10011714:	eb0008e9 	bl	10013ac0 <rt_kprintf>
10011718:	e303046c 	movw	r0, #13420	; 0x346c
1001171c:	e3410003 	movt	r0, #4099	; 0x1003
10011720:	e30316d4 	movw	r1, #14036	; 0x36d4
10011724:	e3411003 	movt	r1, #4099	; 0x1003
10011728:	e3a02e76 	mov	r2, #1888	; 0x760
1001172c:	eb0009a0 	bl	10013db4 <rt_assert_handler>
10011730:	e51b0008 	ldr	r0, [fp, #-8]
10011734:	eb001fc1 	bl	10019640 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
10011738:	e51b3010 	ldr	r3, [fp, #-16]
1001173c:	e3530000 	cmp	r3, #0
10011740:	1a000005 	bne	1001175c <rt_mq_delete+0x80>
10011744:	e30304e0 	movw	r0, #13536	; 0x34e0
10011748:	e3410003 	movt	r0, #4099	; 0x1003
1001174c:	e30316d4 	movw	r1, #14036	; 0x36d4
10011750:	e3411003 	movt	r1, #4099	; 0x1003
10011754:	e3002763 	movw	r2, #1891	; 0x763
10011758:	eb000995 	bl	10013db4 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
1001175c:	e51b3010 	ldr	r3, [fp, #-16]
10011760:	e2833010 	add	r3, r3, #16
10011764:	e1a00003 	mov	r0, r3
10011768:	ebfff68b 	bl	1000f19c <rt_ipc_list_resume_all>
        rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
    else
#endif

    /* free message queue pool */
    RT_KERNEL_FREE(mq->msg_pool);
1001176c:	e51b3010 	ldr	r3, [fp, #-16]
10011770:	e5933018 	ldr	r3, [r3, #24]
10011774:	e1a00003 	mov	r0, r3
10011778:	eb000ce0 	bl	10014b00 <rt_free>

    /* delete message queue object */
    rt_object_delete(&(mq->parent.parent));
1001177c:	e51b3010 	ldr	r3, [fp, #-16]
10011780:	e1a00003 	mov	r0, r3
10011784:	eb001127 	bl	10015c28 <rt_object_delete>

    return RT_EOK;
10011788:	e3a03000 	mov	r3, #0
}
1001178c:	e1a00003 	mov	r0, r3
10011790:	e24bd004 	sub	sp, fp, #4
10011794:	e8bd8800 	pop	{fp, pc}

10011798 <rt_mq_send>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
{
10011798:	e92d4810 	push	{r4, fp, lr}
1001179c:	e28db008 	add	fp, sp, #8
100117a0:	e24dd01c 	sub	sp, sp, #28
100117a4:	e50b0018 	str	r0, [fp, #-24]
100117a8:	e50b101c 	str	r1, [fp, #-28]
100117ac:	e50b2020 	str	r2, [fp, #-32]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
100117b0:	e51b3018 	ldr	r3, [fp, #-24]
100117b4:	e3530000 	cmp	r3, #0
100117b8:	1a000005 	bne	100117d4 <rt_mq_send+0x3c>
100117bc:	e30304e0 	movw	r0, #13536	; 0x34e0
100117c0:	e3410003 	movt	r0, #4099	; 0x1003
100117c4:	e30316e4 	movw	r1, #14052	; 0x36e4
100117c8:	e3411003 	movt	r1, #4099	; 0x1003
100117cc:	e3002789 	movw	r2, #1929	; 0x789
100117d0:	eb000977 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
100117d4:	e51b301c 	ldr	r3, [fp, #-28]
100117d8:	e3530000 	cmp	r3, #0
100117dc:	1a000005 	bne	100117f8 <rt_mq_send+0x60>
100117e0:	e30304f0 	movw	r0, #13552	; 0x34f0
100117e4:	e3410003 	movt	r0, #4099	; 0x1003
100117e8:	e30316e4 	movw	r1, #14052	; 0x36e4
100117ec:	e3411003 	movt	r1, #4099	; 0x1003
100117f0:	e300278a 	movw	r2, #1930	; 0x78a
100117f4:	eb00096e 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(size != 0);
100117f8:	e51b3020 	ldr	r3, [fp, #-32]
100117fc:	e3530000 	cmp	r3, #0
10011800:	1a000005 	bne	1001181c <rt_mq_send+0x84>
10011804:	e3030504 	movw	r0, #13572	; 0x3504
10011808:	e3410003 	movt	r0, #4099	; 0x1003
1001180c:	e30316e4 	movw	r1, #14052	; 0x36e4
10011810:	e3411003 	movt	r1, #4099	; 0x1003
10011814:	e300278b 	movw	r2, #1931	; 0x78b
10011818:	eb000965 	bl	10013db4 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
1001181c:	e51b3018 	ldr	r3, [fp, #-24]
10011820:	e1d331bc 	ldrh	r3, [r3, #28]
10011824:	e1a02003 	mov	r2, r3
10011828:	e51b3020 	ldr	r3, [fp, #-32]
1001182c:	e1520003 	cmp	r2, r3
10011830:	2a000001 	bcs	1001183c <rt_mq_send+0xa4>
        return -RT_ERROR;
10011834:	e3e03000 	mvn	r3, #0
10011838:	ea000058 	b	100119a0 <rt_mq_send+0x208>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
1001183c:	e30239ac 	movw	r3, #10668	; 0x29ac
10011840:	e3413004 	movt	r3, #4100	; 0x1004
10011844:	e5933000 	ldr	r3, [r3]
10011848:	e3530000 	cmp	r3, #0
1001184c:	0a000005 	beq	10011868 <rt_mq_send+0xd0>
10011850:	e30239ac 	movw	r3, #10668	; 0x29ac
10011854:	e3413004 	movt	r3, #4100	; 0x1004
10011858:	e5933000 	ldr	r3, [r3]
1001185c:	e51b2018 	ldr	r2, [fp, #-24]
10011860:	e1a00002 	mov	r0, r2
10011864:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10011868:	eb001f70 	bl	10019630 <rt_hw_interrupt_disable>
1001186c:	e1a03000 	mov	r3, r0
10011870:	e1a04003 	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message*)mq->msg_queue_free;
10011874:	e51b3018 	ldr	r3, [fp, #-24]
10011878:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001187c:	e50b3010 	str	r3, [fp, #-16]
    /* message queue is full */
    if (msg == RT_NULL)
10011880:	e51b3010 	ldr	r3, [fp, #-16]
10011884:	e3530000 	cmp	r3, #0
10011888:	1a000004 	bne	100118a0 <rt_mq_send+0x108>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
1001188c:	e1a03004 	mov	r3, r4
10011890:	e1a00003 	mov	r0, r3
10011894:	eb001f69 	bl	10019640 <rt_hw_interrupt_enable>

        return -RT_EFULL;
10011898:	e3e03002 	mvn	r3, #2
1001189c:	ea00003f 	b	100119a0 <rt_mq_send+0x208>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
100118a0:	e51b3010 	ldr	r3, [fp, #-16]
100118a4:	e5932000 	ldr	r2, [r3]
100118a8:	e51b3018 	ldr	r3, [fp, #-24]
100118ac:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
100118b0:	e1a03004 	mov	r3, r4
100118b4:	e1a00003 	mov	r0, r3
100118b8:	eb001f60 	bl	10019640 <rt_hw_interrupt_enable>

    /* the msg is the new tailer of list, the next shall be NULL */
    msg->next = RT_NULL;
100118bc:	e51b3010 	ldr	r3, [fp, #-16]
100118c0:	e3a02000 	mov	r2, #0
100118c4:	e5832000 	str	r2, [r3]
    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
100118c8:	e51b3010 	ldr	r3, [fp, #-16]
100118cc:	e2833004 	add	r3, r3, #4
100118d0:	e1a00003 	mov	r0, r3
100118d4:	e51b101c 	ldr	r1, [fp, #-28]
100118d8:	e51b2020 	ldr	r2, [fp, #-32]
100118dc:	eb0002b5 	bl	100123b8 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
100118e0:	eb001f52 	bl	10019630 <rt_hw_interrupt_disable>
100118e4:	e1a03000 	mov	r3, r0
100118e8:	e1a04003 	mov	r4, r3
    /* link msg to message queue */
    if (mq->msg_queue_tail != RT_NULL)
100118ec:	e51b3018 	ldr	r3, [fp, #-24]
100118f0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
100118f4:	e3530000 	cmp	r3, #0
100118f8:	0a000003 	beq	1001190c <rt_mq_send+0x174>
    {
        /* if the tail exists, */
        ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
100118fc:	e51b3018 	ldr	r3, [fp, #-24]
10011900:	e5933028 	ldr	r3, [r3, #40]	; 0x28
10011904:	e51b2010 	ldr	r2, [fp, #-16]
10011908:	e5832000 	str	r2, [r3]
    }

    /* set new tail */
    mq->msg_queue_tail = msg;
1001190c:	e51b3018 	ldr	r3, [fp, #-24]
10011910:	e51b2010 	ldr	r2, [fp, #-16]
10011914:	e5832028 	str	r2, [r3, #40]	; 0x28
    /* if the head is empty, set head */
    if (mq->msg_queue_head == RT_NULL)
10011918:	e51b3018 	ldr	r3, [fp, #-24]
1001191c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10011920:	e3530000 	cmp	r3, #0
10011924:	1a000002 	bne	10011934 <rt_mq_send+0x19c>
        mq->msg_queue_head = msg;
10011928:	e51b3018 	ldr	r3, [fp, #-24]
1001192c:	e51b2010 	ldr	r2, [fp, #-16]
10011930:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* increase message entry */
    mq->entry ++;
10011934:	e51b3018 	ldr	r3, [fp, #-24]
10011938:	e1d332b0 	ldrh	r3, [r3, #32]
1001193c:	e2833001 	add	r3, r3, #1
10011940:	e6ff2073 	uxth	r2, r3
10011944:	e51b3018 	ldr	r3, [fp, #-24]
10011948:	e1c322b0 	strh	r2, [r3, #32]

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
1001194c:	e51b3018 	ldr	r3, [fp, #-24]
10011950:	e2833010 	add	r3, r3, #16
10011954:	e1a00003 	mov	r0, r3
10011958:	ebfff5a6 	bl	1000eff8 <rt_list_isempty>
1001195c:	e1a03000 	mov	r3, r0
10011960:	e3530000 	cmp	r3, #0
10011964:	1a000009 	bne	10011990 <rt_mq_send+0x1f8>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
10011968:	e51b3018 	ldr	r3, [fp, #-24]
1001196c:	e2833010 	add	r3, r3, #16
10011970:	e1a00003 	mov	r0, r3
10011974:	ebfff5fa 	bl	1000f164 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10011978:	e1a03004 	mov	r3, r4
1001197c:	e1a00003 	mov	r0, r3
10011980:	eb001f2e 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
10011984:	eb001206 	bl	100161a4 <rt_schedule>

        return RT_EOK;
10011988:	e3a03000 	mov	r3, #0
1001198c:	ea000003 	b	100119a0 <rt_mq_send+0x208>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10011990:	e1a03004 	mov	r3, r4
10011994:	e1a00003 	mov	r0, r3
10011998:	eb001f28 	bl	10019640 <rt_hw_interrupt_enable>

    return RT_EOK;
1001199c:	e3a03000 	mov	r3, #0
}
100119a0:	e1a00003 	mov	r0, r3
100119a4:	e24bd008 	sub	sp, fp, #8
100119a8:	e8bd8810 	pop	{r4, fp, pc}

100119ac <rt_mq_urgent>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size)
{
100119ac:	e92d4810 	push	{r4, fp, lr}
100119b0:	e28db008 	add	fp, sp, #8
100119b4:	e24dd01c 	sub	sp, sp, #28
100119b8:	e50b0018 	str	r0, [fp, #-24]
100119bc:	e50b101c 	str	r1, [fp, #-28]
100119c0:	e50b2020 	str	r2, [fp, #-32]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
100119c4:	e51b3018 	ldr	r3, [fp, #-24]
100119c8:	e3530000 	cmp	r3, #0
100119cc:	1a000005 	bne	100119e8 <rt_mq_urgent+0x3c>
100119d0:	e30304e0 	movw	r0, #13536	; 0x34e0
100119d4:	e3410003 	movt	r0, #4099	; 0x1003
100119d8:	e30316f0 	movw	r1, #14064	; 0x36f0
100119dc:	e3411003 	movt	r1, #4099	; 0x1003
100119e0:	e30027e1 	movw	r2, #2017	; 0x7e1
100119e4:	eb0008f2 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
100119e8:	e51b301c 	ldr	r3, [fp, #-28]
100119ec:	e3530000 	cmp	r3, #0
100119f0:	1a000005 	bne	10011a0c <rt_mq_urgent+0x60>
100119f4:	e30304f0 	movw	r0, #13552	; 0x34f0
100119f8:	e3410003 	movt	r0, #4099	; 0x1003
100119fc:	e30316f0 	movw	r1, #14064	; 0x36f0
10011a00:	e3411003 	movt	r1, #4099	; 0x1003
10011a04:	e30027e2 	movw	r2, #2018	; 0x7e2
10011a08:	eb0008e9 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(size != 0);
10011a0c:	e51b3020 	ldr	r3, [fp, #-32]
10011a10:	e3530000 	cmp	r3, #0
10011a14:	1a000005 	bne	10011a30 <rt_mq_urgent+0x84>
10011a18:	e3030504 	movw	r0, #13572	; 0x3504
10011a1c:	e3410003 	movt	r0, #4099	; 0x1003
10011a20:	e30316f0 	movw	r1, #14064	; 0x36f0
10011a24:	e3411003 	movt	r1, #4099	; 0x1003
10011a28:	e30027e3 	movw	r2, #2019	; 0x7e3
10011a2c:	eb0008e0 	bl	10013db4 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
10011a30:	e51b3018 	ldr	r3, [fp, #-24]
10011a34:	e1d331bc 	ldrh	r3, [r3, #28]
10011a38:	e1a02003 	mov	r2, r3
10011a3c:	e51b3020 	ldr	r3, [fp, #-32]
10011a40:	e1520003 	cmp	r2, r3
10011a44:	2a000001 	bcs	10011a50 <rt_mq_urgent+0xa4>
        return -RT_ERROR;
10011a48:	e3e03000 	mvn	r3, #0
10011a4c:	ea000051 	b	10011b98 <rt_mq_urgent+0x1ec>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
10011a50:	e30239ac 	movw	r3, #10668	; 0x29ac
10011a54:	e3413004 	movt	r3, #4100	; 0x1004
10011a58:	e5933000 	ldr	r3, [r3]
10011a5c:	e3530000 	cmp	r3, #0
10011a60:	0a000005 	beq	10011a7c <rt_mq_urgent+0xd0>
10011a64:	e30239ac 	movw	r3, #10668	; 0x29ac
10011a68:	e3413004 	movt	r3, #4100	; 0x1004
10011a6c:	e5933000 	ldr	r3, [r3]
10011a70:	e51b2018 	ldr	r2, [fp, #-24]
10011a74:	e1a00002 	mov	r0, r2
10011a78:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10011a7c:	eb001eeb 	bl	10019630 <rt_hw_interrupt_disable>
10011a80:	e1a03000 	mov	r3, r0
10011a84:	e1a04003 	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message *)mq->msg_queue_free;
10011a88:	e51b3018 	ldr	r3, [fp, #-24]
10011a8c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10011a90:	e50b3010 	str	r3, [fp, #-16]
    /* message queue is full */
    if (msg == RT_NULL)
10011a94:	e51b3010 	ldr	r3, [fp, #-16]
10011a98:	e3530000 	cmp	r3, #0
10011a9c:	1a000004 	bne	10011ab4 <rt_mq_urgent+0x108>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10011aa0:	e1a03004 	mov	r3, r4
10011aa4:	e1a00003 	mov	r0, r3
10011aa8:	eb001ee4 	bl	10019640 <rt_hw_interrupt_enable>

        return -RT_EFULL;
10011aac:	e3e03002 	mvn	r3, #2
10011ab0:	ea000038 	b	10011b98 <rt_mq_urgent+0x1ec>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
10011ab4:	e51b3010 	ldr	r3, [fp, #-16]
10011ab8:	e5932000 	ldr	r2, [r3]
10011abc:	e51b3018 	ldr	r3, [fp, #-24]
10011ac0:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10011ac4:	e1a03004 	mov	r3, r4
10011ac8:	e1a00003 	mov	r0, r3
10011acc:	eb001edb 	bl	10019640 <rt_hw_interrupt_enable>

    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
10011ad0:	e51b3010 	ldr	r3, [fp, #-16]
10011ad4:	e2833004 	add	r3, r3, #4
10011ad8:	e1a00003 	mov	r0, r3
10011adc:	e51b101c 	ldr	r1, [fp, #-28]
10011ae0:	e51b2020 	ldr	r2, [fp, #-32]
10011ae4:	eb000233 	bl	100123b8 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10011ae8:	eb001ed0 	bl	10019630 <rt_hw_interrupt_disable>
10011aec:	e1a03000 	mov	r3, r0
10011af0:	e1a04003 	mov	r4, r3

    /* link msg to the beginning of message queue */
    msg->next = mq->msg_queue_head;
10011af4:	e51b3018 	ldr	r3, [fp, #-24]
10011af8:	e5932024 	ldr	r2, [r3, #36]	; 0x24
10011afc:	e51b3010 	ldr	r3, [fp, #-16]
10011b00:	e5832000 	str	r2, [r3]
    mq->msg_queue_head = msg;
10011b04:	e51b3018 	ldr	r3, [fp, #-24]
10011b08:	e51b2010 	ldr	r2, [fp, #-16]
10011b0c:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* if there is no tail */
    if (mq->msg_queue_tail == RT_NULL)
10011b10:	e51b3018 	ldr	r3, [fp, #-24]
10011b14:	e5933028 	ldr	r3, [r3, #40]	; 0x28
10011b18:	e3530000 	cmp	r3, #0
10011b1c:	1a000002 	bne	10011b2c <rt_mq_urgent+0x180>
        mq->msg_queue_tail = msg;
10011b20:	e51b3018 	ldr	r3, [fp, #-24]
10011b24:	e51b2010 	ldr	r2, [fp, #-16]
10011b28:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* increase message entry */
    mq->entry ++;
10011b2c:	e51b3018 	ldr	r3, [fp, #-24]
10011b30:	e1d332b0 	ldrh	r3, [r3, #32]
10011b34:	e2833001 	add	r3, r3, #1
10011b38:	e6ff2073 	uxth	r2, r3
10011b3c:	e51b3018 	ldr	r3, [fp, #-24]
10011b40:	e1c322b0 	strh	r2, [r3, #32]

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
10011b44:	e51b3018 	ldr	r3, [fp, #-24]
10011b48:	e2833010 	add	r3, r3, #16
10011b4c:	e1a00003 	mov	r0, r3
10011b50:	ebfff528 	bl	1000eff8 <rt_list_isempty>
10011b54:	e1a03000 	mov	r3, r0
10011b58:	e3530000 	cmp	r3, #0
10011b5c:	1a000009 	bne	10011b88 <rt_mq_urgent+0x1dc>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
10011b60:	e51b3018 	ldr	r3, [fp, #-24]
10011b64:	e2833010 	add	r3, r3, #16
10011b68:	e1a00003 	mov	r0, r3
10011b6c:	ebfff57c 	bl	1000f164 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10011b70:	e1a03004 	mov	r3, r4
10011b74:	e1a00003 	mov	r0, r3
10011b78:	eb001eb0 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
10011b7c:	eb001188 	bl	100161a4 <rt_schedule>

        return RT_EOK;
10011b80:	e3a03000 	mov	r3, #0
10011b84:	ea000003 	b	10011b98 <rt_mq_urgent+0x1ec>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10011b88:	e1a03004 	mov	r3, r4
10011b8c:	e1a00003 	mov	r0, r3
10011b90:	eb001eaa 	bl	10019640 <rt_hw_interrupt_enable>

    return RT_EOK;
10011b94:	e3a03000 	mov	r3, #0
}
10011b98:	e1a00003 	mov	r0, r3
10011b9c:	e24bd008 	sub	sp, fp, #8
10011ba0:	e8bd8810 	pop	{r4, fp, pc}

10011ba4 <rt_mq_recv>:
 */
rt_err_t rt_mq_recv(rt_mq_t    mq,
                    void      *buffer,
                    rt_size_t  size,
                    rt_int32_t timeout)
{
10011ba4:	e92d4810 	push	{r4, fp, lr}
10011ba8:	e28db008 	add	fp, sp, #8
10011bac:	e24dd02c 	sub	sp, sp, #44	; 0x2c
10011bb0:	e50b0028 	str	r0, [fp, #-40]	; 0x28
10011bb4:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
10011bb8:	e50b2030 	str	r2, [fp, #-48]	; 0x30
10011bbc:	e50b3034 	str	r3, [fp, #-52]	; 0x34
    struct rt_thread *thread;
    register rt_ubase_t temp;
    struct rt_mq_message *msg;
    rt_uint32_t tick_delta;

    RT_ASSERT(mq != RT_NULL);
10011bc0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011bc4:	e3530000 	cmp	r3, #0
10011bc8:	1a000005 	bne	10011be4 <rt_mq_recv+0x40>
10011bcc:	e30304e0 	movw	r0, #13536	; 0x34e0
10011bd0:	e3410003 	movt	r0, #4099	; 0x1003
10011bd4:	e3031700 	movw	r1, #14080	; 0x3700
10011bd8:	e3411003 	movt	r1, #4099	; 0x1003
10011bdc:	e3002839 	movw	r2, #2105	; 0x839
10011be0:	eb000873 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
10011be4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10011be8:	e3530000 	cmp	r3, #0
10011bec:	1a000005 	bne	10011c08 <rt_mq_recv+0x64>
10011bf0:	e30304f0 	movw	r0, #13552	; 0x34f0
10011bf4:	e3410003 	movt	r0, #4099	; 0x1003
10011bf8:	e3031700 	movw	r1, #14080	; 0x3700
10011bfc:	e3411003 	movt	r1, #4099	; 0x1003
10011c00:	e300283a 	movw	r2, #2106	; 0x83a
10011c04:	eb00086a 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(size != 0);
10011c08:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10011c0c:	e3530000 	cmp	r3, #0
10011c10:	1a000005 	bne	10011c2c <rt_mq_recv+0x88>
10011c14:	e3030504 	movw	r0, #13572	; 0x3504
10011c18:	e3410003 	movt	r0, #4099	; 0x1003
10011c1c:	e3031700 	movw	r1, #14080	; 0x3700
10011c20:	e3411003 	movt	r1, #4099	; 0x1003
10011c24:	e300283b 	movw	r2, #2107	; 0x83b
10011c28:	eb000861 	bl	10013db4 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
10011c2c:	e3a03000 	mov	r3, #0
10011c30:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
10011c34:	eb001349 	bl	10016960 <rt_thread_self>
10011c38:	e50b0014 	str	r0, [fp, #-20]
    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
10011c3c:	e30239b4 	movw	r3, #10676	; 0x29b4
10011c40:	e3413004 	movt	r3, #4100	; 0x1004
10011c44:	e5933000 	ldr	r3, [r3]
10011c48:	e3530000 	cmp	r3, #0
10011c4c:	0a000005 	beq	10011c68 <rt_mq_recv+0xc4>
10011c50:	e30239b4 	movw	r3, #10676	; 0x29b4
10011c54:	e3413004 	movt	r3, #4100	; 0x1004
10011c58:	e5933000 	ldr	r3, [r3]
10011c5c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10011c60:	e1a00002 	mov	r0, r2
10011c64:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10011c68:	eb001e70 	bl	10019630 <rt_hw_interrupt_disable>
10011c6c:	e1a03000 	mov	r3, r0
10011c70:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mq->entry == 0 && timeout == 0)
10011c74:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011c78:	e1d332b0 	ldrh	r3, [r3, #32]
10011c7c:	e3530000 	cmp	r3, #0
10011c80:	1a000007 	bne	10011ca4 <rt_mq_recv+0x100>
10011c84:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10011c88:	e3530000 	cmp	r3, #0
10011c8c:	1a000004 	bne	10011ca4 <rt_mq_recv+0x100>
    {
        rt_hw_interrupt_enable(temp);
10011c90:	e1a03004 	mov	r3, r4
10011c94:	e1a00003 	mov	r0, r3
10011c98:	eb001e68 	bl	10019640 <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
10011c9c:	e3e03001 	mvn	r3, #1
10011ca0:	ea0000ad 	b	10011f5c <rt_mq_recv+0x3b8>
    }

    /* message queue is empty */
    while (mq->entry == 0)
10011ca4:	ea00006b 	b	10011e58 <rt_mq_recv+0x2b4>
    {
        RT_DEBUG_IN_THREAD_CONTEXT;
10011ca8:	eb001e60 	bl	10019630 <rt_hw_interrupt_disable>
10011cac:	e50b0018 	str	r0, [fp, #-24]
10011cb0:	eb00132a 	bl	10016960 <rt_thread_self>
10011cb4:	e1a03000 	mov	r3, r0
10011cb8:	e3530000 	cmp	r3, #0
10011cbc:	1a00000a 	bne	10011cec <rt_mq_recv+0x148>
10011cc0:	e3030470 	movw	r0, #13424	; 0x3470
10011cc4:	e3410003 	movt	r0, #4099	; 0x1003
10011cc8:	e3031700 	movw	r1, #14080	; 0x3700
10011ccc:	e3411003 	movt	r1, #4099	; 0x1003
10011cd0:	eb00077a 	bl	10013ac0 <rt_kprintf>
10011cd4:	e303046c 	movw	r0, #13420	; 0x346c
10011cd8:	e3410003 	movt	r0, #4099	; 0x1003
10011cdc:	e3031700 	movw	r1, #14080	; 0x3700
10011ce0:	e3411003 	movt	r1, #4099	; 0x1003
10011ce4:	e3002851 	movw	r2, #2129	; 0x851
10011ce8:	eb000831 	bl	10013db4 <rt_assert_handler>
10011cec:	eb001e4f 	bl	10019630 <rt_hw_interrupt_disable>
10011cf0:	e50b001c 	str	r0, [fp, #-28]
10011cf4:	eb000101 	bl	10012100 <rt_interrupt_get_nest>
10011cf8:	e1a03000 	mov	r3, r0
10011cfc:	e3530000 	cmp	r3, #0
10011d00:	0a00000a 	beq	10011d30 <rt_mq_recv+0x18c>
10011d04:	e3030448 	movw	r0, #13384	; 0x3448
10011d08:	e3410003 	movt	r0, #4099	; 0x1003
10011d0c:	e3031700 	movw	r1, #14080	; 0x3700
10011d10:	e3411003 	movt	r1, #4099	; 0x1003
10011d14:	eb000769 	bl	10013ac0 <rt_kprintf>
10011d18:	e303046c 	movw	r0, #13420	; 0x346c
10011d1c:	e3410003 	movt	r0, #4099	; 0x1003
10011d20:	e3031700 	movw	r1, #14080	; 0x3700
10011d24:	e3411003 	movt	r1, #4099	; 0x1003
10011d28:	e3002851 	movw	r2, #2129	; 0x851
10011d2c:	eb000820 	bl	10013db4 <rt_assert_handler>
10011d30:	e51b001c 	ldr	r0, [fp, #-28]
10011d34:	eb001e41 	bl	10019640 <rt_hw_interrupt_enable>
10011d38:	e51b0018 	ldr	r0, [fp, #-24]
10011d3c:	eb001e3f 	bl	10019640 <rt_hw_interrupt_enable>

        /* reset error number in thread */
        thread->error = RT_EOK;
10011d40:	e51b3014 	ldr	r3, [fp, #-20]
10011d44:	e3a02000 	mov	r2, #0
10011d48:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
10011d4c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10011d50:	e3530000 	cmp	r3, #0
10011d54:	1a000007 	bne	10011d78 <rt_mq_recv+0x1d4>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
10011d58:	e1a03004 	mov	r3, r4
10011d5c:	e1a00003 	mov	r0, r3
10011d60:	eb001e36 	bl	10019640 <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
10011d64:	e51b3014 	ldr	r3, [fp, #-20]
10011d68:	e3e02001 	mvn	r2, #1
10011d6c:	e583202c 	str	r2, [r3, #44]	; 0x2c

            return -RT_ETIMEOUT;
10011d70:	e3e03001 	mvn	r3, #1
10011d74:	ea000078 	b	10011f5c <rt_mq_recv+0x3b8>
        }

        /* suspend current thread */
        rt_ipc_list_suspend(&(mq->parent.suspend_thread),
10011d78:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011d7c:	e2832010 	add	r2, r3, #16
10011d80:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011d84:	e5d33007 	ldrb	r3, [r3, #7]
10011d88:	e1a00002 	mov	r0, r2
10011d8c:	e51b1014 	ldr	r1, [fp, #-20]
10011d90:	e1a02003 	mov	r2, r3
10011d94:	ebfff4b2 	bl	1000f064 <rt_ipc_list_suspend>
                            thread,
                            mq->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
10011d98:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10011d9c:	e3530000 	cmp	r3, #0
10011da0:	da00000c 	ble	10011dd8 <rt_mq_recv+0x234>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
10011da4:	ebfff166 	bl	1000e344 <rt_tick_get>
10011da8:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
10011dac:	e51b3014 	ldr	r3, [fp, #-20]
10011db0:	e2832048 	add	r2, r3, #72	; 0x48
10011db4:	e24b3034 	sub	r3, fp, #52	; 0x34
10011db8:	e1a00002 	mov	r0, r2
10011dbc:	e3a01000 	mov	r1, #0
10011dc0:	e1a02003 	mov	r2, r3
10011dc4:	eb0016f6 	bl	100179a4 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10011dc8:	e51b3014 	ldr	r3, [fp, #-20]
10011dcc:	e2833048 	add	r3, r3, #72	; 0x48
10011dd0:	e1a00003 	mov	r0, r3
10011dd4:	eb0015fc 	bl	100175cc <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10011dd8:	e1a03004 	mov	r3, r4
10011ddc:	e1a00003 	mov	r0, r3
10011de0:	eb001e16 	bl	10019640 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
10011de4:	eb0010ee 	bl	100161a4 <rt_schedule>

        /* recv message */
        if (thread->error != RT_EOK)
10011de8:	e51b3014 	ldr	r3, [fp, #-20]
10011dec:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10011df0:	e3530000 	cmp	r3, #0
10011df4:	0a000002 	beq	10011e04 <rt_mq_recv+0x260>
        {
            /* return error */
            return thread->error;
10011df8:	e51b3014 	ldr	r3, [fp, #-20]
10011dfc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10011e00:	ea000055 	b	10011f5c <rt_mq_recv+0x3b8>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
10011e04:	eb001e09 	bl	10019630 <rt_hw_interrupt_disable>
10011e08:	e1a03000 	mov	r3, r0
10011e0c:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
10011e10:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10011e14:	e3530000 	cmp	r3, #0
10011e18:	da00000e 	ble	10011e58 <rt_mq_recv+0x2b4>
        {
            tick_delta = rt_tick_get() - tick_delta;
10011e1c:	ebfff148 	bl	1000e344 <rt_tick_get>
10011e20:	e1a02000 	mov	r2, r0
10011e24:	e51b3010 	ldr	r3, [fp, #-16]
10011e28:	e0633002 	rsb	r3, r3, r2
10011e2c:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
10011e30:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10011e34:	e1a02003 	mov	r2, r3
10011e38:	e51b3010 	ldr	r3, [fp, #-16]
10011e3c:	e0633002 	rsb	r3, r3, r2
10011e40:	e50b3034 	str	r3, [fp, #-52]	; 0x34
            if (timeout < 0)
10011e44:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10011e48:	e3530000 	cmp	r3, #0
10011e4c:	aa000001 	bge	10011e58 <rt_mq_recv+0x2b4>
                timeout = 0;
10011e50:	e3a03000 	mov	r3, #0
10011e54:	e50b3034 	str	r3, [fp, #-52]	; 0x34

        return -RT_ETIMEOUT;
    }

    /* message queue is empty */
    while (mq->entry == 0)
10011e58:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011e5c:	e1d332b0 	ldrh	r3, [r3, #32]
10011e60:	e3530000 	cmp	r3, #0
10011e64:	0affff8f 	beq	10011ca8 <rt_mq_recv+0x104>
                timeout = 0;
        }
    }

    /* get message from queue */
    msg = (struct rt_mq_message *)mq->msg_queue_head;
10011e68:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011e6c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10011e70:	e50b3020 	str	r3, [fp, #-32]
	
    /* move message queue head */
    mq->msg_queue_head = msg->next;
10011e74:	e51b3020 	ldr	r3, [fp, #-32]
10011e78:	e5932000 	ldr	r2, [r3]
10011e7c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011e80:	e5832024 	str	r2, [r3, #36]	; 0x24
    /* reach queue tail, set to NULL */
    if (mq->msg_queue_tail == msg)
10011e84:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011e88:	e5932028 	ldr	r2, [r3, #40]	; 0x28
10011e8c:	e51b3020 	ldr	r3, [fp, #-32]
10011e90:	e1520003 	cmp	r2, r3
10011e94:	1a000002 	bne	10011ea4 <rt_mq_recv+0x300>
        mq->msg_queue_tail = RT_NULL;
10011e98:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011e9c:	e3a02000 	mov	r2, #0
10011ea0:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* decrease message entry */
    mq->entry --;
10011ea4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011ea8:	e1d332b0 	ldrh	r3, [r3, #32]
10011eac:	e2433001 	sub	r3, r3, #1
10011eb0:	e6ff2073 	uxth	r2, r3
10011eb4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011eb8:	e1c322b0 	strh	r2, [r3, #32]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10011ebc:	e1a03004 	mov	r3, r4
10011ec0:	e1a00003 	mov	r0, r3
10011ec4:	eb001ddd 	bl	10019640 <rt_hw_interrupt_enable>

    /* copy message */
    rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
10011ec8:	e51b3020 	ldr	r3, [fp, #-32]
10011ecc:	e2831004 	add	r1, r3, #4
10011ed0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011ed4:	e1d331bc 	ldrh	r3, [r3, #28]
10011ed8:	e1a02003 	mov	r2, r3
10011edc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10011ee0:	e1520003 	cmp	r2, r3
10011ee4:	31a03002 	movcc	r3, r2
10011ee8:	21a03003 	movcs	r3, r3
10011eec:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
10011ef0:	e1a02003 	mov	r2, r3
10011ef4:	eb00012f 	bl	100123b8 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10011ef8:	eb001dcc 	bl	10019630 <rt_hw_interrupt_disable>
10011efc:	e1a03000 	mov	r3, r0
10011f00:	e1a04003 	mov	r4, r3
    /* put message to free list */
    msg->next = (struct rt_mq_message *)mq->msg_queue_free;
10011f04:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011f08:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
10011f0c:	e51b3020 	ldr	r3, [fp, #-32]
10011f10:	e5832000 	str	r2, [r3]
    mq->msg_queue_free = msg;
10011f14:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10011f18:	e51b2020 	ldr	r2, [fp, #-32]
10011f1c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10011f20:	e1a03004 	mov	r3, r4
10011f24:	e1a00003 	mov	r0, r3
10011f28:	eb001dc4 	bl	10019640 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
10011f2c:	e30239b0 	movw	r3, #10672	; 0x29b0
10011f30:	e3413004 	movt	r3, #4100	; 0x1004
10011f34:	e5933000 	ldr	r3, [r3]
10011f38:	e3530000 	cmp	r3, #0
10011f3c:	0a000005 	beq	10011f58 <rt_mq_recv+0x3b4>
10011f40:	e30239b0 	movw	r3, #10672	; 0x29b0
10011f44:	e3413004 	movt	r3, #4100	; 0x1004
10011f48:	e5933000 	ldr	r3, [r3]
10011f4c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10011f50:	e1a00002 	mov	r0, r2
10011f54:	e12fff33 	blx	r3

    return RT_EOK;
10011f58:	e3a03000 	mov	r3, #0
}
10011f5c:	e1a00003 	mov	r0, r3
10011f60:	e24bd008 	sub	sp, fp, #8
10011f64:	e8bd8810 	pop	{r4, fp, pc}

10011f68 <rt_mq_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg)
{
10011f68:	e92d4800 	push	{fp, lr}
10011f6c:	e28db004 	add	fp, sp, #4
10011f70:	e24dd018 	sub	sp, sp, #24
10011f74:	e50b0010 	str	r0, [fp, #-16]
10011f78:	e1a03001 	mov	r3, r1
10011f7c:	e50b2018 	str	r2, [fp, #-24]
10011f80:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
10011f84:	e51b3010 	ldr	r3, [fp, #-16]
10011f88:	e3530000 	cmp	r3, #0
10011f8c:	1a000005 	bne	10011fa8 <rt_mq_control+0x40>
10011f90:	e30304e0 	movw	r0, #13536	; 0x34e0
10011f94:	e3410003 	movt	r0, #4099	; 0x1003
10011f98:	e303170c 	movw	r1, #14092	; 0x370c
10011f9c:	e3411003 	movt	r1, #4099	; 0x1003
10011fa0:	e30028bf 	movw	r2, #2239	; 0x8bf
10011fa4:	eb000782 	bl	10013db4 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
10011fa8:	e55b3011 	ldrb	r3, [fp, #-17]
10011fac:	e3530001 	cmp	r3, #1
10011fb0:	1a00002a 	bne	10012060 <rt_mq_control+0xf8>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
10011fb4:	eb001d9d 	bl	10019630 <rt_hw_interrupt_disable>
10011fb8:	e1a03000 	mov	r3, r0
10011fbc:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&mq->parent.suspend_thread);
10011fc0:	e51b3010 	ldr	r3, [fp, #-16]
10011fc4:	e2833010 	add	r3, r3, #16
10011fc8:	e1a00003 	mov	r0, r3
10011fcc:	ebfff472 	bl	1000f19c <rt_ipc_list_resume_all>

        /* release all message in the queue */
        while (mq->msg_queue_head != RT_NULL)
10011fd0:	ea000015 	b	1001202c <rt_mq_control+0xc4>
        {
            /* get message from queue */
            msg = (struct rt_mq_message *)mq->msg_queue_head;
10011fd4:	e51b3010 	ldr	r3, [fp, #-16]
10011fd8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10011fdc:	e50b300c 	str	r3, [fp, #-12]

            /* move message queue head */
            mq->msg_queue_head = msg->next;
10011fe0:	e51b300c 	ldr	r3, [fp, #-12]
10011fe4:	e5932000 	ldr	r2, [r3]
10011fe8:	e51b3010 	ldr	r3, [fp, #-16]
10011fec:	e5832024 	str	r2, [r3, #36]	; 0x24
            /* reach queue tail, set to NULL */
            if (mq->msg_queue_tail == msg)
10011ff0:	e51b3010 	ldr	r3, [fp, #-16]
10011ff4:	e5932028 	ldr	r2, [r3, #40]	; 0x28
10011ff8:	e51b300c 	ldr	r3, [fp, #-12]
10011ffc:	e1520003 	cmp	r2, r3
10012000:	1a000002 	bne	10012010 <rt_mq_control+0xa8>
                mq->msg_queue_tail = RT_NULL;
10012004:	e51b3010 	ldr	r3, [fp, #-16]
10012008:	e3a02000 	mov	r2, #0
1001200c:	e5832028 	str	r2, [r3, #40]	; 0x28

            /* put message to free list */
            msg->next = (struct rt_mq_message *)mq->msg_queue_free;
10012010:	e51b3010 	ldr	r3, [fp, #-16]
10012014:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
10012018:	e51b300c 	ldr	r3, [fp, #-12]
1001201c:	e5832000 	str	r2, [r3]
            mq->msg_queue_free = msg;
10012020:	e51b3010 	ldr	r3, [fp, #-16]
10012024:	e51b200c 	ldr	r2, [fp, #-12]
10012028:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&mq->parent.suspend_thread);

        /* release all message in the queue */
        while (mq->msg_queue_head != RT_NULL)
1001202c:	e51b3010 	ldr	r3, [fp, #-16]
10012030:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10012034:	e3530000 	cmp	r3, #0
10012038:	1affffe5 	bne	10011fd4 <rt_mq_control+0x6c>
            msg->next = (struct rt_mq_message *)mq->msg_queue_free;
            mq->msg_queue_free = msg;
        }

        /* clean entry */
        mq->entry = 0;
1001203c:	e51b3010 	ldr	r3, [fp, #-16]
10012040:	e3a02000 	mov	r2, #0
10012044:	e1c322b0 	strh	r2, [r3, #32]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10012048:	e51b3008 	ldr	r3, [fp, #-8]
1001204c:	e1a00003 	mov	r0, r3
10012050:	eb001d7a 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
10012054:	eb001052 	bl	100161a4 <rt_schedule>

        return RT_EOK;
10012058:	e3a03000 	mov	r3, #0
1001205c:	ea000000 	b	10012064 <rt_mq_control+0xfc>
    }

    return -RT_ERROR;
10012060:	e3e03000 	mvn	r3, #0
}
10012064:	e1a00003 	mov	r0, r3
10012068:	e24bd004 	sub	sp, fp, #4
1001206c:	e8bd8800 	pop	{fp, pc}

10012070 <rt_interrupt_enter>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_leave
 */
void rt_interrupt_enter(void)
{
10012070:	e92d4800 	push	{fp, lr}
10012074:	e28db004 	add	fp, sp, #4
10012078:	e24dd008 	sub	sp, sp, #8
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq coming..., irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
1001207c:	eb001d6b 	bl	10019630 <rt_hw_interrupt_disable>
10012080:	e50b0008 	str	r0, [fp, #-8]
    rt_interrupt_nest ++;
10012084:	e30239a4 	movw	r3, #10660	; 0x29a4
10012088:	e3413004 	movt	r3, #4100	; 0x1004
1001208c:	e5d33000 	ldrb	r3, [r3]
10012090:	e6ef3073 	uxtb	r3, r3
10012094:	e2833001 	add	r3, r3, #1
10012098:	e6ef2073 	uxtb	r2, r3
1001209c:	e30239a4 	movw	r3, #10660	; 0x29a4
100120a0:	e3413004 	movt	r3, #4100	; 0x1004
100120a4:	e5c32000 	strb	r2, [r3]
    rt_hw_interrupt_enable(level);
100120a8:	e51b0008 	ldr	r0, [fp, #-8]
100120ac:	eb001d63 	bl	10019640 <rt_hw_interrupt_enable>
}
100120b0:	e24bd004 	sub	sp, fp, #4
100120b4:	e8bd8800 	pop	{fp, pc}

100120b8 <rt_interrupt_leave>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_enter
 */
void rt_interrupt_leave(void)
{
100120b8:	e92d4800 	push	{fp, lr}
100120bc:	e28db004 	add	fp, sp, #4
100120c0:	e24dd008 	sub	sp, sp, #8
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq leave, irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
100120c4:	eb001d59 	bl	10019630 <rt_hw_interrupt_disable>
100120c8:	e50b0008 	str	r0, [fp, #-8]
    rt_interrupt_nest --;
100120cc:	e30239a4 	movw	r3, #10660	; 0x29a4
100120d0:	e3413004 	movt	r3, #4100	; 0x1004
100120d4:	e5d33000 	ldrb	r3, [r3]
100120d8:	e6ef3073 	uxtb	r3, r3
100120dc:	e2433001 	sub	r3, r3, #1
100120e0:	e6ef2073 	uxtb	r2, r3
100120e4:	e30239a4 	movw	r3, #10660	; 0x29a4
100120e8:	e3413004 	movt	r3, #4100	; 0x1004
100120ec:	e5c32000 	strb	r2, [r3]
    rt_hw_interrupt_enable(level);
100120f0:	e51b0008 	ldr	r0, [fp, #-8]
100120f4:	eb001d51 	bl	10019640 <rt_hw_interrupt_enable>
}
100120f8:	e24bd004 	sub	sp, fp, #4
100120fc:	e8bd8800 	pop	{fp, pc}

10012100 <rt_interrupt_get_nest>:
 * context is interrupt context.
 *
 * @return the number of nested interrupts.
 */
rt_uint8_t rt_interrupt_get_nest(void)
{
10012100:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012104:	e28db000 	add	fp, sp, #0
    return rt_interrupt_nest;
10012108:	e30239a4 	movw	r3, #10660	; 0x29a4
1001210c:	e3413004 	movt	r3, #4100	; 0x1004
10012110:	e5d33000 	ldrb	r3, [r3]
10012114:	e6ef3073 	uxtb	r3, r3
}
10012118:	e1a00003 	mov	r0, r3
1001211c:	e24bd000 	sub	sp, fp, #0
10012120:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012124:	e12fff1e 	bx	lr

10012128 <rt_get_errno>:
 * This function will get errno
 *
 * @return errno
 */
rt_err_t rt_get_errno(void)
{
10012128:	e92d4800 	push	{fp, lr}
1001212c:	e28db004 	add	fp, sp, #4
10012130:	e24dd008 	sub	sp, sp, #8
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
10012134:	ebfffff1 	bl	10012100 <rt_interrupt_get_nest>
10012138:	e1a03000 	mov	r3, r0
1001213c:	e3530000 	cmp	r3, #0
10012140:	0a000003 	beq	10012154 <rt_get_errno+0x2c>
    {
        /* it's in interrupt context */
        return _errno;
10012144:	e30c336c 	movw	r3, #50028	; 0xc36c
10012148:	e3413003 	movt	r3, #4099	; 0x1003
1001214c:	e5933000 	ldr	r3, [r3]
10012150:	ea00000a 	b	10012180 <rt_get_errno+0x58>
    }

    tid = rt_thread_self();
10012154:	eb001201 	bl	10016960 <rt_thread_self>
10012158:	e50b0008 	str	r0, [fp, #-8]
    if (tid == RT_NULL)
1001215c:	e51b3008 	ldr	r3, [fp, #-8]
10012160:	e3530000 	cmp	r3, #0
10012164:	1a000003 	bne	10012178 <rt_get_errno+0x50>
        return _errno;
10012168:	e30c336c 	movw	r3, #50028	; 0xc36c
1001216c:	e3413003 	movt	r3, #4099	; 0x1003
10012170:	e5933000 	ldr	r3, [r3]
10012174:	ea000001 	b	10012180 <rt_get_errno+0x58>

    return tid->error;
10012178:	e51b3008 	ldr	r3, [fp, #-8]
1001217c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
}
10012180:	e1a00003 	mov	r0, r3
10012184:	e24bd004 	sub	sp, fp, #4
10012188:	e8bd8800 	pop	{fp, pc}

1001218c <rt_set_errno>:
 * This function will set errno
 *
 * @param error the errno shall be set
 */
void rt_set_errno(rt_err_t error)
{
1001218c:	e92d4800 	push	{fp, lr}
10012190:	e28db004 	add	fp, sp, #4
10012194:	e24dd010 	sub	sp, sp, #16
10012198:	e50b0010 	str	r0, [fp, #-16]
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
1001219c:	ebffffd7 	bl	10012100 <rt_interrupt_get_nest>
100121a0:	e1a03000 	mov	r3, r0
100121a4:	e3530000 	cmp	r3, #0
100121a8:	0a000004 	beq	100121c0 <rt_set_errno+0x34>
    {
        /* it's in interrupt context */
        _errno = error;
100121ac:	e30c336c 	movw	r3, #50028	; 0xc36c
100121b0:	e3413003 	movt	r3, #4099	; 0x1003
100121b4:	e51b2010 	ldr	r2, [fp, #-16]
100121b8:	e5832000 	str	r2, [r3]

        return;
100121bc:	ea00000c 	b	100121f4 <rt_set_errno+0x68>
    }

    tid = rt_thread_self();
100121c0:	eb0011e6 	bl	10016960 <rt_thread_self>
100121c4:	e50b0008 	str	r0, [fp, #-8]
    if (tid == RT_NULL)
100121c8:	e51b3008 	ldr	r3, [fp, #-8]
100121cc:	e3530000 	cmp	r3, #0
100121d0:	1a000004 	bne	100121e8 <rt_set_errno+0x5c>
    {
        _errno = error;
100121d4:	e30c336c 	movw	r3, #50028	; 0xc36c
100121d8:	e3413003 	movt	r3, #4099	; 0x1003
100121dc:	e51b2010 	ldr	r2, [fp, #-16]
100121e0:	e5832000 	str	r2, [r3]

        return;
100121e4:	ea000002 	b	100121f4 <rt_set_errno+0x68>
    }

    tid->error = error;
100121e8:	e51b3008 	ldr	r3, [fp, #-8]
100121ec:	e51b2010 	ldr	r2, [fp, #-16]
100121f0:	e583202c 	str	r2, [r3, #44]	; 0x2c
}
100121f4:	e24bd004 	sub	sp, fp, #4
100121f8:	e8bd8800 	pop	{fp, pc}

100121fc <_rt_errno>:
 * This function returns errno.
 *
 * @return the errno in the system
 */
int *_rt_errno(void)
{
100121fc:	e92d4800 	push	{fp, lr}
10012200:	e28db004 	add	fp, sp, #4
10012204:	e24dd008 	sub	sp, sp, #8
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
10012208:	ebffffbc 	bl	10012100 <rt_interrupt_get_nest>
1001220c:	e1a03000 	mov	r3, r0
10012210:	e3530000 	cmp	r3, #0
10012214:	0a000002 	beq	10012224 <_rt_errno+0x28>
        return (int *)&_errno;
10012218:	e30c336c 	movw	r3, #50028	; 0xc36c
1001221c:	e3413003 	movt	r3, #4099	; 0x1003
10012220:	ea000009 	b	1001224c <_rt_errno+0x50>

    tid = rt_thread_self();
10012224:	eb0011cd 	bl	10016960 <rt_thread_self>
10012228:	e50b0008 	str	r0, [fp, #-8]
    if (tid != RT_NULL)
1001222c:	e51b3008 	ldr	r3, [fp, #-8]
10012230:	e3530000 	cmp	r3, #0
10012234:	0a000002 	beq	10012244 <_rt_errno+0x48>
        return (int *)&(tid->error);
10012238:	e51b3008 	ldr	r3, [fp, #-8]
1001223c:	e283302c 	add	r3, r3, #44	; 0x2c
10012240:	ea000001 	b	1001224c <_rt_errno+0x50>

    return (int *)&_errno;
10012244:	e30c336c 	movw	r3, #50028	; 0xc36c
10012248:	e3413003 	movt	r3, #4099	; 0x1003
}
1001224c:	e1a00003 	mov	r0, r3
10012250:	e24bd004 	sub	sp, fp, #4
10012254:	e8bd8800 	pop	{fp, pc}

10012258 <rt_memset>:
 * @param count the copied length
 *
 * @return the address of source memory
 */
void *rt_memset(void *s, int c, rt_ubase_t count)
{
10012258:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001225c:	e28db000 	add	fp, sp, #0
10012260:	e24dd024 	sub	sp, sp, #36	; 0x24
10012264:	e50b0018 	str	r0, [fp, #-24]
10012268:	e50b101c 	str	r1, [fp, #-28]
1001226c:	e50b2020 	str	r2, [fp, #-32]
#define LBLOCKSIZE      (sizeof(rt_int32_t))
#define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
#define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)

    int i;
    char *m = (char *)s;
10012270:	e51b3018 	ldr	r3, [fp, #-24]
10012274:	e50b3008 	str	r3, [fp, #-8]
    rt_uint32_t buffer;
    rt_uint32_t *aligned_addr;
    rt_uint32_t d = c & 0xff;
10012278:	e51b301c 	ldr	r3, [fp, #-28]
1001227c:	e6ef3073 	uxtb	r3, r3
10012280:	e50b3010 	str	r3, [fp, #-16]

    if (!TOO_SMALL(count) && !UNALIGNED(s))
10012284:	e51b3020 	ldr	r3, [fp, #-32]
10012288:	e3530003 	cmp	r3, #3
1001228c:	9a000038 	bls	10012374 <rt_memset+0x11c>
10012290:	e51b3018 	ldr	r3, [fp, #-24]
10012294:	e2033003 	and	r3, r3, #3
10012298:	e3530000 	cmp	r3, #0
1001229c:	1a000034 	bne	10012374 <rt_memset+0x11c>
    {
        /* If we get this far, we know that n is large and m is word-aligned. */
        aligned_addr = (rt_uint32_t *)s;
100122a0:	e51b3018 	ldr	r3, [fp, #-24]
100122a4:	e50b300c 	str	r3, [fp, #-12]
        /* Store D into each char sized location in BUFFER so that
         * we can set large blocks quickly.
         */
        if (LBLOCKSIZE == 4)
        {
            buffer = (d << 8) | d;
100122a8:	e51b3010 	ldr	r3, [fp, #-16]
100122ac:	e1a02403 	lsl	r2, r3, #8
100122b0:	e51b3010 	ldr	r3, [fp, #-16]
100122b4:	e1823003 	orr	r3, r2, r3
100122b8:	e50b3014 	str	r3, [fp, #-20]
            buffer |= (buffer << 16);
100122bc:	e51b3014 	ldr	r3, [fp, #-20]
100122c0:	e1a03803 	lsl	r3, r3, #16
100122c4:	e51b2014 	ldr	r2, [fp, #-20]
100122c8:	e1823003 	orr	r3, r2, r3
100122cc:	e50b3014 	str	r3, [fp, #-20]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
100122d0:	ea000016 	b	10012330 <rt_memset+0xd8>
        {
            *aligned_addr++ = buffer;
100122d4:	e51b300c 	ldr	r3, [fp, #-12]
100122d8:	e2832004 	add	r2, r3, #4
100122dc:	e50b200c 	str	r2, [fp, #-12]
100122e0:	e51b2014 	ldr	r2, [fp, #-20]
100122e4:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
100122e8:	e51b300c 	ldr	r3, [fp, #-12]
100122ec:	e2832004 	add	r2, r3, #4
100122f0:	e50b200c 	str	r2, [fp, #-12]
100122f4:	e51b2014 	ldr	r2, [fp, #-20]
100122f8:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
100122fc:	e51b300c 	ldr	r3, [fp, #-12]
10012300:	e2832004 	add	r2, r3, #4
10012304:	e50b200c 	str	r2, [fp, #-12]
10012308:	e51b2014 	ldr	r2, [fp, #-20]
1001230c:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
10012310:	e51b300c 	ldr	r3, [fp, #-12]
10012314:	e2832004 	add	r2, r3, #4
10012318:	e50b200c 	str	r2, [fp, #-12]
1001231c:	e51b2014 	ldr	r2, [fp, #-20]
10012320:	e5832000 	str	r2, [r3]
            count -= 4 * LBLOCKSIZE;
10012324:	e51b3020 	ldr	r3, [fp, #-32]
10012328:	e2433010 	sub	r3, r3, #16
1001232c:	e50b3020 	str	r3, [fp, #-32]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
10012330:	e51b3020 	ldr	r3, [fp, #-32]
10012334:	e353000f 	cmp	r3, #15
10012338:	8affffe5 	bhi	100122d4 <rt_memset+0x7c>
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
1001233c:	ea000007 	b	10012360 <rt_memset+0x108>
        {
            *aligned_addr++ = buffer;
10012340:	e51b300c 	ldr	r3, [fp, #-12]
10012344:	e2832004 	add	r2, r3, #4
10012348:	e50b200c 	str	r2, [fp, #-12]
1001234c:	e51b2014 	ldr	r2, [fp, #-20]
10012350:	e5832000 	str	r2, [r3]
            count -= LBLOCKSIZE;
10012354:	e51b3020 	ldr	r3, [fp, #-32]
10012358:	e2433004 	sub	r3, r3, #4
1001235c:	e50b3020 	str	r3, [fp, #-32]
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
10012360:	e51b3020 	ldr	r3, [fp, #-32]
10012364:	e3530003 	cmp	r3, #3
10012368:	8afffff4 	bhi	10012340 <rt_memset+0xe8>
            *aligned_addr++ = buffer;
            count -= LBLOCKSIZE;
        }

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
1001236c:	e51b300c 	ldr	r3, [fp, #-12]
10012370:	e50b3008 	str	r3, [fp, #-8]
    }

    while (count--)
10012374:	ea000005 	b	10012390 <rt_memset+0x138>
    {
        *m++ = (char)d;
10012378:	e51b3008 	ldr	r3, [fp, #-8]
1001237c:	e2832001 	add	r2, r3, #1
10012380:	e50b2008 	str	r2, [fp, #-8]
10012384:	e51b2010 	ldr	r2, [fp, #-16]
10012388:	e6ef2072 	uxtb	r2, r2
1001238c:	e5c32000 	strb	r2, [r3]

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
    }

    while (count--)
10012390:	e51b3020 	ldr	r3, [fp, #-32]
10012394:	e2432001 	sub	r2, r3, #1
10012398:	e50b2020 	str	r2, [fp, #-32]
1001239c:	e3530000 	cmp	r3, #0
100123a0:	1afffff4 	bne	10012378 <rt_memset+0x120>
    {
        *m++ = (char)d;
    }

    return s;
100123a4:	e51b3018 	ldr	r3, [fp, #-24]

#undef LBLOCKSIZE
#undef UNALIGNED
#undef TOO_SMALL
#endif
}
100123a8:	e1a00003 	mov	r0, r3
100123ac:	e24bd000 	sub	sp, fp, #0
100123b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100123b4:	e12fff1e 	bx	lr

100123b8 <rt_memcpy>:
 * @param count the copied length
 *
 * @return the address of destination memory
 */
void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
{
100123b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100123bc:	e28db000 	add	fp, sp, #0
100123c0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
100123c4:	e50b0020 	str	r0, [fp, #-32]
100123c8:	e50b1024 	str	r1, [fp, #-36]	; 0x24
100123cc:	e50b2028 	str	r2, [fp, #-40]	; 0x28
                         ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
#define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
#define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)

    char *dst_ptr = (char *)dst;
100123d0:	e51b3020 	ldr	r3, [fp, #-32]
100123d4:	e50b3008 	str	r3, [fp, #-8]
    char *src_ptr = (char *)src;
100123d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100123dc:	e50b300c 	str	r3, [fp, #-12]
    rt_int32_t *aligned_dst;
    rt_int32_t *aligned_src;
    int len = count;
100123e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100123e4:	e50b3018 	str	r3, [fp, #-24]

    /* If the size is small, or either SRC or DST is unaligned,
    then punt into the byte copy loop.  This should be rare. */
    if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
100123e8:	e51b3018 	ldr	r3, [fp, #-24]
100123ec:	e353000f 	cmp	r3, #15
100123f0:	9a000043 	bls	10012504 <rt_memcpy+0x14c>
100123f4:	e51b200c 	ldr	r2, [fp, #-12]
100123f8:	e51b3008 	ldr	r3, [fp, #-8]
100123fc:	e1823003 	orr	r3, r2, r3
10012400:	e2033003 	and	r3, r3, #3
10012404:	e3530000 	cmp	r3, #0
10012408:	1a00003d 	bne	10012504 <rt_memcpy+0x14c>
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
1001240c:	e51b3008 	ldr	r3, [fp, #-8]
10012410:	e50b3010 	str	r3, [fp, #-16]
        aligned_src = (rt_int32_t *)src_ptr;
10012414:	e51b300c 	ldr	r3, [fp, #-12]
10012418:	e50b3014 	str	r3, [fp, #-20]

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
1001241c:	ea000022 	b	100124ac <rt_memcpy+0xf4>
        {
            *aligned_dst++ = *aligned_src++;
10012420:	e51b3010 	ldr	r3, [fp, #-16]
10012424:	e2832004 	add	r2, r3, #4
10012428:	e50b2010 	str	r2, [fp, #-16]
1001242c:	e51b2014 	ldr	r2, [fp, #-20]
10012430:	e2821004 	add	r1, r2, #4
10012434:	e50b1014 	str	r1, [fp, #-20]
10012438:	e5922000 	ldr	r2, [r2]
1001243c:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
10012440:	e51b3010 	ldr	r3, [fp, #-16]
10012444:	e2832004 	add	r2, r3, #4
10012448:	e50b2010 	str	r2, [fp, #-16]
1001244c:	e51b2014 	ldr	r2, [fp, #-20]
10012450:	e2821004 	add	r1, r2, #4
10012454:	e50b1014 	str	r1, [fp, #-20]
10012458:	e5922000 	ldr	r2, [r2]
1001245c:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
10012460:	e51b3010 	ldr	r3, [fp, #-16]
10012464:	e2832004 	add	r2, r3, #4
10012468:	e50b2010 	str	r2, [fp, #-16]
1001246c:	e51b2014 	ldr	r2, [fp, #-20]
10012470:	e2821004 	add	r1, r2, #4
10012474:	e50b1014 	str	r1, [fp, #-20]
10012478:	e5922000 	ldr	r2, [r2]
1001247c:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
10012480:	e51b3010 	ldr	r3, [fp, #-16]
10012484:	e2832004 	add	r2, r3, #4
10012488:	e50b2010 	str	r2, [fp, #-16]
1001248c:	e51b2014 	ldr	r2, [fp, #-20]
10012490:	e2821004 	add	r1, r2, #4
10012494:	e50b1014 	str	r1, [fp, #-20]
10012498:	e5922000 	ldr	r2, [r2]
1001249c:	e5832000 	str	r2, [r3]
            len -= BIGBLOCKSIZE;
100124a0:	e51b3018 	ldr	r3, [fp, #-24]
100124a4:	e2433010 	sub	r3, r3, #16
100124a8:	e50b3018 	str	r3, [fp, #-24]
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
        aligned_src = (rt_int32_t *)src_ptr;

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
100124ac:	e51b3018 	ldr	r3, [fp, #-24]
100124b0:	e353000f 	cmp	r3, #15
100124b4:	8affffd9 	bhi	10012420 <rt_memcpy+0x68>
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
100124b8:	ea00000a 	b	100124e8 <rt_memcpy+0x130>
        {
            *aligned_dst++ = *aligned_src++;
100124bc:	e51b3010 	ldr	r3, [fp, #-16]
100124c0:	e2832004 	add	r2, r3, #4
100124c4:	e50b2010 	str	r2, [fp, #-16]
100124c8:	e51b2014 	ldr	r2, [fp, #-20]
100124cc:	e2821004 	add	r1, r2, #4
100124d0:	e50b1014 	str	r1, [fp, #-20]
100124d4:	e5922000 	ldr	r2, [r2]
100124d8:	e5832000 	str	r2, [r3]
            len -= LITTLEBLOCKSIZE;
100124dc:	e51b3018 	ldr	r3, [fp, #-24]
100124e0:	e2433004 	sub	r3, r3, #4
100124e4:	e50b3018 	str	r3, [fp, #-24]
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
100124e8:	e51b3018 	ldr	r3, [fp, #-24]
100124ec:	e3530003 	cmp	r3, #3
100124f0:	8afffff1 	bhi	100124bc <rt_memcpy+0x104>
            *aligned_dst++ = *aligned_src++;
            len -= LITTLEBLOCKSIZE;
        }

        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
100124f4:	e51b3010 	ldr	r3, [fp, #-16]
100124f8:	e50b3008 	str	r3, [fp, #-8]
        src_ptr = (char *)aligned_src;
100124fc:	e51b3014 	ldr	r3, [fp, #-20]
10012500:	e50b300c 	str	r3, [fp, #-12]
    }

    while (len--)
10012504:	ea000007 	b	10012528 <rt_memcpy+0x170>
        *dst_ptr++ = *src_ptr++;
10012508:	e51b3008 	ldr	r3, [fp, #-8]
1001250c:	e2832001 	add	r2, r3, #1
10012510:	e50b2008 	str	r2, [fp, #-8]
10012514:	e51b200c 	ldr	r2, [fp, #-12]
10012518:	e2821001 	add	r1, r2, #1
1001251c:	e50b100c 	str	r1, [fp, #-12]
10012520:	e5d22000 	ldrb	r2, [r2]
10012524:	e5c32000 	strb	r2, [r3]
        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
        src_ptr = (char *)aligned_src;
    }

    while (len--)
10012528:	e51b3018 	ldr	r3, [fp, #-24]
1001252c:	e2432001 	sub	r2, r3, #1
10012530:	e50b2018 	str	r2, [fp, #-24]
10012534:	e3530000 	cmp	r3, #0
10012538:	1afffff2 	bne	10012508 <rt_memcpy+0x150>
        *dst_ptr++ = *src_ptr++;

    return dst;
1001253c:	e51b3020 	ldr	r3, [fp, #-32]
#undef UNALIGNED
#undef BIGBLOCKSIZE
#undef LITTLEBLOCKSIZE
#undef TOO_SMALL
#endif
}
10012540:	e1a00003 	mov	r0, r3
10012544:	e24bd000 	sub	sp, fp, #0
10012548:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001254c:	e12fff1e 	bx	lr

10012550 <rt_memmove>:
 * @param n the copied length
 *
 * @return the address of destination memory
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
10012550:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012554:	e28db000 	add	fp, sp, #0
10012558:	e24dd01c 	sub	sp, sp, #28
1001255c:	e50b0010 	str	r0, [fp, #-16]
10012560:	e50b1014 	str	r1, [fp, #-20]
10012564:	e50b2018 	str	r2, [fp, #-24]
    char *tmp = (char *)dest, *s = (char *)src;
10012568:	e51b3010 	ldr	r3, [fp, #-16]
1001256c:	e50b3008 	str	r3, [fp, #-8]
10012570:	e51b3014 	ldr	r3, [fp, #-20]
10012574:	e50b300c 	str	r3, [fp, #-12]

    if (s < tmp && tmp < s + n)
10012578:	e51b200c 	ldr	r2, [fp, #-12]
1001257c:	e51b3008 	ldr	r3, [fp, #-8]
10012580:	e1520003 	cmp	r2, r3
10012584:	2a00001e 	bcs	10012604 <rt_memmove+0xb4>
10012588:	e51b200c 	ldr	r2, [fp, #-12]
1001258c:	e51b3018 	ldr	r3, [fp, #-24]
10012590:	e0822003 	add	r2, r2, r3
10012594:	e51b3008 	ldr	r3, [fp, #-8]
10012598:	e1520003 	cmp	r2, r3
1001259c:	9a000018 	bls	10012604 <rt_memmove+0xb4>
    {
        tmp += n;
100125a0:	e51b2008 	ldr	r2, [fp, #-8]
100125a4:	e51b3018 	ldr	r3, [fp, #-24]
100125a8:	e0823003 	add	r3, r2, r3
100125ac:	e50b3008 	str	r3, [fp, #-8]
        s += n;
100125b0:	e51b200c 	ldr	r2, [fp, #-12]
100125b4:	e51b3018 	ldr	r3, [fp, #-24]
100125b8:	e0823003 	add	r3, r2, r3
100125bc:	e50b300c 	str	r3, [fp, #-12]

        while (n--)
100125c0:	ea000009 	b	100125ec <rt_memmove+0x9c>
            *(--tmp) = *(--s);
100125c4:	e51b3008 	ldr	r3, [fp, #-8]
100125c8:	e2433001 	sub	r3, r3, #1
100125cc:	e50b3008 	str	r3, [fp, #-8]
100125d0:	e51b300c 	ldr	r3, [fp, #-12]
100125d4:	e2433001 	sub	r3, r3, #1
100125d8:	e50b300c 	str	r3, [fp, #-12]
100125dc:	e51b300c 	ldr	r3, [fp, #-12]
100125e0:	e5d32000 	ldrb	r2, [r3]
100125e4:	e51b3008 	ldr	r3, [fp, #-8]
100125e8:	e5c32000 	strb	r2, [r3]
    if (s < tmp && tmp < s + n)
    {
        tmp += n;
        s += n;

        while (n--)
100125ec:	e51b3018 	ldr	r3, [fp, #-24]
100125f0:	e2432001 	sub	r2, r3, #1
100125f4:	e50b2018 	str	r2, [fp, #-24]
100125f8:	e3530000 	cmp	r3, #0
100125fc:	1afffff0 	bne	100125c4 <rt_memmove+0x74>
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
    char *tmp = (char *)dest, *s = (char *)src;

    if (s < tmp && tmp < s + n)
10012600:	ea00000d 	b	1001263c <rt_memmove+0xec>
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
10012604:	ea000007 	b	10012628 <rt_memmove+0xd8>
            *tmp++ = *s++;
10012608:	e51b3008 	ldr	r3, [fp, #-8]
1001260c:	e2832001 	add	r2, r3, #1
10012610:	e50b2008 	str	r2, [fp, #-8]
10012614:	e51b200c 	ldr	r2, [fp, #-12]
10012618:	e2821001 	add	r1, r2, #1
1001261c:	e50b100c 	str	r1, [fp, #-12]
10012620:	e5d22000 	ldrb	r2, [r2]
10012624:	e5c32000 	strb	r2, [r3]
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
10012628:	e51b3018 	ldr	r3, [fp, #-24]
1001262c:	e2432001 	sub	r2, r3, #1
10012630:	e50b2018 	str	r2, [fp, #-24]
10012634:	e3530000 	cmp	r3, #0
10012638:	1afffff2 	bne	10012608 <rt_memmove+0xb8>
            *tmp++ = *s++;
    }

    return dest;
1001263c:	e51b3010 	ldr	r3, [fp, #-16]
}
10012640:	e1a00003 	mov	r0, r3
10012644:	e24bd000 	sub	sp, fp, #0
10012648:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001264c:	e12fff1e 	bx	lr

10012650 <rt_memcmp>:
 * @param count the size of the area
 *
 * @return the result
 */
rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
{
10012650:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012654:	e28db000 	add	fp, sp, #0
10012658:	e24dd024 	sub	sp, sp, #36	; 0x24
1001265c:	e50b0018 	str	r0, [fp, #-24]
10012660:	e50b101c 	str	r1, [fp, #-28]
10012664:	e50b2020 	str	r2, [fp, #-32]
    const unsigned char *su1, *su2;
    int res = 0;
10012668:	e3a03000 	mov	r3, #0
1001266c:	e50b3010 	str	r3, [fp, #-16]

    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
10012670:	e51b3018 	ldr	r3, [fp, #-24]
10012674:	e50b3008 	str	r3, [fp, #-8]
10012678:	e51b301c 	ldr	r3, [fp, #-28]
1001267c:	e50b300c 	str	r3, [fp, #-12]
10012680:	ea000013 	b	100126d4 <rt_memcmp+0x84>
        if ((res = *su1 - *su2) != 0)
10012684:	e51b3008 	ldr	r3, [fp, #-8]
10012688:	e5d33000 	ldrb	r3, [r3]
1001268c:	e1a02003 	mov	r2, r3
10012690:	e51b300c 	ldr	r3, [fp, #-12]
10012694:	e5d33000 	ldrb	r3, [r3]
10012698:	e0633002 	rsb	r3, r3, r2
1001269c:	e50b3010 	str	r3, [fp, #-16]
100126a0:	e51b3010 	ldr	r3, [fp, #-16]
100126a4:	e3530000 	cmp	r3, #0
100126a8:	0a000000 	beq	100126b0 <rt_memcmp+0x60>
            break;
100126ac:	ea00000b 	b	100126e0 <rt_memcmp+0x90>
rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
{
    const unsigned char *su1, *su2;
    int res = 0;

    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
100126b0:	e51b3008 	ldr	r3, [fp, #-8]
100126b4:	e2833001 	add	r3, r3, #1
100126b8:	e50b3008 	str	r3, [fp, #-8]
100126bc:	e51b300c 	ldr	r3, [fp, #-12]
100126c0:	e2833001 	add	r3, r3, #1
100126c4:	e50b300c 	str	r3, [fp, #-12]
100126c8:	e51b3020 	ldr	r3, [fp, #-32]
100126cc:	e2433001 	sub	r3, r3, #1
100126d0:	e50b3020 	str	r3, [fp, #-32]
100126d4:	e51b3020 	ldr	r3, [fp, #-32]
100126d8:	e3530000 	cmp	r3, #0
100126dc:	1affffe8 	bne	10012684 <rt_memcmp+0x34>
        if ((res = *su1 - *su2) != 0)
            break;

    return res;
100126e0:	e51b3010 	ldr	r3, [fp, #-16]
}
100126e4:	e1a00003 	mov	r0, r3
100126e8:	e24bd000 	sub	sp, fp, #0
100126ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100126f0:	e12fff1e 	bx	lr

100126f4 <rt_strstr>:
 * @param s2 the find string
 *
 * @return the first occurrence of a s2 in s1, or RT_NULL if no found.
 */
char *rt_strstr(const char *s1, const char *s2)
{
100126f4:	e92d4800 	push	{fp, lr}
100126f8:	e28db004 	add	fp, sp, #4
100126fc:	e24dd010 	sub	sp, sp, #16
10012700:	e50b0010 	str	r0, [fp, #-16]
10012704:	e50b1014 	str	r1, [fp, #-20]
    int l1, l2;

    l2 = rt_strlen(s2);
10012708:	e51b0014 	ldr	r0, [fp, #-20]
1001270c:	eb0000c6 	bl	10012a2c <rt_strlen>
10012710:	e1a03000 	mov	r3, r0
10012714:	e50b300c 	str	r3, [fp, #-12]
    if (!l2)
10012718:	e51b300c 	ldr	r3, [fp, #-12]
1001271c:	e3530000 	cmp	r3, #0
10012720:	1a000001 	bne	1001272c <rt_strstr+0x38>
        return (char *)s1;
10012724:	e51b3010 	ldr	r3, [fp, #-16]
10012728:	ea000019 	b	10012794 <rt_strstr+0xa0>
    l1 = rt_strlen(s1);
1001272c:	e51b0010 	ldr	r0, [fp, #-16]
10012730:	eb0000bd 	bl	10012a2c <rt_strlen>
10012734:	e1a03000 	mov	r3, r0
10012738:	e50b3008 	str	r3, [fp, #-8]
    while (l1 >= l2)
1001273c:	ea00000f 	b	10012780 <rt_strstr+0x8c>
    {
        l1 --;
10012740:	e51b3008 	ldr	r3, [fp, #-8]
10012744:	e2433001 	sub	r3, r3, #1
10012748:	e50b3008 	str	r3, [fp, #-8]
        if (!rt_memcmp(s1, s2, l2))
1001274c:	e51b300c 	ldr	r3, [fp, #-12]
10012750:	e51b0010 	ldr	r0, [fp, #-16]
10012754:	e51b1014 	ldr	r1, [fp, #-20]
10012758:	e1a02003 	mov	r2, r3
1001275c:	ebffffbb 	bl	10012650 <rt_memcmp>
10012760:	e1a03000 	mov	r3, r0
10012764:	e3530000 	cmp	r3, #0
10012768:	1a000001 	bne	10012774 <rt_strstr+0x80>
            return (char *)s1;
1001276c:	e51b3010 	ldr	r3, [fp, #-16]
10012770:	ea000007 	b	10012794 <rt_strstr+0xa0>
        s1 ++;
10012774:	e51b3010 	ldr	r3, [fp, #-16]
10012778:	e2833001 	add	r3, r3, #1
1001277c:	e50b3010 	str	r3, [fp, #-16]

    l2 = rt_strlen(s2);
    if (!l2)
        return (char *)s1;
    l1 = rt_strlen(s1);
    while (l1 >= l2)
10012780:	e51b2008 	ldr	r2, [fp, #-8]
10012784:	e51b300c 	ldr	r3, [fp, #-12]
10012788:	e1520003 	cmp	r2, r3
1001278c:	aaffffeb 	bge	10012740 <rt_strstr+0x4c>
        if (!rt_memcmp(s1, s2, l2))
            return (char *)s1;
        s1 ++;
    }

    return RT_NULL;
10012790:	e3a03000 	mov	r3, #0
}
10012794:	e1a00003 	mov	r0, r3
10012798:	e24bd004 	sub	sp, fp, #4
1001279c:	e8bd8800 	pop	{fp, pc}

100127a0 <rt_strcasecmp>:
 * @param b the string to be compared
 *
 * @return the result
 */
rt_uint32_t rt_strcasecmp(const char *a, const char *b)
{
100127a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100127a4:	e28db000 	add	fp, sp, #0
100127a8:	e24dd014 	sub	sp, sp, #20
100127ac:	e50b0010 	str	r0, [fp, #-16]
100127b0:	e50b1014 	str	r1, [fp, #-20]
    int ca, cb;

    do
    {
        ca = *a++ & 0xff;
100127b4:	e51b3010 	ldr	r3, [fp, #-16]
100127b8:	e2832001 	add	r2, r3, #1
100127bc:	e50b2010 	str	r2, [fp, #-16]
100127c0:	e5d33000 	ldrb	r3, [r3]
100127c4:	e50b3008 	str	r3, [fp, #-8]
        cb = *b++ & 0xff;
100127c8:	e51b3014 	ldr	r3, [fp, #-20]
100127cc:	e2832001 	add	r2, r3, #1
100127d0:	e50b2014 	str	r2, [fp, #-20]
100127d4:	e5d33000 	ldrb	r3, [r3]
100127d8:	e50b300c 	str	r3, [fp, #-12]
        if (ca >= 'A' && ca <= 'Z')
100127dc:	e51b3008 	ldr	r3, [fp, #-8]
100127e0:	e3530040 	cmp	r3, #64	; 0x40
100127e4:	da000005 	ble	10012800 <rt_strcasecmp+0x60>
100127e8:	e51b3008 	ldr	r3, [fp, #-8]
100127ec:	e353005a 	cmp	r3, #90	; 0x5a
100127f0:	ca000002 	bgt	10012800 <rt_strcasecmp+0x60>
            ca += 'a' - 'A';
100127f4:	e51b3008 	ldr	r3, [fp, #-8]
100127f8:	e2833020 	add	r3, r3, #32
100127fc:	e50b3008 	str	r3, [fp, #-8]
        if (cb >= 'A' && cb <= 'Z')
10012800:	e51b300c 	ldr	r3, [fp, #-12]
10012804:	e3530040 	cmp	r3, #64	; 0x40
10012808:	da000005 	ble	10012824 <rt_strcasecmp+0x84>
1001280c:	e51b300c 	ldr	r3, [fp, #-12]
10012810:	e353005a 	cmp	r3, #90	; 0x5a
10012814:	ca000002 	bgt	10012824 <rt_strcasecmp+0x84>
            cb += 'a' - 'A';
10012818:	e51b300c 	ldr	r3, [fp, #-12]
1001281c:	e2833020 	add	r3, r3, #32
10012820:	e50b300c 	str	r3, [fp, #-12]
    }
    while (ca == cb && ca != '\0');
10012824:	e51b2008 	ldr	r2, [fp, #-8]
10012828:	e51b300c 	ldr	r3, [fp, #-12]
1001282c:	e1520003 	cmp	r2, r3
10012830:	1a000002 	bne	10012840 <rt_strcasecmp+0xa0>
10012834:	e51b3008 	ldr	r3, [fp, #-8]
10012838:	e3530000 	cmp	r3, #0
1001283c:	1affffdc 	bne	100127b4 <rt_strcasecmp+0x14>

    return ca - cb;
10012840:	e51b2008 	ldr	r2, [fp, #-8]
10012844:	e51b300c 	ldr	r3, [fp, #-12]
10012848:	e0633002 	rsb	r3, r3, r2
}
1001284c:	e1a00003 	mov	r0, r3
10012850:	e24bd000 	sub	sp, fp, #0
10012854:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012858:	e12fff1e 	bx	lr

1001285c <rt_strncpy>:
 * @param n the maximum copied length
 *
 * @return the result
 */
char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
1001285c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012860:	e28db000 	add	fp, sp, #0
10012864:	e24dd01c 	sub	sp, sp, #28
10012868:	e50b0010 	str	r0, [fp, #-16]
1001286c:	e50b1014 	str	r1, [fp, #-20]
10012870:	e50b2018 	str	r2, [fp, #-24]
    if (n != 0)
10012874:	e51b3018 	ldr	r3, [fp, #-24]
10012878:	e3530000 	cmp	r3, #0
1001287c:	0a000021 	beq	10012908 <rt_strncpy+0xac>
    {
        char *d = dst;
10012880:	e51b3010 	ldr	r3, [fp, #-16]
10012884:	e50b3008 	str	r3, [fp, #-8]
        const char *s = src;
10012888:	e51b3014 	ldr	r3, [fp, #-20]
1001288c:	e50b300c 	str	r3, [fp, #-12]

        do
        {
            if ((*d++ = *s++) == 0)
10012890:	e51b3008 	ldr	r3, [fp, #-8]
10012894:	e2832001 	add	r2, r3, #1
10012898:	e50b2008 	str	r2, [fp, #-8]
1001289c:	e51b200c 	ldr	r2, [fp, #-12]
100128a0:	e2821001 	add	r1, r2, #1
100128a4:	e50b100c 	str	r1, [fp, #-12]
100128a8:	e5d22000 	ldrb	r2, [r2]
100128ac:	e5c32000 	strb	r2, [r3]
100128b0:	e5d33000 	ldrb	r3, [r3]
100128b4:	e3530000 	cmp	r3, #0
100128b8:	1a00000c 	bne	100128f0 <rt_strncpy+0x94>
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
100128bc:	ea000004 	b	100128d4 <rt_strncpy+0x78>
                    *d++ = 0;
100128c0:	e51b3008 	ldr	r3, [fp, #-8]
100128c4:	e2832001 	add	r2, r3, #1
100128c8:	e50b2008 	str	r2, [fp, #-8]
100128cc:	e3a02000 	mov	r2, #0
100128d0:	e5c32000 	strb	r2, [r3]
        do
        {
            if ((*d++ = *s++) == 0)
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
100128d4:	e51b3018 	ldr	r3, [fp, #-24]
100128d8:	e2433001 	sub	r3, r3, #1
100128dc:	e50b3018 	str	r3, [fp, #-24]
100128e0:	e51b3018 	ldr	r3, [fp, #-24]
100128e4:	e3530000 	cmp	r3, #0
100128e8:	1afffff4 	bne	100128c0 <rt_strncpy+0x64>
                    *d++ = 0;
                break;
100128ec:	ea000005 	b	10012908 <rt_strncpy+0xac>
            }
        } while (--n != 0);
100128f0:	e51b3018 	ldr	r3, [fp, #-24]
100128f4:	e2433001 	sub	r3, r3, #1
100128f8:	e50b3018 	str	r3, [fp, #-24]
100128fc:	e51b3018 	ldr	r3, [fp, #-24]
10012900:	e3530000 	cmp	r3, #0
10012904:	1affffe1 	bne	10012890 <rt_strncpy+0x34>
    }

    return (dst);
10012908:	e51b3010 	ldr	r3, [fp, #-16]
}
1001290c:	e1a00003 	mov	r0, r3
10012910:	e24bd000 	sub	sp, fp, #0
10012914:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012918:	e12fff1e 	bx	lr

1001291c <rt_strncmp>:
 * @param count the maximum compare length
 *
 * @return the result
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
1001291c:	e92d0810 	push	{r4, fp}
10012920:	e28db004 	add	fp, sp, #4
10012924:	e24dd010 	sub	sp, sp, #16
10012928:	e50b0008 	str	r0, [fp, #-8]
1001292c:	e50b100c 	str	r1, [fp, #-12]
10012930:	e50b2010 	str	r2, [fp, #-16]
    register signed char __res = 0;
10012934:	e3a04000 	mov	r4, #0

    while (count)
10012938:	ea000013 	b	1001298c <rt_strncmp+0x70>
    {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
1001293c:	e51b3008 	ldr	r3, [fp, #-8]
10012940:	e5d32000 	ldrb	r2, [r3]
10012944:	e51b300c 	ldr	r3, [fp, #-12]
10012948:	e2831001 	add	r1, r3, #1
1001294c:	e50b100c 	str	r1, [fp, #-12]
10012950:	e5d33000 	ldrb	r3, [r3]
10012954:	e0633002 	rsb	r3, r3, r2
10012958:	e6ef3073 	uxtb	r3, r3
1001295c:	e6ef4073 	uxtb	r4, r3
10012960:	e3540000 	cmp	r4, #0
10012964:	1a00000b 	bne	10012998 <rt_strncmp+0x7c>
10012968:	e51b3008 	ldr	r3, [fp, #-8]
1001296c:	e2832001 	add	r2, r3, #1
10012970:	e50b2008 	str	r2, [fp, #-8]
10012974:	e5d33000 	ldrb	r3, [r3]
10012978:	e3530000 	cmp	r3, #0
1001297c:	0a000005 	beq	10012998 <rt_strncmp+0x7c>
            break;
        count --;
10012980:	e51b3010 	ldr	r3, [fp, #-16]
10012984:	e2433001 	sub	r3, r3, #1
10012988:	e50b3010 	str	r3, [fp, #-16]
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
    register signed char __res = 0;

    while (count)
1001298c:	e51b3010 	ldr	r3, [fp, #-16]
10012990:	e3530000 	cmp	r3, #0
10012994:	1affffe8 	bne	1001293c <rt_strncmp+0x20>
        if ((__res = *cs - *ct++) != 0 || !*cs++)
            break;
        count --;
    }

    return __res;
10012998:	e6af3074 	sxtb	r3, r4
}
1001299c:	e1a00003 	mov	r0, r3
100129a0:	e24bd004 	sub	sp, fp, #4
100129a4:	e8bd0810 	pop	{r4, fp}
100129a8:	e12fff1e 	bx	lr

100129ac <rt_strcmp>:
 * @param ct the string to be compared
 *
 * @return the result
 */
rt_int32_t rt_strcmp(const char *cs, const char *ct)
{
100129ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100129b0:	e28db000 	add	fp, sp, #0
100129b4:	e24dd00c 	sub	sp, sp, #12
100129b8:	e50b0008 	str	r0, [fp, #-8]
100129bc:	e50b100c 	str	r1, [fp, #-12]
    while (*cs && *cs == *ct)
100129c0:	ea000005 	b	100129dc <rt_strcmp+0x30>
        cs++, ct++;
100129c4:	e51b3008 	ldr	r3, [fp, #-8]
100129c8:	e2833001 	add	r3, r3, #1
100129cc:	e50b3008 	str	r3, [fp, #-8]
100129d0:	e51b300c 	ldr	r3, [fp, #-12]
100129d4:	e2833001 	add	r3, r3, #1
100129d8:	e50b300c 	str	r3, [fp, #-12]
 *
 * @return the result
 */
rt_int32_t rt_strcmp(const char *cs, const char *ct)
{
    while (*cs && *cs == *ct)
100129dc:	e51b3008 	ldr	r3, [fp, #-8]
100129e0:	e5d33000 	ldrb	r3, [r3]
100129e4:	e3530000 	cmp	r3, #0
100129e8:	0a000005 	beq	10012a04 <rt_strcmp+0x58>
100129ec:	e51b3008 	ldr	r3, [fp, #-8]
100129f0:	e5d32000 	ldrb	r2, [r3]
100129f4:	e51b300c 	ldr	r3, [fp, #-12]
100129f8:	e5d33000 	ldrb	r3, [r3]
100129fc:	e1520003 	cmp	r2, r3
10012a00:	0affffef 	beq	100129c4 <rt_strcmp+0x18>
        cs++, ct++;

    return (*cs - *ct);
10012a04:	e51b3008 	ldr	r3, [fp, #-8]
10012a08:	e5d33000 	ldrb	r3, [r3]
10012a0c:	e1a02003 	mov	r2, r3
10012a10:	e51b300c 	ldr	r3, [fp, #-12]
10012a14:	e5d33000 	ldrb	r3, [r3]
10012a18:	e0633002 	rsb	r3, r3, r2
}
10012a1c:	e1a00003 	mov	r0, r3
10012a20:	e24bd000 	sub	sp, fp, #0
10012a24:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012a28:	e12fff1e 	bx	lr

10012a2c <rt_strlen>:
 * @param s the string
 *
 * @return the length of string
 */
rt_size_t rt_strlen(const char *s)
{
10012a2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012a30:	e28db000 	add	fp, sp, #0
10012a34:	e24dd014 	sub	sp, sp, #20
10012a38:	e50b0010 	str	r0, [fp, #-16]
    const char *sc;

    for (sc = s; *sc != '\0'; ++sc) /* nothing */
10012a3c:	e51b3010 	ldr	r3, [fp, #-16]
10012a40:	e50b3008 	str	r3, [fp, #-8]
10012a44:	ea000002 	b	10012a54 <rt_strlen+0x28>
10012a48:	e51b3008 	ldr	r3, [fp, #-8]
10012a4c:	e2833001 	add	r3, r3, #1
10012a50:	e50b3008 	str	r3, [fp, #-8]
10012a54:	e51b3008 	ldr	r3, [fp, #-8]
10012a58:	e5d33000 	ldrb	r3, [r3]
10012a5c:	e3530000 	cmp	r3, #0
10012a60:	1afffff8 	bne	10012a48 <rt_strlen+0x1c>
        ;

    return sc - s;
10012a64:	e51b2008 	ldr	r2, [fp, #-8]
10012a68:	e51b3010 	ldr	r3, [fp, #-16]
10012a6c:	e0633002 	rsb	r3, r3, r2
}
10012a70:	e1a00003 	mov	r0, r3
10012a74:	e24bd000 	sub	sp, fp, #0
10012a78:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012a7c:	e12fff1e 	bx	lr

10012a80 <rt_strdup>:
 * @param s the string to be duplicated
 *
 * @return the duplicated string pointer
 */
char *rt_strdup(const char *s)
{
10012a80:	e92d4800 	push	{fp, lr}
10012a84:	e28db004 	add	fp, sp, #4
10012a88:	e24dd010 	sub	sp, sp, #16
10012a8c:	e50b0010 	str	r0, [fp, #-16]
    rt_size_t len = rt_strlen(s) + 1;
10012a90:	e51b0010 	ldr	r0, [fp, #-16]
10012a94:	ebffffe4 	bl	10012a2c <rt_strlen>
10012a98:	e1a03000 	mov	r3, r0
10012a9c:	e2833001 	add	r3, r3, #1
10012aa0:	e50b3008 	str	r3, [fp, #-8]
    char *tmp = (char *)rt_malloc(len);
10012aa4:	e51b0008 	ldr	r0, [fp, #-8]
10012aa8:	eb0005f9 	bl	10014294 <rt_malloc>
10012aac:	e50b000c 	str	r0, [fp, #-12]

    if (!tmp)
10012ab0:	e51b300c 	ldr	r3, [fp, #-12]
10012ab4:	e3530000 	cmp	r3, #0
10012ab8:	1a000001 	bne	10012ac4 <rt_strdup+0x44>
        return RT_NULL;
10012abc:	e3a03000 	mov	r3, #0
10012ac0:	ea000004 	b	10012ad8 <rt_strdup+0x58>

    rt_memcpy(tmp, s, len);
10012ac4:	e51b000c 	ldr	r0, [fp, #-12]
10012ac8:	e51b1010 	ldr	r1, [fp, #-16]
10012acc:	e51b2008 	ldr	r2, [fp, #-8]
10012ad0:	ebfffe38 	bl	100123b8 <rt_memcpy>

    return tmp;
10012ad4:	e51b300c 	ldr	r3, [fp, #-12]
}
10012ad8:	e1a00003 	mov	r0, r3
10012adc:	e24bd004 	sub	sp, fp, #4
10012ae0:	e8bd8800 	pop	{fp, pc}

10012ae4 <rt_show_version>:

/**
 * This function will show the version of rt-thread rtos
 */
void rt_show_version(void)
{
10012ae4:	e92d4800 	push	{fp, lr}
10012ae8:	e28db004 	add	fp, sp, #4
10012aec:	e24dd008 	sub	sp, sp, #8
	//while(1)
		{
			rt_kprintf("\n \\ | /\n");
10012af0:	e303071c 	movw	r0, #14108	; 0x371c
10012af4:	e3410003 	movt	r0, #4099	; 0x1003
10012af8:	eb0003f0 	bl	10013ac0 <rt_kprintf>
		    rt_kprintf("- RT -     Thread Operating System\n");
10012afc:	e3030728 	movw	r0, #14120	; 0x3728
10012b00:	e3410003 	movt	r0, #4099	; 0x1003
10012b04:	eb0003ed 	bl	10013ac0 <rt_kprintf>
		    rt_kprintf(" / | \\     %d.%d.%d build %s\n",
10012b08:	e303376c 	movw	r3, #14188	; 0x376c
10012b0c:	e3413003 	movt	r3, #4099	; 0x1003
10012b10:	e58d3000 	str	r3, [sp]
10012b14:	e303074c 	movw	r0, #14156	; 0x374c
10012b18:	e3410003 	movt	r0, #4099	; 0x1003
10012b1c:	e3a01002 	mov	r1, #2
10012b20:	e3a02001 	mov	r2, #1
10012b24:	e3a03000 	mov	r3, #0
10012b28:	eb0003e4 	bl	10013ac0 <rt_kprintf>
		               RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
		    rt_kprintf(" 2006 - 2015 Copyright by rt-thread team\n");
10012b2c:	e3030778 	movw	r0, #14200	; 0x3778
10012b30:	e3410003 	movt	r0, #4099	; 0x1003
10012b34:	eb0003e1 	bl	10013ac0 <rt_kprintf>
		}
}
10012b38:	e24bd004 	sub	sp, fp, #4
10012b3c:	e8bd8800 	pop	{fp, pc}

10012b40 <divide>:

/* private function */
#define isdigit(c)  ((unsigned)((c) - '0') < 10)

rt_inline rt_int32_t divide(rt_int32_t *n, rt_int32_t base)
{
10012b40:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012b44:	e28db000 	add	fp, sp, #0
10012b48:	e24dd014 	sub	sp, sp, #20
10012b4c:	e50b0010 	str	r0, [fp, #-16]
10012b50:	e50b1014 	str	r1, [fp, #-20]
    rt_int32_t res;

    /* optimized for processor which does not support divide instructions. */
    if (base == 10)
10012b54:	e51b3014 	ldr	r3, [fp, #-20]
10012b58:	e353000a 	cmp	r3, #10
10012b5c:	1a000016 	bne	10012bbc <divide+0x7c>
    {
        res = ((rt_uint32_t)*n) % 10U;
10012b60:	e51b3010 	ldr	r3, [fp, #-16]
10012b64:	e5933000 	ldr	r3, [r3]
10012b68:	e1a01003 	mov	r1, r3
10012b6c:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10012b70:	e34c3ccc 	movt	r3, #52428	; 0xcccc
10012b74:	e0832391 	umull	r2, r3, r1, r3
10012b78:	e1a031a3 	lsr	r3, r3, #3
10012b7c:	e1a03083 	lsl	r3, r3, #1
10012b80:	e1a02103 	lsl	r2, r3, #2
10012b84:	e0833002 	add	r3, r3, r2
10012b88:	e0633001 	rsb	r3, r3, r1
10012b8c:	e50b3008 	str	r3, [fp, #-8]
        *n = ((rt_uint32_t)*n) / 10U;
10012b90:	e51b3010 	ldr	r3, [fp, #-16]
10012b94:	e5933000 	ldr	r3, [r3]
10012b98:	e1a02003 	mov	r2, r3
10012b9c:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10012ba0:	e34c3ccc 	movt	r3, #52428	; 0xcccc
10012ba4:	e0832392 	umull	r2, r3, r2, r3
10012ba8:	e1a031a3 	lsr	r3, r3, #3
10012bac:	e1a02003 	mov	r2, r3
10012bb0:	e51b3010 	ldr	r3, [fp, #-16]
10012bb4:	e5832000 	str	r2, [r3]
10012bb8:	ea000009 	b	10012be4 <divide+0xa4>
    }
    else
    {
        res = ((rt_uint32_t)*n) % 16U;
10012bbc:	e51b3010 	ldr	r3, [fp, #-16]
10012bc0:	e5933000 	ldr	r3, [r3]
10012bc4:	e203300f 	and	r3, r3, #15
10012bc8:	e50b3008 	str	r3, [fp, #-8]
        *n = ((rt_uint32_t)*n) / 16U;
10012bcc:	e51b3010 	ldr	r3, [fp, #-16]
10012bd0:	e5933000 	ldr	r3, [r3]
10012bd4:	e1a03223 	lsr	r3, r3, #4
10012bd8:	e1a02003 	mov	r2, r3
10012bdc:	e51b3010 	ldr	r3, [fp, #-16]
10012be0:	e5832000 	str	r2, [r3]
    }

    return res;
10012be4:	e51b3008 	ldr	r3, [fp, #-8]
}
10012be8:	e1a00003 	mov	r0, r3
10012bec:	e24bd000 	sub	sp, fp, #0
10012bf0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012bf4:	e12fff1e 	bx	lr

10012bf8 <skip_atoi>:

rt_inline int skip_atoi(const char **s)
{
10012bf8:	e92d0810 	push	{r4, fp}
10012bfc:	e28db004 	add	fp, sp, #4
10012c00:	e24dd008 	sub	sp, sp, #8
10012c04:	e50b0008 	str	r0, [fp, #-8]
    register int i=0;
10012c08:	e3a04000 	mov	r4, #0
    while (isdigit(**s))
10012c0c:	ea00000b 	b	10012c40 <skip_atoi+0x48>
        i = i * 10 + *((*s)++) - '0';
10012c10:	e1a03004 	mov	r3, r4
10012c14:	e1a03083 	lsl	r3, r3, #1
10012c18:	e1a02103 	lsl	r2, r3, #2
10012c1c:	e0832002 	add	r2, r3, r2
10012c20:	e51b3008 	ldr	r3, [fp, #-8]
10012c24:	e5933000 	ldr	r3, [r3]
10012c28:	e2830001 	add	r0, r3, #1
10012c2c:	e51b1008 	ldr	r1, [fp, #-8]
10012c30:	e5810000 	str	r0, [r1]
10012c34:	e5d33000 	ldrb	r3, [r3]
10012c38:	e0823003 	add	r3, r2, r3
10012c3c:	e2434030 	sub	r4, r3, #48	; 0x30
}

rt_inline int skip_atoi(const char **s)
{
    register int i=0;
    while (isdigit(**s))
10012c40:	e51b3008 	ldr	r3, [fp, #-8]
10012c44:	e5933000 	ldr	r3, [r3]
10012c48:	e5d33000 	ldrb	r3, [r3]
10012c4c:	e2433030 	sub	r3, r3, #48	; 0x30
10012c50:	e3530009 	cmp	r3, #9
10012c54:	9affffed 	bls	10012c10 <skip_atoi+0x18>
        i = i * 10 + *((*s)++) - '0';

    return i;
10012c58:	e1a03004 	mov	r3, r4
}
10012c5c:	e1a00003 	mov	r0, r3
10012c60:	e24bd004 	sub	sp, fp, #4
10012c64:	e8bd0810 	pop	{r4, fp}
10012c68:	e12fff1e 	bx	lr

10012c6c <print_number>:
                          long  num,
                          int   base,
                          int   s,
                          int   type)
#endif
{
10012c6c:	e92d4870 	push	{r4, r5, r6, fp, lr}
10012c70:	e28db010 	add	fp, sp, #16
10012c74:	e24dd044 	sub	sp, sp, #68	; 0x44
10012c78:	e50b0048 	str	r0, [fp, #-72]	; 0x48
10012c7c:	e50b104c 	str	r1, [fp, #-76]	; 0x4c
10012c80:	e50b2050 	str	r2, [fp, #-80]	; 0x50
10012c84:	e50b3054 	str	r3, [fp, #-84]	; 0x54
    static const char small_digits[] = "0123456789abcdef";
    static const char large_digits[] = "0123456789ABCDEF";
    register int i;
    register int size;

    size = s;
10012c88:	e59b4004 	ldr	r4, [fp, #4]

    digits = (type & LARGE) ? large_digits : small_digits;
10012c8c:	e59b300c 	ldr	r3, [fp, #12]
10012c90:	e2033040 	and	r3, r3, #64	; 0x40
10012c94:	e3530000 	cmp	r3, #0
10012c98:	0a000002 	beq	10012ca8 <print_number+0x3c>
10012c9c:	e30338e4 	movw	r3, #14564	; 0x38e4
10012ca0:	e3413003 	movt	r3, #4099	; 0x1003
10012ca4:	ea000001 	b	10012cb0 <print_number+0x44>
10012ca8:	e30338f8 	movw	r3, #14584	; 0x38f8
10012cac:	e3413003 	movt	r3, #4099	; 0x1003
10012cb0:	e50b301c 	str	r3, [fp, #-28]
    if (type & LEFT)
10012cb4:	e59b300c 	ldr	r3, [fp, #12]
10012cb8:	e2033010 	and	r3, r3, #16
10012cbc:	e3530000 	cmp	r3, #0
10012cc0:	0a000002 	beq	10012cd0 <print_number+0x64>
        type &= ~ZEROPAD;
10012cc4:	e59b300c 	ldr	r3, [fp, #12]
10012cc8:	e3c33001 	bic	r3, r3, #1
10012ccc:	e58b300c 	str	r3, [fp, #12]

    c = (type & ZEROPAD) ? '0' : ' ';
10012cd0:	e59b300c 	ldr	r3, [fp, #12]
10012cd4:	e2033001 	and	r3, r3, #1
10012cd8:	e3530000 	cmp	r3, #0
10012cdc:	0a000001 	beq	10012ce8 <print_number+0x7c>
10012ce0:	e3a03030 	mov	r3, #48	; 0x30
10012ce4:	ea000000 	b	10012cec <print_number+0x80>
10012ce8:	e3a03020 	mov	r3, #32
10012cec:	e54b301d 	strb	r3, [fp, #-29]

    /* get sign */
    sign = 0;
10012cf0:	e3a03000 	mov	r3, #0
10012cf4:	e54b3015 	strb	r3, [fp, #-21]
    if (type & SIGN)
10012cf8:	e59b300c 	ldr	r3, [fp, #12]
10012cfc:	e2033002 	and	r3, r3, #2
10012d00:	e3530000 	cmp	r3, #0
10012d04:	0a000015 	beq	10012d60 <print_number+0xf4>
    {
        if (num < 0)
10012d08:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
10012d0c:	e3530000 	cmp	r3, #0
10012d10:	aa000005 	bge	10012d2c <print_number+0xc0>
        {
            sign = '-';
10012d14:	e3a0302d 	mov	r3, #45	; 0x2d
10012d18:	e54b3015 	strb	r3, [fp, #-21]
            num = -num;
10012d1c:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
10012d20:	e2633000 	rsb	r3, r3, #0
10012d24:	e50b3050 	str	r3, [fp, #-80]	; 0x50
10012d28:	ea00000c 	b	10012d60 <print_number+0xf4>
        }
        else if (type & PLUS)
10012d2c:	e59b300c 	ldr	r3, [fp, #12]
10012d30:	e2033004 	and	r3, r3, #4
10012d34:	e3530000 	cmp	r3, #0
10012d38:	0a000002 	beq	10012d48 <print_number+0xdc>
            sign = '+';
10012d3c:	e3a0302b 	mov	r3, #43	; 0x2b
10012d40:	e54b3015 	strb	r3, [fp, #-21]
10012d44:	ea000005 	b	10012d60 <print_number+0xf4>
        else if (type & SPACE)
10012d48:	e59b300c 	ldr	r3, [fp, #12]
10012d4c:	e2033008 	and	r3, r3, #8
10012d50:	e3530000 	cmp	r3, #0
10012d54:	0a000001 	beq	10012d60 <print_number+0xf4>
            sign = ' ';
10012d58:	e3a03020 	mov	r3, #32
10012d5c:	e54b3015 	strb	r3, [fp, #-21]
        else if (base == 8)
            size--;
    }
#endif

    i = 0;
10012d60:	e3a05000 	mov	r5, #0
    if (num == 0)
10012d64:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
10012d68:	e3530000 	cmp	r3, #0
10012d6c:	1a000006 	bne	10012d8c <print_number+0x120>
        tmp[i++]='0';
10012d70:	e1a03005 	mov	r3, r5
10012d74:	e2835001 	add	r5, r3, #1
10012d78:	e24b2014 	sub	r2, fp, #20
10012d7c:	e0823003 	add	r3, r2, r3
10012d80:	e3a02030 	mov	r2, #48	; 0x30
10012d84:	e543202c 	strb	r2, [r3, #-44]	; 0x2c
10012d88:	ea000011 	b	10012dd4 <print_number+0x168>
    else
    {
        while (num != 0)
10012d8c:	ea00000d 	b	10012dc8 <print_number+0x15c>
            tmp[i++] = digits[divide(&num, base)];
10012d90:	e1a06005 	mov	r6, r5
10012d94:	e2865001 	add	r5, r6, #1
10012d98:	e24b3050 	sub	r3, fp, #80	; 0x50
10012d9c:	e1a00003 	mov	r0, r3
10012da0:	e51b1054 	ldr	r1, [fp, #-84]	; 0x54
10012da4:	ebffff65 	bl	10012b40 <divide>
10012da8:	e1a03000 	mov	r3, r0
10012dac:	e1a02003 	mov	r2, r3
10012db0:	e51b301c 	ldr	r3, [fp, #-28]
10012db4:	e0833002 	add	r3, r3, r2
10012db8:	e5d32000 	ldrb	r2, [r3]
10012dbc:	e24b3014 	sub	r3, fp, #20
10012dc0:	e0833006 	add	r3, r3, r6
10012dc4:	e543202c 	strb	r2, [r3, #-44]	; 0x2c
    i = 0;
    if (num == 0)
        tmp[i++]='0';
    else
    {
        while (num != 0)
10012dc8:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
10012dcc:	e3530000 	cmp	r3, #0
10012dd0:	1affffee 	bne	10012d90 <print_number+0x124>
            tmp[i++] = digits[divide(&num, base)];
    }

#ifdef RT_PRINTF_PRECISION
    if (i > precision)
10012dd4:	e59b3008 	ldr	r3, [fp, #8]
10012dd8:	e1550003 	cmp	r5, r3
10012ddc:	da000000 	ble	10012de4 <print_number+0x178>
        precision = i;
10012de0:	e58b5008 	str	r5, [fp, #8]
    size -= precision;
10012de4:	e59b3008 	ldr	r3, [fp, #8]
10012de8:	e0634004 	rsb	r4, r3, r4
#else
    size -= i;
#endif

    if (!(type&(ZEROPAD | LEFT)))
10012dec:	e59b300c 	ldr	r3, [fp, #12]
10012df0:	e2033011 	and	r3, r3, #17
10012df4:	e3530000 	cmp	r3, #0
10012df8:	1a000014 	bne	10012e50 <print_number+0x1e4>
    {
        if ((sign)&&(size>0))
10012dfc:	e55b3015 	ldrb	r3, [fp, #-21]
10012e00:	e3530000 	cmp	r3, #0
10012e04:	0a000002 	beq	10012e14 <print_number+0x1a8>
10012e08:	e3540000 	cmp	r4, #0
10012e0c:	da000000 	ble	10012e14 <print_number+0x1a8>
            size--;
10012e10:	e2444001 	sub	r4, r4, #1

        while (size-->0)
10012e14:	ea000009 	b	10012e40 <print_number+0x1d4>
        {
            if (buf <= end)
10012e18:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
10012e1c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
10012e20:	e1520003 	cmp	r2, r3
10012e24:	8a000002 	bhi	10012e34 <print_number+0x1c8>
                *buf = ' ';
10012e28:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012e2c:	e3a02020 	mov	r2, #32
10012e30:	e5c32000 	strb	r2, [r3]
            ++ buf;
10012e34:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012e38:	e2833001 	add	r3, r3, #1
10012e3c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
    if (!(type&(ZEROPAD | LEFT)))
    {
        if ((sign)&&(size>0))
            size--;

        while (size-->0)
10012e40:	e1a03004 	mov	r3, r4
10012e44:	e2434001 	sub	r4, r3, #1
10012e48:	e3530000 	cmp	r3, #0
10012e4c:	cafffff1 	bgt	10012e18 <print_number+0x1ac>
                *buf = ' ';
            ++ buf;
        }
    }

    if (sign)
10012e50:	e55b3015 	ldrb	r3, [fp, #-21]
10012e54:	e3530000 	cmp	r3, #0
10012e58:	0a00000a 	beq	10012e88 <print_number+0x21c>
    {
        if (buf <= end)
10012e5c:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
10012e60:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
10012e64:	e1520003 	cmp	r2, r3
10012e68:	8a000003 	bhi	10012e7c <print_number+0x210>
        {
            *buf = sign;
10012e6c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012e70:	e55b2015 	ldrb	r2, [fp, #-21]
10012e74:	e5c32000 	strb	r2, [r3]
            -- size;
10012e78:	e2444001 	sub	r4, r4, #1
        }
        ++ buf;
10012e7c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012e80:	e2833001 	add	r3, r3, #1
10012e84:	e50b3048 	str	r3, [fp, #-72]	; 0x48
        }
    }
#endif

    /* no align to the left */
    if (!(type & LEFT))
10012e88:	e59b300c 	ldr	r3, [fp, #12]
10012e8c:	e2033010 	and	r3, r3, #16
10012e90:	e3530000 	cmp	r3, #0
10012e94:	1a00000e 	bne	10012ed4 <print_number+0x268>
    {
        while (size-- > 0)
10012e98:	ea000009 	b	10012ec4 <print_number+0x258>
        {
            if (buf <= end)
10012e9c:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
10012ea0:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
10012ea4:	e1520003 	cmp	r2, r3
10012ea8:	8a000002 	bhi	10012eb8 <print_number+0x24c>
                *buf = c;
10012eac:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012eb0:	e55b201d 	ldrb	r2, [fp, #-29]
10012eb4:	e5c32000 	strb	r2, [r3]
            ++ buf;
10012eb8:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012ebc:	e2833001 	add	r3, r3, #1
10012ec0:	e50b3048 	str	r3, [fp, #-72]	; 0x48
#endif

    /* no align to the left */
    if (!(type & LEFT))
    {
        while (size-- > 0)
10012ec4:	e1a03004 	mov	r3, r4
10012ec8:	e2434001 	sub	r4, r3, #1
10012ecc:	e3530000 	cmp	r3, #0
10012ed0:	cafffff1 	bgt	10012e9c <print_number+0x230>
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
10012ed4:	ea000009 	b	10012f00 <print_number+0x294>
    {
        if (buf <= end)
10012ed8:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
10012edc:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
10012ee0:	e1520003 	cmp	r2, r3
10012ee4:	8a000002 	bhi	10012ef4 <print_number+0x288>
            *buf = '0';
10012ee8:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012eec:	e3a02030 	mov	r2, #48	; 0x30
10012ef0:	e5c32000 	strb	r2, [r3]
        ++ buf;
10012ef4:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012ef8:	e2833001 	add	r3, r3, #1
10012efc:	e50b3048 	str	r3, [fp, #-72]	; 0x48
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
10012f00:	e59b3008 	ldr	r3, [fp, #8]
10012f04:	e2432001 	sub	r2, r3, #1
10012f08:	e58b2008 	str	r2, [fp, #8]
10012f0c:	e1530005 	cmp	r3, r5
10012f10:	cafffff0 	bgt	10012ed8 <print_number+0x26c>
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
10012f14:	ea00000b 	b	10012f48 <print_number+0x2dc>
    {
        if (buf <= end)
10012f18:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
10012f1c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
10012f20:	e1520003 	cmp	r2, r3
10012f24:	8a000004 	bhi	10012f3c <print_number+0x2d0>
            *buf = tmp[i];
10012f28:	e24b3014 	sub	r3, fp, #20
10012f2c:	e0833005 	add	r3, r3, r5
10012f30:	e553202c 	ldrb	r2, [r3, #-44]	; 0x2c
10012f34:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012f38:	e5c32000 	strb	r2, [r3]
        ++ buf;
10012f3c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012f40:	e2833001 	add	r3, r3, #1
10012f44:	e50b3048 	str	r3, [fp, #-72]	; 0x48
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
10012f48:	e1a03005 	mov	r3, r5
10012f4c:	e2435001 	sub	r5, r3, #1
10012f50:	e3530000 	cmp	r3, #0
10012f54:	caffffef 	bgt	10012f18 <print_number+0x2ac>
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
10012f58:	ea000009 	b	10012f84 <print_number+0x318>
    {
        if (buf <= end)
10012f5c:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
10012f60:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
10012f64:	e1520003 	cmp	r2, r3
10012f68:	8a000002 	bhi	10012f78 <print_number+0x30c>
            *buf = ' ';
10012f6c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012f70:	e3a02020 	mov	r2, #32
10012f74:	e5c32000 	strb	r2, [r3]
        ++ buf;
10012f78:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10012f7c:	e2833001 	add	r3, r3, #1
10012f80:	e50b3048 	str	r3, [fp, #-72]	; 0x48
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
10012f84:	e1a03004 	mov	r3, r4
10012f88:	e2434001 	sub	r4, r3, #1
10012f8c:	e3530000 	cmp	r3, #0
10012f90:	cafffff1 	bgt	10012f5c <print_number+0x2f0>
        if (buf <= end)
            *buf = ' ';
        ++ buf;
    }

    return buf;
10012f94:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
}
10012f98:	e1a00003 	mov	r0, r3
10012f9c:	e24bd010 	sub	sp, fp, #16
10012fa0:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

10012fa4 <rt_vsnprintf>:

rt_int32_t rt_vsnprintf(char       *buf,
                        rt_size_t   size,
                        const char *fmt,
                        va_list     args)
{
10012fa4:	e92d4800 	push	{fp, lr}
10012fa8:	e28db004 	add	fp, sp, #4
10012fac:	e24dd050 	sub	sp, sp, #80	; 0x50
10012fb0:	e50b0038 	str	r0, [fp, #-56]	; 0x38
10012fb4:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
10012fb8:	e50b2040 	str	r2, [fp, #-64]	; 0x40
10012fbc:	e50b3044 	str	r3, [fp, #-68]	; 0x44

#ifdef RT_PRINTF_PRECISION
    int precision;      /* min. # of digits for integers and max for a string */
#endif

    str = buf;
10012fc0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10012fc4:	e50b3018 	str	r3, [fp, #-24]
    end = buf + size - 1;
10012fc8:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10012fcc:	e2433001 	sub	r3, r3, #1
10012fd0:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
10012fd4:	e0823003 	add	r3, r2, r3
10012fd8:	e50b301c 	str	r3, [fp, #-28]

    /* Make sure end is always >= buf */
    if (end < buf)
10012fdc:	e51b201c 	ldr	r2, [fp, #-28]
10012fe0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10012fe4:	e1520003 	cmp	r2, r3
10012fe8:	2a000005 	bcs	10013004 <rt_vsnprintf+0x60>
    {
        end  = ((char *)-1);
10012fec:	e3e03000 	mvn	r3, #0
10012ff0:	e50b301c 	str	r3, [fp, #-28]
        size = end - buf;
10012ff4:	e51b201c 	ldr	r2, [fp, #-28]
10012ff8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10012ffc:	e0633002 	rsb	r3, r3, r2
10013000:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
    }

    for (; *fmt ; ++fmt)
10013004:	ea000230 	b	100138cc <rt_vsnprintf+0x928>
    {
        if (*fmt != '%')
10013008:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001300c:	e5d33000 	ldrb	r3, [r3]
10013010:	e3530025 	cmp	r3, #37	; 0x25
10013014:	0a00000b 	beq	10013048 <rt_vsnprintf+0xa4>
        {
            if (str <= end)
10013018:	e51b2018 	ldr	r2, [fp, #-24]
1001301c:	e51b301c 	ldr	r3, [fp, #-28]
10013020:	e1520003 	cmp	r2, r3
10013024:	8a000003 	bhi	10013038 <rt_vsnprintf+0x94>
                *str = *fmt;
10013028:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001302c:	e5d32000 	ldrb	r2, [r3]
10013030:	e51b3018 	ldr	r3, [fp, #-24]
10013034:	e5c32000 	strb	r2, [r3]
            ++ str;
10013038:	e51b3018 	ldr	r3, [fp, #-24]
1001303c:	e2833001 	add	r3, r3, #1
10013040:	e50b3018 	str	r3, [fp, #-24]
            continue;
10013044:	ea00021d 	b	100138c0 <rt_vsnprintf+0x91c>
        }

        /* process flags */
        flags = 0;
10013048:	e3a03000 	mov	r3, #0
1001304c:	e54b3022 	strb	r3, [fp, #-34]	; 0x22

        while (1)
        {
            /* skips the first '%' also */
            ++ fmt;
10013050:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013054:	e2833001 	add	r3, r3, #1
10013058:	e50b3040 	str	r3, [fp, #-64]	; 0x40
            if (*fmt == '-') flags |= LEFT;
1001305c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013060:	e5d33000 	ldrb	r3, [r3]
10013064:	e353002d 	cmp	r3, #45	; 0x2d
10013068:	1a000003 	bne	1001307c <rt_vsnprintf+0xd8>
1001306c:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
10013070:	e3833010 	orr	r3, r3, #16
10013074:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
10013078:	ea000028 	b	10013120 <rt_vsnprintf+0x17c>
            else if (*fmt == '+') flags |= PLUS;
1001307c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013080:	e5d33000 	ldrb	r3, [r3]
10013084:	e353002b 	cmp	r3, #43	; 0x2b
10013088:	1a000003 	bne	1001309c <rt_vsnprintf+0xf8>
1001308c:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
10013090:	e3833004 	orr	r3, r3, #4
10013094:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
10013098:	ea000020 	b	10013120 <rt_vsnprintf+0x17c>
            else if (*fmt == ' ') flags |= SPACE;
1001309c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100130a0:	e5d33000 	ldrb	r3, [r3]
100130a4:	e3530020 	cmp	r3, #32
100130a8:	1a000003 	bne	100130bc <rt_vsnprintf+0x118>
100130ac:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
100130b0:	e3833008 	orr	r3, r3, #8
100130b4:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
100130b8:	ea000018 	b	10013120 <rt_vsnprintf+0x17c>
            else if (*fmt == '#') flags |= SPECIAL;
100130bc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100130c0:	e5d33000 	ldrb	r3, [r3]
100130c4:	e3530023 	cmp	r3, #35	; 0x23
100130c8:	1a000003 	bne	100130dc <rt_vsnprintf+0x138>
100130cc:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
100130d0:	e3833020 	orr	r3, r3, #32
100130d4:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
100130d8:	ea000010 	b	10013120 <rt_vsnprintf+0x17c>
            else if (*fmt == '0') flags |= ZEROPAD;
100130dc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100130e0:	e5d33000 	ldrb	r3, [r3]
100130e4:	e3530030 	cmp	r3, #48	; 0x30
100130e8:	1a000003 	bne	100130fc <rt_vsnprintf+0x158>
100130ec:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
100130f0:	e3833001 	orr	r3, r3, #1
100130f4:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
100130f8:	ea000008 	b	10013120 <rt_vsnprintf+0x17c>
            else break;
100130fc:	e1a00000 	nop			; (mov r0, r0)
        }

        /* get field width */
        field_width = -1;
10013100:	e3e03000 	mvn	r3, #0
10013104:	e50b3028 	str	r3, [fp, #-40]	; 0x28
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
10013108:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001310c:	e5d33000 	ldrb	r3, [r3]
10013110:	e2433030 	sub	r3, r3, #48	; 0x30
10013114:	e3530009 	cmp	r3, #9
10013118:	8a000006 	bhi	10013138 <rt_vsnprintf+0x194>
1001311c:	ea000000 	b	10013124 <rt_vsnprintf+0x180>
            else if (*fmt == '+') flags |= PLUS;
            else if (*fmt == ' ') flags |= SPACE;
            else if (*fmt == '#') flags |= SPECIAL;
            else if (*fmt == '0') flags |= ZEROPAD;
            else break;
        }
10013120:	eaffffca 	b	10013050 <rt_vsnprintf+0xac>

        /* get field width */
        field_width = -1;
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
10013124:	e24b3040 	sub	r3, fp, #64	; 0x40
10013128:	e1a00003 	mov	r0, r3
1001312c:	ebfffeb1 	bl	10012bf8 <skip_atoi>
10013130:	e50b0028 	str	r0, [fp, #-40]	; 0x28
10013134:	ea000014 	b	1001318c <rt_vsnprintf+0x1e8>
        else if (*fmt == '*')
10013138:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001313c:	e5d33000 	ldrb	r3, [r3]
10013140:	e353002a 	cmp	r3, #42	; 0x2a
10013144:	1a000010 	bne	1001318c <rt_vsnprintf+0x1e8>
        {
            ++ fmt;
10013148:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001314c:	e2833001 	add	r3, r3, #1
10013150:	e50b3040 	str	r3, [fp, #-64]	; 0x40
            /* it's the next argument */
            field_width = va_arg(args, int);
10013154:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
10013158:	e2832004 	add	r2, r3, #4
1001315c:	e50b2044 	str	r2, [fp, #-68]	; 0x44
10013160:	e5933000 	ldr	r3, [r3]
10013164:	e50b3028 	str	r3, [fp, #-40]	; 0x28
            if (field_width < 0)
10013168:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001316c:	e3530000 	cmp	r3, #0
10013170:	aa000005 	bge	1001318c <rt_vsnprintf+0x1e8>
            {
                field_width = -field_width;
10013174:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013178:	e2633000 	rsb	r3, r3, #0
1001317c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
                flags |= LEFT;
10013180:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
10013184:	e3833010 	orr	r3, r3, #16
10013188:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
            }
        }

#ifdef RT_PRINTF_PRECISION
        /* get the precision */
        precision = -1;
1001318c:	e3e03000 	mvn	r3, #0
10013190:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
        if (*fmt == '.')
10013194:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013198:	e5d33000 	ldrb	r3, [r3]
1001319c:	e353002e 	cmp	r3, #46	; 0x2e
100131a0:	1a00001d 	bne	1001321c <rt_vsnprintf+0x278>
        {
            ++ fmt;
100131a4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100131a8:	e2833001 	add	r3, r3, #1
100131ac:	e50b3040 	str	r3, [fp, #-64]	; 0x40
            if (isdigit(*fmt)) precision = skip_atoi(&fmt);
100131b0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100131b4:	e5d33000 	ldrb	r3, [r3]
100131b8:	e2433030 	sub	r3, r3, #48	; 0x30
100131bc:	e3530009 	cmp	r3, #9
100131c0:	8a000004 	bhi	100131d8 <rt_vsnprintf+0x234>
100131c4:	e24b3040 	sub	r3, fp, #64	; 0x40
100131c8:	e1a00003 	mov	r0, r3
100131cc:	ebfffe89 	bl	10012bf8 <skip_atoi>
100131d0:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
100131d4:	ea00000b 	b	10013208 <rt_vsnprintf+0x264>
            else if (*fmt == '*')
100131d8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100131dc:	e5d33000 	ldrb	r3, [r3]
100131e0:	e353002a 	cmp	r3, #42	; 0x2a
100131e4:	1a000007 	bne	10013208 <rt_vsnprintf+0x264>
            {
                ++ fmt;
100131e8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100131ec:	e2833001 	add	r3, r3, #1
100131f0:	e50b3040 	str	r3, [fp, #-64]	; 0x40
                /* it's the next argument */
                precision = va_arg(args, int);
100131f4:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
100131f8:	e2832004 	add	r2, r3, #4
100131fc:	e50b2044 	str	r2, [fp, #-68]	; 0x44
10013200:	e5933000 	ldr	r3, [r3]
10013204:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
            }
            if (precision < 0) precision = 0;
10013208:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1001320c:	e3530000 	cmp	r3, #0
10013210:	aa000001 	bge	1001321c <rt_vsnprintf+0x278>
10013214:	e3a03000 	mov	r3, #0
10013218:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
        }
#endif
        /* get the conversion qualifier */
        qualifier = 0;
1001321c:	e3a03000 	mov	r3, #0
10013220:	e54b3023 	strb	r3, [fp, #-35]	; 0x23
#ifdef RT_PRINTF_LONGLONG
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
10013224:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013228:	e5d33000 	ldrb	r3, [r3]
1001322c:	e3530068 	cmp	r3, #104	; 0x68
10013230:	0a000007 	beq	10013254 <rt_vsnprintf+0x2b0>
10013234:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013238:	e5d33000 	ldrb	r3, [r3]
1001323c:	e353006c 	cmp	r3, #108	; 0x6c
10013240:	0a000003 	beq	10013254 <rt_vsnprintf+0x2b0>
10013244:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013248:	e5d33000 	ldrb	r3, [r3]
1001324c:	e353004c 	cmp	r3, #76	; 0x4c
10013250:	1a000011 	bne	1001329c <rt_vsnprintf+0x2f8>
#else
        if (*fmt == 'h' || *fmt == 'l')
#endif
        {
            qualifier = *fmt;
10013254:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013258:	e5d33000 	ldrb	r3, [r3]
1001325c:	e54b3023 	strb	r3, [fp, #-35]	; 0x23
            ++ fmt;
10013260:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013264:	e2833001 	add	r3, r3, #1
10013268:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifdef RT_PRINTF_LONGLONG
            if (qualifier == 'l' && *fmt == 'l')
1001326c:	e55b3023 	ldrb	r3, [fp, #-35]	; 0x23
10013270:	e353006c 	cmp	r3, #108	; 0x6c
10013274:	1a000008 	bne	1001329c <rt_vsnprintf+0x2f8>
10013278:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001327c:	e5d33000 	ldrb	r3, [r3]
10013280:	e353006c 	cmp	r3, #108	; 0x6c
10013284:	1a000004 	bne	1001329c <rt_vsnprintf+0x2f8>
            {
                qualifier = 'L';
10013288:	e3a0304c 	mov	r3, #76	; 0x4c
1001328c:	e54b3023 	strb	r3, [fp, #-35]	; 0x23
                ++ fmt;
10013290:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013294:	e2833001 	add	r3, r3, #1
10013298:	e50b3040 	str	r3, [fp, #-64]	; 0x40
            }
#endif
        }

        /* the default base */
        base = 10;
1001329c:	e3a0300a 	mov	r3, #10
100132a0:	e54b3021 	strb	r3, [fp, #-33]	; 0x21

        switch (*fmt)
100132a4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100132a8:	e5d33000 	ldrb	r3, [r3]
100132ac:	e2433025 	sub	r3, r3, #37	; 0x25
100132b0:	e3530053 	cmp	r3, #83	; 0x53
100132b4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
100132b8:	ea000112 	b	10013708 <rt_vsnprintf+0x764>
100132bc:	100136a8 	.word	0x100136a8
100132c0:	10013708 	.word	0x10013708
100132c4:	10013708 	.word	0x10013708
100132c8:	10013708 	.word	0x10013708
100132cc:	10013708 	.word	0x10013708
100132d0:	10013708 	.word	0x10013708
100132d4:	10013708 	.word	0x10013708
100132d8:	10013708 	.word	0x10013708
100132dc:	10013708 	.word	0x10013708
100132e0:	10013708 	.word	0x10013708
100132e4:	10013708 	.word	0x10013708
100132e8:	10013708 	.word	0x10013708
100132ec:	10013708 	.word	0x10013708
100132f0:	10013708 	.word	0x10013708
100132f4:	10013708 	.word	0x10013708
100132f8:	10013708 	.word	0x10013708
100132fc:	10013708 	.word	0x10013708
10013300:	10013708 	.word	0x10013708
10013304:	10013708 	.word	0x10013708
10013308:	10013708 	.word	0x10013708
1001330c:	10013708 	.word	0x10013708
10013310:	10013708 	.word	0x10013708
10013314:	10013708 	.word	0x10013708
10013318:	10013708 	.word	0x10013708
1001331c:	10013708 	.word	0x10013708
10013320:	10013708 	.word	0x10013708
10013324:	10013708 	.word	0x10013708
10013328:	10013708 	.word	0x10013708
1001332c:	10013708 	.word	0x10013708
10013330:	10013708 	.word	0x10013708
10013334:	10013708 	.word	0x10013708
10013338:	10013708 	.word	0x10013708
1001333c:	10013708 	.word	0x10013708
10013340:	10013708 	.word	0x10013708
10013344:	10013708 	.word	0x10013708
10013348:	10013708 	.word	0x10013708
1001334c:	10013708 	.word	0x10013708
10013350:	10013708 	.word	0x10013708
10013354:	10013708 	.word	0x10013708
10013358:	10013708 	.word	0x10013708
1001335c:	10013708 	.word	0x10013708
10013360:	10013708 	.word	0x10013708
10013364:	10013708 	.word	0x10013708
10013368:	10013708 	.word	0x10013708
1001336c:	10013708 	.word	0x10013708
10013370:	10013708 	.word	0x10013708
10013374:	10013708 	.word	0x10013708
10013378:	10013708 	.word	0x10013708
1001337c:	10013708 	.word	0x10013708
10013380:	10013708 	.word	0x10013708
10013384:	10013708 	.word	0x10013708
10013388:	100136e0 	.word	0x100136e0
1001338c:	10013708 	.word	0x10013708
10013390:	10013708 	.word	0x10013708
10013394:	10013708 	.word	0x10013708
10013398:	10013708 	.word	0x10013708
1001339c:	10013708 	.word	0x10013708
100133a0:	10013708 	.word	0x10013708
100133a4:	10013708 	.word	0x10013708
100133a8:	10013708 	.word	0x10013708
100133ac:	10013708 	.word	0x10013708
100133b0:	10013708 	.word	0x10013708
100133b4:	1001340c 	.word	0x1001340c
100133b8:	100136f8 	.word	0x100136f8
100133bc:	10013708 	.word	0x10013708
100133c0:	10013708 	.word	0x10013708
100133c4:	10013708 	.word	0x10013708
100133c8:	10013708 	.word	0x10013708
100133cc:	100136f8 	.word	0x100136f8
100133d0:	10013708 	.word	0x10013708
100133d4:	10013708 	.word	0x10013708
100133d8:	10013708 	.word	0x10013708
100133dc:	10013708 	.word	0x10013708
100133e0:	10013708 	.word	0x10013708
100133e4:	100136d4 	.word	0x100136d4
100133e8:	10013640 	.word	0x10013640
100133ec:	10013708 	.word	0x10013708
100133f0:	10013708 	.word	0x10013708
100133f4:	100134e4 	.word	0x100134e4
100133f8:	10013708 	.word	0x10013708
100133fc:	10013780 	.word	0x10013780
10013400:	10013708 	.word	0x10013708
10013404:	10013708 	.word	0x10013708
10013408:	100136ec 	.word	0x100136ec
        {
        case 'c':
            if (!(flags & LEFT))
1001340c:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
10013410:	e2033010 	and	r3, r3, #16
10013414:	e3530000 	cmp	r3, #0
10013418:	1a000010 	bne	10013460 <rt_vsnprintf+0x4bc>
            {
                while (--field_width > 0)
1001341c:	ea000009 	b	10013448 <rt_vsnprintf+0x4a4>
                {
                    if (str <= end) *str = ' ';
10013420:	e51b2018 	ldr	r2, [fp, #-24]
10013424:	e51b301c 	ldr	r3, [fp, #-28]
10013428:	e1520003 	cmp	r2, r3
1001342c:	8a000002 	bhi	1001343c <rt_vsnprintf+0x498>
10013430:	e51b3018 	ldr	r3, [fp, #-24]
10013434:	e3a02020 	mov	r2, #32
10013438:	e5c32000 	strb	r2, [r3]
                    ++ str;
1001343c:	e51b3018 	ldr	r3, [fp, #-24]
10013440:	e2833001 	add	r3, r3, #1
10013444:	e50b3018 	str	r3, [fp, #-24]
        switch (*fmt)
        {
        case 'c':
            if (!(flags & LEFT))
            {
                while (--field_width > 0)
10013448:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001344c:	e2433001 	sub	r3, r3, #1
10013450:	e50b3028 	str	r3, [fp, #-40]	; 0x28
10013454:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013458:	e3530000 	cmp	r3, #0
1001345c:	caffffef 	bgt	10013420 <rt_vsnprintf+0x47c>
                    ++ str;
                }
            }

            /* get character */
            c = (rt_uint8_t)va_arg(args, int);
10013460:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
10013464:	e2832004 	add	r2, r3, #4
10013468:	e50b2044 	str	r2, [fp, #-68]	; 0x44
1001346c:	e5933000 	ldr	r3, [r3]
10013470:	e54b302d 	strb	r3, [fp, #-45]	; 0x2d
            if (str <= end) *str = c;
10013474:	e51b2018 	ldr	r2, [fp, #-24]
10013478:	e51b301c 	ldr	r3, [fp, #-28]
1001347c:	e1520003 	cmp	r2, r3
10013480:	8a000002 	bhi	10013490 <rt_vsnprintf+0x4ec>
10013484:	e51b3018 	ldr	r3, [fp, #-24]
10013488:	e55b202d 	ldrb	r2, [fp, #-45]	; 0x2d
1001348c:	e5c32000 	strb	r2, [r3]
            ++ str;
10013490:	e51b3018 	ldr	r3, [fp, #-24]
10013494:	e2833001 	add	r3, r3, #1
10013498:	e50b3018 	str	r3, [fp, #-24]

            /* put width */
            while (--field_width > 0)
1001349c:	ea000009 	b	100134c8 <rt_vsnprintf+0x524>
            {
                if (str <= end) *str = ' ';
100134a0:	e51b2018 	ldr	r2, [fp, #-24]
100134a4:	e51b301c 	ldr	r3, [fp, #-28]
100134a8:	e1520003 	cmp	r2, r3
100134ac:	8a000002 	bhi	100134bc <rt_vsnprintf+0x518>
100134b0:	e51b3018 	ldr	r3, [fp, #-24]
100134b4:	e3a02020 	mov	r2, #32
100134b8:	e5c32000 	strb	r2, [r3]
                ++ str;
100134bc:	e51b3018 	ldr	r3, [fp, #-24]
100134c0:	e2833001 	add	r3, r3, #1
100134c4:	e50b3018 	str	r3, [fp, #-24]
            c = (rt_uint8_t)va_arg(args, int);
            if (str <= end) *str = c;
            ++ str;

            /* put width */
            while (--field_width > 0)
100134c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100134cc:	e2433001 	sub	r3, r3, #1
100134d0:	e50b3028 	str	r3, [fp, #-40]	; 0x28
100134d4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100134d8:	e3530000 	cmp	r3, #0
100134dc:	caffffef 	bgt	100134a0 <rt_vsnprintf+0x4fc>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
100134e0:	ea0000f6 	b	100138c0 <rt_vsnprintf+0x91c>

        case 's':
            s = va_arg(args, char *);
100134e4:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
100134e8:	e2832004 	add	r2, r3, #4
100134ec:	e50b2044 	str	r2, [fp, #-68]	; 0x44
100134f0:	e5933000 	ldr	r3, [r3]
100134f4:	e50b3020 	str	r3, [fp, #-32]
            if (!s) s = "(NULL)";
100134f8:	e51b3020 	ldr	r3, [fp, #-32]
100134fc:	e3530000 	cmp	r3, #0
10013500:	1a000002 	bne	10013510 <rt_vsnprintf+0x56c>
10013504:	e30337a4 	movw	r3, #14244	; 0x37a4
10013508:	e3413003 	movt	r3, #4099	; 0x1003
1001350c:	e50b3020 	str	r3, [fp, #-32]

            len = rt_strlen(s);
10013510:	e51b0020 	ldr	r0, [fp, #-32]
10013514:	ebfffd44 	bl	10012a2c <rt_strlen>
10013518:	e1a03000 	mov	r3, r0
1001351c:	e50b3014 	str	r3, [fp, #-20]
#ifdef RT_PRINTF_PRECISION
            if (precision > 0 && len > precision) len = precision;
10013520:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10013524:	e3530000 	cmp	r3, #0
10013528:	da000005 	ble	10013544 <rt_vsnprintf+0x5a0>
1001352c:	e51b2014 	ldr	r2, [fp, #-20]
10013530:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10013534:	e1520003 	cmp	r2, r3
10013538:	da000001 	ble	10013544 <rt_vsnprintf+0x5a0>
1001353c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10013540:	e50b3014 	str	r3, [fp, #-20]
#endif

            if (!(flags & LEFT))
10013544:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
10013548:	e2033010 	and	r3, r3, #16
1001354c:	e3530000 	cmp	r3, #0
10013550:	1a000010 	bne	10013598 <rt_vsnprintf+0x5f4>
            {
                while (len < field_width--)
10013554:	ea000009 	b	10013580 <rt_vsnprintf+0x5dc>
                {
                    if (str <= end) *str = ' ';
10013558:	e51b2018 	ldr	r2, [fp, #-24]
1001355c:	e51b301c 	ldr	r3, [fp, #-28]
10013560:	e1520003 	cmp	r2, r3
10013564:	8a000002 	bhi	10013574 <rt_vsnprintf+0x5d0>
10013568:	e51b3018 	ldr	r3, [fp, #-24]
1001356c:	e3a02020 	mov	r2, #32
10013570:	e5c32000 	strb	r2, [r3]
                    ++ str;
10013574:	e51b3018 	ldr	r3, [fp, #-24]
10013578:	e2833001 	add	r3, r3, #1
1001357c:	e50b3018 	str	r3, [fp, #-24]
            if (precision > 0 && len > precision) len = precision;
#endif

            if (!(flags & LEFT))
            {
                while (len < field_width--)
10013580:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013584:	e2432001 	sub	r2, r3, #1
10013588:	e50b2028 	str	r2, [fp, #-40]	; 0x28
1001358c:	e51b2014 	ldr	r2, [fp, #-20]
10013590:	e1530002 	cmp	r3, r2
10013594:	caffffef 	bgt	10013558 <rt_vsnprintf+0x5b4>
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
10013598:	e3a03000 	mov	r3, #0
1001359c:	e50b3010 	str	r3, [fp, #-16]
100135a0:	ea000010 	b	100135e8 <rt_vsnprintf+0x644>
            {
                if (str <= end) *str = *s;
100135a4:	e51b2018 	ldr	r2, [fp, #-24]
100135a8:	e51b301c 	ldr	r3, [fp, #-28]
100135ac:	e1520003 	cmp	r2, r3
100135b0:	8a000003 	bhi	100135c4 <rt_vsnprintf+0x620>
100135b4:	e51b3020 	ldr	r3, [fp, #-32]
100135b8:	e5d32000 	ldrb	r2, [r3]
100135bc:	e51b3018 	ldr	r3, [fp, #-24]
100135c0:	e5c32000 	strb	r2, [r3]
                ++ str;
100135c4:	e51b3018 	ldr	r3, [fp, #-24]
100135c8:	e2833001 	add	r3, r3, #1
100135cc:	e50b3018 	str	r3, [fp, #-24]
                ++ s;
100135d0:	e51b3020 	ldr	r3, [fp, #-32]
100135d4:	e2833001 	add	r3, r3, #1
100135d8:	e50b3020 	str	r3, [fp, #-32]
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
100135dc:	e51b3010 	ldr	r3, [fp, #-16]
100135e0:	e2833001 	add	r3, r3, #1
100135e4:	e50b3010 	str	r3, [fp, #-16]
100135e8:	e51b2010 	ldr	r2, [fp, #-16]
100135ec:	e51b3014 	ldr	r3, [fp, #-20]
100135f0:	e1520003 	cmp	r2, r3
100135f4:	baffffea 	blt	100135a4 <rt_vsnprintf+0x600>
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
100135f8:	ea000009 	b	10013624 <rt_vsnprintf+0x680>
            {
                if (str <= end) *str = ' ';
100135fc:	e51b2018 	ldr	r2, [fp, #-24]
10013600:	e51b301c 	ldr	r3, [fp, #-28]
10013604:	e1520003 	cmp	r2, r3
10013608:	8a000002 	bhi	10013618 <rt_vsnprintf+0x674>
1001360c:	e51b3018 	ldr	r3, [fp, #-24]
10013610:	e3a02020 	mov	r2, #32
10013614:	e5c32000 	strb	r2, [r3]
                ++ str;
10013618:	e51b3018 	ldr	r3, [fp, #-24]
1001361c:	e2833001 	add	r3, r3, #1
10013620:	e50b3018 	str	r3, [fp, #-24]
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
10013624:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013628:	e2432001 	sub	r2, r3, #1
1001362c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
10013630:	e51b2014 	ldr	r2, [fp, #-20]
10013634:	e1530002 	cmp	r3, r2
10013638:	caffffef 	bgt	100135fc <rt_vsnprintf+0x658>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
1001363c:	ea00009f 	b	100138c0 <rt_vsnprintf+0x91c>

        case 'p':
            if (field_width == -1)
10013640:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013644:	e3730001 	cmn	r3, #1
10013648:	1a000004 	bne	10013660 <rt_vsnprintf+0x6bc>
            {
                field_width = sizeof(void *) << 1;
1001364c:	e3a03008 	mov	r3, #8
10013650:	e50b3028 	str	r3, [fp, #-40]	; 0x28
                flags |= ZEROPAD;
10013654:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
10013658:	e3833001 	orr	r3, r3, #1
1001365c:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
                               (long)va_arg(args, void *),
10013660:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
10013664:	e2832004 	add	r2, r3, #4
10013668:	e50b2044 	str	r2, [fp, #-68]	; 0x44
1001366c:	e5933000 	ldr	r3, [r3]
            {
                field_width = sizeof(void *) << 1;
                flags |= ZEROPAD;
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
10013670:	e1a0c003 	mov	ip, r3
10013674:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
10013678:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1001367c:	e58d2000 	str	r2, [sp]
10013680:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
10013684:	e58d2004 	str	r2, [sp, #4]
10013688:	e58d3008 	str	r3, [sp, #8]
1001368c:	e51b0018 	ldr	r0, [fp, #-24]
10013690:	e51b101c 	ldr	r1, [fp, #-28]
10013694:	e1a0200c 	mov	r2, ip
10013698:	e3a03010 	mov	r3, #16
1001369c:	ebfffd72 	bl	10012c6c <print_number>
100136a0:	e50b0018 	str	r0, [fp, #-24]
#else
            str = print_number(str, end,
                               (long)va_arg(args, void *),
                               16, field_width, flags);
#endif
            continue;
100136a4:	ea000085 	b	100138c0 <rt_vsnprintf+0x91c>

        case '%':
            if (str <= end) *str = '%';
100136a8:	e51b2018 	ldr	r2, [fp, #-24]
100136ac:	e51b301c 	ldr	r3, [fp, #-28]
100136b0:	e1520003 	cmp	r2, r3
100136b4:	8a000002 	bhi	100136c4 <rt_vsnprintf+0x720>
100136b8:	e51b3018 	ldr	r3, [fp, #-24]
100136bc:	e3a02025 	mov	r2, #37	; 0x25
100136c0:	e5c32000 	strb	r2, [r3]
            ++ str;
100136c4:	e51b3018 	ldr	r3, [fp, #-24]
100136c8:	e2833001 	add	r3, r3, #1
100136cc:	e50b3018 	str	r3, [fp, #-24]
            continue;
100136d0:	ea00007a 	b	100138c0 <rt_vsnprintf+0x91c>

            /* integer number formats - set up the flags and "break" */
        case 'o':
            base = 8;
100136d4:	e3a03008 	mov	r3, #8
100136d8:	e54b3021 	strb	r3, [fp, #-33]	; 0x21
            break;
100136dc:	ea000028 	b	10013784 <rt_vsnprintf+0x7e0>

        case 'X':
            flags |= LARGE;
100136e0:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
100136e4:	e3833040 	orr	r3, r3, #64	; 0x40
100136e8:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
        case 'x':
            base = 16;
100136ec:	e3a03010 	mov	r3, #16
100136f0:	e54b3021 	strb	r3, [fp, #-33]	; 0x21
            break;
100136f4:	ea000022 	b	10013784 <rt_vsnprintf+0x7e0>

        case 'd':
        case 'i':
            flags |= SIGN;
100136f8:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
100136fc:	e3833002 	orr	r3, r3, #2
10013700:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
        case 'u':
            break;
10013704:	ea00001d 	b	10013780 <rt_vsnprintf+0x7dc>

        default:
            if (str <= end) *str = '%';
10013708:	e51b2018 	ldr	r2, [fp, #-24]
1001370c:	e51b301c 	ldr	r3, [fp, #-28]
10013710:	e1520003 	cmp	r2, r3
10013714:	8a000002 	bhi	10013724 <rt_vsnprintf+0x780>
10013718:	e51b3018 	ldr	r3, [fp, #-24]
1001371c:	e3a02025 	mov	r2, #37	; 0x25
10013720:	e5c32000 	strb	r2, [r3]
            ++ str;
10013724:	e51b3018 	ldr	r3, [fp, #-24]
10013728:	e2833001 	add	r3, r3, #1
1001372c:	e50b3018 	str	r3, [fp, #-24]

            if (*fmt)
10013730:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013734:	e5d33000 	ldrb	r3, [r3]
10013738:	e3530000 	cmp	r3, #0
1001373c:	0a00000b 	beq	10013770 <rt_vsnprintf+0x7cc>
            {
                if (str <= end) *str = *fmt;
10013740:	e51b2018 	ldr	r2, [fp, #-24]
10013744:	e51b301c 	ldr	r3, [fp, #-28]
10013748:	e1520003 	cmp	r2, r3
1001374c:	8a000003 	bhi	10013760 <rt_vsnprintf+0x7bc>
10013750:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013754:	e5d32000 	ldrb	r2, [r3]
10013758:	e51b3018 	ldr	r3, [fp, #-24]
1001375c:	e5c32000 	strb	r2, [r3]
                ++ str;
10013760:	e51b3018 	ldr	r3, [fp, #-24]
10013764:	e2833001 	add	r3, r3, #1
10013768:	e50b3018 	str	r3, [fp, #-24]
            }
            else
            {
                -- fmt;
            }
            continue;
1001376c:	ea000053 	b	100138c0 <rt_vsnprintf+0x91c>
                if (str <= end) *str = *fmt;
                ++ str;
            }
            else
            {
                -- fmt;
10013770:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013774:	e2433001 	sub	r3, r3, #1
10013778:	e50b3040 	str	r3, [fp, #-64]	; 0x40
            }
            continue;
1001377c:	ea00004f 	b	100138c0 <rt_vsnprintf+0x91c>

        case 'd':
        case 'i':
            flags |= SIGN;
        case 'u':
            break;
10013780:	e1a00000 	nop			; (mov r0, r0)
            }
            continue;
        }

#ifdef RT_PRINTF_LONGLONG
        if (qualifier == 'L') num = va_arg(args, long long);
10013784:	e55b3023 	ldrb	r3, [fp, #-35]	; 0x23
10013788:	e353004c 	cmp	r3, #76	; 0x4c
1001378c:	1a000007 	bne	100137b0 <rt_vsnprintf+0x80c>
10013790:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
10013794:	e2833007 	add	r3, r3, #7
10013798:	e3c33007 	bic	r3, r3, #7
1001379c:	e2832008 	add	r2, r3, #8
100137a0:	e50b2044 	str	r2, [fp, #-68]	; 0x44
100137a4:	e1c320d0 	ldrd	r2, [r3]
100137a8:	e14b20fc 	strd	r2, [fp, #-12]
100137ac:	ea000035 	b	10013888 <rt_vsnprintf+0x8e4>
        else if (qualifier == 'l')
100137b0:	e55b3023 	ldrb	r3, [fp, #-35]	; 0x23
100137b4:	e353006c 	cmp	r3, #108	; 0x6c
100137b8:	1a00000f 	bne	100137fc <rt_vsnprintf+0x858>
#else
        if (qualifier == 'l')
#endif
        {
            num = va_arg(args, rt_uint32_t);
100137bc:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
100137c0:	e2832004 	add	r2, r3, #4
100137c4:	e50b2044 	str	r2, [fp, #-68]	; 0x44
100137c8:	e5933000 	ldr	r3, [r3]
100137cc:	e1a02003 	mov	r2, r3
100137d0:	e3a03000 	mov	r3, #0
100137d4:	e14b20fc 	strd	r2, [fp, #-12]
            if (flags & SIGN) num = (rt_int32_t)num;
100137d8:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
100137dc:	e2033002 	and	r3, r3, #2
100137e0:	e3530000 	cmp	r3, #0
100137e4:	0a000027 	beq	10013888 <rt_vsnprintf+0x8e4>
100137e8:	e51b300c 	ldr	r3, [fp, #-12]
100137ec:	e1a02003 	mov	r2, r3
100137f0:	e1a03fc2 	asr	r3, r2, #31
100137f4:	e14b20fc 	strd	r2, [fp, #-12]
100137f8:	ea000022 	b	10013888 <rt_vsnprintf+0x8e4>
        }
        else if (qualifier == 'h')
100137fc:	e55b3023 	ldrb	r3, [fp, #-35]	; 0x23
10013800:	e3530068 	cmp	r3, #104	; 0x68
10013804:	1a000010 	bne	1001384c <rt_vsnprintf+0x8a8>
        {
            num = (rt_uint16_t)va_arg(args, rt_int32_t);
10013808:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
1001380c:	e2832004 	add	r2, r3, #4
10013810:	e50b2044 	str	r2, [fp, #-68]	; 0x44
10013814:	e5933000 	ldr	r3, [r3]
10013818:	e6ff3073 	uxth	r3, r3
1001381c:	e6ff2073 	uxth	r2, r3
10013820:	e3a03000 	mov	r3, #0
10013824:	e14b20fc 	strd	r2, [fp, #-12]
            if (flags & SIGN) num = (rt_int16_t)num;
10013828:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
1001382c:	e2033002 	and	r3, r3, #2
10013830:	e3530000 	cmp	r3, #0
10013834:	0a000013 	beq	10013888 <rt_vsnprintf+0x8e4>
10013838:	e15b30bc 	ldrh	r3, [fp, #-12]
1001383c:	e6bf2073 	sxth	r2, r3
10013840:	e1a03fc2 	asr	r3, r2, #31
10013844:	e14b20fc 	strd	r2, [fp, #-12]
10013848:	ea00000e 	b	10013888 <rt_vsnprintf+0x8e4>
        }
        else
        {
            num = va_arg(args, rt_uint32_t);
1001384c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
10013850:	e2832004 	add	r2, r3, #4
10013854:	e50b2044 	str	r2, [fp, #-68]	; 0x44
10013858:	e5933000 	ldr	r3, [r3]
1001385c:	e1a02003 	mov	r2, r3
10013860:	e3a03000 	mov	r3, #0
10013864:	e14b20fc 	strd	r2, [fp, #-12]
            if (flags & SIGN) num = (rt_int32_t)num;
10013868:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
1001386c:	e2033002 	and	r3, r3, #2
10013870:	e3530000 	cmp	r3, #0
10013874:	0a000003 	beq	10013888 <rt_vsnprintf+0x8e4>
10013878:	e51b300c 	ldr	r3, [fp, #-12]
1001387c:	e1a02003 	mov	r2, r3
10013880:	e1a03fc2 	asr	r3, r2, #31
10013884:	e14b20fc 	strd	r2, [fp, #-12]
        }
#ifdef RT_PRINTF_PRECISION
        str = print_number(str, end, num, base, field_width, precision, flags);
10013888:	e51be00c 	ldr	lr, [fp, #-12]
1001388c:	e55bc021 	ldrb	ip, [fp, #-33]	; 0x21
10013890:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
10013894:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10013898:	e58d2000 	str	r2, [sp]
1001389c:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
100138a0:	e58d2004 	str	r2, [sp, #4]
100138a4:	e58d3008 	str	r3, [sp, #8]
100138a8:	e51b0018 	ldr	r0, [fp, #-24]
100138ac:	e51b101c 	ldr	r1, [fp, #-28]
100138b0:	e1a0200e 	mov	r2, lr
100138b4:	e1a0300c 	mov	r3, ip
100138b8:	ebfffceb 	bl	10012c6c <print_number>
100138bc:	e50b0018 	str	r0, [fp, #-24]
    {
        end  = ((char *)-1);
        size = end - buf;
    }

    for (; *fmt ; ++fmt)
100138c0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100138c4:	e2833001 	add	r3, r3, #1
100138c8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
100138cc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100138d0:	e5d33000 	ldrb	r3, [r3]
100138d4:	e3530000 	cmp	r3, #0
100138d8:	1afffdca 	bne	10013008 <rt_vsnprintf+0x64>
#else
        str = print_number(str, end, num, base, field_width, flags);
#endif
    }

    if (str <= end) *str = '\0';
100138dc:	e51b2018 	ldr	r2, [fp, #-24]
100138e0:	e51b301c 	ldr	r3, [fp, #-28]
100138e4:	e1520003 	cmp	r2, r3
100138e8:	8a000003 	bhi	100138fc <rt_vsnprintf+0x958>
100138ec:	e51b3018 	ldr	r3, [fp, #-24]
100138f0:	e3a02000 	mov	r2, #0
100138f4:	e5c32000 	strb	r2, [r3]
100138f8:	ea000002 	b	10013908 <rt_vsnprintf+0x964>
    else *end = '\0';
100138fc:	e51b301c 	ldr	r3, [fp, #-28]
10013900:	e3a02000 	mov	r2, #0
10013904:	e5c32000 	strb	r2, [r3]

    /* the trailing null byte doesn't count towards the total
    * ++str;
    */
    return str - buf;
10013908:	e51b2018 	ldr	r2, [fp, #-24]
1001390c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10013910:	e0633002 	rsb	r3, r3, r2
}
10013914:	e1a00003 	mov	r0, r3
10013918:	e24bd004 	sub	sp, fp, #4
1001391c:	e8bd8800 	pop	{fp, pc}

10013920 <rt_snprintf>:
 * @param buf the buffer to save formatted string
 * @param size the size of buffer
 * @param fmt the format
 */
rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
{
10013920:	e92d000c 	push	{r2, r3}
10013924:	e92d4800 	push	{fp, lr}
10013928:	e28db004 	add	fp, sp, #4
1001392c:	e24dd010 	sub	sp, sp, #16
10013930:	e50b0010 	str	r0, [fp, #-16]
10013934:	e50b1014 	str	r1, [fp, #-20]
    rt_int32_t n;
    va_list args;

    va_start(args, fmt);
10013938:	e28b3008 	add	r3, fp, #8
1001393c:	e50b300c 	str	r3, [fp, #-12]
    n = rt_vsnprintf(buf, size, fmt, args);
10013940:	e51b0010 	ldr	r0, [fp, #-16]
10013944:	e51b1014 	ldr	r1, [fp, #-20]
10013948:	e59b2004 	ldr	r2, [fp, #4]
1001394c:	e51b300c 	ldr	r3, [fp, #-12]
10013950:	ebfffd93 	bl	10012fa4 <rt_vsnprintf>
10013954:	e50b0008 	str	r0, [fp, #-8]
    va_end(args);

    return n;
10013958:	e51b3008 	ldr	r3, [fp, #-8]
}
1001395c:	e1a00003 	mov	r0, r3
10013960:	e24bd004 	sub	sp, fp, #4
10013964:	e8bd4800 	pop	{fp, lr}
10013968:	e28dd008 	add	sp, sp, #8
1001396c:	e12fff1e 	bx	lr

10013970 <rt_vsprintf>:
 * @param buf the buffer to save formatted string
 * @param arg_ptr the arg_ptr
 * @param format the format
 */
rt_int32_t rt_vsprintf(char *buf, const char *format, va_list arg_ptr)
{
10013970:	e92d4800 	push	{fp, lr}
10013974:	e28db004 	add	fp, sp, #4
10013978:	e24dd010 	sub	sp, sp, #16
1001397c:	e50b0008 	str	r0, [fp, #-8]
10013980:	e50b100c 	str	r1, [fp, #-12]
10013984:	e50b2010 	str	r2, [fp, #-16]
    return rt_vsnprintf(buf, (rt_size_t) -1, format, arg_ptr);
10013988:	e51b0008 	ldr	r0, [fp, #-8]
1001398c:	e3e01000 	mvn	r1, #0
10013990:	e51b200c 	ldr	r2, [fp, #-12]
10013994:	e51b3010 	ldr	r3, [fp, #-16]
10013998:	ebfffd81 	bl	10012fa4 <rt_vsnprintf>
1001399c:	e1a03000 	mov	r3, r0
}
100139a0:	e1a00003 	mov	r0, r3
100139a4:	e24bd004 	sub	sp, fp, #4
100139a8:	e8bd8800 	pop	{fp, pc}

100139ac <rt_sprintf>:
 *
 * @param buf the buffer to save formatted string
 * @param format the format
 */
rt_int32_t rt_sprintf(char *buf, const char *format, ...)
{
100139ac:	e92d000e 	push	{r1, r2, r3}
100139b0:	e92d4800 	push	{fp, lr}
100139b4:	e28db004 	add	fp, sp, #4
100139b8:	e24dd014 	sub	sp, sp, #20
100139bc:	e50b0014 	str	r0, [fp, #-20]
    rt_int32_t n;
    va_list arg_ptr;

    va_start(arg_ptr, format);
100139c0:	e28b3008 	add	r3, fp, #8
100139c4:	e50b3010 	str	r3, [fp, #-16]
    n = rt_vsprintf(buf ,format, arg_ptr);
100139c8:	e51b0014 	ldr	r0, [fp, #-20]
100139cc:	e59b1004 	ldr	r1, [fp, #4]
100139d0:	e51b2010 	ldr	r2, [fp, #-16]
100139d4:	ebffffe5 	bl	10013970 <rt_vsprintf>
100139d8:	e50b000c 	str	r0, [fp, #-12]
    va_end(arg_ptr);

    return n;
100139dc:	e51b300c 	ldr	r3, [fp, #-12]
}
100139e0:	e1a00003 	mov	r0, r3
100139e4:	e24bd004 	sub	sp, fp, #4
100139e8:	e8bd4800 	pop	{fp, lr}
100139ec:	e28dd00c 	add	sp, sp, #12
100139f0:	e12fff1e 	bx	lr

100139f4 <rt_console_get_device>:
 * This function returns the device using in console.
 *
 * @return the device using in console or RT_NULL
 */
rt_device_t rt_console_get_device(void)
{
100139f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100139f8:	e28db000 	add	fp, sp, #0
    return _console_device;
100139fc:	e30c3370 	movw	r3, #50032	; 0xc370
10013a00:	e3413003 	movt	r3, #4099	; 0x1003
10013a04:	e5933000 	ldr	r3, [r3]
}
10013a08:	e1a00003 	mov	r0, r3
10013a0c:	e24bd000 	sub	sp, fp, #0
10013a10:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10013a14:	e12fff1e 	bx	lr

10013a18 <rt_console_set_device>:
 * @param name the name of new console device
 *
 * @return the old console device handler
 */
rt_device_t rt_console_set_device(const char *name)
{
10013a18:	e92d4800 	push	{fp, lr}
10013a1c:	e28db004 	add	fp, sp, #4
10013a20:	e24dd010 	sub	sp, sp, #16
10013a24:	e50b0010 	str	r0, [fp, #-16]
    rt_device_t new, old;

    /* save old device */
    old = _console_device;
10013a28:	e30c3370 	movw	r3, #50032	; 0xc370
10013a2c:	e3413003 	movt	r3, #4099	; 0x1003
10013a30:	e5933000 	ldr	r3, [r3]
10013a34:	e50b3008 	str	r3, [fp, #-8]

    /* find new console device */
    new = rt_device_find(name);
10013a38:	e51b0010 	ldr	r0, [fp, #-16]
10013a3c:	ebffeb04 	bl	1000e654 <rt_device_find>
10013a40:	e50b000c 	str	r0, [fp, #-12]
    if (new != RT_NULL)
10013a44:	e51b300c 	ldr	r3, [fp, #-12]
10013a48:	e3530000 	cmp	r3, #0
10013a4c:	0a000010 	beq	10013a94 <rt_console_set_device+0x7c>
    {
        if (_console_device != RT_NULL)
10013a50:	e30c3370 	movw	r3, #50032	; 0xc370
10013a54:	e3413003 	movt	r3, #4099	; 0x1003
10013a58:	e5933000 	ldr	r3, [r3]
10013a5c:	e3530000 	cmp	r3, #0
10013a60:	0a000004 	beq	10013a78 <rt_console_set_device+0x60>
        {
            /* close old console device */
            rt_device_close(_console_device);
10013a64:	e30c3370 	movw	r3, #50032	; 0xc370
10013a68:	e3413003 	movt	r3, #4099	; 0x1003
10013a6c:	e5933000 	ldr	r3, [r3]
10013a70:	e1a00003 	mov	r0, r3
10013a74:	ebffebc0 	bl	1000e97c <rt_device_close>
        }

        /* set new console device */
        rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
10013a78:	e51b000c 	ldr	r0, [fp, #-12]
10013a7c:	e3a01043 	mov	r1, #67	; 0x43
10013a80:	ebffeb57 	bl	1000e7e4 <rt_device_open>
        _console_device = new;
10013a84:	e30c3370 	movw	r3, #50032	; 0xc370
10013a88:	e3413003 	movt	r3, #4099	; 0x1003
10013a8c:	e51b200c 	ldr	r2, [fp, #-12]
10013a90:	e5832000 	str	r2, [r3]
    }

    return old;
10013a94:	e51b3008 	ldr	r3, [fp, #-8]
}
10013a98:	e1a00003 	mov	r0, r3
10013a9c:	e24bd004 	sub	sp, fp, #4
10013aa0:	e8bd8800 	pop	{fp, pc}

10013aa4 <rt_hw_console_output>:
RTM_EXPORT(rt_console_set_device);
#endif

WEAK void rt_hw_console_output(const char *str)
{
10013aa4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10013aa8:	e28db000 	add	fp, sp, #0
10013aac:	e24dd00c 	sub	sp, sp, #12
10013ab0:	e50b0008 	str	r0, [fp, #-8]
    /* empty console output */
}
10013ab4:	e24bd000 	sub	sp, fp, #0
10013ab8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10013abc:	e12fff1e 	bx	lr

10013ac0 <rt_kprintf>:
 * This function will print a formatted string on system console
 *
 * @param fmt the format
 */
void rt_kprintf(const char *fmt, ...)
{
10013ac0:	e92d000f 	push	{r0, r1, r2, r3}
10013ac4:	e92d4800 	push	{fp, lr}
10013ac8:	e28db004 	add	fp, sp, #4
10013acc:	e24dd010 	sub	sp, sp, #16
    va_list args;
    rt_size_t length;
    static char rt_log_buf[RT_CONSOLEBUF_SIZE];

    va_start(args, fmt);
10013ad0:	e28b3008 	add	r3, fp, #8
10013ad4:	e50b3010 	str	r3, [fp, #-16]
    /* the return value of vsnprintf is the number of bytes that would be
     * written to buffer had if the size of the buffer been sufficiently
     * large excluding the terminating null byte. If the output string
     * would be larger than the rt_log_buf, we have to adjust the output
     * length. */
    length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
10013ad8:	e30c0374 	movw	r0, #50036	; 0xc374
10013adc:	e3410003 	movt	r0, #4099	; 0x1003
10013ae0:	e3a0107f 	mov	r1, #127	; 0x7f
10013ae4:	e59b2004 	ldr	r2, [fp, #4]
10013ae8:	e51b3010 	ldr	r3, [fp, #-16]
10013aec:	ebfffd2c 	bl	10012fa4 <rt_vsnprintf>
10013af0:	e1a03000 	mov	r3, r0
10013af4:	e50b3008 	str	r3, [fp, #-8]
    if (length > RT_CONSOLEBUF_SIZE - 1)
10013af8:	e51b3008 	ldr	r3, [fp, #-8]
10013afc:	e353007f 	cmp	r3, #127	; 0x7f
10013b00:	9a000001 	bls	10013b0c <rt_kprintf+0x4c>
        length = RT_CONSOLEBUF_SIZE - 1;
10013b04:	e3a0307f 	mov	r3, #127	; 0x7f
10013b08:	e50b3008 	str	r3, [fp, #-8]
#ifdef RT_USING_DEVICE
    if (_console_device == RT_NULL)
10013b0c:	e30c3370 	movw	r3, #50032	; 0xc370
10013b10:	e3413003 	movt	r3, #4099	; 0x1003
10013b14:	e5933000 	ldr	r3, [r3]
10013b18:	e3530000 	cmp	r3, #0
10013b1c:	1a000003 	bne	10013b30 <rt_kprintf+0x70>
    {
        rt_hw_console_output(rt_log_buf);
10013b20:	e30c0374 	movw	r0, #50036	; 0xc374
10013b24:	e3410003 	movt	r0, #4099	; 0x1003
10013b28:	ebffffdd 	bl	10013aa4 <rt_hw_console_output>
10013b2c:	ea00001c 	b	10013ba4 <rt_kprintf+0xe4>
    }
    else
    {
        rt_uint16_t old_flag = _console_device->open_flag;
10013b30:	e30c3370 	movw	r3, #50032	; 0xc370
10013b34:	e3413003 	movt	r3, #4099	; 0x1003
10013b38:	e5933000 	ldr	r3, [r3]
10013b3c:	e1d331b4 	ldrh	r3, [r3, #20]
10013b40:	e14b30ba 	strh	r3, [fp, #-10]

        _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
10013b44:	e30c3370 	movw	r3, #50032	; 0xc370
10013b48:	e3413003 	movt	r3, #4099	; 0x1003
10013b4c:	e5932000 	ldr	r2, [r3]
10013b50:	e30c3370 	movw	r3, #50032	; 0xc370
10013b54:	e3413003 	movt	r3, #4099	; 0x1003
10013b58:	e5933000 	ldr	r3, [r3]
10013b5c:	e1d331b4 	ldrh	r3, [r3, #20]
10013b60:	e3833040 	orr	r3, r3, #64	; 0x40
10013b64:	e6ff3073 	uxth	r3, r3
10013b68:	e1c231b4 	strh	r3, [r2, #20]
        rt_device_write(_console_device, 0, rt_log_buf, length);
10013b6c:	e30c3370 	movw	r3, #50032	; 0xc370
10013b70:	e3413003 	movt	r3, #4099	; 0x1003
10013b74:	e5933000 	ldr	r3, [r3]
10013b78:	e1a00003 	mov	r0, r3
10013b7c:	e3a01000 	mov	r1, #0
10013b80:	e30c2374 	movw	r2, #50036	; 0xc374
10013b84:	e3412003 	movt	r2, #4099	; 0x1003
10013b88:	e51b3008 	ldr	r3, [fp, #-8]
10013b8c:	ebffebdc 	bl	1000eb04 <rt_device_write>
        _console_device->open_flag = old_flag;
10013b90:	e30c3370 	movw	r3, #50032	; 0xc370
10013b94:	e3413003 	movt	r3, #4099	; 0x1003
10013b98:	e5933000 	ldr	r3, [r3]
10013b9c:	e15b20ba 	ldrh	r2, [fp, #-10]
10013ba0:	e1c321b4 	strh	r2, [r3, #20]
    }
#else
    rt_hw_console_output(rt_log_buf);
#endif
    va_end(args);
}
10013ba4:	e24bd004 	sub	sp, fp, #4
10013ba8:	e8bd4800 	pop	{fp, lr}
10013bac:	e28dd010 	add	sp, sp, #16
10013bb0:	e12fff1e 	bx	lr

10013bb4 <rt_malloc_align>:
 * @param align the alignment size
 *
 * @return the allocated memory block on successful, otherwise returns RT_NULL
 */
void* rt_malloc_align(rt_size_t size, rt_size_t align)
{
10013bb4:	e92d4800 	push	{fp, lr}
10013bb8:	e28db004 	add	fp, sp, #4
10013bbc:	e24dd018 	sub	sp, sp, #24
10013bc0:	e50b0018 	str	r0, [fp, #-24]
10013bc4:	e50b101c 	str	r1, [fp, #-28]
    void *align_ptr;
    void *ptr;
    rt_size_t align_size;

    /* align the alignment size to 4 byte */
    align = ((align + 0x03) & ~0x03);
10013bc8:	e51b301c 	ldr	r3, [fp, #-28]
10013bcc:	e2833003 	add	r3, r3, #3
10013bd0:	e3c33003 	bic	r3, r3, #3
10013bd4:	e50b301c 	str	r3, [fp, #-28]

    /* get total aligned size */
    align_size = ((size + 0x03) & ~0x03) + align;
10013bd8:	e51b3018 	ldr	r3, [fp, #-24]
10013bdc:	e2833003 	add	r3, r3, #3
10013be0:	e3c32003 	bic	r2, r3, #3
10013be4:	e51b301c 	ldr	r3, [fp, #-28]
10013be8:	e0823003 	add	r3, r2, r3
10013bec:	e50b3010 	str	r3, [fp, #-16]
    /* allocate memory block from heap */
    ptr = rt_malloc(align_size);
10013bf0:	e51b0010 	ldr	r0, [fp, #-16]
10013bf4:	eb0001a6 	bl	10014294 <rt_malloc>
10013bf8:	e50b000c 	str	r0, [fp, #-12]
    if (ptr != RT_NULL)
10013bfc:	e51b300c 	ldr	r3, [fp, #-12]
10013c00:	e3530000 	cmp	r3, #0
10013c04:	0a000019 	beq	10013c70 <rt_malloc_align+0xbc>
    {
         /* the allocated memory block is aligned */
        if (((rt_uint32_t)ptr & (align - 1)) == 0)
10013c08:	e51b301c 	ldr	r3, [fp, #-28]
10013c0c:	e2432001 	sub	r2, r3, #1
10013c10:	e51b300c 	ldr	r3, [fp, #-12]
10013c14:	e0033002 	and	r3, r3, r2
10013c18:	e3530000 	cmp	r3, #0
10013c1c:	1a000004 	bne	10013c34 <rt_malloc_align+0x80>
        {
            align_ptr = (void *)((rt_uint32_t)ptr + align);
10013c20:	e51b200c 	ldr	r2, [fp, #-12]
10013c24:	e51b301c 	ldr	r3, [fp, #-28]
10013c28:	e0823003 	add	r3, r2, r3
10013c2c:	e50b3008 	str	r3, [fp, #-8]
10013c30:	ea000007 	b	10013c54 <rt_malloc_align+0xa0>
        }
        else
        {
            align_ptr = (void *)(((rt_uint32_t)ptr + (align - 1)) & ~(align - 1));
10013c34:	e51b200c 	ldr	r2, [fp, #-12]
10013c38:	e51b301c 	ldr	r3, [fp, #-28]
10013c3c:	e0823003 	add	r3, r2, r3
10013c40:	e2432001 	sub	r2, r3, #1
10013c44:	e51b301c 	ldr	r3, [fp, #-28]
10013c48:	e2633000 	rsb	r3, r3, #0
10013c4c:	e0033002 	and	r3, r3, r2
10013c50:	e50b3008 	str	r3, [fp, #-8]
        }

        /* set the pointer before alignment pointer to the real pointer */
        *((rt_uint32_t *)((rt_uint32_t)align_ptr - sizeof(void *))) = (rt_uint32_t)ptr;
10013c54:	e51b3008 	ldr	r3, [fp, #-8]
10013c58:	e2433004 	sub	r3, r3, #4
10013c5c:	e1a02003 	mov	r2, r3
10013c60:	e51b300c 	ldr	r3, [fp, #-12]
10013c64:	e5823000 	str	r3, [r2]

        ptr = align_ptr;
10013c68:	e51b3008 	ldr	r3, [fp, #-8]
10013c6c:	e50b300c 	str	r3, [fp, #-12]
    }

    return ptr;
10013c70:	e51b300c 	ldr	r3, [fp, #-12]
}
10013c74:	e1a00003 	mov	r0, r3
10013c78:	e24bd004 	sub	sp, fp, #4
10013c7c:	e8bd8800 	pop	{fp, pc}

10013c80 <rt_free_align>:
 * rt_malloc_align function and address is aligned.
 *
 * @param ptr the memory block pointer
 */
void rt_free_align(void *ptr)
{
10013c80:	e92d4800 	push	{fp, lr}
10013c84:	e28db004 	add	fp, sp, #4
10013c88:	e24dd010 	sub	sp, sp, #16
10013c8c:	e50b0010 	str	r0, [fp, #-16]
    void *real_ptr;

    real_ptr = (void *)*(rt_uint32_t *)((rt_uint32_t)ptr - sizeof(void *));
10013c90:	e51b3010 	ldr	r3, [fp, #-16]
10013c94:	e2433004 	sub	r3, r3, #4
10013c98:	e5933000 	ldr	r3, [r3]
10013c9c:	e50b3008 	str	r3, [fp, #-8]
    rt_free(real_ptr);
10013ca0:	e51b0008 	ldr	r0, [fp, #-8]
10013ca4:	eb000395 	bl	10014b00 <rt_free>
}
10013ca8:	e24bd004 	sub	sp, fp, #4
10013cac:	e8bd8800 	pop	{fp, pc}

10013cb0 <__rt_ffs>:
 *
 * @return return the index of the first bit set. If value is 0, then this function
 * shall return 0.
 */
int __rt_ffs(int value)
{
10013cb0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10013cb4:	e28db000 	add	fp, sp, #0
10013cb8:	e24dd00c 	sub	sp, sp, #12
10013cbc:	e50b0008 	str	r0, [fp, #-8]
    if (value == 0) return 0;
10013cc0:	e51b3008 	ldr	r3, [fp, #-8]
10013cc4:	e3530000 	cmp	r3, #0
10013cc8:	1a000001 	bne	10013cd4 <__rt_ffs+0x24>
10013ccc:	e3a03000 	mov	r3, #0
10013cd0:	ea000028 	b	10013d78 <__rt_ffs+0xc8>

    if (value & 0xff)
10013cd4:	e51b3008 	ldr	r3, [fp, #-8]
10013cd8:	e6ef3073 	uxtb	r3, r3
10013cdc:	e3530000 	cmp	r3, #0
10013ce0:	0a000006 	beq	10013d00 <__rt_ffs+0x50>
        return __lowest_bit_bitmap[value & 0xff] + 1;
10013ce4:	e51b3008 	ldr	r3, [fp, #-8]
10013ce8:	e6ef2073 	uxtb	r2, r3
10013cec:	e30337ac 	movw	r3, #14252	; 0x37ac
10013cf0:	e3413003 	movt	r3, #4099	; 0x1003
10013cf4:	e7d33002 	ldrb	r3, [r3, r2]
10013cf8:	e2833001 	add	r3, r3, #1
10013cfc:	ea00001d 	b	10013d78 <__rt_ffs+0xc8>

    if (value & 0xff00)
10013d00:	e51b3008 	ldr	r3, [fp, #-8]
10013d04:	e2033cff 	and	r3, r3, #65280	; 0xff00
10013d08:	e3530000 	cmp	r3, #0
10013d0c:	0a000007 	beq	10013d30 <__rt_ffs+0x80>
        return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
10013d10:	e51b3008 	ldr	r3, [fp, #-8]
10013d14:	e2033cff 	and	r3, r3, #65280	; 0xff00
10013d18:	e1a02443 	asr	r2, r3, #8
10013d1c:	e30337ac 	movw	r3, #14252	; 0x37ac
10013d20:	e3413003 	movt	r3, #4099	; 0x1003
10013d24:	e7d33002 	ldrb	r3, [r3, r2]
10013d28:	e2833009 	add	r3, r3, #9
10013d2c:	ea000011 	b	10013d78 <__rt_ffs+0xc8>

    if (value & 0xff0000)
10013d30:	e51b3008 	ldr	r3, [fp, #-8]
10013d34:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
10013d38:	e3530000 	cmp	r3, #0
10013d3c:	0a000007 	beq	10013d60 <__rt_ffs+0xb0>
        return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
10013d40:	e51b3008 	ldr	r3, [fp, #-8]
10013d44:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
10013d48:	e1a02843 	asr	r2, r3, #16
10013d4c:	e30337ac 	movw	r3, #14252	; 0x37ac
10013d50:	e3413003 	movt	r3, #4099	; 0x1003
10013d54:	e7d33002 	ldrb	r3, [r3, r2]
10013d58:	e2833011 	add	r3, r3, #17
10013d5c:	ea000005 	b	10013d78 <__rt_ffs+0xc8>

    return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
10013d60:	e51b3008 	ldr	r3, [fp, #-8]
10013d64:	e1a02c23 	lsr	r2, r3, #24
10013d68:	e30337ac 	movw	r3, #14252	; 0x37ac
10013d6c:	e3413003 	movt	r3, #4099	; 0x1003
10013d70:	e7d33002 	ldrb	r3, [r3, r2]
10013d74:	e2833019 	add	r3, r3, #25
}
10013d78:	e1a00003 	mov	r0, r3
10013d7c:	e24bd000 	sub	sp, fp, #0
10013d80:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10013d84:	e12fff1e 	bx	lr

10013d88 <rt_assert_set_hook>:
/**
 * This function will set a hook function to RT_ASSERT(EX). It will run when the expression is false.
 *
 * @param hook the hook function
 */
void rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line)) {
10013d88:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10013d8c:	e28db000 	add	fp, sp, #0
10013d90:	e24dd00c 	sub	sp, sp, #12
10013d94:	e50b0008 	str	r0, [fp, #-8]
    rt_assert_hook = hook;
10013d98:	e30239a8 	movw	r3, #10664	; 0x29a8
10013d9c:	e3413004 	movt	r3, #4100	; 0x1004
10013da0:	e51b2008 	ldr	r2, [fp, #-8]
10013da4:	e5832000 	str	r2, [r3]
}
10013da8:	e24bd000 	sub	sp, fp, #0
10013dac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10013db0:	e12fff1e 	bx	lr

10013db4 <rt_assert_handler>:
 * @param ex the assertion condition string
 * @param func the function name when assertion.
 * @param line the file line number when assertion.
 */
void rt_assert_handler(const char* ex_string, const char* func, rt_size_t line)
{
10013db4:	e92d4800 	push	{fp, lr}
10013db8:	e28db004 	add	fp, sp, #4
10013dbc:	e24dd018 	sub	sp, sp, #24
10013dc0:	e50b0010 	str	r0, [fp, #-16]
10013dc4:	e50b1014 	str	r1, [fp, #-20]
10013dc8:	e50b2018 	str	r2, [fp, #-24]
    volatile char dummy = 0;
10013dcc:	e3a03000 	mov	r3, #0
10013dd0:	e54b3005 	strb	r3, [fp, #-5]

    if (rt_assert_hook == RT_NULL)
10013dd4:	e30239a8 	movw	r3, #10664	; 0x29a8
10013dd8:	e3413004 	movt	r3, #4100	; 0x1004
10013ddc:	e5933000 	ldr	r3, [r3]
10013de0:	e3530000 	cmp	r3, #0
10013de4:	1a00000b 	bne	10013e18 <rt_assert_handler+0x64>
			rt_schedule();
		}
		else
#endif
		{
	        rt_kprintf("(%s) assertion failed at function:%s, line number:%d \n", ex_string, func, line);
10013de8:	e30308ac 	movw	r0, #14508	; 0x38ac
10013dec:	e3410003 	movt	r0, #4099	; 0x1003
10013df0:	e51b1010 	ldr	r1, [fp, #-16]
10013df4:	e51b2014 	ldr	r2, [fp, #-20]
10013df8:	e51b3018 	ldr	r3, [fp, #-24]
10013dfc:	ebffff2f 	bl	10013ac0 <rt_kprintf>
	        while (dummy == 0);
10013e00:	e1a00000 	nop			; (mov r0, r0)
10013e04:	e55b3005 	ldrb	r3, [fp, #-5]
10013e08:	e6ef3073 	uxtb	r3, r3
10013e0c:	e3530000 	cmp	r3, #0
10013e10:	0afffffb 	beq	10013e04 <rt_assert_handler+0x50>
10013e14:	ea000006 	b	10013e34 <rt_assert_handler+0x80>
		}
    }
	else
	{
        rt_assert_hook(ex_string, func, line);
10013e18:	e30239a8 	movw	r3, #10664	; 0x29a8
10013e1c:	e3413004 	movt	r3, #4100	; 0x1004
10013e20:	e5933000 	ldr	r3, [r3]
10013e24:	e51b0010 	ldr	r0, [fp, #-16]
10013e28:	e51b1014 	ldr	r1, [fp, #-20]
10013e2c:	e51b2018 	ldr	r2, [fp, #-24]
10013e30:	e12fff33 	blx	r3
    }                                                                     
}
10013e34:	e24bd004 	sub	sp, fp, #4
10013e38:	e8bd8800 	pop	{fp, pc}

10013e3c <rt_malloc_sethook>:
 * block is allocated from heap memory.
 *
 * @param hook the hook function
 */
void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
{
10013e3c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10013e40:	e28db000 	add	fp, sp, #0
10013e44:	e24dd00c 	sub	sp, sp, #12
10013e48:	e50b0008 	str	r0, [fp, #-8]
    rt_malloc_hook = hook;
10013e4c:	e30c33f4 	movw	r3, #50164	; 0xc3f4
10013e50:	e3413003 	movt	r3, #4099	; 0x1003
10013e54:	e51b2008 	ldr	r2, [fp, #-8]
10013e58:	e5832000 	str	r2, [r3]
}
10013e5c:	e24bd000 	sub	sp, fp, #0
10013e60:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10013e64:	e12fff1e 	bx	lr

10013e68 <rt_free_sethook>:
 * block is released to heap memory.
 *
 * @param hook the hook function
 */
void rt_free_sethook(void (*hook)(void *ptr))
{
10013e68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10013e6c:	e28db000 	add	fp, sp, #0
10013e70:	e24dd00c 	sub	sp, sp, #12
10013e74:	e50b0008 	str	r0, [fp, #-8]
    rt_free_hook = hook;
10013e78:	e30c33f8 	movw	r3, #50168	; 0xc3f8
10013e7c:	e3413003 	movt	r3, #4099	; 0x1003
10013e80:	e51b2008 	ldr	r2, [fp, #-8]
10013e84:	e5832000 	str	r2, [r3]
}
10013e88:	e24bd000 	sub	sp, fp, #0
10013e8c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10013e90:	e12fff1e 	bx	lr

10013e94 <plug_holes>:
#ifdef RT_MEM_STATS
static rt_size_t used_mem, max_mem;
#endif

static void plug_holes(struct heap_mem *mem)
{
10013e94:	e92d4800 	push	{fp, lr}
10013e98:	e28db004 	add	fp, sp, #4
10013e9c:	e24dd010 	sub	sp, sp, #16
10013ea0:	e50b0010 	str	r0, [fp, #-16]
    struct heap_mem *nmem;
    struct heap_mem *pmem;

    RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
10013ea4:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10013ea8:	e3413003 	movt	r3, #4099	; 0x1003
10013eac:	e5933000 	ldr	r3, [r3]
10013eb0:	e51b2010 	ldr	r2, [fp, #-16]
10013eb4:	e1520003 	cmp	r2, r3
10013eb8:	2a000005 	bcs	10013ed4 <plug_holes+0x40>
10013ebc:	e303090c 	movw	r0, #14604	; 0x390c
10013ec0:	e3410003 	movt	r0, #4099	; 0x1003
10013ec4:	e3031bbc 	movw	r1, #15292	; 0x3bbc
10013ec8:	e3411003 	movt	r1, #4099	; 0x1003
10013ecc:	e3a0208d 	mov	r2, #141	; 0x8d
10013ed0:	ebffffb7 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
10013ed4:	e30c3400 	movw	r3, #50176	; 0xc400
10013ed8:	e3413003 	movt	r3, #4099	; 0x1003
10013edc:	e5933000 	ldr	r3, [r3]
10013ee0:	e51b2010 	ldr	r2, [fp, #-16]
10013ee4:	e1520003 	cmp	r2, r3
10013ee8:	3a000005 	bcc	10013f04 <plug_holes+0x70>
10013eec:	e303092c 	movw	r0, #14636	; 0x392c
10013ef0:	e3410003 	movt	r0, #4099	; 0x1003
10013ef4:	e3031bbc 	movw	r1, #15292	; 0x3bbc
10013ef8:	e3411003 	movt	r1, #4099	; 0x1003
10013efc:	e3a0208e 	mov	r2, #142	; 0x8e
10013f00:	ebffffab 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(mem->used == 0);
10013f04:	e51b3010 	ldr	r3, [fp, #-16]
10013f08:	e1d330b2 	ldrh	r3, [r3, #2]
10013f0c:	e3530000 	cmp	r3, #0
10013f10:	0a000005 	beq	10013f2c <plug_holes+0x98>
10013f14:	e3030958 	movw	r0, #14680	; 0x3958
10013f18:	e3410003 	movt	r0, #4099	; 0x1003
10013f1c:	e3031bbc 	movw	r1, #15292	; 0x3bbc
10013f20:	e3411003 	movt	r1, #4099	; 0x1003
10013f24:	e3a0208f 	mov	r2, #143	; 0x8f
10013f28:	ebffffa1 	bl	10013db4 <rt_assert_handler>

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
10013f2c:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10013f30:	e3413003 	movt	r3, #4099	; 0x1003
10013f34:	e5932000 	ldr	r2, [r3]
10013f38:	e51b3010 	ldr	r3, [fp, #-16]
10013f3c:	e5933004 	ldr	r3, [r3, #4]
10013f40:	e0823003 	add	r3, r2, r3
10013f44:	e50b3008 	str	r3, [fp, #-8]
    if (mem != nmem &&
10013f48:	e51b2010 	ldr	r2, [fp, #-16]
10013f4c:	e51b3008 	ldr	r3, [fp, #-8]
10013f50:	e1520003 	cmp	r2, r3
10013f54:	0a000023 	beq	10013fe8 <plug_holes+0x154>
        nmem->used == 0 &&
10013f58:	e51b3008 	ldr	r3, [fp, #-8]
10013f5c:	e1d330b2 	ldrh	r3, [r3, #2]
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
10013f60:	e3530000 	cmp	r3, #0
10013f64:	1a00001f 	bne	10013fe8 <plug_holes+0x154>
        nmem->used == 0 &&
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
10013f68:	e30c3400 	movw	r3, #50176	; 0xc400
10013f6c:	e3413003 	movt	r3, #4099	; 0x1003
10013f70:	e5933000 	ldr	r3, [r3]
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
        nmem->used == 0 &&
10013f74:	e51b2008 	ldr	r2, [fp, #-8]
10013f78:	e1520003 	cmp	r2, r3
10013f7c:	0a000019 	beq	10013fe8 <plug_holes+0x154>
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
    {
        /* if mem->next is unused and not end of heap_ptr,
         * combine mem and mem->next
         */
        if (lfree == nmem)
10013f80:	e30c3404 	movw	r3, #50180	; 0xc404
10013f84:	e3413003 	movt	r3, #4099	; 0x1003
10013f88:	e5932000 	ldr	r2, [r3]
10013f8c:	e51b3008 	ldr	r3, [fp, #-8]
10013f90:	e1520003 	cmp	r2, r3
10013f94:	1a000003 	bne	10013fa8 <plug_holes+0x114>
        {
            lfree = mem;
10013f98:	e30c3404 	movw	r3, #50180	; 0xc404
10013f9c:	e3413003 	movt	r3, #4099	; 0x1003
10013fa0:	e51b2010 	ldr	r2, [fp, #-16]
10013fa4:	e5832000 	str	r2, [r3]
        }
        mem->next = nmem->next;
10013fa8:	e51b3008 	ldr	r3, [fp, #-8]
10013fac:	e5932004 	ldr	r2, [r3, #4]
10013fb0:	e51b3010 	ldr	r3, [fp, #-16]
10013fb4:	e5832004 	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
10013fb8:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10013fbc:	e3413003 	movt	r3, #4099	; 0x1003
10013fc0:	e5932000 	ldr	r2, [r3]
10013fc4:	e51b3008 	ldr	r3, [fp, #-8]
10013fc8:	e5933004 	ldr	r3, [r3, #4]
10013fcc:	e0822003 	add	r2, r2, r3
10013fd0:	e51b1010 	ldr	r1, [fp, #-16]
10013fd4:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10013fd8:	e3413003 	movt	r3, #4099	; 0x1003
10013fdc:	e5933000 	ldr	r3, [r3]
10013fe0:	e0633001 	rsb	r3, r3, r1
10013fe4:	e5823008 	str	r3, [r2, #8]
    }

    /* plug hole backward */
    pmem = (struct heap_mem *)&heap_ptr[mem->prev];
10013fe8:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10013fec:	e3413003 	movt	r3, #4099	; 0x1003
10013ff0:	e5932000 	ldr	r2, [r3]
10013ff4:	e51b3010 	ldr	r3, [fp, #-16]
10013ff8:	e5933008 	ldr	r3, [r3, #8]
10013ffc:	e0823003 	add	r3, r2, r3
10014000:	e50b300c 	str	r3, [fp, #-12]
    if (pmem != mem && pmem->used == 0)
10014004:	e51b200c 	ldr	r2, [fp, #-12]
10014008:	e51b3010 	ldr	r3, [fp, #-16]
1001400c:	e1520003 	cmp	r2, r3
10014010:	0a00001d 	beq	1001408c <plug_holes+0x1f8>
10014014:	e51b300c 	ldr	r3, [fp, #-12]
10014018:	e1d330b2 	ldrh	r3, [r3, #2]
1001401c:	e3530000 	cmp	r3, #0
10014020:	1a000019 	bne	1001408c <plug_holes+0x1f8>
    {
        /* if mem->prev is unused, combine mem and mem->prev */
        if (lfree == mem)
10014024:	e30c3404 	movw	r3, #50180	; 0xc404
10014028:	e3413003 	movt	r3, #4099	; 0x1003
1001402c:	e5932000 	ldr	r2, [r3]
10014030:	e51b3010 	ldr	r3, [fp, #-16]
10014034:	e1520003 	cmp	r2, r3
10014038:	1a000003 	bne	1001404c <plug_holes+0x1b8>
        {
            lfree = pmem;
1001403c:	e30c3404 	movw	r3, #50180	; 0xc404
10014040:	e3413003 	movt	r3, #4099	; 0x1003
10014044:	e51b200c 	ldr	r2, [fp, #-12]
10014048:	e5832000 	str	r2, [r3]
        }
        pmem->next = mem->next;
1001404c:	e51b3010 	ldr	r3, [fp, #-16]
10014050:	e5932004 	ldr	r2, [r3, #4]
10014054:	e51b300c 	ldr	r3, [fp, #-12]
10014058:	e5832004 	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
1001405c:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014060:	e3413003 	movt	r3, #4099	; 0x1003
10014064:	e5932000 	ldr	r2, [r3]
10014068:	e51b3010 	ldr	r3, [fp, #-16]
1001406c:	e5933004 	ldr	r3, [r3, #4]
10014070:	e0822003 	add	r2, r2, r3
10014074:	e51b100c 	ldr	r1, [fp, #-12]
10014078:	e30c33fc 	movw	r3, #50172	; 0xc3fc
1001407c:	e3413003 	movt	r3, #4099	; 0x1003
10014080:	e5933000 	ldr	r3, [r3]
10014084:	e0633001 	rsb	r3, r3, r1
10014088:	e5823008 	str	r3, [r2, #8]
    }
}
1001408c:	e24bd004 	sub	sp, fp, #4
10014090:	e8bd8800 	pop	{fp, pc}

10014094 <rt_system_heap_init>:
 *
 * @param begin_addr the beginning address of system heap memory.
 * @param end_addr the end address of system heap memory.
 */
void rt_system_heap_init(void *begin_addr, void *end_addr)
{
10014094:	e92d4800 	push	{fp, lr}
10014098:	e28db004 	add	fp, sp, #4
1001409c:	e24dd018 	sub	sp, sp, #24
100140a0:	e50b0018 	str	r0, [fp, #-24]
100140a4:	e50b101c 	str	r1, [fp, #-28]
    struct heap_mem *mem;
    rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
100140a8:	e51b3018 	ldr	r3, [fp, #-24]
100140ac:	e2833003 	add	r3, r3, #3
100140b0:	e3c33003 	bic	r3, r3, #3
100140b4:	e50b3008 	str	r3, [fp, #-8]
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
100140b8:	e51b301c 	ldr	r3, [fp, #-28]
100140bc:	e3c33003 	bic	r3, r3, #3
100140c0:	e50b300c 	str	r3, [fp, #-12]

    RT_DEBUG_NOT_IN_INTERRUPT;
100140c4:	eb001559 	bl	10019630 <rt_hw_interrupt_disable>
100140c8:	e50b0010 	str	r0, [fp, #-16]
100140cc:	ebfff80b 	bl	10012100 <rt_interrupt_get_nest>
100140d0:	e1a03000 	mov	r3, r0
100140d4:	e3530000 	cmp	r3, #0
100140d8:	0a00000a 	beq	10014108 <rt_system_heap_init+0x74>
100140dc:	e3030968 	movw	r0, #14696	; 0x3968
100140e0:	e3410003 	movt	r0, #4099	; 0x1003
100140e4:	e3031bc8 	movw	r1, #15304	; 0x3bc8
100140e8:	e3411003 	movt	r1, #4099	; 0x1003
100140ec:	ebfffe73 	bl	10013ac0 <rt_kprintf>
100140f0:	e303098c 	movw	r0, #14732	; 0x398c
100140f4:	e3410003 	movt	r0, #4099	; 0x1003
100140f8:	e3031bc8 	movw	r1, #15304	; 0x3bc8
100140fc:	e3411003 	movt	r1, #4099	; 0x1003
10014100:	e3a020be 	mov	r2, #190	; 0xbe
10014104:	ebffff2a 	bl	10013db4 <rt_assert_handler>
10014108:	e51b0010 	ldr	r0, [fp, #-16]
1001410c:	eb00154b 	bl	10019640 <rt_hw_interrupt_enable>

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
10014110:	e51b300c 	ldr	r3, [fp, #-12]
10014114:	e3530018 	cmp	r3, #24
10014118:	9a000053 	bls	1001426c <rt_system_heap_init+0x1d8>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
1001411c:	e51b300c 	ldr	r3, [fp, #-12]
10014120:	e2432018 	sub	r2, r3, #24
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
10014124:	e51b3008 	ldr	r3, [fp, #-8]
10014128:	e1520003 	cmp	r2, r3
1001412c:	3a00004e 	bcc	1001426c <rt_system_heap_init+0x1d8>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
    {
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
10014130:	e51b200c 	ldr	r2, [fp, #-12]
10014134:	e51b3008 	ldr	r3, [fp, #-8]
10014138:	e0633002 	rsb	r3, r3, r2
1001413c:	e2432018 	sub	r2, r3, #24
10014140:	e30c3424 	movw	r3, #50212	; 0xc424
10014144:	e3413003 	movt	r3, #4099	; 0x1003
10014148:	e5832000 	str	r2, [r3]

        return;
    }

    /* point to begin address of heap */
    heap_ptr = (rt_uint8_t *)begin_align;
1001414c:	e51b2008 	ldr	r2, [fp, #-8]
10014150:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014154:	e3413003 	movt	r3, #4099	; 0x1003
10014158:	e5832000 	str	r2, [r3]

    RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
                                (rt_uint32_t)heap_ptr, mem_size_aligned));

    /* initialize the start of the heap */
    mem        = (struct heap_mem *)heap_ptr;
1001415c:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014160:	e3413003 	movt	r3, #4099	; 0x1003
10014164:	e5933000 	ldr	r3, [r3]
10014168:	e50b3014 	str	r3, [fp, #-20]
    mem->magic = HEAP_MAGIC;
1001416c:	e51b3014 	ldr	r3, [fp, #-20]
10014170:	e3012ea0 	movw	r2, #7840	; 0x1ea0
10014174:	e1c320b0 	strh	r2, [r3]
    mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
10014178:	e30c3424 	movw	r3, #50212	; 0xc424
1001417c:	e3413003 	movt	r3, #4099	; 0x1003
10014180:	e5933000 	ldr	r3, [r3]
10014184:	e283200c 	add	r2, r3, #12
10014188:	e51b3014 	ldr	r3, [fp, #-20]
1001418c:	e5832004 	str	r2, [r3, #4]
    mem->prev  = 0;
10014190:	e51b3014 	ldr	r3, [fp, #-20]
10014194:	e3a02000 	mov	r2, #0
10014198:	e5832008 	str	r2, [r3, #8]
    mem->used  = 0;
1001419c:	e51b3014 	ldr	r3, [fp, #-20]
100141a0:	e3a02000 	mov	r2, #0
100141a4:	e1c320b2 	strh	r2, [r3, #2]

    /* initialize the end of the heap */
    heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
100141a8:	e30c33fc 	movw	r3, #50172	; 0xc3fc
100141ac:	e3413003 	movt	r3, #4099	; 0x1003
100141b0:	e5932000 	ldr	r2, [r3]
100141b4:	e51b3014 	ldr	r3, [fp, #-20]
100141b8:	e5933004 	ldr	r3, [r3, #4]
100141bc:	e0822003 	add	r2, r2, r3
100141c0:	e30c3400 	movw	r3, #50176	; 0xc400
100141c4:	e3413003 	movt	r3, #4099	; 0x1003
100141c8:	e5832000 	str	r2, [r3]
    heap_end->magic = HEAP_MAGIC;
100141cc:	e30c3400 	movw	r3, #50176	; 0xc400
100141d0:	e3413003 	movt	r3, #4099	; 0x1003
100141d4:	e5933000 	ldr	r3, [r3]
100141d8:	e3012ea0 	movw	r2, #7840	; 0x1ea0
100141dc:	e1c320b0 	strh	r2, [r3]
    heap_end->used  = 1;
100141e0:	e30c3400 	movw	r3, #50176	; 0xc400
100141e4:	e3413003 	movt	r3, #4099	; 0x1003
100141e8:	e5933000 	ldr	r3, [r3]
100141ec:	e3a02001 	mov	r2, #1
100141f0:	e1c320b2 	strh	r2, [r3, #2]
    heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
100141f4:	e30c3400 	movw	r3, #50176	; 0xc400
100141f8:	e3413003 	movt	r3, #4099	; 0x1003
100141fc:	e5932000 	ldr	r2, [r3]
10014200:	e30c3424 	movw	r3, #50212	; 0xc424
10014204:	e3413003 	movt	r3, #4099	; 0x1003
10014208:	e5933000 	ldr	r3, [r3]
1001420c:	e283300c 	add	r3, r3, #12
10014210:	e5823004 	str	r3, [r2, #4]
    heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
10014214:	e30c3400 	movw	r3, #50176	; 0xc400
10014218:	e3413003 	movt	r3, #4099	; 0x1003
1001421c:	e5932000 	ldr	r2, [r3]
10014220:	e30c3424 	movw	r3, #50212	; 0xc424
10014224:	e3413003 	movt	r3, #4099	; 0x1003
10014228:	e5933000 	ldr	r3, [r3]
1001422c:	e283300c 	add	r3, r3, #12
10014230:	e5823008 	str	r3, [r2, #8]

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
10014234:	e30c0408 	movw	r0, #50184	; 0xc408
10014238:	e3410003 	movt	r0, #4099	; 0x1003
1001423c:	e30319cc 	movw	r1, #14796	; 0x39cc
10014240:	e3411003 	movt	r1, #4099	; 0x1003
10014244:	e3a02001 	mov	r2, #1
10014248:	e3a03000 	mov	r3, #0
1001424c:	ebffebef 	bl	1000f210 <rt_sem_init>

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
10014250:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014254:	e3413003 	movt	r3, #4099	; 0x1003
10014258:	e5932000 	ldr	r2, [r3]
1001425c:	e30c3404 	movw	r3, #50180	; 0xc404
10014260:	e3413003 	movt	r3, #4099	; 0x1003
10014264:	e5832000 	str	r2, [r3]
10014268:	ea000007 	b	1001428c <rt_system_heap_init+0x1f8>
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
    }
    else
    {
        rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
1001426c:	e51b2018 	ldr	r2, [fp, #-24]
10014270:	e51b301c 	ldr	r3, [fp, #-28]
10014274:	e3030990 	movw	r0, #14736	; 0x3990
10014278:	e3410003 	movt	r0, #4099	; 0x1003
1001427c:	e1a01002 	mov	r1, r2
10014280:	e1a02003 	mov	r2, r3
10014284:	ebfffe0d 	bl	10013ac0 <rt_kprintf>
                   (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);

        return;
10014288:	e1a00000 	nop			; (mov r0, r0)

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
}
1001428c:	e24bd004 	sub	sp, fp, #4
10014290:	e8bd8800 	pop	{fp, pc}

10014294 <rt_malloc>:
 * @param size is the minimum size of the requested block in bytes.
 *
 * @return pointer to allocated memory or NULL if no free memory was found.
 */
void *rt_malloc(rt_size_t size)
{
10014294:	e92d4800 	push	{fp, lr}
10014298:	e28db004 	add	fp, sp, #4
1001429c:	e24dd020 	sub	sp, sp, #32
100142a0:	e50b0020 	str	r0, [fp, #-32]
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;

    RT_DEBUG_NOT_IN_INTERRUPT;
100142a4:	eb0014e1 	bl	10019630 <rt_hw_interrupt_disable>
100142a8:	e50b000c 	str	r0, [fp, #-12]
100142ac:	ebfff793 	bl	10012100 <rt_interrupt_get_nest>
100142b0:	e1a03000 	mov	r3, r0
100142b4:	e3530000 	cmp	r3, #0
100142b8:	0a00000a 	beq	100142e8 <rt_malloc+0x54>
100142bc:	e3030968 	movw	r0, #14696	; 0x3968
100142c0:	e3410003 	movt	r0, #4099	; 0x1003
100142c4:	e3031bdc 	movw	r1, #15324	; 0x3bdc
100142c8:	e3411003 	movt	r1, #4099	; 0x1003
100142cc:	ebfffdfb 	bl	10013ac0 <rt_kprintf>
100142d0:	e303098c 	movw	r0, #14732	; 0x398c
100142d4:	e3410003 	movt	r0, #4099	; 0x1003
100142d8:	e3031bdc 	movw	r1, #15324	; 0x3bdc
100142dc:	e3411003 	movt	r1, #4099	; 0x1003
100142e0:	e3a020fb 	mov	r2, #251	; 0xfb
100142e4:	ebfffeb2 	bl	10013db4 <rt_assert_handler>
100142e8:	e51b000c 	ldr	r0, [fp, #-12]
100142ec:	eb0014d3 	bl	10019640 <rt_hw_interrupt_enable>

    if (size == 0)
100142f0:	e51b3020 	ldr	r3, [fp, #-32]
100142f4:	e3530000 	cmp	r3, #0
100142f8:	1a000001 	bne	10014304 <rt_malloc+0x70>
        return RT_NULL;
100142fc:	e3a03000 	mov	r3, #0
10014300:	ea00011e 	b	10014780 <rt_malloc+0x4ec>
                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
    else
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));

    /* alignment size */
    size = RT_ALIGN(size, RT_ALIGN_SIZE);
10014304:	e51b3020 	ldr	r3, [fp, #-32]
10014308:	e2833003 	add	r3, r3, #3
1001430c:	e3c33003 	bic	r3, r3, #3
10014310:	e50b3020 	str	r3, [fp, #-32]

    if (size > mem_size_aligned)
10014314:	e30c3424 	movw	r3, #50212	; 0xc424
10014318:	e3413003 	movt	r3, #4099	; 0x1003
1001431c:	e5933000 	ldr	r3, [r3]
10014320:	e51b2020 	ldr	r2, [fp, #-32]
10014324:	e1520003 	cmp	r2, r3
10014328:	9a000001 	bls	10014334 <rt_malloc+0xa0>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));

        return RT_NULL;
1001432c:	e3a03000 	mov	r3, #0
10014330:	ea000112 	b	10014780 <rt_malloc+0x4ec>
    }

    /* every data block must be at least MIN_SIZE_ALIGNED long */
    if (size < MIN_SIZE_ALIGNED)
10014334:	e51b3020 	ldr	r3, [fp, #-32]
10014338:	e353000b 	cmp	r3, #11
1001433c:	8a000001 	bhi	10014348 <rt_malloc+0xb4>
        size = MIN_SIZE_ALIGNED;
10014340:	e3a0300c 	mov	r3, #12
10014344:	e50b3020 	str	r3, [fp, #-32]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
10014348:	e30c0408 	movw	r0, #50184	; 0xc408
1001434c:	e3410003 	movt	r0, #4099	; 0x1003
10014350:	e3e01000 	mvn	r1, #0
10014354:	ebffec44 	bl	1000f46c <rt_sem_take>

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
10014358:	e30c3404 	movw	r3, #50180	; 0xc404
1001435c:	e3413003 	movt	r3, #4099	; 0x1003
10014360:	e5933000 	ldr	r3, [r3]
10014364:	e1a02003 	mov	r2, r3
10014368:	e30c33fc 	movw	r3, #50172	; 0xc3fc
1001436c:	e3413003 	movt	r3, #4099	; 0x1003
10014370:	e5933000 	ldr	r3, [r3]
10014374:	e0633002 	rsb	r3, r3, r2
10014378:	e50b3008 	str	r3, [fp, #-8]
1001437c:	ea0000f3 	b	10014750 <rt_malloc+0x4bc>
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
    {
        mem = (struct heap_mem *)&heap_ptr[ptr];
10014380:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014384:	e3413003 	movt	r3, #4099	; 0x1003
10014388:	e5932000 	ldr	r2, [r3]
1001438c:	e51b3008 	ldr	r3, [fp, #-8]
10014390:	e0823003 	add	r3, r2, r3
10014394:	e50b3010 	str	r3, [fp, #-16]

        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
10014398:	e51b3010 	ldr	r3, [fp, #-16]
1001439c:	e1d330b2 	ldrh	r3, [r3, #2]
100143a0:	e3530000 	cmp	r3, #0
100143a4:	1a0000e2 	bne	10014734 <rt_malloc+0x4a0>
100143a8:	e51b3010 	ldr	r3, [fp, #-16]
100143ac:	e5932004 	ldr	r2, [r3, #4]
100143b0:	e51b3008 	ldr	r3, [fp, #-8]
100143b4:	e0633002 	rsb	r3, r3, r2
100143b8:	e243200c 	sub	r2, r3, #12
100143bc:	e51b3020 	ldr	r3, [fp, #-32]
100143c0:	e1520003 	cmp	r2, r3
100143c4:	3a0000da 	bcc	10014734 <rt_malloc+0x4a0>
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
100143c8:	e51b3010 	ldr	r3, [fp, #-16]
100143cc:	e5932004 	ldr	r2, [r3, #4]
100143d0:	e51b3008 	ldr	r3, [fp, #-8]
100143d4:	e0633002 	rsb	r3, r3, r2
100143d8:	e243200c 	sub	r2, r3, #12
                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
100143dc:	e51b3020 	ldr	r3, [fp, #-32]
100143e0:	e2833018 	add	r3, r3, #24
        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
100143e4:	e1520003 	cmp	r2, r3
100143e8:	3a000042 	bcc	100144f8 <rt_malloc+0x264>
                 * struct heap_mem would fit in but no data between mem2 and mem2->next
                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
                 *       region that couldn't hold data, but when mem->next gets freed,
                 *       the 2 regions would be combined, resulting in more free memory
                 */
                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
100143ec:	e51b2008 	ldr	r2, [fp, #-8]
100143f0:	e51b3020 	ldr	r3, [fp, #-32]
100143f4:	e0823003 	add	r3, r2, r3
100143f8:	e283300c 	add	r3, r3, #12
100143fc:	e50b3014 	str	r3, [fp, #-20]

                /* create mem2 struct */
                mem2       = (struct heap_mem *)&heap_ptr[ptr2];
10014400:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014404:	e3413003 	movt	r3, #4099	; 0x1003
10014408:	e5932000 	ldr	r2, [r3]
1001440c:	e51b3014 	ldr	r3, [fp, #-20]
10014410:	e0823003 	add	r3, r2, r3
10014414:	e50b3018 	str	r3, [fp, #-24]
                mem2->used = 0;
10014418:	e51b3018 	ldr	r3, [fp, #-24]
1001441c:	e3a02000 	mov	r2, #0
10014420:	e1c320b2 	strh	r2, [r3, #2]
                mem2->next = mem->next;
10014424:	e51b3010 	ldr	r3, [fp, #-16]
10014428:	e5932004 	ldr	r2, [r3, #4]
1001442c:	e51b3018 	ldr	r3, [fp, #-24]
10014430:	e5832004 	str	r2, [r3, #4]
                mem2->prev = ptr;
10014434:	e51b3018 	ldr	r3, [fp, #-24]
10014438:	e51b2008 	ldr	r2, [fp, #-8]
1001443c:	e5832008 	str	r2, [r3, #8]

                /* and insert it between mem and mem->next */
                mem->next = ptr2;
10014440:	e51b3010 	ldr	r3, [fp, #-16]
10014444:	e51b2014 	ldr	r2, [fp, #-20]
10014448:	e5832004 	str	r2, [r3, #4]
                mem->used = 1;
1001444c:	e51b3010 	ldr	r3, [fp, #-16]
10014450:	e3a02001 	mov	r2, #1
10014454:	e1c320b2 	strh	r2, [r3, #2]

                if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
10014458:	e51b3018 	ldr	r3, [fp, #-24]
1001445c:	e5932004 	ldr	r2, [r3, #4]
10014460:	e30c3424 	movw	r3, #50212	; 0xc424
10014464:	e3413003 	movt	r3, #4099	; 0x1003
10014468:	e5933000 	ldr	r3, [r3]
1001446c:	e283300c 	add	r3, r3, #12
10014470:	e1520003 	cmp	r2, r3
10014474:	0a000007 	beq	10014498 <rt_malloc+0x204>
                {
                    ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
10014478:	e30c33fc 	movw	r3, #50172	; 0xc3fc
1001447c:	e3413003 	movt	r3, #4099	; 0x1003
10014480:	e5932000 	ldr	r2, [r3]
10014484:	e51b3018 	ldr	r3, [fp, #-24]
10014488:	e5933004 	ldr	r3, [r3, #4]
1001448c:	e0823003 	add	r3, r2, r3
10014490:	e51b2014 	ldr	r2, [fp, #-20]
10014494:	e5832008 	str	r2, [r3, #8]
                }
#ifdef RT_MEM_STATS
                used_mem += (size + SIZEOF_STRUCT_MEM);
10014498:	e30c3428 	movw	r3, #50216	; 0xc428
1001449c:	e3413003 	movt	r3, #4099	; 0x1003
100144a0:	e5932000 	ldr	r2, [r3]
100144a4:	e51b3020 	ldr	r3, [fp, #-32]
100144a8:	e0823003 	add	r3, r2, r3
100144ac:	e283200c 	add	r2, r3, #12
100144b0:	e30c3428 	movw	r3, #50216	; 0xc428
100144b4:	e3413003 	movt	r3, #4099	; 0x1003
100144b8:	e5832000 	str	r2, [r3]
                if (max_mem < used_mem)
100144bc:	e30c342c 	movw	r3, #50220	; 0xc42c
100144c0:	e3413003 	movt	r3, #4099	; 0x1003
100144c4:	e5932000 	ldr	r2, [r3]
100144c8:	e30c3428 	movw	r3, #50216	; 0xc428
100144cc:	e3413003 	movt	r3, #4099	; 0x1003
100144d0:	e5933000 	ldr	r3, [r3]
100144d4:	e1520003 	cmp	r2, r3
100144d8:	2a000027 	bcs	1001457c <rt_malloc+0x2e8>
                    max_mem = used_mem;
100144dc:	e30c3428 	movw	r3, #50216	; 0xc428
100144e0:	e3413003 	movt	r3, #4099	; 0x1003
100144e4:	e5932000 	ldr	r2, [r3]
100144e8:	e30c342c 	movw	r3, #50220	; 0xc42c
100144ec:	e3413003 	movt	r3, #4099	; 0x1003
100144f0:	e5832000 	str	r2, [r3]
100144f4:	ea000020 	b	1001457c <rt_malloc+0x2e8>
                 * take care of this).
                 * -> near fit or excact fit: do not split, no mem2 creation
                 * also can't move mem->next directly behind mem, since mem->next
                 * will always be used at this point!
                 */
                mem->used = 1;
100144f8:	e51b3010 	ldr	r3, [fp, #-16]
100144fc:	e3a02001 	mov	r2, #1
10014500:	e1c320b2 	strh	r2, [r3, #2]
#ifdef RT_MEM_STATS
                used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
10014504:	e51b3010 	ldr	r3, [fp, #-16]
10014508:	e5932004 	ldr	r2, [r3, #4]
1001450c:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014510:	e3413003 	movt	r3, #4099	; 0x1003
10014514:	e5933000 	ldr	r3, [r3]
10014518:	e1a01003 	mov	r1, r3
1001451c:	e51b3010 	ldr	r3, [fp, #-16]
10014520:	e0633001 	rsb	r3, r3, r1
10014524:	e0822003 	add	r2, r2, r3
10014528:	e30c3428 	movw	r3, #50216	; 0xc428
1001452c:	e3413003 	movt	r3, #4099	; 0x1003
10014530:	e5933000 	ldr	r3, [r3]
10014534:	e0822003 	add	r2, r2, r3
10014538:	e30c3428 	movw	r3, #50216	; 0xc428
1001453c:	e3413003 	movt	r3, #4099	; 0x1003
10014540:	e5832000 	str	r2, [r3]
                if (max_mem < used_mem)
10014544:	e30c342c 	movw	r3, #50220	; 0xc42c
10014548:	e3413003 	movt	r3, #4099	; 0x1003
1001454c:	e5932000 	ldr	r2, [r3]
10014550:	e30c3428 	movw	r3, #50216	; 0xc428
10014554:	e3413003 	movt	r3, #4099	; 0x1003
10014558:	e5933000 	ldr	r3, [r3]
1001455c:	e1520003 	cmp	r2, r3
10014560:	2a000005 	bcs	1001457c <rt_malloc+0x2e8>
                    max_mem = used_mem;
10014564:	e30c3428 	movw	r3, #50216	; 0xc428
10014568:	e3413003 	movt	r3, #4099	; 0x1003
1001456c:	e5932000 	ldr	r2, [r3]
10014570:	e30c342c 	movw	r3, #50220	; 0xc42c
10014574:	e3413003 	movt	r3, #4099	; 0x1003
10014578:	e5832000 	str	r2, [r3]
#endif
            }
            /* set memory block magic */
            mem->magic = HEAP_MAGIC;
1001457c:	e51b3010 	ldr	r3, [fp, #-16]
10014580:	e3012ea0 	movw	r2, #7840	; 0x1ea0
10014584:	e1c320b0 	strh	r2, [r3]

            if (mem == lfree)
10014588:	e30c3404 	movw	r3, #50180	; 0xc404
1001458c:	e3413003 	movt	r3, #4099	; 0x1003
10014590:	e5933000 	ldr	r3, [r3]
10014594:	e51b2010 	ldr	r2, [fp, #-16]
10014598:	e1520003 	cmp	r2, r3
1001459c:	1a00002d 	bne	10014658 <rt_malloc+0x3c4>
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
100145a0:	ea00000a 	b	100145d0 <rt_malloc+0x33c>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];
100145a4:	e30c33fc 	movw	r3, #50172	; 0xc3fc
100145a8:	e3413003 	movt	r3, #4099	; 0x1003
100145ac:	e5932000 	ldr	r2, [r3]
100145b0:	e30c3404 	movw	r3, #50180	; 0xc404
100145b4:	e3413003 	movt	r3, #4099	; 0x1003
100145b8:	e5933000 	ldr	r3, [r3]
100145bc:	e5933004 	ldr	r3, [r3, #4]
100145c0:	e0822003 	add	r2, r2, r3
100145c4:	e30c3404 	movw	r3, #50180	; 0xc404
100145c8:	e3413003 	movt	r3, #4099	; 0x1003
100145cc:	e5832000 	str	r2, [r3]
            mem->magic = HEAP_MAGIC;

            if (mem == lfree)
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
100145d0:	e30c3404 	movw	r3, #50180	; 0xc404
100145d4:	e3413003 	movt	r3, #4099	; 0x1003
100145d8:	e5933000 	ldr	r3, [r3]
100145dc:	e1d330b2 	ldrh	r3, [r3, #2]
100145e0:	e3530000 	cmp	r3, #0
100145e4:	0a000007 	beq	10014608 <rt_malloc+0x374>
100145e8:	e30c3404 	movw	r3, #50180	; 0xc404
100145ec:	e3413003 	movt	r3, #4099	; 0x1003
100145f0:	e5932000 	ldr	r2, [r3]
100145f4:	e30c3400 	movw	r3, #50176	; 0xc400
100145f8:	e3413003 	movt	r3, #4099	; 0x1003
100145fc:	e5933000 	ldr	r3, [r3]
10014600:	e1520003 	cmp	r2, r3
10014604:	1affffe6 	bne	100145a4 <rt_malloc+0x310>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];

                RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
10014608:	e30c3404 	movw	r3, #50180	; 0xc404
1001460c:	e3413003 	movt	r3, #4099	; 0x1003
10014610:	e5932000 	ldr	r2, [r3]
10014614:	e30c3400 	movw	r3, #50176	; 0xc400
10014618:	e3413003 	movt	r3, #4099	; 0x1003
1001461c:	e5933000 	ldr	r3, [r3]
10014620:	e1520003 	cmp	r2, r3
10014624:	0a00000b 	beq	10014658 <rt_malloc+0x3c4>
10014628:	e30c3404 	movw	r3, #50180	; 0xc404
1001462c:	e3413003 	movt	r3, #4099	; 0x1003
10014630:	e5933000 	ldr	r3, [r3]
10014634:	e1d330b2 	ldrh	r3, [r3, #2]
10014638:	e3530000 	cmp	r3, #0
1001463c:	0a000005 	beq	10014658 <rt_malloc+0x3c4>
10014640:	e30309d4 	movw	r0, #14804	; 0x39d4
10014644:	e3410003 	movt	r0, #4099	; 0x1003
10014648:	e3031bdc 	movw	r1, #15324	; 0x3bdc
1001464c:	e3411003 	movt	r1, #4099	; 0x1003
10014650:	e300215e 	movw	r2, #350	; 0x15e
10014654:	ebfffdd6 	bl	10013db4 <rt_assert_handler>
            }

            rt_sem_release(&heap_sem);
10014658:	e30c0408 	movw	r0, #50184	; 0xc408
1001465c:	e3410003 	movt	r0, #4099	; 0x1003
10014660:	ebffec15 	bl	1000f6bc <rt_sem_release>
            RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
10014664:	e51b2010 	ldr	r2, [fp, #-16]
10014668:	e51b3020 	ldr	r3, [fp, #-32]
1001466c:	e0823003 	add	r3, r2, r3
10014670:	e283200c 	add	r2, r3, #12
10014674:	e30c3400 	movw	r3, #50176	; 0xc400
10014678:	e3413003 	movt	r3, #4099	; 0x1003
1001467c:	e5933000 	ldr	r3, [r3]
10014680:	e1520003 	cmp	r2, r3
10014684:	9a000005 	bls	100146a0 <rt_malloc+0x40c>
10014688:	e30309fc 	movw	r0, #14844	; 0x39fc
1001468c:	e3410003 	movt	r0, #4099	; 0x1003
10014690:	e3031bdc 	movw	r1, #15324	; 0x3bdc
10014694:	e3411003 	movt	r1, #4099	; 0x1003
10014698:	e3002162 	movw	r2, #354	; 0x162
1001469c:	ebfffdc4 	bl	10013db4 <rt_assert_handler>
            RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
100146a0:	e51b3010 	ldr	r3, [fp, #-16]
100146a4:	e283300c 	add	r3, r3, #12
100146a8:	e2033003 	and	r3, r3, #3
100146ac:	e3530000 	cmp	r3, #0
100146b0:	0a000005 	beq	100146cc <rt_malloc+0x438>
100146b4:	e3030a44 	movw	r0, #14916	; 0x3a44
100146b8:	e3410003 	movt	r0, #4099	; 0x1003
100146bc:	e3031bdc 	movw	r1, #15324	; 0x3bdc
100146c0:	e3411003 	movt	r1, #4099	; 0x1003
100146c4:	e3002163 	movw	r2, #355	; 0x163
100146c8:	ebfffdb9 	bl	10013db4 <rt_assert_handler>
            RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
100146cc:	e51b3010 	ldr	r3, [fp, #-16]
100146d0:	e2033003 	and	r3, r3, #3
100146d4:	e3530000 	cmp	r3, #0
100146d8:	0a000005 	beq	100146f4 <rt_malloc+0x460>
100146dc:	e3030a90 	movw	r0, #14992	; 0x3a90
100146e0:	e3410003 	movt	r0, #4099	; 0x1003
100146e4:	e3031bdc 	movw	r1, #15324	; 0x3bdc
100146e8:	e3411003 	movt	r1, #4099	; 0x1003
100146ec:	e3a02f59 	mov	r2, #356	; 0x164
100146f0:	ebfffdaf 	bl	10013db4 <rt_assert_handler>
            RT_DEBUG_LOG(RT_DEBUG_MEM,
                         ("allocate memory at 0x%x, size: %d\n",
                          (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
                          (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));

            RT_OBJECT_HOOK_CALL(rt_malloc_hook,
100146f4:	e30c33f4 	movw	r3, #50164	; 0xc3f4
100146f8:	e3413003 	movt	r3, #4099	; 0x1003
100146fc:	e5933000 	ldr	r3, [r3]
10014700:	e3530000 	cmp	r3, #0
10014704:	0a000007 	beq	10014728 <rt_malloc+0x494>
10014708:	e30c33f4 	movw	r3, #50164	; 0xc3f4
1001470c:	e3413003 	movt	r3, #4099	; 0x1003
10014710:	e5933000 	ldr	r3, [r3]
10014714:	e51b2010 	ldr	r2, [fp, #-16]
10014718:	e282200c 	add	r2, r2, #12
1001471c:	e1a00002 	mov	r0, r2
10014720:	e51b1020 	ldr	r1, [fp, #-32]
10014724:	e12fff33 	blx	r3
                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));

            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
10014728:	e51b3010 	ldr	r3, [fp, #-16]
1001472c:	e283300c 	add	r3, r3, #12
10014730:	ea000012 	b	10014780 <rt_malloc+0x4ec>
    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
10014734:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014738:	e3413003 	movt	r3, #4099	; 0x1003
1001473c:	e5932000 	ldr	r2, [r3]
10014740:	e51b3008 	ldr	r3, [fp, #-8]
10014744:	e0823003 	add	r3, r2, r3
10014748:	e5933004 	ldr	r3, [r3, #4]
1001474c:	e50b3008 	str	r3, [fp, #-8]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
10014750:	e30c3424 	movw	r3, #50212	; 0xc424
10014754:	e3413003 	movt	r3, #4099	; 0x1003
10014758:	e5932000 	ldr	r2, [r3]
1001475c:	e51b3020 	ldr	r3, [fp, #-32]
10014760:	e0632002 	rsb	r2, r3, r2
        size = MIN_SIZE_ALIGNED;

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
10014764:	e51b3008 	ldr	r3, [fp, #-8]
10014768:	e1520003 	cmp	r2, r3
1001476c:	8affff03 	bhi	10014380 <rt_malloc+0xec>
            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
        }
    }

    rt_sem_release(&heap_sem);
10014770:	e30c0408 	movw	r0, #50184	; 0xc408
10014774:	e3410003 	movt	r0, #4099	; 0x1003
10014778:	ebffebcf 	bl	1000f6bc <rt_sem_release>

    return RT_NULL;
1001477c:	e3a03000 	mov	r3, #0
}
10014780:	e1a00003 	mov	r0, r3
10014784:	e24bd004 	sub	sp, fp, #4
10014788:	e8bd8800 	pop	{fp, pc}

1001478c <rt_realloc>:
 * @param newsize the required new size
 *
 * @return the changed memory block address
 */
void *rt_realloc(void *rmem, rt_size_t newsize)
{
1001478c:	e92d4800 	push	{fp, lr}
10014790:	e28db004 	add	fp, sp, #4
10014794:	e24dd028 	sub	sp, sp, #40	; 0x28
10014798:	e50b0028 	str	r0, [fp, #-40]	; 0x28
1001479c:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
    rt_size_t size;
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;
    void *nmem;

    RT_DEBUG_NOT_IN_INTERRUPT;
100147a0:	eb0013a2 	bl	10019630 <rt_hw_interrupt_disable>
100147a4:	e50b0008 	str	r0, [fp, #-8]
100147a8:	ebfff654 	bl	10012100 <rt_interrupt_get_nest>
100147ac:	e1a03000 	mov	r3, r0
100147b0:	e3530000 	cmp	r3, #0
100147b4:	0a00000a 	beq	100147e4 <rt_realloc+0x58>
100147b8:	e3030968 	movw	r0, #14696	; 0x3968
100147bc:	e3410003 	movt	r0, #4099	; 0x1003
100147c0:	e3031be8 	movw	r1, #15336	; 0x3be8
100147c4:	e3411003 	movt	r1, #4099	; 0x1003
100147c8:	ebfffcbc 	bl	10013ac0 <rt_kprintf>
100147cc:	e303098c 	movw	r0, #14732	; 0x398c
100147d0:	e3410003 	movt	r0, #4099	; 0x1003
100147d4:	e3031be8 	movw	r1, #15336	; 0x3be8
100147d8:	e3411003 	movt	r1, #4099	; 0x1003
100147dc:	e3a02f62 	mov	r2, #392	; 0x188
100147e0:	ebfffd73 	bl	10013db4 <rt_assert_handler>
100147e4:	e51b0008 	ldr	r0, [fp, #-8]
100147e8:	eb001394 	bl	10019640 <rt_hw_interrupt_enable>

    /* alignment size */
    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
100147ec:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
100147f0:	e2833003 	add	r3, r3, #3
100147f4:	e3c33003 	bic	r3, r3, #3
100147f8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    if (newsize > mem_size_aligned)
100147fc:	e30c3424 	movw	r3, #50212	; 0xc424
10014800:	e3413003 	movt	r3, #4099	; 0x1003
10014804:	e5933000 	ldr	r3, [r3]
10014808:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
1001480c:	e1520003 	cmp	r2, r3
10014810:	9a000001 	bls	1001481c <rt_realloc+0x90>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));

        return RT_NULL;
10014814:	e3a03000 	mov	r3, #0
10014818:	ea000089 	b	10014a44 <rt_realloc+0x2b8>
    }

    /* allocate a new memory block */
    if (rmem == RT_NULL)
1001481c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014820:	e3530000 	cmp	r3, #0
10014824:	1a000003 	bne	10014838 <rt_realloc+0xac>
        return rt_malloc(newsize);
10014828:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
1001482c:	ebfffe98 	bl	10014294 <rt_malloc>
10014830:	e1a03000 	mov	r3, r0
10014834:	ea000082 	b	10014a44 <rt_realloc+0x2b8>

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
10014838:	e30c0408 	movw	r0, #50184	; 0xc408
1001483c:	e3410003 	movt	r0, #4099	; 0x1003
10014840:	e3e01000 	mvn	r1, #0
10014844:	ebffeb08 	bl	1000f46c <rt_sem_take>

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
10014848:	e30c33fc 	movw	r3, #50172	; 0xc3fc
1001484c:	e3413003 	movt	r3, #4099	; 0x1003
10014850:	e5933000 	ldr	r3, [r3]
10014854:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10014858:	e1520003 	cmp	r2, r3
1001485c:	3a000005 	bcc	10014878 <rt_realloc+0xec>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
10014860:	e30c3400 	movw	r3, #50176	; 0xc400
10014864:	e3413003 	movt	r3, #4099	; 0x1003
10014868:	e5933000 	ldr	r3, [r3]
    if (rmem == RT_NULL)
        return rt_malloc(newsize);

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
1001486c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10014870:	e1520003 	cmp	r2, r3
10014874:	3a000004 	bcc	1001488c <rt_realloc+0x100>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        /* illegal memory */
        rt_sem_release(&heap_sem);
10014878:	e30c0408 	movw	r0, #50184	; 0xc408
1001487c:	e3410003 	movt	r0, #4099	; 0x1003
10014880:	ebffeb8d 	bl	1000f6bc <rt_sem_release>

        return rmem;
10014884:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014888:	ea00006d 	b	10014a44 <rt_realloc+0x2b8>
    }

    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
1001488c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014890:	e243300c 	sub	r3, r3, #12
10014894:	e50b300c 	str	r3, [fp, #-12]

    ptr = (rt_uint8_t *)mem - heap_ptr;
10014898:	e51b200c 	ldr	r2, [fp, #-12]
1001489c:	e30c33fc 	movw	r3, #50172	; 0xc3fc
100148a0:	e3413003 	movt	r3, #4099	; 0x1003
100148a4:	e5933000 	ldr	r3, [r3]
100148a8:	e0633002 	rsb	r3, r3, r2
100148ac:	e50b3010 	str	r3, [fp, #-16]
    size = mem->next - ptr - SIZEOF_STRUCT_MEM;
100148b0:	e51b300c 	ldr	r3, [fp, #-12]
100148b4:	e5932004 	ldr	r2, [r3, #4]
100148b8:	e51b3010 	ldr	r3, [fp, #-16]
100148bc:	e0633002 	rsb	r3, r3, r2
100148c0:	e243300c 	sub	r3, r3, #12
100148c4:	e50b3014 	str	r3, [fp, #-20]
    if (size == newsize)
100148c8:	e51b2014 	ldr	r2, [fp, #-20]
100148cc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
100148d0:	e1520003 	cmp	r2, r3
100148d4:	1a000004 	bne	100148ec <rt_realloc+0x160>
    {
        /* the size is the same as */
        rt_sem_release(&heap_sem);
100148d8:	e30c0408 	movw	r0, #50184	; 0xc408
100148dc:	e3410003 	movt	r0, #4099	; 0x1003
100148e0:	ebffeb75 	bl	1000f6bc <rt_sem_release>

        return rmem;
100148e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100148e8:	ea000055 	b	10014a44 <rt_realloc+0x2b8>
    }

    if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
100148ec:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
100148f0:	e2832018 	add	r2, r3, #24
100148f4:	e51b3014 	ldr	r3, [fp, #-20]
100148f8:	e1520003 	cmp	r2, r3
100148fc:	2a00003b 	bcs	100149f0 <rt_realloc+0x264>
    {
        /* split memory block */
#ifdef RT_MEM_STATS
        used_mem -= (size - newsize);
10014900:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
10014904:	e51b3014 	ldr	r3, [fp, #-20]
10014908:	e0632002 	rsb	r2, r3, r2
1001490c:	e30c3428 	movw	r3, #50216	; 0xc428
10014910:	e3413003 	movt	r3, #4099	; 0x1003
10014914:	e5933000 	ldr	r3, [r3]
10014918:	e0822003 	add	r2, r2, r3
1001491c:	e30c3428 	movw	r3, #50216	; 0xc428
10014920:	e3413003 	movt	r3, #4099	; 0x1003
10014924:	e5832000 	str	r2, [r3]
#endif

        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
10014928:	e51b2010 	ldr	r2, [fp, #-16]
1001492c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10014930:	e0823003 	add	r3, r2, r3
10014934:	e283300c 	add	r3, r3, #12
10014938:	e50b3018 	str	r3, [fp, #-24]
        mem2 = (struct heap_mem *)&heap_ptr[ptr2];
1001493c:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014940:	e3413003 	movt	r3, #4099	; 0x1003
10014944:	e5932000 	ldr	r2, [r3]
10014948:	e51b3018 	ldr	r3, [fp, #-24]
1001494c:	e0823003 	add	r3, r2, r3
10014950:	e50b301c 	str	r3, [fp, #-28]
        mem2->magic= HEAP_MAGIC;
10014954:	e51b301c 	ldr	r3, [fp, #-28]
10014958:	e3012ea0 	movw	r2, #7840	; 0x1ea0
1001495c:	e1c320b0 	strh	r2, [r3]
        mem2->used = 0;
10014960:	e51b301c 	ldr	r3, [fp, #-28]
10014964:	e3a02000 	mov	r2, #0
10014968:	e1c320b2 	strh	r2, [r3, #2]
        mem2->next = mem->next;
1001496c:	e51b300c 	ldr	r3, [fp, #-12]
10014970:	e5932004 	ldr	r2, [r3, #4]
10014974:	e51b301c 	ldr	r3, [fp, #-28]
10014978:	e5832004 	str	r2, [r3, #4]
        mem2->prev = ptr;
1001497c:	e51b301c 	ldr	r3, [fp, #-28]
10014980:	e51b2010 	ldr	r2, [fp, #-16]
10014984:	e5832008 	str	r2, [r3, #8]
        mem->next = ptr2;
10014988:	e51b300c 	ldr	r3, [fp, #-12]
1001498c:	e51b2018 	ldr	r2, [fp, #-24]
10014990:	e5832004 	str	r2, [r3, #4]
        if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
10014994:	e51b301c 	ldr	r3, [fp, #-28]
10014998:	e5932004 	ldr	r2, [r3, #4]
1001499c:	e30c3424 	movw	r3, #50212	; 0xc424
100149a0:	e3413003 	movt	r3, #4099	; 0x1003
100149a4:	e5933000 	ldr	r3, [r3]
100149a8:	e283300c 	add	r3, r3, #12
100149ac:	e1520003 	cmp	r2, r3
100149b0:	0a000007 	beq	100149d4 <rt_realloc+0x248>
        {
            ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
100149b4:	e30c33fc 	movw	r3, #50172	; 0xc3fc
100149b8:	e3413003 	movt	r3, #4099	; 0x1003
100149bc:	e5932000 	ldr	r2, [r3]
100149c0:	e51b301c 	ldr	r3, [fp, #-28]
100149c4:	e5933004 	ldr	r3, [r3, #4]
100149c8:	e0823003 	add	r3, r2, r3
100149cc:	e51b2018 	ldr	r2, [fp, #-24]
100149d0:	e5832008 	str	r2, [r3, #8]
        }

        plug_holes(mem2);
100149d4:	e51b001c 	ldr	r0, [fp, #-28]
100149d8:	ebfffd2d 	bl	10013e94 <plug_holes>

        rt_sem_release(&heap_sem);
100149dc:	e30c0408 	movw	r0, #50184	; 0xc408
100149e0:	e3410003 	movt	r0, #4099	; 0x1003
100149e4:	ebffeb34 	bl	1000f6bc <rt_sem_release>

        return rmem;
100149e8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100149ec:	ea000014 	b	10014a44 <rt_realloc+0x2b8>
    }
    rt_sem_release(&heap_sem);
100149f0:	e30c0408 	movw	r0, #50184	; 0xc408
100149f4:	e3410003 	movt	r0, #4099	; 0x1003
100149f8:	ebffeb2f 	bl	1000f6bc <rt_sem_release>

    /* expand memory */
    nmem = rt_malloc(newsize);
100149fc:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
10014a00:	ebfffe23 	bl	10014294 <rt_malloc>
10014a04:	e50b0020 	str	r0, [fp, #-32]
    if (nmem != RT_NULL) /* check memory */
10014a08:	e51b3020 	ldr	r3, [fp, #-32]
10014a0c:	e3530000 	cmp	r3, #0
10014a10:	0a00000a 	beq	10014a40 <rt_realloc+0x2b4>
    {
        rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
10014a14:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
10014a18:	e51b3014 	ldr	r3, [fp, #-20]
10014a1c:	e1520003 	cmp	r2, r3
10014a20:	31a03002 	movcc	r3, r2
10014a24:	21a03003 	movcs	r3, r3
10014a28:	e51b0020 	ldr	r0, [fp, #-32]
10014a2c:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
10014a30:	e1a02003 	mov	r2, r3
10014a34:	ebfff65f 	bl	100123b8 <rt_memcpy>
        rt_free(rmem);
10014a38:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10014a3c:	eb00002f 	bl	10014b00 <rt_free>
    }

    return nmem;
10014a40:	e51b3020 	ldr	r3, [fp, #-32]
}
10014a44:	e1a00003 	mov	r0, r3
10014a48:	e24bd004 	sub	sp, fp, #4
10014a4c:	e8bd8800 	pop	{fp, pc}

10014a50 <rt_calloc>:
 * @param size size of the objects to allocate
 *
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *rt_calloc(rt_size_t count, rt_size_t size)
{
10014a50:	e92d4800 	push	{fp, lr}
10014a54:	e28db004 	add	fp, sp, #4
10014a58:	e24dd010 	sub	sp, sp, #16
10014a5c:	e50b0010 	str	r0, [fp, #-16]
10014a60:	e50b1014 	str	r1, [fp, #-20]
    void *p;

    RT_DEBUG_NOT_IN_INTERRUPT;
10014a64:	eb0012f1 	bl	10019630 <rt_hw_interrupt_disable>
10014a68:	e50b0008 	str	r0, [fp, #-8]
10014a6c:	ebfff5a3 	bl	10012100 <rt_interrupt_get_nest>
10014a70:	e1a03000 	mov	r3, r0
10014a74:	e3530000 	cmp	r3, #0
10014a78:	0a00000a 	beq	10014aa8 <rt_calloc+0x58>
10014a7c:	e3030968 	movw	r0, #14696	; 0x3968
10014a80:	e3410003 	movt	r0, #4099	; 0x1003
10014a84:	e3031bf4 	movw	r1, #15348	; 0x3bf4
10014a88:	e3411003 	movt	r1, #4099	; 0x1003
10014a8c:	ebfffc0b 	bl	10013ac0 <rt_kprintf>
10014a90:	e303098c 	movw	r0, #14732	; 0x398c
10014a94:	e3410003 	movt	r0, #4099	; 0x1003
10014a98:	e3031bf4 	movw	r1, #15348	; 0x3bf4
10014a9c:	e3411003 	movt	r1, #4099	; 0x1003
10014aa0:	e30021e5 	movw	r2, #485	; 0x1e5
10014aa4:	ebfffcc2 	bl	10013db4 <rt_assert_handler>
10014aa8:	e51b0008 	ldr	r0, [fp, #-8]
10014aac:	eb0012e3 	bl	10019640 <rt_hw_interrupt_enable>

    /* allocate 'count' objects of size 'size' */
    p = rt_malloc(count * size);
10014ab0:	e51b3010 	ldr	r3, [fp, #-16]
10014ab4:	e51b2014 	ldr	r2, [fp, #-20]
10014ab8:	e0030392 	mul	r3, r2, r3
10014abc:	e1a00003 	mov	r0, r3
10014ac0:	ebfffdf3 	bl	10014294 <rt_malloc>
10014ac4:	e50b000c 	str	r0, [fp, #-12]

    /* zero the memory */
    if (p)
10014ac8:	e51b300c 	ldr	r3, [fp, #-12]
10014acc:	e3530000 	cmp	r3, #0
10014ad0:	0a000006 	beq	10014af0 <rt_calloc+0xa0>
        rt_memset(p, 0, count * size);
10014ad4:	e51b3010 	ldr	r3, [fp, #-16]
10014ad8:	e51b2014 	ldr	r2, [fp, #-20]
10014adc:	e0030392 	mul	r3, r2, r3
10014ae0:	e51b000c 	ldr	r0, [fp, #-12]
10014ae4:	e3a01000 	mov	r1, #0
10014ae8:	e1a02003 	mov	r2, r3
10014aec:	ebfff5d9 	bl	10012258 <rt_memset>

    return p;
10014af0:	e51b300c 	ldr	r3, [fp, #-12]
}
10014af4:	e1a00003 	mov	r0, r3
10014af8:	e24bd004 	sub	sp, fp, #4
10014afc:	e8bd8800 	pop	{fp, pc}

10014b00 <rt_free>:
 * rt_malloc. The released memory block is taken back to system heap.
 *
 * @param rmem the address of memory which will be released
 */
void rt_free(void *rmem)
{
10014b00:	e92d4800 	push	{fp, lr}
10014b04:	e28db004 	add	fp, sp, #4
10014b08:	e24dd010 	sub	sp, sp, #16
10014b0c:	e50b0010 	str	r0, [fp, #-16]
    struct heap_mem *mem;

    RT_DEBUG_NOT_IN_INTERRUPT;
10014b10:	eb0012c6 	bl	10019630 <rt_hw_interrupt_disable>
10014b14:	e50b0008 	str	r0, [fp, #-8]
10014b18:	ebfff578 	bl	10012100 <rt_interrupt_get_nest>
10014b1c:	e1a03000 	mov	r3, r0
10014b20:	e3530000 	cmp	r3, #0
10014b24:	0a00000a 	beq	10014b54 <rt_free+0x54>
10014b28:	e3030968 	movw	r0, #14696	; 0x3968
10014b2c:	e3410003 	movt	r0, #4099	; 0x1003
10014b30:	e3031c00 	movw	r1, #15360	; 0x3c00
10014b34:	e3411003 	movt	r1, #4099	; 0x1003
10014b38:	ebfffbe0 	bl	10013ac0 <rt_kprintf>
10014b3c:	e303098c 	movw	r0, #14732	; 0x398c
10014b40:	e3410003 	movt	r0, #4099	; 0x1003
10014b44:	e3031c00 	movw	r1, #15360	; 0x3c00
10014b48:	e3411003 	movt	r1, #4099	; 0x1003
10014b4c:	e3a02f7f 	mov	r2, #508	; 0x1fc
10014b50:	ebfffc97 	bl	10013db4 <rt_assert_handler>
10014b54:	e51b0008 	ldr	r0, [fp, #-8]
10014b58:	eb0012b8 	bl	10019640 <rt_hw_interrupt_enable>

    if (rmem == RT_NULL)
10014b5c:	e51b3010 	ldr	r3, [fp, #-16]
10014b60:	e3530000 	cmp	r3, #0
10014b64:	1a000000 	bne	10014b6c <rt_free+0x6c>
        return;
10014b68:	ea000073 	b	10014d3c <rt_free+0x23c>
    RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
10014b6c:	e51b3010 	ldr	r3, [fp, #-16]
10014b70:	e2033003 	and	r3, r3, #3
10014b74:	e3530000 	cmp	r3, #0
10014b78:	0a000005 	beq	10014b94 <rt_free+0x94>
10014b7c:	e3030ac0 	movw	r0, #15040	; 0x3ac0
10014b80:	e3410003 	movt	r0, #4099	; 0x1003
10014b84:	e3031c00 	movw	r1, #15360	; 0x3c00
10014b88:	e3411003 	movt	r1, #4099	; 0x1003
10014b8c:	e3a02c02 	mov	r2, #512	; 0x200
10014b90:	ebfffc87 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
10014b94:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014b98:	e3413003 	movt	r3, #4099	; 0x1003
10014b9c:	e5933000 	ldr	r3, [r3]
10014ba0:	e51b2010 	ldr	r2, [fp, #-16]
10014ba4:	e1520003 	cmp	r2, r3
10014ba8:	3a000005 	bcc	10014bc4 <rt_free+0xc4>
10014bac:	e30c3400 	movw	r3, #50176	; 0xc400
10014bb0:	e3413003 	movt	r3, #4099	; 0x1003
10014bb4:	e5933000 	ldr	r3, [r3]
10014bb8:	e51b2010 	ldr	r2, [fp, #-16]
10014bbc:	e1520003 	cmp	r2, r3
10014bc0:	3a000005 	bcc	10014bdc <rt_free+0xdc>
10014bc4:	e3030af0 	movw	r0, #15088	; 0x3af0
10014bc8:	e3410003 	movt	r0, #4099	; 0x1003
10014bcc:	e3031c00 	movw	r1, #15360	; 0x3c00
10014bd0:	e3411003 	movt	r1, #4099	; 0x1003
10014bd4:	e3002202 	movw	r2, #514	; 0x202
10014bd8:	ebfffc75 	bl	10013db4 <rt_assert_handler>
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
10014bdc:	e30c33f8 	movw	r3, #50168	; 0xc3f8
10014be0:	e3413003 	movt	r3, #4099	; 0x1003
10014be4:	e5933000 	ldr	r3, [r3]
10014be8:	e3530000 	cmp	r3, #0
10014bec:	0a000004 	beq	10014c04 <rt_free+0x104>
10014bf0:	e30c33f8 	movw	r3, #50168	; 0xc3f8
10014bf4:	e3413003 	movt	r3, #4099	; 0x1003
10014bf8:	e5933000 	ldr	r3, [r3]
10014bfc:	e51b0010 	ldr	r0, [fp, #-16]
10014c00:	e12fff33 	blx	r3

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
10014c04:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014c08:	e3413003 	movt	r3, #4099	; 0x1003
10014c0c:	e5933000 	ldr	r3, [r3]
10014c10:	e51b2010 	ldr	r2, [fp, #-16]
10014c14:	e1520003 	cmp	r2, r3
10014c18:	3a000005 	bcc	10014c34 <rt_free+0x134>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
10014c1c:	e30c3400 	movw	r3, #50176	; 0xc400
10014c20:	e3413003 	movt	r3, #4099	; 0x1003
10014c24:	e5933000 	ldr	r3, [r3]
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
10014c28:	e51b2010 	ldr	r2, [fp, #-16]
10014c2c:	e1520003 	cmp	r2, r3
10014c30:	3a000000 	bcc	10014c38 <rt_free+0x138>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));

        return;
10014c34:	ea000040 	b	10014d3c <rt_free+0x23c>
    }

    /* Get the corresponding struct heap_mem ... */
    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
10014c38:	e51b3010 	ldr	r3, [fp, #-16]
10014c3c:	e243300c 	sub	r3, r3, #12
10014c40:	e50b300c 	str	r3, [fp, #-12]
                  (rt_uint32_t)rmem,
                  (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));


    /* protect the heap from concurrent access */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
10014c44:	e30c0408 	movw	r0, #50184	; 0xc408
10014c48:	e3410003 	movt	r0, #4099	; 0x1003
10014c4c:	e3e01000 	mvn	r1, #0
10014c50:	ebffea05 	bl	1000f46c <rt_sem_take>

    /* ... which has to be in a used state ... */
    RT_ASSERT(mem->used);
10014c54:	e51b300c 	ldr	r3, [fp, #-12]
10014c58:	e1d330b2 	ldrh	r3, [r3, #2]
10014c5c:	e3530000 	cmp	r3, #0
10014c60:	1a000005 	bne	10014c7c <rt_free+0x17c>
10014c64:	e3030b4c 	movw	r0, #15180	; 0x3b4c
10014c68:	e3410003 	movt	r0, #4099	; 0x1003
10014c6c:	e3031c00 	movw	r1, #15360	; 0x3c00
10014c70:	e3411003 	movt	r1, #4099	; 0x1003
10014c74:	e300221b 	movw	r2, #539	; 0x21b
10014c78:	ebfffc4d 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(mem->magic == HEAP_MAGIC);
10014c7c:	e51b300c 	ldr	r3, [fp, #-12]
10014c80:	e1d330b0 	ldrh	r3, [r3]
10014c84:	e3012ea0 	movw	r2, #7840	; 0x1ea0
10014c88:	e1530002 	cmp	r3, r2
10014c8c:	0a000005 	beq	10014ca8 <rt_free+0x1a8>
10014c90:	e3030b58 	movw	r0, #15192	; 0x3b58
10014c94:	e3410003 	movt	r0, #4099	; 0x1003
10014c98:	e3031c00 	movw	r1, #15360	; 0x3c00
10014c9c:	e3411003 	movt	r1, #4099	; 0x1003
10014ca0:	e3a02f87 	mov	r2, #540	; 0x21c
10014ca4:	ebfffc42 	bl	10013db4 <rt_assert_handler>
    /* ... and is now unused. */
    mem->used  = 0;
10014ca8:	e51b300c 	ldr	r3, [fp, #-12]
10014cac:	e3a02000 	mov	r2, #0
10014cb0:	e1c320b2 	strh	r2, [r3, #2]
    mem->magic = 0;
10014cb4:	e51b300c 	ldr	r3, [fp, #-12]
10014cb8:	e3a02000 	mov	r2, #0
10014cbc:	e1c320b0 	strh	r2, [r3]

    if (mem < lfree)
10014cc0:	e30c3404 	movw	r3, #50180	; 0xc404
10014cc4:	e3413003 	movt	r3, #4099	; 0x1003
10014cc8:	e5933000 	ldr	r3, [r3]
10014ccc:	e51b200c 	ldr	r2, [fp, #-12]
10014cd0:	e1520003 	cmp	r2, r3
10014cd4:	2a000003 	bcs	10014ce8 <rt_free+0x1e8>
    {
        /* the newly freed struct is now the lowest */
        lfree = mem;
10014cd8:	e30c3404 	movw	r3, #50180	; 0xc404
10014cdc:	e3413003 	movt	r3, #4099	; 0x1003
10014ce0:	e51b200c 	ldr	r2, [fp, #-12]
10014ce4:	e5832000 	str	r2, [r3]
    }

#ifdef RT_MEM_STATS
    used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
10014ce8:	e30c3428 	movw	r3, #50216	; 0xc428
10014cec:	e3413003 	movt	r3, #4099	; 0x1003
10014cf0:	e5932000 	ldr	r2, [r3]
10014cf4:	e51b300c 	ldr	r3, [fp, #-12]
10014cf8:	e5931004 	ldr	r1, [r3, #4]
10014cfc:	e30c33fc 	movw	r3, #50172	; 0xc3fc
10014d00:	e3413003 	movt	r3, #4099	; 0x1003
10014d04:	e5933000 	ldr	r3, [r3]
10014d08:	e1a00003 	mov	r0, r3
10014d0c:	e51b300c 	ldr	r3, [fp, #-12]
10014d10:	e0633000 	rsb	r3, r3, r0
10014d14:	e0813003 	add	r3, r1, r3
10014d18:	e0632002 	rsb	r2, r3, r2
10014d1c:	e30c3428 	movw	r3, #50216	; 0xc428
10014d20:	e3413003 	movt	r3, #4099	; 0x1003
10014d24:	e5832000 	str	r2, [r3]
#endif

    /* finally, see if prev or next are free also */
    plug_holes(mem);
10014d28:	e51b000c 	ldr	r0, [fp, #-12]
10014d2c:	ebfffc58 	bl	10013e94 <plug_holes>
    rt_sem_release(&heap_sem);
10014d30:	e30c0408 	movw	r0, #50184	; 0xc408
10014d34:	e3410003 	movt	r0, #4099	; 0x1003
10014d38:	ebffea5f 	bl	1000f6bc <rt_sem_release>
}
10014d3c:	e24bd004 	sub	sp, fp, #4
10014d40:	e8bd8800 	pop	{fp, pc}

10014d44 <rt_memory_info>:

#ifdef RT_MEM_STATS
void rt_memory_info(rt_uint32_t *total,
                    rt_uint32_t *used,
                    rt_uint32_t *max_used)
{
10014d44:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10014d48:	e28db000 	add	fp, sp, #0
10014d4c:	e24dd014 	sub	sp, sp, #20
10014d50:	e50b0008 	str	r0, [fp, #-8]
10014d54:	e50b100c 	str	r1, [fp, #-12]
10014d58:	e50b2010 	str	r2, [fp, #-16]
    if (total != RT_NULL)
10014d5c:	e51b3008 	ldr	r3, [fp, #-8]
10014d60:	e3530000 	cmp	r3, #0
10014d64:	0a000004 	beq	10014d7c <rt_memory_info+0x38>
        *total = mem_size_aligned;
10014d68:	e30c3424 	movw	r3, #50212	; 0xc424
10014d6c:	e3413003 	movt	r3, #4099	; 0x1003
10014d70:	e5932000 	ldr	r2, [r3]
10014d74:	e51b3008 	ldr	r3, [fp, #-8]
10014d78:	e5832000 	str	r2, [r3]
    if (used  != RT_NULL)
10014d7c:	e51b300c 	ldr	r3, [fp, #-12]
10014d80:	e3530000 	cmp	r3, #0
10014d84:	0a000004 	beq	10014d9c <rt_memory_info+0x58>
        *used = used_mem;
10014d88:	e30c3428 	movw	r3, #50216	; 0xc428
10014d8c:	e3413003 	movt	r3, #4099	; 0x1003
10014d90:	e5932000 	ldr	r2, [r3]
10014d94:	e51b300c 	ldr	r3, [fp, #-12]
10014d98:	e5832000 	str	r2, [r3]
    if (max_used != RT_NULL)
10014d9c:	e51b3010 	ldr	r3, [fp, #-16]
10014da0:	e3530000 	cmp	r3, #0
10014da4:	0a000004 	beq	10014dbc <rt_memory_info+0x78>
        *max_used = max_mem;
10014da8:	e30c342c 	movw	r3, #50220	; 0xc42c
10014dac:	e3413003 	movt	r3, #4099	; 0x1003
10014db0:	e5932000 	ldr	r2, [r3]
10014db4:	e51b3010 	ldr	r3, [fp, #-16]
10014db8:	e5832000 	str	r2, [r3]
}
10014dbc:	e24bd000 	sub	sp, fp, #0
10014dc0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10014dc4:	e12fff1e 	bx	lr

10014dc8 <list_mem>:

#ifdef RT_USING_FINSH
#include <finsh.h>

void list_mem(void)
{
10014dc8:	e92d4800 	push	{fp, lr}
10014dcc:	e28db004 	add	fp, sp, #4
    rt_kprintf("total memory: %d\n", mem_size_aligned);
10014dd0:	e30c3424 	movw	r3, #50212	; 0xc424
10014dd4:	e3413003 	movt	r3, #4099	; 0x1003
10014dd8:	e5933000 	ldr	r3, [r3]
10014ddc:	e3030b74 	movw	r0, #15220	; 0x3b74
10014de0:	e3410003 	movt	r0, #4099	; 0x1003
10014de4:	e1a01003 	mov	r1, r3
10014de8:	ebfffb34 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("used memory : %d\n", used_mem);
10014dec:	e30c3428 	movw	r3, #50216	; 0xc428
10014df0:	e3413003 	movt	r3, #4099	; 0x1003
10014df4:	e5933000 	ldr	r3, [r3]
10014df8:	e3030b88 	movw	r0, #15240	; 0x3b88
10014dfc:	e3410003 	movt	r0, #4099	; 0x1003
10014e00:	e1a01003 	mov	r1, r3
10014e04:	ebfffb2d 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("maximum allocated memory: %d\n", max_mem);
10014e08:	e30c342c 	movw	r3, #50220	; 0xc42c
10014e0c:	e3413003 	movt	r3, #4099	; 0x1003
10014e10:	e5933000 	ldr	r3, [r3]
10014e14:	e3030b9c 	movw	r0, #15260	; 0x3b9c
10014e18:	e3410003 	movt	r0, #4099	; 0x1003
10014e1c:	e1a01003 	mov	r1, r3
10014e20:	ebfffb26 	bl	10013ac0 <rt_kprintf>
}
10014e24:	e8bd8800 	pop	{fp, pc}

10014e28 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
10014e28:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10014e2c:	e28db000 	add	fp, sp, #0
10014e30:	e24dd00c 	sub	sp, sp, #12
10014e34:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
10014e38:	e51b3008 	ldr	r3, [fp, #-8]
10014e3c:	e51b2008 	ldr	r2, [fp, #-8]
10014e40:	e5832004 	str	r2, [r3, #4]
10014e44:	e51b3008 	ldr	r3, [fp, #-8]
10014e48:	e5932004 	ldr	r2, [r3, #4]
10014e4c:	e51b3008 	ldr	r3, [fp, #-8]
10014e50:	e5832000 	str	r2, [r3]
}
10014e54:	e24bd000 	sub	sp, fp, #0
10014e58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10014e5c:	e12fff1e 	bx	lr

10014e60 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
10014e60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10014e64:	e28db000 	add	fp, sp, #0
10014e68:	e24dd00c 	sub	sp, sp, #12
10014e6c:	e50b0008 	str	r0, [fp, #-8]
10014e70:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
10014e74:	e51b3008 	ldr	r3, [fp, #-8]
10014e78:	e5933000 	ldr	r3, [r3]
10014e7c:	e51b200c 	ldr	r2, [fp, #-12]
10014e80:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
10014e84:	e51b3008 	ldr	r3, [fp, #-8]
10014e88:	e5932000 	ldr	r2, [r3]
10014e8c:	e51b300c 	ldr	r3, [fp, #-12]
10014e90:	e5832000 	str	r2, [r3]

    l->next = n;
10014e94:	e51b3008 	ldr	r3, [fp, #-8]
10014e98:	e51b200c 	ldr	r2, [fp, #-12]
10014e9c:	e5832000 	str	r2, [r3]
    n->prev = l;
10014ea0:	e51b300c 	ldr	r3, [fp, #-12]
10014ea4:	e51b2008 	ldr	r2, [fp, #-8]
10014ea8:	e5832004 	str	r2, [r3, #4]
}
10014eac:	e24bd000 	sub	sp, fp, #0
10014eb0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10014eb4:	e12fff1e 	bx	lr

10014eb8 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
10014eb8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10014ebc:	e28db000 	add	fp, sp, #0
10014ec0:	e24dd00c 	sub	sp, sp, #12
10014ec4:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
10014ec8:	e51b3008 	ldr	r3, [fp, #-8]
10014ecc:	e5932000 	ldr	r2, [r3]
10014ed0:	e51b3008 	ldr	r3, [fp, #-8]
10014ed4:	e1520003 	cmp	r2, r3
10014ed8:	03a03001 	moveq	r3, #1
10014edc:	13a03000 	movne	r3, #0
10014ee0:	e6ef3073 	uxtb	r3, r3
}
10014ee4:	e1a00003 	mov	r0, r3
10014ee8:	e24bd000 	sub	sp, fp, #0
10014eec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10014ef0:	e12fff1e 	bx	lr

10014ef4 <rt_mp_alloc_sethook>:
 * block is allocated from memory pool.
 *
 * @param hook the hook function
 */
void rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block))
{
10014ef4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10014ef8:	e28db000 	add	fp, sp, #0
10014efc:	e24dd00c 	sub	sp, sp, #12
10014f00:	e50b0008 	str	r0, [fp, #-8]
    rt_mp_alloc_hook = hook;
10014f04:	e30c3430 	movw	r3, #50224	; 0xc430
10014f08:	e3413003 	movt	r3, #4099	; 0x1003
10014f0c:	e51b2008 	ldr	r2, [fp, #-8]
10014f10:	e5832000 	str	r2, [r3]
}
10014f14:	e24bd000 	sub	sp, fp, #0
10014f18:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10014f1c:	e12fff1e 	bx	lr

10014f20 <rt_mp_free_sethook>:
 * block is released to memory pool.
 *
 * @param hook the hook function
 */
void rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block))
{
10014f20:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10014f24:	e28db000 	add	fp, sp, #0
10014f28:	e24dd00c 	sub	sp, sp, #12
10014f2c:	e50b0008 	str	r0, [fp, #-8]
    rt_mp_free_hook = hook;
10014f30:	e30c3434 	movw	r3, #50228	; 0xc434
10014f34:	e3413003 	movt	r3, #4099	; 0x1003
10014f38:	e51b2008 	ldr	r2, [fp, #-8]
10014f3c:	e5832000 	str	r2, [r3]
}
10014f40:	e24bd000 	sub	sp, fp, #0
10014f44:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10014f48:	e12fff1e 	bx	lr

10014f4c <rt_mp_init>:
rt_err_t rt_mp_init(struct rt_mempool *mp,
                    const char        *name,
                    void              *start,
                    rt_size_t          size,
                    rt_size_t          block_size)
{
10014f4c:	e92d4810 	push	{r4, fp, lr}
10014f50:	e28db008 	add	fp, sp, #8
10014f54:	e24dd01c 	sub	sp, sp, #28
10014f58:	e50b0018 	str	r0, [fp, #-24]
10014f5c:	e50b101c 	str	r1, [fp, #-28]
10014f60:	e50b2020 	str	r2, [fp, #-32]
10014f64:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    rt_uint8_t *block_ptr;
    register rt_base_t offset;

    /* parameter check */
    RT_ASSERT(mp != RT_NULL);
10014f68:	e51b3018 	ldr	r3, [fp, #-24]
10014f6c:	e3530000 	cmp	r3, #0
10014f70:	1a000005 	bne	10014f8c <rt_mp_init+0x40>
10014f74:	e3030c08 	movw	r0, #15368	; 0x3c08
10014f78:	e3410003 	movt	r0, #4099	; 0x1003
10014f7c:	e3031c58 	movw	r1, #15448	; 0x3c58
10014f80:	e3411003 	movt	r1, #4099	; 0x1003
10014f84:	e3a02065 	mov	r2, #101	; 0x65
10014f88:	ebfffb89 	bl	10013db4 <rt_assert_handler>

    /* initialize object */
    rt_object_init(&(mp->parent), RT_Object_Class_MemPool, name);
10014f8c:	e51b3018 	ldr	r3, [fp, #-24]
10014f90:	e1a00003 	mov	r0, r3
10014f94:	e3a01006 	mov	r1, #6
10014f98:	e51b201c 	ldr	r2, [fp, #-28]
10014f9c:	eb000284 	bl	100159b4 <rt_object_init>

    /* initialize memory pool */
    mp->start_address = start;
10014fa0:	e51b3018 	ldr	r3, [fp, #-24]
10014fa4:	e51b2020 	ldr	r2, [fp, #-32]
10014fa8:	e5832010 	str	r2, [r3, #16]
    mp->size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
10014fac:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10014fb0:	e3c32003 	bic	r2, r3, #3
10014fb4:	e51b3018 	ldr	r3, [fp, #-24]
10014fb8:	e5832014 	str	r2, [r3, #20]

    /* align the block size */
    block_size = RT_ALIGN(block_size, RT_ALIGN_SIZE);
10014fbc:	e59b3004 	ldr	r3, [fp, #4]
10014fc0:	e2833003 	add	r3, r3, #3
10014fc4:	e3c33003 	bic	r3, r3, #3
10014fc8:	e58b3004 	str	r3, [fp, #4]
    mp->block_size = block_size;
10014fcc:	e51b3018 	ldr	r3, [fp, #-24]
10014fd0:	e59b2004 	ldr	r2, [fp, #4]
10014fd4:	e5832018 	str	r2, [r3, #24]

    /* align to align size byte */
    mp->block_total_count = mp->size / (mp->block_size + sizeof(rt_uint8_t *));
10014fd8:	e51b3018 	ldr	r3, [fp, #-24]
10014fdc:	e5932014 	ldr	r2, [r3, #20]
10014fe0:	e51b3018 	ldr	r3, [fp, #-24]
10014fe4:	e5933018 	ldr	r3, [r3, #24]
10014fe8:	e2833004 	add	r3, r3, #4
10014fec:	e1a00002 	mov	r0, r2
10014ff0:	e1a01003 	mov	r1, r3
10014ff4:	fa006771 	blx	1002edc0 <__aeabi_uidiv>
10014ff8:	e1a03000 	mov	r3, r0
10014ffc:	e1a02003 	mov	r2, r3
10015000:	e51b3018 	ldr	r3, [fp, #-24]
10015004:	e5832020 	str	r2, [r3, #32]
    mp->block_free_count  = mp->block_total_count;
10015008:	e51b3018 	ldr	r3, [fp, #-24]
1001500c:	e5932020 	ldr	r2, [r3, #32]
10015010:	e51b3018 	ldr	r3, [fp, #-24]
10015014:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* initialize suspended thread list */
    rt_list_init(&(mp->suspend_thread));
10015018:	e51b3018 	ldr	r3, [fp, #-24]
1001501c:	e2833028 	add	r3, r3, #40	; 0x28
10015020:	e1a00003 	mov	r0, r3
10015024:	ebffff7f 	bl	10014e28 <rt_list_init>
    mp->suspend_thread_count = 0;
10015028:	e51b3018 	ldr	r3, [fp, #-24]
1001502c:	e3a02000 	mov	r2, #0
10015030:	e5832030 	str	r2, [r3, #48]	; 0x30

    /* initialize free block list */
    block_ptr = (rt_uint8_t *)mp->start_address;
10015034:	e51b3018 	ldr	r3, [fp, #-24]
10015038:	e5933010 	ldr	r3, [r3, #16]
1001503c:	e50b3010 	str	r3, [fp, #-16]
    for (offset = 0; offset < mp->block_total_count; offset ++)
10015040:	e3a04000 	mov	r4, #0
10015044:	ea00000e 	b	10015084 <rt_mp_init+0x138>
    {
        *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *))) =
10015048:	e59b3004 	ldr	r3, [fp, #4]
1001504c:	e2833004 	add	r3, r3, #4
10015050:	e1a02004 	mov	r2, r4
10015054:	e0030392 	mul	r3, r2, r3
10015058:	e51b2010 	ldr	r2, [fp, #-16]
1001505c:	e0823003 	add	r3, r2, r3
            (rt_uint8_t *)(block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *)));
10015060:	e2842001 	add	r2, r4, #1
10015064:	e1a01002 	mov	r1, r2
10015068:	e59b2004 	ldr	r2, [fp, #4]
1001506c:	e2822004 	add	r2, r2, #4
10015070:	e0020192 	mul	r2, r2, r1
10015074:	e51b1010 	ldr	r1, [fp, #-16]
10015078:	e0812002 	add	r2, r1, r2

    /* initialize free block list */
    block_ptr = (rt_uint8_t *)mp->start_address;
    for (offset = 0; offset < mp->block_total_count; offset ++)
    {
        *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *))) =
1001507c:	e5832000 	str	r2, [r3]
    rt_list_init(&(mp->suspend_thread));
    mp->suspend_thread_count = 0;

    /* initialize free block list */
    block_ptr = (rt_uint8_t *)mp->start_address;
    for (offset = 0; offset < mp->block_total_count; offset ++)
10015080:	e2844001 	add	r4, r4, #1
10015084:	e1a02004 	mov	r2, r4
10015088:	e51b3018 	ldr	r3, [fp, #-24]
1001508c:	e5933020 	ldr	r3, [r3, #32]
10015090:	e1520003 	cmp	r2, r3
10015094:	3affffeb 	bcc	10015048 <rt_mp_init+0xfc>
    {
        *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *))) =
            (rt_uint8_t *)(block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *)));
    }

    *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *))) =
10015098:	e2443001 	sub	r3, r4, #1
1001509c:	e1a02003 	mov	r2, r3
100150a0:	e59b3004 	ldr	r3, [fp, #4]
100150a4:	e2833004 	add	r3, r3, #4
100150a8:	e0030293 	mul	r3, r3, r2
100150ac:	e51b2010 	ldr	r2, [fp, #-16]
100150b0:	e0823003 	add	r3, r2, r3
100150b4:	e3a02000 	mov	r2, #0
100150b8:	e5832000 	str	r2, [r3]
        RT_NULL;

    mp->block_list = block_ptr;
100150bc:	e51b3018 	ldr	r3, [fp, #-24]
100150c0:	e51b2010 	ldr	r2, [fp, #-16]
100150c4:	e583201c 	str	r2, [r3, #28]

    return RT_EOK;
100150c8:	e3a03000 	mov	r3, #0
}
100150cc:	e1a00003 	mov	r0, r3
100150d0:	e24bd008 	sub	sp, fp, #8
100150d4:	e8bd8810 	pop	{r4, fp, pc}

100150d8 <rt_mp_detach>:
 * @param mp the memory pool object
 *
 * @return RT_EOK
 */
rt_err_t rt_mp_detach(struct rt_mempool *mp)
{
100150d8:	e92d4810 	push	{r4, fp, lr}
100150dc:	e28db008 	add	fp, sp, #8
100150e0:	e24dd014 	sub	sp, sp, #20
100150e4:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* parameter check */
    RT_ASSERT(mp != RT_NULL);
100150e8:	e51b3018 	ldr	r3, [fp, #-24]
100150ec:	e3530000 	cmp	r3, #0
100150f0:	1a000005 	bne	1001510c <rt_mp_detach+0x34>
100150f4:	e3030c08 	movw	r0, #15368	; 0x3c08
100150f8:	e3410003 	movt	r0, #4099	; 0x1003
100150fc:	e3031c64 	movw	r1, #15460	; 0x3c64
10015100:	e3411003 	movt	r1, #4099	; 0x1003
10015104:	e3a02098 	mov	r2, #152	; 0x98
10015108:	ebfffb29 	bl	10013db4 <rt_assert_handler>

    /* wake up all suspended threads */
    while (!rt_list_isempty(&(mp->suspend_thread)))
1001510c:	ea000013 	b	10015160 <rt_mp_detach+0x88>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
10015110:	eb001146 	bl	10019630 <rt_hw_interrupt_disable>
10015114:	e1a03000 	mov	r3, r0
10015118:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
1001511c:	e51b3018 	ldr	r3, [fp, #-24]
10015120:	e5933028 	ldr	r3, [r3, #40]	; 0x28
10015124:	e2433010 	sub	r3, r3, #16
10015128:	e50b3010 	str	r3, [fp, #-16]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
1001512c:	e51b3010 	ldr	r3, [fp, #-16]
10015130:	e3e02000 	mvn	r2, #0
10015134:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
10015138:	e51b0010 	ldr	r0, [fp, #-16]
1001513c:	eb00078d 	bl	10016f78 <rt_thread_resume>

        /* decrease suspended thread count */
        mp->suspend_thread_count --;
10015140:	e51b3018 	ldr	r3, [fp, #-24]
10015144:	e5933030 	ldr	r3, [r3, #48]	; 0x30
10015148:	e2432001 	sub	r2, r3, #1
1001514c:	e51b3018 	ldr	r3, [fp, #-24]
10015150:	e5832030 	str	r2, [r3, #48]	; 0x30

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10015154:	e1a03004 	mov	r3, r4
10015158:	e1a00003 	mov	r0, r3
1001515c:	eb001137 	bl	10019640 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mp != RT_NULL);

    /* wake up all suspended threads */
    while (!rt_list_isempty(&(mp->suspend_thread)))
10015160:	e51b3018 	ldr	r3, [fp, #-24]
10015164:	e2833028 	add	r3, r3, #40	; 0x28
10015168:	e1a00003 	mov	r0, r3
1001516c:	ebffff51 	bl	10014eb8 <rt_list_isempty>
10015170:	e1a03000 	mov	r3, r0
10015174:	e3530000 	cmp	r3, #0
10015178:	0affffe4 	beq	10015110 <rt_mp_detach+0x38>
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    /* detach object */
    rt_object_detach(&(mp->parent));
1001517c:	e51b3018 	ldr	r3, [fp, #-24]
10015180:	e1a00003 	mov	r0, r3
10015184:	eb000239 	bl	10015a70 <rt_object_detach>

    return RT_EOK;
10015188:	e3a03000 	mov	r3, #0
}
1001518c:	e1a00003 	mov	r0, r3
10015190:	e24bd008 	sub	sp, fp, #8
10015194:	e8bd8810 	pop	{r4, fp, pc}

10015198 <rt_mp_create>:
 * @return the created mempool object
 */
rt_mp_t rt_mp_create(const char *name,
                     rt_size_t   block_count,
                     rt_size_t   block_size)
{
10015198:	e92d4810 	push	{r4, fp, lr}
1001519c:	e28db008 	add	fp, sp, #8
100151a0:	e24dd024 	sub	sp, sp, #36	; 0x24
100151a4:	e50b0020 	str	r0, [fp, #-32]
100151a8:	e50b1024 	str	r1, [fp, #-36]	; 0x24
100151ac:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    rt_uint8_t *block_ptr;
    struct rt_mempool *mp;
    register rt_base_t offset;

    RT_DEBUG_NOT_IN_INTERRUPT;
100151b0:	eb00111e 	bl	10019630 <rt_hw_interrupt_disable>
100151b4:	e50b0010 	str	r0, [fp, #-16]
100151b8:	ebfff3d0 	bl	10012100 <rt_interrupt_get_nest>
100151bc:	e1a03000 	mov	r3, r0
100151c0:	e3530000 	cmp	r3, #0
100151c4:	0a00000a 	beq	100151f4 <rt_mp_create+0x5c>
100151c8:	e3030c18 	movw	r0, #15384	; 0x3c18
100151cc:	e3410003 	movt	r0, #4099	; 0x1003
100151d0:	e3031c74 	movw	r1, #15476	; 0x3c74
100151d4:	e3411003 	movt	r1, #4099	; 0x1003
100151d8:	ebfffa38 	bl	10013ac0 <rt_kprintf>
100151dc:	e3030c3c 	movw	r0, #15420	; 0x3c3c
100151e0:	e3410003 	movt	r0, #4099	; 0x1003
100151e4:	e3031c74 	movw	r1, #15476	; 0x3c74
100151e8:	e3411003 	movt	r1, #4099	; 0x1003
100151ec:	e3a020cd 	mov	r2, #205	; 0xcd
100151f0:	ebfffaef 	bl	10013db4 <rt_assert_handler>
100151f4:	e51b0010 	ldr	r0, [fp, #-16]
100151f8:	eb001110 	bl	10019640 <rt_hw_interrupt_enable>

    /* allocate object */
    mp = (struct rt_mempool *)rt_object_allocate(RT_Object_Class_MemPool, name);
100151fc:	e3a00006 	mov	r0, #6
10015200:	e51b1020 	ldr	r1, [fp, #-32]
10015204:	eb00023a 	bl	10015af4 <rt_object_allocate>
10015208:	e50b0014 	str	r0, [fp, #-20]
    /* allocate object failed */
    if (mp == RT_NULL)
1001520c:	e51b3014 	ldr	r3, [fp, #-20]
10015210:	e3530000 	cmp	r3, #0
10015214:	1a000001 	bne	10015220 <rt_mp_create+0x88>
        return RT_NULL;
10015218:	e3a03000 	mov	r3, #0
1001521c:	ea000052 	b	1001536c <rt_mp_create+0x1d4>

    /* initialize memory pool */
    block_size     = RT_ALIGN(block_size, RT_ALIGN_SIZE);
10015220:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015224:	e2833003 	add	r3, r3, #3
10015228:	e3c33003 	bic	r3, r3, #3
1001522c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
    mp->block_size = block_size;
10015230:	e51b3014 	ldr	r3, [fp, #-20]
10015234:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10015238:	e5832018 	str	r2, [r3, #24]
    mp->size       = (block_size + sizeof(rt_uint8_t *)) * block_count;
1001523c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015240:	e2833004 	add	r3, r3, #4
10015244:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10015248:	e0020392 	mul	r2, r2, r3
1001524c:	e51b3014 	ldr	r3, [fp, #-20]
10015250:	e5832014 	str	r2, [r3, #20]

    /* allocate memory */
    mp->start_address = rt_malloc((block_size + sizeof(rt_uint8_t *)) *
10015254:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015258:	e2833004 	add	r3, r3, #4
1001525c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10015260:	e0030392 	mul	r3, r2, r3
10015264:	e1a00003 	mov	r0, r3
10015268:	ebfffc09 	bl	10014294 <rt_malloc>
1001526c:	e1a02000 	mov	r2, r0
10015270:	e51b3014 	ldr	r3, [fp, #-20]
10015274:	e5832010 	str	r2, [r3, #16]
                                  block_count);
    if (mp->start_address == RT_NULL)
10015278:	e51b3014 	ldr	r3, [fp, #-20]
1001527c:	e5933010 	ldr	r3, [r3, #16]
10015280:	e3530000 	cmp	r3, #0
10015284:	1a000004 	bne	1001529c <rt_mp_create+0x104>
    {
        /* no memory, delete memory pool object */
        rt_object_delete(&(mp->parent));
10015288:	e51b3014 	ldr	r3, [fp, #-20]
1001528c:	e1a00003 	mov	r0, r3
10015290:	eb000264 	bl	10015c28 <rt_object_delete>

        return RT_NULL;
10015294:	e3a03000 	mov	r3, #0
10015298:	ea000033 	b	1001536c <rt_mp_create+0x1d4>
    }

    mp->block_total_count = block_count;
1001529c:	e51b3014 	ldr	r3, [fp, #-20]
100152a0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100152a4:	e5832020 	str	r2, [r3, #32]
    mp->block_free_count  = mp->block_total_count;
100152a8:	e51b3014 	ldr	r3, [fp, #-20]
100152ac:	e5932020 	ldr	r2, [r3, #32]
100152b0:	e51b3014 	ldr	r3, [fp, #-20]
100152b4:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* initialize suspended thread list */
    rt_list_init(&(mp->suspend_thread));
100152b8:	e51b3014 	ldr	r3, [fp, #-20]
100152bc:	e2833028 	add	r3, r3, #40	; 0x28
100152c0:	e1a00003 	mov	r0, r3
100152c4:	ebfffed7 	bl	10014e28 <rt_list_init>
    mp->suspend_thread_count = 0;
100152c8:	e51b3014 	ldr	r3, [fp, #-20]
100152cc:	e3a02000 	mov	r2, #0
100152d0:	e5832030 	str	r2, [r3, #48]	; 0x30

    /* initialize free block list */
    block_ptr = (rt_uint8_t *)mp->start_address;
100152d4:	e51b3014 	ldr	r3, [fp, #-20]
100152d8:	e5933010 	ldr	r3, [r3, #16]
100152dc:	e50b3018 	str	r3, [fp, #-24]
    for (offset = 0; offset < mp->block_total_count; offset ++)
100152e0:	e3a04000 	mov	r4, #0
100152e4:	ea00000e 	b	10015324 <rt_mp_create+0x18c>
    {
        *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *)))
100152e8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100152ec:	e2833004 	add	r3, r3, #4
100152f0:	e1a02004 	mov	r2, r4
100152f4:	e0030392 	mul	r3, r2, r3
100152f8:	e51b2018 	ldr	r2, [fp, #-24]
100152fc:	e0823003 	add	r3, r2, r3
            = block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *));
10015300:	e2842001 	add	r2, r4, #1
10015304:	e1a01002 	mov	r1, r2
10015308:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1001530c:	e2822004 	add	r2, r2, #4
10015310:	e0020192 	mul	r2, r2, r1
10015314:	e51b1018 	ldr	r1, [fp, #-24]
10015318:	e0812002 	add	r2, r1, r2
1001531c:	e5832000 	str	r2, [r3]
    rt_list_init(&(mp->suspend_thread));
    mp->suspend_thread_count = 0;

    /* initialize free block list */
    block_ptr = (rt_uint8_t *)mp->start_address;
    for (offset = 0; offset < mp->block_total_count; offset ++)
10015320:	e2844001 	add	r4, r4, #1
10015324:	e1a02004 	mov	r2, r4
10015328:	e51b3014 	ldr	r3, [fp, #-20]
1001532c:	e5933020 	ldr	r3, [r3, #32]
10015330:	e1520003 	cmp	r2, r3
10015334:	3affffeb 	bcc	100152e8 <rt_mp_create+0x150>
    {
        *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *)))
            = block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *));
    }

    *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *)))
10015338:	e2443001 	sub	r3, r4, #1
1001533c:	e1a02003 	mov	r2, r3
10015340:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015344:	e2833004 	add	r3, r3, #4
10015348:	e0030293 	mul	r3, r3, r2
1001534c:	e51b2018 	ldr	r2, [fp, #-24]
10015350:	e0823003 	add	r3, r2, r3
        = RT_NULL;
10015354:	e3a02000 	mov	r2, #0
10015358:	e5832000 	str	r2, [r3]

    mp->block_list = block_ptr;
1001535c:	e51b3014 	ldr	r3, [fp, #-20]
10015360:	e51b2018 	ldr	r2, [fp, #-24]
10015364:	e583201c 	str	r2, [r3, #28]

    return mp;
10015368:	e51b3014 	ldr	r3, [fp, #-20]
}
1001536c:	e1a00003 	mov	r0, r3
10015370:	e24bd008 	sub	sp, fp, #8
10015374:	e8bd8810 	pop	{r4, fp, pc}

10015378 <rt_mp_delete>:
 * @param mp the memory pool object
 *
 * @return RT_EOK
 */
rt_err_t rt_mp_delete(rt_mp_t mp)
{
10015378:	e92d4810 	push	{r4, fp, lr}
1001537c:	e28db008 	add	fp, sp, #8
10015380:	e24dd014 	sub	sp, sp, #20
10015384:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    RT_DEBUG_NOT_IN_INTERRUPT;
10015388:	eb0010a8 	bl	10019630 <rt_hw_interrupt_disable>
1001538c:	e50b0010 	str	r0, [fp, #-16]
10015390:	ebfff35a 	bl	10012100 <rt_interrupt_get_nest>
10015394:	e1a03000 	mov	r3, r0
10015398:	e3530000 	cmp	r3, #0
1001539c:	0a00000a 	beq	100153cc <rt_mp_delete+0x54>
100153a0:	e3030c18 	movw	r0, #15384	; 0x3c18
100153a4:	e3410003 	movt	r0, #4099	; 0x1003
100153a8:	e3031c84 	movw	r1, #15492	; 0x3c84
100153ac:	e3411003 	movt	r1, #4099	; 0x1003
100153b0:	ebfff9c2 	bl	10013ac0 <rt_kprintf>
100153b4:	e3030c3c 	movw	r0, #15420	; 0x3c3c
100153b8:	e3410003 	movt	r0, #4099	; 0x1003
100153bc:	e3031c84 	movw	r1, #15492	; 0x3c84
100153c0:	e3411003 	movt	r1, #4099	; 0x1003
100153c4:	e3002109 	movw	r2, #265	; 0x109
100153c8:	ebfffa79 	bl	10013db4 <rt_assert_handler>
100153cc:	e51b0010 	ldr	r0, [fp, #-16]
100153d0:	eb00109a 	bl	10019640 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mp != RT_NULL);
100153d4:	e51b3018 	ldr	r3, [fp, #-24]
100153d8:	e3530000 	cmp	r3, #0
100153dc:	1a000005 	bne	100153f8 <rt_mp_delete+0x80>
100153e0:	e3030c08 	movw	r0, #15368	; 0x3c08
100153e4:	e3410003 	movt	r0, #4099	; 0x1003
100153e8:	e3031c84 	movw	r1, #15492	; 0x3c84
100153ec:	e3411003 	movt	r1, #4099	; 0x1003
100153f0:	e3a02f43 	mov	r2, #268	; 0x10c
100153f4:	ebfffa6e 	bl	10013db4 <rt_assert_handler>

    /* wake up all suspended threads */
    while (!rt_list_isempty(&(mp->suspend_thread)))
100153f8:	ea000013 	b	1001544c <rt_mp_delete+0xd4>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
100153fc:	eb00108b 	bl	10019630 <rt_hw_interrupt_disable>
10015400:	e1a03000 	mov	r3, r0
10015404:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
10015408:	e51b3018 	ldr	r3, [fp, #-24]
1001540c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
10015410:	e2433010 	sub	r3, r3, #16
10015414:	e50b3014 	str	r3, [fp, #-20]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
10015418:	e51b3014 	ldr	r3, [fp, #-20]
1001541c:	e3e02000 	mvn	r2, #0
10015420:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
10015424:	e51b0014 	ldr	r0, [fp, #-20]
10015428:	eb0006d2 	bl	10016f78 <rt_thread_resume>

        /* decrease suspended thread count */
        mp->suspend_thread_count --;
1001542c:	e51b3018 	ldr	r3, [fp, #-24]
10015430:	e5933030 	ldr	r3, [r3, #48]	; 0x30
10015434:	e2432001 	sub	r2, r3, #1
10015438:	e51b3018 	ldr	r3, [fp, #-24]
1001543c:	e5832030 	str	r2, [r3, #48]	; 0x30

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10015440:	e1a03004 	mov	r3, r4
10015444:	e1a00003 	mov	r0, r3
10015448:	eb00107c 	bl	10019640 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mp != RT_NULL);

    /* wake up all suspended threads */
    while (!rt_list_isempty(&(mp->suspend_thread)))
1001544c:	e51b3018 	ldr	r3, [fp, #-24]
10015450:	e2833028 	add	r3, r3, #40	; 0x28
10015454:	e1a00003 	mov	r0, r3
10015458:	ebfffe96 	bl	10014eb8 <rt_list_isempty>
1001545c:	e1a03000 	mov	r3, r0
10015460:	e3530000 	cmp	r3, #0
10015464:	0affffe4 	beq	100153fc <rt_mp_delete+0x84>
        rt_module_free(mp->parent.module_id, mp->start_address);
    else
#endif

    /* release allocated room */
    rt_free(mp->start_address);
10015468:	e51b3018 	ldr	r3, [fp, #-24]
1001546c:	e5933010 	ldr	r3, [r3, #16]
10015470:	e1a00003 	mov	r0, r3
10015474:	ebfffda1 	bl	10014b00 <rt_free>

    /* detach object */
    rt_object_delete(&(mp->parent));
10015478:	e51b3018 	ldr	r3, [fp, #-24]
1001547c:	e1a00003 	mov	r0, r3
10015480:	eb0001e8 	bl	10015c28 <rt_object_delete>

    return RT_EOK;
10015484:	e3a03000 	mov	r3, #0
}
10015488:	e1a00003 	mov	r0, r3
1001548c:	e24bd008 	sub	sp, fp, #8
10015490:	e8bd8810 	pop	{r4, fp, pc}

10015494 <rt_mp_alloc>:
 * @param time the waiting time
 *
 * @return the allocated memory block or RT_NULL on allocated failed
 */
void *rt_mp_alloc(rt_mp_t mp, rt_int32_t time)
{
10015494:	e92d4810 	push	{r4, fp, lr}
10015498:	e28db008 	add	fp, sp, #8
1001549c:	e24dd01c 	sub	sp, sp, #28
100154a0:	e50b0020 	str	r0, [fp, #-32]
100154a4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    rt_uint8_t *block_ptr;
    register rt_base_t level;
    struct rt_thread *thread;
    rt_uint32_t before_sleep = 0;
100154a8:	e3a03000 	mov	r3, #0
100154ac:	e50b3010 	str	r3, [fp, #-16]

    /* get current thread */
    thread = rt_thread_self();
100154b0:	eb00052a 	bl	10016960 <rt_thread_self>
100154b4:	e50b0014 	str	r0, [fp, #-20]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100154b8:	eb00105c 	bl	10019630 <rt_hw_interrupt_disable>
100154bc:	e1a04000 	mov	r4, r0

    while (mp->block_free_count == 0)
100154c0:	ea000056 	b	10015620 <rt_mp_alloc+0x18c>
    {
        /* memory block is unavailable. */
        if (time == 0)
100154c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100154c8:	e3530000 	cmp	r3, #0
100154cc:	1a000005 	bne	100154e8 <rt_mp_alloc+0x54>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
100154d0:	e1a00004 	mov	r0, r4
100154d4:	eb001059 	bl	10019640 <rt_hw_interrupt_enable>

            rt_set_errno(-RT_ETIMEOUT);
100154d8:	e3e00001 	mvn	r0, #1
100154dc:	ebfff32a 	bl	1001218c <rt_set_errno>

            return RT_NULL;
100154e0:	e3a03000 	mov	r3, #0
100154e4:	ea00007a 	b	100156d4 <rt_mp_alloc+0x240>
        }

        RT_DEBUG_NOT_IN_INTERRUPT;
100154e8:	eb001050 	bl	10019630 <rt_hw_interrupt_disable>
100154ec:	e50b0018 	str	r0, [fp, #-24]
100154f0:	ebfff302 	bl	10012100 <rt_interrupt_get_nest>
100154f4:	e1a03000 	mov	r3, r0
100154f8:	e3530000 	cmp	r3, #0
100154fc:	0a00000a 	beq	1001552c <rt_mp_alloc+0x98>
10015500:	e3030c18 	movw	r0, #15384	; 0x3c18
10015504:	e3410003 	movt	r0, #4099	; 0x1003
10015508:	e3031c94 	movw	r1, #15508	; 0x3c94
1001550c:	e3411003 	movt	r1, #4099	; 0x1003
10015510:	ebfff96a 	bl	10013ac0 <rt_kprintf>
10015514:	e3030c3c 	movw	r0, #15420	; 0x3c3c
10015518:	e3410003 	movt	r0, #4099	; 0x1003
1001551c:	e3031c94 	movw	r1, #15508	; 0x3c94
10015520:	e3411003 	movt	r1, #4099	; 0x1003
10015524:	e300215b 	movw	r2, #347	; 0x15b
10015528:	ebfffa21 	bl	10013db4 <rt_assert_handler>
1001552c:	e51b0018 	ldr	r0, [fp, #-24]
10015530:	eb001042 	bl	10019640 <rt_hw_interrupt_enable>

        thread->error = RT_EOK;
10015534:	e51b3014 	ldr	r3, [fp, #-20]
10015538:	e3a02000 	mov	r2, #0
1001553c:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* need suspend thread */
        rt_thread_suspend(thread);
10015540:	e51b0014 	ldr	r0, [fp, #-20]
10015544:	eb000667 	bl	10016ee8 <rt_thread_suspend>
        rt_list_insert_after(&(mp->suspend_thread), &(thread->tlist));
10015548:	e51b3020 	ldr	r3, [fp, #-32]
1001554c:	e2832028 	add	r2, r3, #40	; 0x28
10015550:	e51b3014 	ldr	r3, [fp, #-20]
10015554:	e2833010 	add	r3, r3, #16
10015558:	e1a00002 	mov	r0, r2
1001555c:	e1a01003 	mov	r1, r3
10015560:	ebfffe3e 	bl	10014e60 <rt_list_insert_after>
        mp->suspend_thread_count++;
10015564:	e51b3020 	ldr	r3, [fp, #-32]
10015568:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1001556c:	e2832001 	add	r2, r3, #1
10015570:	e51b3020 	ldr	r3, [fp, #-32]
10015574:	e5832030 	str	r2, [r3, #48]	; 0x30

        if (time > 0)
10015578:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1001557c:	e3530000 	cmp	r3, #0
10015580:	da00000c 	ble	100155b8 <rt_mp_alloc+0x124>
        {
            /* get the start tick of timer */
            before_sleep = rt_tick_get();
10015584:	ebffe36e 	bl	1000e344 <rt_tick_get>
10015588:	e50b0010 	str	r0, [fp, #-16]

            /* init thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
1001558c:	e51b3014 	ldr	r3, [fp, #-20]
10015590:	e2832048 	add	r2, r3, #72	; 0x48
10015594:	e24b3024 	sub	r3, fp, #36	; 0x24
10015598:	e1a00002 	mov	r0, r2
1001559c:	e3a01000 	mov	r1, #0
100155a0:	e1a02003 	mov	r2, r3
100155a4:	eb0008fe 	bl	100179a4 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &time);
            rt_timer_start(&(thread->thread_timer));
100155a8:	e51b3014 	ldr	r3, [fp, #-20]
100155ac:	e2833048 	add	r3, r3, #72	; 0x48
100155b0:	e1a00003 	mov	r0, r3
100155b4:	eb000804 	bl	100175cc <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
100155b8:	e1a00004 	mov	r0, r4
100155bc:	eb00101f 	bl	10019640 <rt_hw_interrupt_enable>

        /* do a schedule */
        rt_schedule();
100155c0:	eb0002f7 	bl	100161a4 <rt_schedule>

        if (thread->error != RT_EOK)
100155c4:	e51b3014 	ldr	r3, [fp, #-20]
100155c8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100155cc:	e3530000 	cmp	r3, #0
100155d0:	0a000001 	beq	100155dc <rt_mp_alloc+0x148>
            return RT_NULL;
100155d4:	e3a03000 	mov	r3, #0
100155d8:	ea00003d 	b	100156d4 <rt_mp_alloc+0x240>

        if (time > 0)
100155dc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100155e0:	e3530000 	cmp	r3, #0
100155e4:	da00000b 	ble	10015618 <rt_mp_alloc+0x184>
        {
            time -= rt_tick_get() - before_sleep;
100155e8:	ebffe355 	bl	1000e344 <rt_tick_get>
100155ec:	e1a02000 	mov	r2, r0
100155f0:	e51b3010 	ldr	r3, [fp, #-16]
100155f4:	e0633002 	rsb	r3, r3, r2
100155f8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100155fc:	e0633002 	rsb	r3, r3, r2
10015600:	e50b3024 	str	r3, [fp, #-36]	; 0x24
            if (time < 0)
10015604:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10015608:	e3530000 	cmp	r3, #0
1001560c:	aa000001 	bge	10015618 <rt_mp_alloc+0x184>
                time = 0;
10015610:	e3a03000 	mov	r3, #0
10015614:	e50b3024 	str	r3, [fp, #-36]	; 0x24
        }
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
10015618:	eb001004 	bl	10019630 <rt_hw_interrupt_disable>
1001561c:	e1a04000 	mov	r4, r0
    thread = rt_thread_self();

    /* disable interrupt */
    level = rt_hw_interrupt_disable();

    while (mp->block_free_count == 0)
10015620:	e51b3020 	ldr	r3, [fp, #-32]
10015624:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10015628:	e3530000 	cmp	r3, #0
1001562c:	0affffa4 	beq	100154c4 <rt_mp_alloc+0x30>
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
    }

    /* memory block is available. decrease the free block counter */
    mp->block_free_count--;
10015630:	e51b3020 	ldr	r3, [fp, #-32]
10015634:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10015638:	e2432001 	sub	r2, r3, #1
1001563c:	e51b3020 	ldr	r3, [fp, #-32]
10015640:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* get block from block list */
    block_ptr = mp->block_list;
10015644:	e51b3020 	ldr	r3, [fp, #-32]
10015648:	e593301c 	ldr	r3, [r3, #28]
1001564c:	e50b301c 	str	r3, [fp, #-28]
    RT_ASSERT(block_ptr != RT_NULL);
10015650:	e51b301c 	ldr	r3, [fp, #-28]
10015654:	e3530000 	cmp	r3, #0
10015658:	1a000005 	bne	10015674 <rt_mp_alloc+0x1e0>
1001565c:	e3030c40 	movw	r0, #15424	; 0x3c40
10015660:	e3410003 	movt	r0, #4099	; 0x1003
10015664:	e3031c94 	movw	r1, #15508	; 0x3c94
10015668:	e3411003 	movt	r1, #4099	; 0x1003
1001566c:	e3a02f62 	mov	r2, #392	; 0x188
10015670:	ebfff9cf 	bl	10013db4 <rt_assert_handler>

    /* Setup the next free node. */
    mp->block_list = *(rt_uint8_t **)block_ptr;
10015674:	e51b301c 	ldr	r3, [fp, #-28]
10015678:	e5932000 	ldr	r2, [r3]
1001567c:	e51b3020 	ldr	r3, [fp, #-32]
10015680:	e583201c 	str	r2, [r3, #28]

    /* point to memory pool */
    *(rt_uint8_t **)block_ptr = (rt_uint8_t *)mp;
10015684:	e51b301c 	ldr	r3, [fp, #-28]
10015688:	e51b2020 	ldr	r2, [fp, #-32]
1001568c:	e5832000 	str	r2, [r3]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10015690:	e1a00004 	mov	r0, r4
10015694:	eb000fe9 	bl	10019640 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_mp_alloc_hook,
10015698:	e30c3430 	movw	r3, #50224	; 0xc430
1001569c:	e3413003 	movt	r3, #4099	; 0x1003
100156a0:	e5933000 	ldr	r3, [r3]
100156a4:	e3530000 	cmp	r3, #0
100156a8:	0a000007 	beq	100156cc <rt_mp_alloc+0x238>
100156ac:	e30c3430 	movw	r3, #50224	; 0xc430
100156b0:	e3413003 	movt	r3, #4099	; 0x1003
100156b4:	e5933000 	ldr	r3, [r3]
100156b8:	e51b201c 	ldr	r2, [fp, #-28]
100156bc:	e2822004 	add	r2, r2, #4
100156c0:	e51b0020 	ldr	r0, [fp, #-32]
100156c4:	e1a01002 	mov	r1, r2
100156c8:	e12fff33 	blx	r3
                        (mp, (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *))));

    return (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *));
100156cc:	e51b301c 	ldr	r3, [fp, #-28]
100156d0:	e2833004 	add	r3, r3, #4
}
100156d4:	e1a00003 	mov	r0, r3
100156d8:	e24bd008 	sub	sp, fp, #8
100156dc:	e8bd8810 	pop	{r4, fp, pc}

100156e0 <rt_mp_free>:
 * This function will release a memory block
 *
 * @param block the address of memory block to be released
 */
void rt_mp_free(void *block)
{
100156e0:	e92d4810 	push	{r4, fp, lr}
100156e4:	e28db008 	add	fp, sp, #8
100156e8:	e24dd01c 	sub	sp, sp, #28
100156ec:	e50b0020 	str	r0, [fp, #-32]
    struct rt_mempool *mp;
    struct rt_thread *thread;
    register rt_base_t level;

    /* get the control block of pool which the block belongs to */
    block_ptr = (rt_uint8_t **)((rt_uint8_t *)block - sizeof(rt_uint8_t *));
100156f0:	e51b3020 	ldr	r3, [fp, #-32]
100156f4:	e2433004 	sub	r3, r3, #4
100156f8:	e50b3010 	str	r3, [fp, #-16]
    mp        = (struct rt_mempool *)*block_ptr;
100156fc:	e51b3010 	ldr	r3, [fp, #-16]
10015700:	e5933000 	ldr	r3, [r3]
10015704:	e50b3014 	str	r3, [fp, #-20]

    RT_OBJECT_HOOK_CALL(rt_mp_free_hook, (mp, block));
10015708:	e30c3434 	movw	r3, #50228	; 0xc434
1001570c:	e3413003 	movt	r3, #4099	; 0x1003
10015710:	e5933000 	ldr	r3, [r3]
10015714:	e3530000 	cmp	r3, #0
10015718:	0a000005 	beq	10015734 <rt_mp_free+0x54>
1001571c:	e30c3434 	movw	r3, #50228	; 0xc434
10015720:	e3413003 	movt	r3, #4099	; 0x1003
10015724:	e5933000 	ldr	r3, [r3]
10015728:	e51b0014 	ldr	r0, [fp, #-20]
1001572c:	e51b1020 	ldr	r1, [fp, #-32]
10015730:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10015734:	eb000fbd 	bl	10019630 <rt_hw_interrupt_disable>
10015738:	e1a04000 	mov	r4, r0

    /* increase the free block count */
    mp->block_free_count ++;
1001573c:	e51b3014 	ldr	r3, [fp, #-20]
10015740:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10015744:	e2832001 	add	r2, r3, #1
10015748:	e51b3014 	ldr	r3, [fp, #-20]
1001574c:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* link the block into the block list */
    *block_ptr = mp->block_list;
10015750:	e51b3014 	ldr	r3, [fp, #-20]
10015754:	e593201c 	ldr	r2, [r3, #28]
10015758:	e51b3010 	ldr	r3, [fp, #-16]
1001575c:	e5832000 	str	r2, [r3]
    mp->block_list = (rt_uint8_t *)block_ptr;
10015760:	e51b3014 	ldr	r3, [fp, #-20]
10015764:	e51b2010 	ldr	r2, [fp, #-16]
10015768:	e583201c 	str	r2, [r3, #28]

    if (mp->suspend_thread_count > 0)
1001576c:	e51b3014 	ldr	r3, [fp, #-20]
10015770:	e5933030 	ldr	r3, [r3, #48]	; 0x30
10015774:	e3530000 	cmp	r3, #0
10015778:	0a000011 	beq	100157c4 <rt_mp_free+0xe4>
    {
        /* get the suspended thread */
        thread = rt_list_entry(mp->suspend_thread.next,
1001577c:	e51b3014 	ldr	r3, [fp, #-20]
10015780:	e5933028 	ldr	r3, [r3, #40]	; 0x28
10015784:	e2433010 	sub	r3, r3, #16
10015788:	e50b3018 	str	r3, [fp, #-24]
                               struct rt_thread,
                               tlist);

        /* set error */
        thread->error = RT_EOK;
1001578c:	e51b3018 	ldr	r3, [fp, #-24]
10015790:	e3a02000 	mov	r2, #0
10015794:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* resume thread */
        rt_thread_resume(thread);
10015798:	e51b0018 	ldr	r0, [fp, #-24]
1001579c:	eb0005f5 	bl	10016f78 <rt_thread_resume>

        /* decrease suspended thread count */
        mp->suspend_thread_count --;
100157a0:	e51b3014 	ldr	r3, [fp, #-20]
100157a4:	e5933030 	ldr	r3, [r3, #48]	; 0x30
100157a8:	e2432001 	sub	r2, r3, #1
100157ac:	e51b3014 	ldr	r3, [fp, #-20]
100157b0:	e5832030 	str	r2, [r3, #48]	; 0x30

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
100157b4:	e1a00004 	mov	r0, r4
100157b8:	eb000fa0 	bl	10019640 <rt_hw_interrupt_enable>

        /* do a schedule */
        rt_schedule();
100157bc:	eb000278 	bl	100161a4 <rt_schedule>

        return;
100157c0:	ea000001 	b	100157cc <rt_mp_free+0xec>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
100157c4:	e1a00004 	mov	r0, r4
100157c8:	eb000f9c 	bl	10019640 <rt_hw_interrupt_enable>
}
100157cc:	e24bd008 	sub	sp, fp, #8
100157d0:	e8bd8810 	pop	{r4, fp, pc}

100157d4 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
100157d4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100157d8:	e28db000 	add	fp, sp, #0
100157dc:	e24dd00c 	sub	sp, sp, #12
100157e0:	e50b0008 	str	r0, [fp, #-8]
100157e4:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
100157e8:	e51b3008 	ldr	r3, [fp, #-8]
100157ec:	e5933000 	ldr	r3, [r3]
100157f0:	e51b200c 	ldr	r2, [fp, #-12]
100157f4:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
100157f8:	e51b3008 	ldr	r3, [fp, #-8]
100157fc:	e5932000 	ldr	r2, [r3]
10015800:	e51b300c 	ldr	r3, [fp, #-12]
10015804:	e5832000 	str	r2, [r3]

    l->next = n;
10015808:	e51b3008 	ldr	r3, [fp, #-8]
1001580c:	e51b200c 	ldr	r2, [fp, #-12]
10015810:	e5832000 	str	r2, [r3]
    n->prev = l;
10015814:	e51b300c 	ldr	r3, [fp, #-12]
10015818:	e51b2008 	ldr	r2, [fp, #-8]
1001581c:	e5832004 	str	r2, [r3, #4]
}
10015820:	e24bd000 	sub	sp, fp, #0
10015824:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015828:	e12fff1e 	bx	lr

1001582c <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
1001582c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015830:	e28db000 	add	fp, sp, #0
10015834:	e24dd00c 	sub	sp, sp, #12
10015838:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
1001583c:	e51b3008 	ldr	r3, [fp, #-8]
10015840:	e5933000 	ldr	r3, [r3]
10015844:	e51b2008 	ldr	r2, [fp, #-8]
10015848:	e5922004 	ldr	r2, [r2, #4]
1001584c:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
10015850:	e51b3008 	ldr	r3, [fp, #-8]
10015854:	e5933004 	ldr	r3, [r3, #4]
10015858:	e51b2008 	ldr	r2, [fp, #-8]
1001585c:	e5922000 	ldr	r2, [r2]
10015860:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
10015864:	e51b3008 	ldr	r3, [fp, #-8]
10015868:	e51b2008 	ldr	r2, [fp, #-8]
1001586c:	e5832004 	str	r2, [r3, #4]
10015870:	e51b3008 	ldr	r3, [fp, #-8]
10015874:	e5932004 	ldr	r2, [r3, #4]
10015878:	e51b3008 	ldr	r3, [fp, #-8]
1001587c:	e5832000 	str	r2, [r3]
}
10015880:	e24bd000 	sub	sp, fp, #0
10015884:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015888:	e12fff1e 	bx	lr

1001588c <rt_object_attach_sethook>:
 * attaches to kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_attach_sethook(void (*hook)(struct rt_object *object))
{
1001588c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015890:	e28db000 	add	fp, sp, #0
10015894:	e24dd00c 	sub	sp, sp, #12
10015898:	e50b0008 	str	r0, [fp, #-8]
    rt_object_attach_hook = hook;
1001589c:	e30c3438 	movw	r3, #50232	; 0xc438
100158a0:	e3413003 	movt	r3, #4099	; 0x1003
100158a4:	e51b2008 	ldr	r2, [fp, #-8]
100158a8:	e5832000 	str	r2, [r3]
}
100158ac:	e24bd000 	sub	sp, fp, #0
100158b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100158b4:	e12fff1e 	bx	lr

100158b8 <rt_object_detach_sethook>:
 * detaches from kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_detach_sethook(void (*hook)(struct rt_object *object))
{
100158b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100158bc:	e28db000 	add	fp, sp, #0
100158c0:	e24dd00c 	sub	sp, sp, #12
100158c4:	e50b0008 	str	r0, [fp, #-8]
    rt_object_detach_hook = hook;
100158c8:	e30c343c 	movw	r3, #50236	; 0xc43c
100158cc:	e3413003 	movt	r3, #4099	; 0x1003
100158d0:	e51b2008 	ldr	r2, [fp, #-8]
100158d4:	e5832000 	str	r2, [r3]
}
100158d8:	e24bd000 	sub	sp, fp, #0
100158dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100158e0:	e12fff1e 	bx	lr

100158e4 <rt_object_trytake_sethook>:
 * message queue - message is received by thread
 *
 * @param hook the hook function
 */
void rt_object_trytake_sethook(void (*hook)(struct rt_object *object))
{
100158e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100158e8:	e28db000 	add	fp, sp, #0
100158ec:	e24dd00c 	sub	sp, sp, #12
100158f0:	e50b0008 	str	r0, [fp, #-8]
    rt_object_trytake_hook = hook;
100158f4:	e30239b4 	movw	r3, #10676	; 0x29b4
100158f8:	e3413004 	movt	r3, #4100	; 0x1004
100158fc:	e51b2008 	ldr	r2, [fp, #-8]
10015900:	e5832000 	str	r2, [r3]
}
10015904:	e24bd000 	sub	sp, fp, #0
10015908:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001590c:	e12fff1e 	bx	lr

10015910 <rt_object_take_sethook>:
 * timer - timer is started
 *
 * @param hook the hook function
 */
void rt_object_take_sethook(void (*hook)(struct rt_object *object))
{
10015910:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015914:	e28db000 	add	fp, sp, #0
10015918:	e24dd00c 	sub	sp, sp, #12
1001591c:	e50b0008 	str	r0, [fp, #-8]
    rt_object_take_hook = hook;
10015920:	e30239b0 	movw	r3, #10672	; 0x29b0
10015924:	e3413004 	movt	r3, #4100	; 0x1004
10015928:	e51b2008 	ldr	r2, [fp, #-8]
1001592c:	e5832000 	str	r2, [r3]
}
10015930:	e24bd000 	sub	sp, fp, #0
10015934:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015938:	e12fff1e 	bx	lr

1001593c <rt_object_put_sethook>:
 * is put to kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_put_sethook(void (*hook)(struct rt_object *object))
{
1001593c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015940:	e28db000 	add	fp, sp, #0
10015944:	e24dd00c 	sub	sp, sp, #12
10015948:	e50b0008 	str	r0, [fp, #-8]
    rt_object_put_hook = hook;
1001594c:	e30239ac 	movw	r3, #10668	; 0x29ac
10015950:	e3413004 	movt	r3, #4100	; 0x1004
10015954:	e51b2008 	ldr	r2, [fp, #-8]
10015958:	e5832000 	str	r2, [r3]
}
1001595c:	e24bd000 	sub	sp, fp, #0
10015960:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015964:	e12fff1e 	bx	lr

10015968 <rt_system_object_init>:
 *
 * @deprecated since 0.3.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_object_init(void)
{
10015968:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001596c:	e28db000 	add	fp, sp, #0
}
10015970:	e24bd000 	sub	sp, fp, #0
10015974:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015978:	e12fff1e 	bx	lr

1001597c <rt_object_get_information>:
 * @param type the type of object
 * @return the object type information or RT_NULL
 */
struct rt_object_information *
rt_object_get_information(enum rt_object_class_type type)
{
1001597c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015980:	e28db000 	add	fp, sp, #0
10015984:	e24dd00c 	sub	sp, sp, #12
10015988:	e1a03000 	mov	r3, r0
1001598c:	e54b3005 	strb	r3, [fp, #-5]
    return &rt_object_container[type];
10015990:	e55b3005 	ldrb	r3, [fp, #-5]
10015994:	e1a02203 	lsl	r2, r3, #4
10015998:	e3063878 	movw	r3, #26744	; 0x6878
1001599c:	e3413003 	movt	r3, #4099	; 0x1003
100159a0:	e0823003 	add	r3, r2, r3
}
100159a4:	e1a00003 	mov	r0, r3
100159a8:	e24bd000 	sub	sp, fp, #0
100159ac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100159b0:	e12fff1e 	bx	lr

100159b4 <rt_object_init>:
 * @param name the object name. In system, the object's name must be unique.
 */
void rt_object_init(struct rt_object         *object,
                    enum rt_object_class_type type,
                    const char               *name)
{
100159b4:	e92d4810 	push	{r4, fp, lr}
100159b8:	e28db008 	add	fp, sp, #8
100159bc:	e24dd01c 	sub	sp, sp, #28
100159c0:	e50b0018 	str	r0, [fp, #-24]
100159c4:	e1a03001 	mov	r3, r1
100159c8:	e50b2020 	str	r2, [fp, #-32]
100159cc:	e54b3019 	strb	r3, [fp, #-25]
    /* get module object information */
    information = (rt_module_self() != RT_NULL) ?
        &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
100159d0:	e55b3019 	ldrb	r3, [fp, #-25]
100159d4:	e1a02203 	lsl	r2, r3, #4
100159d8:	e3063878 	movw	r3, #26744	; 0x6878
100159dc:	e3413003 	movt	r3, #4099	; 0x1003
100159e0:	e0823003 	add	r3, r2, r3
100159e4:	e50b3010 	str	r3, [fp, #-16]
#endif

    /* initialize object's parameters */

    /* set object type to static */
    object->type = type | RT_Object_Class_Static;
100159e8:	e55b3019 	ldrb	r3, [fp, #-25]
100159ec:	e1e03c83 	mvn	r3, r3, lsl #25
100159f0:	e1e03ca3 	mvn	r3, r3, lsr #25
100159f4:	e6ef2073 	uxtb	r2, r3
100159f8:	e51b3018 	ldr	r3, [fp, #-24]
100159fc:	e5c32006 	strb	r2, [r3, #6]

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
10015a00:	e51b3018 	ldr	r3, [fp, #-24]
10015a04:	e1a00003 	mov	r0, r3
10015a08:	e51b1020 	ldr	r1, [fp, #-32]
10015a0c:	e3a02006 	mov	r2, #6
10015a10:	ebfff391 	bl	1001285c <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
10015a14:	e30c3438 	movw	r3, #50232	; 0xc438
10015a18:	e3413003 	movt	r3, #4099	; 0x1003
10015a1c:	e5933000 	ldr	r3, [r3]
10015a20:	e3530000 	cmp	r3, #0
10015a24:	0a000004 	beq	10015a3c <rt_object_init+0x88>
10015a28:	e30c3438 	movw	r3, #50232	; 0xc438
10015a2c:	e3413003 	movt	r3, #4099	; 0x1003
10015a30:	e5933000 	ldr	r3, [r3]
10015a34:	e51b0018 	ldr	r0, [fp, #-24]
10015a38:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
10015a3c:	eb000efb 	bl	10019630 <rt_hw_interrupt_disable>
10015a40:	e1a04000 	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
10015a44:	e51b3010 	ldr	r3, [fp, #-16]
10015a48:	e2832004 	add	r2, r3, #4
10015a4c:	e51b3018 	ldr	r3, [fp, #-24]
10015a50:	e2833008 	add	r3, r3, #8
10015a54:	e1a00002 	mov	r0, r2
10015a58:	e1a01003 	mov	r1, r3
10015a5c:	ebffff5c 	bl	100157d4 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
10015a60:	e1a00004 	mov	r0, r4
10015a64:	eb000ef5 	bl	10019640 <rt_hw_interrupt_enable>
}
10015a68:	e24bd008 	sub	sp, fp, #8
10015a6c:	e8bd8810 	pop	{r4, fp, pc}

10015a70 <rt_object_detach>:
 * and the memory of static object is not freed.
 *
 * @param object the specified object to be detached.
 */
void rt_object_detach(rt_object_t object)
{
10015a70:	e92d4810 	push	{r4, fp, lr}
10015a74:	e28db008 	add	fp, sp, #8
10015a78:	e24dd00c 	sub	sp, sp, #12
10015a7c:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
10015a80:	e51b3010 	ldr	r3, [fp, #-16]
10015a84:	e3530000 	cmp	r3, #0
10015a88:	1a000005 	bne	10015aa4 <rt_object_detach+0x34>
10015a8c:	e3030ca0 	movw	r0, #15520	; 0x3ca0
10015a90:	e3410003 	movt	r0, #4099	; 0x1003
10015a94:	e3031d08 	movw	r1, #15624	; 0x3d08
10015a98:	e3411003 	movt	r1, #4099	; 0x1003
10015a9c:	e3a020fb 	mov	r2, #251	; 0xfb
10015aa0:	ebfff8c3 	bl	10013db4 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
10015aa4:	e30c343c 	movw	r3, #50236	; 0xc43c
10015aa8:	e3413003 	movt	r3, #4099	; 0x1003
10015aac:	e5933000 	ldr	r3, [r3]
10015ab0:	e3530000 	cmp	r3, #0
10015ab4:	0a000004 	beq	10015acc <rt_object_detach+0x5c>
10015ab8:	e30c343c 	movw	r3, #50236	; 0xc43c
10015abc:	e3413003 	movt	r3, #4099	; 0x1003
10015ac0:	e5933000 	ldr	r3, [r3]
10015ac4:	e51b0010 	ldr	r0, [fp, #-16]
10015ac8:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
10015acc:	eb000ed7 	bl	10019630 <rt_hw_interrupt_disable>
10015ad0:	e1a04000 	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
10015ad4:	e51b3010 	ldr	r3, [fp, #-16]
10015ad8:	e2833008 	add	r3, r3, #8
10015adc:	e1a00003 	mov	r0, r3
10015ae0:	ebffff51 	bl	1001582c <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
10015ae4:	e1a00004 	mov	r0, r4
10015ae8:	eb000ed4 	bl	10019640 <rt_hw_interrupt_enable>
}
10015aec:	e24bd008 	sub	sp, fp, #8
10015af0:	e8bd8810 	pop	{r4, fp, pc}

10015af4 <rt_object_allocate>:
 * @param name the object name. In system, the object's name must be unique.
 *
 * @return object
 */
rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
{
10015af4:	e92d4810 	push	{r4, fp, lr}
10015af8:	e28db008 	add	fp, sp, #8
10015afc:	e24dd01c 	sub	sp, sp, #28
10015b00:	e1a03000 	mov	r3, r0
10015b04:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10015b08:	e54b301d 	strb	r3, [fp, #-29]
    struct rt_object *object;
    register rt_base_t temp;
    struct rt_object_information *information;

    RT_DEBUG_NOT_IN_INTERRUPT;
10015b0c:	eb000ec7 	bl	10019630 <rt_hw_interrupt_disable>
10015b10:	e50b0010 	str	r0, [fp, #-16]
10015b14:	ebfff179 	bl	10012100 <rt_interrupt_get_nest>
10015b18:	e1a03000 	mov	r3, r0
10015b1c:	e3530000 	cmp	r3, #0
10015b20:	0a00000a 	beq	10015b50 <rt_object_allocate+0x5c>
10015b24:	e3030cb4 	movw	r0, #15540	; 0x3cb4
10015b28:	e3410003 	movt	r0, #4099	; 0x1003
10015b2c:	e3031d1c 	movw	r1, #15644	; 0x3d1c
10015b30:	e3411003 	movt	r1, #4099	; 0x1003
10015b34:	ebfff7e1 	bl	10013ac0 <rt_kprintf>
10015b38:	e3030cd8 	movw	r0, #15576	; 0x3cd8
10015b3c:	e3410003 	movt	r0, #4099	; 0x1003
10015b40:	e3031d1c 	movw	r1, #15644	; 0x3d1c
10015b44:	e3411003 	movt	r1, #4099	; 0x1003
10015b48:	e3a02f46 	mov	r2, #280	; 0x118
10015b4c:	ebfff898 	bl	10013db4 <rt_assert_handler>
10015b50:	e51b0010 	ldr	r0, [fp, #-16]
10015b54:	eb000eb9 	bl	10019640 <rt_hw_interrupt_enable>
     */
    information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
                  &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
10015b58:	e55b301d 	ldrb	r3, [fp, #-29]
10015b5c:	e1a02203 	lsl	r2, r3, #4
10015b60:	e3063878 	movw	r3, #26744	; 0x6878
10015b64:	e3413003 	movt	r3, #4099	; 0x1003
10015b68:	e0823003 	add	r3, r2, r3
10015b6c:	e50b3014 	str	r3, [fp, #-20]
#endif

    object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
10015b70:	e51b3014 	ldr	r3, [fp, #-20]
10015b74:	e593300c 	ldr	r3, [r3, #12]
10015b78:	e1a00003 	mov	r0, r3
10015b7c:	ebfff9c4 	bl	10014294 <rt_malloc>
10015b80:	e50b0018 	str	r0, [fp, #-24]
    if (object == RT_NULL)
10015b84:	e51b3018 	ldr	r3, [fp, #-24]
10015b88:	e3530000 	cmp	r3, #0
10015b8c:	1a000001 	bne	10015b98 <rt_object_allocate+0xa4>
    {
        /* no memory can be allocated */
        return RT_NULL;
10015b90:	e3a03000 	mov	r3, #0
10015b94:	ea000020 	b	10015c1c <rt_object_allocate+0x128>
    }

    /* initialize object's parameters */

    /* set object type */
    object->type = type;
10015b98:	e51b3018 	ldr	r3, [fp, #-24]
10015b9c:	e55b201d 	ldrb	r2, [fp, #-29]
10015ba0:	e5c32006 	strb	r2, [r3, #6]

    /* set object flag */
    object->flag = 0;
10015ba4:	e51b3018 	ldr	r3, [fp, #-24]
10015ba8:	e3a02000 	mov	r2, #0
10015bac:	e5c32007 	strb	r2, [r3, #7]
    }
    object->module_id = (void *)rt_module_self();
#endif

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
10015bb0:	e51b3018 	ldr	r3, [fp, #-24]
10015bb4:	e1a00003 	mov	r0, r3
10015bb8:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
10015bbc:	e3a02006 	mov	r2, #6
10015bc0:	ebfff325 	bl	1001285c <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
10015bc4:	e30c3438 	movw	r3, #50232	; 0xc438
10015bc8:	e3413003 	movt	r3, #4099	; 0x1003
10015bcc:	e5933000 	ldr	r3, [r3]
10015bd0:	e3530000 	cmp	r3, #0
10015bd4:	0a000004 	beq	10015bec <rt_object_allocate+0xf8>
10015bd8:	e30c3438 	movw	r3, #50232	; 0xc438
10015bdc:	e3413003 	movt	r3, #4099	; 0x1003
10015be0:	e5933000 	ldr	r3, [r3]
10015be4:	e51b0018 	ldr	r0, [fp, #-24]
10015be8:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
10015bec:	eb000e8f 	bl	10019630 <rt_hw_interrupt_disable>
10015bf0:	e1a04000 	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
10015bf4:	e51b3014 	ldr	r3, [fp, #-20]
10015bf8:	e2832004 	add	r2, r3, #4
10015bfc:	e51b3018 	ldr	r3, [fp, #-24]
10015c00:	e2833008 	add	r3, r3, #8
10015c04:	e1a00002 	mov	r0, r2
10015c08:	e1a01003 	mov	r1, r3
10015c0c:	ebfffef0 	bl	100157d4 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
10015c10:	e1a00004 	mov	r0, r4
10015c14:	eb000e89 	bl	10019640 <rt_hw_interrupt_enable>

    /* return object */
    return object;
10015c18:	e51b3018 	ldr	r3, [fp, #-24]
}
10015c1c:	e1a00003 	mov	r0, r3
10015c20:	e24bd008 	sub	sp, fp, #8
10015c24:	e8bd8810 	pop	{r4, fp, pc}

10015c28 <rt_object_delete>:
 * This function will delete an object and release object memory.
 *
 * @param object the specified object to be deleted.
 */
void rt_object_delete(rt_object_t object)
{
10015c28:	e92d4810 	push	{r4, fp, lr}
10015c2c:	e28db008 	add	fp, sp, #8
10015c30:	e24dd00c 	sub	sp, sp, #12
10015c34:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
10015c38:	e51b3010 	ldr	r3, [fp, #-16]
10015c3c:	e3530000 	cmp	r3, #0
10015c40:	1a000005 	bne	10015c5c <rt_object_delete+0x34>
10015c44:	e3030ca0 	movw	r0, #15520	; 0x3ca0
10015c48:	e3410003 	movt	r0, #4099	; 0x1003
10015c4c:	e3031d30 	movw	r1, #15664	; 0x3d30
10015c50:	e3411003 	movt	r1, #4099	; 0x1003
10015c54:	e3002159 	movw	r2, #345	; 0x159
10015c58:	ebfff855 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(!(object->type & RT_Object_Class_Static));
10015c5c:	e51b3010 	ldr	r3, [fp, #-16]
10015c60:	e5d33006 	ldrb	r3, [r3, #6]
10015c64:	e6ef3073 	uxtb	r3, r3
10015c68:	e6af3073 	sxtb	r3, r3
10015c6c:	e3530000 	cmp	r3, #0
10015c70:	aa000005 	bge	10015c8c <rt_object_delete+0x64>
10015c74:	e3030cdc 	movw	r0, #15580	; 0x3cdc
10015c78:	e3410003 	movt	r0, #4099	; 0x1003
10015c7c:	e3031d30 	movw	r1, #15664	; 0x3d30
10015c80:	e3411003 	movt	r1, #4099	; 0x1003
10015c84:	e300215a 	movw	r2, #346	; 0x15a
10015c88:	ebfff849 	bl	10013db4 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
10015c8c:	e30c343c 	movw	r3, #50236	; 0xc43c
10015c90:	e3413003 	movt	r3, #4099	; 0x1003
10015c94:	e5933000 	ldr	r3, [r3]
10015c98:	e3530000 	cmp	r3, #0
10015c9c:	0a000004 	beq	10015cb4 <rt_object_delete+0x8c>
10015ca0:	e30c343c 	movw	r3, #50236	; 0xc43c
10015ca4:	e3413003 	movt	r3, #4099	; 0x1003
10015ca8:	e5933000 	ldr	r3, [r3]
10015cac:	e51b0010 	ldr	r0, [fp, #-16]
10015cb0:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
10015cb4:	eb000e5d 	bl	10019630 <rt_hw_interrupt_disable>
10015cb8:	e1a04000 	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
10015cbc:	e51b3010 	ldr	r3, [fp, #-16]
10015cc0:	e2833008 	add	r3, r3, #8
10015cc4:	e1a00003 	mov	r0, r3
10015cc8:	ebfffed7 	bl	1001582c <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
10015ccc:	e1a00004 	mov	r0, r4
10015cd0:	eb000e5a 	bl	10019640 <rt_hw_interrupt_enable>
        rt_module_free((rt_module_t)object->module_id, object);
    else
#endif

    /* free the memory of object */
    RT_KERNEL_FREE(object);
10015cd4:	e51b0010 	ldr	r0, [fp, #-16]
10015cd8:	ebfffb88 	bl	10014b00 <rt_free>
}
10015cdc:	e24bd008 	sub	sp, fp, #8
10015ce0:	e8bd8810 	pop	{r4, fp, pc}

10015ce4 <rt_object_is_systemobject>:
 * @param object the specified object to be judged.
 *
 * @return RT_TRUE if a system object, RT_FALSE for others.
 */
rt_bool_t rt_object_is_systemobject(rt_object_t object)
{
10015ce4:	e92d4800 	push	{fp, lr}
10015ce8:	e28db004 	add	fp, sp, #4
10015cec:	e24dd008 	sub	sp, sp, #8
10015cf0:	e50b0008 	str	r0, [fp, #-8]
    /* object check */
    RT_ASSERT(object != RT_NULL);
10015cf4:	e51b3008 	ldr	r3, [fp, #-8]
10015cf8:	e3530000 	cmp	r3, #0
10015cfc:	1a000005 	bne	10015d18 <rt_object_is_systemobject+0x34>
10015d00:	e3030ca0 	movw	r0, #15520	; 0x3ca0
10015d04:	e3410003 	movt	r0, #4099	; 0x1003
10015d08:	e3031d44 	movw	r1, #15684	; 0x3d44
10015d0c:	e3411003 	movt	r1, #4099	; 0x1003
10015d10:	e300217e 	movw	r2, #382	; 0x17e
10015d14:	ebfff826 	bl	10013db4 <rt_assert_handler>

    if (object->type & RT_Object_Class_Static)
10015d18:	e51b3008 	ldr	r3, [fp, #-8]
10015d1c:	e5d33006 	ldrb	r3, [r3, #6]
10015d20:	e6ef3073 	uxtb	r3, r3
10015d24:	e6af3073 	sxtb	r3, r3
10015d28:	e3530000 	cmp	r3, #0
10015d2c:	aa000001 	bge	10015d38 <rt_object_is_systemobject+0x54>
        return RT_TRUE;
10015d30:	e3a03001 	mov	r3, #1
10015d34:	ea000000 	b	10015d3c <rt_object_is_systemobject+0x58>

    return RT_FALSE;
10015d38:	e3a03000 	mov	r3, #0
}
10015d3c:	e1a00003 	mov	r0, r3
10015d40:	e24bd004 	sub	sp, fp, #4
10015d44:	e8bd8800 	pop	{fp, pc}

10015d48 <rt_object_find>:
 * in object container.
 *
 * @note this function shall not be invoked in interrupt status.
 */
rt_object_t rt_object_find(const char *name, rt_uint8_t type)
{
10015d48:	e92d4800 	push	{fp, lr}
10015d4c:	e28db004 	add	fp, sp, #4
10015d50:	e24dd018 	sub	sp, sp, #24
10015d54:	e50b0018 	str	r0, [fp, #-24]
10015d58:	e1a03001 	mov	r3, r1
10015d5c:	e54b3019 	strb	r3, [fp, #-25]
    struct rt_object *object = RT_NULL;
10015d60:	e3a03000 	mov	r3, #0
10015d64:	e50b3010 	str	r3, [fp, #-16]
    struct rt_list_node *node = RT_NULL;
10015d68:	e3a03000 	mov	r3, #0
10015d6c:	e50b3008 	str	r3, [fp, #-8]
    struct rt_object_information *information = RT_NULL;
10015d70:	e3a03000 	mov	r3, #0
10015d74:	e50b300c 	str	r3, [fp, #-12]

    /* parameter check */
    if ((name == RT_NULL) || (type > RT_Object_Class_Unknown))
10015d78:	e51b3018 	ldr	r3, [fp, #-24]
10015d7c:	e3530000 	cmp	r3, #0
10015d80:	0a000002 	beq	10015d90 <rt_object_find+0x48>
10015d84:	e55b3019 	ldrb	r3, [fp, #-25]
10015d88:	e3530009 	cmp	r3, #9
10015d8c:	9a000001 	bls	10015d98 <rt_object_find+0x50>
        return RT_NULL;
10015d90:	e3a03000 	mov	r3, #0
10015d94:	ea000038 	b	10015e7c <rt_object_find+0x134>

    /* which is invoke in interrupt status */
    RT_DEBUG_NOT_IN_INTERRUPT;
10015d98:	eb000e24 	bl	10019630 <rt_hw_interrupt_disable>
10015d9c:	e50b0014 	str	r0, [fp, #-20]
10015da0:	ebfff0d6 	bl	10012100 <rt_interrupt_get_nest>
10015da4:	e1a03000 	mov	r3, r0
10015da8:	e3530000 	cmp	r3, #0
10015dac:	0a00000a 	beq	10015ddc <rt_object_find+0x94>
10015db0:	e3030cb4 	movw	r0, #15540	; 0x3cb4
10015db4:	e3410003 	movt	r0, #4099	; 0x1003
10015db8:	e3031d60 	movw	r1, #15712	; 0x3d60
10015dbc:	e3411003 	movt	r1, #4099	; 0x1003
10015dc0:	ebfff73e 	bl	10013ac0 <rt_kprintf>
10015dc4:	e3030cd8 	movw	r0, #15576	; 0x3cd8
10015dc8:	e3410003 	movt	r0, #4099	; 0x1003
10015dcc:	e3031d60 	movw	r1, #15712	; 0x3d60
10015dd0:	e3411003 	movt	r1, #4099	; 0x1003
10015dd4:	e300219d 	movw	r2, #413	; 0x19d
10015dd8:	ebfff7f5 	bl	10013db4 <rt_assert_handler>
10015ddc:	e51b0014 	ldr	r0, [fp, #-20]
10015de0:	eb000e16 	bl	10019640 <rt_hw_interrupt_enable>
        }
    }
#endif

    /* enter critical */
    rt_enter_critical();
10015de4:	eb000195 	bl	10016440 <rt_enter_critical>

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
10015de8:	e51b300c 	ldr	r3, [fp, #-12]
10015dec:	e3530000 	cmp	r3, #0
10015df0:	1a000005 	bne	10015e0c <rt_object_find+0xc4>
10015df4:	e55b3019 	ldrb	r3, [fp, #-25]
10015df8:	e1a02203 	lsl	r2, r3, #4
10015dfc:	e3063878 	movw	r3, #26744	; 0x6878
10015e00:	e3413003 	movt	r3, #4099	; 0x1003
10015e04:	e0823003 	add	r3, r2, r3
10015e08:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
10015e0c:	e51b300c 	ldr	r3, [fp, #-12]
10015e10:	e5933004 	ldr	r3, [r3, #4]
10015e14:	e50b3008 	str	r3, [fp, #-8]
10015e18:	ea000010 	b	10015e60 <rt_object_find+0x118>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
10015e1c:	e51b3008 	ldr	r3, [fp, #-8]
10015e20:	e2433008 	sub	r3, r3, #8
10015e24:	e50b3010 	str	r3, [fp, #-16]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
10015e28:	e51b3010 	ldr	r3, [fp, #-16]
10015e2c:	e1a00003 	mov	r0, r3
10015e30:	e51b1018 	ldr	r1, [fp, #-24]
10015e34:	e3a02006 	mov	r2, #6
10015e38:	ebfff2b7 	bl	1001291c <rt_strncmp>
10015e3c:	e1a03000 	mov	r3, r0
10015e40:	e3530000 	cmp	r3, #0
10015e44:	1a000002 	bne	10015e54 <rt_object_find+0x10c>
        {
            /* leave critical */
            rt_exit_critical();
10015e48:	eb00018e 	bl	10016488 <rt_exit_critical>

            return object;
10015e4c:	e51b3010 	ldr	r3, [fp, #-16]
10015e50:	ea000009 	b	10015e7c <rt_object_find+0x134>

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
10015e54:	e51b3008 	ldr	r3, [fp, #-8]
10015e58:	e5933000 	ldr	r3, [r3]
10015e5c:	e50b3008 	str	r3, [fp, #-8]
    rt_enter_critical();

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
         node != &(information->object_list);
10015e60:	e51b300c 	ldr	r3, [fp, #-12]
10015e64:	e2832004 	add	r2, r3, #4
    /* enter critical */
    rt_enter_critical();

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
10015e68:	e51b3008 	ldr	r3, [fp, #-8]
10015e6c:	e1520003 	cmp	r2, r3
10015e70:	1affffe9 	bne	10015e1c <rt_object_find+0xd4>
            return object;
        }
    }

    /* leave critical */
    rt_exit_critical();
10015e74:	eb000183 	bl	10016488 <rt_exit_critical>

    return RT_NULL;
10015e78:	e3a03000 	mov	r3, #0
}
10015e7c:	e1a00003 	mov	r0, r3
10015e80:	e24bd004 	sub	sp, fp, #4
10015e84:	e8bd8800 	pop	{fp, pc}

10015e88 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
10015e88:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015e8c:	e28db000 	add	fp, sp, #0
10015e90:	e24dd00c 	sub	sp, sp, #12
10015e94:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
10015e98:	e51b3008 	ldr	r3, [fp, #-8]
10015e9c:	e51b2008 	ldr	r2, [fp, #-8]
10015ea0:	e5832004 	str	r2, [r3, #4]
10015ea4:	e51b3008 	ldr	r3, [fp, #-8]
10015ea8:	e5932004 	ldr	r2, [r3, #4]
10015eac:	e51b3008 	ldr	r3, [fp, #-8]
10015eb0:	e5832000 	str	r2, [r3]
}
10015eb4:	e24bd000 	sub	sp, fp, #0
10015eb8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015ebc:	e12fff1e 	bx	lr

10015ec0 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
10015ec0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015ec4:	e28db000 	add	fp, sp, #0
10015ec8:	e24dd00c 	sub	sp, sp, #12
10015ecc:	e50b0008 	str	r0, [fp, #-8]
10015ed0:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
10015ed4:	e51b3008 	ldr	r3, [fp, #-8]
10015ed8:	e5933004 	ldr	r3, [r3, #4]
10015edc:	e51b200c 	ldr	r2, [fp, #-12]
10015ee0:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
10015ee4:	e51b3008 	ldr	r3, [fp, #-8]
10015ee8:	e5932004 	ldr	r2, [r3, #4]
10015eec:	e51b300c 	ldr	r3, [fp, #-12]
10015ef0:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
10015ef4:	e51b3008 	ldr	r3, [fp, #-8]
10015ef8:	e51b200c 	ldr	r2, [fp, #-12]
10015efc:	e5832004 	str	r2, [r3, #4]
    n->next = l;
10015f00:	e51b300c 	ldr	r3, [fp, #-12]
10015f04:	e51b2008 	ldr	r2, [fp, #-8]
10015f08:	e5832000 	str	r2, [r3]
}
10015f0c:	e24bd000 	sub	sp, fp, #0
10015f10:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015f14:	e12fff1e 	bx	lr

10015f18 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
10015f18:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015f1c:	e28db000 	add	fp, sp, #0
10015f20:	e24dd00c 	sub	sp, sp, #12
10015f24:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
10015f28:	e51b3008 	ldr	r3, [fp, #-8]
10015f2c:	e5933000 	ldr	r3, [r3]
10015f30:	e51b2008 	ldr	r2, [fp, #-8]
10015f34:	e5922004 	ldr	r2, [r2, #4]
10015f38:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
10015f3c:	e51b3008 	ldr	r3, [fp, #-8]
10015f40:	e5933004 	ldr	r3, [r3, #4]
10015f44:	e51b2008 	ldr	r2, [fp, #-8]
10015f48:	e5922000 	ldr	r2, [r2]
10015f4c:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
10015f50:	e51b3008 	ldr	r3, [fp, #-8]
10015f54:	e51b2008 	ldr	r2, [fp, #-8]
10015f58:	e5832004 	str	r2, [r3, #4]
10015f5c:	e51b3008 	ldr	r3, [fp, #-8]
10015f60:	e5932004 	ldr	r2, [r3, #4]
10015f64:	e51b3008 	ldr	r3, [fp, #-8]
10015f68:	e5832000 	str	r2, [r3]
}
10015f6c:	e24bd000 	sub	sp, fp, #0
10015f70:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015f74:	e12fff1e 	bx	lr

10015f78 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
10015f78:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015f7c:	e28db000 	add	fp, sp, #0
10015f80:	e24dd00c 	sub	sp, sp, #12
10015f84:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
10015f88:	e51b3008 	ldr	r3, [fp, #-8]
10015f8c:	e5932000 	ldr	r2, [r3]
10015f90:	e51b3008 	ldr	r3, [fp, #-8]
10015f94:	e1520003 	cmp	r2, r3
10015f98:	03a03001 	moveq	r3, #1
10015f9c:	13a03000 	movne	r3, #0
10015fa0:	e6ef3073 	uxtb	r3, r3
}
10015fa4:	e1a00003 	mov	r0, r3
10015fa8:	e24bd000 	sub	sp, fp, #0
10015fac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015fb0:	e12fff1e 	bx	lr

10015fb4 <rt_scheduler_sethook>:
 *
 * @param hook the hook function
 */
void
rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to))
{
10015fb4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10015fb8:	e28db000 	add	fp, sp, #0
10015fbc:	e24dd00c 	sub	sp, sp, #12
10015fc0:	e50b0008 	str	r0, [fp, #-8]
    rt_scheduler_hook = hook;
10015fc4:	e30c3444 	movw	r3, #50244	; 0xc444
10015fc8:	e3413003 	movt	r3, #4099	; 0x1003
10015fcc:	e51b2008 	ldr	r2, [fp, #-8]
10015fd0:	e5832000 	str	r2, [r3]
}
10015fd4:	e24bd000 	sub	sp, fp, #0
10015fd8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10015fdc:	e12fff1e 	bx	lr

10015fe0 <_rt_scheduler_stack_check>:
/*@}*/
#endif

#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
10015fe0:	e92d4800 	push	{fp, lr}
10015fe4:	e28db004 	add	fp, sp, #4
10015fe8:	e24dd010 	sub	sp, sp, #16
10015fec:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(thread != RT_NULL);
10015ff0:	e51b3010 	ldr	r3, [fp, #-16]
10015ff4:	e3530000 	cmp	r3, #0
10015ff8:	1a000005 	bne	10016014 <_rt_scheduler_stack_check+0x34>
10015ffc:	e3030d70 	movw	r0, #15728	; 0x3d70
10016000:	e3410003 	movt	r0, #4099	; 0x1003
10016004:	e3031dd8 	movw	r1, #15832	; 0x3dd8
10016008:	e3411003 	movt	r1, #4099	; 0x1003
1001600c:	e3a0205a 	mov	r2, #90	; 0x5a
10016010:	ebfff767 	bl	10013db4 <rt_assert_handler>

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
10016014:	e51b3010 	ldr	r3, [fp, #-16]
10016018:	e5933018 	ldr	r3, [r3, #24]
1001601c:	e1a02003 	mov	r2, r3
10016020:	e51b3010 	ldr	r3, [fp, #-16]
10016024:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10016028:	e1520003 	cmp	r2, r3
1001602c:	9a00000a 	bls	1001605c <_rt_scheduler_stack_check+0x7c>
        (rt_uint32_t)thread->sp >
10016030:	e51b3010 	ldr	r3, [fp, #-16]
10016034:	e5933018 	ldr	r3, [r3, #24]
10016038:	e1a02003 	mov	r2, r3
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
1001603c:	e51b3010 	ldr	r3, [fp, #-16]
10016040:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10016044:	e1a01003 	mov	r1, r3
10016048:	e51b3010 	ldr	r3, [fp, #-16]
1001604c:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
10016050:	e0813003 	add	r3, r1, r3
#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
10016054:	e1520003 	cmp	r2, r3
10016058:	9a00000c 	bls	10016090 <_rt_scheduler_stack_check+0xb0>
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
        rt_uint32_t level;

        rt_kprintf("thread:%s stack overflow\n", thread->name);
1001605c:	e51b3010 	ldr	r3, [fp, #-16]
10016060:	e3030d84 	movw	r0, #15748	; 0x3d84
10016064:	e3410003 	movt	r0, #4099	; 0x1003
10016068:	e1a01003 	mov	r1, r3
1001606c:	ebfff693 	bl	10013ac0 <rt_kprintf>
        #ifdef RT_USING_FINSH
        {
            extern long list_thread(void);
            list_thread();
10016070:	eb003733 	bl	10023d44 <list_thread>
        }
        #endif
        level = rt_hw_interrupt_disable();
10016074:	eb000d6d 	bl	10019630 <rt_hw_interrupt_disable>
10016078:	e1a03000 	mov	r3, r0
1001607c:	e50b3008 	str	r3, [fp, #-8]
        while (level);
10016080:	e51b3008 	ldr	r3, [fp, #-8]
10016084:	e3530000 	cmp	r3, #0
10016088:	1afffffc 	bne	10016080 <_rt_scheduler_stack_check+0xa0>
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
1001608c:	ea00000c 	b	100160c4 <_rt_scheduler_stack_check+0xe4>
        }
        #endif
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
10016090:	e51b3010 	ldr	r3, [fp, #-16]
10016094:	e5933018 	ldr	r3, [r3, #24]
10016098:	e1a02003 	mov	r2, r3
1001609c:	e51b3010 	ldr	r3, [fp, #-16]
100160a0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
100160a4:	e2833020 	add	r3, r3, #32
100160a8:	e1520003 	cmp	r2, r3
100160ac:	8a000004 	bhi	100160c4 <_rt_scheduler_stack_check+0xe4>
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
                   thread->name);
100160b0:	e51b3010 	ldr	r3, [fp, #-16]
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
100160b4:	e3030da0 	movw	r0, #15776	; 0x3da0
100160b8:	e3410003 	movt	r0, #4099	; 0x1003
100160bc:	e1a01003 	mov	r1, r3
100160c0:	ebfff67e 	bl	10013ac0 <rt_kprintf>
                   thread->name);
    }
}
100160c4:	e24bd004 	sub	sp, fp, #4
100160c8:	e8bd8800 	pop	{fp, pc}

100160cc <rt_system_scheduler_init>:
/**
 * @ingroup SystemInit
 * This function will initialize the system scheduler
 */
void rt_system_scheduler_init(void)
{
100160cc:	e92d4818 	push	{r3, r4, fp, lr}
100160d0:	e28db00c 	add	fp, sp, #12
    register rt_base_t offset;

    rt_scheduler_lock_nest = 0;
100160d4:	e30c3440 	movw	r3, #50240	; 0xc440
100160d8:	e3413003 	movt	r3, #4099	; 0x1003
100160dc:	e3a02000 	mov	r2, #0
100160e0:	e1c320b0 	strh	r2, [r3]

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
100160e4:	e3a04000 	mov	r4, #0
100160e8:	ea000006 	b	10016108 <rt_system_scheduler_init+0x3c>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
100160ec:	e1a02184 	lsl	r2, r4, #3
100160f0:	e30239b8 	movw	r3, #10680	; 0x29b8
100160f4:	e3413004 	movt	r3, #4100	; 0x1004
100160f8:	e0823003 	add	r3, r2, r3
100160fc:	e1a00003 	mov	r0, r3
10016100:	ebffff60 	bl	10015e88 <rt_list_init>
    rt_scheduler_lock_nest = 0;

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
10016104:	e2844001 	add	r4, r4, #1
10016108:	e354001f 	cmp	r4, #31
1001610c:	dafffff6 	ble	100160ec <rt_system_scheduler_init+0x20>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
    }

    rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
10016110:	e3023ab8 	movw	r3, #10936	; 0x2ab8
10016114:	e3413004 	movt	r3, #4100	; 0x1004
10016118:	e3a0201f 	mov	r2, #31
1001611c:	e5c32000 	strb	r2, [r3]
    rt_current_thread = RT_NULL;
10016120:	e3023abc 	movw	r3, #10940	; 0x2abc
10016124:	e3413004 	movt	r3, #4100	; 0x1004
10016128:	e3a02000 	mov	r2, #0
1001612c:	e5832000 	str	r2, [r3]

    /* initialize ready priority group */
    rt_thread_ready_priority_group = 0;
10016130:	e3023ac0 	movw	r3, #10944	; 0x2ac0
10016134:	e3413004 	movt	r3, #4100	; 0x1004
10016138:	e3a02000 	mov	r2, #0
1001613c:	e5832000 	str	r2, [r3]
    /* initialize ready table */
    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
#endif

    /* initialize thread defunct */
    rt_list_init(&rt_thread_defunct);
10016140:	e3020ac4 	movw	r0, #10948	; 0x2ac4
10016144:	e3410004 	movt	r0, #4100	; 0x1004
10016148:	ebffff4e 	bl	10015e88 <rt_list_init>
}
1001614c:	e8bd8818 	pop	{r3, r4, fp, pc}

10016150 <rt_system_scheduler_start>:
 * @ingroup SystemInit
 * This function will startup scheduler. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_system_scheduler_start(void)
{
10016150:	e92d4818 	push	{r3, r4, fp, lr}
10016154:	e28db00c 	add	fp, sp, #12
    register rt_ubase_t number;

    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#else
    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
10016158:	e3023ac0 	movw	r3, #10944	; 0x2ac0
1001615c:	e3413004 	movt	r3, #4100	; 0x1004
10016160:	e5933000 	ldr	r3, [r3]
10016164:	e1a00003 	mov	r0, r3
10016168:	ebfff6d0 	bl	10013cb0 <__rt_ffs>
1001616c:	e1a03000 	mov	r3, r0
10016170:	e2433001 	sub	r3, r3, #1
10016174:	e1a04003 	mov	r4, r3
#endif

    /* get switch to thread */
    to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
10016178:	e30239b8 	movw	r3, #10680	; 0x29b8
1001617c:	e3413004 	movt	r3, #4100	; 0x1004
10016180:	e7933184 	ldr	r3, [r3, r4, lsl #3]
10016184:	e2434010 	sub	r4, r3, #16
                              struct rt_thread,
                              tlist);

    rt_current_thread = to_thread;
10016188:	e3023abc 	movw	r3, #10940	; 0x2abc
1001618c:	e3413004 	movt	r3, #4100	; 0x1004
10016190:	e5834000 	str	r4, [r3]

    /* switch to new thread */
    rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
10016194:	e2843018 	add	r3, r4, #24
10016198:	e1a00003 	mov	r0, r3
1001619c:	eb000d35 	bl	10019678 <rt_hw_context_switch_to>

    /* never come back */
}
100161a0:	e8bd8818 	pop	{r3, r4, fp, pc}

100161a4 <rt_schedule>:
/**
 * This function will perform one schedule. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_schedule(void)
{
100161a4:	e92d4810 	push	{r4, fp, lr}
100161a8:	e28db008 	add	fp, sp, #8
100161ac:	e24dd014 	sub	sp, sp, #20
    rt_base_t level;
    struct rt_thread *to_thread;
    struct rt_thread *from_thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100161b0:	eb000d1e 	bl	10019630 <rt_hw_interrupt_disable>
100161b4:	e50b0010 	str	r0, [fp, #-16]

    /* check the scheduler is enabled or not */
    if (rt_scheduler_lock_nest == 0)
100161b8:	e30c3440 	movw	r3, #50240	; 0xc440
100161bc:	e3413003 	movt	r3, #4099	; 0x1003
100161c0:	e1d330b0 	ldrh	r3, [r3]
100161c4:	e3530000 	cmp	r3, #0
100161c8:	1a000042 	bne	100162d8 <rt_schedule+0x134>
    {
        register rt_ubase_t highest_ready_priority;

#if RT_THREAD_PRIORITY_MAX <= 32
        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
100161cc:	e3023ac0 	movw	r3, #10944	; 0x2ac0
100161d0:	e3413004 	movt	r3, #4100	; 0x1004
100161d4:	e5933000 	ldr	r3, [r3]
100161d8:	e1a00003 	mov	r0, r3
100161dc:	ebfff6b3 	bl	10013cb0 <__rt_ffs>
100161e0:	e1a03000 	mov	r3, r0
100161e4:	e2433001 	sub	r3, r3, #1
100161e8:	e1a04003 	mov	r4, r3
        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#endif

        /* get switch to thread */
        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
100161ec:	e30239b8 	movw	r3, #10680	; 0x29b8
100161f0:	e3413004 	movt	r3, #4100	; 0x1004
100161f4:	e7933184 	ldr	r3, [r3, r4, lsl #3]
100161f8:	e2433010 	sub	r3, r3, #16
100161fc:	e50b3014 	str	r3, [fp, #-20]
                                  struct rt_thread,
                                  tlist);

        /* if the destination thread is not the same as current thread */
        if (to_thread != rt_current_thread)
10016200:	e3023abc 	movw	r3, #10940	; 0x2abc
10016204:	e3413004 	movt	r3, #4100	; 0x1004
10016208:	e5933000 	ldr	r3, [r3]
1001620c:	e51b2014 	ldr	r2, [fp, #-20]
10016210:	e1520003 	cmp	r2, r3
10016214:	0a00002f 	beq	100162d8 <rt_schedule+0x134>
        {
            rt_current_priority = (rt_uint8_t)highest_ready_priority;
10016218:	e6ef2074 	uxtb	r2, r4
1001621c:	e3023ab8 	movw	r3, #10936	; 0x2ab8
10016220:	e3413004 	movt	r3, #4100	; 0x1004
10016224:	e5c32000 	strb	r2, [r3]
            from_thread         = rt_current_thread;
10016228:	e3023abc 	movw	r3, #10940	; 0x2abc
1001622c:	e3413004 	movt	r3, #4100	; 0x1004
10016230:	e5933000 	ldr	r3, [r3]
10016234:	e50b3018 	str	r3, [fp, #-24]
            rt_current_thread   = to_thread;
10016238:	e3023abc 	movw	r3, #10940	; 0x2abc
1001623c:	e3413004 	movt	r3, #4100	; 0x1004
10016240:	e51b2014 	ldr	r2, [fp, #-20]
10016244:	e5832000 	str	r2, [r3]

            RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
10016248:	e30c3444 	movw	r3, #50244	; 0xc444
1001624c:	e3413003 	movt	r3, #4099	; 0x1003
10016250:	e5933000 	ldr	r3, [r3]
10016254:	e3530000 	cmp	r3, #0
10016258:	0a000005 	beq	10016274 <rt_schedule+0xd0>
1001625c:	e30c3444 	movw	r3, #50244	; 0xc444
10016260:	e3413003 	movt	r3, #4099	; 0x1003
10016264:	e5933000 	ldr	r3, [r3]
10016268:	e51b0018 	ldr	r0, [fp, #-24]
1001626c:	e51b1014 	ldr	r1, [fp, #-20]
10016270:	e12fff33 	blx	r3
                          rt_interrupt_nest, highest_ready_priority,
                          RT_NAME_MAX, to_thread->name, to_thread->sp,
                          RT_NAME_MAX, from_thread->name, from_thread->sp));

#ifdef RT_USING_OVERFLOW_CHECK
            _rt_scheduler_stack_check(to_thread);
10016274:	e51b0014 	ldr	r0, [fp, #-20]
10016278:	ebffff58 	bl	10015fe0 <_rt_scheduler_stack_check>
#endif

            if (rt_interrupt_nest == 0)
1001627c:	e30239a4 	movw	r3, #10660	; 0x29a4
10016280:	e3413004 	movt	r3, #4100	; 0x1004
10016284:	e5d33000 	ldrb	r3, [r3]
10016288:	e6ef3073 	uxtb	r3, r3
1001628c:	e3530000 	cmp	r3, #0
10016290:	1a000008 	bne	100162b8 <rt_schedule+0x114>
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
10016294:	e51b3018 	ldr	r3, [fp, #-24]
10016298:	e2833018 	add	r3, r3, #24
1001629c:	e1a02003 	mov	r2, r3
                                     (rt_uint32_t)&to_thread->sp);
100162a0:	e51b3014 	ldr	r3, [fp, #-20]
100162a4:	e2833018 	add	r3, r3, #24
            _rt_scheduler_stack_check(to_thread);
#endif

            if (rt_interrupt_nest == 0)
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
100162a8:	e1a00002 	mov	r0, r2
100162ac:	e1a01003 	mov	r1, r3
100162b0:	eb000ce4 	bl	10019648 <rt_hw_context_switch>
100162b4:	ea000007 	b	100162d8 <rt_schedule+0x134>
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
100162b8:	e51b3018 	ldr	r3, [fp, #-24]
100162bc:	e2833018 	add	r3, r3, #24
100162c0:	e1a02003 	mov	r2, r3
                                               (rt_uint32_t)&to_thread->sp);
100162c4:	e51b3014 	ldr	r3, [fp, #-20]
100162c8:	e2833018 	add	r3, r3, #24
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
100162cc:	e1a00002 	mov	r0, r2
100162d0:	e1a01003 	mov	r1, r3
100162d4:	eb000ced 	bl	10019690 <rt_hw_context_switch_interrupt>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
100162d8:	e51b0010 	ldr	r0, [fp, #-16]
100162dc:	eb000cd7 	bl	10019640 <rt_hw_interrupt_enable>
}
100162e0:	e24bd008 	sub	sp, fp, #8
100162e4:	e8bd8810 	pop	{r4, fp, pc}

100162e8 <rt_schedule_insert_thread>:
 *
 * @param thread the thread to be inserted
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_insert_thread(struct rt_thread *thread)
{
100162e8:	e92d4810 	push	{r4, fp, lr}
100162ec:	e28db008 	add	fp, sp, #8
100162f0:	e24dd00c 	sub	sp, sp, #12
100162f4:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
100162f8:	e51b3010 	ldr	r3, [fp, #-16]
100162fc:	e3530000 	cmp	r3, #0
10016300:	1a000005 	bne	1001631c <rt_schedule_insert_thread+0x34>
10016304:	e3030d70 	movw	r0, #15728	; 0x3d70
10016308:	e3410003 	movt	r0, #4099	; 0x1003
1001630c:	e3031df4 	movw	r1, #15860	; 0x3df4
10016310:	e3411003 	movt	r1, #4099	; 0x1003
10016314:	e300210f 	movw	r2, #271	; 0x10f
10016318:	ebfff6a5 	bl	10013db4 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
1001631c:	eb000cc3 	bl	10019630 <rt_hw_interrupt_disable>
10016320:	e1a04000 	mov	r4, r0

    /* change stat */
    thread->stat = RT_THREAD_READY;
10016324:	e51b3010 	ldr	r3, [fp, #-16]
10016328:	e3a02001 	mov	r2, #1
1001632c:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* insert thread to ready list */
    rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
10016330:	e51b3010 	ldr	r3, [fp, #-16]
10016334:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10016338:	e1a02183 	lsl	r2, r3, #3
1001633c:	e30239b8 	movw	r3, #10680	; 0x29b8
10016340:	e3413004 	movt	r3, #4100	; 0x1004
10016344:	e0822003 	add	r2, r2, r3
10016348:	e51b3010 	ldr	r3, [fp, #-16]
1001634c:	e2833010 	add	r3, r3, #16
10016350:	e1a00002 	mov	r0, r2
10016354:	e1a01003 	mov	r1, r3
10016358:	ebfffed8 	bl	10015ec0 <rt_list_insert_before>
#endif

#if RT_THREAD_PRIORITY_MAX > 32
    rt_thread_ready_table[thread->number] |= thread->high_mask;
#endif
    rt_thread_ready_priority_group |= thread->number_mask;
1001635c:	e51b3010 	ldr	r3, [fp, #-16]
10016360:	e5932034 	ldr	r2, [r3, #52]	; 0x34
10016364:	e3023ac0 	movw	r3, #10944	; 0x2ac0
10016368:	e3413004 	movt	r3, #4100	; 0x1004
1001636c:	e5933000 	ldr	r3, [r3]
10016370:	e1822003 	orr	r2, r2, r3
10016374:	e3023ac0 	movw	r3, #10944	; 0x2ac0
10016378:	e3413004 	movt	r3, #4100	; 0x1004
1001637c:	e5832000 	str	r2, [r3]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10016380:	e1a00004 	mov	r0, r4
10016384:	eb000cad 	bl	10019640 <rt_hw_interrupt_enable>
}
10016388:	e24bd008 	sub	sp, fp, #8
1001638c:	e8bd8810 	pop	{r4, fp, pc}

10016390 <rt_schedule_remove_thread>:
 * @param thread the thread to be removed
 *
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_remove_thread(struct rt_thread *thread)
{
10016390:	e92d4810 	push	{r4, fp, lr}
10016394:	e28db008 	add	fp, sp, #8
10016398:	e24dd00c 	sub	sp, sp, #12
1001639c:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
100163a0:	e51b3010 	ldr	r3, [fp, #-16]
100163a4:	e3530000 	cmp	r3, #0
100163a8:	1a000005 	bne	100163c4 <rt_schedule_remove_thread+0x34>
100163ac:	e3030d70 	movw	r0, #15728	; 0x3d70
100163b0:	e3410003 	movt	r0, #4099	; 0x1003
100163b4:	e3031e10 	movw	r1, #15888	; 0x3e10
100163b8:	e3411003 	movt	r1, #4099	; 0x1003
100163bc:	e300213d 	movw	r2, #317	; 0x13d
100163c0:	ebfff67b 	bl	10013db4 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
100163c4:	eb000c99 	bl	10019630 <rt_hw_interrupt_disable>
100163c8:	e1a04000 	mov	r4, r0
                  thread->number_mask,
                  thread->high_mask));
#endif

    /* remove thread from ready list */
    rt_list_remove(&(thread->tlist));
100163cc:	e51b3010 	ldr	r3, [fp, #-16]
100163d0:	e2833010 	add	r3, r3, #16
100163d4:	e1a00003 	mov	r0, r3
100163d8:	ebfffece 	bl	10015f18 <rt_list_remove>
    if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
100163dc:	e51b3010 	ldr	r3, [fp, #-16]
100163e0:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
100163e4:	e1a02183 	lsl	r2, r3, #3
100163e8:	e30239b8 	movw	r3, #10680	; 0x29b8
100163ec:	e3413004 	movt	r3, #4100	; 0x1004
100163f0:	e0823003 	add	r3, r2, r3
100163f4:	e1a00003 	mov	r0, r3
100163f8:	ebfffede 	bl	10015f78 <rt_list_isempty>
100163fc:	e1a03000 	mov	r3, r0
10016400:	e3530000 	cmp	r3, #0
10016404:	0a000009 	beq	10016430 <rt_schedule_remove_thread+0xa0>
        if (rt_thread_ready_table[thread->number] == 0)
        {
            rt_thread_ready_priority_group &= ~thread->number_mask;
        }
#else
        rt_thread_ready_priority_group &= ~thread->number_mask;
10016408:	e51b3010 	ldr	r3, [fp, #-16]
1001640c:	e5933034 	ldr	r3, [r3, #52]	; 0x34
10016410:	e1e02003 	mvn	r2, r3
10016414:	e3023ac0 	movw	r3, #10944	; 0x2ac0
10016418:	e3413004 	movt	r3, #4100	; 0x1004
1001641c:	e5933000 	ldr	r3, [r3]
10016420:	e0022003 	and	r2, r2, r3
10016424:	e3023ac0 	movw	r3, #10944	; 0x2ac0
10016428:	e3413004 	movt	r3, #4100	; 0x1004
1001642c:	e5832000 	str	r2, [r3]
#endif
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10016430:	e1a00004 	mov	r0, r4
10016434:	eb000c81 	bl	10019640 <rt_hw_interrupt_enable>
}
10016438:	e24bd008 	sub	sp, fp, #8
1001643c:	e8bd8810 	pop	{r4, fp, pc}

10016440 <rt_enter_critical>:

/**
 * This function will lock the thread scheduler.
 */
void rt_enter_critical(void)
{
10016440:	e92d4818 	push	{r3, r4, fp, lr}
10016444:	e28db00c 	add	fp, sp, #12
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10016448:	eb000c78 	bl	10019630 <rt_hw_interrupt_disable>
1001644c:	e1a04000 	mov	r4, r0

    /*
     * the maximal number of nest is RT_UINT16_MAX, which is big
     * enough and does not check here
     */
    rt_scheduler_lock_nest ++;
10016450:	e30c3440 	movw	r3, #50240	; 0xc440
10016454:	e3413003 	movt	r3, #4099	; 0x1003
10016458:	e1d330b0 	ldrh	r3, [r3]
1001645c:	e6ff3073 	uxth	r3, r3
10016460:	e6ff3073 	uxth	r3, r3
10016464:	e2833001 	add	r3, r3, #1
10016468:	e6ff3073 	uxth	r3, r3
1001646c:	e6ff2073 	uxth	r2, r3
10016470:	e30c3440 	movw	r3, #50240	; 0xc440
10016474:	e3413003 	movt	r3, #4099	; 0x1003
10016478:	e1c320b0 	strh	r2, [r3]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
1001647c:	e1a00004 	mov	r0, r4
10016480:	eb000c6e 	bl	10019640 <rt_hw_interrupt_enable>
}
10016484:	e8bd8818 	pop	{r3, r4, fp, pc}

10016488 <rt_exit_critical>:

/**
 * This function will unlock the thread scheduler.
 */
void rt_exit_critical(void)
{
10016488:	e92d4818 	push	{r3, r4, fp, lr}
1001648c:	e28db00c 	add	fp, sp, #12
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10016490:	eb000c66 	bl	10019630 <rt_hw_interrupt_disable>
10016494:	e1a04000 	mov	r4, r0

    rt_scheduler_lock_nest --;
10016498:	e30c3440 	movw	r3, #50240	; 0xc440
1001649c:	e3413003 	movt	r3, #4099	; 0x1003
100164a0:	e1d330b0 	ldrh	r3, [r3]
100164a4:	e6ff3073 	uxth	r3, r3
100164a8:	e6ff3073 	uxth	r3, r3
100164ac:	e2433001 	sub	r3, r3, #1
100164b0:	e6ff3073 	uxth	r3, r3
100164b4:	e6ff2073 	uxth	r2, r3
100164b8:	e30c3440 	movw	r3, #50240	; 0xc440
100164bc:	e3413003 	movt	r3, #4099	; 0x1003
100164c0:	e1c320b0 	strh	r2, [r3]

    if (rt_scheduler_lock_nest <= 0)
100164c4:	e30c3440 	movw	r3, #50240	; 0xc440
100164c8:	e3413003 	movt	r3, #4099	; 0x1003
100164cc:	e1d330b0 	ldrh	r3, [r3]
100164d0:	e6bf3073 	sxth	r3, r3
100164d4:	e3530000 	cmp	r3, #0
100164d8:	ca000007 	bgt	100164fc <rt_exit_critical+0x74>
    {
        rt_scheduler_lock_nest = 0;
100164dc:	e30c3440 	movw	r3, #50240	; 0xc440
100164e0:	e3413003 	movt	r3, #4099	; 0x1003
100164e4:	e3a02000 	mov	r2, #0
100164e8:	e1c320b0 	strh	r2, [r3]
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
100164ec:	e1a00004 	mov	r0, r4
100164f0:	eb000c52 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
100164f4:	ebffff2a 	bl	100161a4 <rt_schedule>
100164f8:	ea000001 	b	10016504 <rt_exit_critical+0x7c>
    }
    else
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
100164fc:	e1a00004 	mov	r0, r4
10016500:	eb000c4e 	bl	10019640 <rt_hw_interrupt_enable>
    }
}
10016504:	e8bd8818 	pop	{r3, r4, fp, pc}

10016508 <rt_critical_level>:
 * Get the scheduler lock level
 *
 * @return the level of the scheduler lock. 0 means unlocked.
 */
rt_uint16_t rt_critical_level(void)
{
10016508:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001650c:	e28db000 	add	fp, sp, #0
    return rt_scheduler_lock_nest;
10016510:	e30c3440 	movw	r3, #50240	; 0xc440
10016514:	e3413003 	movt	r3, #4099	; 0x1003
10016518:	e1d330b0 	ldrh	r3, [r3]
1001651c:	e6ff3073 	uxth	r3, r3
}
10016520:	e1a00003 	mov	r0, r3
10016524:	e24bd000 	sub	sp, fp, #0
10016528:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001652c:	e12fff1e 	bx	lr

10016530 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
10016530:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10016534:	e28db000 	add	fp, sp, #0
10016538:	e24dd00c 	sub	sp, sp, #12
1001653c:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
10016540:	e51b3008 	ldr	r3, [fp, #-8]
10016544:	e51b2008 	ldr	r2, [fp, #-8]
10016548:	e5832004 	str	r2, [r3, #4]
1001654c:	e51b3008 	ldr	r3, [fp, #-8]
10016550:	e5932004 	ldr	r2, [r3, #4]
10016554:	e51b3008 	ldr	r3, [fp, #-8]
10016558:	e5832000 	str	r2, [r3]
}
1001655c:	e24bd000 	sub	sp, fp, #0
10016560:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10016564:	e12fff1e 	bx	lr

10016568 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
10016568:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001656c:	e28db000 	add	fp, sp, #0
10016570:	e24dd00c 	sub	sp, sp, #12
10016574:	e50b0008 	str	r0, [fp, #-8]
10016578:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
1001657c:	e51b3008 	ldr	r3, [fp, #-8]
10016580:	e5933000 	ldr	r3, [r3]
10016584:	e51b200c 	ldr	r2, [fp, #-12]
10016588:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
1001658c:	e51b3008 	ldr	r3, [fp, #-8]
10016590:	e5932000 	ldr	r2, [r3]
10016594:	e51b300c 	ldr	r3, [fp, #-12]
10016598:	e5832000 	str	r2, [r3]

    l->next = n;
1001659c:	e51b3008 	ldr	r3, [fp, #-8]
100165a0:	e51b200c 	ldr	r2, [fp, #-12]
100165a4:	e5832000 	str	r2, [r3]
    n->prev = l;
100165a8:	e51b300c 	ldr	r3, [fp, #-12]
100165ac:	e51b2008 	ldr	r2, [fp, #-8]
100165b0:	e5832004 	str	r2, [r3, #4]
}
100165b4:	e24bd000 	sub	sp, fp, #0
100165b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100165bc:	e12fff1e 	bx	lr

100165c0 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
100165c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100165c4:	e28db000 	add	fp, sp, #0
100165c8:	e24dd00c 	sub	sp, sp, #12
100165cc:	e50b0008 	str	r0, [fp, #-8]
100165d0:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
100165d4:	e51b3008 	ldr	r3, [fp, #-8]
100165d8:	e5933004 	ldr	r3, [r3, #4]
100165dc:	e51b200c 	ldr	r2, [fp, #-12]
100165e0:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
100165e4:	e51b3008 	ldr	r3, [fp, #-8]
100165e8:	e5932004 	ldr	r2, [r3, #4]
100165ec:	e51b300c 	ldr	r3, [fp, #-12]
100165f0:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
100165f4:	e51b3008 	ldr	r3, [fp, #-8]
100165f8:	e51b200c 	ldr	r2, [fp, #-12]
100165fc:	e5832004 	str	r2, [r3, #4]
    n->next = l;
10016600:	e51b300c 	ldr	r3, [fp, #-12]
10016604:	e51b2008 	ldr	r2, [fp, #-8]
10016608:	e5832000 	str	r2, [r3]
}
1001660c:	e24bd000 	sub	sp, fp, #0
10016610:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10016614:	e12fff1e 	bx	lr

10016618 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
10016618:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001661c:	e28db000 	add	fp, sp, #0
10016620:	e24dd00c 	sub	sp, sp, #12
10016624:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
10016628:	e51b3008 	ldr	r3, [fp, #-8]
1001662c:	e5933000 	ldr	r3, [r3]
10016630:	e51b2008 	ldr	r2, [fp, #-8]
10016634:	e5922004 	ldr	r2, [r2, #4]
10016638:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
1001663c:	e51b3008 	ldr	r3, [fp, #-8]
10016640:	e5933004 	ldr	r3, [r3, #4]
10016644:	e51b2008 	ldr	r2, [fp, #-8]
10016648:	e5922000 	ldr	r2, [r2]
1001664c:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
10016650:	e51b3008 	ldr	r3, [fp, #-8]
10016654:	e51b2008 	ldr	r2, [fp, #-8]
10016658:	e5832004 	str	r2, [r3, #4]
1001665c:	e51b3008 	ldr	r3, [fp, #-8]
10016660:	e5932004 	ldr	r2, [r3, #4]
10016664:	e51b3008 	ldr	r3, [fp, #-8]
10016668:	e5832000 	str	r2, [r3]
}
1001666c:	e24bd000 	sub	sp, fp, #0
10016670:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10016674:	e12fff1e 	bx	lr

10016678 <rt_thread_exit>:
extern rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];
extern struct rt_thread *rt_current_thread;
extern rt_list_t rt_thread_defunct;

static void rt_thread_exit(void)
{
10016678:	e92d4810 	push	{r4, fp, lr}
1001667c:	e28db008 	add	fp, sp, #8
10016680:	e24dd00c 	sub	sp, sp, #12
    struct rt_thread *thread;
    register rt_base_t level;

    /* get current thread */
    thread = rt_current_thread;
10016684:	e3023abc 	movw	r3, #10940	; 0x2abc
10016688:	e3413004 	movt	r3, #4100	; 0x1004
1001668c:	e5933000 	ldr	r3, [r3]
10016690:	e50b3010 	str	r3, [fp, #-16]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10016694:	eb000be5 	bl	10019630 <rt_hw_interrupt_disable>
10016698:	e1a04000 	mov	r4, r0

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
1001669c:	e51b0010 	ldr	r0, [fp, #-16]
100166a0:	ebffff3a 	bl	10016390 <rt_schedule_remove_thread>
    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
100166a4:	e51b3010 	ldr	r3, [fp, #-16]
100166a8:	e3a02004 	mov	r2, #4
100166ac:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);
100166b0:	e51b3010 	ldr	r3, [fp, #-16]
100166b4:	e2833048 	add	r3, r3, #72	; 0x48
100166b8:	e1a00003 	mov	r0, r3
100166bc:	eb000375 	bl	10017498 <rt_timer_detach>

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
100166c0:	e51b0010 	ldr	r0, [fp, #-16]
100166c4:	ebfffd86 	bl	10015ce4 <rt_object_is_systemobject>
100166c8:	e1a03000 	mov	r3, r0
100166cc:	e3530001 	cmp	r3, #1
100166d0:	1a000006 	bne	100166f0 <rt_thread_exit+0x78>
        thread->cleanup == RT_NULL)
100166d4:	e51b3010 	ldr	r3, [fp, #-16]
100166d8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
    thread->stat = RT_THREAD_CLOSE;

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
100166dc:	e3530000 	cmp	r3, #0
100166e0:	1a000002 	bne	100166f0 <rt_thread_exit+0x78>
        thread->cleanup == RT_NULL)
    {
        rt_object_detach((rt_object_t)thread);
100166e4:	e51b0010 	ldr	r0, [fp, #-16]
100166e8:	ebfffce0 	bl	10015a70 <rt_object_detach>
100166ec:	ea000005 	b	10016708 <rt_thread_exit+0x90>
    }
    else
    {
        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
100166f0:	e51b3010 	ldr	r3, [fp, #-16]
100166f4:	e2833010 	add	r3, r3, #16
100166f8:	e3020ac4 	movw	r0, #10948	; 0x2ac4
100166fc:	e3410004 	movt	r0, #4100	; 0x1004
10016700:	e1a01003 	mov	r1, r3
10016704:	ebffff97 	bl	10016568 <rt_list_insert_after>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10016708:	e1a00004 	mov	r0, r4
1001670c:	eb000bcb 	bl	10019640 <rt_hw_interrupt_enable>

    /* switch to next task */
    rt_schedule();
10016710:	ebfffea3 	bl	100161a4 <rt_schedule>
}
10016714:	e24bd008 	sub	sp, fp, #8
10016718:	e8bd8810 	pop	{r4, fp, pc}

1001671c <_rt_thread_init>:
                                void             *parameter,
                                void             *stack_start,
                                rt_uint32_t       stack_size,
                                rt_uint8_t        priority,
                                rt_uint32_t       tick)
{
1001671c:	e92d4800 	push	{fp, lr}
10016720:	e28db004 	add	fp, sp, #4
10016724:	e24dd018 	sub	sp, sp, #24
10016728:	e50b0008 	str	r0, [fp, #-8]
1001672c:	e50b100c 	str	r1, [fp, #-12]
10016730:	e50b2010 	str	r2, [fp, #-16]
10016734:	e50b3014 	str	r3, [fp, #-20]
    /* init thread list */
    rt_list_init(&(thread->tlist));
10016738:	e51b3008 	ldr	r3, [fp, #-8]
1001673c:	e2833010 	add	r3, r3, #16
10016740:	e1a00003 	mov	r0, r3
10016744:	ebffff79 	bl	10016530 <rt_list_init>

    thread->entry = (void *)entry;
10016748:	e51b3008 	ldr	r3, [fp, #-8]
1001674c:	e51b2010 	ldr	r2, [fp, #-16]
10016750:	e583201c 	str	r2, [r3, #28]
    thread->parameter = parameter;
10016754:	e51b3008 	ldr	r3, [fp, #-8]
10016758:	e51b2014 	ldr	r2, [fp, #-20]
1001675c:	e5832020 	str	r2, [r3, #32]

    /* stack init */
    thread->stack_addr = stack_start;
10016760:	e51b3008 	ldr	r3, [fp, #-8]
10016764:	e59b2004 	ldr	r2, [fp, #4]
10016768:	e5832024 	str	r2, [r3, #36]	; 0x24
    thread->stack_size = (rt_uint16_t)stack_size;
1001676c:	e59b3008 	ldr	r3, [fp, #8]
10016770:	e6ff2073 	uxth	r2, r3
10016774:	e51b3008 	ldr	r3, [fp, #-8]
10016778:	e1c322b8 	strh	r2, [r3, #40]	; 0x28

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
1001677c:	e51b3008 	ldr	r3, [fp, #-8]
10016780:	e5932024 	ldr	r2, [r3, #36]	; 0x24
10016784:	e51b3008 	ldr	r3, [fp, #-8]
10016788:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
1001678c:	e1a00002 	mov	r0, r2
10016790:	e3a01023 	mov	r1, #35	; 0x23
10016794:	e1a02003 	mov	r2, r3
10016798:	ebffeeae 	bl	10012258 <rt_memset>
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
1001679c:	e51b3008 	ldr	r3, [fp, #-8]
100167a0:	e593001c 	ldr	r0, [r3, #28]
100167a4:	e51b3008 	ldr	r3, [fp, #-8]
100167a8:	e5931020 	ldr	r1, [r3, #32]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
100167ac:	e51b3008 	ldr	r3, [fp, #-8]
100167b0:	e5932024 	ldr	r2, [r3, #36]	; 0x24
100167b4:	e51b3008 	ldr	r3, [fp, #-8]
100167b8:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
100167bc:	e2433004 	sub	r3, r3, #4
100167c0:	e0823003 	add	r3, r2, r3
    thread->stack_addr = stack_start;
    thread->stack_size = (rt_uint16_t)stack_size;

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
100167c4:	e1a02003 	mov	r2, r3
100167c8:	e3063678 	movw	r3, #26232	; 0x6678
100167cc:	e3413001 	movt	r3, #4097	; 0x1001
100167d0:	eb000a4a 	bl	10019100 <rt_hw_stack_init>
100167d4:	e1a02000 	mov	r2, r0
100167d8:	e51b3008 	ldr	r3, [fp, #-8]
100167dc:	e5832018 	str	r2, [r3, #24]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
        (void *)rt_thread_exit);

    /* priority init */
    RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
100167e0:	e5db300c 	ldrb	r3, [fp, #12]
100167e4:	e353001f 	cmp	r3, #31
100167e8:	9a000005 	bls	10016804 <_rt_thread_init+0xe8>
100167ec:	e3030e2c 	movw	r0, #15916	; 0x3e2c
100167f0:	e3410003 	movt	r0, #4099	; 0x1003
100167f4:	e3031ec0 	movw	r1, #16064	; 0x3ec0
100167f8:	e3411003 	movt	r1, #4099	; 0x1003
100167fc:	e3a0206e 	mov	r2, #110	; 0x6e
10016800:	ebfff56b 	bl	10013db4 <rt_assert_handler>
    thread->init_priority    = priority;
10016804:	e51b3008 	ldr	r3, [fp, #-8]
10016808:	e5db200c 	ldrb	r2, [fp, #12]
1001680c:	e5c32032 	strb	r2, [r3, #50]	; 0x32
    thread->current_priority = priority;
10016810:	e51b3008 	ldr	r3, [fp, #-8]
10016814:	e5db200c 	ldrb	r2, [fp, #12]
10016818:	e5c32031 	strb	r2, [r3, #49]	; 0x31

    /* tick init */
    thread->init_tick      = tick;
1001681c:	e51b3008 	ldr	r3, [fp, #-8]
10016820:	e59b2010 	ldr	r2, [fp, #16]
10016824:	e5832040 	str	r2, [r3, #64]	; 0x40
    thread->remaining_tick = tick;
10016828:	e51b3008 	ldr	r3, [fp, #-8]
1001682c:	e59b2010 	ldr	r2, [fp, #16]
10016830:	e5832044 	str	r2, [r3, #68]	; 0x44

    /* error and flags */
    thread->error = RT_EOK;
10016834:	e51b3008 	ldr	r3, [fp, #-8]
10016838:	e3a02000 	mov	r2, #0
1001683c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    thread->stat  = RT_THREAD_INIT;
10016840:	e51b3008 	ldr	r3, [fp, #-8]
10016844:	e3a02000 	mov	r2, #0
10016848:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
1001684c:	e51b3008 	ldr	r3, [fp, #-8]
10016850:	e3a02000 	mov	r2, #0
10016854:	e5832070 	str	r2, [r3, #112]	; 0x70
    thread->user_data = 0;
10016858:	e51b3008 	ldr	r3, [fp, #-8]
1001685c:	e3a02000 	mov	r2, #0
10016860:	e5832074 	str	r2, [r3, #116]	; 0x74

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
10016864:	e51b3008 	ldr	r3, [fp, #-8]
10016868:	e2831048 	add	r1, r3, #72	; 0x48
                  thread->name,
1001686c:	e51b2008 	ldr	r2, [fp, #-8]
    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
    thread->user_data = 0;

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
10016870:	e3a03000 	mov	r3, #0
10016874:	e58d3000 	str	r3, [sp]
10016878:	e3a03000 	mov	r3, #0
1001687c:	e58d3004 	str	r3, [sp, #4]
10016880:	e1a00001 	mov	r0, r1
10016884:	e1a01002 	mov	r1, r2
10016888:	e307200c 	movw	r2, #28684	; 0x700c
1001688c:	e3412001 	movt	r2, #4097	; 0x1001
10016890:	e51b3008 	ldr	r3, [fp, #-8]
10016894:	eb0002e2 	bl	10017424 <rt_timer_init>
                  rt_thread_timeout,
                  thread,
                  0,
                  RT_TIMER_FLAG_ONE_SHOT);

    return RT_EOK;
10016898:	e3a03000 	mov	r3, #0
}
1001689c:	e1a00003 	mov	r0, r3
100168a0:	e24bd004 	sub	sp, fp, #4
100168a4:	e8bd8800 	pop	{fp, pc}

100168a8 <rt_thread_init>:
                        void             *parameter,
                        void             *stack_start,
                        rt_uint32_t       stack_size,
                        rt_uint8_t        priority,
                        rt_uint32_t       tick)
{
100168a8:	e92d4800 	push	{fp, lr}
100168ac:	e28db004 	add	fp, sp, #4
100168b0:	e24dd020 	sub	sp, sp, #32
100168b4:	e50b0008 	str	r0, [fp, #-8]
100168b8:	e50b100c 	str	r1, [fp, #-12]
100168bc:	e50b2010 	str	r2, [fp, #-16]
100168c0:	e50b3014 	str	r3, [fp, #-20]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
100168c4:	e51b3008 	ldr	r3, [fp, #-8]
100168c8:	e3530000 	cmp	r3, #0
100168cc:	1a000005 	bne	100168e8 <rt_thread_init+0x40>
100168d0:	e3030e50 	movw	r0, #15952	; 0x3e50
100168d4:	e3410003 	movt	r0, #4099	; 0x1003
100168d8:	e3031ed0 	movw	r1, #16080	; 0x3ed0
100168dc:	e3411003 	movt	r1, #4099	; 0x1003
100168e0:	e3a020a8 	mov	r2, #168	; 0xa8
100168e4:	ebfff532 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(stack_start != RT_NULL);
100168e8:	e59b3004 	ldr	r3, [fp, #4]
100168ec:	e3530000 	cmp	r3, #0
100168f0:	1a000005 	bne	1001690c <rt_thread_init+0x64>
100168f4:	e3030e64 	movw	r0, #15972	; 0x3e64
100168f8:	e3410003 	movt	r0, #4099	; 0x1003
100168fc:	e3031ed0 	movw	r1, #16080	; 0x3ed0
10016900:	e3411003 	movt	r1, #4099	; 0x1003
10016904:	e3a020a9 	mov	r2, #169	; 0xa9
10016908:	ebfff529 	bl	10013db4 <rt_assert_handler>

    /* init thread object */
    rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
1001690c:	e51b0008 	ldr	r0, [fp, #-8]
10016910:	e3a01000 	mov	r1, #0
10016914:	e51b200c 	ldr	r2, [fp, #-12]
10016918:	ebfffc25 	bl	100159b4 <rt_object_init>

    return _rt_thread_init(thread,
1001691c:	e59b3004 	ldr	r3, [fp, #4]
10016920:	e58d3000 	str	r3, [sp]
10016924:	e59b3008 	ldr	r3, [fp, #8]
10016928:	e58d3004 	str	r3, [sp, #4]
1001692c:	e5db300c 	ldrb	r3, [fp, #12]
10016930:	e58d3008 	str	r3, [sp, #8]
10016934:	e59b3010 	ldr	r3, [fp, #16]
10016938:	e58d300c 	str	r3, [sp, #12]
1001693c:	e51b0008 	ldr	r0, [fp, #-8]
10016940:	e51b100c 	ldr	r1, [fp, #-12]
10016944:	e51b2010 	ldr	r2, [fp, #-16]
10016948:	e51b3014 	ldr	r3, [fp, #-20]
1001694c:	ebffff72 	bl	1001671c <_rt_thread_init>
10016950:	e1a03000 	mov	r3, r0
                           parameter,
                           stack_start,
                           stack_size,
                           priority,
                           tick);
}
10016954:	e1a00003 	mov	r0, r3
10016958:	e24bd004 	sub	sp, fp, #4
1001695c:	e8bd8800 	pop	{fp, pc}

10016960 <rt_thread_self>:
 * This function will return self thread object
 *
 * @return the self thread object
 */
rt_thread_t rt_thread_self(void)
{
10016960:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10016964:	e28db000 	add	fp, sp, #0
    return rt_current_thread;
10016968:	e3023abc 	movw	r3, #10940	; 0x2abc
1001696c:	e3413004 	movt	r3, #4100	; 0x1004
10016970:	e5933000 	ldr	r3, [r3]
}
10016974:	e1a00003 	mov	r0, r3
10016978:	e24bd000 	sub	sp, fp, #0
1001697c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10016980:	e12fff1e 	bx	lr

10016984 <rt_thread_startup>:
 * @param thread the thread to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_startup(rt_thread_t thread)
{
10016984:	e92d4800 	push	{fp, lr}
10016988:	e28db004 	add	fp, sp, #4
1001698c:	e24dd008 	sub	sp, sp, #8
10016990:	e50b0008 	str	r0, [fp, #-8]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10016994:	e51b3008 	ldr	r3, [fp, #-8]
10016998:	e3530000 	cmp	r3, #0
1001699c:	1a000005 	bne	100169b8 <rt_thread_startup+0x34>
100169a0:	e3030e50 	movw	r0, #15952	; 0x3e50
100169a4:	e3410003 	movt	r0, #4099	; 0x1003
100169a8:	e3031ee0 	movw	r1, #16096	; 0x3ee0
100169ac:	e3411003 	movt	r1, #4099	; 0x1003
100169b0:	e3a020ce 	mov	r2, #206	; 0xce
100169b4:	ebfff4fe 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_INIT);
100169b8:	e51b3008 	ldr	r3, [fp, #-8]
100169bc:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
100169c0:	e3530000 	cmp	r3, #0
100169c4:	0a000005 	beq	100169e0 <rt_thread_startup+0x5c>
100169c8:	e3030e7c 	movw	r0, #15996	; 0x3e7c
100169cc:	e3410003 	movt	r0, #4099	; 0x1003
100169d0:	e3031ee0 	movw	r1, #16096	; 0x3ee0
100169d4:	e3411003 	movt	r1, #4099	; 0x1003
100169d8:	e3a020cf 	mov	r2, #207	; 0xcf
100169dc:	ebfff4f4 	bl	10013db4 <rt_assert_handler>

    /* set current priority to init priority */
    thread->current_priority = thread->init_priority;
100169e0:	e51b3008 	ldr	r3, [fp, #-8]
100169e4:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
100169e8:	e51b3008 	ldr	r3, [fp, #-8]
100169ec:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
    thread->number      = thread->current_priority >> 3;            /* 5bit */
    thread->number_mask = 1L << thread->number;
    thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
#else
    thread->number_mask = 1L << thread->current_priority;
100169f0:	e51b3008 	ldr	r3, [fp, #-8]
100169f4:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
100169f8:	e1a02003 	mov	r2, r3
100169fc:	e3a03001 	mov	r3, #1
10016a00:	e1a03213 	lsl	r3, r3, r2
10016a04:	e1a02003 	mov	r2, r3
10016a08:	e51b3008 	ldr	r3, [fp, #-8]
10016a0c:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
                                   thread->name, thread->init_priority));
    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
10016a10:	e51b3008 	ldr	r3, [fp, #-8]
10016a14:	e3a02002 	mov	r2, #2
10016a18:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    /* then resume it */
    rt_thread_resume(thread);
10016a1c:	e51b0008 	ldr	r0, [fp, #-8]
10016a20:	eb000154 	bl	10016f78 <rt_thread_resume>
    if (rt_thread_self() != RT_NULL)
10016a24:	ebffffcd 	bl	10016960 <rt_thread_self>
10016a28:	e1a03000 	mov	r3, r0
10016a2c:	e3530000 	cmp	r3, #0
10016a30:	0a000000 	beq	10016a38 <rt_thread_startup+0xb4>
    {
        /* do a scheduling */
        rt_schedule();
10016a34:	ebfffdda 	bl	100161a4 <rt_schedule>
    }

    return RT_EOK;
10016a38:	e3a03000 	mov	r3, #0
}
10016a3c:	e1a00003 	mov	r0, r3
10016a40:	e24bd004 	sub	sp, fp, #4
10016a44:	e8bd8800 	pop	{fp, pc}

10016a48 <rt_thread_detach>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_detach(rt_thread_t thread)
{
10016a48:	e92d4800 	push	{fp, lr}
10016a4c:	e28db004 	add	fp, sp, #4
10016a50:	e24dd010 	sub	sp, sp, #16
10016a54:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10016a58:	e51b3010 	ldr	r3, [fp, #-16]
10016a5c:	e3530000 	cmp	r3, #0
10016a60:	1a000005 	bne	10016a7c <rt_thread_detach+0x34>
10016a64:	e3030e50 	movw	r0, #15952	; 0x3e50
10016a68:	e3410003 	movt	r0, #4099	; 0x1003
10016a6c:	e3031ef4 	movw	r1, #16116	; 0x3ef4
10016a70:	e3411003 	movt	r1, #4099	; 0x1003
10016a74:	e3a020fa 	mov	r2, #250	; 0xfa
10016a78:	ebfff4cd 	bl	10013db4 <rt_assert_handler>

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
10016a7c:	e51b0010 	ldr	r0, [fp, #-16]
10016a80:	ebfffe42 	bl	10016390 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
10016a84:	e51b3010 	ldr	r3, [fp, #-16]
10016a88:	e2833048 	add	r3, r3, #72	; 0x48
10016a8c:	e1a00003 	mov	r0, r3
10016a90:	eb000280 	bl	10017498 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
10016a94:	e51b3010 	ldr	r3, [fp, #-16]
10016a98:	e3a02004 	mov	r2, #4
10016a9c:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* detach object */
    rt_object_detach((rt_object_t)thread);
10016aa0:	e51b0010 	ldr	r0, [fp, #-16]
10016aa4:	ebfffbf1 	bl	10015a70 <rt_object_detach>

    if (thread->cleanup != RT_NULL)
10016aa8:	e51b3010 	ldr	r3, [fp, #-16]
10016aac:	e5933070 	ldr	r3, [r3, #112]	; 0x70
10016ab0:	e3530000 	cmp	r3, #0
10016ab4:	0a000009 	beq	10016ae0 <rt_thread_detach+0x98>
    {
        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
10016ab8:	eb000adc 	bl	10019630 <rt_hw_interrupt_disable>
10016abc:	e50b0008 	str	r0, [fp, #-8]

        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
10016ac0:	e51b3010 	ldr	r3, [fp, #-16]
10016ac4:	e2833010 	add	r3, r3, #16
10016ac8:	e3020ac4 	movw	r0, #10948	; 0x2ac4
10016acc:	e3410004 	movt	r0, #4100	; 0x1004
10016ad0:	e1a01003 	mov	r1, r3
10016ad4:	ebfffea3 	bl	10016568 <rt_list_insert_after>

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
10016ad8:	e51b0008 	ldr	r0, [fp, #-8]
10016adc:	eb000ad7 	bl	10019640 <rt_hw_interrupt_enable>
    }

    return RT_EOK;
10016ae0:	e3a03000 	mov	r3, #0
}
10016ae4:	e1a00003 	mov	r0, r3
10016ae8:	e24bd004 	sub	sp, fp, #4
10016aec:	e8bd8800 	pop	{fp, pc}

10016af0 <rt_thread_create>:
                             void (*entry)(void *parameter),
                             void       *parameter,
                             rt_uint32_t stack_size,
                             rt_uint8_t  priority,
                             rt_uint32_t tick)
{
10016af0:	e92d4800 	push	{fp, lr}
10016af4:	e28db004 	add	fp, sp, #4
10016af8:	e24dd028 	sub	sp, sp, #40	; 0x28
10016afc:	e50b0010 	str	r0, [fp, #-16]
10016b00:	e50b1014 	str	r1, [fp, #-20]
10016b04:	e50b2018 	str	r2, [fp, #-24]
10016b08:	e50b301c 	str	r3, [fp, #-28]
    struct rt_thread *thread;
    void *stack_start;

    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
10016b0c:	e3a00000 	mov	r0, #0
10016b10:	e51b1010 	ldr	r1, [fp, #-16]
10016b14:	ebfffbf6 	bl	10015af4 <rt_object_allocate>
10016b18:	e50b0008 	str	r0, [fp, #-8]
                                                    name);
    if (thread == RT_NULL)
10016b1c:	e51b3008 	ldr	r3, [fp, #-8]
10016b20:	e3530000 	cmp	r3, #0
10016b24:	1a000001 	bne	10016b30 <rt_thread_create+0x40>
        return RT_NULL;
10016b28:	e3a03000 	mov	r3, #0
10016b2c:	ea000017 	b	10016b90 <rt_thread_create+0xa0>

    stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
10016b30:	e51b001c 	ldr	r0, [fp, #-28]
10016b34:	ebfff5d6 	bl	10014294 <rt_malloc>
10016b38:	e50b000c 	str	r0, [fp, #-12]
    if (stack_start == RT_NULL)
10016b3c:	e51b300c 	ldr	r3, [fp, #-12]
10016b40:	e3530000 	cmp	r3, #0
10016b44:	1a000003 	bne	10016b58 <rt_thread_create+0x68>
    {
        /* allocate stack failure */
        rt_object_delete((rt_object_t)thread);
10016b48:	e51b0008 	ldr	r0, [fp, #-8]
10016b4c:	ebfffc35 	bl	10015c28 <rt_object_delete>

        return RT_NULL;
10016b50:	e3a03000 	mov	r3, #0
10016b54:	ea00000d 	b	10016b90 <rt_thread_create+0xa0>
    }

    _rt_thread_init(thread,
10016b58:	e51b300c 	ldr	r3, [fp, #-12]
10016b5c:	e58d3000 	str	r3, [sp]
10016b60:	e51b301c 	ldr	r3, [fp, #-28]
10016b64:	e58d3004 	str	r3, [sp, #4]
10016b68:	e5db3004 	ldrb	r3, [fp, #4]
10016b6c:	e58d3008 	str	r3, [sp, #8]
10016b70:	e59b3008 	ldr	r3, [fp, #8]
10016b74:	e58d300c 	str	r3, [sp, #12]
10016b78:	e51b0008 	ldr	r0, [fp, #-8]
10016b7c:	e51b1010 	ldr	r1, [fp, #-16]
10016b80:	e51b2014 	ldr	r2, [fp, #-20]
10016b84:	e51b3018 	ldr	r3, [fp, #-24]
10016b88:	ebfffee3 	bl	1001671c <_rt_thread_init>
                    stack_start,
                    stack_size,
                    priority,
                    tick);

    return thread;
10016b8c:	e51b3008 	ldr	r3, [fp, #-8]
}
10016b90:	e1a00003 	mov	r0, r3
10016b94:	e24bd004 	sub	sp, fp, #4
10016b98:	e8bd8800 	pop	{fp, pc}

10016b9c <rt_thread_delete>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_delete(rt_thread_t thread)
{
10016b9c:	e92d4800 	push	{fp, lr}
10016ba0:	e28db004 	add	fp, sp, #4
10016ba4:	e24dd010 	sub	sp, sp, #16
10016ba8:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10016bac:	e51b3010 	ldr	r3, [fp, #-16]
10016bb0:	e3530000 	cmp	r3, #0
10016bb4:	1a000005 	bne	10016bd0 <rt_thread_delete+0x34>
10016bb8:	e3030e50 	movw	r0, #15952	; 0x3e50
10016bbc:	e3410003 	movt	r0, #4099	; 0x1003
10016bc0:	e3031f08 	movw	r1, #16136	; 0x3f08
10016bc4:	e3411003 	movt	r1, #4099	; 0x1003
10016bc8:	e3002159 	movw	r2, #345	; 0x159
10016bcc:	ebfff478 	bl	10013db4 <rt_assert_handler>

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
10016bd0:	e51b0010 	ldr	r0, [fp, #-16]
10016bd4:	ebfffded 	bl	10016390 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
10016bd8:	e51b3010 	ldr	r3, [fp, #-16]
10016bdc:	e2833048 	add	r3, r3, #72	; 0x48
10016be0:	e1a00003 	mov	r0, r3
10016be4:	eb00022b 	bl	10017498 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
10016be8:	e51b3010 	ldr	r3, [fp, #-16]
10016bec:	e3a02004 	mov	r2, #4
10016bf0:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* disable interrupt */
    lock = rt_hw_interrupt_disable();
10016bf4:	eb000a8d 	bl	10019630 <rt_hw_interrupt_disable>
10016bf8:	e50b0008 	str	r0, [fp, #-8]

    /* insert to defunct thread list */
    rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
10016bfc:	e51b3010 	ldr	r3, [fp, #-16]
10016c00:	e2833010 	add	r3, r3, #16
10016c04:	e3020ac4 	movw	r0, #10948	; 0x2ac4
10016c08:	e3410004 	movt	r0, #4100	; 0x1004
10016c0c:	e1a01003 	mov	r1, r3
10016c10:	ebfffe54 	bl	10016568 <rt_list_insert_after>

    /* enable interrupt */
    rt_hw_interrupt_enable(lock);
10016c14:	e51b0008 	ldr	r0, [fp, #-8]
10016c18:	eb000a88 	bl	10019640 <rt_hw_interrupt_enable>

    return RT_EOK;
10016c1c:	e3a03000 	mov	r3, #0
}
10016c20:	e1a00003 	mov	r0, r3
10016c24:	e24bd004 	sub	sp, fp, #4
10016c28:	e8bd8800 	pop	{fp, pc}

10016c2c <rt_thread_yield>:
 * is still in READY state.
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_yield(void)
{
10016c2c:	e92d4810 	push	{r4, fp, lr}
10016c30:	e28db008 	add	fp, sp, #8
10016c34:	e24dd00c 	sub	sp, sp, #12
    register rt_base_t level;
    struct rt_thread *thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10016c38:	eb000a7c 	bl	10019630 <rt_hw_interrupt_disable>
10016c3c:	e1a04000 	mov	r4, r0

    /* set to current thread */
    thread = rt_current_thread;
10016c40:	e3023abc 	movw	r3, #10940	; 0x2abc
10016c44:	e3413004 	movt	r3, #4100	; 0x1004
10016c48:	e5933000 	ldr	r3, [r3]
10016c4c:	e50b3010 	str	r3, [fp, #-16]

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
10016c50:	e51b3010 	ldr	r3, [fp, #-16]
10016c54:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10016c58:	e3530001 	cmp	r3, #1
10016c5c:	1a000019 	bne	10016cc8 <rt_thread_yield+0x9c>
        thread->tlist.next != thread->tlist.prev)
10016c60:	e51b3010 	ldr	r3, [fp, #-16]
10016c64:	e5932010 	ldr	r2, [r3, #16]
10016c68:	e51b3010 	ldr	r3, [fp, #-16]
10016c6c:	e5933014 	ldr	r3, [r3, #20]

    /* set to current thread */
    thread = rt_current_thread;

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
10016c70:	e1520003 	cmp	r2, r3
10016c74:	0a000013 	beq	10016cc8 <rt_thread_yield+0x9c>
        thread->tlist.next != thread->tlist.prev)
    {
        /* remove thread from thread list */
        rt_list_remove(&(thread->tlist));
10016c78:	e51b3010 	ldr	r3, [fp, #-16]
10016c7c:	e2833010 	add	r3, r3, #16
10016c80:	e1a00003 	mov	r0, r3
10016c84:	ebfffe63 	bl	10016618 <rt_list_remove>

        /* put thread to end of ready queue */
        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
10016c88:	e51b3010 	ldr	r3, [fp, #-16]
10016c8c:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10016c90:	e1a02183 	lsl	r2, r3, #3
10016c94:	e30239b8 	movw	r3, #10680	; 0x29b8
10016c98:	e3413004 	movt	r3, #4100	; 0x1004
10016c9c:	e0822003 	add	r2, r2, r3
10016ca0:	e51b3010 	ldr	r3, [fp, #-16]
10016ca4:	e2833010 	add	r3, r3, #16
10016ca8:	e1a00002 	mov	r0, r2
10016cac:	e1a01003 	mov	r1, r3
10016cb0:	ebfffe42 	bl	100165c0 <rt_list_insert_before>
                              &(thread->tlist));

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10016cb4:	e1a00004 	mov	r0, r4
10016cb8:	eb000a60 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
10016cbc:	ebfffd38 	bl	100161a4 <rt_schedule>

        return RT_EOK;
10016cc0:	e3a03000 	mov	r3, #0
10016cc4:	ea000002 	b	10016cd4 <rt_thread_yield+0xa8>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10016cc8:	e1a00004 	mov	r0, r4
10016ccc:	eb000a5b 	bl	10019640 <rt_hw_interrupt_enable>

    return RT_EOK;
10016cd0:	e3a03000 	mov	r3, #0
}
10016cd4:	e1a00003 	mov	r0, r3
10016cd8:	e24bd008 	sub	sp, fp, #8
10016cdc:	e8bd8810 	pop	{r4, fp, pc}

10016ce0 <rt_thread_sleep>:
 * @param tick the sleep ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_sleep(rt_tick_t tick)
{
10016ce0:	e92d4810 	push	{r4, fp, lr}
10016ce4:	e28db008 	add	fp, sp, #8
10016ce8:	e24dd014 	sub	sp, sp, #20
10016cec:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10016cf0:	eb000a4e 	bl	10019630 <rt_hw_interrupt_disable>
10016cf4:	e1a04000 	mov	r4, r0
    /* set to current thread */
    thread = rt_current_thread;
10016cf8:	e3023abc 	movw	r3, #10940	; 0x2abc
10016cfc:	e3413004 	movt	r3, #4100	; 0x1004
10016d00:	e5933000 	ldr	r3, [r3]
10016d04:	e50b3010 	str	r3, [fp, #-16]
    RT_ASSERT(thread != RT_NULL);
10016d08:	e51b3010 	ldr	r3, [fp, #-16]
10016d0c:	e3530000 	cmp	r3, #0
10016d10:	1a000005 	bne	10016d2c <rt_thread_sleep+0x4c>
10016d14:	e3030e50 	movw	r0, #15952	; 0x3e50
10016d18:	e3410003 	movt	r0, #4099	; 0x1003
10016d1c:	e3031f1c 	movw	r1, #16156	; 0x3f1c
10016d20:	e3411003 	movt	r1, #4099	; 0x1003
10016d24:	e30021ae 	movw	r2, #430	; 0x1ae
10016d28:	ebfff421 	bl	10013db4 <rt_assert_handler>

    /* suspend thread */
    rt_thread_suspend(thread);
10016d2c:	e51b0010 	ldr	r0, [fp, #-16]
10016d30:	eb00006c 	bl	10016ee8 <rt_thread_suspend>

    /* reset the timeout of thread timer and start it */
    rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
10016d34:	e51b3010 	ldr	r3, [fp, #-16]
10016d38:	e2832048 	add	r2, r3, #72	; 0x48
10016d3c:	e24b3018 	sub	r3, fp, #24
10016d40:	e1a00002 	mov	r0, r2
10016d44:	e3a01000 	mov	r1, #0
10016d48:	e1a02003 	mov	r2, r3
10016d4c:	eb000314 	bl	100179a4 <rt_timer_control>
    rt_timer_start(&(thread->thread_timer));
10016d50:	e51b3010 	ldr	r3, [fp, #-16]
10016d54:	e2833048 	add	r3, r3, #72	; 0x48
10016d58:	e1a00003 	mov	r0, r3
10016d5c:	eb00021a 	bl	100175cc <rt_timer_start>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10016d60:	e1a00004 	mov	r0, r4
10016d64:	eb000a35 	bl	10019640 <rt_hw_interrupt_enable>
	
    rt_schedule();
10016d68:	ebfffd0d 	bl	100161a4 <rt_schedule>

    /* clear error number of this thread to RT_EOK */
    if (thread->error == -RT_ETIMEOUT)
10016d6c:	e51b3010 	ldr	r3, [fp, #-16]
10016d70:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10016d74:	e3730002 	cmn	r3, #2
10016d78:	1a000002 	bne	10016d88 <rt_thread_sleep+0xa8>
        thread->error = RT_EOK;
10016d7c:	e51b3010 	ldr	r3, [fp, #-16]
10016d80:	e3a02000 	mov	r2, #0
10016d84:	e583202c 	str	r2, [r3, #44]	; 0x2c

    return RT_EOK;
10016d88:	e3a03000 	mov	r3, #0
}
10016d8c:	e1a00003 	mov	r0, r3
10016d90:	e24bd008 	sub	sp, fp, #8
10016d94:	e8bd8810 	pop	{r4, fp, pc}

10016d98 <rt_thread_delay>:
 * @param tick the delay ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_delay(rt_tick_t tick)
{
10016d98:	e92d4800 	push	{fp, lr}
10016d9c:	e28db004 	add	fp, sp, #4
10016da0:	e24dd008 	sub	sp, sp, #8
10016da4:	e50b0008 	str	r0, [fp, #-8]
    return rt_thread_sleep(tick);
10016da8:	e51b0008 	ldr	r0, [fp, #-8]
10016dac:	ebffffcb 	bl	10016ce0 <rt_thread_sleep>
10016db0:	e1a03000 	mov	r3, r0
}
10016db4:	e1a00003 	mov	r0, r3
10016db8:	e24bd004 	sub	sp, fp, #4
10016dbc:	e8bd8800 	pop	{fp, pc}

10016dc0 <rt_thread_control>:
 * @param arg the argument of control command
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
{
10016dc0:	e92d4810 	push	{r4, fp, lr}
10016dc4:	e28db008 	add	fp, sp, #8
10016dc8:	e24dd014 	sub	sp, sp, #20
10016dcc:	e50b0010 	str	r0, [fp, #-16]
10016dd0:	e1a03001 	mov	r3, r1
10016dd4:	e50b2018 	str	r2, [fp, #-24]
10016dd8:	e54b3011 	strb	r3, [fp, #-17]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10016ddc:	e51b3010 	ldr	r3, [fp, #-16]
10016de0:	e3530000 	cmp	r3, #0
10016de4:	1a000005 	bne	10016e00 <rt_thread_control+0x40>
10016de8:	e3030e50 	movw	r0, #15952	; 0x3e50
10016dec:	e3410003 	movt	r0, #4099	; 0x1003
10016df0:	e3031f2c 	movw	r1, #16172	; 0x3f2c
10016df4:	e3411003 	movt	r1, #4099	; 0x1003
10016df8:	e30021e1 	movw	r2, #481	; 0x1e1
10016dfc:	ebfff3ec 	bl	10013db4 <rt_assert_handler>

    switch (cmd)
10016e00:	e55b3011 	ldrb	r3, [fp, #-17]
10016e04:	e3530001 	cmp	r3, #1
10016e08:	0a00002e 	beq	10016ec8 <rt_thread_control+0x108>
10016e0c:	e3530002 	cmp	r3, #2
10016e10:	0a000002 	beq	10016e20 <rt_thread_control+0x60>
10016e14:	e3530000 	cmp	r3, #0
10016e18:	0a000026 	beq	10016eb8 <rt_thread_control+0xf8>
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
#endif

    default:
        break;
10016e1c:	ea00002d 	b	10016ed8 <rt_thread_control+0x118>

    switch (cmd)
    {
    case RT_THREAD_CTRL_CHANGE_PRIORITY:
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
10016e20:	eb000a02 	bl	10019630 <rt_hw_interrupt_disable>
10016e24:	e1a04000 	mov	r4, r0

        /* for ready thread, change queue */
        if (thread->stat == RT_THREAD_READY)
10016e28:	e51b3010 	ldr	r3, [fp, #-16]
10016e2c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10016e30:	e3530001 	cmp	r3, #1
10016e34:	1a000010 	bne	10016e7c <rt_thread_control+0xbc>
        {
            /* remove thread from schedule queue first */
            rt_schedule_remove_thread(thread);
10016e38:	e51b0010 	ldr	r0, [fp, #-16]
10016e3c:	ebfffd53 	bl	10016390 <rt_schedule_remove_thread>

            /* change thread priority */
            thread->current_priority = *(rt_uint8_t *)arg;
10016e40:	e51b3018 	ldr	r3, [fp, #-24]
10016e44:	e5d32000 	ldrb	r2, [r3]
10016e48:	e51b3010 	ldr	r3, [fp, #-16]
10016e4c:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
10016e50:	e51b3010 	ldr	r3, [fp, #-16]
10016e54:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10016e58:	e1a02003 	mov	r2, r3
10016e5c:	e3a03001 	mov	r3, #1
10016e60:	e1a03213 	lsl	r3, r3, r2
10016e64:	e1a02003 	mov	r2, r3
10016e68:	e51b3010 	ldr	r3, [fp, #-16]
10016e6c:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif

            /* insert thread to schedule queue again */
            rt_schedule_insert_thread(thread);
10016e70:	e51b0010 	ldr	r0, [fp, #-16]
10016e74:	ebfffd1b 	bl	100162e8 <rt_schedule_insert_thread>
10016e78:	ea00000b 	b	10016eac <rt_thread_control+0xec>
        }
        else
        {
            thread->current_priority = *(rt_uint8_t *)arg;
10016e7c:	e51b3018 	ldr	r3, [fp, #-24]
10016e80:	e5d32000 	ldrb	r2, [r3]
10016e84:	e51b3010 	ldr	r3, [fp, #-16]
10016e88:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
10016e8c:	e51b3010 	ldr	r3, [fp, #-16]
10016e90:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10016e94:	e1a02003 	mov	r2, r3
10016e98:	e3a03001 	mov	r3, #1
10016e9c:	e1a03213 	lsl	r3, r3, r2
10016ea0:	e1a02003 	mov	r2, r3
10016ea4:	e51b3010 	ldr	r3, [fp, #-16]
10016ea8:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10016eac:	e1a00004 	mov	r0, r4
10016eb0:	eb0009e2 	bl	10019640 <rt_hw_interrupt_enable>
        break;
10016eb4:	ea000007 	b	10016ed8 <rt_thread_control+0x118>

    case RT_THREAD_CTRL_STARTUP:
        return rt_thread_startup(thread);
10016eb8:	e51b0010 	ldr	r0, [fp, #-16]
10016ebc:	ebfffeb0 	bl	10016984 <rt_thread_startup>
10016ec0:	e1a03000 	mov	r3, r0
10016ec4:	ea000004 	b	10016edc <rt_thread_control+0x11c>

#ifdef RT_USING_HEAP
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
10016ec8:	e51b0010 	ldr	r0, [fp, #-16]
10016ecc:	ebffff32 	bl	10016b9c <rt_thread_delete>
10016ed0:	e1a03000 	mov	r3, r0
10016ed4:	ea000000 	b	10016edc <rt_thread_control+0x11c>

    default:
        break;
    }

    return RT_EOK;
10016ed8:	e3a03000 	mov	r3, #0
}
10016edc:	e1a00003 	mov	r0, r3
10016ee0:	e24bd008 	sub	sp, fp, #8
10016ee4:	e8bd8810 	pop	{r4, fp, pc}

10016ee8 <rt_thread_suspend>:
 *
 * @note if suspend self thread, after this function call, the
 * rt_schedule() must be invoked.
 */
rt_err_t rt_thread_suspend(rt_thread_t thread)
{
10016ee8:	e92d4810 	push	{r4, fp, lr}
10016eec:	e28db008 	add	fp, sp, #8
10016ef0:	e24dd00c 	sub	sp, sp, #12
10016ef4:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10016ef8:	e51b3010 	ldr	r3, [fp, #-16]
10016efc:	e3530000 	cmp	r3, #0
10016f00:	1a000005 	bne	10016f1c <rt_thread_suspend+0x34>
10016f04:	e3030e50 	movw	r0, #15952	; 0x3e50
10016f08:	e3410003 	movt	r0, #4099	; 0x1003
10016f0c:	e3031f40 	movw	r1, #16192	; 0x3f40
10016f10:	e3411003 	movt	r1, #4099	; 0x1003
10016f14:	e300222f 	movw	r2, #559	; 0x22f
10016f18:	ebfff3a5 	bl	10013db4 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_READY)
10016f1c:	e51b3010 	ldr	r3, [fp, #-16]
10016f20:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10016f24:	e3530001 	cmp	r3, #1
10016f28:	0a000001 	beq	10016f34 <rt_thread_suspend+0x4c>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
10016f2c:	e3e03000 	mvn	r3, #0
10016f30:	ea00000d 	b	10016f6c <rt_thread_suspend+0x84>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10016f34:	eb0009bd 	bl	10019630 <rt_hw_interrupt_disable>
10016f38:	e1a04000 	mov	r4, r0

    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
10016f3c:	e51b3010 	ldr	r3, [fp, #-16]
10016f40:	e3a02002 	mov	r2, #2
10016f44:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    rt_schedule_remove_thread(thread);
10016f48:	e51b0010 	ldr	r0, [fp, #-16]
10016f4c:	ebfffd0f 	bl	10016390 <rt_schedule_remove_thread>

    /* stop thread timer anyway */
    rt_timer_stop(&(thread->thread_timer));
10016f50:	e51b3010 	ldr	r3, [fp, #-16]
10016f54:	e2833048 	add	r3, r3, #72	; 0x48
10016f58:	e1a00003 	mov	r0, r3
10016f5c:	eb000261 	bl	100178e8 <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10016f60:	e1a00004 	mov	r0, r4
10016f64:	eb0009b5 	bl	10019640 <rt_hw_interrupt_enable>

    return RT_EOK;
10016f68:	e3a03000 	mov	r3, #0
}
10016f6c:	e1a00003 	mov	r0, r3
10016f70:	e24bd008 	sub	sp, fp, #8
10016f74:	e8bd8810 	pop	{r4, fp, pc}

10016f78 <rt_thread_resume>:
 * @param thread the thread to be resumed
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_resume(rt_thread_t thread)
{
10016f78:	e92d4810 	push	{r4, fp, lr}
10016f7c:	e28db008 	add	fp, sp, #8
10016f80:	e24dd00c 	sub	sp, sp, #12
10016f84:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10016f88:	e51b3010 	ldr	r3, [fp, #-16]
10016f8c:	e3530000 	cmp	r3, #0
10016f90:	1a000005 	bne	10016fac <rt_thread_resume+0x34>
10016f94:	e3030e50 	movw	r0, #15952	; 0x3e50
10016f98:	e3410003 	movt	r0, #4099	; 0x1003
10016f9c:	e3031f54 	movw	r1, #16212	; 0x3f54
10016fa0:	e3411003 	movt	r1, #4099	; 0x1003
10016fa4:	e3a02f96 	mov	r2, #600	; 0x258
10016fa8:	ebfff381 	bl	10013db4 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_SUSPEND)
10016fac:	e51b3010 	ldr	r3, [fp, #-16]
10016fb0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10016fb4:	e3530002 	cmp	r3, #2
10016fb8:	0a000001 	beq	10016fc4 <rt_thread_resume+0x4c>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
10016fbc:	e3e03000 	mvn	r3, #0
10016fc0:	ea00000e 	b	10017000 <rt_thread_resume+0x88>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10016fc4:	eb000999 	bl	10019630 <rt_hw_interrupt_disable>
10016fc8:	e1a04000 	mov	r4, r0

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
10016fcc:	e51b3010 	ldr	r3, [fp, #-16]
10016fd0:	e2833010 	add	r3, r3, #16
10016fd4:	e1a00003 	mov	r0, r3
10016fd8:	ebfffd8e 	bl	10016618 <rt_list_remove>

    rt_timer_stop(&thread->thread_timer);
10016fdc:	e51b3010 	ldr	r3, [fp, #-16]
10016fe0:	e2833048 	add	r3, r3, #72	; 0x48
10016fe4:	e1a00003 	mov	r0, r3
10016fe8:	eb00023e 	bl	100178e8 <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10016fec:	e1a00004 	mov	r0, r4
10016ff0:	eb000992 	bl	10019640 <rt_hw_interrupt_enable>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
10016ff4:	e51b0010 	ldr	r0, [fp, #-16]
10016ff8:	ebfffcba 	bl	100162e8 <rt_schedule_insert_thread>

    return RT_EOK;
10016ffc:	e3a03000 	mov	r3, #0
}
10017000:	e1a00003 	mov	r0, r3
10017004:	e24bd008 	sub	sp, fp, #8
10017008:	e8bd8810 	pop	{r4, fp, pc}

1001700c <rt_thread_timeout>:
 * when thread is timeout to wait some resource.
 *
 * @param parameter the parameter of thread timeout function
 */
void rt_thread_timeout(void *parameter)
{
1001700c:	e92d4800 	push	{fp, lr}
10017010:	e28db004 	add	fp, sp, #4
10017014:	e24dd010 	sub	sp, sp, #16
10017018:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;

    thread = (struct rt_thread *)parameter;
1001701c:	e51b3010 	ldr	r3, [fp, #-16]
10017020:	e50b3008 	str	r3, [fp, #-8]

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10017024:	e51b3008 	ldr	r3, [fp, #-8]
10017028:	e3530000 	cmp	r3, #0
1001702c:	1a000005 	bne	10017048 <rt_thread_timeout+0x3c>
10017030:	e3030e50 	movw	r0, #15952	; 0x3e50
10017034:	e3410003 	movt	r0, #4099	; 0x1003
10017038:	e3031f68 	movw	r1, #16232	; 0x3f68
1001703c:	e3411003 	movt	r1, #4099	; 0x1003
10017040:	e3002283 	movw	r2, #643	; 0x283
10017044:	ebfff35a 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
10017048:	e51b3008 	ldr	r3, [fp, #-8]
1001704c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10017050:	e3530002 	cmp	r3, #2
10017054:	0a000005 	beq	10017070 <rt_thread_timeout+0x64>
10017058:	e3030e9c 	movw	r0, #16028	; 0x3e9c
1001705c:	e3410003 	movt	r0, #4099	; 0x1003
10017060:	e3031f68 	movw	r1, #16232	; 0x3f68
10017064:	e3411003 	movt	r1, #4099	; 0x1003
10017068:	e3a02fa1 	mov	r2, #644	; 0x284
1001706c:	ebfff350 	bl	10013db4 <rt_assert_handler>

    /* set error number */
    thread->error = -RT_ETIMEOUT;
10017070:	e51b3008 	ldr	r3, [fp, #-8]
10017074:	e3e02001 	mvn	r2, #1
10017078:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
1001707c:	e51b3008 	ldr	r3, [fp, #-8]
10017080:	e2833010 	add	r3, r3, #16
10017084:	e1a00003 	mov	r0, r3
10017088:	ebfffd62 	bl	10016618 <rt_list_remove>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
1001708c:	e51b0008 	ldr	r0, [fp, #-8]
10017090:	ebfffc94 	bl	100162e8 <rt_schedule_insert_thread>

    /* do schedule */
    rt_schedule();
10017094:	ebfffc42 	bl	100161a4 <rt_schedule>
}
10017098:	e24bd004 	sub	sp, fp, #4
1001709c:	e8bd8800 	pop	{fp, pc}

100170a0 <rt_thread_find>:
 * @return the found thread
 *
 * @note please don't invoke this function in interrupt status.
 */
rt_thread_t rt_thread_find(char *name)
{
100170a0:	e92d4800 	push	{fp, lr}
100170a4:	e28db004 	add	fp, sp, #4
100170a8:	e24dd018 	sub	sp, sp, #24
100170ac:	e50b0018 	str	r0, [fp, #-24]
    struct rt_list_node *node;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
100170b0:	ebfffe2a 	bl	10016960 <rt_thread_self>
100170b4:	e1a03000 	mov	r3, r0
100170b8:	e3530000 	cmp	r3, #0
100170bc:	0a000000 	beq	100170c4 <rt_thread_find+0x24>
        rt_enter_critical();
100170c0:	ebfffcde 	bl	10016440 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
100170c4:	e3063878 	movw	r3, #26744	; 0x6878
100170c8:	e3413003 	movt	r3, #4099	; 0x1003
100170cc:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
100170d0:	e51b300c 	ldr	r3, [fp, #-12]
100170d4:	e5933004 	ldr	r3, [r3, #4]
100170d8:	e50b3008 	str	r3, [fp, #-8]
100170dc:	ea000014 	b	10017134 <rt_thread_find+0x94>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
100170e0:	e51b3008 	ldr	r3, [fp, #-8]
100170e4:	e2433008 	sub	r3, r3, #8
100170e8:	e50b3010 	str	r3, [fp, #-16]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
100170ec:	e51b3010 	ldr	r3, [fp, #-16]
100170f0:	e1a00003 	mov	r0, r3
100170f4:	e51b1018 	ldr	r1, [fp, #-24]
100170f8:	e3a02006 	mov	r2, #6
100170fc:	ebffee06 	bl	1001291c <rt_strncmp>
10017100:	e1a03000 	mov	r3, r0
10017104:	e3530000 	cmp	r3, #0
10017108:	1a000006 	bne	10017128 <rt_thread_find+0x88>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
1001710c:	ebfffe13 	bl	10016960 <rt_thread_self>
10017110:	e1a03000 	mov	r3, r0
10017114:	e3530000 	cmp	r3, #0
10017118:	0a000000 	beq	10017120 <rt_thread_find+0x80>
                rt_exit_critical();
1001711c:	ebfffcd9 	bl	10016488 <rt_exit_critical>

            return (rt_thread_t)object;
10017120:	e51b3010 	ldr	r3, [fp, #-16]
10017124:	ea00000d 	b	10017160 <rt_thread_find+0xc0>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
10017128:	e51b3008 	ldr	r3, [fp, #-8]
1001712c:	e5933000 	ldr	r3, [r3]
10017130:	e50b3008 	str	r3, [fp, #-8]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
         node != &(information->object_list);
10017134:	e51b300c 	ldr	r3, [fp, #-12]
10017138:	e2832004 	add	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
1001713c:	e51b3008 	ldr	r3, [fp, #-8]
10017140:	e1520003 	cmp	r2, r3
10017144:	1affffe5 	bne	100170e0 <rt_thread_find+0x40>
            return (rt_thread_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
10017148:	ebfffe04 	bl	10016960 <rt_thread_self>
1001714c:	e1a03000 	mov	r3, r0
10017150:	e3530000 	cmp	r3, #0
10017154:	0a000000 	beq	1001715c <rt_thread_find+0xbc>
        rt_exit_critical();
10017158:	ebfffcca 	bl	10016488 <rt_exit_critical>

    /* not found */
    return RT_NULL;
1001715c:	e3a03000 	mov	r3, #0
}
10017160:	e1a00003 	mov	r0, r3
10017164:	e24bd004 	sub	sp, fp, #4
10017168:	e8bd8800 	pop	{fp, pc}

1001716c <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
1001716c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017170:	e28db000 	add	fp, sp, #0
10017174:	e24dd00c 	sub	sp, sp, #12
10017178:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
1001717c:	e51b3008 	ldr	r3, [fp, #-8]
10017180:	e51b2008 	ldr	r2, [fp, #-8]
10017184:	e5832004 	str	r2, [r3, #4]
10017188:	e51b3008 	ldr	r3, [fp, #-8]
1001718c:	e5932004 	ldr	r2, [r3, #4]
10017190:	e51b3008 	ldr	r3, [fp, #-8]
10017194:	e5832000 	str	r2, [r3]
}
10017198:	e24bd000 	sub	sp, fp, #0
1001719c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100171a0:	e12fff1e 	bx	lr

100171a4 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
100171a4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100171a8:	e28db000 	add	fp, sp, #0
100171ac:	e24dd00c 	sub	sp, sp, #12
100171b0:	e50b0008 	str	r0, [fp, #-8]
100171b4:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
100171b8:	e51b3008 	ldr	r3, [fp, #-8]
100171bc:	e5933000 	ldr	r3, [r3]
100171c0:	e51b200c 	ldr	r2, [fp, #-12]
100171c4:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
100171c8:	e51b3008 	ldr	r3, [fp, #-8]
100171cc:	e5932000 	ldr	r2, [r3]
100171d0:	e51b300c 	ldr	r3, [fp, #-12]
100171d4:	e5832000 	str	r2, [r3]

    l->next = n;
100171d8:	e51b3008 	ldr	r3, [fp, #-8]
100171dc:	e51b200c 	ldr	r2, [fp, #-12]
100171e0:	e5832000 	str	r2, [r3]
    n->prev = l;
100171e4:	e51b300c 	ldr	r3, [fp, #-12]
100171e8:	e51b2008 	ldr	r2, [fp, #-8]
100171ec:	e5832004 	str	r2, [r3, #4]
}
100171f0:	e24bd000 	sub	sp, fp, #0
100171f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100171f8:	e12fff1e 	bx	lr

100171fc <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
100171fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017200:	e28db000 	add	fp, sp, #0
10017204:	e24dd00c 	sub	sp, sp, #12
10017208:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
1001720c:	e51b3008 	ldr	r3, [fp, #-8]
10017210:	e5933000 	ldr	r3, [r3]
10017214:	e51b2008 	ldr	r2, [fp, #-8]
10017218:	e5922004 	ldr	r2, [r2, #4]
1001721c:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
10017220:	e51b3008 	ldr	r3, [fp, #-8]
10017224:	e5933004 	ldr	r3, [r3, #4]
10017228:	e51b2008 	ldr	r2, [fp, #-8]
1001722c:	e5922000 	ldr	r2, [r2]
10017230:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
10017234:	e51b3008 	ldr	r3, [fp, #-8]
10017238:	e51b2008 	ldr	r2, [fp, #-8]
1001723c:	e5832004 	str	r2, [r3, #4]
10017240:	e51b3008 	ldr	r3, [fp, #-8]
10017244:	e5932004 	ldr	r2, [r3, #4]
10017248:	e51b3008 	ldr	r3, [fp, #-8]
1001724c:	e5832000 	str	r2, [r3]
}
10017250:	e24bd000 	sub	sp, fp, #0
10017254:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10017258:	e12fff1e 	bx	lr

1001725c <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
1001725c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017260:	e28db000 	add	fp, sp, #0
10017264:	e24dd00c 	sub	sp, sp, #12
10017268:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
1001726c:	e51b3008 	ldr	r3, [fp, #-8]
10017270:	e5932000 	ldr	r2, [r3]
10017274:	e51b3008 	ldr	r3, [fp, #-8]
10017278:	e1520003 	cmp	r2, r3
1001727c:	03a03001 	moveq	r3, #1
10017280:	13a03000 	movne	r3, #0
10017284:	e6ef3073 	uxtb	r3, r3
}
10017288:	e1a00003 	mov	r0, r3
1001728c:	e24bd000 	sub	sp, fp, #0
10017290:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10017294:	e12fff1e 	bx	lr

10017298 <rt_timer_timeout_sethook>:
 * is timeout.
 *
 * @param hook the hook function
 */
void rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer))
{
10017298:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001729c:	e28db000 	add	fp, sp, #0
100172a0:	e24dd00c 	sub	sp, sp, #12
100172a4:	e50b0008 	str	r0, [fp, #-8]
    rt_timer_timeout_hook = hook;
100172a8:	e30c3450 	movw	r3, #50256	; 0xc450
100172ac:	e3413003 	movt	r3, #4099	; 0x1003
100172b0:	e51b2008 	ldr	r2, [fp, #-8]
100172b4:	e5832000 	str	r2, [r3]
}
100172b8:	e24bd000 	sub	sp, fp, #0
100172bc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100172c0:	e12fff1e 	bx	lr

100172c4 <_rt_timer_init>:
static void _rt_timer_init(rt_timer_t timer,
                           void (*timeout)(void *parameter),
                           void      *parameter,
                           rt_tick_t  time,
                           rt_uint8_t flag)
{
100172c4:	e92d4800 	push	{fp, lr}
100172c8:	e28db004 	add	fp, sp, #4
100172cc:	e24dd018 	sub	sp, sp, #24
100172d0:	e50b0010 	str	r0, [fp, #-16]
100172d4:	e50b1014 	str	r1, [fp, #-20]
100172d8:	e50b2018 	str	r2, [fp, #-24]
100172dc:	e50b301c 	str	r3, [fp, #-28]
    int i;

    /* set flag */
    timer->parent.flag  = flag;
100172e0:	e51b3010 	ldr	r3, [fp, #-16]
100172e4:	e5db2004 	ldrb	r2, [fp, #4]
100172e8:	e5c32007 	strb	r2, [r3, #7]

    /* set deactivated */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
100172ec:	e51b3010 	ldr	r3, [fp, #-16]
100172f0:	e5d33007 	ldrb	r3, [r3, #7]
100172f4:	e3c33001 	bic	r3, r3, #1
100172f8:	e6ef2073 	uxtb	r2, r3
100172fc:	e51b3010 	ldr	r3, [fp, #-16]
10017300:	e5c32007 	strb	r2, [r3, #7]

    timer->timeout_func = timeout;
10017304:	e51b3010 	ldr	r3, [fp, #-16]
10017308:	e51b2014 	ldr	r2, [fp, #-20]
1001730c:	e5832018 	str	r2, [r3, #24]
    timer->parameter    = parameter;
10017310:	e51b3010 	ldr	r3, [fp, #-16]
10017314:	e51b2018 	ldr	r2, [fp, #-24]
10017318:	e583201c 	str	r2, [r3, #28]

    timer->timeout_tick = 0;
1001731c:	e51b3010 	ldr	r3, [fp, #-16]
10017320:	e3a02000 	mov	r2, #0
10017324:	e5832024 	str	r2, [r3, #36]	; 0x24
    timer->init_tick    = time;
10017328:	e51b3010 	ldr	r3, [fp, #-16]
1001732c:	e51b201c 	ldr	r2, [fp, #-28]
10017330:	e5832020 	str	r2, [r3, #32]

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
10017334:	e3a03000 	mov	r3, #0
10017338:	e50b3008 	str	r3, [fp, #-8]
1001733c:	ea000009 	b	10017368 <_rt_timer_init+0xa4>
    {
        rt_list_init(&(timer->row[i]));
10017340:	e51b3008 	ldr	r3, [fp, #-8]
10017344:	e2833002 	add	r3, r3, #2
10017348:	e1a03183 	lsl	r3, r3, #3
1001734c:	e51b2010 	ldr	r2, [fp, #-16]
10017350:	e0823003 	add	r3, r2, r3
10017354:	e1a00003 	mov	r0, r3
10017358:	ebffff83 	bl	1001716c <rt_list_init>

    timer->timeout_tick = 0;
    timer->init_tick    = time;

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
1001735c:	e51b3008 	ldr	r3, [fp, #-8]
10017360:	e2833001 	add	r3, r3, #1
10017364:	e50b3008 	str	r3, [fp, #-8]
10017368:	e51b3008 	ldr	r3, [fp, #-8]
1001736c:	e3530000 	cmp	r3, #0
10017370:	dafffff2 	ble	10017340 <_rt_timer_init+0x7c>
    {
        rt_list_init(&(timer->row[i]));
    }
}
10017374:	e24bd004 	sub	sp, fp, #4
10017378:	e8bd8800 	pop	{fp, pc}

1001737c <rt_timer_list_next_timeout>:

/* the fist timer always in the last row */
static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
{
1001737c:	e92d4800 	push	{fp, lr}
10017380:	e28db004 	add	fp, sp, #4
10017384:	e24dd010 	sub	sp, sp, #16
10017388:	e50b0010 	str	r0, [fp, #-16]
    struct rt_timer *timer;

    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
1001738c:	e51b0010 	ldr	r0, [fp, #-16]
10017390:	ebffffb1 	bl	1001725c <rt_list_isempty>
10017394:	e1a03000 	mov	r3, r0
10017398:	e3530000 	cmp	r3, #0
1001739c:	0a000001 	beq	100173a8 <rt_timer_list_next_timeout+0x2c>
        return RT_TICK_MAX;
100173a0:	e3e03000 	mvn	r3, #0
100173a4:	ea000005 	b	100173c0 <rt_timer_list_next_timeout+0x44>

    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
100173a8:	e51b3010 	ldr	r3, [fp, #-16]
100173ac:	e5933000 	ldr	r3, [r3]
100173b0:	e2433010 	sub	r3, r3, #16
100173b4:	e50b3008 	str	r3, [fp, #-8]
                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);

    return timer->timeout_tick;
100173b8:	e51b3008 	ldr	r3, [fp, #-8]
100173bc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
}
100173c0:	e1a00003 	mov	r0, r3
100173c4:	e24bd004 	sub	sp, fp, #4
100173c8:	e8bd8800 	pop	{fp, pc}

100173cc <_rt_timer_remove>:

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
100173cc:	e92d4800 	push	{fp, lr}
100173d0:	e28db004 	add	fp, sp, #4
100173d4:	e24dd010 	sub	sp, sp, #16
100173d8:	e50b0010 	str	r0, [fp, #-16]
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
100173dc:	e3a03000 	mov	r3, #0
100173e0:	e50b3008 	str	r3, [fp, #-8]
100173e4:	ea000009 	b	10017410 <_rt_timer_remove+0x44>
    {
        rt_list_remove(&timer->row[i]);
100173e8:	e51b3008 	ldr	r3, [fp, #-8]
100173ec:	e2833002 	add	r3, r3, #2
100173f0:	e1a03183 	lsl	r3, r3, #3
100173f4:	e51b2010 	ldr	r2, [fp, #-16]
100173f8:	e0823003 	add	r3, r2, r3
100173fc:	e1a00003 	mov	r0, r3
10017400:	ebffff7d 	bl	100171fc <rt_list_remove>

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
10017404:	e51b3008 	ldr	r3, [fp, #-8]
10017408:	e2833001 	add	r3, r3, #1
1001740c:	e50b3008 	str	r3, [fp, #-8]
10017410:	e51b3008 	ldr	r3, [fp, #-8]
10017414:	e3530000 	cmp	r3, #0
10017418:	dafffff2 	ble	100173e8 <_rt_timer_remove+0x1c>
    {
        rt_list_remove(&timer->row[i]);
    }
}
1001741c:	e24bd004 	sub	sp, fp, #4
10017420:	e8bd8800 	pop	{fp, pc}

10017424 <rt_timer_init>:
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
10017424:	e92d4800 	push	{fp, lr}
10017428:	e28db004 	add	fp, sp, #4
1001742c:	e24dd018 	sub	sp, sp, #24
10017430:	e50b0008 	str	r0, [fp, #-8]
10017434:	e50b100c 	str	r1, [fp, #-12]
10017438:	e50b2010 	str	r2, [fp, #-16]
1001743c:	e50b3014 	str	r3, [fp, #-20]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
10017440:	e51b3008 	ldr	r3, [fp, #-8]
10017444:	e3530000 	cmp	r3, #0
10017448:	1a000005 	bne	10017464 <rt_timer_init+0x40>
1001744c:	e3030f7c 	movw	r0, #16252	; 0x3f7c
10017450:	e3410003 	movt	r0, #4099	; 0x1003
10017454:	e3031fb4 	movw	r1, #16308	; 0x3fb4
10017458:	e3411003 	movt	r1, #4099	; 0x1003
1001745c:	e3a020bc 	mov	r2, #188	; 0xbc
10017460:	ebfff253 	bl	10013db4 <rt_assert_handler>

    /* timer object initialization */
    rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
10017464:	e51b0008 	ldr	r0, [fp, #-8]
10017468:	e3a01008 	mov	r1, #8
1001746c:	e51b200c 	ldr	r2, [fp, #-12]
10017470:	ebfff94f 	bl	100159b4 <rt_object_init>

    _rt_timer_init(timer, timeout, parameter, time, flag);
10017474:	e5db3008 	ldrb	r3, [fp, #8]
10017478:	e58d3000 	str	r3, [sp]
1001747c:	e51b0008 	ldr	r0, [fp, #-8]
10017480:	e51b1010 	ldr	r1, [fp, #-16]
10017484:	e51b2014 	ldr	r2, [fp, #-20]
10017488:	e59b3004 	ldr	r3, [fp, #4]
1001748c:	ebffff8c 	bl	100172c4 <_rt_timer_init>
}
10017490:	e24bd004 	sub	sp, fp, #4
10017494:	e8bd8800 	pop	{fp, pc}

10017498 <rt_timer_detach>:
 * @param timer the static timer object
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
{
10017498:	e92d4810 	push	{r4, fp, lr}
1001749c:	e28db008 	add	fp, sp, #8
100174a0:	e24dd00c 	sub	sp, sp, #12
100174a4:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
100174a8:	e51b3010 	ldr	r3, [fp, #-16]
100174ac:	e3530000 	cmp	r3, #0
100174b0:	1a000005 	bne	100174cc <rt_timer_detach+0x34>
100174b4:	e3030f7c 	movw	r0, #16252	; 0x3f7c
100174b8:	e3410003 	movt	r0, #4099	; 0x1003
100174bc:	e3031fc4 	movw	r1, #16324	; 0x3fc4
100174c0:	e3411003 	movt	r1, #4099	; 0x1003
100174c4:	e3a020d1 	mov	r2, #209	; 0xd1
100174c8:	ebfff239 	bl	10013db4 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100174cc:	eb000857 	bl	10019630 <rt_hw_interrupt_disable>
100174d0:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
100174d4:	e51b0010 	ldr	r0, [fp, #-16]
100174d8:	ebffffbb 	bl	100173cc <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
100174dc:	e1a00004 	mov	r0, r4
100174e0:	eb000856 	bl	10019640 <rt_hw_interrupt_enable>

    rt_object_detach((rt_object_t)timer);
100174e4:	e51b0010 	ldr	r0, [fp, #-16]
100174e8:	ebfff960 	bl	10015a70 <rt_object_detach>

    return -RT_EOK;
100174ec:	e3a03000 	mov	r3, #0
}
100174f0:	e1a00003 	mov	r0, r3
100174f4:	e24bd008 	sub	sp, fp, #8
100174f8:	e8bd8810 	pop	{r4, fp, pc}

100174fc <rt_timer_create>:
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
{
100174fc:	e92d4800 	push	{fp, lr}
10017500:	e28db004 	add	fp, sp, #4
10017504:	e24dd020 	sub	sp, sp, #32
10017508:	e50b0010 	str	r0, [fp, #-16]
1001750c:	e50b1014 	str	r1, [fp, #-20]
10017510:	e50b2018 	str	r2, [fp, #-24]
10017514:	e50b301c 	str	r3, [fp, #-28]
    struct rt_timer *timer;

    /* allocate a object */
    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
10017518:	e3a00008 	mov	r0, #8
1001751c:	e51b1010 	ldr	r1, [fp, #-16]
10017520:	ebfff973 	bl	10015af4 <rt_object_allocate>
10017524:	e50b0008 	str	r0, [fp, #-8]
    if (timer == RT_NULL)
10017528:	e51b3008 	ldr	r3, [fp, #-8]
1001752c:	e3530000 	cmp	r3, #0
10017530:	1a000001 	bne	1001753c <rt_timer_create+0x40>
    {
        return RT_NULL;
10017534:	e3a03000 	mov	r3, #0
10017538:	ea000007 	b	1001755c <rt_timer_create+0x60>
    }

    _rt_timer_init(timer, timeout, parameter, time, flag);
1001753c:	e5db3004 	ldrb	r3, [fp, #4]
10017540:	e58d3000 	str	r3, [sp]
10017544:	e51b0008 	ldr	r0, [fp, #-8]
10017548:	e51b1014 	ldr	r1, [fp, #-20]
1001754c:	e51b2018 	ldr	r2, [fp, #-24]
10017550:	e51b301c 	ldr	r3, [fp, #-28]
10017554:	ebffff5a 	bl	100172c4 <_rt_timer_init>

    return timer;
10017558:	e51b3008 	ldr	r3, [fp, #-8]
}
1001755c:	e1a00003 	mov	r0, r3
10017560:	e24bd004 	sub	sp, fp, #4
10017564:	e8bd8800 	pop	{fp, pc}

10017568 <rt_timer_delete>:
 * @param timer the timer to be deleted
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_delete(rt_timer_t timer)
{
10017568:	e92d4810 	push	{r4, fp, lr}
1001756c:	e28db008 	add	fp, sp, #8
10017570:	e24dd00c 	sub	sp, sp, #12
10017574:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
10017578:	e51b3010 	ldr	r3, [fp, #-16]
1001757c:	e3530000 	cmp	r3, #0
10017580:	1a000005 	bne	1001759c <rt_timer_delete+0x34>
10017584:	e3030f7c 	movw	r0, #16252	; 0x3f7c
10017588:	e3410003 	movt	r0, #4099	; 0x1003
1001758c:	e3031fd4 	movw	r1, #16340	; 0x3fd4
10017590:	e3411003 	movt	r1, #4099	; 0x1003
10017594:	e300210e 	movw	r2, #270	; 0x10e
10017598:	ebfff205 	bl	10013db4 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
1001759c:	eb000823 	bl	10019630 <rt_hw_interrupt_disable>
100175a0:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
100175a4:	e51b0010 	ldr	r0, [fp, #-16]
100175a8:	ebffff87 	bl	100173cc <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
100175ac:	e1a00004 	mov	r0, r4
100175b0:	eb000822 	bl	10019640 <rt_hw_interrupt_enable>

    rt_object_delete((rt_object_t)timer);
100175b4:	e51b0010 	ldr	r0, [fp, #-16]
100175b8:	ebfff99a 	bl	10015c28 <rt_object_delete>

    return -RT_EOK;
100175bc:	e3a03000 	mov	r3, #0
}
100175c0:	e1a00003 	mov	r0, r3
100175c4:	e24bd008 	sub	sp, fp, #8
100175c8:	e8bd8810 	pop	{r4, fp, pc}

100175cc <rt_timer_start>:
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
{
100175cc:	e92d4810 	push	{r4, fp, lr}
100175d0:	e28db008 	add	fp, sp, #8
100175d4:	e24dd024 	sub	sp, sp, #36	; 0x24
100175d8:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
    unsigned int tst_nr;
    static unsigned int random_nr;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
100175dc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100175e0:	e3530000 	cmp	r3, #0
100175e4:	1a000005 	bne	10017600 <rt_timer_start+0x34>
100175e8:	e3030f7c 	movw	r0, #16252	; 0x3f7c
100175ec:	e3410003 	movt	r0, #4099	; 0x1003
100175f0:	e3031fe4 	movw	r1, #16356	; 0x3fe4
100175f4:	e3411003 	movt	r1, #4099	; 0x1003
100175f8:	e3a02e13 	mov	r2, #304	; 0x130
100175fc:	ebfff1ec 	bl	10013db4 <rt_assert_handler>

	/* stop timer firstly */
	level = rt_hw_interrupt_disable();
10017600:	eb00080a 	bl	10019630 <rt_hw_interrupt_disable>
10017604:	e1a04000 	mov	r4, r0
	/* remove timer from list */
    _rt_timer_remove(timer);
10017608:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
1001760c:	ebffff6e 	bl	100173cc <_rt_timer_remove>
    /* change status of timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
10017610:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10017614:	e5d33007 	ldrb	r3, [r3, #7]
10017618:	e3c33001 	bic	r3, r3, #1
1001761c:	e6ef2073 	uxtb	r2, r3
10017620:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10017624:	e5c32007 	strb	r2, [r3, #7]
    rt_hw_interrupt_enable(level);
10017628:	e1a00004 	mov	r0, r4
1001762c:	eb000803 	bl	10019640 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
10017630:	e30239b0 	movw	r3, #10672	; 0x29b0
10017634:	e3413004 	movt	r3, #4100	; 0x1004
10017638:	e5933000 	ldr	r3, [r3]
1001763c:	e3530000 	cmp	r3, #0
10017640:	0a000005 	beq	1001765c <rt_timer_start+0x90>
10017644:	e30239b0 	movw	r3, #10672	; 0x29b0
10017648:	e3413004 	movt	r3, #4100	; 0x1004
1001764c:	e5933000 	ldr	r3, [r3]
10017650:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10017654:	e1a00002 	mov	r0, r2
10017658:	e12fff33 	blx	r3

    /*
     * get timeout tick,
     * the max timeout tick shall not great than RT_TICK_MAX/2
     */
    RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
1001765c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10017660:	e5933020 	ldr	r3, [r3, #32]
10017664:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
10017668:	9a000005 	bls	10017684 <rt_timer_start+0xb8>
1001766c:	e3030f90 	movw	r0, #16272	; 0x3f90
10017670:	e3410003 	movt	r0, #4099	; 0x1003
10017674:	e3031fe4 	movw	r1, #16356	; 0x3fe4
10017678:	e3411003 	movt	r1, #4099	; 0x1003
1001767c:	e3a02d05 	mov	r2, #320	; 0x140
10017680:	ebfff1cb 	bl	10013db4 <rt_assert_handler>
    timer->timeout_tick = rt_tick_get() + timer->init_tick;
10017684:	ebffdb2e 	bl	1000e344 <rt_tick_get>
10017688:	e1a02000 	mov	r2, r0
1001768c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10017690:	e5933020 	ldr	r3, [r3, #32]
10017694:	e0822003 	add	r2, r2, r3
10017698:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001769c:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100176a0:	eb0007e2 	bl	10019630 <rt_hw_interrupt_disable>
100176a4:	e1a04000 	mov	r4, r0
    }
    else
#endif
    {
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
100176a8:	e30c3448 	movw	r3, #50248	; 0xc448
100176ac:	e3413003 	movt	r3, #4099	; 0x1003
100176b0:	e50b3018 	str	r3, [fp, #-24]
    }

    row_head[0]  = &timer_list[0];
100176b4:	e51b3018 	ldr	r3, [fp, #-24]
100176b8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
100176bc:	e3a03000 	mov	r3, #0
100176c0:	e50b3010 	str	r3, [fp, #-16]
100176c4:	ea000046 	b	100177e4 <rt_timer_start+0x218>
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
100176c8:	ea000027 	b	1001776c <rt_timer_start+0x1a0>
             row_head[row_lvl]  = row_head[row_lvl]->next)
        {
            struct rt_timer *t;
            rt_list_t *p = row_head[row_lvl]->next;
100176cc:	e51b3010 	ldr	r3, [fp, #-16]
100176d0:	e1a03103 	lsl	r3, r3, #2
100176d4:	e24b200c 	sub	r2, fp, #12
100176d8:	e0823003 	add	r3, r2, r3
100176dc:	e5133018 	ldr	r3, [r3, #-24]
100176e0:	e5933000 	ldr	r3, [r3]
100176e4:	e50b301c 	str	r3, [fp, #-28]

            /* fix up the entry pointer */
            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
100176e8:	e51b3010 	ldr	r3, [fp, #-16]
100176ec:	e1a03183 	lsl	r3, r3, #3
100176f0:	e2833010 	add	r3, r3, #16
100176f4:	e2633000 	rsb	r3, r3, #0
100176f8:	e51b201c 	ldr	r2, [fp, #-28]
100176fc:	e0823003 	add	r3, r2, r3
10017700:	e50b3020 	str	r3, [fp, #-32]
            /* If we have two timers that timeout at the same time, it's
             * preferred that the timer inserted early get called early.
             * So insert the new timer to the end the the some-timeout timer
             * list.
             */
            if ((t->timeout_tick - timer->timeout_tick) == 0)
10017704:	e51b3020 	ldr	r3, [fp, #-32]
10017708:	e5932024 	ldr	r2, [r3, #36]	; 0x24
1001770c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10017710:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10017714:	e1520003 	cmp	r2, r3
10017718:	1a000000 	bne	10017720 <rt_timer_start+0x154>
            {
                continue;
1001771c:	ea000007 	b	10017740 <rt_timer_start+0x174>
            }
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
10017720:	e51b3020 	ldr	r3, [fp, #-32]
10017724:	e5932024 	ldr	r2, [r3, #36]	; 0x24
10017728:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001772c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10017730:	e0633002 	rsb	r3, r3, r2
10017734:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
10017738:	8a000000 	bhi	10017740 <rt_timer_start+0x174>
            {
                break;
1001773c:	ea000016 	b	1001779c <rt_timer_start+0x1d0>

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
             row_head[row_lvl]  = row_head[row_lvl]->next)
10017740:	e51b3010 	ldr	r3, [fp, #-16]
10017744:	e1a03103 	lsl	r3, r3, #2
10017748:	e24b200c 	sub	r2, fp, #12
1001774c:	e0823003 	add	r3, r2, r3
10017750:	e5133018 	ldr	r3, [r3, #-24]
10017754:	e5932000 	ldr	r2, [r3]
10017758:	e51b3010 	ldr	r3, [fp, #-16]
1001775c:	e1a03103 	lsl	r3, r3, #2
10017760:	e24b100c 	sub	r1, fp, #12
10017764:	e0813003 	add	r3, r1, r3
10017768:	e5032018 	str	r2, [r3, #-24]
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
1001776c:	e51b3010 	ldr	r3, [fp, #-16]
10017770:	e1a03103 	lsl	r3, r3, #2
10017774:	e24b200c 	sub	r2, fp, #12
10017778:	e0823003 	add	r3, r2, r3
1001777c:	e5132018 	ldr	r2, [r3, #-24]
10017780:	e51b3010 	ldr	r3, [fp, #-16]
10017784:	e1a03183 	lsl	r3, r3, #3
10017788:	e51b1018 	ldr	r1, [fp, #-24]
1001778c:	e0813003 	add	r3, r1, r3
10017790:	e5933004 	ldr	r3, [r3, #4]
10017794:	e1520003 	cmp	r2, r3
10017798:	1affffcb 	bne	100176cc <rt_timer_start+0x100>
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
            {
                break;
            }
        }
        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
1001779c:	e51b3010 	ldr	r3, [fp, #-16]
100177a0:	e3530000 	cmp	r3, #0
100177a4:	0a00000b 	beq	100177d8 <rt_timer_start+0x20c>
            row_head[row_lvl+1] = row_head[row_lvl]+1;
100177a8:	e51b3010 	ldr	r3, [fp, #-16]
100177ac:	e2831001 	add	r1, r3, #1
100177b0:	e51b3010 	ldr	r3, [fp, #-16]
100177b4:	e1a03103 	lsl	r3, r3, #2
100177b8:	e24b200c 	sub	r2, fp, #12
100177bc:	e0823003 	add	r3, r2, r3
100177c0:	e5133018 	ldr	r3, [r3, #-24]
100177c4:	e2832008 	add	r2, r3, #8
100177c8:	e1a03101 	lsl	r3, r1, #2
100177cc:	e24b100c 	sub	r1, fp, #12
100177d0:	e0813003 	add	r3, r1, r3
100177d4:	e5032018 	str	r2, [r3, #-24]
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
100177d8:	e51b3010 	ldr	r3, [fp, #-16]
100177dc:	e2833001 	add	r3, r3, #1
100177e0:	e50b3010 	str	r3, [fp, #-16]
100177e4:	e51b3010 	ldr	r3, [fp, #-16]
100177e8:	e3530000 	cmp	r3, #0
100177ec:	0affffb5 	beq	100176c8 <rt_timer_start+0xfc>

    /* Interestingly, this super simple timer insert counter works very very
     * well on distributing the list height uniformly. By means of "very very
     * well", I mean it beats the randomness of timer->timeout_tick very easily
     * (actually, the timeout_tick is not random and easy to be attacked). */
    random_nr++;
100177f0:	e30c3454 	movw	r3, #50260	; 0xc454
100177f4:	e3413003 	movt	r3, #4099	; 0x1003
100177f8:	e5933000 	ldr	r3, [r3]
100177fc:	e2832001 	add	r2, r3, #1
10017800:	e30c3454 	movw	r3, #50260	; 0xc454
10017804:	e3413003 	movt	r3, #4099	; 0x1003
10017808:	e5832000 	str	r2, [r3]
    tst_nr = random_nr;
1001780c:	e30c3454 	movw	r3, #50260	; 0xc454
10017810:	e3413003 	movt	r3, #4099	; 0x1003
10017814:	e5933000 	ldr	r3, [r3]
10017818:	e50b3014 	str	r3, [fp, #-20]

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
1001781c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10017820:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10017824:	e2833010 	add	r3, r3, #16
10017828:	e1a00002 	mov	r0, r2
1001782c:	e1a01003 	mov	r1, r3
10017830:	ebfffe5b 	bl	100171a4 <rt_list_insert_after>
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
10017834:	e3a03002 	mov	r3, #2
10017838:	e50b3010 	str	r3, [fp, #-16]
1001783c:	ea00001a 	b	100178ac <rt_timer_start+0x2e0>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
10017840:	e51b3014 	ldr	r3, [fp, #-20]
10017844:	e2033003 	and	r3, r3, #3
10017848:	e3530000 	cmp	r3, #0
1001784c:	1a00000f 	bne	10017890 <rt_timer_start+0x2c4>
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
10017850:	e51b3010 	ldr	r3, [fp, #-16]
10017854:	e2633001 	rsb	r3, r3, #1
10017858:	e1a03103 	lsl	r3, r3, #2
1001785c:	e24b200c 	sub	r2, fp, #12
10017860:	e0823003 	add	r3, r2, r3
10017864:	e5131018 	ldr	r1, [r3, #-24]
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
10017868:	e51b3010 	ldr	r3, [fp, #-16]
1001786c:	e2633001 	rsb	r3, r3, #1
    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
10017870:	e2833002 	add	r3, r3, #2
10017874:	e1a03183 	lsl	r3, r3, #3
10017878:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1001787c:	e0823003 	add	r3, r2, r3
10017880:	e1a00001 	mov	r0, r1
10017884:	e1a01003 	mov	r1, r3
10017888:	ebfffe45 	bl	100171a4 <rt_list_insert_after>
1001788c:	ea000000 	b	10017894 <rt_timer_start+0x2c8>
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
        else
            break;
10017890:	ea000008 	b	100178b8 <rt_timer_start+0x2ec>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
10017894:	e51b3014 	ldr	r3, [fp, #-20]
10017898:	e1a03123 	lsr	r3, r3, #2
1001789c:	e50b3014 	str	r3, [fp, #-20]
    random_nr++;
    tst_nr = random_nr;

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
100178a0:	e51b3010 	ldr	r3, [fp, #-16]
100178a4:	e2833001 	add	r3, r3, #1
100178a8:	e50b3010 	str	r3, [fp, #-16]
100178ac:	e51b3010 	ldr	r3, [fp, #-16]
100178b0:	e3530001 	cmp	r3, #1
100178b4:	9affffe1 	bls	10017840 <rt_timer_start+0x274>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
    }

    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
100178b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100178bc:	e5d33007 	ldrb	r3, [r3, #7]
100178c0:	e3833001 	orr	r3, r3, #1
100178c4:	e6ef2073 	uxtb	r2, r3
100178c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100178cc:	e5c32007 	strb	r2, [r3, #7]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
100178d0:	e1a00004 	mov	r0, r4
100178d4:	eb000759 	bl	10019640 <rt_hw_interrupt_enable>
            rt_schedule();
        }
    }
#endif

    return -RT_EOK;
100178d8:	e3a03000 	mov	r3, #0
}
100178dc:	e1a00003 	mov	r0, r3
100178e0:	e24bd008 	sub	sp, fp, #8
100178e4:	e8bd8810 	pop	{r4, fp, pc}

100178e8 <rt_timer_stop>:
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
{
100178e8:	e92d4810 	push	{r4, fp, lr}
100178ec:	e28db008 	add	fp, sp, #8
100178f0:	e24dd00c 	sub	sp, sp, #12
100178f4:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
100178f8:	e51b3010 	ldr	r3, [fp, #-16]
100178fc:	e3530000 	cmp	r3, #0
10017900:	1a000005 	bne	1001791c <rt_timer_stop+0x34>
10017904:	e3030f7c 	movw	r0, #16252	; 0x3f7c
10017908:	e3410003 	movt	r0, #4099	; 0x1003
1001790c:	e3031ff4 	movw	r1, #16372	; 0x3ff4
10017910:	e3411003 	movt	r1, #4099	; 0x1003
10017914:	e3a02f6a 	mov	r2, #424	; 0x1a8
10017918:	ebfff125 	bl	10013db4 <rt_assert_handler>
    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
1001791c:	e51b3010 	ldr	r3, [fp, #-16]
10017920:	e5d33007 	ldrb	r3, [r3, #7]
10017924:	e2033001 	and	r3, r3, #1
10017928:	e3530000 	cmp	r3, #0
1001792c:	1a000001 	bne	10017938 <rt_timer_stop+0x50>
        return -RT_ERROR;
10017930:	e3e03000 	mvn	r3, #0
10017934:	ea000017 	b	10017998 <rt_timer_stop+0xb0>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
10017938:	e30239ac 	movw	r3, #10668	; 0x29ac
1001793c:	e3413004 	movt	r3, #4100	; 0x1004
10017940:	e5933000 	ldr	r3, [r3]
10017944:	e3530000 	cmp	r3, #0
10017948:	0a000005 	beq	10017964 <rt_timer_stop+0x7c>
1001794c:	e30239ac 	movw	r3, #10668	; 0x29ac
10017950:	e3413004 	movt	r3, #4100	; 0x1004
10017954:	e5933000 	ldr	r3, [r3]
10017958:	e51b2010 	ldr	r2, [fp, #-16]
1001795c:	e1a00002 	mov	r0, r2
10017960:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10017964:	eb000731 	bl	10019630 <rt_hw_interrupt_disable>
10017968:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
1001796c:	e51b0010 	ldr	r0, [fp, #-16]
10017970:	ebfffe95 	bl	100173cc <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10017974:	e1a00004 	mov	r0, r4
10017978:	eb000730 	bl	10019640 <rt_hw_interrupt_enable>

    /* change stat */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
1001797c:	e51b3010 	ldr	r3, [fp, #-16]
10017980:	e5d33007 	ldrb	r3, [r3, #7]
10017984:	e3c33001 	bic	r3, r3, #1
10017988:	e6ef2073 	uxtb	r2, r3
1001798c:	e51b3010 	ldr	r3, [fp, #-16]
10017990:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
10017994:	e3a03000 	mov	r3, #0
}
10017998:	e1a00003 	mov	r0, r3
1001799c:	e24bd008 	sub	sp, fp, #8
100179a0:	e8bd8810 	pop	{r4, fp, pc}

100179a4 <rt_timer_control>:
 * @param arg the argument
 *
 * @return RT_EOK
 */
rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
{
100179a4:	e92d4800 	push	{fp, lr}
100179a8:	e28db004 	add	fp, sp, #4
100179ac:	e24dd010 	sub	sp, sp, #16
100179b0:	e50b0008 	str	r0, [fp, #-8]
100179b4:	e1a03001 	mov	r3, r1
100179b8:	e50b2010 	str	r2, [fp, #-16]
100179bc:	e54b3009 	strb	r3, [fp, #-9]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
100179c0:	e51b3008 	ldr	r3, [fp, #-8]
100179c4:	e3530000 	cmp	r3, #0
100179c8:	1a000005 	bne	100179e4 <rt_timer_control+0x40>
100179cc:	e3030f7c 	movw	r0, #16252	; 0x3f7c
100179d0:	e3410003 	movt	r0, #4099	; 0x1003
100179d4:	e3041004 	movw	r1, #16388	; 0x4004
100179d8:	e3411003 	movt	r1, #4099	; 0x1003
100179dc:	e30021c9 	movw	r2, #457	; 0x1c9
100179e0:	ebfff0f3 	bl	10013db4 <rt_assert_handler>

    switch (cmd)
100179e4:	e55b3009 	ldrb	r3, [fp, #-9]
100179e8:	e3530003 	cmp	r3, #3
100179ec:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
100179f0:	ea00001b 	b	10017a64 <rt_timer_control+0xc0>
100179f4:	10017a18 	.word	0x10017a18
100179f8:	10017a04 	.word	0x10017a04
100179fc:	10017a2c 	.word	0x10017a2c
10017a00:	10017a48 	.word	0x10017a48
    {
    case RT_TIMER_CTRL_GET_TIME:
        *(rt_tick_t *)arg = timer->init_tick;
10017a04:	e51b3008 	ldr	r3, [fp, #-8]
10017a08:	e5932020 	ldr	r2, [r3, #32]
10017a0c:	e51b3010 	ldr	r3, [fp, #-16]
10017a10:	e5832000 	str	r2, [r3]
        break;
10017a14:	ea000012 	b	10017a64 <rt_timer_control+0xc0>

    case RT_TIMER_CTRL_SET_TIME:
        timer->init_tick = *(rt_tick_t *)arg;
10017a18:	e51b3010 	ldr	r3, [fp, #-16]
10017a1c:	e5932000 	ldr	r2, [r3]
10017a20:	e51b3008 	ldr	r3, [fp, #-8]
10017a24:	e5832020 	str	r2, [r3, #32]
        break;
10017a28:	ea00000d 	b	10017a64 <rt_timer_control+0xc0>

    case RT_TIMER_CTRL_SET_ONESHOT:
        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
10017a2c:	e51b3008 	ldr	r3, [fp, #-8]
10017a30:	e5d33007 	ldrb	r3, [r3, #7]
10017a34:	e3c33002 	bic	r3, r3, #2
10017a38:	e6ef2073 	uxtb	r2, r3
10017a3c:	e51b3008 	ldr	r3, [fp, #-8]
10017a40:	e5c32007 	strb	r2, [r3, #7]
        break;
10017a44:	ea000006 	b	10017a64 <rt_timer_control+0xc0>

    case RT_TIMER_CTRL_SET_PERIODIC:
        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
10017a48:	e51b3008 	ldr	r3, [fp, #-8]
10017a4c:	e5d33007 	ldrb	r3, [r3, #7]
10017a50:	e3833002 	orr	r3, r3, #2
10017a54:	e6ef2073 	uxtb	r2, r3
10017a58:	e51b3008 	ldr	r3, [fp, #-8]
10017a5c:	e5c32007 	strb	r2, [r3, #7]
        break;
10017a60:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
10017a64:	e3a03000 	mov	r3, #0
}
10017a68:	e1a00003 	mov	r0, r3
10017a6c:	e24bd004 	sub	sp, fp, #4
10017a70:	e8bd8800 	pop	{fp, pc}

10017a74 <rt_timer_check>:
 * corresponding timeout function will be invoked.
 *
 * @note this function shall be invoked in operating system timer interrupt.
 */
void rt_timer_check(void)
{
10017a74:	e92d4810 	push	{r4, fp, lr}
10017a78:	e28db008 	add	fp, sp, #8
10017a7c:	e24dd00c 	sub	sp, sp, #12
    rt_tick_t current_tick;
    register rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));

    current_tick = rt_tick_get();
10017a80:	ebffda2f 	bl	1000e344 <rt_tick_get>
10017a84:	e50b0010 	str	r0, [fp, #-16]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10017a88:	eb0006e8 	bl	10019630 <rt_hw_interrupt_disable>
10017a8c:	e1a04000 	mov	r4, r0

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
10017a90:	ea000039 	b	10017b7c <rt_timer_check+0x108>
    {
        t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
10017a94:	e30c3448 	movw	r3, #50248	; 0xc448
10017a98:	e3413003 	movt	r3, #4099	; 0x1003
10017a9c:	e5933000 	ldr	r3, [r3]
10017aa0:	e2433010 	sub	r3, r3, #16
10017aa4:	e50b3014 	str	r3, [fp, #-20]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
10017aa8:	e51b3014 	ldr	r3, [fp, #-20]
10017aac:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10017ab0:	e51b2010 	ldr	r2, [fp, #-16]
10017ab4:	e0633002 	rsb	r3, r3, r2
10017ab8:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
10017abc:	8a00002d 	bhi	10017b78 <rt_timer_check+0x104>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
10017ac0:	e30c3450 	movw	r3, #50256	; 0xc450
10017ac4:	e3413003 	movt	r3, #4099	; 0x1003
10017ac8:	e5933000 	ldr	r3, [r3]
10017acc:	e3530000 	cmp	r3, #0
10017ad0:	0a000004 	beq	10017ae8 <rt_timer_check+0x74>
10017ad4:	e30c3450 	movw	r3, #50256	; 0xc450
10017ad8:	e3413003 	movt	r3, #4099	; 0x1003
10017adc:	e5933000 	ldr	r3, [r3]
10017ae0:	e51b0014 	ldr	r0, [fp, #-20]
10017ae4:	e12fff33 	blx	r3

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
10017ae8:	e51b0014 	ldr	r0, [fp, #-20]
10017aec:	ebfffe36 	bl	100173cc <_rt_timer_remove>

            /* call timeout function */
            t->timeout_func(t->parameter);
10017af0:	e51b3014 	ldr	r3, [fp, #-20]
10017af4:	e5933018 	ldr	r3, [r3, #24]
10017af8:	e51b2014 	ldr	r2, [fp, #-20]
10017afc:	e592201c 	ldr	r2, [r2, #28]
10017b00:	e1a00002 	mov	r0, r2
10017b04:	e12fff33 	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
10017b08:	ebffda0d 	bl	1000e344 <rt_tick_get>
10017b0c:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
10017b10:	e51b3014 	ldr	r3, [fp, #-20]
10017b14:	e5d33007 	ldrb	r3, [r3, #7]
10017b18:	e2033002 	and	r3, r3, #2
10017b1c:	e3530000 	cmp	r3, #0
10017b20:	0a00000d 	beq	10017b5c <rt_timer_check+0xe8>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
10017b24:	e51b3014 	ldr	r3, [fp, #-20]
10017b28:	e5d33007 	ldrb	r3, [r3, #7]
10017b2c:	e2033001 	and	r3, r3, #1
            /* re-get tick */
            current_tick = rt_tick_get();

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
10017b30:	e3530000 	cmp	r3, #0
10017b34:	0a000008 	beq	10017b5c <rt_timer_check+0xe8>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
10017b38:	e51b3014 	ldr	r3, [fp, #-20]
10017b3c:	e5d33007 	ldrb	r3, [r3, #7]
10017b40:	e3c33001 	bic	r3, r3, #1
10017b44:	e6ef2073 	uxtb	r2, r3
10017b48:	e51b3014 	ldr	r3, [fp, #-20]
10017b4c:	e5c32007 	strb	r2, [r3, #7]
                rt_timer_start(t);
10017b50:	e51b0014 	ldr	r0, [fp, #-20]
10017b54:	ebfffe9c 	bl	100175cc <rt_timer_start>
10017b58:	ea000005 	b	10017b74 <rt_timer_check+0x100>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
10017b5c:	e51b3014 	ldr	r3, [fp, #-20]
10017b60:	e5d33007 	ldrb	r3, [r3, #7]
10017b64:	e3c33001 	bic	r3, r3, #1
10017b68:	e6ef2073 	uxtb	r2, r3
10017b6c:	e51b3014 	ldr	r3, [fp, #-20]
10017b70:	e5c32007 	strb	r2, [r3, #7]
10017b74:	ea000000 	b	10017b7c <rt_timer_check+0x108>
            }
        }
        else
            break;
10017b78:	ea000005 	b	10017b94 <rt_timer_check+0x120>
    current_tick = rt_tick_get();

    /* disable interrupt */
    level = rt_hw_interrupt_disable();

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
10017b7c:	e30c0448 	movw	r0, #50248	; 0xc448
10017b80:	e3410003 	movt	r0, #4099	; 0x1003
10017b84:	ebfffdb4 	bl	1001725c <rt_list_isempty>
10017b88:	e1a03000 	mov	r3, r0
10017b8c:	e3530000 	cmp	r3, #0
10017b90:	0affffbf 	beq	10017a94 <rt_timer_check+0x20>
        else
            break;
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10017b94:	e1a00004 	mov	r0, r4
10017b98:	eb0006a8 	bl	10019640 <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
}
10017b9c:	e24bd008 	sub	sp, fp, #8
10017ba0:	e8bd8810 	pop	{r4, fp, pc}

10017ba4 <rt_timer_next_timeout_tick>:
 * This function will return the next timeout tick in the system.
 *
 * @return the next timeout tick in the system
 */
rt_tick_t rt_timer_next_timeout_tick(void)
{
10017ba4:	e92d4800 	push	{fp, lr}
10017ba8:	e28db004 	add	fp, sp, #4
    return rt_timer_list_next_timeout(rt_timer_list);
10017bac:	e30c0448 	movw	r0, #50248	; 0xc448
10017bb0:	e3410003 	movt	r0, #4099	; 0x1003
10017bb4:	ebfffdf0 	bl	1001737c <rt_timer_list_next_timeout>
10017bb8:	e1a03000 	mov	r3, r0
}
10017bbc:	e1a00003 	mov	r0, r3
10017bc0:	e8bd8800 	pop	{fp, pc}

10017bc4 <rt_system_timer_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer
 */
void rt_system_timer_init(void)
{
10017bc4:	e92d4800 	push	{fp, lr}
10017bc8:	e28db004 	add	fp, sp, #4
10017bcc:	e24dd008 	sub	sp, sp, #8
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
10017bd0:	e3a03000 	mov	r3, #0
10017bd4:	e50b3008 	str	r3, [fp, #-8]
10017bd8:	ea000009 	b	10017c04 <rt_system_timer_init+0x40>
    {
        rt_list_init(rt_timer_list+i);
10017bdc:	e51b3008 	ldr	r3, [fp, #-8]
10017be0:	e1a02183 	lsl	r2, r3, #3
10017be4:	e30c3448 	movw	r3, #50248	; 0xc448
10017be8:	e3413003 	movt	r3, #4099	; 0x1003
10017bec:	e0823003 	add	r3, r2, r3
10017bf0:	e1a00003 	mov	r0, r3
10017bf4:	ebfffd5c 	bl	1001716c <rt_list_init>
 */
void rt_system_timer_init(void)
{
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
10017bf8:	e51b3008 	ldr	r3, [fp, #-8]
10017bfc:	e2833001 	add	r3, r3, #1
10017c00:	e50b3008 	str	r3, [fp, #-8]
10017c04:	e51b3008 	ldr	r3, [fp, #-8]
10017c08:	e3530000 	cmp	r3, #0
10017c0c:	0afffff2 	beq	10017bdc <rt_system_timer_init+0x18>
    {
        rt_list_init(rt_timer_list+i);
    }
}
10017c10:	e24bd004 	sub	sp, fp, #4
10017c14:	e8bd8800 	pop	{fp, pc}

10017c18 <rt_system_timer_thread_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer thread
 */
void rt_system_timer_thread_init(void)
{
10017c18:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017c1c:	e28db000 	add	fp, sp, #0
                   10);

    /* startup */
    rt_thread_startup(&timer_thread);
#endif
}
10017c20:	e24bd000 	sub	sp, fp, #0
10017c24:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10017c28:	e12fff1e 	bx	lr

10017c2c <rt_hw_cpu_reset>:
/**
 * reset cpu by dog's time-out
 *
 */
void rt_hw_cpu_reset()
{
10017c2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017c30:	e28db000 	add	fp, sp, #0
    while (1);  /* loop forever and wait for reset to happen */
10017c34:	eafffffe 	b	10017c34 <rt_hw_cpu_reset+0x8>

10017c38 <rt_hw_cpu_shutdown>:
/**
 *  shutdown CPU
 *
 */
void rt_hw_cpu_shutdown()
{
10017c38:	e92d4800 	push	{fp, lr}
10017c3c:	e28db004 	add	fp, sp, #4
10017c40:	e24dd008 	sub	sp, sp, #8
    rt_uint32_t level;
	
	rt_device_t device;
	#if 1
	device = rt_device_find("motor_misc1");
10017c44:	e3040018 	movw	r0, #16408	; 0x4018
10017c48:	e3410003 	movt	r0, #4099	; 0x1003
10017c4c:	ebffda80 	bl	1000e654 <rt_device_find>
10017c50:	e50b0008 	str	r0, [fp, #-8]
	if(device != NULL)
10017c54:	e51b3008 	ldr	r3, [fp, #-8]
10017c58:	e3530000 	cmp	r3, #0
10017c5c:	0a00000d 	beq	10017c98 <rt_hw_cpu_shutdown+0x60>
	{
		
		rt_kprintf("misc shut %d\r\n",device);
10017c60:	e3040024 	movw	r0, #16420	; 0x4024
10017c64:	e3410003 	movt	r0, #4099	; 0x1003
10017c68:	e51b1008 	ldr	r1, [fp, #-8]
10017c6c:	ebffef93 	bl	10013ac0 <rt_kprintf>
		rt_device_control(device,CMD_MISC_CLR_RLY,NULL);
10017c70:	e51b0008 	ldr	r0, [fp, #-8]
10017c74:	e3a0100a 	mov	r1, #10
10017c78:	e3a02000 	mov	r2, #0
10017c7c:	ebffdbcb 	bl	1000ebb0 <rt_device_control>
		rt_device_control(device,CMD_MISC_INTDISABLE,NULL);
10017c80:	e51b0008 	ldr	r0, [fp, #-8]
10017c84:	e3a01002 	mov	r1, #2
10017c88:	e3a02000 	mov	r2, #0
10017c8c:	ebffdbc7 	bl	1000ebb0 <rt_device_control>
		rt_device_close(device);
10017c90:	e51b0008 	ldr	r0, [fp, #-8]
10017c94:	ebffdb38 	bl	1000e97c <rt_device_close>
	}
	
	device = rt_device_find("pwm1");
10017c98:	e3040034 	movw	r0, #16436	; 0x4034
10017c9c:	e3410003 	movt	r0, #4099	; 0x1003
10017ca0:	ebffda6b 	bl	1000e654 <rt_device_find>
10017ca4:	e50b0008 	str	r0, [fp, #-8]
	if(device != NULL)
10017ca8:	e51b3008 	ldr	r3, [fp, #-8]
10017cac:	e3530000 	cmp	r3, #0
10017cb0:	0a000008 	beq	10017cd8 <rt_hw_cpu_shutdown+0xa0>
	{
		rt_kprintf("pwm1 shut\n");
10017cb4:	e304003c 	movw	r0, #16444	; 0x403c
10017cb8:	e3410003 	movt	r0, #4099	; 0x1003
10017cbc:	ebffef7f 	bl	10013ac0 <rt_kprintf>
		rt_device_control(device,CMD_PWMDISABLE,NULL);
10017cc0:	e51b0008 	ldr	r0, [fp, #-8]
10017cc4:	e3a01002 	mov	r1, #2
10017cc8:	e3a02000 	mov	r2, #0
10017ccc:	ebffdbb7 	bl	1000ebb0 <rt_device_control>
		rt_device_close(device);
10017cd0:	e51b0008 	ldr	r0, [fp, #-8]
10017cd4:	ebffdb28 	bl	1000e97c <rt_device_close>
	}
	
	device = rt_device_find("adc1");
10017cd8:	e3040048 	movw	r0, #16456	; 0x4048
10017cdc:	e3410003 	movt	r0, #4099	; 0x1003
10017ce0:	ebffda5b 	bl	1000e654 <rt_device_find>
10017ce4:	e50b0008 	str	r0, [fp, #-8]
	if(device != NULL)
10017ce8:	e51b3008 	ldr	r3, [fp, #-8]
10017cec:	e3530000 	cmp	r3, #0
10017cf0:	0a000004 	beq	10017d08 <rt_hw_cpu_shutdown+0xd0>
	{
		
		rt_kprintf("adc1 shut\n");
10017cf4:	e3040050 	movw	r0, #16464	; 0x4050
10017cf8:	e3410003 	movt	r0, #4099	; 0x1003
10017cfc:	ebffef6f 	bl	10013ac0 <rt_kprintf>
		rt_device_close(device);
10017d00:	e51b0008 	ldr	r0, [fp, #-8]
10017d04:	ebffdb1c 	bl	1000e97c <rt_device_close>
	}
	
	device = rt_device_find("qep1");
10017d08:	e304005c 	movw	r0, #16476	; 0x405c
10017d0c:	e3410003 	movt	r0, #4099	; 0x1003
10017d10:	ebffda4f 	bl	1000e654 <rt_device_find>
10017d14:	e50b0008 	str	r0, [fp, #-8]
	if(device != NULL)
10017d18:	e51b3008 	ldr	r3, [fp, #-8]
10017d1c:	e3530000 	cmp	r3, #0
10017d20:	0a000008 	beq	10017d48 <rt_hw_cpu_shutdown+0x110>
	{
		rt_kprintf("qep1 shut\n");
10017d24:	e3040064 	movw	r0, #16484	; 0x4064
10017d28:	e3410003 	movt	r0, #4099	; 0x1003
10017d2c:	ebffef63 	bl	10013ac0 <rt_kprintf>
		rt_device_control(device,CMD_QEPDISABLE,NULL);
10017d30:	e51b0008 	ldr	r0, [fp, #-8]
10017d34:	e3a01002 	mov	r1, #2
10017d38:	e3a02000 	mov	r2, #0
10017d3c:	ebffdb9b 	bl	1000ebb0 <rt_device_control>
		rt_device_close(device);
10017d40:	e51b0008 	ldr	r0, [fp, #-8]
10017d44:	ebffdb0c 	bl	1000e97c <rt_device_close>
	}
	#endif
    rt_kprintf("shutdown...\n");
10017d48:	e3040070 	movw	r0, #16496	; 0x4070
10017d4c:	e3410003 	movt	r0, #4099	; 0x1003
10017d50:	ebffef5a 	bl	10013ac0 <rt_kprintf>
	
	
    level = rt_hw_interrupt_disable();
10017d54:	eb000635 	bl	10019630 <rt_hw_interrupt_disable>
10017d58:	e1a03000 	mov	r3, r0
10017d5c:	e50b300c 	str	r3, [fp, #-12]
	
    while (level)
10017d60:	ea000005 	b	10017d7c <rt_hw_cpu_shutdown+0x144>
    {
        RT_ASSERT(0);
10017d64:	e3040080 	movw	r0, #16512	; 0x4080
10017d68:	e3410003 	movt	r0, #4099	; 0x1003
10017d6c:	e3041084 	movw	r1, #16516	; 0x4084
10017d70:	e3411003 	movt	r1, #4099	; 0x1003
10017d74:	e3a0205b 	mov	r2, #91	; 0x5b
10017d78:	ebfff00d 	bl	10013db4 <rt_assert_handler>
    rt_kprintf("shutdown...\n");
	
	
    level = rt_hw_interrupt_disable();
	
    while (level)
10017d7c:	e51b300c 	ldr	r3, [fp, #-12]
10017d80:	e3530000 	cmp	r3, #0
10017d84:	1afffff6 	bne	10017d64 <rt_hw_cpu_shutdown+0x12c>
    {
        RT_ASSERT(0);
    }
}
10017d88:	e24bd004 	sub	sp, fp, #4
10017d8c:	e8bd8800 	pop	{fp, pc}

10017d90 <arm_gic_get_active_irq>:
#define GIC_DIST_ICPIDR2(hw_base)           __REG32((hw_base) + 0xfe8)

static unsigned int _gic_max_irq;

int arm_gic_get_active_irq(rt_uint32_t index)
{
10017d90:	e92d4800 	push	{fp, lr}
10017d94:	e28db004 	add	fp, sp, #4
10017d98:	e24dd010 	sub	sp, sp, #16
10017d9c:	e50b0010 	str	r0, [fp, #-16]
    int irq;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
10017da0:	e51b3010 	ldr	r3, [fp, #-16]
10017da4:	e3530000 	cmp	r3, #0
10017da8:	0a000005 	beq	10017dc4 <arm_gic_get_active_irq+0x34>
10017dac:	e3040098 	movw	r0, #16536	; 0x4098
10017db0:	e3410003 	movt	r0, #4099	; 0x1003
10017db4:	e3041144 	movw	r1, #16708	; 0x4144
10017db8:	e3411003 	movt	r1, #4099	; 0x1003
10017dbc:	e3a02041 	mov	r2, #65	; 0x41
10017dc0:	ebffeffb 	bl	10013db4 <rt_assert_handler>

    irq = GIC_CPU_INTACK(_gic_table[index].cpu_hw_base);
10017dc4:	e30c2458 	movw	r2, #50264	; 0xc458
10017dc8:	e3412003 	movt	r2, #4099	; 0x1003
10017dcc:	e51b3010 	ldr	r3, [fp, #-16]
10017dd0:	e1a01003 	mov	r1, r3
10017dd4:	e1a03101 	lsl	r3, r1, #2
10017dd8:	e1a01003 	mov	r1, r3
10017ddc:	e1a03101 	lsl	r3, r1, #2
10017de0:	e0613003 	rsb	r3, r1, r3
10017de4:	e0823003 	add	r3, r2, r3
10017de8:	e2833008 	add	r3, r3, #8
10017dec:	e5933000 	ldr	r3, [r3]
10017df0:	e283300c 	add	r3, r3, #12
10017df4:	e5933000 	ldr	r3, [r3]
10017df8:	e50b3008 	str	r3, [fp, #-8]
    irq += _gic_table[index].offset;
10017dfc:	e30c2458 	movw	r2, #50264	; 0xc458
10017e00:	e3412003 	movt	r2, #4099	; 0x1003
10017e04:	e51b3010 	ldr	r3, [fp, #-16]
10017e08:	e1a01003 	mov	r1, r3
10017e0c:	e1a03101 	lsl	r3, r1, #2
10017e10:	e1a01003 	mov	r1, r3
10017e14:	e1a03101 	lsl	r3, r1, #2
10017e18:	e0613003 	rsb	r3, r1, r3
10017e1c:	e0823003 	add	r3, r2, r3
10017e20:	e5932000 	ldr	r2, [r3]
10017e24:	e51b3008 	ldr	r3, [fp, #-8]
10017e28:	e0823003 	add	r3, r2, r3
10017e2c:	e50b3008 	str	r3, [fp, #-8]
    return irq;
10017e30:	e51b3008 	ldr	r3, [fp, #-8]
}
10017e34:	e1a00003 	mov	r0, r3
10017e38:	e24bd004 	sub	sp, fp, #4
10017e3c:	e8bd8800 	pop	{fp, pc}

10017e40 <arm_gic_ack>:

void arm_gic_ack(rt_uint32_t index, int irq)
{
10017e40:	e92d4800 	push	{fp, lr}
10017e44:	e28db004 	add	fp, sp, #4
10017e48:	e24dd010 	sub	sp, sp, #16
10017e4c:	e50b0010 	str	r0, [fp, #-16]
10017e50:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
10017e54:	e51b2014 	ldr	r2, [fp, #-20]
10017e58:	e1a03fc2 	asr	r3, r2, #31
10017e5c:	e1a03da3 	lsr	r3, r3, #27
10017e60:	e0822003 	add	r2, r2, r3
10017e64:	e202201f 	and	r2, r2, #31
10017e68:	e0633002 	rsb	r3, r3, r2
10017e6c:	e1a02003 	mov	r2, r3
10017e70:	e3a03001 	mov	r3, #1
10017e74:	e1a03213 	lsl	r3, r3, r2
10017e78:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
10017e7c:	e51b3010 	ldr	r3, [fp, #-16]
10017e80:	e3530000 	cmp	r3, #0
10017e84:	0a000005 	beq	10017ea0 <arm_gic_ack+0x60>
10017e88:	e3040098 	movw	r0, #16536	; 0x4098
10017e8c:	e3410003 	movt	r0, #4099	; 0x1003
10017e90:	e304115c 	movw	r1, #16732	; 0x415c
10017e94:	e3411003 	movt	r1, #4099	; 0x1003
10017e98:	e3a0204c 	mov	r2, #76	; 0x4c
10017e9c:	ebffefc4 	bl	10013db4 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
10017ea0:	e51b0014 	ldr	r0, [fp, #-20]
10017ea4:	e30c2458 	movw	r2, #50264	; 0xc458
10017ea8:	e3412003 	movt	r2, #4099	; 0x1003
10017eac:	e51b3010 	ldr	r3, [fp, #-16]
10017eb0:	e1a01003 	mov	r1, r3
10017eb4:	e1a03101 	lsl	r3, r1, #2
10017eb8:	e1a01003 	mov	r1, r3
10017ebc:	e1a03101 	lsl	r3, r1, #2
10017ec0:	e0613003 	rsb	r3, r1, r3
10017ec4:	e0823003 	add	r3, r2, r3
10017ec8:	e5933000 	ldr	r3, [r3]
10017ecc:	e0633000 	rsb	r3, r3, r0
10017ed0:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
10017ed4:	e51b3014 	ldr	r3, [fp, #-20]
10017ed8:	e3530000 	cmp	r3, #0
10017edc:	aa000005 	bge	10017ef8 <arm_gic_ack+0xb8>
10017ee0:	e30400b0 	movw	r0, #16560	; 0x40b0
10017ee4:	e3410003 	movt	r0, #4099	; 0x1003
10017ee8:	e304115c 	movw	r1, #16732	; 0x415c
10017eec:	e3411003 	movt	r1, #4099	; 0x1003
10017ef0:	e3a0204f 	mov	r2, #79	; 0x4f
10017ef4:	ebffefae 	bl	10013db4 <rt_assert_handler>

    GIC_DIST_ENABLE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
10017ef8:	e30c2458 	movw	r2, #50264	; 0xc458
10017efc:	e3412003 	movt	r2, #4099	; 0x1003
10017f00:	e51b3010 	ldr	r3, [fp, #-16]
10017f04:	e1a01003 	mov	r1, r3
10017f08:	e1a03101 	lsl	r3, r1, #2
10017f0c:	e1a01003 	mov	r1, r3
10017f10:	e1a03101 	lsl	r3, r1, #2
10017f14:	e0613003 	rsb	r3, r1, r3
10017f18:	e0823003 	add	r3, r2, r3
10017f1c:	e5932004 	ldr	r2, [r3, #4]
10017f20:	e51b3014 	ldr	r3, [fp, #-20]
10017f24:	e283101f 	add	r1, r3, #31
10017f28:	e3530000 	cmp	r3, #0
10017f2c:	b1a03001 	movlt	r3, r1
10017f30:	a1a03003 	movge	r3, r3
10017f34:	e1a032c3 	asr	r3, r3, #5
10017f38:	e1a03103 	lsl	r3, r3, #2
10017f3c:	e0823003 	add	r3, r2, r3
10017f40:	e2833d06 	add	r3, r3, #384	; 0x180
10017f44:	e1a02003 	mov	r2, r3
10017f48:	e51b3008 	ldr	r3, [fp, #-8]
10017f4c:	e5823000 	str	r3, [r2]
    GIC_CPU_EOI(_gic_table[index].cpu_hw_base) = irq;
10017f50:	e30c2458 	movw	r2, #50264	; 0xc458
10017f54:	e3412003 	movt	r2, #4099	; 0x1003
10017f58:	e51b3010 	ldr	r3, [fp, #-16]
10017f5c:	e1a01003 	mov	r1, r3
10017f60:	e1a03101 	lsl	r3, r1, #2
10017f64:	e1a01003 	mov	r1, r3
10017f68:	e1a03101 	lsl	r3, r1, #2
10017f6c:	e0613003 	rsb	r3, r1, r3
10017f70:	e0823003 	add	r3, r2, r3
10017f74:	e2833008 	add	r3, r3, #8
10017f78:	e5933000 	ldr	r3, [r3]
10017f7c:	e2833010 	add	r3, r3, #16
10017f80:	e1a02003 	mov	r2, r3
10017f84:	e51b3014 	ldr	r3, [fp, #-20]
10017f88:	e5823000 	str	r3, [r2]
    GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base, irq) = mask;
10017f8c:	e30c2458 	movw	r2, #50264	; 0xc458
10017f90:	e3412003 	movt	r2, #4099	; 0x1003
10017f94:	e51b3010 	ldr	r3, [fp, #-16]
10017f98:	e1a01003 	mov	r1, r3
10017f9c:	e1a03101 	lsl	r3, r1, #2
10017fa0:	e1a01003 	mov	r1, r3
10017fa4:	e1a03101 	lsl	r3, r1, #2
10017fa8:	e0613003 	rsb	r3, r1, r3
10017fac:	e0823003 	add	r3, r2, r3
10017fb0:	e5932004 	ldr	r2, [r3, #4]
10017fb4:	e51b3014 	ldr	r3, [fp, #-20]
10017fb8:	e283101f 	add	r1, r3, #31
10017fbc:	e3530000 	cmp	r3, #0
10017fc0:	b1a03001 	movlt	r3, r1
10017fc4:	a1a03003 	movge	r3, r3
10017fc8:	e1a032c3 	asr	r3, r3, #5
10017fcc:	e1a03103 	lsl	r3, r3, #2
10017fd0:	e0823003 	add	r3, r2, r3
10017fd4:	e2833c01 	add	r3, r3, #256	; 0x100
10017fd8:	e1a02003 	mov	r2, r3
10017fdc:	e51b3008 	ldr	r3, [fp, #-8]
10017fe0:	e5823000 	str	r3, [r2]
}
10017fe4:	e24bd004 	sub	sp, fp, #4
10017fe8:	e8bd8800 	pop	{fp, pc}

10017fec <arm_gic_mask>:

void arm_gic_mask(rt_uint32_t index, int irq)
{
10017fec:	e92d4800 	push	{fp, lr}
10017ff0:	e28db004 	add	fp, sp, #4
10017ff4:	e24dd010 	sub	sp, sp, #16
10017ff8:	e50b0010 	str	r0, [fp, #-16]
10017ffc:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
10018000:	e51b2014 	ldr	r2, [fp, #-20]
10018004:	e1a03fc2 	asr	r3, r2, #31
10018008:	e1a03da3 	lsr	r3, r3, #27
1001800c:	e0822003 	add	r2, r2, r3
10018010:	e202201f 	and	r2, r2, #31
10018014:	e0633002 	rsb	r3, r3, r2
10018018:	e1a02003 	mov	r2, r3
1001801c:	e3a03001 	mov	r3, #1
10018020:	e1a03213 	lsl	r3, r3, r2
10018024:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
10018028:	e51b3010 	ldr	r3, [fp, #-16]
1001802c:	e3530000 	cmp	r3, #0
10018030:	0a000005 	beq	1001804c <arm_gic_mask+0x60>
10018034:	e3040098 	movw	r0, #16536	; 0x4098
10018038:	e3410003 	movt	r0, #4099	; 0x1003
1001803c:	e3041168 	movw	r1, #16744	; 0x4168
10018040:	e3411003 	movt	r1, #4099	; 0x1003
10018044:	e3a0205a 	mov	r2, #90	; 0x5a
10018048:	ebffef59 	bl	10013db4 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
1001804c:	e51b0014 	ldr	r0, [fp, #-20]
10018050:	e30c2458 	movw	r2, #50264	; 0xc458
10018054:	e3412003 	movt	r2, #4099	; 0x1003
10018058:	e51b3010 	ldr	r3, [fp, #-16]
1001805c:	e1a01003 	mov	r1, r3
10018060:	e1a03101 	lsl	r3, r1, #2
10018064:	e1a01003 	mov	r1, r3
10018068:	e1a03101 	lsl	r3, r1, #2
1001806c:	e0613003 	rsb	r3, r1, r3
10018070:	e0823003 	add	r3, r2, r3
10018074:	e5933000 	ldr	r3, [r3]
10018078:	e0633000 	rsb	r3, r3, r0
1001807c:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
10018080:	e51b3014 	ldr	r3, [fp, #-20]
10018084:	e3530000 	cmp	r3, #0
10018088:	aa000005 	bge	100180a4 <arm_gic_mask+0xb8>
1001808c:	e30400b0 	movw	r0, #16560	; 0x40b0
10018090:	e3410003 	movt	r0, #4099	; 0x1003
10018094:	e3041168 	movw	r1, #16744	; 0x4168
10018098:	e3411003 	movt	r1, #4099	; 0x1003
1001809c:	e3a0205d 	mov	r2, #93	; 0x5d
100180a0:	ebffef43 	bl	10013db4 <rt_assert_handler>

    GIC_DIST_ENABLE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
100180a4:	e30c2458 	movw	r2, #50264	; 0xc458
100180a8:	e3412003 	movt	r2, #4099	; 0x1003
100180ac:	e51b3010 	ldr	r3, [fp, #-16]
100180b0:	e1a01003 	mov	r1, r3
100180b4:	e1a03101 	lsl	r3, r1, #2
100180b8:	e1a01003 	mov	r1, r3
100180bc:	e1a03101 	lsl	r3, r1, #2
100180c0:	e0613003 	rsb	r3, r1, r3
100180c4:	e0823003 	add	r3, r2, r3
100180c8:	e5932004 	ldr	r2, [r3, #4]
100180cc:	e51b3014 	ldr	r3, [fp, #-20]
100180d0:	e283101f 	add	r1, r3, #31
100180d4:	e3530000 	cmp	r3, #0
100180d8:	b1a03001 	movlt	r3, r1
100180dc:	a1a03003 	movge	r3, r3
100180e0:	e1a032c3 	asr	r3, r3, #5
100180e4:	e1a03103 	lsl	r3, r3, #2
100180e8:	e0823003 	add	r3, r2, r3
100180ec:	e2833d06 	add	r3, r3, #384	; 0x180
100180f0:	e1a02003 	mov	r2, r3
100180f4:	e51b3008 	ldr	r3, [fp, #-8]
100180f8:	e5823000 	str	r3, [r2]
}
100180fc:	e24bd004 	sub	sp, fp, #4
10018100:	e8bd8800 	pop	{fp, pc}

10018104 <arm_gic_set_cpu>:

void arm_gic_set_cpu(rt_uint32_t index, int irq, unsigned int cpumask)
{
10018104:	e92d4800 	push	{fp, lr}
10018108:	e28db004 	add	fp, sp, #4
1001810c:	e24dd018 	sub	sp, sp, #24
10018110:	e50b0010 	str	r0, [fp, #-16]
10018114:	e50b1014 	str	r1, [fp, #-20]
10018118:	e50b2018 	str	r2, [fp, #-24]
    rt_uint32_t old_tgt;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
1001811c:	e51b3010 	ldr	r3, [fp, #-16]
10018120:	e3530000 	cmp	r3, #0
10018124:	0a000005 	beq	10018140 <arm_gic_set_cpu+0x3c>
10018128:	e3040098 	movw	r0, #16536	; 0x4098
1001812c:	e3410003 	movt	r0, #4099	; 0x1003
10018130:	e3041178 	movw	r1, #16760	; 0x4178
10018134:	e3411003 	movt	r1, #4099	; 0x1003
10018138:	e3a02066 	mov	r2, #102	; 0x66
1001813c:	ebffef1c 	bl	10013db4 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
10018140:	e51b0014 	ldr	r0, [fp, #-20]
10018144:	e30c2458 	movw	r2, #50264	; 0xc458
10018148:	e3412003 	movt	r2, #4099	; 0x1003
1001814c:	e51b3010 	ldr	r3, [fp, #-16]
10018150:	e1a01003 	mov	r1, r3
10018154:	e1a03101 	lsl	r3, r1, #2
10018158:	e1a01003 	mov	r1, r3
1001815c:	e1a03101 	lsl	r3, r1, #2
10018160:	e0613003 	rsb	r3, r1, r3
10018164:	e0823003 	add	r3, r2, r3
10018168:	e5933000 	ldr	r3, [r3]
1001816c:	e0633000 	rsb	r3, r3, r0
10018170:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
10018174:	e51b3014 	ldr	r3, [fp, #-20]
10018178:	e3530000 	cmp	r3, #0
1001817c:	aa000005 	bge	10018198 <arm_gic_set_cpu+0x94>
10018180:	e30400b0 	movw	r0, #16560	; 0x40b0
10018184:	e3410003 	movt	r0, #4099	; 0x1003
10018188:	e3041178 	movw	r1, #16760	; 0x4178
1001818c:	e3411003 	movt	r1, #4099	; 0x1003
10018190:	e3a02069 	mov	r2, #105	; 0x69
10018194:	ebffef06 	bl	10013db4 <rt_assert_handler>

    old_tgt = GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq);
10018198:	e30c2458 	movw	r2, #50264	; 0xc458
1001819c:	e3412003 	movt	r2, #4099	; 0x1003
100181a0:	e51b3010 	ldr	r3, [fp, #-16]
100181a4:	e1a01003 	mov	r1, r3
100181a8:	e1a03101 	lsl	r3, r1, #2
100181ac:	e1a01003 	mov	r1, r3
100181b0:	e1a03101 	lsl	r3, r1, #2
100181b4:	e0613003 	rsb	r3, r1, r3
100181b8:	e0823003 	add	r3, r2, r3
100181bc:	e5932004 	ldr	r2, [r3, #4]
100181c0:	e51b3014 	ldr	r3, [fp, #-20]
100181c4:	e2831003 	add	r1, r3, #3
100181c8:	e3530000 	cmp	r3, #0
100181cc:	b1a03001 	movlt	r3, r1
100181d0:	a1a03003 	movge	r3, r3
100181d4:	e1a03143 	asr	r3, r3, #2
100181d8:	e1a03103 	lsl	r3, r3, #2
100181dc:	e0823003 	add	r3, r2, r3
100181e0:	e2833b02 	add	r3, r3, #2048	; 0x800
100181e4:	e5933000 	ldr	r3, [r3]
100181e8:	e50b3008 	str	r3, [fp, #-8]

    old_tgt &= ~(0x0FFUL << ((irq % 4)*8));
100181ec:	e51b2014 	ldr	r2, [fp, #-20]
100181f0:	e1a03fc2 	asr	r3, r2, #31
100181f4:	e1a03f23 	lsr	r3, r3, #30
100181f8:	e0822003 	add	r2, r2, r3
100181fc:	e2022003 	and	r2, r2, #3
10018200:	e0633002 	rsb	r3, r3, r2
10018204:	e1a03183 	lsl	r3, r3, #3
10018208:	e3a020ff 	mov	r2, #255	; 0xff
1001820c:	e1a03312 	lsl	r3, r2, r3
10018210:	e1e03003 	mvn	r3, r3
10018214:	e51b2008 	ldr	r2, [fp, #-8]
10018218:	e0033002 	and	r3, r3, r2
1001821c:	e50b3008 	str	r3, [fp, #-8]
    old_tgt |=   cpumask << ((irq % 4)*8);
10018220:	e51b2014 	ldr	r2, [fp, #-20]
10018224:	e1a03fc2 	asr	r3, r2, #31
10018228:	e1a03f23 	lsr	r3, r3, #30
1001822c:	e0822003 	add	r2, r2, r3
10018230:	e2022003 	and	r2, r2, #3
10018234:	e0633002 	rsb	r3, r3, r2
10018238:	e1a03183 	lsl	r3, r3, #3
1001823c:	e51b2018 	ldr	r2, [fp, #-24]
10018240:	e1a03312 	lsl	r3, r2, r3
10018244:	e51b2008 	ldr	r2, [fp, #-8]
10018248:	e1823003 	orr	r3, r2, r3
1001824c:	e50b3008 	str	r3, [fp, #-8]

    GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq) = old_tgt;
10018250:	e30c2458 	movw	r2, #50264	; 0xc458
10018254:	e3412003 	movt	r2, #4099	; 0x1003
10018258:	e51b3010 	ldr	r3, [fp, #-16]
1001825c:	e1a01003 	mov	r1, r3
10018260:	e1a03101 	lsl	r3, r1, #2
10018264:	e1a01003 	mov	r1, r3
10018268:	e1a03101 	lsl	r3, r1, #2
1001826c:	e0613003 	rsb	r3, r1, r3
10018270:	e0823003 	add	r3, r2, r3
10018274:	e5932004 	ldr	r2, [r3, #4]
10018278:	e51b3014 	ldr	r3, [fp, #-20]
1001827c:	e2831003 	add	r1, r3, #3
10018280:	e3530000 	cmp	r3, #0
10018284:	b1a03001 	movlt	r3, r1
10018288:	a1a03003 	movge	r3, r3
1001828c:	e1a03143 	asr	r3, r3, #2
10018290:	e1a03103 	lsl	r3, r3, #2
10018294:	e0823003 	add	r3, r2, r3
10018298:	e2833b02 	add	r3, r3, #2048	; 0x800
1001829c:	e1a02003 	mov	r2, r3
100182a0:	e51b3008 	ldr	r3, [fp, #-8]
100182a4:	e5823000 	str	r3, [r2]
}
100182a8:	e24bd004 	sub	sp, fp, #4
100182ac:	e8bd8800 	pop	{fp, pc}

100182b0 <arm_gic_umask>:

void arm_gic_umask(rt_uint32_t index, int irq)
{
100182b0:	e92d4800 	push	{fp, lr}
100182b4:	e28db004 	add	fp, sp, #4
100182b8:	e24dd010 	sub	sp, sp, #16
100182bc:	e50b0010 	str	r0, [fp, #-16]
100182c0:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
100182c4:	e51b2014 	ldr	r2, [fp, #-20]
100182c8:	e1a03fc2 	asr	r3, r2, #31
100182cc:	e1a03da3 	lsr	r3, r3, #27
100182d0:	e0822003 	add	r2, r2, r3
100182d4:	e202201f 	and	r2, r2, #31
100182d8:	e0633002 	rsb	r3, r3, r2
100182dc:	e1a02003 	mov	r2, r3
100182e0:	e3a03001 	mov	r3, #1
100182e4:	e1a03213 	lsl	r3, r3, r2
100182e8:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
100182ec:	e51b3010 	ldr	r3, [fp, #-16]
100182f0:	e3530000 	cmp	r3, #0
100182f4:	0a000005 	beq	10018310 <arm_gic_umask+0x60>
100182f8:	e3040098 	movw	r0, #16536	; 0x4098
100182fc:	e3410003 	movt	r0, #4099	; 0x1003
10018300:	e3041188 	movw	r1, #16776	; 0x4188
10018304:	e3411003 	movt	r1, #4099	; 0x1003
10018308:	e3a02077 	mov	r2, #119	; 0x77
1001830c:	ebffeea8 	bl	10013db4 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
10018310:	e51b0014 	ldr	r0, [fp, #-20]
10018314:	e30c2458 	movw	r2, #50264	; 0xc458
10018318:	e3412003 	movt	r2, #4099	; 0x1003
1001831c:	e51b3010 	ldr	r3, [fp, #-16]
10018320:	e1a01003 	mov	r1, r3
10018324:	e1a03101 	lsl	r3, r1, #2
10018328:	e1a01003 	mov	r1, r3
1001832c:	e1a03101 	lsl	r3, r1, #2
10018330:	e0613003 	rsb	r3, r1, r3
10018334:	e0823003 	add	r3, r2, r3
10018338:	e5933000 	ldr	r3, [r3]
1001833c:	e0633000 	rsb	r3, r3, r0
10018340:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
10018344:	e51b3014 	ldr	r3, [fp, #-20]
10018348:	e3530000 	cmp	r3, #0
1001834c:	aa000005 	bge	10018368 <arm_gic_umask+0xb8>
10018350:	e30400b0 	movw	r0, #16560	; 0x40b0
10018354:	e3410003 	movt	r0, #4099	; 0x1003
10018358:	e3041188 	movw	r1, #16776	; 0x4188
1001835c:	e3411003 	movt	r1, #4099	; 0x1003
10018360:	e3a0207a 	mov	r2, #122	; 0x7a
10018364:	ebffee92 	bl	10013db4 <rt_assert_handler>

    GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base, irq) = mask;
10018368:	e30c2458 	movw	r2, #50264	; 0xc458
1001836c:	e3412003 	movt	r2, #4099	; 0x1003
10018370:	e51b3010 	ldr	r3, [fp, #-16]
10018374:	e1a01003 	mov	r1, r3
10018378:	e1a03101 	lsl	r3, r1, #2
1001837c:	e1a01003 	mov	r1, r3
10018380:	e1a03101 	lsl	r3, r1, #2
10018384:	e0613003 	rsb	r3, r1, r3
10018388:	e0823003 	add	r3, r2, r3
1001838c:	e5932004 	ldr	r2, [r3, #4]
10018390:	e51b3014 	ldr	r3, [fp, #-20]
10018394:	e283101f 	add	r1, r3, #31
10018398:	e3530000 	cmp	r3, #0
1001839c:	b1a03001 	movlt	r3, r1
100183a0:	a1a03003 	movge	r3, r3
100183a4:	e1a032c3 	asr	r3, r3, #5
100183a8:	e1a03103 	lsl	r3, r3, #2
100183ac:	e0823003 	add	r3, r2, r3
100183b0:	e2833c01 	add	r3, r3, #256	; 0x100
100183b4:	e1a02003 	mov	r2, r3
100183b8:	e51b3008 	ldr	r3, [fp, #-8]
100183bc:	e5823000 	str	r3, [r2]
}
100183c0:	e24bd004 	sub	sp, fp, #4
100183c4:	e8bd8800 	pop	{fp, pc}

100183c8 <arm_gic_dump_type>:

void arm_gic_dump_type(rt_uint32_t index)
{
100183c8:	e92d4800 	push	{fp, lr}
100183cc:	e28db004 	add	fp, sp, #4
100183d0:	e24dd018 	sub	sp, sp, #24
100183d4:	e50b0010 	str	r0, [fp, #-16]
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
100183d8:	e30c2458 	movw	r2, #50264	; 0xc458
100183dc:	e3412003 	movt	r2, #4099	; 0x1003
100183e0:	e51b3010 	ldr	r3, [fp, #-16]
100183e4:	e1a01003 	mov	r1, r3
100183e8:	e1a03101 	lsl	r3, r1, #2
100183ec:	e1a01003 	mov	r1, r3
100183f0:	e1a03101 	lsl	r3, r1, #2
100183f4:	e0613003 	rsb	r3, r1, r3
100183f8:	e0823003 	add	r3, r2, r3
100183fc:	e5933004 	ldr	r3, [r3, #4]
10018400:	e2833004 	add	r3, r3, #4
10018404:	e5933000 	ldr	r3, [r3]
10018408:	e50b3008 	str	r3, [fp, #-8]
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
1001840c:	e30c2458 	movw	r2, #50264	; 0xc458
10018410:	e3412003 	movt	r2, #4099	; 0x1003
10018414:	e51b3010 	ldr	r3, [fp, #-16]
10018418:	e1a01003 	mov	r1, r3
1001841c:	e1a03101 	lsl	r3, r1, #2
10018420:	e1a01003 	mov	r1, r3
10018424:	e1a03101 	lsl	r3, r1, #2
10018428:	e0613003 	rsb	r3, r1, r3
1001842c:	e0823003 	add	r3, r2, r3
10018430:	e5933004 	ldr	r3, [r3, #4]
10018434:	e2833efe 	add	r3, r3, #4064	; 0xfe0
10018438:	e2833008 	add	r3, r3, #8
1001843c:	e5933000 	ldr	r3, [r3]
10018440:	e1a03223 	lsr	r3, r3, #4
void arm_gic_dump_type(rt_uint32_t index)
{
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
10018444:	e203e00f 	and	lr, r3, #15
10018448:	e30c2458 	movw	r2, #50264	; 0xc458
1001844c:	e3412003 	movt	r2, #4099	; 0x1003
10018450:	e51b3010 	ldr	r3, [fp, #-16]
10018454:	e1a01003 	mov	r1, r3
10018458:	e1a03101 	lsl	r3, r1, #2
1001845c:	e1a01003 	mov	r1, r3
10018460:	e1a03101 	lsl	r3, r1, #2
10018464:	e0613003 	rsb	r3, r1, r3
10018468:	e0823003 	add	r3, r2, r3
1001846c:	e5932004 	ldr	r2, [r3, #4]
10018470:	e30c3464 	movw	r3, #50276	; 0xc464
10018474:	e3413003 	movt	r3, #4099	; 0x1003
10018478:	e593c000 	ldr	ip, [r3]
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
               _gic_table[index].dist_hw_base,
               _gic_max_irq,
               gic_type & (1 << 10) ? "has" : "no",
1001847c:	e51b3008 	ldr	r3, [fp, #-8]
10018480:	e2033b01 	and	r3, r3, #1024	; 0x400
void arm_gic_dump_type(rt_uint32_t index)
{
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
10018484:	e3530000 	cmp	r3, #0
10018488:	0a000002 	beq	10018498 <arm_gic_dump_type+0xd0>
1001848c:	e30430bc 	movw	r3, #16572	; 0x40bc
10018490:	e3413003 	movt	r3, #4099	; 0x1003
10018494:	ea000001 	b	100184a0 <arm_gic_dump_type+0xd8>
10018498:	e30430c0 	movw	r3, #16576	; 0x40c0
1001849c:	e3413003 	movt	r3, #4099	; 0x1003
100184a0:	e58d3000 	str	r3, [sp]
100184a4:	e51b3008 	ldr	r3, [fp, #-8]
100184a8:	e58d3004 	str	r3, [sp, #4]
100184ac:	e30400c4 	movw	r0, #16580	; 0x40c4
100184b0:	e3410003 	movt	r0, #4099	; 0x1003
100184b4:	e1a0100e 	mov	r1, lr
100184b8:	e1a0300c 	mov	r3, ip
100184bc:	ebffed7f 	bl	10013ac0 <rt_kprintf>
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
               _gic_table[index].dist_hw_base,
               _gic_max_irq,
               gic_type & (1 << 10) ? "has" : "no",
               gic_type);
}
100184c0:	e24bd004 	sub	sp, fp, #4
100184c4:	e8bd8800 	pop	{fp, pc}

100184c8 <arm_gic_dist_init>:

int arm_gic_dist_init(rt_uint32_t index, rt_uint32_t dist_base, int irq_start)
{
100184c8:	e92d4800 	push	{fp, lr}
100184cc:	e28db004 	add	fp, sp, #4
100184d0:	e24dd018 	sub	sp, sp, #24
100184d4:	e50b0010 	str	r0, [fp, #-16]
100184d8:	e50b1014 	str	r1, [fp, #-20]
100184dc:	e50b2018 	str	r2, [fp, #-24]
    unsigned int gic_type, i;
    rt_uint32_t cpumask = 3 << 0;
100184e0:	e3a03003 	mov	r3, #3
100184e4:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
100184e8:	e51b3010 	ldr	r3, [fp, #-16]
100184ec:	e3530000 	cmp	r3, #0
100184f0:	0a000005 	beq	1001850c <arm_gic_dist_init+0x44>
100184f4:	e3040098 	movw	r0, #16536	; 0x4098
100184f8:	e3410003 	movt	r0, #4099	; 0x1003
100184fc:	e3041198 	movw	r1, #16792	; 0x4198
10018500:	e3411003 	movt	r1, #4099	; 0x1003
10018504:	e3a02091 	mov	r2, #145	; 0x91
10018508:	ebffee29 	bl	10013db4 <rt_assert_handler>

    _gic_table[index].dist_hw_base = dist_base;
1001850c:	e30c2458 	movw	r2, #50264	; 0xc458
10018510:	e3412003 	movt	r2, #4099	; 0x1003
10018514:	e51b3010 	ldr	r3, [fp, #-16]
10018518:	e1a01003 	mov	r1, r3
1001851c:	e1a03101 	lsl	r3, r1, #2
10018520:	e1a01003 	mov	r1, r3
10018524:	e1a03101 	lsl	r3, r1, #2
10018528:	e0613003 	rsb	r3, r1, r3
1001852c:	e0823003 	add	r3, r2, r3
10018530:	e51b2014 	ldr	r2, [fp, #-20]
10018534:	e5832004 	str	r2, [r3, #4]
    _gic_table[index].offset = irq_start;
10018538:	e51b0018 	ldr	r0, [fp, #-24]
1001853c:	e30c2458 	movw	r2, #50264	; 0xc458
10018540:	e3412003 	movt	r2, #4099	; 0x1003
10018544:	e51b3010 	ldr	r3, [fp, #-16]
10018548:	e1a01003 	mov	r1, r3
1001854c:	e1a03101 	lsl	r3, r1, #2
10018550:	e1a01003 	mov	r1, r3
10018554:	e1a03101 	lsl	r3, r1, #2
10018558:	e0613003 	rsb	r3, r1, r3
1001855c:	e0823003 	add	r3, r2, r3
10018560:	e5830000 	str	r0, [r3]

    /* Find out how many interrupts are supported. */
    gic_type = GIC_DIST_TYPE(dist_base);
10018564:	e51b3014 	ldr	r3, [fp, #-20]
10018568:	e2833004 	add	r3, r3, #4
1001856c:	e5933000 	ldr	r3, [r3]
10018570:	e50b300c 	str	r3, [fp, #-12]
    _gic_max_irq = ((gic_type & 0x1f) + 1) * 32;
10018574:	e51b300c 	ldr	r3, [fp, #-12]
10018578:	e203301f 	and	r3, r3, #31
1001857c:	e2833001 	add	r3, r3, #1
10018580:	e1a02283 	lsl	r2, r3, #5
10018584:	e30c3464 	movw	r3, #50276	; 0xc464
10018588:	e3413003 	movt	r3, #4099	; 0x1003
1001858c:	e5832000 	str	r2, [r3]
    /*
     * The GIC only supports up to 1020 interrupt sources.
     * Limit this to either the architected maximum, or the
     * platform maximum.
     */
    if (_gic_max_irq > 1020)
10018590:	e30c3464 	movw	r3, #50276	; 0xc464
10018594:	e3413003 	movt	r3, #4099	; 0x1003
10018598:	e5933000 	ldr	r3, [r3]
1001859c:	e3530fff 	cmp	r3, #1020	; 0x3fc
100185a0:	9a000003 	bls	100185b4 <arm_gic_dist_init+0xec>
        _gic_max_irq = 1020;
100185a4:	e30c3464 	movw	r3, #50276	; 0xc464
100185a8:	e3413003 	movt	r3, #4099	; 0x1003
100185ac:	e3a02fff 	mov	r2, #1020	; 0x3fc
100185b0:	e5832000 	str	r2, [r3]
    if (_gic_max_irq > ARM_GIC_NR_IRQS)
100185b4:	e30c3464 	movw	r3, #50276	; 0xc464
100185b8:	e3413003 	movt	r3, #4099	; 0x1003
100185bc:	e5933000 	ldr	r3, [r3]
100185c0:	e353005e 	cmp	r3, #94	; 0x5e
100185c4:	9a000003 	bls	100185d8 <arm_gic_dist_init+0x110>
        _gic_max_irq = ARM_GIC_NR_IRQS;
100185c8:	e30c3464 	movw	r3, #50276	; 0xc464
100185cc:	e3413003 	movt	r3, #4099	; 0x1003
100185d0:	e3a0205e 	mov	r2, #94	; 0x5e
100185d4:	e5832000 	str	r2, [r3]

    cpumask |= cpumask << 8;
100185d8:	e51b3008 	ldr	r3, [fp, #-8]
100185dc:	e1a03403 	lsl	r3, r3, #8
100185e0:	e51b2008 	ldr	r2, [fp, #-8]
100185e4:	e1823003 	orr	r3, r2, r3
100185e8:	e50b3008 	str	r3, [fp, #-8]
    cpumask |= cpumask << 16;
100185ec:	e51b3008 	ldr	r3, [fp, #-8]
100185f0:	e1a03803 	lsl	r3, r3, #16
100185f4:	e51b2008 	ldr	r2, [fp, #-8]
100185f8:	e1823003 	orr	r3, r2, r3
100185fc:	e50b3008 	str	r3, [fp, #-8]
    cpumask |= cpumask << 24;
10018600:	e51b3008 	ldr	r3, [fp, #-8]
10018604:	e1a03c03 	lsl	r3, r3, #24
10018608:	e51b2008 	ldr	r2, [fp, #-8]
1001860c:	e1823003 	orr	r3, r2, r3
10018610:	e50b3008 	str	r3, [fp, #-8]

    GIC_DIST_CTRL(dist_base) = 0x0;
10018614:	e51b3014 	ldr	r3, [fp, #-20]
10018618:	e3a02000 	mov	r2, #0
1001861c:	e5832000 	str	r2, [r3]
    /* Disable all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 32)
        GIC_DIST_ENABLE_CLEAR(dist_base, i) = 0xffffffff;
#endif
    /* Set the FIQEn bit, signal FIQ for IGROUP0. */
    GIC_DIST_CTRL(dist_base) = 0x01;
10018620:	e51b3014 	ldr	r3, [fp, #-20]
10018624:	e3a02001 	mov	r2, #1
10018628:	e5832000 	str	r2, [r3]

    return 0;
1001862c:	e3a03000 	mov	r3, #0
}
10018630:	e1a00003 	mov	r0, r3
10018634:	e24bd004 	sub	sp, fp, #4
10018638:	e8bd8800 	pop	{fp, pc}

1001863c <arm_gic_cpu_init>:

int arm_gic_cpu_init(rt_uint32_t index, rt_uint32_t cpu_base)
{
1001863c:	e92d4800 	push	{fp, lr}
10018640:	e28db004 	add	fp, sp, #4
10018644:	e24dd008 	sub	sp, sp, #8
10018648:	e50b0008 	str	r0, [fp, #-8]
1001864c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
10018650:	e51b3008 	ldr	r3, [fp, #-8]
10018654:	e3530000 	cmp	r3, #0
10018658:	0a000005 	beq	10018674 <arm_gic_cpu_init+0x38>
1001865c:	e3040098 	movw	r0, #16536	; 0x4098
10018660:	e3410003 	movt	r0, #4099	; 0x1003
10018664:	e30411ac 	movw	r1, #16812	; 0x41ac
10018668:	e3411003 	movt	r1, #4099	; 0x1003
1001866c:	e3a020c2 	mov	r2, #194	; 0xc2
10018670:	ebffedcf 	bl	10013db4 <rt_assert_handler>

    _gic_table[index].cpu_hw_base = cpu_base;
10018674:	e30c2458 	movw	r2, #50264	; 0xc458
10018678:	e3412003 	movt	r2, #4099	; 0x1003
1001867c:	e51b3008 	ldr	r3, [fp, #-8]
10018680:	e1a01003 	mov	r1, r3
10018684:	e1a03101 	lsl	r3, r1, #2
10018688:	e1a01003 	mov	r1, r3
1001868c:	e1a03101 	lsl	r3, r1, #2
10018690:	e0613003 	rsb	r3, r1, r3
10018694:	e0823003 	add	r3, r2, r3
10018698:	e2833008 	add	r3, r3, #8
1001869c:	e51b200c 	ldr	r2, [fp, #-12]
100186a0:	e5832000 	str	r2, [r3]

    GIC_CPU_PRIMASK(cpu_base) = 0xf0;
100186a4:	e51b300c 	ldr	r3, [fp, #-12]
100186a8:	e2833004 	add	r3, r3, #4
100186ac:	e1a02003 	mov	r2, r3
100186b0:	e3a030f0 	mov	r3, #240	; 0xf0
100186b4:	e5823000 	str	r3, [r2]
    /* Enable CPU interrupt */
    GIC_CPU_CTRL(cpu_base) = 0x01;
100186b8:	e51b300c 	ldr	r3, [fp, #-12]
100186bc:	e3a02001 	mov	r2, #1
100186c0:	e5832000 	str	r2, [r3]

    return 0;
100186c4:	e3a03000 	mov	r3, #0
}
100186c8:	e1a00003 	mov	r0, r3
100186cc:	e24bd004 	sub	sp, fp, #4
100186d0:	e8bd8800 	pop	{fp, pc}

100186d4 <arm_gic_set_group>:

void arm_gic_set_group(rt_uint32_t index, int vector, int group)
{
100186d4:	e92d4800 	push	{fp, lr}
100186d8:	e28db004 	add	fp, sp, #4
100186dc:	e24dd010 	sub	sp, sp, #16
100186e0:	e50b0008 	str	r0, [fp, #-8]
100186e4:	e50b100c 	str	r1, [fp, #-12]
100186e8:	e50b2010 	str	r2, [fp, #-16]
    /* As for GICv2, there are only group0 and group1. */
    RT_ASSERT(group <= 1);
100186ec:	e51b3010 	ldr	r3, [fp, #-16]
100186f0:	e3530001 	cmp	r3, #1
100186f4:	da000005 	ble	10018710 <arm_gic_set_group+0x3c>
100186f8:	e3040100 	movw	r0, #16640	; 0x4100
100186fc:	e3410003 	movt	r0, #4099	; 0x1003
10018700:	e30411c0 	movw	r1, #16832	; 0x41c0
10018704:	e3411003 	movt	r1, #4099	; 0x1003
10018708:	e3a020d0 	mov	r2, #208	; 0xd0
1001870c:	ebffeda8 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(vector < _gic_max_irq);
10018710:	e51b200c 	ldr	r2, [fp, #-12]
10018714:	e30c3464 	movw	r3, #50276	; 0xc464
10018718:	e3413003 	movt	r3, #4099	; 0x1003
1001871c:	e5933000 	ldr	r3, [r3]
10018720:	e1520003 	cmp	r2, r3
10018724:	3a000005 	bcc	10018740 <arm_gic_set_group+0x6c>
10018728:	e304010c 	movw	r0, #16652	; 0x410c
1001872c:	e3410003 	movt	r0, #4099	; 0x1003
10018730:	e30411c0 	movw	r1, #16832	; 0x41c0
10018734:	e3411003 	movt	r1, #4099	; 0x1003
10018738:	e3a020d1 	mov	r2, #209	; 0xd1
1001873c:	ebffed9c 	bl	10013db4 <rt_assert_handler>

    if (group == 0)
10018740:	e51b3010 	ldr	r3, [fp, #-16]
10018744:	e3530000 	cmp	r3, #0
10018748:	1a00002f 	bne	1001880c <arm_gic_set_group+0x138>
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
1001874c:	e30c2458 	movw	r2, #50264	; 0xc458
10018750:	e3412003 	movt	r2, #4099	; 0x1003
10018754:	e51b3008 	ldr	r3, [fp, #-8]
10018758:	e1a01003 	mov	r1, r3
1001875c:	e1a03101 	lsl	r3, r1, #2
10018760:	e1a01003 	mov	r1, r3
10018764:	e1a03101 	lsl	r3, r1, #2
10018768:	e0613003 	rsb	r3, r1, r3
1001876c:	e0823003 	add	r3, r2, r3
10018770:	e5932004 	ldr	r2, [r3, #4]
10018774:	e51b300c 	ldr	r3, [fp, #-12]
10018778:	e283101f 	add	r1, r3, #31
1001877c:	e3530000 	cmp	r3, #0
10018780:	b1a03001 	movlt	r3, r1
10018784:	a1a03003 	movge	r3, r3
10018788:	e1a032c3 	asr	r3, r3, #5
1001878c:	e1a00003 	mov	r0, r3
                        vector) &= ~(1 << (vector % 32));
10018790:	e1a03100 	lsl	r3, r0, #2
10018794:	e0823003 	add	r3, r2, r3
10018798:	e2833080 	add	r3, r3, #128	; 0x80
1001879c:	e1a0c003 	mov	ip, r3
    RT_ASSERT(group <= 1);
    RT_ASSERT(vector < _gic_max_irq);

    if (group == 0)
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
100187a0:	e30c2458 	movw	r2, #50264	; 0xc458
100187a4:	e3412003 	movt	r2, #4099	; 0x1003
100187a8:	e51b3008 	ldr	r3, [fp, #-8]
100187ac:	e1a01003 	mov	r1, r3
100187b0:	e1a03101 	lsl	r3, r1, #2
100187b4:	e1a01003 	mov	r1, r3
100187b8:	e1a03101 	lsl	r3, r1, #2
100187bc:	e0613003 	rsb	r3, r1, r3
100187c0:	e0823003 	add	r3, r2, r3
100187c4:	e5933004 	ldr	r3, [r3, #4]
                        vector) &= ~(1 << (vector % 32));
100187c8:	e1a02100 	lsl	r2, r0, #2
100187cc:	e0833002 	add	r3, r3, r2
100187d0:	e2833080 	add	r3, r3, #128	; 0x80
100187d4:	e5931000 	ldr	r1, [r3]
100187d8:	e51b200c 	ldr	r2, [fp, #-12]
100187dc:	e1a03fc2 	asr	r3, r2, #31
100187e0:	e1a03da3 	lsr	r3, r3, #27
100187e4:	e0822003 	add	r2, r2, r3
100187e8:	e202201f 	and	r2, r2, #31
100187ec:	e0633002 	rsb	r3, r3, r2
100187f0:	e1a02003 	mov	r2, r3
100187f4:	e3a03001 	mov	r3, #1
100187f8:	e1a03213 	lsl	r3, r3, r2
100187fc:	e1e03003 	mvn	r3, r3
10018800:	e0033001 	and	r3, r3, r1
10018804:	e58c3000 	str	r3, [ip]
10018808:	ea000030 	b	100188d0 <arm_gic_set_group+0x1fc>
    }
    else if (group == 1)
1001880c:	e51b3010 	ldr	r3, [fp, #-16]
10018810:	e3530001 	cmp	r3, #1
10018814:	1a00002d 	bne	100188d0 <arm_gic_set_group+0x1fc>
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
10018818:	e30c2458 	movw	r2, #50264	; 0xc458
1001881c:	e3412003 	movt	r2, #4099	; 0x1003
10018820:	e51b3008 	ldr	r3, [fp, #-8]
10018824:	e1a01003 	mov	r1, r3
10018828:	e1a03101 	lsl	r3, r1, #2
1001882c:	e1a01003 	mov	r1, r3
10018830:	e1a03101 	lsl	r3, r1, #2
10018834:	e0613003 	rsb	r3, r1, r3
10018838:	e0823003 	add	r3, r2, r3
1001883c:	e5932004 	ldr	r2, [r3, #4]
10018840:	e51b300c 	ldr	r3, [fp, #-12]
10018844:	e283101f 	add	r1, r3, #31
10018848:	e3530000 	cmp	r3, #0
1001884c:	b1a03001 	movlt	r3, r1
10018850:	a1a03003 	movge	r3, r3
10018854:	e1a032c3 	asr	r3, r3, #5
10018858:	e1a00003 	mov	r0, r3
                        vector) |=  (1 << (vector % 32));
1001885c:	e1a03100 	lsl	r3, r0, #2
10018860:	e0823003 	add	r3, r2, r3
10018864:	e2833080 	add	r3, r3, #128	; 0x80
10018868:	e1a0c003 	mov	ip, r3
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
                        vector) &= ~(1 << (vector % 32));
    }
    else if (group == 1)
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
1001886c:	e30c2458 	movw	r2, #50264	; 0xc458
10018870:	e3412003 	movt	r2, #4099	; 0x1003
10018874:	e51b3008 	ldr	r3, [fp, #-8]
10018878:	e1a01003 	mov	r1, r3
1001887c:	e1a03101 	lsl	r3, r1, #2
10018880:	e1a01003 	mov	r1, r3
10018884:	e1a03101 	lsl	r3, r1, #2
10018888:	e0613003 	rsb	r3, r1, r3
1001888c:	e0823003 	add	r3, r2, r3
10018890:	e5933004 	ldr	r3, [r3, #4]
                        vector) |=  (1 << (vector % 32));
10018894:	e1a02100 	lsl	r2, r0, #2
10018898:	e0833002 	add	r3, r3, r2
1001889c:	e2833080 	add	r3, r3, #128	; 0x80
100188a0:	e5931000 	ldr	r1, [r3]
100188a4:	e51b200c 	ldr	r2, [fp, #-12]
100188a8:	e1a03fc2 	asr	r3, r2, #31
100188ac:	e1a03da3 	lsr	r3, r3, #27
100188b0:	e0822003 	add	r2, r2, r3
100188b4:	e202201f 	and	r2, r2, #31
100188b8:	e0633002 	rsb	r3, r3, r2
100188bc:	e1a02003 	mov	r2, r3
100188c0:	e3a03001 	mov	r3, #1
100188c4:	e1a03213 	lsl	r3, r3, r2
100188c8:	e1813003 	orr	r3, r1, r3
100188cc:	e58c3000 	str	r3, [ip]
    }
}
100188d0:	e24bd004 	sub	sp, fp, #4
100188d4:	e8bd8800 	pop	{fp, pc}

100188d8 <arm_gic_trigger>:

void arm_gic_trigger(rt_uint32_t index, int target_cpu, int irq)
{
100188d8:	e92d4800 	push	{fp, lr}
100188dc:	e28db004 	add	fp, sp, #4
100188e0:	e24dd018 	sub	sp, sp, #24
100188e4:	e50b0010 	str	r0, [fp, #-16]
100188e8:	e50b1014 	str	r1, [fp, #-20]
100188ec:	e50b2018 	str	r2, [fp, #-24]
    unsigned int reg;

    RT_ASSERT(irq <= 15);
100188f0:	e51b3018 	ldr	r3, [fp, #-24]
100188f4:	e353000f 	cmp	r3, #15
100188f8:	da000005 	ble	10018914 <arm_gic_trigger+0x3c>
100188fc:	e3040124 	movw	r0, #16676	; 0x4124
10018900:	e3410003 	movt	r0, #4099	; 0x1003
10018904:	e30411d4 	movw	r1, #16852	; 0x41d4
10018908:	e3411003 	movt	r1, #4099	; 0x1003
1001890c:	e3a020e3 	mov	r2, #227	; 0xe3
10018910:	ebffed27 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(target_cpu <= 255);
10018914:	e51b3014 	ldr	r3, [fp, #-20]
10018918:	e35300ff 	cmp	r3, #255	; 0xff
1001891c:	da000005 	ble	10018938 <arm_gic_trigger+0x60>
10018920:	e3040130 	movw	r0, #16688	; 0x4130
10018924:	e3410003 	movt	r0, #4099	; 0x1003
10018928:	e30411d4 	movw	r1, #16852	; 0x41d4
1001892c:	e3411003 	movt	r1, #4099	; 0x1003
10018930:	e3a020e4 	mov	r2, #228	; 0xe4
10018934:	ebffed1e 	bl	10013db4 <rt_assert_handler>

    reg = (target_cpu << 16) | irq;
10018938:	e51b3014 	ldr	r3, [fp, #-20]
1001893c:	e1a02803 	lsl	r2, r3, #16
10018940:	e51b3018 	ldr	r3, [fp, #-24]
10018944:	e1823003 	orr	r3, r2, r3
10018948:	e50b3008 	str	r3, [fp, #-8]
    GIC_DIST_SOFTINT(_gic_table[index].dist_hw_base) = reg;
1001894c:	e30c2458 	movw	r2, #50264	; 0xc458
10018950:	e3412003 	movt	r2, #4099	; 0x1003
10018954:	e51b3010 	ldr	r3, [fp, #-16]
10018958:	e1a01003 	mov	r1, r3
1001895c:	e1a03101 	lsl	r3, r1, #2
10018960:	e1a01003 	mov	r1, r3
10018964:	e1a03101 	lsl	r3, r1, #2
10018968:	e0613003 	rsb	r3, r1, r3
1001896c:	e0823003 	add	r3, r2, r3
10018970:	e5933004 	ldr	r3, [r3, #4]
10018974:	e2833c0f 	add	r3, r3, #3840	; 0xf00
10018978:	e1a02003 	mov	r2, r3
1001897c:	e51b3008 	ldr	r3, [fp, #-8]
10018980:	e5823000 	str	r3, [r2]
}
10018984:	e24bd004 	sub	sp, fp, #4
10018988:	e8bd8800 	pop	{fp, pc}

1001898c <arm_gic_clear_sgi>:

void arm_gic_clear_sgi(rt_uint32_t index, int target_cpu, int irq)
{
1001898c:	e92d4800 	push	{fp, lr}
10018990:	e28db004 	add	fp, sp, #4
10018994:	e24dd010 	sub	sp, sp, #16
10018998:	e50b0008 	str	r0, [fp, #-8]
1001899c:	e50b100c 	str	r1, [fp, #-12]
100189a0:	e50b2010 	str	r2, [fp, #-16]
    RT_ASSERT(irq <= 15);
100189a4:	e51b3010 	ldr	r3, [fp, #-16]
100189a8:	e353000f 	cmp	r3, #15
100189ac:	da000005 	ble	100189c8 <arm_gic_clear_sgi+0x3c>
100189b0:	e3040124 	movw	r0, #16676	; 0x4124
100189b4:	e3410003 	movt	r0, #4099	; 0x1003
100189b8:	e30411e4 	movw	r1, #16868	; 0x41e4
100189bc:	e3411003 	movt	r1, #4099	; 0x1003
100189c0:	e3a020ec 	mov	r2, #236	; 0xec
100189c4:	ebffecfa 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(target_cpu <= 255);
100189c8:	e51b300c 	ldr	r3, [fp, #-12]
100189cc:	e35300ff 	cmp	r3, #255	; 0xff
100189d0:	da000005 	ble	100189ec <arm_gic_clear_sgi+0x60>
100189d4:	e3040130 	movw	r0, #16688	; 0x4130
100189d8:	e3410003 	movt	r0, #4099	; 0x1003
100189dc:	e30411e4 	movw	r1, #16868	; 0x41e4
100189e0:	e3411003 	movt	r1, #4099	; 0x1003
100189e4:	e3a020ed 	mov	r2, #237	; 0xed
100189e8:	ebffecf1 	bl	10013db4 <rt_assert_handler>

    GIC_DIST_CPENDSGI(_gic_table[index].dist_hw_base, irq) = target_cpu << (irq % 4);
100189ec:	e30c2458 	movw	r2, #50264	; 0xc458
100189f0:	e3412003 	movt	r2, #4099	; 0x1003
100189f4:	e51b3008 	ldr	r3, [fp, #-8]
100189f8:	e1a01003 	mov	r1, r3
100189fc:	e1a03101 	lsl	r3, r1, #2
10018a00:	e1a01003 	mov	r1, r3
10018a04:	e1a03101 	lsl	r3, r1, #2
10018a08:	e0613003 	rsb	r3, r1, r3
10018a0c:	e0823003 	add	r3, r2, r3
10018a10:	e5932004 	ldr	r2, [r3, #4]
10018a14:	e51b3010 	ldr	r3, [fp, #-16]
10018a18:	e2831003 	add	r1, r3, #3
10018a1c:	e3530000 	cmp	r3, #0
10018a20:	b1a03001 	movlt	r3, r1
10018a24:	a1a03003 	movge	r3, r3
10018a28:	e1a03143 	asr	r3, r3, #2
10018a2c:	e1a03103 	lsl	r3, r3, #2
10018a30:	e0823003 	add	r3, r2, r3
10018a34:	e2833ef1 	add	r3, r3, #3856	; 0xf10
10018a38:	e1a01003 	mov	r1, r3
10018a3c:	e51b2010 	ldr	r2, [fp, #-16]
10018a40:	e1a03fc2 	asr	r3, r2, #31
10018a44:	e1a03f23 	lsr	r3, r3, #30
10018a48:	e0822003 	add	r2, r2, r3
10018a4c:	e2022003 	and	r2, r2, #3
10018a50:	e0633002 	rsb	r3, r3, r2
10018a54:	e1a02003 	mov	r2, r3
10018a58:	e51b300c 	ldr	r3, [fp, #-12]
10018a5c:	e1a03213 	lsl	r3, r3, r2
10018a60:	e5813000 	str	r3, [r1]
}
10018a64:	e24bd004 	sub	sp, fp, #4
10018a68:	e8bd8800 	pop	{fp, pc}

10018a6c <rt_hw_interrupt_handle>:
struct rt_irq_desc isr_table[MAX_HANDLERS];
rt_uint32_t rt_interrupt_from_thread, rt_interrupt_to_thread;
rt_uint32_t rt_thread_switch_interrupt_flag;

static void rt_hw_interrupt_handle(int vector, void *param)
{
10018a6c:	e92d4800 	push	{fp, lr}
10018a70:	e28db004 	add	fp, sp, #4
10018a74:	e24dd008 	sub	sp, sp, #8
10018a78:	e50b0008 	str	r0, [fp, #-8]
10018a7c:	e50b100c 	str	r1, [fp, #-12]
    rt_kprintf("Unhandled interrupt %d occured!!!\n", vector);
10018a80:	e30401f8 	movw	r0, #16888	; 0x41f8
10018a84:	e3410003 	movt	r0, #4099	; 0x1003
10018a88:	e51b1008 	ldr	r1, [fp, #-8]
10018a8c:	ebffec0b 	bl	10013ac0 <rt_kprintf>
}
10018a90:	e24bd004 	sub	sp, fp, #4
10018a94:	e8bd8800 	pop	{fp, pc}

10018a98 <rt_hw_vector_init>:

const unsigned int VECTOR_BASE = 0x00;
extern int system_vectors;

static void rt_hw_vector_init(void)
{
10018a98:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018a9c:	e28db000 	add	fp, sp, #0
10018aa0:	e24dd00c 	sub	sp, sp, #12
    int sctrl;
    unsigned int *src = (unsigned int *)&system_vectors;
10018aa4:	e3003000 	movw	r3, #0
10018aa8:	e3413000 	movt	r3, #4096	; 0x1000
10018aac:	e50b3008 	str	r3, [fp, #-8]

    /* C12-C0 is only active when SCTLR.V = 0 */
    asm volatile ("mrc p15, #0, %0, c1, c0, #0"
10018ab0:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
10018ab4:	e50b300c 	str	r3, [fp, #-12]
                  :"=r" (sctrl));
    sctrl &= ~(1 << 13);
10018ab8:	e51b300c 	ldr	r3, [fp, #-12]
10018abc:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
10018ac0:	e50b300c 	str	r3, [fp, #-12]
    asm volatile ("mcr p15, #0, %0, c1, c0, #0"
10018ac4:	e51b300c 	ldr	r3, [fp, #-12]
10018ac8:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
                  :
                  :"r" (sctrl));

    asm volatile ("mcr p15, #0, %0, c12, c0, #0"
10018acc:	e51b3008 	ldr	r3, [fp, #-8]
10018ad0:	ee0c3f10 	mcr	15, 0, r3, cr12, cr0, {0}
                  :
                  :"r" (src));
}
10018ad4:	e24bd000 	sub	sp, fp, #0
10018ad8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018adc:	e12fff1e 	bx	lr

10018ae0 <rt_hw_interrupt_init>:

/**
 * This function will initialize hardware interrupt
 */
void rt_hw_interrupt_init(void)
{
10018ae0:	e92d4818 	push	{r3, r4, fp, lr}
10018ae4:	e28db00c 	add	fp, sp, #12
    register rt_uint32_t idx;

    /* set vector table */
    rt_hw_vector_init();
10018ae8:	ebffffea 	bl	10018a98 <rt_hw_vector_init>

    /* init exceptions table */
    rt_memset(isr_table, 0x00, sizeof(isr_table));
10018aec:	e3020ad8 	movw	r0, #10968	; 0x2ad8
10018af0:	e3410004 	movt	r0, #4100	; 0x1004
10018af4:	e3a01000 	mov	r1, #0
10018af8:	e3002758 	movw	r2, #1880	; 0x758
10018afc:	ebffe5d5 	bl	10012258 <rt_memset>
    for (idx = 0; idx < MAX_HANDLERS; idx++)
10018b00:	e3a04000 	mov	r4, #0
10018b04:	ea00000a 	b	10018b34 <rt_hw_interrupt_init+0x54>
    {
        isr_table[idx].handler = rt_hw_interrupt_handle;
10018b08:	e3022ad8 	movw	r2, #10968	; 0x2ad8
10018b0c:	e3412004 	movt	r2, #4100	; 0x1004
10018b10:	e1a03004 	mov	r3, r4
10018b14:	e1a03103 	lsl	r3, r3, #2
10018b18:	e1a01103 	lsl	r1, r3, #2
10018b1c:	e0833001 	add	r3, r3, r1
10018b20:	e0822003 	add	r2, r2, r3
10018b24:	e3083a6c 	movw	r3, #35436	; 0x8a6c
10018b28:	e3413001 	movt	r3, #4097	; 0x1001
10018b2c:	e5823000 	str	r3, [r2]
    /* set vector table */
    rt_hw_vector_init();

    /* init exceptions table */
    rt_memset(isr_table, 0x00, sizeof(isr_table));
    for (idx = 0; idx < MAX_HANDLERS; idx++)
10018b30:	e2844001 	add	r4, r4, #1
10018b34:	e354005d 	cmp	r4, #93	; 0x5d
10018b38:	9afffff2 	bls	10018b08 <rt_hw_interrupt_init+0x28>
    {
        isr_table[idx].handler = rt_hw_interrupt_handle;
    }
    /* initialize ARM GIC */
    arm_gic_dist_init(0, Zynq7000_GIC_DIST_BASE, 0);
10018b3c:	e3a00000 	mov	r0, #0
10018b40:	e3a01a01 	mov	r1, #4096	; 0x1000
10018b44:	e34f18f0 	movt	r1, #63728	; 0xf8f0
10018b48:	e3a02000 	mov	r2, #0
10018b4c:	ebfffe5d 	bl	100184c8 <arm_gic_dist_init>
    arm_gic_cpu_init(0, Zynq7000_GIC_CPU_BASE);
10018b50:	e3a00000 	mov	r0, #0
10018b54:	e3a01c01 	mov	r1, #256	; 0x100
10018b58:	e34f18f0 	movt	r1, #63728	; 0xf8f0
10018b5c:	ebfffeb6 	bl	1001863c <arm_gic_cpu_init>
    /* init interrupt nest, and context in thread sp */
    rt_interrupt_nest = 0;
10018b60:	e30239a4 	movw	r3, #10660	; 0x29a4
10018b64:	e3413004 	movt	r3, #4100	; 0x1004
10018b68:	e3a02000 	mov	r2, #0
10018b6c:	e5c32000 	strb	r2, [r3]
    rt_interrupt_from_thread = 0;
10018b70:	e3023ad0 	movw	r3, #10960	; 0x2ad0
10018b74:	e3413004 	movt	r3, #4100	; 0x1004
10018b78:	e3a02000 	mov	r2, #0
10018b7c:	e5832000 	str	r2, [r3]
    rt_interrupt_to_thread = 0;
10018b80:	e3023acc 	movw	r3, #10956	; 0x2acc
10018b84:	e3413004 	movt	r3, #4100	; 0x1004
10018b88:	e3a02000 	mov	r2, #0
10018b8c:	e5832000 	str	r2, [r3]
    rt_thread_switch_interrupt_flag = 0;
10018b90:	e3023ad4 	movw	r3, #10964	; 0x2ad4
10018b94:	e3413004 	movt	r3, #4100	; 0x1004
10018b98:	e3a02000 	mov	r2, #0
10018b9c:	e5832000 	str	r2, [r3]
}
10018ba0:	e8bd8818 	pop	{r3, r4, fp, pc}

10018ba4 <rt_hw_interrupt_mask>:
/**
 * This function will mask a interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_mask(int vector)
{
10018ba4:	e92d4800 	push	{fp, lr}
10018ba8:	e28db004 	add	fp, sp, #4
10018bac:	e24dd008 	sub	sp, sp, #8
10018bb0:	e50b0008 	str	r0, [fp, #-8]
    arm_gic_mask(0, vector);
10018bb4:	e3a00000 	mov	r0, #0
10018bb8:	e51b1008 	ldr	r1, [fp, #-8]
10018bbc:	ebfffd0a 	bl	10017fec <arm_gic_mask>
}
10018bc0:	e24bd004 	sub	sp, fp, #4
10018bc4:	e8bd8800 	pop	{fp, pc}

10018bc8 <rt_hw_interrupt_umask>:
/**
 * This function will un-mask a interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_umask(int vector)
{
10018bc8:	e92d4800 	push	{fp, lr}
10018bcc:	e28db004 	add	fp, sp, #4
10018bd0:	e24dd008 	sub	sp, sp, #8
10018bd4:	e50b0008 	str	r0, [fp, #-8]
    arm_gic_umask(0, vector);
10018bd8:	e3a00000 	mov	r0, #0
10018bdc:	e51b1008 	ldr	r1, [fp, #-8]
10018be0:	ebfffdb2 	bl	100182b0 <arm_gic_umask>
}
10018be4:	e24bd004 	sub	sp, fp, #4
10018be8:	e8bd8800 	pop	{fp, pc}

10018bec <rt_hw_interrupt_install>:
 * @param new_handler the interrupt service routine to be installed
 * @param old_handler the old interrupt service routine
 */
rt_isr_handler_t rt_hw_interrupt_install(int vector, rt_isr_handler_t handler,
        void *param, char *name)
{
10018bec:	e92d4800 	push	{fp, lr}
10018bf0:	e28db004 	add	fp, sp, #4
10018bf4:	e24dd018 	sub	sp, sp, #24
10018bf8:	e50b0010 	str	r0, [fp, #-16]
10018bfc:	e50b1014 	str	r1, [fp, #-20]
10018c00:	e50b2018 	str	r2, [fp, #-24]
10018c04:	e50b301c 	str	r3, [fp, #-28]
    rt_isr_handler_t old_handler = RT_NULL;
10018c08:	e3a03000 	mov	r3, #0
10018c0c:	e50b3008 	str	r3, [fp, #-8]

    if (vector < MAX_HANDLERS)
10018c10:	e51b3010 	ldr	r3, [fp, #-16]
10018c14:	e353005d 	cmp	r3, #93	; 0x5d
10018c18:	ca000032 	bgt	10018ce8 <rt_hw_interrupt_install+0xfc>
    {
        old_handler = isr_table[vector].handler;
10018c1c:	e3022ad8 	movw	r2, #10968	; 0x2ad8
10018c20:	e3412004 	movt	r2, #4100	; 0x1004
10018c24:	e51b3010 	ldr	r3, [fp, #-16]
10018c28:	e1a03103 	lsl	r3, r3, #2
10018c2c:	e1a01103 	lsl	r1, r3, #2
10018c30:	e0833001 	add	r3, r3, r1
10018c34:	e0823003 	add	r3, r2, r3
10018c38:	e5933000 	ldr	r3, [r3]
10018c3c:	e50b3008 	str	r3, [fp, #-8]

        if (handler != RT_NULL)
10018c40:	e51b3014 	ldr	r3, [fp, #-20]
10018c44:	e3530000 	cmp	r3, #0
10018c48:	0a00001d 	beq	10018cc4 <rt_hw_interrupt_install+0xd8>
        {
#ifdef RT_USING_INTERRUPT_INFO
            rt_strncpy(isr_table[vector].name, name, RT_NAME_MAX);
10018c4c:	e51b3010 	ldr	r3, [fp, #-16]
10018c50:	e1a03103 	lsl	r3, r3, #2
10018c54:	e1a02103 	lsl	r2, r3, #2
10018c58:	e0833002 	add	r3, r3, r2
10018c5c:	e2832008 	add	r2, r3, #8
10018c60:	e3023ad8 	movw	r3, #10968	; 0x2ad8
10018c64:	e3413004 	movt	r3, #4100	; 0x1004
10018c68:	e0823003 	add	r3, r2, r3
10018c6c:	e1a00003 	mov	r0, r3
10018c70:	e51b101c 	ldr	r1, [fp, #-28]
10018c74:	e3a02006 	mov	r2, #6
10018c78:	ebffe6f7 	bl	1001285c <rt_strncpy>
#endif /* RT_USING_INTERRUPT_INFO */
            isr_table[vector].handler = handler;
10018c7c:	e3022ad8 	movw	r2, #10968	; 0x2ad8
10018c80:	e3412004 	movt	r2, #4100	; 0x1004
10018c84:	e51b3010 	ldr	r3, [fp, #-16]
10018c88:	e1a03103 	lsl	r3, r3, #2
10018c8c:	e1a01103 	lsl	r1, r3, #2
10018c90:	e0833001 	add	r3, r3, r1
10018c94:	e0823003 	add	r3, r2, r3
10018c98:	e51b2014 	ldr	r2, [fp, #-20]
10018c9c:	e5832000 	str	r2, [r3]
            isr_table[vector].param = param;
10018ca0:	e3022ad8 	movw	r2, #10968	; 0x2ad8
10018ca4:	e3412004 	movt	r2, #4100	; 0x1004
10018ca8:	e51b3010 	ldr	r3, [fp, #-16]
10018cac:	e1a03103 	lsl	r3, r3, #2
10018cb0:	e1a01103 	lsl	r1, r3, #2
10018cb4:	e0833001 	add	r3, r3, r1
10018cb8:	e0823003 	add	r3, r2, r3
10018cbc:	e51b2018 	ldr	r2, [fp, #-24]
10018cc0:	e5832004 	str	r2, [r3, #4]
        }
        /* set the interrupt to this cpu */
        arm_gic_set_cpu(0, vector, 1 << rt_cpu_get_smp_id());
10018cc4:	eb00027f 	bl	100196c8 <rt_cpu_get_smp_id>
10018cc8:	e1a03000 	mov	r3, r0
10018ccc:	e1a02003 	mov	r2, r3
10018cd0:	e3a03001 	mov	r3, #1
10018cd4:	e1a03213 	lsl	r3, r3, r2
10018cd8:	e3a00000 	mov	r0, #0
10018cdc:	e51b1010 	ldr	r1, [fp, #-16]
10018ce0:	e1a02003 	mov	r2, r3
10018ce4:	ebfffd06 	bl	10018104 <arm_gic_set_cpu>
    }

    return old_handler;
10018ce8:	e51b3008 	ldr	r3, [fp, #-8]
}
10018cec:	e1a00003 	mov	r0, r3
10018cf0:	e24bd004 	sub	sp, fp, #4
10018cf4:	e8bd8800 	pop	{fp, pc}

10018cf8 <rt_hw_interrupt_clear>:

void rt_hw_interrupt_clear(int vector)
{
10018cf8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018cfc:	e28db000 	add	fp, sp, #0
10018d00:	e24dd00c 	sub	sp, sp, #12
10018d04:	e50b0008 	str	r0, [fp, #-8]
    /* SGI will be cleared automatically. */
    if (vector < 16)
10018d08:	e51b3008 	ldr	r3, [fp, #-8]
10018d0c:	e353000f 	cmp	r3, #15
10018d10:	ca000000 	bgt	10018d18 <rt_hw_interrupt_clear+0x20>
        return;
10018d14:	e1a00000 	nop			; (mov r0, r0)
}
10018d18:	e24bd000 	sub	sp, fp, #0
10018d1c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018d20:	e12fff1e 	bx	lr

10018d24 <rt_hw_cpu_dump_page_table>:
#define RW_NCNBXN      (AP_RW|DOMAIN0|NCNB|DESC_SEC|XN)
/* Read/Write without cache and write buffer */
#define RW_FAULT       (AP_RW|DOMAIN1|NCNB|DESC_SEC)

void rt_hw_cpu_dump_page_table(rt_uint32_t *ptb)
{
10018d24:	e92d4800 	push	{fp, lr}
10018d28:	e28db004 	add	fp, sp, #4
10018d2c:	e24dd020 	sub	sp, sp, #32
10018d30:	e50b0018 	str	r0, [fp, #-24]
    int i;
    int fcnt = 0;
10018d34:	e3a03000 	mov	r3, #0
10018d38:	e50b300c 	str	r3, [fp, #-12]

    rt_kprintf("page table@%p\n", ptb);
10018d3c:	e3040220 	movw	r0, #16928	; 0x4220
10018d40:	e3410003 	movt	r0, #4099	; 0x1003
10018d44:	e51b1018 	ldr	r1, [fp, #-24]
10018d48:	ebffeb5c 	bl	10013ac0 <rt_kprintf>
    for (i = 0; i < 1024*4; i++)
10018d4c:	e3a03000 	mov	r3, #0
10018d50:	e50b3008 	str	r3, [fp, #-8]
10018d54:	ea00007d 	b	10018f50 <rt_hw_cpu_dump_page_table+0x22c>
    {
        rt_uint32_t pte1 = ptb[i];
10018d58:	e51b3008 	ldr	r3, [fp, #-8]
10018d5c:	e1a03103 	lsl	r3, r3, #2
10018d60:	e51b2018 	ldr	r2, [fp, #-24]
10018d64:	e0823003 	add	r3, r2, r3
10018d68:	e5933000 	ldr	r3, [r3]
10018d6c:	e50b3010 	str	r3, [fp, #-16]
        if ((pte1 & 0x3) == 0)
10018d70:	e51b3010 	ldr	r3, [fp, #-16]
10018d74:	e2033003 	and	r3, r3, #3
10018d78:	e3530000 	cmp	r3, #0
10018d7c:	1a000010 	bne	10018dc4 <rt_hw_cpu_dump_page_table+0xa0>
        {
            rt_kprintf("%03x: ", i);
10018d80:	e3040230 	movw	r0, #16944	; 0x4230
10018d84:	e3410003 	movt	r0, #4099	; 0x1003
10018d88:	e51b1008 	ldr	r1, [fp, #-8]
10018d8c:	ebffeb4b 	bl	10013ac0 <rt_kprintf>
            fcnt++;
10018d90:	e51b300c 	ldr	r3, [fp, #-12]
10018d94:	e2833001 	add	r3, r3, #1
10018d98:	e50b300c 	str	r3, [fp, #-12]
            if (fcnt == 16)
10018d9c:	e51b300c 	ldr	r3, [fp, #-12]
10018da0:	e3530010 	cmp	r3, #16
10018da4:	1a000005 	bne	10018dc0 <rt_hw_cpu_dump_page_table+0x9c>
            {
                rt_kprintf("fault\n");
10018da8:	e3040238 	movw	r0, #16952	; 0x4238
10018dac:	e3410003 	movt	r0, #4099	; 0x1003
10018db0:	ebffeb42 	bl	10013ac0 <rt_kprintf>
                fcnt = 0;
10018db4:	e3a03000 	mov	r3, #0
10018db8:	e50b300c 	str	r3, [fp, #-12]
            }
            continue;
10018dbc:	ea000060 	b	10018f44 <rt_hw_cpu_dump_page_table+0x220>
10018dc0:	ea00005f 	b	10018f44 <rt_hw_cpu_dump_page_table+0x220>
        }
        if (fcnt != 0)
10018dc4:	e51b300c 	ldr	r3, [fp, #-12]
10018dc8:	e3530000 	cmp	r3, #0
10018dcc:	0a000004 	beq	10018de4 <rt_hw_cpu_dump_page_table+0xc0>
        {
            rt_kprintf("fault\n");
10018dd0:	e3040238 	movw	r0, #16952	; 0x4238
10018dd4:	e3410003 	movt	r0, #4099	; 0x1003
10018dd8:	ebffeb38 	bl	10013ac0 <rt_kprintf>
            fcnt = 0;
10018ddc:	e3a03000 	mov	r3, #0
10018de0:	e50b300c 	str	r3, [fp, #-12]
        }

        rt_kprintf("%03x: %08x: ", i, pte1);
10018de4:	e3040240 	movw	r0, #16960	; 0x4240
10018de8:	e3410003 	movt	r0, #4099	; 0x1003
10018dec:	e51b1008 	ldr	r1, [fp, #-8]
10018df0:	e51b2010 	ldr	r2, [fp, #-16]
10018df4:	ebffeb31 	bl	10013ac0 <rt_kprintf>
        if ((pte1 & 0x3) == 0x3)
10018df8:	e51b3010 	ldr	r3, [fp, #-16]
10018dfc:	e2033003 	and	r3, r3, #3
10018e00:	e3530003 	cmp	r3, #3
10018e04:	1a000003 	bne	10018e18 <rt_hw_cpu_dump_page_table+0xf4>
        {
            rt_kprintf("LPAE\n");
10018e08:	e3040250 	movw	r0, #16976	; 0x4250
10018e0c:	e3410003 	movt	r0, #4099	; 0x1003
10018e10:	ebffeb2a 	bl	10013ac0 <rt_kprintf>
10018e14:	ea00004a 	b	10018f44 <rt_hw_cpu_dump_page_table+0x220>
        }
        else if ((pte1 & 0x3) == 0x1)
10018e18:	e51b3010 	ldr	r3, [fp, #-16]
10018e1c:	e2033003 	and	r3, r3, #3
10018e20:	e3530001 	cmp	r3, #1
10018e24:	1a00000b 	bne	10018e58 <rt_hw_cpu_dump_page_table+0x134>
        {
            rt_kprintf("pte,ns:%d,domain:%d\n",
                       (pte1 >> 3) & 0x1, (pte1 >> 5) & 0xf);
10018e28:	e51b3010 	ldr	r3, [fp, #-16]
10018e2c:	e1a031a3 	lsr	r3, r3, #3
        {
            rt_kprintf("LPAE\n");
        }
        else if ((pte1 & 0x3) == 0x1)
        {
            rt_kprintf("pte,ns:%d,domain:%d\n",
10018e30:	e2032001 	and	r2, r3, #1
                       (pte1 >> 3) & 0x1, (pte1 >> 5) & 0xf);
10018e34:	e51b3010 	ldr	r3, [fp, #-16]
10018e38:	e1a032a3 	lsr	r3, r3, #5
        {
            rt_kprintf("LPAE\n");
        }
        else if ((pte1 & 0x3) == 0x1)
        {
            rt_kprintf("pte,ns:%d,domain:%d\n",
10018e3c:	e203300f 	and	r3, r3, #15
10018e40:	e3040258 	movw	r0, #16984	; 0x4258
10018e44:	e3410003 	movt	r0, #4099	; 0x1003
10018e48:	e1a01002 	mov	r1, r2
10018e4c:	e1a02003 	mov	r2, r3
10018e50:	ebffeb1a 	bl	10013ac0 <rt_kprintf>
10018e54:	ea00003a 	b	10018f44 <rt_hw_cpu_dump_page_table+0x220>
            /*
             *rt_hw_cpu_dump_page_table_2nd((void*)((pte1 & 0xfffffc000)
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
10018e58:	e51b3010 	ldr	r3, [fp, #-16]
10018e5c:	e2033701 	and	r3, r3, #262144	; 0x40000
10018e60:	e3530000 	cmp	r3, #0
10018e64:	0a000018 	beq	10018ecc <rt_hw_cpu_dump_page_table+0x1a8>
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
                       (pte1 >> 19) & 0x1,
10018e68:	e51b3010 	ldr	r3, [fp, #-16]
10018e6c:	e1a039a3 	lsr	r3, r3, #19
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
10018e70:	e2031001 	and	r1, r3, #1
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
10018e74:	e51b3010 	ldr	r3, [fp, #-16]
10018e78:	e1a026a3 	lsr	r2, r3, #13
10018e7c:	e51b3010 	ldr	r3, [fp, #-16]
10018e80:	e1a03523 	lsr	r3, r3, #10
10018e84:	e1823003 	orr	r3, r2, r3
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
10018e88:	e203e00f 	and	lr, r3, #15
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
10018e8c:	e51b3010 	ldr	r3, [fp, #-16]
10018e90:	e1a03223 	lsr	r3, r3, #4
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
10018e94:	e203c001 	and	ip, r3, #1
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
10018e98:	e51b3010 	ldr	r3, [fp, #-16]
10018e9c:	e1a02523 	lsr	r2, r3, #10
10018ea0:	e51b3010 	ldr	r3, [fp, #-16]
10018ea4:	e1a03123 	lsr	r3, r3, #2
10018ea8:	e1823003 	orr	r3, r2, r3
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
10018eac:	e203301f 	and	r3, r3, #31
10018eb0:	e58d3000 	str	r3, [sp]
10018eb4:	e3040270 	movw	r0, #17008	; 0x4270
10018eb8:	e3410003 	movt	r0, #4099	; 0x1003
10018ebc:	e1a0200e 	mov	r2, lr
10018ec0:	e1a0300c 	mov	r3, ip
10018ec4:	ebffeafd 	bl	10013ac0 <rt_kprintf>
10018ec8:	ea00001d 	b	10018f44 <rt_hw_cpu_dump_page_table+0x220>
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
10018ecc:	e51b3010 	ldr	r3, [fp, #-16]
10018ed0:	e1a039a3 	lsr	r3, r3, #19
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
10018ed4:	e2031001 	and	r1, r3, #1
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
10018ed8:	e51b3010 	ldr	r3, [fp, #-16]
10018edc:	e1a026a3 	lsr	r2, r3, #13
10018ee0:	e51b3010 	ldr	r3, [fp, #-16]
10018ee4:	e1a03523 	lsr	r3, r3, #10
10018ee8:	e1823003 	orr	r3, r2, r3
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
10018eec:	e203e00f 	and	lr, r3, #15
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
10018ef0:	e51b3010 	ldr	r3, [fp, #-16]
10018ef4:	e1a03223 	lsr	r3, r3, #4
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
10018ef8:	e203c001 	and	ip, r3, #1
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
                       (((pte1 & (0x7 << 12)) >> 10) |
10018efc:	e51b3010 	ldr	r3, [fp, #-16]
10018f00:	e2033a07 	and	r3, r3, #28672	; 0x7000
10018f04:	e1a02523 	lsr	r2, r3, #10
                        ((pte1 &        0x0c) >>  2)) & 0x1f,
10018f08:	e51b3010 	ldr	r3, [fp, #-16]
10018f0c:	e203300c 	and	r3, r3, #12
10018f10:	e1a03123 	lsr	r3, r3, #2
            rt_kprintf("section,ns:%d,ap:%x,"
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
                       (((pte1 & (0x7 << 12)) >> 10) |
10018f14:	e1823003 	orr	r3, r2, r3
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
10018f18:	e203201f 	and	r2, r3, #31
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
                       (((pte1 & (0x7 << 12)) >> 10) |
                        ((pte1 &        0x0c) >>  2)) & 0x1f,
                       (pte1 >> 5) & 0xf);
10018f1c:	e51b3010 	ldr	r3, [fp, #-16]
10018f20:	e1a032a3 	lsr	r3, r3, #5
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
10018f24:	e203300f 	and	r3, r3, #15
10018f28:	e58d2000 	str	r2, [sp]
10018f2c:	e58d3004 	str	r3, [sp, #4]
10018f30:	e304029c 	movw	r0, #17052	; 0x429c
10018f34:	e3410003 	movt	r0, #4099	; 0x1003
10018f38:	e1a0200e 	mov	r2, lr
10018f3c:	e1a0300c 	mov	r3, ip
10018f40:	ebffeade 	bl	10013ac0 <rt_kprintf>
{
    int i;
    int fcnt = 0;

    rt_kprintf("page table@%p\n", ptb);
    for (i = 0; i < 1024*4; i++)
10018f44:	e51b3008 	ldr	r3, [fp, #-8]
10018f48:	e2833001 	add	r3, r3, #1
10018f4c:	e50b3008 	str	r3, [fp, #-8]
10018f50:	e51b3008 	ldr	r3, [fp, #-8]
10018f54:	e3530a01 	cmp	r3, #4096	; 0x1000
10018f58:	baffff7e 	blt	10018d58 <rt_hw_cpu_dump_page_table+0x34>
                       (((pte1 & (0x7 << 12)) >> 10) |
                        ((pte1 &        0x0c) >>  2)) & 0x1f,
                       (pte1 >> 5) & 0xf);
        }
    }
}
10018f5c:	e24bd004 	sub	sp, fp, #4
10018f60:	e8bd8800 	pop	{fp, pc}

10018f64 <rt_hw_mmu_setmtt>:
volatile unsigned long MMUTable[4*1024] SECTION("mmu_tbl") __attribute__((aligned(16*1024)));
void rt_hw_mmu_setmtt(rt_uint32_t vaddrStart,
                      rt_uint32_t vaddrEnd,
                      rt_uint32_t paddrStart,
                      rt_uint32_t attr)
{
10018f64:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018f68:	e28db000 	add	fp, sp, #0
10018f6c:	e24dd024 	sub	sp, sp, #36	; 0x24
10018f70:	e50b0018 	str	r0, [fp, #-24]
10018f74:	e50b101c 	str	r1, [fp, #-28]
10018f78:	e50b2020 	str	r2, [fp, #-32]
10018f7c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    volatile rt_uint32_t *pTT;
    volatile int i, nSec;
    pTT  = (rt_uint32_t *)MMUTable + (vaddrStart >> 20);
10018f80:	e51b3018 	ldr	r3, [fp, #-24]
10018f84:	e1a03a23 	lsr	r3, r3, #20
10018f88:	e1a02103 	lsl	r2, r3, #2
10018f8c:	e3083000 	movw	r3, #32768	; 0x8000
10018f90:	e3413003 	movt	r3, #4099	; 0x1003
10018f94:	e0823003 	add	r3, r2, r3
10018f98:	e50b3008 	str	r3, [fp, #-8]
    nSec = (vaddrEnd >> 20) - (vaddrStart >> 20);
10018f9c:	e51b301c 	ldr	r3, [fp, #-28]
10018fa0:	e1a02a23 	lsr	r2, r3, #20
10018fa4:	e51b3018 	ldr	r3, [fp, #-24]
10018fa8:	e1a03a23 	lsr	r3, r3, #20
10018fac:	e0633002 	rsb	r3, r3, r2
10018fb0:	e50b3010 	str	r3, [fp, #-16]
    for(i = 0; i <= nSec; i++)
10018fb4:	e3a03000 	mov	r3, #0
10018fb8:	e50b300c 	str	r3, [fp, #-12]
10018fbc:	ea00000e 	b	10018ffc <rt_hw_mmu_setmtt+0x98>
    {
        *pTT = attr | (((paddrStart >> 20) + i) << 20);
10018fc0:	e51b3020 	ldr	r3, [fp, #-32]
10018fc4:	e1a03a23 	lsr	r3, r3, #20
10018fc8:	e51b200c 	ldr	r2, [fp, #-12]
10018fcc:	e0833002 	add	r3, r3, r2
10018fd0:	e1a02a03 	lsl	r2, r3, #20
10018fd4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10018fd8:	e1822003 	orr	r2, r2, r3
10018fdc:	e51b3008 	ldr	r3, [fp, #-8]
10018fe0:	e5832000 	str	r2, [r3]
        pTT++;
10018fe4:	e51b3008 	ldr	r3, [fp, #-8]
10018fe8:	e2833004 	add	r3, r3, #4
10018fec:	e50b3008 	str	r3, [fp, #-8]
{
    volatile rt_uint32_t *pTT;
    volatile int i, nSec;
    pTT  = (rt_uint32_t *)MMUTable + (vaddrStart >> 20);
    nSec = (vaddrEnd >> 20) - (vaddrStart >> 20);
    for(i = 0; i <= nSec; i++)
10018ff0:	e51b300c 	ldr	r3, [fp, #-12]
10018ff4:	e2833001 	add	r3, r3, #1
10018ff8:	e50b300c 	str	r3, [fp, #-12]
10018ffc:	e51b200c 	ldr	r2, [fp, #-12]
10019000:	e51b3010 	ldr	r3, [fp, #-16]
10019004:	e1520003 	cmp	r2, r3
10019008:	daffffec 	ble	10018fc0 <rt_hw_mmu_setmtt+0x5c>
    {
        *pTT = attr | (((paddrStart >> 20) + i) << 20);
        pTT++;
    }
}
1001900c:	e24bd000 	sub	sp, fp, #0
10019010:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019014:	e12fff1e 	bx	lr

10019018 <rt_hw_set_domain_register>:

unsigned long rt_hw_set_domain_register(unsigned long domain_val)
{
10019018:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001901c:	e28db000 	add	fp, sp, #0
10019020:	e24dd014 	sub	sp, sp, #20
10019024:	e50b0010 	str	r0, [fp, #-16]
    unsigned long old_domain;

    asm volatile ("mrc p15, 0, %0, c3, c0\n" : "=r" (old_domain));
10019028:	ee133f10 	mrc	15, 0, r3, cr3, cr0, {0}
1001902c:	e50b3008 	str	r3, [fp, #-8]
    asm volatile ("mcr p15, 0, %0, c3, c0\n" : :"r" (domain_val) : "memory");
10019030:	e51b3010 	ldr	r3, [fp, #-16]
10019034:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}

    return old_domain;
10019038:	e51b3008 	ldr	r3, [fp, #-8]
}
1001903c:	e1a00003 	mov	r0, r3
10019040:	e24bd000 	sub	sp, fp, #0
10019044:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019048:	e12fff1e 	bx	lr

1001904c <rt_hw_mmu_init>:

void rt_hw_mmu_init(void)
{
1001904c:	e92d4800 	push	{fp, lr}
10019050:	e28db004 	add	fp, sp, #4
    extern rt_uint32_t __text_start;
    rt_hw_cpu_dcache_disable();
10019054:	eb0001cf 	bl	10019798 <rt_hw_cpu_dcache_disable>
    rt_hw_cpu_icache_disable();
10019058:	eb0001d5 	bl	100197b4 <rt_hw_cpu_icache_disable>
    rt_cpu_mmu_disable();
1001905c:	eb0001d8 	bl	100197c4 <rt_cpu_mmu_disable>

    /* set page table */
    /* no access to the memory below .text */
    /* 128M cached DDR memory */
    rt_hw_mmu_setmtt((rt_uint32_t)&__text_start, 0x20000000-1,
10019060:	e3003000 	movw	r3, #0
10019064:	e3413000 	movt	r3, #4096	; 0x1000
10019068:	e1a00003 	mov	r0, r3
1001906c:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
10019070:	e3a02201 	mov	r2, #268435456	; 0x10000000
10019074:	e3003c0e 	movw	r3, #3086	; 0xc0e
10019078:	ebffffb9 	bl	10018f64 <rt_hw_mmu_setmtt>
                     0x10000000, RW_CB);
    /* PL region */
    rt_hw_mmu_setmtt(0x40000000, 0xBFFFFFFF, 0x40000000, RW_NCNBXN);
1001907c:	e3a00101 	mov	r0, #1073741824	; 0x40000000
10019080:	e3e01101 	mvn	r1, #1073741824	; 0x40000000
10019084:	e3a02101 	mov	r2, #1073741824	; 0x40000000
10019088:	e3003c12 	movw	r3, #3090	; 0xc12
1001908c:	ebffffb4 	bl	10018f64 <rt_hw_mmu_setmtt>
    /* IOP registers */
    rt_hw_mmu_setmtt(0xE0000000, 0xE02FFFFF, 0xE0000000, RW_NCNBXN);
10019090:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
10019094:	e30f1fff 	movw	r1, #65535	; 0xffff
10019098:	e34e102f 	movt	r1, #57391	; 0xe02f
1001909c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
100190a0:	e3003c12 	movw	r3, #3090	; 0xc12
100190a4:	ebffffae 	bl	10018f64 <rt_hw_mmu_setmtt>
    /* no access to the SMC memory(enable it if you want) */
    /* SLCR, PS and CPU private registers, note we map more memory space as the
     * entry is 1MB in size. */
    rt_hw_mmu_setmtt(0xF8000000, 0xF8FFFFFF, 0xF8000000, RW_NCNBXN);
100190a8:	e3a0033e 	mov	r0, #-134217728	; 0xf8000000
100190ac:	e3e01407 	mvn	r1, #117440512	; 0x7000000
100190b0:	e3a0233e 	mov	r2, #-134217728	; 0xf8000000
100190b4:	e3003c12 	movw	r3, #3090	; 0xc12
100190b8:	ebffffa9 	bl	10018f64 <rt_hw_mmu_setmtt>
	/*set  the ocm by long_he*/
	rt_hw_mmu_setmtt(0xFFFF0000, 0xFFFFFFFF, 0xFFFF0000, RW_NCNB);
100190bc:	e3a00000 	mov	r0, #0
100190c0:	e34f0fff 	movt	r0, #65535	; 0xffff
100190c4:	e3e01000 	mvn	r1, #0
100190c8:	e3a02000 	mov	r2, #0
100190cc:	e34f2fff 	movt	r2, #65535	; 0xffff
100190d0:	e3003c02 	movw	r3, #3074	; 0xc02
100190d4:	ebffffa2 	bl	10018f64 <rt_hw_mmu_setmtt>

    /*rt_hw_cpu_dump_page_table(MMUTable);*/

    /* become clients for all domains */
    rt_hw_set_domain_register(0x55555555);
100190d8:	e3050555 	movw	r0, #21845	; 0x5555
100190dc:	e3450555 	movt	r0, #21845	; 0x5555
100190e0:	ebffffcc 	bl	10019018 <rt_hw_set_domain_register>

    rt_cpu_tlb_set(MMUTable);
100190e4:	e3080000 	movw	r0, #32768	; 0x8000
100190e8:	e3410003 	movt	r0, #4099	; 0x1003
100190ec:	eb0001bf 	bl	100197f0 <rt_cpu_tlb_set>

    rt_cpu_mmu_enable();
100190f0:	eb0001b9 	bl	100197dc <rt_cpu_mmu_enable>

    rt_hw_cpu_icache_enable();
100190f4:	eb00017c 	bl	100196ec <rt_hw_cpu_icache_enable>
    rt_hw_cpu_dcache_enable();
100190f8:	eb000177 	bl	100196dc <rt_hw_cpu_dcache_enable>
}
100190fc:	e8bd8800 	pop	{fp, pc}

10019100 <rt_hw_stack_init>:
 *
 * @return stack address
 */
rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter,
                             rt_uint8_t *stack_addr, void *texit)
{
10019100:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019104:	e28db000 	add	fp, sp, #0
10019108:	e24dd01c 	sub	sp, sp, #28
1001910c:	e50b0010 	str	r0, [fp, #-16]
10019110:	e50b1014 	str	r1, [fp, #-20]
10019114:	e50b2018 	str	r2, [fp, #-24]
10019118:	e50b301c 	str	r3, [fp, #-28]
    rt_uint32_t *stk;

    stk      = (rt_uint32_t *)stack_addr;
1001911c:	e51b3018 	ldr	r3, [fp, #-24]
10019120:	e50b3008 	str	r3, [fp, #-8]
    *(stk)   = (rt_uint32_t)tentry;         /* entry point */
10019124:	e51b2010 	ldr	r2, [fp, #-16]
10019128:	e51b3008 	ldr	r3, [fp, #-8]
1001912c:	e5832000 	str	r2, [r3]
    *(--stk) = (rt_uint32_t)texit;          /* lr */
10019130:	e51b3008 	ldr	r3, [fp, #-8]
10019134:	e2433004 	sub	r3, r3, #4
10019138:	e50b3008 	str	r3, [fp, #-8]
1001913c:	e51b201c 	ldr	r2, [fp, #-28]
10019140:	e51b3008 	ldr	r3, [fp, #-8]
10019144:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r12 */
10019148:	e51b3008 	ldr	r3, [fp, #-8]
1001914c:	e2433004 	sub	r3, r3, #4
10019150:	e50b3008 	str	r3, [fp, #-8]
10019154:	e51b3008 	ldr	r3, [fp, #-8]
10019158:	e3a02000 	mov	r2, #0
1001915c:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r11 */
10019160:	e51b3008 	ldr	r3, [fp, #-8]
10019164:	e2433004 	sub	r3, r3, #4
10019168:	e50b3008 	str	r3, [fp, #-8]
1001916c:	e51b3008 	ldr	r3, [fp, #-8]
10019170:	e3a02000 	mov	r2, #0
10019174:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r10 */
10019178:	e51b3008 	ldr	r3, [fp, #-8]
1001917c:	e2433004 	sub	r3, r3, #4
10019180:	e50b3008 	str	r3, [fp, #-8]
10019184:	e51b3008 	ldr	r3, [fp, #-8]
10019188:	e3a02000 	mov	r2, #0
1001918c:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r9 */
10019190:	e51b3008 	ldr	r3, [fp, #-8]
10019194:	e2433004 	sub	r3, r3, #4
10019198:	e50b3008 	str	r3, [fp, #-8]
1001919c:	e51b3008 	ldr	r3, [fp, #-8]
100191a0:	e3a02000 	mov	r2, #0
100191a4:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r8 */
100191a8:	e51b3008 	ldr	r3, [fp, #-8]
100191ac:	e2433004 	sub	r3, r3, #4
100191b0:	e50b3008 	str	r3, [fp, #-8]
100191b4:	e51b3008 	ldr	r3, [fp, #-8]
100191b8:	e3a02000 	mov	r2, #0
100191bc:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r7 */
100191c0:	e51b3008 	ldr	r3, [fp, #-8]
100191c4:	e2433004 	sub	r3, r3, #4
100191c8:	e50b3008 	str	r3, [fp, #-8]
100191cc:	e51b3008 	ldr	r3, [fp, #-8]
100191d0:	e3a02000 	mov	r2, #0
100191d4:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r6 */
100191d8:	e51b3008 	ldr	r3, [fp, #-8]
100191dc:	e2433004 	sub	r3, r3, #4
100191e0:	e50b3008 	str	r3, [fp, #-8]
100191e4:	e51b3008 	ldr	r3, [fp, #-8]
100191e8:	e3a02000 	mov	r2, #0
100191ec:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r5 */
100191f0:	e51b3008 	ldr	r3, [fp, #-8]
100191f4:	e2433004 	sub	r3, r3, #4
100191f8:	e50b3008 	str	r3, [fp, #-8]
100191fc:	e51b3008 	ldr	r3, [fp, #-8]
10019200:	e3a02000 	mov	r2, #0
10019204:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r4 */
10019208:	e51b3008 	ldr	r3, [fp, #-8]
1001920c:	e2433004 	sub	r3, r3, #4
10019210:	e50b3008 	str	r3, [fp, #-8]
10019214:	e51b3008 	ldr	r3, [fp, #-8]
10019218:	e3a02000 	mov	r2, #0
1001921c:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r3 */
10019220:	e51b3008 	ldr	r3, [fp, #-8]
10019224:	e2433004 	sub	r3, r3, #4
10019228:	e50b3008 	str	r3, [fp, #-8]
1001922c:	e51b3008 	ldr	r3, [fp, #-8]
10019230:	e3a02000 	mov	r2, #0
10019234:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r2 */
10019238:	e51b3008 	ldr	r3, [fp, #-8]
1001923c:	e2433004 	sub	r3, r3, #4
10019240:	e50b3008 	str	r3, [fp, #-8]
10019244:	e51b3008 	ldr	r3, [fp, #-8]
10019248:	e3a02000 	mov	r2, #0
1001924c:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r1 */
10019250:	e51b3008 	ldr	r3, [fp, #-8]
10019254:	e2433004 	sub	r3, r3, #4
10019258:	e50b3008 	str	r3, [fp, #-8]
1001925c:	e51b3008 	ldr	r3, [fp, #-8]
10019260:	e3a02000 	mov	r2, #0
10019264:	e5832000 	str	r2, [r3]
    *(--stk) = (rt_uint32_t)parameter;      /* r0 : argument */
10019268:	e51b3008 	ldr	r3, [fp, #-8]
1001926c:	e2433004 	sub	r3, r3, #4
10019270:	e50b3008 	str	r3, [fp, #-8]
10019274:	e51b2014 	ldr	r2, [fp, #-20]
10019278:	e51b3008 	ldr	r3, [fp, #-8]
1001927c:	e5832000 	str	r2, [r3]

    /* cpsr */
    if ((rt_uint32_t)tentry & 0x01)
10019280:	e51b3010 	ldr	r3, [fp, #-16]
10019284:	e2033001 	and	r3, r3, #1
10019288:	e3530000 	cmp	r3, #0
1001928c:	0a000006 	beq	100192ac <rt_hw_stack_init+0x1ac>
        *(--stk) = SVCMODE | 0x20;          /* thumb mode */
10019290:	e51b3008 	ldr	r3, [fp, #-8]
10019294:	e2433004 	sub	r3, r3, #4
10019298:	e50b3008 	str	r3, [fp, #-8]
1001929c:	e51b3008 	ldr	r3, [fp, #-8]
100192a0:	e3a02033 	mov	r2, #51	; 0x33
100192a4:	e5832000 	str	r2, [r3]
100192a8:	ea000005 	b	100192c4 <rt_hw_stack_init+0x1c4>
    else
        *(--stk) = SVCMODE;                 /* arm mode   */
100192ac:	e51b3008 	ldr	r3, [fp, #-8]
100192b0:	e2433004 	sub	r3, r3, #4
100192b4:	e50b3008 	str	r3, [fp, #-8]
100192b8:	e51b3008 	ldr	r3, [fp, #-8]
100192bc:	e3a02013 	mov	r2, #19
100192c0:	e5832000 	str	r2, [r3]

    /* return task's current stack address */
    return (rt_uint8_t *)stk;
100192c4:	e51b3008 	ldr	r3, [fp, #-8]
}
100192c8:	e1a00003 	mov	r0, r3
100192cc:	e24bd000 	sub	sp, fp, #0
100192d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100192d4:	e12fff1e 	bx	lr

100192d8 <rt_hw_show_register>:
 * this function will show registers of CPU
 *
 * @param regs the registers point
 */
void rt_hw_show_register (struct rt_hw_exp_stack *regs)
{
100192d8:	e92d4800 	push	{fp, lr}
100192dc:	e28db004 	add	fp, sp, #4
100192e0:	e24dd010 	sub	sp, sp, #16
100192e4:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("Execption:\n");
100192e8:	e30402cc 	movw	r0, #17100	; 0x42cc
100192ec:	e3410003 	movt	r0, #4099	; 0x1003
100192f0:	ebffe9f2 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("r00:0x%08x r01:0x%08x r02:0x%08x r03:0x%08x\n", regs->r0, regs->r1, regs->r2, regs->r3);
100192f4:	e51b3008 	ldr	r3, [fp, #-8]
100192f8:	e5931000 	ldr	r1, [r3]
100192fc:	e51b3008 	ldr	r3, [fp, #-8]
10019300:	e5932004 	ldr	r2, [r3, #4]
10019304:	e51b3008 	ldr	r3, [fp, #-8]
10019308:	e593c008 	ldr	ip, [r3, #8]
1001930c:	e51b3008 	ldr	r3, [fp, #-8]
10019310:	e593300c 	ldr	r3, [r3, #12]
10019314:	e58d3000 	str	r3, [sp]
10019318:	e30402d8 	movw	r0, #17112	; 0x42d8
1001931c:	e3410003 	movt	r0, #4099	; 0x1003
10019320:	e1a0300c 	mov	r3, ip
10019324:	ebffe9e5 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("r04:0x%08x r05:0x%08x r06:0x%08x r07:0x%08x\n", regs->r4, regs->r5, regs->r6, regs->r7);
10019328:	e51b3008 	ldr	r3, [fp, #-8]
1001932c:	e5931010 	ldr	r1, [r3, #16]
10019330:	e51b3008 	ldr	r3, [fp, #-8]
10019334:	e5932014 	ldr	r2, [r3, #20]
10019338:	e51b3008 	ldr	r3, [fp, #-8]
1001933c:	e593c018 	ldr	ip, [r3, #24]
10019340:	e51b3008 	ldr	r3, [fp, #-8]
10019344:	e593301c 	ldr	r3, [r3, #28]
10019348:	e58d3000 	str	r3, [sp]
1001934c:	e3040308 	movw	r0, #17160	; 0x4308
10019350:	e3410003 	movt	r0, #4099	; 0x1003
10019354:	e1a0300c 	mov	r3, ip
10019358:	ebffe9d8 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("r08:0x%08x r09:0x%08x r10:0x%08x\n", regs->r8, regs->r9, regs->r10);
1001935c:	e51b3008 	ldr	r3, [fp, #-8]
10019360:	e5931020 	ldr	r1, [r3, #32]
10019364:	e51b3008 	ldr	r3, [fp, #-8]
10019368:	e5932024 	ldr	r2, [r3, #36]	; 0x24
1001936c:	e51b3008 	ldr	r3, [fp, #-8]
10019370:	e5933028 	ldr	r3, [r3, #40]	; 0x28
10019374:	e3040338 	movw	r0, #17208	; 0x4338
10019378:	e3410003 	movt	r0, #4099	; 0x1003
1001937c:	ebffe9cf 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("fp :0x%08x ip :0x%08x\n", regs->fp, regs->ip);
10019380:	e51b3008 	ldr	r3, [fp, #-8]
10019384:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
10019388:	e51b3008 	ldr	r3, [fp, #-8]
1001938c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
10019390:	e304035c 	movw	r0, #17244	; 0x435c
10019394:	e3410003 	movt	r0, #4099	; 0x1003
10019398:	e1a01002 	mov	r1, r2
1001939c:	e1a02003 	mov	r2, r3
100193a0:	ebffe9c6 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("sp :0x%08x lr :0x%08x pc :0x%08x\n", regs->sp, regs->lr, regs->pc);
100193a4:	e51b3008 	ldr	r3, [fp, #-8]
100193a8:	e5931034 	ldr	r1, [r3, #52]	; 0x34
100193ac:	e51b3008 	ldr	r3, [fp, #-8]
100193b0:	e5932038 	ldr	r2, [r3, #56]	; 0x38
100193b4:	e51b3008 	ldr	r3, [fp, #-8]
100193b8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
100193bc:	e3040374 	movw	r0, #17268	; 0x4374
100193c0:	e3410003 	movt	r0, #4099	; 0x1003
100193c4:	ebffe9bd 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("cpsr:0x%08x\n", regs->cpsr);
100193c8:	e51b3008 	ldr	r3, [fp, #-8]
100193cc:	e5933040 	ldr	r3, [r3, #64]	; 0x40
100193d0:	e3040398 	movw	r0, #17304	; 0x4398
100193d4:	e3410003 	movt	r0, #4099	; 0x1003
100193d8:	e1a01003 	mov	r1, r3
100193dc:	ebffe9b7 	bl	10013ac0 <rt_kprintf>
}
100193e0:	e24bd004 	sub	sp, fp, #4
100193e4:	e8bd8800 	pop	{fp, pc}

100193e8 <rt_hw_trap_undef>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_undef(struct rt_hw_exp_stack *regs)
{
100193e8:	e92d4800 	push	{fp, lr}
100193ec:	e28db004 	add	fp, sp, #4
100193f0:	e24dd008 	sub	sp, sp, #8
100193f4:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("undefined instruction:\n");
100193f8:	e30403a8 	movw	r0, #17320	; 0x43a8
100193fc:	e3410003 	movt	r0, #4099	; 0x1003
10019400:	ebffe9ae 	bl	10013ac0 <rt_kprintf>
    rt_hw_show_register(regs);
10019404:	e51b0008 	ldr	r0, [fp, #-8]
10019408:	ebffffb2 	bl	100192d8 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
1001940c:	eb002a4c 	bl	10023d44 <list_thread>
#endif
    rt_hw_cpu_shutdown();
10019410:	ebfffa08 	bl	10017c38 <rt_hw_cpu_shutdown>
}
10019414:	e24bd004 	sub	sp, fp, #4
10019418:	e8bd8800 	pop	{fp, pc}

1001941c <rt_hw_trap_swi>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_swi(struct rt_hw_exp_stack *regs)
{
1001941c:	e92d4800 	push	{fp, lr}
10019420:	e28db004 	add	fp, sp, #4
10019424:	e24dd008 	sub	sp, sp, #8
10019428:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("software interrupt:\n");
1001942c:	e30403c0 	movw	r0, #17344	; 0x43c0
10019430:	e3410003 	movt	r0, #4099	; 0x1003
10019434:	ebffe9a1 	bl	10013ac0 <rt_kprintf>
    rt_hw_show_register(regs);
10019438:	e51b0008 	ldr	r0, [fp, #-8]
1001943c:	ebffffa5 	bl	100192d8 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
10019440:	eb002a3f 	bl	10023d44 <list_thread>
#endif
    rt_hw_cpu_shutdown();
10019444:	ebfff9fb 	bl	10017c38 <rt_hw_cpu_shutdown>
}
10019448:	e24bd004 	sub	sp, fp, #4
1001944c:	e8bd8800 	pop	{fp, pc}

10019450 <rt_hw_trap_pabt>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_pabt(struct rt_hw_exp_stack *regs)
{
10019450:	e92d4800 	push	{fp, lr}
10019454:	e28db004 	add	fp, sp, #4
10019458:	e24dd008 	sub	sp, sp, #8
1001945c:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("prefetch abort:\n");
10019460:	e30403d8 	movw	r0, #17368	; 0x43d8
10019464:	e3410003 	movt	r0, #4099	; 0x1003
10019468:	ebffe994 	bl	10013ac0 <rt_kprintf>
    rt_hw_show_register(regs);
1001946c:	e51b0008 	ldr	r0, [fp, #-8]
10019470:	ebffff98 	bl	100192d8 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
10019474:	eb002a32 	bl	10023d44 <list_thread>
#endif
    rt_hw_cpu_shutdown();
10019478:	ebfff9ee 	bl	10017c38 <rt_hw_cpu_shutdown>
}
1001947c:	e24bd004 	sub	sp, fp, #4
10019480:	e8bd8800 	pop	{fp, pc}

10019484 <rt_hw_trap_dabt>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_dabt(struct rt_hw_exp_stack *regs)
{
10019484:	e92d4800 	push	{fp, lr}
10019488:	e28db004 	add	fp, sp, #4
1001948c:	e24dd008 	sub	sp, sp, #8
10019490:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("data abort:");
10019494:	e30403ec 	movw	r0, #17388	; 0x43ec
10019498:	e3410003 	movt	r0, #4099	; 0x1003
1001949c:	ebffe987 	bl	10013ac0 <rt_kprintf>
    rt_hw_show_register(regs);
100194a0:	e51b0008 	ldr	r0, [fp, #-8]
100194a4:	ebffff8b 	bl	100192d8 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
100194a8:	eb002a25 	bl	10023d44 <list_thread>
#endif
    rt_hw_cpu_shutdown();
100194ac:	ebfff9e1 	bl	10017c38 <rt_hw_cpu_shutdown>
}
100194b0:	e24bd004 	sub	sp, fp, #4
100194b4:	e8bd8800 	pop	{fp, pc}

100194b8 <rt_hw_trap_resv>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_resv(struct rt_hw_exp_stack *regs)
{
100194b8:	e92d4800 	push	{fp, lr}
100194bc:	e28db004 	add	fp, sp, #4
100194c0:	e24dd008 	sub	sp, sp, #8
100194c4:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("reserved trap:\n");
100194c8:	e30403f8 	movw	r0, #17400	; 0x43f8
100194cc:	e3410003 	movt	r0, #4099	; 0x1003
100194d0:	ebffe97a 	bl	10013ac0 <rt_kprintf>
    rt_hw_show_register(regs);
100194d4:	e51b0008 	ldr	r0, [fp, #-8]
100194d8:	ebffff7e 	bl	100192d8 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
100194dc:	eb002a18 	bl	10023d44 <list_thread>
#endif
    rt_hw_cpu_shutdown();
100194e0:	ebfff9d4 	bl	10017c38 <rt_hw_cpu_shutdown>
}
100194e4:	e24bd004 	sub	sp, fp, #4
100194e8:	e8bd8800 	pop	{fp, pc}

100194ec <rt_hw_trap_irq>:

#define GIC_ACK_INTID_MASK					0x000003ff

void rt_hw_trap_irq()
{
100194ec:	e92d4800 	push	{fp, lr}
100194f0:	e28db004 	add	fp, sp, #4
100194f4:	e24dd010 	sub	sp, sp, #16
    unsigned long ir;
    unsigned long fullir;
    rt_isr_handler_t isr_func;
    extern struct rt_irq_desc isr_table[];

    fullir = arm_gic_get_active_irq(0);
100194f8:	e3a00000 	mov	r0, #0
100194fc:	ebfffa23 	bl	10017d90 <arm_gic_get_active_irq>
10019500:	e1a03000 	mov	r3, r0
10019504:	e50b3008 	str	r3, [fp, #-8]
    ir = fullir & GIC_ACK_INTID_MASK;
10019508:	e51b3008 	ldr	r3, [fp, #-8]
1001950c:	e7e93053 	ubfx	r3, r3, #0, #10
10019510:	e50b300c 	str	r3, [fp, #-12]

    /* get interrupt service routine */
    isr_func = isr_table[ir].handler;
10019514:	e3022ad8 	movw	r2, #10968	; 0x2ad8
10019518:	e3412004 	movt	r2, #4100	; 0x1004
1001951c:	e51b300c 	ldr	r3, [fp, #-12]
10019520:	e1a03103 	lsl	r3, r3, #2
10019524:	e1a01103 	lsl	r1, r3, #2
10019528:	e0833001 	add	r3, r3, r1
1001952c:	e0823003 	add	r3, r2, r3
10019530:	e5933000 	ldr	r3, [r3]
10019534:	e50b3010 	str	r3, [fp, #-16]
    if (isr_func)
10019538:	e51b3010 	ldr	r3, [fp, #-16]
1001953c:	e3530000 	cmp	r3, #0
10019540:	0a00000d 	beq	1001957c <rt_hw_trap_irq+0x90>
    {
        param = isr_table[ir].param;
10019544:	e3022ad8 	movw	r2, #10968	; 0x2ad8
10019548:	e3412004 	movt	r2, #4100	; 0x1004
1001954c:	e51b300c 	ldr	r3, [fp, #-12]
10019550:	e1a03103 	lsl	r3, r3, #2
10019554:	e1a01103 	lsl	r1, r3, #2
10019558:	e0833001 	add	r3, r3, r1
1001955c:	e0823003 	add	r3, r2, r3
10019560:	e5933004 	ldr	r3, [r3, #4]
10019564:	e50b3014 	str	r3, [fp, #-20]
        /* turn to interrupt service routine */
        isr_func(ir, param);
10019568:	e51b200c 	ldr	r2, [fp, #-12]
1001956c:	e51b3010 	ldr	r3, [fp, #-16]
10019570:	e1a00002 	mov	r0, r2
10019574:	e51b1014 	ldr	r1, [fp, #-20]
10019578:	e12fff33 	blx	r3
    }

    /* end of interrupt */
    arm_gic_ack(0, fullir);
1001957c:	e51b3008 	ldr	r3, [fp, #-8]
10019580:	e3a00000 	mov	r0, #0
10019584:	e1a01003 	mov	r1, r3
10019588:	ebfffa2c 	bl	10017e40 <arm_gic_ack>
}
1001958c:	e24bd004 	sub	sp, fp, #4
10019590:	e8bd8800 	pop	{fp, pc}

10019594 <rt_hw_trap_fiq>:

void rt_hw_trap_fiq()
{
10019594:	e92d4800 	push	{fp, lr}
10019598:	e28db004 	add	fp, sp, #4
1001959c:	e24dd010 	sub	sp, sp, #16
    unsigned long ir;
    unsigned long fullir;
    rt_isr_handler_t isr_func;
    extern struct rt_irq_desc isr_table[];

    fullir = arm_gic_get_active_irq(0);
100195a0:	e3a00000 	mov	r0, #0
100195a4:	ebfff9f9 	bl	10017d90 <arm_gic_get_active_irq>
100195a8:	e1a03000 	mov	r3, r0
100195ac:	e50b3008 	str	r3, [fp, #-8]
    ir = fullir & GIC_ACK_INTID_MASK;
100195b0:	e51b3008 	ldr	r3, [fp, #-8]
100195b4:	e7e93053 	ubfx	r3, r3, #0, #10
100195b8:	e50b300c 	str	r3, [fp, #-12]

    /* get interrupt service routine */
    isr_func = isr_table[ir].handler;
100195bc:	e3022ad8 	movw	r2, #10968	; 0x2ad8
100195c0:	e3412004 	movt	r2, #4100	; 0x1004
100195c4:	e51b300c 	ldr	r3, [fp, #-12]
100195c8:	e1a03103 	lsl	r3, r3, #2
100195cc:	e1a01103 	lsl	r1, r3, #2
100195d0:	e0833001 	add	r3, r3, r1
100195d4:	e0823003 	add	r3, r2, r3
100195d8:	e5933000 	ldr	r3, [r3]
100195dc:	e50b3010 	str	r3, [fp, #-16]
    param = isr_table[ir].param;
100195e0:	e3022ad8 	movw	r2, #10968	; 0x2ad8
100195e4:	e3412004 	movt	r2, #4100	; 0x1004
100195e8:	e51b300c 	ldr	r3, [fp, #-12]
100195ec:	e1a03103 	lsl	r3, r3, #2
100195f0:	e1a01103 	lsl	r1, r3, #2
100195f4:	e0833001 	add	r3, r3, r1
100195f8:	e0823003 	add	r3, r2, r3
100195fc:	e5933004 	ldr	r3, [r3, #4]
10019600:	e50b3014 	str	r3, [fp, #-20]

    /* turn to interrupt service routine */
    isr_func(ir, param);
10019604:	e51b200c 	ldr	r2, [fp, #-12]
10019608:	e51b3010 	ldr	r3, [fp, #-16]
1001960c:	e1a00002 	mov	r0, r2
10019610:	e51b1014 	ldr	r1, [fp, #-20]
10019614:	e12fff33 	blx	r3

    /* end of interrupt */
    arm_gic_ack(0, fullir);
10019618:	e51b3008 	ldr	r3, [fp, #-8]
1001961c:	e3a00000 	mov	r0, #0
10019620:	e1a01003 	mov	r1, r3
10019624:	ebfffa05 	bl	10017e40 <arm_gic_ack>
}
10019628:	e24bd004 	sub	sp, fp, #4
1001962c:	e8bd8800 	pop	{fp, pc}

10019630 <rt_hw_interrupt_disable>:
/*
 * rt_base_t rt_hw_interrupt_disable();
 */
.globl rt_hw_interrupt_disable
rt_hw_interrupt_disable:
    mrs r0, cpsr
10019630:	e10f0000 	mrs	r0, CPSR
    orr r1, r0, #NOINT
10019634:	e38010c0 	orr	r1, r0, #192	; 0xc0
    msr cpsr_c, r1
10019638:	e121f001 	msr	CPSR_c, r1
    bx  lr
1001963c:	e12fff1e 	bx	lr

10019640 <rt_hw_interrupt_enable>:
/*
 * void rt_hw_interrupt_enable(rt_base_t level);
 */
.globl rt_hw_interrupt_enable
rt_hw_interrupt_enable:
    msr cpsr, r0
10019640:	e129f000 	msr	CPSR_fc, r0
    bx  lr
10019644:	e12fff1e 	bx	lr

10019648 <rt_hw_context_switch>:
 * r0 --> from
 * r1 --> to
 */
.globl rt_hw_context_switch
rt_hw_context_switch:
    stmfd   sp!, {lr}       @ push pc (lr should be pushed in place of PC)
10019648:	e92d4000 	stmfd	sp!, {lr}
    stmfd   sp!, {r0-r12, lr}   @ push lr & register file
1001964c:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

    mrs r4, cpsr
10019650:	e10f4000 	mrs	r4, CPSR
    tst lr, #0x01
10019654:	e31e0001 	tst	lr, #1
    beq _ARM_MODE
10019658:	0a000000 	beq	10019660 <_ARM_MODE>
    orr r4, r4, #0x20       @ it's thumb code
1001965c:	e3844020 	orr	r4, r4, #32

10019660 <_ARM_MODE>:

_ARM_MODE:
    stmfd sp!, {r4}         @ push cpsr
10019660:	e92d0010 	stmfd	sp!, {r4}

    str sp, [r0]            @ store sp in preempted tasks TCB
10019664:	e580d000 	str	sp, [r0]
    ldr sp, [r1]            @ get new task stack pointer
10019668:	e591d000 	ldr	sp, [r1]

    ldmfd sp!, {r4}         @ pop new task cpsr to spsr
1001966c:	e8bd0010 	ldmfd	sp!, {r4}
    msr spsr_cxsf, r4
10019670:	e16ff004 	msr	SPSR_fsxc, r4

    ldmfd sp!, {r0-r12, lr, pc}^  @ pop new task r0-r12, lr & pc, copy spsr to cpsr
10019674:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

10019678 <rt_hw_context_switch_to>:
 * void rt_hw_context_switch_to(rt_uint32 to);
 * r0 --> to
 */
.globl rt_hw_context_switch_to
rt_hw_context_switch_to:
    ldr sp, [r0]            @ get new task stack pointer
10019678:	e590d000 	ldr	sp, [r0]

    ldmfd sp!, {r4}         @ pop new task spsr
1001967c:	e8bd0010 	ldmfd	sp!, {r4}
    msr spsr_cxsf, r4
10019680:	e16ff004 	msr	SPSR_fsxc, r4

    bic r4, r4, #0x20       @ must be ARM mode
10019684:	e3c44020 	bic	r4, r4, #32
    msr cpsr_cxsf, r4
10019688:	e12ff004 	msr	CPSR_fsxc, r4

    ldmfd sp!, {r0-r12, lr, pc}^   @ pop new task r0-r12, lr & pc
1001968c:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

10019690 <rt_hw_context_switch_interrupt>:
.globl rt_thread_switch_interrupt_flag
.globl rt_interrupt_from_thread
.globl rt_interrupt_to_thread
.globl rt_hw_context_switch_interrupt
rt_hw_context_switch_interrupt:
    ldr r2, =rt_thread_switch_interrupt_flag
10019690:	e59f2024 	ldr	r2, [pc, #36]	; 100196bc <_reswitch+0xc>
    ldr r3, [r2]
10019694:	e5923000 	ldr	r3, [r2]
    cmp r3, #1
10019698:	e3530001 	cmp	r3, #1
    beq _reswitch
1001969c:	0a000003 	beq	100196b0 <_reswitch>
    mov r3, #1              @ set rt_thread_switch_interrupt_flag to 1
100196a0:	e3a03001 	mov	r3, #1
    str r3, [r2]
100196a4:	e5823000 	str	r3, [r2]
    ldr r2, =rt_interrupt_from_thread   @ set rt_interrupt_from_thread
100196a8:	e59f2010 	ldr	r2, [pc, #16]	; 100196c0 <_reswitch+0x10>
    str r0, [r2]
100196ac:	e5820000 	str	r0, [r2]

100196b0 <_reswitch>:
_reswitch:
    ldr r2, =rt_interrupt_to_thread     @ set rt_interrupt_to_thread
100196b0:	e59f200c 	ldr	r2, [pc, #12]	; 100196c4 <_reswitch+0x14>
    str r1, [r2]
100196b4:	e5821000 	str	r1, [r2]
    bx  lr
100196b8:	e12fff1e 	bx	lr
.globl rt_thread_switch_interrupt_flag
.globl rt_interrupt_from_thread
.globl rt_interrupt_to_thread
.globl rt_hw_context_switch_interrupt
rt_hw_context_switch_interrupt:
    ldr r2, =rt_thread_switch_interrupt_flag
100196bc:	10042ad4 	.word	0x10042ad4
    ldr r3, [r2]
    cmp r3, #1
    beq _reswitch
    mov r3, #1              @ set rt_thread_switch_interrupt_flag to 1
    str r3, [r2]
    ldr r2, =rt_interrupt_from_thread   @ set rt_interrupt_from_thread
100196c0:	10042ad0 	.word	0x10042ad0
    str r0, [r2]
_reswitch:
    ldr r2, =rt_interrupt_to_thread     @ set rt_interrupt_to_thread
100196c4:	10042acc 	.word	0x10042acc

100196c8 <rt_cpu_get_smp_id>:
 * 2013-07-05     Bernard      the first version
 */

.globl rt_cpu_get_smp_id
rt_cpu_get_smp_id:
    mrc     p15, #0, r0, c0, c0, #5
100196c8:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
    bx      lr
100196cc:	e12fff1e 	bx	lr

100196d0 <rt_cpu_vector_set_base>:

.globl rt_cpu_vector_set_base
rt_cpu_vector_set_base:
    mcr     p15, #0, r0, c12, c0, #0
100196d0:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
    dsb
100196d4:	f57ff04f 	dsb	sy
    bx      lr
100196d8:	e12fff1e 	bx	lr

100196dc <rt_hw_cpu_dcache_enable>:

.globl rt_hw_cpu_dcache_enable
rt_hw_cpu_dcache_enable:
    mrc     p15, #0, r0, c1, c0, #0
100196dc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0,  r0, #0x00000004
100196e0:	e3800004 	orr	r0, r0, #4
    mcr     p15, #0, r0, c1, c0, #0
100196e4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
100196e8:	e12fff1e 	bx	lr

100196ec <rt_hw_cpu_icache_enable>:

.globl rt_hw_cpu_icache_enable
rt_hw_cpu_icache_enable:
    mrc     p15, #0, r0, c1, c0, #0
100196ec:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0,  r0, #0x00001000
100196f0:	e3800a01 	orr	r0, r0, #4096	; 0x1000
    mcr     p15, #0, r0, c1, c0, #0
100196f4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
100196f8:	e12fff1e 	bx	lr

100196fc <_FLD_MAX_WAY>:
100196fc:	000003ff 	.word	0x000003ff

10019700 <_FLD_MAX_IDX>:
10019700:	000007ff 	.word	0x000007ff

10019704 <rt_cpu_dcache_clean_flush>:
_FLD_MAX_IDX:
   .word  0x7ff

.globl rt_cpu_dcache_clean_flush
rt_cpu_dcache_clean_flush:
    push    {r4-r11}
10019704:	e92d0ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp}
    dmb
10019708:	f57ff05f 	dmb	sy
    mrc     p15, #1, r0, c0, c0, #1  @ read clid register
1001970c:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ands    r3, r0, #0x7000000       @ get level of coherency
10019710:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    mov     r3, r3, lsr #23
10019714:	e1a03ba3 	lsr	r3, r3, #23
    beq     finished
10019718:	0a00001a 	beq	10019788 <finished>
    mov     r10, #0
1001971c:	e3a0a000 	mov	sl, #0

10019720 <loop1>:
loop1:
    add     r2, r10, r10, lsr #1
10019720:	e08a20aa 	add	r2, sl, sl, lsr #1
    mov     r1, r0, lsr r2
10019724:	e1a01230 	lsr	r1, r0, r2
    and     r1, r1, #7
10019728:	e2011007 	and	r1, r1, #7
    cmp     r1, #2
1001972c:	e3510002 	cmp	r1, #2
    blt     skip
10019730:	ba000011 	blt	1001977c <skip>
    mcr     p15, #2, r10, c0, c0, #0
10019734:	ee40af10 	mcr	15, 2, sl, cr0, cr0, {0}
    isb
10019738:	f57ff06f 	isb	sy
    mrc     p15, #1, r1, c0, c0, #0
1001973c:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    and     r2, r1, #7
10019740:	e2012007 	and	r2, r1, #7
    add     r2, r2, #4
10019744:	e2822004 	add	r2, r2, #4
    ldr     r4, _FLD_MAX_WAY
10019748:	e51f4054 	ldr	r4, [pc, #-84]	; 100196fc <_FLD_MAX_WAY>
    ands    r4, r4, r1, lsr #3
1001974c:	e01441a1 	ands	r4, r4, r1, lsr #3
    clz     r5, r4
10019750:	e16f5f14 	clz	r5, r4
    ldr     r7, _FLD_MAX_IDX
10019754:	e51f705c 	ldr	r7, [pc, #-92]	; 10019700 <_FLD_MAX_IDX>
    ands    r7, r7, r1, lsr #13
10019758:	e01776a1 	ands	r7, r7, r1, lsr #13

1001975c <loop2>:
loop2:
    mov     r9, r4
1001975c:	e1a09004 	mov	r9, r4

10019760 <loop3>:
loop3:
    orr     r11, r10, r9, lsl r5
10019760:	e18ab519 	orr	fp, sl, r9, lsl r5
    orr     r11, r11, r7, lsl r2
10019764:	e18bb217 	orr	fp, fp, r7, lsl r2
    mcr     p15, #0, r11, c7, c14, #2
10019768:	ee07bf5e 	mcr	15, 0, fp, cr7, cr14, {2}
    subs    r9, r9, #1
1001976c:	e2599001 	subs	r9, r9, #1
    bge     loop3
10019770:	aafffffa 	bge	10019760 <loop3>
    subs    r7, r7, #1
10019774:	e2577001 	subs	r7, r7, #1
    bge     loop2
10019778:	aafffff7 	bge	1001975c <loop2>

1001977c <skip>:
skip:
    add     r10, r10, #2
1001977c:	e28aa002 	add	sl, sl, #2
    cmp     r3, r10
10019780:	e153000a 	cmp	r3, sl
    bgt     loop1
10019784:	caffffe5 	bgt	10019720 <loop1>

10019788 <finished>:

finished:
    dsb
10019788:	f57ff04f 	dsb	sy
    isb
1001978c:	f57ff06f 	isb	sy
    pop     {r4-r11}
10019790:	e8bd0ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp}
    bx      lr
10019794:	e12fff1e 	bx	lr

10019798 <rt_hw_cpu_dcache_disable>:

.globl rt_hw_cpu_dcache_disable
rt_hw_cpu_dcache_disable:
    push    {r4-r11, lr}
10019798:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bl      rt_cpu_dcache_clean_flush
1001979c:	ebffffd8 	bl	10019704 <rt_cpu_dcache_clean_flush>
    mrc     p15, #0, r0, c1, c0, #0
100197a0:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0,  r0, #0x00000004
100197a4:	e3c00004 	bic	r0, r0, #4
    mcr     p15, #0, r0, c1, c0, #0
100197a8:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    pop     {r4-r11, lr}
100197ac:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bx      lr
100197b0:	e12fff1e 	bx	lr

100197b4 <rt_hw_cpu_icache_disable>:

.globl rt_hw_cpu_icache_disable
rt_hw_cpu_icache_disable:
    mrc     p15, #0, r0, c1, c0, #0
100197b4:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0,  r0, #0x00001000
100197b8:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
    mcr     p15, #0, r0, c1, c0, #0
100197bc:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
100197c0:	e12fff1e 	bx	lr

100197c4 <rt_cpu_mmu_disable>:

.globl rt_cpu_mmu_disable
rt_cpu_mmu_disable:
    mcr     p15, #0, r0, c8, c7, #0    @ invalidate tlb
100197c4:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    mrc     p15, #0, r0, c1, c0, #0
100197c8:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0, r0, #1
100197cc:	e3c00001 	bic	r0, r0, #1
    mcr     p15, #0, r0, c1, c0, #0    @ clear mmu bit
100197d0:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    dsb
100197d4:	f57ff04f 	dsb	sy
    bx      lr
100197d8:	e12fff1e 	bx	lr

100197dc <rt_cpu_mmu_enable>:

.globl rt_cpu_mmu_enable
rt_cpu_mmu_enable:
    mrc     p15, #0, r0, c1, c0, #0
100197dc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, r0, #0x001
100197e0:	e3800001 	orr	r0, r0, #1
    mcr     p15, #0, r0, c1, c0, #0    @ set mmu enable bit
100197e4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    dsb
100197e8:	f57ff04f 	dsb	sy
    bx      lr
100197ec:	e12fff1e 	bx	lr

100197f0 <rt_cpu_tlb_set>:

.globl rt_cpu_tlb_set
rt_cpu_tlb_set:
    mcr     p15, #0, r0, c2, c0, #0
100197f0:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
    dmb
100197f4:	f57ff05f 	dmb	sy
    bx      lr
100197f8:	e12fff1e 	bx	lr

100197fc <_reset>:
.text
/* reset entry */
.globl _reset
_reset:
	/* invalidate SCU */
	ldr	r7, =0xF8F0000C
100197fc:	e59f70ac 	ldr	r7, [pc, #172]	; 100198b0 <stack_setup+0x40>
	ldr	r6, =0xFFFF
10019800:	e59f60ac 	ldr	r6, [pc, #172]	; 100198b4 <stack_setup+0x44>
	str	r6, [r7]
10019804:	e5876000 	str	r6, [r7]

	/* disable MMU */
	mrc	p15, 0, r0, c1, c0, 0		/* read CP15 register 1 */
10019808:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x1				/* clear bit 0 */
1001980c:	e3c00001 	bic	r0, r0, #1
	mcr	p15, 0, r0, c1, c0, 0		/* write value back */
10019810:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

    /* set the cpu to SVC32 mode and disable interrupt */
    mrs     r0, cpsr
10019814:	e10f0000 	mrs	r0, CPSR
    bic     r0, r0, #0x1f
10019818:	e3c0001f 	bic	r0, r0, #31
    orr     r0, r0, #0x13
1001981c:	e3800013 	orr	r0, r0, #19
    msr     cpsr_c, r0
10019820:	e121f000 	msr	CPSR_c, r0

    /* setup stack */
    bl      stack_setup
10019824:	eb000011 	bl	10019870 <stack_setup>

    /* clear .bss */
    mov     r0,#0                   /* get a zero                       */
10019828:	e3a00000 	mov	r0, #0
    ldr     r1,=__bss_start         /* bss start                        */
1001982c:	e59f1084 	ldr	r1, [pc, #132]	; 100198b8 <stack_setup+0x48>
    ldr     r2,=__bss_end           /* bss end                          */
10019830:	e59f2084 	ldr	r2, [pc, #132]	; 100198bc <stack_setup+0x4c>

10019834 <bss_loop>:

bss_loop:
    cmp     r1,r2                   /* check if data to clear           */
10019834:	e1510002 	cmp	r1, r2
    strlo   r0,[r1],#4              /* clear 4 bytes                    */
10019838:	34810004 	strcc	r0, [r1], #4
    blo     bss_loop                /* loop until done                  */
1001983c:	3afffffc 	bcc	10019834 <bss_loop>

    /* call C++ constructors of global objects                          */
    ldr     r0, =__ctors_start__
10019840:	e59f0078 	ldr	r0, [pc, #120]	; 100198c0 <stack_setup+0x50>
    ldr     r1, =__ctors_end__
10019844:	e59f1078 	ldr	r1, [pc, #120]	; 100198c4 <stack_setup+0x54>

10019848 <ctor_loop>:

ctor_loop:
    cmp     r0, r1
10019848:	e1500001 	cmp	r0, r1
    beq     ctor_end
1001984c:	0a000005 	beq	10019868 <ctor_end>
    ldr     r2, [r0], #4
10019850:	e4902004 	ldr	r2, [r0], #4
    stmfd   sp!, {r0-r1}
10019854:	e92d0003 	push	{r0, r1}
    mov     lr, pc
10019858:	e1a0e00f 	mov	lr, pc
    bx      r2
1001985c:	e12fff12 	bx	r2
    ldmfd   sp!, {r0-r1}
10019860:	e8bd0003 	pop	{r0, r1}
    b       ctor_loop
10019864:	eafffff7 	b	10019848 <ctor_loop>

10019868 <ctor_end>:
ctor_end:

    /* start RT-Thread Kernel       */
    ldr     pc, _rtthread_startup
10019868:	e51ff004 	ldr	pc, [pc, #-4]	; 1001986c <_rtthread_startup>

1001986c <_rtthread_startup>:
1001986c:	1000e2c8 	.word	0x1000e2c8

10019870 <stack_setup>:

_rtthread_startup:
    .word rtthread_startup

stack_setup:
    ldr     r0, =stack_top
10019870:	e59f0050 	ldr	r0, [pc, #80]	; 100198c8 <stack_setup+0x58>

    @  Set the startup stack for svc
    mov     sp, r0
10019874:	e1a0d000 	mov	sp, r0

    @  Enter Undefined Instruction Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_UND|I_Bit|F_Bit
10019878:	e321f0db 	msr	CPSR_c, #219	; 0xdb
    mov     sp, r0
1001987c:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #UND_Stack_Size
10019880:	e2400000 	sub	r0, r0, #0

    @  Enter Abort Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_ABT|I_Bit|F_Bit
10019884:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
    mov     sp, r0
10019888:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #ABT_Stack_Size
1001988c:	e2400000 	sub	r0, r0, #0

    @  Enter FIQ Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_FIQ|I_Bit|F_Bit
10019890:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
    mov     sp, r0
10019894:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #FIQ_Stack_Size
10019898:	e2400c01 	sub	r0, r0, #256	; 0x100

    @  Enter IRQ Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_IRQ|I_Bit|F_Bit
1001989c:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
    mov     sp, r0
100198a0:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #IRQ_Stack_Size
100198a4:	e2400c01 	sub	r0, r0, #256	; 0x100

    @  Switch back to SVC
    msr     cpsr_c, #Mode_SVC|I_Bit|F_Bit
100198a8:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

    bx      lr
100198ac:	e12fff1e 	bx	lr
.text
/* reset entry */
.globl _reset
_reset:
	/* invalidate SCU */
	ldr	r7, =0xF8F0000C
100198b0:	f8f0000c 	.word	0xf8f0000c
	ldr	r6, =0xFFFF
100198b4:	0000ffff 	.word	0x0000ffff
    /* setup stack */
    bl      stack_setup

    /* clear .bss */
    mov     r0,#0                   /* get a zero                       */
    ldr     r1,=__bss_start         /* bss start                        */
100198b8:	1003c000 	.word	0x1003c000
    ldr     r2,=__bss_end           /* bss end                          */
100198bc:	100439ac 	.word	0x100439ac
    cmp     r1,r2                   /* check if data to clear           */
    strlo   r0,[r1],#4              /* clear 4 bytes                    */
    blo     bss_loop                /* loop until done                  */

    /* call C++ constructors of global objects                          */
    ldr     r0, =__ctors_start__
100198c0:	10036800 	.word	0x10036800
    ldr     r1, =__ctors_end__
100198c4:	10036800 	.word	0x10036800

_rtthread_startup:
    .word rtthread_startup

stack_setup:
    ldr     r0, =stack_top
100198c8:	1003cc68 	.word	0x1003cc68

100198cc <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
100198cc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100198d0:	e28db000 	add	fp, sp, #0
100198d4:	e24dd00c 	sub	sp, sp, #12
100198d8:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
100198dc:	e51b3008 	ldr	r3, [fp, #-8]
100198e0:	e51b2008 	ldr	r2, [fp, #-8]
100198e4:	e5832004 	str	r2, [r3, #4]
100198e8:	e51b3008 	ldr	r3, [fp, #-8]
100198ec:	e5932004 	ldr	r2, [r3, #4]
100198f0:	e51b3008 	ldr	r3, [fp, #-8]
100198f4:	e5832000 	str	r2, [r3]
}
100198f8:	e24bd000 	sub	sp, fp, #0
100198fc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019900:	e12fff1e 	bx	lr

10019904 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
10019904:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019908:	e28db000 	add	fp, sp, #0
1001990c:	e24dd00c 	sub	sp, sp, #12
10019910:	e50b0008 	str	r0, [fp, #-8]
10019914:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
10019918:	e51b3008 	ldr	r3, [fp, #-8]
1001991c:	e5933004 	ldr	r3, [r3, #4]
10019920:	e51b200c 	ldr	r2, [fp, #-12]
10019924:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
10019928:	e51b3008 	ldr	r3, [fp, #-8]
1001992c:	e5932004 	ldr	r2, [r3, #4]
10019930:	e51b300c 	ldr	r3, [fp, #-12]
10019934:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
10019938:	e51b3008 	ldr	r3, [fp, #-8]
1001993c:	e51b200c 	ldr	r2, [fp, #-12]
10019940:	e5832004 	str	r2, [r3, #4]
    n->next = l;
10019944:	e51b300c 	ldr	r3, [fp, #-12]
10019948:	e51b2008 	ldr	r2, [fp, #-8]
1001994c:	e5832000 	str	r2, [r3]
}
10019950:	e24bd000 	sub	sp, fp, #0
10019954:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019958:	e12fff1e 	bx	lr

1001995c <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
1001995c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019960:	e28db000 	add	fp, sp, #0
10019964:	e24dd00c 	sub	sp, sp, #12
10019968:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
1001996c:	e51b3008 	ldr	r3, [fp, #-8]
10019970:	e5932000 	ldr	r2, [r3]
10019974:	e51b3008 	ldr	r3, [fp, #-8]
10019978:	e1520003 	cmp	r2, r3
1001997c:	03a03001 	moveq	r3, #1
10019980:	13a03000 	movne	r3, #0
10019984:	e6ef3073 	uxtb	r3, r3
}
10019988:	e1a00003 	mov	r0, r3
1001998c:	e24bd000 	sub	sp, fp, #0
10019990:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019994:	e12fff1e 	bx	lr

10019998 <_do_push>:
};

static void _do_push(struct rt_prio_queue *que,
                     rt_uint8_t prio,
                     struct rt_prio_queue_item *item)
{
10019998:	e92d4800 	push	{fp, lr}
1001999c:	e28db004 	add	fp, sp, #4
100199a0:	e24dd010 	sub	sp, sp, #16
100199a4:	e50b0008 	str	r0, [fp, #-8]
100199a8:	e1a03001 	mov	r3, r1
100199ac:	e50b2010 	str	r2, [fp, #-16]
100199b0:	e54b3009 	strb	r3, [fp, #-9]
    if (que->head[prio] == RT_NULL)
100199b4:	e55b3009 	ldrb	r3, [fp, #-9]
100199b8:	e51b2008 	ldr	r2, [fp, #-8]
100199bc:	e1a03103 	lsl	r3, r3, #2
100199c0:	e0823003 	add	r3, r2, r3
100199c4:	e5933004 	ldr	r3, [r3, #4]
100199c8:	e3530000 	cmp	r3, #0
100199cc:	1a00000e 	bne	10019a0c <_do_push+0x74>
    {
        que->head[prio] = item;
100199d0:	e55b3009 	ldrb	r3, [fp, #-9]
100199d4:	e51b2008 	ldr	r2, [fp, #-8]
100199d8:	e1a03103 	lsl	r3, r3, #2
100199dc:	e0823003 	add	r3, r2, r3
100199e0:	e51b2010 	ldr	r2, [fp, #-16]
100199e4:	e5832004 	str	r2, [r3, #4]
        que->bitmap |= 1 << prio;
100199e8:	e51b3008 	ldr	r3, [fp, #-8]
100199ec:	e5933000 	ldr	r3, [r3]
100199f0:	e55b2009 	ldrb	r2, [fp, #-9]
100199f4:	e3a01001 	mov	r1, #1
100199f8:	e1a02211 	lsl	r2, r1, r2
100199fc:	e1832002 	orr	r2, r3, r2
10019a00:	e51b3008 	ldr	r3, [fp, #-8]
10019a04:	e5832000 	str	r2, [r3]
10019a08:	ea000015 	b	10019a64 <_do_push+0xcc>
    }
    else
    {
        RT_ASSERT(que->tail[prio]);
10019a0c:	e55b3009 	ldrb	r3, [fp, #-9]
10019a10:	e51b2008 	ldr	r2, [fp, #-8]
10019a14:	e2833020 	add	r3, r3, #32
10019a18:	e1a03103 	lsl	r3, r3, #2
10019a1c:	e0823003 	add	r3, r2, r3
10019a20:	e5933004 	ldr	r3, [r3, #4]
10019a24:	e3530000 	cmp	r3, #0
10019a28:	1a000005 	bne	10019a44 <_do_push+0xac>
10019a2c:	e3040408 	movw	r0, #17416	; 0x4408
10019a30:	e3410003 	movt	r0, #4099	; 0x1003
10019a34:	e3041480 	movw	r1, #17536	; 0x4480
10019a38:	e3411003 	movt	r1, #4099	; 0x1003
10019a3c:	e3a02033 	mov	r2, #51	; 0x33
10019a40:	ebffe8db 	bl	10013db4 <rt_assert_handler>
        que->tail[prio]->next = item;
10019a44:	e55b3009 	ldrb	r3, [fp, #-9]
10019a48:	e51b2008 	ldr	r2, [fp, #-8]
10019a4c:	e2833020 	add	r3, r3, #32
10019a50:	e1a03103 	lsl	r3, r3, #2
10019a54:	e0823003 	add	r3, r2, r3
10019a58:	e5933004 	ldr	r3, [r3, #4]
10019a5c:	e51b2010 	ldr	r2, [fp, #-16]
10019a60:	e5832000 	str	r2, [r3]
    }
    que->tail[prio] = item;
10019a64:	e55b3009 	ldrb	r3, [fp, #-9]
10019a68:	e51b2008 	ldr	r2, [fp, #-8]
10019a6c:	e2833020 	add	r3, r3, #32
10019a70:	e1a03103 	lsl	r3, r3, #2
10019a74:	e0823003 	add	r3, r2, r3
10019a78:	e51b2010 	ldr	r2, [fp, #-16]
10019a7c:	e5832004 	str	r2, [r3, #4]
}
10019a80:	e24bd004 	sub	sp, fp, #4
10019a84:	e8bd8800 	pop	{fp, pc}

10019a88 <_do_pop>:

static struct rt_prio_queue_item* _do_pop(struct rt_prio_queue *que)
{
10019a88:	e92d4800 	push	{fp, lr}
10019a8c:	e28db004 	add	fp, sp, #4
10019a90:	e24dd010 	sub	sp, sp, #16
10019a94:	e50b0010 	str	r0, [fp, #-16]
    int ffs;
    struct rt_prio_queue_item *item;

    ffs = __rt_ffs(que->bitmap);
10019a98:	e51b3010 	ldr	r3, [fp, #-16]
10019a9c:	e5933000 	ldr	r3, [r3]
10019aa0:	e1a00003 	mov	r0, r3
10019aa4:	ebffe881 	bl	10013cb0 <__rt_ffs>
10019aa8:	e50b0008 	str	r0, [fp, #-8]
    if (ffs == 0)
10019aac:	e51b3008 	ldr	r3, [fp, #-8]
10019ab0:	e3530000 	cmp	r3, #0
10019ab4:	1a000001 	bne	10019ac0 <_do_pop+0x38>
        return RT_NULL;
10019ab8:	e3a03000 	mov	r3, #0
10019abc:	ea000029 	b	10019b68 <_do_pop+0xe0>
    ffs--;
10019ac0:	e51b3008 	ldr	r3, [fp, #-8]
10019ac4:	e2433001 	sub	r3, r3, #1
10019ac8:	e50b3008 	str	r3, [fp, #-8]

    item = que->head[ffs];
10019acc:	e51b2010 	ldr	r2, [fp, #-16]
10019ad0:	e51b3008 	ldr	r3, [fp, #-8]
10019ad4:	e1a03103 	lsl	r3, r3, #2
10019ad8:	e0823003 	add	r3, r2, r3
10019adc:	e5933004 	ldr	r3, [r3, #4]
10019ae0:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(item);
10019ae4:	e51b300c 	ldr	r3, [fp, #-12]
10019ae8:	e3530000 	cmp	r3, #0
10019aec:	1a000005 	bne	10019b08 <_do_pop+0x80>
10019af0:	e3040418 	movw	r0, #17432	; 0x4418
10019af4:	e3410003 	movt	r0, #4099	; 0x1003
10019af8:	e304148c 	movw	r1, #17548	; 0x448c
10019afc:	e3411003 	movt	r1, #4099	; 0x1003
10019b00:	e3a02044 	mov	r2, #68	; 0x44
10019b04:	ebffe8aa 	bl	10013db4 <rt_assert_handler>

    que->head[ffs] = item->next;
10019b08:	e51b300c 	ldr	r3, [fp, #-12]
10019b0c:	e5932000 	ldr	r2, [r3]
10019b10:	e51b1010 	ldr	r1, [fp, #-16]
10019b14:	e51b3008 	ldr	r3, [fp, #-8]
10019b18:	e1a03103 	lsl	r3, r3, #2
10019b1c:	e0813003 	add	r3, r1, r3
10019b20:	e5832004 	str	r2, [r3, #4]
    if (que->head[ffs] == RT_NULL)
10019b24:	e51b2010 	ldr	r2, [fp, #-16]
10019b28:	e51b3008 	ldr	r3, [fp, #-8]
10019b2c:	e1a03103 	lsl	r3, r3, #2
10019b30:	e0823003 	add	r3, r2, r3
10019b34:	e5933004 	ldr	r3, [r3, #4]
10019b38:	e3530000 	cmp	r3, #0
10019b3c:	1a000008 	bne	10019b64 <_do_pop+0xdc>
    {
        que->bitmap &= ~(1 << ffs);
10019b40:	e51b3010 	ldr	r3, [fp, #-16]
10019b44:	e5933000 	ldr	r3, [r3]
10019b48:	e3a01001 	mov	r1, #1
10019b4c:	e51b2008 	ldr	r2, [fp, #-8]
10019b50:	e1a02211 	lsl	r2, r1, r2
10019b54:	e1e02002 	mvn	r2, r2
10019b58:	e0022003 	and	r2, r2, r3
10019b5c:	e51b3010 	ldr	r3, [fp, #-16]
10019b60:	e5832000 	str	r2, [r3]
    }

    return item;
10019b64:	e51b300c 	ldr	r3, [fp, #-12]
}
10019b68:	e1a00003 	mov	r0, r3
10019b6c:	e24bd004 	sub	sp, fp, #4
10019b70:	e8bd8800 	pop	{fp, pc}

10019b74 <rt_prio_queue_init>:
rt_err_t rt_prio_queue_init(struct rt_prio_queue *que,
                            const char *name,
                            void *buf,
                            rt_size_t bufsz,
                            rt_size_t itemsz)
{
10019b74:	e92d4800 	push	{fp, lr}
10019b78:	e28db004 	add	fp, sp, #4
10019b7c:	e24dd018 	sub	sp, sp, #24
10019b80:	e50b0008 	str	r0, [fp, #-8]
10019b84:	e50b100c 	str	r1, [fp, #-12]
10019b88:	e50b2010 	str	r2, [fp, #-16]
10019b8c:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(que);
10019b90:	e51b3008 	ldr	r3, [fp, #-8]
10019b94:	e3530000 	cmp	r3, #0
10019b98:	1a000005 	bne	10019bb4 <rt_prio_queue_init+0x40>
10019b9c:	e3040420 	movw	r0, #17440	; 0x4420
10019ba0:	e3410003 	movt	r0, #4099	; 0x1003
10019ba4:	e3041494 	movw	r1, #17556	; 0x4494
10019ba8:	e3411003 	movt	r1, #4099	; 0x1003
10019bac:	e3a02055 	mov	r2, #85	; 0x55
10019bb0:	ebffe87f 	bl	10013db4 <rt_assert_handler>

    rt_memset(que, 0, sizeof(*que));
10019bb4:	e51b0008 	ldr	r0, [fp, #-8]
10019bb8:	e3a01000 	mov	r1, #0
10019bbc:	e3a02f51 	mov	r2, #324	; 0x144
10019bc0:	ebffe1a4 	bl	10012258 <rt_memset>

    rt_list_init(&(que->suspended_pop_list));
10019bc4:	e51b3008 	ldr	r3, [fp, #-8]
10019bc8:	e2833f41 	add	r3, r3, #260	; 0x104
10019bcc:	e1a00003 	mov	r0, r3
10019bd0:	ebffff3d 	bl	100198cc <rt_list_init>

    rt_mp_init(&que->pool, name, buf, bufsz,
10019bd4:	e51b3008 	ldr	r3, [fp, #-8]
10019bd8:	e2832e11 	add	r2, r3, #272	; 0x110
10019bdc:	e59b3004 	ldr	r3, [fp, #4]
10019be0:	e2833004 	add	r3, r3, #4
10019be4:	e58d3000 	str	r3, [sp]
10019be8:	e1a00002 	mov	r0, r2
10019bec:	e51b100c 	ldr	r1, [fp, #-12]
10019bf0:	e51b2010 	ldr	r2, [fp, #-16]
10019bf4:	e51b3014 	ldr	r3, [fp, #-20]
10019bf8:	ebffecd3 	bl	10014f4c <rt_mp_init>
               sizeof(struct rt_prio_queue_item) + itemsz);

    que->item_sz = itemsz;
10019bfc:	e51b3008 	ldr	r3, [fp, #-8]
10019c00:	e59b2004 	ldr	r2, [fp, #4]
10019c04:	e583210c 	str	r2, [r3, #268]	; 0x10c

    return RT_EOK;
10019c08:	e3a03000 	mov	r3, #0
}
10019c0c:	e1a00003 	mov	r0, r3
10019c10:	e24bd004 	sub	sp, fp, #4
10019c14:	e8bd8800 	pop	{fp, pc}

10019c18 <rt_prio_queue_detach>:

void rt_prio_queue_detach(struct rt_prio_queue *que)
{
10019c18:	e92d4800 	push	{fp, lr}
10019c1c:	e28db004 	add	fp, sp, #4
10019c20:	e24dd010 	sub	sp, sp, #16
10019c24:	e50b0010 	str	r0, [fp, #-16]
    /* wake up all suspended pop threads, push thread is suspended on mempool.
     */
    while (!rt_list_isempty(&(que->suspended_pop_list)))
10019c28:	ea00000e 	b	10019c68 <rt_prio_queue_detach+0x50>
    {
        rt_thread_t thread;

        /* disable interrupt */
        rt_ubase_t temp = rt_hw_interrupt_disable();
10019c2c:	ebfffe7f 	bl	10019630 <rt_hw_interrupt_disable>
10019c30:	e1a03000 	mov	r3, r0
10019c34:	e50b3008 	str	r3, [fp, #-8]

        /* get next suspend thread */
        thread = rt_list_entry(que->suspended_pop_list.next, struct rt_thread, tlist);
10019c38:	e51b3010 	ldr	r3, [fp, #-16]
10019c3c:	e5933104 	ldr	r3, [r3, #260]	; 0x104
10019c40:	e2433010 	sub	r3, r3, #16
10019c44:	e50b300c 	str	r3, [fp, #-12]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
10019c48:	e51b300c 	ldr	r3, [fp, #-12]
10019c4c:	e3e02000 	mvn	r2, #0
10019c50:	e583202c 	str	r2, [r3, #44]	; 0x2c

        rt_thread_resume(thread);
10019c54:	e51b000c 	ldr	r0, [fp, #-12]
10019c58:	ebfff4c6 	bl	10016f78 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10019c5c:	e51b3008 	ldr	r3, [fp, #-8]
10019c60:	e1a00003 	mov	r0, r3
10019c64:	ebfffe75 	bl	10019640 <rt_hw_interrupt_enable>

void rt_prio_queue_detach(struct rt_prio_queue *que)
{
    /* wake up all suspended pop threads, push thread is suspended on mempool.
     */
    while (!rt_list_isempty(&(que->suspended_pop_list)))
10019c68:	e51b3010 	ldr	r3, [fp, #-16]
10019c6c:	e2833f41 	add	r3, r3, #260	; 0x104
10019c70:	e1a00003 	mov	r0, r3
10019c74:	ebffff38 	bl	1001995c <rt_list_isempty>
10019c78:	e1a03000 	mov	r3, r0
10019c7c:	e3530000 	cmp	r3, #0
10019c80:	0affffe9 	beq	10019c2c <rt_prio_queue_detach+0x14>
        rt_thread_resume(thread);

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }
    rt_mp_detach(&que->pool);
10019c84:	e51b3010 	ldr	r3, [fp, #-16]
10019c88:	e2833e11 	add	r3, r3, #272	; 0x110
10019c8c:	e1a00003 	mov	r0, r3
10019c90:	ebffed10 	bl	100150d8 <rt_mp_detach>
}
10019c94:	e24bd004 	sub	sp, fp, #4
10019c98:	e8bd8800 	pop	{fp, pc}

10019c9c <rt_prio_queue_create>:

#ifdef RT_USING_HEAP
struct rt_prio_queue* rt_prio_queue_create(const char *name,
                                           rt_size_t item_nr,
                                           rt_size_t item_sz)
{
10019c9c:	e92d4800 	push	{fp, lr}
10019ca0:	e28db004 	add	fp, sp, #4
10019ca4:	e24dd020 	sub	sp, sp, #32
10019ca8:	e50b0010 	str	r0, [fp, #-16]
10019cac:	e50b1014 	str	r1, [fp, #-20]
10019cb0:	e50b2018 	str	r2, [fp, #-24]
    struct rt_prio_queue *que;
    rt_size_t bufsz;

    bufsz = item_nr * (sizeof(struct rt_prio_queue_item)
                       + item_sz
                       + sizeof(void*));
10019cb4:	e51b3018 	ldr	r3, [fp, #-24]
10019cb8:	e2833008 	add	r3, r3, #8
                                           rt_size_t item_sz)
{
    struct rt_prio_queue *que;
    rt_size_t bufsz;

    bufsz = item_nr * (sizeof(struct rt_prio_queue_item)
10019cbc:	e51b2014 	ldr	r2, [fp, #-20]
10019cc0:	e0030392 	mul	r3, r2, r3
10019cc4:	e50b3008 	str	r3, [fp, #-8]
                       + item_sz
                       + sizeof(void*));

    RT_ASSERT(item_nr);
10019cc8:	e51b3014 	ldr	r3, [fp, #-20]
10019ccc:	e3530000 	cmp	r3, #0
10019cd0:	1a000005 	bne	10019cec <rt_prio_queue_create+0x50>
10019cd4:	e3040424 	movw	r0, #17444	; 0x4424
10019cd8:	e3410003 	movt	r0, #4099	; 0x1003
10019cdc:	e30414a8 	movw	r1, #17576	; 0x44a8
10019ce0:	e3411003 	movt	r1, #4099	; 0x1003
10019ce4:	e3a02087 	mov	r2, #135	; 0x87
10019ce8:	ebffe831 	bl	10013db4 <rt_assert_handler>

    que = rt_malloc(sizeof(*que) + bufsz);
10019cec:	e51b3008 	ldr	r3, [fp, #-8]
10019cf0:	e2833f51 	add	r3, r3, #324	; 0x144
10019cf4:	e1a00003 	mov	r0, r3
10019cf8:	ebffe965 	bl	10014294 <rt_malloc>
10019cfc:	e50b000c 	str	r0, [fp, #-12]
    if (!que)
10019d00:	e51b300c 	ldr	r3, [fp, #-12]
10019d04:	e3530000 	cmp	r3, #0
10019d08:	1a000001 	bne	10019d14 <rt_prio_queue_create+0x78>
        return RT_NULL;
10019d0c:	e3a03000 	mov	r3, #0
10019d10:	ea000008 	b	10019d38 <rt_prio_queue_create+0x9c>

    rt_prio_queue_init(que, name, que+1, bufsz, item_sz);
10019d14:	e51b300c 	ldr	r3, [fp, #-12]
10019d18:	e2832f51 	add	r2, r3, #324	; 0x144
10019d1c:	e51b3018 	ldr	r3, [fp, #-24]
10019d20:	e58d3000 	str	r3, [sp]
10019d24:	e51b000c 	ldr	r0, [fp, #-12]
10019d28:	e51b1010 	ldr	r1, [fp, #-16]
10019d2c:	e51b3008 	ldr	r3, [fp, #-8]
10019d30:	ebffff8f 	bl	10019b74 <rt_prio_queue_init>

    return que;
10019d34:	e51b300c 	ldr	r3, [fp, #-12]
}
10019d38:	e1a00003 	mov	r0, r3
10019d3c:	e24bd004 	sub	sp, fp, #4
10019d40:	e8bd8800 	pop	{fp, pc}

10019d44 <rt_prio_queue_delete>:

void rt_prio_queue_delete(struct rt_prio_queue *que)
{
10019d44:	e92d4800 	push	{fp, lr}
10019d48:	e28db004 	add	fp, sp, #4
10019d4c:	e24dd008 	sub	sp, sp, #8
10019d50:	e50b0008 	str	r0, [fp, #-8]
    rt_prio_queue_detach(que);
10019d54:	e51b0008 	ldr	r0, [fp, #-8]
10019d58:	ebffffae 	bl	10019c18 <rt_prio_queue_detach>
    rt_free(que);
10019d5c:	e51b0008 	ldr	r0, [fp, #-8]
10019d60:	ebffeb66 	bl	10014b00 <rt_free>
}
10019d64:	e24bd004 	sub	sp, fp, #4
10019d68:	e8bd8800 	pop	{fp, pc}

10019d6c <rt_prio_queue_push>:

rt_err_t rt_prio_queue_push(struct rt_prio_queue *que,
                            rt_uint8_t prio,
                            void *data,
                            rt_int32_t timeout)
{
10019d6c:	e92d4800 	push	{fp, lr}
10019d70:	e28db004 	add	fp, sp, #4
10019d74:	e24dd020 	sub	sp, sp, #32
10019d78:	e50b0018 	str	r0, [fp, #-24]
10019d7c:	e50b2020 	str	r2, [fp, #-32]
10019d80:	e50b3024 	str	r3, [fp, #-36]	; 0x24
10019d84:	e1a03001 	mov	r3, r1
10019d88:	e54b3019 	strb	r3, [fp, #-25]
    rt_ubase_t level;
    struct rt_prio_queue_item *item;

    RT_ASSERT(que);
10019d8c:	e51b3018 	ldr	r3, [fp, #-24]
10019d90:	e3530000 	cmp	r3, #0
10019d94:	1a000005 	bne	10019db0 <rt_prio_queue_push+0x44>
10019d98:	e3040420 	movw	r0, #17440	; 0x4420
10019d9c:	e3410003 	movt	r0, #4099	; 0x1003
10019da0:	e30414c0 	movw	r1, #17600	; 0x44c0
10019da4:	e3411003 	movt	r1, #4099	; 0x1003
10019da8:	e3a020a1 	mov	r2, #161	; 0xa1
10019dac:	ebffe800 	bl	10013db4 <rt_assert_handler>

    if (prio >= RT_PRIO_QUEUE_PRIO_MAX)
10019db0:	e55b3019 	ldrb	r3, [fp, #-25]
10019db4:	e353001f 	cmp	r3, #31
10019db8:	9a000001 	bls	10019dc4 <rt_prio_queue_push+0x58>
        return -RT_ERROR;
10019dbc:	e3e03000 	mvn	r3, #0
10019dc0:	ea000034 	b	10019e98 <rt_prio_queue_push+0x12c>

    item = rt_mp_alloc(&que->pool, timeout);
10019dc4:	e51b3018 	ldr	r3, [fp, #-24]
10019dc8:	e2833e11 	add	r3, r3, #272	; 0x110
10019dcc:	e1a00003 	mov	r0, r3
10019dd0:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
10019dd4:	ebffedae 	bl	10015494 <rt_mp_alloc>
10019dd8:	e50b0008 	str	r0, [fp, #-8]
    if (item == RT_NULL)
10019ddc:	e51b3008 	ldr	r3, [fp, #-8]
10019de0:	e3530000 	cmp	r3, #0
10019de4:	1a000001 	bne	10019df0 <rt_prio_queue_push+0x84>
        return -RT_ENOMEM;
10019de8:	e3e03004 	mvn	r3, #4
10019dec:	ea000029 	b	10019e98 <rt_prio_queue_push+0x12c>

    rt_memcpy(item+1, data, que->item_sz);
10019df0:	e51b3008 	ldr	r3, [fp, #-8]
10019df4:	e2832004 	add	r2, r3, #4
10019df8:	e51b3018 	ldr	r3, [fp, #-24]
10019dfc:	e593310c 	ldr	r3, [r3, #268]	; 0x10c
10019e00:	e1a00002 	mov	r0, r2
10019e04:	e51b1020 	ldr	r1, [fp, #-32]
10019e08:	e1a02003 	mov	r2, r3
10019e0c:	ebffe169 	bl	100123b8 <rt_memcpy>
    item->next = RT_NULL;
10019e10:	e51b3008 	ldr	r3, [fp, #-8]
10019e14:	e3a02000 	mov	r2, #0
10019e18:	e5832000 	str	r2, [r3]

    level = rt_hw_interrupt_disable();
10019e1c:	ebfffe03 	bl	10019630 <rt_hw_interrupt_disable>
10019e20:	e1a03000 	mov	r3, r0
10019e24:	e50b300c 	str	r3, [fp, #-12]

    _do_push(que, prio, item);
10019e28:	e55b3019 	ldrb	r3, [fp, #-25]
10019e2c:	e51b0018 	ldr	r0, [fp, #-24]
10019e30:	e1a01003 	mov	r1, r3
10019e34:	e51b2008 	ldr	r2, [fp, #-8]
10019e38:	ebfffed6 	bl	10019998 <_do_push>

    if (!rt_list_isempty(&(que->suspended_pop_list)))
10019e3c:	e51b3018 	ldr	r3, [fp, #-24]
10019e40:	e2833f41 	add	r3, r3, #260	; 0x104
10019e44:	e1a00003 	mov	r0, r3
10019e48:	ebfffec3 	bl	1001995c <rt_list_isempty>
10019e4c:	e1a03000 	mov	r3, r0
10019e50:	e3530000 	cmp	r3, #0
10019e54:	1a00000b 	bne	10019e88 <rt_prio_queue_push+0x11c>
    {
        rt_thread_t thread;

        /* get thread entry */
        thread = rt_list_entry(que->suspended_pop_list.next,
10019e58:	e51b3018 	ldr	r3, [fp, #-24]
10019e5c:	e5933104 	ldr	r3, [r3, #260]	; 0x104
10019e60:	e2433010 	sub	r3, r3, #16
10019e64:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);
        /* resume it */
        rt_thread_resume(thread);
10019e68:	e51b0010 	ldr	r0, [fp, #-16]
10019e6c:	ebfff441 	bl	10016f78 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
10019e70:	e51b300c 	ldr	r3, [fp, #-12]
10019e74:	e1a00003 	mov	r0, r3
10019e78:	ebfffdf0 	bl	10019640 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
10019e7c:	ebfff0c8 	bl	100161a4 <rt_schedule>

        return RT_EOK;
10019e80:	e3a03000 	mov	r3, #0
10019e84:	ea000003 	b	10019e98 <rt_prio_queue_push+0x12c>
    }

    rt_hw_interrupt_enable(level);
10019e88:	e51b300c 	ldr	r3, [fp, #-12]
10019e8c:	e1a00003 	mov	r0, r3
10019e90:	ebfffdea 	bl	10019640 <rt_hw_interrupt_enable>

    return RT_EOK;
10019e94:	e3a03000 	mov	r3, #0
}
10019e98:	e1a00003 	mov	r0, r3
10019e9c:	e24bd004 	sub	sp, fp, #4
10019ea0:	e8bd8800 	pop	{fp, pc}

10019ea4 <rt_prio_queue_pop>:

rt_err_t rt_prio_queue_pop(struct rt_prio_queue *que,
                           void *data,
                           rt_int32_t timeout)
{
10019ea4:	e92d4800 	push	{fp, lr}
10019ea8:	e28db004 	add	fp, sp, #4
10019eac:	e24dd020 	sub	sp, sp, #32
10019eb0:	e50b0018 	str	r0, [fp, #-24]
10019eb4:	e50b101c 	str	r1, [fp, #-28]
10019eb8:	e50b2020 	str	r2, [fp, #-32]
    rt_ubase_t level;
    struct rt_prio_queue_item *item;

    RT_ASSERT(que);
10019ebc:	e51b3018 	ldr	r3, [fp, #-24]
10019ec0:	e3530000 	cmp	r3, #0
10019ec4:	1a000005 	bne	10019ee0 <rt_prio_queue_pop+0x3c>
10019ec8:	e3040420 	movw	r0, #17440	; 0x4420
10019ecc:	e3410003 	movt	r0, #4099	; 0x1003
10019ed0:	e30414d4 	movw	r1, #17620	; 0x44d4
10019ed4:	e3411003 	movt	r1, #4099	; 0x1003
10019ed8:	e3a020cf 	mov	r2, #207	; 0xcf
10019edc:	ebffe7b4 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(data);
10019ee0:	e51b301c 	ldr	r3, [fp, #-28]
10019ee4:	e3530000 	cmp	r3, #0
10019ee8:	1a000005 	bne	10019f04 <rt_prio_queue_pop+0x60>
10019eec:	e304042c 	movw	r0, #17452	; 0x442c
10019ef0:	e3410003 	movt	r0, #4099	; 0x1003
10019ef4:	e30414d4 	movw	r1, #17620	; 0x44d4
10019ef8:	e3411003 	movt	r1, #4099	; 0x1003
10019efc:	e3a020d0 	mov	r2, #208	; 0xd0
10019f00:	ebffe7ab 	bl	10013db4 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
10019f04:	ebfffdc9 	bl	10019630 <rt_hw_interrupt_disable>
10019f08:	e1a03000 	mov	r3, r0
10019f0c:	e50b3008 	str	r3, [fp, #-8]
    for (item = _do_pop(que);
10019f10:	e51b0018 	ldr	r0, [fp, #-24]
10019f14:	ebfffedb 	bl	10019a88 <_do_pop>
10019f18:	e50b000c 	str	r0, [fp, #-12]
10019f1c:	ea000047 	b	1001a040 <rt_prio_queue_pop+0x19c>
         item == RT_NULL;
         item = _do_pop(que))
    {
        rt_thread_t thread;

        if (timeout == 0)
10019f20:	e51b3020 	ldr	r3, [fp, #-32]
10019f24:	e3530000 	cmp	r3, #0
10019f28:	1a000004 	bne	10019f40 <rt_prio_queue_pop+0x9c>
        {
            rt_hw_interrupt_enable(level);
10019f2c:	e51b3008 	ldr	r3, [fp, #-8]
10019f30:	e1a00003 	mov	r0, r3
10019f34:	ebfffdc1 	bl	10019640 <rt_hw_interrupt_enable>
            return -RT_ETIMEOUT;
10019f38:	e3e03001 	mvn	r3, #1
10019f3c:	ea000050 	b	1001a084 <rt_prio_queue_pop+0x1e0>
        }

        RT_DEBUG_NOT_IN_INTERRUPT;
10019f40:	ebfffdba 	bl	10019630 <rt_hw_interrupt_disable>
10019f44:	e50b0010 	str	r0, [fp, #-16]
10019f48:	ebffe06c 	bl	10012100 <rt_interrupt_get_nest>
10019f4c:	e1a03000 	mov	r3, r0
10019f50:	e3530000 	cmp	r3, #0
10019f54:	0a00000a 	beq	10019f84 <rt_prio_queue_pop+0xe0>
10019f58:	e3040434 	movw	r0, #17460	; 0x4434
10019f5c:	e3410003 	movt	r0, #4099	; 0x1003
10019f60:	e30414d4 	movw	r1, #17620	; 0x44d4
10019f64:	e3411003 	movt	r1, #4099	; 0x1003
10019f68:	ebffe6d4 	bl	10013ac0 <rt_kprintf>
10019f6c:	e3040458 	movw	r0, #17496	; 0x4458
10019f70:	e3410003 	movt	r0, #4099	; 0x1003
10019f74:	e30414d4 	movw	r1, #17620	; 0x44d4
10019f78:	e3411003 	movt	r1, #4099	; 0x1003
10019f7c:	e3a020df 	mov	r2, #223	; 0xdf
10019f80:	ebffe78b 	bl	10013db4 <rt_assert_handler>
10019f84:	e51b0010 	ldr	r0, [fp, #-16]
10019f88:	ebfffdac 	bl	10019640 <rt_hw_interrupt_enable>

        thread = rt_thread_self();
10019f8c:	ebfff273 	bl	10016960 <rt_thread_self>
10019f90:	e50b0014 	str	r0, [fp, #-20]
        thread->error = RT_EOK;
10019f94:	e51b3014 	ldr	r3, [fp, #-20]
10019f98:	e3a02000 	mov	r2, #0
10019f9c:	e583202c 	str	r2, [r3, #44]	; 0x2c
        rt_thread_suspend(thread);
10019fa0:	e51b0014 	ldr	r0, [fp, #-20]
10019fa4:	ebfff3cf 	bl	10016ee8 <rt_thread_suspend>

        rt_list_insert_before(&(que->suspended_pop_list), &(thread->tlist));
10019fa8:	e51b3018 	ldr	r3, [fp, #-24]
10019fac:	e2832f41 	add	r2, r3, #260	; 0x104
10019fb0:	e51b3014 	ldr	r3, [fp, #-20]
10019fb4:	e2833010 	add	r3, r3, #16
10019fb8:	e1a00002 	mov	r0, r2
10019fbc:	e1a01003 	mov	r1, r3
10019fc0:	ebfffe4f 	bl	10019904 <rt_list_insert_before>

        if (timeout > 0)
10019fc4:	e51b3020 	ldr	r3, [fp, #-32]
10019fc8:	e3530000 	cmp	r3, #0
10019fcc:	da00000a 	ble	10019ffc <rt_prio_queue_pop+0x158>
        {
            rt_timer_control(&(thread->thread_timer),
10019fd0:	e51b3014 	ldr	r3, [fp, #-20]
10019fd4:	e2832048 	add	r2, r3, #72	; 0x48
10019fd8:	e24b3020 	sub	r3, fp, #32
10019fdc:	e1a00002 	mov	r0, r2
10019fe0:	e3a01000 	mov	r1, #0
10019fe4:	e1a02003 	mov	r2, r3
10019fe8:	ebfff66d 	bl	100179a4 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10019fec:	e51b3014 	ldr	r3, [fp, #-20]
10019ff0:	e2833048 	add	r3, r3, #72	; 0x48
10019ff4:	e1a00003 	mov	r0, r3
10019ff8:	ebfff573 	bl	100175cc <rt_timer_start>
        }

        rt_hw_interrupt_enable(level);
10019ffc:	e51b3008 	ldr	r3, [fp, #-8]
1001a000:	e1a00003 	mov	r0, r3
1001a004:	ebfffd8d 	bl	10019640 <rt_hw_interrupt_enable>

        rt_schedule();
1001a008:	ebfff065 	bl	100161a4 <rt_schedule>

        /* thread is waked up */
        if (thread->error != RT_EOK)
1001a00c:	e51b3014 	ldr	r3, [fp, #-20]
1001a010:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001a014:	e3530000 	cmp	r3, #0
1001a018:	0a000002 	beq	1001a028 <rt_prio_queue_pop+0x184>
            return thread->error;
1001a01c:	e51b3014 	ldr	r3, [fp, #-20]
1001a020:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001a024:	ea000016 	b	1001a084 <rt_prio_queue_pop+0x1e0>
        level = rt_hw_interrupt_disable();
1001a028:	ebfffd80 	bl	10019630 <rt_hw_interrupt_disable>
1001a02c:	e1a03000 	mov	r3, r0
1001a030:	e50b3008 	str	r3, [fp, #-8]
    RT_ASSERT(data);

    level = rt_hw_interrupt_disable();
    for (item = _do_pop(que);
         item == RT_NULL;
         item = _do_pop(que))
1001a034:	e51b0018 	ldr	r0, [fp, #-24]
1001a038:	ebfffe92 	bl	10019a88 <_do_pop>
1001a03c:	e50b000c 	str	r0, [fp, #-12]

    RT_ASSERT(que);
    RT_ASSERT(data);

    level = rt_hw_interrupt_disable();
    for (item = _do_pop(que);
1001a040:	e51b300c 	ldr	r3, [fp, #-12]
1001a044:	e3530000 	cmp	r3, #0
1001a048:	0affffb4 	beq	10019f20 <rt_prio_queue_pop+0x7c>
        if (thread->error != RT_EOK)
            return thread->error;
        level = rt_hw_interrupt_disable();
    }

    rt_hw_interrupt_enable(level);
1001a04c:	e51b3008 	ldr	r3, [fp, #-8]
1001a050:	e1a00003 	mov	r0, r3
1001a054:	ebfffd79 	bl	10019640 <rt_hw_interrupt_enable>

    rt_memcpy(data, item+1, que->item_sz);
1001a058:	e51b300c 	ldr	r3, [fp, #-12]
1001a05c:	e2832004 	add	r2, r3, #4
1001a060:	e51b3018 	ldr	r3, [fp, #-24]
1001a064:	e593310c 	ldr	r3, [r3, #268]	; 0x10c
1001a068:	e51b001c 	ldr	r0, [fp, #-28]
1001a06c:	e1a01002 	mov	r1, r2
1001a070:	e1a02003 	mov	r2, r3
1001a074:	ebffe0cf 	bl	100123b8 <rt_memcpy>
    rt_mp_free(item);
1001a078:	e51b000c 	ldr	r0, [fp, #-12]
1001a07c:	ebffed97 	bl	100156e0 <rt_mp_free>

    return RT_EOK;
1001a080:	e3a03000 	mov	r3, #0
}
1001a084:	e1a00003 	mov	r0, r3
1001a088:	e24bd004 	sub	sp, fp, #4
1001a08c:	e8bd8800 	pop	{fp, pc}

1001a090 <rt_prio_queue_dump>:

void rt_prio_queue_dump(struct rt_prio_queue *que)
{
1001a090:	e92d4800 	push	{fp, lr}
1001a094:	e28db004 	add	fp, sp, #4
1001a098:	e24dd010 	sub	sp, sp, #16
1001a09c:	e50b0010 	str	r0, [fp, #-16]
    int level = 0;
1001a0a0:	e3a03000 	mov	r3, #0
1001a0a4:	e50b3008 	str	r3, [fp, #-8]

    rt_kprintf("bitmap: %08x\n", que->bitmap);
1001a0a8:	e51b3010 	ldr	r3, [fp, #-16]
1001a0ac:	e5933000 	ldr	r3, [r3]
1001a0b0:	e304045c 	movw	r0, #17500	; 0x445c
1001a0b4:	e3410003 	movt	r0, #4099	; 0x1003
1001a0b8:	e1a01003 	mov	r1, r3
1001a0bc:	ebffe67f 	bl	10013ac0 <rt_kprintf>
    for (level = 0; level < RT_PRIO_QUEUE_PRIO_MAX; level++)
1001a0c0:	e3a03000 	mov	r3, #0
1001a0c4:	e50b3008 	str	r3, [fp, #-8]
1001a0c8:	ea00001a 	b	1001a138 <rt_prio_queue_dump+0xa8>
    {
        struct rt_prio_queue_item *item;

        rt_kprintf("%2d: ", level);
1001a0cc:	e304046c 	movw	r0, #17516	; 0x446c
1001a0d0:	e3410003 	movt	r0, #4099	; 0x1003
1001a0d4:	e51b1008 	ldr	r1, [fp, #-8]
1001a0d8:	ebffe678 	bl	10013ac0 <rt_kprintf>
        for (item = que->head[level];
1001a0dc:	e51b2010 	ldr	r2, [fp, #-16]
1001a0e0:	e51b3008 	ldr	r3, [fp, #-8]
1001a0e4:	e1a03103 	lsl	r3, r3, #2
1001a0e8:	e0823003 	add	r3, r2, r3
1001a0ec:	e5933004 	ldr	r3, [r3, #4]
1001a0f0:	e50b300c 	str	r3, [fp, #-12]
1001a0f4:	ea000006 	b	1001a114 <rt_prio_queue_dump+0x84>
             item;
             item = item->next)
        {
            rt_kprintf("%p, ", item);
1001a0f8:	e3040474 	movw	r0, #17524	; 0x4474
1001a0fc:	e3410003 	movt	r0, #4099	; 0x1003
1001a100:	e51b100c 	ldr	r1, [fp, #-12]
1001a104:	ebffe66d 	bl	10013ac0 <rt_kprintf>
        struct rt_prio_queue_item *item;

        rt_kprintf("%2d: ", level);
        for (item = que->head[level];
             item;
             item = item->next)
1001a108:	e51b300c 	ldr	r3, [fp, #-12]
1001a10c:	e5933000 	ldr	r3, [r3]
1001a110:	e50b300c 	str	r3, [fp, #-12]
    for (level = 0; level < RT_PRIO_QUEUE_PRIO_MAX; level++)
    {
        struct rt_prio_queue_item *item;

        rt_kprintf("%2d: ", level);
        for (item = que->head[level];
1001a114:	e51b300c 	ldr	r3, [fp, #-12]
1001a118:	e3530000 	cmp	r3, #0
1001a11c:	1afffff5 	bne	1001a0f8 <rt_prio_queue_dump+0x68>
             item;
             item = item->next)
        {
            rt_kprintf("%p, ", item);
        }
        rt_kprintf("\n");
1001a120:	e304047c 	movw	r0, #17532	; 0x447c
1001a124:	e3410003 	movt	r0, #4099	; 0x1003
1001a128:	ebffe664 	bl	10013ac0 <rt_kprintf>
void rt_prio_queue_dump(struct rt_prio_queue *que)
{
    int level = 0;

    rt_kprintf("bitmap: %08x\n", que->bitmap);
    for (level = 0; level < RT_PRIO_QUEUE_PRIO_MAX; level++)
1001a12c:	e51b3008 	ldr	r3, [fp, #-8]
1001a130:	e2833001 	add	r3, r3, #1
1001a134:	e50b3008 	str	r3, [fp, #-8]
1001a138:	e51b3008 	ldr	r3, [fp, #-8]
1001a13c:	e353001f 	cmp	r3, #31
1001a140:	daffffe1 	ble	1001a0cc <rt_prio_queue_dump+0x3c>
        {
            rt_kprintf("%p, ", item);
        }
        rt_kprintf("\n");
    }
}
1001a144:	e24bd004 	sub	sp, fp, #4
1001a148:	e8bd8800 	pop	{fp, pc}

1001a14c <rt_vbus_tick>:
#include <board.h>
#include "xpseudo_asm_gcc.h"


rt_inline void rt_vbus_tick(unsigned int target_cpu, unsigned int irqnr)
{
1001a14c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001a150:	e28db000 	add	fp, sp, #0
1001a154:	e24dd00c 	sub	sp, sp, #12
1001a158:	e50b0008 	str	r0, [fp, #-8]
1001a15c:	e50b100c 	str	r1, [fp, #-12]
    //__SEV();
}
1001a160:	e24bd000 	sub	sp, fp, #0
1001a164:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001a168:	e12fff1e 	bx	lr

1001a16c <rt_vbus_smp_rmb>:

/* Read memory barrier. */
rt_inline void rt_vbus_smp_rmb(void)
{
1001a16c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001a170:	e28db000 	add	fp, sp, #0
	dmb();
1001a174:	f57ff05f 	dmb	sy
}
1001a178:	e24bd000 	sub	sp, fp, #0
1001a17c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001a180:	e12fff1e 	bx	lr

1001a184 <rt_vbus_smp_wmb>:

/* Write memory barrier. */
rt_inline void rt_vbus_smp_wmb(void)
{
1001a184:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001a188:	e28db000 	add	fp, sp, #0
	dmb();
1001a18c:	f57ff05f 	dmb	sy
}
1001a190:	e24bd000 	sub	sp, fp, #0
1001a194:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001a198:	e12fff1e 	bx	lr

1001a19c <_ring_add_get_bnr>:
                          + sizeof(struct rt_vbus_blk) - 1) \
                         / sizeof(struct rt_vbus_blk))

rt_inline void _ring_add_get_bnr(struct rt_vbus_ring *ring,
                                 rt_size_t bnr)
{
1001a19c:	e92d4800 	push	{fp, lr}
1001a1a0:	e28db004 	add	fp, sp, #4
1001a1a4:	e24dd010 	sub	sp, sp, #16
1001a1a8:	e50b0010 	str	r0, [fp, #-16]
1001a1ac:	e50b1014 	str	r1, [fp, #-20]
    int nidx = ring->get_idx + bnr;
1001a1b0:	e51b3010 	ldr	r3, [fp, #-16]
1001a1b4:	e5932004 	ldr	r2, [r3, #4]
1001a1b8:	e51b3014 	ldr	r3, [fp, #-20]
1001a1bc:	e0823003 	add	r3, r2, r3
1001a1c0:	e50b3008 	str	r3, [fp, #-8]

    if (nidx >= RT_VMM_RB_BLK_NR)
1001a1c4:	e51b3008 	ldr	r3, [fp, #-8]
1001a1c8:	e3530013 	cmp	r3, #19
1001a1cc:	da000002 	ble	1001a1dc <_ring_add_get_bnr+0x40>
    {
        nidx -= RT_VMM_RB_BLK_NR;
1001a1d0:	e51b3008 	ldr	r3, [fp, #-8]
1001a1d4:	e2433014 	sub	r3, r3, #20
1001a1d8:	e50b3008 	str	r3, [fp, #-8]
    }
    rt_vbus_smp_wmb();
1001a1dc:	ebffffe8 	bl	1001a184 <rt_vbus_smp_wmb>
    ring->get_idx = nidx;
1001a1e0:	e51b2008 	ldr	r2, [fp, #-8]
1001a1e4:	e51b3010 	ldr	r3, [fp, #-16]
1001a1e8:	e5832004 	str	r2, [r3, #4]
}
1001a1ec:	e24bd004 	sub	sp, fp, #4
1001a1f0:	e8bd8800 	pop	{fp, pc}

1001a1f4 <_bus_ring_space_nr>:

rt_inline int _bus_ring_space_nr(struct rt_vbus_ring *rg)
{
1001a1f4:	e92d4800 	push	{fp, lr}
1001a1f8:	e28db004 	add	fp, sp, #4
1001a1fc:	e24dd010 	sub	sp, sp, #16
1001a200:	e50b0010 	str	r0, [fp, #-16]
    int delta;

    rt_vbus_smp_rmb();
1001a204:	ebffffd8 	bl	1001a16c <rt_vbus_smp_rmb>
    delta = rg->get_idx - rg->put_idx;
1001a208:	e51b3010 	ldr	r3, [fp, #-16]
1001a20c:	e5932004 	ldr	r2, [r3, #4]
1001a210:	e51b3010 	ldr	r3, [fp, #-16]
1001a214:	e5933000 	ldr	r3, [r3]
1001a218:	e0633002 	rsb	r3, r3, r2
1001a21c:	e50b3008 	str	r3, [fp, #-8]

    if (delta > 0)
1001a220:	e51b3008 	ldr	r3, [fp, #-8]
1001a224:	e3530000 	cmp	r3, #0
1001a228:	da000002 	ble	1001a238 <_bus_ring_space_nr+0x44>
    {
        /* Put is behind the get. */
        return delta - 1;
1001a22c:	e51b3008 	ldr	r3, [fp, #-8]
1001a230:	e2433001 	sub	r3, r3, #1
1001a234:	ea000001 	b	1001a240 <_bus_ring_space_nr+0x4c>
    }
    else
    {
        /* delta is negative. */
        return RT_VMM_RB_BLK_NR + delta - 1;
1001a238:	e51b3008 	ldr	r3, [fp, #-8]
1001a23c:	e2833013 	add	r3, r3, #19
    }
}
1001a240:	e1a00003 	mov	r0, r3
1001a244:	e24bd004 	sub	sp, fp, #4
1001a248:	e8bd8800 	pop	{fp, pc}

1001a24c <_chn_connected>:

/* chn0 is always connected */
static enum rt_vbus_chn_status _chn_status[RT_VBUS_CHANNEL_NR];

rt_inline int _chn_connected(unsigned char chnr)
{
1001a24c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001a250:	e28db000 	add	fp, sp, #0
1001a254:	e24dd00c 	sub	sp, sp, #12
1001a258:	e1a03000 	mov	r3, r0
1001a25c:	e54b3005 	strb	r3, [fp, #-5]
    return _chn_status[chnr] == RT_VBUS_CHN_ST_ESTABLISHED ||
1001a260:	e55b2005 	ldrb	r2, [fp, #-5]
1001a264:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001a268:	e3413003 	movt	r3, #4099	; 0x1003
1001a26c:	e7d33002 	ldrb	r3, [r3, r2]
1001a270:	e3530003 	cmp	r3, #3
1001a274:	0a000005 	beq	1001a290 <_chn_connected+0x44>
           _chn_status[chnr] == RT_VBUS_CHN_ST_SUSPEND;
1001a278:	e55b2005 	ldrb	r2, [fp, #-5]
1001a27c:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001a280:	e3413003 	movt	r3, #4099	; 0x1003
1001a284:	e7d33002 	ldrb	r3, [r3, r2]
/* chn0 is always connected */
static enum rt_vbus_chn_status _chn_status[RT_VBUS_CHANNEL_NR];

rt_inline int _chn_connected(unsigned char chnr)
{
    return _chn_status[chnr] == RT_VBUS_CHN_ST_ESTABLISHED ||
1001a288:	e3530004 	cmp	r3, #4
1001a28c:	1a000001 	bne	1001a298 <_chn_connected+0x4c>
1001a290:	e3a03001 	mov	r3, #1
1001a294:	ea000000 	b	1001a29c <_chn_connected+0x50>
1001a298:	e3a03000 	mov	r3, #0
           _chn_status[chnr] == RT_VBUS_CHN_ST_SUSPEND;
}
1001a29c:	e1a00003 	mov	r0, r3
1001a2a0:	e24bd000 	sub	sp, fp, #0
1001a2a4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001a2a8:	e12fff1e 	bx	lr

1001a2ac <rt_vbus_set_recv_wm>:
    _chn_recv_wm[chnr].low_mark = low;
    _chn_recv_wm[chnr].high_mark = high;
}
#else
void rt_vbus_set_recv_wm(unsigned char chnr, unsigned int low, unsigned int high)
{}
1001a2ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001a2b0:	e28db000 	add	fp, sp, #0
1001a2b4:	e24dd014 	sub	sp, sp, #20
1001a2b8:	e1a03000 	mov	r3, r0
1001a2bc:	e50b100c 	str	r1, [fp, #-12]
1001a2c0:	e50b2010 	str	r2, [fp, #-16]
1001a2c4:	e54b3005 	strb	r3, [fp, #-5]
1001a2c8:	e24bd000 	sub	sp, fp, #0
1001a2cc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001a2d0:	e12fff1e 	bx	lr

1001a2d4 <rt_vbus_set_post_wm>:
void rt_vbus_set_post_wm(unsigned char chnr, unsigned int low, unsigned int high)
{}
1001a2d4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001a2d8:	e28db000 	add	fp, sp, #0
1001a2dc:	e24dd014 	sub	sp, sp, #20
1001a2e0:	e1a03000 	mov	r3, r0
1001a2e4:	e50b100c 	str	r1, [fp, #-12]
1001a2e8:	e50b2010 	str	r2, [fp, #-16]
1001a2ec:	e54b3005 	strb	r3, [fp, #-5]
1001a2f0:	e24bd000 	sub	sp, fp, #0
1001a2f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001a2f8:	e12fff1e 	bx	lr

1001a2fc <rt_vbus_register_listener>:

void rt_vbus_register_listener(unsigned char chnr,
                               enum rt_vbus_event_id eve,
                               rt_vbus_event_listener indi,
                               void *ctx)
{
1001a2fc:	e92d4800 	push	{fp, lr}
1001a300:	e28db004 	add	fp, sp, #4
1001a304:	e24dd010 	sub	sp, sp, #16
1001a308:	e50b200c 	str	r2, [fp, #-12]
1001a30c:	e50b3010 	str	r3, [fp, #-16]
1001a310:	e1a03000 	mov	r3, r0
1001a314:	e54b3005 	strb	r3, [fp, #-5]
1001a318:	e1a03001 	mov	r3, r1
1001a31c:	e54b3006 	strb	r3, [fp, #-6]
    RT_ASSERT(chnr != 0 && chnr < RT_VBUS_CHANNEL_NR);
1001a320:	e55b3005 	ldrb	r3, [fp, #-5]
1001a324:	e3530000 	cmp	r3, #0
1001a328:	0a000002 	beq	1001a338 <rt_vbus_register_listener+0x3c>
1001a32c:	e55b3005 	ldrb	r3, [fp, #-5]
1001a330:	e353001f 	cmp	r3, #31
1001a334:	9a000005 	bls	1001a350 <rt_vbus_register_listener+0x54>
1001a338:	e3040564 	movw	r0, #17764	; 0x4564
1001a33c:	e3410003 	movt	r0, #4099	; 0x1003
1001a340:	e3041898 	movw	r1, #18584	; 0x4898
1001a344:	e3411003 	movt	r1, #4099	; 0x1003
1001a348:	e3a020d3 	mov	r2, #211	; 0xd3
1001a34c:	ebffe698 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(eve < sizeof(_vbus_rx_indi)/sizeof(_vbus_rx_indi[0]));
1001a350:	e55b3006 	ldrb	r3, [fp, #-6]
1001a354:	e3530002 	cmp	r3, #2
1001a358:	9a000005 	bls	1001a374 <rt_vbus_register_listener+0x78>
1001a35c:	e304058c 	movw	r0, #17804	; 0x458c
1001a360:	e3410003 	movt	r0, #4099	; 0x1003
1001a364:	e3041898 	movw	r1, #18584	; 0x4898
1001a368:	e3411003 	movt	r1, #4099	; 0x1003
1001a36c:	e3a020d4 	mov	r2, #212	; 0xd4
1001a370:	ebffe68f 	bl	10013db4 <rt_assert_handler>

    _vbus_rx_indi[eve][chnr].indicate = indi;
1001a374:	e55b1006 	ldrb	r1, [fp, #-6]
1001a378:	e55b2005 	ldrb	r2, [fp, #-5]
1001a37c:	e3033248 	movw	r3, #12872	; 0x3248
1001a380:	e3413004 	movt	r3, #4100	; 0x1004
1001a384:	e1a01281 	lsl	r1, r1, #5
1001a388:	e0812002 	add	r2, r1, r2
1001a38c:	e51b100c 	ldr	r1, [fp, #-12]
1001a390:	e7831182 	str	r1, [r3, r2, lsl #3]
    _vbus_rx_indi[eve][chnr].ctx = ctx;
1001a394:	e55b1006 	ldrb	r1, [fp, #-6]
1001a398:	e55b3005 	ldrb	r3, [fp, #-5]
1001a39c:	e3032248 	movw	r2, #12872	; 0x3248
1001a3a0:	e3412004 	movt	r2, #4100	; 0x1004
1001a3a4:	e1a01281 	lsl	r1, r1, #5
1001a3a8:	e0813003 	add	r3, r1, r3
1001a3ac:	e1a03183 	lsl	r3, r3, #3
1001a3b0:	e0823003 	add	r3, r2, r3
1001a3b4:	e51b2010 	ldr	r2, [fp, #-16]
1001a3b8:	e5832004 	str	r2, [r3, #4]
}
1001a3bc:	e24bd004 	sub	sp, fp, #4
1001a3c0:	e8bd8800 	pop	{fp, pc}

1001a3c4 <_vbus_indicate>:

static void _vbus_indicate(enum rt_vbus_event_id eve, unsigned char chnr)
{
1001a3c4:	e92d4800 	push	{fp, lr}
1001a3c8:	e28db004 	add	fp, sp, #4
1001a3cc:	e24dd008 	sub	sp, sp, #8
1001a3d0:	e1a03000 	mov	r3, r0
1001a3d4:	e1a02001 	mov	r2, r1
1001a3d8:	e54b3005 	strb	r3, [fp, #-5]
1001a3dc:	e1a03002 	mov	r3, r2
1001a3e0:	e54b3006 	strb	r3, [fp, #-6]
    RT_ASSERT(eve < sizeof(_vbus_rx_indi)/sizeof(_vbus_rx_indi[0]));
1001a3e4:	e55b3005 	ldrb	r3, [fp, #-5]
1001a3e8:	e3530002 	cmp	r3, #2
1001a3ec:	9a000005 	bls	1001a408 <_vbus_indicate+0x44>
1001a3f0:	e304058c 	movw	r0, #17804	; 0x458c
1001a3f4:	e3410003 	movt	r0, #4099	; 0x1003
1001a3f8:	e30418b4 	movw	r1, #18612	; 0x48b4
1001a3fc:	e3411003 	movt	r1, #4099	; 0x1003
1001a400:	e3a020dc 	mov	r2, #220	; 0xdc
1001a404:	ebffe66a 	bl	10013db4 <rt_assert_handler>

    if (_vbus_rx_indi[eve][chnr].indicate)
1001a408:	e55b1005 	ldrb	r1, [fp, #-5]
1001a40c:	e55b2006 	ldrb	r2, [fp, #-6]
1001a410:	e3033248 	movw	r3, #12872	; 0x3248
1001a414:	e3413004 	movt	r3, #4100	; 0x1004
1001a418:	e1a01281 	lsl	r1, r1, #5
1001a41c:	e0812002 	add	r2, r1, r2
1001a420:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001a424:	e3530000 	cmp	r3, #0
1001a428:	0a000011 	beq	1001a474 <_vbus_indicate+0xb0>
        _vbus_rx_indi[eve][chnr].indicate(_vbus_rx_indi[eve][chnr].ctx);
1001a42c:	e55b1005 	ldrb	r1, [fp, #-5]
1001a430:	e55b2006 	ldrb	r2, [fp, #-6]
1001a434:	e3033248 	movw	r3, #12872	; 0x3248
1001a438:	e3413004 	movt	r3, #4100	; 0x1004
1001a43c:	e1a01281 	lsl	r1, r1, #5
1001a440:	e0812002 	add	r2, r1, r2
1001a444:	e7931182 	ldr	r1, [r3, r2, lsl #3]
1001a448:	e55b0005 	ldrb	r0, [fp, #-5]
1001a44c:	e55b3006 	ldrb	r3, [fp, #-6]
1001a450:	e3032248 	movw	r2, #12872	; 0x3248
1001a454:	e3412004 	movt	r2, #4100	; 0x1004
1001a458:	e1a00280 	lsl	r0, r0, #5
1001a45c:	e0803003 	add	r3, r0, r3
1001a460:	e1a03183 	lsl	r3, r3, #3
1001a464:	e0823003 	add	r3, r2, r3
1001a468:	e5933004 	ldr	r3, [r3, #4]
1001a46c:	e1a00003 	mov	r0, r3
1001a470:	e12fff31 	blx	r1
}
1001a474:	e24bd004 	sub	sp, fp, #4
1001a478:	e8bd8800 	pop	{fp, pc}

1001a47c <_bus_out_entry>:
static struct rt_thread _bus_out_thread;
static rt_uint8_t _bus_out_thread_stack[_BUS_OUT_THRD_STACK_SZ];
struct rt_prio_queue *_bus_out_que;

static void _bus_out_entry(void *param)
{
1001a47c:	e92d4800 	push	{fp, lr}
1001a480:	e28db004 	add	fp, sp, #4
1001a484:	e24dd028 	sub	sp, sp, #40	; 0x28
1001a488:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    struct rt_vbus_pkg dpkg;

    _bus_out_que = rt_prio_queue_create("vbus",
1001a48c:	e30405c4 	movw	r0, #17860	; 0x45c4
1001a490:	e3410003 	movt	r0, #4099	; 0x1003
1001a494:	e3a01014 	mov	r1, #20
1001a498:	e3a02008 	mov	r2, #8
1001a49c:	ebfffdfe 	bl	10019c9c <rt_prio_queue_create>
1001a4a0:	e1a02000 	mov	r2, r0
1001a4a4:	e3033244 	movw	r3, #12868	; 0x3244
1001a4a8:	e3413004 	movt	r3, #4100	; 0x1004
1001a4ac:	e5832000 	str	r2, [r3]
                                        _BUS_OUT_PKG_NR,
                                        sizeof(struct rt_vbus_pkg));

    if (!_bus_out_que)
1001a4b0:	e3033244 	movw	r3, #12868	; 0x3244
1001a4b4:	e3413004 	movt	r3, #4100	; 0x1004
1001a4b8:	e5933000 	ldr	r3, [r3]
1001a4bc:	e3530000 	cmp	r3, #0
1001a4c0:	1a000003 	bne	1001a4d4 <_bus_out_entry+0x58>
    {
        rt_kprintf("could not create vmm bus queue\n");
1001a4c4:	e30405cc 	movw	r0, #17868	; 0x45cc
1001a4c8:	e3410003 	movt	r0, #4099	; 0x1003
1001a4cc:	ebffe57b 	bl	10013ac0 <rt_kprintf>
1001a4d0:	ea0000ce 	b	1001a810 <_bus_out_entry+0x394>
        return;
    }

    while (rt_prio_queue_pop(_bus_out_que, &dpkg,
1001a4d4:	ea0000bc 	b	1001a7cc <_bus_out_entry+0x350>
                             RT_WAITING_FOREVER) == RT_EOK)
    {
        int sp;
        rt_uint32_t nxtidx;
        const int dnr = LEN2BNR(dpkg.len);
1001a4d8:	e55b301d 	ldrb	r3, [fp, #-29]
1001a4dc:	e2833043 	add	r3, r3, #67	; 0x43
1001a4e0:	e1a03323 	lsr	r3, r3, #6
1001a4e4:	e50b3010 	str	r3, [fp, #-16]

#ifdef RT_VBUS_USING_FLOW_CONTROL
        rt_wm_que_dec(&_chn_wm_que[dpkg.id]);
#endif

        if (!_chn_connected(dpkg.id))
1001a4e8:	e55b3020 	ldrb	r3, [fp, #-32]
1001a4ec:	e1a00003 	mov	r0, r3
1001a4f0:	ebffff55 	bl	1001a24c <_chn_connected>
1001a4f4:	e1a03000 	mov	r3, r0
1001a4f8:	e3530000 	cmp	r3, #0
1001a4fc:	1a000000 	bne	1001a504 <_bus_out_entry+0x88>
            continue;
1001a500:	ea0000b1 	b	1001a7cc <_bus_out_entry+0x350>

        sp = _bus_ring_space_nr(RT_VBUS_OUT_RING);
1001a504:	e303323c 	movw	r3, #12860	; 0x323c
1001a508:	e3413004 	movt	r3, #4100	; 0x1004
1001a50c:	e5933000 	ldr	r3, [r3]
1001a510:	e1a00003 	mov	r0, r3
1001a514:	ebffff36 	bl	1001a1f4 <_bus_ring_space_nr>
1001a518:	e50b0008 	str	r0, [fp, #-8]
        vbus_debug("vmm bus out"
                   "(data: %p, len: %d, prio: %d, id: %d)\n",
                   dpkg.data, dpkg.len, dpkg.prio, dpkg.id);

        /* wait for enough space */
        while (sp < dnr)
1001a51c:	ea00001e 	b	1001a59c <_bus_out_entry+0x120>
        {
            rt_ubase_t lvl = rt_hw_interrupt_disable();
1001a520:	ebfffc42 	bl	10019630 <rt_hw_interrupt_disable>
1001a524:	e1a03000 	mov	r3, r0
1001a528:	e50b3014 	str	r3, [fp, #-20]

            RT_VBUS_OUT_RING->blocked = 1;
1001a52c:	e303323c 	movw	r3, #12860	; 0x323c
1001a530:	e3413004 	movt	r3, #4100	; 0x1004
1001a534:	e5933000 	ldr	r3, [r3]
1001a538:	e3a02001 	mov	r2, #1
1001a53c:	e5832008 	str	r2, [r3, #8]
            rt_vbus_smp_wmb();
1001a540:	ebffff0f 	bl	1001a184 <rt_vbus_smp_wmb>

            /* kick the guest, hoping this could force it do the work */
            rt_vbus_tick(0, RT_VBUS_GUEST_VIRQ);
1001a544:	e3a00000 	mov	r0, #0
1001a548:	e3a01000 	mov	r1, #0
1001a54c:	ebfffefe 	bl	1001a14c <rt_vbus_tick>

            rt_thread_suspend(rt_thread_self());
1001a550:	ebfff102 	bl	10016960 <rt_thread_self>
1001a554:	e1a03000 	mov	r3, r0
1001a558:	e1a00003 	mov	r0, r3
1001a55c:	ebfff261 	bl	10016ee8 <rt_thread_suspend>
            rt_schedule();
1001a560:	ebffef0f 	bl	100161a4 <rt_schedule>

            RT_VBUS_OUT_RING->blocked = 0;
1001a564:	e303323c 	movw	r3, #12860	; 0x323c
1001a568:	e3413004 	movt	r3, #4100	; 0x1004
1001a56c:	e5933000 	ldr	r3, [r3]
1001a570:	e3a02000 	mov	r2, #0
1001a574:	e5832008 	str	r2, [r3, #8]


            rt_hw_interrupt_enable(lvl);
1001a578:	e51b3014 	ldr	r3, [fp, #-20]
1001a57c:	e1a00003 	mov	r0, r3
1001a580:	ebfffc2e 	bl	10019640 <rt_hw_interrupt_enable>

            sp = _bus_ring_space_nr(RT_VBUS_OUT_RING);
1001a584:	e303323c 	movw	r3, #12860	; 0x323c
1001a588:	e3413004 	movt	r3, #4100	; 0x1004
1001a58c:	e5933000 	ldr	r3, [r3]
1001a590:	e1a00003 	mov	r0, r3
1001a594:	ebffff16 	bl	1001a1f4 <_bus_ring_space_nr>
1001a598:	e50b0008 	str	r0, [fp, #-8]
        vbus_debug("vmm bus out"
                   "(data: %p, len: %d, prio: %d, id: %d)\n",
                   dpkg.data, dpkg.len, dpkg.prio, dpkg.id);

        /* wait for enough space */
        while (sp < dnr)
1001a59c:	e51b2008 	ldr	r2, [fp, #-8]
1001a5a0:	e51b3010 	ldr	r3, [fp, #-16]
1001a5a4:	e1520003 	cmp	r2, r3
1001a5a8:	baffffdc 	blt	1001a520 <_bus_out_entry+0xa4>
            rt_hw_interrupt_enable(lvl);

            sp = _bus_ring_space_nr(RT_VBUS_OUT_RING);
        }

        nxtidx = RT_VBUS_OUT_RING->put_idx + dnr;
1001a5ac:	e303323c 	movw	r3, #12860	; 0x323c
1001a5b0:	e3413004 	movt	r3, #4100	; 0x1004
1001a5b4:	e5933000 	ldr	r3, [r3]
1001a5b8:	e5932000 	ldr	r2, [r3]
1001a5bc:	e51b3010 	ldr	r3, [fp, #-16]
1001a5c0:	e0823003 	add	r3, r2, r3
1001a5c4:	e50b3018 	str	r3, [fp, #-24]

        RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].id  = dpkg.id;
1001a5c8:	e303323c 	movw	r3, #12860	; 0x323c
1001a5cc:	e3413004 	movt	r3, #4100	; 0x1004
1001a5d0:	e5932000 	ldr	r2, [r3]
1001a5d4:	e303323c 	movw	r3, #12860	; 0x323c
1001a5d8:	e3413004 	movt	r3, #4100	; 0x1004
1001a5dc:	e5933000 	ldr	r3, [r3]
1001a5e0:	e5933000 	ldr	r3, [r3]
1001a5e4:	e55b1020 	ldrb	r1, [fp, #-32]
1001a5e8:	e1a03303 	lsl	r3, r3, #6
1001a5ec:	e0823003 	add	r3, r2, r3
1001a5f0:	e1a02001 	mov	r2, r1
1001a5f4:	e5c3200c 	strb	r2, [r3, #12]
        RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].qos = dpkg.prio;
1001a5f8:	e303323c 	movw	r3, #12860	; 0x323c
1001a5fc:	e3413004 	movt	r3, #4100	; 0x1004
1001a600:	e5932000 	ldr	r2, [r3]
1001a604:	e303323c 	movw	r3, #12860	; 0x323c
1001a608:	e3413004 	movt	r3, #4100	; 0x1004
1001a60c:	e5933000 	ldr	r3, [r3]
1001a610:	e5933000 	ldr	r3, [r3]
1001a614:	e55b101f 	ldrb	r1, [fp, #-31]
1001a618:	e1a03303 	lsl	r3, r3, #6
1001a61c:	e0823003 	add	r3, r2, r3
1001a620:	e1a02001 	mov	r2, r1
1001a624:	e5c3200d 	strb	r2, [r3, #13]
        RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].len = dpkg.len;
1001a628:	e303323c 	movw	r3, #12860	; 0x323c
1001a62c:	e3413004 	movt	r3, #4100	; 0x1004
1001a630:	e5932000 	ldr	r2, [r3]
1001a634:	e303323c 	movw	r3, #12860	; 0x323c
1001a638:	e3413004 	movt	r3, #4100	; 0x1004
1001a63c:	e5933000 	ldr	r3, [r3]
1001a640:	e5933000 	ldr	r3, [r3]
1001a644:	e55b101d 	ldrb	r1, [fp, #-29]
1001a648:	e1a03303 	lsl	r3, r3, #6
1001a64c:	e0823003 	add	r3, r2, r3
1001a650:	e1a02001 	mov	r2, r1
1001a654:	e5c3200e 	strb	r2, [r3, #14]

        if (nxtidx >= RT_VMM_RB_BLK_NR)
1001a658:	e51b3018 	ldr	r3, [fp, #-24]
1001a65c:	e3530013 	cmp	r3, #19
1001a660:	9a000036 	bls	1001a740 <_bus_out_entry+0x2c4>
        {
            unsigned int tailsz;

            tailsz = (RT_VMM_RB_BLK_NR - RT_VBUS_OUT_RING->put_idx)
1001a664:	e303323c 	movw	r3, #12860	; 0x323c
1001a668:	e3413004 	movt	r3, #4100	; 0x1004
1001a66c:	e5933000 	ldr	r3, [r3]
1001a670:	e5933000 	ldr	r3, [r3]
                * sizeof(RT_VBUS_OUT_RING->blks[0]) - RT_VBUS_BLK_HEAD_SZ;
1001a674:	e1a03303 	lsl	r3, r3, #6
1001a678:	e2633000 	rsb	r3, r3, #0

        if (nxtidx >= RT_VMM_RB_BLK_NR)
        {
            unsigned int tailsz;

            tailsz = (RT_VMM_RB_BLK_NR - RT_VBUS_OUT_RING->put_idx)
1001a67c:	e2833e4f 	add	r3, r3, #1264	; 0x4f0
1001a680:	e283300c 	add	r3, r3, #12
1001a684:	e50b300c 	str	r3, [fp, #-12]
                * sizeof(RT_VBUS_OUT_RING->blks[0]) - RT_VBUS_BLK_HEAD_SZ;

            /* the remaining block is sufficient for the data */
            if (tailsz > dpkg.len)
1001a688:	e55b301d 	ldrb	r3, [fp, #-29]
1001a68c:	e1a02003 	mov	r2, r3
1001a690:	e51b300c 	ldr	r3, [fp, #-12]
1001a694:	e1520003 	cmp	r2, r3
1001a698:	2a000001 	bcs	1001a6a4 <_bus_out_entry+0x228>
                tailsz = dpkg.len;
1001a69c:	e55b301d 	ldrb	r3, [fp, #-29]
1001a6a0:	e50b300c 	str	r3, [fp, #-12]

            rt_memcpy(&RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].data,
1001a6a4:	e303323c 	movw	r3, #12860	; 0x323c
1001a6a8:	e3413004 	movt	r3, #4100	; 0x1004
1001a6ac:	e5932000 	ldr	r2, [r3]
1001a6b0:	e303323c 	movw	r3, #12860	; 0x323c
1001a6b4:	e3413004 	movt	r3, #4100	; 0x1004
1001a6b8:	e5933000 	ldr	r3, [r3]
1001a6bc:	e5933000 	ldr	r3, [r3]
1001a6c0:	e1a03303 	lsl	r3, r3, #6
1001a6c4:	e2833008 	add	r3, r3, #8
1001a6c8:	e0823003 	add	r3, r2, r3
1001a6cc:	e2832008 	add	r2, r3, #8
1001a6d0:	e51b301c 	ldr	r3, [fp, #-28]
1001a6d4:	e1a00002 	mov	r0, r2
1001a6d8:	e1a01003 	mov	r1, r3
1001a6dc:	e51b200c 	ldr	r2, [fp, #-12]
1001a6e0:	ebffdf34 	bl	100123b8 <rt_memcpy>
                      dpkg.data, tailsz);
            rt_memcpy(&RT_VBUS_OUT_RING->blks[0],
1001a6e4:	e303323c 	movw	r3, #12860	; 0x323c
1001a6e8:	e3413004 	movt	r3, #4100	; 0x1004
1001a6ec:	e5933000 	ldr	r3, [r3]
1001a6f0:	e283100c 	add	r1, r3, #12
                      ((char*)dpkg.data)+tailsz,
1001a6f4:	e51b201c 	ldr	r2, [fp, #-28]
            if (tailsz > dpkg.len)
                tailsz = dpkg.len;

            rt_memcpy(&RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].data,
                      dpkg.data, tailsz);
            rt_memcpy(&RT_VBUS_OUT_RING->blks[0],
1001a6f8:	e51b300c 	ldr	r3, [fp, #-12]
1001a6fc:	e0822003 	add	r2, r2, r3
                      ((char*)dpkg.data)+tailsz,
                      dpkg.len - tailsz);
1001a700:	e55b301d 	ldrb	r3, [fp, #-29]
            if (tailsz > dpkg.len)
                tailsz = dpkg.len;

            rt_memcpy(&RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].data,
                      dpkg.data, tailsz);
            rt_memcpy(&RT_VBUS_OUT_RING->blks[0],
1001a704:	e1a00003 	mov	r0, r3
                      ((char*)dpkg.data)+tailsz,
                      dpkg.len - tailsz);
1001a708:	e51b300c 	ldr	r3, [fp, #-12]
1001a70c:	e0633000 	rsb	r3, r3, r0
            if (tailsz > dpkg.len)
                tailsz = dpkg.len;

            rt_memcpy(&RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].data,
                      dpkg.data, tailsz);
            rt_memcpy(&RT_VBUS_OUT_RING->blks[0],
1001a710:	e1a00001 	mov	r0, r1
1001a714:	e1a01002 	mov	r1, r2
1001a718:	e1a02003 	mov	r2, r3
1001a71c:	ebffdf25 	bl	100123b8 <rt_memcpy>
                      ((char*)dpkg.data)+tailsz,
                      dpkg.len - tailsz);

            rt_vbus_smp_wmb();
1001a720:	ebfffe97 	bl	1001a184 <rt_vbus_smp_wmb>
            RT_VBUS_OUT_RING->put_idx = nxtidx - RT_VMM_RB_BLK_NR;
1001a724:	e303323c 	movw	r3, #12860	; 0x323c
1001a728:	e3413004 	movt	r3, #4100	; 0x1004
1001a72c:	e5933000 	ldr	r3, [r3]
1001a730:	e51b2018 	ldr	r2, [fp, #-24]
1001a734:	e2422014 	sub	r2, r2, #20
1001a738:	e5832000 	str	r2, [r3]
1001a73c:	ea000017 	b	1001a7a0 <_bus_out_entry+0x324>
        }
        else
        {
            rt_memcpy(&RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].data,
1001a740:	e303323c 	movw	r3, #12860	; 0x323c
1001a744:	e3413004 	movt	r3, #4100	; 0x1004
1001a748:	e5932000 	ldr	r2, [r3]
1001a74c:	e303323c 	movw	r3, #12860	; 0x323c
1001a750:	e3413004 	movt	r3, #4100	; 0x1004
1001a754:	e5933000 	ldr	r3, [r3]
1001a758:	e5933000 	ldr	r3, [r3]
1001a75c:	e1a03303 	lsl	r3, r3, #6
1001a760:	e2833008 	add	r3, r3, #8
1001a764:	e0823003 	add	r3, r2, r3
1001a768:	e2832008 	add	r2, r3, #8
1001a76c:	e51b301c 	ldr	r3, [fp, #-28]
                      dpkg.data, dpkg.len);
1001a770:	e55b101d 	ldrb	r1, [fp, #-29]
            rt_vbus_smp_wmb();
            RT_VBUS_OUT_RING->put_idx = nxtidx - RT_VMM_RB_BLK_NR;
        }
        else
        {
            rt_memcpy(&RT_VBUS_OUT_RING->blks[RT_VBUS_OUT_RING->put_idx].data,
1001a774:	e1a0c001 	mov	ip, r1
1001a778:	e1a00002 	mov	r0, r2
1001a77c:	e1a01003 	mov	r1, r3
1001a780:	e1a0200c 	mov	r2, ip
1001a784:	ebffdf0b 	bl	100123b8 <rt_memcpy>
                      dpkg.data, dpkg.len);

            rt_vbus_smp_wmb();
1001a788:	ebfffe7d 	bl	1001a184 <rt_vbus_smp_wmb>
            RT_VBUS_OUT_RING->put_idx = nxtidx;
1001a78c:	e303323c 	movw	r3, #12860	; 0x323c
1001a790:	e3413004 	movt	r3, #4100	; 0x1004
1001a794:	e5933000 	ldr	r3, [r3]
1001a798:	e51b2018 	ldr	r2, [fp, #-24]
1001a79c:	e5832000 	str	r2, [r3]
        }

        rt_vbus_smp_wmb();
1001a7a0:	ebfffe77 	bl	1001a184 <rt_vbus_smp_wmb>
        rt_vbus_tick(0, RT_VBUS_GUEST_VIRQ);
1001a7a4:	e3a00000 	mov	r0, #0
1001a7a8:	e3a01000 	mov	r1, #0
1001a7ac:	ebfffe66 	bl	1001a14c <rt_vbus_tick>

        if (dpkg.finished)
1001a7b0:	e55b301e 	ldrb	r3, [fp, #-30]
1001a7b4:	e3530000 	cmp	r3, #0
1001a7b8:	0a000003 	beq	1001a7cc <_bus_out_entry+0x350>
        {
            _vbus_indicate(RT_VBUS_EVENT_ID_TX, dpkg.id);//
1001a7bc:	e55b3020 	ldrb	r3, [fp, #-32]
1001a7c0:	e3a00001 	mov	r0, #1
1001a7c4:	e1a01003 	mov	r1, r3
1001a7c8:	ebfffefd 	bl	1001a3c4 <_vbus_indicate>
    {
        rt_kprintf("could not create vmm bus queue\n");
        return;
    }

    while (rt_prio_queue_pop(_bus_out_que, &dpkg,
1001a7cc:	e3033244 	movw	r3, #12868	; 0x3244
1001a7d0:	e3413004 	movt	r3, #4100	; 0x1004
1001a7d4:	e5932000 	ldr	r2, [r3]
1001a7d8:	e24b3020 	sub	r3, fp, #32
1001a7dc:	e1a00002 	mov	r0, r2
1001a7e0:	e1a01003 	mov	r1, r3
1001a7e4:	e3e02000 	mvn	r2, #0
1001a7e8:	ebfffdad 	bl	10019ea4 <rt_prio_queue_pop>
1001a7ec:	e1a03000 	mov	r3, r0
1001a7f0:	e3530000 	cmp	r3, #0
1001a7f4:	0affff37 	beq	1001a4d8 <_bus_out_entry+0x5c>
        if (dpkg.finished)
        {
            _vbus_indicate(RT_VBUS_EVENT_ID_TX, dpkg.id);//
        }
    }
    RT_ASSERT(0);
1001a7f8:	e30405ec 	movw	r0, #17900	; 0x45ec
1001a7fc:	e3410003 	movt	r0, #4099	; 0x1003
1001a800:	e30418c4 	movw	r1, #18628	; 0x48c4
1001a804:	e3411003 	movt	r1, #4099	; 0x1003
1001a808:	e300214d 	movw	r2, #333	; 0x14d
1001a80c:	ebffe568 	bl	10013db4 <rt_assert_handler>
}
1001a810:	e24bd004 	sub	sp, fp, #4
1001a814:	e8bd8800 	pop	{fp, pc}

1001a818 <rt_vbus_resume_out_thread>:

void rt_vbus_resume_out_thread(void)
{
1001a818:	e92d4800 	push	{fp, lr}
1001a81c:	e28db004 	add	fp, sp, #4
    rt_thread_resume(&_bus_out_thread);
1001a820:	e30c0c88 	movw	r0, #52360	; 0xcc88
1001a824:	e3410003 	movt	r0, #4099	; 0x1003
1001a828:	ebfff1d2 	bl	10016f78 <rt_thread_resume>
    rt_schedule();
1001a82c:	ebffee5c 	bl	100161a4 <rt_schedule>
}
1001a830:	e8bd8800 	pop	{fp, pc}

1001a834 <rt_vbus_post>:
rt_err_t rt_vbus_post(rt_uint8_t id,
                      rt_uint8_t prio,
                      const void *data,
                      rt_size_t size,
                      rt_int32_t timeout)
{
1001a834:	e92d4800 	push	{fp, lr}
1001a838:	e28db004 	add	fp, sp, #4
1001a83c:	e24dd030 	sub	sp, sp, #48	; 0x30
1001a840:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
1001a844:	e50b3030 	str	r3, [fp, #-48]	; 0x30
1001a848:	e1a03000 	mov	r3, r0
1001a84c:	e54b3025 	strb	r3, [fp, #-37]	; 0x25
1001a850:	e1a03001 	mov	r3, r1
1001a854:	e54b3026 	strb	r3, [fp, #-38]	; 0x26
    rt_err_t err = RT_EOK;
1001a858:	e3a03000 	mov	r3, #0
1001a85c:	e50b3008 	str	r3, [fp, #-8]
    struct rt_vbus_pkg pkg;
    unsigned int putsz;
    const unsigned char *dp;

    if (!_bus_out_que)
1001a860:	e3033244 	movw	r3, #12868	; 0x3244
1001a864:	e3413004 	movt	r3, #4100	; 0x1004
1001a868:	e5933000 	ldr	r3, [r3]
1001a86c:	e3530000 	cmp	r3, #0
1001a870:	1a000007 	bne	1001a894 <rt_vbus_post+0x60>
    {
        rt_kprintf("post (data: %p, size: %d, timeout: %d) "
1001a874:	e30405f0 	movw	r0, #17904	; 0x45f0
1001a878:	e3410003 	movt	r0, #4099	; 0x1003
1001a87c:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
1001a880:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
1001a884:	e59b3004 	ldr	r3, [fp, #4]
1001a888:	ebffe48c 	bl	10013ac0 <rt_kprintf>
                   "to bus before initialition\n",
                   data, size, timeout);
        return -RT_ERROR;
1001a88c:	e3e03000 	mvn	r3, #0
1001a890:	ea00006a 	b	1001aa40 <rt_vbus_post+0x20c>
    }

    if (id >= RT_VBUS_CHANNEL_NR)
1001a894:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
1001a898:	e353001f 	cmp	r3, #31
1001a89c:	9a000001 	bls	1001a8a8 <rt_vbus_post+0x74>
        return -RT_ERROR;
1001a8a0:	e3e03000 	mvn	r3, #0
1001a8a4:	ea000065 	b	1001aa40 <rt_vbus_post+0x20c>

    if (timeout != 0)
1001a8a8:	e59b3004 	ldr	r3, [fp, #4]
1001a8ac:	e3530000 	cmp	r3, #0
1001a8b0:	0a000025 	beq	1001a94c <rt_vbus_post+0x118>
    {
        RT_DEBUG_IN_THREAD_CONTEXT;
1001a8b4:	ebfffb5d 	bl	10019630 <rt_hw_interrupt_disable>
1001a8b8:	e50b0014 	str	r0, [fp, #-20]
1001a8bc:	ebfff027 	bl	10016960 <rt_thread_self>
1001a8c0:	e1a03000 	mov	r3, r0
1001a8c4:	e3530000 	cmp	r3, #0
1001a8c8:	1a00000a 	bne	1001a8f8 <rt_vbus_post+0xc4>
1001a8cc:	e3040634 	movw	r0, #17972	; 0x4634
1001a8d0:	e3410003 	movt	r0, #4099	; 0x1003
1001a8d4:	e30418d4 	movw	r1, #18644	; 0x48d4
1001a8d8:	e3411003 	movt	r1, #4099	; 0x1003
1001a8dc:	ebffe477 	bl	10013ac0 <rt_kprintf>
1001a8e0:	e30405ec 	movw	r0, #17900	; 0x45ec
1001a8e4:	e3410003 	movt	r0, #4099	; 0x1003
1001a8e8:	e30418d4 	movw	r1, #18644	; 0x48d4
1001a8ec:	e3411003 	movt	r1, #4099	; 0x1003
1001a8f0:	e300216e 	movw	r2, #366	; 0x16e
1001a8f4:	ebffe52e 	bl	10013db4 <rt_assert_handler>
1001a8f8:	ebfffb4c 	bl	10019630 <rt_hw_interrupt_disable>
1001a8fc:	e50b0018 	str	r0, [fp, #-24]
1001a900:	ebffddfe 	bl	10012100 <rt_interrupt_get_nest>
1001a904:	e1a03000 	mov	r3, r0
1001a908:	e3530000 	cmp	r3, #0
1001a90c:	0a00000a 	beq	1001a93c <rt_vbus_post+0x108>
1001a910:	e304066c 	movw	r0, #18028	; 0x466c
1001a914:	e3410003 	movt	r0, #4099	; 0x1003
1001a918:	e30418d4 	movw	r1, #18644	; 0x48d4
1001a91c:	e3411003 	movt	r1, #4099	; 0x1003
1001a920:	ebffe466 	bl	10013ac0 <rt_kprintf>
1001a924:	e30405ec 	movw	r0, #17900	; 0x45ec
1001a928:	e3410003 	movt	r0, #4099	; 0x1003
1001a92c:	e30418d4 	movw	r1, #18644	; 0x48d4
1001a930:	e3411003 	movt	r1, #4099	; 0x1003
1001a934:	e300216e 	movw	r2, #366	; 0x16e
1001a938:	ebffe51d 	bl	10013db4 <rt_assert_handler>
1001a93c:	e51b0018 	ldr	r0, [fp, #-24]
1001a940:	ebfffb3e 	bl	10019640 <rt_hw_interrupt_enable>
1001a944:	e51b0014 	ldr	r0, [fp, #-20]
1001a948:	ebfffb3c 	bl	10019640 <rt_hw_interrupt_enable>
        if (thread->error != RT_EOK)
            return thread->error;
    }
#endif

    if (_chn_status[id] != RT_VBUS_CHN_ST_ESTABLISHED)
1001a94c:	e55b2025 	ldrb	r2, [fp, #-37]	; 0x25
1001a950:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001a954:	e3413003 	movt	r3, #4099	; 0x1003
1001a958:	e7d33002 	ldrb	r3, [r3, r2]
1001a95c:	e3530003 	cmp	r3, #3
1001a960:	0a000001 	beq	1001a96c <rt_vbus_post+0x138>
        return -RT_ERROR;
1001a964:	e3e03000 	mvn	r3, #0
1001a968:	ea000034 	b	1001aa40 <rt_vbus_post+0x20c>

    dp       = data;
1001a96c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1001a970:	e50b3010 	str	r3, [fp, #-16]
    pkg.id   = id;
1001a974:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
1001a978:	e54b3020 	strb	r3, [fp, #-32]
    pkg.prio = prio;
1001a97c:	e55b3026 	ldrb	r3, [fp, #-38]	; 0x26
1001a980:	e54b301f 	strb	r3, [fp, #-31]
    for (putsz = 0; size; size -= putsz)
1001a984:	e3a03000 	mov	r3, #0
1001a988:	e50b300c 	str	r3, [fp, #-12]
1001a98c:	ea000027 	b	1001aa30 <rt_vbus_post+0x1fc>
    {
        pkg.data = dp;
1001a990:	e51b3010 	ldr	r3, [fp, #-16]
1001a994:	e50b301c 	str	r3, [fp, #-28]

        if (size > RT_VBUS_MAX_PKT_SZ)
1001a998:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001a99c:	e35300fc 	cmp	r3, #252	; 0xfc
1001a9a0:	9a000004 	bls	1001a9b8 <rt_vbus_post+0x184>
        {
            putsz = RT_VBUS_MAX_PKT_SZ;
1001a9a4:	e3a030fc 	mov	r3, #252	; 0xfc
1001a9a8:	e50b300c 	str	r3, [fp, #-12]
            pkg.finished = 0;
1001a9ac:	e3a03000 	mov	r3, #0
1001a9b0:	e54b301e 	strb	r3, [fp, #-30]
1001a9b4:	ea000003 	b	1001a9c8 <rt_vbus_post+0x194>
        }
        else
        {
            putsz = size;
1001a9b8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001a9bc:	e50b300c 	str	r3, [fp, #-12]
            pkg.finished = 1;
1001a9c0:	e3a03001 	mov	r3, #1
1001a9c4:	e54b301e 	strb	r3, [fp, #-30]
        }

        pkg.len = putsz;
1001a9c8:	e51b300c 	ldr	r3, [fp, #-12]
1001a9cc:	e6ef3073 	uxtb	r3, r3
1001a9d0:	e54b301d 	strb	r3, [fp, #-29]
        dp += putsz;
1001a9d4:	e51b2010 	ldr	r2, [fp, #-16]
1001a9d8:	e51b300c 	ldr	r3, [fp, #-12]
1001a9dc:	e0823003 	add	r3, r2, r3
1001a9e0:	e50b3010 	str	r3, [fp, #-16]

        vbus_debug("post (data: %p(%d), size: %d, finshed: %d, timeout: %d)\n",
                   pkg.data, ((unsigned char*)pkg.data)[0],
                   pkg.len, pkg.finished, timeout);

        err = rt_prio_queue_push(_bus_out_que, prio, &pkg, timeout);
1001a9e4:	e3033244 	movw	r3, #12868	; 0x3244
1001a9e8:	e3413004 	movt	r3, #4100	; 0x1004
1001a9ec:	e5931000 	ldr	r1, [r3]
1001a9f0:	e55b2026 	ldrb	r2, [fp, #-38]	; 0x26
1001a9f4:	e24b3020 	sub	r3, fp, #32
1001a9f8:	e1a00001 	mov	r0, r1
1001a9fc:	e1a01002 	mov	r1, r2
1001aa00:	e1a02003 	mov	r2, r3
1001aa04:	e59b3004 	ldr	r3, [fp, #4]
1001aa08:	ebfffcd7 	bl	10019d6c <rt_prio_queue_push>
1001aa0c:	e50b0008 	str	r0, [fp, #-8]
        if (err != RT_EOK)
1001aa10:	e51b3008 	ldr	r3, [fp, #-8]
1001aa14:	e3530000 	cmp	r3, #0
1001aa18:	0a000000 	beq	1001aa20 <rt_vbus_post+0x1ec>
            break;
1001aa1c:	ea000006 	b	1001aa3c <rt_vbus_post+0x208>
        return -RT_ERROR;

    dp       = data;
    pkg.id   = id;
    pkg.prio = prio;
    for (putsz = 0; size; size -= putsz)
1001aa20:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
1001aa24:	e51b300c 	ldr	r3, [fp, #-12]
1001aa28:	e0633002 	rsb	r3, r3, r2
1001aa2c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
1001aa30:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001aa34:	e3530000 	cmp	r3, #0
1001aa38:	1affffd4 	bne	1001a990 <rt_vbus_post+0x15c>
        err = rt_prio_queue_push(_bus_out_que, prio, &pkg, timeout);
        if (err != RT_EOK)
            break;
    }

    return err;
1001aa3c:	e51b3008 	ldr	r3, [fp, #-8]
}
1001aa40:	e1a00003 	mov	r0, r3
1001aa44:	e24bd004 	sub	sp, fp, #4
1001aa48:	e8bd8800 	pop	{fp, pc}

1001aa4c <_chn0_tx_listener>:

struct rt_completion _chn0_post_cmp;

void _chn0_tx_listener(void *p)
{
1001aa4c:	e92d4800 	push	{fp, lr}
1001aa50:	e28db004 	add	fp, sp, #4
1001aa54:	e24dd008 	sub	sp, sp, #8
1001aa58:	e50b0008 	str	r0, [fp, #-8]
    rt_completion_done(&_chn0_post_cmp);
1001aa5c:	e3030230 	movw	r0, #12848	; 0x3230
1001aa60:	e3410004 	movt	r0, #4100	; 0x1004
1001aa64:	eb001755 	bl	100207c0 <rt_completion_done>
}
1001aa68:	e24bd004 	sub	sp, fp, #4
1001aa6c:	e8bd8800 	pop	{fp, pc}

1001aa70 <_chn0_post>:

/* Posts in channel0 should be sync. */
static rt_err_t _chn0_post(const void *data,
                               rt_size_t size,
                               int timeout)
{
1001aa70:	e92d4800 	push	{fp, lr}
1001aa74:	e28db004 	add	fp, sp, #4
1001aa78:	e24dd020 	sub	sp, sp, #32
1001aa7c:	e50b0010 	str	r0, [fp, #-16]
1001aa80:	e50b1014 	str	r1, [fp, #-20]
1001aa84:	e50b2018 	str	r2, [fp, #-24]
    rt_err_t err;

    rt_completion_init(&_chn0_post_cmp);
1001aa88:	e3030230 	movw	r0, #12848	; 0x3230
1001aa8c:	e3410004 	movt	r0, #4100	; 0x1004
1001aa90:	eb0016c7 	bl	100205b4 <rt_completion_init>
    err = rt_vbus_post(0, 0, data, size, timeout);
1001aa94:	e51b3018 	ldr	r3, [fp, #-24]
1001aa98:	e58d3000 	str	r3, [sp]
1001aa9c:	e3a00000 	mov	r0, #0
1001aaa0:	e3a01000 	mov	r1, #0
1001aaa4:	e51b2010 	ldr	r2, [fp, #-16]
1001aaa8:	e51b3014 	ldr	r3, [fp, #-20]
1001aaac:	ebffff60 	bl	1001a834 <rt_vbus_post>
1001aab0:	e50b0008 	str	r0, [fp, #-8]
    if (err != RT_EOK)
1001aab4:	e51b3008 	ldr	r3, [fp, #-8]
1001aab8:	e3530000 	cmp	r3, #0
1001aabc:	0a000001 	beq	1001aac8 <_chn0_post+0x58>
        return err;
1001aac0:	e51b3008 	ldr	r3, [fp, #-8]
1001aac4:	ea000004 	b	1001aadc <_chn0_post+0x6c>
    return rt_completion_wait(&_chn0_post_cmp, timeout);
1001aac8:	e3030230 	movw	r0, #12848	; 0x3230
1001aacc:	e3410004 	movt	r0, #4100	; 0x1004
1001aad0:	e51b1018 	ldr	r1, [fp, #-24]
1001aad4:	eb0016d0 	bl	1002061c <rt_completion_wait>
1001aad8:	e1a03000 	mov	r3, r0
}
1001aadc:	e1a00003 	mov	r0, r3
1001aae0:	e24bd004 	sub	sp, fp, #4
1001aae4:	e8bd8800 	pop	{fp, pc}

1001aae8 <rt_vbus_notify_chn>:
#ifdef RT_VBUS_STATISTICS
static unsigned int _bus_in_action_nr[RT_VBUS_CHANNEL_NR];
#endif

static void rt_vbus_notify_chn(unsigned char chnr, rt_err_t err)
{
1001aae8:	e92d4800 	push	{fp, lr}
1001aaec:	e28db004 	add	fp, sp, #4
1001aaf0:	e24dd008 	sub	sp, sp, #8
1001aaf4:	e1a03000 	mov	r3, r0
1001aaf8:	e50b100c 	str	r1, [fp, #-12]
1001aafc:	e54b3005 	strb	r3, [fp, #-5]
        thread->error = err;
        rt_thread_resume(thread);
    }
    rt_exit_critical();
#endif
    rt_event_send(&_bus_in_event, 1 << chnr);
1001ab00:	e55b3005 	ldrb	r3, [fp, #-5]
1001ab04:	e3a02001 	mov	r2, #1
1001ab08:	e1a03312 	lsl	r3, r2, r3
1001ab0c:	e30d0d94 	movw	r0, #56724	; 0xdd94
1001ab10:	e3410003 	movt	r0, #4099	; 0x1003
1001ab14:	e1a01003 	mov	r1, r3
1001ab18:	ebffd5d0 	bl	10010260 <rt_event_send>
}
1001ab1c:	e24bd004 	sub	sp, fp, #4
1001ab20:	e8bd8800 	pop	{fp, pc}

1001ab24 <rt_vbus_notify_set>:

static void rt_vbus_notify_set(rt_uint32_t set)
{
1001ab24:	e92d4800 	push	{fp, lr}
1001ab28:	e28db004 	add	fp, sp, #4
1001ab2c:	e24dd008 	sub	sp, sp, #8
1001ab30:	e50b0008 	str	r0, [fp, #-8]
    rt_event_send(&_bus_in_event, set);
1001ab34:	e30d0d94 	movw	r0, #56724	; 0xdd94
1001ab38:	e3410003 	movt	r0, #4099	; 0x1003
1001ab3c:	e51b1008 	ldr	r1, [fp, #-8]
1001ab40:	ebffd5c6 	bl	10010260 <rt_event_send>
}
1001ab44:	e24bd004 	sub	sp, fp, #4
1001ab48:	e8bd8800 	pop	{fp, pc}

1001ab4c <rt_vbus_listen_on>:

rt_err_t rt_vbus_listen_on(rt_uint8_t chnr,
                           rt_int32_t timeout)
{
1001ab4c:	e92d4800 	push	{fp, lr}
1001ab50:	e28db004 	add	fp, sp, #4
1001ab54:	e24dd018 	sub	sp, sp, #24
1001ab58:	e1a03000 	mov	r3, r0
1001ab5c:	e50b1014 	str	r1, [fp, #-20]
1001ab60:	e54b300d 	strb	r3, [fp, #-13]
    rt_uint32_t notuse;

    if (chnr == 0 || chnr >= RT_VBUS_CHANNEL_NR || !_chn_connected(chnr))
1001ab64:	e55b300d 	ldrb	r3, [fp, #-13]
1001ab68:	e3530000 	cmp	r3, #0
1001ab6c:	0a000008 	beq	1001ab94 <rt_vbus_listen_on+0x48>
1001ab70:	e55b300d 	ldrb	r3, [fp, #-13]
1001ab74:	e353001f 	cmp	r3, #31
1001ab78:	8a000005 	bhi	1001ab94 <rt_vbus_listen_on+0x48>
1001ab7c:	e55b300d 	ldrb	r3, [fp, #-13]
1001ab80:	e1a00003 	mov	r0, r3
1001ab84:	ebfffdb0 	bl	1001a24c <_chn_connected>
1001ab88:	e1a03000 	mov	r3, r0
1001ab8c:	e3530000 	cmp	r3, #0
1001ab90:	1a000001 	bne	1001ab9c <rt_vbus_listen_on+0x50>
        return -RT_EIO;
1001ab94:	e3e03007 	mvn	r3, #7
1001ab98:	ea00000c 	b	1001abd0 <rt_vbus_listen_on+0x84>

    return rt_event_recv(&_bus_in_event, 1 << chnr,
1001ab9c:	e55b300d 	ldrb	r3, [fp, #-13]
1001aba0:	e3a02001 	mov	r2, #1
1001aba4:	e1a03312 	lsl	r3, r2, r3
1001aba8:	e1a02003 	mov	r2, r3
1001abac:	e24b3008 	sub	r3, fp, #8
1001abb0:	e58d3000 	str	r3, [sp]
1001abb4:	e30d0d94 	movw	r0, #56724	; 0xdd94
1001abb8:	e3410003 	movt	r0, #4099	; 0x1003
1001abbc:	e1a01002 	mov	r1, r2
1001abc0:	e3a02006 	mov	r2, #6
1001abc4:	e51b3014 	ldr	r3, [fp, #-20]
1001abc8:	ebffd626 	bl	10010468 <rt_event_recv>
1001abcc:	e1a03000 	mov	r3, r0
                         RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR,
                         timeout, &notuse);
}
1001abd0:	e1a00003 	mov	r0, r3
1001abd4:	e24bd004 	sub	sp, fp, #4
1001abd8:	e8bd8800 	pop	{fp, pc}

1001abdc <rt_vbus_data_push>:

void rt_vbus_data_push(unsigned int id, struct rt_vbus_data *act)
{
1001abdc:	e92d4800 	push	{fp, lr}
1001abe0:	e28db004 	add	fp, sp, #4
1001abe4:	e24dd010 	sub	sp, sp, #16
1001abe8:	e50b0010 	str	r0, [fp, #-16]
1001abec:	e50b1014 	str	r1, [fp, #-20]
    rt_ubase_t lvl;

    RT_ASSERT(0 < id && id < RT_VBUS_CHANNEL_NR);
1001abf0:	e51b3010 	ldr	r3, [fp, #-16]
1001abf4:	e3530000 	cmp	r3, #0
1001abf8:	0a000002 	beq	1001ac08 <rt_vbus_data_push+0x2c>
1001abfc:	e51b3010 	ldr	r3, [fp, #-16]
1001ac00:	e353001f 	cmp	r3, #31
1001ac04:	9a000005 	bls	1001ac20 <rt_vbus_data_push+0x44>
1001ac08:	e3040690 	movw	r0, #18064	; 0x4690
1001ac0c:	e3410003 	movt	r0, #4099	; 0x1003
1001ac10:	e30418e4 	movw	r1, #18660	; 0x48e4
1001ac14:	e3411003 	movt	r1, #4099	; 0x1003
1001ac18:	e300220e 	movw	r2, #526	; 0x20e
1001ac1c:	ebffe464 	bl	10013db4 <rt_assert_handler>

    lvl = rt_hw_interrupt_disable();
1001ac20:	ebfffa82 	bl	10019630 <rt_hw_interrupt_disable>
1001ac24:	e1a03000 	mov	r3, r0
1001ac28:	e50b3008 	str	r3, [fp, #-8]

    if (_bus_in_action[id][_IN_ACT_HEAD] == RT_NULL)
1001ac2c:	e30d3db0 	movw	r3, #56752	; 0xddb0
1001ac30:	e3413003 	movt	r3, #4099	; 0x1003
1001ac34:	e51b2010 	ldr	r2, [fp, #-16]
1001ac38:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001ac3c:	e3530000 	cmp	r3, #0
1001ac40:	1a00000c 	bne	1001ac78 <rt_vbus_data_push+0x9c>
    {
        _bus_in_action[id][_IN_ACT_HEAD] = act;
1001ac44:	e30d3db0 	movw	r3, #56752	; 0xddb0
1001ac48:	e3413003 	movt	r3, #4099	; 0x1003
1001ac4c:	e51b2010 	ldr	r2, [fp, #-16]
1001ac50:	e51b1014 	ldr	r1, [fp, #-20]
1001ac54:	e7831182 	str	r1, [r3, r2, lsl #3]
        _bus_in_action[id][_IN_ACT_TAIL] = act;
1001ac58:	e30d2db0 	movw	r2, #56752	; 0xddb0
1001ac5c:	e3412003 	movt	r2, #4099	; 0x1003
1001ac60:	e51b3010 	ldr	r3, [fp, #-16]
1001ac64:	e1a03183 	lsl	r3, r3, #3
1001ac68:	e0823003 	add	r3, r2, r3
1001ac6c:	e51b2014 	ldr	r2, [fp, #-20]
1001ac70:	e5832004 	str	r2, [r3, #4]
1001ac74:	ea00000e 	b	1001acb4 <rt_vbus_data_push+0xd8>
    }
    else
    {
        _bus_in_action[id][_IN_ACT_TAIL]->next = act;
1001ac78:	e30d2db0 	movw	r2, #56752	; 0xddb0
1001ac7c:	e3412003 	movt	r2, #4099	; 0x1003
1001ac80:	e51b3010 	ldr	r3, [fp, #-16]
1001ac84:	e1a03183 	lsl	r3, r3, #3
1001ac88:	e0823003 	add	r3, r2, r3
1001ac8c:	e5933004 	ldr	r3, [r3, #4]
1001ac90:	e51b2014 	ldr	r2, [fp, #-20]
1001ac94:	e5832004 	str	r2, [r3, #4]
        _bus_in_action[id][_IN_ACT_TAIL] = act;
1001ac98:	e30d2db0 	movw	r2, #56752	; 0xddb0
1001ac9c:	e3412003 	movt	r2, #4099	; 0x1003
1001aca0:	e51b3010 	ldr	r3, [fp, #-16]
1001aca4:	e1a03183 	lsl	r3, r3, #3
1001aca8:	e0823003 	add	r3, r2, r3
1001acac:	e51b2014 	ldr	r2, [fp, #-20]
1001acb0:	e5832004 	str	r2, [r3, #4]

#ifdef RT_VBUS_STATISTICS
    _bus_in_action_nr[id]++;
#endif

    rt_hw_interrupt_enable(lvl);
1001acb4:	e51b3008 	ldr	r3, [fp, #-8]
1001acb8:	e1a00003 	mov	r0, r3
1001acbc:	ebfffa5f 	bl	10019640 <rt_hw_interrupt_enable>
        _chn0_post(buf, sizeof(buf), RT_WAITING_FOREVER);
        /* Warn the other side in 100 more pkgs. */
        _chn_recv_wm[id].last_warn = _chn_recv_wm[id].level + 100;
    }
#endif
}
1001acc0:	e24bd004 	sub	sp, fp, #4
1001acc4:	e8bd8800 	pop	{fp, pc}

1001acc8 <rt_vbus_data_pop>:

struct rt_vbus_data* rt_vbus_data_pop(unsigned int id)
{
1001acc8:	e92d4800 	push	{fp, lr}
1001accc:	e28db004 	add	fp, sp, #4
1001acd0:	e24dd010 	sub	sp, sp, #16
1001acd4:	e50b0010 	str	r0, [fp, #-16]
    struct rt_vbus_data *act;
    rt_ubase_t lvl;

    RT_ASSERT(0 < id && id < RT_VBUS_CHANNEL_NR);
1001acd8:	e51b3010 	ldr	r3, [fp, #-16]
1001acdc:	e3530000 	cmp	r3, #0
1001ace0:	0a000002 	beq	1001acf0 <rt_vbus_data_pop+0x28>
1001ace4:	e51b3010 	ldr	r3, [fp, #-16]
1001ace8:	e353001f 	cmp	r3, #31
1001acec:	9a000005 	bls	1001ad08 <rt_vbus_data_pop+0x40>
1001acf0:	e3040690 	movw	r0, #18064	; 0x4690
1001acf4:	e3410003 	movt	r0, #4099	; 0x1003
1001acf8:	e30418f8 	movw	r1, #18680	; 0x48f8
1001acfc:	e3411003 	movt	r1, #4099	; 0x1003
1001ad00:	e300223b 	movw	r2, #571	; 0x23b
1001ad04:	ebffe42a 	bl	10013db4 <rt_assert_handler>

    lvl = rt_hw_interrupt_disable();
1001ad08:	ebfffa48 	bl	10019630 <rt_hw_interrupt_disable>
1001ad0c:	e1a03000 	mov	r3, r0
1001ad10:	e50b3008 	str	r3, [fp, #-8]

    act = _bus_in_action[id][_IN_ACT_HEAD];
1001ad14:	e30d3db0 	movw	r3, #56752	; 0xddb0
1001ad18:	e3413003 	movt	r3, #4099	; 0x1003
1001ad1c:	e51b2010 	ldr	r2, [fp, #-16]
1001ad20:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001ad24:	e50b300c 	str	r3, [fp, #-12]
    if (act)
1001ad28:	e51b300c 	ldr	r3, [fp, #-12]
1001ad2c:	e3530000 	cmp	r3, #0
1001ad30:	0a000005 	beq	1001ad4c <rt_vbus_data_pop+0x84>
    {
        _bus_in_action[id][_IN_ACT_HEAD] = act->next;
1001ad34:	e51b300c 	ldr	r3, [fp, #-12]
1001ad38:	e5931004 	ldr	r1, [r3, #4]
1001ad3c:	e30d3db0 	movw	r3, #56752	; 0xddb0
1001ad40:	e3413003 	movt	r3, #4099	; 0x1003
1001ad44:	e51b2010 	ldr	r2, [fp, #-16]
1001ad48:	e7831182 	str	r1, [r3, r2, lsl #3]
    }

    rt_hw_interrupt_enable(lvl);
1001ad4c:	e51b3008 	ldr	r3, [fp, #-8]
1001ad50:	e1a00003 	mov	r0, r3
1001ad54:	ebfffa39 	bl	10019640 <rt_hw_interrupt_enable>
            _chn0_post(buf, sizeof(buf), RT_WAITING_FOREVER);
            _chn_recv_wm[id].last_warn = 0;
        }
    }
#endif
    return act;
1001ad58:	e51b300c 	ldr	r3, [fp, #-12]
}
1001ad5c:	e1a00003 	mov	r0, r3
1001ad60:	e24bd004 	sub	sp, fp, #4
1001ad64:	e8bd8800 	pop	{fp, pc}

1001ad68 <__dump_naked_cmd>:

/* dump cmd that is not start with ACK/NAK */
static size_t __dump_naked_cmd(char *dst, size_t lsize,
                               unsigned char *dp, size_t dsize)
{
1001ad68:	e92d4830 	push	{r4, r5, fp, lr}
1001ad6c:	e28db00c 	add	fp, sp, #12
1001ad70:	e24dd020 	sub	sp, sp, #32
1001ad74:	e50b0018 	str	r0, [fp, #-24]
1001ad78:	e50b101c 	str	r1, [fp, #-28]
1001ad7c:	e50b2020 	str	r2, [fp, #-32]
1001ad80:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    size_t len;
    if (dp[0] == RT_VBUS_CHN0_CMD_DISABLE ||
1001ad84:	e51b3020 	ldr	r3, [fp, #-32]
1001ad88:	e5d33000 	ldrb	r3, [r3]
1001ad8c:	e3530001 	cmp	r3, #1
1001ad90:	0a000007 	beq	1001adb4 <__dump_naked_cmd+0x4c>
        dp[0] == RT_VBUS_CHN0_CMD_SUSPEND ||
1001ad94:	e51b3020 	ldr	r3, [fp, #-32]
1001ad98:	e5d33000 	ldrb	r3, [r3]
/* dump cmd that is not start with ACK/NAK */
static size_t __dump_naked_cmd(char *dst, size_t lsize,
                               unsigned char *dp, size_t dsize)
{
    size_t len;
    if (dp[0] == RT_VBUS_CHN0_CMD_DISABLE ||
1001ad9c:	e3530005 	cmp	r3, #5
1001ada0:	0a000003 	beq	1001adb4 <__dump_naked_cmd+0x4c>
        dp[0] == RT_VBUS_CHN0_CMD_SUSPEND ||
        dp[0] == RT_VBUS_CHN0_CMD_RESUME)
1001ada4:	e51b3020 	ldr	r3, [fp, #-32]
1001ada8:	e5d33000 	ldrb	r3, [r3]
static size_t __dump_naked_cmd(char *dst, size_t lsize,
                               unsigned char *dp, size_t dsize)
{
    size_t len;
    if (dp[0] == RT_VBUS_CHN0_CMD_DISABLE ||
        dp[0] == RT_VBUS_CHN0_CMD_SUSPEND ||
1001adac:	e3530006 	cmp	r3, #6
1001adb0:	1a000012 	bne	1001ae00 <__dump_naked_cmd+0x98>
        dp[0] == RT_VBUS_CHN0_CMD_RESUME)
    {
        len = rt_snprintf(dst, lsize, "%s %d",
                          rt_vbus_cmd2str[dp[0]], dp[1]);
1001adb4:	e51b3020 	ldr	r3, [fp, #-32]
1001adb8:	e5d33000 	ldrb	r3, [r3]
    size_t len;
    if (dp[0] == RT_VBUS_CHN0_CMD_DISABLE ||
        dp[0] == RT_VBUS_CHN0_CMD_SUSPEND ||
        dp[0] == RT_VBUS_CHN0_CMD_RESUME)
    {
        len = rt_snprintf(dst, lsize, "%s %d",
1001adbc:	e1a02003 	mov	r2, r3
1001adc0:	e306392c 	movw	r3, #26924	; 0x692c
1001adc4:	e3413003 	movt	r3, #4099	; 0x1003
1001adc8:	e793c102 	ldr	ip, [r3, r2, lsl #2]
                          rt_vbus_cmd2str[dp[0]], dp[1]);
1001adcc:	e51b3020 	ldr	r3, [fp, #-32]
1001add0:	e2833001 	add	r3, r3, #1
1001add4:	e5d33000 	ldrb	r3, [r3]
    size_t len;
    if (dp[0] == RT_VBUS_CHN0_CMD_DISABLE ||
        dp[0] == RT_VBUS_CHN0_CMD_SUSPEND ||
        dp[0] == RT_VBUS_CHN0_CMD_RESUME)
    {
        len = rt_snprintf(dst, lsize, "%s %d",
1001add8:	e58d3000 	str	r3, [sp]
1001addc:	e51b0018 	ldr	r0, [fp, #-24]
1001ade0:	e51b101c 	ldr	r1, [fp, #-28]
1001ade4:	e30426b4 	movw	r2, #18100	; 0x46b4
1001ade8:	e3412003 	movt	r2, #4099	; 0x1003
1001adec:	e1a0300c 	mov	r3, ip
1001adf0:	ebffe2ca 	bl	10013920 <rt_snprintf>
1001adf4:	e1a03000 	mov	r3, r0
1001adf8:	e50b3010 	str	r3, [fp, #-16]
1001adfc:	ea000044 	b	1001af14 <__dump_naked_cmd+0x1ac>
                          rt_vbus_cmd2str[dp[0]], dp[1]);
    }
    else if (dp[0] == RT_VBUS_CHN0_CMD_ENABLE)
1001ae00:	e51b3020 	ldr	r3, [fp, #-32]
1001ae04:	e5d33000 	ldrb	r3, [r3]
1001ae08:	e3530000 	cmp	r3, #0
1001ae0c:	1a000011 	bne	1001ae58 <__dump_naked_cmd+0xf0>
    {
        len = rt_snprintf(dst, lsize, "%s %s",
                          rt_vbus_cmd2str[dp[0]], dp+1);
1001ae10:	e51b3020 	ldr	r3, [fp, #-32]
1001ae14:	e5d33000 	ldrb	r3, [r3]
        len = rt_snprintf(dst, lsize, "%s %d",
                          rt_vbus_cmd2str[dp[0]], dp[1]);
    }
    else if (dp[0] == RT_VBUS_CHN0_CMD_ENABLE)
    {
        len = rt_snprintf(dst, lsize, "%s %s",
1001ae18:	e1a02003 	mov	r2, r3
1001ae1c:	e306392c 	movw	r3, #26924	; 0x692c
1001ae20:	e3413003 	movt	r3, #4099	; 0x1003
1001ae24:	e793c102 	ldr	ip, [r3, r2, lsl #2]
1001ae28:	e51b3020 	ldr	r3, [fp, #-32]
1001ae2c:	e2833001 	add	r3, r3, #1
1001ae30:	e58d3000 	str	r3, [sp]
1001ae34:	e51b0018 	ldr	r0, [fp, #-24]
1001ae38:	e51b101c 	ldr	r1, [fp, #-28]
1001ae3c:	e30426bc 	movw	r2, #18108	; 0x46bc
1001ae40:	e3412003 	movt	r2, #4099	; 0x1003
1001ae44:	e1a0300c 	mov	r3, ip
1001ae48:	ebffe2b4 	bl	10013920 <rt_snprintf>
1001ae4c:	e1a03000 	mov	r3, r0
1001ae50:	e50b3010 	str	r3, [fp, #-16]
1001ae54:	ea00002e 	b	1001af14 <__dump_naked_cmd+0x1ac>
                          rt_vbus_cmd2str[dp[0]], dp+1);
    }
    else if (dp[0] < RT_VBUS_CHN0_CMD_MAX)
1001ae58:	e51b3020 	ldr	r3, [fp, #-32]
1001ae5c:	e5d33000 	ldrb	r3, [r3]
1001ae60:	e3530006 	cmp	r3, #6
1001ae64:	8a00001b 	bhi	1001aed8 <__dump_naked_cmd+0x170>
    {
        len = rt_snprintf(dst, lsize, "%s %s %d",
                          rt_vbus_cmd2str[dp[0]],
1001ae68:	e51b3020 	ldr	r3, [fp, #-32]
1001ae6c:	e5d33000 	ldrb	r3, [r3]
        len = rt_snprintf(dst, lsize, "%s %s",
                          rt_vbus_cmd2str[dp[0]], dp+1);
    }
    else if (dp[0] < RT_VBUS_CHN0_CMD_MAX)
    {
        len = rt_snprintf(dst, lsize, "%s %s %d",
1001ae70:	e1a02003 	mov	r2, r3
1001ae74:	e306392c 	movw	r3, #26924	; 0x692c
1001ae78:	e3413003 	movt	r3, #4099	; 0x1003
1001ae7c:	e7935102 	ldr	r5, [r3, r2, lsl #2]
1001ae80:	e51b3020 	ldr	r3, [fp, #-32]
1001ae84:	e2834001 	add	r4, r3, #1
                          rt_vbus_cmd2str[dp[0]],
                          dp+1, dp[2+rt_strlen((char*)dp+1)]);
1001ae88:	e51b3020 	ldr	r3, [fp, #-32]
1001ae8c:	e2833001 	add	r3, r3, #1
1001ae90:	e1a00003 	mov	r0, r3
1001ae94:	ebffdee4 	bl	10012a2c <rt_strlen>
1001ae98:	e1a03000 	mov	r3, r0
1001ae9c:	e2833002 	add	r3, r3, #2
1001aea0:	e51b2020 	ldr	r2, [fp, #-32]
1001aea4:	e0823003 	add	r3, r2, r3
1001aea8:	e5d33000 	ldrb	r3, [r3]
        len = rt_snprintf(dst, lsize, "%s %s",
                          rt_vbus_cmd2str[dp[0]], dp+1);
    }
    else if (dp[0] < RT_VBUS_CHN0_CMD_MAX)
    {
        len = rt_snprintf(dst, lsize, "%s %s %d",
1001aeac:	e58d4000 	str	r4, [sp]
1001aeb0:	e58d3004 	str	r3, [sp, #4]
1001aeb4:	e51b0018 	ldr	r0, [fp, #-24]
1001aeb8:	e51b101c 	ldr	r1, [fp, #-28]
1001aebc:	e30426c4 	movw	r2, #18116	; 0x46c4
1001aec0:	e3412003 	movt	r2, #4099	; 0x1003
1001aec4:	e1a03005 	mov	r3, r5
1001aec8:	ebffe294 	bl	10013920 <rt_snprintf>
1001aecc:	e1a03000 	mov	r3, r0
1001aed0:	e50b3010 	str	r3, [fp, #-16]
1001aed4:	ea00000e 	b	1001af14 <__dump_naked_cmd+0x1ac>
                          dp+1, dp[2+rt_strlen((char*)dp+1)]);
    }
    else
    {
        len = rt_snprintf(dst, lsize, "(invalid)%d %d",
                          dp[0], dp[1]);
1001aed8:	e51b3020 	ldr	r3, [fp, #-32]
1001aedc:	e5d33000 	ldrb	r3, [r3]
                          rt_vbus_cmd2str[dp[0]],
                          dp+1, dp[2+rt_strlen((char*)dp+1)]);
    }
    else
    {
        len = rt_snprintf(dst, lsize, "(invalid)%d %d",
1001aee0:	e1a0c003 	mov	ip, r3
                          dp[0], dp[1]);
1001aee4:	e51b3020 	ldr	r3, [fp, #-32]
1001aee8:	e2833001 	add	r3, r3, #1
1001aeec:	e5d33000 	ldrb	r3, [r3]
                          rt_vbus_cmd2str[dp[0]],
                          dp+1, dp[2+rt_strlen((char*)dp+1)]);
    }
    else
    {
        len = rt_snprintf(dst, lsize, "(invalid)%d %d",
1001aef0:	e58d3000 	str	r3, [sp]
1001aef4:	e51b0018 	ldr	r0, [fp, #-24]
1001aef8:	e51b101c 	ldr	r1, [fp, #-28]
1001aefc:	e30426d0 	movw	r2, #18128	; 0x46d0
1001af00:	e3412003 	movt	r2, #4099	; 0x1003
1001af04:	e1a0300c 	mov	r3, ip
1001af08:	ebffe284 	bl	10013920 <rt_snprintf>
1001af0c:	e1a03000 	mov	r3, r0
1001af10:	e50b3010 	str	r3, [fp, #-16]
                          dp[0], dp[1]);
    }
    return len;
1001af14:	e51b3010 	ldr	r3, [fp, #-16]
}
1001af18:	e1a00003 	mov	r0, r3
1001af1c:	e24bd00c 	sub	sp, fp, #12
1001af20:	e8bd8830 	pop	{r4, r5, fp, pc}

1001af24 <dump_cmd_pkt>:

static char _cmd_dump_buf[64];
static char* dump_cmd_pkt(unsigned char *dp, size_t dsize)
{
1001af24:	e92d4800 	push	{fp, lr}
1001af28:	e28db004 	add	fp, sp, #4
1001af2c:	e24dd010 	sub	sp, sp, #16
1001af30:	e50b0010 	str	r0, [fp, #-16]
1001af34:	e50b1014 	str	r1, [fp, #-20]
    size_t len;

    if (dp[0] == RT_VBUS_CHN0_CMD_ACK || dp[0] == RT_VBUS_CHN0_CMD_NAK )
1001af38:	e51b3010 	ldr	r3, [fp, #-16]
1001af3c:	e5d33000 	ldrb	r3, [r3]
1001af40:	e3530003 	cmp	r3, #3
1001af44:	0a000003 	beq	1001af58 <dump_cmd_pkt+0x34>
1001af48:	e51b3010 	ldr	r3, [fp, #-16]
1001af4c:	e5d33000 	ldrb	r3, [r3]
1001af50:	e3530004 	cmp	r3, #4
1001af54:	1a00001d 	bne	1001afd0 <dump_cmd_pkt+0xac>
    {
        len = rt_snprintf(_cmd_dump_buf, sizeof(_cmd_dump_buf),
                          "%s ", rt_vbus_cmd2str[dp[0]]);
1001af58:	e51b3010 	ldr	r3, [fp, #-16]
1001af5c:	e5d33000 	ldrb	r3, [r3]
{
    size_t len;

    if (dp[0] == RT_VBUS_CHN0_CMD_ACK || dp[0] == RT_VBUS_CHN0_CMD_NAK )
    {
        len = rt_snprintf(_cmd_dump_buf, sizeof(_cmd_dump_buf),
1001af60:	e1a02003 	mov	r2, r3
1001af64:	e306392c 	movw	r3, #26924	; 0x692c
1001af68:	e3413003 	movt	r3, #4099	; 0x1003
1001af6c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1001af70:	e30d0eb0 	movw	r0, #57008	; 0xdeb0
1001af74:	e3410003 	movt	r0, #4099	; 0x1003
1001af78:	e3a01040 	mov	r1, #64	; 0x40
1001af7c:	e30426e0 	movw	r2, #18144	; 0x46e0
1001af80:	e3412003 	movt	r2, #4099	; 0x1003
1001af84:	ebffe265 	bl	10013920 <rt_snprintf>
1001af88:	e1a03000 	mov	r3, r0
1001af8c:	e50b3008 	str	r3, [fp, #-8]
                          "%s ", rt_vbus_cmd2str[dp[0]]);
        len += __dump_naked_cmd(_cmd_dump_buf+len, sizeof(_cmd_dump_buf)-len,
1001af90:	e51b2008 	ldr	r2, [fp, #-8]
1001af94:	e30d3eb0 	movw	r3, #57008	; 0xdeb0
1001af98:	e3413003 	movt	r3, #4099	; 0x1003
1001af9c:	e0820003 	add	r0, r2, r3
1001afa0:	e51b3008 	ldr	r3, [fp, #-8]
1001afa4:	e2631040 	rsb	r1, r3, #64	; 0x40
1001afa8:	e51b3010 	ldr	r3, [fp, #-16]
1001afac:	e2832001 	add	r2, r3, #1
1001afb0:	e51b3014 	ldr	r3, [fp, #-20]
1001afb4:	e2433001 	sub	r3, r3, #1
1001afb8:	ebffff6a 	bl	1001ad68 <__dump_naked_cmd>
1001afbc:	e1a02000 	mov	r2, r0
1001afc0:	e51b3008 	ldr	r3, [fp, #-8]
1001afc4:	e0833002 	add	r3, r3, r2
1001afc8:	e50b3008 	str	r3, [fp, #-8]
                                dp+1, dsize-1);
1001afcc:	ea000006 	b	1001afec <dump_cmd_pkt+0xc8>
    }
    else
    {
        len = __dump_naked_cmd(_cmd_dump_buf, sizeof(_cmd_dump_buf),
1001afd0:	e30d0eb0 	movw	r0, #57008	; 0xdeb0
1001afd4:	e3410003 	movt	r0, #4099	; 0x1003
1001afd8:	e3a01040 	mov	r1, #64	; 0x40
1001afdc:	e51b2010 	ldr	r2, [fp, #-16]
1001afe0:	e51b3014 	ldr	r3, [fp, #-20]
1001afe4:	ebffff5f 	bl	1001ad68 <__dump_naked_cmd>
1001afe8:	e50b0008 	str	r0, [fp, #-8]
                               dp, dsize);
    }

    if (len > sizeof(_cmd_dump_buf) - 1)
1001afec:	e51b3008 	ldr	r3, [fp, #-8]
1001aff0:	e353003f 	cmp	r3, #63	; 0x3f
1001aff4:	9a000001 	bls	1001b000 <dump_cmd_pkt+0xdc>
        len = sizeof(_cmd_dump_buf) - 1;
1001aff8:	e3a0303f 	mov	r3, #63	; 0x3f
1001affc:	e50b3008 	str	r3, [fp, #-8]

    _cmd_dump_buf[len] = '\0';
1001b000:	e30d3eb0 	movw	r3, #57008	; 0xdeb0
1001b004:	e3413003 	movt	r3, #4099	; 0x1003
1001b008:	e51b2008 	ldr	r2, [fp, #-8]
1001b00c:	e0833002 	add	r3, r3, r2
1001b010:	e3a02000 	mov	r2, #0
1001b014:	e5c32000 	strb	r2, [r3]
    return _cmd_dump_buf;
1001b018:	e30d3eb0 	movw	r3, #57008	; 0xdeb0
1001b01c:	e3413003 	movt	r3, #4099	; 0x1003
}
1001b020:	e1a00003 	mov	r0, r3
1001b024:	e24bd004 	sub	sp, fp, #4
1001b028:	e8bd8800 	pop	{fp, pc}

1001b02c <_chn0_echo_with>:

static rt_err_t _chn0_echo_with(rt_uint8_t prefix,
                                rt_uint32_t dsize,
                                unsigned char *dp)
{
1001b02c:	e92d4800 	push	{fp, lr}
1001b030:	e28db004 	add	fp, sp, #4
1001b034:	e24dd018 	sub	sp, sp, #24
1001b038:	e1a03000 	mov	r3, r0
1001b03c:	e50b1014 	str	r1, [fp, #-20]
1001b040:	e50b2018 	str	r2, [fp, #-24]
1001b044:	e54b300d 	strb	r3, [fp, #-13]
    rt_err_t err;
    unsigned char *resp;

    resp = rt_malloc(dsize+1);
1001b048:	e51b3014 	ldr	r3, [fp, #-20]
1001b04c:	e2833001 	add	r3, r3, #1
1001b050:	e1a00003 	mov	r0, r3
1001b054:	ebffe48e 	bl	10014294 <rt_malloc>
1001b058:	e50b0008 	str	r0, [fp, #-8]
    if (!resp)
1001b05c:	e51b3008 	ldr	r3, [fp, #-8]
1001b060:	e3530000 	cmp	r3, #0
1001b064:	1a000001 	bne	1001b070 <_chn0_echo_with+0x44>
        return -RT_ENOMEM;
1001b068:	e3e03004 	mvn	r3, #4
1001b06c:	ea000012 	b	1001b0bc <_chn0_echo_with+0x90>
    *resp = prefix;
1001b070:	e51b3008 	ldr	r3, [fp, #-8]
1001b074:	e55b200d 	ldrb	r2, [fp, #-13]
1001b078:	e5c32000 	strb	r2, [r3]
    rt_memcpy(resp+1, dp, dsize);
1001b07c:	e51b3008 	ldr	r3, [fp, #-8]
1001b080:	e2833001 	add	r3, r3, #1
1001b084:	e1a00003 	mov	r0, r3
1001b088:	e51b1018 	ldr	r1, [fp, #-24]
1001b08c:	e51b2014 	ldr	r2, [fp, #-20]
1001b090:	ebffdcc8 	bl	100123b8 <rt_memcpy>
    vbus_verbose("%s --> remote\n", dump_cmd_pkt(resp, dsize+1));

    err = _chn0_post(resp, dsize+1, RT_WAITING_FOREVER);
1001b094:	e51b3014 	ldr	r3, [fp, #-20]
1001b098:	e2833001 	add	r3, r3, #1
1001b09c:	e51b0008 	ldr	r0, [fp, #-8]
1001b0a0:	e1a01003 	mov	r1, r3
1001b0a4:	e3e02000 	mvn	r2, #0
1001b0a8:	ebfffe70 	bl	1001aa70 <_chn0_post>
1001b0ac:	e50b000c 	str	r0, [fp, #-12]

    rt_free(resp);
1001b0b0:	e51b0008 	ldr	r0, [fp, #-8]
1001b0b4:	ebffe691 	bl	10014b00 <rt_free>

    return err;
1001b0b8:	e51b300c 	ldr	r3, [fp, #-12]
}
1001b0bc:	e1a00003 	mov	r0, r3
1001b0c0:	e24bd004 	sub	sp, fp, #4
1001b0c4:	e8bd8800 	pop	{fp, pc}

1001b0c8 <_chn0_nak>:

static rt_err_t _chn0_nak(rt_uint32_t dsize, unsigned char *dp)
{
1001b0c8:	e92d4800 	push	{fp, lr}
1001b0cc:	e28db004 	add	fp, sp, #4
1001b0d0:	e24dd008 	sub	sp, sp, #8
1001b0d4:	e50b0008 	str	r0, [fp, #-8]
1001b0d8:	e50b100c 	str	r1, [fp, #-12]
    return _chn0_echo_with(RT_VBUS_CHN0_CMD_NAK, dsize, dp);
1001b0dc:	e3a00004 	mov	r0, #4
1001b0e0:	e51b1008 	ldr	r1, [fp, #-8]
1001b0e4:	e51b200c 	ldr	r2, [fp, #-12]
1001b0e8:	ebffffcf 	bl	1001b02c <_chn0_echo_with>
1001b0ec:	e1a03000 	mov	r3, r0
}
1001b0f0:	e1a00003 	mov	r0, r3
1001b0f4:	e24bd004 	sub	sp, fp, #4
1001b0f8:	e8bd8800 	pop	{fp, pc}

1001b0fc <_chn0_ack>:

static rt_err_t _chn0_ack(rt_uint32_t dsize, unsigned char *dp)
{
1001b0fc:	e92d4800 	push	{fp, lr}
1001b100:	e28db004 	add	fp, sp, #4
1001b104:	e24dd008 	sub	sp, sp, #8
1001b108:	e50b0008 	str	r0, [fp, #-8]
1001b10c:	e50b100c 	str	r1, [fp, #-12]
    return _chn0_echo_with(RT_VBUS_CHN0_CMD_ACK, dsize, dp);
1001b110:	e3a00003 	mov	r0, #3
1001b114:	e51b1008 	ldr	r1, [fp, #-8]
1001b118:	e51b200c 	ldr	r2, [fp, #-12]
1001b11c:	ebffffc2 	bl	1001b02c <_chn0_echo_with>
1001b120:	e1a03000 	mov	r3, r0
}
1001b124:	e1a00003 	mov	r0, r3
1001b128:	e24bd004 	sub	sp, fp, #4
1001b12c:	e8bd8800 	pop	{fp, pc}

1001b130 <_sess_find>:

static struct rt_vbus_conn_session _sess[RT_VBUS_CHANNEL_NR/2];

static int _sess_find(const unsigned char *name,
                      enum _vbus_session_st st)
{
1001b130:	e92d4800 	push	{fp, lr}
1001b134:	e28db004 	add	fp, sp, #4
1001b138:	e24dd010 	sub	sp, sp, #16
1001b13c:	e50b0010 	str	r0, [fp, #-16]
1001b140:	e1a03001 	mov	r3, r1
1001b144:	e54b3011 	strb	r3, [fp, #-17]
    int i;

    for (i = 0; i < ARRAY_SIZE(_sess); i++)
1001b148:	e3a03000 	mov	r3, #0
1001b14c:	e50b3008 	str	r3, [fp, #-8]
1001b150:	ea000030 	b	1001b218 <_sess_find+0xe8>
    {
        if (_sess[i].st == st && _sess[i].req->name &&
1001b154:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b158:	e3412003 	movt	r2, #4099	; 0x1003
1001b15c:	e51b3008 	ldr	r3, [fp, #-8]
1001b160:	e1a01003 	mov	r1, r3
1001b164:	e1a03181 	lsl	r3, r1, #3
1001b168:	e1a01003 	mov	r1, r3
1001b16c:	e1a03101 	lsl	r3, r1, #2
1001b170:	e0613003 	rsb	r3, r1, r3
1001b174:	e0823003 	add	r3, r2, r3
1001b178:	e5d33004 	ldrb	r3, [r3, #4]
1001b17c:	e55b2011 	ldrb	r2, [fp, #-17]
1001b180:	e1520003 	cmp	r2, r3
1001b184:	1a000020 	bne	1001b20c <_sess_find+0xdc>
1001b188:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b18c:	e3412003 	movt	r2, #4099	; 0x1003
1001b190:	e51b3008 	ldr	r3, [fp, #-8]
1001b194:	e1a01003 	mov	r1, r3
1001b198:	e1a03181 	lsl	r3, r1, #3
1001b19c:	e1a01003 	mov	r1, r3
1001b1a0:	e1a03101 	lsl	r3, r1, #2
1001b1a4:	e0613003 	rsb	r3, r1, r3
1001b1a8:	e0823003 	add	r3, r2, r3
1001b1ac:	e2833010 	add	r3, r3, #16
1001b1b0:	e5933004 	ldr	r3, [r3, #4]
1001b1b4:	e5933004 	ldr	r3, [r3, #4]
1001b1b8:	e3530000 	cmp	r3, #0
1001b1bc:	0a000012 	beq	1001b20c <_sess_find+0xdc>
            rt_strcmp(_sess[i].req->name, (char*)name) == 0)
1001b1c0:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b1c4:	e3412003 	movt	r2, #4099	; 0x1003
1001b1c8:	e51b3008 	ldr	r3, [fp, #-8]
1001b1cc:	e1a01003 	mov	r1, r3
1001b1d0:	e1a03181 	lsl	r3, r1, #3
1001b1d4:	e1a01003 	mov	r1, r3
1001b1d8:	e1a03101 	lsl	r3, r1, #2
1001b1dc:	e0613003 	rsb	r3, r1, r3
1001b1e0:	e0823003 	add	r3, r2, r3
1001b1e4:	e2833010 	add	r3, r3, #16
1001b1e8:	e5933004 	ldr	r3, [r3, #4]
1001b1ec:	e5933004 	ldr	r3, [r3, #4]
1001b1f0:	e1a00003 	mov	r0, r3
1001b1f4:	e51b1010 	ldr	r1, [fp, #-16]
1001b1f8:	ebffddeb 	bl	100129ac <rt_strcmp>
1001b1fc:	e1a03000 	mov	r3, r0
{
    int i;

    for (i = 0; i < ARRAY_SIZE(_sess); i++)
    {
        if (_sess[i].st == st && _sess[i].req->name &&
1001b200:	e3530000 	cmp	r3, #0
1001b204:	1a000000 	bne	1001b20c <_sess_find+0xdc>
            rt_strcmp(_sess[i].req->name, (char*)name) == 0)
            break;
1001b208:	ea000005 	b	1001b224 <_sess_find+0xf4>
static int _sess_find(const unsigned char *name,
                      enum _vbus_session_st st)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(_sess); i++)
1001b20c:	e51b3008 	ldr	r3, [fp, #-8]
1001b210:	e2833001 	add	r3, r3, #1
1001b214:	e50b3008 	str	r3, [fp, #-8]
1001b218:	e51b3008 	ldr	r3, [fp, #-8]
1001b21c:	e353000f 	cmp	r3, #15
1001b220:	9affffcb 	bls	1001b154 <_sess_find+0x24>
    {
        if (_sess[i].st == st && _sess[i].req->name &&
            rt_strcmp(_sess[i].req->name, (char*)name) == 0)
            break;
    }
    return i;
1001b224:	e51b3008 	ldr	r3, [fp, #-8]
}
1001b228:	e1a00003 	mov	r0, r3
1001b22c:	e24bd004 	sub	sp, fp, #4
1001b230:	e8bd8800 	pop	{fp, pc}

1001b234 <_chn0_actor>:

static int _chn0_actor(unsigned char *dp, size_t dsize)
{
1001b234:	e92d4800 	push	{fp, lr}
1001b238:	e28db004 	add	fp, sp, #4
1001b23c:	e24dd030 	sub	sp, sp, #48	; 0x30
1001b240:	e50b0030 	str	r0, [fp, #-48]	; 0x30
1001b244:	e50b1034 	str	r1, [fp, #-52]	; 0x34
    if (*dp != RT_VBUS_CHN0_CMD_SUSPEND && *dp != RT_VBUS_CHN0_CMD_RESUME)
1001b248:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b24c:	e5d33000 	ldrb	r3, [r3]
1001b250:	e3530005 	cmp	r3, #5
        vbus_verbose("local <-- %s\n", dump_cmd_pkt(dp, dsize));

    switch (*dp)
1001b254:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b258:	e5d33000 	ldrb	r3, [r3]
1001b25c:	e3530006 	cmp	r3, #6
1001b260:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001b264:	ea0001c2 	b	1001b974 <_chn0_actor+0x740>
1001b268:	1001b284 	.word	0x1001b284
1001b26c:	1001b870 	.word	0x1001b870
1001b270:	1001b514 	.word	0x1001b514
1001b274:	1001b724 	.word	0x1001b724
1001b278:	1001b8d8 	.word	0x1001b8d8
1001b27c:	1001b974 	.word	0x1001b974
1001b280:	1001b974 	.word	0x1001b974
        {
            int i, chnr;
            rt_err_t err;
            unsigned char *resp;

            i = _sess_find(dp+1, SESSIOM_LISTENING);
1001b284:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b288:	e2833001 	add	r3, r3, #1
1001b28c:	e1a00003 	mov	r0, r3
1001b290:	e3a01001 	mov	r1, #1
1001b294:	ebffffa5 	bl	1001b130 <_sess_find>
1001b298:	e50b000c 	str	r0, [fp, #-12]
            if (i == ARRAY_SIZE(_sess))
1001b29c:	e51b300c 	ldr	r3, [fp, #-12]
1001b2a0:	e3530010 	cmp	r3, #16
1001b2a4:	1a000003 	bne	1001b2b8 <_chn0_actor+0x84>
            {
                _chn0_nak(dsize, dp);
1001b2a8:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
1001b2ac:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
1001b2b0:	ebffff84 	bl	1001b0c8 <_chn0_nak>
                break;
1001b2b4:	ea0001af 	b	1001b978 <_chn0_actor+0x744>
            }

            for (chnr = 0; chnr < ARRAY_SIZE(_chn_status); chnr++)
1001b2b8:	e3a03000 	mov	r3, #0
1001b2bc:	e50b3008 	str	r3, [fp, #-8]
1001b2c0:	ea00000a 	b	1001b2f0 <_chn0_actor+0xbc>
            {
                if (_chn_status[chnr] == RT_VBUS_CHN_ST_AVAILABLE)
1001b2c4:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001b2c8:	e3413003 	movt	r3, #4099	; 0x1003
1001b2cc:	e51b2008 	ldr	r2, [fp, #-8]
1001b2d0:	e0833002 	add	r3, r3, r2
1001b2d4:	e5d33000 	ldrb	r3, [r3]
1001b2d8:	e3530000 	cmp	r3, #0
1001b2dc:	1a000000 	bne	1001b2e4 <_chn0_actor+0xb0>
                    break;
1001b2e0:	ea000005 	b	1001b2fc <_chn0_actor+0xc8>
            {
                _chn0_nak(dsize, dp);
                break;
            }

            for (chnr = 0; chnr < ARRAY_SIZE(_chn_status); chnr++)
1001b2e4:	e51b3008 	ldr	r3, [fp, #-8]
1001b2e8:	e2833001 	add	r3, r3, #1
1001b2ec:	e50b3008 	str	r3, [fp, #-8]
1001b2f0:	e51b3008 	ldr	r3, [fp, #-8]
1001b2f4:	e353001f 	cmp	r3, #31
1001b2f8:	9afffff1 	bls	1001b2c4 <_chn0_actor+0x90>
            {
                if (_chn_status[chnr] == RT_VBUS_CHN_ST_AVAILABLE)
                    break;
            }
            if (chnr == ARRAY_SIZE(_chn_status))
1001b2fc:	e51b3008 	ldr	r3, [fp, #-8]
1001b300:	e3530020 	cmp	r3, #32
1001b304:	1a000003 	bne	1001b318 <_chn0_actor+0xe4>
            {
                _chn0_nak(dsize, dp);
1001b308:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
1001b30c:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
1001b310:	ebffff6c 	bl	1001b0c8 <_chn0_nak>
                break;
1001b314:	ea000197 	b	1001b978 <_chn0_actor+0x744>
            }

            resp = rt_malloc(dsize + 1);
1001b318:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1001b31c:	e2833001 	add	r3, r3, #1
1001b320:	e1a00003 	mov	r0, r3
1001b324:	ebffe3da 	bl	10014294 <rt_malloc>
1001b328:	e50b0010 	str	r0, [fp, #-16]
            if (!resp)
1001b32c:	e51b3010 	ldr	r3, [fp, #-16]
1001b330:	e3530000 	cmp	r3, #0
1001b334:	1a000000 	bne	1001b33c <_chn0_actor+0x108>
                break;
1001b338:	ea00018e 	b	1001b978 <_chn0_actor+0x744>

            *resp = RT_VBUS_CHN0_CMD_SET;
1001b33c:	e51b3010 	ldr	r3, [fp, #-16]
1001b340:	e3a02002 	mov	r2, #2
1001b344:	e5c32000 	strb	r2, [r3]
            rt_memcpy(resp+1, dp+1, dsize-1);
1001b348:	e51b3010 	ldr	r3, [fp, #-16]
1001b34c:	e2831001 	add	r1, r3, #1
1001b350:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b354:	e2832001 	add	r2, r3, #1
1001b358:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1001b35c:	e2433001 	sub	r3, r3, #1
1001b360:	e1a00001 	mov	r0, r1
1001b364:	e1a01002 	mov	r1, r2
1001b368:	e1a02003 	mov	r2, r3
1001b36c:	ebffdc11 	bl	100123b8 <rt_memcpy>
            resp[dsize] = chnr;
1001b370:	e51b2010 	ldr	r2, [fp, #-16]
1001b374:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1001b378:	e0823003 	add	r3, r2, r3
1001b37c:	e51b2008 	ldr	r2, [fp, #-8]
1001b380:	e6ef2072 	uxtb	r2, r2
1001b384:	e5c32000 	strb	r2, [r3]

            rt_vbus_set_recv_wm(chnr, _sess[i].req->recv_wm.low, _sess[i].req->recv_wm.high);
1001b388:	e51b3008 	ldr	r3, [fp, #-8]
1001b38c:	e6ef0073 	uxtb	r0, r3
1001b390:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b394:	e3412003 	movt	r2, #4099	; 0x1003
1001b398:	e51b300c 	ldr	r3, [fp, #-12]
1001b39c:	e1a01003 	mov	r1, r3
1001b3a0:	e1a03181 	lsl	r3, r1, #3
1001b3a4:	e1a01003 	mov	r1, r3
1001b3a8:	e1a03101 	lsl	r3, r1, #2
1001b3ac:	e0613003 	rsb	r3, r1, r3
1001b3b0:	e0823003 	add	r3, r2, r3
1001b3b4:	e2833010 	add	r3, r3, #16
1001b3b8:	e5933004 	ldr	r3, [r3, #4]
1001b3bc:	e593c00c 	ldr	ip, [r3, #12]
1001b3c0:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b3c4:	e3412003 	movt	r2, #4099	; 0x1003
1001b3c8:	e51b300c 	ldr	r3, [fp, #-12]
1001b3cc:	e1a01003 	mov	r1, r3
1001b3d0:	e1a03181 	lsl	r3, r1, #3
1001b3d4:	e1a01003 	mov	r1, r3
1001b3d8:	e1a03101 	lsl	r3, r1, #2
1001b3dc:	e0613003 	rsb	r3, r1, r3
1001b3e0:	e0823003 	add	r3, r2, r3
1001b3e4:	e2833010 	add	r3, r3, #16
1001b3e8:	e5933004 	ldr	r3, [r3, #4]
1001b3ec:	e5933010 	ldr	r3, [r3, #16]
1001b3f0:	e1a0100c 	mov	r1, ip
1001b3f4:	e1a02003 	mov	r2, r3
1001b3f8:	ebfffbab 	bl	1001a2ac <rt_vbus_set_recv_wm>
            rt_vbus_set_post_wm(chnr, _sess[i].req->post_wm.low, _sess[i].req->post_wm.high);
1001b3fc:	e51b3008 	ldr	r3, [fp, #-8]
1001b400:	e6ef0073 	uxtb	r0, r3
1001b404:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b408:	e3412003 	movt	r2, #4099	; 0x1003
1001b40c:	e51b300c 	ldr	r3, [fp, #-12]
1001b410:	e1a01003 	mov	r1, r3
1001b414:	e1a03181 	lsl	r3, r1, #3
1001b418:	e1a01003 	mov	r1, r3
1001b41c:	e1a03101 	lsl	r3, r1, #2
1001b420:	e0613003 	rsb	r3, r1, r3
1001b424:	e0823003 	add	r3, r2, r3
1001b428:	e2833010 	add	r3, r3, #16
1001b42c:	e5933004 	ldr	r3, [r3, #4]
1001b430:	e593c014 	ldr	ip, [r3, #20]
1001b434:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b438:	e3412003 	movt	r2, #4099	; 0x1003
1001b43c:	e51b300c 	ldr	r3, [fp, #-12]
1001b440:	e1a01003 	mov	r1, r3
1001b444:	e1a03181 	lsl	r3, r1, #3
1001b448:	e1a01003 	mov	r1, r3
1001b44c:	e1a03101 	lsl	r3, r1, #2
1001b450:	e0613003 	rsb	r3, r1, r3
1001b454:	e0823003 	add	r3, r2, r3
1001b458:	e2833010 	add	r3, r3, #16
1001b45c:	e5933004 	ldr	r3, [r3, #4]
1001b460:	e5933018 	ldr	r3, [r3, #24]
1001b464:	e1a0100c 	mov	r1, ip
1001b468:	e1a02003 	mov	r2, r3
1001b46c:	ebfffb98 	bl	1001a2d4 <rt_vbus_set_post_wm>

            vbus_verbose("%s --> remote\n", dump_cmd_pkt(resp, dsize+1));
            err = _chn0_post(resp, dsize+1, RT_WAITING_FOREVER);
1001b470:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1001b474:	e2833001 	add	r3, r3, #1
1001b478:	e51b0010 	ldr	r0, [fp, #-16]
1001b47c:	e1a01003 	mov	r1, r3
1001b480:	e3e02000 	mvn	r2, #0
1001b484:	ebfffd79 	bl	1001aa70 <_chn0_post>
1001b488:	e50b0014 	str	r0, [fp, #-20]

            if (err == RT_EOK)
1001b48c:	e51b3014 	ldr	r3, [fp, #-20]
1001b490:	e3530000 	cmp	r3, #0
1001b494:	1a00001b 	bne	1001b508 <_chn0_actor+0x2d4>
            {
                _sess[i].st   = SESSIOM_ESTABLISHING;
1001b498:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b49c:	e3412003 	movt	r2, #4099	; 0x1003
1001b4a0:	e51b300c 	ldr	r3, [fp, #-12]
1001b4a4:	e1a01003 	mov	r1, r3
1001b4a8:	e1a03181 	lsl	r3, r1, #3
1001b4ac:	e1a01003 	mov	r1, r3
1001b4b0:	e1a03101 	lsl	r3, r1, #2
1001b4b4:	e0613003 	rsb	r3, r1, r3
1001b4b8:	e0823003 	add	r3, r2, r3
1001b4bc:	e3a02002 	mov	r2, #2
1001b4c0:	e5c32004 	strb	r2, [r3, #4]
                vbus_debug("set sess %d st: %s\n", i,
                           rt_vbus_sess_st2str[_sess[i].st]);
                _sess[i].chnr = chnr;
1001b4c4:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b4c8:	e3412003 	movt	r2, #4099	; 0x1003
1001b4cc:	e51b300c 	ldr	r3, [fp, #-12]
1001b4d0:	e1a01003 	mov	r1, r3
1001b4d4:	e1a03181 	lsl	r3, r1, #3
1001b4d8:	e1a01003 	mov	r1, r3
1001b4dc:	e1a03101 	lsl	r3, r1, #2
1001b4e0:	e0613003 	rsb	r3, r1, r3
1001b4e4:	e0823003 	add	r3, r2, r3
1001b4e8:	e51b2008 	ldr	r2, [fp, #-8]
1001b4ec:	e5832000 	str	r2, [r3]
                _chn_status[chnr] = RT_VBUS_CHN_ST_ESTABLISHING;
1001b4f0:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001b4f4:	e3413003 	movt	r3, #4099	; 0x1003
1001b4f8:	e51b2008 	ldr	r2, [fp, #-8]
1001b4fc:	e0833002 	add	r3, r3, r2
1001b500:	e3a02002 	mov	r2, #2
1001b504:	e5c32000 	strb	r2, [r3]
            }
            rt_free(resp);
1001b508:	e51b0010 	ldr	r0, [fp, #-16]
1001b50c:	ebffe57b 	bl	10014b00 <rt_free>
        }
        break;
1001b510:	ea000118 	b	1001b978 <_chn0_actor+0x744>
    case RT_VBUS_CHN0_CMD_SET:
        {
            int i, chnr;

            i = _sess_find(dp+1, SESSIOM_ESTABLISHING);
1001b514:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b518:	e2833001 	add	r3, r3, #1
1001b51c:	e1a00003 	mov	r0, r3
1001b520:	e3a01002 	mov	r1, #2
1001b524:	ebffff01 	bl	1001b130 <_sess_find>
1001b528:	e50b0018 	str	r0, [fp, #-24]
            if (i == ARRAY_SIZE(_sess))
1001b52c:	e51b3018 	ldr	r3, [fp, #-24]
1001b530:	e3530010 	cmp	r3, #16
1001b534:	1a000000 	bne	1001b53c <_chn0_actor+0x308>
            {
                vbus_verbose("drop spurious packet\n");
                break;
1001b538:	ea00010e 	b	1001b978 <_chn0_actor+0x744>
            }

            chnr = dp[1+rt_strlen((const char*)dp+1)+1];
1001b53c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b540:	e2833001 	add	r3, r3, #1
1001b544:	e1a00003 	mov	r0, r3
1001b548:	ebffdd37 	bl	10012a2c <rt_strlen>
1001b54c:	e1a03000 	mov	r3, r0
1001b550:	e2833002 	add	r3, r3, #2
1001b554:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
1001b558:	e0823003 	add	r3, r2, r3
1001b55c:	e5d33000 	ldrb	r3, [r3]
1001b560:	e50b301c 	str	r3, [fp, #-28]

            if (chnr == 0 || chnr >= RT_VBUS_CHANNEL_NR)
1001b564:	e51b301c 	ldr	r3, [fp, #-28]
1001b568:	e3530000 	cmp	r3, #0
1001b56c:	0a000101 	beq	1001b978 <_chn0_actor+0x744>
1001b570:	e51b301c 	ldr	r3, [fp, #-28]
1001b574:	e353001f 	cmp	r3, #31
1001b578:	ca0000fe 	bgt	1001b978 <_chn0_actor+0x744>
            {
                vbus_verbose("SET wrong chnr %d\n", chnr);
                break;
            }
            if (_chn_status[chnr] != RT_VBUS_CHN_ST_AVAILABLE)
1001b57c:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001b580:	e3413003 	movt	r3, #4099	; 0x1003
1001b584:	e51b201c 	ldr	r2, [fp, #-28]
1001b588:	e0833002 	add	r3, r3, r2
1001b58c:	e5d33000 	ldrb	r3, [r3]
1001b590:	e3530000 	cmp	r3, #0
1001b594:	0a000003 	beq	1001b5a8 <_chn0_actor+0x374>
            {
                _chn0_nak(dsize, dp);
1001b598:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
1001b59c:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
1001b5a0:	ebfffec8 	bl	1001b0c8 <_chn0_nak>
                vbus_verbose("SET wrong chnr status %d, %s\n",
                             chnr, rt_vbus_chn_st2str[_chn_status[chnr]]);
                break;
1001b5a4:	ea0000f3 	b	1001b978 <_chn0_actor+0x744>
            }

            rt_vbus_set_recv_wm(chnr, _sess[i].req->recv_wm.low, _sess[i].req->recv_wm.high);
1001b5a8:	e51b301c 	ldr	r3, [fp, #-28]
1001b5ac:	e6ef0073 	uxtb	r0, r3
1001b5b0:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b5b4:	e3412003 	movt	r2, #4099	; 0x1003
1001b5b8:	e51b3018 	ldr	r3, [fp, #-24]
1001b5bc:	e1a01003 	mov	r1, r3
1001b5c0:	e1a03181 	lsl	r3, r1, #3
1001b5c4:	e1a01003 	mov	r1, r3
1001b5c8:	e1a03101 	lsl	r3, r1, #2
1001b5cc:	e0613003 	rsb	r3, r1, r3
1001b5d0:	e0823003 	add	r3, r2, r3
1001b5d4:	e2833010 	add	r3, r3, #16
1001b5d8:	e5933004 	ldr	r3, [r3, #4]
1001b5dc:	e593c00c 	ldr	ip, [r3, #12]
1001b5e0:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b5e4:	e3412003 	movt	r2, #4099	; 0x1003
1001b5e8:	e51b3018 	ldr	r3, [fp, #-24]
1001b5ec:	e1a01003 	mov	r1, r3
1001b5f0:	e1a03181 	lsl	r3, r1, #3
1001b5f4:	e1a01003 	mov	r1, r3
1001b5f8:	e1a03101 	lsl	r3, r1, #2
1001b5fc:	e0613003 	rsb	r3, r1, r3
1001b600:	e0823003 	add	r3, r2, r3
1001b604:	e2833010 	add	r3, r3, #16
1001b608:	e5933004 	ldr	r3, [r3, #4]
1001b60c:	e5933010 	ldr	r3, [r3, #16]
1001b610:	e1a0100c 	mov	r1, ip
1001b614:	e1a02003 	mov	r2, r3
1001b618:	ebfffb23 	bl	1001a2ac <rt_vbus_set_recv_wm>
            rt_vbus_set_post_wm(chnr, _sess[i].req->post_wm.low, _sess[i].req->post_wm.high);
1001b61c:	e51b301c 	ldr	r3, [fp, #-28]
1001b620:	e6ef0073 	uxtb	r0, r3
1001b624:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b628:	e3412003 	movt	r2, #4099	; 0x1003
1001b62c:	e51b3018 	ldr	r3, [fp, #-24]
1001b630:	e1a01003 	mov	r1, r3
1001b634:	e1a03181 	lsl	r3, r1, #3
1001b638:	e1a01003 	mov	r1, r3
1001b63c:	e1a03101 	lsl	r3, r1, #2
1001b640:	e0613003 	rsb	r3, r1, r3
1001b644:	e0823003 	add	r3, r2, r3
1001b648:	e2833010 	add	r3, r3, #16
1001b64c:	e5933004 	ldr	r3, [r3, #4]
1001b650:	e593c014 	ldr	ip, [r3, #20]
1001b654:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b658:	e3412003 	movt	r2, #4099	; 0x1003
1001b65c:	e51b3018 	ldr	r3, [fp, #-24]
1001b660:	e1a01003 	mov	r1, r3
1001b664:	e1a03181 	lsl	r3, r1, #3
1001b668:	e1a01003 	mov	r1, r3
1001b66c:	e1a03101 	lsl	r3, r1, #2
1001b670:	e0613003 	rsb	r3, r1, r3
1001b674:	e0823003 	add	r3, r2, r3
1001b678:	e2833010 	add	r3, r3, #16
1001b67c:	e5933004 	ldr	r3, [r3, #4]
1001b680:	e5933018 	ldr	r3, [r3, #24]
1001b684:	e1a0100c 	mov	r1, ip
1001b688:	e1a02003 	mov	r2, r3
1001b68c:	ebfffb10 	bl	1001a2d4 <rt_vbus_set_post_wm>

            if (_chn0_ack(dsize, dp) >= 0)
1001b690:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
1001b694:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
1001b698:	ebfffe97 	bl	1001b0fc <_chn0_ack>
1001b69c:	e1a03000 	mov	r3, r0
1001b6a0:	e3530000 	cmp	r3, #0
1001b6a4:	ba00001d 	blt	1001b720 <_chn0_actor+0x4ec>
            {
                _sess[i].chnr = chnr;
1001b6a8:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b6ac:	e3412003 	movt	r2, #4099	; 0x1003
1001b6b0:	e51b3018 	ldr	r3, [fp, #-24]
1001b6b4:	e1a01003 	mov	r1, r3
1001b6b8:	e1a03181 	lsl	r3, r1, #3
1001b6bc:	e1a01003 	mov	r1, r3
1001b6c0:	e1a03101 	lsl	r3, r1, #2
1001b6c4:	e0613003 	rsb	r3, r1, r3
1001b6c8:	e0823003 	add	r3, r2, r3
1001b6cc:	e51b201c 	ldr	r2, [fp, #-28]
1001b6d0:	e5832000 	str	r2, [r3]
                _chn_status[chnr] = RT_VBUS_CHN_ST_ESTABLISHED;
1001b6d4:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001b6d8:	e3413003 	movt	r3, #4099	; 0x1003
1001b6dc:	e51b201c 	ldr	r2, [fp, #-28]
1001b6e0:	e0833002 	add	r3, r3, r2
1001b6e4:	e3a02003 	mov	r2, #3
1001b6e8:	e5c32000 	strb	r2, [r3]
                vbus_debug("chn %d %s\n", chnr,
                           rt_vbus_chn_st2str[_chn_status[chnr]]);
                rt_completion_done(&_sess[i].cmp);
1001b6ec:	e51b3018 	ldr	r3, [fp, #-24]
1001b6f0:	e1a02003 	mov	r2, r3
1001b6f4:	e1a03182 	lsl	r3, r2, #3
1001b6f8:	e1a02003 	mov	r2, r3
1001b6fc:	e1a03102 	lsl	r3, r2, #2
1001b700:	e0623003 	rsb	r3, r2, r3
1001b704:	e2832008 	add	r2, r3, #8
1001b708:	e30d3ef0 	movw	r3, #57072	; 0xdef0
1001b70c:	e3413003 	movt	r3, #4099	; 0x1003
1001b710:	e0823003 	add	r3, r2, r3
1001b714:	e1a00003 	mov	r0, r3
1001b718:	eb001428 	bl	100207c0 <rt_completion_done>
            }
        }
        break;
1001b71c:	ea000095 	b	1001b978 <_chn0_actor+0x744>
1001b720:	ea000094 	b	1001b978 <_chn0_actor+0x744>
    case RT_VBUS_CHN0_CMD_ACK:
        if (dp[1] == RT_VBUS_CHN0_CMD_SET)
1001b724:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b728:	e2833001 	add	r3, r3, #1
1001b72c:	e5d33000 	ldrb	r3, [r3]
1001b730:	e3530002 	cmp	r3, #2
1001b734:	1a000031 	bne	1001b800 <_chn0_actor+0x5cc>
        {
            int i, chnr;

            i = _sess_find(dp+2, SESSIOM_ESTABLISHING);
1001b738:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b73c:	e2833002 	add	r3, r3, #2
1001b740:	e1a00003 	mov	r0, r3
1001b744:	e3a01002 	mov	r1, #2
1001b748:	ebfffe78 	bl	1001b130 <_sess_find>
1001b74c:	e50b0020 	str	r0, [fp, #-32]
            if (i == ARRAY_SIZE(_sess))
1001b750:	e51b3020 	ldr	r3, [fp, #-32]
1001b754:	e3530010 	cmp	r3, #16
1001b758:	1a000000 	bne	1001b760 <_chn0_actor+0x52c>
                /* drop that spurious packet */
                break;
1001b75c:	ea000085 	b	1001b978 <_chn0_actor+0x744>

            chnr = dp[1+rt_strlen((const char*)dp+2)+2];
1001b760:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b764:	e2833002 	add	r3, r3, #2
1001b768:	e1a00003 	mov	r0, r3
1001b76c:	ebffdcae 	bl	10012a2c <rt_strlen>
1001b770:	e1a03000 	mov	r3, r0
1001b774:	e2833003 	add	r3, r3, #3
1001b778:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
1001b77c:	e0823003 	add	r3, r2, r3
1001b780:	e5d33000 	ldrb	r3, [r3]
1001b784:	e50b3024 	str	r3, [fp, #-36]	; 0x24

            _sess[i].chnr = chnr;
1001b788:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b78c:	e3412003 	movt	r2, #4099	; 0x1003
1001b790:	e51b3020 	ldr	r3, [fp, #-32]
1001b794:	e1a01003 	mov	r1, r3
1001b798:	e1a03181 	lsl	r3, r1, #3
1001b79c:	e1a01003 	mov	r1, r3
1001b7a0:	e1a03101 	lsl	r3, r1, #2
1001b7a4:	e0613003 	rsb	r3, r1, r3
1001b7a8:	e0823003 	add	r3, r2, r3
1001b7ac:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1001b7b0:	e5832000 	str	r2, [r3]
            _chn_status[chnr] = RT_VBUS_CHN_ST_ESTABLISHED;
1001b7b4:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001b7b8:	e3413003 	movt	r3, #4099	; 0x1003
1001b7bc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1001b7c0:	e0833002 	add	r3, r3, r2
1001b7c4:	e3a02003 	mov	r2, #3
1001b7c8:	e5c32000 	strb	r2, [r3]
            vbus_debug("chn %d %s\n", chnr,
                       rt_vbus_chn_st2str[_chn_status[chnr]]);
            rt_completion_done(&_sess[i].cmp);
1001b7cc:	e51b3020 	ldr	r3, [fp, #-32]
1001b7d0:	e1a02003 	mov	r2, r3
1001b7d4:	e1a03182 	lsl	r3, r2, #3
1001b7d8:	e1a02003 	mov	r2, r3
1001b7dc:	e1a03102 	lsl	r3, r2, #2
1001b7e0:	e0623003 	rsb	r3, r2, r3
1001b7e4:	e2832008 	add	r2, r3, #8
1001b7e8:	e30d3ef0 	movw	r3, #57072	; 0xdef0
1001b7ec:	e3413003 	movt	r3, #4099	; 0x1003
1001b7f0:	e0823003 	add	r3, r2, r3
1001b7f4:	e1a00003 	mov	r0, r3
1001b7f8:	eb0013f0 	bl	100207c0 <rt_completion_done>
1001b7fc:	ea00001a 	b	1001b86c <_chn0_actor+0x638>
        }
        else if (dp[1] == RT_VBUS_CHN0_CMD_DISABLE)
1001b800:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b804:	e2833001 	add	r3, r3, #1
1001b808:	e5d33000 	ldrb	r3, [r3]
1001b80c:	e3530001 	cmp	r3, #1
1001b810:	1a000015 	bne	1001b86c <_chn0_actor+0x638>
        {
            unsigned char chnr = dp[2];
1001b814:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b818:	e5d33002 	ldrb	r3, [r3, #2]
1001b81c:	e54b3025 	strb	r3, [fp, #-37]	; 0x25

            if (chnr == 0 || chnr >= RT_VBUS_CHANNEL_NR)
1001b820:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
1001b824:	e3530000 	cmp	r3, #0
1001b828:	0a000052 	beq	1001b978 <_chn0_actor+0x744>
1001b82c:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
1001b830:	e353001f 	cmp	r3, #31
1001b834:	8a00004f 	bhi	1001b978 <_chn0_actor+0x744>
                break;

            /* We could only get here by sending DISABLE command, which is
             * initiated by the rt_vbus_close_chn. */
            _chn_status[chnr] = RT_VBUS_CHN_ST_AVAILABLE;
1001b838:	e55b2025 	ldrb	r2, [fp, #-37]	; 0x25
1001b83c:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001b840:	e3413003 	movt	r3, #4099	; 0x1003
1001b844:	e3a01000 	mov	r1, #0
1001b848:	e7c31002 	strb	r1, [r3, r2]

            _vbus_indicate(RT_VBUS_EVENT_ID_DISCONN, chnr);
1001b84c:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
1001b850:	e3a00002 	mov	r0, #2
1001b854:	e1a01003 	mov	r1, r3
1001b858:	ebfffad9 	bl	1001a3c4 <_vbus_indicate>
            /* notify the thread that the channel has been closed */
            rt_vbus_notify_chn(chnr, -RT_ERROR);
1001b85c:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
1001b860:	e1a00003 	mov	r0, r3
1001b864:	e3e01000 	mvn	r1, #0
1001b868:	ebfffc9e 	bl	1001aae8 <rt_vbus_notify_chn>
        }
        else
        {
            vbus_info("invalid ACK for %d\n", dp[1]);
        }
        break;
1001b86c:	ea000041 	b	1001b978 <_chn0_actor+0x744>
    case RT_VBUS_CHN0_CMD_DISABLE:
        {
            unsigned char chnr = dp[1];
1001b870:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b874:	e5d33001 	ldrb	r3, [r3, #1]
1001b878:	e54b3026 	strb	r3, [fp, #-38]	; 0x26

            if (chnr == 0 || chnr >= RT_VBUS_CHANNEL_NR)
1001b87c:	e55b3026 	ldrb	r3, [fp, #-38]	; 0x26
1001b880:	e3530000 	cmp	r3, #0
1001b884:	0a00003b 	beq	1001b978 <_chn0_actor+0x744>
1001b888:	e55b3026 	ldrb	r3, [fp, #-38]	; 0x26
1001b88c:	e353001f 	cmp	r3, #31
1001b890:	8a000038 	bhi	1001b978 <_chn0_actor+0x744>
                break;

            _chn_status[chnr] = RT_VBUS_CHN_ST_CLOSING;
1001b894:	e55b2026 	ldrb	r2, [fp, #-38]	; 0x26
1001b898:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001b89c:	e3413003 	movt	r3, #4099	; 0x1003
1001b8a0:	e3a01005 	mov	r1, #5
1001b8a4:	e7c31002 	strb	r1, [r3, r2]

            _chn0_ack(dsize, dp);
1001b8a8:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
1001b8ac:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
1001b8b0:	ebfffe11 	bl	1001b0fc <_chn0_ack>

            _vbus_indicate(RT_VBUS_EVENT_ID_DISCONN, chnr);
1001b8b4:	e55b3026 	ldrb	r3, [fp, #-38]	; 0x26
1001b8b8:	e3a00002 	mov	r0, #2
1001b8bc:	e1a01003 	mov	r1, r3
1001b8c0:	ebfffabf 	bl	1001a3c4 <_vbus_indicate>
            /* notify the thread that the channel has been closed */
            rt_vbus_notify_chn(chnr, -RT_ERROR);
1001b8c4:	e55b3026 	ldrb	r3, [fp, #-38]	; 0x26
1001b8c8:	e1a00003 	mov	r0, r3
1001b8cc:	e3e01000 	mvn	r1, #0
1001b8d0:	ebfffc84 	bl	1001aae8 <rt_vbus_notify_chn>
        }
        break;
1001b8d4:	ea000027 	b	1001b978 <_chn0_actor+0x744>
            rt_exit_critical();
        }
#endif
        break;
    case RT_VBUS_CHN0_CMD_NAK:
        if (dp[1] == RT_VBUS_CHN0_CMD_ENABLE)
1001b8d8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b8dc:	e2833001 	add	r3, r3, #1
1001b8e0:	e5d33000 	ldrb	r3, [r3]
1001b8e4:	e3530000 	cmp	r3, #0
1001b8e8:	1a000020 	bne	1001b970 <_chn0_actor+0x73c>
        {
            int i;

            i = _sess_find(dp+2, SESSIOM_ESTABLISHING);
1001b8ec:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001b8f0:	e2833002 	add	r3, r3, #2
1001b8f4:	e1a00003 	mov	r0, r3
1001b8f8:	e3a01002 	mov	r1, #2
1001b8fc:	ebfffe0b 	bl	1001b130 <_sess_find>
1001b900:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
            if (i == ARRAY_SIZE(_sess))
1001b904:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1001b908:	e3530010 	cmp	r3, #16
1001b90c:	1a000000 	bne	1001b914 <_chn0_actor+0x6e0>
                /* drop that spurious packet */
                break;
1001b910:	ea000018 	b	1001b978 <_chn0_actor+0x744>

            _sess[i].chnr = -RT_EIO;
1001b914:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b918:	e3412003 	movt	r2, #4099	; 0x1003
1001b91c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1001b920:	e1a01003 	mov	r1, r3
1001b924:	e1a03181 	lsl	r3, r1, #3
1001b928:	e1a01003 	mov	r1, r3
1001b92c:	e1a03101 	lsl	r3, r1, #2
1001b930:	e0613003 	rsb	r3, r1, r3
1001b934:	e0823003 	add	r3, r2, r3
1001b938:	e3e02007 	mvn	r2, #7
1001b93c:	e5832000 	str	r2, [r3]
            rt_completion_done(&_sess[i].cmp);
1001b940:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1001b944:	e1a02003 	mov	r2, r3
1001b948:	e1a03182 	lsl	r3, r2, #3
1001b94c:	e1a02003 	mov	r2, r3
1001b950:	e1a03102 	lsl	r3, r2, #2
1001b954:	e0623003 	rsb	r3, r2, r3
1001b958:	e2832008 	add	r2, r3, #8
1001b95c:	e30d3ef0 	movw	r3, #57072	; 0xdef0
1001b960:	e3413003 	movt	r3, #4099	; 0x1003
1001b964:	e0823003 	add	r3, r2, r3
1001b968:	e1a00003 	mov	r0, r3
1001b96c:	eb001393 	bl	100207c0 <rt_completion_done>
        }
        else
        {
            vbus_info("invalid NAK for %d\n", dp[1]);
        }
        break;
1001b970:	ea000000 	b	1001b978 <_chn0_actor+0x744>
    default:
        /* just ignore the invalid cmd */
        vbus_info("drop unknown cmd %d on chn0\n", *dp);
        break;
1001b974:	e1a00000 	nop			; (mov r0, r0)
    };

    return RT_EOK;
1001b978:	e3a03000 	mov	r3, #0
}
1001b97c:	e1a00003 	mov	r0, r3
1001b980:	e24bd004 	sub	sp, fp, #4
1001b984:	e8bd8800 	pop	{fp, pc}

1001b988 <rt_vbus_request_chn>:

int rt_vbus_request_chn(struct rt_vbus_request *req,
                        int timeout)
{
1001b988:	e92d4800 	push	{fp, lr}
1001b98c:	e28db004 	add	fp, sp, #4
1001b990:	e24dd020 	sub	sp, sp, #32
1001b994:	e50b0020 	str	r0, [fp, #-32]
1001b998:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    int i, chnr, err;
	size_t plen = rt_strlen(req->name) + 2;
1001b99c:	e51b3020 	ldr	r3, [fp, #-32]
1001b9a0:	e5933004 	ldr	r3, [r3, #4]
1001b9a4:	e1a00003 	mov	r0, r3
1001b9a8:	ebffdc1f 	bl	10012a2c <rt_strlen>
1001b9ac:	e1a03000 	mov	r3, r0
1001b9b0:	e2833002 	add	r3, r3, #2
1001b9b4:	e50b3014 	str	r3, [fp, #-20]
	unsigned char *pbuf;
    rt_ubase_t lvl;

    lvl = rt_hw_interrupt_disable();
1001b9b8:	ebfff71c 	bl	10019630 <rt_hw_interrupt_disable>
1001b9bc:	e1a03000 	mov	r3, r0
1001b9c0:	e50b3018 	str	r3, [fp, #-24]
    for (i = 0; i < ARRAY_SIZE(_sess); i++)
1001b9c4:	e3a03000 	mov	r3, #0
1001b9c8:	e50b3008 	str	r3, [fp, #-8]
1001b9cc:	ea00000f 	b	1001ba10 <rt_vbus_request_chn+0x88>
    {
        if (_sess[i].st == SESSIOM_AVAILABLE)
1001b9d0:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001b9d4:	e3412003 	movt	r2, #4099	; 0x1003
1001b9d8:	e51b3008 	ldr	r3, [fp, #-8]
1001b9dc:	e1a01003 	mov	r1, r3
1001b9e0:	e1a03181 	lsl	r3, r1, #3
1001b9e4:	e1a01003 	mov	r1, r3
1001b9e8:	e1a03101 	lsl	r3, r1, #2
1001b9ec:	e0613003 	rsb	r3, r1, r3
1001b9f0:	e0823003 	add	r3, r2, r3
1001b9f4:	e5d33004 	ldrb	r3, [r3, #4]
1001b9f8:	e3530000 	cmp	r3, #0
1001b9fc:	1a000000 	bne	1001ba04 <rt_vbus_request_chn+0x7c>
            break;
1001ba00:	ea000005 	b	1001ba1c <rt_vbus_request_chn+0x94>
	size_t plen = rt_strlen(req->name) + 2;
	unsigned char *pbuf;
    rt_ubase_t lvl;

    lvl = rt_hw_interrupt_disable();
    for (i = 0; i < ARRAY_SIZE(_sess); i++)
1001ba04:	e51b3008 	ldr	r3, [fp, #-8]
1001ba08:	e2833001 	add	r3, r3, #1
1001ba0c:	e50b3008 	str	r3, [fp, #-8]
1001ba10:	e51b3008 	ldr	r3, [fp, #-8]
1001ba14:	e353000f 	cmp	r3, #15
1001ba18:	9affffec 	bls	1001b9d0 <rt_vbus_request_chn+0x48>
    {
        if (_sess[i].st == SESSIOM_AVAILABLE)
            break;
    }
    if (i == ARRAY_SIZE(_sess))
1001ba1c:	e51b3008 	ldr	r3, [fp, #-8]
1001ba20:	e3530010 	cmp	r3, #16
1001ba24:	1a000004 	bne	1001ba3c <rt_vbus_request_chn+0xb4>
    {
        rt_hw_interrupt_enable(lvl);
1001ba28:	e51b3018 	ldr	r3, [fp, #-24]
1001ba2c:	e1a00003 	mov	r0, r3
1001ba30:	ebfff702 	bl	10019640 <rt_hw_interrupt_enable>
        return -RT_ERROR;
1001ba34:	e3e03000 	mvn	r3, #0
1001ba38:	ea0000bf 	b	1001bd3c <rt_vbus_request_chn+0x3b4>
    }
/*find the available sess*/
    rt_completion_init(&_sess[i].cmp);
1001ba3c:	e51b3008 	ldr	r3, [fp, #-8]
1001ba40:	e1a02003 	mov	r2, r3
1001ba44:	e1a03182 	lsl	r3, r2, #3
1001ba48:	e1a02003 	mov	r2, r3
1001ba4c:	e1a03102 	lsl	r3, r2, #2
1001ba50:	e0623003 	rsb	r3, r2, r3
1001ba54:	e2832008 	add	r2, r3, #8
1001ba58:	e30d3ef0 	movw	r3, #57072	; 0xdef0
1001ba5c:	e3413003 	movt	r3, #4099	; 0x1003
1001ba60:	e0823003 	add	r3, r2, r3
1001ba64:	e1a00003 	mov	r0, r3
1001ba68:	eb0012d1 	bl	100205b4 <rt_completion_init>
    _sess[i].req = req;
1001ba6c:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001ba70:	e3412003 	movt	r2, #4099	; 0x1003
1001ba74:	e51b3008 	ldr	r3, [fp, #-8]
1001ba78:	e1a01003 	mov	r1, r3
1001ba7c:	e1a03181 	lsl	r3, r1, #3
1001ba80:	e1a01003 	mov	r1, r3
1001ba84:	e1a03101 	lsl	r3, r1, #2
1001ba88:	e0613003 	rsb	r3, r1, r3
1001ba8c:	e0823003 	add	r3, r2, r3
1001ba90:	e2833010 	add	r3, r3, #16
1001ba94:	e51b2020 	ldr	r2, [fp, #-32]
1001ba98:	e5832004 	str	r2, [r3, #4]

    if (req->is_server)
1001ba9c:	e51b3020 	ldr	r3, [fp, #-32]
1001baa0:	e5933008 	ldr	r3, [r3, #8]
1001baa4:	e3530000 	cmp	r3, #0
1001baa8:	0a000010 	beq	1001baf0 <rt_vbus_request_chn+0x168>
    {
        _sess[i].st = SESSIOM_LISTENING;
1001baac:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001bab0:	e3412003 	movt	r2, #4099	; 0x1003
1001bab4:	e51b3008 	ldr	r3, [fp, #-8]
1001bab8:	e1a01003 	mov	r1, r3
1001babc:	e1a03181 	lsl	r3, r1, #3
1001bac0:	e1a01003 	mov	r1, r3
1001bac4:	e1a03101 	lsl	r3, r1, #2
1001bac8:	e0613003 	rsb	r3, r1, r3
1001bacc:	e0823003 	add	r3, r2, r3
1001bad0:	e3a02001 	mov	r2, #1
1001bad4:	e5c32004 	strb	r2, [r3, #4]
        rt_hw_interrupt_enable(lvl);
1001bad8:	e51b3018 	ldr	r3, [fp, #-24]
1001badc:	e1a00003 	mov	r0, r3
1001bae0:	ebfff6d6 	bl	10019640 <rt_hw_interrupt_enable>

        vbus_debug("request listening %s on %d\n", req->name, i);

        /* always wait on the condition */
        err = RT_EOK;
1001bae4:	e3a03000 	mov	r3, #0
1001bae8:	e50b3010 	str	r3, [fp, #-16]
        goto _waitforcmp;
1001baec:	ea00002c 	b	1001bba4 <rt_vbus_request_chn+0x21c>
    }

	pbuf = rt_malloc(plen);
1001baf0:	e51b0014 	ldr	r0, [fp, #-20]
1001baf4:	ebffe1e6 	bl	10014294 <rt_malloc>
1001baf8:	e50b001c 	str	r0, [fp, #-28]
	if (!pbuf)
1001bafc:	e51b301c 	ldr	r3, [fp, #-28]
1001bb00:	e3530000 	cmp	r3, #0
1001bb04:	1a000004 	bne	1001bb1c <rt_vbus_request_chn+0x194>
    {
        rt_hw_interrupt_enable(lvl);
1001bb08:	e51b3018 	ldr	r3, [fp, #-24]
1001bb0c:	e1a00003 	mov	r0, r3
1001bb10:	ebfff6ca 	bl	10019640 <rt_hw_interrupt_enable>
        return -RT_ENOMEM;
1001bb14:	e3e03004 	mvn	r3, #4
1001bb18:	ea000087 	b	1001bd3c <rt_vbus_request_chn+0x3b4>
    }

    _sess[i].st = SESSIOM_ESTABLISHING;
1001bb1c:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001bb20:	e3412003 	movt	r2, #4099	; 0x1003
1001bb24:	e51b3008 	ldr	r3, [fp, #-8]
1001bb28:	e1a01003 	mov	r1, r3
1001bb2c:	e1a03181 	lsl	r3, r1, #3
1001bb30:	e1a01003 	mov	r1, r3
1001bb34:	e1a03101 	lsl	r3, r1, #2
1001bb38:	e0613003 	rsb	r3, r1, r3
1001bb3c:	e0823003 	add	r3, r2, r3
1001bb40:	e3a02002 	mov	r2, #2
1001bb44:	e5c32004 	strb	r2, [r3, #4]
    rt_hw_interrupt_enable(lvl);
1001bb48:	e51b3018 	ldr	r3, [fp, #-24]
1001bb4c:	e1a00003 	mov	r0, r3
1001bb50:	ebfff6ba 	bl	10019640 <rt_hw_interrupt_enable>

    pbuf[0] = RT_VBUS_CHN0_CMD_ENABLE;
1001bb54:	e51b301c 	ldr	r3, [fp, #-28]
1001bb58:	e3a02000 	mov	r2, #0
1001bb5c:	e5c32000 	strb	r2, [r3]
    rt_memcpy(pbuf+1, req->name, plen-1);
1001bb60:	e51b301c 	ldr	r3, [fp, #-28]
1001bb64:	e2831001 	add	r1, r3, #1
1001bb68:	e51b3020 	ldr	r3, [fp, #-32]
1001bb6c:	e5932004 	ldr	r2, [r3, #4]
1001bb70:	e51b3014 	ldr	r3, [fp, #-20]
1001bb74:	e2433001 	sub	r3, r3, #1
1001bb78:	e1a00001 	mov	r0, r1
1001bb7c:	e1a01002 	mov	r1, r2
1001bb80:	e1a02003 	mov	r2, r3
1001bb84:	ebffda0b 	bl	100123b8 <rt_memcpy>
    vbus_verbose("%s --> remote\n", dump_cmd_pkt(pbuf, plen));

	err = _chn0_post(pbuf, plen, RT_WAITING_FOREVER);
1001bb88:	e51b001c 	ldr	r0, [fp, #-28]
1001bb8c:	e51b1014 	ldr	r1, [fp, #-20]
1001bb90:	e3e02000 	mvn	r2, #0
1001bb94:	ebfffbb5 	bl	1001aa70 <_chn0_post>
1001bb98:	e50b0010 	str	r0, [fp, #-16]
    rt_free(pbuf);
1001bb9c:	e51b001c 	ldr	r0, [fp, #-28]
1001bba0:	ebffe3d6 	bl	10014b00 <rt_free>

_waitforcmp:
    if (err == RT_EOK)
1001bba4:	e51b3010 	ldr	r3, [fp, #-16]
1001bba8:	e3530000 	cmp	r3, #0
1001bbac:	1a00000d 	bne	1001bbe8 <rt_vbus_request_chn+0x260>
        err = rt_completion_wait(&_sess[i].cmp, timeout);
1001bbb0:	e51b3008 	ldr	r3, [fp, #-8]
1001bbb4:	e1a02003 	mov	r2, r3
1001bbb8:	e1a03182 	lsl	r3, r2, #3
1001bbbc:	e1a02003 	mov	r2, r3
1001bbc0:	e1a03102 	lsl	r3, r2, #2
1001bbc4:	e0623003 	rsb	r3, r2, r3
1001bbc8:	e2832008 	add	r2, r3, #8
1001bbcc:	e30d3ef0 	movw	r3, #57072	; 0xdef0
1001bbd0:	e3413003 	movt	r3, #4099	; 0x1003
1001bbd4:	e0823003 	add	r3, r2, r3
1001bbd8:	e1a00003 	mov	r0, r3
1001bbdc:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
1001bbe0:	eb00128d 	bl	1002061c <rt_completion_wait>
1001bbe4:	e50b0010 	str	r0, [fp, #-16]

    vbus_debug("request wait cmp done %d, chnr %d\n", err, _sess[i].chnr);

    if (err)
1001bbe8:	e51b3010 	ldr	r3, [fp, #-16]
1001bbec:	e3530000 	cmp	r3, #0
1001bbf0:	0a00001c 	beq	1001bc68 <rt_vbus_request_chn+0x2e0>
    {
        /* cleanup the mass when the wait is time out but we have done some job
         */
        if (_sess[i].st == SESSIOM_ESTABLISHING)
1001bbf4:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001bbf8:	e3412003 	movt	r2, #4099	; 0x1003
1001bbfc:	e51b3008 	ldr	r3, [fp, #-8]
1001bc00:	e1a01003 	mov	r1, r3
1001bc04:	e1a03181 	lsl	r3, r1, #3
1001bc08:	e1a01003 	mov	r1, r3
1001bc0c:	e1a03101 	lsl	r3, r1, #2
1001bc10:	e0613003 	rsb	r3, r1, r3
1001bc14:	e0823003 	add	r3, r2, r3
1001bc18:	e5d33004 	ldrb	r3, [r3, #4]
1001bc1c:	e3530002 	cmp	r3, #2
1001bc20:	1a00000d 	bne	1001bc5c <rt_vbus_request_chn+0x2d4>
            _chn_status[_sess[i].chnr] = RT_VBUS_CHN_ST_AVAILABLE;
1001bc24:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001bc28:	e3412003 	movt	r2, #4099	; 0x1003
1001bc2c:	e51b3008 	ldr	r3, [fp, #-8]
1001bc30:	e1a01003 	mov	r1, r3
1001bc34:	e1a03181 	lsl	r3, r1, #3
1001bc38:	e1a01003 	mov	r1, r3
1001bc3c:	e1a03101 	lsl	r3, r1, #2
1001bc40:	e0613003 	rsb	r3, r1, r3
1001bc44:	e0823003 	add	r3, r2, r3
1001bc48:	e5932000 	ldr	r2, [r3]
1001bc4c:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001bc50:	e3413003 	movt	r3, #4099	; 0x1003
1001bc54:	e3a01000 	mov	r1, #0
1001bc58:	e7c31002 	strb	r1, [r3, r2]
        chnr = err;
1001bc5c:	e51b3010 	ldr	r3, [fp, #-16]
1001bc60:	e50b300c 	str	r3, [fp, #-12]
        goto Out;
1001bc64:	ea00001c 	b	1001bcdc <rt_vbus_request_chn+0x354>
    }

    RT_ASSERT(_sess[i].chnr != 0);
1001bc68:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001bc6c:	e3412003 	movt	r2, #4099	; 0x1003
1001bc70:	e51b3008 	ldr	r3, [fp, #-8]
1001bc74:	e1a01003 	mov	r1, r3
1001bc78:	e1a03181 	lsl	r3, r1, #3
1001bc7c:	e1a01003 	mov	r1, r3
1001bc80:	e1a03101 	lsl	r3, r1, #2
1001bc84:	e0613003 	rsb	r3, r1, r3
1001bc88:	e0823003 	add	r3, r2, r3
1001bc8c:	e5933000 	ldr	r3, [r3]
1001bc90:	e3530000 	cmp	r3, #0
1001bc94:	1a000005 	bne	1001bcb0 <rt_vbus_request_chn+0x328>
1001bc98:	e30406e4 	movw	r0, #18148	; 0x46e4
1001bc9c:	e3410003 	movt	r0, #4099	; 0x1003
1001bca0:	e304190c 	movw	r1, #18700	; 0x490c
1001bca4:	e3411003 	movt	r1, #4099	; 0x1003
1001bca8:	e30023f5 	movw	r2, #1013	; 0x3f5
1001bcac:	ebffe040 	bl	10013db4 <rt_assert_handler>

    chnr = _sess[i].chnr;
1001bcb0:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001bcb4:	e3412003 	movt	r2, #4099	; 0x1003
1001bcb8:	e51b3008 	ldr	r3, [fp, #-8]
1001bcbc:	e1a01003 	mov	r1, r3
1001bcc0:	e1a03181 	lsl	r3, r1, #3
1001bcc4:	e1a01003 	mov	r1, r3
1001bcc8:	e1a03101 	lsl	r3, r1, #2
1001bccc:	e0613003 	rsb	r3, r1, r3
1001bcd0:	e0823003 	add	r3, r2, r3
1001bcd4:	e5933000 	ldr	r3, [r3]
1001bcd8:	e50b300c 	str	r3, [fp, #-12]

Out:
    /* detach the sess as we finished the job */
    _sess[i].st = SESSIOM_AVAILABLE;
1001bcdc:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001bce0:	e3412003 	movt	r2, #4099	; 0x1003
1001bce4:	e51b3008 	ldr	r3, [fp, #-8]
1001bce8:	e1a01003 	mov	r1, r3
1001bcec:	e1a03181 	lsl	r3, r1, #3
1001bcf0:	e1a01003 	mov	r1, r3
1001bcf4:	e1a03101 	lsl	r3, r1, #2
1001bcf8:	e0613003 	rsb	r3, r1, r3
1001bcfc:	e0823003 	add	r3, r2, r3
1001bd00:	e3a02000 	mov	r2, #0
1001bd04:	e5c32004 	strb	r2, [r3, #4]
    _sess[i].req = RT_NULL;
1001bd08:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001bd0c:	e3412003 	movt	r2, #4099	; 0x1003
1001bd10:	e51b3008 	ldr	r3, [fp, #-8]
1001bd14:	e1a01003 	mov	r1, r3
1001bd18:	e1a03181 	lsl	r3, r1, #3
1001bd1c:	e1a01003 	mov	r1, r3
1001bd20:	e1a03101 	lsl	r3, r1, #2
1001bd24:	e0613003 	rsb	r3, r1, r3
1001bd28:	e0823003 	add	r3, r2, r3
1001bd2c:	e2833010 	add	r3, r3, #16
1001bd30:	e3a02000 	mov	r2, #0
1001bd34:	e5832004 	str	r2, [r3, #4]

    return chnr;
1001bd38:	e51b300c 	ldr	r3, [fp, #-12]
}
1001bd3c:	e1a00003 	mov	r0, r3
1001bd40:	e24bd004 	sub	sp, fp, #4
1001bd44:	e8bd8800 	pop	{fp, pc}

1001bd48 <rt_vbus_close_chn>:

void rt_vbus_close_chn(unsigned char chnr)
{
1001bd48:	e92d4800 	push	{fp, lr}
1001bd4c:	e28db004 	add	fp, sp, #4
1001bd50:	e24dd018 	sub	sp, sp, #24
1001bd54:	e1a03000 	mov	r3, r0
1001bd58:	e54b3015 	strb	r3, [fp, #-21]
    void *p;
    rt_err_t err;
    unsigned char buf[2];

    buf[0] = RT_VBUS_CHN0_CMD_DISABLE;
1001bd5c:	e3a03001 	mov	r3, #1
1001bd60:	e54b3010 	strb	r3, [fp, #-16]
    buf[1] = chnr;
1001bd64:	e55b3015 	ldrb	r3, [fp, #-21]
1001bd68:	e54b300f 	strb	r3, [fp, #-15]

    RT_ASSERT(0 < chnr && chnr < RT_VBUS_CHANNEL_NR);
1001bd6c:	e55b3015 	ldrb	r3, [fp, #-21]
1001bd70:	e3530000 	cmp	r3, #0
1001bd74:	0a000002 	beq	1001bd84 <rt_vbus_close_chn+0x3c>
1001bd78:	e55b3015 	ldrb	r3, [fp, #-21]
1001bd7c:	e353001f 	cmp	r3, #31
1001bd80:	9a000005 	bls	1001bd9c <rt_vbus_close_chn+0x54>
1001bd84:	e30406f8 	movw	r0, #18168	; 0x46f8
1001bd88:	e3410003 	movt	r0, #4099	; 0x1003
1001bd8c:	e3041920 	movw	r1, #18720	; 0x4920
1001bd90:	e3411003 	movt	r1, #4099	; 0x1003
1001bd94:	e300240a 	movw	r2, #1034	; 0x40a
1001bd98:	ebffe005 	bl	10013db4 <rt_assert_handler>

    if (_chn_status[chnr] == RT_VBUS_CHN_ST_CLOSED ||
1001bd9c:	e55b2015 	ldrb	r2, [fp, #-21]
1001bda0:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001bda4:	e3413003 	movt	r3, #4099	; 0x1003
1001bda8:	e7d33002 	ldrb	r3, [r3, r2]
1001bdac:	e3530001 	cmp	r3, #1
1001bdb0:	0a000005 	beq	1001bdcc <rt_vbus_close_chn+0x84>
        _chn_status[chnr] == RT_VBUS_CHN_ST_CLOSING)
1001bdb4:	e55b2015 	ldrb	r2, [fp, #-21]
1001bdb8:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001bdbc:	e3413003 	movt	r3, #4099	; 0x1003
1001bdc0:	e7d33002 	ldrb	r3, [r3, r2]
    buf[0] = RT_VBUS_CHN0_CMD_DISABLE;
    buf[1] = chnr;

    RT_ASSERT(0 < chnr && chnr < RT_VBUS_CHANNEL_NR);

    if (_chn_status[chnr] == RT_VBUS_CHN_ST_CLOSED ||
1001bdc4:	e3530005 	cmp	r3, #5
1001bdc8:	1a000005 	bne	1001bde4 <rt_vbus_close_chn+0x9c>
        _chn_status[chnr] == RT_VBUS_CHN_ST_CLOSING)
    {
        _chn_status[chnr] = RT_VBUS_CHN_ST_AVAILABLE;
1001bdcc:	e55b2015 	ldrb	r2, [fp, #-21]
1001bdd0:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001bdd4:	e3413003 	movt	r3, #4099	; 0x1003
1001bdd8:	e3a01000 	mov	r1, #0
1001bddc:	e7c31002 	strb	r1, [r3, r2]
        return;
1001bde0:	ea000026 	b	1001be80 <rt_vbus_close_chn+0x138>
    }

    if (!_chn_connected(chnr))
1001bde4:	e55b3015 	ldrb	r3, [fp, #-21]
1001bde8:	e1a00003 	mov	r0, r3
1001bdec:	ebfff916 	bl	1001a24c <_chn_connected>
1001bdf0:	e1a03000 	mov	r3, r0
1001bdf4:	e3530000 	cmp	r3, #0
1001bdf8:	1a000000 	bne	1001be00 <rt_vbus_close_chn+0xb8>
        return;
1001bdfc:	ea00001f 	b	1001be80 <rt_vbus_close_chn+0x138>

    _chn_status[chnr] = RT_VBUS_CHN_ST_CLOSING;
1001be00:	e55b2015 	ldrb	r2, [fp, #-21]
1001be04:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001be08:	e3413003 	movt	r3, #4099	; 0x1003
1001be0c:	e3a01005 	mov	r1, #5
1001be10:	e7c31002 	strb	r1, [r3, r2]
    vbus_info("%s --> remote\n", dump_cmd_pkt(buf, sizeof(buf)));
    err = _chn0_post(&buf, sizeof(buf), RT_WAITING_FOREVER);
1001be14:	e24b3010 	sub	r3, fp, #16
1001be18:	e1a00003 	mov	r0, r3
1001be1c:	e3a01002 	mov	r1, #2
1001be20:	e3e02000 	mvn	r2, #0
1001be24:	ebfffb11 	bl	1001aa70 <_chn0_post>
1001be28:	e50b000c 	str	r0, [fp, #-12]
    if (err == RT_EOK)
1001be2c:	e51b300c 	ldr	r3, [fp, #-12]
1001be30:	e3530000 	cmp	r3, #0
1001be34:	1a000003 	bne	1001be48 <rt_vbus_close_chn+0x100>
        /* wait for the ack */
        rt_vbus_listen_on(chnr, 10 * RT_TICK_PER_SECOND);   /**/
1001be38:	e55b3015 	ldrb	r3, [fp, #-21]
1001be3c:	e1a00003 	mov	r0, r3
1001be40:	e3021710 	movw	r1, #10000	; 0x2710
1001be44:	ebfffb40 	bl	1001ab4c <rt_vbus_listen_on>

    /* cleanup the remaining data */
    for (p = rt_vbus_data_pop(chnr); p; p = rt_vbus_data_pop(chnr))
1001be48:	e55b3015 	ldrb	r3, [fp, #-21]
1001be4c:	e1a00003 	mov	r0, r3
1001be50:	ebfffb9c 	bl	1001acc8 <rt_vbus_data_pop>
1001be54:	e50b0008 	str	r0, [fp, #-8]
1001be58:	ea000005 	b	1001be74 <rt_vbus_close_chn+0x12c>
        rt_free(p);
1001be5c:	e51b0008 	ldr	r0, [fp, #-8]
1001be60:	ebffe326 	bl	10014b00 <rt_free>
    if (err == RT_EOK)
        /* wait for the ack */
        rt_vbus_listen_on(chnr, 10 * RT_TICK_PER_SECOND);   /**/

    /* cleanup the remaining data */
    for (p = rt_vbus_data_pop(chnr); p; p = rt_vbus_data_pop(chnr))
1001be64:	e55b3015 	ldrb	r3, [fp, #-21]
1001be68:	e1a00003 	mov	r0, r3
1001be6c:	ebfffb95 	bl	1001acc8 <rt_vbus_data_pop>
1001be70:	e50b0008 	str	r0, [fp, #-8]
1001be74:	e51b3008 	ldr	r3, [fp, #-8]
1001be78:	e3530000 	cmp	r3, #0
1001be7c:	1afffff6 	bne	1001be5c <rt_vbus_close_chn+0x114>
        rt_free(p);
    /* FIXME: there is a chance that there are some data left on the send
     * buffer. So if we connect other channel with the same number immediately,
     * the new channel will receive some garbage data. However, this is highly
     * un-probable. */
}
1001be80:	e24bd004 	sub	sp, fp, #4
1001be84:	e8bd8800 	pop	{fp, pc}

1001be88 <_bus_in_entry>:
#ifdef RT_VBUS_STATISTICS
static unsigned int _total_data_sz;
#endif

static void _bus_in_entry(void *param)
{
1001be88:	e92d4800 	push	{fp, lr}
1001be8c:	e28db004 	add	fp, sp, #4
1001be90:	e24dd020 	sub	sp, sp, #32
1001be94:	e50b0020 	str	r0, [fp, #-32]
    rt_sem_init(&_bus_in_sem, "vbus", 0, RT_IPC_FLAG_FIFO);
1001be98:	e30d0d78 	movw	r0, #56696	; 0xdd78
1001be9c:	e3410003 	movt	r0, #4099	; 0x1003
1001bea0:	e30415c4 	movw	r1, #17860	; 0x45c4
1001bea4:	e3411003 	movt	r1, #4099	; 0x1003
1001bea8:	e3a02000 	mov	r2, #0
1001beac:	e3a03000 	mov	r3, #0
1001beb0:	ebffccd6 	bl	1000f210 <rt_sem_init>
    rt_event_init(&_bus_in_event, "vbus", RT_IPC_FLAG_FIFO);
1001beb4:	e30d0d94 	movw	r0, #56724	; 0xdd94
1001beb8:	e3410003 	movt	r0, #4099	; 0x1003
1001bebc:	e30415c4 	movw	r1, #17860	; 0x45c4
1001bec0:	e3411003 	movt	r1, #4099	; 0x1003
1001bec4:	e3a02000 	mov	r2, #0
1001bec8:	ebffd050 	bl	10010010 <rt_event_init>
    rt_memset(_bus_in_action, 0, sizeof(_bus_in_action));
1001becc:	e30d0db0 	movw	r0, #56752	; 0xddb0
1001bed0:	e3410003 	movt	r0, #4099	; 0x1003
1001bed4:	e3a01000 	mov	r1, #0
1001bed8:	e3a02c01 	mov	r2, #256	; 0x100
1001bedc:	ebffd8dd 	bl	10012258 <rt_memset>

    while (rt_sem_take(&_bus_in_sem,
1001bee0:	ea0000e3 	b	1001c274 <_bus_in_entry+0x3ec>
                       RT_WAITING_FOREVER) == RT_EOK)
    {
        rt_uint32_t event_set = 0;
1001bee4:	e3a03000 	mov	r3, #0
1001bee8:	e50b3008 	str	r3, [fp, #-8]

        /* while(not empty) */
        while (RT_VBUS_IN_RING->get_idx != RT_VBUS_IN_RING->put_idx)
1001beec:	ea0000d1 	b	1001c238 <_bus_in_entry+0x3b0>
        {
            unsigned int id, nxtidx;
            rt_size_t size;
            struct rt_vbus_data *act;

            rt_vbus_smp_rmb();
1001bef0:	ebfff89d 	bl	1001a16c <rt_vbus_smp_rmb>
            size = RT_VBUS_IN_RING->blks[RT_VBUS_IN_RING->get_idx].len;
1001bef4:	e3033240 	movw	r3, #12864	; 0x3240
1001bef8:	e3413004 	movt	r3, #4100	; 0x1004
1001befc:	e5932000 	ldr	r2, [r3]
1001bf00:	e3033240 	movw	r3, #12864	; 0x3240
1001bf04:	e3413004 	movt	r3, #4100	; 0x1004
1001bf08:	e5933000 	ldr	r3, [r3]
1001bf0c:	e5933004 	ldr	r3, [r3, #4]
1001bf10:	e1a03303 	lsl	r3, r3, #6
1001bf14:	e0823003 	add	r3, r2, r3
1001bf18:	e5d3300e 	ldrb	r3, [r3, #14]
1001bf1c:	e50b3010 	str	r3, [fp, #-16]
            id = RT_VBUS_IN_RING->blks[RT_VBUS_IN_RING->get_idx].id;
1001bf20:	e3033240 	movw	r3, #12864	; 0x3240
1001bf24:	e3413004 	movt	r3, #4100	; 0x1004
1001bf28:	e5932000 	ldr	r2, [r3]
1001bf2c:	e3033240 	movw	r3, #12864	; 0x3240
1001bf30:	e3413004 	movt	r3, #4100	; 0x1004
1001bf34:	e5933000 	ldr	r3, [r3]
1001bf38:	e5933004 	ldr	r3, [r3, #4]
1001bf3c:	e1a03303 	lsl	r3, r3, #6
1001bf40:	e0823003 	add	r3, r2, r3
1001bf44:	e5d3300c 	ldrb	r3, [r3, #12]
1001bf48:	e50b3014 	str	r3, [fp, #-20]

            vbus_debug("vmm bus in: chnr %d, size %d\n", id, size);

            /* Suspended channel can still recv data. */
            if (id > RT_VBUS_CHANNEL_NR || !_chn_connected(id))
1001bf4c:	e51b3014 	ldr	r3, [fp, #-20]
1001bf50:	e3530020 	cmp	r3, #32
1001bf54:	8a000006 	bhi	1001bf74 <_bus_in_entry+0xec>
1001bf58:	e51b3014 	ldr	r3, [fp, #-20]
1001bf5c:	e6ef3073 	uxtb	r3, r3
1001bf60:	e1a00003 	mov	r0, r3
1001bf64:	ebfff8b8 	bl	1001a24c <_chn_connected>
1001bf68:	e1a03000 	mov	r3, r0
1001bf6c:	e3530000 	cmp	r3, #0
1001bf70:	1a000009 	bne	1001bf9c <_bus_in_entry+0x114>
            {
                vbus_error("drop on invalid chn %d\n", id);
                /* drop the invalid packet */
                _ring_add_get_bnr(RT_VBUS_IN_RING, LEN2BNR(size));
1001bf74:	e3033240 	movw	r3, #12864	; 0x3240
1001bf78:	e3413004 	movt	r3, #4100	; 0x1004
1001bf7c:	e5932000 	ldr	r2, [r3]
1001bf80:	e51b3010 	ldr	r3, [fp, #-16]
1001bf84:	e2833043 	add	r3, r3, #67	; 0x43
1001bf88:	e1a03323 	lsr	r3, r3, #6
1001bf8c:	e1a00002 	mov	r0, r2
1001bf90:	e1a01003 	mov	r1, r3
1001bf94:	ebfff880 	bl	1001a19c <_ring_add_get_bnr>
                continue;
1001bf98:	ea0000a6 	b	1001c238 <_bus_in_entry+0x3b0>
            }

            if (id == 0)/*  channel 0 used for command configuration*/
1001bf9c:	e51b3014 	ldr	r3, [fp, #-20]
1001bfa0:	e3530000 	cmp	r3, #0
1001bfa4:	1a00001a 	bne	1001c014 <_bus_in_entry+0x18c>
            {
                if (size > 60)
1001bfa8:	e51b3010 	ldr	r3, [fp, #-16]
1001bfac:	e353003c 	cmp	r3, #60	; 0x3c
1001bfb0:	8a00000d 	bhi	1001bfec <_bus_in_entry+0x164>
                    vbus_error("too big(%d) packet on chn0\n", size);
                else
                    _chn0_actor(RT_VBUS_IN_RING->blks[RT_VBUS_IN_RING->get_idx].data, size);
1001bfb4:	e3033240 	movw	r3, #12864	; 0x3240
1001bfb8:	e3413004 	movt	r3, #4100	; 0x1004
1001bfbc:	e5932000 	ldr	r2, [r3]
1001bfc0:	e3033240 	movw	r3, #12864	; 0x3240
1001bfc4:	e3413004 	movt	r3, #4100	; 0x1004
1001bfc8:	e5933000 	ldr	r3, [r3]
1001bfcc:	e5933004 	ldr	r3, [r3, #4]
1001bfd0:	e1a03303 	lsl	r3, r3, #6
1001bfd4:	e2833008 	add	r3, r3, #8
1001bfd8:	e0823003 	add	r3, r2, r3
1001bfdc:	e2833008 	add	r3, r3, #8
1001bfe0:	e1a00003 	mov	r0, r3
1001bfe4:	e51b1010 	ldr	r1, [fp, #-16]
1001bfe8:	ebfffc91 	bl	1001b234 <_chn0_actor>
                _ring_add_get_bnr(RT_VBUS_IN_RING, LEN2BNR(size));
1001bfec:	e3033240 	movw	r3, #12864	; 0x3240
1001bff0:	e3413004 	movt	r3, #4100	; 0x1004
1001bff4:	e5932000 	ldr	r2, [r3]
1001bff8:	e51b3010 	ldr	r3, [fp, #-16]
1001bffc:	e2833043 	add	r3, r3, #67	; 0x43
1001c000:	e1a03323 	lsr	r3, r3, #6
1001c004:	e1a00002 	mov	r0, r2
1001c008:	e1a01003 	mov	r1, r3
1001c00c:	ebfff862 	bl	1001a19c <_ring_add_get_bnr>
                continue;
1001c010:	ea000088 	b	1001c238 <_bus_in_entry+0x3b0>

#ifdef RT_VBUS_STATISTICS
            _total_data_sz += size;
#endif

            act = rt_malloc(sizeof(*act) + size);
1001c014:	e51b3010 	ldr	r3, [fp, #-16]
1001c018:	e2833008 	add	r3, r3, #8
1001c01c:	e1a00003 	mov	r0, r3
1001c020:	ebffe09b 	bl	10014294 <rt_malloc>
1001c024:	e50b0018 	str	r0, [fp, #-24]
            if (act == RT_NULL)
1001c028:	e51b3018 	ldr	r3, [fp, #-24]
1001c02c:	e3530000 	cmp	r3, #0
1001c030:	1a000009 	bne	1001c05c <_bus_in_entry+0x1d4>
            {
                //vbus_error("drop on OOM (%d, %d)\n", id, size);
                /* drop the packet on malloc fall */
                _ring_add_get_bnr(RT_VBUS_IN_RING, LEN2BNR(size));
1001c034:	e3033240 	movw	r3, #12864	; 0x3240
1001c038:	e3413004 	movt	r3, #4100	; 0x1004
1001c03c:	e5932000 	ldr	r2, [r3]
1001c040:	e51b3010 	ldr	r3, [fp, #-16]
1001c044:	e2833043 	add	r3, r3, #67	; 0x43
1001c048:	e1a03323 	lsr	r3, r3, #6
1001c04c:	e1a00002 	mov	r0, r2
1001c050:	e1a01003 	mov	r1, r3
1001c054:	ebfff850 	bl	1001a19c <_ring_add_get_bnr>
                continue;
1001c058:	ea000076 	b	1001c238 <_bus_in_entry+0x3b0>
            }

            act->size = size;
1001c05c:	e51b3010 	ldr	r3, [fp, #-16]
1001c060:	e6ef2073 	uxtb	r2, r3
1001c064:	e51b3018 	ldr	r3, [fp, #-24]
1001c068:	e5c32000 	strb	r2, [r3]
            act->next = RT_NULL;
1001c06c:	e51b3018 	ldr	r3, [fp, #-24]
1001c070:	e3a02000 	mov	r2, #0
1001c074:	e5832004 	str	r2, [r3, #4]

            nxtidx = RT_VBUS_IN_RING->get_idx + LEN2BNR(size);
1001c078:	e3033240 	movw	r3, #12864	; 0x3240
1001c07c:	e3413004 	movt	r3, #4100	; 0x1004
1001c080:	e5933000 	ldr	r3, [r3]
1001c084:	e5932004 	ldr	r2, [r3, #4]
1001c088:	e51b3010 	ldr	r3, [fp, #-16]
1001c08c:	e2833043 	add	r3, r3, #67	; 0x43
1001c090:	e1a03323 	lsr	r3, r3, #6
1001c094:	e0823003 	add	r3, r2, r3
1001c098:	e50b301c 	str	r3, [fp, #-28]
            if (nxtidx >= RT_VMM_RB_BLK_NR)
1001c09c:	e51b301c 	ldr	r3, [fp, #-28]
1001c0a0:	e3530013 	cmp	r3, #19
1001c0a4:	9a000034 	bls	1001c17c <_bus_in_entry+0x2f4>
            {
                unsigned int tailsz;

                tailsz = (RT_VMM_RB_BLK_NR - RT_VBUS_IN_RING->get_idx)
1001c0a8:	e3033240 	movw	r3, #12864	; 0x3240
1001c0ac:	e3413004 	movt	r3, #4100	; 0x1004
1001c0b0:	e5933000 	ldr	r3, [r3]
1001c0b4:	e5933004 	ldr	r3, [r3, #4]
                          * sizeof(RT_VBUS_IN_RING->blks[0]) - RT_VBUS_BLK_HEAD_SZ;
1001c0b8:	e1a03303 	lsl	r3, r3, #6
1001c0bc:	e2633000 	rsb	r3, r3, #0
            nxtidx = RT_VBUS_IN_RING->get_idx + LEN2BNR(size);
            if (nxtidx >= RT_VMM_RB_BLK_NR)
            {
                unsigned int tailsz;

                tailsz = (RT_VMM_RB_BLK_NR - RT_VBUS_IN_RING->get_idx)
1001c0c0:	e2833e4f 	add	r3, r3, #1264	; 0x4f0
1001c0c4:	e283300c 	add	r3, r3, #12
1001c0c8:	e50b300c 	str	r3, [fp, #-12]
                          * sizeof(RT_VBUS_IN_RING->blks[0]) - RT_VBUS_BLK_HEAD_SZ;

                /* the remaining block is sufficient for the data */
                if (tailsz > size)
1001c0cc:	e51b200c 	ldr	r2, [fp, #-12]
1001c0d0:	e51b3010 	ldr	r3, [fp, #-16]
1001c0d4:	e1520003 	cmp	r2, r3
1001c0d8:	9a000001 	bls	1001c0e4 <_bus_in_entry+0x25c>
                    tailsz = size;
1001c0dc:	e51b3010 	ldr	r3, [fp, #-16]
1001c0e0:	e50b300c 	str	r3, [fp, #-12]

                rt_memcpy(act+1, &RT_VBUS_IN_RING->blks[RT_VBUS_IN_RING->get_idx].data, tailsz);
1001c0e4:	e51b3018 	ldr	r3, [fp, #-24]
1001c0e8:	e2831008 	add	r1, r3, #8
1001c0ec:	e3033240 	movw	r3, #12864	; 0x3240
1001c0f0:	e3413004 	movt	r3, #4100	; 0x1004
1001c0f4:	e5932000 	ldr	r2, [r3]
1001c0f8:	e3033240 	movw	r3, #12864	; 0x3240
1001c0fc:	e3413004 	movt	r3, #4100	; 0x1004
1001c100:	e5933000 	ldr	r3, [r3]
1001c104:	e5933004 	ldr	r3, [r3, #4]
1001c108:	e1a03303 	lsl	r3, r3, #6
1001c10c:	e2833008 	add	r3, r3, #8
1001c110:	e0823003 	add	r3, r2, r3
1001c114:	e2833008 	add	r3, r3, #8
1001c118:	e1a00001 	mov	r0, r1
1001c11c:	e1a01003 	mov	r1, r3
1001c120:	e51b200c 	ldr	r2, [fp, #-12]
1001c124:	ebffd8a3 	bl	100123b8 <rt_memcpy>
                rt_memcpy((char*)(act+1) + tailsz, &RT_VBUS_IN_RING->blks[0], size - tailsz);
1001c128:	e51b300c 	ldr	r3, [fp, #-12]
1001c12c:	e2833008 	add	r3, r3, #8
1001c130:	e51b2018 	ldr	r2, [fp, #-24]
1001c134:	e0820003 	add	r0, r2, r3
1001c138:	e3033240 	movw	r3, #12864	; 0x3240
1001c13c:	e3413004 	movt	r3, #4100	; 0x1004
1001c140:	e5933000 	ldr	r3, [r3]
1001c144:	e283100c 	add	r1, r3, #12
1001c148:	e51b2010 	ldr	r2, [fp, #-16]
1001c14c:	e51b300c 	ldr	r3, [fp, #-12]
1001c150:	e0633002 	rsb	r3, r3, r2
1001c154:	e1a02003 	mov	r2, r3
1001c158:	ebffd896 	bl	100123b8 <rt_memcpy>

                /* It shall make sure the CPU has finished reading the item
                 * before it writes the new tail pointer, which will erase the
                 * item. */
                rt_vbus_smp_wmb();
1001c15c:	ebfff808 	bl	1001a184 <rt_vbus_smp_wmb>
                RT_VBUS_IN_RING->get_idx = nxtidx - RT_VMM_RB_BLK_NR;
1001c160:	e3033240 	movw	r3, #12864	; 0x3240
1001c164:	e3413004 	movt	r3, #4100	; 0x1004
1001c168:	e5933000 	ldr	r3, [r3]
1001c16c:	e51b201c 	ldr	r2, [fp, #-28]
1001c170:	e2422014 	sub	r2, r2, #20
1001c174:	e5832004 	str	r2, [r3, #4]
1001c178:	ea000016 	b	1001c1d8 <_bus_in_entry+0x350>
            }
            else
            {
                rt_memcpy(act+1, &RT_VBUS_IN_RING->blks[RT_VBUS_IN_RING->get_idx].data, size);
1001c17c:	e51b3018 	ldr	r3, [fp, #-24]
1001c180:	e2831008 	add	r1, r3, #8
1001c184:	e3033240 	movw	r3, #12864	; 0x3240
1001c188:	e3413004 	movt	r3, #4100	; 0x1004
1001c18c:	e5932000 	ldr	r2, [r3]
1001c190:	e3033240 	movw	r3, #12864	; 0x3240
1001c194:	e3413004 	movt	r3, #4100	; 0x1004
1001c198:	e5933000 	ldr	r3, [r3]
1001c19c:	e5933004 	ldr	r3, [r3, #4]
1001c1a0:	e1a03303 	lsl	r3, r3, #6
1001c1a4:	e2833008 	add	r3, r3, #8
1001c1a8:	e0823003 	add	r3, r2, r3
1001c1ac:	e2833008 	add	r3, r3, #8
1001c1b0:	e1a00001 	mov	r0, r1
1001c1b4:	e1a01003 	mov	r1, r3
1001c1b8:	e51b2010 	ldr	r2, [fp, #-16]
1001c1bc:	ebffd87d 	bl	100123b8 <rt_memcpy>

                rt_vbus_smp_wmb();
1001c1c0:	ebfff7ef 	bl	1001a184 <rt_vbus_smp_wmb>
                RT_VBUS_IN_RING->get_idx = nxtidx;
1001c1c4:	e3033240 	movw	r3, #12864	; 0x3240
1001c1c8:	e3413004 	movt	r3, #4100	; 0x1004
1001c1cc:	e5933000 	ldr	r3, [r3]
1001c1d0:	e51b201c 	ldr	r2, [fp, #-28]
1001c1d4:	e5832004 	str	r2, [r3, #4]
            }

            rt_vbus_data_push(id, act);
1001c1d8:	e51b0014 	ldr	r0, [fp, #-20]
1001c1dc:	e51b1018 	ldr	r1, [fp, #-24]
1001c1e0:	ebfffa7d 	bl	1001abdc <rt_vbus_data_push>
            _vbus_indicate(RT_VBUS_EVENT_ID_RX, id);
1001c1e4:	e51b3014 	ldr	r3, [fp, #-20]
1001c1e8:	e6ef3073 	uxtb	r3, r3
1001c1ec:	e3a00000 	mov	r0, #0
1001c1f0:	e1a01003 	mov	r1, r3
1001c1f4:	ebfff872 	bl	1001a3c4 <_vbus_indicate>
            event_set |= 1 << id;
1001c1f8:	e51b3014 	ldr	r3, [fp, #-20]
1001c1fc:	e3a02001 	mov	r2, #1
1001c200:	e1a03312 	lsl	r3, r2, r3
1001c204:	e1a02003 	mov	r2, r3
1001c208:	e51b3008 	ldr	r3, [fp, #-8]
1001c20c:	e1833002 	orr	r3, r3, r2
1001c210:	e50b3008 	str	r3, [fp, #-8]

            if (RT_VBUS_IN_RING->blocked)
1001c214:	e3033240 	movw	r3, #12864	; 0x3240
1001c218:	e3413004 	movt	r3, #4100	; 0x1004
1001c21c:	e5933000 	ldr	r3, [r3]
1001c220:	e5933008 	ldr	r3, [r3, #8]
1001c224:	e3530000 	cmp	r3, #0
1001c228:	0a000002 	beq	1001c238 <_bus_in_entry+0x3b0>
                rt_vbus_tick(0, RT_VBUS_GUEST_VIRQ);
1001c22c:	e3a00000 	mov	r0, #0
1001c230:	e3a01000 	mov	r1, #0
1001c234:	ebfff7c4 	bl	1001a14c <rt_vbus_tick>
                       RT_WAITING_FOREVER) == RT_EOK)
    {
        rt_uint32_t event_set = 0;

        /* while(not empty) */
        while (RT_VBUS_IN_RING->get_idx != RT_VBUS_IN_RING->put_idx)
1001c238:	e3033240 	movw	r3, #12864	; 0x3240
1001c23c:	e3413004 	movt	r3, #4100	; 0x1004
1001c240:	e5933000 	ldr	r3, [r3]
1001c244:	e5932004 	ldr	r2, [r3, #4]
1001c248:	e3033240 	movw	r3, #12864	; 0x3240
1001c24c:	e3413004 	movt	r3, #4100	; 0x1004
1001c250:	e5933000 	ldr	r3, [r3]
1001c254:	e5933000 	ldr	r3, [r3]
1001c258:	e1520003 	cmp	r2, r3
1001c25c:	1affff23 	bne	1001bef0 <_bus_in_entry+0x68>

            if (RT_VBUS_IN_RING->blocked)
                rt_vbus_tick(0, RT_VBUS_GUEST_VIRQ);
        }

        if (event_set != 0)
1001c260:	e51b3008 	ldr	r3, [fp, #-8]
1001c264:	e3530000 	cmp	r3, #0
1001c268:	0a000001 	beq	1001c274 <_bus_in_entry+0x3ec>
            rt_vbus_notify_set(event_set);
1001c26c:	e51b0008 	ldr	r0, [fp, #-8]
1001c270:	ebfffa2b 	bl	1001ab24 <rt_vbus_notify_set>
{
    rt_sem_init(&_bus_in_sem, "vbus", 0, RT_IPC_FLAG_FIFO);
    rt_event_init(&_bus_in_event, "vbus", RT_IPC_FLAG_FIFO);
    rt_memset(_bus_in_action, 0, sizeof(_bus_in_action));

    while (rt_sem_take(&_bus_in_sem,
1001c274:	e30d0d78 	movw	r0, #56696	; 0xdd78
1001c278:	e3410003 	movt	r0, #4099	; 0x1003
1001c27c:	e3e01000 	mvn	r1, #0
1001c280:	ebffcc79 	bl	1000f46c <rt_sem_take>
1001c284:	e1a03000 	mov	r3, r0
1001c288:	e3530000 	cmp	r3, #0
1001c28c:	0affff14 	beq	1001bee4 <_bus_in_entry+0x5c>
        }

        if (event_set != 0)
            rt_vbus_notify_set(event_set);
    }
    RT_ASSERT(0);
1001c290:	e30405ec 	movw	r0, #17900	; 0x45ec
1001c294:	e3410003 	movt	r0, #4099	; 0x1003
1001c298:	e3041934 	movw	r1, #18740	; 0x4934
1001c29c:	e3411003 	movt	r1, #4099	; 0x1003
1001c2a0:	e300248d 	movw	r2, #1165	; 0x48d
1001c2a4:	ebffdec2 	bl	10013db4 <rt_assert_handler>
}
1001c2a8:	e24bd004 	sub	sp, fp, #4
1001c2ac:	e8bd8800 	pop	{fp, pc}

1001c2b0 <rt_vbus_isr>:

void rt_vbus_isr(int irqnr, void *param)
{
1001c2b0:	e92d4800 	push	{fp, lr}
1001c2b4:	e28db004 	add	fp, sp, #4
1001c2b8:	e24dd008 	sub	sp, sp, #8
1001c2bc:	e50b0008 	str	r0, [fp, #-8]
1001c2c0:	e50b100c 	str	r1, [fp, #-12]
    if (RT_VBUS_OUT_RING->blocked)   /**/
1001c2c4:	e303323c 	movw	r3, #12860	; 0x323c
1001c2c8:	e3413004 	movt	r3, #4100	; 0x1004
1001c2cc:	e5933000 	ldr	r3, [r3]
1001c2d0:	e5933008 	ldr	r3, [r3, #8]
1001c2d4:	e3530000 	cmp	r3, #0
1001c2d8:	0a000000 	beq	1001c2e0 <rt_vbus_isr+0x30>
        rt_vbus_resume_out_thread();
1001c2dc:	ebfff94d 	bl	1001a818 <rt_vbus_resume_out_thread>

    rt_sem_release(&_bus_in_sem);
1001c2e0:	e30d0d78 	movw	r0, #56696	; 0xdd78
1001c2e4:	e3410003 	movt	r0, #4099	; 0x1003
1001c2e8:	ebffccf3 	bl	1000f6bc <rt_sem_release>
    rt_vbus_hw_eoi(irqnr, param);
1001c2ec:	e51b0008 	ldr	r0, [fp, #-8]
1001c2f0:	e51b100c 	ldr	r1, [fp, #-12]
1001c2f4:	ebffc276 	bl	1000ccd4 <rt_vbus_hw_eoi>
}
1001c2f8:	e24bd004 	sub	sp, fp, #4
1001c2fc:	e8bd8800 	pop	{fp, pc}

1001c300 <rt_vbus_init>:
VBUS
@param 1, 
@param 2, 
*/
int rt_vbus_init(void *outr, void *inr)
{
1001c300:	e92d4800 	push	{fp, lr}
1001c304:	e28db004 	add	fp, sp, #4
1001c308:	e24dd020 	sub	sp, sp, #32
1001c30c:	e50b0010 	str	r0, [fp, #-16]
1001c310:	e50b1014 	str	r1, [fp, #-20]

#ifdef RT_USING_LOGTRACE
    log_trace_register_session(&_lgs);
#endif

    if (outr > inr)
1001c314:	e51b2010 	ldr	r2, [fp, #-16]
1001c318:	e51b3014 	ldr	r3, [fp, #-20]
1001c31c:	e1520003 	cmp	r2, r3
1001c320:	9a00000d 	bls	1001c35c <rt_vbus_init+0x5c>
    {
        RT_ASSERT((char*)outr - (char*)inr >= sizeof(struct rt_vbus_ring));
1001c324:	e51b2010 	ldr	r2, [fp, #-16]
1001c328:	e51b3014 	ldr	r3, [fp, #-20]
1001c32c:	e0633002 	rsb	r3, r3, r2
1001c330:	e1a02003 	mov	r2, r3
1001c334:	e300350b 	movw	r3, #1291	; 0x50b
1001c338:	e1520003 	cmp	r2, r3
1001c33c:	8a000013 	bhi	1001c390 <rt_vbus_init+0x90>
1001c340:	e3040720 	movw	r0, #18208	; 0x4720
1001c344:	e3410003 	movt	r0, #4099	; 0x1003
1001c348:	e3041944 	movw	r1, #18756	; 0x4944
1001c34c:	e3411003 	movt	r1, #4099	; 0x1003
1001c350:	e30024a7 	movw	r2, #1191	; 0x4a7
1001c354:	ebffde96 	bl	10013db4 <rt_assert_handler>
1001c358:	ea00000c 	b	1001c390 <rt_vbus_init+0x90>
    }
    else
    {
        RT_ASSERT((char*)inr - (char*)outr >= sizeof(struct rt_vbus_ring));
1001c35c:	e51b2014 	ldr	r2, [fp, #-20]
1001c360:	e51b3010 	ldr	r3, [fp, #-16]
1001c364:	e0633002 	rsb	r3, r3, r2
1001c368:	e1a02003 	mov	r2, r3
1001c36c:	e300350b 	movw	r3, #1291	; 0x50b
1001c370:	e1520003 	cmp	r2, r3
1001c374:	8a000005 	bhi	1001c390 <rt_vbus_init+0x90>
1001c378:	e3040758 	movw	r0, #18264	; 0x4758
1001c37c:	e3410003 	movt	r0, #4099	; 0x1003
1001c380:	e3041944 	movw	r1, #18756	; 0x4944
1001c384:	e3411003 	movt	r1, #4099	; 0x1003
1001c388:	e30024ab 	movw	r2, #1195	; 0x4ab
1001c38c:	ebffde88 	bl	10013db4 <rt_assert_handler>
    }

    RT_VBUS_OUT_RING = outr;
1001c390:	e303323c 	movw	r3, #12860	; 0x323c
1001c394:	e3413004 	movt	r3, #4100	; 0x1004
1001c398:	e51b2010 	ldr	r2, [fp, #-16]
1001c39c:	e5832000 	str	r2, [r3]
    RT_VBUS_IN_RING  = inr;
1001c3a0:	e3033240 	movw	r3, #12864	; 0x3240
1001c3a4:	e3413004 	movt	r3, #4100	; 0x1004
1001c3a8:	e51b2014 	ldr	r2, [fp, #-20]
1001c3ac:	e5832000 	str	r2, [r3]

    rt_memset(RT_VBUS_OUT_RING, 0, sizeof(*RT_VBUS_OUT_RING));
1001c3b0:	e303323c 	movw	r3, #12860	; 0x323c
1001c3b4:	e3413004 	movt	r3, #4100	; 0x1004
1001c3b8:	e5933000 	ldr	r3, [r3]
1001c3bc:	e1a00003 	mov	r0, r3
1001c3c0:	e3a01000 	mov	r1, #0
1001c3c4:	e300250c 	movw	r2, #1292	; 0x50c
1001c3c8:	ebffd7a2 	bl	10012258 <rt_memset>
    rt_memset(RT_VBUS_IN_RING,  0, sizeof(*RT_VBUS_IN_RING));
1001c3cc:	e3033240 	movw	r3, #12864	; 0x3240
1001c3d0:	e3413004 	movt	r3, #4100	; 0x1004
1001c3d4:	e5933000 	ldr	r3, [r3]
1001c3d8:	e1a00003 	mov	r0, r3
1001c3dc:	e3a01000 	mov	r1, #0
1001c3e0:	e300250c 	movw	r2, #1292	; 0x50c
1001c3e4:	ebffd79b 	bl	10012258 <rt_memset>
    _chn_status[0] = RT_VBUS_CHN_ST_ESTABLISHED;
1001c3e8:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001c3ec:	e3413003 	movt	r3, #4099	; 0x1003
1001c3f0:	e3a02003 	mov	r2, #3
1001c3f4:	e5c32000 	strb	r2, [r3]
    for (i = 1; i < ARRAY_SIZE(_chn_status); i++)
1001c3f8:	e3a03001 	mov	r3, #1
1001c3fc:	e50b3008 	str	r3, [fp, #-8]
1001c400:	ea000008 	b	1001c428 <rt_vbus_init+0x128>
    {
        _chn_status[i] = RT_VBUS_CHN_ST_AVAILABLE;
1001c404:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001c408:	e3413003 	movt	r3, #4099	; 0x1003
1001c40c:	e51b2008 	ldr	r2, [fp, #-8]
1001c410:	e0833002 	add	r3, r3, r2
1001c414:	e3a02000 	mov	r2, #0
1001c418:	e5c32000 	strb	r2, [r3]
    RT_VBUS_IN_RING  = inr;

    rt_memset(RT_VBUS_OUT_RING, 0, sizeof(*RT_VBUS_OUT_RING));
    rt_memset(RT_VBUS_IN_RING,  0, sizeof(*RT_VBUS_IN_RING));
    _chn_status[0] = RT_VBUS_CHN_ST_ESTABLISHED;
    for (i = 1; i < ARRAY_SIZE(_chn_status); i++)
1001c41c:	e51b3008 	ldr	r3, [fp, #-8]
1001c420:	e2833001 	add	r3, r3, #1
1001c424:	e50b3008 	str	r3, [fp, #-8]
1001c428:	e51b3008 	ldr	r3, [fp, #-8]
1001c42c:	e353001f 	cmp	r3, #31
1001c430:	9afffff3 	bls	1001c404 <rt_vbus_init+0x104>
    {
        _chn_status[i] = RT_VBUS_CHN_ST_AVAILABLE;
    }
    for (i = 0; i < ARRAY_SIZE(_sess); i++)/*sess**/
1001c434:	e3a03000 	mov	r3, #0
1001c438:	e50b3008 	str	r3, [fp, #-8]
1001c43c:	ea000019 	b	1001c4a8 <rt_vbus_init+0x1a8>
    {
        _sess[i].req = RT_NULL;
1001c440:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001c444:	e3412003 	movt	r2, #4099	; 0x1003
1001c448:	e51b3008 	ldr	r3, [fp, #-8]
1001c44c:	e1a01003 	mov	r1, r3
1001c450:	e1a03181 	lsl	r3, r1, #3
1001c454:	e1a01003 	mov	r1, r3
1001c458:	e1a03101 	lsl	r3, r1, #2
1001c45c:	e0613003 	rsb	r3, r1, r3
1001c460:	e0823003 	add	r3, r2, r3
1001c464:	e2833010 	add	r3, r3, #16
1001c468:	e3a02000 	mov	r2, #0
1001c46c:	e5832004 	str	r2, [r3, #4]
        _sess[i].st  = SESSIOM_AVAILABLE;
1001c470:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001c474:	e3412003 	movt	r2, #4099	; 0x1003
1001c478:	e51b3008 	ldr	r3, [fp, #-8]
1001c47c:	e1a01003 	mov	r1, r3
1001c480:	e1a03181 	lsl	r3, r1, #3
1001c484:	e1a01003 	mov	r1, r3
1001c488:	e1a03101 	lsl	r3, r1, #2
1001c48c:	e0613003 	rsb	r3, r1, r3
1001c490:	e0823003 	add	r3, r2, r3
1001c494:	e3a02000 	mov	r2, #0
1001c498:	e5c32004 	strb	r2, [r3, #4]
    _chn_status[0] = RT_VBUS_CHN_ST_ESTABLISHED;
    for (i = 1; i < ARRAY_SIZE(_chn_status); i++)
    {
        _chn_status[i] = RT_VBUS_CHN_ST_AVAILABLE;
    }
    for (i = 0; i < ARRAY_SIZE(_sess); i++)/*sess**/
1001c49c:	e51b3008 	ldr	r3, [fp, #-8]
1001c4a0:	e2833001 	add	r3, r3, #1
1001c4a4:	e50b3008 	str	r3, [fp, #-8]
1001c4a8:	e51b3008 	ldr	r3, [fp, #-8]
1001c4ac:	e353000f 	cmp	r3, #15
1001c4b0:	9affffe2 	bls	1001c440 <rt_vbus_init+0x140>
    {
        _sess[i].req = RT_NULL;
        _sess[i].st  = SESSIOM_AVAILABLE;
    }
    _vbus_rx_indi[RT_VBUS_EVENT_ID_TX][0].indicate = _chn0_tx_listener;
1001c4b4:	e3033248 	movw	r3, #12872	; 0x3248
1001c4b8:	e3413004 	movt	r3, #4100	; 0x1004
1001c4bc:	e30a2a4c 	movw	r2, #43596	; 0xaa4c
1001c4c0:	e3412001 	movt	r2, #4097	; 0x1001
1001c4c4:	e5832100 	str	r2, [r3, #256]	; 0x100
    _vbus_rx_indi[RT_VBUS_EVENT_ID_TX][0].ctx = RT_NULL;
1001c4c8:	e3033248 	movw	r3, #12872	; 0x3248
1001c4cc:	e3413004 	movt	r3, #4100	; 0x1004
1001c4d0:	e3a02000 	mov	r2, #0
1001c4d4:	e5832104 	str	r2, [r3, #260]	; 0x104
    _chn_recv_wm[0].high_mark = ~0;
    _chn_recv_wm[0].level = 0;
    _chn_recv_wm[0].last_warn = 0;
#endif

    rt_thread_init(&_bus_out_thread, "vbusout",
1001c4d8:	e30c3d00 	movw	r3, #52480	; 0xcd00
1001c4dc:	e3413003 	movt	r3, #4099	; 0x1003
1001c4e0:	e58d3000 	str	r3, [sp]
1001c4e4:	e3a03b02 	mov	r3, #2048	; 0x800
1001c4e8:	e58d3004 	str	r3, [sp, #4]
1001c4ec:	e3a03008 	mov	r3, #8
1001c4f0:	e58d3008 	str	r3, [sp, #8]
1001c4f4:	e3a03014 	mov	r3, #20
1001c4f8:	e58d300c 	str	r3, [sp, #12]
1001c4fc:	e30c0c88 	movw	r0, #52360	; 0xcc88
1001c500:	e3410003 	movt	r0, #4099	; 0x1003
1001c504:	e3041790 	movw	r1, #18320	; 0x4790
1001c508:	e3411003 	movt	r1, #4099	; 0x1003
1001c50c:	e30a247c 	movw	r2, #42108	; 0xa47c
1001c510:	e3412001 	movt	r2, #4097	; 0x1001
1001c514:	e3a03000 	mov	r3, #0
1001c518:	ebffe8e2 	bl	100168a8 <rt_thread_init>
                   _bus_out_entry, RT_NULL,
                   _bus_out_thread_stack, sizeof(_bus_out_thread_stack),
                   _BUS_OUT_THRD_PRIO, 20);
    rt_thread_startup(&_bus_out_thread);
1001c51c:	e30c0c88 	movw	r0, #52360	; 0xcc88
1001c520:	e3410003 	movt	r0, #4099	; 0x1003
1001c524:	ebffe916 	bl	10016984 <rt_thread_startup>

    rt_thread_init(&_bus_in_thread, "vbusin",
1001c528:	e30d3578 	movw	r3, #54648	; 0xd578
1001c52c:	e3413003 	movt	r3, #4099	; 0x1003
1001c530:	e58d3000 	str	r3, [sp]
1001c534:	e3a03b02 	mov	r3, #2048	; 0x800
1001c538:	e58d3004 	str	r3, [sp, #4]
1001c53c:	e3a03009 	mov	r3, #9
1001c540:	e58d3008 	str	r3, [sp, #8]
1001c544:	e3a03014 	mov	r3, #20
1001c548:	e58d300c 	str	r3, [sp, #12]
1001c54c:	e30d0500 	movw	r0, #54528	; 0xd500
1001c550:	e3410003 	movt	r0, #4099	; 0x1003
1001c554:	e3041798 	movw	r1, #18328	; 0x4798
1001c558:	e3411003 	movt	r1, #4099	; 0x1003
1001c55c:	e30b2e88 	movw	r2, #48776	; 0xbe88
1001c560:	e3412001 	movt	r2, #4097	; 0x1001
1001c564:	e3a03000 	mov	r3, #0
1001c568:	ebffe8ce 	bl	100168a8 <rt_thread_init>
                   _bus_in_entry, RT_NULL,
                   _bus_in_thread_stack, sizeof(_bus_in_thread_stack),
                   _BUS_IN_THRD_PRIO, 20);


    rt_thread_startup(&_bus_in_thread);
1001c56c:	e30d0500 	movw	r0, #54528	; 0xd500
1001c570:	e3410003 	movt	r0, #4099	; 0x1003
1001c574:	ebffe902 	bl	10016984 <rt_thread_startup>

    rt_vbus_hw_init();/**/
1001c578:	ebffc1b7 	bl	1000cc5c <rt_vbus_hw_init>

    rt_kprintf("VBus loaded: %d out blocks, %d in blocks\n",
1001c57c:	e30407a0 	movw	r0, #18336	; 0x47a0
1001c580:	e3410003 	movt	r0, #4099	; 0x1003
1001c584:	e3a01014 	mov	r1, #20
1001c588:	e3a02014 	mov	r2, #20
1001c58c:	ebffdd4b 	bl	10013ac0 <rt_kprintf>
               RT_VMM_RB_BLK_NR, RT_VMM_RB_BLK_NR);

    rt_vbus_chnx_init();
1001c590:	eb00029e 	bl	1001d010 <rt_vbus_chnx_init>

    return 0;
1001c594:	e3a03000 	mov	r3, #0
}
1001c598:	e1a00003 	mov	r0, r3
1001c59c:	e24bd004 	sub	sp, fp, #4
1001c5a0:	e8bd8800 	pop	{fp, pc}

1001c5a4 <rt_vbus_rb_dump>:

void rt_vbus_rb_dump(void)
{
1001c5a4:	e92d4800 	push	{fp, lr}
1001c5a8:	e28db004 	add	fp, sp, #4
    rt_kprintf("OUT ring:(%s blocked)\n", RT_VBUS_OUT_RING->blocked ? "is" : "not");
1001c5ac:	e303323c 	movw	r3, #12860	; 0x323c
1001c5b0:	e3413004 	movt	r3, #4100	; 0x1004
1001c5b4:	e5933000 	ldr	r3, [r3]
1001c5b8:	e5933008 	ldr	r3, [r3, #8]
1001c5bc:	e3530000 	cmp	r3, #0
1001c5c0:	0a000002 	beq	1001c5d0 <rt_vbus_rb_dump+0x2c>
1001c5c4:	e30437cc 	movw	r3, #18380	; 0x47cc
1001c5c8:	e3413003 	movt	r3, #4099	; 0x1003
1001c5cc:	ea000001 	b	1001c5d8 <rt_vbus_rb_dump+0x34>
1001c5d0:	e30437d0 	movw	r3, #18384	; 0x47d0
1001c5d4:	e3413003 	movt	r3, #4099	; 0x1003
1001c5d8:	e30407d4 	movw	r0, #18388	; 0x47d4
1001c5dc:	e3410003 	movt	r0, #4099	; 0x1003
1001c5e0:	e1a01003 	mov	r1, r3
1001c5e4:	ebffdd35 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("put idx: %8x, get idx: %8x\n",
               RT_VBUS_OUT_RING->put_idx, RT_VBUS_OUT_RING->get_idx);
1001c5e8:	e303323c 	movw	r3, #12860	; 0x323c
1001c5ec:	e3413004 	movt	r3, #4100	; 0x1004
1001c5f0:	e5933000 	ldr	r3, [r3]
}

void rt_vbus_rb_dump(void)
{
    rt_kprintf("OUT ring:(%s blocked)\n", RT_VBUS_OUT_RING->blocked ? "is" : "not");
    rt_kprintf("put idx: %8x, get idx: %8x\n",
1001c5f4:	e5932000 	ldr	r2, [r3]
               RT_VBUS_OUT_RING->put_idx, RT_VBUS_OUT_RING->get_idx);
1001c5f8:	e303323c 	movw	r3, #12860	; 0x323c
1001c5fc:	e3413004 	movt	r3, #4100	; 0x1004
1001c600:	e5933000 	ldr	r3, [r3]
}

void rt_vbus_rb_dump(void)
{
    rt_kprintf("OUT ring:(%s blocked)\n", RT_VBUS_OUT_RING->blocked ? "is" : "not");
    rt_kprintf("put idx: %8x, get idx: %8x\n",
1001c604:	e5933004 	ldr	r3, [r3, #4]
1001c608:	e30407ec 	movw	r0, #18412	; 0x47ec
1001c60c:	e3410003 	movt	r0, #4099	; 0x1003
1001c610:	e1a01002 	mov	r1, r2
1001c614:	e1a02003 	mov	r2, r3
1001c618:	ebffdd28 	bl	10013ac0 <rt_kprintf>
               RT_VBUS_OUT_RING->put_idx, RT_VBUS_OUT_RING->get_idx);
    rt_kprintf("space: %d\n", _bus_ring_space_nr(RT_VBUS_OUT_RING));
1001c61c:	e303323c 	movw	r3, #12860	; 0x323c
1001c620:	e3413004 	movt	r3, #4100	; 0x1004
1001c624:	e5933000 	ldr	r3, [r3]
1001c628:	e1a00003 	mov	r0, r3
1001c62c:	ebfff6f0 	bl	1001a1f4 <_bus_ring_space_nr>
1001c630:	e1a03000 	mov	r3, r0
1001c634:	e3040808 	movw	r0, #18440	; 0x4808
1001c638:	e3410003 	movt	r0, #4099	; 0x1003
1001c63c:	e1a01003 	mov	r1, r3
1001c640:	ebffdd1e 	bl	10013ac0 <rt_kprintf>


    rt_kprintf("IN ring:(%s blocked)\n", RT_VBUS_IN_RING->blocked ? "is" : "not");
1001c644:	e3033240 	movw	r3, #12864	; 0x3240
1001c648:	e3413004 	movt	r3, #4100	; 0x1004
1001c64c:	e5933000 	ldr	r3, [r3]
1001c650:	e5933008 	ldr	r3, [r3, #8]
1001c654:	e3530000 	cmp	r3, #0
1001c658:	0a000002 	beq	1001c668 <rt_vbus_rb_dump+0xc4>
1001c65c:	e30437cc 	movw	r3, #18380	; 0x47cc
1001c660:	e3413003 	movt	r3, #4099	; 0x1003
1001c664:	ea000001 	b	1001c670 <rt_vbus_rb_dump+0xcc>
1001c668:	e30437d0 	movw	r3, #18384	; 0x47d0
1001c66c:	e3413003 	movt	r3, #4099	; 0x1003
1001c670:	e3040814 	movw	r0, #18452	; 0x4814
1001c674:	e3410003 	movt	r0, #4099	; 0x1003
1001c678:	e1a01003 	mov	r1, r3
1001c67c:	ebffdd0f 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("put idx: %8x, get idx: %8x\n",
               RT_VBUS_IN_RING->put_idx, RT_VBUS_IN_RING->get_idx);
1001c680:	e3033240 	movw	r3, #12864	; 0x3240
1001c684:	e3413004 	movt	r3, #4100	; 0x1004
1001c688:	e5933000 	ldr	r3, [r3]
               RT_VBUS_OUT_RING->put_idx, RT_VBUS_OUT_RING->get_idx);
    rt_kprintf("space: %d\n", _bus_ring_space_nr(RT_VBUS_OUT_RING));


    rt_kprintf("IN ring:(%s blocked)\n", RT_VBUS_IN_RING->blocked ? "is" : "not");
    rt_kprintf("put idx: %8x, get idx: %8x\n",
1001c68c:	e5932000 	ldr	r2, [r3]
               RT_VBUS_IN_RING->put_idx, RT_VBUS_IN_RING->get_idx);
1001c690:	e3033240 	movw	r3, #12864	; 0x3240
1001c694:	e3413004 	movt	r3, #4100	; 0x1004
1001c698:	e5933000 	ldr	r3, [r3]
               RT_VBUS_OUT_RING->put_idx, RT_VBUS_OUT_RING->get_idx);
    rt_kprintf("space: %d\n", _bus_ring_space_nr(RT_VBUS_OUT_RING));


    rt_kprintf("IN ring:(%s blocked)\n", RT_VBUS_IN_RING->blocked ? "is" : "not");
    rt_kprintf("put idx: %8x, get idx: %8x\n",
1001c69c:	e5933004 	ldr	r3, [r3, #4]
1001c6a0:	e30407ec 	movw	r0, #18412	; 0x47ec
1001c6a4:	e3410003 	movt	r0, #4099	; 0x1003
1001c6a8:	e1a01002 	mov	r1, r2
1001c6ac:	e1a02003 	mov	r2, r3
1001c6b0:	ebffdd02 	bl	10013ac0 <rt_kprintf>
               RT_VBUS_IN_RING->put_idx, RT_VBUS_IN_RING->get_idx);
    rt_kprintf("space: %d\n", _bus_ring_space_nr(RT_VBUS_IN_RING));
1001c6b4:	e3033240 	movw	r3, #12864	; 0x3240
1001c6b8:	e3413004 	movt	r3, #4100	; 0x1004
1001c6bc:	e5933000 	ldr	r3, [r3]
1001c6c0:	e1a00003 	mov	r0, r3
1001c6c4:	ebfff6ca 	bl	1001a1f4 <_bus_ring_space_nr>
1001c6c8:	e1a03000 	mov	r3, r0
1001c6cc:	e3040808 	movw	r0, #18440	; 0x4808
1001c6d0:	e3410003 	movt	r0, #4099	; 0x1003
1001c6d4:	e1a01003 	mov	r1, r3
1001c6d8:	ebffdcf8 	bl	10013ac0 <rt_kprintf>
}
1001c6dc:	e8bd8800 	pop	{fp, pc}

1001c6e0 <rt_vbus_chn_dump>:

void rt_vbus_chn_dump(void)
{
1001c6e0:	e92d4800 	push	{fp, lr}
1001c6e4:	e28db004 	add	fp, sp, #4
1001c6e8:	e24dd008 	sub	sp, sp, #8
    int i;
    rt_kprintf("vbus channel status:\n");
1001c6ec:	e304082c 	movw	r0, #18476	; 0x482c
1001c6f0:	e3410003 	movt	r0, #4099	; 0x1003
1001c6f4:	ebffdcf1 	bl	10013ac0 <rt_kprintf>
    for (i = 0; i < ARRAY_SIZE(_chn_status); i++)
1001c6f8:	e3a03000 	mov	r3, #0
1001c6fc:	e50b3008 	str	r3, [fp, #-8]
1001c700:	ea000010 	b	1001c748 <rt_vbus_chn_dump+0x68>
    {
        rt_kprintf("%2d:%s\n", i, rt_vbus_chn_st2str[_chn_status[i]]);
1001c704:	e30c3c68 	movw	r3, #52328	; 0xcc68
1001c708:	e3413003 	movt	r3, #4099	; 0x1003
1001c70c:	e51b2008 	ldr	r2, [fp, #-8]
1001c710:	e0833002 	add	r3, r3, r2
1001c714:	e5d33000 	ldrb	r3, [r3]
1001c718:	e1a02003 	mov	r2, r3
1001c71c:	e3063908 	movw	r3, #26888	; 0x6908
1001c720:	e3413003 	movt	r3, #4099	; 0x1003
1001c724:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1001c728:	e3040844 	movw	r0, #18500	; 0x4844
1001c72c:	e3410003 	movt	r0, #4099	; 0x1003
1001c730:	e51b1008 	ldr	r1, [fp, #-8]
1001c734:	e1a02003 	mov	r2, r3
1001c738:	ebffdce0 	bl	10013ac0 <rt_kprintf>

void rt_vbus_chn_dump(void)
{
    int i;
    rt_kprintf("vbus channel status:\n");
    for (i = 0; i < ARRAY_SIZE(_chn_status); i++)
1001c73c:	e51b3008 	ldr	r3, [fp, #-8]
1001c740:	e2833001 	add	r3, r3, #1
1001c744:	e50b3008 	str	r3, [fp, #-8]
1001c748:	e51b3008 	ldr	r3, [fp, #-8]
1001c74c:	e353001f 	cmp	r3, #31
1001c750:	9affffeb 	bls	1001c704 <rt_vbus_chn_dump+0x24>
    {
        rt_kprintf("%2d:%s\n", i, rt_vbus_chn_st2str[_chn_status[i]]);
    }
}
1001c754:	e24bd004 	sub	sp, fp, #4
1001c758:	e8bd8800 	pop	{fp, pc}

1001c75c <rt_vbus_sess_dump>:

void rt_vbus_sess_dump(void)
{
1001c75c:	e92d4800 	push	{fp, lr}
1001c760:	e28db004 	add	fp, sp, #4
1001c764:	e24dd008 	sub	sp, sp, #8
    int i;

    rt_kprintf("vbus conn session:\n");
1001c768:	e304084c 	movw	r0, #18508	; 0x484c
1001c76c:	e3410003 	movt	r0, #4099	; 0x1003
1001c770:	ebffdcd2 	bl	10013ac0 <rt_kprintf>
    for (i = 0; i < ARRAY_SIZE(_sess); i++)
1001c774:	e3a03000 	mov	r3, #0
1001c778:	e50b3008 	str	r3, [fp, #-8]
1001c77c:	ea000030 	b	1001c844 <rt_vbus_sess_dump+0xe8>
    {
        rt_kprintf("%2d(%s):%s\n", i, _sess[i].req ? _sess[i].req->name : "",
1001c780:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001c784:	e3412003 	movt	r2, #4099	; 0x1003
1001c788:	e51b3008 	ldr	r3, [fp, #-8]
1001c78c:	e1a01003 	mov	r1, r3
1001c790:	e1a03181 	lsl	r3, r1, #3
1001c794:	e1a01003 	mov	r1, r3
1001c798:	e1a03101 	lsl	r3, r1, #2
1001c79c:	e0613003 	rsb	r3, r1, r3
1001c7a0:	e0823003 	add	r3, r2, r3
1001c7a4:	e2833010 	add	r3, r3, #16
1001c7a8:	e5933004 	ldr	r3, [r3, #4]
1001c7ac:	e3530000 	cmp	r3, #0
1001c7b0:	0a00000c 	beq	1001c7e8 <rt_vbus_sess_dump+0x8c>
1001c7b4:	e30d2ef0 	movw	r2, #57072	; 0xdef0
1001c7b8:	e3412003 	movt	r2, #4099	; 0x1003
1001c7bc:	e51b3008 	ldr	r3, [fp, #-8]
1001c7c0:	e1a01003 	mov	r1, r3
1001c7c4:	e1a03181 	lsl	r3, r1, #3
1001c7c8:	e1a01003 	mov	r1, r3
1001c7cc:	e1a03101 	lsl	r3, r1, #2
1001c7d0:	e0613003 	rsb	r3, r1, r3
1001c7d4:	e0823003 	add	r3, r2, r3
1001c7d8:	e2833010 	add	r3, r3, #16
1001c7dc:	e5933004 	ldr	r3, [r3, #4]
1001c7e0:	e5932004 	ldr	r2, [r3, #4]
1001c7e4:	ea000001 	b	1001c7f0 <rt_vbus_sess_dump+0x94>
1001c7e8:	e3042860 	movw	r2, #18528	; 0x4860
1001c7ec:	e3412003 	movt	r2, #4099	; 0x1003
                   rt_vbus_sess_st2str[_sess[i].st]);
1001c7f0:	e30d1ef0 	movw	r1, #57072	; 0xdef0
1001c7f4:	e3411003 	movt	r1, #4099	; 0x1003
1001c7f8:	e51b3008 	ldr	r3, [fp, #-8]
1001c7fc:	e1a00003 	mov	r0, r3
1001c800:	e1a03180 	lsl	r3, r0, #3
1001c804:	e1a00003 	mov	r0, r3
1001c808:	e1a03100 	lsl	r3, r0, #2
1001c80c:	e0603003 	rsb	r3, r0, r3
1001c810:	e0813003 	add	r3, r1, r3
1001c814:	e5d33004 	ldrb	r3, [r3, #4]
    int i;

    rt_kprintf("vbus conn session:\n");
    for (i = 0; i < ARRAY_SIZE(_sess); i++)
    {
        rt_kprintf("%2d(%s):%s\n", i, _sess[i].req ? _sess[i].req->name : "",
1001c818:	e1a01003 	mov	r1, r3
1001c81c:	e3063920 	movw	r3, #26912	; 0x6920
1001c820:	e3413003 	movt	r3, #4099	; 0x1003
1001c824:	e7933101 	ldr	r3, [r3, r1, lsl #2]
1001c828:	e3040864 	movw	r0, #18532	; 0x4864
1001c82c:	e3410003 	movt	r0, #4099	; 0x1003
1001c830:	e51b1008 	ldr	r1, [fp, #-8]
1001c834:	ebffdca1 	bl	10013ac0 <rt_kprintf>
void rt_vbus_sess_dump(void)
{
    int i;

    rt_kprintf("vbus conn session:\n");
    for (i = 0; i < ARRAY_SIZE(_sess); i++)
1001c838:	e51b3008 	ldr	r3, [fp, #-8]
1001c83c:	e2833001 	add	r3, r3, #1
1001c840:	e50b3008 	str	r3, [fp, #-8]
1001c844:	e51b3008 	ldr	r3, [fp, #-8]
1001c848:	e353000f 	cmp	r3, #15
1001c84c:	9affffcb 	bls	1001c780 <rt_vbus_sess_dump+0x24>
    {
        rt_kprintf("%2d(%s):%s\n", i, _sess[i].req ? _sess[i].req->name : "",
                   rt_vbus_sess_st2str[_sess[i].st]);
    }
}
1001c850:	e24bd004 	sub	sp, fp, #4
1001c854:	e8bd8800 	pop	{fp, pc}

1001c858 <rt_vbus_que_dump>:

void rt_vbus_que_dump(void)
{
1001c858:	e92d4800 	push	{fp, lr}
1001c85c:	e28db004 	add	fp, sp, #4
    rt_kprintf("out que:\n");
1001c860:	e3040870 	movw	r0, #18544	; 0x4870
1001c864:	e3410003 	movt	r0, #4099	; 0x1003
1001c868:	ebffdc94 	bl	10013ac0 <rt_kprintf>
    rt_prio_queue_dump(_bus_out_que);
1001c86c:	e3033244 	movw	r3, #12868	; 0x3244
1001c870:	e3413004 	movt	r3, #4100	; 0x1004
1001c874:	e5933000 	ldr	r3, [r3]
1001c878:	e1a00003 	mov	r0, r3
1001c87c:	ebfff603 	bl	1001a090 <rt_prio_queue_dump>
}
1001c880:	e8bd8800 	pop	{fp, pc}

1001c884 <rt_vbus_total_data_sz>:

unsigned int rt_vbus_total_data_sz(void)
{
1001c884:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001c888:	e28db000 	add	fp, sp, #0
#ifdef RT_VBUS_STATISTICS
    return _total_data_sz;
#else
    return (unsigned int)-1;
1001c88c:	e3e03000 	mvn	r3, #0
#endif
}
1001c890:	e1a00003 	mov	r0, r3
1001c894:	e24bd000 	sub	sp, fp, #0
1001c898:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001c89c:	e12fff1e 	bx	lr

1001c8a0 <rt_vbus_data_pkt_dump>:

void rt_vbus_data_pkt_dump(void)
{
1001c8a0:	e92d4800 	push	{fp, lr}
1001c8a4:	e28db004 	add	fp, sp, #4
1001c8a8:	e24dd008 	sub	sp, sp, #8
    int i;

    for (i = 0; i < ARRAY_SIZE(_bus_in_action); i++)
1001c8ac:	e3a03000 	mov	r3, #0
1001c8b0:	e50b3008 	str	r3, [fp, #-8]
1001c8b4:	ea00001c 	b	1001c92c <rt_vbus_data_pkt_dump+0x8c>
        struct rt_vbus_data *dp;

#ifdef RT_VBUS_STATISTICS
        rt_kprintf("%2d %4d: ", i, _bus_in_action_nr[i]);
#else
        rt_kprintf("%2d: ", i);
1001c8b8:	e304087c 	movw	r0, #18556	; 0x487c
1001c8bc:	e3410003 	movt	r0, #4099	; 0x1003
1001c8c0:	e51b1008 	ldr	r1, [fp, #-8]
1001c8c4:	ebffdc7d 	bl	10013ac0 <rt_kprintf>
#endif
        for (dp = _bus_in_action[i][_IN_ACT_HEAD];
1001c8c8:	e30d3db0 	movw	r3, #56752	; 0xddb0
1001c8cc:	e3413003 	movt	r3, #4099	; 0x1003
1001c8d0:	e51b2008 	ldr	r2, [fp, #-8]
1001c8d4:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001c8d8:	e50b300c 	str	r3, [fp, #-12]
1001c8dc:	ea000009 	b	1001c908 <rt_vbus_data_pkt_dump+0x68>
             dp;
             dp = dp->next)
        {
            rt_kprintf("%p(%d) -> ", dp, dp->size);
1001c8e0:	e51b300c 	ldr	r3, [fp, #-12]
1001c8e4:	e5d33000 	ldrb	r3, [r3]
1001c8e8:	e3040884 	movw	r0, #18564	; 0x4884
1001c8ec:	e3410003 	movt	r0, #4099	; 0x1003
1001c8f0:	e51b100c 	ldr	r1, [fp, #-12]
1001c8f4:	e1a02003 	mov	r2, r3
1001c8f8:	ebffdc70 	bl	10013ac0 <rt_kprintf>
#else
        rt_kprintf("%2d: ", i);
#endif
        for (dp = _bus_in_action[i][_IN_ACT_HEAD];
             dp;
             dp = dp->next)
1001c8fc:	e51b300c 	ldr	r3, [fp, #-12]
1001c900:	e5933004 	ldr	r3, [r3, #4]
1001c904:	e50b300c 	str	r3, [fp, #-12]
#ifdef RT_VBUS_STATISTICS
        rt_kprintf("%2d %4d: ", i, _bus_in_action_nr[i]);
#else
        rt_kprintf("%2d: ", i);
#endif
        for (dp = _bus_in_action[i][_IN_ACT_HEAD];
1001c908:	e51b300c 	ldr	r3, [fp, #-12]
1001c90c:	e3530000 	cmp	r3, #0
1001c910:	1afffff2 	bne	1001c8e0 <rt_vbus_data_pkt_dump+0x40>
             dp;
             dp = dp->next)
        {
            rt_kprintf("%p(%d) -> ", dp, dp->size);
        }
        rt_kprintf(" nil\n");
1001c914:	e3040890 	movw	r0, #18576	; 0x4890
1001c918:	e3410003 	movt	r0, #4099	; 0x1003
1001c91c:	ebffdc67 	bl	10013ac0 <rt_kprintf>

void rt_vbus_data_pkt_dump(void)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(_bus_in_action); i++)
1001c920:	e51b3008 	ldr	r3, [fp, #-8]
1001c924:	e2833001 	add	r3, r3, #1
1001c928:	e50b3008 	str	r3, [fp, #-8]
1001c92c:	e51b3008 	ldr	r3, [fp, #-8]
1001c930:	e353001f 	cmp	r3, #31
1001c934:	9affffdf 	bls	1001c8b8 <rt_vbus_data_pkt_dump+0x18>
        {
            rt_kprintf("%p(%d) -> ", dp, dp->size);
        }
        rt_kprintf(" nil\n");
    }
}
1001c938:	e24bd004 	sub	sp, fp, #4
1001c93c:	e8bd8800 	pop	{fp, pc}

1001c940 <_rx_indicate>:
#include <rtdevice.h>

#include "vbus.h"

static void _rx_indicate(void *ctx)
{
1001c940:	e92d4800 	push	{fp, lr}
1001c944:	e28db004 	add	fp, sp, #4
1001c948:	e24dd010 	sub	sp, sp, #16
1001c94c:	e50b0010 	str	r0, [fp, #-16]
    rt_device_t dev = ctx;
1001c950:	e51b3010 	ldr	r3, [fp, #-16]
1001c954:	e50b3008 	str	r3, [fp, #-8]

    if (dev->rx_indicate)
1001c958:	e51b3008 	ldr	r3, [fp, #-8]
1001c95c:	e5933018 	ldr	r3, [r3, #24]
1001c960:	e3530000 	cmp	r3, #0
1001c964:	0a000004 	beq	1001c97c <_rx_indicate+0x3c>
        dev->rx_indicate(dev, 0);
1001c968:	e51b3008 	ldr	r3, [fp, #-8]
1001c96c:	e5933018 	ldr	r3, [r3, #24]
1001c970:	e51b0008 	ldr	r0, [fp, #-8]
1001c974:	e3a01000 	mov	r1, #0
1001c978:	e12fff33 	blx	r3
}
1001c97c:	e24bd004 	sub	sp, fp, #4
1001c980:	e8bd8800 	pop	{fp, pc}

1001c984 <_tx_complete>:

static void _tx_complete(void *ctx)
{
1001c984:	e92d4800 	push	{fp, lr}
1001c988:	e28db004 	add	fp, sp, #4
1001c98c:	e24dd010 	sub	sp, sp, #16
1001c990:	e50b0010 	str	r0, [fp, #-16]
    rt_device_t dev = ctx;
1001c994:	e51b3010 	ldr	r3, [fp, #-16]
1001c998:	e50b3008 	str	r3, [fp, #-8]

    if (dev->tx_complete)
1001c99c:	e51b3008 	ldr	r3, [fp, #-8]
1001c9a0:	e593301c 	ldr	r3, [r3, #28]
1001c9a4:	e3530000 	cmp	r3, #0
1001c9a8:	0a000004 	beq	1001c9c0 <_tx_complete+0x3c>
        dev->tx_complete(dev, 0);
1001c9ac:	e51b3008 	ldr	r3, [fp, #-8]
1001c9b0:	e593301c 	ldr	r3, [r3, #28]
1001c9b4:	e51b0008 	ldr	r0, [fp, #-8]
1001c9b8:	e3a01000 	mov	r1, #0
1001c9bc:	e12fff33 	blx	r3
}
1001c9c0:	e24bd004 	sub	sp, fp, #4
1001c9c4:	e8bd8800 	pop	{fp, pc}

1001c9c8 <_open>:

static rt_err_t _open(rt_device_t dev, rt_uint16_t oflag)
{
1001c9c8:	e92d4800 	push	{fp, lr}
1001c9cc:	e28db004 	add	fp, sp, #4
1001c9d0:	e24dd010 	sub	sp, sp, #16
1001c9d4:	e50b0010 	str	r0, [fp, #-16]
1001c9d8:	e1a03001 	mov	r3, r1
1001c9dc:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    int chnr;
    struct rt_vbus_dev *vdev = dev->user_data;
1001c9e0:	e51b3010 	ldr	r3, [fp, #-16]
1001c9e4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1001c9e8:	e50b3008 	str	r3, [fp, #-8]

    if (vdev->chnr)
1001c9ec:	e51b3008 	ldr	r3, [fp, #-8]
1001c9f0:	e5d33000 	ldrb	r3, [r3]
1001c9f4:	e3530000 	cmp	r3, #0
1001c9f8:	0a000001 	beq	1001ca04 <_open+0x3c>
        return RT_EOK;
1001c9fc:	e3a03000 	mov	r3, #0
1001ca00:	ea00001f 	b	1001ca84 <_open+0xbc>

    /* FIXME: request the same name for twice will crash */
    chnr = rt_vbus_request_chn(&vdev->req, RT_WAITING_FOREVER);
1001ca04:	e51b3008 	ldr	r3, [fp, #-8]
1001ca08:	e283300c 	add	r3, r3, #12
1001ca0c:	e1a00003 	mov	r0, r3
1001ca10:	e3e01000 	mvn	r1, #0
1001ca14:	ebfffbdb 	bl	1001b988 <rt_vbus_request_chn>
1001ca18:	e50b000c 	str	r0, [fp, #-12]
    if (chnr < 0)
1001ca1c:	e51b300c 	ldr	r3, [fp, #-12]
1001ca20:	e3530000 	cmp	r3, #0
1001ca24:	aa000001 	bge	1001ca30 <_open+0x68>
        return chnr;
1001ca28:	e51b300c 	ldr	r3, [fp, #-12]
1001ca2c:	ea000014 	b	1001ca84 <_open+0xbc>

    vdev->chnr = chnr;
1001ca30:	e51b300c 	ldr	r3, [fp, #-12]
1001ca34:	e6ef2073 	uxtb	r2, r3
1001ca38:	e51b3008 	ldr	r3, [fp, #-8]
1001ca3c:	e5c32000 	strb	r2, [r3]
    rt_vbus_register_listener(chnr, RT_VBUS_EVENT_ID_RX, _rx_indicate, dev);
1001ca40:	e51b300c 	ldr	r3, [fp, #-12]
1001ca44:	e6ef3073 	uxtb	r3, r3
1001ca48:	e1a00003 	mov	r0, r3
1001ca4c:	e3a01000 	mov	r1, #0
1001ca50:	e30c2940 	movw	r2, #51520	; 0xc940
1001ca54:	e3412001 	movt	r2, #4097	; 0x1001
1001ca58:	e51b3010 	ldr	r3, [fp, #-16]
1001ca5c:	ebfff626 	bl	1001a2fc <rt_vbus_register_listener>
    rt_vbus_register_listener(chnr, RT_VBUS_EVENT_ID_TX, _tx_complete, dev);
1001ca60:	e51b300c 	ldr	r3, [fp, #-12]
1001ca64:	e6ef3073 	uxtb	r3, r3
1001ca68:	e1a00003 	mov	r0, r3
1001ca6c:	e3a01001 	mov	r1, #1
1001ca70:	e30c2984 	movw	r2, #51588	; 0xc984
1001ca74:	e3412001 	movt	r2, #4097	; 0x1001
1001ca78:	e51b3010 	ldr	r3, [fp, #-16]
1001ca7c:	ebfff61e 	bl	1001a2fc <rt_vbus_register_listener>

    return RT_EOK;
1001ca80:	e3a03000 	mov	r3, #0
}
1001ca84:	e1a00003 	mov	r0, r3
1001ca88:	e24bd004 	sub	sp, fp, #4
1001ca8c:	e8bd8800 	pop	{fp, pc}

1001ca90 <_close>:

static rt_err_t _close(rt_device_t dev)
{
1001ca90:	e92d4800 	push	{fp, lr}
1001ca94:	e28db004 	add	fp, sp, #4
1001ca98:	e24dd010 	sub	sp, sp, #16
1001ca9c:	e50b0010 	str	r0, [fp, #-16]
    struct rt_vbus_dev *vdev = dev->user_data;
1001caa0:	e51b3010 	ldr	r3, [fp, #-16]
1001caa4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1001caa8:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(vdev->chnr != 0);
1001caac:	e51b3008 	ldr	r3, [fp, #-8]
1001cab0:	e5d33000 	ldrb	r3, [r3]
1001cab4:	e3530000 	cmp	r3, #0
1001cab8:	1a000005 	bne	1001cad4 <_close+0x44>
1001cabc:	e3040954 	movw	r0, #18772	; 0x4954
1001cac0:	e3410003 	movt	r0, #4099	; 0x1003
1001cac4:	e304196c 	movw	r1, #18796	; 0x496c
1001cac8:	e3411003 	movt	r1, #4099	; 0x1003
1001cacc:	e3a0204c 	mov	r2, #76	; 0x4c
1001cad0:	ebffdcb7 	bl	10013db4 <rt_assert_handler>

    rt_vbus_close_chn(vdev->chnr);
1001cad4:	e51b3008 	ldr	r3, [fp, #-8]
1001cad8:	e5d33000 	ldrb	r3, [r3]
1001cadc:	e1a00003 	mov	r0, r3
1001cae0:	ebfffc98 	bl	1001bd48 <rt_vbus_close_chn>
    vdev->chnr = 0;
1001cae4:	e51b3008 	ldr	r3, [fp, #-8]
1001cae8:	e3a02000 	mov	r2, #0
1001caec:	e5c32000 	strb	r2, [r3]

    return RT_EOK;
1001caf0:	e3a03000 	mov	r3, #0
}
1001caf4:	e1a00003 	mov	r0, r3
1001caf8:	e24bd004 	sub	sp, fp, #4
1001cafc:	e8bd8800 	pop	{fp, pc}

1001cb00 <_read>:

static rt_size_t _read(rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size)
{
1001cb00:	e92d4800 	push	{fp, lr}
1001cb04:	e28db004 	add	fp, sp, #4
1001cb08:	e24dd020 	sub	sp, sp, #32
1001cb0c:	e50b0018 	str	r0, [fp, #-24]
1001cb10:	e50b101c 	str	r1, [fp, #-28]
1001cb14:	e50b2020 	str	r2, [fp, #-32]
1001cb18:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    rt_size_t outsz = 0;
1001cb1c:	e3a03000 	mov	r3, #0
1001cb20:	e50b3008 	str	r3, [fp, #-8]
    struct rt_vbus_dev *vdev = dev->user_data;
1001cb24:	e51b3018 	ldr	r3, [fp, #-24]
1001cb28:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1001cb2c:	e50b3014 	str	r3, [fp, #-20]

    RT_ASSERT(vdev->chnr != 0);
1001cb30:	e51b3014 	ldr	r3, [fp, #-20]
1001cb34:	e5d33000 	ldrb	r3, [r3]
1001cb38:	e3530000 	cmp	r3, #0
1001cb3c:	1a000005 	bne	1001cb58 <_read+0x58>
1001cb40:	e3040954 	movw	r0, #18772	; 0x4954
1001cb44:	e3410003 	movt	r0, #4099	; 0x1003
1001cb48:	e3041974 	movw	r1, #18804	; 0x4974
1001cb4c:	e3411003 	movt	r1, #4099	; 0x1003
1001cb50:	e3a02059 	mov	r2, #89	; 0x59
1001cb54:	ebffdc96 	bl	10013db4 <rt_assert_handler>

    if (vdev->act == RT_NULL)
1001cb58:	e51b3014 	ldr	r3, [fp, #-20]
1001cb5c:	e5933004 	ldr	r3, [r3, #4]
1001cb60:	e3530000 	cmp	r3, #0
1001cb64:	1a000009 	bne	1001cb90 <_read+0x90>
    {
        vdev->act = rt_vbus_data_pop(vdev->chnr);
1001cb68:	e51b3014 	ldr	r3, [fp, #-20]
1001cb6c:	e5d33000 	ldrb	r3, [r3]
1001cb70:	e1a00003 	mov	r0, r3
1001cb74:	ebfff853 	bl	1001acc8 <rt_vbus_data_pop>
1001cb78:	e1a02000 	mov	r2, r0
1001cb7c:	e51b3014 	ldr	r3, [fp, #-20]
1001cb80:	e5832004 	str	r2, [r3, #4]
        vdev->pos = 0;
1001cb84:	e51b3014 	ldr	r3, [fp, #-20]
1001cb88:	e3a02000 	mov	r2, #0
1001cb8c:	e5832008 	str	r2, [r3, #8]

    while (1)
    {
        rt_err_t err;

        while (vdev->act)
1001cb90:	ea00004d 	b	1001cccc <_read+0x1cc>
        {
            rt_size_t cpysz;

            if (size - outsz > vdev->act->size - vdev->pos)
1001cb94:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1001cb98:	e51b3008 	ldr	r3, [fp, #-8]
1001cb9c:	e0632002 	rsb	r2, r3, r2
1001cba0:	e51b3014 	ldr	r3, [fp, #-20]
1001cba4:	e5933004 	ldr	r3, [r3, #4]
1001cba8:	e5d33000 	ldrb	r3, [r3]
1001cbac:	e1a01003 	mov	r1, r3
1001cbb0:	e51b3014 	ldr	r3, [fp, #-20]
1001cbb4:	e5933008 	ldr	r3, [r3, #8]
1001cbb8:	e0633001 	rsb	r3, r3, r1
1001cbbc:	e1520003 	cmp	r2, r3
1001cbc0:	9a000008 	bls	1001cbe8 <_read+0xe8>
                cpysz = vdev->act->size - vdev->pos;
1001cbc4:	e51b3014 	ldr	r3, [fp, #-20]
1001cbc8:	e5933004 	ldr	r3, [r3, #4]
1001cbcc:	e5d33000 	ldrb	r3, [r3]
1001cbd0:	e1a02003 	mov	r2, r3
1001cbd4:	e51b3014 	ldr	r3, [fp, #-20]
1001cbd8:	e5933008 	ldr	r3, [r3, #8]
1001cbdc:	e0633002 	rsb	r3, r3, r2
1001cbe0:	e50b3010 	str	r3, [fp, #-16]
1001cbe4:	ea000003 	b	1001cbf8 <_read+0xf8>
            else
                cpysz = size - outsz;/*get the lower value*/
1001cbe8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1001cbec:	e51b3008 	ldr	r3, [fp, #-8]
1001cbf0:	e0633002 	rsb	r3, r3, r2
1001cbf4:	e50b3010 	str	r3, [fp, #-16]

            rt_memcpy((char*)buffer + outsz, ((char*)(vdev->act+1)) + vdev->pos, cpysz);
1001cbf8:	e51b2020 	ldr	r2, [fp, #-32]
1001cbfc:	e51b3008 	ldr	r3, [fp, #-8]
1001cc00:	e0821003 	add	r1, r2, r3
1001cc04:	e51b3014 	ldr	r3, [fp, #-20]
1001cc08:	e5932004 	ldr	r2, [r3, #4]
1001cc0c:	e51b3014 	ldr	r3, [fp, #-20]
1001cc10:	e5933008 	ldr	r3, [r3, #8]
1001cc14:	e2833008 	add	r3, r3, #8
1001cc18:	e0823003 	add	r3, r2, r3
1001cc1c:	e1a00001 	mov	r0, r1
1001cc20:	e1a01003 	mov	r1, r3
1001cc24:	e51b2010 	ldr	r2, [fp, #-16]
1001cc28:	ebffd5e2 	bl	100123b8 <rt_memcpy>
            vdev->pos += cpysz;
1001cc2c:	e51b3014 	ldr	r3, [fp, #-20]
1001cc30:	e5932008 	ldr	r2, [r3, #8]
1001cc34:	e51b3010 	ldr	r3, [fp, #-16]
1001cc38:	e0822003 	add	r2, r2, r3
1001cc3c:	e51b3014 	ldr	r3, [fp, #-20]
1001cc40:	e5832008 	str	r2, [r3, #8]

            outsz += cpysz;
1001cc44:	e51b2008 	ldr	r2, [fp, #-8]
1001cc48:	e51b3010 	ldr	r3, [fp, #-16]
1001cc4c:	e0823003 	add	r3, r2, r3
1001cc50:	e50b3008 	str	r3, [fp, #-8]
            if (outsz == size)
1001cc54:	e51b2008 	ldr	r2, [fp, #-8]
1001cc58:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1001cc5c:	e1520003 	cmp	r2, r3
1001cc60:	1a000001 	bne	1001cc6c <_read+0x16c>
            {
                return outsz;
1001cc64:	e51b3008 	ldr	r3, [fp, #-8]
1001cc68:	ea00003e 	b	1001cd68 <_read+0x268>
            }
            else if (outsz > size)
1001cc6c:	e51b2008 	ldr	r2, [fp, #-8]
1001cc70:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1001cc74:	e1520003 	cmp	r2, r3
1001cc78:	9a000005 	bls	1001cc94 <_read+0x194>
                RT_ASSERT(0);
1001cc7c:	e3040964 	movw	r0, #18788	; 0x4964
1001cc80:	e3410003 	movt	r0, #4099	; 0x1003
1001cc84:	e3041974 	movw	r1, #18804	; 0x4974
1001cc88:	e3411003 	movt	r1, #4099	; 0x1003
1001cc8c:	e3a02077 	mov	r2, #119	; 0x77
1001cc90:	ebffdc47 	bl	10013db4 <rt_assert_handler>

            /* free old and get new */
            rt_free(vdev->act);
1001cc94:	e51b3014 	ldr	r3, [fp, #-20]
1001cc98:	e5933004 	ldr	r3, [r3, #4]
1001cc9c:	e1a00003 	mov	r0, r3
1001cca0:	ebffdf96 	bl	10014b00 <rt_free>
            vdev->act = rt_vbus_data_pop(vdev->chnr);
1001cca4:	e51b3014 	ldr	r3, [fp, #-20]
1001cca8:	e5d33000 	ldrb	r3, [r3]
1001ccac:	e1a00003 	mov	r0, r3
1001ccb0:	ebfff804 	bl	1001acc8 <rt_vbus_data_pop>
1001ccb4:	e1a02000 	mov	r2, r0
1001ccb8:	e51b3014 	ldr	r3, [fp, #-20]
1001ccbc:	e5832004 	str	r2, [r3, #4]
            vdev->pos = 0;
1001ccc0:	e51b3014 	ldr	r3, [fp, #-20]
1001ccc4:	e3a02000 	mov	r2, #0
1001ccc8:	e5832008 	str	r2, [r3, #8]

    while (1)
    {
        rt_err_t err;

        while (vdev->act)
1001cccc:	e51b3014 	ldr	r3, [fp, #-20]
1001ccd0:	e5933004 	ldr	r3, [r3, #4]
1001ccd4:	e3530000 	cmp	r3, #0
1001ccd8:	1affffad 	bne	1001cb94 <_read+0x94>
        }

        /* TODO: We don't want to touch the rx_indicate here. But this lead to
         * some duplication. Maybe we should find a better way to handle this.
         */
        if (rt_interrupt_get_nest() == 0)
1001ccdc:	ebffd507 	bl	10012100 <rt_interrupt_get_nest>
1001cce0:	e1a03000 	mov	r3, r0
1001cce4:	e3530000 	cmp	r3, #0
1001cce8:	1a000006 	bne	1001cd08 <_read+0x208>
        {
            err = rt_vbus_listen_on(vdev->chnr, RT_WAITING_FOREVER);
1001ccec:	e51b3014 	ldr	r3, [fp, #-20]
1001ccf0:	e5d33000 	ldrb	r3, [r3]
1001ccf4:	e1a00003 	mov	r0, r3
1001ccf8:	e3e01000 	mvn	r1, #0
1001ccfc:	ebfff792 	bl	1001ab4c <rt_vbus_listen_on>
1001cd00:	e50b000c 	str	r0, [fp, #-12]
1001cd04:	ea000005 	b	1001cd20 <_read+0x220>
        }
        else
        {
            err = rt_vbus_listen_on(vdev->chnr, 0);
1001cd08:	e51b3014 	ldr	r3, [fp, #-20]
1001cd0c:	e5d33000 	ldrb	r3, [r3]
1001cd10:	e1a00003 	mov	r0, r3
1001cd14:	e3a01000 	mov	r1, #0
1001cd18:	ebfff78b 	bl	1001ab4c <rt_vbus_listen_on>
1001cd1c:	e50b000c 	str	r0, [fp, #-12]
        }
        if (err != RT_EOK)
1001cd20:	e51b300c 	ldr	r3, [fp, #-12]
1001cd24:	e3530000 	cmp	r3, #0
1001cd28:	0a000003 	beq	1001cd3c <_read+0x23c>
        {
            rt_set_errno(err);
1001cd2c:	e51b000c 	ldr	r0, [fp, #-12]
1001cd30:	ebffd515 	bl	1001218c <rt_set_errno>
            return outsz;
1001cd34:	e51b3008 	ldr	r3, [fp, #-8]
1001cd38:	ea00000a 	b	1001cd68 <_read+0x268>
        }
        vdev->act = rt_vbus_data_pop(vdev->chnr);
1001cd3c:	e51b3014 	ldr	r3, [fp, #-20]
1001cd40:	e5d33000 	ldrb	r3, [r3]
1001cd44:	e1a00003 	mov	r0, r3
1001cd48:	ebfff7de 	bl	1001acc8 <rt_vbus_data_pop>
1001cd4c:	e1a02000 	mov	r2, r0
1001cd50:	e51b3014 	ldr	r3, [fp, #-20]
1001cd54:	e5832004 	str	r2, [r3, #4]
        vdev->pos = 0;
1001cd58:	e51b3014 	ldr	r3, [fp, #-20]
1001cd5c:	e3a02000 	mov	r2, #0
1001cd60:	e5832008 	str	r2, [r3, #8]
    }
1001cd64:	eaffff89 	b	1001cb90 <_read+0x90>
}
1001cd68:	e1a00003 	mov	r0, r3
1001cd6c:	e24bd004 	sub	sp, fp, #4
1001cd70:	e8bd8800 	pop	{fp, pc}

1001cd74 <_write>:

static rt_size_t _write(rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size)
{
1001cd74:	e92d4800 	push	{fp, lr}
1001cd78:	e28db004 	add	fp, sp, #4
1001cd7c:	e24dd020 	sub	sp, sp, #32
1001cd80:	e50b0010 	str	r0, [fp, #-16]
1001cd84:	e50b1014 	str	r1, [fp, #-20]
1001cd88:	e50b2018 	str	r2, [fp, #-24]
1001cd8c:	e50b301c 	str	r3, [fp, #-28]
    rt_err_t err;
    struct rt_vbus_dev *vdev = dev->user_data;
1001cd90:	e51b3010 	ldr	r3, [fp, #-16]
1001cd94:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1001cd98:	e50b300c 	str	r3, [fp, #-12]

    RT_ASSERT(vdev->chnr != 0);
1001cd9c:	e51b300c 	ldr	r3, [fp, #-12]
1001cda0:	e5d33000 	ldrb	r3, [r3]
1001cda4:	e3530000 	cmp	r3, #0
1001cda8:	1a000005 	bne	1001cdc4 <_write+0x50>
1001cdac:	e3040954 	movw	r0, #18772	; 0x4954
1001cdb0:	e3410003 	movt	r0, #4099	; 0x1003
1001cdb4:	e304197c 	movw	r1, #18812	; 0x497c
1001cdb8:	e3411003 	movt	r1, #4099	; 0x1003
1001cdbc:	e3a02099 	mov	r2, #153	; 0x99
1001cdc0:	ebffdbfb 	bl	10013db4 <rt_assert_handler>

    if (rt_interrupt_get_nest() == 0)
1001cdc4:	ebffd4cd 	bl	10012100 <rt_interrupt_get_nest>
1001cdc8:	e1a03000 	mov	r3, r0
1001cdcc:	e3530000 	cmp	r3, #0
1001cdd0:	1a00000c 	bne	1001ce08 <_write+0x94>
    {
        /* Thread context. */
        err = rt_vbus_post(vdev->chnr, vdev->req.prio,
1001cdd4:	e51b300c 	ldr	r3, [fp, #-12]
1001cdd8:	e5d31000 	ldrb	r1, [r3]
1001cddc:	e51b300c 	ldr	r3, [fp, #-12]
1001cde0:	e5d3200c 	ldrb	r2, [r3, #12]
1001cde4:	e3e03000 	mvn	r3, #0
1001cde8:	e58d3000 	str	r3, [sp]
1001cdec:	e1a00001 	mov	r0, r1
1001cdf0:	e1a01002 	mov	r1, r2
1001cdf4:	e51b2018 	ldr	r2, [fp, #-24]
1001cdf8:	e51b301c 	ldr	r3, [fp, #-28]
1001cdfc:	ebfff68c 	bl	1001a834 <rt_vbus_post>
1001ce00:	e50b0008 	str	r0, [fp, #-8]
1001ce04:	ea00000b 	b	1001ce38 <_write+0xc4>
                           buffer, size, RT_WAITING_FOREVER);
    }
    else
    {
        /* Interrupt context. */
        err = rt_vbus_post(vdev->chnr, vdev->req.prio,
1001ce08:	e51b300c 	ldr	r3, [fp, #-12]
1001ce0c:	e5d31000 	ldrb	r1, [r3]
1001ce10:	e51b300c 	ldr	r3, [fp, #-12]
1001ce14:	e5d3200c 	ldrb	r2, [r3, #12]
1001ce18:	e3a03000 	mov	r3, #0
1001ce1c:	e58d3000 	str	r3, [sp]
1001ce20:	e1a00001 	mov	r0, r1
1001ce24:	e1a01002 	mov	r1, r2
1001ce28:	e51b2018 	ldr	r2, [fp, #-24]
1001ce2c:	e51b301c 	ldr	r3, [fp, #-28]
1001ce30:	ebfff67f 	bl	1001a834 <rt_vbus_post>
1001ce34:	e50b0008 	str	r0, [fp, #-8]
                           buffer, size, 0);
    }

    if (err)
1001ce38:	e51b3008 	ldr	r3, [fp, #-8]
1001ce3c:	e3530000 	cmp	r3, #0
1001ce40:	0a000003 	beq	1001ce54 <_write+0xe0>
    {
        rt_set_errno(err);
1001ce44:	e51b0008 	ldr	r0, [fp, #-8]
1001ce48:	ebffd4cf 	bl	1001218c <rt_set_errno>
        return 0;
1001ce4c:	e3a03000 	mov	r3, #0
1001ce50:	ea000000 	b	1001ce58 <_write+0xe4>
    }

    return size;
1001ce54:	e51b301c 	ldr	r3, [fp, #-28]
}
1001ce58:	e1a00003 	mov	r0, r3
1001ce5c:	e24bd004 	sub	sp, fp, #4
1001ce60:	e8bd8800 	pop	{fp, pc}

1001ce64 <_control>:

rt_err_t  _control(rt_device_t dev, rt_uint8_t cmd, void *args)
{
1001ce64:	e92d4800 	push	{fp, lr}
1001ce68:	e28db004 	add	fp, sp, #4
1001ce6c:	e24dd018 	sub	sp, sp, #24
1001ce70:	e50b0010 	str	r0, [fp, #-16]
1001ce74:	e1a03001 	mov	r3, r1
1001ce78:	e50b2018 	str	r2, [fp, #-24]
1001ce7c:	e54b3011 	strb	r3, [fp, #-17]
    RT_ASSERT(dev);
1001ce80:	e51b3010 	ldr	r3, [fp, #-16]
1001ce84:	e3530000 	cmp	r3, #0
1001ce88:	1a000005 	bne	1001cea4 <_control+0x40>
1001ce8c:	e3040968 	movw	r0, #18792	; 0x4968
1001ce90:	e3410003 	movt	r0, #4099	; 0x1003
1001ce94:	e3041984 	movw	r1, #18820	; 0x4984
1001ce98:	e3411003 	movt	r1, #4099	; 0x1003
1001ce9c:	e3a020b3 	mov	r2, #179	; 0xb3
1001cea0:	ebffdbc3 	bl	10013db4 <rt_assert_handler>

    switch (cmd) {
1001cea4:	e55b3011 	ldrb	r3, [fp, #-17]
1001cea8:	e35300d3 	cmp	r3, #211	; 0xd3
1001ceac:	0a000002 	beq	1001cebc <_control+0x58>
        return RT_EOK;
    }
        break;
#endif
    default:
        break;
1001ceb0:	e1a00000 	nop			; (mov r0, r0)
    };

    return -RT_ENOSYS;
1001ceb4:	e3e03005 	mvn	r3, #5
1001ceb8:	ea00001d 	b	1001cf34 <_control+0xd0>
{
    RT_ASSERT(dev);

    switch (cmd) {
    case VBUS_IOC_LISCFG: {
        struct rt_vbus_dev *vdev = dev->user_data;
1001cebc:	e51b3010 	ldr	r3, [fp, #-16]
1001cec0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1001cec4:	e50b3008 	str	r3, [fp, #-8]
        struct rt_vbus_dev_liscfg *liscfg = args;
1001cec8:	e51b3018 	ldr	r3, [fp, #-24]
1001cecc:	e50b300c 	str	r3, [fp, #-12]

        RT_ASSERT(vdev->chnr != 0);
1001ced0:	e51b3008 	ldr	r3, [fp, #-8]
1001ced4:	e5d33000 	ldrb	r3, [r3]
1001ced8:	e3530000 	cmp	r3, #0
1001cedc:	1a000005 	bne	1001cef8 <_control+0x94>
1001cee0:	e3040954 	movw	r0, #18772	; 0x4954
1001cee4:	e3410003 	movt	r0, #4099	; 0x1003
1001cee8:	e3041984 	movw	r1, #18820	; 0x4984
1001ceec:	e3411003 	movt	r1, #4099	; 0x1003
1001cef0:	e3a020ba 	mov	r2, #186	; 0xba
1001cef4:	ebffdbae 	bl	10013db4 <rt_assert_handler>
        if (!liscfg)
1001cef8:	e51b300c 	ldr	r3, [fp, #-12]
1001cefc:	e3530000 	cmp	r3, #0
1001cf00:	1a000001 	bne	1001cf0c <_control+0xa8>
            return -RT_ERROR;
1001cf04:	e3e03000 	mvn	r3, #0
1001cf08:	ea000009 	b	1001cf34 <_control+0xd0>

        rt_vbus_register_listener(vdev->chnr, liscfg->event,
1001cf0c:	e51b3008 	ldr	r3, [fp, #-8]
1001cf10:	e5d30000 	ldrb	r0, [r3]
1001cf14:	e51b300c 	ldr	r3, [fp, #-12]
1001cf18:	e5d31000 	ldrb	r1, [r3]
1001cf1c:	e51b300c 	ldr	r3, [fp, #-12]
1001cf20:	e5932004 	ldr	r2, [r3, #4]
1001cf24:	e51b300c 	ldr	r3, [fp, #-12]
1001cf28:	e5933008 	ldr	r3, [r3, #8]
1001cf2c:	ebfff4f2 	bl	1001a2fc <rt_vbus_register_listener>
                                  liscfg->listener, liscfg->ctx);
        return RT_EOK;
1001cf30:	e3a03000 	mov	r3, #0
    default:
        break;
    };

    return -RT_ENOSYS;
}
1001cf34:	e1a00003 	mov	r0, r3
1001cf38:	e24bd004 	sub	sp, fp, #4
1001cf3c:	e8bd8800 	pop	{fp, pc}

1001cf40 <rt_vbus_get_chnnr>:

rt_uint8_t rt_vbus_get_chnnr(rt_device_t dev)
{
1001cf40:	e92d4800 	push	{fp, lr}
1001cf44:	e28db004 	add	fp, sp, #4
1001cf48:	e24dd010 	sub	sp, sp, #16
1001cf4c:	e50b0010 	str	r0, [fp, #-16]
    struct rt_vbus_dev *vdev;

    RT_ASSERT(dev);
1001cf50:	e51b3010 	ldr	r3, [fp, #-16]
1001cf54:	e3530000 	cmp	r3, #0
1001cf58:	1a000005 	bne	1001cf74 <rt_vbus_get_chnnr+0x34>
1001cf5c:	e3040968 	movw	r0, #18792	; 0x4968
1001cf60:	e3410003 	movt	r0, #4099	; 0x1003
1001cf64:	e3041990 	movw	r1, #18832	; 0x4990
1001cf68:	e3411003 	movt	r1, #4099	; 0x1003
1001cf6c:	e3a020f2 	mov	r2, #242	; 0xf2
1001cf70:	ebffdb8f 	bl	10013db4 <rt_assert_handler>

    vdev = dev->user_data;
1001cf74:	e51b3010 	ldr	r3, [fp, #-16]
1001cf78:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1001cf7c:	e50b3008 	str	r3, [fp, #-8]

    return vdev->chnr;
1001cf80:	e51b3008 	ldr	r3, [fp, #-8]
1001cf84:	e5d33000 	ldrb	r3, [r3]
}
1001cf88:	e1a00003 	mov	r0, r3
1001cf8c:	e24bd004 	sub	sp, fp, #4
1001cf90:	e8bd8800 	pop	{fp, pc}

1001cf94 <rt_vbus_chnx_register_disconn>:

void rt_vbus_chnx_register_disconn(rt_device_t dev,
                                   rt_vbus_event_listener indi,
                                   void *ctx)
{
1001cf94:	e92d4800 	push	{fp, lr}
1001cf98:	e28db004 	add	fp, sp, #4
1001cf9c:	e24dd018 	sub	sp, sp, #24
1001cfa0:	e50b0010 	str	r0, [fp, #-16]
1001cfa4:	e50b1014 	str	r1, [fp, #-20]
1001cfa8:	e50b2018 	str	r2, [fp, #-24]
    struct rt_vbus_dev *vdev = dev->user_data;
1001cfac:	e51b3010 	ldr	r3, [fp, #-16]
1001cfb0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1001cfb4:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(vdev->chnr != 0);
1001cfb8:	e51b3008 	ldr	r3, [fp, #-8]
1001cfbc:	e5d33000 	ldrb	r3, [r3]
1001cfc0:	e3530000 	cmp	r3, #0
1001cfc4:	1a000005 	bne	1001cfe0 <rt_vbus_chnx_register_disconn+0x4c>
1001cfc8:	e3040954 	movw	r0, #18772	; 0x4954
1001cfcc:	e3410003 	movt	r0, #4099	; 0x1003
1001cfd0:	e30419a4 	movw	r1, #18852	; 0x49a4
1001cfd4:	e3411003 	movt	r1, #4099	; 0x1003
1001cfd8:	e3a020ff 	mov	r2, #255	; 0xff
1001cfdc:	ebffdb74 	bl	10013db4 <rt_assert_handler>

    if (vdev)
1001cfe0:	e51b3008 	ldr	r3, [fp, #-8]
1001cfe4:	e3530000 	cmp	r3, #0
1001cfe8:	0a000006 	beq	1001d008 <rt_vbus_chnx_register_disconn+0x74>
        rt_vbus_register_listener(vdev->chnr, RT_VBUS_EVENT_ID_DISCONN,
1001cfec:	e51b3008 	ldr	r3, [fp, #-8]
1001cff0:	e5d33000 	ldrb	r3, [r3]
1001cff4:	e1a00003 	mov	r0, r3
1001cff8:	e3a01002 	mov	r1, #2
1001cffc:	e51b2014 	ldr	r2, [fp, #-20]
1001d000:	e51b3018 	ldr	r3, [fp, #-24]
1001d004:	ebfff4bc 	bl	1001a2fc <rt_vbus_register_listener>
                                  indi, ctx);
}
1001d008:	e24bd004 	sub	sp, fp, #4
1001d00c:	e8bd8800 	pop	{fp, pc}

1001d010 <rt_vbus_chnx_init>:

extern struct rt_vbus_dev rt_vbus_chn_devx[];
static struct rt_device _devx[32];

rt_err_t rt_vbus_chnx_init(void)
{
1001d010:	e92d4800 	push	{fp, lr}
1001d014:	e28db004 	add	fp, sp, #4
1001d018:	e24dd008 	sub	sp, sp, #8
    int i;
    struct rt_vbus_dev *p;

    for (i = 0,                   p = rt_vbus_chn_devx;
1001d01c:	e3a03000 	mov	r3, #0
1001d020:	e50b3008 	str	r3, [fp, #-8]
1001d024:	e3063828 	movw	r3, #26664	; 0x6828
1001d028:	e3413003 	movt	r3, #4099	; 0x1003
1001d02c:	e50b300c 	str	r3, [fp, #-12]
1001d030:	ea00006d 	b	1001d1ec <rt_vbus_chnx_init+0x1dc>
         i < ARRAY_SIZE(_devx) && p->req.name;
         i++,                     p++)
    {
        _devx[i].type      = RT_Device_Class_Char;
1001d034:	e30e2070 	movw	r2, #57456	; 0xe070
1001d038:	e3412003 	movt	r2, #4099	; 0x1003
1001d03c:	e51b3008 	ldr	r3, [fp, #-8]
1001d040:	e1a01003 	mov	r1, r3
1001d044:	e1a03101 	lsl	r3, r1, #2
1001d048:	e1a01003 	mov	r1, r3
1001d04c:	e1a03201 	lsl	r3, r1, #4
1001d050:	e0613003 	rsb	r3, r1, r3
1001d054:	e0823003 	add	r3, r2, r3
1001d058:	e2833010 	add	r3, r3, #16
1001d05c:	e3a02000 	mov	r2, #0
1001d060:	e5c32000 	strb	r2, [r3]
        _devx[i].open      = _open;
1001d064:	e30e2070 	movw	r2, #57456	; 0xe070
1001d068:	e3412003 	movt	r2, #4099	; 0x1003
1001d06c:	e51b3008 	ldr	r3, [fp, #-8]
1001d070:	e1a01003 	mov	r1, r3
1001d074:	e1a03101 	lsl	r3, r1, #2
1001d078:	e1a01003 	mov	r1, r3
1001d07c:	e1a03201 	lsl	r3, r1, #4
1001d080:	e0613003 	rsb	r3, r1, r3
1001d084:	e0823003 	add	r3, r2, r3
1001d088:	e2832020 	add	r2, r3, #32
1001d08c:	e30c39c8 	movw	r3, #51656	; 0xc9c8
1001d090:	e3413001 	movt	r3, #4097	; 0x1001
1001d094:	e5823004 	str	r3, [r2, #4]
        _devx[i].close     = _close;
1001d098:	e30e2070 	movw	r2, #57456	; 0xe070
1001d09c:	e3412003 	movt	r2, #4099	; 0x1003
1001d0a0:	e51b3008 	ldr	r3, [fp, #-8]
1001d0a4:	e1a01003 	mov	r1, r3
1001d0a8:	e1a03101 	lsl	r3, r1, #2
1001d0ac:	e1a01003 	mov	r1, r3
1001d0b0:	e1a03201 	lsl	r3, r1, #4
1001d0b4:	e0613003 	rsb	r3, r1, r3
1001d0b8:	e0823003 	add	r3, r2, r3
1001d0bc:	e2832028 	add	r2, r3, #40	; 0x28
1001d0c0:	e30c3a90 	movw	r3, #51856	; 0xca90
1001d0c4:	e3413001 	movt	r3, #4097	; 0x1001
1001d0c8:	e5823000 	str	r3, [r2]
        _devx[i].read      = _read;
1001d0cc:	e30e2070 	movw	r2, #57456	; 0xe070
1001d0d0:	e3412003 	movt	r2, #4099	; 0x1003
1001d0d4:	e51b3008 	ldr	r3, [fp, #-8]
1001d0d8:	e1a01003 	mov	r1, r3
1001d0dc:	e1a03101 	lsl	r3, r1, #2
1001d0e0:	e1a01003 	mov	r1, r3
1001d0e4:	e1a03201 	lsl	r3, r1, #4
1001d0e8:	e0613003 	rsb	r3, r1, r3
1001d0ec:	e0823003 	add	r3, r2, r3
1001d0f0:	e2832028 	add	r2, r3, #40	; 0x28
1001d0f4:	e30c3b00 	movw	r3, #51968	; 0xcb00
1001d0f8:	e3413001 	movt	r3, #4097	; 0x1001
1001d0fc:	e5823004 	str	r3, [r2, #4]
        _devx[i].write     = _write;
1001d100:	e30e2070 	movw	r2, #57456	; 0xe070
1001d104:	e3412003 	movt	r2, #4099	; 0x1003
1001d108:	e51b3008 	ldr	r3, [fp, #-8]
1001d10c:	e1a01003 	mov	r1, r3
1001d110:	e1a03101 	lsl	r3, r1, #2
1001d114:	e1a01003 	mov	r1, r3
1001d118:	e1a03201 	lsl	r3, r1, #4
1001d11c:	e0613003 	rsb	r3, r1, r3
1001d120:	e0823003 	add	r3, r2, r3
1001d124:	e2832030 	add	r2, r3, #48	; 0x30
1001d128:	e30c3d74 	movw	r3, #52596	; 0xcd74
1001d12c:	e3413001 	movt	r3, #4097	; 0x1001
1001d130:	e5823000 	str	r3, [r2]
        _devx[i].control   = _control;
1001d134:	e30e2070 	movw	r2, #57456	; 0xe070
1001d138:	e3412003 	movt	r2, #4099	; 0x1003
1001d13c:	e51b3008 	ldr	r3, [fp, #-8]
1001d140:	e1a01003 	mov	r1, r3
1001d144:	e1a03101 	lsl	r3, r1, #2
1001d148:	e1a01003 	mov	r1, r3
1001d14c:	e1a03201 	lsl	r3, r1, #4
1001d150:	e0613003 	rsb	r3, r1, r3
1001d154:	e0823003 	add	r3, r2, r3
1001d158:	e2832030 	add	r2, r3, #48	; 0x30
1001d15c:	e30c3e64 	movw	r3, #52836	; 0xce64
1001d160:	e3413001 	movt	r3, #4097	; 0x1001
1001d164:	e5823004 	str	r3, [r2, #4]
        _devx[i].user_data = p;
1001d168:	e30e2070 	movw	r2, #57456	; 0xe070
1001d16c:	e3412003 	movt	r2, #4099	; 0x1003
1001d170:	e51b3008 	ldr	r3, [fp, #-8]
1001d174:	e1a01003 	mov	r1, r3
1001d178:	e1a03101 	lsl	r3, r1, #2
1001d17c:	e1a01003 	mov	r1, r3
1001d180:	e1a03201 	lsl	r3, r1, #4
1001d184:	e0613003 	rsb	r3, r1, r3
1001d188:	e0823003 	add	r3, r2, r3
1001d18c:	e2833038 	add	r3, r3, #56	; 0x38
1001d190:	e51b200c 	ldr	r2, [fp, #-12]
1001d194:	e5832000 	str	r2, [r3]
        rt_device_register(&_devx[i], p->req.name, RT_DEVICE_FLAG_RDWR);
1001d198:	e51b3008 	ldr	r3, [fp, #-8]
1001d19c:	e1a02003 	mov	r2, r3
1001d1a0:	e1a03102 	lsl	r3, r2, #2
1001d1a4:	e1a02003 	mov	r2, r3
1001d1a8:	e1a03202 	lsl	r3, r2, #4
1001d1ac:	e0623003 	rsb	r3, r2, r3
1001d1b0:	e30e2070 	movw	r2, #57456	; 0xe070
1001d1b4:	e3412003 	movt	r2, #4099	; 0x1003
1001d1b8:	e0832002 	add	r2, r3, r2
1001d1bc:	e51b300c 	ldr	r3, [fp, #-12]
1001d1c0:	e5933010 	ldr	r3, [r3, #16]
1001d1c4:	e1a00002 	mov	r0, r2
1001d1c8:	e1a01003 	mov	r1, r3
1001d1cc:	e3a02003 	mov	r2, #3
1001d1d0:	ebffc4e2 	bl	1000e560 <rt_device_register>
    int i;
    struct rt_vbus_dev *p;

    for (i = 0,                   p = rt_vbus_chn_devx;
         i < ARRAY_SIZE(_devx) && p->req.name;
         i++,                     p++)
1001d1d4:	e51b3008 	ldr	r3, [fp, #-8]
1001d1d8:	e2833001 	add	r3, r3, #1
1001d1dc:	e50b3008 	str	r3, [fp, #-8]
1001d1e0:	e51b300c 	ldr	r3, [fp, #-12]
1001d1e4:	e2833028 	add	r3, r3, #40	; 0x28
1001d1e8:	e50b300c 	str	r3, [fp, #-12]
{
    int i;
    struct rt_vbus_dev *p;

    for (i = 0,                   p = rt_vbus_chn_devx;
         i < ARRAY_SIZE(_devx) && p->req.name;
1001d1ec:	e51b3008 	ldr	r3, [fp, #-8]
rt_err_t rt_vbus_chnx_init(void)
{
    int i;
    struct rt_vbus_dev *p;

    for (i = 0,                   p = rt_vbus_chn_devx;
1001d1f0:	e353001f 	cmp	r3, #31
1001d1f4:	8a000003 	bhi	1001d208 <rt_vbus_chnx_init+0x1f8>
         i < ARRAY_SIZE(_devx) && p->req.name;
1001d1f8:	e51b300c 	ldr	r3, [fp, #-12]
1001d1fc:	e5933010 	ldr	r3, [r3, #16]
1001d200:	e3530000 	cmp	r3, #0
1001d204:	1affff8a 	bne	1001d034 <rt_vbus_chnx_init+0x24>
        _devx[i].control   = _control;
        _devx[i].user_data = p;
        rt_device_register(&_devx[i], p->req.name, RT_DEVICE_FLAG_RDWR);
    }

    return RT_EOK;
1001d208:	e3a03000 	mov	r3, #0
}
1001d20c:	e1a00003 	mov	r0, r3
1001d210:	e24bd004 	sub	sp, fp, #4
1001d214:	e8bd8800 	pop	{fp, pc}

1001d218 <clock_time_system_init>:
#include <rtthread.h>
#include <pthread.h>

struct timeval _timevalue;
void clock_time_system_init()
{
1001d218:	e92d4800 	push	{fp, lr}
1001d21c:	e28db004 	add	fp, sp, #4
1001d220:	e24dd010 	sub	sp, sp, #16
    time_t time;
    rt_tick_t tick;
    rt_device_t device;

    time = 0;
1001d224:	e3a03000 	mov	r3, #0
1001d228:	e50b3010 	str	r3, [fp, #-16]
    device = rt_device_find("rtc");
1001d22c:	e30409c4 	movw	r0, #18884	; 0x49c4
1001d230:	e3410003 	movt	r0, #4099	; 0x1003
1001d234:	ebffc506 	bl	1000e654 <rt_device_find>
1001d238:	e50b0008 	str	r0, [fp, #-8]
    if (device != RT_NULL)
1001d23c:	e51b3008 	ldr	r3, [fp, #-8]
1001d240:	e3530000 	cmp	r3, #0
1001d244:	0a000004 	beq	1001d25c <clock_time_system_init+0x44>
    {
        /* get realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time);
1001d248:	e24b3010 	sub	r3, fp, #16
1001d24c:	e51b0008 	ldr	r0, [fp, #-8]
1001d250:	e3a01010 	mov	r1, #16
1001d254:	e1a02003 	mov	r2, r3
1001d258:	ebffc654 	bl	1000ebb0 <rt_device_control>
    }

    /* get tick */
    tick = rt_tick_get();
1001d25c:	ebffc438 	bl	1000e344 <rt_tick_get>
1001d260:	e50b000c 	str	r0, [fp, #-12]

    _timevalue.tv_usec = (tick%RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
1001d264:	e51b000c 	ldr	r0, [fp, #-12]
1001d268:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1001d26c:	e3413062 	movt	r3, #4194	; 0x1062
1001d270:	e0832390 	umull	r2, r3, r0, r3
1001d274:	e1a02323 	lsr	r2, r3, #6
1001d278:	e1a01002 	mov	r1, r2
1001d27c:	e1a03101 	lsl	r3, r1, #2
1001d280:	e1a01003 	mov	r1, r3
1001d284:	e1a03281 	lsl	r3, r1, #5
1001d288:	e0613003 	rsb	r3, r1, r3
1001d28c:	e0833002 	add	r3, r3, r2
1001d290:	e1a03183 	lsl	r3, r3, #3
1001d294:	e0632000 	rsb	r2, r3, r0
1001d298:	e1a01002 	mov	r1, r2
1001d29c:	e1a03101 	lsl	r3, r1, #2
1001d2a0:	e1a01003 	mov	r1, r3
1001d2a4:	e1a03281 	lsl	r3, r1, #5
1001d2a8:	e0613003 	rsb	r3, r1, r3
1001d2ac:	e0833002 	add	r3, r3, r2
1001d2b0:	e1a03183 	lsl	r3, r3, #3
1001d2b4:	e1a02003 	mov	r2, r3
1001d2b8:	e3033548 	movw	r3, #13640	; 0x3548
1001d2bc:	e3413004 	movt	r3, #4100	; 0x1004
1001d2c0:	e5832004 	str	r2, [r3, #4]
    _timevalue.tv_sec = time - tick/RT_TICK_PER_SECOND - 1;
1001d2c4:	e51b3010 	ldr	r3, [fp, #-16]
1001d2c8:	e1a01003 	mov	r1, r3
1001d2cc:	e51b200c 	ldr	r2, [fp, #-12]
1001d2d0:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1001d2d4:	e3413062 	movt	r3, #4194	; 0x1062
1001d2d8:	e0832392 	umull	r2, r3, r2, r3
1001d2dc:	e1a03323 	lsr	r3, r3, #6
1001d2e0:	e0633001 	rsb	r3, r3, r1
1001d2e4:	e2433001 	sub	r3, r3, #1
1001d2e8:	e1a02003 	mov	r2, r3
1001d2ec:	e3033548 	movw	r3, #13640	; 0x3548
1001d2f0:	e3413004 	movt	r3, #4100	; 0x1004
1001d2f4:	e5832000 	str	r2, [r3]
}
1001d2f8:	e24bd004 	sub	sp, fp, #4
1001d2fc:	e8bd8800 	pop	{fp, pc}

1001d300 <clock_time_to_tick>:

int clock_time_to_tick(const struct timespec *time)
{
1001d300:	e92d4800 	push	{fp, lr}
1001d304:	e28db004 	add	fp, sp, #4
1001d308:	e24dd020 	sub	sp, sp, #32
1001d30c:	e50b0020 	str	r0, [fp, #-32]
    int tick;
    int nsecond, second;
    struct timespec tp;

    RT_ASSERT(time != RT_NULL);
1001d310:	e51b3020 	ldr	r3, [fp, #-32]
1001d314:	e3530000 	cmp	r3, #0
1001d318:	1a000005 	bne	1001d334 <clock_time_to_tick+0x34>
1001d31c:	e30409c8 	movw	r0, #18888	; 0x49c8
1001d320:	e3410003 	movt	r0, #4099	; 0x1003
1001d324:	e30419d8 	movw	r1, #18904	; 0x49d8
1001d328:	e3411003 	movt	r1, #4099	; 0x1003
1001d32c:	e3a02039 	mov	r2, #57	; 0x39
1001d330:	ebffda9f 	bl	10013db4 <rt_assert_handler>

    tick = RT_WAITING_FOREVER;
1001d334:	e3e03000 	mvn	r3, #0
1001d338:	e50b3008 	str	r3, [fp, #-8]
    if (time != NULL)
1001d33c:	e51b3020 	ldr	r3, [fp, #-32]
1001d340:	e3530000 	cmp	r3, #0
1001d344:	0a000040 	beq	1001d44c <clock_time_to_tick+0x14c>
    {
        /* get current tp */
        clock_gettime(CLOCK_REALTIME, &tp);
1001d348:	e24b3018 	sub	r3, fp, #24
1001d34c:	e3a00001 	mov	r0, #1
1001d350:	e1a01003 	mov	r1, r3
1001d354:	eb00005a 	bl	1001d4c4 <clock_gettime>

        if ((time->tv_nsec - tp.tv_nsec) < 0)
1001d358:	e51b3020 	ldr	r3, [fp, #-32]
1001d35c:	e5932004 	ldr	r2, [r3, #4]
1001d360:	e51b3014 	ldr	r3, [fp, #-20]
1001d364:	e0633002 	rsb	r3, r3, r2
1001d368:	e3530000 	cmp	r3, #0
1001d36c:	aa00000f 	bge	1001d3b0 <clock_time_to_tick+0xb0>
        {
            nsecond = NANOSECOND_PER_SECOND - (tp.tv_nsec - time->tv_nsec);
1001d370:	e51b3020 	ldr	r3, [fp, #-32]
1001d374:	e5932004 	ldr	r2, [r3, #4]
1001d378:	e51b3014 	ldr	r3, [fp, #-20]
1001d37c:	e0633002 	rsb	r3, r3, r2
1001d380:	e1a02003 	mov	r2, r3
1001d384:	e3a03cca 	mov	r3, #51712	; 0xca00
1001d388:	e3433b9a 	movt	r3, #15258	; 0x3b9a
1001d38c:	e0823003 	add	r3, r2, r3
1001d390:	e50b300c 	str	r3, [fp, #-12]
            second  = time->tv_sec - tp.tv_sec - 1;
1001d394:	e51b3020 	ldr	r3, [fp, #-32]
1001d398:	e5932000 	ldr	r2, [r3]
1001d39c:	e51b3018 	ldr	r3, [fp, #-24]
1001d3a0:	e0633002 	rsb	r3, r3, r2
1001d3a4:	e2433001 	sub	r3, r3, #1
1001d3a8:	e50b3010 	str	r3, [fp, #-16]
1001d3ac:	ea000009 	b	1001d3d8 <clock_time_to_tick+0xd8>
        }
        else
        {
            nsecond = time->tv_nsec - tp.tv_nsec;
1001d3b0:	e51b3020 	ldr	r3, [fp, #-32]
1001d3b4:	e5932004 	ldr	r2, [r3, #4]
1001d3b8:	e51b3014 	ldr	r3, [fp, #-20]
1001d3bc:	e0633002 	rsb	r3, r3, r2
1001d3c0:	e50b300c 	str	r3, [fp, #-12]
            second  = time->tv_sec - tp.tv_sec;
1001d3c4:	e51b3020 	ldr	r3, [fp, #-32]
1001d3c8:	e5932000 	ldr	r2, [r3]
1001d3cc:	e51b3018 	ldr	r3, [fp, #-24]
1001d3d0:	e0633002 	rsb	r3, r3, r2
1001d3d4:	e50b3010 	str	r3, [fp, #-16]
        }

        tick = second * RT_TICK_PER_SECOND + nsecond * RT_TICK_PER_SECOND / NANOSECOND_PER_SECOND;
1001d3d8:	e51b1010 	ldr	r1, [fp, #-16]
1001d3dc:	e1a02001 	mov	r2, r1
1001d3e0:	e1a03102 	lsl	r3, r2, #2
1001d3e4:	e1a02003 	mov	r2, r3
1001d3e8:	e1a03282 	lsl	r3, r2, #5
1001d3ec:	e0623003 	rsb	r3, r2, r3
1001d3f0:	e0833001 	add	r3, r3, r1
1001d3f4:	e1a03183 	lsl	r3, r3, #3
1001d3f8:	e1a00003 	mov	r0, r3
1001d3fc:	e51b100c 	ldr	r1, [fp, #-12]
1001d400:	e1a02001 	mov	r2, r1
1001d404:	e1a03102 	lsl	r3, r2, #2
1001d408:	e1a02003 	mov	r2, r3
1001d40c:	e1a03282 	lsl	r3, r2, #5
1001d410:	e0623003 	rsb	r3, r2, r3
1001d414:	e0833001 	add	r3, r3, r1
1001d418:	e1a03183 	lsl	r3, r3, #3
1001d41c:	e1a024a3 	lsr	r2, r3, #9
1001d420:	e3043b83 	movw	r3, #19331	; 0x4b83
1001d424:	e3403004 	movt	r3, #4
1001d428:	e0832392 	umull	r2, r3, r2, r3
1001d42c:	e1a033a3 	lsr	r3, r3, #7
1001d430:	e0803003 	add	r3, r0, r3
1001d434:	e50b3008 	str	r3, [fp, #-8]
        if (tick < 0) tick = 0;
1001d438:	e51b3008 	ldr	r3, [fp, #-8]
1001d43c:	e3530000 	cmp	r3, #0
1001d440:	aa000001 	bge	1001d44c <clock_time_to_tick+0x14c>
1001d444:	e3a03000 	mov	r3, #0
1001d448:	e50b3008 	str	r3, [fp, #-8]
    }

    return tick;
1001d44c:	e51b3008 	ldr	r3, [fp, #-8]
}
1001d450:	e1a00003 	mov	r0, r3
1001d454:	e24bd004 	sub	sp, fp, #4
1001d458:	e8bd8800 	pop	{fp, pc}

1001d45c <clock_getres>:
RTM_EXPORT(clock_time_to_tick);

int clock_getres(clockid_t clockid, struct timespec *res)
{
1001d45c:	e92d4800 	push	{fp, lr}
1001d460:	e28db004 	add	fp, sp, #4
1001d464:	e24dd008 	sub	sp, sp, #8
1001d468:	e50b0008 	str	r0, [fp, #-8]
1001d46c:	e50b100c 	str	r1, [fp, #-12]
    if ((clockid != CLOCK_REALTIME) || (res == RT_NULL))
1001d470:	e51b3008 	ldr	r3, [fp, #-8]
1001d474:	e3530001 	cmp	r3, #1
1001d478:	1a000002 	bne	1001d488 <clock_getres+0x2c>
1001d47c:	e51b300c 	ldr	r3, [fp, #-12]
1001d480:	e3530000 	cmp	r3, #0
1001d484:	1a000003 	bne	1001d498 <clock_getres+0x3c>
    {
        rt_set_errno(EINVAL);
1001d488:	e3a00016 	mov	r0, #22
1001d48c:	ebffd33e 	bl	1001218c <rt_set_errno>

        return -1;
1001d490:	e3e03000 	mvn	r3, #0
1001d494:	ea000007 	b	1001d4b8 <clock_getres+0x5c>
    }

    res->tv_sec = 0;
1001d498:	e51b300c 	ldr	r3, [fp, #-12]
1001d49c:	e3a02000 	mov	r2, #0
1001d4a0:	e5832000 	str	r2, [r3]
    res->tv_nsec = NANOSECOND_PER_SECOND/RT_TICK_PER_SECOND;
1001d4a4:	e51b200c 	ldr	r2, [fp, #-12]
1001d4a8:	e3043240 	movw	r3, #16960	; 0x4240
1001d4ac:	e340300f 	movt	r3, #15
1001d4b0:	e5823004 	str	r3, [r2, #4]

    return 0;
1001d4b4:	e3a03000 	mov	r3, #0
}
1001d4b8:	e1a00003 	mov	r0, r3
1001d4bc:	e24bd004 	sub	sp, fp, #4
1001d4c0:	e8bd8800 	pop	{fp, pc}

1001d4c4 <clock_gettime>:
RTM_EXPORT(clock_getres);

int clock_gettime(clockid_t clockid, struct timespec *tp)
{
1001d4c4:	e92d4800 	push	{fp, lr}
1001d4c8:	e28db004 	add	fp, sp, #4
1001d4cc:	e24dd010 	sub	sp, sp, #16
1001d4d0:	e50b0010 	str	r0, [fp, #-16]
1001d4d4:	e50b1014 	str	r1, [fp, #-20]
    rt_tick_t tick;

    if ((clockid != CLOCK_REALTIME) || (tp == RT_NULL))
1001d4d8:	e51b3010 	ldr	r3, [fp, #-16]
1001d4dc:	e3530001 	cmp	r3, #1
1001d4e0:	1a000002 	bne	1001d4f0 <clock_gettime+0x2c>
1001d4e4:	e51b3014 	ldr	r3, [fp, #-20]
1001d4e8:	e3530000 	cmp	r3, #0
1001d4ec:	1a000003 	bne	1001d500 <clock_gettime+0x3c>
    {
        rt_set_errno(EINVAL);
1001d4f0:	e3a00016 	mov	r0, #22
1001d4f4:	ebffd324 	bl	1001218c <rt_set_errno>

        return -1;
1001d4f8:	e3e03000 	mvn	r3, #0
1001d4fc:	ea00002e 	b	1001d5bc <clock_gettime+0xf8>
    }

    /* get tick */
    tick = rt_tick_get();
1001d500:	ebffc38f 	bl	1000e344 <rt_tick_get>
1001d504:	e50b0008 	str	r0, [fp, #-8]

    tp->tv_sec = _timevalue.tv_sec + tick / RT_TICK_PER_SECOND;
1001d508:	e3033548 	movw	r3, #13640	; 0x3548
1001d50c:	e3413004 	movt	r3, #4100	; 0x1004
1001d510:	e5933000 	ldr	r3, [r3]
1001d514:	e1a01003 	mov	r1, r3
1001d518:	e51b2008 	ldr	r2, [fp, #-8]
1001d51c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1001d520:	e3413062 	movt	r3, #4194	; 0x1062
1001d524:	e0832392 	umull	r2, r3, r2, r3
1001d528:	e1a03323 	lsr	r3, r3, #6
1001d52c:	e0813003 	add	r3, r1, r3
1001d530:	e1a02003 	mov	r2, r3
1001d534:	e51b3014 	ldr	r3, [fp, #-20]
1001d538:	e5832000 	str	r2, [r3]
    tp->tv_nsec = (_timevalue.tv_usec + (tick % RT_TICK_PER_SECOND) * NANOSECOND_PER_TICK) * 1000;
1001d53c:	e3033548 	movw	r3, #13640	; 0x3548
1001d540:	e3413004 	movt	r3, #4100	; 0x1004
1001d544:	e5933004 	ldr	r3, [r3, #4]
1001d548:	e1a0c003 	mov	ip, r3
1001d54c:	e51b0008 	ldr	r0, [fp, #-8]
1001d550:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1001d554:	e3413062 	movt	r3, #4194	; 0x1062
1001d558:	e0832390 	umull	r2, r3, r0, r3
1001d55c:	e1a02323 	lsr	r2, r3, #6
1001d560:	e1a01002 	mov	r1, r2
1001d564:	e1a03101 	lsl	r3, r1, #2
1001d568:	e1a01003 	mov	r1, r3
1001d56c:	e1a03281 	lsl	r3, r1, #5
1001d570:	e0613003 	rsb	r3, r1, r3
1001d574:	e0833002 	add	r3, r3, r2
1001d578:	e1a03183 	lsl	r3, r3, #3
1001d57c:	e0632000 	rsb	r2, r3, r0
1001d580:	e3043240 	movw	r3, #16960	; 0x4240
1001d584:	e340300f 	movt	r3, #15
1001d588:	e0030293 	mul	r3, r3, r2
1001d58c:	e08c1003 	add	r1, ip, r3
1001d590:	e1a02001 	mov	r2, r1
1001d594:	e1a03102 	lsl	r3, r2, #2
1001d598:	e1a02003 	mov	r2, r3
1001d59c:	e1a03282 	lsl	r3, r2, #5
1001d5a0:	e0623003 	rsb	r3, r2, r3
1001d5a4:	e0833001 	add	r3, r3, r1
1001d5a8:	e1a03183 	lsl	r3, r3, #3
1001d5ac:	e1a02003 	mov	r2, r3
1001d5b0:	e51b3014 	ldr	r3, [fp, #-20]
1001d5b4:	e5832004 	str	r2, [r3, #4]
    
    return 0;
1001d5b8:	e3a03000 	mov	r3, #0
}
1001d5bc:	e1a00003 	mov	r0, r3
1001d5c0:	e24bd004 	sub	sp, fp, #4
1001d5c4:	e8bd8800 	pop	{fp, pc}

1001d5c8 <clock_settime>:
RTM_EXPORT(clock_gettime);

int clock_settime(clockid_t clockid, const struct timespec *tp)
{
1001d5c8:	e92d4800 	push	{fp, lr}
1001d5cc:	e28db004 	add	fp, sp, #4
1001d5d0:	e24dd018 	sub	sp, sp, #24
1001d5d4:	e50b0018 	str	r0, [fp, #-24]
1001d5d8:	e50b101c 	str	r1, [fp, #-28]
    int second;
    rt_tick_t tick;
    rt_device_t device;

    if ((clockid != CLOCK_REALTIME) || (tp == RT_NULL))
1001d5dc:	e51b3018 	ldr	r3, [fp, #-24]
1001d5e0:	e3530001 	cmp	r3, #1
1001d5e4:	1a000002 	bne	1001d5f4 <clock_settime+0x2c>
1001d5e8:	e51b301c 	ldr	r3, [fp, #-28]
1001d5ec:	e3530000 	cmp	r3, #0
1001d5f0:	1a000003 	bne	1001d604 <clock_settime+0x3c>
    {
        rt_set_errno(EINVAL);
1001d5f4:	e3a00016 	mov	r0, #22
1001d5f8:	ebffd2e3 	bl	1001218c <rt_set_errno>

        return -1;
1001d5fc:	e3e03000 	mvn	r3, #0
1001d600:	ea00003a 	b	1001d6f0 <clock_settime+0x128>
    }

    /* get second */
    second = tp->tv_sec;
1001d604:	e51b301c 	ldr	r3, [fp, #-28]
1001d608:	e5933000 	ldr	r3, [r3]
1001d60c:	e50b3010 	str	r3, [fp, #-16]
    /* get tick */
    tick = rt_tick_get();
1001d610:	ebffc34b 	bl	1000e344 <rt_tick_get>
1001d614:	e50b0008 	str	r0, [fp, #-8]

    /* update timevalue */
    _timevalue.tv_usec = MICROSECOND_PER_SECOND - (tick % RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
1001d618:	e51b0008 	ldr	r0, [fp, #-8]
1001d61c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1001d620:	e3413062 	movt	r3, #4194	; 0x1062
1001d624:	e0832390 	umull	r2, r3, r0, r3
1001d628:	e1a02323 	lsr	r2, r3, #6
1001d62c:	e1a01002 	mov	r1, r2
1001d630:	e1a03101 	lsl	r3, r1, #2
1001d634:	e1a01003 	mov	r1, r3
1001d638:	e1a03281 	lsl	r3, r1, #5
1001d63c:	e0613003 	rsb	r3, r1, r3
1001d640:	e0833002 	add	r3, r3, r2
1001d644:	e1a03183 	lsl	r3, r3, #3
1001d648:	e0632000 	rsb	r2, r3, r0
1001d64c:	e1a01002 	mov	r1, r2
1001d650:	e1a03101 	lsl	r3, r1, #2
1001d654:	e1a01003 	mov	r1, r3
1001d658:	e1a03281 	lsl	r3, r1, #5
1001d65c:	e0613003 	rsb	r3, r1, r3
1001d660:	e0833002 	add	r3, r3, r2
1001d664:	e1a03183 	lsl	r3, r3, #3
1001d668:	e263393d 	rsb	r3, r3, #999424	; 0xf4000
1001d66c:	e2833d09 	add	r3, r3, #576	; 0x240
1001d670:	e1a02003 	mov	r2, r3
1001d674:	e3033548 	movw	r3, #13640	; 0x3548
1001d678:	e3413004 	movt	r3, #4100	; 0x1004
1001d67c:	e5832004 	str	r2, [r3, #4]
    _timevalue.tv_sec = second - tick/RT_TICK_PER_SECOND - 1;
1001d680:	e51b3010 	ldr	r3, [fp, #-16]
1001d684:	e1a01003 	mov	r1, r3
1001d688:	e51b2008 	ldr	r2, [fp, #-8]
1001d68c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1001d690:	e3413062 	movt	r3, #4194	; 0x1062
1001d694:	e0832392 	umull	r2, r3, r2, r3
1001d698:	e1a03323 	lsr	r3, r3, #6
1001d69c:	e0633001 	rsb	r3, r3, r1
1001d6a0:	e2433001 	sub	r3, r3, #1
1001d6a4:	e1a02003 	mov	r2, r3
1001d6a8:	e3033548 	movw	r3, #13640	; 0x3548
1001d6ac:	e3413004 	movt	r3, #4100	; 0x1004
1001d6b0:	e5832000 	str	r2, [r3]

    /* update for RTC device */
    device = rt_device_find("rtc");
1001d6b4:	e30409c4 	movw	r0, #18884	; 0x49c4
1001d6b8:	e3410003 	movt	r0, #4099	; 0x1003
1001d6bc:	ebffc3e4 	bl	1000e654 <rt_device_find>
1001d6c0:	e50b000c 	str	r0, [fp, #-12]
    if (device != RT_NULL)
1001d6c4:	e51b300c 	ldr	r3, [fp, #-12]
1001d6c8:	e3530000 	cmp	r3, #0
1001d6cc:	0a000006 	beq	1001d6ec <clock_settime+0x124>
    {
        /* set realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &second);
1001d6d0:	e24b3010 	sub	r3, fp, #16
1001d6d4:	e51b000c 	ldr	r0, [fp, #-12]
1001d6d8:	e3a01011 	mov	r1, #17
1001d6dc:	e1a02003 	mov	r2, r3
1001d6e0:	ebffc532 	bl	1000ebb0 <rt_device_control>
    }
    else
        return -1;

    return 0;
1001d6e4:	e3a03000 	mov	r3, #0
1001d6e8:	ea000000 	b	1001d6f0 <clock_settime+0x128>
    {
        /* set realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &second);
    }
    else
        return -1;
1001d6ec:	e3e03000 	mvn	r3, #0

    return 0;
}
1001d6f0:	e1a00003 	mov	r0, r3
1001d6f4:	e24bd004 	sub	sp, fp, #4
1001d6f8:	e8bd8800 	pop	{fp, pc}

1001d6fc <posix_mq_system_init>:
#include "pthread_internal.h"

static mqd_t posix_mq_list = RT_NULL;
static struct rt_semaphore posix_mq_lock;
void posix_mq_system_init()
{
1001d6fc:	e92d4800 	push	{fp, lr}
1001d700:	e28db004 	add	fp, sp, #4
    rt_sem_init(&posix_mq_lock, "pmq", 1, RT_IPC_FLAG_FIFO);
1001d704:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001d708:	e3410003 	movt	r0, #4099	; 0x1003
1001d70c:	e30419ec 	movw	r1, #18924	; 0x49ec
1001d710:	e3411003 	movt	r1, #4099	; 0x1003
1001d714:	e3a02001 	mov	r2, #1
1001d718:	e3a03000 	mov	r3, #0
1001d71c:	ebffc6bb 	bl	1000f210 <rt_sem_init>
}
1001d720:	e8bd8800 	pop	{fp, pc}

1001d724 <posix_mq_insert>:

rt_inline void posix_mq_insert(mqd_t pmq)
{
1001d724:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001d728:	e28db000 	add	fp, sp, #0
1001d72c:	e24dd00c 	sub	sp, sp, #12
1001d730:	e50b0008 	str	r0, [fp, #-8]
    pmq->next = posix_mq_list;
1001d734:	e30e37f0 	movw	r3, #59376	; 0xe7f0
1001d738:	e3413003 	movt	r3, #4099	; 0x1003
1001d73c:	e5932000 	ldr	r2, [r3]
1001d740:	e51b3008 	ldr	r3, [fp, #-8]
1001d744:	e5832008 	str	r2, [r3, #8]
    posix_mq_list = pmq;
1001d748:	e30e37f0 	movw	r3, #59376	; 0xe7f0
1001d74c:	e3413003 	movt	r3, #4099	; 0x1003
1001d750:	e51b2008 	ldr	r2, [fp, #-8]
1001d754:	e5832000 	str	r2, [r3]
}
1001d758:	e24bd000 	sub	sp, fp, #0
1001d75c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001d760:	e12fff1e 	bx	lr

1001d764 <posix_mq_delete>:

static void posix_mq_delete(mqd_t pmq)
{
1001d764:	e92d4800 	push	{fp, lr}
1001d768:	e28db004 	add	fp, sp, #4
1001d76c:	e24dd010 	sub	sp, sp, #16
1001d770:	e50b0010 	str	r0, [fp, #-16]
    mqd_t iter;
    if (posix_mq_list == pmq)
1001d774:	e30e37f0 	movw	r3, #59376	; 0xe7f0
1001d778:	e3413003 	movt	r3, #4099	; 0x1003
1001d77c:	e5932000 	ldr	r2, [r3]
1001d780:	e51b3010 	ldr	r3, [fp, #-16]
1001d784:	e1520003 	cmp	r2, r3
1001d788:	1a00000b 	bne	1001d7bc <posix_mq_delete+0x58>
    {
        posix_mq_list = pmq->next;
1001d78c:	e51b3010 	ldr	r3, [fp, #-16]
1001d790:	e5932008 	ldr	r2, [r3, #8]
1001d794:	e30e37f0 	movw	r3, #59376	; 0xe7f0
1001d798:	e3413003 	movt	r3, #4099	; 0x1003
1001d79c:	e5832000 	str	r2, [r3]

        rt_mq_delete(pmq->mq);
1001d7a0:	e51b3010 	ldr	r3, [fp, #-16]
1001d7a4:	e5933004 	ldr	r3, [r3, #4]
1001d7a8:	e1a00003 	mov	r0, r3
1001d7ac:	ebffcfca 	bl	100116dc <rt_mq_delete>
        rt_free(pmq);
1001d7b0:	e51b0010 	ldr	r0, [fp, #-16]
1001d7b4:	ebffdcd1 	bl	10014b00 <rt_free>

        return;
1001d7b8:	ea000023 	b	1001d84c <posix_mq_delete+0xe8>
    }
    for (iter = posix_mq_list; iter->next != RT_NULL; iter = iter->next)
1001d7bc:	e30e37f0 	movw	r3, #59376	; 0xe7f0
1001d7c0:	e3413003 	movt	r3, #4099	; 0x1003
1001d7c4:	e5933000 	ldr	r3, [r3]
1001d7c8:	e50b3008 	str	r3, [fp, #-8]
1001d7cc:	ea00001a 	b	1001d83c <posix_mq_delete+0xd8>
    {
        if (iter->next == pmq)
1001d7d0:	e51b3008 	ldr	r3, [fp, #-8]
1001d7d4:	e5932008 	ldr	r2, [r3, #8]
1001d7d8:	e51b3010 	ldr	r3, [fp, #-16]
1001d7dc:	e1520003 	cmp	r2, r3
1001d7e0:	1a000012 	bne	1001d830 <posix_mq_delete+0xcc>
        {
            /* delete this mq */
            if (pmq->next != RT_NULL)
1001d7e4:	e51b3010 	ldr	r3, [fp, #-16]
1001d7e8:	e5933008 	ldr	r3, [r3, #8]
1001d7ec:	e3530000 	cmp	r3, #0
1001d7f0:	0a000004 	beq	1001d808 <posix_mq_delete+0xa4>
                iter->next = pmq->next;
1001d7f4:	e51b3010 	ldr	r3, [fp, #-16]
1001d7f8:	e5932008 	ldr	r2, [r3, #8]
1001d7fc:	e51b3008 	ldr	r3, [fp, #-8]
1001d800:	e5832008 	str	r2, [r3, #8]
1001d804:	ea000002 	b	1001d814 <posix_mq_delete+0xb0>
            else
                iter->next = RT_NULL;
1001d808:	e51b3008 	ldr	r3, [fp, #-8]
1001d80c:	e3a02000 	mov	r2, #0
1001d810:	e5832008 	str	r2, [r3, #8]

            /* delete RT-Thread mqueue */
            rt_mq_delete(pmq->mq);
1001d814:	e51b3010 	ldr	r3, [fp, #-16]
1001d818:	e5933004 	ldr	r3, [r3, #4]
1001d81c:	e1a00003 	mov	r0, r3
1001d820:	ebffcfad 	bl	100116dc <rt_mq_delete>
            rt_free(pmq);
1001d824:	e51b0010 	ldr	r0, [fp, #-16]
1001d828:	ebffdcb4 	bl	10014b00 <rt_free>

            return ;
1001d82c:	ea000006 	b	1001d84c <posix_mq_delete+0xe8>
        rt_mq_delete(pmq->mq);
        rt_free(pmq);

        return;
    }
    for (iter = posix_mq_list; iter->next != RT_NULL; iter = iter->next)
1001d830:	e51b3008 	ldr	r3, [fp, #-8]
1001d834:	e5933008 	ldr	r3, [r3, #8]
1001d838:	e50b3008 	str	r3, [fp, #-8]
1001d83c:	e51b3008 	ldr	r3, [fp, #-8]
1001d840:	e5933008 	ldr	r3, [r3, #8]
1001d844:	e3530000 	cmp	r3, #0
1001d848:	1affffe0 	bne	1001d7d0 <posix_mq_delete+0x6c>
            rt_free(pmq);

            return ;
        }
    }
}
1001d84c:	e24bd004 	sub	sp, fp, #4
1001d850:	e8bd8800 	pop	{fp, pc}

1001d854 <posix_mq_find>:

static mqd_t posix_mq_find(const char* name)
{
1001d854:	e92d4800 	push	{fp, lr}
1001d858:	e28db004 	add	fp, sp, #4
1001d85c:	e24dd010 	sub	sp, sp, #16
1001d860:	e50b0010 	str	r0, [fp, #-16]
    mqd_t iter;
    rt_object_t object;

    for (iter = posix_mq_list; iter != RT_NULL; iter = iter->next)
1001d864:	e30e37f0 	movw	r3, #59376	; 0xe7f0
1001d868:	e3413003 	movt	r3, #4099	; 0x1003
1001d86c:	e5933000 	ldr	r3, [r3]
1001d870:	e50b3008 	str	r3, [fp, #-8]
1001d874:	ea00000f 	b	1001d8b8 <posix_mq_find+0x64>
    {
        object = (rt_object_t)(iter->mq);
1001d878:	e51b3008 	ldr	r3, [fp, #-8]
1001d87c:	e5933004 	ldr	r3, [r3, #4]
1001d880:	e50b300c 	str	r3, [fp, #-12]

        if (strncmp(object->name, name, RT_NAME_MAX) == 0)
1001d884:	e51b300c 	ldr	r3, [fp, #-12]
1001d888:	e1a00003 	mov	r0, r3
1001d88c:	e51b1010 	ldr	r1, [fp, #-16]
1001d890:	e3a02006 	mov	r2, #6
1001d894:	fa0047da 	blx	1002f804 <strncmp>
1001d898:	e1a03000 	mov	r3, r0
1001d89c:	e3530000 	cmp	r3, #0
1001d8a0:	1a000001 	bne	1001d8ac <posix_mq_find+0x58>
        {
            return iter;
1001d8a4:	e51b3008 	ldr	r3, [fp, #-8]
1001d8a8:	ea000006 	b	1001d8c8 <posix_mq_find+0x74>
static mqd_t posix_mq_find(const char* name)
{
    mqd_t iter;
    rt_object_t object;

    for (iter = posix_mq_list; iter != RT_NULL; iter = iter->next)
1001d8ac:	e51b3008 	ldr	r3, [fp, #-8]
1001d8b0:	e5933008 	ldr	r3, [r3, #8]
1001d8b4:	e50b3008 	str	r3, [fp, #-8]
1001d8b8:	e51b3008 	ldr	r3, [fp, #-8]
1001d8bc:	e3530000 	cmp	r3, #0
1001d8c0:	1affffec 	bne	1001d878 <posix_mq_find+0x24>
        {
            return iter;
        }
    }

    return RT_NULL;
1001d8c4:	e3a03000 	mov	r3, #0
}
1001d8c8:	e1a00003 	mov	r0, r3
1001d8cc:	e24bd004 	sub	sp, fp, #4
1001d8d0:	e8bd8800 	pop	{fp, pc}

1001d8d4 <mq_setattr>:

int mq_setattr(mqd_t                 mqdes,
               const struct mq_attr *mqstat,
               struct mq_attr       *omqstat)
{
1001d8d4:	e92d4800 	push	{fp, lr}
1001d8d8:	e28db004 	add	fp, sp, #4
1001d8dc:	e24dd010 	sub	sp, sp, #16
1001d8e0:	e50b0008 	str	r0, [fp, #-8]
1001d8e4:	e50b100c 	str	r1, [fp, #-12]
1001d8e8:	e50b2010 	str	r2, [fp, #-16]
    rt_set_errno(-RT_ERROR);
1001d8ec:	e3e00000 	mvn	r0, #0
1001d8f0:	ebffd225 	bl	1001218c <rt_set_errno>

    return -1;
1001d8f4:	e3e03000 	mvn	r3, #0
}
1001d8f8:	e1a00003 	mov	r0, r3
1001d8fc:	e24bd004 	sub	sp, fp, #4
1001d900:	e8bd8800 	pop	{fp, pc}

1001d904 <mq_getattr>:
RTM_EXPORT(mq_setattr);

int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat)
{
1001d904:	e92d4800 	push	{fp, lr}
1001d908:	e28db004 	add	fp, sp, #4
1001d90c:	e24dd008 	sub	sp, sp, #8
1001d910:	e50b0008 	str	r0, [fp, #-8]
1001d914:	e50b100c 	str	r1, [fp, #-12]
    if ((mqdes == RT_NULL) || mqstat == RT_NULL)
1001d918:	e51b3008 	ldr	r3, [fp, #-8]
1001d91c:	e3530000 	cmp	r3, #0
1001d920:	0a000002 	beq	1001d930 <mq_getattr+0x2c>
1001d924:	e51b300c 	ldr	r3, [fp, #-12]
1001d928:	e3530000 	cmp	r3, #0
1001d92c:	1a000003 	bne	1001d940 <mq_getattr+0x3c>
    {
        rt_set_errno(EBADF);
1001d930:	e3a00009 	mov	r0, #9
1001d934:	ebffd214 	bl	1001218c <rt_set_errno>

        return -1;
1001d938:	e3e03000 	mvn	r3, #0
1001d93c:	ea000012 	b	1001d98c <mq_getattr+0x88>
    }

    mqstat->mq_maxmsg = mqdes->mq->max_msgs;
1001d940:	e51b3008 	ldr	r3, [fp, #-8]
1001d944:	e5933004 	ldr	r3, [r3, #4]
1001d948:	e1d331be 	ldrh	r3, [r3, #30]
1001d94c:	e1a02003 	mov	r2, r3
1001d950:	e51b300c 	ldr	r3, [fp, #-12]
1001d954:	e5832004 	str	r2, [r3, #4]
    mqstat->mq_msgsize = mqdes->mq->msg_size;
1001d958:	e51b3008 	ldr	r3, [fp, #-8]
1001d95c:	e5933004 	ldr	r3, [r3, #4]
1001d960:	e1d331bc 	ldrh	r3, [r3, #28]
1001d964:	e1a02003 	mov	r2, r3
1001d968:	e51b300c 	ldr	r3, [fp, #-12]
1001d96c:	e5832008 	str	r2, [r3, #8]
    mqstat->mq_curmsgs = 0;
1001d970:	e51b300c 	ldr	r3, [fp, #-12]
1001d974:	e3a02000 	mov	r2, #0
1001d978:	e583200c 	str	r2, [r3, #12]
    mqstat->mq_flags = 0;
1001d97c:	e51b300c 	ldr	r3, [fp, #-12]
1001d980:	e3a02000 	mov	r2, #0
1001d984:	e5832000 	str	r2, [r3]

    return 0;
1001d988:	e3a03000 	mov	r3, #0
}
1001d98c:	e1a00003 	mov	r0, r3
1001d990:	e24bd004 	sub	sp, fp, #4
1001d994:	e8bd8800 	pop	{fp, pc}

1001d998 <mq_open>:
RTM_EXPORT(mq_getattr);

mqd_t mq_open(const char *name, int oflag, ...)
{
1001d998:	e92d000e 	push	{r1, r2, r3}
1001d99c:	e92d4800 	push	{fp, lr}
1001d9a0:	e28db004 	add	fp, sp, #4
1001d9a4:	e24dd01c 	sub	sp, sp, #28
1001d9a8:	e50b001c 	str	r0, [fp, #-28]
    mqd_t mqdes;
    va_list arg;
    mode_t mode;
    struct mq_attr *attr = RT_NULL;
1001d9ac:	e3a03000 	mov	r3, #0
1001d9b0:	e50b3010 	str	r3, [fp, #-16]

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
1001d9b4:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001d9b8:	e3410003 	movt	r0, #4099	; 0x1003
1001d9bc:	e3e01000 	mvn	r1, #0
1001d9c0:	ebffc6a9 	bl	1000f46c <rt_sem_take>

    mqdes = RT_NULL;
1001d9c4:	e3a03000 	mov	r3, #0
1001d9c8:	e50b300c 	str	r3, [fp, #-12]
    if (oflag & O_CREAT)
1001d9cc:	e59b3004 	ldr	r3, [fp, #4]
1001d9d0:	e2033c01 	and	r3, r3, #256	; 0x100
1001d9d4:	e3530000 	cmp	r3, #0
1001d9d8:	0a00003d 	beq	1001dad4 <mq_open+0x13c>
    {
        va_start(arg, oflag);
1001d9dc:	e28b3008 	add	r3, fp, #8
1001d9e0:	e50b3018 	str	r3, [fp, #-24]
        mode = (mode_t)va_arg(arg, unsigned int);
1001d9e4:	e51b3018 	ldr	r3, [fp, #-24]
1001d9e8:	e2832004 	add	r2, r3, #4
1001d9ec:	e50b2018 	str	r2, [fp, #-24]
1001d9f0:	e5933000 	ldr	r3, [r3]
1001d9f4:	e50b3014 	str	r3, [fp, #-20]
        mode = mode;
        attr = (struct mq_attr *)va_arg(arg, struct mq_attr *);
1001d9f8:	e51b3018 	ldr	r3, [fp, #-24]
1001d9fc:	e2832004 	add	r2, r3, #4
1001da00:	e50b2018 	str	r2, [fp, #-24]
1001da04:	e5933000 	ldr	r3, [r3]
1001da08:	e50b3010 	str	r3, [fp, #-16]
        va_end(arg);

        if (oflag & O_EXCL)
1001da0c:	e59b3004 	ldr	r3, [fp, #4]
1001da10:	e2033c02 	and	r3, r3, #512	; 0x200
1001da14:	e3530000 	cmp	r3, #0
1001da18:	0a000007 	beq	1001da3c <mq_open+0xa4>
        {
            if (posix_mq_find(name) != RT_NULL)
1001da1c:	e51b001c 	ldr	r0, [fp, #-28]
1001da20:	ebffff8b 	bl	1001d854 <posix_mq_find>
1001da24:	e1a03000 	mov	r3, r0
1001da28:	e3530000 	cmp	r3, #0
1001da2c:	0a000002 	beq	1001da3c <mq_open+0xa4>
            {
                rt_set_errno(EEXIST);
1001da30:	e3a00011 	mov	r0, #17
1001da34:	ebffd1d4 	bl	1001218c <rt_set_errno>
                goto __return;
1001da38:	ea00003a 	b	1001db28 <mq_open+0x190>
            }
        }
        mqdes = (mqd_t) rt_malloc (sizeof(struct mqdes));
1001da3c:	e3a0000c 	mov	r0, #12
1001da40:	ebffda13 	bl	10014294 <rt_malloc>
1001da44:	e50b000c 	str	r0, [fp, #-12]
        if (mqdes == RT_NULL)
1001da48:	e51b300c 	ldr	r3, [fp, #-12]
1001da4c:	e3530000 	cmp	r3, #0
1001da50:	1a000002 	bne	1001da60 <mq_open+0xc8>
        {
            rt_set_errno(ENFILE);
1001da54:	e3a00017 	mov	r0, #23
1001da58:	ebffd1cb 	bl	1001218c <rt_set_errno>
            goto __return;
1001da5c:	ea000031 	b	1001db28 <mq_open+0x190>
        }

        /* create RT-Thread message queue */
        mqdes->mq = rt_mq_create(name, attr->mq_msgsize, attr->mq_maxmsg, RT_IPC_FLAG_FIFO);
1001da60:	e51b3010 	ldr	r3, [fp, #-16]
1001da64:	e5933008 	ldr	r3, [r3, #8]
1001da68:	e1a02003 	mov	r2, r3
1001da6c:	e51b3010 	ldr	r3, [fp, #-16]
1001da70:	e5933004 	ldr	r3, [r3, #4]
1001da74:	e51b001c 	ldr	r0, [fp, #-28]
1001da78:	e1a01002 	mov	r1, r2
1001da7c:	e1a02003 	mov	r2, r3
1001da80:	e3a03000 	mov	r3, #0
1001da84:	ebffcea5 	bl	10011520 <rt_mq_create>
1001da88:	e1a02000 	mov	r2, r0
1001da8c:	e51b300c 	ldr	r3, [fp, #-12]
1001da90:	e5832004 	str	r2, [r3, #4]
        if (mqdes->mq == RT_NULL) /* create failed */
1001da94:	e51b300c 	ldr	r3, [fp, #-12]
1001da98:	e5933004 	ldr	r3, [r3, #4]
1001da9c:	e3530000 	cmp	r3, #0
1001daa0:	1a000002 	bne	1001dab0 <mq_open+0x118>
        {
            rt_set_errno(ENFILE);
1001daa4:	e3a00017 	mov	r0, #23
1001daa8:	ebffd1b7 	bl	1001218c <rt_set_errno>
            goto __return;
1001daac:	ea00001d 	b	1001db28 <mq_open+0x190>
        }
        /* initialize reference count */
        mqdes->refcount = 1;
1001dab0:	e51b300c 	ldr	r3, [fp, #-12]
1001dab4:	e3a02001 	mov	r2, #1
1001dab8:	e1c320b0 	strh	r2, [r3]
        mqdes->unlinked = 0;
1001dabc:	e51b300c 	ldr	r3, [fp, #-12]
1001dac0:	e3a02000 	mov	r2, #0
1001dac4:	e1c320b2 	strh	r2, [r3, #2]

        /* insert mq to posix mq list */
        posix_mq_insert(mqdes);
1001dac8:	e51b000c 	ldr	r0, [fp, #-12]
1001dacc:	ebffff14 	bl	1001d724 <posix_mq_insert>
1001dad0:	ea00000f 	b	1001db14 <mq_open+0x17c>
    }
    else
    {
        /* find mqueue */
        mqdes = posix_mq_find(name);
1001dad4:	e51b001c 	ldr	r0, [fp, #-28]
1001dad8:	ebffff5d 	bl	1001d854 <posix_mq_find>
1001dadc:	e50b000c 	str	r0, [fp, #-12]
        if (mqdes != RT_NULL)
1001dae0:	e51b300c 	ldr	r3, [fp, #-12]
1001dae4:	e3530000 	cmp	r3, #0
1001dae8:	0a000006 	beq	1001db08 <mq_open+0x170>
        {
            mqdes->refcount ++; /* increase reference count */
1001daec:	e51b300c 	ldr	r3, [fp, #-12]
1001daf0:	e1d330b0 	ldrh	r3, [r3]
1001daf4:	e2833001 	add	r3, r3, #1
1001daf8:	e6ff2073 	uxth	r2, r3
1001dafc:	e51b300c 	ldr	r3, [fp, #-12]
1001db00:	e1c320b0 	strh	r2, [r3]
1001db04:	ea000002 	b	1001db14 <mq_open+0x17c>
        }
        else
        {
            rt_set_errno(ENOENT);
1001db08:	e3a00002 	mov	r0, #2
1001db0c:	ebffd19e 	bl	1001218c <rt_set_errno>
            goto __return;
1001db10:	ea000004 	b	1001db28 <mq_open+0x190>
        }
    }
    rt_sem_release(&posix_mq_lock);
1001db14:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001db18:	e3410003 	movt	r0, #4099	; 0x1003
1001db1c:	ebffc6e6 	bl	1000f6bc <rt_sem_release>

    return mqdes;
1001db20:	e51b300c 	ldr	r3, [fp, #-12]
1001db24:	ea000010 	b	1001db6c <mq_open+0x1d4>

__return:
    /* release lock */
    rt_sem_release(&posix_mq_lock);
1001db28:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001db2c:	e3410003 	movt	r0, #4099	; 0x1003
1001db30:	ebffc6e1 	bl	1000f6bc <rt_sem_release>

    /* release allocated memory */
    if (mqdes != RT_NULL)
1001db34:	e51b300c 	ldr	r3, [fp, #-12]
1001db38:	e3530000 	cmp	r3, #0
1001db3c:	0a000009 	beq	1001db68 <mq_open+0x1d0>
    {
        if (mqdes->mq != RT_NULL)
1001db40:	e51b300c 	ldr	r3, [fp, #-12]
1001db44:	e5933004 	ldr	r3, [r3, #4]
1001db48:	e3530000 	cmp	r3, #0
1001db4c:	0a000003 	beq	1001db60 <mq_open+0x1c8>
        {
            /* delete RT-Thread message queue */
            rt_mq_delete(mqdes->mq);
1001db50:	e51b300c 	ldr	r3, [fp, #-12]
1001db54:	e5933004 	ldr	r3, [r3, #4]
1001db58:	e1a00003 	mov	r0, r3
1001db5c:	ebffcede 	bl	100116dc <rt_mq_delete>
        }
        rt_free(mqdes);
1001db60:	e51b000c 	ldr	r0, [fp, #-12]
1001db64:	ebffdbe5 	bl	10014b00 <rt_free>
    }
    return RT_NULL;
1001db68:	e3a03000 	mov	r3, #0
}
1001db6c:	e1a00003 	mov	r0, r3
1001db70:	e24bd004 	sub	sp, fp, #4
1001db74:	e8bd4800 	pop	{fp, lr}
1001db78:	e28dd00c 	add	sp, sp, #12
1001db7c:	e12fff1e 	bx	lr

1001db80 <mq_receive>:
RTM_EXPORT(mq_open);

ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio)
{
1001db80:	e92d4800 	push	{fp, lr}
1001db84:	e28db004 	add	fp, sp, #4
1001db88:	e24dd018 	sub	sp, sp, #24
1001db8c:	e50b0010 	str	r0, [fp, #-16]
1001db90:	e50b1014 	str	r1, [fp, #-20]
1001db94:	e50b2018 	str	r2, [fp, #-24]
1001db98:	e50b301c 	str	r3, [fp, #-28]
    rt_err_t result;

    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
1001db9c:	e51b3010 	ldr	r3, [fp, #-16]
1001dba0:	e3530000 	cmp	r3, #0
1001dba4:	0a000002 	beq	1001dbb4 <mq_receive+0x34>
1001dba8:	e51b3014 	ldr	r3, [fp, #-20]
1001dbac:	e3530000 	cmp	r3, #0
1001dbb0:	1a000003 	bne	1001dbc4 <mq_receive+0x44>
    {
        rt_set_errno(EINVAL);
1001dbb4:	e3a00016 	mov	r0, #22
1001dbb8:	ebffd173 	bl	1001218c <rt_set_errno>

        return -1;
1001dbbc:	e3e03000 	mvn	r3, #0
1001dbc0:	ea00000f 	b	1001dc04 <mq_receive+0x84>
    }

    result = rt_mq_recv(mqdes->mq, msg_ptr, msg_len, RT_WAITING_FOREVER);
1001dbc4:	e51b3010 	ldr	r3, [fp, #-16]
1001dbc8:	e5933004 	ldr	r3, [r3, #4]
1001dbcc:	e1a00003 	mov	r0, r3
1001dbd0:	e51b1014 	ldr	r1, [fp, #-20]
1001dbd4:	e51b2018 	ldr	r2, [fp, #-24]
1001dbd8:	e3e03000 	mvn	r3, #0
1001dbdc:	ebffcff0 	bl	10011ba4 <rt_mq_recv>
1001dbe0:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
1001dbe4:	e51b3008 	ldr	r3, [fp, #-8]
1001dbe8:	e3530000 	cmp	r3, #0
1001dbec:	1a000001 	bne	1001dbf8 <mq_receive+0x78>
        return msg_len;
1001dbf0:	e51b3018 	ldr	r3, [fp, #-24]
1001dbf4:	ea000002 	b	1001dc04 <mq_receive+0x84>

    rt_set_errno(EBADF);
1001dbf8:	e3a00009 	mov	r0, #9
1001dbfc:	ebffd162 	bl	1001218c <rt_set_errno>
    return -1;
1001dc00:	e3e03000 	mvn	r3, #0
}
1001dc04:	e1a00003 	mov	r0, r3
1001dc08:	e24bd004 	sub	sp, fp, #4
1001dc0c:	e8bd8800 	pop	{fp, pc}

1001dc10 <mq_send>:
RTM_EXPORT(mq_receive);

int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio)
{
1001dc10:	e92d4800 	push	{fp, lr}
1001dc14:	e28db004 	add	fp, sp, #4
1001dc18:	e24dd018 	sub	sp, sp, #24
1001dc1c:	e50b0010 	str	r0, [fp, #-16]
1001dc20:	e50b1014 	str	r1, [fp, #-20]
1001dc24:	e50b2018 	str	r2, [fp, #-24]
1001dc28:	e50b301c 	str	r3, [fp, #-28]
    rt_err_t result;

    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
1001dc2c:	e51b3010 	ldr	r3, [fp, #-16]
1001dc30:	e3530000 	cmp	r3, #0
1001dc34:	0a000002 	beq	1001dc44 <mq_send+0x34>
1001dc38:	e51b3014 	ldr	r3, [fp, #-20]
1001dc3c:	e3530000 	cmp	r3, #0
1001dc40:	1a000003 	bne	1001dc54 <mq_send+0x44>
    {
        rt_set_errno(EINVAL);
1001dc44:	e3a00016 	mov	r0, #22
1001dc48:	ebffd14f 	bl	1001218c <rt_set_errno>

        return -1;
1001dc4c:	e3e03000 	mvn	r3, #0
1001dc50:	ea00000e 	b	1001dc90 <mq_send+0x80>
    }

    result = rt_mq_send(mqdes->mq, (void*)msg_ptr, msg_len);
1001dc54:	e51b3010 	ldr	r3, [fp, #-16]
1001dc58:	e5933004 	ldr	r3, [r3, #4]
1001dc5c:	e1a00003 	mov	r0, r3
1001dc60:	e51b1014 	ldr	r1, [fp, #-20]
1001dc64:	e51b2018 	ldr	r2, [fp, #-24]
1001dc68:	ebffceca 	bl	10011798 <rt_mq_send>
1001dc6c:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
1001dc70:	e51b3008 	ldr	r3, [fp, #-8]
1001dc74:	e3530000 	cmp	r3, #0
1001dc78:	1a000001 	bne	1001dc84 <mq_send+0x74>
        return 0;
1001dc7c:	e3a03000 	mov	r3, #0
1001dc80:	ea000002 	b	1001dc90 <mq_send+0x80>

    rt_set_errno(EBADF);
1001dc84:	e3a00009 	mov	r0, #9
1001dc88:	ebffd13f 	bl	1001218c <rt_set_errno>

    return -1;
1001dc8c:	e3e03000 	mvn	r3, #0
}
1001dc90:	e1a00003 	mov	r0, r3
1001dc94:	e24bd004 	sub	sp, fp, #4
1001dc98:	e8bd8800 	pop	{fp, pc}

1001dc9c <mq_timedreceive>:
ssize_t mq_timedreceive(mqd_t                  mqdes,
                        char                  *msg_ptr,
                        size_t                 msg_len,
                        unsigned              *msg_prio,
                        const struct timespec *abs_timeout)
{
1001dc9c:	e92d4800 	push	{fp, lr}
1001dca0:	e28db004 	add	fp, sp, #4
1001dca4:	e24dd018 	sub	sp, sp, #24
1001dca8:	e50b0010 	str	r0, [fp, #-16]
1001dcac:	e50b1014 	str	r1, [fp, #-20]
1001dcb0:	e50b2018 	str	r2, [fp, #-24]
1001dcb4:	e50b301c 	str	r3, [fp, #-28]
    int tick;
    rt_err_t result;

    /* parameters check */
    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
1001dcb8:	e51b3010 	ldr	r3, [fp, #-16]
1001dcbc:	e3530000 	cmp	r3, #0
1001dcc0:	0a000002 	beq	1001dcd0 <mq_timedreceive+0x34>
1001dcc4:	e51b3014 	ldr	r3, [fp, #-20]
1001dcc8:	e3530000 	cmp	r3, #0
1001dccc:	1a000003 	bne	1001dce0 <mq_timedreceive+0x44>
    {
        rt_set_errno(EINVAL);
1001dcd0:	e3a00016 	mov	r0, #22
1001dcd4:	ebffd12c 	bl	1001218c <rt_set_errno>

        return -1;
1001dcd8:	e3e03000 	mvn	r3, #0
1001dcdc:	ea000018 	b	1001dd44 <mq_timedreceive+0xa8>
    }

    tick = clock_time_to_tick(abs_timeout);
1001dce0:	e59b0004 	ldr	r0, [fp, #4]
1001dce4:	ebfffd85 	bl	1001d300 <clock_time_to_tick>
1001dce8:	e50b0008 	str	r0, [fp, #-8]

    result = rt_mq_recv(mqdes->mq, msg_ptr, msg_len, tick);
1001dcec:	e51b3010 	ldr	r3, [fp, #-16]
1001dcf0:	e5933004 	ldr	r3, [r3, #4]
1001dcf4:	e1a00003 	mov	r0, r3
1001dcf8:	e51b1014 	ldr	r1, [fp, #-20]
1001dcfc:	e51b2018 	ldr	r2, [fp, #-24]
1001dd00:	e51b3008 	ldr	r3, [fp, #-8]
1001dd04:	ebffcfa6 	bl	10011ba4 <rt_mq_recv>
1001dd08:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
1001dd0c:	e51b300c 	ldr	r3, [fp, #-12]
1001dd10:	e3530000 	cmp	r3, #0
1001dd14:	1a000001 	bne	1001dd20 <mq_timedreceive+0x84>
        return msg_len;
1001dd18:	e51b3018 	ldr	r3, [fp, #-24]
1001dd1c:	ea000008 	b	1001dd44 <mq_timedreceive+0xa8>

    if (result == -RT_ETIMEOUT)
1001dd20:	e51b300c 	ldr	r3, [fp, #-12]
1001dd24:	e3730002 	cmn	r3, #2
1001dd28:	1a000002 	bne	1001dd38 <mq_timedreceive+0x9c>
        rt_set_errno(ETIMEDOUT);
1001dd2c:	e3a00074 	mov	r0, #116	; 0x74
1001dd30:	ebffd115 	bl	1001218c <rt_set_errno>
1001dd34:	ea000001 	b	1001dd40 <mq_timedreceive+0xa4>
    else
        rt_set_errno(EBADMSG);
1001dd38:	e3a0004d 	mov	r0, #77	; 0x4d
1001dd3c:	ebffd112 	bl	1001218c <rt_set_errno>

    return -1;
1001dd40:	e3e03000 	mvn	r3, #0
}
1001dd44:	e1a00003 	mov	r0, r3
1001dd48:	e24bd004 	sub	sp, fp, #4
1001dd4c:	e8bd8800 	pop	{fp, pc}

1001dd50 <mq_timedsend>:
int mq_timedsend(mqd_t                  mqdes,
                 const char            *msg_ptr,
                 size_t                 msg_len,
                 unsigned               msg_prio,
                 const struct timespec *abs_timeout)
{
1001dd50:	e92d4800 	push	{fp, lr}
1001dd54:	e28db004 	add	fp, sp, #4
1001dd58:	e24dd010 	sub	sp, sp, #16
1001dd5c:	e50b0008 	str	r0, [fp, #-8]
1001dd60:	e50b100c 	str	r1, [fp, #-12]
1001dd64:	e50b2010 	str	r2, [fp, #-16]
1001dd68:	e50b3014 	str	r3, [fp, #-20]
    /* RT-Thread does not support timed send */
    return mq_send(mqdes, msg_ptr, msg_len, msg_prio);
1001dd6c:	e51b0008 	ldr	r0, [fp, #-8]
1001dd70:	e51b100c 	ldr	r1, [fp, #-12]
1001dd74:	e51b2010 	ldr	r2, [fp, #-16]
1001dd78:	e51b3014 	ldr	r3, [fp, #-20]
1001dd7c:	ebffffa3 	bl	1001dc10 <mq_send>
1001dd80:	e1a03000 	mov	r3, r0
}
1001dd84:	e1a00003 	mov	r0, r3
1001dd88:	e24bd004 	sub	sp, fp, #4
1001dd8c:	e8bd8800 	pop	{fp, pc}

1001dd90 <mq_notify>:
RTM_EXPORT(mq_timedsend);

int mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
1001dd90:	e92d4800 	push	{fp, lr}
1001dd94:	e28db004 	add	fp, sp, #4
1001dd98:	e24dd008 	sub	sp, sp, #8
1001dd9c:	e50b0008 	str	r0, [fp, #-8]
1001dda0:	e50b100c 	str	r1, [fp, #-12]
    rt_set_errno(-RT_ERROR);
1001dda4:	e3e00000 	mvn	r0, #0
1001dda8:	ebffd0f7 	bl	1001218c <rt_set_errno>

    return -1;
1001ddac:	e3e03000 	mvn	r3, #0
}
1001ddb0:	e1a00003 	mov	r0, r3
1001ddb4:	e24bd004 	sub	sp, fp, #4
1001ddb8:	e8bd8800 	pop	{fp, pc}

1001ddbc <mq_close>:
RTM_EXPORT(mq_notify);

int mq_close(mqd_t mqdes)
{
1001ddbc:	e92d4800 	push	{fp, lr}
1001ddc0:	e28db004 	add	fp, sp, #4
1001ddc4:	e24dd008 	sub	sp, sp, #8
1001ddc8:	e50b0008 	str	r0, [fp, #-8]
    if (mqdes == RT_NULL)
1001ddcc:	e51b3008 	ldr	r3, [fp, #-8]
1001ddd0:	e3530000 	cmp	r3, #0
1001ddd4:	1a000003 	bne	1001dde8 <mq_close+0x2c>
    {
        rt_set_errno(EINVAL);
1001ddd8:	e3a00016 	mov	r0, #22
1001dddc:	ebffd0ea 	bl	1001218c <rt_set_errno>

        return -1;
1001dde0:	e3e03000 	mvn	r3, #0
1001dde4:	ea000017 	b	1001de48 <mq_close+0x8c>
    }

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
1001dde8:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001ddec:	e3410003 	movt	r0, #4099	; 0x1003
1001ddf0:	e3e01000 	mvn	r1, #0
1001ddf4:	ebffc59c 	bl	1000f46c <rt_sem_take>
    mqdes->refcount --;
1001ddf8:	e51b3008 	ldr	r3, [fp, #-8]
1001ddfc:	e1d330b0 	ldrh	r3, [r3]
1001de00:	e2433001 	sub	r3, r3, #1
1001de04:	e6ff2073 	uxth	r2, r3
1001de08:	e51b3008 	ldr	r3, [fp, #-8]
1001de0c:	e1c320b0 	strh	r2, [r3]
    if (mqdes->refcount == 0)
1001de10:	e51b3008 	ldr	r3, [fp, #-8]
1001de14:	e1d330b0 	ldrh	r3, [r3]
1001de18:	e3530000 	cmp	r3, #0
1001de1c:	1a000005 	bne	1001de38 <mq_close+0x7c>
    {
        /* delete from posix mqueue list */
        if (mqdes->unlinked)
1001de20:	e51b3008 	ldr	r3, [fp, #-8]
1001de24:	e1d330b2 	ldrh	r3, [r3, #2]
1001de28:	e3530000 	cmp	r3, #0
1001de2c:	0a000001 	beq	1001de38 <mq_close+0x7c>
            posix_mq_delete(mqdes);
1001de30:	e51b0008 	ldr	r0, [fp, #-8]
1001de34:	ebfffe4a 	bl	1001d764 <posix_mq_delete>
    }
    rt_sem_release(&posix_mq_lock);
1001de38:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001de3c:	e3410003 	movt	r0, #4099	; 0x1003
1001de40:	ebffc61d 	bl	1000f6bc <rt_sem_release>

    return 0;
1001de44:	e3a03000 	mov	r3, #0
}
1001de48:	e1a00003 	mov	r0, r3
1001de4c:	e24bd004 	sub	sp, fp, #4
1001de50:	e8bd8800 	pop	{fp, pc}

1001de54 <mq_unlink>:
RTM_EXPORT(mq_close);

int mq_unlink(const char *name)
{
1001de54:	e92d4800 	push	{fp, lr}
1001de58:	e28db004 	add	fp, sp, #4
1001de5c:	e24dd010 	sub	sp, sp, #16
1001de60:	e50b0010 	str	r0, [fp, #-16]
    mqd_t pmq;

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
1001de64:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001de68:	e3410003 	movt	r0, #4099	; 0x1003
1001de6c:	e3e01000 	mvn	r1, #0
1001de70:	ebffc57d 	bl	1000f46c <rt_sem_take>
    pmq = posix_mq_find(name);
1001de74:	e51b0010 	ldr	r0, [fp, #-16]
1001de78:	ebfffe75 	bl	1001d854 <posix_mq_find>
1001de7c:	e50b0008 	str	r0, [fp, #-8]
    if (pmq != RT_NULL)
1001de80:	e51b3008 	ldr	r3, [fp, #-8]
1001de84:	e3530000 	cmp	r3, #0
1001de88:	0a00000d 	beq	1001dec4 <mq_unlink+0x70>
    {
        pmq->unlinked = 1;
1001de8c:	e51b3008 	ldr	r3, [fp, #-8]
1001de90:	e3a02001 	mov	r2, #1
1001de94:	e1c320b2 	strh	r2, [r3, #2]
        if (pmq->refcount == 0)
1001de98:	e51b3008 	ldr	r3, [fp, #-8]
1001de9c:	e1d330b0 	ldrh	r3, [r3]
1001dea0:	e3530000 	cmp	r3, #0
1001dea4:	1a000001 	bne	1001deb0 <mq_unlink+0x5c>
        {
            /* remove this mqueue */
            posix_mq_delete(pmq);
1001dea8:	e51b0008 	ldr	r0, [fp, #-8]
1001deac:	ebfffe2c 	bl	1001d764 <posix_mq_delete>
        }
        rt_sem_release(&posix_mq_lock);
1001deb0:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001deb4:	e3410003 	movt	r0, #4099	; 0x1003
1001deb8:	ebffc5ff 	bl	1000f6bc <rt_sem_release>

        return 0;
1001debc:	e3a03000 	mov	r3, #0
1001dec0:	ea000005 	b	1001dedc <mq_unlink+0x88>
    }
    rt_sem_release(&posix_mq_lock);
1001dec4:	e30e07f4 	movw	r0, #59380	; 0xe7f4
1001dec8:	e3410003 	movt	r0, #4099	; 0x1003
1001decc:	ebffc5fa 	bl	1000f6bc <rt_sem_release>

    /* no this entry */
    rt_set_errno(ENOENT);
1001ded0:	e3a00002 	mov	r0, #2
1001ded4:	ebffd0ac 	bl	1001218c <rt_set_errno>

    return -1;
1001ded8:	e3e03000 	mvn	r3, #0
}
1001dedc:	e1a00003 	mov	r0, r3
1001dee0:	e24bd004 	sub	sp, fp, #4
1001dee4:	e8bd8800 	pop	{fp, pc}

1001dee8 <_pthread_get_data>:
    void** tls; /* thread-local storage area */
};
typedef struct _pthread_data _pthread_data_t;

rt_inline _pthread_data_t *_pthread_get_data(pthread_t thread)
{
1001dee8:	e92d4800 	push	{fp, lr}
1001deec:	e28db004 	add	fp, sp, #4
1001def0:	e24dd010 	sub	sp, sp, #16
1001def4:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    RT_ASSERT(thread != RT_NULL);
1001def8:	e51b3010 	ldr	r3, [fp, #-16]
1001defc:	e3530000 	cmp	r3, #0
1001df00:	1a000005 	bne	1001df1c <_pthread_get_data+0x34>
1001df04:	e30409f0 	movw	r0, #18928	; 0x49f0
1001df08:	e3410003 	movt	r0, #4099	; 0x1003
1001df0c:	e3041a78 	movw	r1, #19064	; 0x4a78
1001df10:	e3411003 	movt	r1, #4099	; 0x1003
1001df14:	e3a0204c 	mov	r2, #76	; 0x4c
1001df18:	ebffd7a5 	bl	10013db4 <rt_assert_handler>

    ptd = (_pthread_data_t *)thread->user_data;
1001df1c:	e51b3010 	ldr	r3, [fp, #-16]
1001df20:	e5933074 	ldr	r3, [r3, #116]	; 0x74
1001df24:	e50b3008 	str	r3, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1001df28:	e51b3008 	ldr	r3, [fp, #-8]
1001df2c:	e3530000 	cmp	r3, #0
1001df30:	1a000005 	bne	1001df4c <_pthread_get_data+0x64>
1001df34:	e3040a04 	movw	r0, #18948	; 0x4a04
1001df38:	e3410003 	movt	r0, #4099	; 0x1003
1001df3c:	e3041a78 	movw	r1, #19064	; 0x4a78
1001df40:	e3411003 	movt	r1, #4099	; 0x1003
1001df44:	e3a0204f 	mov	r2, #79	; 0x4f
1001df48:	ebffd799 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(ptd->magic == PTHREAD_MAGIC);
1001df4c:	e51b3008 	ldr	r3, [fp, #-8]
1001df50:	e5932000 	ldr	r2, [r3]
1001df54:	e3063873 	movw	r3, #26739	; 0x6873
1001df58:	e3473074 	movt	r3, #28788	; 0x7074
1001df5c:	e1520003 	cmp	r2, r3
1001df60:	0a000005 	beq	1001df7c <_pthread_get_data+0x94>
1001df64:	e3040a14 	movw	r0, #18964	; 0x4a14
1001df68:	e3410003 	movt	r0, #4099	; 0x1003
1001df6c:	e3041a78 	movw	r1, #19064	; 0x4a78
1001df70:	e3411003 	movt	r1, #4099	; 0x1003
1001df74:	e3a02050 	mov	r2, #80	; 0x50
1001df78:	ebffd78d 	bl	10013db4 <rt_assert_handler>

    return ptd;
1001df7c:	e51b3008 	ldr	r3, [fp, #-8]
}
1001df80:	e1a00003 	mov	r0, r3
1001df84:	e24bd004 	sub	sp, fp, #4
1001df88:	e8bd8800 	pop	{fp, pc}

1001df8c <pthread_system_init>:
#include <pthread.h>
#include <sched.h>
#include "pthread_internal.h"

int pthread_system_init(void)
{
1001df8c:	e92d4800 	push	{fp, lr}
1001df90:	e28db004 	add	fp, sp, #4
    /* initialize clock and time */
    clock_time_system_init();
1001df94:	ebfffc9f 	bl	1001d218 <clock_time_system_init>

    /* initialize key area */
    pthread_key_system_init();
1001df98:	eb0004c6 	bl	1001f2b8 <pthread_key_system_init>
    /* initialize posix mqueue */
    posix_mq_system_init();
1001df9c:	ebfffdd6 	bl	1001d6fc <posix_mq_system_init>
    /* initialize posix semaphore */
    posix_sem_system_init();
1001dfa0:	eb000571 	bl	1001f56c <posix_sem_system_init>

    return 0;
1001dfa4:	e3a03000 	mov	r3, #0
}
1001dfa8:	e1a00003 	mov	r0, r3
1001dfac:	e8bd8800 	pop	{fp, pc}

1001dfb0 <_pthread_cleanup>:

static void _pthread_cleanup(rt_thread_t tid)
{
1001dfb0:	e92d4800 	push	{fp, lr}
1001dfb4:	e28db004 	add	fp, sp, #4
1001dfb8:	e24dd010 	sub	sp, sp, #16
1001dfbc:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    ptd = _pthread_get_data(tid);
1001dfc0:	e51b0010 	ldr	r0, [fp, #-16]
1001dfc4:	ebffffc7 	bl	1001dee8 <_pthread_get_data>
1001dfc8:	e50b0008 	str	r0, [fp, #-8]

    /* clear cleanup function */
    tid->cleanup = RT_NULL;
1001dfcc:	e51b3010 	ldr	r3, [fp, #-16]
1001dfd0:	e3a02000 	mov	r2, #0
1001dfd4:	e5832070 	str	r2, [r3, #112]	; 0x70
    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
1001dfd8:	e51b3008 	ldr	r3, [fp, #-8]
1001dfdc:	e5d3300b 	ldrb	r3, [r3, #11]
1001dfe0:	e3530000 	cmp	r3, #0
1001dfe4:	1a000004 	bne	1001dffc <_pthread_cleanup+0x4c>
    {
        rt_sem_release(ptd->joinable_sem);
1001dfe8:	e51b3008 	ldr	r3, [fp, #-8]
1001dfec:	e5933020 	ldr	r3, [r3, #32]
1001dff0:	e1a00003 	mov	r0, r3
1001dff4:	ebffc5b0 	bl	1000f6bc <rt_sem_release>
1001dff8:	ea000001 	b	1001e004 <_pthread_cleanup+0x54>
    }
    else
    {
        /* release pthread resource */
        pthread_detach(tid);
1001dffc:	e51b0010 	ldr	r0, [fp, #-16]
1001e000:	eb0000f9 	bl	1001e3ec <pthread_detach>
    }
}
1001e004:	e24bd004 	sub	sp, fp, #4
1001e008:	e8bd8800 	pop	{fp, pc}

1001e00c <pthread_entry_stub>:

static void pthread_entry_stub(void *parameter)
{
1001e00c:	e92d4800 	push	{fp, lr}
1001e010:	e28db004 	add	fp, sp, #4
1001e014:	e24dd010 	sub	sp, sp, #16
1001e018:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    void *value;

    ptd = (_pthread_data_t*)parameter;
1001e01c:	e51b3010 	ldr	r3, [fp, #-16]
1001e020:	e50b3008 	str	r3, [fp, #-8]

    /* execute pthread entry */
    value = ptd->thread_entry(ptd->thread_parameter);
1001e024:	e51b3008 	ldr	r3, [fp, #-8]
1001e028:	e5933014 	ldr	r3, [r3, #20]
1001e02c:	e51b2008 	ldr	r2, [fp, #-8]
1001e030:	e5922018 	ldr	r2, [r2, #24]
1001e034:	e1a00002 	mov	r0, r2
1001e038:	e12fff33 	blx	r3
1001e03c:	e50b000c 	str	r0, [fp, #-12]
    /* set value */
    ptd->return_value = value;
1001e040:	e51b3008 	ldr	r3, [fp, #-8]
1001e044:	e51b200c 	ldr	r2, [fp, #-12]
1001e048:	e583201c 	str	r2, [r3, #28]
}
1001e04c:	e24bd004 	sub	sp, fp, #4
1001e050:	e8bd8800 	pop	{fp, pc}

1001e054 <pthread_create>:

int pthread_create(pthread_t            *tid,
                   const pthread_attr_t *attr, 
                   void *(*start) (void *), void *parameter)
{
1001e054:	e92d4800 	push	{fp, lr}
1001e058:	e28db004 	add	fp, sp, #4
1001e05c:	e24dd038 	sub	sp, sp, #56	; 0x38
1001e060:	e50b0020 	str	r0, [fp, #-32]
1001e064:	e50b1024 	str	r1, [fp, #-36]	; 0x24
1001e068:	e50b2028 	str	r2, [fp, #-40]	; 0x28
1001e06c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    char name[RT_NAME_MAX];
    static rt_uint16_t pthread_number = 0;
    _pthread_data_t *ptd;

    /* tid shall be provided */
    RT_ASSERT(tid != RT_NULL);
1001e070:	e51b3020 	ldr	r3, [fp, #-32]
1001e074:	e3530000 	cmp	r3, #0
1001e078:	1a000005 	bne	1001e094 <pthread_create+0x40>
1001e07c:	e3040a30 	movw	r0, #18992	; 0x4a30
1001e080:	e3410003 	movt	r0, #4099	; 0x1003
1001e084:	e3041a8c 	movw	r1, #19084	; 0x4a8c
1001e088:	e3411003 	movt	r1, #4099	; 0x1003
1001e08c:	e3a02055 	mov	r2, #85	; 0x55
1001e090:	ebffd747 	bl	10013db4 <rt_assert_handler>

    /* allocate posix thread data */
    ptd = (_pthread_data_t*)rt_malloc(sizeof(_pthread_data_t));
1001e094:	e3a00030 	mov	r0, #48	; 0x30
1001e098:	ebffd87d 	bl	10014294 <rt_malloc>
1001e09c:	e50b000c 	str	r0, [fp, #-12]
    if (ptd == RT_NULL)
1001e0a0:	e51b300c 	ldr	r3, [fp, #-12]
1001e0a4:	e3530000 	cmp	r3, #0
1001e0a8:	1a000001 	bne	1001e0b4 <pthread_create+0x60>
        return ENOMEM;
1001e0ac:	e3a0300c 	mov	r3, #12
1001e0b0:	ea0000ca 	b	1001e3e0 <pthread_create+0x38c>
    /* clean posix thread data memory */
    rt_memset(ptd, 0, sizeof(_pthread_data_t));
1001e0b4:	e51b000c 	ldr	r0, [fp, #-12]
1001e0b8:	e3a01000 	mov	r1, #0
1001e0bc:	e3a02030 	mov	r2, #48	; 0x30
1001e0c0:	ebffd064 	bl	10012258 <rt_memset>
    ptd->canceled = 0;
1001e0c4:	e51b300c 	ldr	r3, [fp, #-12]
1001e0c8:	e3a02000 	mov	r2, #0
1001e0cc:	e5c32026 	strb	r2, [r3, #38]	; 0x26
    ptd->cancelstate = PTHREAD_CANCEL_DISABLE;
1001e0d0:	e51b300c 	ldr	r3, [fp, #-12]
1001e0d4:	e3a02003 	mov	r2, #3
1001e0d8:	e5c32024 	strb	r2, [r3, #36]	; 0x24
    ptd->canceltype = PTHREAD_CANCEL_DEFERRED;
1001e0dc:	e51b300c 	ldr	r3, [fp, #-12]
1001e0e0:	e3a02002 	mov	r2, #2
1001e0e4:	e5c32025 	strb	r2, [r3, #37]	; 0x25
    ptd->magic = PTHREAD_MAGIC;
1001e0e8:	e51b200c 	ldr	r2, [fp, #-12]
1001e0ec:	e3063873 	movw	r3, #26739	; 0x6873
1001e0f0:	e3473074 	movt	r3, #28788	; 0x7074
1001e0f4:	e5823000 	str	r3, [r2]

    if (attr != RT_NULL)
1001e0f8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1001e0fc:	e3530000 	cmp	r3, #0
1001e100:	0a000005 	beq	1001e11c <pthread_create+0xc8>
        ptd->attr = *attr;
1001e104:	e51b300c 	ldr	r3, [fp, #-12]
1001e108:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1001e10c:	e2833004 	add	r3, r3, #4
1001e110:	e8920007 	ldm	r2, {r0, r1, r2}
1001e114:	e8830007 	stm	r3, {r0, r1, r2}
1001e118:	ea000003 	b	1001e12c <pthread_create+0xd8>
    else 
    {
        /* use default attribute */
        pthread_attr_init(&ptd->attr);
1001e11c:	e51b300c 	ldr	r3, [fp, #-12]
1001e120:	e2833004 	add	r3, r3, #4
1001e124:	e1a00003 	mov	r0, r3
1001e128:	eb0002b1 	bl	1001ebf4 <pthread_attr_init>
    }

    rt_snprintf(name, sizeof(name), "pth%02d", pthread_number ++);
1001e12c:	e30e3810 	movw	r3, #59408	; 0xe810
1001e130:	e3413003 	movt	r3, #4099	; 0x1003
1001e134:	e1d320b0 	ldrh	r2, [r3]
1001e138:	e2823001 	add	r3, r2, #1
1001e13c:	e6ff1073 	uxth	r1, r3
1001e140:	e30e3810 	movw	r3, #59408	; 0xe810
1001e144:	e3413003 	movt	r3, #4099	; 0x1003
1001e148:	e1c310b0 	strh	r1, [r3]
1001e14c:	e1a0c002 	mov	ip, r2
1001e150:	e24b3018 	sub	r3, fp, #24
1001e154:	e1a00003 	mov	r0, r3
1001e158:	e3a01006 	mov	r1, #6
1001e15c:	e3042a40 	movw	r2, #19008	; 0x4a40
1001e160:	e3412003 	movt	r2, #4099	; 0x1003
1001e164:	e1a0300c 	mov	r3, ip
1001e168:	ebffd5ec 	bl	10013920 <rt_snprintf>
    if (ptd->attr.stack_base == 0)
1001e16c:	e51b300c 	ldr	r3, [fp, #-12]
1001e170:	e5933004 	ldr	r3, [r3, #4]
1001e174:	e3530000 	cmp	r3, #0
1001e178:	1a000005 	bne	1001e194 <pthread_create+0x140>
    {
        stack = (void*)rt_malloc(ptd->attr.stack_size);
1001e17c:	e51b300c 	ldr	r3, [fp, #-12]
1001e180:	e1d330b8 	ldrh	r3, [r3, #8]
1001e184:	e1a00003 	mov	r0, r3
1001e188:	ebffd841 	bl	10014294 <rt_malloc>
1001e18c:	e50b0008 	str	r0, [fp, #-8]
1001e190:	ea000002 	b	1001e1a0 <pthread_create+0x14c>
    }
    else
        stack = (void*)(ptd->attr.stack_base);
1001e194:	e51b300c 	ldr	r3, [fp, #-12]
1001e198:	e5933004 	ldr	r3, [r3, #4]
1001e19c:	e50b3008 	str	r3, [fp, #-8]

    if (stack == RT_NULL) 
1001e1a0:	e51b3008 	ldr	r3, [fp, #-8]
1001e1a4:	e3530000 	cmp	r3, #0
1001e1a8:	1a000003 	bne	1001e1bc <pthread_create+0x168>
    {
        rt_free(ptd);
1001e1ac:	e51b000c 	ldr	r0, [fp, #-12]
1001e1b0:	ebffda52 	bl	10014b00 <rt_free>

        return ENOMEM;
1001e1b4:	e3a0300c 	mov	r3, #12
1001e1b8:	ea000088 	b	1001e3e0 <pthread_create+0x38c>
    }

    /* pthread is a static thread object */
    ptd->tid = (rt_thread_t) rt_malloc(sizeof(struct rt_thread));
1001e1bc:	e3a00078 	mov	r0, #120	; 0x78
1001e1c0:	ebffd833 	bl	10014294 <rt_malloc>
1001e1c4:	e1a02000 	mov	r2, r0
1001e1c8:	e51b300c 	ldr	r3, [fp, #-12]
1001e1cc:	e5832010 	str	r2, [r3, #16]
    if (ptd->tid == RT_NULL)
1001e1d0:	e51b300c 	ldr	r3, [fp, #-12]
1001e1d4:	e5933010 	ldr	r3, [r3, #16]
1001e1d8:	e3530000 	cmp	r3, #0
1001e1dc:	1a000009 	bne	1001e208 <pthread_create+0x1b4>
    {
        if (ptd->attr.stack_base == 0)
1001e1e0:	e51b300c 	ldr	r3, [fp, #-12]
1001e1e4:	e5933004 	ldr	r3, [r3, #4]
1001e1e8:	e3530000 	cmp	r3, #0
1001e1ec:	1a000001 	bne	1001e1f8 <pthread_create+0x1a4>
            rt_free(stack);
1001e1f0:	e51b0008 	ldr	r0, [fp, #-8]
1001e1f4:	ebffda41 	bl	10014b00 <rt_free>
        rt_free(ptd);
1001e1f8:	e51b000c 	ldr	r0, [fp, #-12]
1001e1fc:	ebffda3f 	bl	10014b00 <rt_free>

        return ENOMEM;
1001e200:	e3a0300c 	mov	r3, #12
1001e204:	ea000075 	b	1001e3e0 <pthread_create+0x38c>
    }

    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
1001e208:	e51b300c 	ldr	r3, [fp, #-12]
1001e20c:	e5d3300b 	ldrb	r3, [r3, #11]
1001e210:	e3530000 	cmp	r3, #0
1001e214:	1a000015 	bne	1001e270 <pthread_create+0x21c>
    {
        ptd->joinable_sem = rt_sem_create(name, 0, RT_IPC_FLAG_FIFO);
1001e218:	e24b3018 	sub	r3, fp, #24
1001e21c:	e1a00003 	mov	r0, r3
1001e220:	e3a01000 	mov	r1, #0
1001e224:	e3a02000 	mov	r2, #0
1001e228:	ebffc433 	bl	1000f2fc <rt_sem_create>
1001e22c:	e1a02000 	mov	r2, r0
1001e230:	e51b300c 	ldr	r3, [fp, #-12]
1001e234:	e5832020 	str	r2, [r3, #32]
        if (ptd->joinable_sem == RT_NULL)
1001e238:	e51b300c 	ldr	r3, [fp, #-12]
1001e23c:	e5933020 	ldr	r3, [r3, #32]
1001e240:	e3530000 	cmp	r3, #0
1001e244:	1a00000c 	bne	1001e27c <pthread_create+0x228>
        {
            if (ptd->attr.stack_base != 0)
1001e248:	e51b300c 	ldr	r3, [fp, #-12]
1001e24c:	e5933004 	ldr	r3, [r3, #4]
1001e250:	e3530000 	cmp	r3, #0
1001e254:	0a000001 	beq	1001e260 <pthread_create+0x20c>
                rt_free(stack);
1001e258:	e51b0008 	ldr	r0, [fp, #-8]
1001e25c:	ebffda27 	bl	10014b00 <rt_free>
            rt_free(ptd);
1001e260:	e51b000c 	ldr	r0, [fp, #-12]
1001e264:	ebffda25 	bl	10014b00 <rt_free>

            return ENOMEM;
1001e268:	e3a0300c 	mov	r3, #12
1001e26c:	ea00005b 	b	1001e3e0 <pthread_create+0x38c>
        }
    }
    else
        ptd->joinable_sem = RT_NULL;
1001e270:	e51b300c 	ldr	r3, [fp, #-12]
1001e274:	e3a02000 	mov	r2, #0
1001e278:	e5832020 	str	r2, [r3, #32]

    /* set parameter */
    ptd->thread_entry = start;
1001e27c:	e51b300c 	ldr	r3, [fp, #-12]
1001e280:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1001e284:	e5832014 	str	r2, [r3, #20]
    ptd->thread_parameter = parameter;
1001e288:	e51b300c 	ldr	r3, [fp, #-12]
1001e28c:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
1001e290:	e5832018 	str	r2, [r3, #24]

    /* initial this pthread to system */
    if (rt_thread_init(ptd->tid, name, pthread_entry_stub, ptd, 
1001e294:	e51b300c 	ldr	r3, [fp, #-12]
1001e298:	e5930010 	ldr	r0, [r3, #16]
        stack, ptd->attr.stack_size, 
1001e29c:	e51b300c 	ldr	r3, [fp, #-12]
1001e2a0:	e1d330b8 	ldrh	r3, [r3, #8]
    /* set parameter */
    ptd->thread_entry = start;
    ptd->thread_parameter = parameter;

    /* initial this pthread to system */
    if (rt_thread_init(ptd->tid, name, pthread_entry_stub, ptd, 
1001e2a4:	e1a0c003 	mov	ip, r3
1001e2a8:	e51b300c 	ldr	r3, [fp, #-12]
1001e2ac:	e5d3300a 	ldrb	r3, [r3, #10]
1001e2b0:	e24b1018 	sub	r1, fp, #24
1001e2b4:	e51b2008 	ldr	r2, [fp, #-8]
1001e2b8:	e58d2000 	str	r2, [sp]
1001e2bc:	e58dc004 	str	ip, [sp, #4]
1001e2c0:	e58d3008 	str	r3, [sp, #8]
1001e2c4:	e3a03005 	mov	r3, #5
1001e2c8:	e58d300c 	str	r3, [sp, #12]
1001e2cc:	e30e200c 	movw	r2, #57356	; 0xe00c
1001e2d0:	e3412001 	movt	r2, #4097	; 0x1001
1001e2d4:	e51b300c 	ldr	r3, [fp, #-12]
1001e2d8:	ebffe172 	bl	100168a8 <rt_thread_init>
1001e2dc:	e1a03000 	mov	r3, r0
1001e2e0:	e3530000 	cmp	r3, #0
1001e2e4:	0a000011 	beq	1001e330 <pthread_create+0x2dc>
        stack, ptd->attr.stack_size, 
        ptd->attr.priority, 5) != RT_EOK)
    {
        if (ptd->attr.stack_base == 0)
1001e2e8:	e51b300c 	ldr	r3, [fp, #-12]
1001e2ec:	e5933004 	ldr	r3, [r3, #4]
1001e2f0:	e3530000 	cmp	r3, #0
1001e2f4:	1a000001 	bne	1001e300 <pthread_create+0x2ac>
            rt_free(stack);
1001e2f8:	e51b0008 	ldr	r0, [fp, #-8]
1001e2fc:	ebffd9ff 	bl	10014b00 <rt_free>
        if (ptd->joinable_sem != RT_NULL)
1001e300:	e51b300c 	ldr	r3, [fp, #-12]
1001e304:	e5933020 	ldr	r3, [r3, #32]
1001e308:	e3530000 	cmp	r3, #0
1001e30c:	0a000003 	beq	1001e320 <pthread_create+0x2cc>
            rt_sem_delete(ptd->joinable_sem);
1001e310:	e51b300c 	ldr	r3, [fp, #-12]
1001e314:	e5933020 	ldr	r3, [r3, #32]
1001e318:	e1a00003 	mov	r0, r3
1001e31c:	ebffc427 	bl	1000f3c0 <rt_sem_delete>
        rt_free(ptd);
1001e320:	e51b000c 	ldr	r0, [fp, #-12]
1001e324:	ebffd9f5 	bl	10014b00 <rt_free>

        return EINVAL;
1001e328:	e3a03016 	mov	r3, #22
1001e32c:	ea00002b 	b	1001e3e0 <pthread_create+0x38c>
    }

    /* set pthread id */
    *tid = ptd->tid;
1001e330:	e51b300c 	ldr	r3, [fp, #-12]
1001e334:	e5932010 	ldr	r2, [r3, #16]
1001e338:	e51b3020 	ldr	r3, [fp, #-32]
1001e33c:	e5832000 	str	r2, [r3]

    /* set pthread cleanup function and ptd data */
    (*tid)->cleanup = _pthread_cleanup;
1001e340:	e51b3020 	ldr	r3, [fp, #-32]
1001e344:	e5932000 	ldr	r2, [r3]
1001e348:	e30d3fb0 	movw	r3, #57264	; 0xdfb0
1001e34c:	e3413001 	movt	r3, #4097	; 0x1001
1001e350:	e5823070 	str	r3, [r2, #112]	; 0x70
    (*tid)->user_data = (rt_uint32_t)ptd;
1001e354:	e51b3020 	ldr	r3, [fp, #-32]
1001e358:	e5933000 	ldr	r3, [r3]
1001e35c:	e51b200c 	ldr	r2, [fp, #-12]
1001e360:	e5832074 	str	r2, [r3, #116]	; 0x74

    /* start thread */
    result = rt_thread_startup(*tid);
1001e364:	e51b3020 	ldr	r3, [fp, #-32]
1001e368:	e5933000 	ldr	r3, [r3]
1001e36c:	e1a00003 	mov	r0, r3
1001e370:	ebffe183 	bl	10016984 <rt_thread_startup>
1001e374:	e50b0010 	str	r0, [fp, #-16]
    if (result == RT_EOK)
1001e378:	e51b3010 	ldr	r3, [fp, #-16]
1001e37c:	e3530000 	cmp	r3, #0
1001e380:	1a000001 	bne	1001e38c <pthread_create+0x338>
        return 0;
1001e384:	e3a03000 	mov	r3, #0
1001e388:	ea000014 	b	1001e3e0 <pthread_create+0x38c>

    /* start thread failed */
    rt_thread_detach(ptd->tid);
1001e38c:	e51b300c 	ldr	r3, [fp, #-12]
1001e390:	e5933010 	ldr	r3, [r3, #16]
1001e394:	e1a00003 	mov	r0, r3
1001e398:	ebffe1aa 	bl	10016a48 <rt_thread_detach>
    if (ptd->attr.stack_base == 0)
1001e39c:	e51b300c 	ldr	r3, [fp, #-12]
1001e3a0:	e5933004 	ldr	r3, [r3, #4]
1001e3a4:	e3530000 	cmp	r3, #0
1001e3a8:	1a000001 	bne	1001e3b4 <pthread_create+0x360>
        rt_free(stack);
1001e3ac:	e51b0008 	ldr	r0, [fp, #-8]
1001e3b0:	ebffd9d2 	bl	10014b00 <rt_free>
    if (ptd->joinable_sem != RT_NULL)
1001e3b4:	e51b300c 	ldr	r3, [fp, #-12]
1001e3b8:	e5933020 	ldr	r3, [r3, #32]
1001e3bc:	e3530000 	cmp	r3, #0
1001e3c0:	0a000003 	beq	1001e3d4 <pthread_create+0x380>
        rt_sem_delete(ptd->joinable_sem);
1001e3c4:	e51b300c 	ldr	r3, [fp, #-12]
1001e3c8:	e5933020 	ldr	r3, [r3, #32]
1001e3cc:	e1a00003 	mov	r0, r3
1001e3d0:	ebffc3fa 	bl	1000f3c0 <rt_sem_delete>

    rt_free(ptd);
1001e3d4:	e51b000c 	ldr	r0, [fp, #-12]
1001e3d8:	ebffd9c8 	bl	10014b00 <rt_free>

    return EINVAL;
1001e3dc:	e3a03016 	mov	r3, #22
}
1001e3e0:	e1a00003 	mov	r0, r3
1001e3e4:	e24bd004 	sub	sp, fp, #4
1001e3e8:	e8bd8800 	pop	{fp, pc}

1001e3ec <pthread_detach>:
RTM_EXPORT(pthread_create);

int pthread_detach(pthread_t thread)
{
1001e3ec:	e92d4800 	push	{fp, lr}
1001e3f0:	e28db004 	add	fp, sp, #4
1001e3f4:	e24dd010 	sub	sp, sp, #16
1001e3f8:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t* ptd;

    ptd = _pthread_get_data(thread);
1001e3fc:	e51b0010 	ldr	r0, [fp, #-16]
1001e400:	ebfffeb8 	bl	1001dee8 <_pthread_get_data>
1001e404:	e50b0008 	str	r0, [fp, #-8]

    if (thread->stat == RT_THREAD_CLOSE)
1001e408:	e51b3010 	ldr	r3, [fp, #-16]
1001e40c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
1001e410:	e3530004 	cmp	r3, #4
1001e414:	1a000023 	bne	1001e4a8 <pthread_detach+0xbc>
    {
        /* delete joinable semaphore */
        if (ptd->joinable_sem != RT_NULL)
1001e418:	e51b3008 	ldr	r3, [fp, #-8]
1001e41c:	e5933020 	ldr	r3, [r3, #32]
1001e420:	e3530000 	cmp	r3, #0
1001e424:	0a000003 	beq	1001e438 <pthread_detach+0x4c>
            rt_sem_delete(ptd->joinable_sem);
1001e428:	e51b3008 	ldr	r3, [fp, #-8]
1001e42c:	e5933020 	ldr	r3, [r3, #32]
1001e430:	e1a00003 	mov	r0, r3
1001e434:	ebffc3e1 	bl	1000f3c0 <rt_sem_delete>
        /* detach thread object */
        rt_thread_detach(ptd->tid);
1001e438:	e51b3008 	ldr	r3, [fp, #-8]
1001e43c:	e5933010 	ldr	r3, [r3, #16]
1001e440:	e1a00003 	mov	r0, r3
1001e444:	ebffe17f 	bl	10016a48 <rt_thread_detach>

        /* release thread resource */
        if (ptd->attr.stack_base == RT_NULL)
1001e448:	e51b3008 	ldr	r3, [fp, #-8]
1001e44c:	e5933004 	ldr	r3, [r3, #4]
1001e450:	e3530000 	cmp	r3, #0
1001e454:	1a000004 	bne	1001e46c <pthread_detach+0x80>
        {
            /* release thread allocated stack */
            rt_free(ptd->tid->stack_addr);
1001e458:	e51b3008 	ldr	r3, [fp, #-8]
1001e45c:	e5933010 	ldr	r3, [r3, #16]
1001e460:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1001e464:	e1a00003 	mov	r0, r3
1001e468:	ebffd9a4 	bl	10014b00 <rt_free>

        /*
         * if this thread create the local thread data,
         * delete it
         */
        if (ptd->tls != RT_NULL)
1001e46c:	e51b3008 	ldr	r3, [fp, #-8]
1001e470:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001e474:	e3530000 	cmp	r3, #0
1001e478:	0a000003 	beq	1001e48c <pthread_detach+0xa0>
            rt_free(ptd->tls);
1001e47c:	e51b3008 	ldr	r3, [fp, #-8]
1001e480:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001e484:	e1a00003 	mov	r0, r3
1001e488:	ebffd99c 	bl	10014b00 <rt_free>
        rt_free(ptd->tid);
1001e48c:	e51b3008 	ldr	r3, [fp, #-8]
1001e490:	e5933010 	ldr	r3, [r3, #16]
1001e494:	e1a00003 	mov	r0, r3
1001e498:	ebffd998 	bl	10014b00 <rt_free>
        rt_free(ptd);
1001e49c:	e51b0008 	ldr	r0, [fp, #-8]
1001e4a0:	ebffd996 	bl	10014b00 <rt_free>
1001e4a4:	ea00000b 	b	1001e4d8 <pthread_detach+0xec>
    }
    else
    {
        rt_enter_critical();
1001e4a8:	ebffdfe4 	bl	10016440 <rt_enter_critical>
        /* change to detach state */
        ptd->attr.detachstate = PTHREAD_CREATE_DETACHED;
1001e4ac:	e51b3008 	ldr	r3, [fp, #-8]
1001e4b0:	e3a02001 	mov	r2, #1
1001e4b4:	e5c3200b 	strb	r2, [r3, #11]

        /* detach joinable semaphore */
        rt_sem_delete(ptd->joinable_sem);
1001e4b8:	e51b3008 	ldr	r3, [fp, #-8]
1001e4bc:	e5933020 	ldr	r3, [r3, #32]
1001e4c0:	e1a00003 	mov	r0, r3
1001e4c4:	ebffc3bd 	bl	1000f3c0 <rt_sem_delete>
        ptd->joinable_sem = RT_NULL;
1001e4c8:	e51b3008 	ldr	r3, [fp, #-8]
1001e4cc:	e3a02000 	mov	r2, #0
1001e4d0:	e5832020 	str	r2, [r3, #32]
        rt_exit_critical();
1001e4d4:	ebffdfeb 	bl	10016488 <rt_exit_critical>
    }

    return 0;
1001e4d8:	e3a03000 	mov	r3, #0
}
1001e4dc:	e1a00003 	mov	r0, r3
1001e4e0:	e24bd004 	sub	sp, fp, #4
1001e4e4:	e8bd8800 	pop	{fp, pc}

1001e4e8 <pthread_join>:
RTM_EXPORT(pthread_detach);

int pthread_join (pthread_t thread, void **value_ptr)
{
1001e4e8:	e92d4800 	push	{fp, lr}
1001e4ec:	e28db004 	add	fp, sp, #4
1001e4f0:	e24dd010 	sub	sp, sp, #16
1001e4f4:	e50b0010 	str	r0, [fp, #-16]
1001e4f8:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t* ptd;
    rt_err_t result;

    if (thread == rt_thread_self())
1001e4fc:	ebffe117 	bl	10016960 <rt_thread_self>
1001e500:	e1a02000 	mov	r2, r0
1001e504:	e51b3010 	ldr	r3, [fp, #-16]
1001e508:	e1520003 	cmp	r2, r3
1001e50c:	1a000001 	bne	1001e518 <pthread_join+0x30>
    {
        /* join self */
        return EDEADLK;
1001e510:	e3a0302d 	mov	r3, #45	; 0x2d
1001e514:	ea00001d 	b	1001e590 <pthread_join+0xa8>
    }

    ptd = _pthread_get_data(thread);
1001e518:	e51b0010 	ldr	r0, [fp, #-16]
1001e51c:	ebfffe71 	bl	1001dee8 <_pthread_get_data>
1001e520:	e50b0008 	str	r0, [fp, #-8]
    if (ptd->attr.detachstate == PTHREAD_CREATE_DETACHED)
1001e524:	e51b3008 	ldr	r3, [fp, #-8]
1001e528:	e5d3300b 	ldrb	r3, [r3, #11]
1001e52c:	e3530001 	cmp	r3, #1
1001e530:	1a000001 	bne	1001e53c <pthread_join+0x54>
        return EINVAL; /* join on a detached pthread */
1001e534:	e3a03016 	mov	r3, #22
1001e538:	ea000014 	b	1001e590 <pthread_join+0xa8>

    result = rt_sem_take(ptd->joinable_sem, RT_WAITING_FOREVER);
1001e53c:	e51b3008 	ldr	r3, [fp, #-8]
1001e540:	e5933020 	ldr	r3, [r3, #32]
1001e544:	e1a00003 	mov	r0, r3
1001e548:	e3e01000 	mvn	r1, #0
1001e54c:	ebffc3c6 	bl	1000f46c <rt_sem_take>
1001e550:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
1001e554:	e51b300c 	ldr	r3, [fp, #-12]
1001e558:	e3530000 	cmp	r3, #0
1001e55c:	1a00000a 	bne	1001e58c <pthread_join+0xa4>
    {
        /* get return value */
        if (value_ptr != RT_NULL)
1001e560:	e51b3014 	ldr	r3, [fp, #-20]
1001e564:	e3530000 	cmp	r3, #0
1001e568:	0a000003 	beq	1001e57c <pthread_join+0x94>
            *value_ptr = ptd->return_value;
1001e56c:	e51b3008 	ldr	r3, [fp, #-8]
1001e570:	e593201c 	ldr	r2, [r3, #28]
1001e574:	e51b3014 	ldr	r3, [fp, #-20]
1001e578:	e5832000 	str	r2, [r3]

        /* release resource */
        pthread_detach(thread);
1001e57c:	e51b0010 	ldr	r0, [fp, #-16]
1001e580:	ebffff99 	bl	1001e3ec <pthread_detach>
    }
    else
        return ESRCH;
    
    return 0;
1001e584:	e3a03000 	mov	r3, #0
1001e588:	ea000000 	b	1001e590 <pthread_join+0xa8>

        /* release resource */
        pthread_detach(thread);
    }
    else
        return ESRCH;
1001e58c:	e3a03003 	mov	r3, #3
    
    return 0;
}
1001e590:	e1a00003 	mov	r0, r3
1001e594:	e24bd004 	sub	sp, fp, #4
1001e598:	e8bd8800 	pop	{fp, pc}

1001e59c <pthread_exit>:
RTM_EXPORT(pthread_join);

void pthread_exit (void *value)
{
1001e59c:	e92d4800 	push	{fp, lr}
1001e5a0:	e28db004 	add	fp, sp, #4
1001e5a4:	e24dd018 	sub	sp, sp, #24
1001e5a8:	e50b0018 	str	r0, [fp, #-24]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;
    extern _pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

    ptd = _pthread_get_data(rt_thread_self());
1001e5ac:	ebffe0eb 	bl	10016960 <rt_thread_self>
1001e5b0:	e1a03000 	mov	r3, r0
1001e5b4:	e1a00003 	mov	r0, r3
1001e5b8:	ebfffe4a 	bl	1001dee8 <_pthread_get_data>
1001e5bc:	e50b000c 	str	r0, [fp, #-12]

    rt_enter_critical();
1001e5c0:	ebffdf9e 	bl	10016440 <rt_enter_critical>
    /* disable cancel */
    ptd->cancelstate = PTHREAD_CANCEL_DISABLE;
1001e5c4:	e51b300c 	ldr	r3, [fp, #-12]
1001e5c8:	e3a02003 	mov	r2, #3
1001e5cc:	e5c32024 	strb	r2, [r3, #36]	; 0x24
    /* set return value */
    ptd->return_value = value;
1001e5d0:	e51b300c 	ldr	r3, [fp, #-12]
1001e5d4:	e51b2018 	ldr	r2, [fp, #-24]
1001e5d8:	e583201c 	str	r2, [r3, #28]
    rt_exit_critical();
1001e5dc:	ebffdfa9 	bl	10016488 <rt_exit_critical>

    /* invoke pushed cleanup */
    while (ptd->cleanup != RT_NULL)
1001e5e0:	ea00000e 	b	1001e620 <pthread_exit+0x84>
    {
        cleanup = ptd->cleanup;
1001e5e4:	e51b300c 	ldr	r3, [fp, #-12]
1001e5e8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1001e5ec:	e50b3010 	str	r3, [fp, #-16]
        ptd->cleanup = cleanup->next;
1001e5f0:	e51b3010 	ldr	r3, [fp, #-16]
1001e5f4:	e5932008 	ldr	r2, [r3, #8]
1001e5f8:	e51b300c 	ldr	r3, [fp, #-12]
1001e5fc:	e5832028 	str	r2, [r3, #40]	; 0x28

        cleanup->cleanup_func(cleanup->parameter);
1001e600:	e51b3010 	ldr	r3, [fp, #-16]
1001e604:	e5933000 	ldr	r3, [r3]
1001e608:	e51b2010 	ldr	r2, [fp, #-16]
1001e60c:	e5922004 	ldr	r2, [r2, #4]
1001e610:	e1a00002 	mov	r0, r2
1001e614:	e12fff33 	blx	r3
        /* release this cleanup function */
        rt_free(cleanup);
1001e618:	e51b0010 	ldr	r0, [fp, #-16]
1001e61c:	ebffd937 	bl	10014b00 <rt_free>
    /* set return value */
    ptd->return_value = value;
    rt_exit_critical();

    /* invoke pushed cleanup */
    while (ptd->cleanup != RT_NULL)
1001e620:	e51b300c 	ldr	r3, [fp, #-12]
1001e624:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1001e628:	e3530000 	cmp	r3, #0
1001e62c:	1affffec 	bne	1001e5e4 <pthread_exit+0x48>
        /* release this cleanup function */
        rt_free(cleanup);
    }

    /* destruct thread local key */
    if (ptd->tls != RT_NULL)
1001e630:	e51b300c 	ldr	r3, [fp, #-12]
1001e634:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001e638:	e3530000 	cmp	r3, #0
1001e63c:	0a000027 	beq	1001e6e0 <pthread_exit+0x144>
    {
        void *data;
        rt_uint32_t index;
        
        for (index = 0; index < PTHREAD_KEY_MAX; index ++)
1001e640:	e3a03000 	mov	r3, #0
1001e644:	e50b3008 	str	r3, [fp, #-8]
1001e648:	ea00001a 	b	1001e6b8 <pthread_exit+0x11c>
        {
            if (_thread_keys[index].is_used)
1001e64c:	e3033550 	movw	r3, #13648	; 0x3550
1001e650:	e3413004 	movt	r3, #4100	; 0x1004
1001e654:	e51b2008 	ldr	r2, [fp, #-8]
1001e658:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001e65c:	e3530000 	cmp	r3, #0
1001e660:	0a000011 	beq	1001e6ac <pthread_exit+0x110>
            {
                data = ptd->tls[index];
1001e664:	e51b300c 	ldr	r3, [fp, #-12]
1001e668:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1001e66c:	e51b3008 	ldr	r3, [fp, #-8]
1001e670:	e1a03103 	lsl	r3, r3, #2
1001e674:	e0823003 	add	r3, r2, r3
1001e678:	e5933000 	ldr	r3, [r3]
1001e67c:	e50b3014 	str	r3, [fp, #-20]
                if (data)
1001e680:	e51b3014 	ldr	r3, [fp, #-20]
1001e684:	e3530000 	cmp	r3, #0
1001e688:	0a000007 	beq	1001e6ac <pthread_exit+0x110>
                    _thread_keys[index].destructor(data);
1001e68c:	e3032550 	movw	r2, #13648	; 0x3550
1001e690:	e3412004 	movt	r2, #4100	; 0x1004
1001e694:	e51b3008 	ldr	r3, [fp, #-8]
1001e698:	e1a03183 	lsl	r3, r3, #3
1001e69c:	e0823003 	add	r3, r2, r3
1001e6a0:	e5933004 	ldr	r3, [r3, #4]
1001e6a4:	e51b0014 	ldr	r0, [fp, #-20]
1001e6a8:	e12fff33 	blx	r3
    if (ptd->tls != RT_NULL)
    {
        void *data;
        rt_uint32_t index;
        
        for (index = 0; index < PTHREAD_KEY_MAX; index ++)
1001e6ac:	e51b3008 	ldr	r3, [fp, #-8]
1001e6b0:	e2833001 	add	r3, r3, #1
1001e6b4:	e50b3008 	str	r3, [fp, #-8]
1001e6b8:	e51b3008 	ldr	r3, [fp, #-8]
1001e6bc:	e3530007 	cmp	r3, #7
1001e6c0:	9affffe1 	bls	1001e64c <pthread_exit+0xb0>
                    _thread_keys[index].destructor(data);
            }
        }

        /* release tls area */
        rt_free(ptd->tls);
1001e6c4:	e51b300c 	ldr	r3, [fp, #-12]
1001e6c8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001e6cc:	e1a00003 	mov	r0, r3
1001e6d0:	ebffd90a 	bl	10014b00 <rt_free>
        ptd->tls = RT_NULL;
1001e6d4:	e51b300c 	ldr	r3, [fp, #-12]
1001e6d8:	e3a02000 	mov	r2, #0
1001e6dc:	e583202c 	str	r2, [r3, #44]	; 0x2c
    }

    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
1001e6e0:	e51b300c 	ldr	r3, [fp, #-12]
1001e6e4:	e5d3300b 	ldrb	r3, [r3, #11]
1001e6e8:	e3530000 	cmp	r3, #0
1001e6ec:	1a000003 	bne	1001e700 <pthread_exit+0x164>
    {
        /* release the joinable pthread */
        rt_sem_release(ptd->joinable_sem);
1001e6f0:	e51b300c 	ldr	r3, [fp, #-12]
1001e6f4:	e5933020 	ldr	r3, [r3, #32]
1001e6f8:	e1a00003 	mov	r0, r3
1001e6fc:	ebffc3ee 	bl	1000f6bc <rt_sem_release>
    }

    /* detach thread */
    rt_thread_detach(ptd->tid);
1001e700:	e51b300c 	ldr	r3, [fp, #-12]
1001e704:	e5933010 	ldr	r3, [r3, #16]
1001e708:	e1a00003 	mov	r0, r3
1001e70c:	ebffe0cd 	bl	10016a48 <rt_thread_detach>
    /* reschedule thread */
    rt_schedule();
1001e710:	ebffdea3 	bl	100161a4 <rt_schedule>
}
1001e714:	e24bd004 	sub	sp, fp, #4
1001e718:	e8bd8800 	pop	{fp, pc}

1001e71c <pthread_once>:
RTM_EXPORT(pthread_exit);

int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))
{
1001e71c:	e92d4800 	push	{fp, lr}
1001e720:	e28db004 	add	fp, sp, #4
1001e724:	e24dd008 	sub	sp, sp, #8
1001e728:	e50b0008 	str	r0, [fp, #-8]
1001e72c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(once_control != RT_NULL);
1001e730:	e51b3008 	ldr	r3, [fp, #-8]
1001e734:	e3530000 	cmp	r3, #0
1001e738:	1a000005 	bne	1001e754 <pthread_once+0x38>
1001e73c:	e3040a48 	movw	r0, #19016	; 0x4a48
1001e740:	e3410003 	movt	r0, #4099	; 0x1003
1001e744:	e3041a9c 	movw	r1, #19100	; 0x4a9c
1001e748:	e3411003 	movt	r1, #4099	; 0x1003
1001e74c:	e300214a 	movw	r2, #330	; 0x14a
1001e750:	ebffd597 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(init_routine != RT_NULL);
1001e754:	e51b300c 	ldr	r3, [fp, #-12]
1001e758:	e3530000 	cmp	r3, #0
1001e75c:	1a000005 	bne	1001e778 <pthread_once+0x5c>
1001e760:	e3040a60 	movw	r0, #19040	; 0x4a60
1001e764:	e3410003 	movt	r0, #4099	; 0x1003
1001e768:	e3041a9c 	movw	r1, #19100	; 0x4a9c
1001e76c:	e3411003 	movt	r1, #4099	; 0x1003
1001e770:	e300214b 	movw	r2, #331	; 0x14b
1001e774:	ebffd58e 	bl	10013db4 <rt_assert_handler>

    rt_enter_critical();
1001e778:	ebffdf30 	bl	10016440 <rt_enter_critical>
    if (!(*once_control))
1001e77c:	e51b3008 	ldr	r3, [fp, #-8]
1001e780:	e5933000 	ldr	r3, [r3]
1001e784:	e3530000 	cmp	r3, #0
1001e788:	1a000005 	bne	1001e7a4 <pthread_once+0x88>
    {
        /* call routine once */
        *once_control = 1;
1001e78c:	e51b3008 	ldr	r3, [fp, #-8]
1001e790:	e3a02001 	mov	r2, #1
1001e794:	e5832000 	str	r2, [r3]
        rt_exit_critical();
1001e798:	ebffdf3a 	bl	10016488 <rt_exit_critical>

        init_routine();
1001e79c:	e51b300c 	ldr	r3, [fp, #-12]
1001e7a0:	e12fff33 	blx	r3
    }
    rt_exit_critical();
1001e7a4:	ebffdf37 	bl	10016488 <rt_exit_critical>

    return 0;
1001e7a8:	e3a03000 	mov	r3, #0
}
1001e7ac:	e1a00003 	mov	r0, r3
1001e7b0:	e24bd004 	sub	sp, fp, #4
1001e7b4:	e8bd8800 	pop	{fp, pc}

1001e7b8 <pthread_atfork>:
RTM_EXPORT(pthread_once);

int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void))
{
1001e7b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001e7bc:	e28db000 	add	fp, sp, #0
1001e7c0:	e24dd014 	sub	sp, sp, #20
1001e7c4:	e50b0008 	str	r0, [fp, #-8]
1001e7c8:	e50b100c 	str	r1, [fp, #-12]
1001e7cc:	e50b2010 	str	r2, [fp, #-16]
    return EOPNOTSUPP;
1001e7d0:	e3a0305f 	mov	r3, #95	; 0x5f
}
1001e7d4:	e1a00003 	mov	r0, r3
1001e7d8:	e24bd000 	sub	sp, fp, #0
1001e7dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001e7e0:	e12fff1e 	bx	lr

1001e7e4 <pthread_kill>:
RTM_EXPORT(pthread_atfork);

int pthread_kill(pthread_t thread, int sig)
{
1001e7e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001e7e8:	e28db000 	add	fp, sp, #0
1001e7ec:	e24dd00c 	sub	sp, sp, #12
1001e7f0:	e50b0008 	str	r0, [fp, #-8]
1001e7f4:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
1001e7f8:	e3a0305f 	mov	r3, #95	; 0x5f
}
1001e7fc:	e1a00003 	mov	r0, r3
1001e800:	e24bd000 	sub	sp, fp, #0
1001e804:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001e808:	e12fff1e 	bx	lr

1001e80c <pthread_cleanup_pop>:
RTM_EXPORT(pthread_kill);

void pthread_cleanup_pop(int execute)
{
1001e80c:	e92d4800 	push	{fp, lr}
1001e810:	e28db004 	add	fp, sp, #4
1001e814:	e24dd010 	sub	sp, sp, #16
1001e818:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1001e81c:	ebffe04f 	bl	10016960 <rt_thread_self>
1001e820:	e1a03000 	mov	r3, r0
1001e824:	e1a00003 	mov	r0, r3
1001e828:	ebfffdae 	bl	1001dee8 <_pthread_get_data>
1001e82c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1001e830:	e51b3008 	ldr	r3, [fp, #-8]
1001e834:	e3530000 	cmp	r3, #0
1001e838:	1a000005 	bne	1001e854 <pthread_cleanup_pop+0x48>
1001e83c:	e3040a04 	movw	r0, #18948	; 0x4a04
1001e840:	e3410003 	movt	r0, #4099	; 0x1003
1001e844:	e3041aac 	movw	r1, #19116	; 0x4aac
1001e848:	e3411003 	movt	r1, #4099	; 0x1003
1001e84c:	e300216f 	movw	r2, #367	; 0x16f
1001e850:	ebffd557 	bl	10013db4 <rt_assert_handler>

    if (execute)
1001e854:	e51b3010 	ldr	r3, [fp, #-16]
1001e858:	e3530000 	cmp	r3, #0
1001e85c:	0a000016 	beq	1001e8bc <pthread_cleanup_pop+0xb0>
    {
        rt_enter_critical();
1001e860:	ebffdef6 	bl	10016440 <rt_enter_critical>
        cleanup = ptd->cleanup;
1001e864:	e51b3008 	ldr	r3, [fp, #-8]
1001e868:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1001e86c:	e50b300c 	str	r3, [fp, #-12]
        if (cleanup)
1001e870:	e51b300c 	ldr	r3, [fp, #-12]
1001e874:	e3530000 	cmp	r3, #0
1001e878:	0a000003 	beq	1001e88c <pthread_cleanup_pop+0x80>
            ptd->cleanup = cleanup->next;
1001e87c:	e51b300c 	ldr	r3, [fp, #-12]
1001e880:	e5932008 	ldr	r2, [r3, #8]
1001e884:	e51b3008 	ldr	r3, [fp, #-8]
1001e888:	e5832028 	str	r2, [r3, #40]	; 0x28
        rt_exit_critical();
1001e88c:	ebffdefd 	bl	10016488 <rt_exit_critical>

        if (cleanup)
1001e890:	e51b300c 	ldr	r3, [fp, #-12]
1001e894:	e3530000 	cmp	r3, #0
1001e898:	0a000007 	beq	1001e8bc <pthread_cleanup_pop+0xb0>
        {
            cleanup->cleanup_func(cleanup->parameter);
1001e89c:	e51b300c 	ldr	r3, [fp, #-12]
1001e8a0:	e5933000 	ldr	r3, [r3]
1001e8a4:	e51b200c 	ldr	r2, [fp, #-12]
1001e8a8:	e5922004 	ldr	r2, [r2, #4]
1001e8ac:	e1a00002 	mov	r0, r2
1001e8b0:	e12fff33 	blx	r3

            rt_free(cleanup);
1001e8b4:	e51b000c 	ldr	r0, [fp, #-12]
1001e8b8:	ebffd890 	bl	10014b00 <rt_free>
        }
    }
}
1001e8bc:	e24bd004 	sub	sp, fp, #4
1001e8c0:	e8bd8800 	pop	{fp, pc}

1001e8c4 <pthread_cleanup_push>:
RTM_EXPORT(pthread_cleanup_pop);

void pthread_cleanup_push(void (*routine)(void*), void *arg)
{
1001e8c4:	e92d4800 	push	{fp, lr}
1001e8c8:	e28db004 	add	fp, sp, #4
1001e8cc:	e24dd010 	sub	sp, sp, #16
1001e8d0:	e50b0010 	str	r0, [fp, #-16]
1001e8d4:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1001e8d8:	ebffe020 	bl	10016960 <rt_thread_self>
1001e8dc:	e1a03000 	mov	r3, r0
1001e8e0:	e1a00003 	mov	r0, r3
1001e8e4:	ebfffd7f 	bl	1001dee8 <_pthread_get_data>
1001e8e8:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1001e8ec:	e51b3008 	ldr	r3, [fp, #-8]
1001e8f0:	e3530000 	cmp	r3, #0
1001e8f4:	1a000005 	bne	1001e910 <pthread_cleanup_push+0x4c>
1001e8f8:	e3040a04 	movw	r0, #18948	; 0x4a04
1001e8fc:	e3410003 	movt	r0, #4099	; 0x1003
1001e900:	e3041ac0 	movw	r1, #19136	; 0x4ac0
1001e904:	e3411003 	movt	r1, #4099	; 0x1003
1001e908:	e300218a 	movw	r2, #394	; 0x18a
1001e90c:	ebffd528 	bl	10013db4 <rt_assert_handler>

    cleanup = (_pthread_cleanup_t *)rt_malloc(sizeof(_pthread_cleanup_t));
1001e910:	e3a0000c 	mov	r0, #12
1001e914:	ebffd65e 	bl	10014294 <rt_malloc>
1001e918:	e50b000c 	str	r0, [fp, #-12]
    if (cleanup != RT_NULL)
1001e91c:	e51b300c 	ldr	r3, [fp, #-12]
1001e920:	e3530000 	cmp	r3, #0
1001e924:	0a00000e 	beq	1001e964 <pthread_cleanup_push+0xa0>
    {
        cleanup->cleanup_func = routine;
1001e928:	e51b300c 	ldr	r3, [fp, #-12]
1001e92c:	e51b2010 	ldr	r2, [fp, #-16]
1001e930:	e5832000 	str	r2, [r3]
        cleanup->parameter = arg;
1001e934:	e51b300c 	ldr	r3, [fp, #-12]
1001e938:	e51b2014 	ldr	r2, [fp, #-20]
1001e93c:	e5832004 	str	r2, [r3, #4]

        rt_enter_critical();
1001e940:	ebffdebe 	bl	10016440 <rt_enter_critical>
        cleanup->next = ptd->cleanup;
1001e944:	e51b3008 	ldr	r3, [fp, #-8]
1001e948:	e5932028 	ldr	r2, [r3, #40]	; 0x28
1001e94c:	e51b300c 	ldr	r3, [fp, #-12]
1001e950:	e5832008 	str	r2, [r3, #8]
        ptd->cleanup = cleanup;
1001e954:	e51b3008 	ldr	r3, [fp, #-8]
1001e958:	e51b200c 	ldr	r2, [fp, #-12]
1001e95c:	e5832028 	str	r2, [r3, #40]	; 0x28
        rt_exit_critical();
1001e960:	ebffdec8 	bl	10016488 <rt_exit_critical>
    }
}
1001e964:	e24bd004 	sub	sp, fp, #4
1001e968:	e8bd8800 	pop	{fp, pc}

1001e96c <pthread_setcancelstate>:
 * The pthread_cancel(), pthread_setcancelstate(), and pthread_setcanceltype()
 * functions are defined to be async-cancel safe.
 */

int pthread_setcancelstate(int state, int *oldstate)
{
1001e96c:	e92d4800 	push	{fp, lr}
1001e970:	e28db004 	add	fp, sp, #4
1001e974:	e24dd010 	sub	sp, sp, #16
1001e978:	e50b0010 	str	r0, [fp, #-16]
1001e97c:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t *ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1001e980:	ebffdff6 	bl	10016960 <rt_thread_self>
1001e984:	e1a03000 	mov	r3, r0
1001e988:	e1a00003 	mov	r0, r3
1001e98c:	ebfffd55 	bl	1001dee8 <_pthread_get_data>
1001e990:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1001e994:	e51b3008 	ldr	r3, [fp, #-8]
1001e998:	e3530000 	cmp	r3, #0
1001e99c:	1a000005 	bne	1001e9b8 <pthread_setcancelstate+0x4c>
1001e9a0:	e3040a04 	movw	r0, #18948	; 0x4a04
1001e9a4:	e3410003 	movt	r0, #4099	; 0x1003
1001e9a8:	e3041ad8 	movw	r1, #19160	; 0x4ad8
1001e9ac:	e3411003 	movt	r1, #4099	; 0x1003
1001e9b0:	e3a02f6f 	mov	r2, #444	; 0x1bc
1001e9b4:	ebffd4fe 	bl	10013db4 <rt_assert_handler>

    if ((state == PTHREAD_CANCEL_ENABLE) || (state == PTHREAD_CANCEL_DISABLE))
1001e9b8:	e51b3010 	ldr	r3, [fp, #-16]
1001e9bc:	e3530001 	cmp	r3, #1
1001e9c0:	0a000002 	beq	1001e9d0 <pthread_setcancelstate+0x64>
1001e9c4:	e51b3010 	ldr	r3, [fp, #-16]
1001e9c8:	e3530003 	cmp	r3, #3
1001e9cc:	1a00000d 	bne	1001ea08 <pthread_setcancelstate+0x9c>
    {
        if (oldstate)
1001e9d0:	e51b3014 	ldr	r3, [fp, #-20]
1001e9d4:	e3530000 	cmp	r3, #0
1001e9d8:	0a000004 	beq	1001e9f0 <pthread_setcancelstate+0x84>
            *oldstate = ptd->cancelstate;
1001e9dc:	e51b3008 	ldr	r3, [fp, #-8]
1001e9e0:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
1001e9e4:	e1a02003 	mov	r2, r3
1001e9e8:	e51b3014 	ldr	r3, [fp, #-20]
1001e9ec:	e5832000 	str	r2, [r3]
        ptd->cancelstate = state;
1001e9f0:	e51b3010 	ldr	r3, [fp, #-16]
1001e9f4:	e6ef2073 	uxtb	r2, r3
1001e9f8:	e51b3008 	ldr	r3, [fp, #-8]
1001e9fc:	e5c32024 	strb	r2, [r3, #36]	; 0x24

        return 0;
1001ea00:	e3a03000 	mov	r3, #0
1001ea04:	ea000000 	b	1001ea0c <pthread_setcancelstate+0xa0>
    }

    return EINVAL;
1001ea08:	e3a03016 	mov	r3, #22
}
1001ea0c:	e1a00003 	mov	r0, r3
1001ea10:	e24bd004 	sub	sp, fp, #4
1001ea14:	e8bd8800 	pop	{fp, pc}

1001ea18 <pthread_setcanceltype>:
RTM_EXPORT(pthread_setcancelstate);

int pthread_setcanceltype(int type, int *oldtype)
{
1001ea18:	e92d4800 	push	{fp, lr}
1001ea1c:	e28db004 	add	fp, sp, #4
1001ea20:	e24dd010 	sub	sp, sp, #16
1001ea24:	e50b0010 	str	r0, [fp, #-16]
1001ea28:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t *ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1001ea2c:	ebffdfcb 	bl	10016960 <rt_thread_self>
1001ea30:	e1a03000 	mov	r3, r0
1001ea34:	e1a00003 	mov	r0, r3
1001ea38:	ebfffd2a 	bl	1001dee8 <_pthread_get_data>
1001ea3c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1001ea40:	e51b3008 	ldr	r3, [fp, #-8]
1001ea44:	e3530000 	cmp	r3, #0
1001ea48:	1a000005 	bne	1001ea64 <pthread_setcanceltype+0x4c>
1001ea4c:	e3040a04 	movw	r0, #18948	; 0x4a04
1001ea50:	e3410003 	movt	r0, #4099	; 0x1003
1001ea54:	e3041af0 	movw	r1, #19184	; 0x4af0
1001ea58:	e3411003 	movt	r1, #4099	; 0x1003
1001ea5c:	e30021d1 	movw	r2, #465	; 0x1d1
1001ea60:	ebffd4d3 	bl	10013db4 <rt_assert_handler>

    if ((type != PTHREAD_CANCEL_DEFERRED) && (type != PTHREAD_CANCEL_ASYNCHRONOUS)) 
1001ea64:	e51b3010 	ldr	r3, [fp, #-16]
1001ea68:	e3530002 	cmp	r3, #2
1001ea6c:	0a000004 	beq	1001ea84 <pthread_setcanceltype+0x6c>
1001ea70:	e51b3010 	ldr	r3, [fp, #-16]
1001ea74:	e3530000 	cmp	r3, #0
1001ea78:	0a000001 	beq	1001ea84 <pthread_setcanceltype+0x6c>
        return EINVAL;
1001ea7c:	e3a03016 	mov	r3, #22
1001ea80:	ea00000d 	b	1001eabc <pthread_setcanceltype+0xa4>

    if (oldtype)
1001ea84:	e51b3014 	ldr	r3, [fp, #-20]
1001ea88:	e3530000 	cmp	r3, #0
1001ea8c:	0a000005 	beq	1001eaa8 <pthread_setcanceltype+0x90>
        *oldtype = ptd->canceltype;
1001ea90:	e51b3008 	ldr	r3, [fp, #-8]
1001ea94:	e5d33025 	ldrb	r3, [r3, #37]	; 0x25
1001ea98:	e6ef3073 	uxtb	r3, r3
1001ea9c:	e1a02003 	mov	r2, r3
1001eaa0:	e51b3014 	ldr	r3, [fp, #-20]
1001eaa4:	e5832000 	str	r2, [r3]
    ptd->canceltype = type;
1001eaa8:	e51b3010 	ldr	r3, [fp, #-16]
1001eaac:	e6ef2073 	uxtb	r2, r3
1001eab0:	e51b3008 	ldr	r3, [fp, #-8]
1001eab4:	e5c32025 	strb	r2, [r3, #37]	; 0x25

    return 0;
1001eab8:	e3a03000 	mov	r3, #0
}
1001eabc:	e1a00003 	mov	r0, r3
1001eac0:	e24bd004 	sub	sp, fp, #4
1001eac4:	e8bd8800 	pop	{fp, pc}

1001eac8 <pthread_testcancel>:
RTM_EXPORT(pthread_setcanceltype);

void pthread_testcancel(void)
{
1001eac8:	e92d4800 	push	{fp, lr}
1001eacc:	e28db004 	add	fp, sp, #4
1001ead0:	e24dd008 	sub	sp, sp, #8
    int cancel=0;
1001ead4:	e3a03000 	mov	r3, #0
1001ead8:	e50b3008 	str	r3, [fp, #-8]
    _pthread_data_t* ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1001eadc:	ebffdf9f 	bl	10016960 <rt_thread_self>
1001eae0:	e1a03000 	mov	r3, r0
1001eae4:	e1a00003 	mov	r0, r3
1001eae8:	ebfffcfe 	bl	1001dee8 <_pthread_get_data>
1001eaec:	e50b000c 	str	r0, [fp, #-12]
    RT_ASSERT(ptd != RT_NULL);
1001eaf0:	e51b300c 	ldr	r3, [fp, #-12]
1001eaf4:	e3530000 	cmp	r3, #0
1001eaf8:	1a000005 	bne	1001eb14 <pthread_testcancel+0x4c>
1001eafc:	e3040a04 	movw	r0, #18948	; 0x4a04
1001eb00:	e3410003 	movt	r0, #4099	; 0x1003
1001eb04:	e3041b08 	movw	r1, #19208	; 0x4b08
1001eb08:	e3411003 	movt	r1, #4099	; 0x1003
1001eb0c:	e30021e5 	movw	r2, #485	; 0x1e5
1001eb10:	ebffd4a7 	bl	10013db4 <rt_assert_handler>

    if (ptd->cancelstate == PTHREAD_CANCEL_ENABLE)
1001eb14:	e51b300c 	ldr	r3, [fp, #-12]
1001eb18:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
1001eb1c:	e3530001 	cmp	r3, #1
1001eb20:	1a000003 	bne	1001eb34 <pthread_testcancel+0x6c>
        cancel = ptd->canceled;
1001eb24:	e51b300c 	ldr	r3, [fp, #-12]
1001eb28:	e5d33026 	ldrb	r3, [r3, #38]	; 0x26
1001eb2c:	e6ef3073 	uxtb	r3, r3
1001eb30:	e50b3008 	str	r3, [fp, #-8]
    if (cancel)
1001eb34:	e51b3008 	ldr	r3, [fp, #-8]
1001eb38:	e3530000 	cmp	r3, #0
1001eb3c:	0a000001 	beq	1001eb48 <pthread_testcancel+0x80>
        pthread_exit((void*)PTHREAD_CANCELED);
1001eb40:	e3a00004 	mov	r0, #4
1001eb44:	ebfffe94 	bl	1001e59c <pthread_exit>
}
1001eb48:	e24bd004 	sub	sp, fp, #4
1001eb4c:	e8bd8800 	pop	{fp, pc}

1001eb50 <pthread_cancel>:
RTM_EXPORT(pthread_testcancel);

int pthread_cancel(pthread_t thread)
{
1001eb50:	e92d4800 	push	{fp, lr}
1001eb54:	e28db004 	add	fp, sp, #4
1001eb58:	e24dd010 	sub	sp, sp, #16
1001eb5c:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;

    /* cancel self */
    if (thread == rt_thread_self())
1001eb60:	ebffdf7e 	bl	10016960 <rt_thread_self>
1001eb64:	e1a02000 	mov	r2, r0
1001eb68:	e51b3010 	ldr	r3, [fp, #-16]
1001eb6c:	e1520003 	cmp	r2, r3
1001eb70:	1a000001 	bne	1001eb7c <pthread_cancel+0x2c>
        return 0;
1001eb74:	e3a03000 	mov	r3, #0
1001eb78:	ea00001a 	b	1001ebe8 <pthread_cancel+0x98>

    /* get posix thread data */
    ptd = _pthread_get_data(thread);
1001eb7c:	e51b0010 	ldr	r0, [fp, #-16]
1001eb80:	ebfffcd8 	bl	1001dee8 <_pthread_get_data>
1001eb84:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1001eb88:	e51b3008 	ldr	r3, [fp, #-8]
1001eb8c:	e3530000 	cmp	r3, #0
1001eb90:	1a000005 	bne	1001ebac <pthread_cancel+0x5c>
1001eb94:	e3040a04 	movw	r0, #18948	; 0x4a04
1001eb98:	e3410003 	movt	r0, #4099	; 0x1003
1001eb9c:	e3041b1c 	movw	r1, #19228	; 0x4b1c
1001eba0:	e3411003 	movt	r1, #4099	; 0x1003
1001eba4:	e3a02f7e 	mov	r2, #504	; 0x1f8
1001eba8:	ebffd481 	bl	10013db4 <rt_assert_handler>

    /* set canceled */
    if (ptd->cancelstate == PTHREAD_CANCEL_ENABLE)
1001ebac:	e51b3008 	ldr	r3, [fp, #-8]
1001ebb0:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
1001ebb4:	e3530001 	cmp	r3, #1
1001ebb8:	1a000009 	bne	1001ebe4 <pthread_cancel+0x94>
    {
        ptd->canceled = 1;
1001ebbc:	e51b3008 	ldr	r3, [fp, #-8]
1001ebc0:	e3a02001 	mov	r2, #1
1001ebc4:	e5c32026 	strb	r2, [r3, #38]	; 0x26
        if (ptd->canceltype == PTHREAD_CANCEL_ASYNCHRONOUS)
1001ebc8:	e51b3008 	ldr	r3, [fp, #-8]
1001ebcc:	e5d33025 	ldrb	r3, [r3, #37]	; 0x25
1001ebd0:	e6ef3073 	uxtb	r3, r3
1001ebd4:	e3530000 	cmp	r3, #0
1001ebd8:	1a000001 	bne	1001ebe4 <pthread_cancel+0x94>
             * this thread will be removed from scheduler list
             * and because there is a cleanup function in the
             * thread (pthread_cleanup), it will move to defunct
             * thread list and wait for handling in idle thread.
             */
            rt_thread_detach(thread);
1001ebdc:	e51b0010 	ldr	r0, [fp, #-16]
1001ebe0:	ebffdf98 	bl	10016a48 <rt_thread_detach>
        }
    }

    return 0;
1001ebe4:	e3a03000 	mov	r3, #0
}
1001ebe8:	e1a00003 	mov	r0, r3
1001ebec:	e24bd004 	sub	sp, fp, #4
1001ebf0:	e8bd8800 	pop	{fp, pc}

1001ebf4 <pthread_attr_init>:
    SCHED_FIFO,                 /* scheduler policy */
    PTHREAD_INHERIT_SCHED       /* Inherit parent prio/policy */
};

int pthread_attr_init(pthread_attr_t *attr)
{
1001ebf4:	e92d4800 	push	{fp, lr}
1001ebf8:	e28db004 	add	fp, sp, #4
1001ebfc:	e24dd008 	sub	sp, sp, #8
1001ec00:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(attr != RT_NULL);
1001ec04:	e51b3008 	ldr	r3, [fp, #-8]
1001ec08:	e3530000 	cmp	r3, #0
1001ec0c:	1a000005 	bne	1001ec28 <pthread_attr_init+0x34>
1001ec10:	e3040b38 	movw	r0, #19256	; 0x4b38
1001ec14:	e3410003 	movt	r0, #4099	; 0x1003
1001ec18:	e3041b5c 	movw	r1, #19292	; 0x4b5c
1001ec1c:	e3411003 	movt	r1, #4099	; 0x1003
1001ec20:	e3a0202d 	mov	r2, #45	; 0x2d
1001ec24:	ebffd462 	bl	10013db4 <rt_assert_handler>

    *attr = pthread_default_attr;
1001ec28:	e51b2008 	ldr	r2, [fp, #-8]
1001ec2c:	e3043b2c 	movw	r3, #19244	; 0x4b2c
1001ec30:	e3413003 	movt	r3, #4099	; 0x1003
1001ec34:	e1a0c002 	mov	ip, r2
1001ec38:	e8930007 	ldm	r3, {r0, r1, r2}
1001ec3c:	e88c0007 	stm	ip, {r0, r1, r2}

    return 0;
1001ec40:	e3a03000 	mov	r3, #0
}
1001ec44:	e1a00003 	mov	r0, r3
1001ec48:	e24bd004 	sub	sp, fp, #4
1001ec4c:	e8bd8800 	pop	{fp, pc}

1001ec50 <pthread_attr_destroy>:
RTM_EXPORT(pthread_attr_init);

int pthread_attr_destroy(pthread_attr_t *attr)
{
1001ec50:	e92d4800 	push	{fp, lr}
1001ec54:	e28db004 	add	fp, sp, #4
1001ec58:	e24dd008 	sub	sp, sp, #8
1001ec5c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(attr != RT_NULL);
1001ec60:	e51b3008 	ldr	r3, [fp, #-8]
1001ec64:	e3530000 	cmp	r3, #0
1001ec68:	1a000005 	bne	1001ec84 <pthread_attr_destroy+0x34>
1001ec6c:	e3040b38 	movw	r0, #19256	; 0x4b38
1001ec70:	e3410003 	movt	r0, #4099	; 0x1003
1001ec74:	e3041b70 	movw	r1, #19312	; 0x4b70
1001ec78:	e3411003 	movt	r1, #4099	; 0x1003
1001ec7c:	e3a02037 	mov	r2, #55	; 0x37
1001ec80:	ebffd44b 	bl	10013db4 <rt_assert_handler>

    memset(attr, 0, sizeof(pthread_attr_t));
1001ec84:	e51b0008 	ldr	r0, [fp, #-8]
1001ec88:	e3a01000 	mov	r1, #0
1001ec8c:	e3a0200c 	mov	r2, #12
1001ec90:	fa0041c1 	blx	1002f39c <memset>

    return 0;
1001ec94:	e3a03000 	mov	r3, #0
}
1001ec98:	e1a00003 	mov	r0, r3
1001ec9c:	e24bd004 	sub	sp, fp, #4
1001eca0:	e8bd8800 	pop	{fp, pc}

1001eca4 <pthread_attr_setdetachstate>:
RTM_EXPORT(pthread_attr_destroy);

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
1001eca4:	e92d4800 	push	{fp, lr}
1001eca8:	e28db004 	add	fp, sp, #4
1001ecac:	e24dd008 	sub	sp, sp, #8
1001ecb0:	e50b0008 	str	r0, [fp, #-8]
1001ecb4:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001ecb8:	e51b3008 	ldr	r3, [fp, #-8]
1001ecbc:	e3530000 	cmp	r3, #0
1001ecc0:	1a000005 	bne	1001ecdc <pthread_attr_setdetachstate+0x38>
1001ecc4:	e3040b38 	movw	r0, #19256	; 0x4b38
1001ecc8:	e3410003 	movt	r0, #4099	; 0x1003
1001eccc:	e3041b88 	movw	r1, #19336	; 0x4b88
1001ecd0:	e3411003 	movt	r1, #4099	; 0x1003
1001ecd4:	e3a02041 	mov	r2, #65	; 0x41
1001ecd8:	ebffd435 	bl	10013db4 <rt_assert_handler>

    if (state != PTHREAD_CREATE_JOINABLE && state != PTHREAD_CREATE_DETACHED)
1001ecdc:	e51b300c 	ldr	r3, [fp, #-12]
1001ece0:	e3530000 	cmp	r3, #0
1001ece4:	0a000004 	beq	1001ecfc <pthread_attr_setdetachstate+0x58>
1001ece8:	e51b300c 	ldr	r3, [fp, #-12]
1001ecec:	e3530001 	cmp	r3, #1
1001ecf0:	0a000001 	beq	1001ecfc <pthread_attr_setdetachstate+0x58>
        return EINVAL;
1001ecf4:	e3a03016 	mov	r3, #22
1001ecf8:	ea000004 	b	1001ed10 <pthread_attr_setdetachstate+0x6c>

    attr->detachstate = state;
1001ecfc:	e51b300c 	ldr	r3, [fp, #-12]
1001ed00:	e6ef2073 	uxtb	r2, r3
1001ed04:	e51b3008 	ldr	r3, [fp, #-8]
1001ed08:	e5c32007 	strb	r2, [r3, #7]

    return 0;
1001ed0c:	e3a03000 	mov	r3, #0
}
1001ed10:	e1a00003 	mov	r0, r3
1001ed14:	e24bd004 	sub	sp, fp, #4
1001ed18:	e8bd8800 	pop	{fp, pc}

1001ed1c <pthread_attr_getdetachstate>:
RTM_EXPORT(pthread_attr_setdetachstate);

int pthread_attr_getdetachstate(pthread_attr_t const *attr, int *state)
{
1001ed1c:	e92d4800 	push	{fp, lr}
1001ed20:	e28db004 	add	fp, sp, #4
1001ed24:	e24dd008 	sub	sp, sp, #8
1001ed28:	e50b0008 	str	r0, [fp, #-8]
1001ed2c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001ed30:	e51b3008 	ldr	r3, [fp, #-8]
1001ed34:	e3530000 	cmp	r3, #0
1001ed38:	1a000005 	bne	1001ed54 <pthread_attr_getdetachstate+0x38>
1001ed3c:	e3040b38 	movw	r0, #19256	; 0x4b38
1001ed40:	e3410003 	movt	r0, #4099	; 0x1003
1001ed44:	e3041ba4 	movw	r1, #19364	; 0x4ba4
1001ed48:	e3411003 	movt	r1, #4099	; 0x1003
1001ed4c:	e3a0204e 	mov	r2, #78	; 0x4e
1001ed50:	ebffd417 	bl	10013db4 <rt_assert_handler>

    *state = (int)attr->detachstate;
1001ed54:	e51b3008 	ldr	r3, [fp, #-8]
1001ed58:	e5d33007 	ldrb	r3, [r3, #7]
1001ed5c:	e1a02003 	mov	r2, r3
1001ed60:	e51b300c 	ldr	r3, [fp, #-12]
1001ed64:	e5832000 	str	r2, [r3]

    return 0;
1001ed68:	e3a03000 	mov	r3, #0
}
1001ed6c:	e1a00003 	mov	r0, r3
1001ed70:	e24bd004 	sub	sp, fp, #4
1001ed74:	e8bd8800 	pop	{fp, pc}

1001ed78 <pthread_attr_setschedpolicy>:
RTM_EXPORT(pthread_attr_getdetachstate);

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
1001ed78:	e92d4800 	push	{fp, lr}
1001ed7c:	e28db004 	add	fp, sp, #4
1001ed80:	e24dd008 	sub	sp, sp, #8
1001ed84:	e50b0008 	str	r0, [fp, #-8]
1001ed88:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001ed8c:	e51b3008 	ldr	r3, [fp, #-8]
1001ed90:	e3530000 	cmp	r3, #0
1001ed94:	1a000005 	bne	1001edb0 <pthread_attr_setschedpolicy+0x38>
1001ed98:	e3040b38 	movw	r0, #19256	; 0x4b38
1001ed9c:	e3410003 	movt	r0, #4099	; 0x1003
1001eda0:	e3041bc0 	movw	r1, #19392	; 0x4bc0
1001eda4:	e3411003 	movt	r1, #4099	; 0x1003
1001eda8:	e3a02058 	mov	r2, #88	; 0x58
1001edac:	ebffd400 	bl	10013db4 <rt_assert_handler>

    attr->policy = policy;
1001edb0:	e51b300c 	ldr	r3, [fp, #-12]
1001edb4:	e6ef2073 	uxtb	r2, r3
1001edb8:	e51b3008 	ldr	r3, [fp, #-8]
1001edbc:	e5c32008 	strb	r2, [r3, #8]

    return 0;
1001edc0:	e3a03000 	mov	r3, #0
}
1001edc4:	e1a00003 	mov	r0, r3
1001edc8:	e24bd004 	sub	sp, fp, #4
1001edcc:	e8bd8800 	pop	{fp, pc}

1001edd0 <pthread_attr_getschedpolicy>:
RTM_EXPORT(pthread_attr_setschedpolicy);

int pthread_attr_getschedpolicy(pthread_attr_t const *attr, int *policy)
{
1001edd0:	e92d4800 	push	{fp, lr}
1001edd4:	e28db004 	add	fp, sp, #4
1001edd8:	e24dd008 	sub	sp, sp, #8
1001eddc:	e50b0008 	str	r0, [fp, #-8]
1001ede0:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001ede4:	e51b3008 	ldr	r3, [fp, #-8]
1001ede8:	e3530000 	cmp	r3, #0
1001edec:	1a000005 	bne	1001ee08 <pthread_attr_getschedpolicy+0x38>
1001edf0:	e3040b38 	movw	r0, #19256	; 0x4b38
1001edf4:	e3410003 	movt	r0, #4099	; 0x1003
1001edf8:	e3041bdc 	movw	r1, #19420	; 0x4bdc
1001edfc:	e3411003 	movt	r1, #4099	; 0x1003
1001ee00:	e3a02062 	mov	r2, #98	; 0x62
1001ee04:	ebffd3ea 	bl	10013db4 <rt_assert_handler>

    *policy = (int)attr->policy;
1001ee08:	e51b3008 	ldr	r3, [fp, #-8]
1001ee0c:	e5d33008 	ldrb	r3, [r3, #8]
1001ee10:	e1a02003 	mov	r2, r3
1001ee14:	e51b300c 	ldr	r3, [fp, #-12]
1001ee18:	e5832000 	str	r2, [r3]

    return 0;
1001ee1c:	e3a03000 	mov	r3, #0
}
1001ee20:	e1a00003 	mov	r0, r3
1001ee24:	e24bd004 	sub	sp, fp, #4
1001ee28:	e8bd8800 	pop	{fp, pc}

1001ee2c <pthread_attr_setschedparam>:
RTM_EXPORT(pthread_attr_getschedpolicy);

int pthread_attr_setschedparam(pthread_attr_t           *attr,
                               struct sched_param const *param)
{
1001ee2c:	e92d4800 	push	{fp, lr}
1001ee30:	e28db004 	add	fp, sp, #4
1001ee34:	e24dd008 	sub	sp, sp, #8
1001ee38:	e50b0008 	str	r0, [fp, #-8]
1001ee3c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001ee40:	e51b3008 	ldr	r3, [fp, #-8]
1001ee44:	e3530000 	cmp	r3, #0
1001ee48:	1a000005 	bne	1001ee64 <pthread_attr_setschedparam+0x38>
1001ee4c:	e3040b38 	movw	r0, #19256	; 0x4b38
1001ee50:	e3410003 	movt	r0, #4099	; 0x1003
1001ee54:	e3041bf8 	movw	r1, #19448	; 0x4bf8
1001ee58:	e3411003 	movt	r1, #4099	; 0x1003
1001ee5c:	e3a0206d 	mov	r2, #109	; 0x6d
1001ee60:	ebffd3d3 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(param != RT_NULL);
1001ee64:	e51b300c 	ldr	r3, [fp, #-12]
1001ee68:	e3530000 	cmp	r3, #0
1001ee6c:	1a000005 	bne	1001ee88 <pthread_attr_setschedparam+0x5c>
1001ee70:	e3040b48 	movw	r0, #19272	; 0x4b48
1001ee74:	e3410003 	movt	r0, #4099	; 0x1003
1001ee78:	e3041bf8 	movw	r1, #19448	; 0x4bf8
1001ee7c:	e3411003 	movt	r1, #4099	; 0x1003
1001ee80:	e3a0206e 	mov	r2, #110	; 0x6e
1001ee84:	ebffd3ca 	bl	10013db4 <rt_assert_handler>

    attr->priority = param->sched_priority;
1001ee88:	e51b300c 	ldr	r3, [fp, #-12]
1001ee8c:	e5933000 	ldr	r3, [r3]
1001ee90:	e6ef2073 	uxtb	r2, r3
1001ee94:	e51b3008 	ldr	r3, [fp, #-8]
1001ee98:	e5c32006 	strb	r2, [r3, #6]

    return 0;
1001ee9c:	e3a03000 	mov	r3, #0
}
1001eea0:	e1a00003 	mov	r0, r3
1001eea4:	e24bd004 	sub	sp, fp, #4
1001eea8:	e8bd8800 	pop	{fp, pc}

1001eeac <pthread_attr_getschedparam>:
RTM_EXPORT(pthread_attr_setschedparam);

int pthread_attr_getschedparam(pthread_attr_t const *attr,
                               struct sched_param   *param)
{
1001eeac:	e92d4800 	push	{fp, lr}
1001eeb0:	e28db004 	add	fp, sp, #4
1001eeb4:	e24dd008 	sub	sp, sp, #8
1001eeb8:	e50b0008 	str	r0, [fp, #-8]
1001eebc:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001eec0:	e51b3008 	ldr	r3, [fp, #-8]
1001eec4:	e3530000 	cmp	r3, #0
1001eec8:	1a000005 	bne	1001eee4 <pthread_attr_getschedparam+0x38>
1001eecc:	e3040b38 	movw	r0, #19256	; 0x4b38
1001eed0:	e3410003 	movt	r0, #4099	; 0x1003
1001eed4:	e3041c14 	movw	r1, #19476	; 0x4c14
1001eed8:	e3411003 	movt	r1, #4099	; 0x1003
1001eedc:	e3a02079 	mov	r2, #121	; 0x79
1001eee0:	ebffd3b3 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(param != RT_NULL);
1001eee4:	e51b300c 	ldr	r3, [fp, #-12]
1001eee8:	e3530000 	cmp	r3, #0
1001eeec:	1a000005 	bne	1001ef08 <pthread_attr_getschedparam+0x5c>
1001eef0:	e3040b48 	movw	r0, #19272	; 0x4b48
1001eef4:	e3410003 	movt	r0, #4099	; 0x1003
1001eef8:	e3041c14 	movw	r1, #19476	; 0x4c14
1001eefc:	e3411003 	movt	r1, #4099	; 0x1003
1001ef00:	e3a0207a 	mov	r2, #122	; 0x7a
1001ef04:	ebffd3aa 	bl	10013db4 <rt_assert_handler>

    param->sched_priority = attr->priority;
1001ef08:	e51b3008 	ldr	r3, [fp, #-8]
1001ef0c:	e5d33006 	ldrb	r3, [r3, #6]
1001ef10:	e1a02003 	mov	r2, r3
1001ef14:	e51b300c 	ldr	r3, [fp, #-12]
1001ef18:	e5832000 	str	r2, [r3]

    return 0;
1001ef1c:	e3a03000 	mov	r3, #0
}
1001ef20:	e1a00003 	mov	r0, r3
1001ef24:	e24bd004 	sub	sp, fp, #4
1001ef28:	e8bd8800 	pop	{fp, pc}

1001ef2c <pthread_attr_setstacksize>:
RTM_EXPORT(pthread_attr_getschedparam);

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stack_size)
{
1001ef2c:	e92d4800 	push	{fp, lr}
1001ef30:	e28db004 	add	fp, sp, #4
1001ef34:	e24dd008 	sub	sp, sp, #8
1001ef38:	e50b0008 	str	r0, [fp, #-8]
1001ef3c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001ef40:	e51b3008 	ldr	r3, [fp, #-8]
1001ef44:	e3530000 	cmp	r3, #0
1001ef48:	1a000005 	bne	1001ef64 <pthread_attr_setstacksize+0x38>
1001ef4c:	e3040b38 	movw	r0, #19256	; 0x4b38
1001ef50:	e3410003 	movt	r0, #4099	; 0x1003
1001ef54:	e3041c30 	movw	r1, #19504	; 0x4c30
1001ef58:	e3411003 	movt	r1, #4099	; 0x1003
1001ef5c:	e3a02084 	mov	r2, #132	; 0x84
1001ef60:	ebffd393 	bl	10013db4 <rt_assert_handler>

    attr->stack_size = stack_size;
1001ef64:	e51b300c 	ldr	r3, [fp, #-12]
1001ef68:	e6ff2073 	uxth	r2, r3
1001ef6c:	e51b3008 	ldr	r3, [fp, #-8]
1001ef70:	e1c320b4 	strh	r2, [r3, #4]

    return 0;
1001ef74:	e3a03000 	mov	r3, #0
}
1001ef78:	e1a00003 	mov	r0, r3
1001ef7c:	e24bd004 	sub	sp, fp, #4
1001ef80:	e8bd8800 	pop	{fp, pc}

1001ef84 <pthread_attr_getstacksize>:
RTM_EXPORT(pthread_attr_setstacksize);

int pthread_attr_getstacksize(pthread_attr_t const *attr, size_t *stack_size)
{
1001ef84:	e92d4800 	push	{fp, lr}
1001ef88:	e28db004 	add	fp, sp, #4
1001ef8c:	e24dd008 	sub	sp, sp, #8
1001ef90:	e50b0008 	str	r0, [fp, #-8]
1001ef94:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001ef98:	e51b3008 	ldr	r3, [fp, #-8]
1001ef9c:	e3530000 	cmp	r3, #0
1001efa0:	1a000005 	bne	1001efbc <pthread_attr_getstacksize+0x38>
1001efa4:	e3040b38 	movw	r0, #19256	; 0x4b38
1001efa8:	e3410003 	movt	r0, #4099	; 0x1003
1001efac:	e3041c4c 	movw	r1, #19532	; 0x4c4c
1001efb0:	e3411003 	movt	r1, #4099	; 0x1003
1001efb4:	e3a0208e 	mov	r2, #142	; 0x8e
1001efb8:	ebffd37d 	bl	10013db4 <rt_assert_handler>

    *stack_size = attr->stack_size;
1001efbc:	e51b3008 	ldr	r3, [fp, #-8]
1001efc0:	e1d330b4 	ldrh	r3, [r3, #4]
1001efc4:	e1a02003 	mov	r2, r3
1001efc8:	e51b300c 	ldr	r3, [fp, #-12]
1001efcc:	e5832000 	str	r2, [r3]

    return 0;
1001efd0:	e3a03000 	mov	r3, #0
}
1001efd4:	e1a00003 	mov	r0, r3
1001efd8:	e24bd004 	sub	sp, fp, #4
1001efdc:	e8bd8800 	pop	{fp, pc}

1001efe0 <pthread_attr_setstackaddr>:
RTM_EXPORT(pthread_attr_getstacksize);

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack_addr)
{
1001efe0:	e92d4800 	push	{fp, lr}
1001efe4:	e28db004 	add	fp, sp, #4
1001efe8:	e24dd008 	sub	sp, sp, #8
1001efec:	e50b0008 	str	r0, [fp, #-8]
1001eff0:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001eff4:	e51b3008 	ldr	r3, [fp, #-8]
1001eff8:	e3530000 	cmp	r3, #0
1001effc:	1a000005 	bne	1001f018 <pthread_attr_setstackaddr+0x38>
1001f000:	e3040b38 	movw	r0, #19256	; 0x4b38
1001f004:	e3410003 	movt	r0, #4099	; 0x1003
1001f008:	e3041c68 	movw	r1, #19560	; 0x4c68
1001f00c:	e3411003 	movt	r1, #4099	; 0x1003
1001f010:	e3a02098 	mov	r2, #152	; 0x98
1001f014:	ebffd366 	bl	10013db4 <rt_assert_handler>

    return EOPNOTSUPP;
1001f018:	e3a0305f 	mov	r3, #95	; 0x5f
}
1001f01c:	e1a00003 	mov	r0, r3
1001f020:	e24bd004 	sub	sp, fp, #4
1001f024:	e8bd8800 	pop	{fp, pc}

1001f028 <pthread_attr_getstackaddr>:
RTM_EXPORT(pthread_attr_setstackaddr);

int pthread_attr_getstackaddr(pthread_attr_t const *attr, void **stack_addr)
{
1001f028:	e92d4800 	push	{fp, lr}
1001f02c:	e28db004 	add	fp, sp, #4
1001f030:	e24dd008 	sub	sp, sp, #8
1001f034:	e50b0008 	str	r0, [fp, #-8]
1001f038:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1001f03c:	e51b3008 	ldr	r3, [fp, #-8]
1001f040:	e3530000 	cmp	r3, #0
1001f044:	1a000005 	bne	1001f060 <pthread_attr_getstackaddr+0x38>
1001f048:	e3040b38 	movw	r0, #19256	; 0x4b38
1001f04c:	e3410003 	movt	r0, #4099	; 0x1003
1001f050:	e3041c84 	movw	r1, #19588	; 0x4c84
1001f054:	e3411003 	movt	r1, #4099	; 0x1003
1001f058:	e3a020a0 	mov	r2, #160	; 0xa0
1001f05c:	ebffd354 	bl	10013db4 <rt_assert_handler>

    return EOPNOTSUPP;
1001f060:	e3a0305f 	mov	r3, #95	; 0x5f
}
1001f064:	e1a00003 	mov	r0, r3
1001f068:	e24bd004 	sub	sp, fp, #4
1001f06c:	e8bd8800 	pop	{fp, pc}

1001f070 <pthread_attr_setstack>:
RTM_EXPORT(pthread_attr_getstackaddr);

int pthread_attr_setstack(pthread_attr_t *attr,
                          void           *stack_base,
                          size_t          stack_size)
{
1001f070:	e92d4800 	push	{fp, lr}
1001f074:	e28db004 	add	fp, sp, #4
1001f078:	e24dd010 	sub	sp, sp, #16
1001f07c:	e50b0008 	str	r0, [fp, #-8]
1001f080:	e50b100c 	str	r1, [fp, #-12]
1001f084:	e50b2010 	str	r2, [fp, #-16]
    RT_ASSERT(attr != RT_NULL);
1001f088:	e51b3008 	ldr	r3, [fp, #-8]
1001f08c:	e3530000 	cmp	r3, #0
1001f090:	1a000005 	bne	1001f0ac <pthread_attr_setstack+0x3c>
1001f094:	e3040b38 	movw	r0, #19256	; 0x4b38
1001f098:	e3410003 	movt	r0, #4099	; 0x1003
1001f09c:	e3041ca0 	movw	r1, #19616	; 0x4ca0
1001f0a0:	e3411003 	movt	r1, #4099	; 0x1003
1001f0a4:	e3a020aa 	mov	r2, #170	; 0xaa
1001f0a8:	ebffd341 	bl	10013db4 <rt_assert_handler>

    attr->stack_base = stack_base;
1001f0ac:	e51b3008 	ldr	r3, [fp, #-8]
1001f0b0:	e51b200c 	ldr	r2, [fp, #-12]
1001f0b4:	e5832000 	str	r2, [r3]
    attr->stack_size = RT_ALIGN_DOWN(stack_size, RT_ALIGN_SIZE);
1001f0b8:	e51b3010 	ldr	r3, [fp, #-16]
1001f0bc:	e6ff3073 	uxth	r3, r3
1001f0c0:	e3c33003 	bic	r3, r3, #3
1001f0c4:	e6ff2073 	uxth	r2, r3
1001f0c8:	e51b3008 	ldr	r3, [fp, #-8]
1001f0cc:	e1c320b4 	strh	r2, [r3, #4]

    return 0;
1001f0d0:	e3a03000 	mov	r3, #0
}
1001f0d4:	e1a00003 	mov	r0, r3
1001f0d8:	e24bd004 	sub	sp, fp, #4
1001f0dc:	e8bd8800 	pop	{fp, pc}

1001f0e0 <pthread_attr_getstack>:
RTM_EXPORT(pthread_attr_setstack);

int pthread_attr_getstack(pthread_attr_t const *attr,
                          void                **stack_base,
                          size_t               *stack_size)
{
1001f0e0:	e92d4800 	push	{fp, lr}
1001f0e4:	e28db004 	add	fp, sp, #4
1001f0e8:	e24dd010 	sub	sp, sp, #16
1001f0ec:	e50b0008 	str	r0, [fp, #-8]
1001f0f0:	e50b100c 	str	r1, [fp, #-12]
1001f0f4:	e50b2010 	str	r2, [fp, #-16]
    RT_ASSERT(attr != RT_NULL);
1001f0f8:	e51b3008 	ldr	r3, [fp, #-8]
1001f0fc:	e3530000 	cmp	r3, #0
1001f100:	1a000005 	bne	1001f11c <pthread_attr_getstack+0x3c>
1001f104:	e3040b38 	movw	r0, #19256	; 0x4b38
1001f108:	e3410003 	movt	r0, #4099	; 0x1003
1001f10c:	e3041cb8 	movw	r1, #19640	; 0x4cb8
1001f110:	e3411003 	movt	r1, #4099	; 0x1003
1001f114:	e3a020b7 	mov	r2, #183	; 0xb7
1001f118:	ebffd325 	bl	10013db4 <rt_assert_handler>

    *stack_base = attr->stack_base;
1001f11c:	e51b3008 	ldr	r3, [fp, #-8]
1001f120:	e5932000 	ldr	r2, [r3]
1001f124:	e51b300c 	ldr	r3, [fp, #-12]
1001f128:	e5832000 	str	r2, [r3]
    *stack_size = attr->stack_size;
1001f12c:	e51b3008 	ldr	r3, [fp, #-8]
1001f130:	e1d330b4 	ldrh	r3, [r3, #4]
1001f134:	e1a02003 	mov	r2, r3
1001f138:	e51b3010 	ldr	r3, [fp, #-16]
1001f13c:	e5832000 	str	r2, [r3]

    return 0;
1001f140:	e3a03000 	mov	r3, #0
}
1001f144:	e1a00003 	mov	r0, r3
1001f148:	e24bd004 	sub	sp, fp, #4
1001f14c:	e8bd8800 	pop	{fp, pc}

1001f150 <pthread_attr_setguardsize>:
RTM_EXPORT(pthread_attr_getstack);

int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guard_size)
{
1001f150:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001f154:	e28db000 	add	fp, sp, #0
1001f158:	e24dd00c 	sub	sp, sp, #12
1001f15c:	e50b0008 	str	r0, [fp, #-8]
1001f160:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
1001f164:	e3a0305f 	mov	r3, #95	; 0x5f
}
1001f168:	e1a00003 	mov	r0, r3
1001f16c:	e24bd000 	sub	sp, fp, #0
1001f170:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001f174:	e12fff1e 	bx	lr

1001f178 <pthread_attr_getguardsize>:

int pthread_attr_getguardsize(pthread_attr_t const *attr, size_t *guard_size)
{
1001f178:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001f17c:	e28db000 	add	fp, sp, #0
1001f180:	e24dd00c 	sub	sp, sp, #12
1001f184:	e50b0008 	str	r0, [fp, #-8]
1001f188:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
1001f18c:	e3a0305f 	mov	r3, #95	; 0x5f
}
1001f190:	e1a00003 	mov	r0, r3
1001f194:	e24bd000 	sub	sp, fp, #0
1001f198:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001f19c:	e12fff1e 	bx	lr

1001f1a0 <pthread_attr_setscope>:
RTM_EXPORT(pthread_attr_getguardsize);

int pthread_attr_setscope(pthread_attr_t *attr, int scope)
{
1001f1a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001f1a4:	e28db000 	add	fp, sp, #0
1001f1a8:	e24dd00c 	sub	sp, sp, #12
1001f1ac:	e50b0008 	str	r0, [fp, #-8]
1001f1b0:	e50b100c 	str	r1, [fp, #-12]
    if (scope == PTHREAD_SCOPE_SYSTEM)
1001f1b4:	e51b300c 	ldr	r3, [fp, #-12]
1001f1b8:	e3530001 	cmp	r3, #1
1001f1bc:	1a000001 	bne	1001f1c8 <pthread_attr_setscope+0x28>
        return 0;
1001f1c0:	e3a03000 	mov	r3, #0
1001f1c4:	ea000005 	b	1001f1e0 <pthread_attr_setscope+0x40>
    if (scope == PTHREAD_SCOPE_PROCESS)
1001f1c8:	e51b300c 	ldr	r3, [fp, #-12]
1001f1cc:	e3530000 	cmp	r3, #0
1001f1d0:	1a000001 	bne	1001f1dc <pthread_attr_setscope+0x3c>
        return EOPNOTSUPP;
1001f1d4:	e3a0305f 	mov	r3, #95	; 0x5f
1001f1d8:	ea000000 	b	1001f1e0 <pthread_attr_setscope+0x40>

    return EINVAL;
1001f1dc:	e3a03016 	mov	r3, #22
}
1001f1e0:	e1a00003 	mov	r0, r3
1001f1e4:	e24bd000 	sub	sp, fp, #0
1001f1e8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001f1ec:	e12fff1e 	bx	lr

1001f1f0 <pthread_attr_getscope>:
RTM_EXPORT(pthread_attr_setscope);

int pthread_attr_getscope(pthread_attr_t const *attr)
{
1001f1f0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001f1f4:	e28db000 	add	fp, sp, #0
1001f1f8:	e24dd00c 	sub	sp, sp, #12
1001f1fc:	e50b0008 	str	r0, [fp, #-8]
    return PTHREAD_SCOPE_SYSTEM;
1001f200:	e3a03001 	mov	r3, #1
}
1001f204:	e1a00003 	mov	r0, r3
1001f208:	e24bd000 	sub	sp, fp, #0
1001f20c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001f210:	e12fff1e 	bx	lr

1001f214 <_pthread_get_data>:
    void** tls; /* thread-local storage area */
};
typedef struct _pthread_data _pthread_data_t;

rt_inline _pthread_data_t *_pthread_get_data(pthread_t thread)
{
1001f214:	e92d4800 	push	{fp, lr}
1001f218:	e28db004 	add	fp, sp, #4
1001f21c:	e24dd010 	sub	sp, sp, #16
1001f220:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    RT_ASSERT(thread != RT_NULL);
1001f224:	e51b3010 	ldr	r3, [fp, #-16]
1001f228:	e3530000 	cmp	r3, #0
1001f22c:	1a000005 	bne	1001f248 <_pthread_get_data+0x34>
1001f230:	e3040cd0 	movw	r0, #19664	; 0x4cd0
1001f234:	e3410003 	movt	r0, #4099	; 0x1003
1001f238:	e3041d30 	movw	r1, #19760	; 0x4d30
1001f23c:	e3411003 	movt	r1, #4099	; 0x1003
1001f240:	e3a0204c 	mov	r2, #76	; 0x4c
1001f244:	ebffd2da 	bl	10013db4 <rt_assert_handler>

    ptd = (_pthread_data_t *)thread->user_data;
1001f248:	e51b3010 	ldr	r3, [fp, #-16]
1001f24c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
1001f250:	e50b3008 	str	r3, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1001f254:	e51b3008 	ldr	r3, [fp, #-8]
1001f258:	e3530000 	cmp	r3, #0
1001f25c:	1a000005 	bne	1001f278 <_pthread_get_data+0x64>
1001f260:	e3040ce4 	movw	r0, #19684	; 0x4ce4
1001f264:	e3410003 	movt	r0, #4099	; 0x1003
1001f268:	e3041d30 	movw	r1, #19760	; 0x4d30
1001f26c:	e3411003 	movt	r1, #4099	; 0x1003
1001f270:	e3a0204f 	mov	r2, #79	; 0x4f
1001f274:	ebffd2ce 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(ptd->magic == PTHREAD_MAGIC);
1001f278:	e51b3008 	ldr	r3, [fp, #-8]
1001f27c:	e5932000 	ldr	r2, [r3]
1001f280:	e3063873 	movw	r3, #26739	; 0x6873
1001f284:	e3473074 	movt	r3, #28788	; 0x7074
1001f288:	e1520003 	cmp	r2, r3
1001f28c:	0a000005 	beq	1001f2a8 <_pthread_get_data+0x94>
1001f290:	e3040cf4 	movw	r0, #19700	; 0x4cf4
1001f294:	e3410003 	movt	r0, #4099	; 0x1003
1001f298:	e3041d30 	movw	r1, #19760	; 0x4d30
1001f29c:	e3411003 	movt	r1, #4099	; 0x1003
1001f2a0:	e3a02050 	mov	r2, #80	; 0x50
1001f2a4:	ebffd2c2 	bl	10013db4 <rt_assert_handler>

    return ptd;
1001f2a8:	e51b3008 	ldr	r3, [fp, #-8]
}
1001f2ac:	e1a00003 	mov	r0, r3
1001f2b0:	e24bd004 	sub	sp, fp, #4
1001f2b4:	e8bd8800 	pop	{fp, pc}

1001f2b8 <pthread_key_system_init>:
#include "pthread_internal.h"

_pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

void pthread_key_system_init()
{
1001f2b8:	e92d4800 	push	{fp, lr}
1001f2bc:	e28db004 	add	fp, sp, #4
    rt_memset(&_thread_keys[0], 0, sizeof(_thread_keys));
1001f2c0:	e3030550 	movw	r0, #13648	; 0x3550
1001f2c4:	e3410004 	movt	r0, #4100	; 0x1004
1001f2c8:	e3a01000 	mov	r1, #0
1001f2cc:	e3a02040 	mov	r2, #64	; 0x40
1001f2d0:	ebffcbe0 	bl	10012258 <rt_memset>
}
1001f2d4:	e8bd8800 	pop	{fp, pc}

1001f2d8 <pthread_getspecific>:

void *pthread_getspecific(pthread_key_t key)
{
1001f2d8:	e92d4800 	push	{fp, lr}
1001f2dc:	e28db004 	add	fp, sp, #4
1001f2e0:	e24dd010 	sub	sp, sp, #16
1001f2e4:	e50b0010 	str	r0, [fp, #-16]
    struct _pthread_data* ptd;

    ptd = _pthread_get_data(rt_thread_self());
1001f2e8:	ebffdd9c 	bl	10016960 <rt_thread_self>
1001f2ec:	e1a03000 	mov	r3, r0
1001f2f0:	e1a00003 	mov	r0, r3
1001f2f4:	ebffffc6 	bl	1001f214 <_pthread_get_data>
1001f2f8:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != NULL);
1001f2fc:	e51b3008 	ldr	r3, [fp, #-8]
1001f300:	e3530000 	cmp	r3, #0
1001f304:	1a000005 	bne	1001f320 <pthread_getspecific+0x48>
1001f308:	e3040d10 	movw	r0, #19728	; 0x4d10
1001f30c:	e3410003 	movt	r0, #4099	; 0x1003
1001f310:	e3041d1c 	movw	r1, #19740	; 0x4d1c
1001f314:	e3411003 	movt	r1, #4099	; 0x1003
1001f318:	e3a02028 	mov	r2, #40	; 0x28
1001f31c:	ebffd2a4 	bl	10013db4 <rt_assert_handler>

    if (ptd->tls == NULL)
1001f320:	e51b3008 	ldr	r3, [fp, #-8]
1001f324:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001f328:	e3530000 	cmp	r3, #0
1001f32c:	1a000001 	bne	1001f338 <pthread_getspecific+0x60>
        return NULL;
1001f330:	e3a03000 	mov	r3, #0
1001f334:	ea000010 	b	1001f37c <pthread_getspecific+0xa4>

    if ((key < PTHREAD_KEY_MAX) && (_thread_keys[key].is_used))
1001f338:	e51b3010 	ldr	r3, [fp, #-16]
1001f33c:	e3530007 	cmp	r3, #7
1001f340:	ca00000c 	bgt	1001f378 <pthread_getspecific+0xa0>
1001f344:	e3033550 	movw	r3, #13648	; 0x3550
1001f348:	e3413004 	movt	r3, #4100	; 0x1004
1001f34c:	e51b2010 	ldr	r2, [fp, #-16]
1001f350:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001f354:	e3530000 	cmp	r3, #0
1001f358:	0a000006 	beq	1001f378 <pthread_getspecific+0xa0>
        return ptd->tls[key];
1001f35c:	e51b3008 	ldr	r3, [fp, #-8]
1001f360:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1001f364:	e51b3010 	ldr	r3, [fp, #-16]
1001f368:	e1a03103 	lsl	r3, r3, #2
1001f36c:	e0823003 	add	r3, r2, r3
1001f370:	e5933000 	ldr	r3, [r3]
1001f374:	ea000000 	b	1001f37c <pthread_getspecific+0xa4>

    return NULL;
1001f378:	e3a03000 	mov	r3, #0
}
1001f37c:	e1a00003 	mov	r0, r3
1001f380:	e24bd004 	sub	sp, fp, #4
1001f384:	e8bd8800 	pop	{fp, pc}

1001f388 <pthread_setspecific>:
RTM_EXPORT(pthread_getspecific);

int pthread_setspecific(pthread_key_t key, const void *value)
{
1001f388:	e92d4800 	push	{fp, lr}
1001f38c:	e28db004 	add	fp, sp, #4
1001f390:	e24dd010 	sub	sp, sp, #16
1001f394:	e50b0010 	str	r0, [fp, #-16]
1001f398:	e50b1014 	str	r1, [fp, #-20]
    struct _pthread_data* ptd;

    ptd = _pthread_get_data(rt_thread_self());
1001f39c:	ebffdd6f 	bl	10016960 <rt_thread_self>
1001f3a0:	e1a03000 	mov	r3, r0
1001f3a4:	e1a00003 	mov	r0, r3
1001f3a8:	ebffff99 	bl	1001f214 <_pthread_get_data>
1001f3ac:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != NULL);
1001f3b0:	e51b3008 	ldr	r3, [fp, #-8]
1001f3b4:	e3530000 	cmp	r3, #0
1001f3b8:	1a000005 	bne	1001f3d4 <pthread_setspecific+0x4c>
1001f3bc:	e3040d10 	movw	r0, #19728	; 0x4d10
1001f3c0:	e3410003 	movt	r0, #4099	; 0x1003
1001f3c4:	e3041d44 	movw	r1, #19780	; 0x4d44
1001f3c8:	e3411003 	movt	r1, #4099	; 0x1003
1001f3cc:	e3a02039 	mov	r2, #57	; 0x39
1001f3d0:	ebffd277 	bl	10013db4 <rt_assert_handler>

    /* check tls area */
    if (ptd->tls == NULL)
1001f3d4:	e51b3008 	ldr	r3, [fp, #-8]
1001f3d8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001f3dc:	e3530000 	cmp	r3, #0
1001f3e0:	1a000004 	bne	1001f3f8 <pthread_setspecific+0x70>
    {
        ptd->tls = (void**)rt_malloc(sizeof(void*) * PTHREAD_KEY_MAX);
1001f3e4:	e3a00020 	mov	r0, #32
1001f3e8:	ebffd3a9 	bl	10014294 <rt_malloc>
1001f3ec:	e1a02000 	mov	r2, r0
1001f3f0:	e51b3008 	ldr	r3, [fp, #-8]
1001f3f4:	e583202c 	str	r2, [r3, #44]	; 0x2c
    }

    if ((key < PTHREAD_KEY_MAX) && _thread_keys[key].is_used)
1001f3f8:	e51b3010 	ldr	r3, [fp, #-16]
1001f3fc:	e3530007 	cmp	r3, #7
1001f400:	ca00000e 	bgt	1001f440 <pthread_setspecific+0xb8>
1001f404:	e3033550 	movw	r3, #13648	; 0x3550
1001f408:	e3413004 	movt	r3, #4100	; 0x1004
1001f40c:	e51b2010 	ldr	r2, [fp, #-16]
1001f410:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001f414:	e3530000 	cmp	r3, #0
1001f418:	0a000008 	beq	1001f440 <pthread_setspecific+0xb8>
    {
        ptd->tls[key] = (void *)value;
1001f41c:	e51b3008 	ldr	r3, [fp, #-8]
1001f420:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1001f424:	e51b3010 	ldr	r3, [fp, #-16]
1001f428:	e1a03103 	lsl	r3, r3, #2
1001f42c:	e0823003 	add	r3, r2, r3
1001f430:	e51b2014 	ldr	r2, [fp, #-20]
1001f434:	e5832000 	str	r2, [r3]

        return 0;
1001f438:	e3a03000 	mov	r3, #0
1001f43c:	ea000000 	b	1001f444 <pthread_setspecific+0xbc>
    }

    return EINVAL;
1001f440:	e3a03016 	mov	r3, #22
}
1001f444:	e1a00003 	mov	r0, r3
1001f448:	e24bd004 	sub	sp, fp, #4
1001f44c:	e8bd8800 	pop	{fp, pc}

1001f450 <pthread_key_create>:
RTM_EXPORT(pthread_setspecific);

int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))
{
1001f450:	e92d4800 	push	{fp, lr}
1001f454:	e28db004 	add	fp, sp, #4
1001f458:	e24dd010 	sub	sp, sp, #16
1001f45c:	e50b0010 	str	r0, [fp, #-16]
1001f460:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t index;

    rt_enter_critical();
1001f464:	ebffdbf5 	bl	10016440 <rt_enter_critical>
    for (index = 0; index < PTHREAD_KEY_MAX; index ++)
1001f468:	e3a03000 	mov	r3, #0
1001f46c:	e50b3008 	str	r3, [fp, #-8]
1001f470:	ea00001a 	b	1001f4e0 <pthread_key_create+0x90>
    {
        if (_thread_keys[index].is_used == 0)
1001f474:	e3033550 	movw	r3, #13648	; 0x3550
1001f478:	e3413004 	movt	r3, #4100	; 0x1004
1001f47c:	e51b2008 	ldr	r2, [fp, #-8]
1001f480:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001f484:	e3530000 	cmp	r3, #0
1001f488:	1a000011 	bne	1001f4d4 <pthread_key_create+0x84>
        {
            _thread_keys[index].is_used = 1;
1001f48c:	e3033550 	movw	r3, #13648	; 0x3550
1001f490:	e3413004 	movt	r3, #4100	; 0x1004
1001f494:	e51b2008 	ldr	r2, [fp, #-8]
1001f498:	e3a01001 	mov	r1, #1
1001f49c:	e7831182 	str	r1, [r3, r2, lsl #3]
            _thread_keys[index].destructor = destructor;
1001f4a0:	e3032550 	movw	r2, #13648	; 0x3550
1001f4a4:	e3412004 	movt	r2, #4100	; 0x1004
1001f4a8:	e51b3008 	ldr	r3, [fp, #-8]
1001f4ac:	e1a03183 	lsl	r3, r3, #3
1001f4b0:	e0823003 	add	r3, r2, r3
1001f4b4:	e51b2014 	ldr	r2, [fp, #-20]
1001f4b8:	e5832004 	str	r2, [r3, #4]

            *key = index;
1001f4bc:	e51b2008 	ldr	r2, [fp, #-8]
1001f4c0:	e51b3010 	ldr	r3, [fp, #-16]
1001f4c4:	e5832000 	str	r2, [r3]

            rt_exit_critical();
1001f4c8:	ebffdbee 	bl	10016488 <rt_exit_critical>

            return 0;
1001f4cc:	e3a03000 	mov	r3, #0
1001f4d0:	ea000007 	b	1001f4f4 <pthread_key_create+0xa4>
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))
{
    rt_uint32_t index;

    rt_enter_critical();
    for (index = 0; index < PTHREAD_KEY_MAX; index ++)
1001f4d4:	e51b3008 	ldr	r3, [fp, #-8]
1001f4d8:	e2833001 	add	r3, r3, #1
1001f4dc:	e50b3008 	str	r3, [fp, #-8]
1001f4e0:	e51b3008 	ldr	r3, [fp, #-8]
1001f4e4:	e3530007 	cmp	r3, #7
1001f4e8:	9affffe1 	bls	1001f474 <pthread_key_create+0x24>

            return 0;
        }
    }

    rt_exit_critical();
1001f4ec:	ebffdbe5 	bl	10016488 <rt_exit_critical>

    return EAGAIN;
1001f4f0:	e3a0300b 	mov	r3, #11
}
1001f4f4:	e1a00003 	mov	r0, r3
1001f4f8:	e24bd004 	sub	sp, fp, #4
1001f4fc:	e8bd8800 	pop	{fp, pc}

1001f500 <pthread_key_delete>:
RTM_EXPORT(pthread_key_create);

int pthread_key_delete(pthread_key_t key)
{
1001f500:	e92d4800 	push	{fp, lr}
1001f504:	e28db004 	add	fp, sp, #4
1001f508:	e24dd008 	sub	sp, sp, #8
1001f50c:	e50b0008 	str	r0, [fp, #-8]
    if (key >= PTHREAD_KEY_MAX)
1001f510:	e51b3008 	ldr	r3, [fp, #-8]
1001f514:	e3530007 	cmp	r3, #7
1001f518:	da000001 	ble	1001f524 <pthread_key_delete+0x24>
        return EINVAL;
1001f51c:	e3a03016 	mov	r3, #22
1001f520:	ea00000e 	b	1001f560 <pthread_key_delete+0x60>

    rt_enter_critical();
1001f524:	ebffdbc5 	bl	10016440 <rt_enter_critical>
    _thread_keys[key].is_used = 0;
1001f528:	e3033550 	movw	r3, #13648	; 0x3550
1001f52c:	e3413004 	movt	r3, #4100	; 0x1004
1001f530:	e51b2008 	ldr	r2, [fp, #-8]
1001f534:	e3a01000 	mov	r1, #0
1001f538:	e7831182 	str	r1, [r3, r2, lsl #3]
    _thread_keys[key].destructor = 0;
1001f53c:	e3032550 	movw	r2, #13648	; 0x3550
1001f540:	e3412004 	movt	r2, #4100	; 0x1004
1001f544:	e51b3008 	ldr	r3, [fp, #-8]
1001f548:	e1a03183 	lsl	r3, r3, #3
1001f54c:	e0823003 	add	r3, r2, r3
1001f550:	e3a02000 	mov	r2, #0
1001f554:	e5832004 	str	r2, [r3, #4]
    rt_exit_critical();
1001f558:	ebffdbca 	bl	10016488 <rt_exit_critical>

    return 0;
1001f55c:	e3a03000 	mov	r3, #0
}
1001f560:	e1a00003 	mov	r0, r3
1001f564:	e24bd004 	sub	sp, fp, #4
1001f568:	e8bd8800 	pop	{fp, pc}

1001f56c <posix_sem_system_init>:
#include "pthread_internal.h"

static sem_t *posix_sem_list = RT_NULL;
static struct rt_semaphore posix_sem_lock;
void posix_sem_system_init()
{
1001f56c:	e92d4800 	push	{fp, lr}
1001f570:	e28db004 	add	fp, sp, #4
    rt_sem_init(&posix_sem_lock, "psem", 1, RT_IPC_FLAG_FIFO);
1001f574:	e30e0818 	movw	r0, #59416	; 0xe818
1001f578:	e3410003 	movt	r0, #4099	; 0x1003
1001f57c:	e3041d58 	movw	r1, #19800	; 0x4d58
1001f580:	e3411003 	movt	r1, #4099	; 0x1003
1001f584:	e3a02001 	mov	r2, #1
1001f588:	e3a03000 	mov	r3, #0
1001f58c:	ebffbf1f 	bl	1000f210 <rt_sem_init>
}
1001f590:	e8bd8800 	pop	{fp, pc}

1001f594 <posix_sem_insert>:

rt_inline void posix_sem_insert(sem_t *psem)
{
1001f594:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001f598:	e28db000 	add	fp, sp, #0
1001f59c:	e24dd00c 	sub	sp, sp, #12
1001f5a0:	e50b0008 	str	r0, [fp, #-8]
    psem->next = posix_sem_list;
1001f5a4:	e30e3814 	movw	r3, #59412	; 0xe814
1001f5a8:	e3413003 	movt	r3, #4099	; 0x1003
1001f5ac:	e5932000 	ldr	r2, [r3]
1001f5b0:	e51b3008 	ldr	r3, [fp, #-8]
1001f5b4:	e5832008 	str	r2, [r3, #8]
    posix_sem_list = psem;
1001f5b8:	e30e3814 	movw	r3, #59412	; 0xe814
1001f5bc:	e3413003 	movt	r3, #4099	; 0x1003
1001f5c0:	e51b2008 	ldr	r2, [fp, #-8]
1001f5c4:	e5832000 	str	r2, [r3]
}
1001f5c8:	e24bd000 	sub	sp, fp, #0
1001f5cc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001f5d0:	e12fff1e 	bx	lr

1001f5d4 <posix_sem_delete>:

static void posix_sem_delete(sem_t *psem)
{
1001f5d4:	e92d4800 	push	{fp, lr}
1001f5d8:	e28db004 	add	fp, sp, #4
1001f5dc:	e24dd010 	sub	sp, sp, #16
1001f5e0:	e50b0010 	str	r0, [fp, #-16]
    sem_t *iter;
    if (posix_sem_list == psem)
1001f5e4:	e30e3814 	movw	r3, #59412	; 0xe814
1001f5e8:	e3413003 	movt	r3, #4099	; 0x1003
1001f5ec:	e5932000 	ldr	r2, [r3]
1001f5f0:	e51b3010 	ldr	r3, [fp, #-16]
1001f5f4:	e1520003 	cmp	r2, r3
1001f5f8:	1a00000b 	bne	1001f62c <posix_sem_delete+0x58>
    {
        posix_sem_list = psem->next;
1001f5fc:	e51b3010 	ldr	r3, [fp, #-16]
1001f600:	e5932008 	ldr	r2, [r3, #8]
1001f604:	e30e3814 	movw	r3, #59412	; 0xe814
1001f608:	e3413003 	movt	r3, #4099	; 0x1003
1001f60c:	e5832000 	str	r2, [r3]

        rt_sem_delete(psem->sem);
1001f610:	e51b3010 	ldr	r3, [fp, #-16]
1001f614:	e5933004 	ldr	r3, [r3, #4]
1001f618:	e1a00003 	mov	r0, r3
1001f61c:	ebffbf67 	bl	1000f3c0 <rt_sem_delete>
        rt_free(psem);
1001f620:	e51b0010 	ldr	r0, [fp, #-16]
1001f624:	ebffd535 	bl	10014b00 <rt_free>

        return;
1001f628:	ea000023 	b	1001f6bc <posix_sem_delete+0xe8>
    }
    for (iter = posix_sem_list; iter->next != RT_NULL; iter = iter->next)
1001f62c:	e30e3814 	movw	r3, #59412	; 0xe814
1001f630:	e3413003 	movt	r3, #4099	; 0x1003
1001f634:	e5933000 	ldr	r3, [r3]
1001f638:	e50b3008 	str	r3, [fp, #-8]
1001f63c:	ea00001a 	b	1001f6ac <posix_sem_delete+0xd8>
    {
        if (iter->next == psem)
1001f640:	e51b3008 	ldr	r3, [fp, #-8]
1001f644:	e5932008 	ldr	r2, [r3, #8]
1001f648:	e51b3010 	ldr	r3, [fp, #-16]
1001f64c:	e1520003 	cmp	r2, r3
1001f650:	1a000012 	bne	1001f6a0 <posix_sem_delete+0xcc>
        {
            /* delete this mq */
            if (psem->next != RT_NULL)
1001f654:	e51b3010 	ldr	r3, [fp, #-16]
1001f658:	e5933008 	ldr	r3, [r3, #8]
1001f65c:	e3530000 	cmp	r3, #0
1001f660:	0a000004 	beq	1001f678 <posix_sem_delete+0xa4>
                iter->next = psem->next;
1001f664:	e51b3010 	ldr	r3, [fp, #-16]
1001f668:	e5932008 	ldr	r2, [r3, #8]
1001f66c:	e51b3008 	ldr	r3, [fp, #-8]
1001f670:	e5832008 	str	r2, [r3, #8]
1001f674:	ea000002 	b	1001f684 <posix_sem_delete+0xb0>
            else
                iter->next = RT_NULL;
1001f678:	e51b3008 	ldr	r3, [fp, #-8]
1001f67c:	e3a02000 	mov	r2, #0
1001f680:	e5832008 	str	r2, [r3, #8]

            /* delete RT-Thread mqueue */
            rt_sem_delete(psem->sem);
1001f684:	e51b3010 	ldr	r3, [fp, #-16]
1001f688:	e5933004 	ldr	r3, [r3, #4]
1001f68c:	e1a00003 	mov	r0, r3
1001f690:	ebffbf4a 	bl	1000f3c0 <rt_sem_delete>
            rt_free(psem);
1001f694:	e51b0010 	ldr	r0, [fp, #-16]
1001f698:	ebffd518 	bl	10014b00 <rt_free>

            return ;
1001f69c:	ea000006 	b	1001f6bc <posix_sem_delete+0xe8>
        rt_sem_delete(psem->sem);
        rt_free(psem);

        return;
    }
    for (iter = posix_sem_list; iter->next != RT_NULL; iter = iter->next)
1001f6a0:	e51b3008 	ldr	r3, [fp, #-8]
1001f6a4:	e5933008 	ldr	r3, [r3, #8]
1001f6a8:	e50b3008 	str	r3, [fp, #-8]
1001f6ac:	e51b3008 	ldr	r3, [fp, #-8]
1001f6b0:	e5933008 	ldr	r3, [r3, #8]
1001f6b4:	e3530000 	cmp	r3, #0
1001f6b8:	1affffe0 	bne	1001f640 <posix_sem_delete+0x6c>
            rt_free(psem);

            return ;
        }
    }
}
1001f6bc:	e24bd004 	sub	sp, fp, #4
1001f6c0:	e8bd8800 	pop	{fp, pc}

1001f6c4 <posix_sem_find>:

static sem_t *posix_sem_find(const char* name)
{
1001f6c4:	e92d4800 	push	{fp, lr}
1001f6c8:	e28db004 	add	fp, sp, #4
1001f6cc:	e24dd010 	sub	sp, sp, #16
1001f6d0:	e50b0010 	str	r0, [fp, #-16]
    sem_t *iter;
    rt_object_t object;

    for (iter = posix_sem_list; iter != RT_NULL; iter = iter->next)
1001f6d4:	e30e3814 	movw	r3, #59412	; 0xe814
1001f6d8:	e3413003 	movt	r3, #4099	; 0x1003
1001f6dc:	e5933000 	ldr	r3, [r3]
1001f6e0:	e50b3008 	str	r3, [fp, #-8]
1001f6e4:	ea00000f 	b	1001f728 <posix_sem_find+0x64>
    {
        object = (rt_object_t)&(iter->sem);
1001f6e8:	e51b3008 	ldr	r3, [fp, #-8]
1001f6ec:	e2833004 	add	r3, r3, #4
1001f6f0:	e50b300c 	str	r3, [fp, #-12]

        if (strncmp(object->name, name, RT_NAME_MAX) == 0)
1001f6f4:	e51b300c 	ldr	r3, [fp, #-12]
1001f6f8:	e1a00003 	mov	r0, r3
1001f6fc:	e51b1010 	ldr	r1, [fp, #-16]
1001f700:	e3a02006 	mov	r2, #6
1001f704:	fa00403e 	blx	1002f804 <strncmp>
1001f708:	e1a03000 	mov	r3, r0
1001f70c:	e3530000 	cmp	r3, #0
1001f710:	1a000001 	bne	1001f71c <posix_sem_find+0x58>
        {
            return iter;
1001f714:	e51b3008 	ldr	r3, [fp, #-8]
1001f718:	ea000006 	b	1001f738 <posix_sem_find+0x74>
static sem_t *posix_sem_find(const char* name)
{
    sem_t *iter;
    rt_object_t object;

    for (iter = posix_sem_list; iter != RT_NULL; iter = iter->next)
1001f71c:	e51b3008 	ldr	r3, [fp, #-8]
1001f720:	e5933008 	ldr	r3, [r3, #8]
1001f724:	e50b3008 	str	r3, [fp, #-8]
1001f728:	e51b3008 	ldr	r3, [fp, #-8]
1001f72c:	e3530000 	cmp	r3, #0
1001f730:	1affffec 	bne	1001f6e8 <posix_sem_find+0x24>
        {
            return iter;
        }
    }
    
    return RT_NULL;
1001f734:	e3a03000 	mov	r3, #0
}
1001f738:	e1a00003 	mov	r0, r3
1001f73c:	e24bd004 	sub	sp, fp, #4
1001f740:	e8bd8800 	pop	{fp, pc}

1001f744 <sem_close>:

int sem_close(sem_t *sem)
{
1001f744:	e92d4800 	push	{fp, lr}
1001f748:	e28db004 	add	fp, sp, #4
1001f74c:	e24dd008 	sub	sp, sp, #8
1001f750:	e50b0008 	str	r0, [fp, #-8]
    if (sem == RT_NULL)
1001f754:	e51b3008 	ldr	r3, [fp, #-8]
1001f758:	e3530000 	cmp	r3, #0
1001f75c:	1a000003 	bne	1001f770 <sem_close+0x2c>
    {
        rt_set_errno(EINVAL);
1001f760:	e3a00016 	mov	r0, #22
1001f764:	ebffca88 	bl	1001218c <rt_set_errno>

        return -1;
1001f768:	e3e03000 	mvn	r3, #0
1001f76c:	ea000019 	b	1001f7d8 <sem_close+0x94>
    }

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1001f770:	e30e0818 	movw	r0, #59416	; 0xe818
1001f774:	e3410003 	movt	r0, #4099	; 0x1003
1001f778:	e3e01000 	mvn	r1, #0
1001f77c:	ebffbf3a 	bl	1000f46c <rt_sem_take>
    sem->refcount --;
1001f780:	e51b3008 	ldr	r3, [fp, #-8]
1001f784:	e1d330b0 	ldrh	r3, [r3]
1001f788:	e2433001 	sub	r3, r3, #1
1001f78c:	e6ff2073 	uxth	r2, r3
1001f790:	e51b3008 	ldr	r3, [fp, #-8]
1001f794:	e1c320b0 	strh	r2, [r3]
    if (sem->refcount == 0)
1001f798:	e51b3008 	ldr	r3, [fp, #-8]
1001f79c:	e1d330b0 	ldrh	r3, [r3]
1001f7a0:	e3530000 	cmp	r3, #0
1001f7a4:	1a000007 	bne	1001f7c8 <sem_close+0x84>
    {
        /* delete from posix semaphore list */
        if (sem->unlinked)
1001f7a8:	e51b3008 	ldr	r3, [fp, #-8]
1001f7ac:	e5d33002 	ldrb	r3, [r3, #2]
1001f7b0:	e3530000 	cmp	r3, #0
1001f7b4:	0a000001 	beq	1001f7c0 <sem_close+0x7c>
            posix_sem_delete(sem);
1001f7b8:	e51b0008 	ldr	r0, [fp, #-8]
1001f7bc:	ebffff84 	bl	1001f5d4 <posix_sem_delete>
        sem = RT_NULL;
1001f7c0:	e3a03000 	mov	r3, #0
1001f7c4:	e50b3008 	str	r3, [fp, #-8]
    }
    rt_sem_release(&posix_sem_lock);
1001f7c8:	e30e0818 	movw	r0, #59416	; 0xe818
1001f7cc:	e3410003 	movt	r0, #4099	; 0x1003
1001f7d0:	ebffbfb9 	bl	1000f6bc <rt_sem_release>

    return 0;
1001f7d4:	e3a03000 	mov	r3, #0
}
1001f7d8:	e1a00003 	mov	r0, r3
1001f7dc:	e24bd004 	sub	sp, fp, #4
1001f7e0:	e8bd8800 	pop	{fp, pc}

1001f7e4 <sem_destroy>:
RTM_EXPORT(sem_close);

int sem_destroy(sem_t *sem)
{
1001f7e4:	e92d4800 	push	{fp, lr}
1001f7e8:	e28db004 	add	fp, sp, #4
1001f7ec:	e24dd010 	sub	sp, sp, #16
1001f7f0:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if ((!sem) || !(sem->unamed))
1001f7f4:	e51b3010 	ldr	r3, [fp, #-16]
1001f7f8:	e3530000 	cmp	r3, #0
1001f7fc:	0a000003 	beq	1001f810 <sem_destroy+0x2c>
1001f800:	e51b3010 	ldr	r3, [fp, #-16]
1001f804:	e5d33003 	ldrb	r3, [r3, #3]
1001f808:	e3530000 	cmp	r3, #0
1001f80c:	1a000003 	bne	1001f820 <sem_destroy+0x3c>
    {
        rt_set_errno(EINVAL);
1001f810:	e3a00016 	mov	r0, #22
1001f814:	ebffca5c 	bl	1001218c <rt_set_errno>

        return -1;
1001f818:	e3e03000 	mvn	r3, #0
1001f81c:	ea000018 	b	1001f884 <sem_destroy+0xa0>
    }

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1001f820:	e30e0818 	movw	r0, #59416	; 0xe818
1001f824:	e3410003 	movt	r0, #4099	; 0x1003
1001f828:	e3e01000 	mvn	r1, #0
1001f82c:	ebffbf0e 	bl	1000f46c <rt_sem_take>
    result = rt_sem_trytake(sem->sem);
1001f830:	e51b3010 	ldr	r3, [fp, #-16]
1001f834:	e5933004 	ldr	r3, [r3, #4]
1001f838:	e1a00003 	mov	r0, r3
1001f83c:	ebffbf93 	bl	1000f690 <rt_sem_trytake>
1001f840:	e50b0008 	str	r0, [fp, #-8]
    if (result != RT_EOK)
1001f844:	e51b3008 	ldr	r3, [fp, #-8]
1001f848:	e3530000 	cmp	r3, #0
1001f84c:	0a000006 	beq	1001f86c <sem_destroy+0x88>
    {
        rt_sem_release(&posix_sem_lock);
1001f850:	e30e0818 	movw	r0, #59416	; 0xe818
1001f854:	e3410003 	movt	r0, #4099	; 0x1003
1001f858:	ebffbf97 	bl	1000f6bc <rt_sem_release>
        rt_set_errno(EBUSY);
1001f85c:	e3a00010 	mov	r0, #16
1001f860:	ebffca49 	bl	1001218c <rt_set_errno>

        return -1;
1001f864:	e3e03000 	mvn	r3, #0
1001f868:	ea000005 	b	1001f884 <sem_destroy+0xa0>
    }

    /* destroy an unamed posix semaphore */
    posix_sem_delete(sem);
1001f86c:	e51b0010 	ldr	r0, [fp, #-16]
1001f870:	ebffff57 	bl	1001f5d4 <posix_sem_delete>
    rt_sem_release(&posix_sem_lock);
1001f874:	e30e0818 	movw	r0, #59416	; 0xe818
1001f878:	e3410003 	movt	r0, #4099	; 0x1003
1001f87c:	ebffbf8e 	bl	1000f6bc <rt_sem_release>

    return 0;
1001f880:	e3a03000 	mov	r3, #0
}
1001f884:	e1a00003 	mov	r0, r3
1001f888:	e24bd004 	sub	sp, fp, #4
1001f88c:	e8bd8800 	pop	{fp, pc}

1001f890 <sem_unlink>:
RTM_EXPORT(sem_destroy);

int sem_unlink(const char *name)
{
1001f890:	e92d4800 	push	{fp, lr}
1001f894:	e28db004 	add	fp, sp, #4
1001f898:	e24dd010 	sub	sp, sp, #16
1001f89c:	e50b0010 	str	r0, [fp, #-16]
    sem_t *psem;

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1001f8a0:	e30e0818 	movw	r0, #59416	; 0xe818
1001f8a4:	e3410003 	movt	r0, #4099	; 0x1003
1001f8a8:	e3e01000 	mvn	r1, #0
1001f8ac:	ebffbeee 	bl	1000f46c <rt_sem_take>
    psem = posix_sem_find(name);
1001f8b0:	e51b0010 	ldr	r0, [fp, #-16]
1001f8b4:	ebffff82 	bl	1001f6c4 <posix_sem_find>
1001f8b8:	e50b0008 	str	r0, [fp, #-8]
    if (psem != RT_NULL)
1001f8bc:	e51b3008 	ldr	r3, [fp, #-8]
1001f8c0:	e3530000 	cmp	r3, #0
1001f8c4:	0a00000d 	beq	1001f900 <sem_unlink+0x70>
    {
        psem->unlinked = 1;
1001f8c8:	e51b3008 	ldr	r3, [fp, #-8]
1001f8cc:	e3a02001 	mov	r2, #1
1001f8d0:	e5c32002 	strb	r2, [r3, #2]
        if (psem->refcount == 0)
1001f8d4:	e51b3008 	ldr	r3, [fp, #-8]
1001f8d8:	e1d330b0 	ldrh	r3, [r3]
1001f8dc:	e3530000 	cmp	r3, #0
1001f8e0:	1a000001 	bne	1001f8ec <sem_unlink+0x5c>
        {
            /* remove this semaphore */
            posix_sem_delete(psem);
1001f8e4:	e51b0008 	ldr	r0, [fp, #-8]
1001f8e8:	ebffff39 	bl	1001f5d4 <posix_sem_delete>
        }
        rt_sem_release(&posix_sem_lock);
1001f8ec:	e30e0818 	movw	r0, #59416	; 0xe818
1001f8f0:	e3410003 	movt	r0, #4099	; 0x1003
1001f8f4:	ebffbf70 	bl	1000f6bc <rt_sem_release>

        return 0;
1001f8f8:	e3a03000 	mov	r3, #0
1001f8fc:	ea000005 	b	1001f918 <sem_unlink+0x88>
    }
    rt_sem_release(&posix_sem_lock);
1001f900:	e30e0818 	movw	r0, #59416	; 0xe818
1001f904:	e3410003 	movt	r0, #4099	; 0x1003
1001f908:	ebffbf6b 	bl	1000f6bc <rt_sem_release>

    /* no this entry */
    rt_set_errno(ENOENT);
1001f90c:	e3a00002 	mov	r0, #2
1001f910:	ebffca1d 	bl	1001218c <rt_set_errno>

    return -1;
1001f914:	e3e03000 	mvn	r3, #0
}
1001f918:	e1a00003 	mov	r0, r3
1001f91c:	e24bd004 	sub	sp, fp, #4
1001f920:	e8bd8800 	pop	{fp, pc}

1001f924 <sem_getvalue>:
RTM_EXPORT(sem_unlink);

int sem_getvalue(sem_t *sem, int *sval)
{
1001f924:	e92d4800 	push	{fp, lr}
1001f928:	e28db004 	add	fp, sp, #4
1001f92c:	e24dd008 	sub	sp, sp, #8
1001f930:	e50b0008 	str	r0, [fp, #-8]
1001f934:	e50b100c 	str	r1, [fp, #-12]
    if (!sem || !sval)
1001f938:	e51b3008 	ldr	r3, [fp, #-8]
1001f93c:	e3530000 	cmp	r3, #0
1001f940:	0a000002 	beq	1001f950 <sem_getvalue+0x2c>
1001f944:	e51b300c 	ldr	r3, [fp, #-12]
1001f948:	e3530000 	cmp	r3, #0
1001f94c:	1a000003 	bne	1001f960 <sem_getvalue+0x3c>
    {
        rt_set_errno(EINVAL);
1001f950:	e3a00016 	mov	r0, #22
1001f954:	ebffca0c 	bl	1001218c <rt_set_errno>

        return -1;
1001f958:	e3e03000 	mvn	r3, #0
1001f95c:	ea000006 	b	1001f97c <sem_getvalue+0x58>
    }
    *sval = sem->sem->value;
1001f960:	e51b3008 	ldr	r3, [fp, #-8]
1001f964:	e5933004 	ldr	r3, [r3, #4]
1001f968:	e1d331b8 	ldrh	r3, [r3, #24]
1001f96c:	e1a02003 	mov	r2, r3
1001f970:	e51b300c 	ldr	r3, [fp, #-12]
1001f974:	e5832000 	str	r2, [r3]

    return 0;
1001f978:	e3a03000 	mov	r3, #0
}
1001f97c:	e1a00003 	mov	r0, r3
1001f980:	e24bd004 	sub	sp, fp, #4
1001f984:	e8bd8800 	pop	{fp, pc}

1001f988 <sem_init>:
RTM_EXPORT(sem_getvalue);

int sem_init(sem_t *sem, int pshared, unsigned int value)
{
1001f988:	e92d4800 	push	{fp, lr}
1001f98c:	e28db004 	add	fp, sp, #4
1001f990:	e24dd018 	sub	sp, sp, #24
1001f994:	e50b0010 	str	r0, [fp, #-16]
1001f998:	e50b1014 	str	r1, [fp, #-20]
1001f99c:	e50b2018 	str	r2, [fp, #-24]
    char name[RT_NAME_MAX];
    static rt_uint16_t psem_number = 0;

    if (sem == RT_NULL)
1001f9a0:	e51b3010 	ldr	r3, [fp, #-16]
1001f9a4:	e3530000 	cmp	r3, #0
1001f9a8:	1a000003 	bne	1001f9bc <sem_init+0x34>
    {
        rt_set_errno(EINVAL);
1001f9ac:	e3a00016 	mov	r0, #22
1001f9b0:	ebffc9f5 	bl	1001218c <rt_set_errno>

        return -1;
1001f9b4:	e3e03000 	mvn	r3, #0
1001f9b8:	ea000031 	b	1001fa84 <sem_init+0xfc>
    }

    rt_snprintf(name, sizeof(name), "psem%02d", psem_number++);
1001f9bc:	e30e3834 	movw	r3, #59444	; 0xe834
1001f9c0:	e3413003 	movt	r3, #4099	; 0x1003
1001f9c4:	e1d320b0 	ldrh	r2, [r3]
1001f9c8:	e2823001 	add	r3, r2, #1
1001f9cc:	e6ff1073 	uxth	r1, r3
1001f9d0:	e30e3834 	movw	r3, #59444	; 0xe834
1001f9d4:	e3413003 	movt	r3, #4099	; 0x1003
1001f9d8:	e1c310b0 	strh	r1, [r3]
1001f9dc:	e1a0c002 	mov	ip, r2
1001f9e0:	e24b300c 	sub	r3, fp, #12
1001f9e4:	e1a00003 	mov	r0, r3
1001f9e8:	e3a01006 	mov	r1, #6
1001f9ec:	e3042d60 	movw	r2, #19808	; 0x4d60
1001f9f0:	e3412003 	movt	r2, #4099	; 0x1003
1001f9f4:	e1a0300c 	mov	r3, ip
1001f9f8:	ebffcfc8 	bl	10013920 <rt_snprintf>
    sem->sem = rt_sem_create(name, value, RT_IPC_FLAG_FIFO);
1001f9fc:	e24b300c 	sub	r3, fp, #12
1001fa00:	e1a00003 	mov	r0, r3
1001fa04:	e51b1018 	ldr	r1, [fp, #-24]
1001fa08:	e3a02000 	mov	r2, #0
1001fa0c:	ebffbe3a 	bl	1000f2fc <rt_sem_create>
1001fa10:	e1a02000 	mov	r2, r0
1001fa14:	e51b3010 	ldr	r3, [fp, #-16]
1001fa18:	e5832004 	str	r2, [r3, #4]
    if (sem == RT_NULL)
1001fa1c:	e51b3010 	ldr	r3, [fp, #-16]
1001fa20:	e3530000 	cmp	r3, #0
1001fa24:	1a000003 	bne	1001fa38 <sem_init+0xb0>
    {
        rt_set_errno(ENOMEM);
1001fa28:	e3a0000c 	mov	r0, #12
1001fa2c:	ebffc9d6 	bl	1001218c <rt_set_errno>

        return -1;
1001fa30:	e3e03000 	mvn	r3, #0
1001fa34:	ea000012 	b	1001fa84 <sem_init+0xfc>
    }

    /* initialize posix semaphore */
    sem->refcount = 1;
1001fa38:	e51b3010 	ldr	r3, [fp, #-16]
1001fa3c:	e3a02001 	mov	r2, #1
1001fa40:	e1c320b0 	strh	r2, [r3]
    sem->unlinked = 0;
1001fa44:	e51b3010 	ldr	r3, [fp, #-16]
1001fa48:	e3a02000 	mov	r2, #0
1001fa4c:	e5c32002 	strb	r2, [r3, #2]
    sem->unamed = 1;
1001fa50:	e51b3010 	ldr	r3, [fp, #-16]
1001fa54:	e3a02001 	mov	r2, #1
1001fa58:	e5c32003 	strb	r2, [r3, #3]
    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1001fa5c:	e30e0818 	movw	r0, #59416	; 0xe818
1001fa60:	e3410003 	movt	r0, #4099	; 0x1003
1001fa64:	e3e01000 	mvn	r1, #0
1001fa68:	ebffbe7f 	bl	1000f46c <rt_sem_take>
    posix_sem_insert(sem);
1001fa6c:	e51b0010 	ldr	r0, [fp, #-16]
1001fa70:	ebfffec7 	bl	1001f594 <posix_sem_insert>
    rt_sem_release(&posix_sem_lock);
1001fa74:	e30e0818 	movw	r0, #59416	; 0xe818
1001fa78:	e3410003 	movt	r0, #4099	; 0x1003
1001fa7c:	ebffbf0e 	bl	1000f6bc <rt_sem_release>

    return 0;
1001fa80:	e3a03000 	mov	r3, #0
}
1001fa84:	e1a00003 	mov	r0, r3
1001fa88:	e24bd004 	sub	sp, fp, #4
1001fa8c:	e8bd8800 	pop	{fp, pc}

1001fa90 <sem_open>:
RTM_EXPORT(sem_init);

sem_t *sem_open(const char *name, int oflag, ...)
{
1001fa90:	e92d000e 	push	{r1, r2, r3}
1001fa94:	e92d4800 	push	{fp, lr}
1001fa98:	e28db004 	add	fp, sp, #4
1001fa9c:	e24dd01c 	sub	sp, sp, #28
1001faa0:	e50b001c 	str	r0, [fp, #-28]
    sem_t* sem;
    va_list arg;
    mode_t mode;
    unsigned int value;

    sem = RT_NULL;
1001faa4:	e3a03000 	mov	r3, #0
1001faa8:	e50b300c 	str	r3, [fp, #-12]

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1001faac:	e30e0818 	movw	r0, #59416	; 0xe818
1001fab0:	e3410003 	movt	r0, #4099	; 0x1003
1001fab4:	e3e01000 	mvn	r1, #0
1001fab8:	ebffbe6b 	bl	1000f46c <rt_sem_take>
    if (oflag & O_CREAT)
1001fabc:	e59b3004 	ldr	r3, [fp, #4]
1001fac0:	e2033c01 	and	r3, r3, #256	; 0x100
1001fac4:	e3530000 	cmp	r3, #0
1001fac8:	0a00003a 	beq	1001fbb8 <sem_open+0x128>
    {
        va_start(arg, oflag);
1001facc:	e28b3008 	add	r3, fp, #8
1001fad0:	e50b3018 	str	r3, [fp, #-24]
        mode = (mode_t) va_arg( arg, unsigned int); mode = mode;
1001fad4:	e51b3018 	ldr	r3, [fp, #-24]
1001fad8:	e2832004 	add	r2, r3, #4
1001fadc:	e50b2018 	str	r2, [fp, #-24]
1001fae0:	e5933000 	ldr	r3, [r3]
1001fae4:	e50b3010 	str	r3, [fp, #-16]
        value = va_arg( arg, unsigned int);
1001fae8:	e51b3018 	ldr	r3, [fp, #-24]
1001faec:	e2832004 	add	r2, r3, #4
1001faf0:	e50b2018 	str	r2, [fp, #-24]
1001faf4:	e5933000 	ldr	r3, [r3]
1001faf8:	e50b3014 	str	r3, [fp, #-20]
        va_end(arg);

        if (oflag & O_EXCL)
1001fafc:	e59b3004 	ldr	r3, [fp, #4]
1001fb00:	e2033c02 	and	r3, r3, #512	; 0x200
1001fb04:	e3530000 	cmp	r3, #0
1001fb08:	0a000007 	beq	1001fb2c <sem_open+0x9c>
        {
            if (posix_sem_find(name) != RT_NULL)
1001fb0c:	e51b001c 	ldr	r0, [fp, #-28]
1001fb10:	ebfffeeb 	bl	1001f6c4 <posix_sem_find>
1001fb14:	e1a03000 	mov	r3, r0
1001fb18:	e3530000 	cmp	r3, #0
1001fb1c:	0a000002 	beq	1001fb2c <sem_open+0x9c>
            {
                rt_set_errno(EEXIST);
1001fb20:	e3a00011 	mov	r0, #17
1001fb24:	ebffc998 	bl	1001218c <rt_set_errno>
                goto __return;
1001fb28:	ea000037 	b	1001fc0c <sem_open+0x17c>
            }
        }
        sem = (sem_t*) rt_malloc (sizeof(struct posix_sem));
1001fb2c:	e3a0000c 	mov	r0, #12
1001fb30:	ebffd1d7 	bl	10014294 <rt_malloc>
1001fb34:	e50b000c 	str	r0, [fp, #-12]
        if (sem == RT_NULL)
1001fb38:	e51b300c 	ldr	r3, [fp, #-12]
1001fb3c:	e3530000 	cmp	r3, #0
1001fb40:	1a000002 	bne	1001fb50 <sem_open+0xc0>
        {
            rt_set_errno(ENFILE);
1001fb44:	e3a00017 	mov	r0, #23
1001fb48:	ebffc98f 	bl	1001218c <rt_set_errno>
            goto __return;
1001fb4c:	ea00002e 	b	1001fc0c <sem_open+0x17c>
        }

        /* create RT-Thread semaphore */
        sem->sem = rt_sem_create(name, value, RT_IPC_FLAG_FIFO);
1001fb50:	e51b001c 	ldr	r0, [fp, #-28]
1001fb54:	e51b1014 	ldr	r1, [fp, #-20]
1001fb58:	e3a02000 	mov	r2, #0
1001fb5c:	ebffbde6 	bl	1000f2fc <rt_sem_create>
1001fb60:	e1a02000 	mov	r2, r0
1001fb64:	e51b300c 	ldr	r3, [fp, #-12]
1001fb68:	e5832004 	str	r2, [r3, #4]
        if (sem->sem == RT_NULL) /* create failed */
1001fb6c:	e51b300c 	ldr	r3, [fp, #-12]
1001fb70:	e5933004 	ldr	r3, [r3, #4]
1001fb74:	e3530000 	cmp	r3, #0
1001fb78:	1a000002 	bne	1001fb88 <sem_open+0xf8>
        {
            rt_set_errno(ENFILE);
1001fb7c:	e3a00017 	mov	r0, #23
1001fb80:	ebffc981 	bl	1001218c <rt_set_errno>
            goto __return;
1001fb84:	ea000020 	b	1001fc0c <sem_open+0x17c>
        }
        /* initialize reference count */
        sem->refcount = 1;
1001fb88:	e51b300c 	ldr	r3, [fp, #-12]
1001fb8c:	e3a02001 	mov	r2, #1
1001fb90:	e1c320b0 	strh	r2, [r3]
        sem->unlinked = 0;
1001fb94:	e51b300c 	ldr	r3, [fp, #-12]
1001fb98:	e3a02000 	mov	r2, #0
1001fb9c:	e5c32002 	strb	r2, [r3, #2]
        sem->unamed = 0;
1001fba0:	e51b300c 	ldr	r3, [fp, #-12]
1001fba4:	e3a02000 	mov	r2, #0
1001fba8:	e5c32003 	strb	r2, [r3, #3]

        /* insert semaphore to posix semaphore list */
        posix_sem_insert(sem);
1001fbac:	e51b000c 	ldr	r0, [fp, #-12]
1001fbb0:	ebfffe77 	bl	1001f594 <posix_sem_insert>
1001fbb4:	ea00000f 	b	1001fbf8 <sem_open+0x168>
    }
    else
    {
        /* find semaphore */
        sem = posix_sem_find(name);
1001fbb8:	e51b001c 	ldr	r0, [fp, #-28]
1001fbbc:	ebfffec0 	bl	1001f6c4 <posix_sem_find>
1001fbc0:	e50b000c 	str	r0, [fp, #-12]
        if (sem != RT_NULL)
1001fbc4:	e51b300c 	ldr	r3, [fp, #-12]
1001fbc8:	e3530000 	cmp	r3, #0
1001fbcc:	0a000006 	beq	1001fbec <sem_open+0x15c>
        {
            sem->refcount ++; /* increase reference count */
1001fbd0:	e51b300c 	ldr	r3, [fp, #-12]
1001fbd4:	e1d330b0 	ldrh	r3, [r3]
1001fbd8:	e2833001 	add	r3, r3, #1
1001fbdc:	e6ff2073 	uxth	r2, r3
1001fbe0:	e51b300c 	ldr	r3, [fp, #-12]
1001fbe4:	e1c320b0 	strh	r2, [r3]
1001fbe8:	ea000002 	b	1001fbf8 <sem_open+0x168>
        }
        else
        {
            rt_set_errno(ENOENT);
1001fbec:	e3a00002 	mov	r0, #2
1001fbf0:	ebffc965 	bl	1001218c <rt_set_errno>
            goto __return;
1001fbf4:	ea000004 	b	1001fc0c <sem_open+0x17c>
        }
    }
    rt_sem_release(&posix_sem_lock);
1001fbf8:	e30e0818 	movw	r0, #59416	; 0xe818
1001fbfc:	e3410003 	movt	r0, #4099	; 0x1003
1001fc00:	ebffbead 	bl	1000f6bc <rt_sem_release>

    return sem;
1001fc04:	e51b300c 	ldr	r3, [fp, #-12]
1001fc08:	ea000010 	b	1001fc50 <sem_open+0x1c0>

__return:
    /* release lock */
    rt_sem_release(&posix_sem_lock);
1001fc0c:	e30e0818 	movw	r0, #59416	; 0xe818
1001fc10:	e3410003 	movt	r0, #4099	; 0x1003
1001fc14:	ebffbea8 	bl	1000f6bc <rt_sem_release>

    /* release allocated memory */
    if (sem != RT_NULL)
1001fc18:	e51b300c 	ldr	r3, [fp, #-12]
1001fc1c:	e3530000 	cmp	r3, #0
1001fc20:	0a000009 	beq	1001fc4c <sem_open+0x1bc>
    {
        /* delete RT-Thread semaphore */
        if (sem->sem != RT_NULL)
1001fc24:	e51b300c 	ldr	r3, [fp, #-12]
1001fc28:	e5933004 	ldr	r3, [r3, #4]
1001fc2c:	e3530000 	cmp	r3, #0
1001fc30:	0a000003 	beq	1001fc44 <sem_open+0x1b4>
            rt_sem_delete(sem->sem);
1001fc34:	e51b300c 	ldr	r3, [fp, #-12]
1001fc38:	e5933004 	ldr	r3, [r3, #4]
1001fc3c:	e1a00003 	mov	r0, r3
1001fc40:	ebffbdde 	bl	1000f3c0 <rt_sem_delete>
        rt_free(sem);
1001fc44:	e51b000c 	ldr	r0, [fp, #-12]
1001fc48:	ebffd3ac 	bl	10014b00 <rt_free>
    }

    return RT_NULL;
1001fc4c:	e3a03000 	mov	r3, #0
}
1001fc50:	e1a00003 	mov	r0, r3
1001fc54:	e24bd004 	sub	sp, fp, #4
1001fc58:	e8bd4800 	pop	{fp, lr}
1001fc5c:	e28dd00c 	add	sp, sp, #12
1001fc60:	e12fff1e 	bx	lr

1001fc64 <sem_post>:
RTM_EXPORT(sem_open);

int sem_post(sem_t *sem)
{
1001fc64:	e92d4800 	push	{fp, lr}
1001fc68:	e28db004 	add	fp, sp, #4
1001fc6c:	e24dd010 	sub	sp, sp, #16
1001fc70:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
1001fc74:	e51b3010 	ldr	r3, [fp, #-16]
1001fc78:	e3530000 	cmp	r3, #0
1001fc7c:	1a000003 	bne	1001fc90 <sem_post+0x2c>
    {
        rt_set_errno(EINVAL);
1001fc80:	e3a00016 	mov	r0, #22
1001fc84:	ebffc940 	bl	1001218c <rt_set_errno>

        return -1;
1001fc88:	e3e03000 	mvn	r3, #0
1001fc8c:	ea00000c 	b	1001fcc4 <sem_post+0x60>
    }

    result = rt_sem_release(sem->sem);
1001fc90:	e51b3010 	ldr	r3, [fp, #-16]
1001fc94:	e5933004 	ldr	r3, [r3, #4]
1001fc98:	e1a00003 	mov	r0, r3
1001fc9c:	ebffbe86 	bl	1000f6bc <rt_sem_release>
1001fca0:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
1001fca4:	e51b3008 	ldr	r3, [fp, #-8]
1001fca8:	e3530000 	cmp	r3, #0
1001fcac:	1a000001 	bne	1001fcb8 <sem_post+0x54>
        return 0;
1001fcb0:	e3a03000 	mov	r3, #0
1001fcb4:	ea000002 	b	1001fcc4 <sem_post+0x60>

    rt_set_errno(EINVAL);
1001fcb8:	e3a00016 	mov	r0, #22
1001fcbc:	ebffc932 	bl	1001218c <rt_set_errno>

    return -1;
1001fcc0:	e3e03000 	mvn	r3, #0
}
1001fcc4:	e1a00003 	mov	r0, r3
1001fcc8:	e24bd004 	sub	sp, fp, #4
1001fccc:	e8bd8800 	pop	{fp, pc}

1001fcd0 <sem_timedwait>:
RTM_EXPORT(sem_post);

int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout)
{
1001fcd0:	e92d4800 	push	{fp, lr}
1001fcd4:	e28db004 	add	fp, sp, #4
1001fcd8:	e24dd010 	sub	sp, sp, #16
1001fcdc:	e50b0010 	str	r0, [fp, #-16]
1001fce0:	e50b1014 	str	r1, [fp, #-20]
    rt_err_t result;
    rt_int32_t tick;

    if (!sem || !abs_timeout)
1001fce4:	e51b3010 	ldr	r3, [fp, #-16]
1001fce8:	e3530000 	cmp	r3, #0
1001fcec:	0a000002 	beq	1001fcfc <sem_timedwait+0x2c>
1001fcf0:	e51b3014 	ldr	r3, [fp, #-20]
1001fcf4:	e3530000 	cmp	r3, #0
1001fcf8:	1a000001 	bne	1001fd04 <sem_timedwait+0x34>
        return EINVAL;
1001fcfc:	e3a03016 	mov	r3, #22
1001fd00:	ea000017 	b	1001fd64 <sem_timedwait+0x94>

    /* calculate os tick */
    tick = clock_time_to_tick(abs_timeout);
1001fd04:	e51b0014 	ldr	r0, [fp, #-20]
1001fd08:	ebfff57c 	bl	1001d300 <clock_time_to_tick>
1001fd0c:	e50b0008 	str	r0, [fp, #-8]
    
    result = rt_sem_take(sem->sem, tick);
1001fd10:	e51b3010 	ldr	r3, [fp, #-16]
1001fd14:	e5933004 	ldr	r3, [r3, #4]
1001fd18:	e1a00003 	mov	r0, r3
1001fd1c:	e51b1008 	ldr	r1, [fp, #-8]
1001fd20:	ebffbdd1 	bl	1000f46c <rt_sem_take>
1001fd24:	e50b000c 	str	r0, [fp, #-12]
    if (result == -RT_ETIMEOUT)
1001fd28:	e51b300c 	ldr	r3, [fp, #-12]
1001fd2c:	e3730002 	cmn	r3, #2
1001fd30:	1a000003 	bne	1001fd44 <sem_timedwait+0x74>
    {
        rt_set_errno(ETIMEDOUT);
1001fd34:	e3a00074 	mov	r0, #116	; 0x74
1001fd38:	ebffc913 	bl	1001218c <rt_set_errno>

        return -1;
1001fd3c:	e3e03000 	mvn	r3, #0
1001fd40:	ea000007 	b	1001fd64 <sem_timedwait+0x94>
    }
    if (result == RT_EOK)
1001fd44:	e51b300c 	ldr	r3, [fp, #-12]
1001fd48:	e3530000 	cmp	r3, #0
1001fd4c:	1a000001 	bne	1001fd58 <sem_timedwait+0x88>
        return 0;
1001fd50:	e3a03000 	mov	r3, #0
1001fd54:	ea000002 	b	1001fd64 <sem_timedwait+0x94>

    rt_set_errno(EINTR);
1001fd58:	e3a00004 	mov	r0, #4
1001fd5c:	ebffc90a 	bl	1001218c <rt_set_errno>

    return -1;
1001fd60:	e3e03000 	mvn	r3, #0
}
1001fd64:	e1a00003 	mov	r0, r3
1001fd68:	e24bd004 	sub	sp, fp, #4
1001fd6c:	e8bd8800 	pop	{fp, pc}

1001fd70 <sem_trywait>:
RTM_EXPORT(sem_timedwait);

int sem_trywait(sem_t *sem)
{
1001fd70:	e92d4800 	push	{fp, lr}
1001fd74:	e28db004 	add	fp, sp, #4
1001fd78:	e24dd010 	sub	sp, sp, #16
1001fd7c:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
1001fd80:	e51b3010 	ldr	r3, [fp, #-16]
1001fd84:	e3530000 	cmp	r3, #0
1001fd88:	1a000003 	bne	1001fd9c <sem_trywait+0x2c>
    {
        rt_set_errno(EINVAL);
1001fd8c:	e3a00016 	mov	r0, #22
1001fd90:	ebffc8fd 	bl	1001218c <rt_set_errno>

        return -1;
1001fd94:	e3e03000 	mvn	r3, #0
1001fd98:	ea000014 	b	1001fdf0 <sem_trywait+0x80>
    }

    result = rt_sem_take(sem->sem, RT_WAITING_FOREVER);
1001fd9c:	e51b3010 	ldr	r3, [fp, #-16]
1001fda0:	e5933004 	ldr	r3, [r3, #4]
1001fda4:	e1a00003 	mov	r0, r3
1001fda8:	e3e01000 	mvn	r1, #0
1001fdac:	ebffbdae 	bl	1000f46c <rt_sem_take>
1001fdb0:	e50b0008 	str	r0, [fp, #-8]
    if (result == -RT_ETIMEOUT)
1001fdb4:	e51b3008 	ldr	r3, [fp, #-8]
1001fdb8:	e3730002 	cmn	r3, #2
1001fdbc:	1a000003 	bne	1001fdd0 <sem_trywait+0x60>
    {
        rt_set_errno(EAGAIN);
1001fdc0:	e3a0000b 	mov	r0, #11
1001fdc4:	ebffc8f0 	bl	1001218c <rt_set_errno>

        return -1;
1001fdc8:	e3e03000 	mvn	r3, #0
1001fdcc:	ea000007 	b	1001fdf0 <sem_trywait+0x80>
    }
    if (result == RT_EOK)
1001fdd0:	e51b3008 	ldr	r3, [fp, #-8]
1001fdd4:	e3530000 	cmp	r3, #0
1001fdd8:	1a000001 	bne	1001fde4 <sem_trywait+0x74>
        return 0;
1001fddc:	e3a03000 	mov	r3, #0
1001fde0:	ea000002 	b	1001fdf0 <sem_trywait+0x80>

    rt_set_errno(EINTR);
1001fde4:	e3a00004 	mov	r0, #4
1001fde8:	ebffc8e7 	bl	1001218c <rt_set_errno>

    return -1;
1001fdec:	e3e03000 	mvn	r3, #0
}
1001fdf0:	e1a00003 	mov	r0, r3
1001fdf4:	e24bd004 	sub	sp, fp, #4
1001fdf8:	e8bd8800 	pop	{fp, pc}

1001fdfc <sem_wait>:
RTM_EXPORT(sem_trywait);

int sem_wait(sem_t *sem)
{
1001fdfc:	e92d4800 	push	{fp, lr}
1001fe00:	e28db004 	add	fp, sp, #4
1001fe04:	e24dd010 	sub	sp, sp, #16
1001fe08:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
1001fe0c:	e51b3010 	ldr	r3, [fp, #-16]
1001fe10:	e3530000 	cmp	r3, #0
1001fe14:	1a000003 	bne	1001fe28 <sem_wait+0x2c>
    {
        rt_set_errno(EINVAL);
1001fe18:	e3a00016 	mov	r0, #22
1001fe1c:	ebffc8da 	bl	1001218c <rt_set_errno>

        return -1;
1001fe20:	e3e03000 	mvn	r3, #0
1001fe24:	ea00000d 	b	1001fe60 <sem_wait+0x64>
    }

    result = rt_sem_take(sem->sem, RT_WAITING_FOREVER);
1001fe28:	e51b3010 	ldr	r3, [fp, #-16]
1001fe2c:	e5933004 	ldr	r3, [r3, #4]
1001fe30:	e1a00003 	mov	r0, r3
1001fe34:	e3e01000 	mvn	r1, #0
1001fe38:	ebffbd8b 	bl	1000f46c <rt_sem_take>
1001fe3c:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
1001fe40:	e51b3008 	ldr	r3, [fp, #-8]
1001fe44:	e3530000 	cmp	r3, #0
1001fe48:	1a000001 	bne	1001fe54 <sem_wait+0x58>
        return 0;
1001fe4c:	e3a03000 	mov	r3, #0
1001fe50:	ea000002 	b	1001fe60 <sem_wait+0x64>

    rt_set_errno(EINTR);
1001fe54:	e3a00004 	mov	r0, #4
1001fe58:	ebffc8cb 	bl	1001218c <rt_set_errno>

    return -1;
1001fe5c:	e3e03000 	mvn	r3, #0
}
1001fe60:	e1a00003 	mov	r0, r3
1001fe64:	e24bd004 	sub	sp, fp, #4
1001fe68:	e8bd8800 	pop	{fp, pc}

1001fe6c <libc_system_init>:
#endif

#endif

int libc_system_init(void)
{
1001fe6c:	e92d4800 	push	{fp, lr}
1001fe70:	e28db004 	add	fp, sp, #4
        fd = fd;
    }
#endif

    /* set PATH and HOME */
    putenv("PATH=/bin");
1001fe74:	e3040d6c 	movw	r0, #19820	; 0x4d6c
1001fe78:	e3410003 	movt	r0, #4099	; 0x1003
1001fe7c:	fa003d6f 	blx	1002f440 <putenv>
    putenv("HOME=/home");
1001fe80:	e3040d78 	movw	r0, #19832	; 0x4d78
1001fe84:	e3410003 	movt	r0, #4099	; 0x1003
1001fe88:	fa003d6c 	blx	1002f440 <putenv>

#ifdef RT_USING_PTHREADS
    pthread_system_init();
1001fe8c:	ebfff83e 	bl	1001df8c <pthread_system_init>
#endif

    return 0;
1001fe90:	e3a03000 	mov	r3, #0
}
1001fe94:	e1a00003 	mov	r0, r3
1001fe98:	e8bd8800 	pop	{fp, pc}

1001fe9c <_close_r>:

/* Reentrant versions of system calls.  */

int
_close_r(struct _reent *ptr, int fd)
{
1001fe9c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001fea0:	e28db000 	add	fp, sp, #0
1001fea4:	e24dd00c 	sub	sp, sp, #12
1001fea8:	e50b0008 	str	r0, [fp, #-8]
1001feac:	e50b100c 	str	r1, [fp, #-12]
#ifndef RT_USING_DFS
	return 0;
1001feb0:	e3a03000 	mov	r3, #0
#else
	return close(fd);
#endif
}
1001feb4:	e1a00003 	mov	r0, r3
1001feb8:	e24bd000 	sub	sp, fp, #0
1001febc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001fec0:	e12fff1e 	bx	lr

1001fec4 <_execve_r>:

int
_execve_r(struct _reent *ptr, const char * name, char *const *argv, char *const *env)
{
1001fec4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001fec8:	e28db000 	add	fp, sp, #0
1001fecc:	e24dd014 	sub	sp, sp, #20
1001fed0:	e50b0008 	str	r0, [fp, #-8]
1001fed4:	e50b100c 	str	r1, [fp, #-12]
1001fed8:	e50b2010 	str	r2, [fp, #-16]
1001fedc:	e50b3014 	str	r3, [fp, #-20]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1001fee0:	e51b3008 	ldr	r3, [fp, #-8]
1001fee4:	e3a02086 	mov	r2, #134	; 0x86
1001fee8:	e5832000 	str	r2, [r3]
	return -1;
1001feec:	e3e03000 	mvn	r3, #0
}
1001fef0:	e1a00003 	mov	r0, r3
1001fef4:	e24bd000 	sub	sp, fp, #0
1001fef8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001fefc:	e12fff1e 	bx	lr

1001ff00 <_fcntl_r>:

int
_fcntl_r(struct _reent *ptr, int fd, int cmd, int arg)
{
1001ff00:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001ff04:	e28db000 	add	fp, sp, #0
1001ff08:	e24dd014 	sub	sp, sp, #20
1001ff0c:	e50b0008 	str	r0, [fp, #-8]
1001ff10:	e50b100c 	str	r1, [fp, #-12]
1001ff14:	e50b2010 	str	r2, [fp, #-16]
1001ff18:	e50b3014 	str	r3, [fp, #-20]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1001ff1c:	e51b3008 	ldr	r3, [fp, #-8]
1001ff20:	e3a02086 	mov	r2, #134	; 0x86
1001ff24:	e5832000 	str	r2, [r3]
	return -1;
1001ff28:	e3e03000 	mvn	r3, #0
}
1001ff2c:	e1a00003 	mov	r0, r3
1001ff30:	e24bd000 	sub	sp, fp, #0
1001ff34:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001ff38:	e12fff1e 	bx	lr

1001ff3c <_fork_r>:

int
_fork_r(struct _reent *ptr)
{
1001ff3c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001ff40:	e28db000 	add	fp, sp, #0
1001ff44:	e24dd00c 	sub	sp, sp, #12
1001ff48:	e50b0008 	str	r0, [fp, #-8]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1001ff4c:	e51b3008 	ldr	r3, [fp, #-8]
1001ff50:	e3a02086 	mov	r2, #134	; 0x86
1001ff54:	e5832000 	str	r2, [r3]
	return -1;
1001ff58:	e3e03000 	mvn	r3, #0
}
1001ff5c:	e1a00003 	mov	r0, r3
1001ff60:	e24bd000 	sub	sp, fp, #0
1001ff64:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001ff68:	e12fff1e 	bx	lr

1001ff6c <_fstat_r>:

int
_fstat_r(struct _reent *ptr, int fd, struct stat *pstat)
{
1001ff6c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001ff70:	e28db000 	add	fp, sp, #0
1001ff74:	e24dd014 	sub	sp, sp, #20
1001ff78:	e50b0008 	str	r0, [fp, #-8]
1001ff7c:	e50b100c 	str	r1, [fp, #-12]
1001ff80:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1001ff84:	e51b3008 	ldr	r3, [fp, #-8]
1001ff88:	e3a02086 	mov	r2, #134	; 0x86
1001ff8c:	e5832000 	str	r2, [r3]
	return -1;
1001ff90:	e3e03000 	mvn	r3, #0
}
1001ff94:	e1a00003 	mov	r0, r3
1001ff98:	e24bd000 	sub	sp, fp, #0
1001ff9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001ffa0:	e12fff1e 	bx	lr

1001ffa4 <_getpid_r>:

int
_getpid_r(struct _reent *ptr)
{
1001ffa4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001ffa8:	e28db000 	add	fp, sp, #0
1001ffac:	e24dd00c 	sub	sp, sp, #12
1001ffb0:	e50b0008 	str	r0, [fp, #-8]
	return 0;
1001ffb4:	e3a03000 	mov	r3, #0
}
1001ffb8:	e1a00003 	mov	r0, r3
1001ffbc:	e24bd000 	sub	sp, fp, #0
1001ffc0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001ffc4:	e12fff1e 	bx	lr

1001ffc8 <_isatty_r>:

int
_isatty_r(struct _reent *ptr, int fd)
{
1001ffc8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001ffcc:	e28db000 	add	fp, sp, #0
1001ffd0:	e24dd00c 	sub	sp, sp, #12
1001ffd4:	e50b0008 	str	r0, [fp, #-8]
1001ffd8:	e50b100c 	str	r1, [fp, #-12]
	if (fd >=0 && fd < 3) return 1;
1001ffdc:	e51b300c 	ldr	r3, [fp, #-12]
1001ffe0:	e3530000 	cmp	r3, #0
1001ffe4:	ba000004 	blt	1001fffc <_isatty_r+0x34>
1001ffe8:	e51b300c 	ldr	r3, [fp, #-12]
1001ffec:	e3530002 	cmp	r3, #2
1001fff0:	ca000001 	bgt	1001fffc <_isatty_r+0x34>
1001fff4:	e3a03001 	mov	r3, #1
1001fff8:	ea000003 	b	1002000c <_isatty_r+0x44>

	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1001fffc:	e51b3008 	ldr	r3, [fp, #-8]
10020000:	e3a02086 	mov	r2, #134	; 0x86
10020004:	e5832000 	str	r2, [r3]
	return -1;
10020008:	e3e03000 	mvn	r3, #0
}
1002000c:	e1a00003 	mov	r0, r3
10020010:	e24bd000 	sub	sp, fp, #0
10020014:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020018:	e12fff1e 	bx	lr

1002001c <_kill_r>:

int
_kill_r(struct _reent *ptr, int pid, int sig)
{
1002001c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020020:	e28db000 	add	fp, sp, #0
10020024:	e24dd014 	sub	sp, sp, #20
10020028:	e50b0008 	str	r0, [fp, #-8]
1002002c:	e50b100c 	str	r1, [fp, #-12]
10020030:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
10020034:	e51b3008 	ldr	r3, [fp, #-8]
10020038:	e3a02086 	mov	r2, #134	; 0x86
1002003c:	e5832000 	str	r2, [r3]
	return -1;
10020040:	e3e03000 	mvn	r3, #0
}
10020044:	e1a00003 	mov	r0, r3
10020048:	e24bd000 	sub	sp, fp, #0
1002004c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020050:	e12fff1e 	bx	lr

10020054 <_link_r>:

int
_link_r(struct _reent *ptr, const char *old, const char *new)
{
10020054:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020058:	e28db000 	add	fp, sp, #0
1002005c:	e24dd014 	sub	sp, sp, #20
10020060:	e50b0008 	str	r0, [fp, #-8]
10020064:	e50b100c 	str	r1, [fp, #-12]
10020068:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1002006c:	e51b3008 	ldr	r3, [fp, #-8]
10020070:	e3a02086 	mov	r2, #134	; 0x86
10020074:	e5832000 	str	r2, [r3]
	return -1;
10020078:	e3e03000 	mvn	r3, #0
}
1002007c:	e1a00003 	mov	r0, r3
10020080:	e24bd000 	sub	sp, fp, #0
10020084:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020088:	e12fff1e 	bx	lr

1002008c <_lseek_r>:

_off_t
_lseek_r(struct _reent *ptr, int fd, _off_t pos, int whence)
{
1002008c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020090:	e28db000 	add	fp, sp, #0
10020094:	e24dd014 	sub	sp, sp, #20
10020098:	e50b0008 	str	r0, [fp, #-8]
1002009c:	e50b100c 	str	r1, [fp, #-12]
100200a0:	e50b2010 	str	r2, [fp, #-16]
100200a4:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
100200a8:	e3a03000 	mov	r3, #0
	_off_t rc;

	rc = lseek(fd, pos, whence);
	return rc;
#endif
}
100200ac:	e1a00003 	mov	r0, r3
100200b0:	e24bd000 	sub	sp, fp, #0
100200b4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100200b8:	e12fff1e 	bx	lr

100200bc <_mkdir_r>:

int
_mkdir_r(struct _reent *ptr, const char *name, int mode)
{
100200bc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100200c0:	e28db000 	add	fp, sp, #0
100200c4:	e24dd014 	sub	sp, sp, #20
100200c8:	e50b0008 	str	r0, [fp, #-8]
100200cc:	e50b100c 	str	r1, [fp, #-12]
100200d0:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
100200d4:	e3a03000 	mov	r3, #0
	int rc;

	rc = mkdir(name, mode);
	return rc;
#endif
}
100200d8:	e1a00003 	mov	r0, r3
100200dc:	e24bd000 	sub	sp, fp, #0
100200e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100200e4:	e12fff1e 	bx	lr

100200e8 <_open_r>:

int
_open_r(struct _reent *ptr, const char *file, int flags, int mode)
{
100200e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100200ec:	e28db000 	add	fp, sp, #0
100200f0:	e24dd014 	sub	sp, sp, #20
100200f4:	e50b0008 	str	r0, [fp, #-8]
100200f8:	e50b100c 	str	r1, [fp, #-12]
100200fc:	e50b2010 	str	r2, [fp, #-16]
10020100:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
10020104:	e3a03000 	mov	r3, #0
	int rc;

	rc = open(file, flags, mode);
	return rc;
#endif
}
10020108:	e1a00003 	mov	r0, r3
1002010c:	e24bd000 	sub	sp, fp, #0
10020110:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020114:	e12fff1e 	bx	lr

10020118 <_read_r>:

_ssize_t 
_read_r(struct _reent *ptr, int fd, void *buf, size_t nbytes)
{
10020118:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002011c:	e28db000 	add	fp, sp, #0
10020120:	e24dd014 	sub	sp, sp, #20
10020124:	e50b0008 	str	r0, [fp, #-8]
10020128:	e50b100c 	str	r1, [fp, #-12]
1002012c:	e50b2010 	str	r2, [fp, #-16]
10020130:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
10020134:	e3a03000 	mov	r3, #0
	_ssize_t rc;

	rc = read(fd, buf, nbytes);
	return rc;
#endif
}
10020138:	e1a00003 	mov	r0, r3
1002013c:	e24bd000 	sub	sp, fp, #0
10020140:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020144:	e12fff1e 	bx	lr

10020148 <_rename_r>:

int
_rename_r(struct _reent *ptr, const char *old, const char *new)
{
10020148:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002014c:	e28db000 	add	fp, sp, #0
10020150:	e24dd014 	sub	sp, sp, #20
10020154:	e50b0008 	str	r0, [fp, #-8]
10020158:	e50b100c 	str	r1, [fp, #-12]
1002015c:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
10020160:	e3a03000 	mov	r3, #0
	int rc;

	rc = rename(old, new);
	return rc;
#endif
}
10020164:	e1a00003 	mov	r0, r3
10020168:	e24bd000 	sub	sp, fp, #0
1002016c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020170:	e12fff1e 	bx	lr

10020174 <_sbrk_r>:

void *
_sbrk_r(struct _reent *ptr, ptrdiff_t incr)
{
10020174:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020178:	e28db000 	add	fp, sp, #0
1002017c:	e24dd00c 	sub	sp, sp, #12
10020180:	e50b0008 	str	r0, [fp, #-8]
10020184:	e50b100c 	str	r1, [fp, #-12]
	/* no use this routine to get memory */
	return RT_NULL;
10020188:	e3a03000 	mov	r3, #0
}
1002018c:	e1a00003 	mov	r0, r3
10020190:	e24bd000 	sub	sp, fp, #0
10020194:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020198:	e12fff1e 	bx	lr

1002019c <_stat_r>:

int
_stat_r(struct _reent *ptr, const char *file, struct stat *pstat)
{
1002019c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100201a0:	e28db000 	add	fp, sp, #0
100201a4:	e24dd014 	sub	sp, sp, #20
100201a8:	e50b0008 	str	r0, [fp, #-8]
100201ac:	e50b100c 	str	r1, [fp, #-12]
100201b0:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
100201b4:	e3a03000 	mov	r3, #0
	int rc;

	rc = stat(file, pstat);
	return rc;
#endif
}
100201b8:	e1a00003 	mov	r0, r3
100201bc:	e24bd000 	sub	sp, fp, #0
100201c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100201c4:	e12fff1e 	bx	lr

100201c8 <_times_r>:

_CLOCK_T_
_times_r(struct _reent *ptr, struct tms *ptms)
{
100201c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100201cc:	e28db000 	add	fp, sp, #0
100201d0:	e24dd00c 	sub	sp, sp, #12
100201d4:	e50b0008 	str	r0, [fp, #-8]
100201d8:	e50b100c 	str	r1, [fp, #-12]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
100201dc:	e51b3008 	ldr	r3, [fp, #-8]
100201e0:	e3a02086 	mov	r2, #134	; 0x86
100201e4:	e5832000 	str	r2, [r3]
	return -1;
100201e8:	e3e03000 	mvn	r3, #0
}
100201ec:	e1a00003 	mov	r0, r3
100201f0:	e24bd000 	sub	sp, fp, #0
100201f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100201f8:	e12fff1e 	bx	lr

100201fc <_unlink_r>:

int
_unlink_r(struct _reent *ptr, const char *file)
{
100201fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020200:	e28db000 	add	fp, sp, #0
10020204:	e24dd00c 	sub	sp, sp, #12
10020208:	e50b0008 	str	r0, [fp, #-8]
1002020c:	e50b100c 	str	r1, [fp, #-12]
#ifndef RT_USING_DFS
	return 0;
10020210:	e3a03000 	mov	r3, #0
	int rc;

	rc = unlink(file);
	return rc;
#endif
}
10020214:	e1a00003 	mov	r0, r3
10020218:	e24bd000 	sub	sp, fp, #0
1002021c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020220:	e12fff1e 	bx	lr

10020224 <_wait_r>:

int
_wait_r(struct _reent *ptr, int *status)
{
10020224:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020228:	e28db000 	add	fp, sp, #0
1002022c:	e24dd00c 	sub	sp, sp, #12
10020230:	e50b0008 	str	r0, [fp, #-8]
10020234:	e50b100c 	str	r1, [fp, #-12]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
10020238:	e51b3008 	ldr	r3, [fp, #-8]
1002023c:	e3a02086 	mov	r2, #134	; 0x86
10020240:	e5832000 	str	r2, [r3]
	return -1;
10020244:	e3e03000 	mvn	r3, #0
}
10020248:	e1a00003 	mov	r0, r3
1002024c:	e24bd000 	sub	sp, fp, #0
10020250:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020254:	e12fff1e 	bx	lr

10020258 <_write_r>:

#ifdef RT_USING_DEVICE
_ssize_t
_write_r(struct _reent *ptr, int fd, const void *buf, size_t nbytes)
{
10020258:	e92d4800 	push	{fp, lr}
1002025c:	e28db004 	add	fp, sp, #4
10020260:	e24dd018 	sub	sp, sp, #24
10020264:	e50b0010 	str	r0, [fp, #-16]
10020268:	e50b1014 	str	r1, [fp, #-20]
1002026c:	e50b2018 	str	r2, [fp, #-24]
10020270:	e50b301c 	str	r3, [fp, #-28]
	if (fd < 3)
10020274:	e51b3014 	ldr	r3, [fp, #-20]
10020278:	e3530002 	cmp	r3, #2
1002027c:	ca00000b 	bgt	100202b0 <_write_r+0x58>
	{
#ifdef RT_USING_CONSOLE
		rt_device_t console_device;
		extern rt_device_t rt_console_get_device(void);

		console_device = rt_console_get_device();
10020280:	ebffcddb 	bl	100139f4 <rt_console_get_device>
10020284:	e50b0008 	str	r0, [fp, #-8]
		if (console_device != 0) rt_device_write(console_device, 0, buf, nbytes);
10020288:	e51b3008 	ldr	r3, [fp, #-8]
1002028c:	e3530000 	cmp	r3, #0
10020290:	0a000004 	beq	100202a8 <_write_r+0x50>
10020294:	e51b0008 	ldr	r0, [fp, #-8]
10020298:	e3a01000 	mov	r1, #0
1002029c:	e51b2018 	ldr	r2, [fp, #-24]
100202a0:	e51b301c 	ldr	r3, [fp, #-28]
100202a4:	ebffba16 	bl	1000eb04 <rt_device_write>
		return nbytes;
100202a8:	e51b301c 	ldr	r3, [fp, #-28]
100202ac:	ea000000 	b	100202b4 <_write_r+0x5c>
	    _ssize_t rc;

	    rc = write(fd, buf, nbytes);
	    return rc;
#else
        return 0;
100202b0:	e3a03000 	mov	r3, #0
#endif
	}
}
100202b4:	e1a00003 	mov	r0, r3
100202b8:	e24bd004 	sub	sp, fp, #4
100202bc:	e8bd8800 	pop	{fp, pc}

100202c0 <_gettimeofday_r>:
#else
/* POSIX thread provides clock_gettime function */
#include <time.h>
int
_gettimeofday_r(struct _reent *ptr, struct timeval *__tp, void *__tzp)
{
100202c0:	e92d4800 	push	{fp, lr}
100202c4:	e28db004 	add	fp, sp, #4
100202c8:	e24dd018 	sub	sp, sp, #24
100202cc:	e50b0010 	str	r0, [fp, #-16]
100202d0:	e50b1014 	str	r1, [fp, #-20]
100202d4:	e50b2018 	str	r2, [fp, #-24]
	struct timespec tp;

	if (clock_gettime(CLOCK_REALTIME, &tp) == 0)
100202d8:	e24b300c 	sub	r3, fp, #12
100202dc:	e3a00001 	mov	r0, #1
100202e0:	e1a01003 	mov	r1, r3
100202e4:	ebfff476 	bl	1001d4c4 <clock_gettime>
100202e8:	e1a03000 	mov	r3, r0
100202ec:	e3530000 	cmp	r3, #0
100202f0:	1a000013 	bne	10020344 <_gettimeofday_r+0x84>
	{
		if (__tp != RT_NULL)
100202f4:	e51b3014 	ldr	r3, [fp, #-20]
100202f8:	e3530000 	cmp	r3, #0
100202fc:	0a00000e 	beq	1002033c <_gettimeofday_r+0x7c>
		{
			__tp->tv_sec  = tp.tv_sec;
10020300:	e51b200c 	ldr	r2, [fp, #-12]
10020304:	e51b3014 	ldr	r3, [fp, #-20]
10020308:	e5832000 	str	r2, [r3]
			__tp->tv_usec = tp.tv_nsec * 1000UL;
1002030c:	e51b3008 	ldr	r3, [fp, #-8]
10020310:	e1a01003 	mov	r1, r3
10020314:	e1a02001 	mov	r2, r1
10020318:	e1a03102 	lsl	r3, r2, #2
1002031c:	e1a02003 	mov	r2, r3
10020320:	e1a03282 	lsl	r3, r2, #5
10020324:	e0623003 	rsb	r3, r2, r3
10020328:	e0833001 	add	r3, r3, r1
1002032c:	e1a03183 	lsl	r3, r3, #3
10020330:	e1a02003 	mov	r2, r3
10020334:	e51b3014 	ldr	r3, [fp, #-20]
10020338:	e5832004 	str	r2, [r3, #4]
		}

		return tp.tv_sec;
1002033c:	e51b300c 	ldr	r3, [fp, #-12]
10020340:	ea000003 	b	10020354 <_gettimeofday_r+0x94>
	}

	/* return "not supported" */
	ptr->_errno = ENOTSUP;
10020344:	e51b3010 	ldr	r3, [fp, #-16]
10020348:	e3a02086 	mov	r2, #134	; 0x86
1002034c:	e5832000 	str	r2, [r3]
	return -1;
10020350:	e3e03000 	mvn	r3, #0
}
10020354:	e1a00003 	mov	r0, r3
10020358:	e24bd004 	sub	sp, fp, #4
1002035c:	e8bd8800 	pop	{fp, pc}

10020360 <_malloc_r>:
#endif

/* Memory routine */
void *
_malloc_r (struct _reent *ptr, size_t size)
{
10020360:	e92d4800 	push	{fp, lr}
10020364:	e28db004 	add	fp, sp, #4
10020368:	e24dd010 	sub	sp, sp, #16
1002036c:	e50b0010 	str	r0, [fp, #-16]
10020370:	e50b1014 	str	r1, [fp, #-20]
	void* result;

	result = (void*)rt_malloc (size);
10020374:	e51b0014 	ldr	r0, [fp, #-20]
10020378:	ebffcfc5 	bl	10014294 <rt_malloc>
1002037c:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
10020380:	e51b3008 	ldr	r3, [fp, #-8]
10020384:	e3530000 	cmp	r3, #0
10020388:	1a000002 	bne	10020398 <_malloc_r+0x38>
	{
		ptr->_errno = ENOMEM;
1002038c:	e51b3010 	ldr	r3, [fp, #-16]
10020390:	e3a0200c 	mov	r2, #12
10020394:	e5832000 	str	r2, [r3]
	}

	return result;
10020398:	e51b3008 	ldr	r3, [fp, #-8]
}
1002039c:	e1a00003 	mov	r0, r3
100203a0:	e24bd004 	sub	sp, fp, #4
100203a4:	e8bd8800 	pop	{fp, pc}

100203a8 <_realloc_r>:

void *
_realloc_r (struct _reent *ptr, void *old, size_t newlen)
{
100203a8:	e92d4800 	push	{fp, lr}
100203ac:	e28db004 	add	fp, sp, #4
100203b0:	e24dd018 	sub	sp, sp, #24
100203b4:	e50b0010 	str	r0, [fp, #-16]
100203b8:	e50b1014 	str	r1, [fp, #-20]
100203bc:	e50b2018 	str	r2, [fp, #-24]
	void* result;

	result = (void*)rt_realloc (old, newlen);
100203c0:	e51b0014 	ldr	r0, [fp, #-20]
100203c4:	e51b1018 	ldr	r1, [fp, #-24]
100203c8:	ebffd0ef 	bl	1001478c <rt_realloc>
100203cc:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
100203d0:	e51b3008 	ldr	r3, [fp, #-8]
100203d4:	e3530000 	cmp	r3, #0
100203d8:	1a000002 	bne	100203e8 <_realloc_r+0x40>
	{
		ptr->_errno = ENOMEM;
100203dc:	e51b3010 	ldr	r3, [fp, #-16]
100203e0:	e3a0200c 	mov	r2, #12
100203e4:	e5832000 	str	r2, [r3]
	}

	return result;
100203e8:	e51b3008 	ldr	r3, [fp, #-8]
}
100203ec:	e1a00003 	mov	r0, r3
100203f0:	e24bd004 	sub	sp, fp, #4
100203f4:	e8bd8800 	pop	{fp, pc}

100203f8 <_calloc_r>:

void *_calloc_r (struct _reent *ptr, size_t size, size_t len)
{
100203f8:	e92d4800 	push	{fp, lr}
100203fc:	e28db004 	add	fp, sp, #4
10020400:	e24dd018 	sub	sp, sp, #24
10020404:	e50b0010 	str	r0, [fp, #-16]
10020408:	e50b1014 	str	r1, [fp, #-20]
1002040c:	e50b2018 	str	r2, [fp, #-24]
	void* result;

	result = (void*)rt_calloc (size, len);
10020410:	e51b0014 	ldr	r0, [fp, #-20]
10020414:	e51b1018 	ldr	r1, [fp, #-24]
10020418:	ebffd18c 	bl	10014a50 <rt_calloc>
1002041c:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
10020420:	e51b3008 	ldr	r3, [fp, #-8]
10020424:	e3530000 	cmp	r3, #0
10020428:	1a000002 	bne	10020438 <_calloc_r+0x40>
	{
		ptr->_errno = ENOMEM;
1002042c:	e51b3010 	ldr	r3, [fp, #-16]
10020430:	e3a0200c 	mov	r2, #12
10020434:	e5832000 	str	r2, [r3]
	}

	return result;
10020438:	e51b3008 	ldr	r3, [fp, #-8]
}
1002043c:	e1a00003 	mov	r0, r3
10020440:	e24bd004 	sub	sp, fp, #4
10020444:	e8bd8800 	pop	{fp, pc}

10020448 <_free_r>:

void 
_free_r (struct _reent *ptr, void *addr)
{
10020448:	e92d4800 	push	{fp, lr}
1002044c:	e28db004 	add	fp, sp, #4
10020450:	e24dd008 	sub	sp, sp, #8
10020454:	e50b0008 	str	r0, [fp, #-8]
10020458:	e50b100c 	str	r1, [fp, #-12]
	rt_free (addr);
1002045c:	e51b000c 	ldr	r0, [fp, #-12]
10020460:	ebffd1a6 	bl	10014b00 <rt_free>
}
10020464:	e24bd004 	sub	sp, fp, #4
10020468:	e8bd8800 	pop	{fp, pc}

1002046c <_exit>:

void
_exit (int status)
{
1002046c:	e92d4800 	push	{fp, lr}
10020470:	e28db004 	add	fp, sp, #4
10020474:	e24dd008 	sub	sp, sp, #8
10020478:	e50b0008 	str	r0, [fp, #-8]
		/* re-schedule */
		rt_schedule();
	}
#endif
	
	rt_kprintf("thread:%s exit with %d\n", rt_thread_self()->name, status);
1002047c:	ebffd937 	bl	10016960 <rt_thread_self>
10020480:	e1a03000 	mov	r3, r0
10020484:	e3040d84 	movw	r0, #19844	; 0x4d84
10020488:	e3410003 	movt	r0, #4099	; 0x1003
1002048c:	e1a01003 	mov	r1, r3
10020490:	e51b2008 	ldr	r2, [fp, #-8]
10020494:	ebffcd89 	bl	10013ac0 <rt_kprintf>
	RT_ASSERT(0);
10020498:	e3040d9c 	movw	r0, #19868	; 0x4d9c
1002049c:	e3410003 	movt	r0, #4099	; 0x1003
100204a0:	e3041da0 	movw	r1, #19872	; 0x4da0
100204a4:	e3411003 	movt	r1, #4099	; 0x1003
100204a8:	e30021b2 	movw	r2, #434	; 0x1b2
100204ac:	ebffce40 	bl	10013db4 <rt_assert_handler>

	while (1);
100204b0:	eafffffe 	b	100204b0 <_exit+0x44>

100204b4 <_system>:
}

void 
_system(const char *s)
{
100204b4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100204b8:	e28db000 	add	fp, sp, #0
100204bc:	e24dd00c 	sub	sp, sp, #12
100204c0:	e50b0008 	str	r0, [fp, #-8]
    /* not support this call */
    return;
100204c4:	e1a00000 	nop			; (mov r0, r0)
}
100204c8:	e24bd000 	sub	sp, fp, #0
100204cc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100204d0:	e12fff1e 	bx	lr

100204d4 <__libc_init_array>:

void __libc_init_array(void)
{
100204d4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100204d8:	e28db000 	add	fp, sp, #0
	/* we not use __libc init_aray to initialize C++ objects */
}
100204dc:	e24bd000 	sub	sp, fp, #0
100204e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100204e4:	e12fff1e 	bx	lr

100204e8 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
100204e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100204ec:	e28db000 	add	fp, sp, #0
100204f0:	e24dd00c 	sub	sp, sp, #12
100204f4:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
100204f8:	e51b3008 	ldr	r3, [fp, #-8]
100204fc:	e51b2008 	ldr	r2, [fp, #-8]
10020500:	e5832004 	str	r2, [r3, #4]
10020504:	e51b3008 	ldr	r3, [fp, #-8]
10020508:	e5932004 	ldr	r2, [r3, #4]
1002050c:	e51b3008 	ldr	r3, [fp, #-8]
10020510:	e5832000 	str	r2, [r3]
}
10020514:	e24bd000 	sub	sp, fp, #0
10020518:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002051c:	e12fff1e 	bx	lr

10020520 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
10020520:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020524:	e28db000 	add	fp, sp, #0
10020528:	e24dd00c 	sub	sp, sp, #12
1002052c:	e50b0008 	str	r0, [fp, #-8]
10020530:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
10020534:	e51b3008 	ldr	r3, [fp, #-8]
10020538:	e5933004 	ldr	r3, [r3, #4]
1002053c:	e51b200c 	ldr	r2, [fp, #-12]
10020540:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
10020544:	e51b3008 	ldr	r3, [fp, #-8]
10020548:	e5932004 	ldr	r2, [r3, #4]
1002054c:	e51b300c 	ldr	r3, [fp, #-12]
10020550:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
10020554:	e51b3008 	ldr	r3, [fp, #-8]
10020558:	e51b200c 	ldr	r2, [fp, #-12]
1002055c:	e5832004 	str	r2, [r3, #4]
    n->next = l;
10020560:	e51b300c 	ldr	r3, [fp, #-12]
10020564:	e51b2008 	ldr	r2, [fp, #-8]
10020568:	e5832000 	str	r2, [r3]
}
1002056c:	e24bd000 	sub	sp, fp, #0
10020570:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020574:	e12fff1e 	bx	lr

10020578 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
10020578:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002057c:	e28db000 	add	fp, sp, #0
10020580:	e24dd00c 	sub	sp, sp, #12
10020584:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
10020588:	e51b3008 	ldr	r3, [fp, #-8]
1002058c:	e5932000 	ldr	r2, [r3]
10020590:	e51b3008 	ldr	r3, [fp, #-8]
10020594:	e1520003 	cmp	r2, r3
10020598:	03a03001 	moveq	r3, #1
1002059c:	13a03000 	movne	r3, #0
100205a0:	e6ef3073 	uxtb	r3, r3
}
100205a4:	e1a00003 	mov	r0, r3
100205a8:	e24bd000 	sub	sp, fp, #0
100205ac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100205b0:	e12fff1e 	bx	lr

100205b4 <rt_completion_init>:

#define RT_COMPLETED    1
#define RT_UNCOMPLETED  0

void rt_completion_init(struct rt_completion *completion)
{
100205b4:	e92d4800 	push	{fp, lr}
100205b8:	e28db004 	add	fp, sp, #4
100205bc:	e24dd010 	sub	sp, sp, #16
100205c0:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
100205c4:	e51b3010 	ldr	r3, [fp, #-16]
100205c8:	e3530000 	cmp	r3, #0
100205cc:	1a000005 	bne	100205e8 <rt_completion_init+0x34>
100205d0:	e3040da8 	movw	r0, #19880	; 0x4da8
100205d4:	e3410003 	movt	r0, #4099	; 0x1003
100205d8:	e3041e18 	movw	r1, #19992	; 0x4e18
100205dc:	e3411003 	movt	r1, #4099	; 0x1003
100205e0:	e3a02023 	mov	r2, #35	; 0x23
100205e4:	ebffcdf2 	bl	10013db4 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
100205e8:	ebffe410 	bl	10019630 <rt_hw_interrupt_disable>
100205ec:	e50b0008 	str	r0, [fp, #-8]
    completion->flag = RT_UNCOMPLETED;
100205f0:	e51b3010 	ldr	r3, [fp, #-16]
100205f4:	e3a02000 	mov	r2, #0
100205f8:	e5832000 	str	r2, [r3]
    rt_list_init(&completion->suspended_list);
100205fc:	e51b3010 	ldr	r3, [fp, #-16]
10020600:	e2833004 	add	r3, r3, #4
10020604:	e1a00003 	mov	r0, r3
10020608:	ebffffb6 	bl	100204e8 <rt_list_init>
    rt_hw_interrupt_enable(level);
1002060c:	e51b0008 	ldr	r0, [fp, #-8]
10020610:	ebffe40a 	bl	10019640 <rt_hw_interrupt_enable>
}
10020614:	e24bd004 	sub	sp, fp, #4
10020618:	e8bd8800 	pop	{fp, pc}

1002061c <rt_completion_wait>:
RTM_EXPORT(rt_completion_init);

rt_err_t rt_completion_wait(struct rt_completion *completion,
                            rt_int32_t            timeout)
{
1002061c:	e92d4800 	push	{fp, lr}
10020620:	e28db004 	add	fp, sp, #4
10020624:	e24dd018 	sub	sp, sp, #24
10020628:	e50b0018 	str	r0, [fp, #-24]
1002062c:	e50b101c 	str	r1, [fp, #-28]
    rt_err_t result;
    rt_base_t level;
    rt_thread_t thread;
    RT_ASSERT(completion != RT_NULL);
10020630:	e51b3018 	ldr	r3, [fp, #-24]
10020634:	e3530000 	cmp	r3, #0
10020638:	1a000005 	bne	10020654 <rt_completion_wait+0x38>
1002063c:	e3040da8 	movw	r0, #19880	; 0x4da8
10020640:	e3410003 	movt	r0, #4099	; 0x1003
10020644:	e3041e2c 	movw	r1, #20012	; 0x4e2c
10020648:	e3411003 	movt	r1, #4099	; 0x1003
1002064c:	e3a02032 	mov	r2, #50	; 0x32
10020650:	ebffcdd7 	bl	10013db4 <rt_assert_handler>

    result = RT_EOK;
10020654:	e3a03000 	mov	r3, #0
10020658:	e50b3008 	str	r3, [fp, #-8]
    thread = rt_thread_self();
1002065c:	ebffd8bf 	bl	10016960 <rt_thread_self>
10020660:	e50b0010 	str	r0, [fp, #-16]

    level = rt_hw_interrupt_disable();
10020664:	ebffe3f1 	bl	10019630 <rt_hw_interrupt_disable>
10020668:	e50b000c 	str	r0, [fp, #-12]
    if (completion->flag != RT_COMPLETED)
1002066c:	e51b3018 	ldr	r3, [fp, #-24]
10020670:	e5933000 	ldr	r3, [r3]
10020674:	e3530001 	cmp	r3, #1
10020678:	0a000047 	beq	1002079c <rt_completion_wait+0x180>
    {
        /* only one thread can suspend on complete */
        RT_ASSERT(rt_list_isempty(&(completion->suspended_list)));
1002067c:	e51b3018 	ldr	r3, [fp, #-24]
10020680:	e2833004 	add	r3, r3, #4
10020684:	e1a00003 	mov	r0, r3
10020688:	ebffffba 	bl	10020578 <rt_list_isempty>
1002068c:	e1a03000 	mov	r3, r0
10020690:	e3530000 	cmp	r3, #0
10020694:	1a000005 	bne	100206b0 <rt_completion_wait+0x94>
10020698:	e3040dc0 	movw	r0, #19904	; 0x4dc0
1002069c:	e3410003 	movt	r0, #4099	; 0x1003
100206a0:	e3041e2c 	movw	r1, #20012	; 0x4e2c
100206a4:	e3411003 	movt	r1, #4099	; 0x1003
100206a8:	e3a0203b 	mov	r2, #59	; 0x3b
100206ac:	ebffcdc0 	bl	10013db4 <rt_assert_handler>

        if (timeout == 0)
100206b0:	e51b301c 	ldr	r3, [fp, #-28]
100206b4:	e3530000 	cmp	r3, #0
100206b8:	1a000002 	bne	100206c8 <rt_completion_wait+0xac>
        {
            result = -RT_ETIMEOUT;
100206bc:	e3e03001 	mvn	r3, #1
100206c0:	e50b3008 	str	r3, [fp, #-8]
            goto __exit;
100206c4:	ea000037 	b	100207a8 <rt_completion_wait+0x18c>
        }
        else
        {
            /* reset thread error number */
            thread->error = RT_EOK;
100206c8:	e51b3010 	ldr	r3, [fp, #-16]
100206cc:	e3a02000 	mov	r2, #0
100206d0:	e583202c 	str	r2, [r3, #44]	; 0x2c

            /* suspend thread */
            rt_thread_suspend(thread);
100206d4:	e51b0010 	ldr	r0, [fp, #-16]
100206d8:	ebffda02 	bl	10016ee8 <rt_thread_suspend>
            /* add to suspended list */
            rt_list_insert_before(&(completion->suspended_list),
100206dc:	e51b3018 	ldr	r3, [fp, #-24]
100206e0:	e2832004 	add	r2, r3, #4
100206e4:	e51b3010 	ldr	r3, [fp, #-16]
100206e8:	e2833010 	add	r3, r3, #16
100206ec:	e1a00002 	mov	r0, r2
100206f0:	e1a01003 	mov	r1, r3
100206f4:	ebffff89 	bl	10020520 <rt_list_insert_before>
                                  &(thread->tlist));

            /* current context checking */
            RT_DEBUG_NOT_IN_INTERRUPT;
100206f8:	ebffe3cc 	bl	10019630 <rt_hw_interrupt_disable>
100206fc:	e50b0014 	str	r0, [fp, #-20]
10020700:	ebffc67e 	bl	10012100 <rt_interrupt_get_nest>
10020704:	e1a03000 	mov	r3, r0
10020708:	e3530000 	cmp	r3, #0
1002070c:	0a00000a 	beq	1002073c <rt_completion_wait+0x120>
10020710:	e3040df0 	movw	r0, #19952	; 0x4df0
10020714:	e3410003 	movt	r0, #4099	; 0x1003
10020718:	e3041e2c 	movw	r1, #20012	; 0x4e2c
1002071c:	e3411003 	movt	r1, #4099	; 0x1003
10020720:	ebffcce6 	bl	10013ac0 <rt_kprintf>
10020724:	e3040e14 	movw	r0, #19988	; 0x4e14
10020728:	e3410003 	movt	r0, #4099	; 0x1003
1002072c:	e3041e2c 	movw	r1, #20012	; 0x4e2c
10020730:	e3411003 	movt	r1, #4099	; 0x1003
10020734:	e3a0204e 	mov	r2, #78	; 0x4e
10020738:	ebffcd9d 	bl	10013db4 <rt_assert_handler>
1002073c:	e51b0014 	ldr	r0, [fp, #-20]
10020740:	ebffe3be 	bl	10019640 <rt_hw_interrupt_enable>

            /* start timer */
            if (timeout > 0)
10020744:	e51b301c 	ldr	r3, [fp, #-28]
10020748:	e3530000 	cmp	r3, #0
1002074c:	da00000a 	ble	1002077c <rt_completion_wait+0x160>
            {
                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
10020750:	e51b3010 	ldr	r3, [fp, #-16]
10020754:	e2832048 	add	r2, r3, #72	; 0x48
10020758:	e24b301c 	sub	r3, fp, #28
1002075c:	e1a00002 	mov	r0, r2
10020760:	e3a01000 	mov	r1, #0
10020764:	e1a02003 	mov	r2, r3
10020768:	ebffdc8d 	bl	100179a4 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &timeout);
                rt_timer_start(&(thread->thread_timer));
1002076c:	e51b3010 	ldr	r3, [fp, #-16]
10020770:	e2833048 	add	r3, r3, #72	; 0x48
10020774:	e1a00003 	mov	r0, r3
10020778:	ebffdb93 	bl	100175cc <rt_timer_start>
            }
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
1002077c:	e51b000c 	ldr	r0, [fp, #-12]
10020780:	ebffe3ae 	bl	10019640 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
10020784:	ebffd686 	bl	100161a4 <rt_schedule>

            /* thread is waked up */
            result = thread->error;
10020788:	e51b3010 	ldr	r3, [fp, #-16]
1002078c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10020790:	e50b3008 	str	r3, [fp, #-8]

            level = rt_hw_interrupt_disable();
10020794:	ebffe3a5 	bl	10019630 <rt_hw_interrupt_disable>
10020798:	e50b000c 	str	r0, [fp, #-12]
        }
    }
    /* clean completed flag */
    completion->flag = RT_UNCOMPLETED;
1002079c:	e51b3018 	ldr	r3, [fp, #-24]
100207a0:	e3a02000 	mov	r2, #0
100207a4:	e5832000 	str	r2, [r3]

__exit:
    rt_hw_interrupt_enable(level);
100207a8:	e51b000c 	ldr	r0, [fp, #-12]
100207ac:	ebffe3a3 	bl	10019640 <rt_hw_interrupt_enable>

    return result;
100207b0:	e51b3008 	ldr	r3, [fp, #-8]
}
100207b4:	e1a00003 	mov	r0, r3
100207b8:	e24bd004 	sub	sp, fp, #4
100207bc:	e8bd8800 	pop	{fp, pc}

100207c0 <rt_completion_done>:
RTM_EXPORT(rt_completion_wait);

void rt_completion_done(struct rt_completion *completion)
{
100207c0:	e92d4800 	push	{fp, lr}
100207c4:	e28db004 	add	fp, sp, #4
100207c8:	e24dd010 	sub	sp, sp, #16
100207cc:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
100207d0:	e51b3010 	ldr	r3, [fp, #-16]
100207d4:	e3530000 	cmp	r3, #0
100207d8:	1a000005 	bne	100207f4 <rt_completion_done+0x34>
100207dc:	e3040da8 	movw	r0, #19880	; 0x4da8
100207e0:	e3410003 	movt	r0, #4099	; 0x1003
100207e4:	e3041e40 	movw	r1, #20032	; 0x4e40
100207e8:	e3411003 	movt	r1, #4099	; 0x1003
100207ec:	e3a02072 	mov	r2, #114	; 0x72
100207f0:	ebffcd6f 	bl	10013db4 <rt_assert_handler>

    if (completion->flag == RT_COMPLETED)
100207f4:	e51b3010 	ldr	r3, [fp, #-16]
100207f8:	e5933000 	ldr	r3, [r3]
100207fc:	e3530001 	cmp	r3, #1
10020800:	1a000000 	bne	10020808 <rt_completion_done+0x48>
        return;
10020804:	ea000017 	b	10020868 <rt_completion_done+0xa8>

    level = rt_hw_interrupt_disable();
10020808:	ebffe388 	bl	10019630 <rt_hw_interrupt_disable>
1002080c:	e50b0008 	str	r0, [fp, #-8]
    completion->flag = RT_COMPLETED;
10020810:	e51b3010 	ldr	r3, [fp, #-16]
10020814:	e3a02001 	mov	r2, #1
10020818:	e5832000 	str	r2, [r3]

    if (!rt_list_isempty(&(completion->suspended_list)))
1002081c:	e51b3010 	ldr	r3, [fp, #-16]
10020820:	e2833004 	add	r3, r3, #4
10020824:	e1a00003 	mov	r0, r3
10020828:	ebffff52 	bl	10020578 <rt_list_isempty>
1002082c:	e1a03000 	mov	r3, r0
10020830:	e3530000 	cmp	r3, #0
10020834:	1a000009 	bne	10020860 <rt_completion_done+0xa0>
    {
        /* there is one thread in suspended list */
        struct rt_thread *thread;

        /* get thread entry */
        thread = rt_list_entry(completion->suspended_list.next,
10020838:	e51b3010 	ldr	r3, [fp, #-16]
1002083c:	e5933004 	ldr	r3, [r3, #4]
10020840:	e2433010 	sub	r3, r3, #16
10020844:	e50b300c 	str	r3, [fp, #-12]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
10020848:	e51b000c 	ldr	r0, [fp, #-12]
1002084c:	ebffd9c9 	bl	10016f78 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
10020850:	e51b0008 	ldr	r0, [fp, #-8]
10020854:	ebffe379 	bl	10019640 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
10020858:	ebffd651 	bl	100161a4 <rt_schedule>
1002085c:	ea000001 	b	10020868 <rt_completion_done+0xa8>
    }
    else
    {
        rt_hw_interrupt_enable(level);
10020860:	e51b0008 	ldr	r0, [fp, #-8]
10020864:	ebffe375 	bl	10019640 <rt_hw_interrupt_enable>
    }
}
10020868:	e24bd004 	sub	sp, fp, #4
1002086c:	e8bd8800 	pop	{fp, pc}

10020870 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
10020870:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020874:	e28db000 	add	fp, sp, #0
10020878:	e24dd00c 	sub	sp, sp, #12
1002087c:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
10020880:	e51b3008 	ldr	r3, [fp, #-8]
10020884:	e51b2008 	ldr	r2, [fp, #-8]
10020888:	e5832004 	str	r2, [r3, #4]
1002088c:	e51b3008 	ldr	r3, [fp, #-8]
10020890:	e5932004 	ldr	r2, [r3, #4]
10020894:	e51b3008 	ldr	r3, [fp, #-8]
10020898:	e5832000 	str	r2, [r3]
}
1002089c:	e24bd000 	sub	sp, fp, #0
100208a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100208a4:	e12fff1e 	bx	lr

100208a8 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
100208a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100208ac:	e28db000 	add	fp, sp, #0
100208b0:	e24dd00c 	sub	sp, sp, #12
100208b4:	e50b0008 	str	r0, [fp, #-8]
100208b8:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
100208bc:	e51b3008 	ldr	r3, [fp, #-8]
100208c0:	e5933004 	ldr	r3, [r3, #4]
100208c4:	e51b200c 	ldr	r2, [fp, #-12]
100208c8:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
100208cc:	e51b3008 	ldr	r3, [fp, #-8]
100208d0:	e5932004 	ldr	r2, [r3, #4]
100208d4:	e51b300c 	ldr	r3, [fp, #-12]
100208d8:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
100208dc:	e51b3008 	ldr	r3, [fp, #-8]
100208e0:	e51b200c 	ldr	r2, [fp, #-12]
100208e4:	e5832004 	str	r2, [r3, #4]
    n->next = l;
100208e8:	e51b300c 	ldr	r3, [fp, #-12]
100208ec:	e51b2008 	ldr	r2, [fp, #-8]
100208f0:	e5832000 	str	r2, [r3]
}
100208f4:	e24bd000 	sub	sp, fp, #0
100208f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100208fc:	e12fff1e 	bx	lr

10020900 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
10020900:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10020904:	e28db000 	add	fp, sp, #0
10020908:	e24dd00c 	sub	sp, sp, #12
1002090c:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
10020910:	e51b3008 	ldr	r3, [fp, #-8]
10020914:	e5932000 	ldr	r2, [r3]
10020918:	e51b3008 	ldr	r3, [fp, #-8]
1002091c:	e1520003 	cmp	r2, r3
10020920:	03a03001 	moveq	r3, #1
10020924:	13a03000 	movne	r3, #0
10020928:	e6ef3073 	uxtb	r3, r3
}
1002092c:	e1a00003 	mov	r0, r3
10020930:	e24bd000 	sub	sp, fp, #0
10020934:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10020938:	e12fff1e 	bx	lr

1002093c <rt_data_queue_init>:
rt_err_t
rt_data_queue_init(struct rt_data_queue *queue,
                   rt_uint16_t size,
                   rt_uint16_t lwm,
                   void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
{
1002093c:	e92d4800 	push	{fp, lr}
10020940:	e28db004 	add	fp, sp, #4
10020944:	e24dd010 	sub	sp, sp, #16
10020948:	e50b0008 	str	r0, [fp, #-8]
1002094c:	e50b3010 	str	r3, [fp, #-16]
10020950:	e14b10ba 	strh	r1, [fp, #-10]
10020954:	e14b20bc 	strh	r2, [fp, #-12]
    RT_ASSERT(queue != RT_NULL);
10020958:	e51b3008 	ldr	r3, [fp, #-8]
1002095c:	e3530000 	cmp	r3, #0
10020960:	1a000005 	bne	1002097c <rt_data_queue_init+0x40>
10020964:	e3040e54 	movw	r0, #20052	; 0x4e54
10020968:	e3410003 	movt	r0, #4099	; 0x1003
1002096c:	e3041eb4 	movw	r1, #20148	; 0x4eb4
10020970:	e3411003 	movt	r1, #4099	; 0x1003
10020974:	e3a02029 	mov	r2, #41	; 0x29
10020978:	ebffcd0d 	bl	10013db4 <rt_assert_handler>

    queue->evt_notify = evt_notify;
1002097c:	e51b3008 	ldr	r3, [fp, #-8]
10020980:	e51b2010 	ldr	r2, [fp, #-16]
10020984:	e5832020 	str	r2, [r3, #32]

    queue->size = size;
10020988:	e51b3008 	ldr	r3, [fp, #-8]
1002098c:	e15b20ba 	ldrh	r2, [fp, #-10]
10020990:	e1c320b0 	strh	r2, [r3]
    queue->lwm = lwm;
10020994:	e51b3008 	ldr	r3, [fp, #-8]
10020998:	e15b20bc 	ldrh	r2, [fp, #-12]
1002099c:	e1c320b2 	strh	r2, [r3, #2]
    queue->waiting_lwm = RT_FALSE;
100209a0:	e51b3008 	ldr	r3, [fp, #-8]
100209a4:	e3a02000 	mov	r2, #0
100209a8:	e5832004 	str	r2, [r3, #4]

    queue->get_index = 0;
100209ac:	e51b3008 	ldr	r3, [fp, #-8]
100209b0:	e3a02000 	mov	r2, #0
100209b4:	e1c320b8 	strh	r2, [r3, #8]
    queue->put_index = 0;
100209b8:	e51b3008 	ldr	r3, [fp, #-8]
100209bc:	e3a02000 	mov	r2, #0
100209c0:	e1c320ba 	strh	r2, [r3, #10]

    rt_list_init(&(queue->suspended_push_list));
100209c4:	e51b3008 	ldr	r3, [fp, #-8]
100209c8:	e2833010 	add	r3, r3, #16
100209cc:	e1a00003 	mov	r0, r3
100209d0:	ebffffa6 	bl	10020870 <rt_list_init>
    rt_list_init(&(queue->suspended_pop_list));
100209d4:	e51b3008 	ldr	r3, [fp, #-8]
100209d8:	e2833018 	add	r3, r3, #24
100209dc:	e1a00003 	mov	r0, r3
100209e0:	ebffffa2 	bl	10020870 <rt_list_init>

    queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
100209e4:	e15b30ba 	ldrh	r3, [fp, #-10]
100209e8:	e1a03183 	lsl	r3, r3, #3
100209ec:	e1a00003 	mov	r0, r3
100209f0:	ebffce27 	bl	10014294 <rt_malloc>
100209f4:	e1a02000 	mov	r2, r0
100209f8:	e51b3008 	ldr	r3, [fp, #-8]
100209fc:	e583200c 	str	r2, [r3, #12]
    if (queue->queue == RT_NULL)
10020a00:	e51b3008 	ldr	r3, [fp, #-8]
10020a04:	e593300c 	ldr	r3, [r3, #12]
10020a08:	e3530000 	cmp	r3, #0
10020a0c:	1a000001 	bne	10020a18 <rt_data_queue_init+0xdc>
    {
        return -RT_ENOMEM;
10020a10:	e3e03004 	mvn	r3, #4
10020a14:	ea000000 	b	10020a1c <rt_data_queue_init+0xe0>
    }

    return RT_EOK;
10020a18:	e3a03000 	mov	r3, #0
}
10020a1c:	e1a00003 	mov	r0, r3
10020a20:	e24bd004 	sub	sp, fp, #4
10020a24:	e8bd8800 	pop	{fp, pc}

10020a28 <rt_data_queue_push>:

rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
                            const void *data_ptr,
                            rt_size_t data_size,
                            rt_int32_t timeout)
{
10020a28:	e92d4800 	push	{fp, lr}
10020a2c:	e28db004 	add	fp, sp, #4
10020a30:	e24dd028 	sub	sp, sp, #40	; 0x28
10020a34:	e50b0020 	str	r0, [fp, #-32]
10020a38:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10020a3c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
10020a40:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    rt_uint16_t mask;
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    
    RT_ASSERT(queue != RT_NULL);
10020a44:	e51b3020 	ldr	r3, [fp, #-32]
10020a48:	e3530000 	cmp	r3, #0
10020a4c:	1a000005 	bne	10020a68 <rt_data_queue_push+0x40>
10020a50:	e3040e54 	movw	r0, #20052	; 0x4e54
10020a54:	e3410003 	movt	r0, #4099	; 0x1003
10020a58:	e3041ec8 	movw	r1, #20168	; 0x4ec8
10020a5c:	e3411003 	movt	r1, #4099	; 0x1003
10020a60:	e3a0204b 	mov	r2, #75	; 0x4b
10020a64:	ebffccd2 	bl	10013db4 <rt_assert_handler>

    result = RT_EOK;
10020a68:	e3a03000 	mov	r3, #0
10020a6c:	e50b300c 	str	r3, [fp, #-12]
    thread = rt_thread_self();
10020a70:	ebffd7ba 	bl	10016960 <rt_thread_self>
10020a74:	e50b0010 	str	r0, [fp, #-16]
    mask = queue->size - 1;
10020a78:	e51b3020 	ldr	r3, [fp, #-32]
10020a7c:	e1d330b0 	ldrh	r3, [r3]
10020a80:	e2433001 	sub	r3, r3, #1
10020a84:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee

    level = rt_hw_interrupt_disable();
10020a88:	ebffe2e8 	bl	10019630 <rt_hw_interrupt_disable>
10020a8c:	e1a03000 	mov	r3, r0
10020a90:	e50b3008 	str	r3, [fp, #-8]
    while (queue->put_index - queue->get_index == queue->size)
10020a94:	ea000043 	b	10020ba8 <rt_data_queue_push+0x180>
    {
        queue->waiting_lwm = RT_TRUE;
10020a98:	e51b3020 	ldr	r3, [fp, #-32]
10020a9c:	e3a02001 	mov	r2, #1
10020aa0:	e5832004 	str	r2, [r3, #4]

        /* queue is full */
        if (timeout == 0)
10020aa4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10020aa8:	e3530000 	cmp	r3, #0
10020aac:	1a000002 	bne	10020abc <rt_data_queue_push+0x94>
        {
            result = -RT_ETIMEOUT;
10020ab0:	e3e03001 	mvn	r3, #1
10020ab4:	e50b300c 	str	r3, [fp, #-12]

            goto __exit;
10020ab8:	ea000073 	b	10020c8c <rt_data_queue_push+0x264>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
10020abc:	ebffe2db 	bl	10019630 <rt_hw_interrupt_disable>
10020ac0:	e50b0018 	str	r0, [fp, #-24]
10020ac4:	ebffc58d 	bl	10012100 <rt_interrupt_get_nest>
10020ac8:	e1a03000 	mov	r3, r0
10020acc:	e3530000 	cmp	r3, #0
10020ad0:	0a00000a 	beq	10020b00 <rt_data_queue_push+0xd8>
10020ad4:	e3040e68 	movw	r0, #20072	; 0x4e68
10020ad8:	e3410003 	movt	r0, #4099	; 0x1003
10020adc:	e3041ec8 	movw	r1, #20168	; 0x4ec8
10020ae0:	e3411003 	movt	r1, #4099	; 0x1003
10020ae4:	ebffcbf5 	bl	10013ac0 <rt_kprintf>
10020ae8:	e3040e8c 	movw	r0, #20108	; 0x4e8c
10020aec:	e3410003 	movt	r0, #4099	; 0x1003
10020af0:	e3041ec8 	movw	r1, #20168	; 0x4ec8
10020af4:	e3411003 	movt	r1, #4099	; 0x1003
10020af8:	e3a0205f 	mov	r2, #95	; 0x5f
10020afc:	ebffccac 	bl	10013db4 <rt_assert_handler>
10020b00:	e51b0018 	ldr	r0, [fp, #-24]
10020b04:	ebffe2cd 	bl	10019640 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
10020b08:	e51b3010 	ldr	r3, [fp, #-16]
10020b0c:	e3a02000 	mov	r2, #0
10020b10:	e583202c 	str	r2, [r3, #44]	; 0x2c
        
        /* suspend thread on the push list */
        rt_thread_suspend(thread);
10020b14:	e51b0010 	ldr	r0, [fp, #-16]
10020b18:	ebffd8f2 	bl	10016ee8 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
10020b1c:	e51b3020 	ldr	r3, [fp, #-32]
10020b20:	e2832010 	add	r2, r3, #16
10020b24:	e51b3010 	ldr	r3, [fp, #-16]
10020b28:	e2833010 	add	r3, r3, #16
10020b2c:	e1a00002 	mov	r0, r2
10020b30:	e1a01003 	mov	r1, r3
10020b34:	ebffff5b 	bl	100208a8 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
10020b38:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10020b3c:	e3530000 	cmp	r3, #0
10020b40:	da00000a 	ble	10020b70 <rt_data_queue_push+0x148>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
10020b44:	e51b3010 	ldr	r3, [fp, #-16]
10020b48:	e2832048 	add	r2, r3, #72	; 0x48
10020b4c:	e24b302c 	sub	r3, fp, #44	; 0x2c
10020b50:	e1a00002 	mov	r0, r2
10020b54:	e3a01000 	mov	r1, #0
10020b58:	e1a02003 	mov	r2, r3
10020b5c:	ebffdb90 	bl	100179a4 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10020b60:	e51b3010 	ldr	r3, [fp, #-16]
10020b64:	e2833048 	add	r3, r3, #72	; 0x48
10020b68:	e1a00003 	mov	r0, r3
10020b6c:	ebffda96 	bl	100175cc <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10020b70:	e51b3008 	ldr	r3, [fp, #-8]
10020b74:	e1a00003 	mov	r0, r3
10020b78:	ebffe2b0 	bl	10019640 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
10020b7c:	ebffd588 	bl	100161a4 <rt_schedule>

        /* thread is waked up */
        result = thread->error;
10020b80:	e51b3010 	ldr	r3, [fp, #-16]
10020b84:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10020b88:	e50b300c 	str	r3, [fp, #-12]
        level = rt_hw_interrupt_disable();
10020b8c:	ebffe2a7 	bl	10019630 <rt_hw_interrupt_disable>
10020b90:	e1a03000 	mov	r3, r0
10020b94:	e50b3008 	str	r3, [fp, #-8]
        if (result != RT_EOK) goto __exit;
10020b98:	e51b300c 	ldr	r3, [fp, #-12]
10020b9c:	e3530000 	cmp	r3, #0
10020ba0:	0a000000 	beq	10020ba8 <rt_data_queue_push+0x180>
10020ba4:	ea000038 	b	10020c8c <rt_data_queue_push+0x264>
    result = RT_EOK;
    thread = rt_thread_self();
    mask = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->put_index - queue->get_index == queue->size)
10020ba8:	e51b3020 	ldr	r3, [fp, #-32]
10020bac:	e1d330ba 	ldrh	r3, [r3, #10]
10020bb0:	e1a02003 	mov	r2, r3
10020bb4:	e51b3020 	ldr	r3, [fp, #-32]
10020bb8:	e1d330b8 	ldrh	r3, [r3, #8]
10020bbc:	e0633002 	rsb	r3, r3, r2
10020bc0:	e51b2020 	ldr	r2, [fp, #-32]
10020bc4:	e1d220b0 	ldrh	r2, [r2]
10020bc8:	e1530002 	cmp	r3, r2
10020bcc:	0affffb1 	beq	10020a98 <rt_data_queue_push+0x70>
        result = thread->error;
        level = rt_hw_interrupt_disable();
        if (result != RT_EOK) goto __exit;
    }

    queue->queue[queue->put_index & mask].data_ptr  = data_ptr;
10020bd0:	e51b3020 	ldr	r3, [fp, #-32]
10020bd4:	e593200c 	ldr	r2, [r3, #12]
10020bd8:	e51b3020 	ldr	r3, [fp, #-32]
10020bdc:	e1d310ba 	ldrh	r1, [r3, #10]
10020be0:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
10020be4:	e0033001 	and	r3, r3, r1
10020be8:	e6ff3073 	uxth	r3, r3
10020bec:	e1a03183 	lsl	r3, r3, #3
10020bf0:	e0823003 	add	r3, r2, r3
10020bf4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10020bf8:	e5832000 	str	r2, [r3]
    queue->queue[queue->put_index & mask].data_size = data_size;
10020bfc:	e51b3020 	ldr	r3, [fp, #-32]
10020c00:	e593200c 	ldr	r2, [r3, #12]
10020c04:	e51b3020 	ldr	r3, [fp, #-32]
10020c08:	e1d310ba 	ldrh	r1, [r3, #10]
10020c0c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
10020c10:	e0033001 	and	r3, r3, r1
10020c14:	e6ff3073 	uxth	r3, r3
10020c18:	e1a03183 	lsl	r3, r3, #3
10020c1c:	e0823003 	add	r3, r2, r3
10020c20:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10020c24:	e5832004 	str	r2, [r3, #4]
    queue->put_index += 1;
10020c28:	e51b3020 	ldr	r3, [fp, #-32]
10020c2c:	e1d330ba 	ldrh	r3, [r3, #10]
10020c30:	e2833001 	add	r3, r3, #1
10020c34:	e6ff2073 	uxth	r2, r3
10020c38:	e51b3020 	ldr	r3, [fp, #-32]
10020c3c:	e1c320ba 	strh	r2, [r3, #10]

    if (!rt_list_isempty(&(queue->suspended_pop_list)))
10020c40:	e51b3020 	ldr	r3, [fp, #-32]
10020c44:	e2833018 	add	r3, r3, #24
10020c48:	e1a00003 	mov	r0, r3
10020c4c:	ebffff2b 	bl	10020900 <rt_list_isempty>
10020c50:	e1a03000 	mov	r3, r0
10020c54:	e3530000 	cmp	r3, #0
10020c58:	1a00000b 	bne	10020c8c <rt_data_queue_push+0x264>
    {
        /* there is at least one thread in suspended list */

        /* get thread entry */
        thread = rt_list_entry(queue->suspended_pop_list.next,
10020c5c:	e51b3020 	ldr	r3, [fp, #-32]
10020c60:	e5933018 	ldr	r3, [r3, #24]
10020c64:	e2433010 	sub	r3, r3, #16
10020c68:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
10020c6c:	e51b0010 	ldr	r0, [fp, #-16]
10020c70:	ebffd8c0 	bl	10016f78 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
10020c74:	e51b3008 	ldr	r3, [fp, #-8]
10020c78:	e1a00003 	mov	r0, r3
10020c7c:	ebffe26f 	bl	10019640 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
10020c80:	ebffd547 	bl	100161a4 <rt_schedule>

        return result;
10020c84:	e51b300c 	ldr	r3, [fp, #-12]
10020c88:	ea00000f 	b	10020ccc <rt_data_queue_push+0x2a4>
    }

__exit:
    rt_hw_interrupt_enable(level);
10020c8c:	e51b3008 	ldr	r3, [fp, #-8]
10020c90:	e1a00003 	mov	r0, r3
10020c94:	ebffe269 	bl	10019640 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
10020c98:	e51b300c 	ldr	r3, [fp, #-12]
10020c9c:	e3530000 	cmp	r3, #0
10020ca0:	1a000008 	bne	10020cc8 <rt_data_queue_push+0x2a0>
10020ca4:	e51b3020 	ldr	r3, [fp, #-32]
10020ca8:	e5933020 	ldr	r3, [r3, #32]
10020cac:	e3530000 	cmp	r3, #0
10020cb0:	0a000004 	beq	10020cc8 <rt_data_queue_push+0x2a0>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
10020cb4:	e51b3020 	ldr	r3, [fp, #-32]
10020cb8:	e5933020 	ldr	r3, [r3, #32]
10020cbc:	e51b0020 	ldr	r0, [fp, #-32]
10020cc0:	e3a01002 	mov	r1, #2
10020cc4:	e12fff33 	blx	r3
    }

    return result;
10020cc8:	e51b300c 	ldr	r3, [fp, #-12]
}
10020ccc:	e1a00003 	mov	r0, r3
10020cd0:	e24bd004 	sub	sp, fp, #4
10020cd4:	e8bd8800 	pop	{fp, pc}

10020cd8 <rt_data_queue_pop>:

rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
                           const void** data_ptr,
                           rt_size_t *size, 
                           rt_int32_t timeout)
{
10020cd8:	e92d4800 	push	{fp, lr}
10020cdc:	e28db004 	add	fp, sp, #4
10020ce0:	e24dd028 	sub	sp, sp, #40	; 0x28
10020ce4:	e50b0020 	str	r0, [fp, #-32]
10020ce8:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10020cec:	e50b2028 	str	r2, [fp, #-40]	; 0x28
10020cf0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
10020cf4:	e51b3020 	ldr	r3, [fp, #-32]
10020cf8:	e3530000 	cmp	r3, #0
10020cfc:	1a000005 	bne	10020d18 <rt_data_queue_pop+0x40>
10020d00:	e3040e54 	movw	r0, #20052	; 0x4e54
10020d04:	e3410003 	movt	r0, #4099	; 0x1003
10020d08:	e3041edc 	movw	r1, #20188	; 0x4edc
10020d0c:	e3411003 	movt	r1, #4099	; 0x1003
10020d10:	e3a020a9 	mov	r2, #169	; 0xa9
10020d14:	ebffcc26 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(data_ptr != RT_NULL);
10020d18:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10020d1c:	e3530000 	cmp	r3, #0
10020d20:	1a000005 	bne	10020d3c <rt_data_queue_pop+0x64>
10020d24:	e3040e90 	movw	r0, #20112	; 0x4e90
10020d28:	e3410003 	movt	r0, #4099	; 0x1003
10020d2c:	e3041edc 	movw	r1, #20188	; 0x4edc
10020d30:	e3411003 	movt	r1, #4099	; 0x1003
10020d34:	e3a020aa 	mov	r2, #170	; 0xaa
10020d38:	ebffcc1d 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(size != RT_NULL);
10020d3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10020d40:	e3530000 	cmp	r3, #0
10020d44:	1a000005 	bne	10020d60 <rt_data_queue_pop+0x88>
10020d48:	e3040ea4 	movw	r0, #20132	; 0x4ea4
10020d4c:	e3410003 	movt	r0, #4099	; 0x1003
10020d50:	e3041edc 	movw	r1, #20188	; 0x4edc
10020d54:	e3411003 	movt	r1, #4099	; 0x1003
10020d58:	e3a020ab 	mov	r2, #171	; 0xab
10020d5c:	ebffcc14 	bl	10013db4 <rt_assert_handler>

    result = RT_EOK;
10020d60:	e3a03000 	mov	r3, #0
10020d64:	e50b300c 	str	r3, [fp, #-12]
    thread = rt_thread_self();
10020d68:	ebffd6fc 	bl	10016960 <rt_thread_self>
10020d6c:	e50b0010 	str	r0, [fp, #-16]
    mask   = queue->size - 1;
10020d70:	e51b3020 	ldr	r3, [fp, #-32]
10020d74:	e1d330b0 	ldrh	r3, [r3]
10020d78:	e2433001 	sub	r3, r3, #1
10020d7c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee

    level = rt_hw_interrupt_disable();
10020d80:	ebffe22a 	bl	10019630 <rt_hw_interrupt_disable>
10020d84:	e1a03000 	mov	r3, r0
10020d88:	e50b3008 	str	r3, [fp, #-8]
    while (queue->get_index == queue->put_index)
10020d8c:	ea000040 	b	10020e94 <rt_data_queue_pop+0x1bc>
    {
        /* queue is empty */
        if (timeout == 0)
10020d90:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10020d94:	e3530000 	cmp	r3, #0
10020d98:	1a000002 	bne	10020da8 <rt_data_queue_pop+0xd0>
        {
            result = -RT_ETIMEOUT;
10020d9c:	e3e03001 	mvn	r3, #1
10020da0:	e50b300c 	str	r3, [fp, #-12]
            goto __exit;
10020da4:	ea00008b 	b	10020fd8 <rt_data_queue_pop+0x300>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
10020da8:	ebffe220 	bl	10019630 <rt_hw_interrupt_disable>
10020dac:	e50b0018 	str	r0, [fp, #-24]
10020db0:	ebffc4d2 	bl	10012100 <rt_interrupt_get_nest>
10020db4:	e1a03000 	mov	r3, r0
10020db8:	e3530000 	cmp	r3, #0
10020dbc:	0a00000a 	beq	10020dec <rt_data_queue_pop+0x114>
10020dc0:	e3040e68 	movw	r0, #20072	; 0x4e68
10020dc4:	e3410003 	movt	r0, #4099	; 0x1003
10020dc8:	e3041edc 	movw	r1, #20188	; 0x4edc
10020dcc:	e3411003 	movt	r1, #4099	; 0x1003
10020dd0:	ebffcb3a 	bl	10013ac0 <rt_kprintf>
10020dd4:	e3040e8c 	movw	r0, #20108	; 0x4e8c
10020dd8:	e3410003 	movt	r0, #4099	; 0x1003
10020ddc:	e3041edc 	movw	r1, #20188	; 0x4edc
10020de0:	e3411003 	movt	r1, #4099	; 0x1003
10020de4:	e3a020bc 	mov	r2, #188	; 0xbc
10020de8:	ebffcbf1 	bl	10013db4 <rt_assert_handler>
10020dec:	e51b0018 	ldr	r0, [fp, #-24]
10020df0:	ebffe212 	bl	10019640 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
10020df4:	e51b3010 	ldr	r3, [fp, #-16]
10020df8:	e3a02000 	mov	r2, #0
10020dfc:	e583202c 	str	r2, [r3, #44]	; 0x2c
        
        /* suspend thread on the pop list */
        rt_thread_suspend(thread);
10020e00:	e51b0010 	ldr	r0, [fp, #-16]
10020e04:	ebffd837 	bl	10016ee8 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
10020e08:	e51b3020 	ldr	r3, [fp, #-32]
10020e0c:	e2832018 	add	r2, r3, #24
10020e10:	e51b3010 	ldr	r3, [fp, #-16]
10020e14:	e2833010 	add	r3, r3, #16
10020e18:	e1a00002 	mov	r0, r2
10020e1c:	e1a01003 	mov	r1, r3
10020e20:	ebfffea0 	bl	100208a8 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
10020e24:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10020e28:	e3530000 	cmp	r3, #0
10020e2c:	da00000a 	ble	10020e5c <rt_data_queue_pop+0x184>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
10020e30:	e51b3010 	ldr	r3, [fp, #-16]
10020e34:	e2832048 	add	r2, r3, #72	; 0x48
10020e38:	e24b302c 	sub	r3, fp, #44	; 0x2c
10020e3c:	e1a00002 	mov	r0, r2
10020e40:	e3a01000 	mov	r1, #0
10020e44:	e1a02003 	mov	r2, r3
10020e48:	ebffdad5 	bl	100179a4 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10020e4c:	e51b3010 	ldr	r3, [fp, #-16]
10020e50:	e2833048 	add	r3, r3, #72	; 0x48
10020e54:	e1a00003 	mov	r0, r3
10020e58:	ebffd9db 	bl	100175cc <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10020e5c:	e51b3008 	ldr	r3, [fp, #-8]
10020e60:	e1a00003 	mov	r0, r3
10020e64:	ebffe1f5 	bl	10019640 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
10020e68:	ebffd4cd 	bl	100161a4 <rt_schedule>

        /* thread is waked up */
        result = thread->error;
10020e6c:	e51b3010 	ldr	r3, [fp, #-16]
10020e70:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10020e74:	e50b300c 	str	r3, [fp, #-12]
        level  = rt_hw_interrupt_disable();
10020e78:	ebffe1ec 	bl	10019630 <rt_hw_interrupt_disable>
10020e7c:	e1a03000 	mov	r3, r0
10020e80:	e50b3008 	str	r3, [fp, #-8]
        if (result != RT_EOK)
10020e84:	e51b300c 	ldr	r3, [fp, #-12]
10020e88:	e3530000 	cmp	r3, #0
10020e8c:	0a000000 	beq	10020e94 <rt_data_queue_pop+0x1bc>
            goto __exit;
10020e90:	ea000050 	b	10020fd8 <rt_data_queue_pop+0x300>
    result = RT_EOK;
    thread = rt_thread_self();
    mask   = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->get_index == queue->put_index)
10020e94:	e51b3020 	ldr	r3, [fp, #-32]
10020e98:	e1d320b8 	ldrh	r2, [r3, #8]
10020e9c:	e51b3020 	ldr	r3, [fp, #-32]
10020ea0:	e1d330ba 	ldrh	r3, [r3, #10]
10020ea4:	e1520003 	cmp	r2, r3
10020ea8:	0affffb8 	beq	10020d90 <rt_data_queue_pop+0xb8>
        level  = rt_hw_interrupt_disable();
        if (result != RT_EOK)
            goto __exit;
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
10020eac:	e51b3020 	ldr	r3, [fp, #-32]
10020eb0:	e593200c 	ldr	r2, [r3, #12]
10020eb4:	e51b3020 	ldr	r3, [fp, #-32]
10020eb8:	e1d310b8 	ldrh	r1, [r3, #8]
10020ebc:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
10020ec0:	e0033001 	and	r3, r3, r1
10020ec4:	e6ff3073 	uxth	r3, r3
10020ec8:	e1a03183 	lsl	r3, r3, #3
10020ecc:	e0823003 	add	r3, r2, r3
10020ed0:	e5932000 	ldr	r2, [r3]
10020ed4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10020ed8:	e5832000 	str	r2, [r3]
    *size     = queue->queue[queue->get_index & mask].data_size;
10020edc:	e51b3020 	ldr	r3, [fp, #-32]
10020ee0:	e593200c 	ldr	r2, [r3, #12]
10020ee4:	e51b3020 	ldr	r3, [fp, #-32]
10020ee8:	e1d310b8 	ldrh	r1, [r3, #8]
10020eec:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
10020ef0:	e0033001 	and	r3, r3, r1
10020ef4:	e6ff3073 	uxth	r3, r3
10020ef8:	e1a03183 	lsl	r3, r3, #3
10020efc:	e0823003 	add	r3, r2, r3
10020f00:	e5932004 	ldr	r2, [r3, #4]
10020f04:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10020f08:	e5832000 	str	r2, [r3]

    queue->get_index += 1;
10020f0c:	e51b3020 	ldr	r3, [fp, #-32]
10020f10:	e1d330b8 	ldrh	r3, [r3, #8]
10020f14:	e2833001 	add	r3, r3, #1
10020f18:	e6ff2073 	uxth	r2, r3
10020f1c:	e51b3020 	ldr	r3, [fp, #-32]
10020f20:	e1c320b8 	strh	r2, [r3, #8]

    if ((queue->waiting_lwm == RT_TRUE) && 
10020f24:	e51b3020 	ldr	r3, [fp, #-32]
10020f28:	e5933004 	ldr	r3, [r3, #4]
10020f2c:	e3530001 	cmp	r3, #1
10020f30:	1a000028 	bne	10020fd8 <rt_data_queue_pop+0x300>
        (queue->put_index - queue->get_index) <= queue->lwm)
10020f34:	e51b3020 	ldr	r3, [fp, #-32]
10020f38:	e1d330ba 	ldrh	r3, [r3, #10]
10020f3c:	e1a02003 	mov	r2, r3
10020f40:	e51b3020 	ldr	r3, [fp, #-32]
10020f44:	e1d330b8 	ldrh	r3, [r3, #8]
10020f48:	e0633002 	rsb	r3, r3, r2
10020f4c:	e51b2020 	ldr	r2, [fp, #-32]
10020f50:	e1d220b2 	ldrh	r2, [r2, #2]
    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
    *size     = queue->queue[queue->get_index & mask].data_size;

    queue->get_index += 1;

    if ((queue->waiting_lwm == RT_TRUE) && 
10020f54:	e1530002 	cmp	r3, r2
10020f58:	ca00001e 	bgt	10020fd8 <rt_data_queue_pop+0x300>
        (queue->put_index - queue->get_index) <= queue->lwm)
    {
        queue->waiting_lwm = RT_FALSE;
10020f5c:	e51b3020 	ldr	r3, [fp, #-32]
10020f60:	e3a02000 	mov	r2, #0
10020f64:	e5832004 	str	r2, [r3, #4]

        /*
         * there is at least one thread in suspended list
         * and less than low water mark
         */
        if (!rt_list_isempty(&(queue->suspended_push_list)))
10020f68:	e51b3020 	ldr	r3, [fp, #-32]
10020f6c:	e2833010 	add	r3, r3, #16
10020f70:	e1a00003 	mov	r0, r3
10020f74:	ebfffe61 	bl	10020900 <rt_list_isempty>
10020f78:	e1a03000 	mov	r3, r0
10020f7c:	e3530000 	cmp	r3, #0
10020f80:	1a000009 	bne	10020fac <rt_data_queue_pop+0x2d4>
        {
            /* get thread entry */
            thread = rt_list_entry(queue->suspended_push_list.next,
10020f84:	e51b3020 	ldr	r3, [fp, #-32]
10020f88:	e5933010 	ldr	r3, [r3, #16]
10020f8c:	e2433010 	sub	r3, r3, #16
10020f90:	e50b3010 	str	r3, [fp, #-16]
                                   struct rt_thread,
                                   tlist);

            /* resume it */
            rt_thread_resume(thread);
10020f94:	e51b0010 	ldr	r0, [fp, #-16]
10020f98:	ebffd7f6 	bl	10016f78 <rt_thread_resume>
            rt_hw_interrupt_enable(level);
10020f9c:	e51b3008 	ldr	r3, [fp, #-8]
10020fa0:	e1a00003 	mov	r0, r3
10020fa4:	ebffe1a5 	bl	10019640 <rt_hw_interrupt_enable>

            /* perform a schedule */
            rt_schedule();
10020fa8:	ebffd47d 	bl	100161a4 <rt_schedule>
        }

        if (queue->evt_notify != RT_NULL)
10020fac:	e51b3020 	ldr	r3, [fp, #-32]
10020fb0:	e5933020 	ldr	r3, [r3, #32]
10020fb4:	e3530000 	cmp	r3, #0
10020fb8:	0a000004 	beq	10020fd0 <rt_data_queue_pop+0x2f8>
            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
10020fbc:	e51b3020 	ldr	r3, [fp, #-32]
10020fc0:	e5933020 	ldr	r3, [r3, #32]
10020fc4:	e51b0020 	ldr	r0, [fp, #-32]
10020fc8:	e3a01003 	mov	r1, #3
10020fcc:	e12fff33 	blx	r3

        return result;
10020fd0:	e51b300c 	ldr	r3, [fp, #-12]
10020fd4:	ea00000f 	b	10021018 <rt_data_queue_pop+0x340>
    }

__exit:
    rt_hw_interrupt_enable(level);
10020fd8:	e51b3008 	ldr	r3, [fp, #-8]
10020fdc:	e1a00003 	mov	r0, r3
10020fe0:	ebffe196 	bl	10019640 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
10020fe4:	e51b300c 	ldr	r3, [fp, #-12]
10020fe8:	e3530000 	cmp	r3, #0
10020fec:	1a000008 	bne	10021014 <rt_data_queue_pop+0x33c>
10020ff0:	e51b3020 	ldr	r3, [fp, #-32]
10020ff4:	e5933020 	ldr	r3, [r3, #32]
10020ff8:	e3530000 	cmp	r3, #0
10020ffc:	0a000004 	beq	10021014 <rt_data_queue_pop+0x33c>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
10021000:	e51b3020 	ldr	r3, [fp, #-32]
10021004:	e5933020 	ldr	r3, [r3, #32]
10021008:	e51b0020 	ldr	r0, [fp, #-32]
1002100c:	e3a01001 	mov	r1, #1
10021010:	e12fff33 	blx	r3
    }

    return result;
10021014:	e51b300c 	ldr	r3, [fp, #-12]
}
10021018:	e1a00003 	mov	r0, r3
1002101c:	e24bd004 	sub	sp, fp, #4
10021020:	e8bd8800 	pop	{fp, pc}

10021024 <rt_data_queue_peak>:
RTM_EXPORT(rt_data_queue_pop);

rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
                            const void** data_ptr,
                            rt_size_t *size)
{
10021024:	e92d4800 	push	{fp, lr}
10021028:	e28db004 	add	fp, sp, #4
1002102c:	e24dd018 	sub	sp, sp, #24
10021030:	e50b0010 	str	r0, [fp, #-16]
10021034:	e50b1014 	str	r1, [fp, #-20]
10021038:	e50b2018 	str	r2, [fp, #-24]
    rt_ubase_t  level;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
1002103c:	e51b3010 	ldr	r3, [fp, #-16]
10021040:	e3530000 	cmp	r3, #0
10021044:	1a000005 	bne	10021060 <rt_data_queue_peak+0x3c>
10021048:	e3040e54 	movw	r0, #20052	; 0x4e54
1002104c:	e3410003 	movt	r0, #4099	; 0x1003
10021050:	e3041ef0 	movw	r1, #20208	; 0x4ef0
10021054:	e3411003 	movt	r1, #4099	; 0x1003
10021058:	e3a02e11 	mov	r2, #272	; 0x110
1002105c:	ebffcb54 	bl	10013db4 <rt_assert_handler>

    mask = queue->size - 1;
10021060:	e51b3010 	ldr	r3, [fp, #-16]
10021064:	e1d330b0 	ldrh	r3, [r3]
10021068:	e2433001 	sub	r3, r3, #1
1002106c:	e14b30b6 	strh	r3, [fp, #-6]

    level = rt_hw_interrupt_disable();
10021070:	ebffe16e 	bl	10019630 <rt_hw_interrupt_disable>
10021074:	e1a03000 	mov	r3, r0
10021078:	e50b300c 	str	r3, [fp, #-12]

    if (queue->get_index == queue->put_index) 
1002107c:	e51b3010 	ldr	r3, [fp, #-16]
10021080:	e1d320b8 	ldrh	r2, [r3, #8]
10021084:	e51b3010 	ldr	r3, [fp, #-16]
10021088:	e1d330ba 	ldrh	r3, [r3, #10]
1002108c:	e1520003 	cmp	r2, r3
10021090:	1a000004 	bne	100210a8 <rt_data_queue_peak+0x84>
    {
        rt_hw_interrupt_enable(level);
10021094:	e51b300c 	ldr	r3, [fp, #-12]
10021098:	e1a00003 	mov	r0, r3
1002109c:	ebffe167 	bl	10019640 <rt_hw_interrupt_enable>
        
        return -RT_EEMPTY;
100210a0:	e3e03003 	mvn	r3, #3
100210a4:	ea00001b 	b	10021118 <rt_data_queue_peak+0xf4>
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
100210a8:	e51b3010 	ldr	r3, [fp, #-16]
100210ac:	e593200c 	ldr	r2, [r3, #12]
100210b0:	e51b3010 	ldr	r3, [fp, #-16]
100210b4:	e1d310b8 	ldrh	r1, [r3, #8]
100210b8:	e15b30b6 	ldrh	r3, [fp, #-6]
100210bc:	e0033001 	and	r3, r3, r1
100210c0:	e6ff3073 	uxth	r3, r3
100210c4:	e1a03183 	lsl	r3, r3, #3
100210c8:	e0823003 	add	r3, r2, r3
100210cc:	e5932000 	ldr	r2, [r3]
100210d0:	e51b3014 	ldr	r3, [fp, #-20]
100210d4:	e5832000 	str	r2, [r3]
    *size     = queue->queue[queue->get_index & mask].data_size;
100210d8:	e51b3010 	ldr	r3, [fp, #-16]
100210dc:	e593200c 	ldr	r2, [r3, #12]
100210e0:	e51b3010 	ldr	r3, [fp, #-16]
100210e4:	e1d310b8 	ldrh	r1, [r3, #8]
100210e8:	e15b30b6 	ldrh	r3, [fp, #-6]
100210ec:	e0033001 	and	r3, r3, r1
100210f0:	e6ff3073 	uxth	r3, r3
100210f4:	e1a03183 	lsl	r3, r3, #3
100210f8:	e0823003 	add	r3, r2, r3
100210fc:	e5932004 	ldr	r2, [r3, #4]
10021100:	e51b3018 	ldr	r3, [fp, #-24]
10021104:	e5832000 	str	r2, [r3]

    rt_hw_interrupt_enable(level);
10021108:	e51b300c 	ldr	r3, [fp, #-12]
1002110c:	e1a00003 	mov	r0, r3
10021110:	ebffe14a 	bl	10019640 <rt_hw_interrupt_enable>

    return RT_EOK;
10021114:	e3a03000 	mov	r3, #0
}
10021118:	e1a00003 	mov	r0, r3
1002111c:	e24bd004 	sub	sp, fp, #4
10021120:	e8bd8800 	pop	{fp, pc}

10021124 <rt_data_queue_reset>:
RTM_EXPORT(rt_data_queue_peak);

void rt_data_queue_reset(struct rt_data_queue *queue)
{
10021124:	e92d4810 	push	{r4, fp, lr}
10021128:	e28db008 	add	fp, sp, #8
1002112c:	e24dd014 	sub	sp, sp, #20
10021130:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    rt_enter_critical();
10021134:	ebffd4c1 	bl	10016440 <rt_enter_critical>
    /* wakeup all suspend threads */

    /* resume on pop list */
    while (!rt_list_isempty(&(queue->suspended_pop_list)))
10021138:	ea00000e 	b	10021178 <rt_data_queue_reset+0x54>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
1002113c:	ebffe13b 	bl	10019630 <rt_hw_interrupt_disable>
10021140:	e1a03000 	mov	r3, r0
10021144:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(queue->suspended_pop_list.next,
10021148:	e51b3018 	ldr	r3, [fp, #-24]
1002114c:	e5933018 	ldr	r3, [r3, #24]
10021150:	e2433010 	sub	r3, r3, #16
10021154:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
10021158:	e51b3010 	ldr	r3, [fp, #-16]
1002115c:	e3e02000 	mvn	r2, #0
10021160:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
10021164:	e51b0010 	ldr	r0, [fp, #-16]
10021168:	ebffd782 	bl	10016f78 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
1002116c:	e1a03004 	mov	r3, r4
10021170:	e1a00003 	mov	r0, r3
10021174:	ebffe131 	bl	10019640 <rt_hw_interrupt_enable>

    rt_enter_critical();
    /* wakeup all suspend threads */

    /* resume on pop list */
    while (!rt_list_isempty(&(queue->suspended_pop_list)))
10021178:	e51b3018 	ldr	r3, [fp, #-24]
1002117c:	e2833018 	add	r3, r3, #24
10021180:	e1a00003 	mov	r0, r3
10021184:	ebfffddd 	bl	10020900 <rt_list_isempty>
10021188:	e1a03000 	mov	r3, r0
1002118c:	e3530000 	cmp	r3, #0
10021190:	0affffe9 	beq	1002113c <rt_data_queue_reset+0x18>
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    /* resume on push list */
    while (!rt_list_isempty(&(queue->suspended_push_list)))
10021194:	ea00000e 	b	100211d4 <rt_data_queue_reset+0xb0>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
10021198:	ebffe124 	bl	10019630 <rt_hw_interrupt_disable>
1002119c:	e1a03000 	mov	r3, r0
100211a0:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(queue->suspended_push_list.next,
100211a4:	e51b3018 	ldr	r3, [fp, #-24]
100211a8:	e5933010 	ldr	r3, [r3, #16]
100211ac:	e2433010 	sub	r3, r3, #16
100211b0:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
100211b4:	e51b3010 	ldr	r3, [fp, #-16]
100211b8:	e3e02000 	mvn	r2, #0
100211bc:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
100211c0:	e51b0010 	ldr	r0, [fp, #-16]
100211c4:	ebffd76b 	bl	10016f78 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
100211c8:	e1a03004 	mov	r3, r4
100211cc:	e1a00003 	mov	r0, r3
100211d0:	ebffe11a 	bl	10019640 <rt_hw_interrupt_enable>
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    /* resume on push list */
    while (!rt_list_isempty(&(queue->suspended_push_list)))
100211d4:	e51b3018 	ldr	r3, [fp, #-24]
100211d8:	e2833010 	add	r3, r3, #16
100211dc:	e1a00003 	mov	r0, r3
100211e0:	ebfffdc6 	bl	10020900 <rt_list_isempty>
100211e4:	e1a03000 	mov	r3, r0
100211e8:	e3530000 	cmp	r3, #0
100211ec:	0affffe9 	beq	10021198 <rt_data_queue_reset+0x74>
        rt_thread_resume(thread);

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }
    rt_exit_critical();
100211f0:	ebffd4a4 	bl	10016488 <rt_exit_critical>

    rt_schedule();
100211f4:	ebffd3ea 	bl	100161a4 <rt_schedule>
}
100211f8:	e24bd008 	sub	sp, fp, #8
100211fc:	e8bd8810 	pop	{r4, fp, pc}

10021200 <_serial_poll_rx>:

/*
 * Serial poll routines 
 */
rt_inline int _serial_poll_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
10021200:	e92d4800 	push	{fp, lr}
10021204:	e28db004 	add	fp, sp, #4
10021208:	e24dd018 	sub	sp, sp, #24
1002120c:	e50b0010 	str	r0, [fp, #-16]
10021210:	e50b1014 	str	r1, [fp, #-20]
10021214:	e50b2018 	str	r2, [fp, #-24]
    int ch;
    int size;
    
    RT_ASSERT(serial != RT_NULL);
10021218:	e51b3010 	ldr	r3, [fp, #-16]
1002121c:	e3530000 	cmp	r3, #0
10021220:	1a000005 	bne	1002123c <_serial_poll_rx+0x3c>
10021224:	e3040f04 	movw	r0, #20228	; 0x4f04
10021228:	e3410003 	movt	r0, #4099	; 0x1003
1002122c:	e3051050 	movw	r1, #20560	; 0x5050
10021230:	e3411003 	movt	r1, #4099	; 0x1003
10021234:	e3a0202e 	mov	r2, #46	; 0x2e
10021238:	ebffcadd 	bl	10013db4 <rt_assert_handler>
    size = length;
1002123c:	e51b3018 	ldr	r3, [fp, #-24]
10021240:	e50b3008 	str	r3, [fp, #-8]

    while (length)
10021244:	ea000013 	b	10021298 <_serial_poll_rx+0x98>
    {
        ch = serial->ops->getc(serial);
10021248:	e51b3010 	ldr	r3, [fp, #-16]
1002124c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021250:	e593300c 	ldr	r3, [r3, #12]
10021254:	e51b0010 	ldr	r0, [fp, #-16]
10021258:	e12fff33 	blx	r3
1002125c:	e50b000c 	str	r0, [fp, #-12]
        *data = ch; 
10021260:	e51b300c 	ldr	r3, [fp, #-12]
10021264:	e6ef2073 	uxtb	r2, r3
10021268:	e51b3014 	ldr	r3, [fp, #-20]
1002126c:	e5c32000 	strb	r2, [r3]
        data ++; length --;
10021270:	e51b3014 	ldr	r3, [fp, #-20]
10021274:	e2833001 	add	r3, r3, #1
10021278:	e50b3014 	str	r3, [fp, #-20]
1002127c:	e51b3018 	ldr	r3, [fp, #-24]
10021280:	e2433001 	sub	r3, r3, #1
10021284:	e50b3018 	str	r3, [fp, #-24]

        if (ch == '\n') break;
10021288:	e51b300c 	ldr	r3, [fp, #-12]
1002128c:	e353000a 	cmp	r3, #10
10021290:	1a000000 	bne	10021298 <_serial_poll_rx+0x98>
10021294:	ea000002 	b	100212a4 <_serial_poll_rx+0xa4>
    int size;
    
    RT_ASSERT(serial != RT_NULL);
    size = length;

    while (length)
10021298:	e51b3018 	ldr	r3, [fp, #-24]
1002129c:	e3530000 	cmp	r3, #0
100212a0:	1affffe8 	bne	10021248 <_serial_poll_rx+0x48>
        data ++; length --;

        if (ch == '\n') break;
    }

    return size - length;
100212a4:	e51b2008 	ldr	r2, [fp, #-8]
100212a8:	e51b3018 	ldr	r3, [fp, #-24]
100212ac:	e0633002 	rsb	r3, r3, r2
}
100212b0:	e1a00003 	mov	r0, r3
100212b4:	e24bd004 	sub	sp, fp, #4
100212b8:	e8bd8800 	pop	{fp, pc}

100212bc <_serial_poll_tx>:

rt_inline int _serial_poll_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
100212bc:	e92d4800 	push	{fp, lr}
100212c0:	e28db004 	add	fp, sp, #4
100212c4:	e24dd018 	sub	sp, sp, #24
100212c8:	e50b0010 	str	r0, [fp, #-16]
100212cc:	e50b1014 	str	r1, [fp, #-20]
100212d0:	e50b2018 	str	r2, [fp, #-24]
    int size;
    RT_ASSERT(serial != RT_NULL);
100212d4:	e51b3010 	ldr	r3, [fp, #-16]
100212d8:	e3530000 	cmp	r3, #0
100212dc:	1a000005 	bne	100212f8 <_serial_poll_tx+0x3c>
100212e0:	e3040f04 	movw	r0, #20228	; 0x4f04
100212e4:	e3410003 	movt	r0, #4099	; 0x1003
100212e8:	e3051080 	movw	r1, #20608	; 0x5080
100212ec:	e3411003 	movt	r1, #4099	; 0x1003
100212f0:	e3a02040 	mov	r2, #64	; 0x40
100212f4:	ebffcaae 	bl	10013db4 <rt_assert_handler>

    size = length;
100212f8:	e51b3018 	ldr	r3, [fp, #-24]
100212fc:	e50b3008 	str	r3, [fp, #-8]
    while (length)
10021300:	ea00001c 	b	10021378 <_serial_poll_tx+0xbc>
    {
        /*
         * to be polite with serial console add a line feed
         * to the carriage return character
         */
        if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
10021304:	e51b3014 	ldr	r3, [fp, #-20]
10021308:	e5d33000 	ldrb	r3, [r3]
1002130c:	e353000a 	cmp	r3, #10
10021310:	1a00000a 	bne	10021340 <_serial_poll_tx+0x84>
10021314:	e51b3010 	ldr	r3, [fp, #-16]
10021318:	e1d331b4 	ldrh	r3, [r3, #20]
1002131c:	e2033040 	and	r3, r3, #64	; 0x40
10021320:	e3530000 	cmp	r3, #0
10021324:	0a000005 	beq	10021340 <_serial_poll_tx+0x84>
        {
            serial->ops->putc(serial, '\r');
10021328:	e51b3010 	ldr	r3, [fp, #-16]
1002132c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021330:	e5933008 	ldr	r3, [r3, #8]
10021334:	e51b0010 	ldr	r0, [fp, #-16]
10021338:	e3a0100d 	mov	r1, #13
1002133c:	e12fff33 	blx	r3
        }
    
        serial->ops->putc(serial, *data);
10021340:	e51b3010 	ldr	r3, [fp, #-16]
10021344:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021348:	e5933008 	ldr	r3, [r3, #8]
1002134c:	e51b2014 	ldr	r2, [fp, #-20]
10021350:	e5d22000 	ldrb	r2, [r2]
10021354:	e51b0010 	ldr	r0, [fp, #-16]
10021358:	e1a01002 	mov	r1, r2
1002135c:	e12fff33 	blx	r3
    
        ++ data;
10021360:	e51b3014 	ldr	r3, [fp, #-20]
10021364:	e2833001 	add	r3, r3, #1
10021368:	e50b3014 	str	r3, [fp, #-20]
        -- length;
1002136c:	e51b3018 	ldr	r3, [fp, #-24]
10021370:	e2433001 	sub	r3, r3, #1
10021374:	e50b3018 	str	r3, [fp, #-24]
{
    int size;
    RT_ASSERT(serial != RT_NULL);

    size = length;
    while (length)
10021378:	e51b3018 	ldr	r3, [fp, #-24]
1002137c:	e3530000 	cmp	r3, #0
10021380:	1affffdf 	bne	10021304 <_serial_poll_tx+0x48>
    
        ++ data;
        -- length;
    }

    return size - length;
10021384:	e51b2008 	ldr	r2, [fp, #-8]
10021388:	e51b3018 	ldr	r3, [fp, #-24]
1002138c:	e0633002 	rsb	r3, r3, r2
}
10021390:	e1a00003 	mov	r0, r3
10021394:	e24bd004 	sub	sp, fp, #4
10021398:	e8bd8800 	pop	{fp, pc}

1002139c <_serial_int_rx>:

/*
 * Serial interrupt routines
 */
rt_inline int _serial_int_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
1002139c:	e92d4800 	push	{fp, lr}
100213a0:	e28db004 	add	fp, sp, #4
100213a4:	e24dd020 	sub	sp, sp, #32
100213a8:	e50b0018 	str	r0, [fp, #-24]
100213ac:	e50b101c 	str	r1, [fp, #-28]
100213b0:	e50b2020 	str	r2, [fp, #-32]
    int size;
    struct rt_serial_rx_fifo* rx_fifo;

    RT_ASSERT(serial != RT_NULL);
100213b4:	e51b3018 	ldr	r3, [fp, #-24]
100213b8:	e3530000 	cmp	r3, #0
100213bc:	1a000005 	bne	100213d8 <_serial_int_rx+0x3c>
100213c0:	e3040f04 	movw	r0, #20228	; 0x4f04
100213c4:	e3410003 	movt	r0, #4099	; 0x1003
100213c8:	e3051030 	movw	r1, #20528	; 0x5030
100213cc:	e3411003 	movt	r1, #4099	; 0x1003
100213d0:	e3a0205f 	mov	r2, #95	; 0x5f
100213d4:	ebffca76 	bl	10013db4 <rt_assert_handler>
    size = length; 
100213d8:	e51b3020 	ldr	r3, [fp, #-32]
100213dc:	e50b3008 	str	r3, [fp, #-8]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
100213e0:	e51b3018 	ldr	r3, [fp, #-24]
100213e4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
100213e8:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(rx_fifo != RT_NULL);
100213ec:	e51b300c 	ldr	r3, [fp, #-12]
100213f0:	e3530000 	cmp	r3, #0
100213f4:	1a000005 	bne	10021410 <_serial_int_rx+0x74>
100213f8:	e3040f18 	movw	r0, #20248	; 0x4f18
100213fc:	e3410003 	movt	r0, #4099	; 0x1003
10021400:	e3051030 	movw	r1, #20528	; 0x5030
10021404:	e3411003 	movt	r1, #4099	; 0x1003
10021408:	e3a02063 	mov	r2, #99	; 0x63
1002140c:	ebffca68 	bl	10013db4 <rt_assert_handler>

    /* read from software FIFO */
    while (length)
10021410:	ea00002f 	b	100214d4 <_serial_int_rx+0x138>
    {
        int ch;
        rt_base_t level;

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
10021414:	ebffe085 	bl	10019630 <rt_hw_interrupt_disable>
10021418:	e50b0010 	str	r0, [fp, #-16]
        if (rx_fifo->get_index != rx_fifo->put_index)
1002141c:	e51b300c 	ldr	r3, [fp, #-12]
10021420:	e1d320b6 	ldrh	r2, [r3, #6]
10021424:	e51b300c 	ldr	r3, [fp, #-12]
10021428:	e1d330b4 	ldrh	r3, [r3, #4]
1002142c:	e1520003 	cmp	r2, r3
10021430:	0a000018 	beq	10021498 <_serial_int_rx+0xfc>
        {
            ch = rx_fifo->buffer[rx_fifo->get_index];
10021434:	e51b300c 	ldr	r3, [fp, #-12]
10021438:	e5933000 	ldr	r3, [r3]
1002143c:	e51b200c 	ldr	r2, [fp, #-12]
10021440:	e1d220b6 	ldrh	r2, [r2, #6]
10021444:	e0833002 	add	r3, r3, r2
10021448:	e5d33000 	ldrb	r3, [r3]
1002144c:	e50b3014 	str	r3, [fp, #-20]
            rx_fifo->get_index += 1;
10021450:	e51b300c 	ldr	r3, [fp, #-12]
10021454:	e1d330b6 	ldrh	r3, [r3, #6]
10021458:	e2833001 	add	r3, r3, #1
1002145c:	e6ff2073 	uxth	r2, r3
10021460:	e51b300c 	ldr	r3, [fp, #-12]
10021464:	e1c320b6 	strh	r2, [r3, #6]
            if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
10021468:	e51b300c 	ldr	r3, [fp, #-12]
1002146c:	e1d320b6 	ldrh	r2, [r3, #6]
10021470:	e51b3018 	ldr	r3, [fp, #-24]
10021474:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10021478:	e7ef3553 	ubfx	r3, r3, #10, #16
1002147c:	e6ff3073 	uxth	r3, r3
10021480:	e1520003 	cmp	r2, r3
10021484:	3a000006 	bcc	100214a4 <_serial_int_rx+0x108>
10021488:	e51b300c 	ldr	r3, [fp, #-12]
1002148c:	e3a02000 	mov	r2, #0
10021490:	e1c320b6 	strh	r2, [r3, #6]
10021494:	ea000002 	b	100214a4 <_serial_int_rx+0x108>
        }
        else
        {
            /* no data, enable interrupt and break out */
            rt_hw_interrupt_enable(level);
10021498:	e51b0010 	ldr	r0, [fp, #-16]
1002149c:	ebffe067 	bl	10019640 <rt_hw_interrupt_enable>
            break;
100214a0:	ea00000e 	b	100214e0 <_serial_int_rx+0x144>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
100214a4:	e51b0010 	ldr	r0, [fp, #-16]
100214a8:	ebffe064 	bl	10019640 <rt_hw_interrupt_enable>

        *data = ch & 0xff;
100214ac:	e51b3014 	ldr	r3, [fp, #-20]
100214b0:	e6ef2073 	uxtb	r2, r3
100214b4:	e51b301c 	ldr	r3, [fp, #-28]
100214b8:	e5c32000 	strb	r2, [r3]
        data ++; length --;
100214bc:	e51b301c 	ldr	r3, [fp, #-28]
100214c0:	e2833001 	add	r3, r3, #1
100214c4:	e50b301c 	str	r3, [fp, #-28]
100214c8:	e51b3020 	ldr	r3, [fp, #-32]
100214cc:	e2433001 	sub	r3, r3, #1
100214d0:	e50b3020 	str	r3, [fp, #-32]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (length)
100214d4:	e51b3020 	ldr	r3, [fp, #-32]
100214d8:	e3530000 	cmp	r3, #0
100214dc:	1affffcc 	bne	10021414 <_serial_int_rx+0x78>

        *data = ch & 0xff;
        data ++; length --;
    }

    return size - length;
100214e0:	e51b2008 	ldr	r2, [fp, #-8]
100214e4:	e51b3020 	ldr	r3, [fp, #-32]
100214e8:	e0633002 	rsb	r3, r3, r2
}
100214ec:	e1a00003 	mov	r0, r3
100214f0:	e24bd004 	sub	sp, fp, #4
100214f4:	e8bd8800 	pop	{fp, pc}

100214f8 <_serial_int_tx>:

rt_inline int _serial_int_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
100214f8:	e92d4800 	push	{fp, lr}
100214fc:	e28db004 	add	fp, sp, #4
10021500:	e24dd018 	sub	sp, sp, #24
10021504:	e50b0010 	str	r0, [fp, #-16]
10021508:	e50b1014 	str	r1, [fp, #-20]
1002150c:	e50b2018 	str	r2, [fp, #-24]
    int size;
    struct rt_serial_tx_fifo *tx;
    
    RT_ASSERT(serial != RT_NULL);
10021510:	e51b3010 	ldr	r3, [fp, #-16]
10021514:	e3530000 	cmp	r3, #0
10021518:	1a000005 	bne	10021534 <_serial_int_tx+0x3c>
1002151c:	e3040f04 	movw	r0, #20228	; 0x4f04
10021520:	e3410003 	movt	r0, #4099	; 0x1003
10021524:	e3051070 	movw	r1, #20592	; 0x5070
10021528:	e3411003 	movt	r1, #4099	; 0x1003
1002152c:	e3a02089 	mov	r2, #137	; 0x89
10021530:	ebffca1f 	bl	10013db4 <rt_assert_handler>

    size = length;
10021534:	e51b3018 	ldr	r3, [fp, #-24]
10021538:	e50b3008 	str	r3, [fp, #-8]
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
1002153c:	e51b3010 	ldr	r3, [fp, #-16]
10021540:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
10021544:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(tx != RT_NULL);
10021548:	e51b300c 	ldr	r3, [fp, #-12]
1002154c:	e3530000 	cmp	r3, #0
10021550:	1a000005 	bne	1002156c <_serial_int_tx+0x74>
10021554:	e3040f2c 	movw	r0, #20268	; 0x4f2c
10021558:	e3410003 	movt	r0, #4099	; 0x1003
1002155c:	e3051070 	movw	r1, #20592	; 0x5070
10021560:	e3411003 	movt	r1, #4099	; 0x1003
10021564:	e3a0208d 	mov	r2, #141	; 0x8d
10021568:	ebffca11 	bl	10013db4 <rt_assert_handler>

    while (length)
1002156c:	ea000015 	b	100215c8 <_serial_int_tx+0xd0>
    {
        if (serial->ops->putc(serial, *(char*)data) == -1)
10021570:	e51b3010 	ldr	r3, [fp, #-16]
10021574:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021578:	e5933008 	ldr	r3, [r3, #8]
1002157c:	e51b2014 	ldr	r2, [fp, #-20]
10021580:	e5d22000 	ldrb	r2, [r2]
10021584:	e51b0010 	ldr	r0, [fp, #-16]
10021588:	e1a01002 	mov	r1, r2
1002158c:	e12fff33 	blx	r3
10021590:	e1a03000 	mov	r3, r0
10021594:	e3730001 	cmn	r3, #1
10021598:	1a000004 	bne	100215b0 <_serial_int_tx+0xb8>
        {
            rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
1002159c:	e51b300c 	ldr	r3, [fp, #-12]
100215a0:	e1a00003 	mov	r0, r3
100215a4:	e3e01000 	mvn	r1, #0
100215a8:	ebfffc1b 	bl	1002061c <rt_completion_wait>
            continue;
100215ac:	ea000005 	b	100215c8 <_serial_int_tx+0xd0>
        }

        data ++; length --;
100215b0:	e51b3014 	ldr	r3, [fp, #-20]
100215b4:	e2833001 	add	r3, r3, #1
100215b8:	e50b3014 	str	r3, [fp, #-20]
100215bc:	e51b3018 	ldr	r3, [fp, #-24]
100215c0:	e2433001 	sub	r3, r3, #1
100215c4:	e50b3018 	str	r3, [fp, #-24]

    size = length;
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
    RT_ASSERT(tx != RT_NULL);

    while (length)
100215c8:	e51b3018 	ldr	r3, [fp, #-24]
100215cc:	e3530000 	cmp	r3, #0
100215d0:	1affffe6 	bne	10021570 <_serial_int_tx+0x78>
        }

        data ++; length --;
    }

    return size - length;
100215d4:	e51b2008 	ldr	r2, [fp, #-8]
100215d8:	e51b3018 	ldr	r3, [fp, #-24]
100215dc:	e0633002 	rsb	r3, r3, r2
}
100215e0:	e1a00003 	mov	r0, r3
100215e4:	e24bd004 	sub	sp, fp, #4
100215e8:	e8bd8800 	pop	{fp, pc}

100215ec <_serial_dma_rx>:

/*
 * Serial DMA routines
 */
rt_inline int _serial_dma_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
100215ec:	e92d4800 	push	{fp, lr}
100215f0:	e28db004 	add	fp, sp, #4
100215f4:	e24dd020 	sub	sp, sp, #32
100215f8:	e50b0018 	str	r0, [fp, #-24]
100215fc:	e50b101c 	str	r1, [fp, #-28]
10021600:	e50b2020 	str	r2, [fp, #-32]
    rt_base_t level;
    int result = RT_EOK;
10021604:	e3a03000 	mov	r3, #0
10021608:	e50b3008 	str	r3, [fp, #-8]
    struct rt_serial_rx_dma *rx_dma;

    RT_ASSERT((serial != RT_NULL) && (data != RT_NULL));
1002160c:	e51b3018 	ldr	r3, [fp, #-24]
10021610:	e3530000 	cmp	r3, #0
10021614:	0a000002 	beq	10021624 <_serial_dma_rx+0x38>
10021618:	e51b301c 	ldr	r3, [fp, #-28]
1002161c:	e3530000 	cmp	r3, #0
10021620:	1a000005 	bne	1002163c <_serial_dma_rx+0x50>
10021624:	e3040f3c 	movw	r0, #20284	; 0x4f3c
10021628:	e3410003 	movt	r0, #4099	; 0x1003
1002162c:	e3051040 	movw	r1, #20544	; 0x5040
10021630:	e3411003 	movt	r1, #4099	; 0x1003
10021634:	e3a020a6 	mov	r2, #166	; 0xa6
10021638:	ebffc9dd 	bl	10013db4 <rt_assert_handler>
    rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
1002163c:	e51b3018 	ldr	r3, [fp, #-24]
10021640:	e5933048 	ldr	r3, [r3, #72]	; 0x48
10021644:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(rx_dma != RT_NULL);
10021648:	e51b300c 	ldr	r3, [fp, #-12]
1002164c:	e3530000 	cmp	r3, #0
10021650:	1a000005 	bne	1002166c <_serial_dma_rx+0x80>
10021654:	e3040f68 	movw	r0, #20328	; 0x4f68
10021658:	e3410003 	movt	r0, #4099	; 0x1003
1002165c:	e3051040 	movw	r1, #20544	; 0x5040
10021660:	e3411003 	movt	r1, #4099	; 0x1003
10021664:	e3a020a8 	mov	r2, #168	; 0xa8
10021668:	ebffc9d1 	bl	10013db4 <rt_assert_handler>
    level = rt_hw_interrupt_disable();
1002166c:	ebffdfef 	bl	10019630 <rt_hw_interrupt_disable>
10021670:	e50b0010 	str	r0, [fp, #-16]
    //if (rx_dma->activated != RT_TRUE)
    //{
        //rx_dma->activated = RT_TRUE;
        serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_RX);
10021674:	e51b3018 	ldr	r3, [fp, #-24]
10021678:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1002167c:	e593c010 	ldr	ip, [r3, #16]
10021680:	e51b3020 	ldr	r3, [fp, #-32]
10021684:	e51b0018 	ldr	r0, [fp, #-24]
10021688:	e51b101c 	ldr	r1, [fp, #-28]
1002168c:	e1a02003 	mov	r2, r3
10021690:	e3a03001 	mov	r3, #1
10021694:	e12fff3c 	blx	ip
    //}
    //else result = -RT_EBUSY;
    rt_hw_interrupt_enable(level);
10021698:	e51b0010 	ldr	r0, [fp, #-16]
1002169c:	ebffdfe7 	bl	10019640 <rt_hw_interrupt_enable>

    if (result == RT_EOK) return length;
100216a0:	e51b3008 	ldr	r3, [fp, #-8]
100216a4:	e3530000 	cmp	r3, #0
100216a8:	1a000001 	bne	100216b4 <_serial_dma_rx+0xc8>
100216ac:	e51b3020 	ldr	r3, [fp, #-32]
100216b0:	ea000002 	b	100216c0 <_serial_dma_rx+0xd4>

    rt_set_errno(result);
100216b4:	e51b0008 	ldr	r0, [fp, #-8]
100216b8:	ebffc2b3 	bl	1001218c <rt_set_errno>
    return 0;
100216bc:	e3a03000 	mov	r3, #0
}
100216c0:	e1a00003 	mov	r0, r3
100216c4:	e24bd004 	sub	sp, fp, #4
100216c8:	e8bd8800 	pop	{fp, pc}

100216cc <_serial_dma_tx>:

rt_inline int _serial_dma_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
100216cc:	e92d4800 	push	{fp, lr}
100216d0:	e28db004 	add	fp, sp, #4
100216d4:	e24dd020 	sub	sp, sp, #32
100216d8:	e50b0018 	str	r0, [fp, #-24]
100216dc:	e50b101c 	str	r1, [fp, #-28]
100216e0:	e50b2020 	str	r2, [fp, #-32]
    rt_base_t level;
    rt_err_t result;
    struct rt_serial_tx_dma *tx_dma;

    tx_dma = (struct rt_serial_tx_dma*)(serial->serial_tx);
100216e4:	e51b3018 	ldr	r3, [fp, #-24]
100216e8:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
100216ec:	e50b3008 	str	r3, [fp, #-8]
    
    result = rt_data_queue_push(&(tx_dma->data_queue), data, length, RT_WAITING_FOREVER); 
100216f0:	e51b3008 	ldr	r3, [fp, #-8]
100216f4:	e2832004 	add	r2, r3, #4
100216f8:	e51b3020 	ldr	r3, [fp, #-32]
100216fc:	e1a00002 	mov	r0, r2
10021700:	e51b101c 	ldr	r1, [fp, #-28]
10021704:	e1a02003 	mov	r2, r3
10021708:	e3e03000 	mvn	r3, #0
1002170c:	ebfffcc5 	bl	10020a28 <rt_data_queue_push>
10021710:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
10021714:	e51b300c 	ldr	r3, [fp, #-12]
10021718:	e3530000 	cmp	r3, #0
1002171c:	1a000018 	bne	10021784 <_serial_dma_tx+0xb8>
    {
        level = rt_hw_interrupt_disable();
10021720:	ebffdfc2 	bl	10019630 <rt_hw_interrupt_disable>
10021724:	e50b0010 	str	r0, [fp, #-16]
        if (tx_dma->activated != RT_TRUE)
10021728:	e51b3008 	ldr	r3, [fp, #-8]
1002172c:	e5933000 	ldr	r3, [r3]
10021730:	e3530001 	cmp	r3, #1
10021734:	0a00000e 	beq	10021774 <_serial_dma_tx+0xa8>
        {
            tx_dma->activated = RT_TRUE;
10021738:	e51b3008 	ldr	r3, [fp, #-8]
1002173c:	e3a02001 	mov	r2, #1
10021740:	e5832000 	str	r2, [r3]
            rt_hw_interrupt_enable(level);
10021744:	e51b0010 	ldr	r0, [fp, #-16]
10021748:	ebffdfbc 	bl	10019640 <rt_hw_interrupt_enable>

            /* make a DMA transfer */
            serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_TX);
1002174c:	e51b3018 	ldr	r3, [fp, #-24]
10021750:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021754:	e593c010 	ldr	ip, [r3, #16]
10021758:	e51b3020 	ldr	r3, [fp, #-32]
1002175c:	e51b0018 	ldr	r0, [fp, #-24]
10021760:	e51b101c 	ldr	r1, [fp, #-28]
10021764:	e1a02003 	mov	r2, r3
10021768:	e3a03002 	mov	r3, #2
1002176c:	e12fff3c 	blx	ip
10021770:	ea000001 	b	1002177c <_serial_dma_tx+0xb0>
        }
        else
        {
            rt_hw_interrupt_enable(level);
10021774:	e51b0010 	ldr	r0, [fp, #-16]
10021778:	ebffdfb0 	bl	10019640 <rt_hw_interrupt_enable>
        }

        return length;
1002177c:	e51b3020 	ldr	r3, [fp, #-32]
10021780:	ea000002 	b	10021790 <_serial_dma_tx+0xc4>
    }
    else
    {
        rt_set_errno(result);
10021784:	e51b000c 	ldr	r0, [fp, #-12]
10021788:	ebffc27f 	bl	1001218c <rt_set_errno>
        return 0;
1002178c:	e3a03000 	mov	r3, #0
    }
}
10021790:	e1a00003 	mov	r0, r3
10021794:	e24bd004 	sub	sp, fp, #4
10021798:	e8bd8800 	pop	{fp, pc}

1002179c <rt_serial_init>:
/* RT-Thread Device Interface */
/*
 * This function initializes serial device.
 */
static rt_err_t rt_serial_init(struct rt_device *dev)
{
1002179c:	e92d4800 	push	{fp, lr}
100217a0:	e28db004 	add	fp, sp, #4
100217a4:	e24dd010 	sub	sp, sp, #16
100217a8:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
100217ac:	e3a03000 	mov	r3, #0
100217b0:	e50b3008 	str	r3, [fp, #-8]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
100217b4:	e51b3010 	ldr	r3, [fp, #-16]
100217b8:	e3530000 	cmp	r3, #0
100217bc:	1a000005 	bne	100217d8 <rt_serial_init+0x3c>
100217c0:	e3040f7c 	movw	r0, #20348	; 0x4f7c
100217c4:	e3410003 	movt	r0, #4099	; 0x1003
100217c8:	e3041ff0 	movw	r1, #20464	; 0x4ff0
100217cc:	e3411003 	movt	r1, #4099	; 0x1003
100217d0:	e3a020e3 	mov	r2, #227	; 0xe3
100217d4:	ebffc976 	bl	10013db4 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
100217d8:	e51b3010 	ldr	r3, [fp, #-16]
100217dc:	e50b300c 	str	r3, [fp, #-12]

    /* initialize rx/tx */
    serial->serial_rx = RT_NULL;
100217e0:	e51b300c 	ldr	r3, [fp, #-12]
100217e4:	e3a02000 	mov	r2, #0
100217e8:	e5832048 	str	r2, [r3, #72]	; 0x48
    serial->serial_tx = RT_NULL;
100217ec:	e51b300c 	ldr	r3, [fp, #-12]
100217f0:	e3a02000 	mov	r2, #0
100217f4:	e583204c 	str	r2, [r3, #76]	; 0x4c

    /* apply configuration */
    if (serial->ops->configure)
100217f8:	e51b300c 	ldr	r3, [fp, #-12]
100217fc:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021800:	e5933000 	ldr	r3, [r3]
10021804:	e3530000 	cmp	r3, #0
10021808:	0a000008 	beq	10021830 <rt_serial_init+0x94>
        result = serial->ops->configure(serial, &serial->config);
1002180c:	e51b300c 	ldr	r3, [fp, #-12]
10021810:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021814:	e5933000 	ldr	r3, [r3]
10021818:	e51b200c 	ldr	r2, [fp, #-12]
1002181c:	e2822040 	add	r2, r2, #64	; 0x40
10021820:	e51b000c 	ldr	r0, [fp, #-12]
10021824:	e1a01002 	mov	r1, r2
10021828:	e12fff33 	blx	r3
1002182c:	e50b0008 	str	r0, [fp, #-8]
	rt_kprintf("%x\r\n", result);
10021830:	e3040f8c 	movw	r0, #20364	; 0x4f8c
10021834:	e3410003 	movt	r0, #4099	; 0x1003
10021838:	e51b1008 	ldr	r1, [fp, #-8]
1002183c:	ebffc89f 	bl	10013ac0 <rt_kprintf>
    return result;
10021840:	e51b3008 	ldr	r3, [fp, #-8]
}
10021844:	e1a00003 	mov	r0, r3
10021848:	e24bd004 	sub	sp, fp, #4
1002184c:	e8bd8800 	pop	{fp, pc}

10021850 <rt_serial_open>:

static rt_err_t rt_serial_open(struct rt_device *dev, rt_uint16_t oflag)
{
10021850:	e92d4800 	push	{fp, lr}
10021854:	e28db004 	add	fp, sp, #4
10021858:	e24dd020 	sub	sp, sp, #32
1002185c:	e50b0020 	str	r0, [fp, #-32]
10021860:	e1a03001 	mov	r3, r1
10021864:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
10021868:	e51b3020 	ldr	r3, [fp, #-32]
1002186c:	e3530000 	cmp	r3, #0
10021870:	1a000005 	bne	1002188c <rt_serial_open+0x3c>
10021874:	e3040f7c 	movw	r0, #20348	; 0x4f7c
10021878:	e3410003 	movt	r0, #4099	; 0x1003
1002187c:	e3051000 	movw	r1, #20480	; 0x5000
10021880:	e3411003 	movt	r1, #4099	; 0x1003
10021884:	e3a020f5 	mov	r2, #245	; 0xf5
10021888:	ebffc949 	bl	10013db4 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
1002188c:	e51b3020 	ldr	r3, [fp, #-32]
10021890:	e50b3008 	str	r3, [fp, #-8]

    /* check device flag with the open flag */
    if ((oflag & RT_DEVICE_FLAG_DMA_RX) && !(dev->flag & RT_DEVICE_FLAG_DMA_RX)) 
10021894:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
10021898:	e2033c02 	and	r3, r3, #512	; 0x200
1002189c:	e3530000 	cmp	r3, #0
100218a0:	0a000006 	beq	100218c0 <rt_serial_open+0x70>
100218a4:	e51b3020 	ldr	r3, [fp, #-32]
100218a8:	e1d331b2 	ldrh	r3, [r3, #18]
100218ac:	e2033c02 	and	r3, r3, #512	; 0x200
100218b0:	e3530000 	cmp	r3, #0
100218b4:	1a000001 	bne	100218c0 <rt_serial_open+0x70>
        return -RT_EIO;
100218b8:	e3e03007 	mvn	r3, #7
100218bc:	ea0000da 	b	10021c2c <rt_serial_open+0x3dc>
    if ((oflag & RT_DEVICE_FLAG_DMA_TX) && !(dev->flag & RT_DEVICE_FLAG_DMA_TX))
100218c0:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
100218c4:	e2033b02 	and	r3, r3, #2048	; 0x800
100218c8:	e3530000 	cmp	r3, #0
100218cc:	0a000006 	beq	100218ec <rt_serial_open+0x9c>
100218d0:	e51b3020 	ldr	r3, [fp, #-32]
100218d4:	e1d331b2 	ldrh	r3, [r3, #18]
100218d8:	e2033b02 	and	r3, r3, #2048	; 0x800
100218dc:	e3530000 	cmp	r3, #0
100218e0:	1a000001 	bne	100218ec <rt_serial_open+0x9c>
        return -RT_EIO;
100218e4:	e3e03007 	mvn	r3, #7
100218e8:	ea0000cf 	b	10021c2c <rt_serial_open+0x3dc>
    if ((oflag & RT_DEVICE_FLAG_INT_RX) && !(dev->flag & RT_DEVICE_FLAG_INT_RX))
100218ec:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
100218f0:	e2033c01 	and	r3, r3, #256	; 0x100
100218f4:	e3530000 	cmp	r3, #0
100218f8:	0a000006 	beq	10021918 <rt_serial_open+0xc8>
100218fc:	e51b3020 	ldr	r3, [fp, #-32]
10021900:	e1d331b2 	ldrh	r3, [r3, #18]
10021904:	e2033c01 	and	r3, r3, #256	; 0x100
10021908:	e3530000 	cmp	r3, #0
1002190c:	1a000001 	bne	10021918 <rt_serial_open+0xc8>
        return -RT_EIO;
10021910:	e3e03007 	mvn	r3, #7
10021914:	ea0000c4 	b	10021c2c <rt_serial_open+0x3dc>
    if ((oflag & RT_DEVICE_FLAG_INT_TX) && !(dev->flag & RT_DEVICE_FLAG_INT_TX))
10021918:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1002191c:	e2033b01 	and	r3, r3, #1024	; 0x400
10021920:	e3530000 	cmp	r3, #0
10021924:	0a000006 	beq	10021944 <rt_serial_open+0xf4>
10021928:	e51b3020 	ldr	r3, [fp, #-32]
1002192c:	e1d331b2 	ldrh	r3, [r3, #18]
10021930:	e2033b01 	and	r3, r3, #1024	; 0x400
10021934:	e3530000 	cmp	r3, #0
10021938:	1a000001 	bne	10021944 <rt_serial_open+0xf4>
        return -RT_EIO;
1002193c:	e3e03007 	mvn	r3, #7
10021940:	ea0000b9 	b	10021c2c <rt_serial_open+0x3dc>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
10021944:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
10021948:	e6ef3073 	uxtb	r3, r3
1002194c:	e6ff2073 	uxth	r2, r3
10021950:	e51b3020 	ldr	r3, [fp, #-32]
10021954:	e1c321b4 	strh	r2, [r3, #20]
    
    /* initialize the Rx/Tx structure according to open flag */
    if (serial->serial_rx == RT_NULL)
10021958:	e51b3008 	ldr	r3, [fp, #-8]
1002195c:	e5933048 	ldr	r3, [r3, #72]	; 0x48
10021960:	e3530000 	cmp	r3, #0
10021964:	1a000060 	bne	10021aec <rt_serial_open+0x29c>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_RX)
10021968:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1002196c:	e2033c02 	and	r3, r3, #512	; 0x200
10021970:	e3530000 	cmp	r3, #0
10021974:	0a00001f 	beq	100219f8 <rt_serial_open+0x1a8>
        {
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*) rt_malloc (sizeof(struct rt_serial_rx_dma));
10021978:	e3a00004 	mov	r0, #4
1002197c:	ebffca44 	bl	10014294 <rt_malloc>
10021980:	e50b000c 	str	r0, [fp, #-12]
            RT_ASSERT(rx_dma != RT_NULL);
10021984:	e51b300c 	ldr	r3, [fp, #-12]
10021988:	e3530000 	cmp	r3, #0
1002198c:	1a000005 	bne	100219a8 <rt_serial_open+0x158>
10021990:	e3040f68 	movw	r0, #20328	; 0x4f68
10021994:	e3410003 	movt	r0, #4099	; 0x1003
10021998:	e3051000 	movw	r1, #20480	; 0x5000
1002199c:	e3411003 	movt	r1, #4099	; 0x1003
100219a0:	e300210d 	movw	r2, #269	; 0x10d
100219a4:	ebffc902 	bl	10013db4 <rt_assert_handler>
            rx_dma->activated = RT_FALSE;
100219a8:	e51b300c 	ldr	r3, [fp, #-12]
100219ac:	e3a02000 	mov	r2, #0
100219b0:	e5832000 	str	r2, [r3]

            serial->serial_rx = rx_dma;
100219b4:	e51b3008 	ldr	r3, [fp, #-8]
100219b8:	e51b200c 	ldr	r2, [fp, #-12]
100219bc:	e5832048 	str	r2, [r3, #72]	; 0x48
            dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
100219c0:	e51b3020 	ldr	r3, [fp, #-32]
100219c4:	e1d331b4 	ldrh	r3, [r3, #20]
100219c8:	e3833c02 	orr	r3, r3, #512	; 0x200
100219cc:	e6ff2073 	uxth	r2, r3
100219d0:	e51b3020 	ldr	r3, [fp, #-32]
100219d4:	e1c321b4 	strh	r2, [r3, #20]
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_DMARX, (void *)RT_DEVICE_FLAG_DMA_RX);
100219d8:	e51b3008 	ldr	r3, [fp, #-8]
100219dc:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
100219e0:	e5933004 	ldr	r3, [r3, #4]
100219e4:	e51b0008 	ldr	r0, [fp, #-8]
100219e8:	e3a01014 	mov	r1, #20
100219ec:	e3a02c02 	mov	r2, #512	; 0x200
100219f0:	e12fff33 	blx	r3
100219f4:	ea00003c 	b	10021aec <rt_serial_open+0x29c>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
100219f8:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
100219fc:	e2033c01 	and	r3, r3, #256	; 0x100
10021a00:	e3530000 	cmp	r3, #0
10021a04:	0a000035 	beq	10021ae0 <rt_serial_open+0x290>
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
                serial->config.bufsz);
10021a08:	e51b3008 	ldr	r3, [fp, #-8]
10021a0c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10021a10:	e7ef3553 	ubfx	r3, r3, #10, #16
10021a14:	e6ff3073 	uxth	r3, r3
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
10021a18:	e2833008 	add	r3, r3, #8
10021a1c:	e1a00003 	mov	r0, r3
10021a20:	ebffca1b 	bl	10014294 <rt_malloc>
10021a24:	e50b0010 	str	r0, [fp, #-16]
                serial->config.bufsz);
            RT_ASSERT(rx_fifo != RT_NULL);
10021a28:	e51b3010 	ldr	r3, [fp, #-16]
10021a2c:	e3530000 	cmp	r3, #0
10021a30:	1a000005 	bne	10021a4c <rt_serial_open+0x1fc>
10021a34:	e3040f18 	movw	r0, #20248	; 0x4f18
10021a38:	e3410003 	movt	r0, #4099	; 0x1003
10021a3c:	e3051000 	movw	r1, #20480	; 0x5000
10021a40:	e3411003 	movt	r1, #4099	; 0x1003
10021a44:	e300211a 	movw	r2, #282	; 0x11a
10021a48:	ebffc8d9 	bl	10013db4 <rt_assert_handler>
            rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
10021a4c:	e51b3010 	ldr	r3, [fp, #-16]
10021a50:	e2832008 	add	r2, r3, #8
10021a54:	e51b3010 	ldr	r3, [fp, #-16]
10021a58:	e5832000 	str	r2, [r3]
            rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
10021a5c:	e51b3010 	ldr	r3, [fp, #-16]
10021a60:	e5932000 	ldr	r2, [r3]
10021a64:	e51b3008 	ldr	r3, [fp, #-8]
10021a68:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10021a6c:	e7ef3553 	ubfx	r3, r3, #10, #16
10021a70:	e6ff3073 	uxth	r3, r3
10021a74:	e1a00002 	mov	r0, r2
10021a78:	e3a01000 	mov	r1, #0
10021a7c:	e1a02003 	mov	r2, r3
10021a80:	ebffc1f4 	bl	10012258 <rt_memset>
            rx_fifo->put_index = 0;
10021a84:	e51b3010 	ldr	r3, [fp, #-16]
10021a88:	e3a02000 	mov	r2, #0
10021a8c:	e1c320b4 	strh	r2, [r3, #4]
            rx_fifo->get_index = 0;
10021a90:	e51b3010 	ldr	r3, [fp, #-16]
10021a94:	e3a02000 	mov	r2, #0
10021a98:	e1c320b6 	strh	r2, [r3, #6]

            serial->serial_rx = rx_fifo;
10021a9c:	e51b3008 	ldr	r3, [fp, #-8]
10021aa0:	e51b2010 	ldr	r2, [fp, #-16]
10021aa4:	e5832048 	str	r2, [r3, #72]	; 0x48
            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
10021aa8:	e51b3020 	ldr	r3, [fp, #-32]
10021aac:	e1d331b4 	ldrh	r3, [r3, #20]
10021ab0:	e3833c01 	orr	r3, r3, #256	; 0x100
10021ab4:	e6ff2073 	uxth	r2, r3
10021ab8:	e51b3020 	ldr	r3, [fp, #-32]
10021abc:	e1c321b4 	strh	r2, [r3, #20]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
10021ac0:	e51b3008 	ldr	r3, [fp, #-8]
10021ac4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021ac8:	e5933004 	ldr	r3, [r3, #4]
10021acc:	e51b0008 	ldr	r0, [fp, #-8]
10021ad0:	e3a01010 	mov	r1, #16
10021ad4:	e3a02c01 	mov	r2, #256	; 0x100
10021ad8:	e12fff33 	blx	r3
10021adc:	ea000002 	b	10021aec <rt_serial_open+0x29c>
        }
        else
        {
            serial->serial_rx = RT_NULL;
10021ae0:	e51b3008 	ldr	r3, [fp, #-8]
10021ae4:	e3a02000 	mov	r2, #0
10021ae8:	e5832048 	str	r2, [r3, #72]	; 0x48
        }
    }

    if (serial->serial_tx == RT_NULL)
10021aec:	e51b3008 	ldr	r3, [fp, #-8]
10021af0:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
10021af4:	e3530000 	cmp	r3, #0
10021af8:	1a00004a 	bne	10021c28 <rt_serial_open+0x3d8>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_TX)
10021afc:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
10021b00:	e2033b02 	and	r3, r3, #2048	; 0x800
10021b04:	e3530000 	cmp	r3, #0
10021b08:	0a00001f 	beq	10021b8c <rt_serial_open+0x33c>
        {
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) rt_malloc (sizeof(struct rt_serial_tx_dma));
10021b0c:	e3a00028 	mov	r0, #40	; 0x28
10021b10:	ebffc9df 	bl	10014294 <rt_malloc>
10021b14:	e50b0014 	str	r0, [fp, #-20]
            RT_ASSERT(tx_dma != RT_NULL);
10021b18:	e51b3014 	ldr	r3, [fp, #-20]
10021b1c:	e3530000 	cmp	r3, #0
10021b20:	1a000005 	bne	10021b3c <rt_serial_open+0x2ec>
10021b24:	e3040f94 	movw	r0, #20372	; 0x4f94
10021b28:	e3410003 	movt	r0, #4099	; 0x1003
10021b2c:	e3051000 	movw	r1, #20480	; 0x5000
10021b30:	e3411003 	movt	r1, #4099	; 0x1003
10021b34:	e3002132 	movw	r2, #306	; 0x132
10021b38:	ebffc89d 	bl	10013db4 <rt_assert_handler>
            tx_dma->activated = RT_FALSE;
10021b3c:	e51b3014 	ldr	r3, [fp, #-20]
10021b40:	e3a02000 	mov	r2, #0
10021b44:	e5832000 	str	r2, [r3]
            
            rt_data_queue_init(&(tx_dma->data_queue), 8, 4, RT_NULL);
10021b48:	e51b3014 	ldr	r3, [fp, #-20]
10021b4c:	e2833004 	add	r3, r3, #4
10021b50:	e1a00003 	mov	r0, r3
10021b54:	e3a01008 	mov	r1, #8
10021b58:	e3a02004 	mov	r2, #4
10021b5c:	e3a03000 	mov	r3, #0
10021b60:	ebfffb75 	bl	1002093c <rt_data_queue_init>
            serial->serial_tx = tx_dma;
10021b64:	e51b3008 	ldr	r3, [fp, #-8]
10021b68:	e51b2014 	ldr	r2, [fp, #-20]
10021b6c:	e583204c 	str	r2, [r3, #76]	; 0x4c

            dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
10021b70:	e51b3020 	ldr	r3, [fp, #-32]
10021b74:	e1d331b4 	ldrh	r3, [r3, #20]
10021b78:	e3833b02 	orr	r3, r3, #2048	; 0x800
10021b7c:	e6ff2073 	uxth	r2, r3
10021b80:	e51b3020 	ldr	r3, [fp, #-32]
10021b84:	e1c321b4 	strh	r2, [r3, #20]
10021b88:	ea000026 	b	10021c28 <rt_serial_open+0x3d8>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_TX)
10021b8c:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
10021b90:	e2033b01 	and	r3, r3, #1024	; 0x400
10021b94:	e3530000 	cmp	r3, #0
10021b98:	0a00001f 	beq	10021c1c <rt_serial_open+0x3cc>
        {
            struct rt_serial_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*) rt_malloc(sizeof(struct rt_serial_tx_fifo));
10021b9c:	e3a0000c 	mov	r0, #12
10021ba0:	ebffc9bb 	bl	10014294 <rt_malloc>
10021ba4:	e50b0018 	str	r0, [fp, #-24]
            RT_ASSERT(tx_fifo != RT_NULL);
10021ba8:	e51b3018 	ldr	r3, [fp, #-24]
10021bac:	e3530000 	cmp	r3, #0
10021bb0:	1a000005 	bne	10021bcc <rt_serial_open+0x37c>
10021bb4:	e3040fa8 	movw	r0, #20392	; 0x4fa8
10021bb8:	e3410003 	movt	r0, #4099	; 0x1003
10021bbc:	e3051000 	movw	r1, #20480	; 0x5000
10021bc0:	e3411003 	movt	r1, #4099	; 0x1003
10021bc4:	e300213f 	movw	r2, #319	; 0x13f
10021bc8:	ebffc879 	bl	10013db4 <rt_assert_handler>

            rt_completion_init(&(tx_fifo->completion));
10021bcc:	e51b3018 	ldr	r3, [fp, #-24]
10021bd0:	e1a00003 	mov	r0, r3
10021bd4:	ebfffa76 	bl	100205b4 <rt_completion_init>
            serial->serial_tx = tx_fifo;
10021bd8:	e51b3008 	ldr	r3, [fp, #-8]
10021bdc:	e51b2018 	ldr	r2, [fp, #-24]
10021be0:	e583204c 	str	r2, [r3, #76]	; 0x4c

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
10021be4:	e51b3020 	ldr	r3, [fp, #-32]
10021be8:	e1d331b4 	ldrh	r3, [r3, #20]
10021bec:	e3833b01 	orr	r3, r3, #1024	; 0x400
10021bf0:	e6ff2073 	uxth	r2, r3
10021bf4:	e51b3020 	ldr	r3, [fp, #-32]
10021bf8:	e1c321b4 	strh	r2, [r3, #20]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
10021bfc:	e51b3008 	ldr	r3, [fp, #-8]
10021c00:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021c04:	e5933004 	ldr	r3, [r3, #4]
10021c08:	e51b0008 	ldr	r0, [fp, #-8]
10021c0c:	e3a01010 	mov	r1, #16
10021c10:	e3a02b01 	mov	r2, #1024	; 0x400
10021c14:	e12fff33 	blx	r3
10021c18:	ea000002 	b	10021c28 <rt_serial_open+0x3d8>
        }
        else
        {
            serial->serial_tx = RT_NULL;
10021c1c:	e51b3008 	ldr	r3, [fp, #-8]
10021c20:	e3a02000 	mov	r2, #0
10021c24:	e583204c 	str	r2, [r3, #76]	; 0x4c
        }
    }

    return RT_EOK;
10021c28:	e3a03000 	mov	r3, #0
}
10021c2c:	e1a00003 	mov	r0, r3
10021c30:	e24bd004 	sub	sp, fp, #4
10021c34:	e8bd8800 	pop	{fp, pc}

10021c38 <rt_serial_close>:

static rt_err_t rt_serial_close(struct rt_device *dev)
{
10021c38:	e92d4800 	push	{fp, lr}
10021c3c:	e28db004 	add	fp, sp, #4
10021c40:	e24dd020 	sub	sp, sp, #32
10021c44:	e50b0020 	str	r0, [fp, #-32]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
10021c48:	e51b3020 	ldr	r3, [fp, #-32]
10021c4c:	e3530000 	cmp	r3, #0
10021c50:	1a000005 	bne	10021c6c <rt_serial_close+0x34>
10021c54:	e3040f7c 	movw	r0, #20348	; 0x4f7c
10021c58:	e3410003 	movt	r0, #4099	; 0x1003
10021c5c:	e3051010 	movw	r1, #20496	; 0x5010
10021c60:	e3411003 	movt	r1, #4099	; 0x1003
10021c64:	e3002155 	movw	r2, #341	; 0x155
10021c68:	ebffc851 	bl	10013db4 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
10021c6c:	e51b3020 	ldr	r3, [fp, #-32]
10021c70:	e50b3008 	str	r3, [fp, #-8]

    /* this device has more reference count */
    if (dev->ref_count > 1) return RT_EOK;
10021c74:	e51b3020 	ldr	r3, [fp, #-32]
10021c78:	e5d33016 	ldrb	r3, [r3, #22]
10021c7c:	e3530001 	cmp	r3, #1
10021c80:	9a000001 	bls	10021c8c <rt_serial_close+0x54>
10021c84:	e3a03000 	mov	r3, #0
10021c88:	ea000080 	b	10021e90 <rt_serial_close+0x258>
    
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
10021c8c:	e51b3020 	ldr	r3, [fp, #-32]
10021c90:	e1d331b4 	ldrh	r3, [r3, #20]
10021c94:	e2033c01 	and	r3, r3, #256	; 0x100
10021c98:	e3530000 	cmp	r3, #0
10021c9c:	0a00001e 	beq	10021d1c <rt_serial_close+0xe4>
    {
        struct rt_serial_rx_fifo* rx_fifo;

        rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
10021ca0:	e51b3008 	ldr	r3, [fp, #-8]
10021ca4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
10021ca8:	e50b300c 	str	r3, [fp, #-12]
        RT_ASSERT(rx_fifo != RT_NULL);
10021cac:	e51b300c 	ldr	r3, [fp, #-12]
10021cb0:	e3530000 	cmp	r3, #0
10021cb4:	1a000005 	bne	10021cd0 <rt_serial_close+0x98>
10021cb8:	e3040f18 	movw	r0, #20248	; 0x4f18
10021cbc:	e3410003 	movt	r0, #4099	; 0x1003
10021cc0:	e3051010 	movw	r1, #20496	; 0x5010
10021cc4:	e3411003 	movt	r1, #4099	; 0x1003
10021cc8:	e3a02e16 	mov	r2, #352	; 0x160
10021ccc:	ebffc838 	bl	10013db4 <rt_assert_handler>

        rt_free(rx_fifo);
10021cd0:	e51b000c 	ldr	r0, [fp, #-12]
10021cd4:	ebffcb89 	bl	10014b00 <rt_free>
        serial->serial_rx = RT_NULL;
10021cd8:	e51b3008 	ldr	r3, [fp, #-8]
10021cdc:	e3a02000 	mov	r2, #0
10021ce0:	e5832048 	str	r2, [r3, #72]	; 0x48
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
10021ce4:	e51b3020 	ldr	r3, [fp, #-32]
10021ce8:	e1d331b4 	ldrh	r3, [r3, #20]
10021cec:	e3c33c01 	bic	r3, r3, #256	; 0x100
10021cf0:	e6ff2073 	uxth	r2, r3
10021cf4:	e51b3020 	ldr	r3, [fp, #-32]
10021cf8:	e1c321b4 	strh	r2, [r3, #20]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
10021cfc:	e51b3008 	ldr	r3, [fp, #-8]
10021d00:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021d04:	e5933004 	ldr	r3, [r3, #4]
10021d08:	e51b0008 	ldr	r0, [fp, #-8]
10021d0c:	e3a01011 	mov	r1, #17
10021d10:	e3a02b01 	mov	r2, #1024	; 0x400
10021d14:	e12fff33 	blx	r3
10021d18:	ea00001b 	b	10021d8c <rt_serial_close+0x154>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
10021d1c:	e51b3020 	ldr	r3, [fp, #-32]
10021d20:	e1d331b4 	ldrh	r3, [r3, #20]
10021d24:	e2033c02 	and	r3, r3, #512	; 0x200
10021d28:	e3530000 	cmp	r3, #0
10021d2c:	0a000016 	beq	10021d8c <rt_serial_close+0x154>
    {
        struct rt_serial_rx_dma* rx_dma;

        rx_dma = (struct rt_serial_rx_dma*)serial->serial_tx;
10021d30:	e51b3008 	ldr	r3, [fp, #-8]
10021d34:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
10021d38:	e50b3010 	str	r3, [fp, #-16]
        RT_ASSERT(rx_dma != RT_NULL);
10021d3c:	e51b3010 	ldr	r3, [fp, #-16]
10021d40:	e3530000 	cmp	r3, #0
10021d44:	1a000005 	bne	10021d60 <rt_serial_close+0x128>
10021d48:	e3040f68 	movw	r0, #20328	; 0x4f68
10021d4c:	e3410003 	movt	r0, #4099	; 0x1003
10021d50:	e3051010 	movw	r1, #20496	; 0x5010
10021d54:	e3411003 	movt	r1, #4099	; 0x1003
10021d58:	e300216d 	movw	r2, #365	; 0x16d
10021d5c:	ebffc814 	bl	10013db4 <rt_assert_handler>

        rt_free(rx_dma);
10021d60:	e51b0010 	ldr	r0, [fp, #-16]
10021d64:	ebffcb65 	bl	10014b00 <rt_free>
        serial->serial_rx = RT_NULL;
10021d68:	e51b3008 	ldr	r3, [fp, #-8]
10021d6c:	e3a02000 	mov	r2, #0
10021d70:	e5832048 	str	r2, [r3, #72]	; 0x48
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_RX;
10021d74:	e51b3020 	ldr	r3, [fp, #-32]
10021d78:	e1d331b4 	ldrh	r3, [r3, #20]
10021d7c:	e3c33c02 	bic	r3, r3, #512	; 0x200
10021d80:	e6ff2073 	uxth	r2, r3
10021d84:	e51b3020 	ldr	r3, [fp, #-32]
10021d88:	e1c321b4 	strh	r2, [r3, #20]
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
10021d8c:	e51b3020 	ldr	r3, [fp, #-32]
10021d90:	e1d331b4 	ldrh	r3, [r3, #20]
10021d94:	e2033b01 	and	r3, r3, #1024	; 0x400
10021d98:	e3530000 	cmp	r3, #0
10021d9c:	0a00001e 	beq	10021e1c <rt_serial_close+0x1e4>
    {
        struct rt_serial_tx_fifo* tx_fifo;

        tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_rx;
10021da0:	e51b3008 	ldr	r3, [fp, #-8]
10021da4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
10021da8:	e50b3014 	str	r3, [fp, #-20]
        RT_ASSERT(tx_fifo != RT_NULL);
10021dac:	e51b3014 	ldr	r3, [fp, #-20]
10021db0:	e3530000 	cmp	r3, #0
10021db4:	1a000005 	bne	10021dd0 <rt_serial_close+0x198>
10021db8:	e3040fa8 	movw	r0, #20392	; 0x4fa8
10021dbc:	e3410003 	movt	r0, #4099	; 0x1003
10021dc0:	e3051010 	movw	r1, #20496	; 0x5010
10021dc4:	e3411003 	movt	r1, #4099	; 0x1003
10021dc8:	e3002179 	movw	r2, #377	; 0x179
10021dcc:	ebffc7f8 	bl	10013db4 <rt_assert_handler>

        rt_free(tx_fifo);
10021dd0:	e51b0014 	ldr	r0, [fp, #-20]
10021dd4:	ebffcb49 	bl	10014b00 <rt_free>
        serial->serial_tx = RT_NULL;
10021dd8:	e51b3008 	ldr	r3, [fp, #-8]
10021ddc:	e3a02000 	mov	r2, #0
10021de0:	e583204c 	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
10021de4:	e51b3020 	ldr	r3, [fp, #-32]
10021de8:	e1d331b4 	ldrh	r3, [r3, #20]
10021dec:	e3c33b01 	bic	r3, r3, #1024	; 0x400
10021df0:	e6ff2073 	uxth	r2, r3
10021df4:	e51b3020 	ldr	r3, [fp, #-32]
10021df8:	e1c321b4 	strh	r2, [r3, #20]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
10021dfc:	e51b3008 	ldr	r3, [fp, #-8]
10021e00:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10021e04:	e5933004 	ldr	r3, [r3, #4]
10021e08:	e51b0008 	ldr	r0, [fp, #-8]
10021e0c:	e3a01011 	mov	r1, #17
10021e10:	e3a02b01 	mov	r2, #1024	; 0x400
10021e14:	e12fff33 	blx	r3
10021e18:	ea00001b 	b	10021e8c <rt_serial_close+0x254>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
10021e1c:	e51b3020 	ldr	r3, [fp, #-32]
10021e20:	e1d331b4 	ldrh	r3, [r3, #20]
10021e24:	e2033b02 	and	r3, r3, #2048	; 0x800
10021e28:	e3530000 	cmp	r3, #0
10021e2c:	0a000016 	beq	10021e8c <rt_serial_close+0x254>
    {
        struct rt_serial_tx_dma* tx_dma;

        tx_dma = (struct rt_serial_tx_dma*)serial->serial_tx;
10021e30:	e51b3008 	ldr	r3, [fp, #-8]
10021e34:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
10021e38:	e50b3018 	str	r3, [fp, #-24]
        RT_ASSERT(tx_dma != RT_NULL);
10021e3c:	e51b3018 	ldr	r3, [fp, #-24]
10021e40:	e3530000 	cmp	r3, #0
10021e44:	1a000005 	bne	10021e60 <rt_serial_close+0x228>
10021e48:	e3040f94 	movw	r0, #20372	; 0x4f94
10021e4c:	e3410003 	movt	r0, #4099	; 0x1003
10021e50:	e3051010 	movw	r1, #20496	; 0x5010
10021e54:	e3411003 	movt	r1, #4099	; 0x1003
10021e58:	e3002186 	movw	r2, #390	; 0x186
10021e5c:	ebffc7d4 	bl	10013db4 <rt_assert_handler>

        rt_free(tx_dma);
10021e60:	e51b0018 	ldr	r0, [fp, #-24]
10021e64:	ebffcb25 	bl	10014b00 <rt_free>
        serial->serial_tx = RT_NULL;
10021e68:	e51b3008 	ldr	r3, [fp, #-8]
10021e6c:	e3a02000 	mov	r2, #0
10021e70:	e583204c 	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_TX;
10021e74:	e51b3020 	ldr	r3, [fp, #-32]
10021e78:	e1d331b4 	ldrh	r3, [r3, #20]
10021e7c:	e3c33b02 	bic	r3, r3, #2048	; 0x800
10021e80:	e6ff2073 	uxth	r2, r3
10021e84:	e51b3020 	ldr	r3, [fp, #-32]
10021e88:	e1c321b4 	strh	r2, [r3, #20]
    }

    return RT_EOK;
10021e8c:	e3a03000 	mov	r3, #0
}
10021e90:	e1a00003 	mov	r0, r3
10021e94:	e24bd004 	sub	sp, fp, #4
10021e98:	e8bd8800 	pop	{fp, pc}

10021e9c <rt_serial_read>:

static rt_size_t rt_serial_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)
{
10021e9c:	e92d4800 	push	{fp, lr}
10021ea0:	e28db004 	add	fp, sp, #4
10021ea4:	e24dd018 	sub	sp, sp, #24
10021ea8:	e50b0010 	str	r0, [fp, #-16]
10021eac:	e50b1014 	str	r1, [fp, #-20]
10021eb0:	e50b2018 	str	r2, [fp, #-24]
10021eb4:	e50b301c 	str	r3, [fp, #-28]
    struct rt_serial_device *serial;
	//rt_kprintf("&x\r\n",dev->open_flag);

    RT_ASSERT(dev != RT_NULL);
10021eb8:	e51b3010 	ldr	r3, [fp, #-16]
10021ebc:	e3530000 	cmp	r3, #0
10021ec0:	1a000005 	bne	10021edc <rt_serial_read+0x40>
10021ec4:	e3040f7c 	movw	r0, #20348	; 0x4f7c
10021ec8:	e3410003 	movt	r0, #4099	; 0x1003
10021ecc:	e3051020 	movw	r1, #20512	; 0x5020
10021ed0:	e3411003 	movt	r1, #4099	; 0x1003
10021ed4:	e3a02f66 	mov	r2, #408	; 0x198
10021ed8:	ebffc7b5 	bl	10013db4 <rt_assert_handler>
    if (size == 0) return 0;
10021edc:	e51b301c 	ldr	r3, [fp, #-28]
10021ee0:	e3530000 	cmp	r3, #0
10021ee4:	1a000001 	bne	10021ef0 <rt_serial_read+0x54>
10021ee8:	e3a03000 	mov	r3, #0
10021eec:	ea00001f 	b	10021f70 <rt_serial_read+0xd4>

    serial = (struct rt_serial_device *)dev;
10021ef0:	e51b3010 	ldr	r3, [fp, #-16]
10021ef4:	e50b3008 	str	r3, [fp, #-8]
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
10021ef8:	e51b3010 	ldr	r3, [fp, #-16]
10021efc:	e1d331b4 	ldrh	r3, [r3, #20]
10021f00:	e2033c01 	and	r3, r3, #256	; 0x100
10021f04:	e3530000 	cmp	r3, #0
10021f08:	0a000006 	beq	10021f28 <rt_serial_read+0x8c>
    {
        return _serial_int_rx(serial, buffer, size);
10021f0c:	e51b301c 	ldr	r3, [fp, #-28]
10021f10:	e51b0008 	ldr	r0, [fp, #-8]
10021f14:	e51b1018 	ldr	r1, [fp, #-24]
10021f18:	e1a02003 	mov	r2, r3
10021f1c:	ebfffd1e 	bl	1002139c <_serial_int_rx>
10021f20:	e1a03000 	mov	r3, r0
10021f24:	ea000011 	b	10021f70 <rt_serial_read+0xd4>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
10021f28:	e51b3010 	ldr	r3, [fp, #-16]
10021f2c:	e1d331b4 	ldrh	r3, [r3, #20]
10021f30:	e2033c02 	and	r3, r3, #512	; 0x200
10021f34:	e3530000 	cmp	r3, #0
10021f38:	0a000006 	beq	10021f58 <rt_serial_read+0xbc>
    {
        return _serial_dma_rx(serial, buffer, size);
10021f3c:	e51b301c 	ldr	r3, [fp, #-28]
10021f40:	e51b0008 	ldr	r0, [fp, #-8]
10021f44:	e51b1018 	ldr	r1, [fp, #-24]
10021f48:	e1a02003 	mov	r2, r3
10021f4c:	ebfffda6 	bl	100215ec <_serial_dma_rx>
10021f50:	e1a03000 	mov	r3, r0
10021f54:	ea000005 	b	10021f70 <rt_serial_read+0xd4>
    }

    return _serial_poll_rx(serial, buffer, size);
10021f58:	e51b301c 	ldr	r3, [fp, #-28]
10021f5c:	e51b0008 	ldr	r0, [fp, #-8]
10021f60:	e51b1018 	ldr	r1, [fp, #-24]
10021f64:	e1a02003 	mov	r2, r3
10021f68:	ebfffca4 	bl	10021200 <_serial_poll_rx>
10021f6c:	e1a03000 	mov	r3, r0
}
10021f70:	e1a00003 	mov	r0, r3
10021f74:	e24bd004 	sub	sp, fp, #4
10021f78:	e8bd8800 	pop	{fp, pc}

10021f7c <rt_serial_write>:

static rt_size_t rt_serial_write(struct rt_device *dev,
                                 rt_off_t          pos,
                                 const void       *buffer,
                                 rt_size_t         size)
{
10021f7c:	e92d4800 	push	{fp, lr}
10021f80:	e28db004 	add	fp, sp, #4
10021f84:	e24dd018 	sub	sp, sp, #24
10021f88:	e50b0010 	str	r0, [fp, #-16]
10021f8c:	e50b1014 	str	r1, [fp, #-20]
10021f90:	e50b2018 	str	r2, [fp, #-24]
10021f94:	e50b301c 	str	r3, [fp, #-28]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
10021f98:	e51b3010 	ldr	r3, [fp, #-16]
10021f9c:	e3530000 	cmp	r3, #0
10021fa0:	1a000005 	bne	10021fbc <rt_serial_write+0x40>
10021fa4:	e3040f7c 	movw	r0, #20348	; 0x4f7c
10021fa8:	e3410003 	movt	r0, #4099	; 0x1003
10021fac:	e3051060 	movw	r1, #20576	; 0x5060
10021fb0:	e3411003 	movt	r1, #4099	; 0x1003
10021fb4:	e30021af 	movw	r2, #431	; 0x1af
10021fb8:	ebffc77d 	bl	10013db4 <rt_assert_handler>
    if (size == 0) return 0;
10021fbc:	e51b301c 	ldr	r3, [fp, #-28]
10021fc0:	e3530000 	cmp	r3, #0
10021fc4:	1a000001 	bne	10021fd0 <rt_serial_write+0x54>
10021fc8:	e3a03000 	mov	r3, #0
10021fcc:	ea00001f 	b	10022050 <rt_serial_write+0xd4>

    serial = (struct rt_serial_device *)dev;
10021fd0:	e51b3010 	ldr	r3, [fp, #-16]
10021fd4:	e50b3008 	str	r3, [fp, #-8]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
10021fd8:	e51b3010 	ldr	r3, [fp, #-16]
10021fdc:	e1d331b4 	ldrh	r3, [r3, #20]
10021fe0:	e2033b01 	and	r3, r3, #1024	; 0x400
10021fe4:	e3530000 	cmp	r3, #0
10021fe8:	0a000006 	beq	10022008 <rt_serial_write+0x8c>
    {
        return _serial_int_tx(serial, buffer, size);
10021fec:	e51b301c 	ldr	r3, [fp, #-28]
10021ff0:	e51b0008 	ldr	r0, [fp, #-8]
10021ff4:	e51b1018 	ldr	r1, [fp, #-24]
10021ff8:	e1a02003 	mov	r2, r3
10021ffc:	ebfffd3d 	bl	100214f8 <_serial_int_tx>
10022000:	e1a03000 	mov	r3, r0
10022004:	ea000011 	b	10022050 <rt_serial_write+0xd4>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
10022008:	e51b3010 	ldr	r3, [fp, #-16]
1002200c:	e1d331b4 	ldrh	r3, [r3, #20]
10022010:	e2033b02 	and	r3, r3, #2048	; 0x800
10022014:	e3530000 	cmp	r3, #0
10022018:	0a000006 	beq	10022038 <rt_serial_write+0xbc>
    {
        return _serial_dma_tx(serial, buffer, size);
1002201c:	e51b301c 	ldr	r3, [fp, #-28]
10022020:	e51b0008 	ldr	r0, [fp, #-8]
10022024:	e51b1018 	ldr	r1, [fp, #-24]
10022028:	e1a02003 	mov	r2, r3
1002202c:	ebfffda6 	bl	100216cc <_serial_dma_tx>
10022030:	e1a03000 	mov	r3, r0
10022034:	ea000005 	b	10022050 <rt_serial_write+0xd4>
    }
    else
    {
        return _serial_poll_tx(serial, buffer, size);
10022038:	e51b301c 	ldr	r3, [fp, #-28]
1002203c:	e51b0008 	ldr	r0, [fp, #-8]
10022040:	e51b1018 	ldr	r1, [fp, #-24]
10022044:	e1a02003 	mov	r2, r3
10022048:	ebfffc9b 	bl	100212bc <_serial_poll_tx>
1002204c:	e1a03000 	mov	r3, r0
    }
}
10022050:	e1a00003 	mov	r0, r3
10022054:	e24bd004 	sub	sp, fp, #4
10022058:	e8bd8800 	pop	{fp, pc}

1002205c <rt_serial_control>:

static rt_err_t rt_serial_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
1002205c:	e92d4800 	push	{fp, lr}
10022060:	e28db004 	add	fp, sp, #4
10022064:	e24dd018 	sub	sp, sp, #24
10022068:	e50b0010 	str	r0, [fp, #-16]
1002206c:	e1a03001 	mov	r3, r1
10022070:	e50b2018 	str	r2, [fp, #-24]
10022074:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
10022078:	e51b3010 	ldr	r3, [fp, #-16]
1002207c:	e3530000 	cmp	r3, #0
10022080:	1a000005 	bne	1002209c <rt_serial_control+0x40>
10022084:	e3040f7c 	movw	r0, #20348	; 0x4f7c
10022088:	e3410003 	movt	r0, #4099	; 0x1003
1002208c:	e3051090 	movw	r1, #20624	; 0x5090
10022090:	e3411003 	movt	r1, #4099	; 0x1003
10022094:	e3a02f72 	mov	r2, #456	; 0x1c8
10022098:	ebffc745 	bl	10013db4 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
1002209c:	e51b3010 	ldr	r3, [fp, #-16]
100220a0:	e50b3008 	str	r3, [fp, #-8]

    switch (cmd)
100220a4:	e55b3011 	ldrb	r3, [fp, #-17]
100220a8:	e3530002 	cmp	r3, #2
100220ac:	0a000004 	beq	100220c4 <rt_serial_control+0x68>
100220b0:	e3530003 	cmp	r3, #3
100220b4:	0a000010 	beq	100220fc <rt_serial_control+0xa0>
100220b8:	e3530001 	cmp	r3, #1
100220bc:	0a000007 	beq	100220e0 <rt_serial_control+0x84>
100220c0:	ea000014 	b	10022118 <rt_serial_control+0xbc>
    {
        case RT_DEVICE_CTRL_SUSPEND:
            /* suspend device */
            dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
100220c4:	e51b3010 	ldr	r3, [fp, #-16]
100220c8:	e1d331b2 	ldrh	r3, [r3, #18]
100220cc:	e3833020 	orr	r3, r3, #32
100220d0:	e6ff2073 	uxth	r2, r3
100220d4:	e51b3010 	ldr	r3, [fp, #-16]
100220d8:	e1c321b2 	strh	r2, [r3, #18]
            break;
100220dc:	ea000016 	b	1002213c <rt_serial_control+0xe0>

        case RT_DEVICE_CTRL_RESUME:
            /* resume device */
            dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
100220e0:	e51b3010 	ldr	r3, [fp, #-16]
100220e4:	e1d331b2 	ldrh	r3, [r3, #18]
100220e8:	e3c33020 	bic	r3, r3, #32
100220ec:	e6ff2073 	uxth	r2, r3
100220f0:	e51b3010 	ldr	r3, [fp, #-16]
100220f4:	e1c321b2 	strh	r2, [r3, #18]
            break;
100220f8:	ea00000f 	b	1002213c <rt_serial_control+0xe0>

        case RT_DEVICE_CTRL_CONFIG:
            /* configure device */
            serial->ops->configure(serial, (struct serial_configure *)args);
100220fc:	e51b3008 	ldr	r3, [fp, #-8]
10022100:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10022104:	e5933000 	ldr	r3, [r3]
10022108:	e51b0008 	ldr	r0, [fp, #-8]
1002210c:	e51b1018 	ldr	r1, [fp, #-24]
10022110:	e12fff33 	blx	r3
            break;
10022114:	ea000008 	b	1002213c <rt_serial_control+0xe0>

        default :
            /* control device */
            serial->ops->control(serial, cmd, args);
10022118:	e51b3008 	ldr	r3, [fp, #-8]
1002211c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10022120:	e5933004 	ldr	r3, [r3, #4]
10022124:	e55b2011 	ldrb	r2, [fp, #-17]
10022128:	e51b0008 	ldr	r0, [fp, #-8]
1002212c:	e1a01002 	mov	r1, r2
10022130:	e51b2018 	ldr	r2, [fp, #-24]
10022134:	e12fff33 	blx	r3
            break;
10022138:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
1002213c:	e3a03000 	mov	r3, #0
}
10022140:	e1a00003 	mov	r0, r3
10022144:	e24bd004 	sub	sp, fp, #4
10022148:	e8bd8800 	pop	{fp, pc}

1002214c <rt_hw_serial_register>:
 */
rt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
1002214c:	e92d4800 	push	{fp, lr}
10022150:	e28db004 	add	fp, sp, #4
10022154:	e24dd018 	sub	sp, sp, #24
10022158:	e50b0010 	str	r0, [fp, #-16]
1002215c:	e50b1014 	str	r1, [fp, #-20]
10022160:	e50b2018 	str	r2, [fp, #-24]
10022164:	e50b301c 	str	r3, [fp, #-28]
    struct rt_device *device;
    RT_ASSERT(serial != RT_NULL);
10022168:	e51b3010 	ldr	r3, [fp, #-16]
1002216c:	e3530000 	cmp	r3, #0
10022170:	1a000005 	bne	1002218c <rt_hw_serial_register+0x40>
10022174:	e3040f04 	movw	r0, #20228	; 0x4f04
10022178:	e3410003 	movt	r0, #4099	; 0x1003
1002217c:	e30510a4 	movw	r1, #20644	; 0x50a4
10022180:	e3411003 	movt	r1, #4099	; 0x1003
10022184:	e30021ee 	movw	r2, #494	; 0x1ee
10022188:	ebffc709 	bl	10013db4 <rt_assert_handler>

    device = &(serial->parent);
1002218c:	e51b3010 	ldr	r3, [fp, #-16]
10022190:	e50b3008 	str	r3, [fp, #-8]

    device->type        = RT_Device_Class_Char;
10022194:	e51b3008 	ldr	r3, [fp, #-8]
10022198:	e3a02000 	mov	r2, #0
1002219c:	e5c32010 	strb	r2, [r3, #16]
    device->rx_indicate = RT_NULL;
100221a0:	e51b3008 	ldr	r3, [fp, #-8]
100221a4:	e3a02000 	mov	r2, #0
100221a8:	e5832018 	str	r2, [r3, #24]
    device->tx_complete = RT_NULL;
100221ac:	e51b3008 	ldr	r3, [fp, #-8]
100221b0:	e3a02000 	mov	r2, #0
100221b4:	e583201c 	str	r2, [r3, #28]

    device->init        = rt_serial_init;
100221b8:	e51b2008 	ldr	r2, [fp, #-8]
100221bc:	e301379c 	movw	r3, #6044	; 0x179c
100221c0:	e3413002 	movt	r3, #4098	; 0x1002
100221c4:	e5823020 	str	r3, [r2, #32]
    device->open        = rt_serial_open;
100221c8:	e51b2008 	ldr	r2, [fp, #-8]
100221cc:	e3013850 	movw	r3, #6224	; 0x1850
100221d0:	e3413002 	movt	r3, #4098	; 0x1002
100221d4:	e5823024 	str	r3, [r2, #36]	; 0x24
    device->close       = rt_serial_close;
100221d8:	e51b2008 	ldr	r2, [fp, #-8]
100221dc:	e3013c38 	movw	r3, #7224	; 0x1c38
100221e0:	e3413002 	movt	r3, #4098	; 0x1002
100221e4:	e5823028 	str	r3, [r2, #40]	; 0x28
    device->read        = rt_serial_read;
100221e8:	e51b2008 	ldr	r2, [fp, #-8]
100221ec:	e3013e9c 	movw	r3, #7836	; 0x1e9c
100221f0:	e3413002 	movt	r3, #4098	; 0x1002
100221f4:	e582302c 	str	r3, [r2, #44]	; 0x2c
    device->write       = rt_serial_write;
100221f8:	e51b2008 	ldr	r2, [fp, #-8]
100221fc:	e3013f7c 	movw	r3, #8060	; 0x1f7c
10022200:	e3413002 	movt	r3, #4098	; 0x1002
10022204:	e5823030 	str	r3, [r2, #48]	; 0x30
    device->control     = rt_serial_control;
10022208:	e51b2008 	ldr	r2, [fp, #-8]
1002220c:	e302305c 	movw	r3, #8284	; 0x205c
10022210:	e3413002 	movt	r3, #4098	; 0x1002
10022214:	e5823034 	str	r3, [r2, #52]	; 0x34
    device->user_data   = data;
10022218:	e51b3008 	ldr	r3, [fp, #-8]
1002221c:	e51b201c 	ldr	r2, [fp, #-28]
10022220:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* register a character device */
    return rt_device_register(device, name, flag);
10022224:	e51b3018 	ldr	r3, [fp, #-24]
10022228:	e6ff3073 	uxth	r3, r3
1002222c:	e51b0008 	ldr	r0, [fp, #-8]
10022230:	e51b1014 	ldr	r1, [fp, #-20]
10022234:	e1a02003 	mov	r2, r3
10022238:	ebffb0c8 	bl	1000e560 <rt_device_register>
1002223c:	e1a03000 	mov	r3, r0
}
10022240:	e1a00003 	mov	r0, r3
10022244:	e24bd004 	sub	sp, fp, #4
10022248:	e8bd8800 	pop	{fp, pc}

1002224c <rt_hw_serial_isr>:

/* ISR for serial interrupt */
void rt_hw_serial_isr(struct rt_serial_device *serial, int event)
{
1002224c:	e92d4800 	push	{fp, lr}
10022250:	e28db004 	add	fp, sp, #4
10022254:	e24dd038 	sub	sp, sp, #56	; 0x38
10022258:	e50b0038 	str	r0, [fp, #-56]	; 0x38
1002225c:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
    switch (event & 0xff)
10022260:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10022264:	e6ef3073 	uxtb	r3, r3
10022268:	e2433001 	sub	r3, r3, #1
1002226c:	e3530003 	cmp	r3, #3
10022270:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10022274:	ea0000d3 	b	100225c8 <rt_hw_serial_isr+0x37c>
10022278:	10022288 	.word	0x10022288
1002227c:	10022494 	.word	0x10022494
10022280:	10022584 	.word	0x10022584
10022284:	100224b0 	.word	0x100224b0
    {
        case RT_SERIAL_EVENT_RX_IND:
        {
            int ch = -1;
10022288:	e3e03000 	mvn	r3, #0
1002228c:	e50b3008 	str	r3, [fp, #-8]
            rt_base_t level;
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
10022290:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10022294:	e5933048 	ldr	r3, [r3, #72]	; 0x48
10022298:	e50b300c 	str	r3, [fp, #-12]
            RT_ASSERT(rx_fifo != RT_NULL);
1002229c:	e51b300c 	ldr	r3, [fp, #-12]
100222a0:	e3530000 	cmp	r3, #0
100222a4:	1a000005 	bne	100222c0 <rt_hw_serial_isr+0x74>
100222a8:	e3040f18 	movw	r0, #20248	; 0x4f18
100222ac:	e3410003 	movt	r0, #4099	; 0x1003
100222b0:	e30510bc 	movw	r1, #20668	; 0x50bc
100222b4:	e3411003 	movt	r1, #4099	; 0x1003
100222b8:	e300220e 	movw	r2, #526	; 0x20e
100222bc:	ebffc6bc 	bl	10013db4 <rt_assert_handler>
            
            /* interrupt mode receive */
            RT_ASSERT(serial->parent.open_flag & RT_DEVICE_FLAG_INT_RX);
100222c0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100222c4:	e1d331b4 	ldrh	r3, [r3, #20]
100222c8:	e2033c01 	and	r3, r3, #256	; 0x100
100222cc:	e3530000 	cmp	r3, #0
100222d0:	1a000005 	bne	100222ec <rt_hw_serial_isr+0xa0>
100222d4:	e3040fbc 	movw	r0, #20412	; 0x4fbc
100222d8:	e3410003 	movt	r0, #4099	; 0x1003
100222dc:	e30510bc 	movw	r1, #20668	; 0x50bc
100222e0:	e3411003 	movt	r1, #4099	; 0x1003
100222e4:	e3002211 	movw	r2, #529	; 0x211
100222e8:	ebffc6b1 	bl	10013db4 <rt_assert_handler>
            
            while (1)
            {
                ch = serial->ops->getc(serial);
100222ec:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100222f0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
100222f4:	e593300c 	ldr	r3, [r3, #12]
100222f8:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
100222fc:	e12fff33 	blx	r3
10022300:	e50b0008 	str	r0, [fp, #-8]
                if (ch == -1) break;
10022304:	e51b3008 	ldr	r3, [fp, #-8]
10022308:	e3730001 	cmn	r3, #1
1002230c:	1a000005 	bne	10022328 <rt_hw_serial_isr+0xdc>
10022310:	e1a00000 	nop			; (mov r0, r0)
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
            }
            
            /* invoke callback */
            if (serial->parent.rx_indicate != RT_NULL)
10022314:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10022318:	e5933018 	ldr	r3, [r3, #24]
1002231c:	e3530000 	cmp	r3, #0
10022320:	0a00005a 	beq	10022490 <rt_hw_serial_isr+0x244>
10022324:	ea000034 	b	100223fc <rt_hw_serial_isr+0x1b0>
            {
                ch = serial->ops->getc(serial);
                if (ch == -1) break;
                
                /* disable interrupt */
                level = rt_hw_interrupt_disable();
10022328:	ebffdcc0 	bl	10019630 <rt_hw_interrupt_disable>
1002232c:	e50b0010 	str	r0, [fp, #-16]
                
                rx_fifo->buffer[rx_fifo->put_index] = ch;
10022330:	e51b300c 	ldr	r3, [fp, #-12]
10022334:	e5933000 	ldr	r3, [r3]
10022338:	e51b200c 	ldr	r2, [fp, #-12]
1002233c:	e1d220b4 	ldrh	r2, [r2, #4]
10022340:	e0833002 	add	r3, r3, r2
10022344:	e51b2008 	ldr	r2, [fp, #-8]
10022348:	e6ef2072 	uxtb	r2, r2
1002234c:	e5c32000 	strb	r2, [r3]
                rx_fifo->put_index += 1;
10022350:	e51b300c 	ldr	r3, [fp, #-12]
10022354:	e1d330b4 	ldrh	r3, [r3, #4]
10022358:	e2833001 	add	r3, r3, #1
1002235c:	e6ff2073 	uxth	r2, r3
10022360:	e51b300c 	ldr	r3, [fp, #-12]
10022364:	e1c320b4 	strh	r2, [r3, #4]
                if (rx_fifo->put_index >= serial->config.bufsz) rx_fifo->put_index = 0;
10022368:	e51b300c 	ldr	r3, [fp, #-12]
1002236c:	e1d320b4 	ldrh	r2, [r3, #4]
10022370:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10022374:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10022378:	e7ef3553 	ubfx	r3, r3, #10, #16
1002237c:	e6ff3073 	uxth	r3, r3
10022380:	e1520003 	cmp	r2, r3
10022384:	3a000002 	bcc	10022394 <rt_hw_serial_isr+0x148>
10022388:	e51b300c 	ldr	r3, [fp, #-12]
1002238c:	e3a02000 	mov	r2, #0
10022390:	e1c320b4 	strh	r2, [r3, #4]
                
                /* if the next position is read index, discard this 'read char' */
                if (rx_fifo->put_index == rx_fifo->get_index)
10022394:	e51b300c 	ldr	r3, [fp, #-12]
10022398:	e1d320b4 	ldrh	r2, [r3, #4]
1002239c:	e51b300c 	ldr	r3, [fp, #-12]
100223a0:	e1d330b6 	ldrh	r3, [r3, #6]
100223a4:	e1520003 	cmp	r2, r3
100223a8:	1a000010 	bne	100223f0 <rt_hw_serial_isr+0x1a4>
                {
                    rx_fifo->get_index += 1;
100223ac:	e51b300c 	ldr	r3, [fp, #-12]
100223b0:	e1d330b6 	ldrh	r3, [r3, #6]
100223b4:	e2833001 	add	r3, r3, #1
100223b8:	e6ff2073 	uxth	r2, r3
100223bc:	e51b300c 	ldr	r3, [fp, #-12]
100223c0:	e1c320b6 	strh	r2, [r3, #6]
                    if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
100223c4:	e51b300c 	ldr	r3, [fp, #-12]
100223c8:	e1d320b6 	ldrh	r2, [r3, #6]
100223cc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100223d0:	e5933044 	ldr	r3, [r3, #68]	; 0x44
100223d4:	e7ef3553 	ubfx	r3, r3, #10, #16
100223d8:	e6ff3073 	uxth	r3, r3
100223dc:	e1520003 	cmp	r2, r3
100223e0:	3a000002 	bcc	100223f0 <rt_hw_serial_isr+0x1a4>
100223e4:	e51b300c 	ldr	r3, [fp, #-12]
100223e8:	e3a02000 	mov	r2, #0
100223ec:	e1c320b6 	strh	r2, [r3, #6]
                }
                
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
100223f0:	e51b0010 	ldr	r0, [fp, #-16]
100223f4:	ebffdc91 	bl	10019640 <rt_hw_interrupt_enable>
            }
100223f8:	eaffffbb 	b	100222ec <rt_hw_serial_isr+0xa0>
            if (serial->parent.rx_indicate != RT_NULL)
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
100223fc:	ebffdc8b 	bl	10019630 <rt_hw_interrupt_disable>
10022400:	e50b0010 	str	r0, [fp, #-16]
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
10022404:	e51b300c 	ldr	r3, [fp, #-12]
10022408:	e1d320b4 	ldrh	r2, [r3, #4]
1002240c:	e51b300c 	ldr	r3, [fp, #-12]
10022410:	e1d330b6 	ldrh	r3, [r3, #6]
10022414:	e1520003 	cmp	r2, r3
10022418:	3a000006 	bcc	10022438 <rt_hw_serial_isr+0x1ec>
1002241c:	e51b300c 	ldr	r3, [fp, #-12]
10022420:	e1d330b4 	ldrh	r3, [r3, #4]
10022424:	e1a02003 	mov	r2, r3
10022428:	e51b300c 	ldr	r3, [fp, #-12]
1002242c:	e1d330b6 	ldrh	r3, [r3, #6]
10022430:	e0633002 	rsb	r3, r3, r2
10022434:	ea00000b 	b	10022468 <rt_hw_serial_isr+0x21c>
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
10022438:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1002243c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10022440:	e7ef3553 	ubfx	r3, r3, #10, #16
10022444:	e6ff3073 	uxth	r3, r3
10022448:	e1a02003 	mov	r2, r3
1002244c:	e51b300c 	ldr	r3, [fp, #-12]
10022450:	e1d330b4 	ldrh	r3, [r3, #4]
10022454:	e1a01003 	mov	r1, r3
10022458:	e51b300c 	ldr	r3, [fp, #-12]
1002245c:	e1d330b6 	ldrh	r3, [r3, #6]
10022460:	e0633001 	rsb	r3, r3, r1
10022464:	e0823003 	add	r3, r2, r3
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
10022468:	e50b3014 	str	r3, [fp, #-20]
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
                rt_hw_interrupt_enable(level);
1002246c:	e51b0010 	ldr	r0, [fp, #-16]
10022470:	ebffdc72 	bl	10019640 <rt_hw_interrupt_enable>

                serial->parent.rx_indicate(&serial->parent, rx_length);
10022474:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10022478:	e5933018 	ldr	r3, [r3, #24]
1002247c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
10022480:	e1a00002 	mov	r0, r2
10022484:	e51b1014 	ldr	r1, [fp, #-20]
10022488:	e12fff33 	blx	r3
            }
            break;
1002248c:	ea00004d 	b	100225c8 <rt_hw_serial_isr+0x37c>
10022490:	ea00004c 	b	100225c8 <rt_hw_serial_isr+0x37c>
        }
        case RT_SERIAL_EVENT_TX_DONE:
        {
            struct rt_serial_tx_fifo* tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
10022494:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10022498:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
1002249c:	e50b3018 	str	r3, [fp, #-24]
            rt_completion_done(&(tx_fifo->completion));
100224a0:	e51b3018 	ldr	r3, [fp, #-24]
100224a4:	e1a00003 	mov	r0, r3
100224a8:	ebfff8c4 	bl	100207c0 <rt_completion_done>
            break;
100224ac:	ea000045 	b	100225c8 <rt_hw_serial_isr+0x37c>
            const void *data_ptr;
            rt_size_t data_size;
            const void *last_data_ptr;
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) serial->serial_tx;
100224b0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100224b4:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
100224b8:	e50b301c 	str	r3, [fp, #-28]
            
            rt_data_queue_pop(&(tx_dma->data_queue), &last_data_ptr, &data_size, 0);
100224bc:	e51b301c 	ldr	r3, [fp, #-28]
100224c0:	e2831004 	add	r1, r3, #4
100224c4:	e24b2030 	sub	r2, fp, #48	; 0x30
100224c8:	e24b302c 	sub	r3, fp, #44	; 0x2c
100224cc:	e1a00001 	mov	r0, r1
100224d0:	e1a01002 	mov	r1, r2
100224d4:	e1a02003 	mov	r2, r3
100224d8:	e3a03000 	mov	r3, #0
100224dc:	ebfff9fd 	bl	10020cd8 <rt_data_queue_pop>
            if (rt_data_queue_peak(&(tx_dma->data_queue), &data_ptr, &data_size) == RT_EOK)
100224e0:	e51b301c 	ldr	r3, [fp, #-28]
100224e4:	e2831004 	add	r1, r3, #4
100224e8:	e24b2028 	sub	r2, fp, #40	; 0x28
100224ec:	e24b302c 	sub	r3, fp, #44	; 0x2c
100224f0:	e1a00001 	mov	r0, r1
100224f4:	e1a01002 	mov	r1, r2
100224f8:	e1a02003 	mov	r2, r3
100224fc:	ebfffac8 	bl	10021024 <rt_data_queue_peak>
10022500:	e1a03000 	mov	r3, r0
10022504:	e3530000 	cmp	r3, #0
10022508:	1a00000d 	bne	10022544 <rt_hw_serial_isr+0x2f8>
            {
                /* transmit next data node */
                tx_dma->activated = RT_TRUE;
1002250c:	e51b301c 	ldr	r3, [fp, #-28]
10022510:	e3a02001 	mov	r2, #1
10022514:	e5832000 	str	r2, [r3]
                serial->ops->dma_transmit(serial, data_ptr, data_size, RT_SERIAL_DMA_TX);
10022518:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1002251c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10022520:	e593c010 	ldr	ip, [r3, #16]
10022524:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10022528:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1002252c:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
10022530:	e1a01002 	mov	r1, r2
10022534:	e1a02003 	mov	r2, r3
10022538:	e3a03002 	mov	r3, #2
1002253c:	e12fff3c 	blx	ip
10022540:	ea000002 	b	10022550 <rt_hw_serial_isr+0x304>
            }
            else
            {
                tx_dma->activated = RT_FALSE;
10022544:	e51b301c 	ldr	r3, [fp, #-28]
10022548:	e3a02000 	mov	r2, #0
1002254c:	e5832000 	str	r2, [r3]
            }
            
            /* invoke callback */
            if (serial->parent.tx_complete != RT_NULL)
10022550:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10022554:	e593301c 	ldr	r3, [r3, #28]
10022558:	e3530000 	cmp	r3, #0
1002255c:	0a000006 	beq	1002257c <rt_hw_serial_isr+0x330>
            {
                serial->parent.tx_complete(&serial->parent, (void*)last_data_ptr);
10022560:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10022564:	e593301c 	ldr	r3, [r3, #28]
10022568:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
1002256c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
10022570:	e1a00001 	mov	r0, r1
10022574:	e1a01002 	mov	r1, r2
10022578:	e12fff33 	blx	r3
            }
            break;
1002257c:	e1a00000 	nop			; (mov r0, r0)
10022580:	ea000010 	b	100225c8 <rt_hw_serial_isr+0x37c>
        case RT_SERIAL_EVENT_RX_DMADONE:
        {
            int length;
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
10022584:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10022588:	e5933048 	ldr	r3, [r3, #72]	; 0x48
1002258c:	e50b3020 	str	r3, [fp, #-32]
            /* get DMA rx length */
            length = (event & (~0xff)) >> 8;
10022590:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10022594:	e1a03443 	asr	r3, r3, #8
10022598:	e50b3024 	str	r3, [fp, #-36]	; 0x24
            serial->parent.rx_indicate(&(serial->parent), length);
1002259c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100225a0:	e5933018 	ldr	r3, [r3, #24]
100225a4:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
100225a8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100225ac:	e1a00001 	mov	r0, r1
100225b0:	e1a01002 	mov	r1, r2
100225b4:	e12fff33 	blx	r3
            rx_dma->activated = RT_FALSE;
100225b8:	e51b3020 	ldr	r3, [fp, #-32]
100225bc:	e3a02000 	mov	r2, #0
100225c0:	e5832000 	str	r2, [r3]
            break;
100225c4:	e1a00000 	nop			; (mov r0, r0)
        }
    }
}
100225c8:	e24bd004 	sub	sp, fp, #4
100225cc:	e8bd8800 	pop	{fp, pc}

100225d0 <finsh_get_prompt>:
#if defined(FINSH_USING_MSH) || (defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR))
#if defined(RT_USING_DFS)
#include <dfs_posix.h>
#endif
const char *finsh_get_prompt()
{
100225d0:	e92d4800 	push	{fp, lr}
100225d4:	e28db004 	add	fp, sp, #4
#define _MSH_PROMPT "msh "
#define _PROMPT     "finsh "
    static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};

#ifdef FINSH_USING_MSH
    if (msh_is_used()) strcpy(finsh_prompt, _MSH_PROMPT);
100225d8:	eb000a4e 	bl	10024f18 <msh_is_used>
100225dc:	e1a03000 	mov	r3, r0
100225e0:	e3530000 	cmp	r3, #0
100225e4:	0a000008 	beq	1002260c <finsh_get_prompt+0x3c>
100225e8:	e30f38b0 	movw	r3, #63664	; 0xf8b0
100225ec:	e3413003 	movt	r3, #4099	; 0x1003
100225f0:	e30520d0 	movw	r2, #20688	; 0x50d0
100225f4:	e3412003 	movt	r2, #4099	; 0x1003
100225f8:	e8920003 	ldm	r2, {r0, r1}
100225fc:	e5830000 	str	r0, [r3]
10022600:	e2833004 	add	r3, r3, #4
10022604:	e5c31000 	strb	r1, [r3]
10022608:	ea00000a 	b	10022638 <finsh_get_prompt+0x68>
    else
#endif
        strcpy(finsh_prompt, _PROMPT);
1002260c:	e30f38b0 	movw	r3, #63664	; 0xf8b0
10022610:	e3413003 	movt	r3, #4099	; 0x1003
10022614:	e30520d8 	movw	r2, #20696	; 0x50d8
10022618:	e3412003 	movt	r2, #4099	; 0x1003
1002261c:	e8920003 	ldm	r2, {r0, r1}
10022620:	e5830000 	str	r0, [r3]
10022624:	e2833004 	add	r3, r3, #4
10022628:	e1c310b0 	strh	r1, [r3]
1002262c:	e2833002 	add	r3, r3, #2
10022630:	e1a02821 	lsr	r2, r1, #16
10022634:	e5c32000 	strb	r2, [r3]
#if defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR)
    /* get current working directory */
    getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
#endif

    strcat(finsh_prompt, ">");
10022638:	e30f08b0 	movw	r0, #63664	; 0xf8b0
1002263c:	e3410003 	movt	r0, #4099	; 0x1003
10022640:	fa003458 	blx	1002f7a8 <strlen>
10022644:	e1a03000 	mov	r3, r0
10022648:	e1a02003 	mov	r2, r3
1002264c:	e30f38b0 	movw	r3, #63664	; 0xf8b0
10022650:	e3413003 	movt	r3, #4099	; 0x1003
10022654:	e0822003 	add	r2, r2, r3
10022658:	e30530e0 	movw	r3, #20704	; 0x50e0
1002265c:	e3413003 	movt	r3, #4099	; 0x1003
10022660:	e1d330b0 	ldrh	r3, [r3]
10022664:	e1c230b0 	strh	r3, [r2]

    return finsh_prompt;
10022668:	e30f38b0 	movw	r3, #63664	; 0xf8b0
1002266c:	e3413003 	movt	r3, #4099	; 0x1003
}
10022670:	e1a00003 	mov	r0, r3
10022674:	e8bd8800 	pop	{fp, pc}

10022678 <finsh_rx_ind>:
#endif

static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
{
10022678:	e92d4800 	push	{fp, lr}
1002267c:	e28db004 	add	fp, sp, #4
10022680:	e24dd008 	sub	sp, sp, #8
10022684:	e50b0008 	str	r0, [fp, #-8]
10022688:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(shell != RT_NULL);
1002268c:	e3033590 	movw	r3, #13712	; 0x3590
10022690:	e3413004 	movt	r3, #4100	; 0x1004
10022694:	e5933000 	ldr	r3, [r3]
10022698:	e3530000 	cmp	r3, #0
1002269c:	1a000005 	bne	100226b8 <finsh_rx_ind+0x40>
100226a0:	e30500e4 	movw	r0, #20708	; 0x50e4
100226a4:	e3410003 	movt	r0, #4099	; 0x1003
100226a8:	e30511a4 	movw	r1, #20900	; 0x51a4
100226ac:	e3411003 	movt	r1, #4099	; 0x1003
100226b0:	e3a02056 	mov	r2, #86	; 0x56
100226b4:	ebffc5be 	bl	10013db4 <rt_assert_handler>

    /* release semaphore to let finsh thread rx data */
    rt_sem_release(&shell->rx_sem);
100226b8:	e3033590 	movw	r3, #13712	; 0x3590
100226bc:	e3413004 	movt	r3, #4100	; 0x1004
100226c0:	e5933000 	ldr	r3, [r3]
100226c4:	e1a00003 	mov	r0, r3
100226c8:	ebffb3fb 	bl	1000f6bc <rt_sem_release>

    return RT_EOK;
100226cc:	e3a03000 	mov	r3, #0
}
100226d0:	e1a00003 	mov	r0, r3
100226d4:	e24bd004 	sub	sp, fp, #4
100226d8:	e8bd8800 	pop	{fp, pc}

100226dc <finsh_set_device>:
 * This function sets the input device of finsh shell.
 *
 * @param device_name the name of new input device.
 */
void finsh_set_device(const char *device_name)
{
100226dc:	e92d4800 	push	{fp, lr}
100226e0:	e28db004 	add	fp, sp, #4
100226e4:	e24dd010 	sub	sp, sp, #16
100226e8:	e50b0010 	str	r0, [fp, #-16]
    rt_device_t dev = RT_NULL;
100226ec:	e3a03000 	mov	r3, #0
100226f0:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(shell != RT_NULL);
100226f4:	e3033590 	movw	r3, #13712	; 0x3590
100226f8:	e3413004 	movt	r3, #4100	; 0x1004
100226fc:	e5933000 	ldr	r3, [r3]
10022700:	e3530000 	cmp	r3, #0
10022704:	1a000005 	bne	10022720 <finsh_set_device+0x44>
10022708:	e30500e4 	movw	r0, #20708	; 0x50e4
1002270c:	e3410003 	movt	r0, #4099	; 0x1003
10022710:	e30511b4 	movw	r1, #20916	; 0x51b4
10022714:	e3411003 	movt	r1, #4099	; 0x1003
10022718:	e3a02069 	mov	r2, #105	; 0x69
1002271c:	ebffc5a4 	bl	10013db4 <rt_assert_handler>
    dev = rt_device_find(device_name);
10022720:	e51b0010 	ldr	r0, [fp, #-16]
10022724:	ebffafca 	bl	1000e654 <rt_device_find>
10022728:	e50b0008 	str	r0, [fp, #-8]
    if (dev == RT_NULL)
1002272c:	e51b3008 	ldr	r3, [fp, #-8]
10022730:	e3530000 	cmp	r3, #0
10022734:	1a000004 	bne	1002274c <finsh_set_device+0x70>
    {
        rt_kprintf("finsh: can not find device: %s\n", device_name);
10022738:	e30500f8 	movw	r0, #20728	; 0x50f8
1002273c:	e3410003 	movt	r0, #4099	; 0x1003
10022740:	e51b1010 	ldr	r1, [fp, #-16]
10022744:	ebffc4dd 	bl	10013ac0 <rt_kprintf>
        return;
10022748:	ea00003b 	b	1002283c <finsh_set_device+0x160>
    }

    /* check whether it's a same device */
    if (dev == shell->device) return;
1002274c:	e3033590 	movw	r3, #13712	; 0x3590
10022750:	e3413004 	movt	r3, #4100	; 0x1004
10022754:	e5933000 	ldr	r3, [r3]
10022758:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
1002275c:	e51b3008 	ldr	r3, [fp, #-8]
10022760:	e1520003 	cmp	r2, r3
10022764:	1a000000 	bne	1002276c <finsh_set_device+0x90>
10022768:	ea000033 	b	1002283c <finsh_set_device+0x160>
    /* open this device and set the new device in finsh shell */
    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX | \
1002276c:	e51b0008 	ldr	r0, [fp, #-8]
10022770:	e3001143 	movw	r1, #323	; 0x143
10022774:	ebffb01a 	bl	1000e7e4 <rt_device_open>
10022778:	e1a03000 	mov	r3, r0
1002277c:	e3530000 	cmp	r3, #0
10022780:	1a00002d 	bne	1002283c <finsh_set_device+0x160>
                       RT_DEVICE_FLAG_STREAM) == RT_EOK)
    {
        if (shell->device != RT_NULL)
10022784:	e3033590 	movw	r3, #13712	; 0x3590
10022788:	e3413004 	movt	r3, #4100	; 0x1004
1002278c:	e5933000 	ldr	r3, [r3]
10022790:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10022794:	e3530000 	cmp	r3, #0
10022798:	0a00000c 	beq	100227d0 <finsh_set_device+0xf4>
        {
            /* close old finsh device */
            rt_device_close(shell->device);
1002279c:	e3033590 	movw	r3, #13712	; 0x3590
100227a0:	e3413004 	movt	r3, #4100	; 0x1004
100227a4:	e5933000 	ldr	r3, [r3]
100227a8:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
100227ac:	e1a00003 	mov	r0, r3
100227b0:	ebffb071 	bl	1000e97c <rt_device_close>
            rt_device_set_rx_indicate(shell->device, RT_NULL);
100227b4:	e3033590 	movw	r3, #13712	; 0x3590
100227b8:	e3413004 	movt	r3, #4100	; 0x1004
100227bc:	e5933000 	ldr	r3, [r3]
100227c0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
100227c4:	e1a00003 	mov	r0, r3
100227c8:	e3a01000 	mov	r1, #0
100227cc:	ebffb118 	bl	1000ec34 <rt_device_set_rx_indicate>
        }

        /* clear line buffer before switch to new device */
        memset(shell->line, 0, sizeof(shell->line));
100227d0:	e3033590 	movw	r3, #13712	; 0x3590
100227d4:	e3413004 	movt	r3, #4100	; 0x1004
100227d8:	e5933000 	ldr	r3, [r3]
100227dc:	e2833e25 	add	r3, r3, #592	; 0x250
100227e0:	e1a00003 	mov	r0, r3
100227e4:	e3a01000 	mov	r1, #0
100227e8:	e3a02050 	mov	r2, #80	; 0x50
100227ec:	fa0032ea 	blx	1002f39c <memset>
        shell->line_curpos = shell->line_position = 0;
100227f0:	e3033590 	movw	r3, #13712	; 0x3590
100227f4:	e3413004 	movt	r3, #4100	; 0x1004
100227f8:	e5932000 	ldr	r2, [r3]
100227fc:	e3033590 	movw	r3, #13712	; 0x3590
10022800:	e3413004 	movt	r3, #4100	; 0x1004
10022804:	e5933000 	ldr	r3, [r3]
10022808:	e3a01000 	mov	r1, #0
1002280c:	e5c312a0 	strb	r1, [r3, #672]	; 0x2a0
10022810:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10022814:	e5c232a1 	strb	r3, [r2, #673]	; 0x2a1

        shell->device = dev;
10022818:	e3033590 	movw	r3, #13712	; 0x3590
1002281c:	e3413004 	movt	r3, #4100	; 0x1004
10022820:	e5933000 	ldr	r3, [r3]
10022824:	e51b2008 	ldr	r2, [fp, #-8]
10022828:	e58322a4 	str	r2, [r3, #676]	; 0x2a4
        rt_device_set_rx_indicate(dev, finsh_rx_ind);
1002282c:	e51b0008 	ldr	r0, [fp, #-8]
10022830:	e3021678 	movw	r1, #9848	; 0x2678
10022834:	e3411002 	movt	r1, #4098	; 0x1002
10022838:	ebffb0fd 	bl	1000ec34 <rt_device_set_rx_indicate>
    }
}
1002283c:	e24bd004 	sub	sp, fp, #4
10022840:	e8bd8800 	pop	{fp, pc}

10022844 <finsh_get_device>:
 * This function returns current finsh shell input device.
 *
 * @return the finsh shell input device name is returned.
 */
const char *finsh_get_device()
{
10022844:	e92d4800 	push	{fp, lr}
10022848:	e28db004 	add	fp, sp, #4
    RT_ASSERT(shell != RT_NULL);
1002284c:	e3033590 	movw	r3, #13712	; 0x3590
10022850:	e3413004 	movt	r3, #4100	; 0x1004
10022854:	e5933000 	ldr	r3, [r3]
10022858:	e3530000 	cmp	r3, #0
1002285c:	1a000005 	bne	10022878 <finsh_get_device+0x34>
10022860:	e30500e4 	movw	r0, #20708	; 0x50e4
10022864:	e3410003 	movt	r0, #4099	; 0x1003
10022868:	e30511c8 	movw	r1, #20936	; 0x51c8
1002286c:	e3411003 	movt	r1, #4099	; 0x1003
10022870:	e3a02090 	mov	r2, #144	; 0x90
10022874:	ebffc54e 	bl	10013db4 <rt_assert_handler>
    return shell->device->parent.name;
10022878:	e3033590 	movw	r3, #13712	; 0x3590
1002287c:	e3413004 	movt	r3, #4100	; 0x1004
10022880:	e5933000 	ldr	r3, [r3]
10022884:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
}
10022888:	e1a00003 	mov	r0, r3
1002288c:	e8bd8800 	pop	{fp, pc}

10022890 <finsh_set_echo>:
 * FINSH_OPTION_ECHO=0x01 is echo mode, other values are none-echo mode.
 *
 * @param echo the echo mode
 */
void finsh_set_echo(rt_uint32_t echo)
{
10022890:	e92d4800 	push	{fp, lr}
10022894:	e28db004 	add	fp, sp, #4
10022898:	e24dd008 	sub	sp, sp, #8
1002289c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(shell != RT_NULL);
100228a0:	e3033590 	movw	r3, #13712	; 0x3590
100228a4:	e3413004 	movt	r3, #4100	; 0x1004
100228a8:	e5933000 	ldr	r3, [r3]
100228ac:	e3530000 	cmp	r3, #0
100228b0:	1a000005 	bne	100228cc <finsh_set_echo+0x3c>
100228b4:	e30500e4 	movw	r0, #20708	; 0x50e4
100228b8:	e3410003 	movt	r0, #4099	; 0x1003
100228bc:	e30511dc 	movw	r1, #20956	; 0x51dc
100228c0:	e3411003 	movt	r1, #4099	; 0x1003
100228c4:	e3a0209f 	mov	r2, #159	; 0x9f
100228c8:	ebffc539 	bl	10013db4 <rt_assert_handler>
    shell->echo_mode = (rt_uint8_t)echo;
100228cc:	e3033590 	movw	r3, #13712	; 0x3590
100228d0:	e3413004 	movt	r3, #4100	; 0x1004
100228d4:	e5932000 	ldr	r2, [r3]
100228d8:	e51b3008 	ldr	r3, [fp, #-8]
100228dc:	e6ef3073 	uxtb	r3, r3
100228e0:	e2033001 	and	r3, r3, #1
100228e4:	e6ef1073 	uxtb	r1, r3
100228e8:	e5d2301d 	ldrb	r3, [r2, #29]
100228ec:	e7c03011 	bfi	r3, r1, #0, #1
100228f0:	e5c2301d 	strb	r3, [r2, #29]
}
100228f4:	e24bd004 	sub	sp, fp, #4
100228f8:	e8bd8800 	pop	{fp, pc}

100228fc <finsh_get_echo>:
 * This function gets the echo mode of finsh shell.
 *
 * @return the echo mode
 */
rt_uint32_t finsh_get_echo()
{
100228fc:	e92d4800 	push	{fp, lr}
10022900:	e28db004 	add	fp, sp, #4
    RT_ASSERT(shell != RT_NULL);
10022904:	e3033590 	movw	r3, #13712	; 0x3590
10022908:	e3413004 	movt	r3, #4100	; 0x1004
1002290c:	e5933000 	ldr	r3, [r3]
10022910:	e3530000 	cmp	r3, #0
10022914:	1a000005 	bne	10022930 <finsh_get_echo+0x34>
10022918:	e30500e4 	movw	r0, #20708	; 0x50e4
1002291c:	e3410003 	movt	r0, #4099	; 0x1003
10022920:	e30511ec 	movw	r1, #20972	; 0x51ec
10022924:	e3411003 	movt	r1, #4099	; 0x1003
10022928:	e3a020ac 	mov	r2, #172	; 0xac
1002292c:	ebffc520 	bl	10013db4 <rt_assert_handler>

    return shell->echo_mode;
10022930:	e3033590 	movw	r3, #13712	; 0x3590
10022934:	e3413004 	movt	r3, #4100	; 0x1004
10022938:	e5933000 	ldr	r3, [r3]
1002293c:	e5d3301d 	ldrb	r3, [r3, #29]
10022940:	e7e03053 	ubfx	r3, r3, #0, #1
10022944:	e6ef3073 	uxtb	r3, r3
}
10022948:	e1a00003 	mov	r0, r3
1002294c:	e8bd8800 	pop	{fp, pc}

10022950 <shell_auto_complete>:

static void shell_auto_complete(char *prefix)
{
10022950:	e92d4800 	push	{fp, lr}
10022954:	e28db004 	add	fp, sp, #4
10022958:	e24dd008 	sub	sp, sp, #8
1002295c:	e50b0008 	str	r0, [fp, #-8]

    rt_kprintf("\n");
10022960:	e3050118 	movw	r0, #20760	; 0x5118
10022964:	e3410003 	movt	r0, #4099	; 0x1003
10022968:	ebffc454 	bl	10013ac0 <rt_kprintf>
#ifdef FINSH_USING_MSH
    if (msh_is_used() == RT_TRUE)
1002296c:	eb000969 	bl	10024f18 <msh_is_used>
10022970:	e1a03000 	mov	r3, r0
10022974:	e3530001 	cmp	r3, #1
10022978:	1a000002 	bne	10022988 <shell_auto_complete+0x38>
    {
        msh_auto_complete(prefix);
1002297c:	e51b0008 	ldr	r0, [fp, #-8]
10022980:	eb000b3c 	bl	10025678 <msh_auto_complete>
10022984:	ea000001 	b	10022990 <shell_auto_complete+0x40>
    else
#endif
    {
#ifndef FINSH_USING_MSH_ONLY
        extern void list_prefix(char * prefix);
        list_prefix(prefix);
10022988:	e51b0008 	ldr	r0, [fp, #-8]
1002298c:	eb00081a 	bl	100249fc <list_prefix>
#endif
    }

    rt_kprintf("%s%s", FINSH_PROMPT, prefix);
10022990:	ebffff0e 	bl	100225d0 <finsh_get_prompt>
10022994:	e1a03000 	mov	r3, r0
10022998:	e305011c 	movw	r0, #20764	; 0x511c
1002299c:	e3410003 	movt	r0, #4099	; 0x1003
100229a0:	e1a01003 	mov	r1, r3
100229a4:	e51b2008 	ldr	r2, [fp, #-8]
100229a8:	ebffc444 	bl	10013ac0 <rt_kprintf>
}
100229ac:	e24bd004 	sub	sp, fp, #4
100229b0:	e8bd8800 	pop	{fp, pc}

100229b4 <finsh_run_line>:

#ifndef FINSH_USING_MSH_ONLY
void finsh_run_line(struct finsh_parser *parser, const char *line)
{
100229b4:	e92d4830 	push	{r4, r5, fp, lr}
100229b8:	e28db00c 	add	fp, sp, #12
100229bc:	e24dd010 	sub	sp, sp, #16
100229c0:	e50b0018 	str	r0, [fp, #-24]
100229c4:	e50b101c 	str	r1, [fp, #-28]
    const char *err_str;

    rt_kprintf("\n");
100229c8:	e3050118 	movw	r0, #20760	; 0x5118
100229cc:	e3410003 	movt	r0, #4099	; 0x1003
100229d0:	ebffc43a 	bl	10013ac0 <rt_kprintf>
    finsh_parser_run(parser, (unsigned char *)line);
100229d4:	e51b0018 	ldr	r0, [fp, #-24]
100229d8:	e51b101c 	ldr	r1, [fp, #-28]
100229dc:	eb0029c2 	bl	1002d0ec <finsh_parser_run>

    /* compile node root */
    if (finsh_errno() == 0)
100229e0:	eb001a71 	bl	100293ac <finsh_errno>
100229e4:	e1a03000 	mov	r3, r0
100229e8:	e3530000 	cmp	r3, #0
100229ec:	1a000004 	bne	10022a04 <finsh_run_line+0x50>
    {
        finsh_compiler_run(parser->root);
100229f0:	e51b3018 	ldr	r3, [fp, #-24]
100229f4:	e5933098 	ldr	r3, [r3, #152]	; 0x98
100229f8:	e1a00003 	mov	r0, r3
100229fc:	eb001a13 	bl	10029250 <finsh_compiler_run>
10022a00:	ea000008 	b	10022a28 <finsh_run_line+0x74>
    }
    else
    {
        err_str = finsh_error_string(finsh_errno());
10022a04:	eb001a68 	bl	100293ac <finsh_errno>
10022a08:	e1a03000 	mov	r3, r0
10022a0c:	e1a00003 	mov	r0, r3
10022a10:	eb001a6e 	bl	100293d0 <finsh_error_string>
10022a14:	e50b0010 	str	r0, [fp, #-16]
        rt_kprintf("%s\n", err_str);
10022a18:	e3050124 	movw	r0, #20772	; 0x5124
10022a1c:	e3410003 	movt	r0, #4099	; 0x1003
10022a20:	e51b1010 	ldr	r1, [fp, #-16]
10022a24:	ebffc425 	bl	10013ac0 <rt_kprintf>
    }

    /* run virtual machine */
    if (finsh_errno() == 0)
10022a28:	eb001a5f 	bl	100293ac <finsh_errno>
10022a2c:	e1a03000 	mov	r3, r0
10022a30:	e3530000 	cmp	r3, #0
10022a34:	1a000022 	bne	10022ac4 <finsh_run_line+0x110>
    {
        char ch;
        finsh_vm_run();
10022a38:	eb002b81 	bl	1002d844 <finsh_vm_run>

        ch = (unsigned char)finsh_stack_bottom();
10022a3c:	eb001c31 	bl	10029b08 <finsh_stack_bottom>
10022a40:	e1a03000 	mov	r3, r0
10022a44:	e54b3011 	strb	r3, [fp, #-17]
        if (ch > 0x20 && ch < 0x7e)
10022a48:	e55b3011 	ldrb	r3, [fp, #-17]
10022a4c:	e3530020 	cmp	r3, #32
10022a50:	9a000011 	bls	10022a9c <finsh_run_line+0xe8>
10022a54:	e55b3011 	ldrb	r3, [fp, #-17]
10022a58:	e353007d 	cmp	r3, #125	; 0x7d
10022a5c:	8a00000e 	bhi	10022a9c <finsh_run_line+0xe8>
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
                       (unsigned char)finsh_stack_bottom(),
10022a60:	eb001c28 	bl	10029b08 <finsh_stack_bottom>
10022a64:	e1a03000 	mov	r3, r0
10022a68:	e6ef3073 	uxtb	r3, r3
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
10022a6c:	e1a05003 	mov	r5, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
10022a70:	eb001c24 	bl	10029b08 <finsh_stack_bottom>
10022a74:	e1a03000 	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
10022a78:	e1a04003 	mov	r4, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
10022a7c:	eb001c21 	bl	10029b08 <finsh_stack_bottom>
10022a80:	e1a03000 	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
10022a84:	e3050128 	movw	r0, #20776	; 0x5128
10022a88:	e3410003 	movt	r0, #4099	; 0x1003
10022a8c:	e1a01005 	mov	r1, r5
10022a90:	e1a02004 	mov	r2, r4
10022a94:	ebffc409 	bl	10013ac0 <rt_kprintf>
10022a98:	ea000009 	b	10022ac4 <finsh_run_line+0x110>
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
                       (unsigned int)finsh_stack_bottom(),
10022a9c:	eb001c19 	bl	10029b08 <finsh_stack_bottom>
10022aa0:	e1a03000 	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
10022aa4:	e1a04003 	mov	r4, r3
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
10022aa8:	eb001c16 	bl	10029b08 <finsh_stack_bottom>
10022aac:	e1a03000 	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
10022ab0:	e305013c 	movw	r0, #20796	; 0x513c
10022ab4:	e3410003 	movt	r0, #4099	; 0x1003
10022ab8:	e1a01004 	mov	r1, r4
10022abc:	e1a02003 	mov	r2, r3
10022ac0:	ebffc3fe 	bl	10013ac0 <rt_kprintf>
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
    }

    finsh_flush(parser);
10022ac4:	e51b0018 	ldr	r0, [fp, #-24]
10022ac8:	eb001c17 	bl	10029b2c <finsh_flush>
}
10022acc:	e24bd00c 	sub	sp, fp, #12
10022ad0:	e8bd8830 	pop	{r4, r5, fp, pc}

10022ad4 <shell_handle_history>:
#endif

#ifdef FINSH_USING_HISTORY
static rt_bool_t shell_handle_history(struct finsh_shell *shell)
{
10022ad4:	e92d4800 	push	{fp, lr}
10022ad8:	e28db004 	add	fp, sp, #4
10022adc:	e24dd008 	sub	sp, sp, #8
10022ae0:	e50b0008 	str	r0, [fp, #-8]
    for (i = 0; i <= 60; i++)
        putchar(' ');
    rt_kprintf("\r");

#else
    rt_kprintf("\033[2K\r");
10022ae4:	e305014c 	movw	r0, #20812	; 0x514c
10022ae8:	e3410003 	movt	r0, #4099	; 0x1003
10022aec:	ebffc3f3 	bl	10013ac0 <rt_kprintf>
#endif
    rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
10022af0:	ebfffeb6 	bl	100225d0 <finsh_get_prompt>
10022af4:	e1a02000 	mov	r2, r0
10022af8:	e51b3008 	ldr	r3, [fp, #-8]
10022afc:	e2833e25 	add	r3, r3, #592	; 0x250
10022b00:	e305011c 	movw	r0, #20764	; 0x511c
10022b04:	e3410003 	movt	r0, #4099	; 0x1003
10022b08:	e1a01002 	mov	r1, r2
10022b0c:	e1a02003 	mov	r2, r3
10022b10:	ebffc3ea 	bl	10013ac0 <rt_kprintf>
    return RT_FALSE;
10022b14:	e3a03000 	mov	r3, #0
}
10022b18:	e1a00003 	mov	r0, r3
10022b1c:	e24bd004 	sub	sp, fp, #4
10022b20:	e8bd8800 	pop	{fp, pc}

10022b24 <shell_push_history>:

static void shell_push_history(struct finsh_shell *shell)
{
10022b24:	e92d4800 	push	{fp, lr}
10022b28:	e28db004 	add	fp, sp, #4
10022b2c:	e24dd010 	sub	sp, sp, #16
10022b30:	e50b0010 	str	r0, [fp, #-16]
    if (shell->line_position != 0)
10022b34:	e51b3010 	ldr	r3, [fp, #-16]
10022b38:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10022b3c:	e3530000 	cmp	r3, #0
10022b40:	0a000065 	beq	10022cdc <shell_push_history+0x1b8>
    {
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
10022b44:	e51b3010 	ldr	r3, [fp, #-16]
10022b48:	e1d332b0 	ldrh	r3, [r3, #32]
10022b4c:	e3530004 	cmp	r3, #4
10022b50:	9a00003d 	bls	10022c4c <shell_push_history+0x128>
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
10022b54:	e3a03000 	mov	r3, #0
10022b58:	e50b3008 	str	r3, [fp, #-8]
10022b5c:	ea000017 	b	10022bc0 <shell_push_history+0x9c>
            {
                memcpy(&shell->cmd_history[index][0],
10022b60:	e51b3008 	ldr	r3, [fp, #-8]
10022b64:	e1a03203 	lsl	r3, r3, #4
10022b68:	e1a02103 	lsl	r2, r3, #2
10022b6c:	e0833002 	add	r3, r3, r2
10022b70:	e2833020 	add	r3, r3, #32
10022b74:	e51b2010 	ldr	r2, [fp, #-16]
10022b78:	e0823003 	add	r3, r2, r3
10022b7c:	e2831002 	add	r1, r3, #2
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
10022b80:	e51b3008 	ldr	r3, [fp, #-8]
10022b84:	e2833001 	add	r3, r3, #1
10022b88:	e1a03203 	lsl	r3, r3, #4
10022b8c:	e1a02103 	lsl	r2, r3, #2
10022b90:	e0833002 	add	r3, r3, r2
10022b94:	e2833020 	add	r3, r3, #32
10022b98:	e51b2010 	ldr	r2, [fp, #-16]
10022b9c:	e0823003 	add	r3, r2, r3
10022ba0:	e2833002 	add	r3, r3, #2
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
            {
                memcpy(&shell->cmd_history[index][0],
10022ba4:	e1a00001 	mov	r0, r1
10022ba8:	e1a01003 	mov	r1, r3
10022bac:	e3a02050 	mov	r2, #80	; 0x50
10022bb0:	fa0031cf 	blx	1002f2f4 <memcpy>
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
10022bb4:	e51b3008 	ldr	r3, [fp, #-8]
10022bb8:	e2833001 	add	r3, r3, #1
10022bbc:	e50b3008 	str	r3, [fp, #-8]
10022bc0:	e51b3008 	ldr	r3, [fp, #-8]
10022bc4:	e3530003 	cmp	r3, #3
10022bc8:	daffffe4 	ble	10022b60 <shell_push_history+0x3c>
            {
                memcpy(&shell->cmd_history[index][0],
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
            }
            memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
10022bcc:	e51b3008 	ldr	r3, [fp, #-8]
10022bd0:	e1a03203 	lsl	r3, r3, #4
10022bd4:	e1a02103 	lsl	r2, r3, #2
10022bd8:	e0833002 	add	r3, r3, r2
10022bdc:	e2833020 	add	r3, r3, #32
10022be0:	e51b2010 	ldr	r2, [fp, #-16]
10022be4:	e0823003 	add	r3, r2, r3
10022be8:	e2833002 	add	r3, r3, #2
10022bec:	e1a00003 	mov	r0, r3
10022bf0:	e3a01000 	mov	r1, #0
10022bf4:	e3a02050 	mov	r2, #80	; 0x50
10022bf8:	fa0031e7 	blx	1002f39c <memset>
            memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
10022bfc:	e51b3008 	ldr	r3, [fp, #-8]
10022c00:	e1a03203 	lsl	r3, r3, #4
10022c04:	e1a02103 	lsl	r2, r3, #2
10022c08:	e0833002 	add	r3, r3, r2
10022c0c:	e2833020 	add	r3, r3, #32
10022c10:	e51b2010 	ldr	r2, [fp, #-16]
10022c14:	e0823003 	add	r3, r2, r3
10022c18:	e2831002 	add	r1, r3, #2
10022c1c:	e51b3010 	ldr	r3, [fp, #-16]
10022c20:	e2832e25 	add	r2, r3, #592	; 0x250
10022c24:	e51b3010 	ldr	r3, [fp, #-16]
10022c28:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10022c2c:	e1a00001 	mov	r0, r1
10022c30:	e1a01002 	mov	r1, r2
10022c34:	e1a02003 	mov	r2, r3
10022c38:	fa0031ad 	blx	1002f2f4 <memcpy>

            /* it's the maximum history */
            shell->history_count = FINSH_HISTORY_LINES;
10022c3c:	e51b3010 	ldr	r3, [fp, #-16]
10022c40:	e3a02005 	mov	r2, #5
10022c44:	e1c322b0 	strh	r2, [r3, #32]
10022c48:	ea000023 	b	10022cdc <shell_push_history+0x1b8>
        }
        else
        {
            memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
10022c4c:	e51b3010 	ldr	r3, [fp, #-16]
10022c50:	e1d332b0 	ldrh	r3, [r3, #32]
10022c54:	e1a03203 	lsl	r3, r3, #4
10022c58:	e1a02103 	lsl	r2, r3, #2
10022c5c:	e0833002 	add	r3, r3, r2
10022c60:	e2833020 	add	r3, r3, #32
10022c64:	e51b2010 	ldr	r2, [fp, #-16]
10022c68:	e0823003 	add	r3, r2, r3
10022c6c:	e2833002 	add	r3, r3, #2
10022c70:	e1a00003 	mov	r0, r3
10022c74:	e3a01000 	mov	r1, #0
10022c78:	e3a02050 	mov	r2, #80	; 0x50
10022c7c:	fa0031c6 	blx	1002f39c <memset>
            memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
10022c80:	e51b3010 	ldr	r3, [fp, #-16]
10022c84:	e1d332b0 	ldrh	r3, [r3, #32]
10022c88:	e1a03203 	lsl	r3, r3, #4
10022c8c:	e1a02103 	lsl	r2, r3, #2
10022c90:	e0833002 	add	r3, r3, r2
10022c94:	e2833020 	add	r3, r3, #32
10022c98:	e51b2010 	ldr	r2, [fp, #-16]
10022c9c:	e0823003 	add	r3, r2, r3
10022ca0:	e2831002 	add	r1, r3, #2
10022ca4:	e51b3010 	ldr	r3, [fp, #-16]
10022ca8:	e2832e25 	add	r2, r3, #592	; 0x250
10022cac:	e51b3010 	ldr	r3, [fp, #-16]
10022cb0:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10022cb4:	e1a00001 	mov	r0, r1
10022cb8:	e1a01002 	mov	r1, r2
10022cbc:	e1a02003 	mov	r2, r3
10022cc0:	fa00318b 	blx	1002f2f4 <memcpy>

            /* increase count and set current history position */
            shell->history_count ++;
10022cc4:	e51b3010 	ldr	r3, [fp, #-16]
10022cc8:	e1d332b0 	ldrh	r3, [r3, #32]
10022ccc:	e2833001 	add	r3, r3, #1
10022cd0:	e6ff2073 	uxth	r2, r3
10022cd4:	e51b3010 	ldr	r3, [fp, #-16]
10022cd8:	e1c322b0 	strh	r2, [r3, #32]
        }
    }
    shell->current_history = shell->history_count;
10022cdc:	e51b3010 	ldr	r3, [fp, #-16]
10022ce0:	e1d322b0 	ldrh	r2, [r3, #32]
10022ce4:	e51b3010 	ldr	r3, [fp, #-16]
10022ce8:	e1c321be 	strh	r2, [r3, #30]
}
10022cec:	e24bd004 	sub	sp, fp, #4
10022cf0:	e8bd8800 	pop	{fp, pc}

10022cf4 <finsh_thread_entry>:

#ifndef RT_USING_HEAP
struct finsh_shell _shell;
#endif
void finsh_thread_entry(void *parameter)
{
10022cf4:	e92d4830 	push	{r4, r5, fp, lr}
10022cf8:	e28db00c 	add	fp, sp, #12
10022cfc:	e24dd018 	sub	sp, sp, #24
10022d00:	e50b0020 	str	r0, [fp, #-32]
    char ch;

    /* normal is echo mode */
    shell->echo_mode = 1;
10022d04:	e3033590 	movw	r3, #13712	; 0x3590
10022d08:	e3413004 	movt	r3, #4100	; 0x1004
10022d0c:	e5932000 	ldr	r2, [r3]
10022d10:	e5d2301d 	ldrb	r3, [r2, #29]
10022d14:	e3833001 	orr	r3, r3, #1
10022d18:	e5c2301d 	strb	r3, [r2, #29]

#ifndef FINSH_USING_MSH_ONLY
    finsh_init(&shell->parser);
10022d1c:	e3033590 	movw	r3, #13712	; 0x3590
10022d20:	e3413004 	movt	r3, #4100	; 0x1004
10022d24:	e5933000 	ldr	r3, [r3]
10022d28:	e2833f6d 	add	r3, r3, #436	; 0x1b4
10022d2c:	e1a00003 	mov	r0, r3
10022d30:	eb001b66 	bl	10029ad0 <finsh_init>
#endif
    rt_kprintf(FINSH_PROMPT);
10022d34:	ebfffe25 	bl	100225d0 <finsh_get_prompt>
10022d38:	e1a03000 	mov	r3, r0
10022d3c:	e1a00003 	mov	r0, r3
10022d40:	ebffc35e 	bl	10013ac0 <rt_kprintf>

    /* set console device as shell device */
    if (shell->device == RT_NULL)
10022d44:	e3033590 	movw	r3, #13712	; 0x3590
10022d48:	e3413004 	movt	r3, #4100	; 0x1004
10022d4c:	e5933000 	ldr	r3, [r3]
10022d50:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10022d54:	e3530000 	cmp	r3, #0
10022d58:	1a000020 	bne	10022de0 <finsh_thread_entry+0xec>
    {
#ifdef RT_USING_CONSOLE
        shell->device = rt_console_get_device();
10022d5c:	e3033590 	movw	r3, #13712	; 0x3590
10022d60:	e3413004 	movt	r3, #4100	; 0x1004
10022d64:	e5934000 	ldr	r4, [r3]
10022d68:	ebffc321 	bl	100139f4 <rt_console_get_device>
10022d6c:	e1a03000 	mov	r3, r0
10022d70:	e58432a4 	str	r3, [r4, #676]	; 0x2a4
        RT_ASSERT(shell->device);
10022d74:	e3033590 	movw	r3, #13712	; 0x3590
10022d78:	e3413004 	movt	r3, #4100	; 0x1004
10022d7c:	e5933000 	ldr	r3, [r3]
10022d80:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10022d84:	e3530000 	cmp	r3, #0
10022d88:	1a000005 	bne	10022da4 <finsh_thread_entry+0xb0>
10022d8c:	e3050154 	movw	r0, #20820	; 0x5154
10022d90:	e3410003 	movt	r0, #4099	; 0x1003
10022d94:	e30511fc 	movw	r1, #20988	; 0x51fc
10022d98:	e3411003 	movt	r1, #4099	; 0x1003
10022d9c:	e300213a 	movw	r2, #314	; 0x13a
10022da0:	ebffc403 	bl	10013db4 <rt_assert_handler>
        rt_device_set_rx_indicate(shell->device, finsh_rx_ind);
10022da4:	e3033590 	movw	r3, #13712	; 0x3590
10022da8:	e3413004 	movt	r3, #4100	; 0x1004
10022dac:	e5933000 	ldr	r3, [r3]
10022db0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10022db4:	e1a00003 	mov	r0, r3
10022db8:	e3021678 	movw	r1, #9848	; 0x2678
10022dbc:	e3411002 	movt	r1, #4098	; 0x1002
10022dc0:	ebffaf9b 	bl	1000ec34 <rt_device_set_rx_indicate>
        rt_device_open(shell->device, (RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_INT_RX));
10022dc4:	e3033590 	movw	r3, #13712	; 0x3590
10022dc8:	e3413004 	movt	r3, #4100	; 0x1004
10022dcc:	e5933000 	ldr	r3, [r3]
10022dd0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10022dd4:	e1a00003 	mov	r0, r3
10022dd8:	e3001143 	movw	r1, #323	; 0x143
10022ddc:	ebffae80 	bl	1000e7e4 <rt_device_open>
    }

    while (1)
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;
10022de0:	e3033590 	movw	r3, #13712	; 0x3590
10022de4:	e3413004 	movt	r3, #4100	; 0x1004
10022de8:	e5933000 	ldr	r3, [r3]
10022dec:	e1a00003 	mov	r0, r3
10022df0:	e3e01000 	mvn	r1, #0
10022df4:	ebffb19c 	bl	1000f46c <rt_sem_take>
10022df8:	e1a03000 	mov	r3, r0
10022dfc:	e3530000 	cmp	r3, #0
10022e00:	0a000000 	beq	10022e08 <finsh_thread_entry+0x114>
10022e04:	ea0002c0 	b	1002390c <finsh_thread_entry+0xc18>

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
10022e08:	ea0002b2 	b	100238d8 <finsh_thread_entry+0xbe4>
             * up key  : 0x1b 0x5b 0x41
             * down key: 0x1b 0x5b 0x42
             * right key:0x1b 0x5b 0x43
             * left key: 0x1b 0x5b 0x44
             */
            if (ch == 0x1b)
10022e0c:	e55b3019 	ldrb	r3, [fp, #-25]
10022e10:	e353001b 	cmp	r3, #27
10022e14:	1a000005 	bne	10022e30 <finsh_thread_entry+0x13c>
            {
                shell->stat = WAIT_SPEC_KEY;
10022e18:	e3033590 	movw	r3, #13712	; 0x3590
10022e1c:	e3413004 	movt	r3, #4100	; 0x1004
10022e20:	e5933000 	ldr	r3, [r3]
10022e24:	e3a02001 	mov	r2, #1
10022e28:	e5c3201c 	strb	r2, [r3, #28]
                continue;
10022e2c:	ea0002a9 	b	100238d8 <finsh_thread_entry+0xbe4>
            }
            else if (shell->stat == WAIT_SPEC_KEY)
10022e30:	e3033590 	movw	r3, #13712	; 0x3590
10022e34:	e3413004 	movt	r3, #4100	; 0x1004
10022e38:	e5933000 	ldr	r3, [r3]
10022e3c:	e5d3301c 	ldrb	r3, [r3, #28]
10022e40:	e3530001 	cmp	r3, #1
10022e44:	1a00000e 	bne	10022e84 <finsh_thread_entry+0x190>
            {
                if (ch == 0x5b)
10022e48:	e55b3019 	ldrb	r3, [fp, #-25]
10022e4c:	e353005b 	cmp	r3, #91	; 0x5b
10022e50:	1a000005 	bne	10022e6c <finsh_thread_entry+0x178>
                {
                    shell->stat = WAIT_FUNC_KEY;
10022e54:	e3033590 	movw	r3, #13712	; 0x3590
10022e58:	e3413004 	movt	r3, #4100	; 0x1004
10022e5c:	e5933000 	ldr	r3, [r3]
10022e60:	e3a02002 	mov	r2, #2
10022e64:	e5c3201c 	strb	r2, [r3, #28]
                    continue;
10022e68:	ea00029a 	b	100238d8 <finsh_thread_entry+0xbe4>
                }

                shell->stat = WAIT_NORMAL;
10022e6c:	e3033590 	movw	r3, #13712	; 0x3590
10022e70:	e3413004 	movt	r3, #4100	; 0x1004
10022e74:	e5933000 	ldr	r3, [r3]
10022e78:	e3a02000 	mov	r2, #0
10022e7c:	e5c3201c 	strb	r2, [r3, #28]
10022e80:	ea0000d5 	b	100231dc <finsh_thread_entry+0x4e8>
            }
            else if (shell->stat == WAIT_FUNC_KEY)
10022e84:	e3033590 	movw	r3, #13712	; 0x3590
10022e88:	e3413004 	movt	r3, #4100	; 0x1004
10022e8c:	e5933000 	ldr	r3, [r3]
10022e90:	e5d3301c 	ldrb	r3, [r3, #28]
10022e94:	e3530002 	cmp	r3, #2
10022e98:	1a0000cf 	bne	100231dc <finsh_thread_entry+0x4e8>
            {
                shell->stat = WAIT_NORMAL;
10022e9c:	e3033590 	movw	r3, #13712	; 0x3590
10022ea0:	e3413004 	movt	r3, #4100	; 0x1004
10022ea4:	e5933000 	ldr	r3, [r3]
10022ea8:	e3a02000 	mov	r2, #0
10022eac:	e5c3201c 	strb	r2, [r3, #28]

                if (ch == 0x41) /* up key */
10022eb0:	e55b3019 	ldrb	r3, [fp, #-25]
10022eb4:	e3530041 	cmp	r3, #65	; 0x41
10022eb8:	1a00003d 	bne	10022fb4 <finsh_thread_entry+0x2c0>
                {
#ifdef FINSH_USING_HISTORY
                    /* prev history */
                    if (shell->current_history > 0)
10022ebc:	e3033590 	movw	r3, #13712	; 0x3590
10022ec0:	e3413004 	movt	r3, #4100	; 0x1004
10022ec4:	e5933000 	ldr	r3, [r3]
10022ec8:	e1d331be 	ldrh	r3, [r3, #30]
10022ecc:	e3530000 	cmp	r3, #0
10022ed0:	0a000031 	beq	10022f9c <finsh_thread_entry+0x2a8>
                        shell->current_history --;
10022ed4:	e3033590 	movw	r3, #13712	; 0x3590
10022ed8:	e3413004 	movt	r3, #4100	; 0x1004
10022edc:	e5933000 	ldr	r3, [r3]
10022ee0:	e1d321be 	ldrh	r2, [r3, #30]
10022ee4:	e2422001 	sub	r2, r2, #1
10022ee8:	e6ff2072 	uxth	r2, r2
10022eec:	e1c321be 	strh	r2, [r3, #30]
                        shell->current_history = 0;
                        continue;
                    }

                    /* copy the history command */
                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
10022ef0:	e3033590 	movw	r3, #13712	; 0x3590
10022ef4:	e3413004 	movt	r3, #4100	; 0x1004
10022ef8:	e5933000 	ldr	r3, [r3]
10022efc:	e2830e25 	add	r0, r3, #592	; 0x250
10022f00:	e3033590 	movw	r3, #13712	; 0x3590
10022f04:	e3413004 	movt	r3, #4100	; 0x1004
10022f08:	e5932000 	ldr	r2, [r3]
10022f0c:	e3033590 	movw	r3, #13712	; 0x3590
10022f10:	e3413004 	movt	r3, #4100	; 0x1004
10022f14:	e5933000 	ldr	r3, [r3]
10022f18:	e1d331be 	ldrh	r3, [r3, #30]
10022f1c:	e1a03203 	lsl	r3, r3, #4
10022f20:	e1a01103 	lsl	r1, r3, #2
10022f24:	e0833001 	add	r3, r3, r1
10022f28:	e2833020 	add	r3, r3, #32
10022f2c:	e0823003 	add	r3, r2, r3
10022f30:	e2833002 	add	r3, r3, #2
10022f34:	e1a01003 	mov	r1, r3
10022f38:	e3a02050 	mov	r2, #80	; 0x50
10022f3c:	fa0030ec 	blx	1002f2f4 <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
10022f40:	e3033590 	movw	r3, #13712	; 0x3590
10022f44:	e3413004 	movt	r3, #4100	; 0x1004
10022f48:	e5935000 	ldr	r5, [r3]
10022f4c:	e3033590 	movw	r3, #13712	; 0x3590
10022f50:	e3413004 	movt	r3, #4100	; 0x1004
10022f54:	e5934000 	ldr	r4, [r3]
10022f58:	e3033590 	movw	r3, #13712	; 0x3590
10022f5c:	e3413004 	movt	r3, #4100	; 0x1004
10022f60:	e5933000 	ldr	r3, [r3]
10022f64:	e2833e25 	add	r3, r3, #592	; 0x250
10022f68:	e1a00003 	mov	r0, r3
10022f6c:	fa00320d 	blx	1002f7a8 <strlen>
10022f70:	e1a03000 	mov	r3, r0
10022f74:	e6ef3073 	uxtb	r3, r3
10022f78:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
10022f7c:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
10022f80:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1
                    shell_handle_history(shell);
10022f84:	e3033590 	movw	r3, #13712	; 0x3590
10022f88:	e3413004 	movt	r3, #4100	; 0x1004
10022f8c:	e5933000 	ldr	r3, [r3]
10022f90:	e1a00003 	mov	r0, r3
10022f94:	ebfffece 	bl	10022ad4 <shell_handle_history>
#endif
                    continue;
10022f98:	ea00024e 	b	100238d8 <finsh_thread_entry+0xbe4>
                    /* prev history */
                    if (shell->current_history > 0)
                        shell->current_history --;
                    else
                    {
                        shell->current_history = 0;
10022f9c:	e3033590 	movw	r3, #13712	; 0x3590
10022fa0:	e3413004 	movt	r3, #4100	; 0x1004
10022fa4:	e5933000 	ldr	r3, [r3]
10022fa8:	e3a02000 	mov	r2, #0
10022fac:	e1c321be 	strh	r2, [r3, #30]
                        continue;
10022fb0:	ea000248 	b	100238d8 <finsh_thread_entry+0xbe4>
                    shell->line_curpos = shell->line_position = strlen(shell->line);
                    shell_handle_history(shell);
#endif
                    continue;
                }
                else if (ch == 0x42) /* down key */
10022fb4:	e55b3019 	ldrb	r3, [fp, #-25]
10022fb8:	e3530042 	cmp	r3, #66	; 0x42
10022fbc:	1a000050 	bne	10023104 <finsh_thread_entry+0x410>
                {
#ifdef FINSH_USING_HISTORY
                    /* next history */
                    if (shell->current_history < shell->history_count - 1)
10022fc0:	e3033590 	movw	r3, #13712	; 0x3590
10022fc4:	e3413004 	movt	r3, #4100	; 0x1004
10022fc8:	e5933000 	ldr	r3, [r3]
10022fcc:	e1d331be 	ldrh	r3, [r3, #30]
10022fd0:	e1a02003 	mov	r2, r3
10022fd4:	e3033590 	movw	r3, #13712	; 0x3590
10022fd8:	e3413004 	movt	r3, #4100	; 0x1004
10022fdc:	e5933000 	ldr	r3, [r3]
10022fe0:	e1d332b0 	ldrh	r3, [r3, #32]
10022fe4:	e2433001 	sub	r3, r3, #1
10022fe8:	e1520003 	cmp	r2, r3
10022fec:	aa000007 	bge	10023010 <finsh_thread_entry+0x31c>
                        shell->current_history ++;
10022ff0:	e3033590 	movw	r3, #13712	; 0x3590
10022ff4:	e3413004 	movt	r3, #4100	; 0x1004
10022ff8:	e5933000 	ldr	r3, [r3]
10022ffc:	e1d321be 	ldrh	r2, [r3, #30]
10023000:	e2822001 	add	r2, r2, #1
10023004:	e6ff2072 	uxth	r2, r2
10023008:	e1c321be 	strh	r2, [r3, #30]
1002300c:	ea000011 	b	10023058 <finsh_thread_entry+0x364>
                    else
                    {
                        /* set to the end of history */
                        if (shell->history_count != 0)
10023010:	e3033590 	movw	r3, #13712	; 0x3590
10023014:	e3413004 	movt	r3, #4100	; 0x1004
10023018:	e5933000 	ldr	r3, [r3]
1002301c:	e1d332b0 	ldrh	r3, [r3, #32]
10023020:	e3530000 	cmp	r3, #0
10023024:	0a00000a 	beq	10023054 <finsh_thread_entry+0x360>
                            shell->current_history = shell->history_count - 1;
10023028:	e3033590 	movw	r3, #13712	; 0x3590
1002302c:	e3413004 	movt	r3, #4100	; 0x1004
10023030:	e5932000 	ldr	r2, [r3]
10023034:	e3033590 	movw	r3, #13712	; 0x3590
10023038:	e3413004 	movt	r3, #4100	; 0x1004
1002303c:	e5933000 	ldr	r3, [r3]
10023040:	e1d332b0 	ldrh	r3, [r3, #32]
10023044:	e2433001 	sub	r3, r3, #1
10023048:	e6ff3073 	uxth	r3, r3
1002304c:	e1c231be 	strh	r3, [r2, #30]
10023050:	ea000000 	b	10023058 <finsh_thread_entry+0x364>
                        else
                            continue;
10023054:	ea00021f 	b	100238d8 <finsh_thread_entry+0xbe4>
                    }

                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
10023058:	e3033590 	movw	r3, #13712	; 0x3590
1002305c:	e3413004 	movt	r3, #4100	; 0x1004
10023060:	e5933000 	ldr	r3, [r3]
10023064:	e2830e25 	add	r0, r3, #592	; 0x250
10023068:	e3033590 	movw	r3, #13712	; 0x3590
1002306c:	e3413004 	movt	r3, #4100	; 0x1004
10023070:	e5932000 	ldr	r2, [r3]
10023074:	e3033590 	movw	r3, #13712	; 0x3590
10023078:	e3413004 	movt	r3, #4100	; 0x1004
1002307c:	e5933000 	ldr	r3, [r3]
10023080:	e1d331be 	ldrh	r3, [r3, #30]
10023084:	e1a03203 	lsl	r3, r3, #4
10023088:	e1a01103 	lsl	r1, r3, #2
1002308c:	e0833001 	add	r3, r3, r1
10023090:	e2833020 	add	r3, r3, #32
10023094:	e0823003 	add	r3, r2, r3
10023098:	e2833002 	add	r3, r3, #2
1002309c:	e1a01003 	mov	r1, r3
100230a0:	e3a02050 	mov	r2, #80	; 0x50
100230a4:	fa003092 	blx	1002f2f4 <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
100230a8:	e3033590 	movw	r3, #13712	; 0x3590
100230ac:	e3413004 	movt	r3, #4100	; 0x1004
100230b0:	e5935000 	ldr	r5, [r3]
100230b4:	e3033590 	movw	r3, #13712	; 0x3590
100230b8:	e3413004 	movt	r3, #4100	; 0x1004
100230bc:	e5934000 	ldr	r4, [r3]
100230c0:	e3033590 	movw	r3, #13712	; 0x3590
100230c4:	e3413004 	movt	r3, #4100	; 0x1004
100230c8:	e5933000 	ldr	r3, [r3]
100230cc:	e2833e25 	add	r3, r3, #592	; 0x250
100230d0:	e1a00003 	mov	r0, r3
100230d4:	fa0031b3 	blx	1002f7a8 <strlen>
100230d8:	e1a03000 	mov	r3, r0
100230dc:	e6ef3073 	uxtb	r3, r3
100230e0:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
100230e4:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
100230e8:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1
                    shell_handle_history(shell);
100230ec:	e3033590 	movw	r3, #13712	; 0x3590
100230f0:	e3413004 	movt	r3, #4100	; 0x1004
100230f4:	e5933000 	ldr	r3, [r3]
100230f8:	e1a00003 	mov	r0, r3
100230fc:	ebfffe74 	bl	10022ad4 <shell_handle_history>
#endif
                    continue;
10023100:	ea0001f4 	b	100238d8 <finsh_thread_entry+0xbe4>
                }
                else if (ch == 0x44) /* left key */
10023104:	e55b3019 	ldrb	r3, [fp, #-25]
10023108:	e3530044 	cmp	r3, #68	; 0x44
1002310c:	1a000010 	bne	10023154 <finsh_thread_entry+0x460>
                {
                    if (shell->line_curpos)
10023110:	e3033590 	movw	r3, #13712	; 0x3590
10023114:	e3413004 	movt	r3, #4100	; 0x1004
10023118:	e5933000 	ldr	r3, [r3]
1002311c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10023120:	e3530000 	cmp	r3, #0
10023124:	0a000009 	beq	10023150 <finsh_thread_entry+0x45c>
                    {
                        rt_kprintf("\b");
10023128:	e3050164 	movw	r0, #20836	; 0x5164
1002312c:	e3410003 	movt	r0, #4099	; 0x1003
10023130:	ebffc262 	bl	10013ac0 <rt_kprintf>
                        shell->line_curpos --;
10023134:	e3033590 	movw	r3, #13712	; 0x3590
10023138:	e3413004 	movt	r3, #4100	; 0x1004
1002313c:	e5933000 	ldr	r3, [r3]
10023140:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
10023144:	e2422001 	sub	r2, r2, #1
10023148:	e6ef2072 	uxtb	r2, r2
1002314c:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
                    }

                    continue;
10023150:	ea0001e0 	b	100238d8 <finsh_thread_entry+0xbe4>
                }
                else if (ch == 0x43) /* right key */
10023154:	e55b3019 	ldrb	r3, [fp, #-25]
10023158:	e3530043 	cmp	r3, #67	; 0x43
1002315c:	1a00001e 	bne	100231dc <finsh_thread_entry+0x4e8>
                {
                    if (shell->line_curpos < shell->line_position)
10023160:	e3033590 	movw	r3, #13712	; 0x3590
10023164:	e3413004 	movt	r3, #4100	; 0x1004
10023168:	e5933000 	ldr	r3, [r3]
1002316c:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
10023170:	e3033590 	movw	r3, #13712	; 0x3590
10023174:	e3413004 	movt	r3, #4100	; 0x1004
10023178:	e5933000 	ldr	r3, [r3]
1002317c:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10023180:	e1520003 	cmp	r2, r3
10023184:	2a000013 	bcs	100231d8 <finsh_thread_entry+0x4e4>
                    {
                        rt_kprintf("%c", shell->line[shell->line_curpos]);
10023188:	e3033590 	movw	r3, #13712	; 0x3590
1002318c:	e3413004 	movt	r3, #4100	; 0x1004
10023190:	e5932000 	ldr	r2, [r3]
10023194:	e3033590 	movw	r3, #13712	; 0x3590
10023198:	e3413004 	movt	r3, #4100	; 0x1004
1002319c:	e5933000 	ldr	r3, [r3]
100231a0:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100231a4:	e0823003 	add	r3, r2, r3
100231a8:	e5d33250 	ldrb	r3, [r3, #592]	; 0x250
100231ac:	e3050168 	movw	r0, #20840	; 0x5168
100231b0:	e3410003 	movt	r0, #4099	; 0x1003
100231b4:	e1a01003 	mov	r1, r3
100231b8:	ebffc240 	bl	10013ac0 <rt_kprintf>
                        shell->line_curpos ++;
100231bc:	e3033590 	movw	r3, #13712	; 0x3590
100231c0:	e3413004 	movt	r3, #4100	; 0x1004
100231c4:	e5933000 	ldr	r3, [r3]
100231c8:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
100231cc:	e2822001 	add	r2, r2, #1
100231d0:	e6ef2072 	uxtb	r2, r2
100231d4:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
                    }

                    continue;
100231d8:	ea0001be 	b	100238d8 <finsh_thread_entry+0xbe4>
                }

            }

            /* handle CR key */
            if (ch == '\r')
100231dc:	e55b3019 	ldrb	r3, [fp, #-25]
100231e0:	e353000d 	cmp	r3, #13
100231e4:	1a000018 	bne	1002324c <finsh_thread_entry+0x558>
            {
                char next;

                if (rt_device_read(shell->device, 0, &next, 1) == 1)
100231e8:	e3033590 	movw	r3, #13712	; 0x3590
100231ec:	e3413004 	movt	r3, #4100	; 0x1004
100231f0:	e5933000 	ldr	r3, [r3]
100231f4:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
100231f8:	e24b301a 	sub	r3, fp, #26
100231fc:	e1a00002 	mov	r0, r2
10023200:	e3a01000 	mov	r1, #0
10023204:	e1a02003 	mov	r2, r3
10023208:	e3a03001 	mov	r3, #1
1002320c:	ebffae11 	bl	1000ea58 <rt_device_read>
10023210:	e1a03000 	mov	r3, r0
10023214:	e3530001 	cmp	r3, #1
10023218:	1a000008 	bne	10023240 <finsh_thread_entry+0x54c>
                {
                    if (next == '\0') ch = 'r'; /* linux telnet will issue '\0' */
1002321c:	e55b301a 	ldrb	r3, [fp, #-26]
10023220:	e3530000 	cmp	r3, #0
10023224:	1a000002 	bne	10023234 <finsh_thread_entry+0x540>
10023228:	e3a03072 	mov	r3, #114	; 0x72
1002322c:	e54b3019 	strb	r3, [fp, #-25]
10023230:	ea0000b1 	b	100234fc <finsh_thread_entry+0x808>
                    else ch = next;
10023234:	e55b301a 	ldrb	r3, [fp, #-26]
10023238:	e54b3019 	strb	r3, [fp, #-25]
1002323c:	ea0000ae 	b	100234fc <finsh_thread_entry+0x808>
                }
                else ch = '\r';
10023240:	e3a0300d 	mov	r3, #13
10023244:	e54b3019 	strb	r3, [fp, #-25]
10023248:	ea0000ab 	b	100234fc <finsh_thread_entry+0x808>
            }
            /* handle tab key */
            else if (ch == '\t')
1002324c:	e55b3019 	ldrb	r3, [fp, #-25]
10023250:	e3530009 	cmp	r3, #9
10023254:	1a000028 	bne	100232fc <finsh_thread_entry+0x608>
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
10023258:	e3a03000 	mov	r3, #0
1002325c:	e50b3010 	str	r3, [fp, #-16]
10023260:	ea000005 	b	1002327c <finsh_thread_entry+0x588>
                    rt_kprintf("\b");
10023264:	e3050164 	movw	r0, #20836	; 0x5164
10023268:	e3410003 	movt	r0, #4099	; 0x1003
1002326c:	ebffc213 	bl	10013ac0 <rt_kprintf>
            /* handle tab key */
            else if (ch == '\t')
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
10023270:	e51b3010 	ldr	r3, [fp, #-16]
10023274:	e2833001 	add	r3, r3, #1
10023278:	e50b3010 	str	r3, [fp, #-16]
1002327c:	e3033590 	movw	r3, #13712	; 0x3590
10023280:	e3413004 	movt	r3, #4100	; 0x1004
10023284:	e5933000 	ldr	r3, [r3]
10023288:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
1002328c:	e1a02003 	mov	r2, r3
10023290:	e51b3010 	ldr	r3, [fp, #-16]
10023294:	e1520003 	cmp	r2, r3
10023298:	cafffff1 	bgt	10023264 <finsh_thread_entry+0x570>
                    rt_kprintf("\b");

                /* auto complete */
                shell_auto_complete(&shell->line[0]);
1002329c:	e3033590 	movw	r3, #13712	; 0x3590
100232a0:	e3413004 	movt	r3, #4100	; 0x1004
100232a4:	e5933000 	ldr	r3, [r3]
100232a8:	e2833e25 	add	r3, r3, #592	; 0x250
100232ac:	e1a00003 	mov	r0, r3
100232b0:	ebfffda6 	bl	10022950 <shell_auto_complete>
                /* re-calculate position */
                shell->line_curpos = shell->line_position = strlen(shell->line);
100232b4:	e3033590 	movw	r3, #13712	; 0x3590
100232b8:	e3413004 	movt	r3, #4100	; 0x1004
100232bc:	e5935000 	ldr	r5, [r3]
100232c0:	e3033590 	movw	r3, #13712	; 0x3590
100232c4:	e3413004 	movt	r3, #4100	; 0x1004
100232c8:	e5934000 	ldr	r4, [r3]
100232cc:	e3033590 	movw	r3, #13712	; 0x3590
100232d0:	e3413004 	movt	r3, #4100	; 0x1004
100232d4:	e5933000 	ldr	r3, [r3]
100232d8:	e2833e25 	add	r3, r3, #592	; 0x250
100232dc:	e1a00003 	mov	r0, r3
100232e0:	fa003130 	blx	1002f7a8 <strlen>
100232e4:	e1a03000 	mov	r3, r0
100232e8:	e6ef3073 	uxtb	r3, r3
100232ec:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
100232f0:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
100232f4:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1

                continue;
100232f8:	ea000176 	b	100238d8 <finsh_thread_entry+0xbe4>
            }
            /* handle backspace key */
            else if (ch == 0x7f || ch == 0x08)
100232fc:	e55b3019 	ldrb	r3, [fp, #-25]
10023300:	e353007f 	cmp	r3, #127	; 0x7f
10023304:	0a000002 	beq	10023314 <finsh_thread_entry+0x620>
10023308:	e55b3019 	ldrb	r3, [fp, #-25]
1002330c:	e3530008 	cmp	r3, #8
10023310:	1a000079 	bne	100234fc <finsh_thread_entry+0x808>
            {
                /* note that shell->line_curpos >= 0 */
                if (shell->line_curpos == 0)
10023314:	e3033590 	movw	r3, #13712	; 0x3590
10023318:	e3413004 	movt	r3, #4100	; 0x1004
1002331c:	e5933000 	ldr	r3, [r3]
10023320:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10023324:	e3530000 	cmp	r3, #0
10023328:	1a000000 	bne	10023330 <finsh_thread_entry+0x63c>
                    continue;
1002332c:	ea000169 	b	100238d8 <finsh_thread_entry+0xbe4>

                shell->line_position--;
10023330:	e3033590 	movw	r3, #13712	; 0x3590
10023334:	e3413004 	movt	r3, #4100	; 0x1004
10023338:	e5933000 	ldr	r3, [r3]
1002333c:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
10023340:	e2422001 	sub	r2, r2, #1
10023344:	e6ef2072 	uxtb	r2, r2
10023348:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
                shell->line_curpos--;
1002334c:	e3033590 	movw	r3, #13712	; 0x3590
10023350:	e3413004 	movt	r3, #4100	; 0x1004
10023354:	e5933000 	ldr	r3, [r3]
10023358:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
1002335c:	e2422001 	sub	r2, r2, #1
10023360:	e6ef2072 	uxtb	r2, r2
10023364:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1

                if (shell->line_position > shell->line_curpos)
10023368:	e3033590 	movw	r3, #13712	; 0x3590
1002336c:	e3413004 	movt	r3, #4100	; 0x1004
10023370:	e5933000 	ldr	r3, [r3]
10023374:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
10023378:	e3033590 	movw	r3, #13712	; 0x3590
1002337c:	e3413004 	movt	r3, #4100	; 0x1004
10023380:	e5933000 	ldr	r3, [r3]
10023384:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10023388:	e1520003 	cmp	r2, r3
1002338c:	9a00004c 	bls	100234c4 <finsh_thread_entry+0x7d0>
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
10023390:	e3033590 	movw	r3, #13712	; 0x3590
10023394:	e3413004 	movt	r3, #4100	; 0x1004
10023398:	e5932000 	ldr	r2, [r3]
1002339c:	e3033590 	movw	r3, #13712	; 0x3590
100233a0:	e3413004 	movt	r3, #4100	; 0x1004
100233a4:	e5933000 	ldr	r3, [r3]
100233a8:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100233ac:	e2833e25 	add	r3, r3, #592	; 0x250
100233b0:	e0821003 	add	r1, r2, r3
                               &shell->line[shell->line_curpos + 1],
100233b4:	e3033590 	movw	r3, #13712	; 0x3590
100233b8:	e3413004 	movt	r3, #4100	; 0x1004
100233bc:	e5932000 	ldr	r2, [r3]
100233c0:	e3033590 	movw	r3, #13712	; 0x3590
100233c4:	e3413004 	movt	r3, #4100	; 0x1004
100233c8:	e5933000 	ldr	r3, [r3]
100233cc:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100233d0:	e2833001 	add	r3, r3, #1
100233d4:	e2833e25 	add	r3, r3, #592	; 0x250
100233d8:	e0822003 	add	r2, r2, r3
                               shell->line_position - shell->line_curpos);
100233dc:	e3033590 	movw	r3, #13712	; 0x3590
100233e0:	e3413004 	movt	r3, #4100	; 0x1004
100233e4:	e5933000 	ldr	r3, [r3]
100233e8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100233ec:	e1a00003 	mov	r0, r3
100233f0:	e3033590 	movw	r3, #13712	; 0x3590
100233f4:	e3413004 	movt	r3, #4100	; 0x1004
100233f8:	e5933000 	ldr	r3, [r3]
100233fc:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10023400:	e0633000 	rsb	r3, r3, r0

                if (shell->line_position > shell->line_curpos)
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
10023404:	e1a00001 	mov	r0, r1
10023408:	e1a01002 	mov	r1, r2
1002340c:	e1a02003 	mov	r2, r3
10023410:	ebffbc4e 	bl	10012550 <rt_memmove>
                               &shell->line[shell->line_curpos + 1],
                               shell->line_position - shell->line_curpos);
                    shell->line[shell->line_position] = 0;
10023414:	e3033590 	movw	r3, #13712	; 0x3590
10023418:	e3413004 	movt	r3, #4100	; 0x1004
1002341c:	e5932000 	ldr	r2, [r3]
10023420:	e3033590 	movw	r3, #13712	; 0x3590
10023424:	e3413004 	movt	r3, #4100	; 0x1004
10023428:	e5933000 	ldr	r3, [r3]
1002342c:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10023430:	e0823003 	add	r3, r2, r3
10023434:	e3a02000 	mov	r2, #0
10023438:	e5c32250 	strb	r2, [r3, #592]	; 0x250

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
1002343c:	e3033590 	movw	r3, #13712	; 0x3590
10023440:	e3413004 	movt	r3, #4100	; 0x1004
10023444:	e5932000 	ldr	r2, [r3]
10023448:	e3033590 	movw	r3, #13712	; 0x3590
1002344c:	e3413004 	movt	r3, #4100	; 0x1004
10023450:	e5933000 	ldr	r3, [r3]
10023454:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10023458:	e2833e25 	add	r3, r3, #592	; 0x250
1002345c:	e0823003 	add	r3, r2, r3
10023460:	e305016c 	movw	r0, #20844	; 0x516c
10023464:	e3410003 	movt	r0, #4099	; 0x1003
10023468:	e1a01003 	mov	r1, r3
1002346c:	ebffc193 	bl	10013ac0 <rt_kprintf>

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
10023470:	e3033590 	movw	r3, #13712	; 0x3590
10023474:	e3413004 	movt	r3, #4100	; 0x1004
10023478:	e5933000 	ldr	r3, [r3]
1002347c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10023480:	e50b3014 	str	r3, [fp, #-20]
10023484:	ea000005 	b	100234a0 <finsh_thread_entry+0x7ac>
                        rt_kprintf("\b");
10023488:	e3050164 	movw	r0, #20836	; 0x5164
1002348c:	e3410003 	movt	r0, #4099	; 0x1003
10023490:	ebffc18a 	bl	10013ac0 <rt_kprintf>
                    shell->line[shell->line_position] = 0;

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
10023494:	e51b3014 	ldr	r3, [fp, #-20]
10023498:	e2833001 	add	r3, r3, #1
1002349c:	e50b3014 	str	r3, [fp, #-20]
100234a0:	e3033590 	movw	r3, #13712	; 0x3590
100234a4:	e3413004 	movt	r3, #4100	; 0x1004
100234a8:	e5933000 	ldr	r3, [r3]
100234ac:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100234b0:	e1a02003 	mov	r2, r3
100234b4:	e51b3014 	ldr	r3, [fp, #-20]
100234b8:	e1520003 	cmp	r2, r3
100234bc:	aafffff1 	bge	10023488 <finsh_thread_entry+0x794>
100234c0:	ea00000c 	b	100234f8 <finsh_thread_entry+0x804>
                        rt_kprintf("\b");
                }
                else
                {
                    rt_kprintf("\b \b");
100234c4:	e3050174 	movw	r0, #20852	; 0x5174
100234c8:	e3410003 	movt	r0, #4099	; 0x1003
100234cc:	ebffc17b 	bl	10013ac0 <rt_kprintf>
                    shell->line[shell->line_position] = 0;
100234d0:	e3033590 	movw	r3, #13712	; 0x3590
100234d4:	e3413004 	movt	r3, #4100	; 0x1004
100234d8:	e5932000 	ldr	r2, [r3]
100234dc:	e3033590 	movw	r3, #13712	; 0x3590
100234e0:	e3413004 	movt	r3, #4100	; 0x1004
100234e4:	e5933000 	ldr	r3, [r3]
100234e8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100234ec:	e0823003 	add	r3, r2, r3
100234f0:	e3a02000 	mov	r2, #0
100234f4:	e5c32250 	strb	r2, [r3, #592]	; 0x250
                }

                continue;
100234f8:	ea0000f6 	b	100238d8 <finsh_thread_entry+0xbe4>
            }

            /* handle end of line, break */
            if (ch == '\r' || ch == '\n')
100234fc:	e55b3019 	ldrb	r3, [fp, #-25]
10023500:	e353000d 	cmp	r3, #13
10023504:	0a000002 	beq	10023514 <finsh_thread_entry+0x820>
10023508:	e55b3019 	ldrb	r3, [fp, #-25]
1002350c:	e353000a 	cmp	r3, #10
10023510:	1a00004d 	bne	1002364c <finsh_thread_entry+0x958>
            {
#ifdef FINSH_USING_HISTORY
                shell_push_history(shell);
10023514:	e3033590 	movw	r3, #13712	; 0x3590
10023518:	e3413004 	movt	r3, #4100	; 0x1004
1002351c:	e5933000 	ldr	r3, [r3]
10023520:	e1a00003 	mov	r0, r3
10023524:	ebfffd7e 	bl	10022b24 <shell_push_history>
#endif

#ifdef FINSH_USING_MSH
                if (msh_is_used() == RT_TRUE)
10023528:	eb00067a 	bl	10024f18 <msh_is_used>
1002352c:	e1a03000 	mov	r3, r0
10023530:	e3530001 	cmp	r3, #1
10023534:	1a00000e 	bne	10023574 <finsh_thread_entry+0x880>
                {
                    rt_kprintf("\n");
10023538:	e3050118 	movw	r0, #20760	; 0x5118
1002353c:	e3410003 	movt	r0, #4099	; 0x1003
10023540:	ebffc15e 	bl	10013ac0 <rt_kprintf>
                    msh_exec(shell->line, shell->line_position);
10023544:	e3033590 	movw	r3, #13712	; 0x3590
10023548:	e3413004 	movt	r3, #4100	; 0x1004
1002354c:	e5933000 	ldr	r3, [r3]
10023550:	e2832e25 	add	r2, r3, #592	; 0x250
10023554:	e3033590 	movw	r3, #13712	; 0x3590
10023558:	e3413004 	movt	r3, #4100	; 0x1004
1002355c:	e5933000 	ldr	r3, [r3]
10023560:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10023564:	e1a00002 	mov	r0, r2
10023568:	e1a01003 	mov	r1, r3
1002356c:	eb0007e2 	bl	100254fc <msh_exec>
10023570:	ea00001e 	b	100235f0 <finsh_thread_entry+0x8fc>
                else
#endif
                {
#ifndef FINSH_USING_MSH_ONLY
                    /* add ';' and run the command line */
                    shell->line[shell->line_position] = ';';
10023574:	e3033590 	movw	r3, #13712	; 0x3590
10023578:	e3413004 	movt	r3, #4100	; 0x1004
1002357c:	e5932000 	ldr	r2, [r3]
10023580:	e3033590 	movw	r3, #13712	; 0x3590
10023584:	e3413004 	movt	r3, #4100	; 0x1004
10023588:	e5933000 	ldr	r3, [r3]
1002358c:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10023590:	e0823003 	add	r3, r2, r3
10023594:	e3a0203b 	mov	r2, #59	; 0x3b
10023598:	e5c32250 	strb	r2, [r3, #592]	; 0x250

                    if (shell->line_position != 0) finsh_run_line(&shell->parser, shell->line);
1002359c:	e3033590 	movw	r3, #13712	; 0x3590
100235a0:	e3413004 	movt	r3, #4100	; 0x1004
100235a4:	e5933000 	ldr	r3, [r3]
100235a8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100235ac:	e3530000 	cmp	r3, #0
100235b0:	0a00000b 	beq	100235e4 <finsh_thread_entry+0x8f0>
100235b4:	e3033590 	movw	r3, #13712	; 0x3590
100235b8:	e3413004 	movt	r3, #4100	; 0x1004
100235bc:	e5933000 	ldr	r3, [r3]
100235c0:	e2832f6d 	add	r2, r3, #436	; 0x1b4
100235c4:	e3033590 	movw	r3, #13712	; 0x3590
100235c8:	e3413004 	movt	r3, #4100	; 0x1004
100235cc:	e5933000 	ldr	r3, [r3]
100235d0:	e2833e25 	add	r3, r3, #592	; 0x250
100235d4:	e1a00002 	mov	r0, r2
100235d8:	e1a01003 	mov	r1, r3
100235dc:	ebfffcf4 	bl	100229b4 <finsh_run_line>
100235e0:	ea000002 	b	100235f0 <finsh_thread_entry+0x8fc>
                    else rt_kprintf("\n");
100235e4:	e3050118 	movw	r0, #20760	; 0x5118
100235e8:	e3410003 	movt	r0, #4099	; 0x1003
100235ec:	ebffc133 	bl	10013ac0 <rt_kprintf>
#endif
                }

                rt_kprintf(FINSH_PROMPT);
100235f0:	ebfffbf6 	bl	100225d0 <finsh_get_prompt>
100235f4:	e1a03000 	mov	r3, r0
100235f8:	e1a00003 	mov	r0, r3
100235fc:	ebffc12f 	bl	10013ac0 <rt_kprintf>
                memset(shell->line, 0, sizeof(shell->line));
10023600:	e3033590 	movw	r3, #13712	; 0x3590
10023604:	e3413004 	movt	r3, #4100	; 0x1004
10023608:	e5933000 	ldr	r3, [r3]
1002360c:	e2833e25 	add	r3, r3, #592	; 0x250
10023610:	e1a00003 	mov	r0, r3
10023614:	e3a01000 	mov	r1, #0
10023618:	e3a02050 	mov	r2, #80	; 0x50
1002361c:	fa002f5e 	blx	1002f39c <memset>
                shell->line_curpos = shell->line_position = 0;
10023620:	e3033590 	movw	r3, #13712	; 0x3590
10023624:	e3413004 	movt	r3, #4100	; 0x1004
10023628:	e5932000 	ldr	r2, [r3]
1002362c:	e3033590 	movw	r3, #13712	; 0x3590
10023630:	e3413004 	movt	r3, #4100	; 0x1004
10023634:	e5933000 	ldr	r3, [r3]
10023638:	e3a01000 	mov	r1, #0
1002363c:	e5c312a0 	strb	r1, [r3, #672]	; 0x2a0
10023640:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10023644:	e5c232a1 	strb	r3, [r2, #673]	; 0x2a1
                break;
10023648:	ea0000af 	b	1002390c <finsh_thread_entry+0xc18>
            }

            /* it's a large line, discard it */
            if (shell->line_position >= FINSH_CMD_SIZE)
1002364c:	e3033590 	movw	r3, #13712	; 0x3590
10023650:	e3413004 	movt	r3, #4100	; 0x1004
10023654:	e5933000 	ldr	r3, [r3]
10023658:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
1002365c:	e353004f 	cmp	r3, #79	; 0x4f
10023660:	9a000004 	bls	10023678 <finsh_thread_entry+0x984>
                shell->line_position = 0;
10023664:	e3033590 	movw	r3, #13712	; 0x3590
10023668:	e3413004 	movt	r3, #4100	; 0x1004
1002366c:	e5933000 	ldr	r3, [r3]
10023670:	e3a02000 	mov	r2, #0
10023674:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0

            /* normal character */
            if (shell->line_curpos < shell->line_position)
10023678:	e3033590 	movw	r3, #13712	; 0x3590
1002367c:	e3413004 	movt	r3, #4100	; 0x1004
10023680:	e5933000 	ldr	r3, [r3]
10023684:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
10023688:	e3033590 	movw	r3, #13712	; 0x3590
1002368c:	e3413004 	movt	r3, #4100	; 0x1004
10023690:	e5933000 	ldr	r3, [r3]
10023694:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10023698:	e1520003 	cmp	r2, r3
1002369c:	2a000055 	bcs	100237f8 <finsh_thread_entry+0xb04>
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
100236a0:	e3033590 	movw	r3, #13712	; 0x3590
100236a4:	e3413004 	movt	r3, #4100	; 0x1004
100236a8:	e5932000 	ldr	r2, [r3]
100236ac:	e3033590 	movw	r3, #13712	; 0x3590
100236b0:	e3413004 	movt	r3, #4100	; 0x1004
100236b4:	e5933000 	ldr	r3, [r3]
100236b8:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100236bc:	e2833001 	add	r3, r3, #1
100236c0:	e2833e25 	add	r3, r3, #592	; 0x250
100236c4:	e0821003 	add	r1, r2, r3
                           &shell->line[shell->line_curpos],
100236c8:	e3033590 	movw	r3, #13712	; 0x3590
100236cc:	e3413004 	movt	r3, #4100	; 0x1004
100236d0:	e5932000 	ldr	r2, [r3]
100236d4:	e3033590 	movw	r3, #13712	; 0x3590
100236d8:	e3413004 	movt	r3, #4100	; 0x1004
100236dc:	e5933000 	ldr	r3, [r3]
100236e0:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100236e4:	e2833e25 	add	r3, r3, #592	; 0x250
100236e8:	e0822003 	add	r2, r2, r3
                           shell->line_position - shell->line_curpos);
100236ec:	e3033590 	movw	r3, #13712	; 0x3590
100236f0:	e3413004 	movt	r3, #4100	; 0x1004
100236f4:	e5933000 	ldr	r3, [r3]
100236f8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100236fc:	e1a00003 	mov	r0, r3
10023700:	e3033590 	movw	r3, #13712	; 0x3590
10023704:	e3413004 	movt	r3, #4100	; 0x1004
10023708:	e5933000 	ldr	r3, [r3]
1002370c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10023710:	e0633000 	rsb	r3, r3, r0
            /* normal character */
            if (shell->line_curpos < shell->line_position)
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
10023714:	e1a00001 	mov	r0, r1
10023718:	e1a01002 	mov	r1, r2
1002371c:	e1a02003 	mov	r2, r3
10023720:	ebffbb8a 	bl	10012550 <rt_memmove>
                           &shell->line[shell->line_curpos],
                           shell->line_position - shell->line_curpos);
                shell->line[shell->line_curpos] = ch;
10023724:	e3033590 	movw	r3, #13712	; 0x3590
10023728:	e3413004 	movt	r3, #4100	; 0x1004
1002372c:	e5932000 	ldr	r2, [r3]
10023730:	e3033590 	movw	r3, #13712	; 0x3590
10023734:	e3413004 	movt	r3, #4100	; 0x1004
10023738:	e5933000 	ldr	r3, [r3]
1002373c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10023740:	e55b1019 	ldrb	r1, [fp, #-25]
10023744:	e0823003 	add	r3, r2, r3
10023748:	e1a02001 	mov	r2, r1
1002374c:	e5c32250 	strb	r2, [r3, #592]	; 0x250
                if (shell->echo_mode)
10023750:	e3033590 	movw	r3, #13712	; 0x3590
10023754:	e3413004 	movt	r3, #4100	; 0x1004
10023758:	e5933000 	ldr	r3, [r3]
1002375c:	e5d3301d 	ldrb	r3, [r3, #29]
10023760:	e2033001 	and	r3, r3, #1
10023764:	e6ef3073 	uxtb	r3, r3
10023768:	e3530000 	cmp	r3, #0
1002376c:	0a00000c 	beq	100237a4 <finsh_thread_entry+0xab0>
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);
10023770:	e3033590 	movw	r3, #13712	; 0x3590
10023774:	e3413004 	movt	r3, #4100	; 0x1004
10023778:	e5932000 	ldr	r2, [r3]
1002377c:	e3033590 	movw	r3, #13712	; 0x3590
10023780:	e3413004 	movt	r3, #4100	; 0x1004
10023784:	e5933000 	ldr	r3, [r3]
10023788:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
1002378c:	e2833e25 	add	r3, r3, #592	; 0x250
10023790:	e0823003 	add	r3, r2, r3
10023794:	e3050178 	movw	r0, #20856	; 0x5178
10023798:	e3410003 	movt	r0, #4099	; 0x1003
1002379c:	e1a01003 	mov	r1, r3
100237a0:	ebffc0c6 	bl	10013ac0 <rt_kprintf>

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
100237a4:	e3033590 	movw	r3, #13712	; 0x3590
100237a8:	e3413004 	movt	r3, #4100	; 0x1004
100237ac:	e5933000 	ldr	r3, [r3]
100237b0:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100237b4:	e50b3018 	str	r3, [fp, #-24]
100237b8:	ea000005 	b	100237d4 <finsh_thread_entry+0xae0>
                    rt_kprintf("\b");
100237bc:	e3050164 	movw	r0, #20836	; 0x5164
100237c0:	e3410003 	movt	r0, #4099	; 0x1003
100237c4:	ebffc0bd 	bl	10013ac0 <rt_kprintf>
                shell->line[shell->line_curpos] = ch;
                if (shell->echo_mode)
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
100237c8:	e51b3018 	ldr	r3, [fp, #-24]
100237cc:	e2833001 	add	r3, r3, #1
100237d0:	e50b3018 	str	r3, [fp, #-24]
100237d4:	e3033590 	movw	r3, #13712	; 0x3590
100237d8:	e3413004 	movt	r3, #4100	; 0x1004
100237dc:	e5933000 	ldr	r3, [r3]
100237e0:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100237e4:	e1a02003 	mov	r2, r3
100237e8:	e51b3018 	ldr	r3, [fp, #-24]
100237ec:	e1520003 	cmp	r2, r3
100237f0:	cafffff1 	bgt	100237bc <finsh_thread_entry+0xac8>
100237f4:	ea000017 	b	10023858 <finsh_thread_entry+0xb64>
                    rt_kprintf("\b");
            }
            else
            {
                shell->line[shell->line_position] = ch;
100237f8:	e3033590 	movw	r3, #13712	; 0x3590
100237fc:	e3413004 	movt	r3, #4100	; 0x1004
10023800:	e5932000 	ldr	r2, [r3]
10023804:	e3033590 	movw	r3, #13712	; 0x3590
10023808:	e3413004 	movt	r3, #4100	; 0x1004
1002380c:	e5933000 	ldr	r3, [r3]
10023810:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10023814:	e55b1019 	ldrb	r1, [fp, #-25]
10023818:	e0823003 	add	r3, r2, r3
1002381c:	e1a02001 	mov	r2, r1
10023820:	e5c32250 	strb	r2, [r3, #592]	; 0x250
                if (shell->echo_mode)
10023824:	e3033590 	movw	r3, #13712	; 0x3590
10023828:	e3413004 	movt	r3, #4100	; 0x1004
1002382c:	e5933000 	ldr	r3, [r3]
10023830:	e5d3301d 	ldrb	r3, [r3, #29]
10023834:	e2033001 	and	r3, r3, #1
10023838:	e6ef3073 	uxtb	r3, r3
1002383c:	e3530000 	cmp	r3, #0
10023840:	0a000004 	beq	10023858 <finsh_thread_entry+0xb64>
                    rt_kprintf("%c", ch);
10023844:	e55b3019 	ldrb	r3, [fp, #-25]
10023848:	e3050168 	movw	r0, #20840	; 0x5168
1002384c:	e3410003 	movt	r0, #4099	; 0x1003
10023850:	e1a01003 	mov	r1, r3
10023854:	ebffc099 	bl	10013ac0 <rt_kprintf>
            }

            ch = 0;
10023858:	e3a03000 	mov	r3, #0
1002385c:	e54b3019 	strb	r3, [fp, #-25]
            shell->line_position ++;
10023860:	e3033590 	movw	r3, #13712	; 0x3590
10023864:	e3413004 	movt	r3, #4100	; 0x1004
10023868:	e5933000 	ldr	r3, [r3]
1002386c:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
10023870:	e2822001 	add	r2, r2, #1
10023874:	e6ef2072 	uxtb	r2, r2
10023878:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
            shell->line_curpos++;
1002387c:	e3033590 	movw	r3, #13712	; 0x3590
10023880:	e3413004 	movt	r3, #4100	; 0x1004
10023884:	e5933000 	ldr	r3, [r3]
10023888:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
1002388c:	e2822001 	add	r2, r2, #1
10023890:	e6ef2072 	uxtb	r2, r2
10023894:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
            if (shell->line_position >= 80)
10023898:	e3033590 	movw	r3, #13712	; 0x3590
1002389c:	e3413004 	movt	r3, #4100	; 0x1004
100238a0:	e5933000 	ldr	r3, [r3]
100238a4:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100238a8:	e353004f 	cmp	r3, #79	; 0x4f
100238ac:	9a000009 	bls	100238d8 <finsh_thread_entry+0xbe4>
            {
                /* clear command line */
                shell->line_position = 0;
100238b0:	e3033590 	movw	r3, #13712	; 0x3590
100238b4:	e3413004 	movt	r3, #4100	; 0x1004
100238b8:	e5933000 	ldr	r3, [r3]
100238bc:	e3a02000 	mov	r2, #0
100238c0:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
                shell->line_curpos = 0;
100238c4:	e3033590 	movw	r3, #13712	; 0x3590
100238c8:	e3413004 	movt	r3, #4100	; 0x1004
100238cc:	e5933000 	ldr	r3, [r3]
100238d0:	e3a02000 	mov	r2, #0
100238d4:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
100238d8:	e3033590 	movw	r3, #13712	; 0x3590
100238dc:	e3413004 	movt	r3, #4100	; 0x1004
100238e0:	e5933000 	ldr	r3, [r3]
100238e4:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
100238e8:	e24b3019 	sub	r3, fp, #25
100238ec:	e1a00002 	mov	r0, r2
100238f0:	e3a01000 	mov	r1, #0
100238f4:	e1a02003 	mov	r2, r3
100238f8:	e3a03001 	mov	r3, #1
100238fc:	ebffac55 	bl	1000ea58 <rt_device_read>
10023900:	e1a03000 	mov	r3, r0
10023904:	e3530001 	cmp	r3, #1
10023908:	0afffd3f 	beq	10022e0c <finsh_thread_entry+0x118>
                /* clear command line */
                shell->line_position = 0;
                shell->line_curpos = 0;
            }
        } /* end of device read */
    }
1002390c:	eafffd33 	b	10022de0 <finsh_thread_entry+0xec>

10023910 <finsh_system_function_init>:
}

void finsh_system_function_init(const void *begin, const void *end)
{
10023910:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10023914:	e28db000 	add	fp, sp, #0
10023918:	e24dd00c 	sub	sp, sp, #12
1002391c:	e50b0008 	str	r0, [fp, #-8]
10023920:	e50b100c 	str	r1, [fp, #-12]
    _syscall_table_begin = (struct finsh_syscall *) begin;
10023924:	e30f3934 	movw	r3, #63796	; 0xf934
10023928:	e3413003 	movt	r3, #4099	; 0x1003
1002392c:	e51b2008 	ldr	r2, [fp, #-8]
10023930:	e5832000 	str	r2, [r3]
    _syscall_table_end = (struct finsh_syscall *) end;
10023934:	e30f3938 	movw	r3, #63800	; 0xf938
10023938:	e3413003 	movt	r3, #4099	; 0x1003
1002393c:	e51b200c 	ldr	r2, [fp, #-12]
10023940:	e5832000 	str	r2, [r3]
}
10023944:	e24bd000 	sub	sp, fp, #0
10023948:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002394c:	e12fff1e 	bx	lr

10023950 <finsh_system_var_init>:

void finsh_system_var_init(const void *begin, const void *end)
{
10023950:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10023954:	e28db000 	add	fp, sp, #0
10023958:	e24dd00c 	sub	sp, sp, #12
1002395c:	e50b0008 	str	r0, [fp, #-8]
10023960:	e50b100c 	str	r1, [fp, #-12]
    _sysvar_table_begin = (struct finsh_sysvar *) begin;
10023964:	e30f393c 	movw	r3, #63804	; 0xf93c
10023968:	e3413003 	movt	r3, #4099	; 0x1003
1002396c:	e51b2008 	ldr	r2, [fp, #-8]
10023970:	e5832000 	str	r2, [r3]
    _sysvar_table_end = (struct finsh_sysvar *) end;
10023974:	e30f3940 	movw	r3, #63808	; 0xf940
10023978:	e3413003 	movt	r3, #4099	; 0x1003
1002397c:	e51b200c 	ldr	r2, [fp, #-12]
10023980:	e5832000 	str	r2, [r3]
}
10023984:	e24bd000 	sub	sp, fp, #0
10023988:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002398c:	e12fff1e 	bx	lr

10023990 <finsh_system_init>:
 * @ingroup finsh
 *
 * This function will initialize finsh shell
 */
int finsh_system_init(void)
{
10023990:	e92d4800 	push	{fp, lr}
10023994:	e28db004 	add	fp, sp, #4
10023998:	e24dd018 	sub	sp, sp, #24
    /* GNU GCC Compiler and TI CCS */
    extern const int __fsymtab_start;
    extern const int __fsymtab_end;
    extern const int __vsymtab_start;
    extern const int __vsymtab_end;
    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
1002399c:	e30204d8 	movw	r0, #9432	; 0x24d8
100239a0:	e3410003 	movt	r0, #4099	; 0x1003
100239a4:	e302173c 	movw	r1, #10044	; 0x273c
100239a8:	e3411003 	movt	r1, #4099	; 0x1003
100239ac:	ebffffd7 	bl	10023910 <finsh_system_function_init>
    finsh_system_var_init(&__vsymtab_start, &__vsymtab_end);
100239b0:	e302073c 	movw	r0, #10044	; 0x273c
100239b4:	e3410003 	movt	r0, #4099	; 0x1003
100239b8:	e302174c 	movw	r1, #10060	; 0x274c
100239bc:	e3411003 	movt	r1, #4099	; 0x1003
100239c0:	ebffffe2 	bl	10023950 <finsh_system_var_init>
#endif
#endif

    /* create or set shell structure */
#ifdef RT_USING_HEAP
    shell = (struct finsh_shell *)rt_malloc(sizeof(struct finsh_shell));
100239c4:	e3a00faa 	mov	r0, #680	; 0x2a8
100239c8:	ebffc231 	bl	10014294 <rt_malloc>
100239cc:	e1a02000 	mov	r2, r0
100239d0:	e3033590 	movw	r3, #13712	; 0x3590
100239d4:	e3413004 	movt	r3, #4100	; 0x1004
100239d8:	e5832000 	str	r2, [r3]
    if (shell == RT_NULL)
100239dc:	e3033590 	movw	r3, #13712	; 0x3590
100239e0:	e3413004 	movt	r3, #4100	; 0x1004
100239e4:	e5933000 	ldr	r3, [r3]
100239e8:	e3530000 	cmp	r3, #0
100239ec:	1a000004 	bne	10023a04 <finsh_system_init+0x74>
    {
        rt_kprintf("no memory for shell\n");
100239f0:	e305017c 	movw	r0, #20860	; 0x517c
100239f4:	e3410003 	movt	r0, #4099	; 0x1003
100239f8:	ebffc030 	bl	10013ac0 <rt_kprintf>
        return -1;
100239fc:	e3e03000 	mvn	r3, #0
10023a00:	ea000028 	b	10023aa8 <finsh_system_init+0x118>
    }
#else
    shell = &_shell;
#endif

    memset(shell, 0, sizeof(struct finsh_shell));
10023a04:	e3033590 	movw	r3, #13712	; 0x3590
10023a08:	e3413004 	movt	r3, #4100	; 0x1004
10023a0c:	e5933000 	ldr	r3, [r3]
10023a10:	e1a00003 	mov	r0, r3
10023a14:	e3a01000 	mov	r1, #0
10023a18:	e3a02faa 	mov	r2, #680	; 0x2a8
10023a1c:	fa002e5e 	blx	1002f39c <memset>

    rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
10023a20:	e3033590 	movw	r3, #13712	; 0x3590
10023a24:	e3413004 	movt	r3, #4100	; 0x1004
10023a28:	e5933000 	ldr	r3, [r3]
10023a2c:	e1a00003 	mov	r0, r3
10023a30:	e3051194 	movw	r1, #20884	; 0x5194
10023a34:	e3411003 	movt	r1, #4099	; 0x1003
10023a38:	e3a02000 	mov	r2, #0
10023a3c:	e3a03000 	mov	r3, #0
10023a40:	ebffadf2 	bl	1000f210 <rt_sem_init>
    result = rt_thread_init(&finsh_thread,
10023a44:	e30e38b0 	movw	r3, #59568	; 0xe8b0
10023a48:	e3413003 	movt	r3, #4099	; 0x1003
10023a4c:	e58d3000 	str	r3, [sp]
10023a50:	e3a03a01 	mov	r3, #4096	; 0x1000
10023a54:	e58d3004 	str	r3, [sp, #4]
10023a58:	e3a03014 	mov	r3, #20
10023a5c:	e58d3008 	str	r3, [sp, #8]
10023a60:	e3a0300a 	mov	r3, #10
10023a64:	e58d300c 	str	r3, [sp, #12]
10023a68:	e30e0838 	movw	r0, #59448	; 0xe838
10023a6c:	e3410003 	movt	r0, #4099	; 0x1003
10023a70:	e305119c 	movw	r1, #20892	; 0x519c
10023a74:	e3411003 	movt	r1, #4099	; 0x1003
10023a78:	e3022cf4 	movw	r2, #11508	; 0x2cf4
10023a7c:	e3412002 	movt	r2, #4098	; 0x1002
10023a80:	e3a03000 	mov	r3, #0
10023a84:	ebffcb87 	bl	100168a8 <rt_thread_init>
10023a88:	e50b0008 	str	r0, [fp, #-8]
                            "tshell",
                            finsh_thread_entry, RT_NULL,
                            &finsh_thread_stack[0], sizeof(finsh_thread_stack),
                            FINSH_THREAD_PRIORITY, 10);

    if (result == RT_EOK)
10023a8c:	e51b3008 	ldr	r3, [fp, #-8]
10023a90:	e3530000 	cmp	r3, #0
10023a94:	1a000002 	bne	10023aa4 <finsh_system_init+0x114>
        rt_thread_startup(&finsh_thread);
10023a98:	e30e0838 	movw	r0, #59448	; 0xe838
10023a9c:	e3410003 	movt	r0, #4099	; 0x1003
10023aa0:	ebffcbb7 	bl	10016984 <rt_thread_startup>
    return 0;
10023aa4:	e3a03000 	mov	r3, #0
}
10023aa8:	e1a00003 	mov	r0, r3
10023aac:	e24bd004 	sub	sp, fp, #4
10023ab0:	e8bd8800 	pop	{fp, pc}

10023ab4 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
10023ab4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10023ab8:	e28db000 	add	fp, sp, #0
10023abc:	e24dd00c 	sub	sp, sp, #12
10023ac0:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
10023ac4:	e51b3008 	ldr	r3, [fp, #-8]
10023ac8:	e5932000 	ldr	r2, [r3]
10023acc:	e51b3008 	ldr	r3, [fp, #-8]
10023ad0:	e1520003 	cmp	r2, r3
10023ad4:	03a03001 	moveq	r3, #1
10023ad8:	13a03000 	movne	r3, #0
10023adc:	e6ef3073 	uxtb	r3, r3
}
10023ae0:	e1a00003 	mov	r0, r3
10023ae4:	e24bd000 	sub	sp, fp, #0
10023ae8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10023aec:	e12fff1e 	bx	lr

10023af0 <rt_list_len>:

#include <rtthread.h>
#include "finsh.h"

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
10023af0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10023af4:	e28db000 	add	fp, sp, #0
10023af8:	e24dd014 	sub	sp, sp, #20
10023afc:	e50b0010 	str	r0, [fp, #-16]
    unsigned int len = 0;
10023b00:	e3a03000 	mov	r3, #0
10023b04:	e50b3008 	str	r3, [fp, #-8]
    const rt_list_t *p = l;
10023b08:	e51b3010 	ldr	r3, [fp, #-16]
10023b0c:	e50b300c 	str	r3, [fp, #-12]
    while (p->next != l)
10023b10:	ea000005 	b	10023b2c <rt_list_len+0x3c>
    {
        p = p->next;
10023b14:	e51b300c 	ldr	r3, [fp, #-12]
10023b18:	e5933000 	ldr	r3, [r3]
10023b1c:	e50b300c 	str	r3, [fp, #-12]
        len ++;
10023b20:	e51b3008 	ldr	r3, [fp, #-8]
10023b24:	e2833001 	add	r3, r3, #1
10023b28:	e50b3008 	str	r3, [fp, #-8]

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
    unsigned int len = 0;
    const rt_list_t *p = l;
    while (p->next != l)
10023b2c:	e51b300c 	ldr	r3, [fp, #-12]
10023b30:	e5932000 	ldr	r2, [r3]
10023b34:	e51b3010 	ldr	r3, [fp, #-16]
10023b38:	e1520003 	cmp	r2, r3
10023b3c:	1afffff4 	bne	10023b14 <rt_list_len+0x24>
    {
        p = p->next;
        len ++;
    }

    return len;
10023b40:	e51b3008 	ldr	r3, [fp, #-8]
}
10023b44:	e1a00003 	mov	r0, r3
10023b48:	e24bd000 	sub	sp, fp, #0
10023b4c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10023b50:	e12fff1e 	bx	lr

10023b54 <hello>:

long hello(void)
{
10023b54:	e92d4800 	push	{fp, lr}
10023b58:	e28db004 	add	fp, sp, #4
    rt_kprintf("Hello RT-Thread!\n");
10023b5c:	e3050210 	movw	r0, #21008	; 0x5210
10023b60:	e3410003 	movt	r0, #4099	; 0x1003
10023b64:	ebffbfd5 	bl	10013ac0 <rt_kprintf>

    return 0;
10023b68:	e3a03000 	mov	r3, #0
}
10023b6c:	e1a00003 	mov	r0, r3
10023b70:	e8bd8800 	pop	{fp, pc}

10023b74 <version>:
FINSH_FUNCTION_EXPORT(hello, say hello world);

extern void rt_show_version(void);
long version(void)
{
10023b74:	e92d4800 	push	{fp, lr}
10023b78:	e28db004 	add	fp, sp, #4
    rt_show_version();
10023b7c:	ebffbbd8 	bl	10012ae4 <rt_show_version>

    return 0;
10023b80:	e3a03000 	mov	r3, #0
}
10023b84:	e1a00003 	mov	r0, r3
10023b88:	e8bd8800 	pop	{fp, pc}

10023b8c <_list_thread>:
MSH_CMD_EXPORT(version, show RT-Thread version information);

extern struct rt_object_information rt_object_container[];

static long _list_thread(struct rt_list_node *list)
{
10023b8c:	e92d4800 	push	{fp, lr}
10023b90:	e28db004 	add	fp, sp, #4
10023b94:	e24dd020 	sub	sp, sp, #32
10023b98:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
10023b9c:	e3050224 	movw	r0, #21028	; 0x5224
10023ba0:	e3410003 	movt	r0, #4099	; 0x1003
10023ba4:	ebffbfc5 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
10023ba8:	e3050270 	movw	r0, #21104	; 0x5270
10023bac:	e3410003 	movt	r0, #4099	; 0x1003
10023bb0:	ebffbfc2 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10023bb4:	e51b3018 	ldr	r3, [fp, #-24]
10023bb8:	e5933000 	ldr	r3, [r3]
10023bbc:	e50b3008 	str	r3, [fp, #-8]
10023bc0:	ea000057 	b	10023d24 <_list_thread+0x198>
    {
        thread = rt_list_entry(node, struct rt_thread, list);
10023bc4:	e51b3008 	ldr	r3, [fp, #-8]
10023bc8:	e2433008 	sub	r3, r3, #8
10023bcc:	e50b3010 	str	r3, [fp, #-16]
        rt_kprintf("%-8.*s 0x%02x", RT_NAME_MAX, thread->name, thread->current_priority);
10023bd0:	e51b2010 	ldr	r2, [fp, #-16]
10023bd4:	e51b3010 	ldr	r3, [fp, #-16]
10023bd8:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10023bdc:	e30502b8 	movw	r0, #21176	; 0x52b8
10023be0:	e3410003 	movt	r0, #4099	; 0x1003
10023be4:	e3a01006 	mov	r1, #6
10023be8:	ebffbfb4 	bl	10013ac0 <rt_kprintf>

        if (thread->stat == RT_THREAD_READY)        rt_kprintf(" ready  ");
10023bec:	e51b3010 	ldr	r3, [fp, #-16]
10023bf0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10023bf4:	e3530001 	cmp	r3, #1
10023bf8:	1a000003 	bne	10023c0c <_list_thread+0x80>
10023bfc:	e30502c8 	movw	r0, #21192	; 0x52c8
10023c00:	e3410003 	movt	r0, #4099	; 0x1003
10023c04:	ebffbfad 	bl	10013ac0 <rt_kprintf>
10023c08:	ea000016 	b	10023c68 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_SUSPEND) rt_kprintf(" suspend");
10023c0c:	e51b3010 	ldr	r3, [fp, #-16]
10023c10:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10023c14:	e3530002 	cmp	r3, #2
10023c18:	1a000003 	bne	10023c2c <_list_thread+0xa0>
10023c1c:	e30502d4 	movw	r0, #21204	; 0x52d4
10023c20:	e3410003 	movt	r0, #4099	; 0x1003
10023c24:	ebffbfa5 	bl	10013ac0 <rt_kprintf>
10023c28:	ea00000e 	b	10023c68 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_INIT)    rt_kprintf(" init   ");
10023c2c:	e51b3010 	ldr	r3, [fp, #-16]
10023c30:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10023c34:	e3530000 	cmp	r3, #0
10023c38:	1a000003 	bne	10023c4c <_list_thread+0xc0>
10023c3c:	e30502e0 	movw	r0, #21216	; 0x52e0
10023c40:	e3410003 	movt	r0, #4099	; 0x1003
10023c44:	ebffbf9d 	bl	10013ac0 <rt_kprintf>
10023c48:	ea000006 	b	10023c68 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");
10023c4c:	e51b3010 	ldr	r3, [fp, #-16]
10023c50:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10023c54:	e3530004 	cmp	r3, #4
10023c58:	1a000002 	bne	10023c68 <_list_thread+0xdc>
10023c5c:	e30502ec 	movw	r0, #21228	; 0x52ec
10023c60:	e3410003 	movt	r0, #4099	; 0x1003
10023c64:	ebffbf95 	bl	10013ac0 <rt_kprintf>

        ptr = (rt_uint8_t*)thread->stack_addr;
10023c68:	e51b3010 	ldr	r3, [fp, #-16]
10023c6c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10023c70:	e50b300c 	str	r3, [fp, #-12]
        while (*ptr == '#')ptr ++;
10023c74:	ea000002 	b	10023c84 <_list_thread+0xf8>
10023c78:	e51b300c 	ldr	r3, [fp, #-12]
10023c7c:	e2833001 	add	r3, r3, #1
10023c80:	e50b300c 	str	r3, [fp, #-12]
10023c84:	e51b300c 	ldr	r3, [fp, #-12]
10023c88:	e5d33000 	ldrb	r3, [r3]
10023c8c:	e3530023 	cmp	r3, #35	; 0x23
10023c90:	0afffff8 	beq	10023c78 <_list_thread+0xec>

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
10023c94:	e51b3010 	ldr	r3, [fp, #-16]
10023c98:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
10023c9c:	e1a02003 	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
10023ca0:	e51b3010 	ldr	r3, [fp, #-16]
10023ca4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10023ca8:	e1a01003 	mov	r1, r3
10023cac:	e51b3010 	ldr	r3, [fp, #-16]
10023cb0:	e5933018 	ldr	r3, [r3, #24]
10023cb4:	e0633001 	rsb	r3, r3, r1
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
10023cb8:	e0821003 	add	r1, r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
10023cbc:	e51b3010 	ldr	r3, [fp, #-16]
10023cc0:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
10023cc4:	e1a0e003 	mov	lr, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
10023cc8:	e51b3010 	ldr	r3, [fp, #-16]
10023ccc:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
10023cd0:	e1a02003 	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
10023cd4:	e51b3010 	ldr	r3, [fp, #-16]
10023cd8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10023cdc:	e1a00003 	mov	r0, r3
10023ce0:	e51b300c 	ldr	r3, [fp, #-12]
10023ce4:	e0633000 	rsb	r3, r3, r0
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
10023ce8:	e082c003 	add	ip, r2, r3
10023cec:	e51b3010 	ldr	r3, [fp, #-16]
10023cf0:	e5932044 	ldr	r2, [r3, #68]	; 0x44
10023cf4:	e51b3010 	ldr	r3, [fp, #-16]
10023cf8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10023cfc:	e58d2000 	str	r2, [sp]
10023d00:	e58d3004 	str	r3, [sp, #4]
10023d04:	e30502f8 	movw	r0, #21240	; 0x52f8
10023d08:	e3410003 	movt	r0, #4099	; 0x1003
10023d0c:	e1a0200e 	mov	r2, lr
10023d10:	e1a0300c 	mov	r3, ip
10023d14:	ebffbf69 	bl	10013ac0 <rt_kprintf>
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
    for (node = list->next; node != list; node = node->next)
10023d18:	e51b3008 	ldr	r3, [fp, #-8]
10023d1c:	e5933000 	ldr	r3, [r3]
10023d20:	e50b3008 	str	r3, [fp, #-8]
10023d24:	e51b2008 	ldr	r2, [fp, #-8]
10023d28:	e51b3018 	ldr	r3, [fp, #-24]
10023d2c:	e1520003 	cmp	r2, r3
10023d30:	1affffa3 	bne	10023bc4 <_list_thread+0x38>
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
            thread->remaining_tick,
            thread->error);
    }
	
    return 0;
10023d34:	e3a03000 	mov	r3, #0
}
10023d38:	e1a00003 	mov	r0, r3
10023d3c:	e24bd004 	sub	sp, fp, #4
10023d40:	e8bd8800 	pop	{fp, pc}

10023d44 <list_thread>:

long list_thread(void)
{
10023d44:	e92d4800 	push	{fp, lr}
10023d48:	e28db004 	add	fp, sp, #4
    return _list_thread(&rt_object_container[RT_Object_Class_Thread].object_list);
10023d4c:	e59f000c 	ldr	r0, [pc, #12]	; 10023d60 <list_thread+0x1c>
10023d50:	ebffff8d 	bl	10023b8c <_list_thread>
10023d54:	e1a03000 	mov	r3, r0
}
10023d58:	e1a00003 	mov	r0, r3
10023d5c:	e8bd8800 	pop	{fp, pc}
10023d60:	1003687c 	.word	0x1003687c

10023d64 <show_wait_queue>:
FINSH_FUNCTION_EXPORT(list_thread, list thread);
MSH_CMD_EXPORT(list_thread, list thread);

static void show_wait_queue(struct rt_list_node *list)
{
10023d64:	e92d4800 	push	{fp, lr}
10023d68:	e28db004 	add	fp, sp, #4
10023d6c:	e24dd010 	sub	sp, sp, #16
10023d70:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
10023d74:	e51b3010 	ldr	r3, [fp, #-16]
10023d78:	e5933000 	ldr	r3, [r3]
10023d7c:	e50b3008 	str	r3, [fp, #-8]
10023d80:	ea000012 	b	10023dd0 <show_wait_queue+0x6c>
    {
        thread = rt_list_entry(node, struct rt_thread, tlist);
10023d84:	e51b3008 	ldr	r3, [fp, #-8]
10023d88:	e2433010 	sub	r3, r3, #16
10023d8c:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%s", thread->name);
10023d90:	e51b300c 	ldr	r3, [fp, #-12]
10023d94:	e305031c 	movw	r0, #21276	; 0x531c
10023d98:	e3410003 	movt	r0, #4099	; 0x1003
10023d9c:	e1a01003 	mov	r1, r3
10023da0:	ebffbf46 	bl	10013ac0 <rt_kprintf>

        if (node->next != list)
10023da4:	e51b3008 	ldr	r3, [fp, #-8]
10023da8:	e5932000 	ldr	r2, [r3]
10023dac:	e51b3010 	ldr	r3, [fp, #-16]
10023db0:	e1520003 	cmp	r2, r3
10023db4:	0a000002 	beq	10023dc4 <show_wait_queue+0x60>
            rt_kprintf("/");
10023db8:	e3050320 	movw	r0, #21280	; 0x5320
10023dbc:	e3410003 	movt	r0, #4099	; 0x1003
10023dc0:	ebffbf3e 	bl	10013ac0 <rt_kprintf>
static void show_wait_queue(struct rt_list_node *list)
{
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
10023dc4:	e51b3008 	ldr	r3, [fp, #-8]
10023dc8:	e5933000 	ldr	r3, [r3]
10023dcc:	e50b3008 	str	r3, [fp, #-8]
10023dd0:	e51b2008 	ldr	r2, [fp, #-8]
10023dd4:	e51b3010 	ldr	r3, [fp, #-16]
10023dd8:	e1520003 	cmp	r2, r3
10023ddc:	1affffe8 	bne	10023d84 <show_wait_queue+0x20>
        rt_kprintf("%s", thread->name);

        if (node->next != list)
            rt_kprintf("/");
    }
}
10023de0:	e24bd004 	sub	sp, fp, #4
10023de4:	e8bd8800 	pop	{fp, pc}

10023de8 <_list_sem>:

#ifdef RT_USING_SEMAPHORE
static long _list_sem(struct rt_list_node *list)
{
10023de8:	e92d4830 	push	{r4, r5, fp, lr}
10023dec:	e28db00c 	add	fp, sp, #12
10023df0:	e24dd018 	sub	sp, sp, #24
10023df4:	e50b0018 	str	r0, [fp, #-24]
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
10023df8:	e3050324 	movw	r0, #21284	; 0x5324
10023dfc:	e3410003 	movt	r0, #4099	; 0x1003
10023e00:	ebffbf2e 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("--------  --- --------------\n");
10023e04:	e3050344 	movw	r0, #21316	; 0x5344
10023e08:	e3410003 	movt	r0, #4099	; 0x1003
10023e0c:	ebffbf2b 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10023e10:	e51b3018 	ldr	r3, [fp, #-24]
10023e14:	e5933000 	ldr	r3, [r3]
10023e18:	e50b3010 	str	r3, [fp, #-16]
10023e1c:	ea000034 	b	10023ef4 <_list_sem+0x10c>
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
10023e20:	e51b3010 	ldr	r3, [fp, #-16]
10023e24:	e2433008 	sub	r3, r3, #8
10023e28:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&sem->parent.suspend_thread))
10023e2c:	e51b3014 	ldr	r3, [fp, #-20]
10023e30:	e2833010 	add	r3, r3, #16
10023e34:	e1a00003 	mov	r0, r3
10023e38:	ebffff1d 	bl	10023ab4 <rt_list_isempty>
10023e3c:	e1a03000 	mov	r3, r0
10023e40:	e3530000 	cmp	r3, #0
10023e44:	1a000017 	bne	10023ea8 <_list_sem+0xc0>
        {
            rt_kprintf("%-8.*s  %03d %d:", 
                       RT_NAME_MAX,
                       sem->parent.parent.name,
10023e48:	e51b4014 	ldr	r4, [fp, #-20]
                       sem->value,
10023e4c:	e51b3014 	ldr	r3, [fp, #-20]
10023e50:	e1d331b8 	ldrh	r3, [r3, #24]
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
10023e54:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
10023e58:	e51b3014 	ldr	r3, [fp, #-20]
10023e5c:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
10023e60:	e1a00003 	mov	r0, r3
10023e64:	ebffff21 	bl	10023af0 <rt_list_len>
10023e68:	e1a03000 	mov	r3, r0
10023e6c:	e58d3000 	str	r3, [sp]
10023e70:	e3050364 	movw	r0, #21348	; 0x5364
10023e74:	e3410003 	movt	r0, #4099	; 0x1003
10023e78:	e3a01006 	mov	r1, #6
10023e7c:	e1a02004 	mov	r2, r4
10023e80:	e1a03005 	mov	r3, r5
10023e84:	ebffbf0d 	bl	10013ac0 <rt_kprintf>
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
            show_wait_queue(&(sem->parent.suspend_thread));
10023e88:	e51b3014 	ldr	r3, [fp, #-20]
10023e8c:	e2833010 	add	r3, r3, #16
10023e90:	e1a00003 	mov	r0, r3
10023e94:	ebffffb2 	bl	10023d64 <show_wait_queue>
            rt_kprintf("\n");
10023e98:	e3050378 	movw	r0, #21368	; 0x5378
10023e9c:	e3410003 	movt	r0, #4099	; 0x1003
10023ea0:	ebffbf06 	bl	10013ac0 <rt_kprintf>
10023ea4:	ea00000f 	b	10023ee8 <_list_sem+0x100>
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
                       RT_NAME_MAX,
                       sem->parent.parent.name,
10023ea8:	e51b4014 	ldr	r4, [fp, #-20]
                       sem->value,
10023eac:	e51b3014 	ldr	r3, [fp, #-20]
10023eb0:	e1d331b8 	ldrh	r3, [r3, #24]
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
10023eb4:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
10023eb8:	e51b3014 	ldr	r3, [fp, #-20]
10023ebc:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
10023ec0:	e1a00003 	mov	r0, r3
10023ec4:	ebffff09 	bl	10023af0 <rt_list_len>
10023ec8:	e1a03000 	mov	r3, r0
10023ecc:	e58d3000 	str	r3, [sp]
10023ed0:	e305037c 	movw	r0, #21372	; 0x537c
10023ed4:	e3410003 	movt	r0, #4099	; 0x1003
10023ed8:	e3a01006 	mov	r1, #6
10023edc:	e1a02004 	mov	r2, r4
10023ee0:	e1a03005 	mov	r3, r5
10023ee4:	ebffbef5 	bl	10013ac0 <rt_kprintf>
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
    rt_kprintf("--------  --- --------------\n");
    for (node = list->next; node != list; node = node->next)
10023ee8:	e51b3010 	ldr	r3, [fp, #-16]
10023eec:	e5933000 	ldr	r3, [r3]
10023ef0:	e50b3010 	str	r3, [fp, #-16]
10023ef4:	e51b2010 	ldr	r2, [fp, #-16]
10023ef8:	e51b3018 	ldr	r3, [fp, #-24]
10023efc:	e1520003 	cmp	r2, r3
10023f00:	1affffc6 	bne	10023e20 <_list_sem+0x38>
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
        }
    }

    return 0;
10023f04:	e3a03000 	mov	r3, #0
}
10023f08:	e1a00003 	mov	r0, r3
10023f0c:	e24bd00c 	sub	sp, fp, #12
10023f10:	e8bd8830 	pop	{r4, r5, fp, pc}

10023f14 <list_sem>:

long list_sem(void)
{
10023f14:	e92d4800 	push	{fp, lr}
10023f18:	e28db004 	add	fp, sp, #4
    return _list_sem(&rt_object_container[RT_Object_Class_Semaphore].object_list);
10023f1c:	e59f000c 	ldr	r0, [pc, #12]	; 10023f30 <list_sem+0x1c>
10023f20:	ebffffb0 	bl	10023de8 <_list_sem>
10023f24:	e1a03000 	mov	r3, r0
}
10023f28:	e1a00003 	mov	r0, r3
10023f2c:	e8bd8800 	pop	{fp, pc}
10023f30:	1003688c 	.word	0x1003688c

10023f34 <_list_event>:
MSH_CMD_EXPORT(list_sem, list semaphore in system);
#endif

#ifdef RT_USING_EVENT
static long _list_event(struct rt_list_node *list)
{
10023f34:	e92d4830 	push	{r4, r5, fp, lr}
10023f38:	e28db00c 	add	fp, sp, #12
10023f3c:	e24dd018 	sub	sp, sp, #24
10023f40:	e50b0018 	str	r0, [fp, #-24]
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
10023f44:	e3050390 	movw	r0, #21392	; 0x5390
10023f48:	e3410003 	movt	r0, #4099	; 0x1003
10023f4c:	ebffbedb 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("-------- ---------- --------------\n");
10023f50:	e30503b4 	movw	r0, #21428	; 0x53b4
10023f54:	e3410003 	movt	r0, #4099	; 0x1003
10023f58:	ebffbed8 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10023f5c:	e51b3018 	ldr	r3, [fp, #-24]
10023f60:	e5933000 	ldr	r3, [r3]
10023f64:	e50b3010 	str	r3, [fp, #-16]
10023f68:	ea00002a 	b	10024018 <_list_event+0xe4>
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
10023f6c:	e51b3010 	ldr	r3, [fp, #-16]
10023f70:	e2433008 	sub	r3, r3, #8
10023f74:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&e->parent.suspend_thread))
10023f78:	e51b3014 	ldr	r3, [fp, #-20]
10023f7c:	e2833010 	add	r3, r3, #16
10023f80:	e1a00003 	mov	r0, r3
10023f84:	ebfffeca 	bl	10023ab4 <rt_list_isempty>
10023f88:	e1a03000 	mov	r3, r0
10023f8c:	e3530000 	cmp	r3, #0
10023f90:	1a000016 	bne	10023ff0 <_list_event+0xbc>
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
                       RT_NAME_MAX,
                       e->parent.parent.name,
10023f94:	e51b5014 	ldr	r5, [fp, #-20]
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
10023f98:	e51b3014 	ldr	r3, [fp, #-20]
10023f9c:	e5934018 	ldr	r4, [r3, #24]
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
10023fa0:	e51b3014 	ldr	r3, [fp, #-20]
10023fa4:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
10023fa8:	e1a00003 	mov	r0, r3
10023fac:	ebfffecf 	bl	10023af0 <rt_list_len>
10023fb0:	e1a03000 	mov	r3, r0
10023fb4:	e58d3000 	str	r3, [sp]
10023fb8:	e30503d8 	movw	r0, #21464	; 0x53d8
10023fbc:	e3410003 	movt	r0, #4099	; 0x1003
10023fc0:	e3a01006 	mov	r1, #6
10023fc4:	e1a02005 	mov	r2, r5
10023fc8:	e1a03004 	mov	r3, r4
10023fcc:	ebffbebb 	bl	10013ac0 <rt_kprintf>
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
            show_wait_queue(&(e->parent.suspend_thread));
10023fd0:	e51b3014 	ldr	r3, [fp, #-20]
10023fd4:	e2833010 	add	r3, r3, #16
10023fd8:	e1a00003 	mov	r0, r3
10023fdc:	ebffff60 	bl	10023d64 <show_wait_queue>
            rt_kprintf("\n");
10023fe0:	e3050378 	movw	r0, #21368	; 0x5378
10023fe4:	e3410003 	movt	r0, #4099	; 0x1003
10023fe8:	ebffbeb4 	bl	10013ac0 <rt_kprintf>
10023fec:	ea000006 	b	1002400c <_list_event+0xd8>
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
10023ff0:	e51b2014 	ldr	r2, [fp, #-20]
            show_wait_queue(&(e->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
10023ff4:	e51b3014 	ldr	r3, [fp, #-20]
10023ff8:	e5933018 	ldr	r3, [r3, #24]
10023ffc:	e30503f0 	movw	r0, #21488	; 0x53f0
10024000:	e3410003 	movt	r0, #4099	; 0x1003
10024004:	e3a01006 	mov	r1, #6
10024008:	ebffbeac 	bl	10013ac0 <rt_kprintf>
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
    rt_kprintf("-------- ---------- --------------\n");
    for (node = list->next; node != list; node = node->next)
1002400c:	e51b3010 	ldr	r3, [fp, #-16]
10024010:	e5933000 	ldr	r3, [r3]
10024014:	e50b3010 	str	r3, [fp, #-16]
10024018:	e51b2010 	ldr	r2, [fp, #-16]
1002401c:	e51b3018 	ldr	r3, [fp, #-24]
10024020:	e1520003 	cmp	r2, r3
10024024:	1affffd0 	bne	10023f6c <_list_event+0x38>
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
        }
    }

    return 0;
10024028:	e3a03000 	mov	r3, #0
}
1002402c:	e1a00003 	mov	r0, r3
10024030:	e24bd00c 	sub	sp, fp, #12
10024034:	e8bd8830 	pop	{r4, r5, fp, pc}

10024038 <list_event>:

long list_event(void)
{
10024038:	e92d4800 	push	{fp, lr}
1002403c:	e28db004 	add	fp, sp, #4
    return _list_event(&rt_object_container[RT_Object_Class_Event].object_list);
10024040:	e59f000c 	ldr	r0, [pc, #12]	; 10024054 <list_event+0x1c>
10024044:	ebffffba 	bl	10023f34 <_list_event>
10024048:	e1a03000 	mov	r3, r0
}
1002404c:	e1a00003 	mov	r0, r3
10024050:	e8bd8800 	pop	{fp, pc}
10024054:	100368ac 	.word	0x100368ac

10024058 <_list_mutex>:
MSH_CMD_EXPORT(list_event, list event in system);
#endif

#ifdef RT_USING_MUTEX
static long _list_mutex(struct rt_list_node *list)
{
10024058:	e92d4870 	push	{r4, r5, r6, fp, lr}
1002405c:	e28db010 	add	fp, sp, #16
10024060:	e24dd024 	sub	sp, sp, #36	; 0x24
10024064:	e50b0020 	str	r0, [fp, #-32]
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
10024068:	e3050404 	movw	r0, #21508	; 0x5404
1002406c:	e3410003 	movt	r0, #4099	; 0x1003
10024070:	ebffbe92 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("-------- -------- ---- --------------\n");
10024074:	e305042c 	movw	r0, #21548	; 0x542c
10024078:	e3410003 	movt	r0, #4099	; 0x1003
1002407c:	ebffbe8f 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10024080:	e51b3020 	ldr	r3, [fp, #-32]
10024084:	e5933000 	ldr	r3, [r3]
10024088:	e50b3018 	str	r3, [fp, #-24]
1002408c:	ea00001a 	b	100240fc <_list_mutex+0xa4>
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
10024090:	e51b3018 	ldr	r3, [fp, #-24]
10024094:	e2433008 	sub	r3, r3, #8
10024098:	e50b301c 	str	r3, [fp, #-28]
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
                   RT_NAME_MAX,
                   m->parent.parent.name,
1002409c:	e51b401c 	ldr	r4, [fp, #-28]
                   RT_NAME_MAX,
                   m->owner->name,
100240a0:	e51b301c 	ldr	r3, [fp, #-28]
100240a4:	e593301c 	ldr	r3, [r3, #28]
100240a8:	e1a06003 	mov	r6, r3
                   m->hold,
100240ac:	e51b301c 	ldr	r3, [fp, #-28]
100240b0:	e5d3301b 	ldrb	r3, [r3, #27]
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
100240b4:	e1a05003 	mov	r5, r3
                   RT_NAME_MAX,
                   m->parent.parent.name,
                   RT_NAME_MAX,
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
100240b8:	e51b301c 	ldr	r3, [fp, #-28]
100240bc:	e2833010 	add	r3, r3, #16
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
100240c0:	e1a00003 	mov	r0, r3
100240c4:	ebfffe89 	bl	10023af0 <rt_list_len>
100240c8:	e1a03000 	mov	r3, r0
100240cc:	e58d6000 	str	r6, [sp]
100240d0:	e58d5004 	str	r5, [sp, #4]
100240d4:	e58d3008 	str	r3, [sp, #8]
100240d8:	e3050454 	movw	r0, #21588	; 0x5454
100240dc:	e3410003 	movt	r0, #4099	; 0x1003
100240e0:	e3a01006 	mov	r1, #6
100240e4:	e1a02004 	mov	r2, r4
100240e8:	e3a03006 	mov	r3, #6
100240ec:	ebffbe73 	bl	10013ac0 <rt_kprintf>
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
100240f0:	e51b3018 	ldr	r3, [fp, #-24]
100240f4:	e5933000 	ldr	r3, [r3]
100240f8:	e50b3018 	str	r3, [fp, #-24]
100240fc:	e51b2018 	ldr	r2, [fp, #-24]
10024100:	e51b3020 	ldr	r3, [fp, #-32]
10024104:	e1520003 	cmp	r2, r3
10024108:	1affffe0 	bne	10024090 <_list_mutex+0x38>
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
    }

    return 0;
1002410c:	e3a03000 	mov	r3, #0
}
10024110:	e1a00003 	mov	r0, r3
10024114:	e24bd010 	sub	sp, fp, #16
10024118:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

1002411c <list_mutex>:

long list_mutex(void)
{
1002411c:	e92d4800 	push	{fp, lr}
10024120:	e28db004 	add	fp, sp, #4
    return _list_mutex(&rt_object_container[RT_Object_Class_Mutex].object_list);
10024124:	e59f000c 	ldr	r0, [pc, #12]	; 10024138 <list_mutex+0x1c>
10024128:	ebffffca 	bl	10024058 <_list_mutex>
1002412c:	e1a03000 	mov	r3, r0
}
10024130:	e1a00003 	mov	r0, r3
10024134:	e8bd8800 	pop	{fp, pc}
10024138:	1003689c 	.word	0x1003689c

1002413c <_list_mailbox>:
MSH_CMD_EXPORT(list_mutex, list mutex in system);
#endif

#ifdef RT_USING_MAILBOX
static long _list_mailbox(struct rt_list_node *list)
{
1002413c:	e92d4870 	push	{r4, r5, r6, fp, lr}
10024140:	e28db010 	add	fp, sp, #16
10024144:	e24dd01c 	sub	sp, sp, #28
10024148:	e50b0020 	str	r0, [fp, #-32]
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
1002414c:	e305046c 	movw	r0, #21612	; 0x546c
10024150:	e3410003 	movt	r0, #4099	; 0x1003
10024154:	ebffbe59 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("-------- ----  ---- --------------\n");
10024158:	e3050490 	movw	r0, #21648	; 0x5490
1002415c:	e3410003 	movt	r0, #4099	; 0x1003
10024160:	ebffbe56 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10024164:	e51b3020 	ldr	r3, [fp, #-32]
10024168:	e5933000 	ldr	r3, [r3]
1002416c:	e50b3018 	str	r3, [fp, #-24]
10024170:	ea00003c 	b	10024268 <_list_mailbox+0x12c>
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
10024174:	e51b3018 	ldr	r3, [fp, #-24]
10024178:	e2433008 	sub	r3, r3, #8
1002417c:	e50b301c 	str	r3, [fp, #-28]
        if (!rt_list_isempty(&m->parent.suspend_thread))
10024180:	e51b301c 	ldr	r3, [fp, #-28]
10024184:	e2833010 	add	r3, r3, #16
10024188:	e1a00003 	mov	r0, r3
1002418c:	ebfffe48 	bl	10023ab4 <rt_list_isempty>
10024190:	e1a03000 	mov	r3, r0
10024194:	e3530000 	cmp	r3, #0
10024198:	1a00001b 	bne	1002420c <_list_mailbox+0xd0>
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
1002419c:	e51b401c 	ldr	r4, [fp, #-28]
                       m->entry,
100241a0:	e51b301c 	ldr	r3, [fp, #-28]
100241a4:	e1d331be 	ldrh	r3, [r3, #30]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
100241a8:	e1a06003 	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
100241ac:	e51b301c 	ldr	r3, [fp, #-28]
100241b0:	e1d331bc 	ldrh	r3, [r3, #28]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
100241b4:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
100241b8:	e51b301c 	ldr	r3, [fp, #-28]
100241bc:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
100241c0:	e1a00003 	mov	r0, r3
100241c4:	ebfffe49 	bl	10023af0 <rt_list_len>
100241c8:	e1a03000 	mov	r3, r0
100241cc:	e58d5000 	str	r5, [sp]
100241d0:	e58d3004 	str	r3, [sp, #4]
100241d4:	e30504b4 	movw	r0, #21684	; 0x54b4
100241d8:	e3410003 	movt	r0, #4099	; 0x1003
100241dc:	e3a01006 	mov	r1, #6
100241e0:	e1a02004 	mov	r2, r4
100241e4:	e1a03006 	mov	r3, r6
100241e8:	ebffbe34 	bl	10013ac0 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
100241ec:	e51b301c 	ldr	r3, [fp, #-28]
100241f0:	e2833010 	add	r3, r3, #16
100241f4:	e1a00003 	mov	r0, r3
100241f8:	ebfffed9 	bl	10023d64 <show_wait_queue>
            rt_kprintf("\n");
100241fc:	e3050378 	movw	r0, #21368	; 0x5378
10024200:	e3410003 	movt	r0, #4099	; 0x1003
10024204:	ebffbe2d 	bl	10013ac0 <rt_kprintf>
10024208:	ea000013 	b	1002425c <_list_mailbox+0x120>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
1002420c:	e51b401c 	ldr	r4, [fp, #-28]
                       m->entry,
10024210:	e51b301c 	ldr	r3, [fp, #-28]
10024214:	e1d331be 	ldrh	r3, [r3, #30]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
10024218:	e1a06003 	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
1002421c:	e51b301c 	ldr	r3, [fp, #-28]
10024220:	e1d331bc 	ldrh	r3, [r3, #28]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
10024224:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
10024228:	e51b301c 	ldr	r3, [fp, #-28]
1002422c:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
10024230:	e1a00003 	mov	r0, r3
10024234:	ebfffe2d 	bl	10023af0 <rt_list_len>
10024238:	e1a03000 	mov	r3, r0
1002423c:	e58d5000 	str	r5, [sp]
10024240:	e58d3004 	str	r3, [sp, #4]
10024244:	e30504cc 	movw	r0, #21708	; 0x54cc
10024248:	e3410003 	movt	r0, #4099	; 0x1003
1002424c:	e3a01006 	mov	r1, #6
10024250:	e1a02004 	mov	r2, r4
10024254:	e1a03006 	mov	r3, r6
10024258:	ebffbe18 	bl	10013ac0 <rt_kprintf>
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
    rt_kprintf("-------- ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
1002425c:	e51b3018 	ldr	r3, [fp, #-24]
10024260:	e5933000 	ldr	r3, [r3]
10024264:	e50b3018 	str	r3, [fp, #-24]
10024268:	e51b2018 	ldr	r2, [fp, #-24]
1002426c:	e51b3020 	ldr	r3, [fp, #-32]
10024270:	e1520003 	cmp	r2, r3
10024274:	1affffbe 	bne	10024174 <_list_mailbox+0x38>
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
10024278:	e3a03000 	mov	r3, #0
}
1002427c:	e1a00003 	mov	r0, r3
10024280:	e24bd010 	sub	sp, fp, #16
10024284:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

10024288 <list_mailbox>:

long list_mailbox(void)
{
10024288:	e92d4800 	push	{fp, lr}
1002428c:	e28db004 	add	fp, sp, #4
    return _list_mailbox(&rt_object_container[RT_Object_Class_MailBox].object_list);
10024290:	e59f000c 	ldr	r0, [pc, #12]	; 100242a4 <list_mailbox+0x1c>
10024294:	ebffffa8 	bl	1002413c <_list_mailbox>
10024298:	e1a03000 	mov	r3, r0
}
1002429c:	e1a00003 	mov	r0, r3
100242a0:	e8bd8800 	pop	{fp, pc}
100242a4:	100368bc 	.word	0x100368bc

100242a8 <_list_msgqueue>:
MSH_CMD_EXPORT(list_mailbox, list mail box in system);
#endif

#ifdef RT_USING_MESSAGEQUEUE
static long _list_msgqueue(struct rt_list_node *list)
{
100242a8:	e92d4830 	push	{r4, r5, fp, lr}
100242ac:	e28db00c 	add	fp, sp, #12
100242b0:	e24dd018 	sub	sp, sp, #24
100242b4:	e50b0018 	str	r0, [fp, #-24]
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
100242b8:	e30504e4 	movw	r0, #21732	; 0x54e4
100242bc:	e3410003 	movt	r0, #4099	; 0x1003
100242c0:	ebffbdfe 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("-------- ----  --------------\n");
100242c4:	e3050504 	movw	r0, #21764	; 0x5504
100242c8:	e3410003 	movt	r0, #4099	; 0x1003
100242cc:	ebffbdfb 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
100242d0:	e51b3018 	ldr	r3, [fp, #-24]
100242d4:	e5933000 	ldr	r3, [r3]
100242d8:	e50b3010 	str	r3, [fp, #-16]
100242dc:	ea000034 	b	100243b4 <_list_msgqueue+0x10c>
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
100242e0:	e51b3010 	ldr	r3, [fp, #-16]
100242e4:	e2433008 	sub	r3, r3, #8
100242e8:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&m->parent.suspend_thread))
100242ec:	e51b3014 	ldr	r3, [fp, #-20]
100242f0:	e2833010 	add	r3, r3, #16
100242f4:	e1a00003 	mov	r0, r3
100242f8:	ebfffded 	bl	10023ab4 <rt_list_isempty>
100242fc:	e1a03000 	mov	r3, r0
10024300:	e3530000 	cmp	r3, #0
10024304:	1a000017 	bne	10024368 <_list_msgqueue+0xc0>
        {
            rt_kprintf("%-8.*s %04d  %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
10024308:	e51b4014 	ldr	r4, [fp, #-20]
                       m->entry,
1002430c:	e51b3014 	ldr	r3, [fp, #-20]
10024310:	e1d332b0 	ldrh	r3, [r3, #32]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
10024314:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
10024318:	e51b3014 	ldr	r3, [fp, #-20]
1002431c:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
10024320:	e1a00003 	mov	r0, r3
10024324:	ebfffdf1 	bl	10023af0 <rt_list_len>
10024328:	e1a03000 	mov	r3, r0
1002432c:	e58d3000 	str	r3, [sp]
10024330:	e3050524 	movw	r0, #21796	; 0x5524
10024334:	e3410003 	movt	r0, #4099	; 0x1003
10024338:	e3a01006 	mov	r1, #6
1002433c:	e1a02004 	mov	r2, r4
10024340:	e1a03005 	mov	r3, r5
10024344:	ebffbddd 	bl	10013ac0 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
10024348:	e51b3014 	ldr	r3, [fp, #-20]
1002434c:	e2833010 	add	r3, r3, #16
10024350:	e1a00003 	mov	r0, r3
10024354:	ebfffe82 	bl	10023d64 <show_wait_queue>
            rt_kprintf("\n");
10024358:	e3050378 	movw	r0, #21368	; 0x5378
1002435c:	e3410003 	movt	r0, #4099	; 0x1003
10024360:	ebffbdd6 	bl	10013ac0 <rt_kprintf>
10024364:	ea00000f 	b	100243a8 <_list_msgqueue+0x100>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
10024368:	e51b4014 	ldr	r4, [fp, #-20]
                       m->entry,
1002436c:	e51b3014 	ldr	r3, [fp, #-20]
10024370:	e1d332b0 	ldrh	r3, [r3, #32]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
10024374:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
10024378:	e51b3014 	ldr	r3, [fp, #-20]
1002437c:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
10024380:	e1a00003 	mov	r0, r3
10024384:	ebfffdd9 	bl	10023af0 <rt_list_len>
10024388:	e1a03000 	mov	r3, r0
1002438c:	e58d3000 	str	r3, [sp]
10024390:	e3050538 	movw	r0, #21816	; 0x5538
10024394:	e3410003 	movt	r0, #4099	; 0x1003
10024398:	e3a01006 	mov	r1, #6
1002439c:	e1a02004 	mov	r2, r4
100243a0:	e1a03005 	mov	r3, r5
100243a4:	ebffbdc5 	bl	10013ac0 <rt_kprintf>
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
    rt_kprintf("-------- ----  --------------\n");
    for (node = list->next; node != list; node = node->next)
100243a8:	e51b3010 	ldr	r3, [fp, #-16]
100243ac:	e5933000 	ldr	r3, [r3]
100243b0:	e50b3010 	str	r3, [fp, #-16]
100243b4:	e51b2010 	ldr	r2, [fp, #-16]
100243b8:	e51b3018 	ldr	r3, [fp, #-24]
100243bc:	e1520003 	cmp	r2, r3
100243c0:	1affffc6 	bne	100242e0 <_list_msgqueue+0x38>
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
100243c4:	e3a03000 	mov	r3, #0
}
100243c8:	e1a00003 	mov	r0, r3
100243cc:	e24bd00c 	sub	sp, fp, #12
100243d0:	e8bd8830 	pop	{r4, r5, fp, pc}

100243d4 <list_msgqueue>:

long list_msgqueue(void)
{
100243d4:	e92d4800 	push	{fp, lr}
100243d8:	e28db004 	add	fp, sp, #4
    return _list_msgqueue(&rt_object_container[RT_Object_Class_MessageQueue].object_list);
100243dc:	e59f000c 	ldr	r0, [pc, #12]	; 100243f0 <list_msgqueue+0x1c>
100243e0:	ebffffb0 	bl	100242a8 <_list_msgqueue>
100243e4:	e1a03000 	mov	r3, r0
}
100243e8:	e1a00003 	mov	r0, r3
100243ec:	e8bd8800 	pop	{fp, pc}
100243f0:	100368cc 	.word	0x100368cc

100243f4 <_list_mempool>:
MSH_CMD_EXPORT(list_memheap, list memory heap in system);
#endif

#ifdef RT_USING_MEMPOOL
static long _list_mempool(struct rt_list_node *list)
{
100243f4:	e92d4800 	push	{fp, lr}
100243f8:	e28db004 	add	fp, sp, #4
100243fc:	e24dd020 	sub	sp, sp, #32
10024400:	e50b0010 	str	r0, [fp, #-16]
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
10024404:	e305054c 	movw	r0, #21836	; 0x554c
10024408:	e3410003 	movt	r0, #4099	; 0x1003
1002440c:	ebffbdab 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("-------- ----  ----  ---- --------------\n");
10024410:	e3050578 	movw	r0, #21880	; 0x5578
10024414:	e3410003 	movt	r0, #4099	; 0x1003
10024418:	ebffbda8 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
1002441c:	e51b3010 	ldr	r3, [fp, #-16]
10024420:	e5933000 	ldr	r3, [r3]
10024424:	e50b3008 	str	r3, [fp, #-8]
10024428:	ea000035 	b	10024504 <_list_mempool+0x110>
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
1002442c:	e51b3008 	ldr	r3, [fp, #-8]
10024430:	e2433008 	sub	r3, r3, #8
10024434:	e50b300c 	str	r3, [fp, #-12]
        if (mp->suspend_thread_count > 0)
10024438:	e51b300c 	ldr	r3, [fp, #-12]
1002443c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
10024440:	e3530000 	cmp	r3, #0
10024444:	0a000019 	beq	100244b0 <_list_mempool+0xbc>
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
                       RT_NAME_MAX,
                       mp->parent.name,
10024448:	e51be00c 	ldr	lr, [fp, #-12]
    for (node = list->next; node != list; node = node->next)
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
        if (mp->suspend_thread_count > 0)
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
1002444c:	e51b300c 	ldr	r3, [fp, #-12]
10024450:	e593c018 	ldr	ip, [r3, #24]
10024454:	e51b300c 	ldr	r3, [fp, #-12]
10024458:	e5931020 	ldr	r1, [r3, #32]
1002445c:	e51b300c 	ldr	r3, [fp, #-12]
10024460:	e5932024 	ldr	r2, [r3, #36]	; 0x24
10024464:	e51b300c 	ldr	r3, [fp, #-12]
10024468:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1002446c:	e58d1000 	str	r1, [sp]
10024470:	e58d2004 	str	r2, [sp, #4]
10024474:	e58d3008 	str	r3, [sp, #8]
10024478:	e30505a4 	movw	r0, #21924	; 0x55a4
1002447c:	e3410003 	movt	r0, #4099	; 0x1003
10024480:	e3a01006 	mov	r1, #6
10024484:	e1a0200e 	mov	r2, lr
10024488:	e1a0300c 	mov	r3, ip
1002448c:	ebffbd8b 	bl	10013ac0 <rt_kprintf>
                       mp->parent.name,
                       mp->block_size,
                       mp->block_total_count,
                       mp->block_free_count,
                       mp->suspend_thread_count);
            show_wait_queue(&(mp->suspend_thread));
10024490:	e51b300c 	ldr	r3, [fp, #-12]
10024494:	e2833028 	add	r3, r3, #40	; 0x28
10024498:	e1a00003 	mov	r0, r3
1002449c:	ebfffe30 	bl	10023d64 <show_wait_queue>
            rt_kprintf("\n");
100244a0:	e3050378 	movw	r0, #21368	; 0x5378
100244a4:	e3410003 	movt	r0, #4099	; 0x1003
100244a8:	ebffbd84 	bl	10013ac0 <rt_kprintf>
100244ac:	ea000011 	b	100244f8 <_list_mempool+0x104>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
                       RT_NAME_MAX,
                       mp->parent.name,
100244b0:	e51be00c 	ldr	lr, [fp, #-12]
            show_wait_queue(&(mp->suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
100244b4:	e51b300c 	ldr	r3, [fp, #-12]
100244b8:	e593c018 	ldr	ip, [r3, #24]
100244bc:	e51b300c 	ldr	r3, [fp, #-12]
100244c0:	e5931020 	ldr	r1, [r3, #32]
100244c4:	e51b300c 	ldr	r3, [fp, #-12]
100244c8:	e5932024 	ldr	r2, [r3, #36]	; 0x24
100244cc:	e51b300c 	ldr	r3, [fp, #-12]
100244d0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
100244d4:	e58d1000 	str	r1, [sp]
100244d8:	e58d2004 	str	r2, [sp, #4]
100244dc:	e58d3008 	str	r3, [sp, #8]
100244e0:	e30505c0 	movw	r0, #21952	; 0x55c0
100244e4:	e3410003 	movt	r0, #4099	; 0x1003
100244e8:	e3a01006 	mov	r1, #6
100244ec:	e1a0200e 	mov	r2, lr
100244f0:	e1a0300c 	mov	r3, ip
100244f4:	ebffbd71 	bl	10013ac0 <rt_kprintf>
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
    rt_kprintf("-------- ----  ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
100244f8:	e51b3008 	ldr	r3, [fp, #-8]
100244fc:	e5933000 	ldr	r3, [r3]
10024500:	e50b3008 	str	r3, [fp, #-8]
10024504:	e51b2008 	ldr	r2, [fp, #-8]
10024508:	e51b3010 	ldr	r3, [fp, #-16]
1002450c:	e1520003 	cmp	r2, r3
10024510:	1affffc5 	bne	1002442c <_list_mempool+0x38>
                       mp->block_free_count,
                       mp->suspend_thread_count);
        }
    }

    return 0;
10024514:	e3a03000 	mov	r3, #0
}
10024518:	e1a00003 	mov	r0, r3
1002451c:	e24bd004 	sub	sp, fp, #4
10024520:	e8bd8800 	pop	{fp, pc}

10024524 <list_mempool>:

long list_mempool(void)
{
10024524:	e92d4800 	push	{fp, lr}
10024528:	e28db004 	add	fp, sp, #4
    return _list_mempool(&rt_object_container[RT_Object_Class_MemPool].object_list);
1002452c:	e59f000c 	ldr	r0, [pc, #12]	; 10024540 <list_mempool+0x1c>
10024530:	ebffffaf 	bl	100243f4 <_list_mempool>
10024534:	e1a03000 	mov	r3, r0
}
10024538:	e1a00003 	mov	r0, r3
1002453c:	e8bd8800 	pop	{fp, pc}
10024540:	100368dc 	.word	0x100368dc

10024544 <_list_timer>:
FINSH_FUNCTION_EXPORT(list_mempool, list memory pool in system)
MSH_CMD_EXPORT(list_mempool, list memory pool in system);
#endif

static long _list_timer(struct rt_list_node *list)
{
10024544:	e92d4800 	push	{fp, lr}
10024548:	e28db004 	add	fp, sp, #4
1002454c:	e24dd018 	sub	sp, sp, #24
10024550:	e50b0010 	str	r0, [fp, #-16]
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
10024554:	e30505dc 	movw	r0, #21980	; 0x55dc
10024558:	e3410003 	movt	r0, #4099	; 0x1003
1002455c:	ebffbd57 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("-------- ---------- ---------- -----------\n");
10024560:	e3050604 	movw	r0, #22020	; 0x5604
10024564:	e3410003 	movt	r0, #4099	; 0x1003
10024568:	ebffbd54 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
1002456c:	e51b3010 	ldr	r3, [fp, #-16]
10024570:	e5933000 	ldr	r3, [r3]
10024574:	e50b3008 	str	r3, [fp, #-8]
10024578:	ea00001c 	b	100245f0 <_list_timer+0xac>
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
1002457c:	e51b3008 	ldr	r3, [fp, #-8]
10024580:	e2433008 	sub	r3, r3, #8
10024584:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
                   RT_NAME_MAX,
                   timer->parent.name,
10024588:	e51b200c 	ldr	r2, [fp, #-12]
    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
1002458c:	e51b300c 	ldr	r3, [fp, #-12]
10024590:	e593c020 	ldr	ip, [r3, #32]
10024594:	e51b300c 	ldr	r3, [fp, #-12]
10024598:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1002459c:	e58d3000 	str	r3, [sp]
100245a0:	e3050630 	movw	r0, #22064	; 0x5630
100245a4:	e3410003 	movt	r0, #4099	; 0x1003
100245a8:	e3a01006 	mov	r1, #6
100245ac:	e1a0300c 	mov	r3, ip
100245b0:	ebffbd42 	bl	10013ac0 <rt_kprintf>
                   RT_NAME_MAX,
                   timer->parent.name,
                   timer->init_tick,
                   timer->timeout_tick);
        if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
100245b4:	e51b300c 	ldr	r3, [fp, #-12]
100245b8:	e5d33007 	ldrb	r3, [r3, #7]
100245bc:	e2033001 	and	r3, r3, #1
100245c0:	e3530000 	cmp	r3, #0
100245c4:	0a000003 	beq	100245d8 <_list_timer+0x94>
            rt_kprintf("activated\n");
100245c8:	e3050648 	movw	r0, #22088	; 0x5648
100245cc:	e3410003 	movt	r0, #4099	; 0x1003
100245d0:	ebffbd3a 	bl	10013ac0 <rt_kprintf>
100245d4:	ea000002 	b	100245e4 <_list_timer+0xa0>
        else
            rt_kprintf("deactivated\n");
100245d8:	e3050654 	movw	r0, #22100	; 0x5654
100245dc:	e3410003 	movt	r0, #4099	; 0x1003
100245e0:	ebffbd36 	bl	10013ac0 <rt_kprintf>
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
100245e4:	e51b3008 	ldr	r3, [fp, #-8]
100245e8:	e5933000 	ldr	r3, [r3]
100245ec:	e50b3008 	str	r3, [fp, #-8]
100245f0:	e51b2008 	ldr	r2, [fp, #-8]
100245f4:	e51b3010 	ldr	r3, [fp, #-16]
100245f8:	e1520003 	cmp	r2, r3
100245fc:	1affffde 	bne	1002457c <_list_timer+0x38>
            rt_kprintf("activated\n");
        else
            rt_kprintf("deactivated\n");
    }

    rt_kprintf("current tick:0x%08x\n", rt_tick_get());
10024600:	ebffa74f 	bl	1000e344 <rt_tick_get>
10024604:	e1a03000 	mov	r3, r0
10024608:	e3050664 	movw	r0, #22116	; 0x5664
1002460c:	e3410003 	movt	r0, #4099	; 0x1003
10024610:	e1a01003 	mov	r1, r3
10024614:	ebffbd29 	bl	10013ac0 <rt_kprintf>

    return 0;
10024618:	e3a03000 	mov	r3, #0
}
1002461c:	e1a00003 	mov	r0, r3
10024620:	e24bd004 	sub	sp, fp, #4
10024624:	e8bd8800 	pop	{fp, pc}

10024628 <list_timer>:

long list_timer(void)
{
10024628:	e92d4800 	push	{fp, lr}
1002462c:	e28db004 	add	fp, sp, #4
    return _list_timer(&rt_object_container[RT_Object_Class_Timer].object_list);
10024630:	e59f000c 	ldr	r0, [pc, #12]	; 10024644 <list_timer+0x1c>
10024634:	ebffffc2 	bl	10024544 <_list_timer>
10024638:	e1a03000 	mov	r3, r0
}
1002463c:	e1a00003 	mov	r0, r3
10024640:	e8bd8800 	pop	{fp, pc}
10024644:	100368fc 	.word	0x100368fc

10024648 <_list_device>:
FINSH_FUNCTION_EXPORT(list_timer, list timer in system);
MSH_CMD_EXPORT(list_timer, list timer in system);

#ifdef RT_USING_DEVICE
static long _list_device(struct rt_list_node *list)
{
10024648:	e92d4800 	push	{fp, lr}
1002464c:	e28db004 	add	fp, sp, #4
10024650:	e24dd068 	sub	sp, sp, #104	; 0x68
10024654:	e50b0060 	str	r0, [fp, #-96]	; 0x60
    struct rt_device *device;
    struct rt_list_node *node;
    char * const device_type_str[] =
10024658:	e3053804 	movw	r3, #22532	; 0x5804
1002465c:	e3413003 	movt	r3, #4099	; 0x1003
10024660:	e24b205c 	sub	r2, fp, #92	; 0x5c
10024664:	e1a01003 	mov	r1, r3
10024668:	e3a03050 	mov	r3, #80	; 0x50
1002466c:	e1a00002 	mov	r0, r2
10024670:	e1a02003 	mov	r2, r3
10024674:	fa002b1e 	blx	1002f2f4 <memcpy>
		"Timer Device",
		"Miscellaneous Device",
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
10024678:	e305067c 	movw	r0, #22140	; 0x567c
1002467c:	e3410003 	movt	r0, #4099	; 0x1003
10024680:	ebffbd0e 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("-------- -------------------- ----------\n");
10024684:	e30506a8 	movw	r0, #22184	; 0x56a8
10024688:	e3410003 	movt	r0, #4099	; 0x1003
1002468c:	ebffbd0b 	bl	10013ac0 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10024690:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
10024694:	e5933000 	ldr	r3, [r3]
10024698:	e50b3008 	str	r3, [fp, #-8]
1002469c:	ea00001a 	b	1002470c <_list_device+0xc4>
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
100246a0:	e51b3008 	ldr	r3, [fp, #-8]
100246a4:	e2433008 	sub	r3, r3, #8
100246a8:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%-8.*s %-20s %-8d\n",
                   RT_NAME_MAX,
                   device->parent.name,
100246ac:	e51bc00c 	ldr	ip, [fp, #-12]
                   (device->type <= RT_Device_Class_Unknown) ?
100246b0:	e51b300c 	ldr	r3, [fp, #-12]
100246b4:	e5d33010 	ldrb	r3, [r3, #16]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
100246b8:	e3530013 	cmp	r3, #19
100246bc:	8a000006 	bhi	100246dc <_list_device+0x94>
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
100246c0:	e51b300c 	ldr	r3, [fp, #-12]
100246c4:	e5d33010 	ldrb	r3, [r3, #16]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
100246c8:	e1a03103 	lsl	r3, r3, #2
100246cc:	e24b2004 	sub	r2, fp, #4
100246d0:	e0823003 	add	r3, r2, r3
100246d4:	e5133058 	ldr	r3, [r3, #-88]	; 0x58
100246d8:	ea000000 	b	100246e0 <_list_device+0x98>
100246dc:	e51b3010 	ldr	r3, [fp, #-16]
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
100246e0:	e51b200c 	ldr	r2, [fp, #-12]
100246e4:	e5d22016 	ldrb	r2, [r2, #22]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
100246e8:	e58d2000 	str	r2, [sp]
100246ec:	e30506d4 	movw	r0, #22228	; 0x56d4
100246f0:	e3410003 	movt	r0, #4099	; 0x1003
100246f4:	e3a01006 	mov	r1, #6
100246f8:	e1a0200c 	mov	r2, ip
100246fc:	ebffbcef 	bl	10013ac0 <rt_kprintf>
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
10024700:	e51b3008 	ldr	r3, [fp, #-8]
10024704:	e5933000 	ldr	r3, [r3]
10024708:	e50b3008 	str	r3, [fp, #-8]
1002470c:	e51b2008 	ldr	r2, [fp, #-8]
10024710:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
10024714:	e1520003 	cmp	r2, r3
10024718:	1affffe0 	bne	100246a0 <_list_device+0x58>
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
    }

    return 0;
1002471c:	e3a03000 	mov	r3, #0
}
10024720:	e1a00003 	mov	r0, r3
10024724:	e24bd004 	sub	sp, fp, #4
10024728:	e8bd8800 	pop	{fp, pc}

1002472c <list_device>:

long list_device(void)
{
1002472c:	e92d4800 	push	{fp, lr}
10024730:	e28db004 	add	fp, sp, #4
    return _list_device(&rt_object_container[RT_Object_Class_Device].object_list);
10024734:	e59f000c 	ldr	r0, [pc, #12]	; 10024748 <list_device+0x1c>
10024738:	ebffffc2 	bl	10024648 <_list_device>
1002473c:	e1a03000 	mov	r3, r0
}
10024740:	e1a00003 	mov	r0, r3
10024744:	e8bd8800 	pop	{fp, pc}
10024748:	100368ec 	.word	0x100368ec

1002474c <list>:
}
FINSH_FUNCTION_EXPORT(list_mod_detail, list module objects in system)
#endif

long list(void)
{
1002474c:	e92d4800 	push	{fp, lr}
10024750:	e28db004 	add	fp, sp, #4
10024754:	e24dd010 	sub	sp, sp, #16
#ifndef FINSH_USING_MSH_ONLY
    struct finsh_syscall_item *syscall_item;
    struct finsh_sysvar_item *sysvar_item;
#endif
	
    rt_kprintf("--Function List:\n");
10024758:	e3050854 	movw	r0, #22612	; 0x5854
1002475c:	e3410003 	movt	r0, #4099	; 0x1003
10024760:	ebffbcd6 	bl	10013ac0 <rt_kprintf>
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
10024764:	e30f3934 	movw	r3, #63796	; 0xf934
10024768:	e3413003 	movt	r3, #4099	; 0x1003
1002476c:	e5933000 	ldr	r3, [r3]
10024770:	e50b3010 	str	r3, [fp, #-16]
10024774:	ea000016 	b	100247d4 <list+0x88>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip the internal command */
			if (strncmp((char*)index->name, "__", 2) == 0) continue;
10024778:	e51b3010 	ldr	r3, [fp, #-16]
1002477c:	e5933000 	ldr	r3, [r3]
10024780:	e1a00003 	mov	r0, r3
10024784:	e3051868 	movw	r1, #22632	; 0x5868
10024788:	e3411003 	movt	r1, #4099	; 0x1003
1002478c:	e3a02002 	mov	r2, #2
10024790:	fa002c1b 	blx	1002f804 <strncmp>
10024794:	e1a03000 	mov	r3, r0
10024798:	e3530000 	cmp	r3, #0
1002479c:	1a000000 	bne	100247a4 <list+0x58>
100247a0:	ea000008 	b	100247c8 <list+0x7c>

#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
100247a4:	e51b3010 	ldr	r3, [fp, #-16]
100247a8:	e5932000 	ldr	r2, [r3]
100247ac:	e51b3010 	ldr	r3, [fp, #-16]
100247b0:	e5933004 	ldr	r3, [r3, #4]
100247b4:	e305086c 	movw	r0, #22636	; 0x586c
100247b8:	e3410003 	movt	r0, #4099	; 0x1003
100247bc:	e1a01002 	mov	r1, r2
100247c0:	e1a02003 	mov	r2, r3
100247c4:	ebffbcbd 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
100247c8:	e51b3010 	ldr	r3, [fp, #-16]
100247cc:	e283300c 	add	r3, r3, #12
100247d0:	e50b3010 	str	r3, [fp, #-16]
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
100247d4:	e30f3938 	movw	r3, #63800	; 0xf938
100247d8:	e3413003 	movt	r3, #4099	; 0x1003
100247dc:	e5933000 	ldr	r3, [r3]
#endif
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
100247e0:	e51b2010 	ldr	r2, [fp, #-16]
100247e4:	e1520003 	cmp	r2, r3
100247e8:	3affffe2 	bcc	10024778 <list+0x2c>
        }
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
100247ec:	e30f3950 	movw	r3, #63824	; 0xf950
100247f0:	e3413003 	movt	r3, #4099	; 0x1003
100247f4:	e5933000 	ldr	r3, [r3]
100247f8:	e50b3008 	str	r3, [fp, #-8]
    while (syscall_item != NULL)
100247fc:	ea000008 	b	10024824 <list+0xd8>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
10024800:	e51b3008 	ldr	r3, [fp, #-8]
10024804:	e5933004 	ldr	r3, [r3, #4]
10024808:	e305087c 	movw	r0, #22652	; 0x587c
1002480c:	e3410003 	movt	r0, #4099	; 0x1003
10024810:	e1a01003 	mov	r1, r3
10024814:	ebffbca9 	bl	10013ac0 <rt_kprintf>
        syscall_item = syscall_item->next;
10024818:	e51b3008 	ldr	r3, [fp, #-8]
1002481c:	e5933000 	ldr	r3, [r3]
10024820:	e50b3008 	str	r3, [fp, #-8]
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
10024824:	e51b3008 	ldr	r3, [fp, #-8]
10024828:	e3530000 	cmp	r3, #0
1002482c:	1afffff3 	bne	10024800 <list+0xb4>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
        syscall_item = syscall_item->next;
    }

    rt_kprintf("--Variable List:\n");
10024830:	e3050884 	movw	r0, #22660	; 0x5884
10024834:	e3410003 	movt	r0, #4099	; 0x1003
10024838:	ebffbca0 	bl	10013ac0 <rt_kprintf>
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
1002483c:	e30f393c 	movw	r3, #63804	; 0xf93c
10024840:	e3413003 	movt	r3, #4099	; 0x1003
10024844:	e5933000 	ldr	r3, [r3]
10024848:	e50b3014 	str	r3, [fp, #-20]
1002484c:	ea00000b 	b	10024880 <list+0x134>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
10024850:	e51b3014 	ldr	r3, [fp, #-20]
10024854:	e5932000 	ldr	r2, [r3]
10024858:	e51b3014 	ldr	r3, [fp, #-20]
1002485c:	e5933004 	ldr	r3, [r3, #4]
10024860:	e305086c 	movw	r0, #22636	; 0x586c
10024864:	e3410003 	movt	r0, #4099	; 0x1003
10024868:	e1a01002 	mov	r1, r2
1002486c:	e1a02003 	mov	r2, r3
10024870:	ebffbc92 	bl	10013ac0 <rt_kprintf>
    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
10024874:	e51b3014 	ldr	r3, [fp, #-20]
10024878:	e2833010 	add	r3, r3, #16
1002487c:	e50b3014 	str	r3, [fp, #-20]

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
10024880:	e30f3940 	movw	r3, #63808	; 0xf940
10024884:	e3413003 	movt	r3, #4099	; 0x1003
10024888:	e5933000 	ldr	r3, [r3]
    }

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
1002488c:	e51b2014 	ldr	r2, [fp, #-20]
10024890:	e1520003 	cmp	r2, r3
10024894:	3affffed 	bcc	10024850 <list+0x104>
            rt_kprintf("%s\n", index->name);
#endif
        }
    }

    sysvar_item = global_sysvar_list;
10024898:	e3033760 	movw	r3, #14176	; 0x3760
1002489c:	e3413004 	movt	r3, #4100	; 0x1004
100248a0:	e5933000 	ldr	r3, [r3]
100248a4:	e50b300c 	str	r3, [fp, #-12]
    while (sysvar_item != NULL)
100248a8:	ea000008 	b	100248d0 <list+0x184>
    {
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
100248ac:	e51b300c 	ldr	r3, [fp, #-12]
100248b0:	e5933004 	ldr	r3, [r3, #4]
100248b4:	e305087c 	movw	r0, #22652	; 0x587c
100248b8:	e3410003 	movt	r0, #4099	; 0x1003
100248bc:	e1a01003 	mov	r1, r3
100248c0:	ebffbc7e 	bl	10013ac0 <rt_kprintf>
        sysvar_item = sysvar_item->next;
100248c4:	e51b300c 	ldr	r3, [fp, #-12]
100248c8:	e5933000 	ldr	r3, [r3]
100248cc:	e50b300c 	str	r3, [fp, #-12]
#endif
        }
    }

    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
100248d0:	e51b300c 	ldr	r3, [fp, #-12]
100248d4:	e3530000 	cmp	r3, #0
100248d8:	1afffff3 	bne	100248ac <list+0x160>
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
        sysvar_item = sysvar_item->next;
    }
#endif
	
    return 0;
100248dc:	e3a03000 	mov	r3, #0
}
100248e0:	e1a00003 	mov	r0, r3
100248e4:	e24bd004 	sub	sp, fp, #4
100248e8:	e8bd8800 	pop	{fp, pc}

100248ec <str_is_prefix>:
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
100248ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100248f0:	e28db000 	add	fp, sp, #0
100248f4:	e24dd00c 	sub	sp, sp, #12
100248f8:	e50b0008 	str	r0, [fp, #-8]
100248fc:	e50b100c 	str	r1, [fp, #-12]
    while ((*prefix) && (*prefix == *str))
10024900:	ea000005 	b	1002491c <str_is_prefix+0x30>
    {
        prefix ++;
10024904:	e51b3008 	ldr	r3, [fp, #-8]
10024908:	e2833001 	add	r3, r3, #1
1002490c:	e50b3008 	str	r3, [fp, #-8]
        str ++;
10024910:	e51b300c 	ldr	r3, [fp, #-12]
10024914:	e2833001 	add	r3, r3, #1
10024918:	e50b300c 	str	r3, [fp, #-12]
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
    while ((*prefix) && (*prefix == *str))
1002491c:	e51b3008 	ldr	r3, [fp, #-8]
10024920:	e5d33000 	ldrb	r3, [r3]
10024924:	e3530000 	cmp	r3, #0
10024928:	0a000005 	beq	10024944 <str_is_prefix+0x58>
1002492c:	e51b3008 	ldr	r3, [fp, #-8]
10024930:	e5d32000 	ldrb	r2, [r3]
10024934:	e51b300c 	ldr	r3, [fp, #-12]
10024938:	e5d33000 	ldrb	r3, [r3]
1002493c:	e1520003 	cmp	r2, r3
10024940:	0affffef 	beq	10024904 <str_is_prefix+0x18>
    {
        prefix ++;
        str ++;
    }

    if (*prefix == 0)
10024944:	e51b3008 	ldr	r3, [fp, #-8]
10024948:	e5d33000 	ldrb	r3, [r3]
1002494c:	e3530000 	cmp	r3, #0
10024950:	1a000001 	bne	1002495c <str_is_prefix+0x70>
        return 0;
10024954:	e3a03000 	mov	r3, #0
10024958:	ea000000 	b	10024960 <str_is_prefix+0x74>

    return -1;
1002495c:	e3e03000 	mvn	r3, #0
}
10024960:	e1a00003 	mov	r0, r3
10024964:	e24bd000 	sub	sp, fp, #0
10024968:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002496c:	e12fff1e 	bx	lr

10024970 <str_common>:

static int str_common(const char *str1, const char *str2)
{
10024970:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10024974:	e28db000 	add	fp, sp, #0
10024978:	e24dd014 	sub	sp, sp, #20
1002497c:	e50b0010 	str	r0, [fp, #-16]
10024980:	e50b1014 	str	r1, [fp, #-20]
    const char *str = str1;
10024984:	e51b3010 	ldr	r3, [fp, #-16]
10024988:	e50b3008 	str	r3, [fp, #-8]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
1002498c:	ea000005 	b	100249a8 <str_common+0x38>
    {
        str ++;
10024990:	e51b3008 	ldr	r3, [fp, #-8]
10024994:	e2833001 	add	r3, r3, #1
10024998:	e50b3008 	str	r3, [fp, #-8]
        str2 ++;
1002499c:	e51b3014 	ldr	r3, [fp, #-20]
100249a0:	e2833001 	add	r3, r3, #1
100249a4:	e50b3014 	str	r3, [fp, #-20]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
100249a8:	e51b3008 	ldr	r3, [fp, #-8]
100249ac:	e5d33000 	ldrb	r3, [r3]
100249b0:	e3530000 	cmp	r3, #0
100249b4:	0a000009 	beq	100249e0 <str_common+0x70>
100249b8:	e51b3014 	ldr	r3, [fp, #-20]
100249bc:	e5d33000 	ldrb	r3, [r3]
100249c0:	e3530000 	cmp	r3, #0
100249c4:	0a000005 	beq	100249e0 <str_common+0x70>
100249c8:	e51b3008 	ldr	r3, [fp, #-8]
100249cc:	e5d32000 	ldrb	r2, [r3]
100249d0:	e51b3014 	ldr	r3, [fp, #-20]
100249d4:	e5d33000 	ldrb	r3, [r3]
100249d8:	e1520003 	cmp	r2, r3
100249dc:	0affffeb 	beq	10024990 <str_common+0x20>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
100249e0:	e51b2008 	ldr	r2, [fp, #-8]
100249e4:	e51b3010 	ldr	r3, [fp, #-16]
100249e8:	e0633002 	rsb	r3, r3, r2
}
100249ec:	e1a00003 	mov	r0, r3
100249f0:	e24bd000 	sub	sp, fp, #0
100249f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100249f8:	e12fff1e 	bx	lr

100249fc <list_prefix>:

void list_prefix(char *prefix)
{
100249fc:	e92d4800 	push	{fp, lr}
10024a00:	e28db004 	add	fp, sp, #4
10024a04:	e24dd028 	sub	sp, sp, #40	; 0x28
10024a08:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    struct finsh_sysvar_item *sysvar_item;
    rt_uint16_t func_cnt, var_cnt;
    int length, min_length;
    const char *name_ptr;

    func_cnt = 0;
10024a0c:	e3a03000 	mov	r3, #0
10024a10:	e14b30be 	strh	r3, [fp, #-14]
    var_cnt  = 0;
10024a14:	e3a03000 	mov	r3, #0
10024a18:	e14b31b0 	strh	r3, [fp, #-16]
    min_length = 0;
10024a1c:	e3a03000 	mov	r3, #0
10024a20:	e50b3014 	str	r3, [fp, #-20]
    name_ptr = RT_NULL;
10024a24:	e3a03000 	mov	r3, #0
10024a28:	e50b3018 	str	r3, [fp, #-24]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
10024a2c:	e30f3934 	movw	r3, #63796	; 0xf934
10024a30:	e3413003 	movt	r3, #4099	; 0x1003
10024a34:	e5933000 	ldr	r3, [r3]
10024a38:	e50b301c 	str	r3, [fp, #-28]
10024a3c:	ea000041 	b	10024b48 <list_prefix+0x14c>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip internal command */
			if (str_is_prefix("__", index->name) == 0) continue;
10024a40:	e51b301c 	ldr	r3, [fp, #-28]
10024a44:	e5933000 	ldr	r3, [r3]
10024a48:	e3050868 	movw	r0, #22632	; 0x5868
10024a4c:	e3410003 	movt	r0, #4099	; 0x1003
10024a50:	e1a01003 	mov	r1, r3
10024a54:	ebffffa4 	bl	100248ec <str_is_prefix>
10024a58:	e1a03000 	mov	r3, r0
10024a5c:	e3530000 	cmp	r3, #0
10024a60:	1a000000 	bne	10024a68 <list_prefix+0x6c>
10024a64:	ea000034 	b	10024b3c <list_prefix+0x140>
			
            if (str_is_prefix(prefix, index->name) == 0)
10024a68:	e51b301c 	ldr	r3, [fp, #-28]
10024a6c:	e5933000 	ldr	r3, [r3]
10024a70:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10024a74:	e1a01003 	mov	r1, r3
10024a78:	ebffff9b 	bl	100248ec <str_is_prefix>
10024a7c:	e1a03000 	mov	r3, r0
10024a80:	e3530000 	cmp	r3, #0
10024a84:	1a00002c 	bne	10024b3c <list_prefix+0x140>
            {
                if (func_cnt == 0)
10024a88:	e15b30be 	ldrh	r3, [fp, #-14]
10024a8c:	e3530000 	cmp	r3, #0
10024a90:	1a00000d 	bne	10024acc <list_prefix+0xd0>
                {
                    rt_kprintf("--function:\n");
10024a94:	e3050898 	movw	r0, #22680	; 0x5898
10024a98:	e3410003 	movt	r0, #4099	; 0x1003
10024a9c:	ebffbc07 	bl	10013ac0 <rt_kprintf>

                    if (*prefix != 0)
10024aa0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10024aa4:	e5d33000 	ldrb	r3, [r3]
10024aa8:	e3530000 	cmp	r3, #0
10024aac:	0a000006 	beq	10024acc <list_prefix+0xd0>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
10024ab0:	e51b301c 	ldr	r3, [fp, #-28]
10024ab4:	e5933000 	ldr	r3, [r3]
10024ab8:	e50b3018 	str	r3, [fp, #-24]

                        /* set initial length */
                        min_length = strlen(name_ptr);
10024abc:	e51b0018 	ldr	r0, [fp, #-24]
10024ac0:	fa002b38 	blx	1002f7a8 <strlen>
10024ac4:	e1a03000 	mov	r3, r0
10024ac8:	e50b3014 	str	r3, [fp, #-20]
                    }
                }

                func_cnt ++;
10024acc:	e15b30be 	ldrh	r3, [fp, #-14]
10024ad0:	e2833001 	add	r3, r3, #1
10024ad4:	e14b30be 	strh	r3, [fp, #-14]

                if (*prefix != 0)
10024ad8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10024adc:	e5d33000 	ldrb	r3, [r3]
10024ae0:	e3530000 	cmp	r3, #0
10024ae4:	0a00000b 	beq	10024b18 <list_prefix+0x11c>
                {
                    length = str_common(name_ptr, index->name);
10024ae8:	e51b301c 	ldr	r3, [fp, #-28]
10024aec:	e5933000 	ldr	r3, [r3]
10024af0:	e51b0018 	ldr	r0, [fp, #-24]
10024af4:	e1a01003 	mov	r1, r3
10024af8:	ebffff9c 	bl	10024970 <str_common>
10024afc:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                    if (length < min_length)
10024b00:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10024b04:	e51b3014 	ldr	r3, [fp, #-20]
10024b08:	e1520003 	cmp	r2, r3
10024b0c:	aa000001 	bge	10024b18 <list_prefix+0x11c>
                        min_length = length;
10024b10:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10024b14:	e50b3014 	str	r3, [fp, #-20]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
10024b18:	e51b301c 	ldr	r3, [fp, #-28]
10024b1c:	e5932000 	ldr	r2, [r3]
10024b20:	e51b301c 	ldr	r3, [fp, #-28]
10024b24:	e5933004 	ldr	r3, [r3, #4]
10024b28:	e305086c 	movw	r0, #22636	; 0x586c
10024b2c:	e3410003 	movt	r0, #4099	; 0x1003
10024b30:	e1a01002 	mov	r1, r2
10024b34:	e1a02003 	mov	r2, r3
10024b38:	ebffbbe0 	bl	10013ac0 <rt_kprintf>
    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
10024b3c:	e51b301c 	ldr	r3, [fp, #-28]
10024b40:	e283300c 	add	r3, r3, #12
10024b44:	e50b301c 	str	r3, [fp, #-28]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
10024b48:	e30f3938 	movw	r3, #63800	; 0xf938
10024b4c:	e3413003 	movt	r3, #4099	; 0x1003
10024b50:	e5933000 	ldr	r3, [r3]
    name_ptr = RT_NULL;

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
10024b54:	e51b201c 	ldr	r2, [fp, #-28]
10024b58:	e1520003 	cmp	r2, r3
10024b5c:	3affffb7 	bcc	10024a40 <list_prefix+0x44>
            }
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
10024b60:	e30f3950 	movw	r3, #63824	; 0xf950
10024b64:	e3413003 	movt	r3, #4099	; 0x1003
10024b68:	e5933000 	ldr	r3, [r3]
10024b6c:	e50b3008 	str	r3, [fp, #-8]
    while (syscall_item != NULL)
10024b70:	ea000037 	b	10024c54 <list_prefix+0x258>
    {
        if (str_is_prefix(prefix, syscall_item->syscall.name) == 0)
10024b74:	e51b3008 	ldr	r3, [fp, #-8]
10024b78:	e5933004 	ldr	r3, [r3, #4]
10024b7c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10024b80:	e1a01003 	mov	r1, r3
10024b84:	ebffff58 	bl	100248ec <str_is_prefix>
10024b88:	e1a03000 	mov	r3, r0
10024b8c:	e3530000 	cmp	r3, #0
10024b90:	1a00002c 	bne	10024c48 <list_prefix+0x24c>
        {
            if (func_cnt == 0)
10024b94:	e15b30be 	ldrh	r3, [fp, #-14]
10024b98:	e3530000 	cmp	r3, #0
10024b9c:	1a000010 	bne	10024be4 <list_prefix+0x1e8>
            {
                rt_kprintf("--function:\n");
10024ba0:	e3050898 	movw	r0, #22680	; 0x5898
10024ba4:	e3410003 	movt	r0, #4099	; 0x1003
10024ba8:	ebffbbc4 	bl	10013ac0 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
10024bac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10024bb0:	e5d33000 	ldrb	r3, [r3]
10024bb4:	e3530000 	cmp	r3, #0
10024bb8:	0a000009 	beq	10024be4 <list_prefix+0x1e8>
10024bbc:	e51b3018 	ldr	r3, [fp, #-24]
10024bc0:	e3530000 	cmp	r3, #0
10024bc4:	1a000006 	bne	10024be4 <list_prefix+0x1e8>
                {
                    /* set name_ptr */
                    name_ptr = syscall_item->syscall.name;
10024bc8:	e51b3008 	ldr	r3, [fp, #-8]
10024bcc:	e5933004 	ldr	r3, [r3, #4]
10024bd0:	e50b3018 	str	r3, [fp, #-24]

                    /* set initial length */
                    min_length = strlen(name_ptr);
10024bd4:	e51b0018 	ldr	r0, [fp, #-24]
10024bd8:	fa002af2 	blx	1002f7a8 <strlen>
10024bdc:	e1a03000 	mov	r3, r0
10024be0:	e50b3014 	str	r3, [fp, #-20]
                }
            }

            func_cnt ++;
10024be4:	e15b30be 	ldrh	r3, [fp, #-14]
10024be8:	e2833001 	add	r3, r3, #1
10024bec:	e14b30be 	strh	r3, [fp, #-14]

            if (*prefix != 0)
10024bf0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10024bf4:	e5d33000 	ldrb	r3, [r3]
10024bf8:	e3530000 	cmp	r3, #0
10024bfc:	0a00000b 	beq	10024c30 <list_prefix+0x234>
            {
                length = str_common(name_ptr, syscall_item->syscall.name);
10024c00:	e51b3008 	ldr	r3, [fp, #-8]
10024c04:	e5933004 	ldr	r3, [r3, #4]
10024c08:	e51b0018 	ldr	r0, [fp, #-24]
10024c0c:	e1a01003 	mov	r1, r3
10024c10:	ebffff56 	bl	10024970 <str_common>
10024c14:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                if (length < min_length)
10024c18:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10024c1c:	e51b3014 	ldr	r3, [fp, #-20]
10024c20:	e1520003 	cmp	r2, r3
10024c24:	aa000001 	bge	10024c30 <list_prefix+0x234>
                    min_length = length;
10024c28:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10024c2c:	e50b3014 	str	r3, [fp, #-20]
            }

            rt_kprintf("[l] %s\n", syscall_item->syscall.name);
10024c30:	e51b3008 	ldr	r3, [fp, #-8]
10024c34:	e5933004 	ldr	r3, [r3, #4]
10024c38:	e305087c 	movw	r0, #22652	; 0x587c
10024c3c:	e3410003 	movt	r0, #4099	; 0x1003
10024c40:	e1a01003 	mov	r1, r3
10024c44:	ebffbb9d 	bl	10013ac0 <rt_kprintf>
        }
        syscall_item = syscall_item->next;
10024c48:	e51b3008 	ldr	r3, [fp, #-8]
10024c4c:	e5933000 	ldr	r3, [r3]
10024c50:	e50b3008 	str	r3, [fp, #-8]
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
10024c54:	e51b3008 	ldr	r3, [fp, #-8]
10024c58:	e3530000 	cmp	r3, #0
10024c5c:	1affffc4 	bne	10024b74 <list_prefix+0x178>
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
10024c60:	e30f393c 	movw	r3, #63804	; 0xf93c
10024c64:	e3413003 	movt	r3, #4099	; 0x1003
10024c68:	e5933000 	ldr	r3, [r3]
10024c6c:	e50b3020 	str	r3, [fp, #-32]
10024c70:	ea00003a 	b	10024d60 <list_prefix+0x364>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
            if (str_is_prefix(prefix, index->name) == 0)
10024c74:	e51b3020 	ldr	r3, [fp, #-32]
10024c78:	e5933000 	ldr	r3, [r3]
10024c7c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10024c80:	e1a01003 	mov	r1, r3
10024c84:	ebffff18 	bl	100248ec <str_is_prefix>
10024c88:	e1a03000 	mov	r3, r0
10024c8c:	e3530000 	cmp	r3, #0
10024c90:	1a00002f 	bne	10024d54 <list_prefix+0x358>
            {
                if (var_cnt == 0)
10024c94:	e15b31b0 	ldrh	r3, [fp, #-16]
10024c98:	e3530000 	cmp	r3, #0
10024c9c:	1a000010 	bne	10024ce4 <list_prefix+0x2e8>
                {
                    rt_kprintf("--variable:\n");
10024ca0:	e30508a8 	movw	r0, #22696	; 0x58a8
10024ca4:	e3410003 	movt	r0, #4099	; 0x1003
10024ca8:	ebffbb84 	bl	10013ac0 <rt_kprintf>

                    if (*prefix != 0 && name_ptr == NULL)
10024cac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10024cb0:	e5d33000 	ldrb	r3, [r3]
10024cb4:	e3530000 	cmp	r3, #0
10024cb8:	0a000009 	beq	10024ce4 <list_prefix+0x2e8>
10024cbc:	e51b3018 	ldr	r3, [fp, #-24]
10024cc0:	e3530000 	cmp	r3, #0
10024cc4:	1a000006 	bne	10024ce4 <list_prefix+0x2e8>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
10024cc8:	e51b3020 	ldr	r3, [fp, #-32]
10024ccc:	e5933000 	ldr	r3, [r3]
10024cd0:	e50b3018 	str	r3, [fp, #-24]

                        /* set initial length */
                        min_length = strlen(name_ptr);
10024cd4:	e51b0018 	ldr	r0, [fp, #-24]
10024cd8:	fa002ab2 	blx	1002f7a8 <strlen>
10024cdc:	e1a03000 	mov	r3, r0
10024ce0:	e50b3014 	str	r3, [fp, #-20]

                    }
                }

                var_cnt ++;
10024ce4:	e15b31b0 	ldrh	r3, [fp, #-16]
10024ce8:	e2833001 	add	r3, r3, #1
10024cec:	e14b31b0 	strh	r3, [fp, #-16]

                if (*prefix != 0)
10024cf0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10024cf4:	e5d33000 	ldrb	r3, [r3]
10024cf8:	e3530000 	cmp	r3, #0
10024cfc:	0a00000b 	beq	10024d30 <list_prefix+0x334>
                {
                    length = str_common(name_ptr, index->name);
10024d00:	e51b3020 	ldr	r3, [fp, #-32]
10024d04:	e5933000 	ldr	r3, [r3]
10024d08:	e51b0018 	ldr	r0, [fp, #-24]
10024d0c:	e1a01003 	mov	r1, r3
10024d10:	ebffff16 	bl	10024970 <str_common>
10024d14:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                    if (length < min_length)
10024d18:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10024d1c:	e51b3014 	ldr	r3, [fp, #-20]
10024d20:	e1520003 	cmp	r2, r3
10024d24:	aa000001 	bge	10024d30 <list_prefix+0x334>
                        min_length = length;
10024d28:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10024d2c:	e50b3014 	str	r3, [fp, #-20]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
10024d30:	e51b3020 	ldr	r3, [fp, #-32]
10024d34:	e5932000 	ldr	r2, [r3]
10024d38:	e51b3020 	ldr	r3, [fp, #-32]
10024d3c:	e5933004 	ldr	r3, [r3, #4]
10024d40:	e305086c 	movw	r0, #22636	; 0x586c
10024d44:	e3410003 	movt	r0, #4099	; 0x1003
10024d48:	e1a01002 	mov	r1, r2
10024d4c:	e1a02003 	mov	r2, r3
10024d50:	ebffbb5a 	bl	10013ac0 <rt_kprintf>
    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
10024d54:	e51b3020 	ldr	r3, [fp, #-32]
10024d58:	e2833010 	add	r3, r3, #16
10024d5c:	e50b3020 	str	r3, [fp, #-32]

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
10024d60:	e30f3940 	movw	r3, #63808	; 0xf940
10024d64:	e3413003 	movt	r3, #4099	; 0x1003
10024d68:	e5933000 	ldr	r3, [r3]
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
10024d6c:	e51b2020 	ldr	r2, [fp, #-32]
10024d70:	e1520003 	cmp	r2, r3
10024d74:	3affffbe 	bcc	10024c74 <list_prefix+0x278>
            }
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
10024d78:	e3033760 	movw	r3, #14176	; 0x3760
10024d7c:	e3413004 	movt	r3, #4100	; 0x1004
10024d80:	e5933000 	ldr	r3, [r3]
10024d84:	e50b300c 	str	r3, [fp, #-12]
    while (sysvar_item != NULL)
10024d88:	ea000037 	b	10024e6c <list_prefix+0x470>
    {
        if (str_is_prefix(prefix, sysvar_item->sysvar.name) == 0)
10024d8c:	e51b300c 	ldr	r3, [fp, #-12]
10024d90:	e5933004 	ldr	r3, [r3, #4]
10024d94:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10024d98:	e1a01003 	mov	r1, r3
10024d9c:	ebfffed2 	bl	100248ec <str_is_prefix>
10024da0:	e1a03000 	mov	r3, r0
10024da4:	e3530000 	cmp	r3, #0
10024da8:	1a00002c 	bne	10024e60 <list_prefix+0x464>
        {
            if (var_cnt == 0)
10024dac:	e15b31b0 	ldrh	r3, [fp, #-16]
10024db0:	e3530000 	cmp	r3, #0
10024db4:	1a000010 	bne	10024dfc <list_prefix+0x400>
            {
                rt_kprintf("--variable:\n");
10024db8:	e30508a8 	movw	r0, #22696	; 0x58a8
10024dbc:	e3410003 	movt	r0, #4099	; 0x1003
10024dc0:	ebffbb3e 	bl	10013ac0 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
10024dc4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10024dc8:	e5d33000 	ldrb	r3, [r3]
10024dcc:	e3530000 	cmp	r3, #0
10024dd0:	0a000009 	beq	10024dfc <list_prefix+0x400>
10024dd4:	e51b3018 	ldr	r3, [fp, #-24]
10024dd8:	e3530000 	cmp	r3, #0
10024ddc:	1a000006 	bne	10024dfc <list_prefix+0x400>
                {
                    /* set name_ptr */
                    name_ptr = sysvar_item->sysvar.name;
10024de0:	e51b300c 	ldr	r3, [fp, #-12]
10024de4:	e5933004 	ldr	r3, [r3, #4]
10024de8:	e50b3018 	str	r3, [fp, #-24]

                    /* set initial length */
                    min_length = strlen(name_ptr);
10024dec:	e51b0018 	ldr	r0, [fp, #-24]
10024df0:	fa002a6c 	blx	1002f7a8 <strlen>
10024df4:	e1a03000 	mov	r3, r0
10024df8:	e50b3014 	str	r3, [fp, #-20]
                }
            }

            var_cnt ++;
10024dfc:	e15b31b0 	ldrh	r3, [fp, #-16]
10024e00:	e2833001 	add	r3, r3, #1
10024e04:	e14b31b0 	strh	r3, [fp, #-16]

            if (*prefix != 0)
10024e08:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10024e0c:	e5d33000 	ldrb	r3, [r3]
10024e10:	e3530000 	cmp	r3, #0
10024e14:	0a00000b 	beq	10024e48 <list_prefix+0x44c>
            {
                length = str_common(name_ptr, sysvar_item->sysvar.name);
10024e18:	e51b300c 	ldr	r3, [fp, #-12]
10024e1c:	e5933004 	ldr	r3, [r3, #4]
10024e20:	e51b0018 	ldr	r0, [fp, #-24]
10024e24:	e1a01003 	mov	r1, r3
10024e28:	ebfffed0 	bl	10024970 <str_common>
10024e2c:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                if (length < min_length)
10024e30:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10024e34:	e51b3014 	ldr	r3, [fp, #-20]
10024e38:	e1520003 	cmp	r2, r3
10024e3c:	aa000001 	bge	10024e48 <list_prefix+0x44c>
                    min_length = length;
10024e40:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10024e44:	e50b3014 	str	r3, [fp, #-20]
            }

            rt_kprintf("[v] %s\n", sysvar_item->sysvar.name);
10024e48:	e51b300c 	ldr	r3, [fp, #-12]
10024e4c:	e5933004 	ldr	r3, [r3, #4]
10024e50:	e30508b8 	movw	r0, #22712	; 0x58b8
10024e54:	e3410003 	movt	r0, #4099	; 0x1003
10024e58:	e1a01003 	mov	r1, r3
10024e5c:	ebffbb17 	bl	10013ac0 <rt_kprintf>
        }
        sysvar_item = sysvar_item->next;
10024e60:	e51b300c 	ldr	r3, [fp, #-12]
10024e64:	e5933000 	ldr	r3, [r3]
10024e68:	e50b300c 	str	r3, [fp, #-12]
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
10024e6c:	e51b300c 	ldr	r3, [fp, #-12]
10024e70:	e3530000 	cmp	r3, #0
10024e74:	1affffc4 	bne	10024d8c <list_prefix+0x390>
        }
        sysvar_item = sysvar_item->next;
    }

    /* only one matched */
    if (name_ptr != NULL)
10024e78:	e51b3018 	ldr	r3, [fp, #-24]
10024e7c:	e3530000 	cmp	r3, #0
10024e80:	0a000004 	beq	10024e98 <list_prefix+0x49c>
    {
        rt_strncpy(prefix, name_ptr, min_length);
10024e84:	e51b3014 	ldr	r3, [fp, #-20]
10024e88:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10024e8c:	e51b1018 	ldr	r1, [fp, #-24]
10024e90:	e1a02003 	mov	r2, r3
10024e94:	ebffb670 	bl	1001285c <rt_strncpy>
    }
}
10024e98:	e24bd004 	sub	sp, fp, #4
10024e9c:	e8bd8800 	pop	{fp, pc}

10024ea0 <cmd_ps>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_netstat, __cmd_netstat, list the information of TCP/IP);
#endif
#endif /* RT_USING_LWIP */

int cmd_ps(int argc, char** argv)
{
10024ea0:	e92d4800 	push	{fp, lr}
10024ea4:	e28db004 	add	fp, sp, #4
10024ea8:	e24dd008 	sub	sp, sp, #8
10024eac:	e50b0008 	str	r0, [fp, #-8]
10024eb0:	e50b100c 	str	r1, [fp, #-12]
    extern long list_thread(void);

    list_thread();
10024eb4:	ebfffba2 	bl	10023d44 <list_thread>
    return 0;
10024eb8:	e3a03000 	mov	r3, #0
}
10024ebc:	e1a00003 	mov	r0, r3
10024ec0:	e24bd004 	sub	sp, fp, #4
10024ec4:	e8bd8800 	pop	{fp, pc}

10024ec8 <cmd_time>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_ps, __cmd_ps, List threads in the system.);

int cmd_time(int argc, char** argv)
{
10024ec8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10024ecc:	e28db000 	add	fp, sp, #0
10024ed0:	e24dd00c 	sub	sp, sp, #12
10024ed4:	e50b0008 	str	r0, [fp, #-8]
10024ed8:	e50b100c 	str	r1, [fp, #-12]
    return 0;
10024edc:	e3a03000 	mov	r3, #0
}
10024ee0:	e1a00003 	mov	r0, r3
10024ee4:	e24bd000 	sub	sp, fp, #0
10024ee8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10024eec:	e12fff1e 	bx	lr

10024ef0 <cmd_free>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_time, __cmd_time, Execute command with time.);

#ifdef RT_USING_HEAP
int cmd_free(int argc, char** argv)
{
10024ef0:	e92d4800 	push	{fp, lr}
10024ef4:	e28db004 	add	fp, sp, #4
10024ef8:	e24dd008 	sub	sp, sp, #8
10024efc:	e50b0008 	str	r0, [fp, #-8]
10024f00:	e50b100c 	str	r1, [fp, #-12]
    extern void list_memheap(void);

#ifdef RT_USING_MEMHEAP_AS_HEAP
    list_memheap();
#else
    list_mem();
10024f04:	ebffbfaf 	bl	10014dc8 <list_mem>
#endif
    return 0;
10024f08:	e3a03000 	mov	r3, #0
}
10024f0c:	e1a00003 	mov	r0, r3
10024f10:	e24bd004 	sub	sp, fp, #4
10024f14:	e8bd8800 	pop	{fp, pc}

10024f18 <msh_is_used>:
static rt_bool_t __msh_state = RT_TRUE;
#else
static rt_bool_t __msh_state = RT_FALSE;
#endif
rt_bool_t msh_is_used(void)
{
10024f18:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10024f1c:	e28db000 	add	fp, sp, #0
    return __msh_state;
10024f20:	e3063948 	movw	r3, #26952	; 0x6948
10024f24:	e3413003 	movt	r3, #4099	; 0x1003
10024f28:	e5933000 	ldr	r3, [r3]
}
10024f2c:	e1a00003 	mov	r0, r3
10024f30:	e24bd000 	sub	sp, fp, #0
10024f34:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10024f38:	e12fff1e 	bx	lr

10024f3c <msh_exit>:

static int msh_exit(int argc, char** argv)
{
10024f3c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10024f40:	e28db000 	add	fp, sp, #0
10024f44:	e24dd00c 	sub	sp, sp, #12
10024f48:	e50b0008 	str	r0, [fp, #-8]
10024f4c:	e50b100c 	str	r1, [fp, #-12]
    /* return to finsh shell mode */
    __msh_state = RT_FALSE;
10024f50:	e3063948 	movw	r3, #26952	; 0x6948
10024f54:	e3413003 	movt	r3, #4099	; 0x1003
10024f58:	e3a02000 	mov	r2, #0
10024f5c:	e5832000 	str	r2, [r3]

    return 0;
10024f60:	e3a03000 	mov	r3, #0
}
10024f64:	e1a00003 	mov	r0, r3
10024f68:	e24bd000 	sub	sp, fp, #0
10024f6c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10024f70:	e12fff1e 	bx	lr

10024f74 <msh_enter>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_exit, __cmd_exit, return to RT-Thread shell mode.);

static int msh_enter(void)
{
10024f74:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10024f78:	e28db000 	add	fp, sp, #0
    /* enter module shell mode */
    __msh_state = RT_TRUE;
10024f7c:	e3063948 	movw	r3, #26952	; 0x6948
10024f80:	e3413003 	movt	r3, #4099	; 0x1003
10024f84:	e3a02001 	mov	r2, #1
10024f88:	e5832000 	str	r2, [r3]
    return 0;
10024f8c:	e3a03000 	mov	r3, #0
}
10024f90:	e1a00003 	mov	r0, r3
10024f94:	e24bd000 	sub	sp, fp, #0
10024f98:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10024f9c:	e12fff1e 	bx	lr

10024fa0 <msh_help>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_enter, msh, use module shell);
#endif

int msh_help(int argc, char** argv)
{
10024fa0:	e92d4800 	push	{fp, lr}
10024fa4:	e28db004 	add	fp, sp, #4
10024fa8:	e24dd010 	sub	sp, sp, #16
10024fac:	e50b0010 	str	r0, [fp, #-16]
10024fb0:	e50b1014 	str	r1, [fp, #-20]
    rt_kprintf("RT-Thread shell commands:\n");
10024fb4:	e30508c0 	movw	r0, #22720	; 0x58c0
10024fb8:	e3410003 	movt	r0, #4099	; 0x1003
10024fbc:	ebffbabf 	bl	10013ac0 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
10024fc0:	e30f3934 	movw	r3, #63796	; 0xf934
10024fc4:	e3413003 	movt	r3, #4099	; 0x1003
10024fc8:	e5933000 	ldr	r3, [r3]
10024fcc:	e50b3008 	str	r3, [fp, #-8]
10024fd0:	ea000017 	b	10025034 <msh_help+0x94>
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
        {
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
10024fd4:	e51b3008 	ldr	r3, [fp, #-8]
10024fd8:	e5933000 	ldr	r3, [r3]
10024fdc:	e1a00003 	mov	r0, r3
10024fe0:	e30518dc 	movw	r1, #22748	; 0x58dc
10024fe4:	e3411003 	movt	r1, #4099	; 0x1003
10024fe8:	e3a02006 	mov	r2, #6
10024fec:	fa002a04 	blx	1002f804 <strncmp>
10024ff0:	e1a03000 	mov	r3, r0
10024ff4:	e3530000 	cmp	r3, #0
10024ff8:	0a000000 	beq	10025000 <msh_help+0x60>
10024ffc:	ea000009 	b	10025028 <msh_help+0x88>
#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
            rt_kprintf("%-16s - %s\n", &index->name[6], index->desc);
10025000:	e51b3008 	ldr	r3, [fp, #-8]
10025004:	e5933000 	ldr	r3, [r3]
10025008:	e2832006 	add	r2, r3, #6
1002500c:	e51b3008 	ldr	r3, [fp, #-8]
10025010:	e5933004 	ldr	r3, [r3, #4]
10025014:	e30508e4 	movw	r0, #22756	; 0x58e4
10025018:	e3410003 	movt	r0, #4099	; 0x1003
1002501c:	e1a01002 	mov	r1, r2
10025020:	e1a02003 	mov	r2, r3
10025024:	ebffbaa5 	bl	10013ac0 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
10025028:	e51b3008 	ldr	r3, [fp, #-8]
1002502c:	e283300c 	add	r3, r3, #12
10025030:	e50b3008 	str	r3, [fp, #-8]
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
10025034:	e30f3938 	movw	r3, #63800	; 0xf938
10025038:	e3413003 	movt	r3, #4099	; 0x1003
1002503c:	e5933000 	ldr	r3, [r3]
{
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
10025040:	e51b2008 	ldr	r2, [fp, #-8]
10025044:	e1520003 	cmp	r2, r3
10025048:	3affffe1 	bcc	10024fd4 <msh_help+0x34>
#else
            rt_kprintf("%s ", &index->name[6]);
#endif
        }
    }
    rt_kprintf("\n");
1002504c:	e30508f0 	movw	r0, #22768	; 0x58f0
10025050:	e3410003 	movt	r0, #4099	; 0x1003
10025054:	ebffba99 	bl	10013ac0 <rt_kprintf>

    return 0;
10025058:	e3a03000 	mov	r3, #0
}
1002505c:	e1a00003 	mov	r0, r3
10025060:	e24bd004 	sub	sp, fp, #4
10025064:	e8bd8800 	pop	{fp, pc}

10025068 <msh_split>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_help, __cmd_help, RT-Thread shell help.);

static int msh_split(char* cmd, rt_size_t length, char* argv[RT_FINSH_ARG_MAX])
{
10025068:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002506c:	e28db000 	add	fp, sp, #0
10025070:	e24dd024 	sub	sp, sp, #36	; 0x24
10025074:	e50b0018 	str	r0, [fp, #-24]
10025078:	e50b101c 	str	r1, [fp, #-28]
1002507c:	e50b2020 	str	r2, [fp, #-32]
    char *ptr;
    rt_size_t position;
    rt_size_t argc;

    ptr = cmd;
10025080:	e51b3018 	ldr	r3, [fp, #-24]
10025084:	e50b3008 	str	r3, [fp, #-8]
    position = 0; argc = 0;
10025088:	e3a03000 	mov	r3, #0
1002508c:	e50b300c 	str	r3, [fp, #-12]
10025090:	e3a03000 	mov	r3, #0
10025094:	e50b3010 	str	r3, [fp, #-16]

    while (position < length)
10025098:	ea00007b 	b	1002528c <msh_split+0x224>
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
1002509c:	ea000008 	b	100250c4 <msh_split+0x5c>
        {
            *ptr = '\0';
100250a0:	e51b3008 	ldr	r3, [fp, #-8]
100250a4:	e3a02000 	mov	r2, #0
100250a8:	e5c32000 	strb	r2, [r3]
            ptr ++; position ++;
100250ac:	e51b3008 	ldr	r3, [fp, #-8]
100250b0:	e2833001 	add	r3, r3, #1
100250b4:	e50b3008 	str	r3, [fp, #-8]
100250b8:	e51b300c 	ldr	r3, [fp, #-12]
100250bc:	e2833001 	add	r3, r3, #1
100250c0:	e50b300c 	str	r3, [fp, #-12]
    position = 0; argc = 0;

    while (position < length)
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
100250c4:	e51b3008 	ldr	r3, [fp, #-8]
100250c8:	e5d33000 	ldrb	r3, [r3]
100250cc:	e3530020 	cmp	r3, #32
100250d0:	0a000003 	beq	100250e4 <msh_split+0x7c>
100250d4:	e51b3008 	ldr	r3, [fp, #-8]
100250d8:	e5d33000 	ldrb	r3, [r3]
100250dc:	e3530009 	cmp	r3, #9
100250e0:	1a000003 	bne	100250f4 <msh_split+0x8c>
100250e4:	e51b200c 	ldr	r2, [fp, #-12]
100250e8:	e51b301c 	ldr	r3, [fp, #-28]
100250ec:	e1520003 	cmp	r2, r3
100250f0:	3affffea 	bcc	100250a0 <msh_split+0x38>
        {
            *ptr = '\0';
            ptr ++; position ++;
        }
        if (position >= length) break;
100250f4:	e51b200c 	ldr	r2, [fp, #-12]
100250f8:	e51b301c 	ldr	r3, [fp, #-28]
100250fc:	e1520003 	cmp	r2, r3
10025100:	3a000000 	bcc	10025108 <msh_split+0xa0>
10025104:	ea000064 	b	1002529c <msh_split+0x234>

        /* handle string */
        if (*ptr == '"')
10025108:	e51b3008 	ldr	r3, [fp, #-8]
1002510c:	e5d33000 	ldrb	r3, [r3]
10025110:	e3530022 	cmp	r3, #34	; 0x22
10025114:	1a00003b 	bne	10025208 <msh_split+0x1a0>
        {
            ptr ++; position ++;
10025118:	e51b3008 	ldr	r3, [fp, #-8]
1002511c:	e2833001 	add	r3, r3, #1
10025120:	e50b3008 	str	r3, [fp, #-8]
10025124:	e51b300c 	ldr	r3, [fp, #-12]
10025128:	e2833001 	add	r3, r3, #1
1002512c:	e50b300c 	str	r3, [fp, #-12]
            argv[argc] = ptr; argc ++;
10025130:	e51b3010 	ldr	r3, [fp, #-16]
10025134:	e1a03103 	lsl	r3, r3, #2
10025138:	e51b2020 	ldr	r2, [fp, #-32]
1002513c:	e0823003 	add	r3, r2, r3
10025140:	e51b2008 	ldr	r2, [fp, #-8]
10025144:	e5832000 	str	r2, [r3]
10025148:	e51b3010 	ldr	r3, [fp, #-16]
1002514c:	e2833001 	add	r3, r3, #1
10025150:	e50b3010 	str	r3, [fp, #-16]

            /* skip this string */
            while (*ptr != '"' && position < length)
10025154:	ea000014 	b	100251ac <msh_split+0x144>
            {
                if (*ptr == '\\')
10025158:	e51b3008 	ldr	r3, [fp, #-8]
1002515c:	e5d33000 	ldrb	r3, [r3]
10025160:	e353005c 	cmp	r3, #92	; 0x5c
10025164:	1a00000a 	bne	10025194 <msh_split+0x12c>
                {
                    if (*(ptr + 1) == '"')
10025168:	e51b3008 	ldr	r3, [fp, #-8]
1002516c:	e2833001 	add	r3, r3, #1
10025170:	e5d33000 	ldrb	r3, [r3]
10025174:	e3530022 	cmp	r3, #34	; 0x22
10025178:	1a000005 	bne	10025194 <msh_split+0x12c>
                    {
                        ptr ++; position ++;
1002517c:	e51b3008 	ldr	r3, [fp, #-8]
10025180:	e2833001 	add	r3, r3, #1
10025184:	e50b3008 	str	r3, [fp, #-8]
10025188:	e51b300c 	ldr	r3, [fp, #-12]
1002518c:	e2833001 	add	r3, r3, #1
10025190:	e50b300c 	str	r3, [fp, #-12]
                    }
                }
                ptr ++; position ++;
10025194:	e51b3008 	ldr	r3, [fp, #-8]
10025198:	e2833001 	add	r3, r3, #1
1002519c:	e50b3008 	str	r3, [fp, #-8]
100251a0:	e51b300c 	ldr	r3, [fp, #-12]
100251a4:	e2833001 	add	r3, r3, #1
100251a8:	e50b300c 	str	r3, [fp, #-12]
        {
            ptr ++; position ++;
            argv[argc] = ptr; argc ++;

            /* skip this string */
            while (*ptr != '"' && position < length)
100251ac:	e51b3008 	ldr	r3, [fp, #-8]
100251b0:	e5d33000 	ldrb	r3, [r3]
100251b4:	e3530022 	cmp	r3, #34	; 0x22
100251b8:	0a000003 	beq	100251cc <msh_split+0x164>
100251bc:	e51b200c 	ldr	r2, [fp, #-12]
100251c0:	e51b301c 	ldr	r3, [fp, #-28]
100251c4:	e1520003 	cmp	r2, r3
100251c8:	3affffe2 	bcc	10025158 <msh_split+0xf0>
                        ptr ++; position ++;
                    }
                }
                ptr ++; position ++;
            }
            if (position >= length) break;
100251cc:	e51b200c 	ldr	r2, [fp, #-12]
100251d0:	e51b301c 	ldr	r3, [fp, #-28]
100251d4:	e1520003 	cmp	r2, r3
100251d8:	3a000000 	bcc	100251e0 <msh_split+0x178>
100251dc:	ea00002e 	b	1002529c <msh_split+0x234>

            /* skip '"' */
            *ptr = '\0'; ptr ++; position ++;
100251e0:	e51b3008 	ldr	r3, [fp, #-8]
100251e4:	e3a02000 	mov	r2, #0
100251e8:	e5c32000 	strb	r2, [r3]
100251ec:	e51b3008 	ldr	r3, [fp, #-8]
100251f0:	e2833001 	add	r3, r3, #1
100251f4:	e50b3008 	str	r3, [fp, #-8]
100251f8:	e51b300c 	ldr	r3, [fp, #-12]
100251fc:	e2833001 	add	r3, r3, #1
10025200:	e50b300c 	str	r3, [fp, #-12]
10025204:	ea000020 	b	1002528c <msh_split+0x224>
        }
        else
        {
            argv[argc] = ptr;
10025208:	e51b3010 	ldr	r3, [fp, #-16]
1002520c:	e1a03103 	lsl	r3, r3, #2
10025210:	e51b2020 	ldr	r2, [fp, #-32]
10025214:	e0823003 	add	r3, r2, r3
10025218:	e51b2008 	ldr	r2, [fp, #-8]
1002521c:	e5832000 	str	r2, [r3]
            argc ++;
10025220:	e51b3010 	ldr	r3, [fp, #-16]
10025224:	e2833001 	add	r3, r3, #1
10025228:	e50b3010 	str	r3, [fp, #-16]
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
1002522c:	ea000005 	b	10025248 <msh_split+0x1e0>
            {
                ptr ++; position ++;
10025230:	e51b3008 	ldr	r3, [fp, #-8]
10025234:	e2833001 	add	r3, r3, #1
10025238:	e50b3008 	str	r3, [fp, #-8]
1002523c:	e51b300c 	ldr	r3, [fp, #-12]
10025240:	e2833001 	add	r3, r3, #1
10025244:	e50b300c 	str	r3, [fp, #-12]
        }
        else
        {
            argv[argc] = ptr;
            argc ++;
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
10025248:	e51b3008 	ldr	r3, [fp, #-8]
1002524c:	e5d33000 	ldrb	r3, [r3]
10025250:	e3530020 	cmp	r3, #32
10025254:	0a000007 	beq	10025278 <msh_split+0x210>
10025258:	e51b3008 	ldr	r3, [fp, #-8]
1002525c:	e5d33000 	ldrb	r3, [r3]
10025260:	e3530009 	cmp	r3, #9
10025264:	0a000003 	beq	10025278 <msh_split+0x210>
10025268:	e51b200c 	ldr	r2, [fp, #-12]
1002526c:	e51b301c 	ldr	r3, [fp, #-28]
10025270:	e1520003 	cmp	r2, r3
10025274:	3affffed 	bcc	10025230 <msh_split+0x1c8>
            {
                ptr ++; position ++;
            }
            if (position >= length) break;
10025278:	e51b200c 	ldr	r2, [fp, #-12]
1002527c:	e51b301c 	ldr	r3, [fp, #-28]
10025280:	e1520003 	cmp	r2, r3
10025284:	3a000000 	bcc	1002528c <msh_split+0x224>
10025288:	ea000003 	b	1002529c <msh_split+0x234>
    rt_size_t argc;

    ptr = cmd;
    position = 0; argc = 0;

    while (position < length)
1002528c:	e51b200c 	ldr	r2, [fp, #-12]
10025290:	e51b301c 	ldr	r3, [fp, #-28]
10025294:	e1520003 	cmp	r2, r3
10025298:	3affff7f 	bcc	1002509c <msh_split+0x34>
            }
            if (position >= length) break;
        }
    }

    return argc;
1002529c:	e51b3010 	ldr	r3, [fp, #-16]
}
100252a0:	e1a00003 	mov	r0, r3
100252a4:	e24bd000 	sub	sp, fp, #0
100252a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100252ac:	e12fff1e 	bx	lr

100252b0 <msh_get_cmd>:

static cmd_function_t msh_get_cmd(char *cmd, int size)
{
100252b0:	e92d4800 	push	{fp, lr}
100252b4:	e28db004 	add	fp, sp, #4
100252b8:	e24dd010 	sub	sp, sp, #16
100252bc:	e50b0010 	str	r0, [fp, #-16]
100252c0:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;
100252c4:	e3a03000 	mov	r3, #0
100252c8:	e50b300c 	str	r3, [fp, #-12]

    for (index = _syscall_table_begin;
100252cc:	e30f3934 	movw	r3, #63796	; 0xf934
100252d0:	e3413003 	movt	r3, #4099	; 0x1003
100252d4:	e5933000 	ldr	r3, [r3]
100252d8:	e50b3008 	str	r3, [fp, #-8]
100252dc:	ea000024 	b	10025374 <msh_get_cmd+0xc4>
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
100252e0:	e51b3008 	ldr	r3, [fp, #-8]
100252e4:	e5933000 	ldr	r3, [r3]
100252e8:	e1a00003 	mov	r0, r3
100252ec:	e30518dc 	movw	r1, #22748	; 0x58dc
100252f0:	e3411003 	movt	r1, #4099	; 0x1003
100252f4:	e3a02006 	mov	r2, #6
100252f8:	fa002941 	blx	1002f804 <strncmp>
100252fc:	e1a03000 	mov	r3, r0
10025300:	e3530000 	cmp	r3, #0
10025304:	0a000000 	beq	1002530c <msh_get_cmd+0x5c>
10025308:	ea000016 	b	10025368 <msh_get_cmd+0xb8>
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
1002530c:	e51b3008 	ldr	r3, [fp, #-8]
10025310:	e5933000 	ldr	r3, [r3]
10025314:	e2832006 	add	r2, r3, #6
10025318:	e51b3014 	ldr	r3, [fp, #-20]
1002531c:	e1a00002 	mov	r0, r2
10025320:	e51b1010 	ldr	r1, [fp, #-16]
10025324:	e1a02003 	mov	r2, r3
10025328:	fa002935 	blx	1002f804 <strncmp>
1002532c:	e1a03000 	mov	r3, r0
10025330:	e3530000 	cmp	r3, #0
10025334:	1a00000b 	bne	10025368 <msh_get_cmd+0xb8>
			index->name[6 + size] == '\0')
10025338:	e51b3008 	ldr	r3, [fp, #-8]
1002533c:	e5933000 	ldr	r3, [r3]
10025340:	e51b2014 	ldr	r2, [fp, #-20]
10025344:	e2822006 	add	r2, r2, #6
10025348:	e0833002 	add	r3, r3, r2
1002534c:	e5d33000 	ldrb	r3, [r3]
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
10025350:	e3530000 	cmp	r3, #0
10025354:	1a000003 	bne	10025368 <msh_get_cmd+0xb8>
			index->name[6 + size] == '\0')
        {
            cmd_func = (cmd_function_t)index->func;
10025358:	e51b3008 	ldr	r3, [fp, #-8]
1002535c:	e5933008 	ldr	r3, [r3, #8]
10025360:	e50b300c 	str	r3, [fp, #-12]
            break;
10025364:	ea000008 	b	1002538c <msh_get_cmd+0xdc>
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
10025368:	e51b3008 	ldr	r3, [fp, #-8]
1002536c:	e283300c 	add	r3, r3, #12
10025370:	e50b3008 	str	r3, [fp, #-8]
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
10025374:	e30f3938 	movw	r3, #63800	; 0xf938
10025378:	e3413003 	movt	r3, #4099	; 0x1003
1002537c:	e5933000 	ldr	r3, [r3]
static cmd_function_t msh_get_cmd(char *cmd, int size)
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
10025380:	e51b2008 	ldr	r2, [fp, #-8]
10025384:	e1520003 	cmp	r2, r3
10025388:	3affffd4 	bcc	100252e0 <msh_get_cmd+0x30>
            cmd_func = (cmd_function_t)index->func;
            break;
        }
    }

    return cmd_func;
1002538c:	e51b300c 	ldr	r3, [fp, #-12]
}
10025390:	e1a00003 	mov	r0, r3
10025394:	e24bd004 	sub	sp, fp, #4
10025398:	e8bd8800 	pop	{fp, pc}

1002539c <_msh_exec_cmd>:
}
RTM_EXPORT(system);
#endif

static int _msh_exec_cmd(char* cmd, rt_size_t length, int *retp)
{
1002539c:	e92d4800 	push	{fp, lr}
100253a0:	e28db004 	add	fp, sp, #4
100253a4:	e24dd048 	sub	sp, sp, #72	; 0x48
100253a8:	e50b0040 	str	r0, [fp, #-64]	; 0x40
100253ac:	e50b1044 	str	r1, [fp, #-68]	; 0x44
100253b0:	e50b2048 	str	r2, [fp, #-72]	; 0x48
    int argc;
    int cmd0_size = 0;
100253b4:	e3a03000 	mov	r3, #0
100253b8:	e50b3008 	str	r3, [fp, #-8]
    cmd_function_t cmd_func;
    char *argv[RT_FINSH_ARG_MAX];

    RT_ASSERT(cmd);
100253bc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100253c0:	e3530000 	cmp	r3, #0
100253c4:	1a000005 	bne	100253e0 <_msh_exec_cmd+0x44>
100253c8:	e30508f4 	movw	r0, #22772	; 0x58f4
100253cc:	e3410003 	movt	r0, #4099	; 0x1003
100253d0:	e305191c 	movw	r1, #22812	; 0x591c
100253d4:	e3411003 	movt	r1, #4099	; 0x1003
100253d8:	e300210a 	movw	r2, #266	; 0x10a
100253dc:	ebffba74 	bl	10013db4 <rt_assert_handler>
    RT_ASSERT(retp);
100253e0:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
100253e4:	e3530000 	cmp	r3, #0
100253e8:	1a000005 	bne	10025404 <_msh_exec_cmd+0x68>
100253ec:	e30508f8 	movw	r0, #22776	; 0x58f8
100253f0:	e3410003 	movt	r0, #4099	; 0x1003
100253f4:	e305191c 	movw	r1, #22812	; 0x591c
100253f8:	e3411003 	movt	r1, #4099	; 0x1003
100253fc:	e300210b 	movw	r2, #267	; 0x10b
10025400:	ebffba6b 	bl	10013db4 <rt_assert_handler>

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
10025404:	ea000002 	b	10025414 <_msh_exec_cmd+0x78>
        cmd0_size ++;
10025408:	e51b3008 	ldr	r3, [fp, #-8]
1002540c:	e2833001 	add	r3, r3, #1
10025410:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(cmd);
    RT_ASSERT(retp);

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
10025414:	e51b3008 	ldr	r3, [fp, #-8]
10025418:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
1002541c:	e0823003 	add	r3, r2, r3
10025420:	e5d33000 	ldrb	r3, [r3]
10025424:	e3530020 	cmp	r3, #32
10025428:	0a000009 	beq	10025454 <_msh_exec_cmd+0xb8>
1002542c:	e51b3008 	ldr	r3, [fp, #-8]
10025430:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
10025434:	e0823003 	add	r3, r2, r3
10025438:	e5d33000 	ldrb	r3, [r3]
1002543c:	e3530009 	cmp	r3, #9
10025440:	0a000003 	beq	10025454 <_msh_exec_cmd+0xb8>
10025444:	e51b2008 	ldr	r2, [fp, #-8]
10025448:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
1002544c:	e1520003 	cmp	r2, r3
10025450:	3affffec 	bcc	10025408 <_msh_exec_cmd+0x6c>
        cmd0_size ++;
    if (cmd0_size == 0)
10025454:	e51b3008 	ldr	r3, [fp, #-8]
10025458:	e3530000 	cmp	r3, #0
1002545c:	1a000001 	bne	10025468 <_msh_exec_cmd+0xcc>
        return -RT_ERROR;
10025460:	e3e03000 	mvn	r3, #0
10025464:	ea000021 	b	100254f0 <_msh_exec_cmd+0x154>

    cmd_func = msh_get_cmd(cmd, cmd0_size);
10025468:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002546c:	e51b1008 	ldr	r1, [fp, #-8]
10025470:	ebffff8e 	bl	100252b0 <msh_get_cmd>
10025474:	e50b000c 	str	r0, [fp, #-12]
    if (cmd_func == RT_NULL)
10025478:	e51b300c 	ldr	r3, [fp, #-12]
1002547c:	e3530000 	cmp	r3, #0
10025480:	1a000001 	bne	1002548c <_msh_exec_cmd+0xf0>
        return -RT_ERROR;
10025484:	e3e03000 	mvn	r3, #0
10025488:	ea000018 	b	100254f0 <_msh_exec_cmd+0x154>

    /* split arguments */
    memset(argv, 0x00, sizeof(argv));
1002548c:	e24b3038 	sub	r3, fp, #56	; 0x38
10025490:	e1a00003 	mov	r0, r3
10025494:	e3a01000 	mov	r1, #0
10025498:	e3a02028 	mov	r2, #40	; 0x28
1002549c:	fa0027be 	blx	1002f39c <memset>
    argc = msh_split(cmd, length, argv);
100254a0:	e24b3038 	sub	r3, fp, #56	; 0x38
100254a4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
100254a8:	e51b1044 	ldr	r1, [fp, #-68]	; 0x44
100254ac:	e1a02003 	mov	r2, r3
100254b0:	ebfffeec 	bl	10025068 <msh_split>
100254b4:	e50b0010 	str	r0, [fp, #-16]
    if (argc == 0)
100254b8:	e51b3010 	ldr	r3, [fp, #-16]
100254bc:	e3530000 	cmp	r3, #0
100254c0:	1a000001 	bne	100254cc <_msh_exec_cmd+0x130>
        return -RT_ERROR;
100254c4:	e3e03000 	mvn	r3, #0
100254c8:	ea000008 	b	100254f0 <_msh_exec_cmd+0x154>

    /* exec this command */
    *retp = cmd_func(argc, argv);
100254cc:	e24b2038 	sub	r2, fp, #56	; 0x38
100254d0:	e51b300c 	ldr	r3, [fp, #-12]
100254d4:	e51b0010 	ldr	r0, [fp, #-16]
100254d8:	e1a01002 	mov	r1, r2
100254dc:	e12fff33 	blx	r3
100254e0:	e1a02000 	mov	r2, r0
100254e4:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
100254e8:	e5832000 	str	r2, [r3]
    return 0;
100254ec:	e3a03000 	mov	r3, #0
}
100254f0:	e1a00003 	mov	r0, r3
100254f4:	e24bd004 	sub	sp, fp, #4
100254f8:	e8bd8800 	pop	{fp, pc}

100254fc <msh_exec>:

int msh_exec(char* cmd, rt_size_t length)
{
100254fc:	e92d4800 	push	{fp, lr}
10025500:	e28db004 	add	fp, sp, #4
10025504:	e24dd010 	sub	sp, sp, #16
10025508:	e50b0010 	str	r0, [fp, #-16]
1002550c:	e50b1014 	str	r1, [fp, #-20]
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
10025510:	ea000005 	b	1002552c <msh_exec+0x30>
    {
        cmd++;
10025514:	e51b3010 	ldr	r3, [fp, #-16]
10025518:	e2833001 	add	r3, r3, #1
1002551c:	e50b3010 	str	r3, [fp, #-16]
        length--;
10025520:	e51b3014 	ldr	r3, [fp, #-20]
10025524:	e2433001 	sub	r3, r3, #1
10025528:	e50b3014 	str	r3, [fp, #-20]
int msh_exec(char* cmd, rt_size_t length)
{
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
1002552c:	e51b3010 	ldr	r3, [fp, #-16]
10025530:	e5d33000 	ldrb	r3, [r3]
10025534:	e3530020 	cmp	r3, #32
10025538:	0afffff5 	beq	10025514 <msh_exec+0x18>
1002553c:	e51b3010 	ldr	r3, [fp, #-16]
10025540:	e5d33000 	ldrb	r3, [r3]
10025544:	e3530009 	cmp	r3, #9
10025548:	0afffff1 	beq	10025514 <msh_exec+0x18>
    {
        cmd++;
        length--;
    }

    if (length == 0)
1002554c:	e51b3014 	ldr	r3, [fp, #-20]
10025550:	e3530000 	cmp	r3, #0
10025554:	1a000001 	bne	10025560 <msh_exec+0x64>
        return 0;
10025558:	e3a03000 	mov	r3, #0
1002555c:	ea00001f 	b	100255e0 <msh_exec+0xe4>
    /* Exec sequence:
     * 1. built-in command
     * 2. module(if enabled)
     * 3. chdir to the directry(if possible)
     */
    if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
10025560:	e24b300c 	sub	r3, fp, #12
10025564:	e51b0010 	ldr	r0, [fp, #-16]
10025568:	e51b1014 	ldr	r1, [fp, #-20]
1002556c:	e1a02003 	mov	r2, r3
10025570:	ebffff89 	bl	1002539c <_msh_exec_cmd>
10025574:	e1a03000 	mov	r3, r0
10025578:	e3530000 	cmp	r3, #0
1002557c:	1a000001 	bne	10025588 <msh_exec+0x8c>
    {
        return cmd_ret;
10025580:	e51b300c 	ldr	r3, [fp, #-12]
10025584:	ea000015 	b	100255e0 <msh_exec+0xe4>
#endif

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
10025588:	e51b3010 	ldr	r3, [fp, #-16]
1002558c:	e50b3008 	str	r3, [fp, #-8]
        while(*tcmd != ' ' && *tcmd != '\0')
10025590:	ea000002 	b	100255a0 <msh_exec+0xa4>
        {
            tcmd++;
10025594:	e51b3008 	ldr	r3, [fp, #-8]
10025598:	e2833001 	add	r3, r3, #1
1002559c:	e50b3008 	str	r3, [fp, #-8]

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
        while(*tcmd != ' ' && *tcmd != '\0')
100255a0:	e51b3008 	ldr	r3, [fp, #-8]
100255a4:	e5d33000 	ldrb	r3, [r3]
100255a8:	e3530020 	cmp	r3, #32
100255ac:	0a000003 	beq	100255c0 <msh_exec+0xc4>
100255b0:	e51b3008 	ldr	r3, [fp, #-8]
100255b4:	e5d33000 	ldrb	r3, [r3]
100255b8:	e3530000 	cmp	r3, #0
100255bc:	1afffff4 	bne	10025594 <msh_exec+0x98>
        {
            tcmd++;
        }
        *tcmd = '\0';
100255c0:	e51b3008 	ldr	r3, [fp, #-8]
100255c4:	e3a02000 	mov	r2, #0
100255c8:	e5c32000 	strb	r2, [r3]
    }
    rt_kprintf("%s: command not found.\n", cmd);
100255cc:	e3050900 	movw	r0, #22784	; 0x5900
100255d0:	e3410003 	movt	r0, #4099	; 0x1003
100255d4:	e51b1010 	ldr	r1, [fp, #-16]
100255d8:	ebffb938 	bl	10013ac0 <rt_kprintf>
    return -1;
100255dc:	e3e03000 	mvn	r3, #0
}
100255e0:	e1a00003 	mov	r0, r3
100255e4:	e24bd004 	sub	sp, fp, #4
100255e8:	e8bd8800 	pop	{fp, pc}

100255ec <str_common>:

static int str_common(const char *str1, const char *str2)
{
100255ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100255f0:	e28db000 	add	fp, sp, #0
100255f4:	e24dd014 	sub	sp, sp, #20
100255f8:	e50b0010 	str	r0, [fp, #-16]
100255fc:	e50b1014 	str	r1, [fp, #-20]
    const char *str = str1;
10025600:	e51b3010 	ldr	r3, [fp, #-16]
10025604:	e50b3008 	str	r3, [fp, #-8]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
10025608:	ea000005 	b	10025624 <str_common+0x38>
    {
        str ++;
1002560c:	e51b3008 	ldr	r3, [fp, #-8]
10025610:	e2833001 	add	r3, r3, #1
10025614:	e50b3008 	str	r3, [fp, #-8]
        str2 ++;
10025618:	e51b3014 	ldr	r3, [fp, #-20]
1002561c:	e2833001 	add	r3, r3, #1
10025620:	e50b3014 	str	r3, [fp, #-20]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
10025624:	e51b3008 	ldr	r3, [fp, #-8]
10025628:	e5d33000 	ldrb	r3, [r3]
1002562c:	e3530000 	cmp	r3, #0
10025630:	0a000009 	beq	1002565c <str_common+0x70>
10025634:	e51b3014 	ldr	r3, [fp, #-20]
10025638:	e5d33000 	ldrb	r3, [r3]
1002563c:	e3530000 	cmp	r3, #0
10025640:	0a000005 	beq	1002565c <str_common+0x70>
10025644:	e51b3008 	ldr	r3, [fp, #-8]
10025648:	e5d32000 	ldrb	r2, [r3]
1002564c:	e51b3014 	ldr	r3, [fp, #-20]
10025650:	e5d33000 	ldrb	r3, [r3]
10025654:	e1520003 	cmp	r2, r3
10025658:	0affffeb 	beq	1002560c <str_common+0x20>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
1002565c:	e51b2008 	ldr	r2, [fp, #-8]
10025660:	e51b3010 	ldr	r3, [fp, #-16]
10025664:	e0633002 	rsb	r3, r3, r2
}
10025668:	e1a00003 	mov	r0, r3
1002566c:	e24bd000 	sub	sp, fp, #0
10025670:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10025674:	e12fff1e 	bx	lr

10025678 <msh_auto_complete>:
    rt_free(full_path);
}
#endif

void msh_auto_complete(char *prefix)
{
10025678:	e92d4800 	push	{fp, lr}
1002567c:	e28db004 	add	fp, sp, #4
10025680:	e24dd020 	sub	sp, sp, #32
10025684:	e50b0020 	str	r0, [fp, #-32]
    int length, min_length;
    const char *name_ptr, *cmd_name;
    struct finsh_syscall *index;

    min_length = 0;
10025688:	e3a03000 	mov	r3, #0
1002568c:	e50b3008 	str	r3, [fp, #-8]
    name_ptr = RT_NULL;
10025690:	e3a03000 	mov	r3, #0
10025694:	e50b300c 	str	r3, [fp, #-12]

    if (*prefix == '\0') 
10025698:	e51b3020 	ldr	r3, [fp, #-32]
1002569c:	e5d33000 	ldrb	r3, [r3]
100256a0:	e3530000 	cmp	r3, #0
100256a4:	1a000003 	bne	100256b8 <msh_auto_complete+0x40>
    {
        msh_help(0, RT_NULL);
100256a8:	e3a00000 	mov	r0, #0
100256ac:	e3a01000 	mov	r1, #0
100256b0:	ebfffe3a 	bl	10024fa0 <msh_help>
        return;
100256b4:	ea000046 	b	100257d4 <msh_auto_complete+0x15c>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
100256b8:	e30f3934 	movw	r3, #63796	; 0xf934
100256bc:	e3413003 	movt	r3, #4099	; 0x1003
100256c0:	e5933000 	ldr	r3, [r3]
100256c4:	e50b3010 	str	r3, [fp, #-16]
100256c8:	ea000032 	b	10025798 <msh_auto_complete+0x120>
        {
            /* skip finsh shell function */
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
100256cc:	e51b3010 	ldr	r3, [fp, #-16]
100256d0:	e5933000 	ldr	r3, [r3]
100256d4:	e1a00003 	mov	r0, r3
100256d8:	e30518dc 	movw	r1, #22748	; 0x58dc
100256dc:	e3411003 	movt	r1, #4099	; 0x1003
100256e0:	e3a02006 	mov	r2, #6
100256e4:	fa002846 	blx	1002f804 <strncmp>
100256e8:	e1a03000 	mov	r3, r0
100256ec:	e3530000 	cmp	r3, #0
100256f0:	0a000000 	beq	100256f8 <msh_auto_complete+0x80>
100256f4:	ea000024 	b	1002578c <msh_auto_complete+0x114>

            cmd_name = (const char*) &index->name[6];
100256f8:	e51b3010 	ldr	r3, [fp, #-16]
100256fc:	e5933000 	ldr	r3, [r3]
10025700:	e2833006 	add	r3, r3, #6
10025704:	e50b3014 	str	r3, [fp, #-20]
            if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
10025708:	e51b0020 	ldr	r0, [fp, #-32]
1002570c:	fa002825 	blx	1002f7a8 <strlen>
10025710:	e1a03000 	mov	r3, r0
10025714:	e51b0020 	ldr	r0, [fp, #-32]
10025718:	e51b1014 	ldr	r1, [fp, #-20]
1002571c:	e1a02003 	mov	r2, r3
10025720:	fa002837 	blx	1002f804 <strncmp>
10025724:	e1a03000 	mov	r3, r0
10025728:	e3530000 	cmp	r3, #0
1002572c:	1a000016 	bne	1002578c <msh_auto_complete+0x114>
            {
                if (min_length == 0)
10025730:	e51b3008 	ldr	r3, [fp, #-8]
10025734:	e3530000 	cmp	r3, #0
10025738:	1a000005 	bne	10025754 <msh_auto_complete+0xdc>
                {
                    /* set name_ptr */
                    name_ptr = cmd_name;
1002573c:	e51b3014 	ldr	r3, [fp, #-20]
10025740:	e50b300c 	str	r3, [fp, #-12]
                    /* set initial length */
                    min_length = strlen(name_ptr);
10025744:	e51b000c 	ldr	r0, [fp, #-12]
10025748:	fa002816 	blx	1002f7a8 <strlen>
1002574c:	e1a03000 	mov	r3, r0
10025750:	e50b3008 	str	r3, [fp, #-8]
                }

                length = str_common(name_ptr, cmd_name);
10025754:	e51b000c 	ldr	r0, [fp, #-12]
10025758:	e51b1014 	ldr	r1, [fp, #-20]
1002575c:	ebffffa2 	bl	100255ec <str_common>
10025760:	e50b0018 	str	r0, [fp, #-24]
                if (length < min_length)
10025764:	e51b2018 	ldr	r2, [fp, #-24]
10025768:	e51b3008 	ldr	r3, [fp, #-8]
1002576c:	e1520003 	cmp	r2, r3
10025770:	aa000001 	bge	1002577c <msh_auto_complete+0x104>
                    min_length = length;
10025774:	e51b3018 	ldr	r3, [fp, #-24]
10025778:	e50b3008 	str	r3, [fp, #-8]

                rt_kprintf("%s\n", cmd_name);
1002577c:	e3050918 	movw	r0, #22808	; 0x5918
10025780:	e3410003 	movt	r0, #4099	; 0x1003
10025784:	e51b1014 	ldr	r1, [fp, #-20]
10025788:	ebffb8cc 	bl	10013ac0 <rt_kprintf>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
1002578c:	e51b3010 	ldr	r3, [fp, #-16]
10025790:	e283300c 	add	r3, r3, #12
10025794:	e50b3010 	str	r3, [fp, #-16]
10025798:	e30f3938 	movw	r3, #63800	; 0xf938
1002579c:	e3413003 	movt	r3, #4099	; 0x1003
100257a0:	e5933000 	ldr	r3, [r3]
100257a4:	e51b2010 	ldr	r2, [fp, #-16]
100257a8:	e1520003 	cmp	r2, r3
100257ac:	3affffc6 	bcc	100256cc <msh_auto_complete+0x54>
            }
        }
    }

    /* auto complete string */
    if (name_ptr != NULL)
100257b0:	e51b300c 	ldr	r3, [fp, #-12]
100257b4:	e3530000 	cmp	r3, #0
100257b8:	0a000004 	beq	100257d0 <msh_auto_complete+0x158>
    {
        rt_strncpy(prefix, name_ptr, min_length);
100257bc:	e51b3008 	ldr	r3, [fp, #-8]
100257c0:	e51b0020 	ldr	r0, [fp, #-32]
100257c4:	e51b100c 	ldr	r1, [fp, #-12]
100257c8:	e1a02003 	mov	r2, r3
100257cc:	ebffb422 	bl	1001285c <rt_strncpy>
    }

    return ;
100257d0:	e1a00000 	nop			; (mov r0, r0)
}
100257d4:	e24bd004 	sub	sp, fp, #4
100257d8:	e8bd8800 	pop	{fp, pc}

100257dc <finsh_compile>:
#define finsh_code_byte(x)  do { *finsh_compile_pc = (x); finsh_compile_pc ++; } while(0)
#define finsh_code_word(x)  do { FINSH_SET16(finsh_compile_pc, x); finsh_compile_pc +=2; } while(0)
#define finsh_code_dword(x) do { FINSH_SET32(finsh_compile_pc, x); finsh_compile_pc +=4; } while(0)

static int finsh_compile(struct finsh_node* node)
{
100257dc:	e92d4800 	push	{fp, lr}
100257e0:	e28db004 	add	fp, sp, #4
100257e4:	e24dd028 	sub	sp, sp, #40	; 0x28
100257e8:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    if (node != NULL)
100257ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100257f0:	e3530000 	cmp	r3, #0
100257f4:	0a000db3 	beq	10028ec8 <finsh_compile+0x36ec>
    {
        /* compile child node */
        if (finsh_node_child(node) != NULL)
100257f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100257fc:	e5933010 	ldr	r3, [r3, #16]
10025800:	e3530000 	cmp	r3, #0
10025804:	0a000003 	beq	10025818 <finsh_compile+0x3c>
            finsh_compile(finsh_node_child(node));
10025808:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002580c:	e5933010 	ldr	r3, [r3, #16]
10025810:	e1a00003 	mov	r0, r3
10025814:	ebfffff0 	bl	100257dc <finsh_compile>

        /* compile current node */
        switch (node->node_type)
10025818:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002581c:	e5d33000 	ldrb	r3, [r3]
10025820:	e2433001 	sub	r3, r3, #1
10025824:	e353001a 	cmp	r3, #26
10025828:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002582c:	ea000d97 	b	10028e90 <finsh_compile+0x36b4>
10025830:	1002589c 	.word	0x1002589c
10025834:	10026134 	.word	0x10026134
10025838:	1002619c 	.word	0x1002619c
1002583c:	1002619c 	.word	0x1002619c
10025840:	10026274 	.word	0x10026274
10025844:	10026274 	.word	0x10026274
10025848:	1002634c 	.word	0x1002634c
1002584c:	1002641c 	.word	0x1002641c
10025850:	100264ec 	.word	0x100264ec
10025854:	100265bc 	.word	0x100265bc
10025858:	1002668c 	.word	0x1002668c
1002585c:	1002675c 	.word	0x1002675c
10025860:	1002682c 	.word	0x1002682c
10025864:	100268fc 	.word	0x100268fc
10025868:	100269cc 	.word	0x100269cc
1002586c:	10026a9c 	.word	0x10026a9c
10025870:	10026b6c 	.word	0x10026b6c
10025874:	10026c3c 	.word	0x10026c3c
10025878:	10026cf8 	.word	0x10026cf8
1002587c:	10028e90 	.word	0x10028e90
10025880:	10026ff4 	.word	0x10026ff4
10025884:	10027608 	.word	0x10027608
10025888:	10027c1c 	.word	0x10027c1c
1002588c:	100284ac 	.word	0x100284ac
10025890:	10028db8 	.word	0x10028db8
10025894:	10028e9c 	.word	0x10028e9c
10025898:	10028d3c 	.word	0x10028d3c
        {
        case FINSH_NODE_ID:
            {
                /* identifier::syscall */
                if (node->idtype & FINSH_IDTYPE_SYSCALL)
1002589c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100258a0:	e5d33002 	ldrb	r3, [r3, #2]
100258a4:	e2033004 	and	r3, r3, #4
100258a8:	e3530000 	cmp	r3, #0
100258ac:	0a000039 	beq	10025998 <finsh_compile+0x1bc>
                {
                    /* load address */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
100258b0:	e3033594 	movw	r3, #13716	; 0x3594
100258b4:	e3413004 	movt	r3, #4100	; 0x1004
100258b8:	e5933000 	ldr	r3, [r3]
100258bc:	e3a02024 	mov	r2, #36	; 0x24
100258c0:	e5c32000 	strb	r2, [r3]
100258c4:	e3033594 	movw	r3, #13716	; 0x3594
100258c8:	e3413004 	movt	r3, #4100	; 0x1004
100258cc:	e5933000 	ldr	r3, [r3]
100258d0:	e2832001 	add	r2, r3, #1
100258d4:	e3033594 	movw	r3, #13716	; 0x3594
100258d8:	e3413004 	movt	r3, #4100	; 0x1004
100258dc:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)node->id.syscall->func);
100258e0:	e3033594 	movw	r3, #13716	; 0x3594
100258e4:	e3413004 	movt	r3, #4100	; 0x1004
100258e8:	e5933000 	ldr	r3, [r3]
100258ec:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100258f0:	e5922008 	ldr	r2, [r2, #8]
100258f4:	e5922008 	ldr	r2, [r2, #8]
100258f8:	e6ef2072 	uxtb	r2, r2
100258fc:	e5c32000 	strb	r2, [r3]
10025900:	e3033594 	movw	r3, #13716	; 0x3594
10025904:	e3413004 	movt	r3, #4100	; 0x1004
10025908:	e5933000 	ldr	r3, [r3]
1002590c:	e2833001 	add	r3, r3, #1
10025910:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10025914:	e5922008 	ldr	r2, [r2, #8]
10025918:	e5922008 	ldr	r2, [r2, #8]
1002591c:	e1a02422 	lsr	r2, r2, #8
10025920:	e6ef2072 	uxtb	r2, r2
10025924:	e5c32000 	strb	r2, [r3]
10025928:	e3033594 	movw	r3, #13716	; 0x3594
1002592c:	e3413004 	movt	r3, #4100	; 0x1004
10025930:	e5933000 	ldr	r3, [r3]
10025934:	e2833002 	add	r3, r3, #2
10025938:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1002593c:	e5922008 	ldr	r2, [r2, #8]
10025940:	e5922008 	ldr	r2, [r2, #8]
10025944:	e1a02822 	lsr	r2, r2, #16
10025948:	e6ef2072 	uxtb	r2, r2
1002594c:	e5c32000 	strb	r2, [r3]
10025950:	e3033594 	movw	r3, #13716	; 0x3594
10025954:	e3413004 	movt	r3, #4100	; 0x1004
10025958:	e5933000 	ldr	r3, [r3]
1002595c:	e2833003 	add	r3, r3, #3
10025960:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10025964:	e5922008 	ldr	r2, [r2, #8]
10025968:	e5922008 	ldr	r2, [r2, #8]
1002596c:	e1a02c22 	lsr	r2, r2, #24
10025970:	e6ef2072 	uxtb	r2, r2
10025974:	e5c32000 	strb	r2, [r3]
10025978:	e3033594 	movw	r3, #13716	; 0x3594
1002597c:	e3413004 	movt	r3, #4100	; 0x1004
10025980:	e5933000 	ldr	r3, [r3]
10025984:	e2832004 	add	r2, r3, #4
10025988:	e3033594 	movw	r3, #13716	; 0x3594
1002598c:	e3413004 	movt	r3, #4100	; 0x1004
10025990:	e5832000 	str	r2, [r3]
10025994:	ea0001e5 	b	10026130 <finsh_compile+0x954>
                }
                /* identifier::sysvar */
                else if (node->idtype & FINSH_IDTYPE_SYSVAR)
10025998:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002599c:	e5d33002 	ldrb	r3, [r3, #2]
100259a0:	e2033002 	and	r3, r3, #2
100259a4:	e3530000 	cmp	r3, #0
100259a8:	0a0000f0 	beq	10025d70 <finsh_compile+0x594>
                {
                    struct finsh_sysvar* sysvar;

                    sysvar = node->id.sysvar;
100259ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100259b0:	e5933008 	ldr	r3, [r3, #8]
100259b4:	e50b3010 	str	r3, [fp, #-16]
                    if (sysvar != NULL)
100259b8:	e51b3010 	ldr	r3, [fp, #-16]
100259bc:	e3530000 	cmp	r3, #0
100259c0:	0a0000e9 	beq	10025d6c <finsh_compile+0x590>
                    {
                        switch (sysvar->type)
100259c4:	e51b3010 	ldr	r3, [fp, #-16]
100259c8:	e5d33008 	ldrb	r3, [r3, #8]
100259cc:	e2433003 	sub	r3, r3, #3
100259d0:	e353000b 	cmp	r3, #11
100259d4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
100259d8:	ea0001d4 	b	10026130 <finsh_compile+0x954>
100259dc:	10025a0c 	.word	0x10025a0c
100259e0:	10025a0c 	.word	0x10025a0c
100259e4:	10025c4c 	.word	0x10025c4c
100259e8:	10025b2c 	.word	0x10025b2c
100259ec:	10025b2c 	.word	0x10025b2c
100259f0:	10025c4c 	.word	0x10025c4c
100259f4:	10025c4c 	.word	0x10025c4c
100259f8:	10025c4c 	.word	0x10025c4c
100259fc:	10025c4c 	.word	0x10025c4c
10025a00:	10025c4c 	.word	0x10025c4c
10025a04:	10025c4c 	.word	0x10025c4c
10025a08:	10025c4c 	.word	0x10025c4c
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10025a0c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10025a10:	e5d33002 	ldrb	r3, [r3, #2]
10025a14:	e2033008 	and	r3, r3, #8
10025a18:	e3530000 	cmp	r3, #0
10025a1c:	0a00000c 	beq	10025a54 <finsh_compile+0x278>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10025a20:	e3033594 	movw	r3, #13716	; 0x3594
10025a24:	e3413004 	movt	r3, #4100	; 0x1004
10025a28:	e5933000 	ldr	r3, [r3]
10025a2c:	e3a02024 	mov	r2, #36	; 0x24
10025a30:	e5c32000 	strb	r2, [r3]
10025a34:	e3033594 	movw	r3, #13716	; 0x3594
10025a38:	e3413004 	movt	r3, #4100	; 0x1004
10025a3c:	e5933000 	ldr	r3, [r3]
10025a40:	e2832001 	add	r2, r3, #1
10025a44:	e3033594 	movw	r3, #13716	; 0x3594
10025a48:	e3413004 	movt	r3, #4100	; 0x1004
10025a4c:	e5832000 	str	r2, [r3]
10025a50:	ea00000b 	b	10025a84 <finsh_compile+0x2a8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10025a54:	e3033594 	movw	r3, #13716	; 0x3594
10025a58:	e3413004 	movt	r3, #4100	; 0x1004
10025a5c:	e5933000 	ldr	r3, [r3]
10025a60:	e3a02025 	mov	r2, #37	; 0x25
10025a64:	e5c32000 	strb	r2, [r3]
10025a68:	e3033594 	movw	r3, #13716	; 0x3594
10025a6c:	e3413004 	movt	r3, #4100	; 0x1004
10025a70:	e5933000 	ldr	r3, [r3]
10025a74:	e2832001 	add	r2, r3, #1
10025a78:	e3033594 	movw	r3, #13716	; 0x3594
10025a7c:	e3413004 	movt	r3, #4100	; 0x1004
10025a80:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
10025a84:	e3033594 	movw	r3, #13716	; 0x3594
10025a88:	e3413004 	movt	r3, #4100	; 0x1004
10025a8c:	e5933000 	ldr	r3, [r3]
10025a90:	e51b2010 	ldr	r2, [fp, #-16]
10025a94:	e592200c 	ldr	r2, [r2, #12]
10025a98:	e6ef2072 	uxtb	r2, r2
10025a9c:	e5c32000 	strb	r2, [r3]
10025aa0:	e3033594 	movw	r3, #13716	; 0x3594
10025aa4:	e3413004 	movt	r3, #4100	; 0x1004
10025aa8:	e5933000 	ldr	r3, [r3]
10025aac:	e2833001 	add	r3, r3, #1
10025ab0:	e51b2010 	ldr	r2, [fp, #-16]
10025ab4:	e592200c 	ldr	r2, [r2, #12]
10025ab8:	e1a02422 	lsr	r2, r2, #8
10025abc:	e6ef2072 	uxtb	r2, r2
10025ac0:	e5c32000 	strb	r2, [r3]
10025ac4:	e3033594 	movw	r3, #13716	; 0x3594
10025ac8:	e3413004 	movt	r3, #4100	; 0x1004
10025acc:	e5933000 	ldr	r3, [r3]
10025ad0:	e2833002 	add	r3, r3, #2
10025ad4:	e51b2010 	ldr	r2, [fp, #-16]
10025ad8:	e592200c 	ldr	r2, [r2, #12]
10025adc:	e1a02822 	lsr	r2, r2, #16
10025ae0:	e6ef2072 	uxtb	r2, r2
10025ae4:	e5c32000 	strb	r2, [r3]
10025ae8:	e3033594 	movw	r3, #13716	; 0x3594
10025aec:	e3413004 	movt	r3, #4100	; 0x1004
10025af0:	e5933000 	ldr	r3, [r3]
10025af4:	e2833003 	add	r3, r3, #3
10025af8:	e51b2010 	ldr	r2, [fp, #-16]
10025afc:	e592200c 	ldr	r2, [r2, #12]
10025b00:	e1a02c22 	lsr	r2, r2, #24
10025b04:	e6ef2072 	uxtb	r2, r2
10025b08:	e5c32000 	strb	r2, [r3]
10025b0c:	e3033594 	movw	r3, #13716	; 0x3594
10025b10:	e3413004 	movt	r3, #4100	; 0x1004
10025b14:	e5933000 	ldr	r3, [r3]
10025b18:	e2832004 	add	r2, r3, #4
10025b1c:	e3033594 	movw	r3, #13716	; 0x3594
10025b20:	e3413004 	movt	r3, #4100	; 0x1004
10025b24:	e5832000 	str	r2, [r3]
                            break;
10025b28:	ea00008f 	b	10025d6c <finsh_compile+0x590>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10025b2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10025b30:	e5d33002 	ldrb	r3, [r3, #2]
10025b34:	e2033008 	and	r3, r3, #8
10025b38:	e3530000 	cmp	r3, #0
10025b3c:	0a00000c 	beq	10025b74 <finsh_compile+0x398>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10025b40:	e3033594 	movw	r3, #13716	; 0x3594
10025b44:	e3413004 	movt	r3, #4100	; 0x1004
10025b48:	e5933000 	ldr	r3, [r3]
10025b4c:	e3a02024 	mov	r2, #36	; 0x24
10025b50:	e5c32000 	strb	r2, [r3]
10025b54:	e3033594 	movw	r3, #13716	; 0x3594
10025b58:	e3413004 	movt	r3, #4100	; 0x1004
10025b5c:	e5933000 	ldr	r3, [r3]
10025b60:	e2832001 	add	r2, r3, #1
10025b64:	e3033594 	movw	r3, #13716	; 0x3594
10025b68:	e3413004 	movt	r3, #4100	; 0x1004
10025b6c:	e5832000 	str	r2, [r3]
10025b70:	ea00000b 	b	10025ba4 <finsh_compile+0x3c8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10025b74:	e3033594 	movw	r3, #13716	; 0x3594
10025b78:	e3413004 	movt	r3, #4100	; 0x1004
10025b7c:	e5933000 	ldr	r3, [r3]
10025b80:	e3a02026 	mov	r2, #38	; 0x26
10025b84:	e5c32000 	strb	r2, [r3]
10025b88:	e3033594 	movw	r3, #13716	; 0x3594
10025b8c:	e3413004 	movt	r3, #4100	; 0x1004
10025b90:	e5933000 	ldr	r3, [r3]
10025b94:	e2832001 	add	r2, r3, #1
10025b98:	e3033594 	movw	r3, #13716	; 0x3594
10025b9c:	e3413004 	movt	r3, #4100	; 0x1004
10025ba0:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
10025ba4:	e3033594 	movw	r3, #13716	; 0x3594
10025ba8:	e3413004 	movt	r3, #4100	; 0x1004
10025bac:	e5933000 	ldr	r3, [r3]
10025bb0:	e51b2010 	ldr	r2, [fp, #-16]
10025bb4:	e592200c 	ldr	r2, [r2, #12]
10025bb8:	e6ef2072 	uxtb	r2, r2
10025bbc:	e5c32000 	strb	r2, [r3]
10025bc0:	e3033594 	movw	r3, #13716	; 0x3594
10025bc4:	e3413004 	movt	r3, #4100	; 0x1004
10025bc8:	e5933000 	ldr	r3, [r3]
10025bcc:	e2833001 	add	r3, r3, #1
10025bd0:	e51b2010 	ldr	r2, [fp, #-16]
10025bd4:	e592200c 	ldr	r2, [r2, #12]
10025bd8:	e1a02422 	lsr	r2, r2, #8
10025bdc:	e6ef2072 	uxtb	r2, r2
10025be0:	e5c32000 	strb	r2, [r3]
10025be4:	e3033594 	movw	r3, #13716	; 0x3594
10025be8:	e3413004 	movt	r3, #4100	; 0x1004
10025bec:	e5933000 	ldr	r3, [r3]
10025bf0:	e2833002 	add	r3, r3, #2
10025bf4:	e51b2010 	ldr	r2, [fp, #-16]
10025bf8:	e592200c 	ldr	r2, [r2, #12]
10025bfc:	e1a02822 	lsr	r2, r2, #16
10025c00:	e6ef2072 	uxtb	r2, r2
10025c04:	e5c32000 	strb	r2, [r3]
10025c08:	e3033594 	movw	r3, #13716	; 0x3594
10025c0c:	e3413004 	movt	r3, #4100	; 0x1004
10025c10:	e5933000 	ldr	r3, [r3]
10025c14:	e2833003 	add	r3, r3, #3
10025c18:	e51b2010 	ldr	r2, [fp, #-16]
10025c1c:	e592200c 	ldr	r2, [r2, #12]
10025c20:	e1a02c22 	lsr	r2, r2, #24
10025c24:	e6ef2072 	uxtb	r2, r2
10025c28:	e5c32000 	strb	r2, [r3]
10025c2c:	e3033594 	movw	r3, #13716	; 0x3594
10025c30:	e3413004 	movt	r3, #4100	; 0x1004
10025c34:	e5933000 	ldr	r3, [r3]
10025c38:	e2832004 	add	r2, r3, #4
10025c3c:	e3033594 	movw	r3, #13716	; 0x3594
10025c40:	e3413004 	movt	r3, #4100	; 0x1004
10025c44:	e5832000 	str	r2, [r3]
                            break;
10025c48:	ea000047 	b	10025d6c <finsh_compile+0x590>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10025c4c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10025c50:	e5d33002 	ldrb	r3, [r3, #2]
10025c54:	e2033008 	and	r3, r3, #8
10025c58:	e3530000 	cmp	r3, #0
10025c5c:	0a00000c 	beq	10025c94 <finsh_compile+0x4b8>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10025c60:	e3033594 	movw	r3, #13716	; 0x3594
10025c64:	e3413004 	movt	r3, #4100	; 0x1004
10025c68:	e5933000 	ldr	r3, [r3]
10025c6c:	e3a02024 	mov	r2, #36	; 0x24
10025c70:	e5c32000 	strb	r2, [r3]
10025c74:	e3033594 	movw	r3, #13716	; 0x3594
10025c78:	e3413004 	movt	r3, #4100	; 0x1004
10025c7c:	e5933000 	ldr	r3, [r3]
10025c80:	e2832001 	add	r2, r3, #1
10025c84:	e3033594 	movw	r3, #13716	; 0x3594
10025c88:	e3413004 	movt	r3, #4100	; 0x1004
10025c8c:	e5832000 	str	r2, [r3]
10025c90:	ea00000b 	b	10025cc4 <finsh_compile+0x4e8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10025c94:	e3033594 	movw	r3, #13716	; 0x3594
10025c98:	e3413004 	movt	r3, #4100	; 0x1004
10025c9c:	e5933000 	ldr	r3, [r3]
10025ca0:	e3a02027 	mov	r2, #39	; 0x27
10025ca4:	e5c32000 	strb	r2, [r3]
10025ca8:	e3033594 	movw	r3, #13716	; 0x3594
10025cac:	e3413004 	movt	r3, #4100	; 0x1004
10025cb0:	e5933000 	ldr	r3, [r3]
10025cb4:	e2832001 	add	r2, r3, #1
10025cb8:	e3033594 	movw	r3, #13716	; 0x3594
10025cbc:	e3413004 	movt	r3, #4100	; 0x1004
10025cc0:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
10025cc4:	e3033594 	movw	r3, #13716	; 0x3594
10025cc8:	e3413004 	movt	r3, #4100	; 0x1004
10025ccc:	e5933000 	ldr	r3, [r3]
10025cd0:	e51b2010 	ldr	r2, [fp, #-16]
10025cd4:	e592200c 	ldr	r2, [r2, #12]
10025cd8:	e6ef2072 	uxtb	r2, r2
10025cdc:	e5c32000 	strb	r2, [r3]
10025ce0:	e3033594 	movw	r3, #13716	; 0x3594
10025ce4:	e3413004 	movt	r3, #4100	; 0x1004
10025ce8:	e5933000 	ldr	r3, [r3]
10025cec:	e2833001 	add	r3, r3, #1
10025cf0:	e51b2010 	ldr	r2, [fp, #-16]
10025cf4:	e592200c 	ldr	r2, [r2, #12]
10025cf8:	e1a02422 	lsr	r2, r2, #8
10025cfc:	e6ef2072 	uxtb	r2, r2
10025d00:	e5c32000 	strb	r2, [r3]
10025d04:	e3033594 	movw	r3, #13716	; 0x3594
10025d08:	e3413004 	movt	r3, #4100	; 0x1004
10025d0c:	e5933000 	ldr	r3, [r3]
10025d10:	e2833002 	add	r3, r3, #2
10025d14:	e51b2010 	ldr	r2, [fp, #-16]
10025d18:	e592200c 	ldr	r2, [r2, #12]
10025d1c:	e1a02822 	lsr	r2, r2, #16
10025d20:	e6ef2072 	uxtb	r2, r2
10025d24:	e5c32000 	strb	r2, [r3]
10025d28:	e3033594 	movw	r3, #13716	; 0x3594
10025d2c:	e3413004 	movt	r3, #4100	; 0x1004
10025d30:	e5933000 	ldr	r3, [r3]
10025d34:	e2833003 	add	r3, r3, #3
10025d38:	e51b2010 	ldr	r2, [fp, #-16]
10025d3c:	e592200c 	ldr	r2, [r2, #12]
10025d40:	e1a02c22 	lsr	r2, r2, #24
10025d44:	e6ef2072 	uxtb	r2, r2
10025d48:	e5c32000 	strb	r2, [r3]
10025d4c:	e3033594 	movw	r3, #13716	; 0x3594
10025d50:	e3413004 	movt	r3, #4100	; 0x1004
10025d54:	e5933000 	ldr	r3, [r3]
10025d58:	e2832004 	add	r2, r3, #4
10025d5c:	e3033594 	movw	r3, #13716	; 0x3594
10025d60:	e3413004 	movt	r3, #4100	; 0x1004
10025d64:	e5832000 	str	r2, [r3]
                            break;
10025d68:	e1a00000 	nop			; (mov r0, r0)
10025d6c:	ea0000ef 	b	10026130 <finsh_compile+0x954>
                /* identifier::var */
                else
                {
                    struct finsh_var* var;

                    var = node->id.var;
10025d70:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10025d74:	e5933008 	ldr	r3, [r3, #8]
10025d78:	e50b3014 	str	r3, [fp, #-20]
                    if (var != NULL)
10025d7c:	e51b3014 	ldr	r3, [fp, #-20]
10025d80:	e3530000 	cmp	r3, #0
10025d84:	0a0000e9 	beq	10026130 <finsh_compile+0x954>
                    {
                        switch (var->type)
10025d88:	e51b3014 	ldr	r3, [fp, #-20]
10025d8c:	e5d33011 	ldrb	r3, [r3, #17]
10025d90:	e2433003 	sub	r3, r3, #3
10025d94:	e353000b 	cmp	r3, #11
10025d98:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10025d9c:	ea000c40 	b	10028ea4 <finsh_compile+0x36c8>
10025da0:	10025dd0 	.word	0x10025dd0
10025da4:	10025dd0 	.word	0x10025dd0
10025da8:	10026010 	.word	0x10026010
10025dac:	10025ef0 	.word	0x10025ef0
10025db0:	10025ef0 	.word	0x10025ef0
10025db4:	10026010 	.word	0x10026010
10025db8:	10026010 	.word	0x10026010
10025dbc:	10026010 	.word	0x10026010
10025dc0:	10026010 	.word	0x10026010
10025dc4:	10026010 	.word	0x10026010
10025dc8:	10026010 	.word	0x10026010
10025dcc:	10026010 	.word	0x10026010
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10025dd0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10025dd4:	e5d33002 	ldrb	r3, [r3, #2]
10025dd8:	e2033008 	and	r3, r3, #8
10025ddc:	e3530000 	cmp	r3, #0
10025de0:	0a00000c 	beq	10025e18 <finsh_compile+0x63c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10025de4:	e3033594 	movw	r3, #13716	; 0x3594
10025de8:	e3413004 	movt	r3, #4100	; 0x1004
10025dec:	e5933000 	ldr	r3, [r3]
10025df0:	e3a02024 	mov	r2, #36	; 0x24
10025df4:	e5c32000 	strb	r2, [r3]
10025df8:	e3033594 	movw	r3, #13716	; 0x3594
10025dfc:	e3413004 	movt	r3, #4100	; 0x1004
10025e00:	e5933000 	ldr	r3, [r3]
10025e04:	e2832001 	add	r2, r3, #1
10025e08:	e3033594 	movw	r3, #13716	; 0x3594
10025e0c:	e3413004 	movt	r3, #4100	; 0x1004
10025e10:	e5832000 	str	r2, [r3]
10025e14:	ea00000b 	b	10025e48 <finsh_compile+0x66c>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10025e18:	e3033594 	movw	r3, #13716	; 0x3594
10025e1c:	e3413004 	movt	r3, #4100	; 0x1004
10025e20:	e5933000 	ldr	r3, [r3]
10025e24:	e3a02025 	mov	r2, #37	; 0x25
10025e28:	e5c32000 	strb	r2, [r3]
10025e2c:	e3033594 	movw	r3, #13716	; 0x3594
10025e30:	e3413004 	movt	r3, #4100	; 0x1004
10025e34:	e5933000 	ldr	r3, [r3]
10025e38:	e2832001 	add	r2, r3, #1
10025e3c:	e3033594 	movw	r3, #13716	; 0x3594
10025e40:	e3413004 	movt	r3, #4100	; 0x1004
10025e44:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.char_value));
10025e48:	e3033594 	movw	r3, #13716	; 0x3594
10025e4c:	e3413004 	movt	r3, #4100	; 0x1004
10025e50:	e5933000 	ldr	r3, [r3]
10025e54:	e51b2014 	ldr	r2, [fp, #-20]
10025e58:	e2822014 	add	r2, r2, #20
10025e5c:	e6ef2072 	uxtb	r2, r2
10025e60:	e5c32000 	strb	r2, [r3]
10025e64:	e3033594 	movw	r3, #13716	; 0x3594
10025e68:	e3413004 	movt	r3, #4100	; 0x1004
10025e6c:	e5933000 	ldr	r3, [r3]
10025e70:	e2833001 	add	r3, r3, #1
10025e74:	e51b2014 	ldr	r2, [fp, #-20]
10025e78:	e2822014 	add	r2, r2, #20
10025e7c:	e1a02422 	lsr	r2, r2, #8
10025e80:	e6ef2072 	uxtb	r2, r2
10025e84:	e5c32000 	strb	r2, [r3]
10025e88:	e3033594 	movw	r3, #13716	; 0x3594
10025e8c:	e3413004 	movt	r3, #4100	; 0x1004
10025e90:	e5933000 	ldr	r3, [r3]
10025e94:	e2833002 	add	r3, r3, #2
10025e98:	e51b2014 	ldr	r2, [fp, #-20]
10025e9c:	e2822014 	add	r2, r2, #20
10025ea0:	e1a02822 	lsr	r2, r2, #16
10025ea4:	e6ef2072 	uxtb	r2, r2
10025ea8:	e5c32000 	strb	r2, [r3]
10025eac:	e3033594 	movw	r3, #13716	; 0x3594
10025eb0:	e3413004 	movt	r3, #4100	; 0x1004
10025eb4:	e5933000 	ldr	r3, [r3]
10025eb8:	e2833003 	add	r3, r3, #3
10025ebc:	e51b2014 	ldr	r2, [fp, #-20]
10025ec0:	e2822014 	add	r2, r2, #20
10025ec4:	e1a02c22 	lsr	r2, r2, #24
10025ec8:	e6ef2072 	uxtb	r2, r2
10025ecc:	e5c32000 	strb	r2, [r3]
10025ed0:	e3033594 	movw	r3, #13716	; 0x3594
10025ed4:	e3413004 	movt	r3, #4100	; 0x1004
10025ed8:	e5933000 	ldr	r3, [r3]
10025edc:	e2832004 	add	r2, r3, #4
10025ee0:	e3033594 	movw	r3, #13716	; 0x3594
10025ee4:	e3413004 	movt	r3, #4100	; 0x1004
10025ee8:	e5832000 	str	r2, [r3]
                            break;
10025eec:	ea00008f 	b	10026130 <finsh_compile+0x954>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10025ef0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10025ef4:	e5d33002 	ldrb	r3, [r3, #2]
10025ef8:	e2033008 	and	r3, r3, #8
10025efc:	e3530000 	cmp	r3, #0
10025f00:	0a00000c 	beq	10025f38 <finsh_compile+0x75c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10025f04:	e3033594 	movw	r3, #13716	; 0x3594
10025f08:	e3413004 	movt	r3, #4100	; 0x1004
10025f0c:	e5933000 	ldr	r3, [r3]
10025f10:	e3a02024 	mov	r2, #36	; 0x24
10025f14:	e5c32000 	strb	r2, [r3]
10025f18:	e3033594 	movw	r3, #13716	; 0x3594
10025f1c:	e3413004 	movt	r3, #4100	; 0x1004
10025f20:	e5933000 	ldr	r3, [r3]
10025f24:	e2832001 	add	r2, r3, #1
10025f28:	e3033594 	movw	r3, #13716	; 0x3594
10025f2c:	e3413004 	movt	r3, #4100	; 0x1004
10025f30:	e5832000 	str	r2, [r3]
10025f34:	ea00000b 	b	10025f68 <finsh_compile+0x78c>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10025f38:	e3033594 	movw	r3, #13716	; 0x3594
10025f3c:	e3413004 	movt	r3, #4100	; 0x1004
10025f40:	e5933000 	ldr	r3, [r3]
10025f44:	e3a02026 	mov	r2, #38	; 0x26
10025f48:	e5c32000 	strb	r2, [r3]
10025f4c:	e3033594 	movw	r3, #13716	; 0x3594
10025f50:	e3413004 	movt	r3, #4100	; 0x1004
10025f54:	e5933000 	ldr	r3, [r3]
10025f58:	e2832001 	add	r2, r3, #1
10025f5c:	e3033594 	movw	r3, #13716	; 0x3594
10025f60:	e3413004 	movt	r3, #4100	; 0x1004
10025f64:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.short_value));
10025f68:	e3033594 	movw	r3, #13716	; 0x3594
10025f6c:	e3413004 	movt	r3, #4100	; 0x1004
10025f70:	e5933000 	ldr	r3, [r3]
10025f74:	e51b2014 	ldr	r2, [fp, #-20]
10025f78:	e2822014 	add	r2, r2, #20
10025f7c:	e6ef2072 	uxtb	r2, r2
10025f80:	e5c32000 	strb	r2, [r3]
10025f84:	e3033594 	movw	r3, #13716	; 0x3594
10025f88:	e3413004 	movt	r3, #4100	; 0x1004
10025f8c:	e5933000 	ldr	r3, [r3]
10025f90:	e2833001 	add	r3, r3, #1
10025f94:	e51b2014 	ldr	r2, [fp, #-20]
10025f98:	e2822014 	add	r2, r2, #20
10025f9c:	e1a02422 	lsr	r2, r2, #8
10025fa0:	e6ef2072 	uxtb	r2, r2
10025fa4:	e5c32000 	strb	r2, [r3]
10025fa8:	e3033594 	movw	r3, #13716	; 0x3594
10025fac:	e3413004 	movt	r3, #4100	; 0x1004
10025fb0:	e5933000 	ldr	r3, [r3]
10025fb4:	e2833002 	add	r3, r3, #2
10025fb8:	e51b2014 	ldr	r2, [fp, #-20]
10025fbc:	e2822014 	add	r2, r2, #20
10025fc0:	e1a02822 	lsr	r2, r2, #16
10025fc4:	e6ef2072 	uxtb	r2, r2
10025fc8:	e5c32000 	strb	r2, [r3]
10025fcc:	e3033594 	movw	r3, #13716	; 0x3594
10025fd0:	e3413004 	movt	r3, #4100	; 0x1004
10025fd4:	e5933000 	ldr	r3, [r3]
10025fd8:	e2833003 	add	r3, r3, #3
10025fdc:	e51b2014 	ldr	r2, [fp, #-20]
10025fe0:	e2822014 	add	r2, r2, #20
10025fe4:	e1a02c22 	lsr	r2, r2, #24
10025fe8:	e6ef2072 	uxtb	r2, r2
10025fec:	e5c32000 	strb	r2, [r3]
10025ff0:	e3033594 	movw	r3, #13716	; 0x3594
10025ff4:	e3413004 	movt	r3, #4100	; 0x1004
10025ff8:	e5933000 	ldr	r3, [r3]
10025ffc:	e2832004 	add	r2, r3, #4
10026000:	e3033594 	movw	r3, #13716	; 0x3594
10026004:	e3413004 	movt	r3, #4100	; 0x1004
10026008:	e5832000 	str	r2, [r3]
                            break;
1002600c:	ea000047 	b	10026130 <finsh_compile+0x954>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10026010:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026014:	e5d33002 	ldrb	r3, [r3, #2]
10026018:	e2033008 	and	r3, r3, #8
1002601c:	e3530000 	cmp	r3, #0
10026020:	0a00000c 	beq	10026058 <finsh_compile+0x87c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10026024:	e3033594 	movw	r3, #13716	; 0x3594
10026028:	e3413004 	movt	r3, #4100	; 0x1004
1002602c:	e5933000 	ldr	r3, [r3]
10026030:	e3a02024 	mov	r2, #36	; 0x24
10026034:	e5c32000 	strb	r2, [r3]
10026038:	e3033594 	movw	r3, #13716	; 0x3594
1002603c:	e3413004 	movt	r3, #4100	; 0x1004
10026040:	e5933000 	ldr	r3, [r3]
10026044:	e2832001 	add	r2, r3, #1
10026048:	e3033594 	movw	r3, #13716	; 0x3594
1002604c:	e3413004 	movt	r3, #4100	; 0x1004
10026050:	e5832000 	str	r2, [r3]
10026054:	ea00000b 	b	10026088 <finsh_compile+0x8ac>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10026058:	e3033594 	movw	r3, #13716	; 0x3594
1002605c:	e3413004 	movt	r3, #4100	; 0x1004
10026060:	e5933000 	ldr	r3, [r3]
10026064:	e3a02027 	mov	r2, #39	; 0x27
10026068:	e5c32000 	strb	r2, [r3]
1002606c:	e3033594 	movw	r3, #13716	; 0x3594
10026070:	e3413004 	movt	r3, #4100	; 0x1004
10026074:	e5933000 	ldr	r3, [r3]
10026078:	e2832001 	add	r2, r3, #1
1002607c:	e3033594 	movw	r3, #13716	; 0x3594
10026080:	e3413004 	movt	r3, #4100	; 0x1004
10026084:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.long_value));
10026088:	e3033594 	movw	r3, #13716	; 0x3594
1002608c:	e3413004 	movt	r3, #4100	; 0x1004
10026090:	e5933000 	ldr	r3, [r3]
10026094:	e51b2014 	ldr	r2, [fp, #-20]
10026098:	e2822014 	add	r2, r2, #20
1002609c:	e6ef2072 	uxtb	r2, r2
100260a0:	e5c32000 	strb	r2, [r3]
100260a4:	e3033594 	movw	r3, #13716	; 0x3594
100260a8:	e3413004 	movt	r3, #4100	; 0x1004
100260ac:	e5933000 	ldr	r3, [r3]
100260b0:	e2833001 	add	r3, r3, #1
100260b4:	e51b2014 	ldr	r2, [fp, #-20]
100260b8:	e2822014 	add	r2, r2, #20
100260bc:	e1a02422 	lsr	r2, r2, #8
100260c0:	e6ef2072 	uxtb	r2, r2
100260c4:	e5c32000 	strb	r2, [r3]
100260c8:	e3033594 	movw	r3, #13716	; 0x3594
100260cc:	e3413004 	movt	r3, #4100	; 0x1004
100260d0:	e5933000 	ldr	r3, [r3]
100260d4:	e2833002 	add	r3, r3, #2
100260d8:	e51b2014 	ldr	r2, [fp, #-20]
100260dc:	e2822014 	add	r2, r2, #20
100260e0:	e1a02822 	lsr	r2, r2, #16
100260e4:	e6ef2072 	uxtb	r2, r2
100260e8:	e5c32000 	strb	r2, [r3]
100260ec:	e3033594 	movw	r3, #13716	; 0x3594
100260f0:	e3413004 	movt	r3, #4100	; 0x1004
100260f4:	e5933000 	ldr	r3, [r3]
100260f8:	e2833003 	add	r3, r3, #3
100260fc:	e51b2014 	ldr	r2, [fp, #-20]
10026100:	e2822014 	add	r2, r2, #20
10026104:	e1a02c22 	lsr	r2, r2, #24
10026108:	e6ef2072 	uxtb	r2, r2
1002610c:	e5c32000 	strb	r2, [r3]
10026110:	e3033594 	movw	r3, #13716	; 0x3594
10026114:	e3413004 	movt	r3, #4100	; 0x1004
10026118:	e5933000 	ldr	r3, [r3]
1002611c:	e2832004 	add	r2, r3, #4
10026120:	e3033594 	movw	r3, #13716	; 0x3594
10026124:	e3413004 	movt	r3, #4100	; 0x1004
10026128:	e5832000 	str	r2, [r3]
                            break;
1002612c:	e1a00000 	nop			; (mov r0, r0)
                        }
                    }
                }
            }
            break;
10026130:	ea000b5b 	b	10028ea4 <finsh_compile+0x36c8>

        /* load const */
        case FINSH_NODE_VALUE_CHAR:
            finsh_code_byte(FINSH_OP_LD_BYTE);
10026134:	e3033594 	movw	r3, #13716	; 0x3594
10026138:	e3413004 	movt	r3, #4100	; 0x1004
1002613c:	e5933000 	ldr	r3, [r3]
10026140:	e3a02022 	mov	r2, #34	; 0x22
10026144:	e5c32000 	strb	r2, [r3]
10026148:	e3033594 	movw	r3, #13716	; 0x3594
1002614c:	e3413004 	movt	r3, #4100	; 0x1004
10026150:	e5933000 	ldr	r3, [r3]
10026154:	e2832001 	add	r2, r3, #1
10026158:	e3033594 	movw	r3, #13716	; 0x3594
1002615c:	e3413004 	movt	r3, #4100	; 0x1004
10026160:	e5832000 	str	r2, [r3]
            finsh_code_byte(node->value.char_value);
10026164:	e3033594 	movw	r3, #13716	; 0x3594
10026168:	e3413004 	movt	r3, #4100	; 0x1004
1002616c:	e5933000 	ldr	r3, [r3]
10026170:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10026174:	e5d22004 	ldrb	r2, [r2, #4]
10026178:	e5c32000 	strb	r2, [r3]
1002617c:	e3033594 	movw	r3, #13716	; 0x3594
10026180:	e3413004 	movt	r3, #4100	; 0x1004
10026184:	e5933000 	ldr	r3, [r3]
10026188:	e2832001 	add	r2, r3, #1
1002618c:	e3033594 	movw	r3, #13716	; 0x3594
10026190:	e3413004 	movt	r3, #4100	; 0x1004
10026194:	e5832000 	str	r2, [r3]
            break;
10026198:	ea000b42 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_VALUE_INT:
        case FINSH_NODE_VALUE_LONG:
            finsh_code_byte(FINSH_OP_LD_DWORD);
1002619c:	e3033594 	movw	r3, #13716	; 0x3594
100261a0:	e3413004 	movt	r3, #4100	; 0x1004
100261a4:	e5933000 	ldr	r3, [r3]
100261a8:	e3a02024 	mov	r2, #36	; 0x24
100261ac:	e5c32000 	strb	r2, [r3]
100261b0:	e3033594 	movw	r3, #13716	; 0x3594
100261b4:	e3413004 	movt	r3, #4100	; 0x1004
100261b8:	e5933000 	ldr	r3, [r3]
100261bc:	e2832001 	add	r2, r3, #1
100261c0:	e3033594 	movw	r3, #13716	; 0x3594
100261c4:	e3413004 	movt	r3, #4100	; 0x1004
100261c8:	e5832000 	str	r2, [r3]
            finsh_code_dword(node->value.long_value);
100261cc:	e3033594 	movw	r3, #13716	; 0x3594
100261d0:	e3413004 	movt	r3, #4100	; 0x1004
100261d4:	e5933000 	ldr	r3, [r3]
100261d8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100261dc:	e5922004 	ldr	r2, [r2, #4]
100261e0:	e6ef2072 	uxtb	r2, r2
100261e4:	e5c32000 	strb	r2, [r3]
100261e8:	e3033594 	movw	r3, #13716	; 0x3594
100261ec:	e3413004 	movt	r3, #4100	; 0x1004
100261f0:	e5933000 	ldr	r3, [r3]
100261f4:	e2833001 	add	r3, r3, #1
100261f8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100261fc:	e5922004 	ldr	r2, [r2, #4]
10026200:	e1a02422 	lsr	r2, r2, #8
10026204:	e6ef2072 	uxtb	r2, r2
10026208:	e5c32000 	strb	r2, [r3]
1002620c:	e3033594 	movw	r3, #13716	; 0x3594
10026210:	e3413004 	movt	r3, #4100	; 0x1004
10026214:	e5933000 	ldr	r3, [r3]
10026218:	e2833002 	add	r3, r3, #2
1002621c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10026220:	e5922004 	ldr	r2, [r2, #4]
10026224:	e1a02822 	lsr	r2, r2, #16
10026228:	e6ef2072 	uxtb	r2, r2
1002622c:	e5c32000 	strb	r2, [r3]
10026230:	e3033594 	movw	r3, #13716	; 0x3594
10026234:	e3413004 	movt	r3, #4100	; 0x1004
10026238:	e5933000 	ldr	r3, [r3]
1002623c:	e2833003 	add	r3, r3, #3
10026240:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10026244:	e5922004 	ldr	r2, [r2, #4]
10026248:	e1a02c22 	lsr	r2, r2, #24
1002624c:	e6ef2072 	uxtb	r2, r2
10026250:	e5c32000 	strb	r2, [r3]
10026254:	e3033594 	movw	r3, #13716	; 0x3594
10026258:	e3413004 	movt	r3, #4100	; 0x1004
1002625c:	e5933000 	ldr	r3, [r3]
10026260:	e2832004 	add	r2, r3, #4
10026264:	e3033594 	movw	r3, #13716	; 0x3594
10026268:	e3413004 	movt	r3, #4100	; 0x1004
1002626c:	e5832000 	str	r2, [r3]
            break;
10026270:	ea000b0c 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_VALUE_NULL:
        case FINSH_NODE_VALUE_STRING:
            finsh_code_byte(FINSH_OP_LD_DWORD);
10026274:	e3033594 	movw	r3, #13716	; 0x3594
10026278:	e3413004 	movt	r3, #4100	; 0x1004
1002627c:	e5933000 	ldr	r3, [r3]
10026280:	e3a02024 	mov	r2, #36	; 0x24
10026284:	e5c32000 	strb	r2, [r3]
10026288:	e3033594 	movw	r3, #13716	; 0x3594
1002628c:	e3413004 	movt	r3, #4100	; 0x1004
10026290:	e5933000 	ldr	r3, [r3]
10026294:	e2832001 	add	r2, r3, #1
10026298:	e3033594 	movw	r3, #13716	; 0x3594
1002629c:	e3413004 	movt	r3, #4100	; 0x1004
100262a0:	e5832000 	str	r2, [r3]
            finsh_code_dword((u_long)node->value.ptr);
100262a4:	e3033594 	movw	r3, #13716	; 0x3594
100262a8:	e3413004 	movt	r3, #4100	; 0x1004
100262ac:	e5933000 	ldr	r3, [r3]
100262b0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100262b4:	e5922004 	ldr	r2, [r2, #4]
100262b8:	e6ef2072 	uxtb	r2, r2
100262bc:	e5c32000 	strb	r2, [r3]
100262c0:	e3033594 	movw	r3, #13716	; 0x3594
100262c4:	e3413004 	movt	r3, #4100	; 0x1004
100262c8:	e5933000 	ldr	r3, [r3]
100262cc:	e2833001 	add	r3, r3, #1
100262d0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100262d4:	e5922004 	ldr	r2, [r2, #4]
100262d8:	e1a02422 	lsr	r2, r2, #8
100262dc:	e6ef2072 	uxtb	r2, r2
100262e0:	e5c32000 	strb	r2, [r3]
100262e4:	e3033594 	movw	r3, #13716	; 0x3594
100262e8:	e3413004 	movt	r3, #4100	; 0x1004
100262ec:	e5933000 	ldr	r3, [r3]
100262f0:	e2833002 	add	r3, r3, #2
100262f4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100262f8:	e5922004 	ldr	r2, [r2, #4]
100262fc:	e1a02822 	lsr	r2, r2, #16
10026300:	e6ef2072 	uxtb	r2, r2
10026304:	e5c32000 	strb	r2, [r3]
10026308:	e3033594 	movw	r3, #13716	; 0x3594
1002630c:	e3413004 	movt	r3, #4100	; 0x1004
10026310:	e5933000 	ldr	r3, [r3]
10026314:	e2833003 	add	r3, r3, #3
10026318:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1002631c:	e5922004 	ldr	r2, [r2, #4]
10026320:	e1a02c22 	lsr	r2, r2, #24
10026324:	e6ef2072 	uxtb	r2, r2
10026328:	e5c32000 	strb	r2, [r3]
1002632c:	e3033594 	movw	r3, #13716	; 0x3594
10026330:	e3413004 	movt	r3, #4100	; 0x1004
10026334:	e5933000 	ldr	r3, [r3]
10026338:	e2832004 	add	r2, r3, #4
1002633c:	e3033594 	movw	r3, #13716	; 0x3594
10026340:	e3413004 	movt	r3, #4100	; 0x1004
10026344:	e5832000 	str	r2, [r3]
            break;
10026348:	ea000ad6 	b	10028ea8 <finsh_compile+0x36cc>

        /* arithmetic operation */
        case FINSH_NODE_SYS_ADD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_ADD_BYTE);
1002634c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026350:	e5d33001 	ldrb	r3, [r3, #1]
10026354:	e3530001 	cmp	r3, #1
10026358:	1a00000c 	bne	10026390 <finsh_compile+0xbb4>
1002635c:	e3033594 	movw	r3, #13716	; 0x3594
10026360:	e3413004 	movt	r3, #4100	; 0x1004
10026364:	e5933000 	ldr	r3, [r3]
10026368:	e3a02001 	mov	r2, #1
1002636c:	e5c32000 	strb	r2, [r3]
10026370:	e3033594 	movw	r3, #13716	; 0x3594
10026374:	e3413004 	movt	r3, #4100	; 0x1004
10026378:	e5933000 	ldr	r3, [r3]
1002637c:	e2832001 	add	r2, r3, #1
10026380:	e3033594 	movw	r3, #13716	; 0x3594
10026384:	e3413004 	movt	r3, #4100	; 0x1004
10026388:	e5832000 	str	r2, [r3]
1002638c:	ea000021 	b	10026418 <finsh_compile+0xc3c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_ADD_WORD);
10026390:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026394:	e5d33001 	ldrb	r3, [r3, #1]
10026398:	e3530002 	cmp	r3, #2
1002639c:	1a00000c 	bne	100263d4 <finsh_compile+0xbf8>
100263a0:	e3033594 	movw	r3, #13716	; 0x3594
100263a4:	e3413004 	movt	r3, #4100	; 0x1004
100263a8:	e5933000 	ldr	r3, [r3]
100263ac:	e3a02002 	mov	r2, #2
100263b0:	e5c32000 	strb	r2, [r3]
100263b4:	e3033594 	movw	r3, #13716	; 0x3594
100263b8:	e3413004 	movt	r3, #4100	; 0x1004
100263bc:	e5933000 	ldr	r3, [r3]
100263c0:	e2832001 	add	r2, r3, #1
100263c4:	e3033594 	movw	r3, #13716	; 0x3594
100263c8:	e3413004 	movt	r3, #4100	; 0x1004
100263cc:	e5832000 	str	r2, [r3]
100263d0:	ea000010 	b	10026418 <finsh_compile+0xc3c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_ADD_DWORD);
100263d4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100263d8:	e5d33001 	ldrb	r3, [r3, #1]
100263dc:	e3530003 	cmp	r3, #3
100263e0:	1a00000c 	bne	10026418 <finsh_compile+0xc3c>
100263e4:	e3033594 	movw	r3, #13716	; 0x3594
100263e8:	e3413004 	movt	r3, #4100	; 0x1004
100263ec:	e5933000 	ldr	r3, [r3]
100263f0:	e3a02003 	mov	r2, #3
100263f4:	e5c32000 	strb	r2, [r3]
100263f8:	e3033594 	movw	r3, #13716	; 0x3594
100263fc:	e3413004 	movt	r3, #4100	; 0x1004
10026400:	e5933000 	ldr	r3, [r3]
10026404:	e2832001 	add	r2, r3, #1
10026408:	e3033594 	movw	r3, #13716	; 0x3594
1002640c:	e3413004 	movt	r3, #4100	; 0x1004
10026410:	e5832000 	str	r2, [r3]
            break;
10026414:	ea000aa3 	b	10028ea8 <finsh_compile+0x36cc>
10026418:	ea000aa2 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SUB:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SUB_BYTE);
1002641c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026420:	e5d33001 	ldrb	r3, [r3, #1]
10026424:	e3530001 	cmp	r3, #1
10026428:	1a00000c 	bne	10026460 <finsh_compile+0xc84>
1002642c:	e3033594 	movw	r3, #13716	; 0x3594
10026430:	e3413004 	movt	r3, #4100	; 0x1004
10026434:	e5933000 	ldr	r3, [r3]
10026438:	e3a02004 	mov	r2, #4
1002643c:	e5c32000 	strb	r2, [r3]
10026440:	e3033594 	movw	r3, #13716	; 0x3594
10026444:	e3413004 	movt	r3, #4100	; 0x1004
10026448:	e5933000 	ldr	r3, [r3]
1002644c:	e2832001 	add	r2, r3, #1
10026450:	e3033594 	movw	r3, #13716	; 0x3594
10026454:	e3413004 	movt	r3, #4100	; 0x1004
10026458:	e5832000 	str	r2, [r3]
1002645c:	ea000021 	b	100264e8 <finsh_compile+0xd0c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SUB_WORD);
10026460:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026464:	e5d33001 	ldrb	r3, [r3, #1]
10026468:	e3530002 	cmp	r3, #2
1002646c:	1a00000c 	bne	100264a4 <finsh_compile+0xcc8>
10026470:	e3033594 	movw	r3, #13716	; 0x3594
10026474:	e3413004 	movt	r3, #4100	; 0x1004
10026478:	e5933000 	ldr	r3, [r3]
1002647c:	e3a02005 	mov	r2, #5
10026480:	e5c32000 	strb	r2, [r3]
10026484:	e3033594 	movw	r3, #13716	; 0x3594
10026488:	e3413004 	movt	r3, #4100	; 0x1004
1002648c:	e5933000 	ldr	r3, [r3]
10026490:	e2832001 	add	r2, r3, #1
10026494:	e3033594 	movw	r3, #13716	; 0x3594
10026498:	e3413004 	movt	r3, #4100	; 0x1004
1002649c:	e5832000 	str	r2, [r3]
100264a0:	ea000010 	b	100264e8 <finsh_compile+0xd0c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SUB_DWORD);
100264a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100264a8:	e5d33001 	ldrb	r3, [r3, #1]
100264ac:	e3530003 	cmp	r3, #3
100264b0:	1a00000c 	bne	100264e8 <finsh_compile+0xd0c>
100264b4:	e3033594 	movw	r3, #13716	; 0x3594
100264b8:	e3413004 	movt	r3, #4100	; 0x1004
100264bc:	e5933000 	ldr	r3, [r3]
100264c0:	e3a02006 	mov	r2, #6
100264c4:	e5c32000 	strb	r2, [r3]
100264c8:	e3033594 	movw	r3, #13716	; 0x3594
100264cc:	e3413004 	movt	r3, #4100	; 0x1004
100264d0:	e5933000 	ldr	r3, [r3]
100264d4:	e2832001 	add	r2, r3, #1
100264d8:	e3033594 	movw	r3, #13716	; 0x3594
100264dc:	e3413004 	movt	r3, #4100	; 0x1004
100264e0:	e5832000 	str	r2, [r3]
            break;
100264e4:	ea000a6f 	b	10028ea8 <finsh_compile+0x36cc>
100264e8:	ea000a6e 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_MUL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MUL_BYTE);
100264ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100264f0:	e5d33001 	ldrb	r3, [r3, #1]
100264f4:	e3530001 	cmp	r3, #1
100264f8:	1a00000c 	bne	10026530 <finsh_compile+0xd54>
100264fc:	e3033594 	movw	r3, #13716	; 0x3594
10026500:	e3413004 	movt	r3, #4100	; 0x1004
10026504:	e5933000 	ldr	r3, [r3]
10026508:	e3a0200d 	mov	r2, #13
1002650c:	e5c32000 	strb	r2, [r3]
10026510:	e3033594 	movw	r3, #13716	; 0x3594
10026514:	e3413004 	movt	r3, #4100	; 0x1004
10026518:	e5933000 	ldr	r3, [r3]
1002651c:	e2832001 	add	r2, r3, #1
10026520:	e3033594 	movw	r3, #13716	; 0x3594
10026524:	e3413004 	movt	r3, #4100	; 0x1004
10026528:	e5832000 	str	r2, [r3]
1002652c:	ea000021 	b	100265b8 <finsh_compile+0xddc>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MUL_WORD);
10026530:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026534:	e5d33001 	ldrb	r3, [r3, #1]
10026538:	e3530002 	cmp	r3, #2
1002653c:	1a00000c 	bne	10026574 <finsh_compile+0xd98>
10026540:	e3033594 	movw	r3, #13716	; 0x3594
10026544:	e3413004 	movt	r3, #4100	; 0x1004
10026548:	e5933000 	ldr	r3, [r3]
1002654c:	e3a0200e 	mov	r2, #14
10026550:	e5c32000 	strb	r2, [r3]
10026554:	e3033594 	movw	r3, #13716	; 0x3594
10026558:	e3413004 	movt	r3, #4100	; 0x1004
1002655c:	e5933000 	ldr	r3, [r3]
10026560:	e2832001 	add	r2, r3, #1
10026564:	e3033594 	movw	r3, #13716	; 0x3594
10026568:	e3413004 	movt	r3, #4100	; 0x1004
1002656c:	e5832000 	str	r2, [r3]
10026570:	ea000010 	b	100265b8 <finsh_compile+0xddc>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MUL_DWORD);
10026574:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026578:	e5d33001 	ldrb	r3, [r3, #1]
1002657c:	e3530003 	cmp	r3, #3
10026580:	1a00000c 	bne	100265b8 <finsh_compile+0xddc>
10026584:	e3033594 	movw	r3, #13716	; 0x3594
10026588:	e3413004 	movt	r3, #4100	; 0x1004
1002658c:	e5933000 	ldr	r3, [r3]
10026590:	e3a0200f 	mov	r2, #15
10026594:	e5c32000 	strb	r2, [r3]
10026598:	e3033594 	movw	r3, #13716	; 0x3594
1002659c:	e3413004 	movt	r3, #4100	; 0x1004
100265a0:	e5933000 	ldr	r3, [r3]
100265a4:	e2832001 	add	r2, r3, #1
100265a8:	e3033594 	movw	r3, #13716	; 0x3594
100265ac:	e3413004 	movt	r3, #4100	; 0x1004
100265b0:	e5832000 	str	r2, [r3]
            break;
100265b4:	ea000a3b 	b	10028ea8 <finsh_compile+0x36cc>
100265b8:	ea000a3a 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_DIV:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_DIV_BYTE);
100265bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100265c0:	e5d33001 	ldrb	r3, [r3, #1]
100265c4:	e3530001 	cmp	r3, #1
100265c8:	1a00000c 	bne	10026600 <finsh_compile+0xe24>
100265cc:	e3033594 	movw	r3, #13716	; 0x3594
100265d0:	e3413004 	movt	r3, #4100	; 0x1004
100265d4:	e5933000 	ldr	r3, [r3]
100265d8:	e3a02007 	mov	r2, #7
100265dc:	e5c32000 	strb	r2, [r3]
100265e0:	e3033594 	movw	r3, #13716	; 0x3594
100265e4:	e3413004 	movt	r3, #4100	; 0x1004
100265e8:	e5933000 	ldr	r3, [r3]
100265ec:	e2832001 	add	r2, r3, #1
100265f0:	e3033594 	movw	r3, #13716	; 0x3594
100265f4:	e3413004 	movt	r3, #4100	; 0x1004
100265f8:	e5832000 	str	r2, [r3]
100265fc:	ea000021 	b	10026688 <finsh_compile+0xeac>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_DIV_WORD);
10026600:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026604:	e5d33001 	ldrb	r3, [r3, #1]
10026608:	e3530002 	cmp	r3, #2
1002660c:	1a00000c 	bne	10026644 <finsh_compile+0xe68>
10026610:	e3033594 	movw	r3, #13716	; 0x3594
10026614:	e3413004 	movt	r3, #4100	; 0x1004
10026618:	e5933000 	ldr	r3, [r3]
1002661c:	e3a02008 	mov	r2, #8
10026620:	e5c32000 	strb	r2, [r3]
10026624:	e3033594 	movw	r3, #13716	; 0x3594
10026628:	e3413004 	movt	r3, #4100	; 0x1004
1002662c:	e5933000 	ldr	r3, [r3]
10026630:	e2832001 	add	r2, r3, #1
10026634:	e3033594 	movw	r3, #13716	; 0x3594
10026638:	e3413004 	movt	r3, #4100	; 0x1004
1002663c:	e5832000 	str	r2, [r3]
10026640:	ea000010 	b	10026688 <finsh_compile+0xeac>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_DIV_DWORD);
10026644:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026648:	e5d33001 	ldrb	r3, [r3, #1]
1002664c:	e3530003 	cmp	r3, #3
10026650:	1a00000c 	bne	10026688 <finsh_compile+0xeac>
10026654:	e3033594 	movw	r3, #13716	; 0x3594
10026658:	e3413004 	movt	r3, #4100	; 0x1004
1002665c:	e5933000 	ldr	r3, [r3]
10026660:	e3a02009 	mov	r2, #9
10026664:	e5c32000 	strb	r2, [r3]
10026668:	e3033594 	movw	r3, #13716	; 0x3594
1002666c:	e3413004 	movt	r3, #4100	; 0x1004
10026670:	e5933000 	ldr	r3, [r3]
10026674:	e2832001 	add	r2, r3, #1
10026678:	e3033594 	movw	r3, #13716	; 0x3594
1002667c:	e3413004 	movt	r3, #4100	; 0x1004
10026680:	e5832000 	str	r2, [r3]
            break;
10026684:	ea000a07 	b	10028ea8 <finsh_compile+0x36cc>
10026688:	ea000a06 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_MOD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MOD_BYTE);
1002668c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026690:	e5d33001 	ldrb	r3, [r3, #1]
10026694:	e3530001 	cmp	r3, #1
10026698:	1a00000c 	bne	100266d0 <finsh_compile+0xef4>
1002669c:	e3033594 	movw	r3, #13716	; 0x3594
100266a0:	e3413004 	movt	r3, #4100	; 0x1004
100266a4:	e5933000 	ldr	r3, [r3]
100266a8:	e3a0200a 	mov	r2, #10
100266ac:	e5c32000 	strb	r2, [r3]
100266b0:	e3033594 	movw	r3, #13716	; 0x3594
100266b4:	e3413004 	movt	r3, #4100	; 0x1004
100266b8:	e5933000 	ldr	r3, [r3]
100266bc:	e2832001 	add	r2, r3, #1
100266c0:	e3033594 	movw	r3, #13716	; 0x3594
100266c4:	e3413004 	movt	r3, #4100	; 0x1004
100266c8:	e5832000 	str	r2, [r3]
100266cc:	ea000021 	b	10026758 <finsh_compile+0xf7c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MOD_WORD);
100266d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100266d4:	e5d33001 	ldrb	r3, [r3, #1]
100266d8:	e3530002 	cmp	r3, #2
100266dc:	1a00000c 	bne	10026714 <finsh_compile+0xf38>
100266e0:	e3033594 	movw	r3, #13716	; 0x3594
100266e4:	e3413004 	movt	r3, #4100	; 0x1004
100266e8:	e5933000 	ldr	r3, [r3]
100266ec:	e3a0200b 	mov	r2, #11
100266f0:	e5c32000 	strb	r2, [r3]
100266f4:	e3033594 	movw	r3, #13716	; 0x3594
100266f8:	e3413004 	movt	r3, #4100	; 0x1004
100266fc:	e5933000 	ldr	r3, [r3]
10026700:	e2832001 	add	r2, r3, #1
10026704:	e3033594 	movw	r3, #13716	; 0x3594
10026708:	e3413004 	movt	r3, #4100	; 0x1004
1002670c:	e5832000 	str	r2, [r3]
10026710:	ea000010 	b	10026758 <finsh_compile+0xf7c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MOD_DWORD);
10026714:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026718:	e5d33001 	ldrb	r3, [r3, #1]
1002671c:	e3530003 	cmp	r3, #3
10026720:	1a00000c 	bne	10026758 <finsh_compile+0xf7c>
10026724:	e3033594 	movw	r3, #13716	; 0x3594
10026728:	e3413004 	movt	r3, #4100	; 0x1004
1002672c:	e5933000 	ldr	r3, [r3]
10026730:	e3a0200c 	mov	r2, #12
10026734:	e5c32000 	strb	r2, [r3]
10026738:	e3033594 	movw	r3, #13716	; 0x3594
1002673c:	e3413004 	movt	r3, #4100	; 0x1004
10026740:	e5933000 	ldr	r3, [r3]
10026744:	e2832001 	add	r2, r3, #1
10026748:	e3033594 	movw	r3, #13716	; 0x3594
1002674c:	e3413004 	movt	r3, #4100	; 0x1004
10026750:	e5832000 	str	r2, [r3]
            break;
10026754:	ea0009d3 	b	10028ea8 <finsh_compile+0x36cc>
10026758:	ea0009d2 	b	10028ea8 <finsh_compile+0x36cc>

        /* bit operation */
        case FINSH_NODE_SYS_AND:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_AND_BYTE);
1002675c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026760:	e5d33001 	ldrb	r3, [r3, #1]
10026764:	e3530001 	cmp	r3, #1
10026768:	1a00000c 	bne	100267a0 <finsh_compile+0xfc4>
1002676c:	e3033594 	movw	r3, #13716	; 0x3594
10026770:	e3413004 	movt	r3, #4100	; 0x1004
10026774:	e5933000 	ldr	r3, [r3]
10026778:	e3a02010 	mov	r2, #16
1002677c:	e5c32000 	strb	r2, [r3]
10026780:	e3033594 	movw	r3, #13716	; 0x3594
10026784:	e3413004 	movt	r3, #4100	; 0x1004
10026788:	e5933000 	ldr	r3, [r3]
1002678c:	e2832001 	add	r2, r3, #1
10026790:	e3033594 	movw	r3, #13716	; 0x3594
10026794:	e3413004 	movt	r3, #4100	; 0x1004
10026798:	e5832000 	str	r2, [r3]
1002679c:	ea000021 	b	10026828 <finsh_compile+0x104c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_AND_WORD);
100267a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100267a4:	e5d33001 	ldrb	r3, [r3, #1]
100267a8:	e3530002 	cmp	r3, #2
100267ac:	1a00000c 	bne	100267e4 <finsh_compile+0x1008>
100267b0:	e3033594 	movw	r3, #13716	; 0x3594
100267b4:	e3413004 	movt	r3, #4100	; 0x1004
100267b8:	e5933000 	ldr	r3, [r3]
100267bc:	e3a02011 	mov	r2, #17
100267c0:	e5c32000 	strb	r2, [r3]
100267c4:	e3033594 	movw	r3, #13716	; 0x3594
100267c8:	e3413004 	movt	r3, #4100	; 0x1004
100267cc:	e5933000 	ldr	r3, [r3]
100267d0:	e2832001 	add	r2, r3, #1
100267d4:	e3033594 	movw	r3, #13716	; 0x3594
100267d8:	e3413004 	movt	r3, #4100	; 0x1004
100267dc:	e5832000 	str	r2, [r3]
100267e0:	ea000010 	b	10026828 <finsh_compile+0x104c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_AND_DWORD);
100267e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100267e8:	e5d33001 	ldrb	r3, [r3, #1]
100267ec:	e3530003 	cmp	r3, #3
100267f0:	1a00000c 	bne	10026828 <finsh_compile+0x104c>
100267f4:	e3033594 	movw	r3, #13716	; 0x3594
100267f8:	e3413004 	movt	r3, #4100	; 0x1004
100267fc:	e5933000 	ldr	r3, [r3]
10026800:	e3a02012 	mov	r2, #18
10026804:	e5c32000 	strb	r2, [r3]
10026808:	e3033594 	movw	r3, #13716	; 0x3594
1002680c:	e3413004 	movt	r3, #4100	; 0x1004
10026810:	e5933000 	ldr	r3, [r3]
10026814:	e2832001 	add	r2, r3, #1
10026818:	e3033594 	movw	r3, #13716	; 0x3594
1002681c:	e3413004 	movt	r3, #4100	; 0x1004
10026820:	e5832000 	str	r2, [r3]
            break;
10026824:	ea00099f 	b	10028ea8 <finsh_compile+0x36cc>
10026828:	ea00099e 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_OR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_OR_BYTE);
1002682c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026830:	e5d33001 	ldrb	r3, [r3, #1]
10026834:	e3530001 	cmp	r3, #1
10026838:	1a00000c 	bne	10026870 <finsh_compile+0x1094>
1002683c:	e3033594 	movw	r3, #13716	; 0x3594
10026840:	e3413004 	movt	r3, #4100	; 0x1004
10026844:	e5933000 	ldr	r3, [r3]
10026848:	e3a02013 	mov	r2, #19
1002684c:	e5c32000 	strb	r2, [r3]
10026850:	e3033594 	movw	r3, #13716	; 0x3594
10026854:	e3413004 	movt	r3, #4100	; 0x1004
10026858:	e5933000 	ldr	r3, [r3]
1002685c:	e2832001 	add	r2, r3, #1
10026860:	e3033594 	movw	r3, #13716	; 0x3594
10026864:	e3413004 	movt	r3, #4100	; 0x1004
10026868:	e5832000 	str	r2, [r3]
1002686c:	ea000021 	b	100268f8 <finsh_compile+0x111c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_OR_WORD);
10026870:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026874:	e5d33001 	ldrb	r3, [r3, #1]
10026878:	e3530002 	cmp	r3, #2
1002687c:	1a00000c 	bne	100268b4 <finsh_compile+0x10d8>
10026880:	e3033594 	movw	r3, #13716	; 0x3594
10026884:	e3413004 	movt	r3, #4100	; 0x1004
10026888:	e5933000 	ldr	r3, [r3]
1002688c:	e3a02014 	mov	r2, #20
10026890:	e5c32000 	strb	r2, [r3]
10026894:	e3033594 	movw	r3, #13716	; 0x3594
10026898:	e3413004 	movt	r3, #4100	; 0x1004
1002689c:	e5933000 	ldr	r3, [r3]
100268a0:	e2832001 	add	r2, r3, #1
100268a4:	e3033594 	movw	r3, #13716	; 0x3594
100268a8:	e3413004 	movt	r3, #4100	; 0x1004
100268ac:	e5832000 	str	r2, [r3]
100268b0:	ea000010 	b	100268f8 <finsh_compile+0x111c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_OR_DWORD);
100268b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100268b8:	e5d33001 	ldrb	r3, [r3, #1]
100268bc:	e3530003 	cmp	r3, #3
100268c0:	1a00000c 	bne	100268f8 <finsh_compile+0x111c>
100268c4:	e3033594 	movw	r3, #13716	; 0x3594
100268c8:	e3413004 	movt	r3, #4100	; 0x1004
100268cc:	e5933000 	ldr	r3, [r3]
100268d0:	e3a02015 	mov	r2, #21
100268d4:	e5c32000 	strb	r2, [r3]
100268d8:	e3033594 	movw	r3, #13716	; 0x3594
100268dc:	e3413004 	movt	r3, #4100	; 0x1004
100268e0:	e5933000 	ldr	r3, [r3]
100268e4:	e2832001 	add	r2, r3, #1
100268e8:	e3033594 	movw	r3, #13716	; 0x3594
100268ec:	e3413004 	movt	r3, #4100	; 0x1004
100268f0:	e5832000 	str	r2, [r3]
            break;
100268f4:	ea00096b 	b	10028ea8 <finsh_compile+0x36cc>
100268f8:	ea00096a 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_XOR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_XOR_BYTE);
100268fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026900:	e5d33001 	ldrb	r3, [r3, #1]
10026904:	e3530001 	cmp	r3, #1
10026908:	1a00000c 	bne	10026940 <finsh_compile+0x1164>
1002690c:	e3033594 	movw	r3, #13716	; 0x3594
10026910:	e3413004 	movt	r3, #4100	; 0x1004
10026914:	e5933000 	ldr	r3, [r3]
10026918:	e3a02016 	mov	r2, #22
1002691c:	e5c32000 	strb	r2, [r3]
10026920:	e3033594 	movw	r3, #13716	; 0x3594
10026924:	e3413004 	movt	r3, #4100	; 0x1004
10026928:	e5933000 	ldr	r3, [r3]
1002692c:	e2832001 	add	r2, r3, #1
10026930:	e3033594 	movw	r3, #13716	; 0x3594
10026934:	e3413004 	movt	r3, #4100	; 0x1004
10026938:	e5832000 	str	r2, [r3]
1002693c:	ea000021 	b	100269c8 <finsh_compile+0x11ec>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_XOR_WORD);
10026940:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026944:	e5d33001 	ldrb	r3, [r3, #1]
10026948:	e3530002 	cmp	r3, #2
1002694c:	1a00000c 	bne	10026984 <finsh_compile+0x11a8>
10026950:	e3033594 	movw	r3, #13716	; 0x3594
10026954:	e3413004 	movt	r3, #4100	; 0x1004
10026958:	e5933000 	ldr	r3, [r3]
1002695c:	e3a02017 	mov	r2, #23
10026960:	e5c32000 	strb	r2, [r3]
10026964:	e3033594 	movw	r3, #13716	; 0x3594
10026968:	e3413004 	movt	r3, #4100	; 0x1004
1002696c:	e5933000 	ldr	r3, [r3]
10026970:	e2832001 	add	r2, r3, #1
10026974:	e3033594 	movw	r3, #13716	; 0x3594
10026978:	e3413004 	movt	r3, #4100	; 0x1004
1002697c:	e5832000 	str	r2, [r3]
10026980:	ea000010 	b	100269c8 <finsh_compile+0x11ec>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_XOR_DWORD);
10026984:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026988:	e5d33001 	ldrb	r3, [r3, #1]
1002698c:	e3530003 	cmp	r3, #3
10026990:	1a00000c 	bne	100269c8 <finsh_compile+0x11ec>
10026994:	e3033594 	movw	r3, #13716	; 0x3594
10026998:	e3413004 	movt	r3, #4100	; 0x1004
1002699c:	e5933000 	ldr	r3, [r3]
100269a0:	e3a02018 	mov	r2, #24
100269a4:	e5c32000 	strb	r2, [r3]
100269a8:	e3033594 	movw	r3, #13716	; 0x3594
100269ac:	e3413004 	movt	r3, #4100	; 0x1004
100269b0:	e5933000 	ldr	r3, [r3]
100269b4:	e2832001 	add	r2, r3, #1
100269b8:	e3033594 	movw	r3, #13716	; 0x3594
100269bc:	e3413004 	movt	r3, #4100	; 0x1004
100269c0:	e5832000 	str	r2, [r3]
            break;
100269c4:	ea000937 	b	10028ea8 <finsh_compile+0x36cc>
100269c8:	ea000936 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_BITWISE:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_BITWISE_BYTE);
100269cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100269d0:	e5d33001 	ldrb	r3, [r3, #1]
100269d4:	e3530001 	cmp	r3, #1
100269d8:	1a00000c 	bne	10026a10 <finsh_compile+0x1234>
100269dc:	e3033594 	movw	r3, #13716	; 0x3594
100269e0:	e3413004 	movt	r3, #4100	; 0x1004
100269e4:	e5933000 	ldr	r3, [r3]
100269e8:	e3a02019 	mov	r2, #25
100269ec:	e5c32000 	strb	r2, [r3]
100269f0:	e3033594 	movw	r3, #13716	; 0x3594
100269f4:	e3413004 	movt	r3, #4100	; 0x1004
100269f8:	e5933000 	ldr	r3, [r3]
100269fc:	e2832001 	add	r2, r3, #1
10026a00:	e3033594 	movw	r3, #13716	; 0x3594
10026a04:	e3413004 	movt	r3, #4100	; 0x1004
10026a08:	e5832000 	str	r2, [r3]
10026a0c:	ea000021 	b	10026a98 <finsh_compile+0x12bc>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_BITWISE_WORD);
10026a10:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026a14:	e5d33001 	ldrb	r3, [r3, #1]
10026a18:	e3530002 	cmp	r3, #2
10026a1c:	1a00000c 	bne	10026a54 <finsh_compile+0x1278>
10026a20:	e3033594 	movw	r3, #13716	; 0x3594
10026a24:	e3413004 	movt	r3, #4100	; 0x1004
10026a28:	e5933000 	ldr	r3, [r3]
10026a2c:	e3a0201a 	mov	r2, #26
10026a30:	e5c32000 	strb	r2, [r3]
10026a34:	e3033594 	movw	r3, #13716	; 0x3594
10026a38:	e3413004 	movt	r3, #4100	; 0x1004
10026a3c:	e5933000 	ldr	r3, [r3]
10026a40:	e2832001 	add	r2, r3, #1
10026a44:	e3033594 	movw	r3, #13716	; 0x3594
10026a48:	e3413004 	movt	r3, #4100	; 0x1004
10026a4c:	e5832000 	str	r2, [r3]
10026a50:	ea000010 	b	10026a98 <finsh_compile+0x12bc>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_BITWISE_DWORD);
10026a54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026a58:	e5d33001 	ldrb	r3, [r3, #1]
10026a5c:	e3530003 	cmp	r3, #3
10026a60:	1a00000c 	bne	10026a98 <finsh_compile+0x12bc>
10026a64:	e3033594 	movw	r3, #13716	; 0x3594
10026a68:	e3413004 	movt	r3, #4100	; 0x1004
10026a6c:	e5933000 	ldr	r3, [r3]
10026a70:	e3a0201b 	mov	r2, #27
10026a74:	e5c32000 	strb	r2, [r3]
10026a78:	e3033594 	movw	r3, #13716	; 0x3594
10026a7c:	e3413004 	movt	r3, #4100	; 0x1004
10026a80:	e5933000 	ldr	r3, [r3]
10026a84:	e2832001 	add	r2, r3, #1
10026a88:	e3033594 	movw	r3, #13716	; 0x3594
10026a8c:	e3413004 	movt	r3, #4100	; 0x1004
10026a90:	e5832000 	str	r2, [r3]
            break;
10026a94:	ea000903 	b	10028ea8 <finsh_compile+0x36cc>
10026a98:	ea000902 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SHL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHL_BYTE);
10026a9c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026aa0:	e5d33001 	ldrb	r3, [r3, #1]
10026aa4:	e3530001 	cmp	r3, #1
10026aa8:	1a00000c 	bne	10026ae0 <finsh_compile+0x1304>
10026aac:	e3033594 	movw	r3, #13716	; 0x3594
10026ab0:	e3413004 	movt	r3, #4100	; 0x1004
10026ab4:	e5933000 	ldr	r3, [r3]
10026ab8:	e3a0201c 	mov	r2, #28
10026abc:	e5c32000 	strb	r2, [r3]
10026ac0:	e3033594 	movw	r3, #13716	; 0x3594
10026ac4:	e3413004 	movt	r3, #4100	; 0x1004
10026ac8:	e5933000 	ldr	r3, [r3]
10026acc:	e2832001 	add	r2, r3, #1
10026ad0:	e3033594 	movw	r3, #13716	; 0x3594
10026ad4:	e3413004 	movt	r3, #4100	; 0x1004
10026ad8:	e5832000 	str	r2, [r3]
10026adc:	ea000021 	b	10026b68 <finsh_compile+0x138c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHL_WORD);
10026ae0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026ae4:	e5d33001 	ldrb	r3, [r3, #1]
10026ae8:	e3530002 	cmp	r3, #2
10026aec:	1a00000c 	bne	10026b24 <finsh_compile+0x1348>
10026af0:	e3033594 	movw	r3, #13716	; 0x3594
10026af4:	e3413004 	movt	r3, #4100	; 0x1004
10026af8:	e5933000 	ldr	r3, [r3]
10026afc:	e3a0201d 	mov	r2, #29
10026b00:	e5c32000 	strb	r2, [r3]
10026b04:	e3033594 	movw	r3, #13716	; 0x3594
10026b08:	e3413004 	movt	r3, #4100	; 0x1004
10026b0c:	e5933000 	ldr	r3, [r3]
10026b10:	e2832001 	add	r2, r3, #1
10026b14:	e3033594 	movw	r3, #13716	; 0x3594
10026b18:	e3413004 	movt	r3, #4100	; 0x1004
10026b1c:	e5832000 	str	r2, [r3]
10026b20:	ea000010 	b	10026b68 <finsh_compile+0x138c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHL_DWORD);
10026b24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026b28:	e5d33001 	ldrb	r3, [r3, #1]
10026b2c:	e3530003 	cmp	r3, #3
10026b30:	1a00000c 	bne	10026b68 <finsh_compile+0x138c>
10026b34:	e3033594 	movw	r3, #13716	; 0x3594
10026b38:	e3413004 	movt	r3, #4100	; 0x1004
10026b3c:	e5933000 	ldr	r3, [r3]
10026b40:	e3a0201e 	mov	r2, #30
10026b44:	e5c32000 	strb	r2, [r3]
10026b48:	e3033594 	movw	r3, #13716	; 0x3594
10026b4c:	e3413004 	movt	r3, #4100	; 0x1004
10026b50:	e5933000 	ldr	r3, [r3]
10026b54:	e2832001 	add	r2, r3, #1
10026b58:	e3033594 	movw	r3, #13716	; 0x3594
10026b5c:	e3413004 	movt	r3, #4100	; 0x1004
10026b60:	e5832000 	str	r2, [r3]
            break;
10026b64:	ea0008cf 	b	10028ea8 <finsh_compile+0x36cc>
10026b68:	ea0008ce 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SHR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHR_BYTE);
10026b6c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026b70:	e5d33001 	ldrb	r3, [r3, #1]
10026b74:	e3530001 	cmp	r3, #1
10026b78:	1a00000c 	bne	10026bb0 <finsh_compile+0x13d4>
10026b7c:	e3033594 	movw	r3, #13716	; 0x3594
10026b80:	e3413004 	movt	r3, #4100	; 0x1004
10026b84:	e5933000 	ldr	r3, [r3]
10026b88:	e3a0201f 	mov	r2, #31
10026b8c:	e5c32000 	strb	r2, [r3]
10026b90:	e3033594 	movw	r3, #13716	; 0x3594
10026b94:	e3413004 	movt	r3, #4100	; 0x1004
10026b98:	e5933000 	ldr	r3, [r3]
10026b9c:	e2832001 	add	r2, r3, #1
10026ba0:	e3033594 	movw	r3, #13716	; 0x3594
10026ba4:	e3413004 	movt	r3, #4100	; 0x1004
10026ba8:	e5832000 	str	r2, [r3]
10026bac:	ea000021 	b	10026c38 <finsh_compile+0x145c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHR_WORD);
10026bb0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026bb4:	e5d33001 	ldrb	r3, [r3, #1]
10026bb8:	e3530002 	cmp	r3, #2
10026bbc:	1a00000c 	bne	10026bf4 <finsh_compile+0x1418>
10026bc0:	e3033594 	movw	r3, #13716	; 0x3594
10026bc4:	e3413004 	movt	r3, #4100	; 0x1004
10026bc8:	e5933000 	ldr	r3, [r3]
10026bcc:	e3a02020 	mov	r2, #32
10026bd0:	e5c32000 	strb	r2, [r3]
10026bd4:	e3033594 	movw	r3, #13716	; 0x3594
10026bd8:	e3413004 	movt	r3, #4100	; 0x1004
10026bdc:	e5933000 	ldr	r3, [r3]
10026be0:	e2832001 	add	r2, r3, #1
10026be4:	e3033594 	movw	r3, #13716	; 0x3594
10026be8:	e3413004 	movt	r3, #4100	; 0x1004
10026bec:	e5832000 	str	r2, [r3]
10026bf0:	ea000010 	b	10026c38 <finsh_compile+0x145c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHR_DWORD);
10026bf4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026bf8:	e5d33001 	ldrb	r3, [r3, #1]
10026bfc:	e3530003 	cmp	r3, #3
10026c00:	1a00000c 	bne	10026c38 <finsh_compile+0x145c>
10026c04:	e3033594 	movw	r3, #13716	; 0x3594
10026c08:	e3413004 	movt	r3, #4100	; 0x1004
10026c0c:	e5933000 	ldr	r3, [r3]
10026c10:	e3a02021 	mov	r2, #33	; 0x21
10026c14:	e5c32000 	strb	r2, [r3]
10026c18:	e3033594 	movw	r3, #13716	; 0x3594
10026c1c:	e3413004 	movt	r3, #4100	; 0x1004
10026c20:	e5933000 	ldr	r3, [r3]
10026c24:	e2832001 	add	r2, r3, #1
10026c28:	e3033594 	movw	r3, #13716	; 0x3594
10026c2c:	e3413004 	movt	r3, #4100	; 0x1004
10026c30:	e5832000 	str	r2, [r3]
            break;
10026c34:	ea00089b 	b	10028ea8 <finsh_compile+0x36cc>
10026c38:	ea00089a 	b	10028ea8 <finsh_compile+0x36cc>
        case FINSH_NODE_SYS_FUNC:
            {
                int parameters;
                struct finsh_node* sibling;

                parameters = 0;
10026c3c:	e3a03000 	mov	r3, #0
10026c40:	e50b3008 	str	r3, [fp, #-8]
                if (finsh_node_child(node) != NULL)
10026c44:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026c48:	e5933010 	ldr	r3, [r3, #16]
10026c4c:	e3530000 	cmp	r3, #0
10026c50:	0a000027 	beq	10026cf4 <finsh_compile+0x1518>
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
10026c54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026c58:	e5933010 	ldr	r3, [r3, #16]
10026c5c:	e593300c 	ldr	r3, [r3, #12]
10026c60:	e50b300c 	str	r3, [fp, #-12]
                    while (sibling != NULL)
10026c64:	ea000005 	b	10026c80 <finsh_compile+0x14a4>
                    {
                        parameters ++;
10026c68:	e51b3008 	ldr	r3, [fp, #-8]
10026c6c:	e2833001 	add	r3, r3, #1
10026c70:	e50b3008 	str	r3, [fp, #-8]
                        sibling = finsh_node_sibling(sibling);
10026c74:	e51b300c 	ldr	r3, [fp, #-12]
10026c78:	e593300c 	ldr	r3, [r3, #12]
10026c7c:	e50b300c 	str	r3, [fp, #-12]

                parameters = 0;
                if (finsh_node_child(node) != NULL)
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
                    while (sibling != NULL)
10026c80:	e51b300c 	ldr	r3, [fp, #-12]
10026c84:	e3530000 	cmp	r3, #0
10026c88:	1afffff6 	bne	10026c68 <finsh_compile+0x148c>

                    /* load address of function */
                    // finsh_code_dword((long)&(node->var->value.ptr));

                    /* syscall parameters */
                    finsh_code_byte(FINSH_OP_SYSCALL);
10026c8c:	e3033594 	movw	r3, #13716	; 0x3594
10026c90:	e3413004 	movt	r3, #4100	; 0x1004
10026c94:	e5933000 	ldr	r3, [r3]
10026c98:	e3a0202c 	mov	r2, #44	; 0x2c
10026c9c:	e5c32000 	strb	r2, [r3]
10026ca0:	e3033594 	movw	r3, #13716	; 0x3594
10026ca4:	e3413004 	movt	r3, #4100	; 0x1004
10026ca8:	e5933000 	ldr	r3, [r3]
10026cac:	e2832001 	add	r2, r3, #1
10026cb0:	e3033594 	movw	r3, #13716	; 0x3594
10026cb4:	e3413004 	movt	r3, #4100	; 0x1004
10026cb8:	e5832000 	str	r2, [r3]
                    finsh_code_byte(parameters);
10026cbc:	e3033594 	movw	r3, #13716	; 0x3594
10026cc0:	e3413004 	movt	r3, #4100	; 0x1004
10026cc4:	e5933000 	ldr	r3, [r3]
10026cc8:	e51b2008 	ldr	r2, [fp, #-8]
10026ccc:	e6ef2072 	uxtb	r2, r2
10026cd0:	e5c32000 	strb	r2, [r3]
10026cd4:	e3033594 	movw	r3, #13716	; 0x3594
10026cd8:	e3413004 	movt	r3, #4100	; 0x1004
10026cdc:	e5933000 	ldr	r3, [r3]
10026ce0:	e2832001 	add	r2, r3, #1
10026ce4:	e3033594 	movw	r3, #13716	; 0x3594
10026ce8:	e3413004 	movt	r3, #4100	; 0x1004
10026cec:	e5832000 	str	r2, [r3]
                }
            }
            break;
10026cf0:	ea00086c 	b	10028ea8 <finsh_compile+0x36cc>
10026cf4:	ea00086b 	b	10028ea8 <finsh_compile+0x36cc>

        /* assign expression */
        case FINSH_NODE_SYS_ASSIGN:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
10026cf8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026cfc:	e5933010 	ldr	r3, [r3, #16]
10026d00:	e3530000 	cmp	r3, #0
10026d04:	0a00005c 	beq	10026e7c <finsh_compile+0x16a0>
10026d08:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026d0c:	e5933010 	ldr	r3, [r3, #16]
10026d10:	e5d33000 	ldrb	r3, [r3]
10026d14:	e3530001 	cmp	r3, #1
10026d18:	1a000057 	bne	10026e7c <finsh_compile+0x16a0>
            {
                switch (finsh_node_child(node)->data_type)
10026d1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026d20:	e5933010 	ldr	r3, [r3, #16]
10026d24:	e5d33001 	ldrb	r3, [r3, #1]
10026d28:	e3530002 	cmp	r3, #2
10026d2c:	0a00001c 	beq	10026da4 <finsh_compile+0x15c8>
10026d30:	e3530003 	cmp	r3, #3
10026d34:	0a000033 	beq	10026e08 <finsh_compile+0x162c>
10026d38:	e3530001 	cmp	r3, #1
10026d3c:	1a00004a 	bne	10026e6c <finsh_compile+0x1690>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
10026d40:	e3033594 	movw	r3, #13716	; 0x3594
10026d44:	e3413004 	movt	r3, #4100	; 0x1004
10026d48:	e5933000 	ldr	r3, [r3]
10026d4c:	e3a02028 	mov	r2, #40	; 0x28
10026d50:	e5c32000 	strb	r2, [r3]
10026d54:	e3033594 	movw	r3, #13716	; 0x3594
10026d58:	e3413004 	movt	r3, #4100	; 0x1004
10026d5c:	e5933000 	ldr	r3, [r3]
10026d60:	e2832001 	add	r2, r3, #1
10026d64:	e3033594 	movw	r3, #13716	; 0x3594
10026d68:	e3413004 	movt	r3, #4100	; 0x1004
10026d6c:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
10026d70:	e3033594 	movw	r3, #13716	; 0x3594
10026d74:	e3413004 	movt	r3, #4100	; 0x1004
10026d78:	e5933000 	ldr	r3, [r3]
10026d7c:	e3a0202d 	mov	r2, #45	; 0x2d
10026d80:	e5c32000 	strb	r2, [r3]
10026d84:	e3033594 	movw	r3, #13716	; 0x3594
10026d88:	e3413004 	movt	r3, #4100	; 0x1004
10026d8c:	e5933000 	ldr	r3, [r3]
10026d90:	e2832001 	add	r2, r3, #1
10026d94:	e3033594 	movw	r3, #13716	; 0x3594
10026d98:	e3413004 	movt	r3, #4100	; 0x1004
10026d9c:	e5832000 	str	r2, [r3]
                    break;
10026da0:	ea000034 	b	10026e78 <finsh_compile+0x169c>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
10026da4:	e3033594 	movw	r3, #13716	; 0x3594
10026da8:	e3413004 	movt	r3, #4100	; 0x1004
10026dac:	e5933000 	ldr	r3, [r3]
10026db0:	e3a02029 	mov	r2, #41	; 0x29
10026db4:	e5c32000 	strb	r2, [r3]
10026db8:	e3033594 	movw	r3, #13716	; 0x3594
10026dbc:	e3413004 	movt	r3, #4100	; 0x1004
10026dc0:	e5933000 	ldr	r3, [r3]
10026dc4:	e2832001 	add	r2, r3, #1
10026dc8:	e3033594 	movw	r3, #13716	; 0x3594
10026dcc:	e3413004 	movt	r3, #4100	; 0x1004
10026dd0:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
10026dd4:	e3033594 	movw	r3, #13716	; 0x3594
10026dd8:	e3413004 	movt	r3, #4100	; 0x1004
10026ddc:	e5933000 	ldr	r3, [r3]
10026de0:	e3a0202e 	mov	r2, #46	; 0x2e
10026de4:	e5c32000 	strb	r2, [r3]
10026de8:	e3033594 	movw	r3, #13716	; 0x3594
10026dec:	e3413004 	movt	r3, #4100	; 0x1004
10026df0:	e5933000 	ldr	r3, [r3]
10026df4:	e2832001 	add	r2, r3, #1
10026df8:	e3033594 	movw	r3, #13716	; 0x3594
10026dfc:	e3413004 	movt	r3, #4100	; 0x1004
10026e00:	e5832000 	str	r2, [r3]
                    break;
10026e04:	ea00001b 	b	10026e78 <finsh_compile+0x169c>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10026e08:	e3033594 	movw	r3, #13716	; 0x3594
10026e0c:	e3413004 	movt	r3, #4100	; 0x1004
10026e10:	e5933000 	ldr	r3, [r3]
10026e14:	e3a0202a 	mov	r2, #42	; 0x2a
10026e18:	e5c32000 	strb	r2, [r3]
10026e1c:	e3033594 	movw	r3, #13716	; 0x3594
10026e20:	e3413004 	movt	r3, #4100	; 0x1004
10026e24:	e5933000 	ldr	r3, [r3]
10026e28:	e2832001 	add	r2, r3, #1
10026e2c:	e3033594 	movw	r3, #13716	; 0x3594
10026e30:	e3413004 	movt	r3, #4100	; 0x1004
10026e34:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10026e38:	e3033594 	movw	r3, #13716	; 0x3594
10026e3c:	e3413004 	movt	r3, #4100	; 0x1004
10026e40:	e5933000 	ldr	r3, [r3]
10026e44:	e3a0202f 	mov	r2, #47	; 0x2f
10026e48:	e5c32000 	strb	r2, [r3]
10026e4c:	e3033594 	movw	r3, #13716	; 0x3594
10026e50:	e3413004 	movt	r3, #4100	; 0x1004
10026e54:	e5933000 	ldr	r3, [r3]
10026e58:	e2832001 	add	r2, r3, #1
10026e5c:	e3033594 	movw	r3, #13716	; 0x3594
10026e60:	e3413004 	movt	r3, #4100	; 0x1004
10026e64:	e5832000 	str	r2, [r3]
                    break;
10026e68:	ea000002 	b	10026e78 <finsh_compile+0x169c>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
10026e6c:	e3a00003 	mov	r0, #3
10026e70:	eb00093f 	bl	10029374 <finsh_error_set>
                }
            }
10026e74:	ea00005d 	b	10026ff0 <finsh_compile+0x1814>
10026e78:	ea00005c 	b	10026ff0 <finsh_compile+0x1814>
            else if (finsh_node_child(node)->node_type == FINSH_NODE_SYS_GETVALUE)
10026e7c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026e80:	e5933010 	ldr	r3, [r3, #16]
10026e84:	e5d33000 	ldrb	r3, [r3]
10026e88:	e3530019 	cmp	r3, #25
10026e8c:	1a000057 	bne	10026ff0 <finsh_compile+0x1814>
            {
                switch ((finsh_node_child(node)->data_type) & 0x0F)
10026e90:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026e94:	e5933010 	ldr	r3, [r3, #16]
10026e98:	e5d33001 	ldrb	r3, [r3, #1]
10026e9c:	e203300f 	and	r3, r3, #15
10026ea0:	e3530002 	cmp	r3, #2
10026ea4:	0a00001c 	beq	10026f1c <finsh_compile+0x1740>
10026ea8:	e3530003 	cmp	r3, #3
10026eac:	0a000033 	beq	10026f80 <finsh_compile+0x17a4>
10026eb0:	e3530001 	cmp	r3, #1
10026eb4:	1a00004a 	bne	10026fe4 <finsh_compile+0x1808>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
10026eb8:	e3033594 	movw	r3, #13716	; 0x3594
10026ebc:	e3413004 	movt	r3, #4100	; 0x1004
10026ec0:	e5933000 	ldr	r3, [r3]
10026ec4:	e3a02028 	mov	r2, #40	; 0x28
10026ec8:	e5c32000 	strb	r2, [r3]
10026ecc:	e3033594 	movw	r3, #13716	; 0x3594
10026ed0:	e3413004 	movt	r3, #4100	; 0x1004
10026ed4:	e5933000 	ldr	r3, [r3]
10026ed8:	e2832001 	add	r2, r3, #1
10026edc:	e3033594 	movw	r3, #13716	; 0x3594
10026ee0:	e3413004 	movt	r3, #4100	; 0x1004
10026ee4:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
10026ee8:	e3033594 	movw	r3, #13716	; 0x3594
10026eec:	e3413004 	movt	r3, #4100	; 0x1004
10026ef0:	e5933000 	ldr	r3, [r3]
10026ef4:	e3a0202d 	mov	r2, #45	; 0x2d
10026ef8:	e5c32000 	strb	r2, [r3]
10026efc:	e3033594 	movw	r3, #13716	; 0x3594
10026f00:	e3413004 	movt	r3, #4100	; 0x1004
10026f04:	e5933000 	ldr	r3, [r3]
10026f08:	e2832001 	add	r2, r3, #1
10026f0c:	e3033594 	movw	r3, #13716	; 0x3594
10026f10:	e3413004 	movt	r3, #4100	; 0x1004
10026f14:	e5832000 	str	r2, [r3]
                    break;
10026f18:	ea000034 	b	10026ff0 <finsh_compile+0x1814>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
10026f1c:	e3033594 	movw	r3, #13716	; 0x3594
10026f20:	e3413004 	movt	r3, #4100	; 0x1004
10026f24:	e5933000 	ldr	r3, [r3]
10026f28:	e3a02029 	mov	r2, #41	; 0x29
10026f2c:	e5c32000 	strb	r2, [r3]
10026f30:	e3033594 	movw	r3, #13716	; 0x3594
10026f34:	e3413004 	movt	r3, #4100	; 0x1004
10026f38:	e5933000 	ldr	r3, [r3]
10026f3c:	e2832001 	add	r2, r3, #1
10026f40:	e3033594 	movw	r3, #13716	; 0x3594
10026f44:	e3413004 	movt	r3, #4100	; 0x1004
10026f48:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
10026f4c:	e3033594 	movw	r3, #13716	; 0x3594
10026f50:	e3413004 	movt	r3, #4100	; 0x1004
10026f54:	e5933000 	ldr	r3, [r3]
10026f58:	e3a0202e 	mov	r2, #46	; 0x2e
10026f5c:	e5c32000 	strb	r2, [r3]
10026f60:	e3033594 	movw	r3, #13716	; 0x3594
10026f64:	e3413004 	movt	r3, #4100	; 0x1004
10026f68:	e5933000 	ldr	r3, [r3]
10026f6c:	e2832001 	add	r2, r3, #1
10026f70:	e3033594 	movw	r3, #13716	; 0x3594
10026f74:	e3413004 	movt	r3, #4100	; 0x1004
10026f78:	e5832000 	str	r2, [r3]
                    break;
10026f7c:	ea00001b 	b	10026ff0 <finsh_compile+0x1814>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10026f80:	e3033594 	movw	r3, #13716	; 0x3594
10026f84:	e3413004 	movt	r3, #4100	; 0x1004
10026f88:	e5933000 	ldr	r3, [r3]
10026f8c:	e3a0202a 	mov	r2, #42	; 0x2a
10026f90:	e5c32000 	strb	r2, [r3]
10026f94:	e3033594 	movw	r3, #13716	; 0x3594
10026f98:	e3413004 	movt	r3, #4100	; 0x1004
10026f9c:	e5933000 	ldr	r3, [r3]
10026fa0:	e2832001 	add	r2, r3, #1
10026fa4:	e3033594 	movw	r3, #13716	; 0x3594
10026fa8:	e3413004 	movt	r3, #4100	; 0x1004
10026fac:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10026fb0:	e3033594 	movw	r3, #13716	; 0x3594
10026fb4:	e3413004 	movt	r3, #4100	; 0x1004
10026fb8:	e5933000 	ldr	r3, [r3]
10026fbc:	e3a0202f 	mov	r2, #47	; 0x2f
10026fc0:	e5c32000 	strb	r2, [r3]
10026fc4:	e3033594 	movw	r3, #13716	; 0x3594
10026fc8:	e3413004 	movt	r3, #4100	; 0x1004
10026fcc:	e5933000 	ldr	r3, [r3]
10026fd0:	e2832001 	add	r2, r3, #1
10026fd4:	e3033594 	movw	r3, #13716	; 0x3594
10026fd8:	e3413004 	movt	r3, #4100	; 0x1004
10026fdc:	e5832000 	str	r2, [r3]
                    break;
10026fe0:	ea000002 	b	10026ff0 <finsh_compile+0x1814>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
10026fe4:	e3a00003 	mov	r0, #3
10026fe8:	eb0008e1 	bl	10029374 <finsh_error_set>
                }
            }
            break;
10026fec:	ea0007ad 	b	10028ea8 <finsh_compile+0x36cc>
10026ff0:	ea0007ac 	b	10028ea8 <finsh_compile+0x36cc>

        /* pre-increase */
        case FINSH_NODE_SYS_PREINC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
10026ff4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10026ff8:	e5933010 	ldr	r3, [r3, #16]
10026ffc:	e3530000 	cmp	r3, #0
10027000:	0a00017f 	beq	10027604 <finsh_compile+0x1e28>
10027004:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10027008:	e5933010 	ldr	r3, [r3, #16]
1002700c:	e5d33000 	ldrb	r3, [r3]
10027010:	e3530001 	cmp	r3, #1
10027014:	1a00017a 	bne	10027604 <finsh_compile+0x1e28>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
10027018:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002701c:	e5933010 	ldr	r3, [r3, #16]
10027020:	e5933008 	ldr	r3, [r3, #8]
10027024:	e50b3018 	str	r3, [fp, #-24]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
10027028:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002702c:	e5d33001 	ldrb	r3, [r3, #1]
10027030:	e3530002 	cmp	r3, #2
10027034:	0a000076 	beq	10027214 <finsh_compile+0x1a38>
10027038:	e3530003 	cmp	r3, #3
1002703c:	0a0000ec 	beq	100273f4 <finsh_compile+0x1c18>
10027040:	e3530001 	cmp	r3, #1
10027044:	0a000000 	beq	1002704c <finsh_compile+0x1870>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
10027048:	ea000796 	b	10028ea8 <finsh_compile+0x36cc>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
1002704c:	e3033594 	movw	r3, #13716	; 0x3594
10027050:	e3413004 	movt	r3, #4100	; 0x1004
10027054:	e5933000 	ldr	r3, [r3]
10027058:	e3a02025 	mov	r2, #37	; 0x25
1002705c:	e5c32000 	strb	r2, [r3]
10027060:	e3033594 	movw	r3, #13716	; 0x3594
10027064:	e3413004 	movt	r3, #4100	; 0x1004
10027068:	e5933000 	ldr	r3, [r3]
1002706c:	e2832001 	add	r2, r3, #1
10027070:	e3033594 	movw	r3, #13716	; 0x3594
10027074:	e3413004 	movt	r3, #4100	; 0x1004
10027078:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
1002707c:	e3033594 	movw	r3, #13716	; 0x3594
10027080:	e3413004 	movt	r3, #4100	; 0x1004
10027084:	e5933000 	ldr	r3, [r3]
10027088:	e51b2018 	ldr	r2, [fp, #-24]
1002708c:	e2822014 	add	r2, r2, #20
10027090:	e6ef2072 	uxtb	r2, r2
10027094:	e5c32000 	strb	r2, [r3]
10027098:	e3033594 	movw	r3, #13716	; 0x3594
1002709c:	e3413004 	movt	r3, #4100	; 0x1004
100270a0:	e5933000 	ldr	r3, [r3]
100270a4:	e2833001 	add	r3, r3, #1
100270a8:	e51b2018 	ldr	r2, [fp, #-24]
100270ac:	e2822014 	add	r2, r2, #20
100270b0:	e1a02422 	lsr	r2, r2, #8
100270b4:	e6ef2072 	uxtb	r2, r2
100270b8:	e5c32000 	strb	r2, [r3]
100270bc:	e3033594 	movw	r3, #13716	; 0x3594
100270c0:	e3413004 	movt	r3, #4100	; 0x1004
100270c4:	e5933000 	ldr	r3, [r3]
100270c8:	e2833002 	add	r3, r3, #2
100270cc:	e51b2018 	ldr	r2, [fp, #-24]
100270d0:	e2822014 	add	r2, r2, #20
100270d4:	e1a02822 	lsr	r2, r2, #16
100270d8:	e6ef2072 	uxtb	r2, r2
100270dc:	e5c32000 	strb	r2, [r3]
100270e0:	e3033594 	movw	r3, #13716	; 0x3594
100270e4:	e3413004 	movt	r3, #4100	; 0x1004
100270e8:	e5933000 	ldr	r3, [r3]
100270ec:	e2833003 	add	r3, r3, #3
100270f0:	e51b2018 	ldr	r2, [fp, #-24]
100270f4:	e2822014 	add	r2, r2, #20
100270f8:	e1a02c22 	lsr	r2, r2, #24
100270fc:	e6ef2072 	uxtb	r2, r2
10027100:	e5c32000 	strb	r2, [r3]
10027104:	e3033594 	movw	r3, #13716	; 0x3594
10027108:	e3413004 	movt	r3, #4100	; 0x1004
1002710c:	e5933000 	ldr	r3, [r3]
10027110:	e2832004 	add	r2, r3, #4
10027114:	e3033594 	movw	r3, #13716	; 0x3594
10027118:	e3413004 	movt	r3, #4100	; 0x1004
1002711c:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
10027120:	e3033594 	movw	r3, #13716	; 0x3594
10027124:	e3413004 	movt	r3, #4100	; 0x1004
10027128:	e5933000 	ldr	r3, [r3]
1002712c:	e3a02022 	mov	r2, #34	; 0x22
10027130:	e5c32000 	strb	r2, [r3]
10027134:	e3033594 	movw	r3, #13716	; 0x3594
10027138:	e3413004 	movt	r3, #4100	; 0x1004
1002713c:	e5933000 	ldr	r3, [r3]
10027140:	e2832001 	add	r2, r3, #1
10027144:	e3033594 	movw	r3, #13716	; 0x3594
10027148:	e3413004 	movt	r3, #4100	; 0x1004
1002714c:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
10027150:	e3033594 	movw	r3, #13716	; 0x3594
10027154:	e3413004 	movt	r3, #4100	; 0x1004
10027158:	e5933000 	ldr	r3, [r3]
1002715c:	e3a02001 	mov	r2, #1
10027160:	e5c32000 	strb	r2, [r3]
10027164:	e3033594 	movw	r3, #13716	; 0x3594
10027168:	e3413004 	movt	r3, #4100	; 0x1004
1002716c:	e5933000 	ldr	r3, [r3]
10027170:	e2832001 	add	r2, r3, #1
10027174:	e3033594 	movw	r3, #13716	; 0x3594
10027178:	e3413004 	movt	r3, #4100	; 0x1004
1002717c:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
10027180:	e3033594 	movw	r3, #13716	; 0x3594
10027184:	e3413004 	movt	r3, #4100	; 0x1004
10027188:	e5933000 	ldr	r3, [r3]
1002718c:	e3a02001 	mov	r2, #1
10027190:	e5c32000 	strb	r2, [r3]
10027194:	e3033594 	movw	r3, #13716	; 0x3594
10027198:	e3413004 	movt	r3, #4100	; 0x1004
1002719c:	e5933000 	ldr	r3, [r3]
100271a0:	e2832001 	add	r2, r3, #1
100271a4:	e3033594 	movw	r3, #13716	; 0x3594
100271a8:	e3413004 	movt	r3, #4100	; 0x1004
100271ac:	e5832000 	str	r2, [r3]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
100271b0:	e3033594 	movw	r3, #13716	; 0x3594
100271b4:	e3413004 	movt	r3, #4100	; 0x1004
100271b8:	e5933000 	ldr	r3, [r3]
100271bc:	e3a02028 	mov	r2, #40	; 0x28
100271c0:	e5c32000 	strb	r2, [r3]
100271c4:	e3033594 	movw	r3, #13716	; 0x3594
100271c8:	e3413004 	movt	r3, #4100	; 0x1004
100271cc:	e5933000 	ldr	r3, [r3]
100271d0:	e2832001 	add	r2, r3, #1
100271d4:	e3033594 	movw	r3, #13716	; 0x3594
100271d8:	e3413004 	movt	r3, #4100	; 0x1004
100271dc:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
100271e0:	e3033594 	movw	r3, #13716	; 0x3594
100271e4:	e3413004 	movt	r3, #4100	; 0x1004
100271e8:	e5933000 	ldr	r3, [r3]
100271ec:	e3a0202f 	mov	r2, #47	; 0x2f
100271f0:	e5c32000 	strb	r2, [r3]
100271f4:	e3033594 	movw	r3, #13716	; 0x3594
100271f8:	e3413004 	movt	r3, #4100	; 0x1004
100271fc:	e5933000 	ldr	r3, [r3]
10027200:	e2832001 	add	r2, r3, #1
10027204:	e3033594 	movw	r3, #13716	; 0x3594
10027208:	e3413004 	movt	r3, #4100	; 0x1004
1002720c:	e5832000 	str	r2, [r3]

                    break;
10027210:	ea0000fb 	b	10027604 <finsh_compile+0x1e28>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10027214:	e3033594 	movw	r3, #13716	; 0x3594
10027218:	e3413004 	movt	r3, #4100	; 0x1004
1002721c:	e5933000 	ldr	r3, [r3]
10027220:	e3a02026 	mov	r2, #38	; 0x26
10027224:	e5c32000 	strb	r2, [r3]
10027228:	e3033594 	movw	r3, #13716	; 0x3594
1002722c:	e3413004 	movt	r3, #4100	; 0x1004
10027230:	e5933000 	ldr	r3, [r3]
10027234:	e2832001 	add	r2, r3, #1
10027238:	e3033594 	movw	r3, #13716	; 0x3594
1002723c:	e3413004 	movt	r3, #4100	; 0x1004
10027240:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10027244:	e3033594 	movw	r3, #13716	; 0x3594
10027248:	e3413004 	movt	r3, #4100	; 0x1004
1002724c:	e5933000 	ldr	r3, [r3]
10027250:	e51b2018 	ldr	r2, [fp, #-24]
10027254:	e2822014 	add	r2, r2, #20
10027258:	e6ef2072 	uxtb	r2, r2
1002725c:	e5c32000 	strb	r2, [r3]
10027260:	e3033594 	movw	r3, #13716	; 0x3594
10027264:	e3413004 	movt	r3, #4100	; 0x1004
10027268:	e5933000 	ldr	r3, [r3]
1002726c:	e2833001 	add	r3, r3, #1
10027270:	e51b2018 	ldr	r2, [fp, #-24]
10027274:	e2822014 	add	r2, r2, #20
10027278:	e1a02422 	lsr	r2, r2, #8
1002727c:	e6ef2072 	uxtb	r2, r2
10027280:	e5c32000 	strb	r2, [r3]
10027284:	e3033594 	movw	r3, #13716	; 0x3594
10027288:	e3413004 	movt	r3, #4100	; 0x1004
1002728c:	e5933000 	ldr	r3, [r3]
10027290:	e2833002 	add	r3, r3, #2
10027294:	e51b2018 	ldr	r2, [fp, #-24]
10027298:	e2822014 	add	r2, r2, #20
1002729c:	e1a02822 	lsr	r2, r2, #16
100272a0:	e6ef2072 	uxtb	r2, r2
100272a4:	e5c32000 	strb	r2, [r3]
100272a8:	e3033594 	movw	r3, #13716	; 0x3594
100272ac:	e3413004 	movt	r3, #4100	; 0x1004
100272b0:	e5933000 	ldr	r3, [r3]
100272b4:	e2833003 	add	r3, r3, #3
100272b8:	e51b2018 	ldr	r2, [fp, #-24]
100272bc:	e2822014 	add	r2, r2, #20
100272c0:	e1a02c22 	lsr	r2, r2, #24
100272c4:	e6ef2072 	uxtb	r2, r2
100272c8:	e5c32000 	strb	r2, [r3]
100272cc:	e3033594 	movw	r3, #13716	; 0x3594
100272d0:	e3413004 	movt	r3, #4100	; 0x1004
100272d4:	e5933000 	ldr	r3, [r3]
100272d8:	e2832004 	add	r2, r3, #4
100272dc:	e3033594 	movw	r3, #13716	; 0x3594
100272e0:	e3413004 	movt	r3, #4100	; 0x1004
100272e4:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
100272e8:	e3033594 	movw	r3, #13716	; 0x3594
100272ec:	e3413004 	movt	r3, #4100	; 0x1004
100272f0:	e5933000 	ldr	r3, [r3]
100272f4:	e3a02023 	mov	r2, #35	; 0x23
100272f8:	e5c32000 	strb	r2, [r3]
100272fc:	e3033594 	movw	r3, #13716	; 0x3594
10027300:	e3413004 	movt	r3, #4100	; 0x1004
10027304:	e5933000 	ldr	r3, [r3]
10027308:	e2832001 	add	r2, r3, #1
1002730c:	e3033594 	movw	r3, #13716	; 0x3594
10027310:	e3413004 	movt	r3, #4100	; 0x1004
10027314:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
10027318:	e3033594 	movw	r3, #13716	; 0x3594
1002731c:	e3413004 	movt	r3, #4100	; 0x1004
10027320:	e5933000 	ldr	r3, [r3]
10027324:	e3a02001 	mov	r2, #1
10027328:	e5c32000 	strb	r2, [r3]
1002732c:	e3033594 	movw	r3, #13716	; 0x3594
10027330:	e3413004 	movt	r3, #4100	; 0x1004
10027334:	e5933000 	ldr	r3, [r3]
10027338:	e2833001 	add	r3, r3, #1
1002733c:	e3a02000 	mov	r2, #0
10027340:	e5c32000 	strb	r2, [r3]
10027344:	e3033594 	movw	r3, #13716	; 0x3594
10027348:	e3413004 	movt	r3, #4100	; 0x1004
1002734c:	e5933000 	ldr	r3, [r3]
10027350:	e2832002 	add	r2, r3, #2
10027354:	e3033594 	movw	r3, #13716	; 0x3594
10027358:	e3413004 	movt	r3, #4100	; 0x1004
1002735c:	e5832000 	str	r2, [r3]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
10027360:	e3033594 	movw	r3, #13716	; 0x3594
10027364:	e3413004 	movt	r3, #4100	; 0x1004
10027368:	e5933000 	ldr	r3, [r3]
1002736c:	e3a02002 	mov	r2, #2
10027370:	e5c32000 	strb	r2, [r3]
10027374:	e3033594 	movw	r3, #13716	; 0x3594
10027378:	e3413004 	movt	r3, #4100	; 0x1004
1002737c:	e5933000 	ldr	r3, [r3]
10027380:	e2832001 	add	r2, r3, #1
10027384:	e3033594 	movw	r3, #13716	; 0x3594
10027388:	e3413004 	movt	r3, #4100	; 0x1004
1002738c:	e5832000 	str	r2, [r3]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
10027390:	e3033594 	movw	r3, #13716	; 0x3594
10027394:	e3413004 	movt	r3, #4100	; 0x1004
10027398:	e5933000 	ldr	r3, [r3]
1002739c:	e3a02029 	mov	r2, #41	; 0x29
100273a0:	e5c32000 	strb	r2, [r3]
100273a4:	e3033594 	movw	r3, #13716	; 0x3594
100273a8:	e3413004 	movt	r3, #4100	; 0x1004
100273ac:	e5933000 	ldr	r3, [r3]
100273b0:	e2832001 	add	r2, r3, #1
100273b4:	e3033594 	movw	r3, #13716	; 0x3594
100273b8:	e3413004 	movt	r3, #4100	; 0x1004
100273bc:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
100273c0:	e3033594 	movw	r3, #13716	; 0x3594
100273c4:	e3413004 	movt	r3, #4100	; 0x1004
100273c8:	e5933000 	ldr	r3, [r3]
100273cc:	e3a0202f 	mov	r2, #47	; 0x2f
100273d0:	e5c32000 	strb	r2, [r3]
100273d4:	e3033594 	movw	r3, #13716	; 0x3594
100273d8:	e3413004 	movt	r3, #4100	; 0x1004
100273dc:	e5933000 	ldr	r3, [r3]
100273e0:	e2832001 	add	r2, r3, #1
100273e4:	e3033594 	movw	r3, #13716	; 0x3594
100273e8:	e3413004 	movt	r3, #4100	; 0x1004
100273ec:	e5832000 	str	r2, [r3]

                    break;
100273f0:	ea000083 	b	10027604 <finsh_compile+0x1e28>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
100273f4:	e3033594 	movw	r3, #13716	; 0x3594
100273f8:	e3413004 	movt	r3, #4100	; 0x1004
100273fc:	e5933000 	ldr	r3, [r3]
10027400:	e3a02027 	mov	r2, #39	; 0x27
10027404:	e5c32000 	strb	r2, [r3]
10027408:	e3033594 	movw	r3, #13716	; 0x3594
1002740c:	e3413004 	movt	r3, #4100	; 0x1004
10027410:	e5933000 	ldr	r3, [r3]
10027414:	e2832001 	add	r2, r3, #1
10027418:	e3033594 	movw	r3, #13716	; 0x3594
1002741c:	e3413004 	movt	r3, #4100	; 0x1004
10027420:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10027424:	e3033594 	movw	r3, #13716	; 0x3594
10027428:	e3413004 	movt	r3, #4100	; 0x1004
1002742c:	e5933000 	ldr	r3, [r3]
10027430:	e51b2018 	ldr	r2, [fp, #-24]
10027434:	e2822014 	add	r2, r2, #20
10027438:	e6ef2072 	uxtb	r2, r2
1002743c:	e5c32000 	strb	r2, [r3]
10027440:	e3033594 	movw	r3, #13716	; 0x3594
10027444:	e3413004 	movt	r3, #4100	; 0x1004
10027448:	e5933000 	ldr	r3, [r3]
1002744c:	e2833001 	add	r3, r3, #1
10027450:	e51b2018 	ldr	r2, [fp, #-24]
10027454:	e2822014 	add	r2, r2, #20
10027458:	e1a02422 	lsr	r2, r2, #8
1002745c:	e6ef2072 	uxtb	r2, r2
10027460:	e5c32000 	strb	r2, [r3]
10027464:	e3033594 	movw	r3, #13716	; 0x3594
10027468:	e3413004 	movt	r3, #4100	; 0x1004
1002746c:	e5933000 	ldr	r3, [r3]
10027470:	e2833002 	add	r3, r3, #2
10027474:	e51b2018 	ldr	r2, [fp, #-24]
10027478:	e2822014 	add	r2, r2, #20
1002747c:	e1a02822 	lsr	r2, r2, #16
10027480:	e6ef2072 	uxtb	r2, r2
10027484:	e5c32000 	strb	r2, [r3]
10027488:	e3033594 	movw	r3, #13716	; 0x3594
1002748c:	e3413004 	movt	r3, #4100	; 0x1004
10027490:	e5933000 	ldr	r3, [r3]
10027494:	e2833003 	add	r3, r3, #3
10027498:	e51b2018 	ldr	r2, [fp, #-24]
1002749c:	e2822014 	add	r2, r2, #20
100274a0:	e1a02c22 	lsr	r2, r2, #24
100274a4:	e6ef2072 	uxtb	r2, r2
100274a8:	e5c32000 	strb	r2, [r3]
100274ac:	e3033594 	movw	r3, #13716	; 0x3594
100274b0:	e3413004 	movt	r3, #4100	; 0x1004
100274b4:	e5933000 	ldr	r3, [r3]
100274b8:	e2832004 	add	r2, r3, #4
100274bc:	e3033594 	movw	r3, #13716	; 0x3594
100274c0:	e3413004 	movt	r3, #4100	; 0x1004
100274c4:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
100274c8:	e3033594 	movw	r3, #13716	; 0x3594
100274cc:	e3413004 	movt	r3, #4100	; 0x1004
100274d0:	e5933000 	ldr	r3, [r3]
100274d4:	e3a02024 	mov	r2, #36	; 0x24
100274d8:	e5c32000 	strb	r2, [r3]
100274dc:	e3033594 	movw	r3, #13716	; 0x3594
100274e0:	e3413004 	movt	r3, #4100	; 0x1004
100274e4:	e5933000 	ldr	r3, [r3]
100274e8:	e2832001 	add	r2, r3, #1
100274ec:	e3033594 	movw	r3, #13716	; 0x3594
100274f0:	e3413004 	movt	r3, #4100	; 0x1004
100274f4:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
100274f8:	e3033594 	movw	r3, #13716	; 0x3594
100274fc:	e3413004 	movt	r3, #4100	; 0x1004
10027500:	e5933000 	ldr	r3, [r3]
10027504:	e3a02001 	mov	r2, #1
10027508:	e5c32000 	strb	r2, [r3]
1002750c:	e3033594 	movw	r3, #13716	; 0x3594
10027510:	e3413004 	movt	r3, #4100	; 0x1004
10027514:	e5933000 	ldr	r3, [r3]
10027518:	e2833001 	add	r3, r3, #1
1002751c:	e3a02000 	mov	r2, #0
10027520:	e5c32000 	strb	r2, [r3]
10027524:	e3033594 	movw	r3, #13716	; 0x3594
10027528:	e3413004 	movt	r3, #4100	; 0x1004
1002752c:	e5933000 	ldr	r3, [r3]
10027530:	e2833002 	add	r3, r3, #2
10027534:	e3a02000 	mov	r2, #0
10027538:	e5c32000 	strb	r2, [r3]
1002753c:	e3033594 	movw	r3, #13716	; 0x3594
10027540:	e3413004 	movt	r3, #4100	; 0x1004
10027544:	e5933000 	ldr	r3, [r3]
10027548:	e2833003 	add	r3, r3, #3
1002754c:	e3a02000 	mov	r2, #0
10027550:	e5c32000 	strb	r2, [r3]
10027554:	e3033594 	movw	r3, #13716	; 0x3594
10027558:	e3413004 	movt	r3, #4100	; 0x1004
1002755c:	e5933000 	ldr	r3, [r3]
10027560:	e2832004 	add	r2, r3, #4
10027564:	e3033594 	movw	r3, #13716	; 0x3594
10027568:	e3413004 	movt	r3, #4100	; 0x1004
1002756c:	e5832000 	str	r2, [r3]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
10027570:	e3033594 	movw	r3, #13716	; 0x3594
10027574:	e3413004 	movt	r3, #4100	; 0x1004
10027578:	e5933000 	ldr	r3, [r3]
1002757c:	e3a02003 	mov	r2, #3
10027580:	e5c32000 	strb	r2, [r3]
10027584:	e3033594 	movw	r3, #13716	; 0x3594
10027588:	e3413004 	movt	r3, #4100	; 0x1004
1002758c:	e5933000 	ldr	r3, [r3]
10027590:	e2832001 	add	r2, r3, #1
10027594:	e3033594 	movw	r3, #13716	; 0x3594
10027598:	e3413004 	movt	r3, #4100	; 0x1004
1002759c:	e5832000 	str	r2, [r3]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
100275a0:	e3033594 	movw	r3, #13716	; 0x3594
100275a4:	e3413004 	movt	r3, #4100	; 0x1004
100275a8:	e5933000 	ldr	r3, [r3]
100275ac:	e3a0202a 	mov	r2, #42	; 0x2a
100275b0:	e5c32000 	strb	r2, [r3]
100275b4:	e3033594 	movw	r3, #13716	; 0x3594
100275b8:	e3413004 	movt	r3, #4100	; 0x1004
100275bc:	e5933000 	ldr	r3, [r3]
100275c0:	e2832001 	add	r2, r3, #1
100275c4:	e3033594 	movw	r3, #13716	; 0x3594
100275c8:	e3413004 	movt	r3, #4100	; 0x1004
100275cc:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
100275d0:	e3033594 	movw	r3, #13716	; 0x3594
100275d4:	e3413004 	movt	r3, #4100	; 0x1004
100275d8:	e5933000 	ldr	r3, [r3]
100275dc:	e3a0202f 	mov	r2, #47	; 0x2f
100275e0:	e5c32000 	strb	r2, [r3]
100275e4:	e3033594 	movw	r3, #13716	; 0x3594
100275e8:	e3413004 	movt	r3, #4100	; 0x1004
100275ec:	e5933000 	ldr	r3, [r3]
100275f0:	e2832001 	add	r2, r3, #1
100275f4:	e3033594 	movw	r3, #13716	; 0x3594
100275f8:	e3413004 	movt	r3, #4100	; 0x1004
100275fc:	e5832000 	str	r2, [r3]

                    break;
10027600:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
10027604:	ea000627 	b	10028ea8 <finsh_compile+0x36cc>

        /* pre-decrease */
        case FINSH_NODE_SYS_PREDEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
10027608:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002760c:	e5933010 	ldr	r3, [r3, #16]
10027610:	e3530000 	cmp	r3, #0
10027614:	0a00017f 	beq	10027c18 <finsh_compile+0x243c>
10027618:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002761c:	e5933010 	ldr	r3, [r3, #16]
10027620:	e5d33000 	ldrb	r3, [r3]
10027624:	e3530001 	cmp	r3, #1
10027628:	1a00017a 	bne	10027c18 <finsh_compile+0x243c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
1002762c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10027630:	e5933010 	ldr	r3, [r3, #16]
10027634:	e5933008 	ldr	r3, [r3, #8]
10027638:	e50b301c 	str	r3, [fp, #-28]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
1002763c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10027640:	e5d33001 	ldrb	r3, [r3, #1]
10027644:	e3530002 	cmp	r3, #2
10027648:	0a000076 	beq	10027828 <finsh_compile+0x204c>
1002764c:	e3530003 	cmp	r3, #3
10027650:	0a0000ec 	beq	10027a08 <finsh_compile+0x222c>
10027654:	e3530001 	cmp	r3, #1
10027658:	0a000000 	beq	10027660 <finsh_compile+0x1e84>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
1002765c:	ea000611 	b	10028ea8 <finsh_compile+0x36cc>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10027660:	e3033594 	movw	r3, #13716	; 0x3594
10027664:	e3413004 	movt	r3, #4100	; 0x1004
10027668:	e5933000 	ldr	r3, [r3]
1002766c:	e3a02025 	mov	r2, #37	; 0x25
10027670:	e5c32000 	strb	r2, [r3]
10027674:	e3033594 	movw	r3, #13716	; 0x3594
10027678:	e3413004 	movt	r3, #4100	; 0x1004
1002767c:	e5933000 	ldr	r3, [r3]
10027680:	e2832001 	add	r2, r3, #1
10027684:	e3033594 	movw	r3, #13716	; 0x3594
10027688:	e3413004 	movt	r3, #4100	; 0x1004
1002768c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
10027690:	e3033594 	movw	r3, #13716	; 0x3594
10027694:	e3413004 	movt	r3, #4100	; 0x1004
10027698:	e5933000 	ldr	r3, [r3]
1002769c:	e51b201c 	ldr	r2, [fp, #-28]
100276a0:	e2822014 	add	r2, r2, #20
100276a4:	e6ef2072 	uxtb	r2, r2
100276a8:	e5c32000 	strb	r2, [r3]
100276ac:	e3033594 	movw	r3, #13716	; 0x3594
100276b0:	e3413004 	movt	r3, #4100	; 0x1004
100276b4:	e5933000 	ldr	r3, [r3]
100276b8:	e2833001 	add	r3, r3, #1
100276bc:	e51b201c 	ldr	r2, [fp, #-28]
100276c0:	e2822014 	add	r2, r2, #20
100276c4:	e1a02422 	lsr	r2, r2, #8
100276c8:	e6ef2072 	uxtb	r2, r2
100276cc:	e5c32000 	strb	r2, [r3]
100276d0:	e3033594 	movw	r3, #13716	; 0x3594
100276d4:	e3413004 	movt	r3, #4100	; 0x1004
100276d8:	e5933000 	ldr	r3, [r3]
100276dc:	e2833002 	add	r3, r3, #2
100276e0:	e51b201c 	ldr	r2, [fp, #-28]
100276e4:	e2822014 	add	r2, r2, #20
100276e8:	e1a02822 	lsr	r2, r2, #16
100276ec:	e6ef2072 	uxtb	r2, r2
100276f0:	e5c32000 	strb	r2, [r3]
100276f4:	e3033594 	movw	r3, #13716	; 0x3594
100276f8:	e3413004 	movt	r3, #4100	; 0x1004
100276fc:	e5933000 	ldr	r3, [r3]
10027700:	e2833003 	add	r3, r3, #3
10027704:	e51b201c 	ldr	r2, [fp, #-28]
10027708:	e2822014 	add	r2, r2, #20
1002770c:	e1a02c22 	lsr	r2, r2, #24
10027710:	e6ef2072 	uxtb	r2, r2
10027714:	e5c32000 	strb	r2, [r3]
10027718:	e3033594 	movw	r3, #13716	; 0x3594
1002771c:	e3413004 	movt	r3, #4100	; 0x1004
10027720:	e5933000 	ldr	r3, [r3]
10027724:	e2832004 	add	r2, r3, #4
10027728:	e3033594 	movw	r3, #13716	; 0x3594
1002772c:	e3413004 	movt	r3, #4100	; 0x1004
10027730:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
10027734:	e3033594 	movw	r3, #13716	; 0x3594
10027738:	e3413004 	movt	r3, #4100	; 0x1004
1002773c:	e5933000 	ldr	r3, [r3]
10027740:	e3a02022 	mov	r2, #34	; 0x22
10027744:	e5c32000 	strb	r2, [r3]
10027748:	e3033594 	movw	r3, #13716	; 0x3594
1002774c:	e3413004 	movt	r3, #4100	; 0x1004
10027750:	e5933000 	ldr	r3, [r3]
10027754:	e2832001 	add	r2, r3, #1
10027758:	e3033594 	movw	r3, #13716	; 0x3594
1002775c:	e3413004 	movt	r3, #4100	; 0x1004
10027760:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
10027764:	e3033594 	movw	r3, #13716	; 0x3594
10027768:	e3413004 	movt	r3, #4100	; 0x1004
1002776c:	e5933000 	ldr	r3, [r3]
10027770:	e3a02001 	mov	r2, #1
10027774:	e5c32000 	strb	r2, [r3]
10027778:	e3033594 	movw	r3, #13716	; 0x3594
1002777c:	e3413004 	movt	r3, #4100	; 0x1004
10027780:	e5933000 	ldr	r3, [r3]
10027784:	e2832001 	add	r2, r3, #1
10027788:	e3033594 	movw	r3, #13716	; 0x3594
1002778c:	e3413004 	movt	r3, #4100	; 0x1004
10027790:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
10027794:	e3033594 	movw	r3, #13716	; 0x3594
10027798:	e3413004 	movt	r3, #4100	; 0x1004
1002779c:	e5933000 	ldr	r3, [r3]
100277a0:	e3a02004 	mov	r2, #4
100277a4:	e5c32000 	strb	r2, [r3]
100277a8:	e3033594 	movw	r3, #13716	; 0x3594
100277ac:	e3413004 	movt	r3, #4100	; 0x1004
100277b0:	e5933000 	ldr	r3, [r3]
100277b4:	e2832001 	add	r2, r3, #1
100277b8:	e3033594 	movw	r3, #13716	; 0x3594
100277bc:	e3413004 	movt	r3, #4100	; 0x1004
100277c0:	e5832000 	str	r2, [r3]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
100277c4:	e3033594 	movw	r3, #13716	; 0x3594
100277c8:	e3413004 	movt	r3, #4100	; 0x1004
100277cc:	e5933000 	ldr	r3, [r3]
100277d0:	e3a02028 	mov	r2, #40	; 0x28
100277d4:	e5c32000 	strb	r2, [r3]
100277d8:	e3033594 	movw	r3, #13716	; 0x3594
100277dc:	e3413004 	movt	r3, #4100	; 0x1004
100277e0:	e5933000 	ldr	r3, [r3]
100277e4:	e2832001 	add	r2, r3, #1
100277e8:	e3033594 	movw	r3, #13716	; 0x3594
100277ec:	e3413004 	movt	r3, #4100	; 0x1004
100277f0:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
100277f4:	e3033594 	movw	r3, #13716	; 0x3594
100277f8:	e3413004 	movt	r3, #4100	; 0x1004
100277fc:	e5933000 	ldr	r3, [r3]
10027800:	e3a0202f 	mov	r2, #47	; 0x2f
10027804:	e5c32000 	strb	r2, [r3]
10027808:	e3033594 	movw	r3, #13716	; 0x3594
1002780c:	e3413004 	movt	r3, #4100	; 0x1004
10027810:	e5933000 	ldr	r3, [r3]
10027814:	e2832001 	add	r2, r3, #1
10027818:	e3033594 	movw	r3, #13716	; 0x3594
1002781c:	e3413004 	movt	r3, #4100	; 0x1004
10027820:	e5832000 	str	r2, [r3]

                    break;
10027824:	ea0000fb 	b	10027c18 <finsh_compile+0x243c>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10027828:	e3033594 	movw	r3, #13716	; 0x3594
1002782c:	e3413004 	movt	r3, #4100	; 0x1004
10027830:	e5933000 	ldr	r3, [r3]
10027834:	e3a02026 	mov	r2, #38	; 0x26
10027838:	e5c32000 	strb	r2, [r3]
1002783c:	e3033594 	movw	r3, #13716	; 0x3594
10027840:	e3413004 	movt	r3, #4100	; 0x1004
10027844:	e5933000 	ldr	r3, [r3]
10027848:	e2832001 	add	r2, r3, #1
1002784c:	e3033594 	movw	r3, #13716	; 0x3594
10027850:	e3413004 	movt	r3, #4100	; 0x1004
10027854:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10027858:	e3033594 	movw	r3, #13716	; 0x3594
1002785c:	e3413004 	movt	r3, #4100	; 0x1004
10027860:	e5933000 	ldr	r3, [r3]
10027864:	e51b201c 	ldr	r2, [fp, #-28]
10027868:	e2822014 	add	r2, r2, #20
1002786c:	e6ef2072 	uxtb	r2, r2
10027870:	e5c32000 	strb	r2, [r3]
10027874:	e3033594 	movw	r3, #13716	; 0x3594
10027878:	e3413004 	movt	r3, #4100	; 0x1004
1002787c:	e5933000 	ldr	r3, [r3]
10027880:	e2833001 	add	r3, r3, #1
10027884:	e51b201c 	ldr	r2, [fp, #-28]
10027888:	e2822014 	add	r2, r2, #20
1002788c:	e1a02422 	lsr	r2, r2, #8
10027890:	e6ef2072 	uxtb	r2, r2
10027894:	e5c32000 	strb	r2, [r3]
10027898:	e3033594 	movw	r3, #13716	; 0x3594
1002789c:	e3413004 	movt	r3, #4100	; 0x1004
100278a0:	e5933000 	ldr	r3, [r3]
100278a4:	e2833002 	add	r3, r3, #2
100278a8:	e51b201c 	ldr	r2, [fp, #-28]
100278ac:	e2822014 	add	r2, r2, #20
100278b0:	e1a02822 	lsr	r2, r2, #16
100278b4:	e6ef2072 	uxtb	r2, r2
100278b8:	e5c32000 	strb	r2, [r3]
100278bc:	e3033594 	movw	r3, #13716	; 0x3594
100278c0:	e3413004 	movt	r3, #4100	; 0x1004
100278c4:	e5933000 	ldr	r3, [r3]
100278c8:	e2833003 	add	r3, r3, #3
100278cc:	e51b201c 	ldr	r2, [fp, #-28]
100278d0:	e2822014 	add	r2, r2, #20
100278d4:	e1a02c22 	lsr	r2, r2, #24
100278d8:	e6ef2072 	uxtb	r2, r2
100278dc:	e5c32000 	strb	r2, [r3]
100278e0:	e3033594 	movw	r3, #13716	; 0x3594
100278e4:	e3413004 	movt	r3, #4100	; 0x1004
100278e8:	e5933000 	ldr	r3, [r3]
100278ec:	e2832004 	add	r2, r3, #4
100278f0:	e3033594 	movw	r3, #13716	; 0x3594
100278f4:	e3413004 	movt	r3, #4100	; 0x1004
100278f8:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
100278fc:	e3033594 	movw	r3, #13716	; 0x3594
10027900:	e3413004 	movt	r3, #4100	; 0x1004
10027904:	e5933000 	ldr	r3, [r3]
10027908:	e3a02023 	mov	r2, #35	; 0x23
1002790c:	e5c32000 	strb	r2, [r3]
10027910:	e3033594 	movw	r3, #13716	; 0x3594
10027914:	e3413004 	movt	r3, #4100	; 0x1004
10027918:	e5933000 	ldr	r3, [r3]
1002791c:	e2832001 	add	r2, r3, #1
10027920:	e3033594 	movw	r3, #13716	; 0x3594
10027924:	e3413004 	movt	r3, #4100	; 0x1004
10027928:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
1002792c:	e3033594 	movw	r3, #13716	; 0x3594
10027930:	e3413004 	movt	r3, #4100	; 0x1004
10027934:	e5933000 	ldr	r3, [r3]
10027938:	e3a02001 	mov	r2, #1
1002793c:	e5c32000 	strb	r2, [r3]
10027940:	e3033594 	movw	r3, #13716	; 0x3594
10027944:	e3413004 	movt	r3, #4100	; 0x1004
10027948:	e5933000 	ldr	r3, [r3]
1002794c:	e2833001 	add	r3, r3, #1
10027950:	e3a02000 	mov	r2, #0
10027954:	e5c32000 	strb	r2, [r3]
10027958:	e3033594 	movw	r3, #13716	; 0x3594
1002795c:	e3413004 	movt	r3, #4100	; 0x1004
10027960:	e5933000 	ldr	r3, [r3]
10027964:	e2832002 	add	r2, r3, #2
10027968:	e3033594 	movw	r3, #13716	; 0x3594
1002796c:	e3413004 	movt	r3, #4100	; 0x1004
10027970:	e5832000 	str	r2, [r3]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
10027974:	e3033594 	movw	r3, #13716	; 0x3594
10027978:	e3413004 	movt	r3, #4100	; 0x1004
1002797c:	e5933000 	ldr	r3, [r3]
10027980:	e3a02005 	mov	r2, #5
10027984:	e5c32000 	strb	r2, [r3]
10027988:	e3033594 	movw	r3, #13716	; 0x3594
1002798c:	e3413004 	movt	r3, #4100	; 0x1004
10027990:	e5933000 	ldr	r3, [r3]
10027994:	e2832001 	add	r2, r3, #1
10027998:	e3033594 	movw	r3, #13716	; 0x3594
1002799c:	e3413004 	movt	r3, #4100	; 0x1004
100279a0:	e5832000 	str	r2, [r3]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
100279a4:	e3033594 	movw	r3, #13716	; 0x3594
100279a8:	e3413004 	movt	r3, #4100	; 0x1004
100279ac:	e5933000 	ldr	r3, [r3]
100279b0:	e3a02029 	mov	r2, #41	; 0x29
100279b4:	e5c32000 	strb	r2, [r3]
100279b8:	e3033594 	movw	r3, #13716	; 0x3594
100279bc:	e3413004 	movt	r3, #4100	; 0x1004
100279c0:	e5933000 	ldr	r3, [r3]
100279c4:	e2832001 	add	r2, r3, #1
100279c8:	e3033594 	movw	r3, #13716	; 0x3594
100279cc:	e3413004 	movt	r3, #4100	; 0x1004
100279d0:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
100279d4:	e3033594 	movw	r3, #13716	; 0x3594
100279d8:	e3413004 	movt	r3, #4100	; 0x1004
100279dc:	e5933000 	ldr	r3, [r3]
100279e0:	e3a0202f 	mov	r2, #47	; 0x2f
100279e4:	e5c32000 	strb	r2, [r3]
100279e8:	e3033594 	movw	r3, #13716	; 0x3594
100279ec:	e3413004 	movt	r3, #4100	; 0x1004
100279f0:	e5933000 	ldr	r3, [r3]
100279f4:	e2832001 	add	r2, r3, #1
100279f8:	e3033594 	movw	r3, #13716	; 0x3594
100279fc:	e3413004 	movt	r3, #4100	; 0x1004
10027a00:	e5832000 	str	r2, [r3]

                    break;
10027a04:	ea000083 	b	10027c18 <finsh_compile+0x243c>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10027a08:	e3033594 	movw	r3, #13716	; 0x3594
10027a0c:	e3413004 	movt	r3, #4100	; 0x1004
10027a10:	e5933000 	ldr	r3, [r3]
10027a14:	e3a02027 	mov	r2, #39	; 0x27
10027a18:	e5c32000 	strb	r2, [r3]
10027a1c:	e3033594 	movw	r3, #13716	; 0x3594
10027a20:	e3413004 	movt	r3, #4100	; 0x1004
10027a24:	e5933000 	ldr	r3, [r3]
10027a28:	e2832001 	add	r2, r3, #1
10027a2c:	e3033594 	movw	r3, #13716	; 0x3594
10027a30:	e3413004 	movt	r3, #4100	; 0x1004
10027a34:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10027a38:	e3033594 	movw	r3, #13716	; 0x3594
10027a3c:	e3413004 	movt	r3, #4100	; 0x1004
10027a40:	e5933000 	ldr	r3, [r3]
10027a44:	e51b201c 	ldr	r2, [fp, #-28]
10027a48:	e2822014 	add	r2, r2, #20
10027a4c:	e6ef2072 	uxtb	r2, r2
10027a50:	e5c32000 	strb	r2, [r3]
10027a54:	e3033594 	movw	r3, #13716	; 0x3594
10027a58:	e3413004 	movt	r3, #4100	; 0x1004
10027a5c:	e5933000 	ldr	r3, [r3]
10027a60:	e2833001 	add	r3, r3, #1
10027a64:	e51b201c 	ldr	r2, [fp, #-28]
10027a68:	e2822014 	add	r2, r2, #20
10027a6c:	e1a02422 	lsr	r2, r2, #8
10027a70:	e6ef2072 	uxtb	r2, r2
10027a74:	e5c32000 	strb	r2, [r3]
10027a78:	e3033594 	movw	r3, #13716	; 0x3594
10027a7c:	e3413004 	movt	r3, #4100	; 0x1004
10027a80:	e5933000 	ldr	r3, [r3]
10027a84:	e2833002 	add	r3, r3, #2
10027a88:	e51b201c 	ldr	r2, [fp, #-28]
10027a8c:	e2822014 	add	r2, r2, #20
10027a90:	e1a02822 	lsr	r2, r2, #16
10027a94:	e6ef2072 	uxtb	r2, r2
10027a98:	e5c32000 	strb	r2, [r3]
10027a9c:	e3033594 	movw	r3, #13716	; 0x3594
10027aa0:	e3413004 	movt	r3, #4100	; 0x1004
10027aa4:	e5933000 	ldr	r3, [r3]
10027aa8:	e2833003 	add	r3, r3, #3
10027aac:	e51b201c 	ldr	r2, [fp, #-28]
10027ab0:	e2822014 	add	r2, r2, #20
10027ab4:	e1a02c22 	lsr	r2, r2, #24
10027ab8:	e6ef2072 	uxtb	r2, r2
10027abc:	e5c32000 	strb	r2, [r3]
10027ac0:	e3033594 	movw	r3, #13716	; 0x3594
10027ac4:	e3413004 	movt	r3, #4100	; 0x1004
10027ac8:	e5933000 	ldr	r3, [r3]
10027acc:	e2832004 	add	r2, r3, #4
10027ad0:	e3033594 	movw	r3, #13716	; 0x3594
10027ad4:	e3413004 	movt	r3, #4100	; 0x1004
10027ad8:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10027adc:	e3033594 	movw	r3, #13716	; 0x3594
10027ae0:	e3413004 	movt	r3, #4100	; 0x1004
10027ae4:	e5933000 	ldr	r3, [r3]
10027ae8:	e3a02024 	mov	r2, #36	; 0x24
10027aec:	e5c32000 	strb	r2, [r3]
10027af0:	e3033594 	movw	r3, #13716	; 0x3594
10027af4:	e3413004 	movt	r3, #4100	; 0x1004
10027af8:	e5933000 	ldr	r3, [r3]
10027afc:	e2832001 	add	r2, r3, #1
10027b00:	e3033594 	movw	r3, #13716	; 0x3594
10027b04:	e3413004 	movt	r3, #4100	; 0x1004
10027b08:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
10027b0c:	e3033594 	movw	r3, #13716	; 0x3594
10027b10:	e3413004 	movt	r3, #4100	; 0x1004
10027b14:	e5933000 	ldr	r3, [r3]
10027b18:	e3a02001 	mov	r2, #1
10027b1c:	e5c32000 	strb	r2, [r3]
10027b20:	e3033594 	movw	r3, #13716	; 0x3594
10027b24:	e3413004 	movt	r3, #4100	; 0x1004
10027b28:	e5933000 	ldr	r3, [r3]
10027b2c:	e2833001 	add	r3, r3, #1
10027b30:	e3a02000 	mov	r2, #0
10027b34:	e5c32000 	strb	r2, [r3]
10027b38:	e3033594 	movw	r3, #13716	; 0x3594
10027b3c:	e3413004 	movt	r3, #4100	; 0x1004
10027b40:	e5933000 	ldr	r3, [r3]
10027b44:	e2833002 	add	r3, r3, #2
10027b48:	e3a02000 	mov	r2, #0
10027b4c:	e5c32000 	strb	r2, [r3]
10027b50:	e3033594 	movw	r3, #13716	; 0x3594
10027b54:	e3413004 	movt	r3, #4100	; 0x1004
10027b58:	e5933000 	ldr	r3, [r3]
10027b5c:	e2833003 	add	r3, r3, #3
10027b60:	e3a02000 	mov	r2, #0
10027b64:	e5c32000 	strb	r2, [r3]
10027b68:	e3033594 	movw	r3, #13716	; 0x3594
10027b6c:	e3413004 	movt	r3, #4100	; 0x1004
10027b70:	e5933000 	ldr	r3, [r3]
10027b74:	e2832004 	add	r2, r3, #4
10027b78:	e3033594 	movw	r3, #13716	; 0x3594
10027b7c:	e3413004 	movt	r3, #4100	; 0x1004
10027b80:	e5832000 	str	r2, [r3]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
10027b84:	e3033594 	movw	r3, #13716	; 0x3594
10027b88:	e3413004 	movt	r3, #4100	; 0x1004
10027b8c:	e5933000 	ldr	r3, [r3]
10027b90:	e3a02006 	mov	r2, #6
10027b94:	e5c32000 	strb	r2, [r3]
10027b98:	e3033594 	movw	r3, #13716	; 0x3594
10027b9c:	e3413004 	movt	r3, #4100	; 0x1004
10027ba0:	e5933000 	ldr	r3, [r3]
10027ba4:	e2832001 	add	r2, r3, #1
10027ba8:	e3033594 	movw	r3, #13716	; 0x3594
10027bac:	e3413004 	movt	r3, #4100	; 0x1004
10027bb0:	e5832000 	str	r2, [r3]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10027bb4:	e3033594 	movw	r3, #13716	; 0x3594
10027bb8:	e3413004 	movt	r3, #4100	; 0x1004
10027bbc:	e5933000 	ldr	r3, [r3]
10027bc0:	e3a0202a 	mov	r2, #42	; 0x2a
10027bc4:	e5c32000 	strb	r2, [r3]
10027bc8:	e3033594 	movw	r3, #13716	; 0x3594
10027bcc:	e3413004 	movt	r3, #4100	; 0x1004
10027bd0:	e5933000 	ldr	r3, [r3]
10027bd4:	e2832001 	add	r2, r3, #1
10027bd8:	e3033594 	movw	r3, #13716	; 0x3594
10027bdc:	e3413004 	movt	r3, #4100	; 0x1004
10027be0:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10027be4:	e3033594 	movw	r3, #13716	; 0x3594
10027be8:	e3413004 	movt	r3, #4100	; 0x1004
10027bec:	e5933000 	ldr	r3, [r3]
10027bf0:	e3a0202f 	mov	r2, #47	; 0x2f
10027bf4:	e5c32000 	strb	r2, [r3]
10027bf8:	e3033594 	movw	r3, #13716	; 0x3594
10027bfc:	e3413004 	movt	r3, #4100	; 0x1004
10027c00:	e5933000 	ldr	r3, [r3]
10027c04:	e2832001 	add	r2, r3, #1
10027c08:	e3033594 	movw	r3, #13716	; 0x3594
10027c0c:	e3413004 	movt	r3, #4100	; 0x1004
10027c10:	e5832000 	str	r2, [r3]

                    break;
10027c14:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
10027c18:	ea0004a2 	b	10028ea8 <finsh_compile+0x36cc>

        /* increase */
        case FINSH_NODE_SYS_INC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
10027c1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10027c20:	e5933010 	ldr	r3, [r3, #16]
10027c24:	e3530000 	cmp	r3, #0
10027c28:	0a00021e 	beq	100284a8 <finsh_compile+0x2ccc>
10027c2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10027c30:	e5933010 	ldr	r3, [r3, #16]
10027c34:	e5d33000 	ldrb	r3, [r3]
10027c38:	e3530001 	cmp	r3, #1
10027c3c:	1a000219 	bne	100284a8 <finsh_compile+0x2ccc>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
10027c40:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10027c44:	e5933010 	ldr	r3, [r3, #16]
10027c48:	e5933008 	ldr	r3, [r3, #8]
10027c4c:	e50b3020 	str	r3, [fp, #-32]

                switch (node->data_type)
10027c50:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10027c54:	e5d33001 	ldrb	r3, [r3, #1]
10027c58:	e3530002 	cmp	r3, #2
10027c5c:	0a0000ab 	beq	10027f10 <finsh_compile+0x2734>
10027c60:	e3530003 	cmp	r3, #3
10027c64:	0a000156 	beq	100281c4 <finsh_compile+0x29e8>
10027c68:	e3530001 	cmp	r3, #1
10027c6c:	0a000000 	beq	10027c74 <finsh_compile+0x2498>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
10027c70:	ea00048c 	b	10028ea8 <finsh_compile+0x36cc>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10027c74:	e3033594 	movw	r3, #13716	; 0x3594
10027c78:	e3413004 	movt	r3, #4100	; 0x1004
10027c7c:	e5933000 	ldr	r3, [r3]
10027c80:	e3a02024 	mov	r2, #36	; 0x24
10027c84:	e5c32000 	strb	r2, [r3]
10027c88:	e3033594 	movw	r3, #13716	; 0x3594
10027c8c:	e3413004 	movt	r3, #4100	; 0x1004
10027c90:	e5933000 	ldr	r3, [r3]
10027c94:	e2832001 	add	r2, r3, #1
10027c98:	e3033594 	movw	r3, #13716	; 0x3594
10027c9c:	e3413004 	movt	r3, #4100	; 0x1004
10027ca0:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
10027ca4:	e3033594 	movw	r3, #13716	; 0x3594
10027ca8:	e3413004 	movt	r3, #4100	; 0x1004
10027cac:	e5933000 	ldr	r3, [r3]
10027cb0:	e51b2020 	ldr	r2, [fp, #-32]
10027cb4:	e2822014 	add	r2, r2, #20
10027cb8:	e6ef2072 	uxtb	r2, r2
10027cbc:	e5c32000 	strb	r2, [r3]
10027cc0:	e3033594 	movw	r3, #13716	; 0x3594
10027cc4:	e3413004 	movt	r3, #4100	; 0x1004
10027cc8:	e5933000 	ldr	r3, [r3]
10027ccc:	e2833001 	add	r3, r3, #1
10027cd0:	e51b2020 	ldr	r2, [fp, #-32]
10027cd4:	e2822014 	add	r2, r2, #20
10027cd8:	e1a02422 	lsr	r2, r2, #8
10027cdc:	e6ef2072 	uxtb	r2, r2
10027ce0:	e5c32000 	strb	r2, [r3]
10027ce4:	e3033594 	movw	r3, #13716	; 0x3594
10027ce8:	e3413004 	movt	r3, #4100	; 0x1004
10027cec:	e5933000 	ldr	r3, [r3]
10027cf0:	e2833002 	add	r3, r3, #2
10027cf4:	e51b2020 	ldr	r2, [fp, #-32]
10027cf8:	e2822014 	add	r2, r2, #20
10027cfc:	e1a02822 	lsr	r2, r2, #16
10027d00:	e6ef2072 	uxtb	r2, r2
10027d04:	e5c32000 	strb	r2, [r3]
10027d08:	e3033594 	movw	r3, #13716	; 0x3594
10027d0c:	e3413004 	movt	r3, #4100	; 0x1004
10027d10:	e5933000 	ldr	r3, [r3]
10027d14:	e2833003 	add	r3, r3, #3
10027d18:	e51b2020 	ldr	r2, [fp, #-32]
10027d1c:	e2822014 	add	r2, r2, #20
10027d20:	e1a02c22 	lsr	r2, r2, #24
10027d24:	e6ef2072 	uxtb	r2, r2
10027d28:	e5c32000 	strb	r2, [r3]
10027d2c:	e3033594 	movw	r3, #13716	; 0x3594
10027d30:	e3413004 	movt	r3, #4100	; 0x1004
10027d34:	e5933000 	ldr	r3, [r3]
10027d38:	e2832004 	add	r2, r3, #4
10027d3c:	e3033594 	movw	r3, #13716	; 0x3594
10027d40:	e3413004 	movt	r3, #4100	; 0x1004
10027d44:	e5832000 	str	r2, [r3]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10027d48:	e3033594 	movw	r3, #13716	; 0x3594
10027d4c:	e3413004 	movt	r3, #4100	; 0x1004
10027d50:	e5933000 	ldr	r3, [r3]
10027d54:	e3a02025 	mov	r2, #37	; 0x25
10027d58:	e5c32000 	strb	r2, [r3]
10027d5c:	e3033594 	movw	r3, #13716	; 0x3594
10027d60:	e3413004 	movt	r3, #4100	; 0x1004
10027d64:	e5933000 	ldr	r3, [r3]
10027d68:	e2832001 	add	r2, r3, #1
10027d6c:	e3033594 	movw	r3, #13716	; 0x3594
10027d70:	e3413004 	movt	r3, #4100	; 0x1004
10027d74:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
10027d78:	e3033594 	movw	r3, #13716	; 0x3594
10027d7c:	e3413004 	movt	r3, #4100	; 0x1004
10027d80:	e5933000 	ldr	r3, [r3]
10027d84:	e51b2020 	ldr	r2, [fp, #-32]
10027d88:	e2822014 	add	r2, r2, #20
10027d8c:	e6ef2072 	uxtb	r2, r2
10027d90:	e5c32000 	strb	r2, [r3]
10027d94:	e3033594 	movw	r3, #13716	; 0x3594
10027d98:	e3413004 	movt	r3, #4100	; 0x1004
10027d9c:	e5933000 	ldr	r3, [r3]
10027da0:	e2833001 	add	r3, r3, #1
10027da4:	e51b2020 	ldr	r2, [fp, #-32]
10027da8:	e2822014 	add	r2, r2, #20
10027dac:	e1a02422 	lsr	r2, r2, #8
10027db0:	e6ef2072 	uxtb	r2, r2
10027db4:	e5c32000 	strb	r2, [r3]
10027db8:	e3033594 	movw	r3, #13716	; 0x3594
10027dbc:	e3413004 	movt	r3, #4100	; 0x1004
10027dc0:	e5933000 	ldr	r3, [r3]
10027dc4:	e2833002 	add	r3, r3, #2
10027dc8:	e51b2020 	ldr	r2, [fp, #-32]
10027dcc:	e2822014 	add	r2, r2, #20
10027dd0:	e1a02822 	lsr	r2, r2, #16
10027dd4:	e6ef2072 	uxtb	r2, r2
10027dd8:	e5c32000 	strb	r2, [r3]
10027ddc:	e3033594 	movw	r3, #13716	; 0x3594
10027de0:	e3413004 	movt	r3, #4100	; 0x1004
10027de4:	e5933000 	ldr	r3, [r3]
10027de8:	e2833003 	add	r3, r3, #3
10027dec:	e51b2020 	ldr	r2, [fp, #-32]
10027df0:	e2822014 	add	r2, r2, #20
10027df4:	e1a02c22 	lsr	r2, r2, #24
10027df8:	e6ef2072 	uxtb	r2, r2
10027dfc:	e5c32000 	strb	r2, [r3]
10027e00:	e3033594 	movw	r3, #13716	; 0x3594
10027e04:	e3413004 	movt	r3, #4100	; 0x1004
10027e08:	e5933000 	ldr	r3, [r3]
10027e0c:	e2832004 	add	r2, r3, #4
10027e10:	e3033594 	movw	r3, #13716	; 0x3594
10027e14:	e3413004 	movt	r3, #4100	; 0x1004
10027e18:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
10027e1c:	e3033594 	movw	r3, #13716	; 0x3594
10027e20:	e3413004 	movt	r3, #4100	; 0x1004
10027e24:	e5933000 	ldr	r3, [r3]
10027e28:	e3a02022 	mov	r2, #34	; 0x22
10027e2c:	e5c32000 	strb	r2, [r3]
10027e30:	e3033594 	movw	r3, #13716	; 0x3594
10027e34:	e3413004 	movt	r3, #4100	; 0x1004
10027e38:	e5933000 	ldr	r3, [r3]
10027e3c:	e2832001 	add	r2, r3, #1
10027e40:	e3033594 	movw	r3, #13716	; 0x3594
10027e44:	e3413004 	movt	r3, #4100	; 0x1004
10027e48:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
10027e4c:	e3033594 	movw	r3, #13716	; 0x3594
10027e50:	e3413004 	movt	r3, #4100	; 0x1004
10027e54:	e5933000 	ldr	r3, [r3]
10027e58:	e3a02001 	mov	r2, #1
10027e5c:	e5c32000 	strb	r2, [r3]
10027e60:	e3033594 	movw	r3, #13716	; 0x3594
10027e64:	e3413004 	movt	r3, #4100	; 0x1004
10027e68:	e5933000 	ldr	r3, [r3]
10027e6c:	e2832001 	add	r2, r3, #1
10027e70:	e3033594 	movw	r3, #13716	; 0x3594
10027e74:	e3413004 	movt	r3, #4100	; 0x1004
10027e78:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
10027e7c:	e3033594 	movw	r3, #13716	; 0x3594
10027e80:	e3413004 	movt	r3, #4100	; 0x1004
10027e84:	e5933000 	ldr	r3, [r3]
10027e88:	e3a02001 	mov	r2, #1
10027e8c:	e5c32000 	strb	r2, [r3]
10027e90:	e3033594 	movw	r3, #13716	; 0x3594
10027e94:	e3413004 	movt	r3, #4100	; 0x1004
10027e98:	e5933000 	ldr	r3, [r3]
10027e9c:	e2832001 	add	r2, r3, #1
10027ea0:	e3033594 	movw	r3, #13716	; 0x3594
10027ea4:	e3413004 	movt	r3, #4100	; 0x1004
10027ea8:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
10027eac:	e3033594 	movw	r3, #13716	; 0x3594
10027eb0:	e3413004 	movt	r3, #4100	; 0x1004
10027eb4:	e5933000 	ldr	r3, [r3]
10027eb8:	e3a02028 	mov	r2, #40	; 0x28
10027ebc:	e5c32000 	strb	r2, [r3]
10027ec0:	e3033594 	movw	r3, #13716	; 0x3594
10027ec4:	e3413004 	movt	r3, #4100	; 0x1004
10027ec8:	e5933000 	ldr	r3, [r3]
10027ecc:	e2832001 	add	r2, r3, #1
10027ed0:	e3033594 	movw	r3, #13716	; 0x3594
10027ed4:	e3413004 	movt	r3, #4100	; 0x1004
10027ed8:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
10027edc:	e3033594 	movw	r3, #13716	; 0x3594
10027ee0:	e3413004 	movt	r3, #4100	; 0x1004
10027ee4:	e5933000 	ldr	r3, [r3]
10027ee8:	e3a0202b 	mov	r2, #43	; 0x2b
10027eec:	e5c32000 	strb	r2, [r3]
10027ef0:	e3033594 	movw	r3, #13716	; 0x3594
10027ef4:	e3413004 	movt	r3, #4100	; 0x1004
10027ef8:	e5933000 	ldr	r3, [r3]
10027efc:	e2832001 	add	r2, r3, #1
10027f00:	e3033594 	movw	r3, #13716	; 0x3594
10027f04:	e3413004 	movt	r3, #4100	; 0x1004
10027f08:	e5832000 	str	r2, [r3]
                    break;
10027f0c:	ea000165 	b	100284a8 <finsh_compile+0x2ccc>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10027f10:	e3033594 	movw	r3, #13716	; 0x3594
10027f14:	e3413004 	movt	r3, #4100	; 0x1004
10027f18:	e5933000 	ldr	r3, [r3]
10027f1c:	e3a02024 	mov	r2, #36	; 0x24
10027f20:	e5c32000 	strb	r2, [r3]
10027f24:	e3033594 	movw	r3, #13716	; 0x3594
10027f28:	e3413004 	movt	r3, #4100	; 0x1004
10027f2c:	e5933000 	ldr	r3, [r3]
10027f30:	e2832001 	add	r2, r3, #1
10027f34:	e3033594 	movw	r3, #13716	; 0x3594
10027f38:	e3413004 	movt	r3, #4100	; 0x1004
10027f3c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10027f40:	e3033594 	movw	r3, #13716	; 0x3594
10027f44:	e3413004 	movt	r3, #4100	; 0x1004
10027f48:	e5933000 	ldr	r3, [r3]
10027f4c:	e51b2020 	ldr	r2, [fp, #-32]
10027f50:	e2822014 	add	r2, r2, #20
10027f54:	e6ef2072 	uxtb	r2, r2
10027f58:	e5c32000 	strb	r2, [r3]
10027f5c:	e3033594 	movw	r3, #13716	; 0x3594
10027f60:	e3413004 	movt	r3, #4100	; 0x1004
10027f64:	e5933000 	ldr	r3, [r3]
10027f68:	e2833001 	add	r3, r3, #1
10027f6c:	e51b2020 	ldr	r2, [fp, #-32]
10027f70:	e2822014 	add	r2, r2, #20
10027f74:	e1a02422 	lsr	r2, r2, #8
10027f78:	e6ef2072 	uxtb	r2, r2
10027f7c:	e5c32000 	strb	r2, [r3]
10027f80:	e3033594 	movw	r3, #13716	; 0x3594
10027f84:	e3413004 	movt	r3, #4100	; 0x1004
10027f88:	e5933000 	ldr	r3, [r3]
10027f8c:	e2833002 	add	r3, r3, #2
10027f90:	e51b2020 	ldr	r2, [fp, #-32]
10027f94:	e2822014 	add	r2, r2, #20
10027f98:	e1a02822 	lsr	r2, r2, #16
10027f9c:	e6ef2072 	uxtb	r2, r2
10027fa0:	e5c32000 	strb	r2, [r3]
10027fa4:	e3033594 	movw	r3, #13716	; 0x3594
10027fa8:	e3413004 	movt	r3, #4100	; 0x1004
10027fac:	e5933000 	ldr	r3, [r3]
10027fb0:	e2833003 	add	r3, r3, #3
10027fb4:	e51b2020 	ldr	r2, [fp, #-32]
10027fb8:	e2822014 	add	r2, r2, #20
10027fbc:	e1a02c22 	lsr	r2, r2, #24
10027fc0:	e6ef2072 	uxtb	r2, r2
10027fc4:	e5c32000 	strb	r2, [r3]
10027fc8:	e3033594 	movw	r3, #13716	; 0x3594
10027fcc:	e3413004 	movt	r3, #4100	; 0x1004
10027fd0:	e5933000 	ldr	r3, [r3]
10027fd4:	e2832004 	add	r2, r3, #4
10027fd8:	e3033594 	movw	r3, #13716	; 0x3594
10027fdc:	e3413004 	movt	r3, #4100	; 0x1004
10027fe0:	e5832000 	str	r2, [r3]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10027fe4:	e3033594 	movw	r3, #13716	; 0x3594
10027fe8:	e3413004 	movt	r3, #4100	; 0x1004
10027fec:	e5933000 	ldr	r3, [r3]
10027ff0:	e3a02026 	mov	r2, #38	; 0x26
10027ff4:	e5c32000 	strb	r2, [r3]
10027ff8:	e3033594 	movw	r3, #13716	; 0x3594
10027ffc:	e3413004 	movt	r3, #4100	; 0x1004
10028000:	e5933000 	ldr	r3, [r3]
10028004:	e2832001 	add	r2, r3, #1
10028008:	e3033594 	movw	r3, #13716	; 0x3594
1002800c:	e3413004 	movt	r3, #4100	; 0x1004
10028010:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10028014:	e3033594 	movw	r3, #13716	; 0x3594
10028018:	e3413004 	movt	r3, #4100	; 0x1004
1002801c:	e5933000 	ldr	r3, [r3]
10028020:	e51b2020 	ldr	r2, [fp, #-32]
10028024:	e2822014 	add	r2, r2, #20
10028028:	e6ef2072 	uxtb	r2, r2
1002802c:	e5c32000 	strb	r2, [r3]
10028030:	e3033594 	movw	r3, #13716	; 0x3594
10028034:	e3413004 	movt	r3, #4100	; 0x1004
10028038:	e5933000 	ldr	r3, [r3]
1002803c:	e2833001 	add	r3, r3, #1
10028040:	e51b2020 	ldr	r2, [fp, #-32]
10028044:	e2822014 	add	r2, r2, #20
10028048:	e1a02422 	lsr	r2, r2, #8
1002804c:	e6ef2072 	uxtb	r2, r2
10028050:	e5c32000 	strb	r2, [r3]
10028054:	e3033594 	movw	r3, #13716	; 0x3594
10028058:	e3413004 	movt	r3, #4100	; 0x1004
1002805c:	e5933000 	ldr	r3, [r3]
10028060:	e2833002 	add	r3, r3, #2
10028064:	e51b2020 	ldr	r2, [fp, #-32]
10028068:	e2822014 	add	r2, r2, #20
1002806c:	e1a02822 	lsr	r2, r2, #16
10028070:	e6ef2072 	uxtb	r2, r2
10028074:	e5c32000 	strb	r2, [r3]
10028078:	e3033594 	movw	r3, #13716	; 0x3594
1002807c:	e3413004 	movt	r3, #4100	; 0x1004
10028080:	e5933000 	ldr	r3, [r3]
10028084:	e2833003 	add	r3, r3, #3
10028088:	e51b2020 	ldr	r2, [fp, #-32]
1002808c:	e2822014 	add	r2, r2, #20
10028090:	e1a02c22 	lsr	r2, r2, #24
10028094:	e6ef2072 	uxtb	r2, r2
10028098:	e5c32000 	strb	r2, [r3]
1002809c:	e3033594 	movw	r3, #13716	; 0x3594
100280a0:	e3413004 	movt	r3, #4100	; 0x1004
100280a4:	e5933000 	ldr	r3, [r3]
100280a8:	e2832004 	add	r2, r3, #4
100280ac:	e3033594 	movw	r3, #13716	; 0x3594
100280b0:	e3413004 	movt	r3, #4100	; 0x1004
100280b4:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
100280b8:	e3033594 	movw	r3, #13716	; 0x3594
100280bc:	e3413004 	movt	r3, #4100	; 0x1004
100280c0:	e5933000 	ldr	r3, [r3]
100280c4:	e3a02023 	mov	r2, #35	; 0x23
100280c8:	e5c32000 	strb	r2, [r3]
100280cc:	e3033594 	movw	r3, #13716	; 0x3594
100280d0:	e3413004 	movt	r3, #4100	; 0x1004
100280d4:	e5933000 	ldr	r3, [r3]
100280d8:	e2832001 	add	r2, r3, #1
100280dc:	e3033594 	movw	r3, #13716	; 0x3594
100280e0:	e3413004 	movt	r3, #4100	; 0x1004
100280e4:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
100280e8:	e3033594 	movw	r3, #13716	; 0x3594
100280ec:	e3413004 	movt	r3, #4100	; 0x1004
100280f0:	e5933000 	ldr	r3, [r3]
100280f4:	e3a02001 	mov	r2, #1
100280f8:	e5c32000 	strb	r2, [r3]
100280fc:	e3033594 	movw	r3, #13716	; 0x3594
10028100:	e3413004 	movt	r3, #4100	; 0x1004
10028104:	e5933000 	ldr	r3, [r3]
10028108:	e2833001 	add	r3, r3, #1
1002810c:	e3a02000 	mov	r2, #0
10028110:	e5c32000 	strb	r2, [r3]
10028114:	e3033594 	movw	r3, #13716	; 0x3594
10028118:	e3413004 	movt	r3, #4100	; 0x1004
1002811c:	e5933000 	ldr	r3, [r3]
10028120:	e2832002 	add	r2, r3, #2
10028124:	e3033594 	movw	r3, #13716	; 0x3594
10028128:	e3413004 	movt	r3, #4100	; 0x1004
1002812c:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
10028130:	e3033594 	movw	r3, #13716	; 0x3594
10028134:	e3413004 	movt	r3, #4100	; 0x1004
10028138:	e5933000 	ldr	r3, [r3]
1002813c:	e3a02002 	mov	r2, #2
10028140:	e5c32000 	strb	r2, [r3]
10028144:	e3033594 	movw	r3, #13716	; 0x3594
10028148:	e3413004 	movt	r3, #4100	; 0x1004
1002814c:	e5933000 	ldr	r3, [r3]
10028150:	e2832001 	add	r2, r3, #1
10028154:	e3033594 	movw	r3, #13716	; 0x3594
10028158:	e3413004 	movt	r3, #4100	; 0x1004
1002815c:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
10028160:	e3033594 	movw	r3, #13716	; 0x3594
10028164:	e3413004 	movt	r3, #4100	; 0x1004
10028168:	e5933000 	ldr	r3, [r3]
1002816c:	e3a02029 	mov	r2, #41	; 0x29
10028170:	e5c32000 	strb	r2, [r3]
10028174:	e3033594 	movw	r3, #13716	; 0x3594
10028178:	e3413004 	movt	r3, #4100	; 0x1004
1002817c:	e5933000 	ldr	r3, [r3]
10028180:	e2832001 	add	r2, r3, #1
10028184:	e3033594 	movw	r3, #13716	; 0x3594
10028188:	e3413004 	movt	r3, #4100	; 0x1004
1002818c:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
10028190:	e3033594 	movw	r3, #13716	; 0x3594
10028194:	e3413004 	movt	r3, #4100	; 0x1004
10028198:	e5933000 	ldr	r3, [r3]
1002819c:	e3a0202b 	mov	r2, #43	; 0x2b
100281a0:	e5c32000 	strb	r2, [r3]
100281a4:	e3033594 	movw	r3, #13716	; 0x3594
100281a8:	e3413004 	movt	r3, #4100	; 0x1004
100281ac:	e5933000 	ldr	r3, [r3]
100281b0:	e2832001 	add	r2, r3, #1
100281b4:	e3033594 	movw	r3, #13716	; 0x3594
100281b8:	e3413004 	movt	r3, #4100	; 0x1004
100281bc:	e5832000 	str	r2, [r3]
                    break;
100281c0:	ea0000b8 	b	100284a8 <finsh_compile+0x2ccc>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
100281c4:	e3033594 	movw	r3, #13716	; 0x3594
100281c8:	e3413004 	movt	r3, #4100	; 0x1004
100281cc:	e5933000 	ldr	r3, [r3]
100281d0:	e3a02024 	mov	r2, #36	; 0x24
100281d4:	e5c32000 	strb	r2, [r3]
100281d8:	e3033594 	movw	r3, #13716	; 0x3594
100281dc:	e3413004 	movt	r3, #4100	; 0x1004
100281e0:	e5933000 	ldr	r3, [r3]
100281e4:	e2832001 	add	r2, r3, #1
100281e8:	e3033594 	movw	r3, #13716	; 0x3594
100281ec:	e3413004 	movt	r3, #4100	; 0x1004
100281f0:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
100281f4:	e3033594 	movw	r3, #13716	; 0x3594
100281f8:	e3413004 	movt	r3, #4100	; 0x1004
100281fc:	e5933000 	ldr	r3, [r3]
10028200:	e51b2020 	ldr	r2, [fp, #-32]
10028204:	e2822014 	add	r2, r2, #20
10028208:	e6ef2072 	uxtb	r2, r2
1002820c:	e5c32000 	strb	r2, [r3]
10028210:	e3033594 	movw	r3, #13716	; 0x3594
10028214:	e3413004 	movt	r3, #4100	; 0x1004
10028218:	e5933000 	ldr	r3, [r3]
1002821c:	e2833001 	add	r3, r3, #1
10028220:	e51b2020 	ldr	r2, [fp, #-32]
10028224:	e2822014 	add	r2, r2, #20
10028228:	e1a02422 	lsr	r2, r2, #8
1002822c:	e6ef2072 	uxtb	r2, r2
10028230:	e5c32000 	strb	r2, [r3]
10028234:	e3033594 	movw	r3, #13716	; 0x3594
10028238:	e3413004 	movt	r3, #4100	; 0x1004
1002823c:	e5933000 	ldr	r3, [r3]
10028240:	e2833002 	add	r3, r3, #2
10028244:	e51b2020 	ldr	r2, [fp, #-32]
10028248:	e2822014 	add	r2, r2, #20
1002824c:	e1a02822 	lsr	r2, r2, #16
10028250:	e6ef2072 	uxtb	r2, r2
10028254:	e5c32000 	strb	r2, [r3]
10028258:	e3033594 	movw	r3, #13716	; 0x3594
1002825c:	e3413004 	movt	r3, #4100	; 0x1004
10028260:	e5933000 	ldr	r3, [r3]
10028264:	e2833003 	add	r3, r3, #3
10028268:	e51b2020 	ldr	r2, [fp, #-32]
1002826c:	e2822014 	add	r2, r2, #20
10028270:	e1a02c22 	lsr	r2, r2, #24
10028274:	e6ef2072 	uxtb	r2, r2
10028278:	e5c32000 	strb	r2, [r3]
1002827c:	e3033594 	movw	r3, #13716	; 0x3594
10028280:	e3413004 	movt	r3, #4100	; 0x1004
10028284:	e5933000 	ldr	r3, [r3]
10028288:	e2832004 	add	r2, r3, #4
1002828c:	e3033594 	movw	r3, #13716	; 0x3594
10028290:	e3413004 	movt	r3, #4100	; 0x1004
10028294:	e5832000 	str	r2, [r3]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10028298:	e3033594 	movw	r3, #13716	; 0x3594
1002829c:	e3413004 	movt	r3, #4100	; 0x1004
100282a0:	e5933000 	ldr	r3, [r3]
100282a4:	e3a02027 	mov	r2, #39	; 0x27
100282a8:	e5c32000 	strb	r2, [r3]
100282ac:	e3033594 	movw	r3, #13716	; 0x3594
100282b0:	e3413004 	movt	r3, #4100	; 0x1004
100282b4:	e5933000 	ldr	r3, [r3]
100282b8:	e2832001 	add	r2, r3, #1
100282bc:	e3033594 	movw	r3, #13716	; 0x3594
100282c0:	e3413004 	movt	r3, #4100	; 0x1004
100282c4:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
100282c8:	e3033594 	movw	r3, #13716	; 0x3594
100282cc:	e3413004 	movt	r3, #4100	; 0x1004
100282d0:	e5933000 	ldr	r3, [r3]
100282d4:	e51b2020 	ldr	r2, [fp, #-32]
100282d8:	e2822014 	add	r2, r2, #20
100282dc:	e6ef2072 	uxtb	r2, r2
100282e0:	e5c32000 	strb	r2, [r3]
100282e4:	e3033594 	movw	r3, #13716	; 0x3594
100282e8:	e3413004 	movt	r3, #4100	; 0x1004
100282ec:	e5933000 	ldr	r3, [r3]
100282f0:	e2833001 	add	r3, r3, #1
100282f4:	e51b2020 	ldr	r2, [fp, #-32]
100282f8:	e2822014 	add	r2, r2, #20
100282fc:	e1a02422 	lsr	r2, r2, #8
10028300:	e6ef2072 	uxtb	r2, r2
10028304:	e5c32000 	strb	r2, [r3]
10028308:	e3033594 	movw	r3, #13716	; 0x3594
1002830c:	e3413004 	movt	r3, #4100	; 0x1004
10028310:	e5933000 	ldr	r3, [r3]
10028314:	e2833002 	add	r3, r3, #2
10028318:	e51b2020 	ldr	r2, [fp, #-32]
1002831c:	e2822014 	add	r2, r2, #20
10028320:	e1a02822 	lsr	r2, r2, #16
10028324:	e6ef2072 	uxtb	r2, r2
10028328:	e5c32000 	strb	r2, [r3]
1002832c:	e3033594 	movw	r3, #13716	; 0x3594
10028330:	e3413004 	movt	r3, #4100	; 0x1004
10028334:	e5933000 	ldr	r3, [r3]
10028338:	e2833003 	add	r3, r3, #3
1002833c:	e51b2020 	ldr	r2, [fp, #-32]
10028340:	e2822014 	add	r2, r2, #20
10028344:	e1a02c22 	lsr	r2, r2, #24
10028348:	e6ef2072 	uxtb	r2, r2
1002834c:	e5c32000 	strb	r2, [r3]
10028350:	e3033594 	movw	r3, #13716	; 0x3594
10028354:	e3413004 	movt	r3, #4100	; 0x1004
10028358:	e5933000 	ldr	r3, [r3]
1002835c:	e2832004 	add	r2, r3, #4
10028360:	e3033594 	movw	r3, #13716	; 0x3594
10028364:	e3413004 	movt	r3, #4100	; 0x1004
10028368:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
1002836c:	e3033594 	movw	r3, #13716	; 0x3594
10028370:	e3413004 	movt	r3, #4100	; 0x1004
10028374:	e5933000 	ldr	r3, [r3]
10028378:	e3a02024 	mov	r2, #36	; 0x24
1002837c:	e5c32000 	strb	r2, [r3]
10028380:	e3033594 	movw	r3, #13716	; 0x3594
10028384:	e3413004 	movt	r3, #4100	; 0x1004
10028388:	e5933000 	ldr	r3, [r3]
1002838c:	e2832001 	add	r2, r3, #1
10028390:	e3033594 	movw	r3, #13716	; 0x3594
10028394:	e3413004 	movt	r3, #4100	; 0x1004
10028398:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
1002839c:	e3033594 	movw	r3, #13716	; 0x3594
100283a0:	e3413004 	movt	r3, #4100	; 0x1004
100283a4:	e5933000 	ldr	r3, [r3]
100283a8:	e3a02001 	mov	r2, #1
100283ac:	e5c32000 	strb	r2, [r3]
100283b0:	e3033594 	movw	r3, #13716	; 0x3594
100283b4:	e3413004 	movt	r3, #4100	; 0x1004
100283b8:	e5933000 	ldr	r3, [r3]
100283bc:	e2833001 	add	r3, r3, #1
100283c0:	e3a02000 	mov	r2, #0
100283c4:	e5c32000 	strb	r2, [r3]
100283c8:	e3033594 	movw	r3, #13716	; 0x3594
100283cc:	e3413004 	movt	r3, #4100	; 0x1004
100283d0:	e5933000 	ldr	r3, [r3]
100283d4:	e2833002 	add	r3, r3, #2
100283d8:	e3a02000 	mov	r2, #0
100283dc:	e5c32000 	strb	r2, [r3]
100283e0:	e3033594 	movw	r3, #13716	; 0x3594
100283e4:	e3413004 	movt	r3, #4100	; 0x1004
100283e8:	e5933000 	ldr	r3, [r3]
100283ec:	e2833003 	add	r3, r3, #3
100283f0:	e3a02000 	mov	r2, #0
100283f4:	e5c32000 	strb	r2, [r3]
100283f8:	e3033594 	movw	r3, #13716	; 0x3594
100283fc:	e3413004 	movt	r3, #4100	; 0x1004
10028400:	e5933000 	ldr	r3, [r3]
10028404:	e2832004 	add	r2, r3, #4
10028408:	e3033594 	movw	r3, #13716	; 0x3594
1002840c:	e3413004 	movt	r3, #4100	; 0x1004
10028410:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
10028414:	e3033594 	movw	r3, #13716	; 0x3594
10028418:	e3413004 	movt	r3, #4100	; 0x1004
1002841c:	e5933000 	ldr	r3, [r3]
10028420:	e3a02003 	mov	r2, #3
10028424:	e5c32000 	strb	r2, [r3]
10028428:	e3033594 	movw	r3, #13716	; 0x3594
1002842c:	e3413004 	movt	r3, #4100	; 0x1004
10028430:	e5933000 	ldr	r3, [r3]
10028434:	e2832001 	add	r2, r3, #1
10028438:	e3033594 	movw	r3, #13716	; 0x3594
1002843c:	e3413004 	movt	r3, #4100	; 0x1004
10028440:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10028444:	e3033594 	movw	r3, #13716	; 0x3594
10028448:	e3413004 	movt	r3, #4100	; 0x1004
1002844c:	e5933000 	ldr	r3, [r3]
10028450:	e3a0202a 	mov	r2, #42	; 0x2a
10028454:	e5c32000 	strb	r2, [r3]
10028458:	e3033594 	movw	r3, #13716	; 0x3594
1002845c:	e3413004 	movt	r3, #4100	; 0x1004
10028460:	e5933000 	ldr	r3, [r3]
10028464:	e2832001 	add	r2, r3, #1
10028468:	e3033594 	movw	r3, #13716	; 0x3594
1002846c:	e3413004 	movt	r3, #4100	; 0x1004
10028470:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
10028474:	e3033594 	movw	r3, #13716	; 0x3594
10028478:	e3413004 	movt	r3, #4100	; 0x1004
1002847c:	e5933000 	ldr	r3, [r3]
10028480:	e3a0202b 	mov	r2, #43	; 0x2b
10028484:	e5c32000 	strb	r2, [r3]
10028488:	e3033594 	movw	r3, #13716	; 0x3594
1002848c:	e3413004 	movt	r3, #4100	; 0x1004
10028490:	e5933000 	ldr	r3, [r3]
10028494:	e2832001 	add	r2, r3, #1
10028498:	e3033594 	movw	r3, #13716	; 0x3594
1002849c:	e3413004 	movt	r3, #4100	; 0x1004
100284a0:	e5832000 	str	r2, [r3]
                    break;
100284a4:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
100284a8:	ea00027e 	b	10028ea8 <finsh_compile+0x36cc>

        /* decrease */
        case FINSH_NODE_SYS_DEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
100284ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100284b0:	e5933010 	ldr	r3, [r3, #16]
100284b4:	e3530000 	cmp	r3, #0
100284b8:	0a00021e 	beq	10028d38 <finsh_compile+0x355c>
100284bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100284c0:	e5933010 	ldr	r3, [r3, #16]
100284c4:	e5d33000 	ldrb	r3, [r3]
100284c8:	e3530001 	cmp	r3, #1
100284cc:	1a000219 	bne	10028d38 <finsh_compile+0x355c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
100284d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100284d4:	e5933010 	ldr	r3, [r3, #16]
100284d8:	e5933008 	ldr	r3, [r3, #8]
100284dc:	e50b3024 	str	r3, [fp, #-36]	; 0x24

                switch (node->data_type)
100284e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100284e4:	e5d33001 	ldrb	r3, [r3, #1]
100284e8:	e3530002 	cmp	r3, #2
100284ec:	0a0000ab 	beq	100287a0 <finsh_compile+0x2fc4>
100284f0:	e3530003 	cmp	r3, #3
100284f4:	0a000156 	beq	10028a54 <finsh_compile+0x3278>
100284f8:	e3530001 	cmp	r3, #1
100284fc:	0a000000 	beq	10028504 <finsh_compile+0x2d28>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
10028500:	ea000268 	b	10028ea8 <finsh_compile+0x36cc>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10028504:	e3033594 	movw	r3, #13716	; 0x3594
10028508:	e3413004 	movt	r3, #4100	; 0x1004
1002850c:	e5933000 	ldr	r3, [r3]
10028510:	e3a02024 	mov	r2, #36	; 0x24
10028514:	e5c32000 	strb	r2, [r3]
10028518:	e3033594 	movw	r3, #13716	; 0x3594
1002851c:	e3413004 	movt	r3, #4100	; 0x1004
10028520:	e5933000 	ldr	r3, [r3]
10028524:	e2832001 	add	r2, r3, #1
10028528:	e3033594 	movw	r3, #13716	; 0x3594
1002852c:	e3413004 	movt	r3, #4100	; 0x1004
10028530:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
10028534:	e3033594 	movw	r3, #13716	; 0x3594
10028538:	e3413004 	movt	r3, #4100	; 0x1004
1002853c:	e5933000 	ldr	r3, [r3]
10028540:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028544:	e2822014 	add	r2, r2, #20
10028548:	e6ef2072 	uxtb	r2, r2
1002854c:	e5c32000 	strb	r2, [r3]
10028550:	e3033594 	movw	r3, #13716	; 0x3594
10028554:	e3413004 	movt	r3, #4100	; 0x1004
10028558:	e5933000 	ldr	r3, [r3]
1002855c:	e2833001 	add	r3, r3, #1
10028560:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028564:	e2822014 	add	r2, r2, #20
10028568:	e1a02422 	lsr	r2, r2, #8
1002856c:	e6ef2072 	uxtb	r2, r2
10028570:	e5c32000 	strb	r2, [r3]
10028574:	e3033594 	movw	r3, #13716	; 0x3594
10028578:	e3413004 	movt	r3, #4100	; 0x1004
1002857c:	e5933000 	ldr	r3, [r3]
10028580:	e2833002 	add	r3, r3, #2
10028584:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028588:	e2822014 	add	r2, r2, #20
1002858c:	e1a02822 	lsr	r2, r2, #16
10028590:	e6ef2072 	uxtb	r2, r2
10028594:	e5c32000 	strb	r2, [r3]
10028598:	e3033594 	movw	r3, #13716	; 0x3594
1002859c:	e3413004 	movt	r3, #4100	; 0x1004
100285a0:	e5933000 	ldr	r3, [r3]
100285a4:	e2833003 	add	r3, r3, #3
100285a8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100285ac:	e2822014 	add	r2, r2, #20
100285b0:	e1a02c22 	lsr	r2, r2, #24
100285b4:	e6ef2072 	uxtb	r2, r2
100285b8:	e5c32000 	strb	r2, [r3]
100285bc:	e3033594 	movw	r3, #13716	; 0x3594
100285c0:	e3413004 	movt	r3, #4100	; 0x1004
100285c4:	e5933000 	ldr	r3, [r3]
100285c8:	e2832004 	add	r2, r3, #4
100285cc:	e3033594 	movw	r3, #13716	; 0x3594
100285d0:	e3413004 	movt	r3, #4100	; 0x1004
100285d4:	e5832000 	str	r2, [r3]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
100285d8:	e3033594 	movw	r3, #13716	; 0x3594
100285dc:	e3413004 	movt	r3, #4100	; 0x1004
100285e0:	e5933000 	ldr	r3, [r3]
100285e4:	e3a02025 	mov	r2, #37	; 0x25
100285e8:	e5c32000 	strb	r2, [r3]
100285ec:	e3033594 	movw	r3, #13716	; 0x3594
100285f0:	e3413004 	movt	r3, #4100	; 0x1004
100285f4:	e5933000 	ldr	r3, [r3]
100285f8:	e2832001 	add	r2, r3, #1
100285fc:	e3033594 	movw	r3, #13716	; 0x3594
10028600:	e3413004 	movt	r3, #4100	; 0x1004
10028604:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
10028608:	e3033594 	movw	r3, #13716	; 0x3594
1002860c:	e3413004 	movt	r3, #4100	; 0x1004
10028610:	e5933000 	ldr	r3, [r3]
10028614:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028618:	e2822014 	add	r2, r2, #20
1002861c:	e6ef2072 	uxtb	r2, r2
10028620:	e5c32000 	strb	r2, [r3]
10028624:	e3033594 	movw	r3, #13716	; 0x3594
10028628:	e3413004 	movt	r3, #4100	; 0x1004
1002862c:	e5933000 	ldr	r3, [r3]
10028630:	e2833001 	add	r3, r3, #1
10028634:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028638:	e2822014 	add	r2, r2, #20
1002863c:	e1a02422 	lsr	r2, r2, #8
10028640:	e6ef2072 	uxtb	r2, r2
10028644:	e5c32000 	strb	r2, [r3]
10028648:	e3033594 	movw	r3, #13716	; 0x3594
1002864c:	e3413004 	movt	r3, #4100	; 0x1004
10028650:	e5933000 	ldr	r3, [r3]
10028654:	e2833002 	add	r3, r3, #2
10028658:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1002865c:	e2822014 	add	r2, r2, #20
10028660:	e1a02822 	lsr	r2, r2, #16
10028664:	e6ef2072 	uxtb	r2, r2
10028668:	e5c32000 	strb	r2, [r3]
1002866c:	e3033594 	movw	r3, #13716	; 0x3594
10028670:	e3413004 	movt	r3, #4100	; 0x1004
10028674:	e5933000 	ldr	r3, [r3]
10028678:	e2833003 	add	r3, r3, #3
1002867c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028680:	e2822014 	add	r2, r2, #20
10028684:	e1a02c22 	lsr	r2, r2, #24
10028688:	e6ef2072 	uxtb	r2, r2
1002868c:	e5c32000 	strb	r2, [r3]
10028690:	e3033594 	movw	r3, #13716	; 0x3594
10028694:	e3413004 	movt	r3, #4100	; 0x1004
10028698:	e5933000 	ldr	r3, [r3]
1002869c:	e2832004 	add	r2, r3, #4
100286a0:	e3033594 	movw	r3, #13716	; 0x3594
100286a4:	e3413004 	movt	r3, #4100	; 0x1004
100286a8:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
100286ac:	e3033594 	movw	r3, #13716	; 0x3594
100286b0:	e3413004 	movt	r3, #4100	; 0x1004
100286b4:	e5933000 	ldr	r3, [r3]
100286b8:	e3a02022 	mov	r2, #34	; 0x22
100286bc:	e5c32000 	strb	r2, [r3]
100286c0:	e3033594 	movw	r3, #13716	; 0x3594
100286c4:	e3413004 	movt	r3, #4100	; 0x1004
100286c8:	e5933000 	ldr	r3, [r3]
100286cc:	e2832001 	add	r2, r3, #1
100286d0:	e3033594 	movw	r3, #13716	; 0x3594
100286d4:	e3413004 	movt	r3, #4100	; 0x1004
100286d8:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
100286dc:	e3033594 	movw	r3, #13716	; 0x3594
100286e0:	e3413004 	movt	r3, #4100	; 0x1004
100286e4:	e5933000 	ldr	r3, [r3]
100286e8:	e3a02001 	mov	r2, #1
100286ec:	e5c32000 	strb	r2, [r3]
100286f0:	e3033594 	movw	r3, #13716	; 0x3594
100286f4:	e3413004 	movt	r3, #4100	; 0x1004
100286f8:	e5933000 	ldr	r3, [r3]
100286fc:	e2832001 	add	r2, r3, #1
10028700:	e3033594 	movw	r3, #13716	; 0x3594
10028704:	e3413004 	movt	r3, #4100	; 0x1004
10028708:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
1002870c:	e3033594 	movw	r3, #13716	; 0x3594
10028710:	e3413004 	movt	r3, #4100	; 0x1004
10028714:	e5933000 	ldr	r3, [r3]
10028718:	e3a02004 	mov	r2, #4
1002871c:	e5c32000 	strb	r2, [r3]
10028720:	e3033594 	movw	r3, #13716	; 0x3594
10028724:	e3413004 	movt	r3, #4100	; 0x1004
10028728:	e5933000 	ldr	r3, [r3]
1002872c:	e2832001 	add	r2, r3, #1
10028730:	e3033594 	movw	r3, #13716	; 0x3594
10028734:	e3413004 	movt	r3, #4100	; 0x1004
10028738:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
1002873c:	e3033594 	movw	r3, #13716	; 0x3594
10028740:	e3413004 	movt	r3, #4100	; 0x1004
10028744:	e5933000 	ldr	r3, [r3]
10028748:	e3a02028 	mov	r2, #40	; 0x28
1002874c:	e5c32000 	strb	r2, [r3]
10028750:	e3033594 	movw	r3, #13716	; 0x3594
10028754:	e3413004 	movt	r3, #4100	; 0x1004
10028758:	e5933000 	ldr	r3, [r3]
1002875c:	e2832001 	add	r2, r3, #1
10028760:	e3033594 	movw	r3, #13716	; 0x3594
10028764:	e3413004 	movt	r3, #4100	; 0x1004
10028768:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
1002876c:	e3033594 	movw	r3, #13716	; 0x3594
10028770:	e3413004 	movt	r3, #4100	; 0x1004
10028774:	e5933000 	ldr	r3, [r3]
10028778:	e3a0202b 	mov	r2, #43	; 0x2b
1002877c:	e5c32000 	strb	r2, [r3]
10028780:	e3033594 	movw	r3, #13716	; 0x3594
10028784:	e3413004 	movt	r3, #4100	; 0x1004
10028788:	e5933000 	ldr	r3, [r3]
1002878c:	e2832001 	add	r2, r3, #1
10028790:	e3033594 	movw	r3, #13716	; 0x3594
10028794:	e3413004 	movt	r3, #4100	; 0x1004
10028798:	e5832000 	str	r2, [r3]
                    break;
1002879c:	ea000165 	b	10028d38 <finsh_compile+0x355c>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
100287a0:	e3033594 	movw	r3, #13716	; 0x3594
100287a4:	e3413004 	movt	r3, #4100	; 0x1004
100287a8:	e5933000 	ldr	r3, [r3]
100287ac:	e3a02024 	mov	r2, #36	; 0x24
100287b0:	e5c32000 	strb	r2, [r3]
100287b4:	e3033594 	movw	r3, #13716	; 0x3594
100287b8:	e3413004 	movt	r3, #4100	; 0x1004
100287bc:	e5933000 	ldr	r3, [r3]
100287c0:	e2832001 	add	r2, r3, #1
100287c4:	e3033594 	movw	r3, #13716	; 0x3594
100287c8:	e3413004 	movt	r3, #4100	; 0x1004
100287cc:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
100287d0:	e3033594 	movw	r3, #13716	; 0x3594
100287d4:	e3413004 	movt	r3, #4100	; 0x1004
100287d8:	e5933000 	ldr	r3, [r3]
100287dc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100287e0:	e2822014 	add	r2, r2, #20
100287e4:	e6ef2072 	uxtb	r2, r2
100287e8:	e5c32000 	strb	r2, [r3]
100287ec:	e3033594 	movw	r3, #13716	; 0x3594
100287f0:	e3413004 	movt	r3, #4100	; 0x1004
100287f4:	e5933000 	ldr	r3, [r3]
100287f8:	e2833001 	add	r3, r3, #1
100287fc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028800:	e2822014 	add	r2, r2, #20
10028804:	e1a02422 	lsr	r2, r2, #8
10028808:	e6ef2072 	uxtb	r2, r2
1002880c:	e5c32000 	strb	r2, [r3]
10028810:	e3033594 	movw	r3, #13716	; 0x3594
10028814:	e3413004 	movt	r3, #4100	; 0x1004
10028818:	e5933000 	ldr	r3, [r3]
1002881c:	e2833002 	add	r3, r3, #2
10028820:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028824:	e2822014 	add	r2, r2, #20
10028828:	e1a02822 	lsr	r2, r2, #16
1002882c:	e6ef2072 	uxtb	r2, r2
10028830:	e5c32000 	strb	r2, [r3]
10028834:	e3033594 	movw	r3, #13716	; 0x3594
10028838:	e3413004 	movt	r3, #4100	; 0x1004
1002883c:	e5933000 	ldr	r3, [r3]
10028840:	e2833003 	add	r3, r3, #3
10028844:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028848:	e2822014 	add	r2, r2, #20
1002884c:	e1a02c22 	lsr	r2, r2, #24
10028850:	e6ef2072 	uxtb	r2, r2
10028854:	e5c32000 	strb	r2, [r3]
10028858:	e3033594 	movw	r3, #13716	; 0x3594
1002885c:	e3413004 	movt	r3, #4100	; 0x1004
10028860:	e5933000 	ldr	r3, [r3]
10028864:	e2832004 	add	r2, r3, #4
10028868:	e3033594 	movw	r3, #13716	; 0x3594
1002886c:	e3413004 	movt	r3, #4100	; 0x1004
10028870:	e5832000 	str	r2, [r3]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10028874:	e3033594 	movw	r3, #13716	; 0x3594
10028878:	e3413004 	movt	r3, #4100	; 0x1004
1002887c:	e5933000 	ldr	r3, [r3]
10028880:	e3a02026 	mov	r2, #38	; 0x26
10028884:	e5c32000 	strb	r2, [r3]
10028888:	e3033594 	movw	r3, #13716	; 0x3594
1002888c:	e3413004 	movt	r3, #4100	; 0x1004
10028890:	e5933000 	ldr	r3, [r3]
10028894:	e2832001 	add	r2, r3, #1
10028898:	e3033594 	movw	r3, #13716	; 0x3594
1002889c:	e3413004 	movt	r3, #4100	; 0x1004
100288a0:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
100288a4:	e3033594 	movw	r3, #13716	; 0x3594
100288a8:	e3413004 	movt	r3, #4100	; 0x1004
100288ac:	e5933000 	ldr	r3, [r3]
100288b0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100288b4:	e2822014 	add	r2, r2, #20
100288b8:	e6ef2072 	uxtb	r2, r2
100288bc:	e5c32000 	strb	r2, [r3]
100288c0:	e3033594 	movw	r3, #13716	; 0x3594
100288c4:	e3413004 	movt	r3, #4100	; 0x1004
100288c8:	e5933000 	ldr	r3, [r3]
100288cc:	e2833001 	add	r3, r3, #1
100288d0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100288d4:	e2822014 	add	r2, r2, #20
100288d8:	e1a02422 	lsr	r2, r2, #8
100288dc:	e6ef2072 	uxtb	r2, r2
100288e0:	e5c32000 	strb	r2, [r3]
100288e4:	e3033594 	movw	r3, #13716	; 0x3594
100288e8:	e3413004 	movt	r3, #4100	; 0x1004
100288ec:	e5933000 	ldr	r3, [r3]
100288f0:	e2833002 	add	r3, r3, #2
100288f4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100288f8:	e2822014 	add	r2, r2, #20
100288fc:	e1a02822 	lsr	r2, r2, #16
10028900:	e6ef2072 	uxtb	r2, r2
10028904:	e5c32000 	strb	r2, [r3]
10028908:	e3033594 	movw	r3, #13716	; 0x3594
1002890c:	e3413004 	movt	r3, #4100	; 0x1004
10028910:	e5933000 	ldr	r3, [r3]
10028914:	e2833003 	add	r3, r3, #3
10028918:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1002891c:	e2822014 	add	r2, r2, #20
10028920:	e1a02c22 	lsr	r2, r2, #24
10028924:	e6ef2072 	uxtb	r2, r2
10028928:	e5c32000 	strb	r2, [r3]
1002892c:	e3033594 	movw	r3, #13716	; 0x3594
10028930:	e3413004 	movt	r3, #4100	; 0x1004
10028934:	e5933000 	ldr	r3, [r3]
10028938:	e2832004 	add	r2, r3, #4
1002893c:	e3033594 	movw	r3, #13716	; 0x3594
10028940:	e3413004 	movt	r3, #4100	; 0x1004
10028944:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
10028948:	e3033594 	movw	r3, #13716	; 0x3594
1002894c:	e3413004 	movt	r3, #4100	; 0x1004
10028950:	e5933000 	ldr	r3, [r3]
10028954:	e3a02023 	mov	r2, #35	; 0x23
10028958:	e5c32000 	strb	r2, [r3]
1002895c:	e3033594 	movw	r3, #13716	; 0x3594
10028960:	e3413004 	movt	r3, #4100	; 0x1004
10028964:	e5933000 	ldr	r3, [r3]
10028968:	e2832001 	add	r2, r3, #1
1002896c:	e3033594 	movw	r3, #13716	; 0x3594
10028970:	e3413004 	movt	r3, #4100	; 0x1004
10028974:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
10028978:	e3033594 	movw	r3, #13716	; 0x3594
1002897c:	e3413004 	movt	r3, #4100	; 0x1004
10028980:	e5933000 	ldr	r3, [r3]
10028984:	e3a02001 	mov	r2, #1
10028988:	e5c32000 	strb	r2, [r3]
1002898c:	e3033594 	movw	r3, #13716	; 0x3594
10028990:	e3413004 	movt	r3, #4100	; 0x1004
10028994:	e5933000 	ldr	r3, [r3]
10028998:	e2833001 	add	r3, r3, #1
1002899c:	e3a02000 	mov	r2, #0
100289a0:	e5c32000 	strb	r2, [r3]
100289a4:	e3033594 	movw	r3, #13716	; 0x3594
100289a8:	e3413004 	movt	r3, #4100	; 0x1004
100289ac:	e5933000 	ldr	r3, [r3]
100289b0:	e2832002 	add	r2, r3, #2
100289b4:	e3033594 	movw	r3, #13716	; 0x3594
100289b8:	e3413004 	movt	r3, #4100	; 0x1004
100289bc:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
100289c0:	e3033594 	movw	r3, #13716	; 0x3594
100289c4:	e3413004 	movt	r3, #4100	; 0x1004
100289c8:	e5933000 	ldr	r3, [r3]
100289cc:	e3a02005 	mov	r2, #5
100289d0:	e5c32000 	strb	r2, [r3]
100289d4:	e3033594 	movw	r3, #13716	; 0x3594
100289d8:	e3413004 	movt	r3, #4100	; 0x1004
100289dc:	e5933000 	ldr	r3, [r3]
100289e0:	e2832001 	add	r2, r3, #1
100289e4:	e3033594 	movw	r3, #13716	; 0x3594
100289e8:	e3413004 	movt	r3, #4100	; 0x1004
100289ec:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
100289f0:	e3033594 	movw	r3, #13716	; 0x3594
100289f4:	e3413004 	movt	r3, #4100	; 0x1004
100289f8:	e5933000 	ldr	r3, [r3]
100289fc:	e3a02029 	mov	r2, #41	; 0x29
10028a00:	e5c32000 	strb	r2, [r3]
10028a04:	e3033594 	movw	r3, #13716	; 0x3594
10028a08:	e3413004 	movt	r3, #4100	; 0x1004
10028a0c:	e5933000 	ldr	r3, [r3]
10028a10:	e2832001 	add	r2, r3, #1
10028a14:	e3033594 	movw	r3, #13716	; 0x3594
10028a18:	e3413004 	movt	r3, #4100	; 0x1004
10028a1c:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
10028a20:	e3033594 	movw	r3, #13716	; 0x3594
10028a24:	e3413004 	movt	r3, #4100	; 0x1004
10028a28:	e5933000 	ldr	r3, [r3]
10028a2c:	e3a0202b 	mov	r2, #43	; 0x2b
10028a30:	e5c32000 	strb	r2, [r3]
10028a34:	e3033594 	movw	r3, #13716	; 0x3594
10028a38:	e3413004 	movt	r3, #4100	; 0x1004
10028a3c:	e5933000 	ldr	r3, [r3]
10028a40:	e2832001 	add	r2, r3, #1
10028a44:	e3033594 	movw	r3, #13716	; 0x3594
10028a48:	e3413004 	movt	r3, #4100	; 0x1004
10028a4c:	e5832000 	str	r2, [r3]
                    break;
10028a50:	ea0000b8 	b	10028d38 <finsh_compile+0x355c>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10028a54:	e3033594 	movw	r3, #13716	; 0x3594
10028a58:	e3413004 	movt	r3, #4100	; 0x1004
10028a5c:	e5933000 	ldr	r3, [r3]
10028a60:	e3a02024 	mov	r2, #36	; 0x24
10028a64:	e5c32000 	strb	r2, [r3]
10028a68:	e3033594 	movw	r3, #13716	; 0x3594
10028a6c:	e3413004 	movt	r3, #4100	; 0x1004
10028a70:	e5933000 	ldr	r3, [r3]
10028a74:	e2832001 	add	r2, r3, #1
10028a78:	e3033594 	movw	r3, #13716	; 0x3594
10028a7c:	e3413004 	movt	r3, #4100	; 0x1004
10028a80:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10028a84:	e3033594 	movw	r3, #13716	; 0x3594
10028a88:	e3413004 	movt	r3, #4100	; 0x1004
10028a8c:	e5933000 	ldr	r3, [r3]
10028a90:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028a94:	e2822014 	add	r2, r2, #20
10028a98:	e6ef2072 	uxtb	r2, r2
10028a9c:	e5c32000 	strb	r2, [r3]
10028aa0:	e3033594 	movw	r3, #13716	; 0x3594
10028aa4:	e3413004 	movt	r3, #4100	; 0x1004
10028aa8:	e5933000 	ldr	r3, [r3]
10028aac:	e2833001 	add	r3, r3, #1
10028ab0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028ab4:	e2822014 	add	r2, r2, #20
10028ab8:	e1a02422 	lsr	r2, r2, #8
10028abc:	e6ef2072 	uxtb	r2, r2
10028ac0:	e5c32000 	strb	r2, [r3]
10028ac4:	e3033594 	movw	r3, #13716	; 0x3594
10028ac8:	e3413004 	movt	r3, #4100	; 0x1004
10028acc:	e5933000 	ldr	r3, [r3]
10028ad0:	e2833002 	add	r3, r3, #2
10028ad4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028ad8:	e2822014 	add	r2, r2, #20
10028adc:	e1a02822 	lsr	r2, r2, #16
10028ae0:	e6ef2072 	uxtb	r2, r2
10028ae4:	e5c32000 	strb	r2, [r3]
10028ae8:	e3033594 	movw	r3, #13716	; 0x3594
10028aec:	e3413004 	movt	r3, #4100	; 0x1004
10028af0:	e5933000 	ldr	r3, [r3]
10028af4:	e2833003 	add	r3, r3, #3
10028af8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028afc:	e2822014 	add	r2, r2, #20
10028b00:	e1a02c22 	lsr	r2, r2, #24
10028b04:	e6ef2072 	uxtb	r2, r2
10028b08:	e5c32000 	strb	r2, [r3]
10028b0c:	e3033594 	movw	r3, #13716	; 0x3594
10028b10:	e3413004 	movt	r3, #4100	; 0x1004
10028b14:	e5933000 	ldr	r3, [r3]
10028b18:	e2832004 	add	r2, r3, #4
10028b1c:	e3033594 	movw	r3, #13716	; 0x3594
10028b20:	e3413004 	movt	r3, #4100	; 0x1004
10028b24:	e5832000 	str	r2, [r3]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10028b28:	e3033594 	movw	r3, #13716	; 0x3594
10028b2c:	e3413004 	movt	r3, #4100	; 0x1004
10028b30:	e5933000 	ldr	r3, [r3]
10028b34:	e3a02027 	mov	r2, #39	; 0x27
10028b38:	e5c32000 	strb	r2, [r3]
10028b3c:	e3033594 	movw	r3, #13716	; 0x3594
10028b40:	e3413004 	movt	r3, #4100	; 0x1004
10028b44:	e5933000 	ldr	r3, [r3]
10028b48:	e2832001 	add	r2, r3, #1
10028b4c:	e3033594 	movw	r3, #13716	; 0x3594
10028b50:	e3413004 	movt	r3, #4100	; 0x1004
10028b54:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10028b58:	e3033594 	movw	r3, #13716	; 0x3594
10028b5c:	e3413004 	movt	r3, #4100	; 0x1004
10028b60:	e5933000 	ldr	r3, [r3]
10028b64:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028b68:	e2822014 	add	r2, r2, #20
10028b6c:	e6ef2072 	uxtb	r2, r2
10028b70:	e5c32000 	strb	r2, [r3]
10028b74:	e3033594 	movw	r3, #13716	; 0x3594
10028b78:	e3413004 	movt	r3, #4100	; 0x1004
10028b7c:	e5933000 	ldr	r3, [r3]
10028b80:	e2833001 	add	r3, r3, #1
10028b84:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028b88:	e2822014 	add	r2, r2, #20
10028b8c:	e1a02422 	lsr	r2, r2, #8
10028b90:	e6ef2072 	uxtb	r2, r2
10028b94:	e5c32000 	strb	r2, [r3]
10028b98:	e3033594 	movw	r3, #13716	; 0x3594
10028b9c:	e3413004 	movt	r3, #4100	; 0x1004
10028ba0:	e5933000 	ldr	r3, [r3]
10028ba4:	e2833002 	add	r3, r3, #2
10028ba8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028bac:	e2822014 	add	r2, r2, #20
10028bb0:	e1a02822 	lsr	r2, r2, #16
10028bb4:	e6ef2072 	uxtb	r2, r2
10028bb8:	e5c32000 	strb	r2, [r3]
10028bbc:	e3033594 	movw	r3, #13716	; 0x3594
10028bc0:	e3413004 	movt	r3, #4100	; 0x1004
10028bc4:	e5933000 	ldr	r3, [r3]
10028bc8:	e2833003 	add	r3, r3, #3
10028bcc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10028bd0:	e2822014 	add	r2, r2, #20
10028bd4:	e1a02c22 	lsr	r2, r2, #24
10028bd8:	e6ef2072 	uxtb	r2, r2
10028bdc:	e5c32000 	strb	r2, [r3]
10028be0:	e3033594 	movw	r3, #13716	; 0x3594
10028be4:	e3413004 	movt	r3, #4100	; 0x1004
10028be8:	e5933000 	ldr	r3, [r3]
10028bec:	e2832004 	add	r2, r3, #4
10028bf0:	e3033594 	movw	r3, #13716	; 0x3594
10028bf4:	e3413004 	movt	r3, #4100	; 0x1004
10028bf8:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10028bfc:	e3033594 	movw	r3, #13716	; 0x3594
10028c00:	e3413004 	movt	r3, #4100	; 0x1004
10028c04:	e5933000 	ldr	r3, [r3]
10028c08:	e3a02024 	mov	r2, #36	; 0x24
10028c0c:	e5c32000 	strb	r2, [r3]
10028c10:	e3033594 	movw	r3, #13716	; 0x3594
10028c14:	e3413004 	movt	r3, #4100	; 0x1004
10028c18:	e5933000 	ldr	r3, [r3]
10028c1c:	e2832001 	add	r2, r3, #1
10028c20:	e3033594 	movw	r3, #13716	; 0x3594
10028c24:	e3413004 	movt	r3, #4100	; 0x1004
10028c28:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
10028c2c:	e3033594 	movw	r3, #13716	; 0x3594
10028c30:	e3413004 	movt	r3, #4100	; 0x1004
10028c34:	e5933000 	ldr	r3, [r3]
10028c38:	e3a02001 	mov	r2, #1
10028c3c:	e5c32000 	strb	r2, [r3]
10028c40:	e3033594 	movw	r3, #13716	; 0x3594
10028c44:	e3413004 	movt	r3, #4100	; 0x1004
10028c48:	e5933000 	ldr	r3, [r3]
10028c4c:	e2833001 	add	r3, r3, #1
10028c50:	e3a02000 	mov	r2, #0
10028c54:	e5c32000 	strb	r2, [r3]
10028c58:	e3033594 	movw	r3, #13716	; 0x3594
10028c5c:	e3413004 	movt	r3, #4100	; 0x1004
10028c60:	e5933000 	ldr	r3, [r3]
10028c64:	e2833002 	add	r3, r3, #2
10028c68:	e3a02000 	mov	r2, #0
10028c6c:	e5c32000 	strb	r2, [r3]
10028c70:	e3033594 	movw	r3, #13716	; 0x3594
10028c74:	e3413004 	movt	r3, #4100	; 0x1004
10028c78:	e5933000 	ldr	r3, [r3]
10028c7c:	e2833003 	add	r3, r3, #3
10028c80:	e3a02000 	mov	r2, #0
10028c84:	e5c32000 	strb	r2, [r3]
10028c88:	e3033594 	movw	r3, #13716	; 0x3594
10028c8c:	e3413004 	movt	r3, #4100	; 0x1004
10028c90:	e5933000 	ldr	r3, [r3]
10028c94:	e2832004 	add	r2, r3, #4
10028c98:	e3033594 	movw	r3, #13716	; 0x3594
10028c9c:	e3413004 	movt	r3, #4100	; 0x1004
10028ca0:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
10028ca4:	e3033594 	movw	r3, #13716	; 0x3594
10028ca8:	e3413004 	movt	r3, #4100	; 0x1004
10028cac:	e5933000 	ldr	r3, [r3]
10028cb0:	e3a02006 	mov	r2, #6
10028cb4:	e5c32000 	strb	r2, [r3]
10028cb8:	e3033594 	movw	r3, #13716	; 0x3594
10028cbc:	e3413004 	movt	r3, #4100	; 0x1004
10028cc0:	e5933000 	ldr	r3, [r3]
10028cc4:	e2832001 	add	r2, r3, #1
10028cc8:	e3033594 	movw	r3, #13716	; 0x3594
10028ccc:	e3413004 	movt	r3, #4100	; 0x1004
10028cd0:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10028cd4:	e3033594 	movw	r3, #13716	; 0x3594
10028cd8:	e3413004 	movt	r3, #4100	; 0x1004
10028cdc:	e5933000 	ldr	r3, [r3]
10028ce0:	e3a0202a 	mov	r2, #42	; 0x2a
10028ce4:	e5c32000 	strb	r2, [r3]
10028ce8:	e3033594 	movw	r3, #13716	; 0x3594
10028cec:	e3413004 	movt	r3, #4100	; 0x1004
10028cf0:	e5933000 	ldr	r3, [r3]
10028cf4:	e2832001 	add	r2, r3, #1
10028cf8:	e3033594 	movw	r3, #13716	; 0x3594
10028cfc:	e3413004 	movt	r3, #4100	; 0x1004
10028d00:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
10028d04:	e3033594 	movw	r3, #13716	; 0x3594
10028d08:	e3413004 	movt	r3, #4100	; 0x1004
10028d0c:	e5933000 	ldr	r3, [r3]
10028d10:	e3a0202b 	mov	r2, #43	; 0x2b
10028d14:	e5c32000 	strb	r2, [r3]
10028d18:	e3033594 	movw	r3, #13716	; 0x3594
10028d1c:	e3413004 	movt	r3, #4100	; 0x1004
10028d20:	e5933000 	ldr	r3, [r3]
10028d24:	e2832001 	add	r2, r3, #1
10028d28:	e3033594 	movw	r3, #13716	; 0x3594
10028d2c:	e3413004 	movt	r3, #4100	; 0x1004
10028d30:	e5832000 	str	r2, [r3]
                    break;
10028d34:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
10028d38:	ea00005a 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_NULL:
            finsh_code_dword(0);
10028d3c:	e3033594 	movw	r3, #13716	; 0x3594
10028d40:	e3413004 	movt	r3, #4100	; 0x1004
10028d44:	e5933000 	ldr	r3, [r3]
10028d48:	e3a02000 	mov	r2, #0
10028d4c:	e5c32000 	strb	r2, [r3]
10028d50:	e3033594 	movw	r3, #13716	; 0x3594
10028d54:	e3413004 	movt	r3, #4100	; 0x1004
10028d58:	e5933000 	ldr	r3, [r3]
10028d5c:	e2833001 	add	r3, r3, #1
10028d60:	e3a02000 	mov	r2, #0
10028d64:	e5c32000 	strb	r2, [r3]
10028d68:	e3033594 	movw	r3, #13716	; 0x3594
10028d6c:	e3413004 	movt	r3, #4100	; 0x1004
10028d70:	e5933000 	ldr	r3, [r3]
10028d74:	e2833002 	add	r3, r3, #2
10028d78:	e3a02000 	mov	r2, #0
10028d7c:	e5c32000 	strb	r2, [r3]
10028d80:	e3033594 	movw	r3, #13716	; 0x3594
10028d84:	e3413004 	movt	r3, #4100	; 0x1004
10028d88:	e5933000 	ldr	r3, [r3]
10028d8c:	e2833003 	add	r3, r3, #3
10028d90:	e3a02000 	mov	r2, #0
10028d94:	e5c32000 	strb	r2, [r3]
10028d98:	e3033594 	movw	r3, #13716	; 0x3594
10028d9c:	e3413004 	movt	r3, #4100	; 0x1004
10028da0:	e5933000 	ldr	r3, [r3]
10028da4:	e2832004 	add	r2, r3, #4
10028da8:	e3033594 	movw	r3, #13716	; 0x3594
10028dac:	e3413004 	movt	r3, #4100	; 0x1004
10028db0:	e5832000 	str	r2, [r3]
            break;
10028db4:	ea00003b 	b	10028ea8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_GETVALUE:
            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10028db8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10028dbc:	e5d33002 	ldrb	r3, [r3, #2]
10028dc0:	e2033008 	and	r3, r3, #8
10028dc4:	e3530000 	cmp	r3, #0
10028dc8:	1a00002f 	bne	10028e8c <finsh_compile+0x36b0>
            {
                /* nothing will be generated */
            }
            else
            {
                switch (node->data_type)
10028dcc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10028dd0:	e5d33001 	ldrb	r3, [r3, #1]
10028dd4:	e3530002 	cmp	r3, #2
10028dd8:	0a000011 	beq	10028e24 <finsh_compile+0x3648>
10028ddc:	e3530003 	cmp	r3, #3
10028de0:	0a00001c 	beq	10028e58 <finsh_compile+0x367c>
10028de4:	e3530001 	cmp	r3, #1
10028de8:	0a000000 	beq	10028df0 <finsh_compile+0x3614>
                    break;
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
                    break;
                default:
                    break;
10028dec:	ea000026 	b	10028e8c <finsh_compile+0x36b0>
            else
            {
                switch (node->data_type)
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
10028df0:	e3033594 	movw	r3, #13716	; 0x3594
10028df4:	e3413004 	movt	r3, #4100	; 0x1004
10028df8:	e5933000 	ldr	r3, [r3]
10028dfc:	e3a0202d 	mov	r2, #45	; 0x2d
10028e00:	e5c32000 	strb	r2, [r3]
10028e04:	e3033594 	movw	r3, #13716	; 0x3594
10028e08:	e3413004 	movt	r3, #4100	; 0x1004
10028e0c:	e5933000 	ldr	r3, [r3]
10028e10:	e2832001 	add	r2, r3, #1
10028e14:	e3033594 	movw	r3, #13716	; 0x3594
10028e18:	e3413004 	movt	r3, #4100	; 0x1004
10028e1c:	e5832000 	str	r2, [r3]
                    break;
10028e20:	ea000019 	b	10028e8c <finsh_compile+0x36b0>
                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
10028e24:	e3033594 	movw	r3, #13716	; 0x3594
10028e28:	e3413004 	movt	r3, #4100	; 0x1004
10028e2c:	e5933000 	ldr	r3, [r3]
10028e30:	e3a0202e 	mov	r2, #46	; 0x2e
10028e34:	e5c32000 	strb	r2, [r3]
10028e38:	e3033594 	movw	r3, #13716	; 0x3594
10028e3c:	e3413004 	movt	r3, #4100	; 0x1004
10028e40:	e5933000 	ldr	r3, [r3]
10028e44:	e2832001 	add	r2, r3, #1
10028e48:	e3033594 	movw	r3, #13716	; 0x3594
10028e4c:	e3413004 	movt	r3, #4100	; 0x1004
10028e50:	e5832000 	str	r2, [r3]
                    break;
10028e54:	ea00000c 	b	10028e8c <finsh_compile+0x36b0>
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10028e58:	e3033594 	movw	r3, #13716	; 0x3594
10028e5c:	e3413004 	movt	r3, #4100	; 0x1004
10028e60:	e5933000 	ldr	r3, [r3]
10028e64:	e3a0202f 	mov	r2, #47	; 0x2f
10028e68:	e5c32000 	strb	r2, [r3]
10028e6c:	e3033594 	movw	r3, #13716	; 0x3594
10028e70:	e3413004 	movt	r3, #4100	; 0x1004
10028e74:	e5933000 	ldr	r3, [r3]
10028e78:	e2832001 	add	r2, r3, #1
10028e7c:	e3033594 	movw	r3, #13716	; 0x3594
10028e80:	e3413004 	movt	r3, #4100	; 0x1004
10028e84:	e5832000 	str	r2, [r3]
                    break;
10028e88:	e1a00000 	nop			; (mov r0, r0)
                default:
                    break;
                }
            }
            break;
10028e8c:	ea000005 	b	10028ea8 <finsh_compile+0x36cc>
        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;

        default:
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
10028e90:	e3a00008 	mov	r0, #8
10028e94:	eb000136 	bl	10029374 <finsh_error_set>
            break;
10028e98:	ea000002 	b	10028ea8 <finsh_compile+0x36cc>
            }
            break;

        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;
10028e9c:	e1a00000 	nop			; (mov r0, r0)
10028ea0:	ea000000 	b	10028ea8 <finsh_compile+0x36cc>
                            break;
                        }
                    }
                }
            }
            break;
10028ea4:	e1a00000 	nop			; (mov r0, r0)
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
            break;
        }

        /* compile sibling node */
        if (finsh_node_sibling(node) != NULL)
10028ea8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10028eac:	e593300c 	ldr	r3, [r3, #12]
10028eb0:	e3530000 	cmp	r3, #0
10028eb4:	0a000003 	beq	10028ec8 <finsh_compile+0x36ec>
            finsh_compile(finsh_node_sibling(node));
10028eb8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10028ebc:	e593300c 	ldr	r3, [r3, #12]
10028ec0:	e1a00003 	mov	r0, r3
10028ec4:	ebfff244 	bl	100257dc <finsh_compile>
    }

    return 0;
10028ec8:	e3a03000 	mov	r3, #0
}
10028ecc:	e1a00003 	mov	r0, r3
10028ed0:	e24bd004 	sub	sp, fp, #4
10028ed4:	e8bd8800 	pop	{fp, pc}

10028ed8 <finsh_type_check>:

static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
10028ed8:	e92d4800 	push	{fp, lr}
10028edc:	e28db004 	add	fp, sp, #4
10028ee0:	e24dd010 	sub	sp, sp, #16
10028ee4:	e50b0010 	str	r0, [fp, #-16]
10028ee8:	e1a03001 	mov	r3, r1
10028eec:	e54b3011 	strb	r3, [fp, #-17]
    if (node != NULL)
10028ef0:	e51b3010 	ldr	r3, [fp, #-16]
10028ef4:	e3530000 	cmp	r3, #0
10028ef8:	0a0000d0 	beq	10029240 <finsh_type_check+0x368>
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
10028efc:	e51b3010 	ldr	r3, [fp, #-16]
10028f00:	e5d33000 	ldrb	r3, [r3]
10028f04:	e3530013 	cmp	r3, #19
10028f08:	0a00000b 	beq	10028f3c <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREINC ||
10028f0c:	e51b3010 	ldr	r3, [fp, #-16]
10028f10:	e5d33000 	ldrb	r3, [r3]
static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
10028f14:	e3530015 	cmp	r3, #21
10028f18:	0a000007 	beq	10028f3c <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
10028f1c:	e51b3010 	ldr	r3, [fp, #-16]
10028f20:	e5d33000 	ldrb	r3, [r3]
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
10028f24:	e3530016 	cmp	r3, #22
10028f28:	0a000003 	beq	10028f3c <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREDEC ||
            node->node_type == FINSH_NODE_SYS_GETADDR)
10028f2c:	e51b3010 	ldr	r3, [fp, #-16]
10028f30:	e5d33000 	ldrb	r3, [r3]
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
10028f34:	e353001a 	cmp	r3, #26
10028f38:	1a000005 	bne	10028f54 <finsh_type_check+0x7c>
            node->node_type == FINSH_NODE_SYS_GETADDR)
        {
            /* address */
            finsh_type_check(finsh_node_child(node), FINSH_IDTYPE_ADDRESS);
10028f3c:	e51b3010 	ldr	r3, [fp, #-16]
10028f40:	e5933010 	ldr	r3, [r3, #16]
10028f44:	e1a00003 	mov	r0, r3
10028f48:	e3a01008 	mov	r1, #8
10028f4c:	ebffffe1 	bl	10028ed8 <finsh_type_check>
10028f50:	ea000012 	b	10028fa0 <finsh_type_check+0xc8>
        }
        else if (node->node_type == FINSH_NODE_SYS_GETVALUE && is_addr)
10028f54:	e51b3010 	ldr	r3, [fp, #-16]
10028f58:	e5d33000 	ldrb	r3, [r3]
10028f5c:	e3530019 	cmp	r3, #25
10028f60:	1a000008 	bne	10028f88 <finsh_type_check+0xb0>
10028f64:	e55b3011 	ldrb	r3, [fp, #-17]
10028f68:	e3530000 	cmp	r3, #0
10028f6c:	0a000005 	beq	10028f88 <finsh_type_check+0xb0>
        {
            /* change the attribute of getvalue in left expr */
            finsh_type_check(finsh_node_child(node), 0);
10028f70:	e51b3010 	ldr	r3, [fp, #-16]
10028f74:	e5933010 	ldr	r3, [r3, #16]
10028f78:	e1a00003 	mov	r0, r3
10028f7c:	e3a01000 	mov	r1, #0
10028f80:	ebffffd4 	bl	10028ed8 <finsh_type_check>
10028f84:	ea000005 	b	10028fa0 <finsh_type_check+0xc8>
        }
        else
        {
            /* transfer 'av' to child node */
            finsh_type_check(finsh_node_child(node), is_addr);
10028f88:	e51b3010 	ldr	r3, [fp, #-16]
10028f8c:	e5932010 	ldr	r2, [r3, #16]
10028f90:	e55b3011 	ldrb	r3, [fp, #-17]
10028f94:	e1a00002 	mov	r0, r2
10028f98:	e1a01003 	mov	r1, r3
10028f9c:	ebffffcd 	bl	10028ed8 <finsh_type_check>
        }

        /* always does not load address in sibling */
        finsh_type_check(finsh_node_sibling(node), FINSH_NODE_VALUE);
10028fa0:	e51b3010 	ldr	r3, [fp, #-16]
10028fa4:	e593300c 	ldr	r3, [r3, #12]
10028fa8:	e1a00003 	mov	r0, r3
10028fac:	e3a01000 	mov	r1, #0
10028fb0:	ebffffc8 	bl	10028ed8 <finsh_type_check>

        /** set attribute of current node */

        /* make sure the current node is address or value */
        if (node->idtype != FINSH_IDTYPE_SYSCALL) node->idtype |= is_addr;
10028fb4:	e51b3010 	ldr	r3, [fp, #-16]
10028fb8:	e5d33002 	ldrb	r3, [r3, #2]
10028fbc:	e3530004 	cmp	r3, #4
10028fc0:	0a000006 	beq	10028fe0 <finsh_type_check+0x108>
10028fc4:	e51b3010 	ldr	r3, [fp, #-16]
10028fc8:	e5d32002 	ldrb	r2, [r3, #2]
10028fcc:	e55b3011 	ldrb	r3, [fp, #-17]
10028fd0:	e1823003 	orr	r3, r2, r3
10028fd4:	e6ef2073 	uxtb	r2, r3
10028fd8:	e51b3010 	ldr	r3, [fp, #-16]
10028fdc:	e5c32002 	strb	r2, [r3, #2]

        if (finsh_node_child(node) != NULL)
10028fe0:	e51b3010 	ldr	r3, [fp, #-16]
10028fe4:	e5933010 	ldr	r3, [r3, #16]
10028fe8:	e3530000 	cmp	r3, #0
10028fec:	0a000006 	beq	1002900c <finsh_type_check+0x134>
        {
            node->data_type = finsh_node_child(node)->data_type;
10028ff0:	e51b3010 	ldr	r3, [fp, #-16]
10028ff4:	e5933010 	ldr	r3, [r3, #16]
10028ff8:	e5d32001 	ldrb	r2, [r3, #1]
10028ffc:	e51b3010 	ldr	r3, [fp, #-16]
10029000:	e5c32001 	strb	r2, [r3, #1]
            return 0;
10029004:	e3a03000 	mov	r3, #0
10029008:	ea00008d 	b	10029244 <finsh_type_check+0x36c>
        }

        if (node->node_type == FINSH_NODE_ID)
1002900c:	e51b3010 	ldr	r3, [fp, #-16]
10029010:	e5d33000 	ldrb	r3, [r3]
10029014:	e3530001 	cmp	r3, #1
10029018:	1a00006d 	bne	100291d4 <finsh_type_check+0x2fc>
        {
            if (node->idtype & FINSH_IDTYPE_VAR)
1002901c:	e51b3010 	ldr	r3, [fp, #-16]
10029020:	e5d33002 	ldrb	r3, [r3, #2]
10029024:	e2033001 	and	r3, r3, #1
10029028:	e3530000 	cmp	r3, #0
1002902c:	0a000031 	beq	100290f8 <finsh_type_check+0x220>
            {
                struct finsh_var* var;

                var = node->id.var;
10029030:	e51b3010 	ldr	r3, [fp, #-16]
10029034:	e5933008 	ldr	r3, [r3, #8]
10029038:	e50b3008 	str	r3, [fp, #-8]
                if (var != NULL)
1002903c:	e51b3008 	ldr	r3, [fp, #-8]
10029040:	e3530000 	cmp	r3, #0
10029044:	0a00002a 	beq	100290f4 <finsh_type_check+0x21c>
                {
                    switch (var->type)
10029048:	e51b3008 	ldr	r3, [fp, #-8]
1002904c:	e5d33011 	ldrb	r3, [r3, #17]
10029050:	e2433001 	sub	r3, r3, #1
10029054:	e353000d 	cmp	r3, #13
10029058:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002905c:	ea000021 	b	100290e8 <finsh_type_check+0x210>
10029060:	10029098 	.word	0x10029098
10029064:	100290d8 	.word	0x100290d8
10029068:	100290a8 	.word	0x100290a8
1002906c:	100290a8 	.word	0x100290a8
10029070:	100290d8 	.word	0x100290d8
10029074:	100290b8 	.word	0x100290b8
10029078:	100290b8 	.word	0x100290b8
1002907c:	100290d8 	.word	0x100290d8
10029080:	100290c8 	.word	0x100290c8
10029084:	100290c8 	.word	0x100290c8
10029088:	100290d8 	.word	0x100290d8
1002908c:	100290c8 	.word	0x100290c8
10029090:	100290c8 	.word	0x100290c8
10029094:	100290d8 	.word	0x100290d8
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
10029098:	e51b3010 	ldr	r3, [fp, #-16]
1002909c:	e3a02000 	mov	r2, #0
100290a0:	e5c32001 	strb	r2, [r3, #1]
                        break;
100290a4:	ea000012 	b	100290f4 <finsh_type_check+0x21c>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
100290a8:	e51b3010 	ldr	r3, [fp, #-16]
100290ac:	e3a02001 	mov	r2, #1
100290b0:	e5c32001 	strb	r2, [r3, #1]
                        break;
100290b4:	ea00000e 	b	100290f4 <finsh_type_check+0x21c>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
100290b8:	e51b3010 	ldr	r3, [fp, #-16]
100290bc:	e3a02002 	mov	r2, #2
100290c0:	e5c32001 	strb	r2, [r3, #1]
                        break;
100290c4:	ea00000a 	b	100290f4 <finsh_type_check+0x21c>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
100290c8:	e51b3010 	ldr	r3, [fp, #-16]
100290cc:	e3a02003 	mov	r2, #3
100290d0:	e5c32001 	strb	r2, [r3, #1]
                        break;
100290d4:	ea000006 	b	100290f4 <finsh_type_check+0x21c>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
100290d8:	e51b3010 	ldr	r3, [fp, #-16]
100290dc:	e3a02003 	mov	r2, #3
100290e0:	e5c32001 	strb	r2, [r3, #1]
                        break;
100290e4:	ea000002 	b	100290f4 <finsh_type_check+0x21c>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
100290e8:	e3a00003 	mov	r0, #3
100290ec:	eb0000a0 	bl	10029374 <finsh_error_set>
                        break;
100290f0:	e1a00000 	nop			; (mov r0, r0)
100290f4:	ea000051 	b	10029240 <finsh_type_check+0x368>
                    }
                }
            }
            else if (node->idtype & FINSH_IDTYPE_SYSVAR)
100290f8:	e51b3010 	ldr	r3, [fp, #-16]
100290fc:	e5d33002 	ldrb	r3, [r3, #2]
10029100:	e2033002 	and	r3, r3, #2
10029104:	e3530000 	cmp	r3, #0
10029108:	0a000030 	beq	100291d0 <finsh_type_check+0x2f8>
            {
                struct finsh_sysvar *sysvar;

                sysvar = node->id.sysvar;
1002910c:	e51b3010 	ldr	r3, [fp, #-16]
10029110:	e5933008 	ldr	r3, [r3, #8]
10029114:	e50b300c 	str	r3, [fp, #-12]
                if (sysvar != NULL)
10029118:	e51b300c 	ldr	r3, [fp, #-12]
1002911c:	e3530000 	cmp	r3, #0
10029120:	0a00002a 	beq	100291d0 <finsh_type_check+0x2f8>
                {
                    switch (sysvar->type)
10029124:	e51b300c 	ldr	r3, [fp, #-12]
10029128:	e5d33008 	ldrb	r3, [r3, #8]
1002912c:	e2433001 	sub	r3, r3, #1
10029130:	e353000d 	cmp	r3, #13
10029134:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10029138:	ea000021 	b	100291c4 <finsh_type_check+0x2ec>
1002913c:	10029174 	.word	0x10029174
10029140:	100291b4 	.word	0x100291b4
10029144:	10029184 	.word	0x10029184
10029148:	10029184 	.word	0x10029184
1002914c:	100291b4 	.word	0x100291b4
10029150:	10029194 	.word	0x10029194
10029154:	10029194 	.word	0x10029194
10029158:	100291b4 	.word	0x100291b4
1002915c:	100291a4 	.word	0x100291a4
10029160:	100291a4 	.word	0x100291a4
10029164:	100291b4 	.word	0x100291b4
10029168:	100291a4 	.word	0x100291a4
1002916c:	100291a4 	.word	0x100291a4
10029170:	100291b4 	.word	0x100291b4
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
10029174:	e51b3010 	ldr	r3, [fp, #-16]
10029178:	e3a02000 	mov	r2, #0
1002917c:	e5c32001 	strb	r2, [r3, #1]
                        break;
10029180:	ea000012 	b	100291d0 <finsh_type_check+0x2f8>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
10029184:	e51b3010 	ldr	r3, [fp, #-16]
10029188:	e3a02001 	mov	r2, #1
1002918c:	e5c32001 	strb	r2, [r3, #1]
                        break;
10029190:	ea00000e 	b	100291d0 <finsh_type_check+0x2f8>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
10029194:	e51b3010 	ldr	r3, [fp, #-16]
10029198:	e3a02002 	mov	r2, #2
1002919c:	e5c32001 	strb	r2, [r3, #1]
                        break;
100291a0:	ea00000a 	b	100291d0 <finsh_type_check+0x2f8>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
100291a4:	e51b3010 	ldr	r3, [fp, #-16]
100291a8:	e3a02003 	mov	r2, #3
100291ac:	e5c32001 	strb	r2, [r3, #1]
                        break;
100291b0:	ea000006 	b	100291d0 <finsh_type_check+0x2f8>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
100291b4:	e51b3010 	ldr	r3, [fp, #-16]
100291b8:	e3a02003 	mov	r2, #3
100291bc:	e5c32001 	strb	r2, [r3, #1]
                        break;
100291c0:	ea000002 	b	100291d0 <finsh_type_check+0x2f8>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
100291c4:	e3a00003 	mov	r0, #3
100291c8:	eb000069 	bl	10029374 <finsh_error_set>
                        break;
100291cc:	e1a00000 	nop			; (mov r0, r0)
100291d0:	ea00001a 	b	10029240 <finsh_type_check+0x368>
                    }
                }
            }
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
100291d4:	e51b3010 	ldr	r3, [fp, #-16]
100291d8:	e5d33000 	ldrb	r3, [r3]
100291dc:	e3530002 	cmp	r3, #2
100291e0:	1a000003 	bne	100291f4 <finsh_type_check+0x31c>
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
100291e4:	e51b3010 	ldr	r3, [fp, #-16]
100291e8:	e3a02001 	mov	r2, #1
100291ec:	e5c32001 	strb	r2, [r3, #1]
100291f0:	ea000012 	b	10029240 <finsh_type_check+0x368>
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
100291f4:	e51b3010 	ldr	r3, [fp, #-16]
100291f8:	e5d33000 	ldrb	r3, [r3]
100291fc:	e3530003 	cmp	r3, #3
10029200:	0a00000b 	beq	10029234 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
10029204:	e51b3010 	ldr	r3, [fp, #-16]
10029208:	e5d33000 	ldrb	r3, [r3]
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
1002920c:	e3530004 	cmp	r3, #4
10029210:	0a000007 	beq	10029234 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
10029214:	e51b3010 	ldr	r3, [fp, #-16]
10029218:	e5d33000 	ldrb	r3, [r3]
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
1002921c:	e3530005 	cmp	r3, #5
10029220:	0a000003 	beq	10029234 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_STRING  ||
            node->node_type == FINSH_NODE_VALUE_NULL)
10029224:	e51b3010 	ldr	r3, [fp, #-16]
10029228:	e5d33000 	ldrb	r3, [r3]
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
1002922c:	e3530006 	cmp	r3, #6
10029230:	1a000002 	bne	10029240 <finsh_type_check+0x368>
            node->node_type == FINSH_NODE_VALUE_NULL)
        {
            node->data_type = FINSH_DATA_TYPE_DWORD;
10029234:	e51b3010 	ldr	r3, [fp, #-16]
10029238:	e3a02003 	mov	r2, #3
1002923c:	e5c32001 	strb	r2, [r3, #1]
        }
    }
    return 0;
10029240:	e3a03000 	mov	r3, #0
}
10029244:	e1a00003 	mov	r0, r3
10029248:	e24bd004 	sub	sp, fp, #4
1002924c:	e8bd8800 	pop	{fp, pc}

10029250 <finsh_compiler_run>:

int finsh_compiler_run(struct finsh_node* node)
{
10029250:	e92d4800 	push	{fp, lr}
10029254:	e28db004 	add	fp, sp, #4
10029258:	e24dd010 	sub	sp, sp, #16
1002925c:	e50b0010 	str	r0, [fp, #-16]
    struct finsh_node* sibling;

    /* type check */
    finsh_type_check(node, FINSH_NODE_VALUE);
10029260:	e51b0010 	ldr	r0, [fp, #-16]
10029264:	e3a01000 	mov	r1, #0
10029268:	ebffff1a 	bl	10028ed8 <finsh_type_check>

    /* clean text segment and vm stack */
    memset(&text_segment[0], 0, sizeof(text_segment));
1002926c:	e3030824 	movw	r0, #14372	; 0x3824
10029270:	e3410004 	movt	r0, #4100	; 0x1004
10029274:	e3a01000 	mov	r1, #0
10029278:	e3a02080 	mov	r2, #128	; 0x80
1002927c:	fa001846 	blx	1002f39c <memset>
    memset(&finsh_vm_stack[0], 0, sizeof(finsh_vm_stack[0]));
10029280:	e30308a4 	movw	r0, #14500	; 0x38a4
10029284:	e3410004 	movt	r0, #4100	; 0x1004
10029288:	e3a01000 	mov	r1, #0
1002928c:	e3a02004 	mov	r2, #4
10029290:	fa001841 	blx	1002f39c <memset>

    /* reset compile stack pointer and pc */
    finsh_compile_sp = &finsh_vm_stack[0];
10029294:	e3033598 	movw	r3, #13720	; 0x3598
10029298:	e3413004 	movt	r3, #4100	; 0x1004
1002929c:	e30328a4 	movw	r2, #14500	; 0x38a4
100292a0:	e3412004 	movt	r2, #4100	; 0x1004
100292a4:	e5832000 	str	r2, [r3]
    finsh_compile_pc = &text_segment[0];
100292a8:	e3033594 	movw	r3, #13716	; 0x3594
100292ac:	e3413004 	movt	r3, #4100	; 0x1004
100292b0:	e3032824 	movw	r2, #14372	; 0x3824
100292b4:	e3412004 	movt	r2, #4100	; 0x1004
100292b8:	e5832000 	str	r2, [r3]

    /* compile node */
    sibling = node;
100292bc:	e51b3010 	ldr	r3, [fp, #-16]
100292c0:	e50b3008 	str	r3, [fp, #-8]
    while (sibling != NULL)
100292c4:	ea000018 	b	1002932c <finsh_compiler_run+0xdc>
    {
        struct finsh_node* current_node;
        current_node = sibling;
100292c8:	e51b3008 	ldr	r3, [fp, #-8]
100292cc:	e50b300c 	str	r3, [fp, #-12]

        /* get sibling node */
        sibling = current_node->sibling;
100292d0:	e51b300c 	ldr	r3, [fp, #-12]
100292d4:	e593300c 	ldr	r3, [r3, #12]
100292d8:	e50b3008 	str	r3, [fp, #-8]

        /* clean sibling node */
        current_node->sibling = NULL;
100292dc:	e51b300c 	ldr	r3, [fp, #-12]
100292e0:	e3a02000 	mov	r2, #0
100292e4:	e583200c 	str	r2, [r3, #12]
        finsh_compile(current_node);
100292e8:	e51b000c 	ldr	r0, [fp, #-12]
100292ec:	ebfff13a 	bl	100257dc <finsh_compile>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
100292f0:	e51b3008 	ldr	r3, [fp, #-8]
100292f4:	e3530000 	cmp	r3, #0
100292f8:	0a00000b 	beq	1002932c <finsh_compiler_run+0xdc>
100292fc:	e3033594 	movw	r3, #13716	; 0x3594
10029300:	e3413004 	movt	r3, #4100	; 0x1004
10029304:	e5933000 	ldr	r3, [r3]
10029308:	e3a0202b 	mov	r2, #43	; 0x2b
1002930c:	e5c32000 	strb	r2, [r3]
10029310:	e3033594 	movw	r3, #13716	; 0x3594
10029314:	e3413004 	movt	r3, #4100	; 0x1004
10029318:	e5933000 	ldr	r3, [r3]
1002931c:	e2832001 	add	r2, r3, #1
10029320:	e3033594 	movw	r3, #13716	; 0x3594
10029324:	e3413004 	movt	r3, #4100	; 0x1004
10029328:	e5832000 	str	r2, [r3]
    finsh_compile_sp = &finsh_vm_stack[0];
    finsh_compile_pc = &text_segment[0];

    /* compile node */
    sibling = node;
    while (sibling != NULL)
1002932c:	e51b3008 	ldr	r3, [fp, #-8]
10029330:	e3530000 	cmp	r3, #0
10029334:	1affffe3 	bne	100292c8 <finsh_compiler_run+0x78>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
    }

    return 0;
10029338:	e3a03000 	mov	r3, #0
}
1002933c:	e1a00003 	mov	r0, r3
10029340:	e24bd004 	sub	sp, fp, #4
10029344:	e8bd8800 	pop	{fp, pc}

10029348 <finsh_error_init>:
	"Unknown symbol",
	"Null node"
};

int finsh_error_init()
{
10029348:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002934c:	e28db000 	add	fp, sp, #0
	global_errno = FINSH_ERROR_OK;
10029350:	e303359c 	movw	r3, #13724	; 0x359c
10029354:	e3413004 	movt	r3, #4100	; 0x1004
10029358:	e3a02000 	mov	r2, #0
1002935c:	e5c32000 	strb	r2, [r3]

	return 0;
10029360:	e3a03000 	mov	r3, #0
}
10029364:	e1a00003 	mov	r0, r3
10029368:	e24bd000 	sub	sp, fp, #0
1002936c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10029370:	e12fff1e 	bx	lr

10029374 <finsh_error_set>:

int finsh_error_set(u_char type)
{
10029374:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10029378:	e28db000 	add	fp, sp, #0
1002937c:	e24dd00c 	sub	sp, sp, #12
10029380:	e1a03000 	mov	r3, r0
10029384:	e54b3005 	strb	r3, [fp, #-5]
	global_errno = type;
10029388:	e303359c 	movw	r3, #13724	; 0x359c
1002938c:	e3413004 	movt	r3, #4100	; 0x1004
10029390:	e55b2005 	ldrb	r2, [fp, #-5]
10029394:	e5c32000 	strb	r2, [r3]

	return 0;
10029398:	e3a03000 	mov	r3, #0
}
1002939c:	e1a00003 	mov	r0, r3
100293a0:	e24bd000 	sub	sp, fp, #0
100293a4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100293a8:	e12fff1e 	bx	lr

100293ac <finsh_errno>:

u_char finsh_errno()
{
100293ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100293b0:	e28db000 	add	fp, sp, #0
	return global_errno;
100293b4:	e303359c 	movw	r3, #13724	; 0x359c
100293b8:	e3413004 	movt	r3, #4100	; 0x1004
100293bc:	e5d33000 	ldrb	r3, [r3]
}
100293c0:	e1a00003 	mov	r0, r3
100293c4:	e24bd000 	sub	sp, fp, #0
100293c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100293cc:	e12fff1e 	bx	lr

100293d0 <finsh_error_string>:

const char* finsh_error_string(u_char type)
{
100293d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100293d4:	e28db000 	add	fp, sp, #0
100293d8:	e24dd00c 	sub	sp, sp, #12
100293dc:	e1a03000 	mov	r3, r0
100293e0:	e54b3005 	strb	r3, [fp, #-5]
	return finsh_error_string_table[type];
100293e4:	e55b2005 	ldrb	r2, [fp, #-5]
100293e8:	e306394c 	movw	r3, #26956	; 0x694c
100293ec:	e3413003 	movt	r3, #4099	; 0x1003
100293f0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
}
100293f4:	e1a00003 	mov	r0, r3
100293f8:	e24bd000 	sub	sp, fp, #0
100293fc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10029400:	e12fff1e 	bx	lr

10029404 <finsh_heap_init>:
static void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header);
static void finsh_block_split(struct finsh_block_header* header, size_t size);
static void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header);

int finsh_heap_init(void)
{
10029404:	e92d4800 	push	{fp, lr}
10029408:	e28db004 	add	fp, sp, #4
	/* clear heap to zero */
	memset(&finsh_heap[0], 0, sizeof(finsh_heap));
1002940c:	e30305a0 	movw	r0, #13728	; 0x35a0
10029410:	e3410004 	movt	r0, #4100	; 0x1004
10029414:	e3a01000 	mov	r1, #0
10029418:	e3a02080 	mov	r2, #128	; 0x80
1002941c:	fa0017de 	blx	1002f39c <memset>

	/* init free and alloc list */
    free_list           = BLOCK_HEADER(&finsh_heap[0]);
10029420:	e30f3948 	movw	r3, #63816	; 0xf948
10029424:	e3413003 	movt	r3, #4099	; 0x1003
10029428:	e30325a0 	movw	r2, #13728	; 0x35a0
1002942c:	e3412004 	movt	r2, #4100	; 0x1004
10029430:	e5832000 	str	r2, [r3]
	free_list->length   = FINSH_HEAP_MAX - sizeof(struct finsh_block_header);
10029434:	e30f3948 	movw	r3, #63816	; 0xf948
10029438:	e3413003 	movt	r3, #4099	; 0x1003
1002943c:	e5933000 	ldr	r3, [r3]
10029440:	e3a02078 	mov	r2, #120	; 0x78
10029444:	e5832000 	str	r2, [r3]
    free_list->next     = NULL;
10029448:	e30f3948 	movw	r3, #63816	; 0xf948
1002944c:	e3413003 	movt	r3, #4099	; 0x1003
10029450:	e5933000 	ldr	r3, [r3]
10029454:	e3a02000 	mov	r2, #0
10029458:	e5832004 	str	r2, [r3, #4]

    allocate_list       = NULL;
1002945c:	e30f394c 	movw	r3, #63820	; 0xf94c
10029460:	e3413003 	movt	r3, #4099	; 0x1003
10029464:	e3a02000 	mov	r2, #0
10029468:	e5832000 	str	r2, [r3]

    return 0;
1002946c:	e3a03000 	mov	r3, #0
}
10029470:	e1a00003 	mov	r0, r3
10029474:	e8bd8800 	pop	{fp, pc}

10029478 <finsh_heap_allocate>:

/**
 * allocate a block from heap
 */
void* finsh_heap_allocate(size_t size)
{
10029478:	e92d4800 	push	{fp, lr}
1002947c:	e28db004 	add	fp, sp, #4
10029480:	e24dd010 	sub	sp, sp, #16
10029484:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);
10029488:	e51b3010 	ldr	r3, [fp, #-16]
1002948c:	e2833003 	add	r3, r3, #3
10029490:	e3c33003 	bic	r3, r3, #3
10029494:	e50b3010 	str	r3, [fp, #-16]

    /* find the first fit block */
    for (header = free_list;
10029498:	e30f3948 	movw	r3, #63816	; 0xf948
1002949c:	e3413003 	movt	r3, #4099	; 0x1003
100294a0:	e5933000 	ldr	r3, [r3]
100294a4:	e50b3008 	str	r3, [fp, #-8]
100294a8:	ea000002 	b	100294b8 <finsh_heap_allocate+0x40>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
        header = header->next) ;
100294ac:	e51b3008 	ldr	r3, [fp, #-8]
100294b0:	e5933004 	ldr	r3, [r3, #4]
100294b4:	e50b3008 	str	r3, [fp, #-8]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);

    /* find the first fit block */
    for (header = free_list;
100294b8:	e51b3008 	ldr	r3, [fp, #-8]
100294bc:	e3530000 	cmp	r3, #0
100294c0:	0a000005 	beq	100294dc <finsh_heap_allocate+0x64>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
100294c4:	e51b3008 	ldr	r3, [fp, #-8]
100294c8:	e5932000 	ldr	r2, [r3]
100294cc:	e51b3010 	ldr	r3, [fp, #-16]
100294d0:	e2833008 	add	r3, r3, #8
100294d4:	e1520003 	cmp	r2, r3
100294d8:	9afffff3 	bls	100294ac <finsh_heap_allocate+0x34>
        header = header->next) ;

	if (header == NULL)
100294dc:	e51b3008 	ldr	r3, [fp, #-8]
100294e0:	e3530000 	cmp	r3, #0
100294e4:	1a000016 	bne	10029544 <finsh_heap_allocate+0xcc>
	{
		finsh_heap_gc();
100294e8:	eb000043 	bl	100295fc <finsh_heap_gc>

		/* find the first fit block */
		for (header = free_list;
100294ec:	e30f3948 	movw	r3, #63816	; 0xf948
100294f0:	e3413003 	movt	r3, #4099	; 0x1003
100294f4:	e5933000 	ldr	r3, [r3]
100294f8:	e50b3008 	str	r3, [fp, #-8]
100294fc:	ea000002 	b	1002950c <finsh_heap_allocate+0x94>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
			header = header->next) ;
10029500:	e51b3008 	ldr	r3, [fp, #-8]
10029504:	e5933004 	ldr	r3, [r3, #4]
10029508:	e50b3008 	str	r3, [fp, #-8]
	if (header == NULL)
	{
		finsh_heap_gc();

		/* find the first fit block */
		for (header = free_list;
1002950c:	e51b3008 	ldr	r3, [fp, #-8]
10029510:	e3530000 	cmp	r3, #0
10029514:	0a000005 	beq	10029530 <finsh_heap_allocate+0xb8>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
10029518:	e51b3008 	ldr	r3, [fp, #-8]
1002951c:	e5932000 	ldr	r2, [r3]
10029520:	e51b3010 	ldr	r3, [fp, #-16]
10029524:	e2833008 	add	r3, r3, #8
10029528:	e1520003 	cmp	r2, r3
1002952c:	3afffff3 	bcc	10029500 <finsh_heap_allocate+0x88>
			header = header->next) ;

		/* there is no memory */
		if (header == NULL) return NULL;
10029530:	e51b3008 	ldr	r3, [fp, #-8]
10029534:	e3530000 	cmp	r3, #0
10029538:	1a000001 	bne	10029544 <finsh_heap_allocate+0xcc>
1002953c:	e3a03000 	mov	r3, #0
10029540:	ea000015 	b	1002959c <finsh_heap_allocate+0x124>
	}

    /* split block */
	finsh_block_split(header, size);
10029544:	e51b0008 	ldr	r0, [fp, #-8]
10029548:	e51b1010 	ldr	r1, [fp, #-16]
1002954c:	eb0000d4 	bl	100298a4 <finsh_block_split>

	/* remove from free list */
	finsh_block_remove(&free_list, header);
10029550:	e30f0948 	movw	r0, #63816	; 0xf948
10029554:	e3410003 	movt	r0, #4099	; 0x1003
10029558:	e51b1008 	ldr	r1, [fp, #-8]
1002955c:	eb0000a5 	bl	100297f8 <finsh_block_remove>
	header->next = NULL;
10029560:	e51b3008 	ldr	r3, [fp, #-8]
10029564:	e3a02000 	mov	r2, #0
10029568:	e5832004 	str	r2, [r3, #4]

    /* insert to allocate list */
    finsh_block_insert(&allocate_list, header);
1002956c:	e30f094c 	movw	r0, #63820	; 0xf94c
10029570:	e3410003 	movt	r0, #4099	; 0x1003
10029574:	e51b1008 	ldr	r1, [fp, #-8]
10029578:	eb000060 	bl	10029700 <finsh_block_insert>

	memset(finsh_block_get_data(header), 0, size);
1002957c:	e51b3008 	ldr	r3, [fp, #-8]
10029580:	e2833008 	add	r3, r3, #8
10029584:	e1a00003 	mov	r0, r3
10029588:	e3a01000 	mov	r1, #0
1002958c:	e51b2010 	ldr	r2, [fp, #-16]
10029590:	fa001781 	blx	1002f39c <memset>

	return finsh_block_get_data(header);
10029594:	e51b3008 	ldr	r3, [fp, #-8]
10029598:	e2833008 	add	r3, r3, #8
}
1002959c:	e1a00003 	mov	r0, r3
100295a0:	e24bd004 	sub	sp, fp, #4
100295a4:	e8bd8800 	pop	{fp, pc}

100295a8 <finsh_heap_free>:

/**
 * release the allocated block
 */
void  finsh_heap_free(void*ptr)
{
100295a8:	e92d4800 	push	{fp, lr}
100295ac:	e28db004 	add	fp, sp, #4
100295b0:	e24dd010 	sub	sp, sp, #16
100295b4:	e50b0010 	str	r0, [fp, #-16]
    struct finsh_block_header* header;

    /* get block header */
	header = finsh_block_get_header(ptr);
100295b8:	e51b3010 	ldr	r3, [fp, #-16]
100295bc:	e2433008 	sub	r3, r3, #8
100295c0:	e50b3008 	str	r3, [fp, #-8]

    /* remove from allocate list */
	finsh_block_remove(&allocate_list, header);
100295c4:	e30f094c 	movw	r0, #63820	; 0xf94c
100295c8:	e3410003 	movt	r0, #4099	; 0x1003
100295cc:	e51b1008 	ldr	r1, [fp, #-8]
100295d0:	eb000088 	bl	100297f8 <finsh_block_remove>

	/* insert to free list */
	finsh_block_insert(&free_list, header);
100295d4:	e30f0948 	movw	r0, #63816	; 0xf948
100295d8:	e3410003 	movt	r0, #4099	; 0x1003
100295dc:	e51b1008 	ldr	r1, [fp, #-8]
100295e0:	eb000046 	bl	10029700 <finsh_block_insert>
	finsh_block_merge(&free_list, header);
100295e4:	e30f0948 	movw	r0, #63816	; 0xf948
100295e8:	e3410003 	movt	r0, #4099	; 0x1003
100295ec:	e51b1008 	ldr	r1, [fp, #-8]
100295f0:	eb0000c9 	bl	1002991c <finsh_block_merge>
}
100295f4:	e24bd004 	sub	sp, fp, #4
100295f8:	e8bd8800 	pop	{fp, pc}

100295fc <finsh_heap_gc>:

/**
 * garbage collector
 */
static void finsh_heap_gc(void)
{
100295fc:	e92d4800 	push	{fp, lr}
10029600:	e28db004 	add	fp, sp, #4
10029604:	e24dd010 	sub	sp, sp, #16
	int i;
	struct finsh_block_header *header, *temp;

	temp = NULL;
10029608:	e3a03000 	mov	r3, #0
1002960c:	e50b3010 	str	r3, [fp, #-16]

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
10029610:	e30f394c 	movw	r3, #63820	; 0xf94c
10029614:	e3413003 	movt	r3, #4099	; 0x1003
10029618:	e5933000 	ldr	r3, [r3]
1002961c:	e50b300c 	str	r3, [fp, #-12]
10029620:	ea000031 	b	100296ec <finsh_heap_gc+0xf0>
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
10029624:	e3a03000 	mov	r3, #0
10029628:	e50b3008 	str	r3, [fp, #-8]
1002962c:	ea00001f 	b	100296b0 <finsh_heap_gc+0xb4>
    	{
    		if (global_variable[i].type != finsh_type_unknown)
10029630:	e3032764 	movw	r2, #14180	; 0x3764
10029634:	e3412004 	movt	r2, #4100	; 0x1004
10029638:	e51b3008 	ldr	r3, [fp, #-8]
1002963c:	e1a01003 	mov	r1, r3
10029640:	e1a03181 	lsl	r3, r1, #3
10029644:	e1a01003 	mov	r1, r3
10029648:	e1a03101 	lsl	r3, r1, #2
1002964c:	e0613003 	rsb	r3, r1, r3
10029650:	e0823003 	add	r3, r2, r3
10029654:	e2833010 	add	r3, r3, #16
10029658:	e5d33001 	ldrb	r3, [r3, #1]
1002965c:	e3530000 	cmp	r3, #0
10029660:	0a00000f 	beq	100296a4 <finsh_heap_gc+0xa8>
    		{
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
10029664:	e3032764 	movw	r2, #14180	; 0x3764
10029668:	e3412004 	movt	r2, #4100	; 0x1004
1002966c:	e51b3008 	ldr	r3, [fp, #-8]
10029670:	e1a01003 	mov	r1, r3
10029674:	e1a03181 	lsl	r3, r1, #3
10029678:	e1a01003 	mov	r1, r3
1002967c:	e1a03101 	lsl	r3, r1, #2
10029680:	e0613003 	rsb	r3, r1, r3
10029684:	e0823003 	add	r3, r2, r3
10029688:	e2833010 	add	r3, r3, #16
1002968c:	e5932004 	ldr	r2, [r3, #4]
10029690:	e51b300c 	ldr	r3, [fp, #-12]
10029694:	e2833008 	add	r3, r3, #8
10029698:	e1520003 	cmp	r2, r3
1002969c:	1a000000 	bne	100296a4 <finsh_heap_gc+0xa8>
					break;
100296a0:	ea000005 	b	100296bc <finsh_heap_gc+0xc0>
	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
100296a4:	e51b3008 	ldr	r3, [fp, #-8]
100296a8:	e2833001 	add	r3, r3, #1
100296ac:	e50b3008 	str	r3, [fp, #-8]
100296b0:	e51b3008 	ldr	r3, [fp, #-8]
100296b4:	e3530007 	cmp	r3, #7
100296b8:	daffffdc 	ble	10029630 <finsh_heap_gc+0x34>
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
					break;
    		}
    	}

		temp   = header;
100296bc:	e51b300c 	ldr	r3, [fp, #-12]
100296c0:	e50b3010 	str	r3, [fp, #-16]
		header = header->next;
100296c4:	e51b300c 	ldr	r3, [fp, #-12]
100296c8:	e5933004 	ldr	r3, [r3, #4]
100296cc:	e50b300c 	str	r3, [fp, #-12]

		/* this block is an unused block, release it */
    	if (i == FINSH_VARIABLE_MAX)
100296d0:	e51b3008 	ldr	r3, [fp, #-8]
100296d4:	e3530008 	cmp	r3, #8
100296d8:	1a000003 	bne	100296ec <finsh_heap_gc+0xf0>
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
100296dc:	e51b3010 	ldr	r3, [fp, #-16]
100296e0:	e2833008 	add	r3, r3, #8
100296e4:	e1a00003 	mov	r0, r3
100296e8:	ebffffae 	bl	100295a8 <finsh_heap_free>
	struct finsh_block_header *header, *temp;

	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
100296ec:	e51b300c 	ldr	r3, [fp, #-12]
100296f0:	e3530000 	cmp	r3, #0
100296f4:	1affffca 	bne	10029624 <finsh_heap_gc+0x28>
    	if (i == FINSH_VARIABLE_MAX)
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
    	}
    }
}
100296f8:	e24bd004 	sub	sp, fp, #4
100296fc:	e8bd8800 	pop	{fp, pc}

10029700 <finsh_block_insert>:

/**
 * insert a block to list
 */
void finsh_block_insert(struct finsh_block_header** list, struct finsh_block_header* header)
{
10029700:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10029704:	e28db000 	add	fp, sp, #0
10029708:	e24dd014 	sub	sp, sp, #20
1002970c:	e50b0010 	str	r0, [fp, #-16]
10029710:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* node;

    if (*list == NULL)
10029714:	e51b3010 	ldr	r3, [fp, #-16]
10029718:	e5933000 	ldr	r3, [r3]
1002971c:	e3530000 	cmp	r3, #0
10029720:	1a000003 	bne	10029734 <finsh_block_insert+0x34>
    {
        *list = header;
10029724:	e51b3010 	ldr	r3, [fp, #-16]
10029728:	e51b2014 	ldr	r2, [fp, #-20]
1002972c:	e5832000 	str	r2, [r3]
        return;
10029730:	ea00002d 	b	100297ec <finsh_block_insert+0xec>
    }

    /* find out insert point */
	node = *list;
10029734:	e51b3010 	ldr	r3, [fp, #-16]
10029738:	e5933000 	ldr	r3, [r3]
1002973c:	e50b3008 	str	r3, [fp, #-8]

	if (node > header)
10029740:	e51b2008 	ldr	r2, [fp, #-8]
10029744:	e51b3014 	ldr	r3, [fp, #-20]
10029748:	e1520003 	cmp	r2, r3
1002974c:	9a000006 	bls	1002976c <finsh_block_insert+0x6c>
	{
		/* insert node in the header of list */
		header->next = node;
10029750:	e51b3014 	ldr	r3, [fp, #-20]
10029754:	e51b2008 	ldr	r2, [fp, #-8]
10029758:	e5832004 	str	r2, [r3, #4]
		*list = header;
1002975c:	e51b3010 	ldr	r3, [fp, #-16]
10029760:	e51b2014 	ldr	r2, [fp, #-20]
10029764:	e5832000 	str	r2, [r3]

		return;
10029768:	ea00001f 	b	100297ec <finsh_block_insert+0xec>
	}
	else
	{
		for (node = *list; node; node = node->next)
1002976c:	e51b3010 	ldr	r3, [fp, #-16]
10029770:	e5933000 	ldr	r3, [r3]
10029774:	e50b3008 	str	r3, [fp, #-8]
10029778:	ea00000d 	b	100297b4 <finsh_block_insert+0xb4>
		{
    		if (node->next > header) break;
1002977c:	e51b3008 	ldr	r3, [fp, #-8]
10029780:	e5932004 	ldr	r2, [r3, #4]
10029784:	e51b3014 	ldr	r3, [fp, #-20]
10029788:	e1520003 	cmp	r2, r3
1002978c:	9a000000 	bls	10029794 <finsh_block_insert+0x94>
10029790:	ea00000a 	b	100297c0 <finsh_block_insert+0xc0>

    		if (node->next == NULL) break;
10029794:	e51b3008 	ldr	r3, [fp, #-8]
10029798:	e5933004 	ldr	r3, [r3, #4]
1002979c:	e3530000 	cmp	r3, #0
100297a0:	1a000000 	bne	100297a8 <finsh_block_insert+0xa8>
100297a4:	ea000005 	b	100297c0 <finsh_block_insert+0xc0>

		return;
	}
	else
	{
		for (node = *list; node; node = node->next)
100297a8:	e51b3008 	ldr	r3, [fp, #-8]
100297ac:	e5933004 	ldr	r3, [r3, #4]
100297b0:	e50b3008 	str	r3, [fp, #-8]
100297b4:	e51b3008 	ldr	r3, [fp, #-8]
100297b8:	e3530000 	cmp	r3, #0
100297bc:	1affffee 	bne	1002977c <finsh_block_insert+0x7c>
    		if (node->next == NULL) break;
		}
	}

    /* insert node */
    if (node->next != NULL) header->next = node->next;
100297c0:	e51b3008 	ldr	r3, [fp, #-8]
100297c4:	e5933004 	ldr	r3, [r3, #4]
100297c8:	e3530000 	cmp	r3, #0
100297cc:	0a000003 	beq	100297e0 <finsh_block_insert+0xe0>
100297d0:	e51b3008 	ldr	r3, [fp, #-8]
100297d4:	e5932004 	ldr	r2, [r3, #4]
100297d8:	e51b3014 	ldr	r3, [fp, #-20]
100297dc:	e5832004 	str	r2, [r3, #4]
    node->next      = header;
100297e0:	e51b3008 	ldr	r3, [fp, #-8]
100297e4:	e51b2014 	ldr	r2, [fp, #-20]
100297e8:	e5832004 	str	r2, [r3, #4]
}
100297ec:	e24bd000 	sub	sp, fp, #0
100297f0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100297f4:	e12fff1e 	bx	lr

100297f8 <finsh_block_remove>:

/**
 * remove block from list
 */
void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header)
{
100297f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100297fc:	e28db000 	add	fp, sp, #0
10029800:	e24dd014 	sub	sp, sp, #20
10029804:	e50b0010 	str	r0, [fp, #-16]
10029808:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* node;

    node = *list;
1002980c:	e51b3010 	ldr	r3, [fp, #-16]
10029810:	e5933000 	ldr	r3, [r3]
10029814:	e50b3008 	str	r3, [fp, #-8]
    if (node == header)
10029818:	e51b2008 	ldr	r2, [fp, #-8]
1002981c:	e51b3014 	ldr	r3, [fp, #-20]
10029820:	e1520003 	cmp	r2, r3
10029824:	1a000007 	bne	10029848 <finsh_block_remove+0x50>
    {
        /* remove list header */
        *list = header->next;
10029828:	e51b3014 	ldr	r3, [fp, #-20]
1002982c:	e5932004 	ldr	r2, [r3, #4]
10029830:	e51b3010 	ldr	r3, [fp, #-16]
10029834:	e5832000 	str	r2, [r3]
        header->next = NULL;
10029838:	e51b3014 	ldr	r3, [fp, #-20]
1002983c:	e3a02000 	mov	r2, #0
10029840:	e5832004 	str	r2, [r3, #4]

        return;
10029844:	ea000013 	b	10029898 <finsh_block_remove+0xa0>
    }

    for (node = *list; node != NULL; node = node->next)
10029848:	e51b3010 	ldr	r3, [fp, #-16]
1002984c:	e5933000 	ldr	r3, [r3]
10029850:	e50b3008 	str	r3, [fp, #-8]
10029854:	ea00000c 	b	1002988c <finsh_block_remove+0x94>
    {
        if (node->next == header)
10029858:	e51b3008 	ldr	r3, [fp, #-8]
1002985c:	e5932004 	ldr	r2, [r3, #4]
10029860:	e51b3014 	ldr	r3, [fp, #-20]
10029864:	e1520003 	cmp	r2, r3
10029868:	1a000004 	bne	10029880 <finsh_block_remove+0x88>
        {
            node->next = header->next;
1002986c:	e51b3014 	ldr	r3, [fp, #-20]
10029870:	e5932004 	ldr	r2, [r3, #4]
10029874:	e51b3008 	ldr	r3, [fp, #-8]
10029878:	e5832004 	str	r2, [r3, #4]
            break;
1002987c:	ea000005 	b	10029898 <finsh_block_remove+0xa0>
        header->next = NULL;

        return;
    }

    for (node = *list; node != NULL; node = node->next)
10029880:	e51b3008 	ldr	r3, [fp, #-8]
10029884:	e5933004 	ldr	r3, [r3, #4]
10029888:	e50b3008 	str	r3, [fp, #-8]
1002988c:	e51b3008 	ldr	r3, [fp, #-8]
10029890:	e3530000 	cmp	r3, #0
10029894:	1affffef 	bne	10029858 <finsh_block_remove+0x60>
        {
            node->next = header->next;
            break;
        }
    }
}
10029898:	e24bd000 	sub	sp, fp, #0
1002989c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100298a0:	e12fff1e 	bx	lr

100298a4 <finsh_block_split>:

/**
 * split block
 */
void finsh_block_split(struct finsh_block_header* header, size_t size)
{
100298a4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100298a8:	e28db000 	add	fp, sp, #0
100298ac:	e24dd014 	sub	sp, sp, #20
100298b0:	e50b0010 	str	r0, [fp, #-16]
100298b4:	e50b1014 	str	r1, [fp, #-20]

    /*
     * split header into two node:
     * header->next->...
     */
    next = BLOCK_HEADER((u_char*)header + sizeof(struct finsh_block_header) + size);
100298b8:	e51b3014 	ldr	r3, [fp, #-20]
100298bc:	e2833008 	add	r3, r3, #8
100298c0:	e51b2010 	ldr	r2, [fp, #-16]
100298c4:	e0823003 	add	r3, r2, r3
100298c8:	e50b3008 	str	r3, [fp, #-8]
    next->length = header->length - sizeof(struct finsh_block_header) - size;
100298cc:	e51b3010 	ldr	r3, [fp, #-16]
100298d0:	e5932000 	ldr	r2, [r3]
100298d4:	e51b3014 	ldr	r3, [fp, #-20]
100298d8:	e0633002 	rsb	r3, r3, r2
100298dc:	e2432008 	sub	r2, r3, #8
100298e0:	e51b3008 	ldr	r3, [fp, #-8]
100298e4:	e5832000 	str	r2, [r3]
    header->length = size;
100298e8:	e51b3010 	ldr	r3, [fp, #-16]
100298ec:	e51b2014 	ldr	r2, [fp, #-20]
100298f0:	e5832000 	str	r2, [r3]
    next->next = header->next;
100298f4:	e51b3010 	ldr	r3, [fp, #-16]
100298f8:	e5932004 	ldr	r2, [r3, #4]
100298fc:	e51b3008 	ldr	r3, [fp, #-8]
10029900:	e5832004 	str	r2, [r3, #4]

    header->next = next;
10029904:	e51b3010 	ldr	r3, [fp, #-16]
10029908:	e51b2008 	ldr	r2, [fp, #-8]
1002990c:	e5832004 	str	r2, [r3, #4]
}
10029910:	e24bd000 	sub	sp, fp, #0
10029914:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10029918:	e12fff1e 	bx	lr

1002991c <finsh_block_merge>:

void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header)
{
1002991c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10029920:	e28db000 	add	fp, sp, #0
10029924:	e24dd014 	sub	sp, sp, #20
10029928:	e50b0010 	str	r0, [fp, #-16]
1002992c:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* prev_node;
    struct finsh_block_header* next_node;

    next_node = header->next;
10029930:	e51b3014 	ldr	r3, [fp, #-20]
10029934:	e5933004 	ldr	r3, [r3, #4]
10029938:	e50b300c 	str	r3, [fp, #-12]

    if (*list == header) prev_node = NULL;
1002993c:	e51b3010 	ldr	r3, [fp, #-16]
10029940:	e5932000 	ldr	r2, [r3]
10029944:	e51b3014 	ldr	r3, [fp, #-20]
10029948:	e1520003 	cmp	r2, r3
1002994c:	1a000002 	bne	1002995c <finsh_block_merge+0x40>
10029950:	e3a03000 	mov	r3, #0
10029954:	e50b3008 	str	r3, [fp, #-8]
10029958:	ea00000f 	b	1002999c <finsh_block_merge+0x80>
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
1002995c:	e51b3010 	ldr	r3, [fp, #-16]
10029960:	e5933000 	ldr	r3, [r3]
10029964:	e50b3008 	str	r3, [fp, #-8]
10029968:	ea000008 	b	10029990 <finsh_block_merge+0x74>
        {
            if (prev_node->next == header)
1002996c:	e51b3008 	ldr	r3, [fp, #-8]
10029970:	e5932004 	ldr	r2, [r3, #4]
10029974:	e51b3014 	ldr	r3, [fp, #-20]
10029978:	e1520003 	cmp	r2, r3
1002997c:	1a000000 	bne	10029984 <finsh_block_merge+0x68>
                break;
10029980:	ea000005 	b	1002999c <finsh_block_merge+0x80>

    if (*list == header) prev_node = NULL;
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
10029984:	e51b3008 	ldr	r3, [fp, #-8]
10029988:	e5933004 	ldr	r3, [r3, #4]
1002998c:	e50b3008 	str	r3, [fp, #-8]
10029990:	e51b3008 	ldr	r3, [fp, #-8]
10029994:	e3530000 	cmp	r3, #0
10029998:	1afffff3 	bne	1002996c <finsh_block_merge+0x50>
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
1002999c:	e51b3008 	ldr	r3, [fp, #-8]
100299a0:	e3530000 	cmp	r3, #0
100299a4:	0a00002f 	beq	10029a68 <finsh_block_merge+0x14c>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
100299a8:	e51b3008 	ldr	r3, [fp, #-8]
100299ac:	e5933000 	ldr	r3, [r3]
100299b0:	e2833008 	add	r3, r3, #8
100299b4:	e51b2008 	ldr	r2, [fp, #-8]
100299b8:	e0822003 	add	r2, r2, r3
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
100299bc:	e51b3014 	ldr	r3, [fp, #-20]
100299c0:	e1520003 	cmp	r2, r3
100299c4:	1a000027 	bne	10029a68 <finsh_block_merge+0x14c>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
100299c8:	e51b300c 	ldr	r3, [fp, #-12]
100299cc:	e3530000 	cmp	r3, #0
100299d0:	0a000017 	beq	10029a34 <finsh_block_merge+0x118>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
100299d4:	e51b3014 	ldr	r3, [fp, #-20]
100299d8:	e5933000 	ldr	r3, [r3]
100299dc:	e2833008 	add	r3, r3, #8
100299e0:	e51b2014 	ldr	r2, [fp, #-20]
100299e4:	e0822003 	add	r2, r2, r3
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
100299e8:	e51b300c 	ldr	r3, [fp, #-12]
100299ec:	e1520003 	cmp	r2, r3
100299f0:	1a00000f 	bne	10029a34 <finsh_block_merge+0x118>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
            == (u_char*)next_node))
        {
            /* merge three node */
        	prev_node->length += header->length + next_node->length +
100299f4:	e51b3008 	ldr	r3, [fp, #-8]
100299f8:	e5932000 	ldr	r2, [r3]
100299fc:	e51b3014 	ldr	r3, [fp, #-20]
10029a00:	e5931000 	ldr	r1, [r3]
10029a04:	e51b300c 	ldr	r3, [fp, #-12]
10029a08:	e5933000 	ldr	r3, [r3]
10029a0c:	e0813003 	add	r3, r1, r3
10029a10:	e0823003 	add	r3, r2, r3
10029a14:	e2832010 	add	r2, r3, #16
10029a18:	e51b3008 	ldr	r3, [fp, #-8]
10029a1c:	e5832000 	str	r2, [r3]
                2 * sizeof(struct finsh_block_header);

            prev_node->next = next_node->next;
10029a20:	e51b300c 	ldr	r3, [fp, #-12]
10029a24:	e5932004 	ldr	r2, [r3, #4]
10029a28:	e51b3008 	ldr	r3, [fp, #-8]
10029a2c:	e5832004 	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
10029a30:	ea000023 	b	10029ac4 <finsh_block_merge+0x1a8>

            prev_node->next = next_node->next;
        }
        else
        {
            prev_node->length += header->length + sizeof(struct finsh_block_header);
10029a34:	e51b3008 	ldr	r3, [fp, #-8]
10029a38:	e5932000 	ldr	r2, [r3]
10029a3c:	e51b3014 	ldr	r3, [fp, #-20]
10029a40:	e5933000 	ldr	r3, [r3]
10029a44:	e0823003 	add	r3, r2, r3
10029a48:	e2832008 	add	r2, r3, #8
10029a4c:	e51b3008 	ldr	r3, [fp, #-8]
10029a50:	e5832000 	str	r2, [r3]
            prev_node->next = header->next;
10029a54:	e51b3014 	ldr	r3, [fp, #-20]
10029a58:	e5932004 	ldr	r2, [r3, #4]
10029a5c:	e51b3008 	ldr	r3, [fp, #-8]
10029a60:	e5832004 	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
10029a64:	ea000016 	b	10029ac4 <finsh_block_merge+0x1a8>
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
10029a68:	e51b300c 	ldr	r3, [fp, #-12]
10029a6c:	e3530000 	cmp	r3, #0
10029a70:	0a000013 	beq	10029ac4 <finsh_block_merge+0x1a8>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
10029a74:	e51b3014 	ldr	r3, [fp, #-20]
10029a78:	e5933000 	ldr	r3, [r3]
10029a7c:	e2833008 	add	r3, r3, #8
10029a80:	e51b2014 	ldr	r2, [fp, #-20]
10029a84:	e0822003 	add	r2, r2, r3
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
10029a88:	e51b300c 	ldr	r3, [fp, #-12]
10029a8c:	e1520003 	cmp	r2, r3
10029a90:	1a00000b 	bne	10029ac4 <finsh_block_merge+0x1a8>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
        == (u_char*)next_node))
    {
        header->length += next_node->length + sizeof(struct finsh_block_header);
10029a94:	e51b3014 	ldr	r3, [fp, #-20]
10029a98:	e5932000 	ldr	r2, [r3]
10029a9c:	e51b300c 	ldr	r3, [fp, #-12]
10029aa0:	e5933000 	ldr	r3, [r3]
10029aa4:	e0823003 	add	r3, r2, r3
10029aa8:	e2832008 	add	r2, r3, #8
10029aac:	e51b3014 	ldr	r3, [fp, #-20]
10029ab0:	e5832000 	str	r2, [r3]
        header->next = next_node->next;
10029ab4:	e51b300c 	ldr	r3, [fp, #-12]
10029ab8:	e5932004 	ldr	r2, [r3, #4]
10029abc:	e51b3014 	ldr	r3, [fp, #-20]
10029ac0:	e5832004 	str	r2, [r3, #4]
    }
}
10029ac4:	e24bd000 	sub	sp, fp, #0
10029ac8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10029acc:	e12fff1e 	bx	lr

10029ad0 <finsh_init>:
#include "finsh_var.h"
#include "finsh_error.h"
#include "finsh_heap.h"

int finsh_init(struct finsh_parser* parser)
{
10029ad0:	e92d4800 	push	{fp, lr}
10029ad4:	e28db004 	add	fp, sp, #4
10029ad8:	e24dd008 	sub	sp, sp, #8
10029adc:	e50b0008 	str	r0, [fp, #-8]
	finsh_parser_init(parser);
10029ae0:	e51b0008 	ldr	r0, [fp, #-8]
10029ae4:	eb000e1b 	bl	1002d358 <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
10029ae8:	eb000027 	bl	10029b8c <finsh_node_init>
	finsh_var_init();
10029aec:	eb000e25 	bl	1002d388 <finsh_var_init>
	finsh_error_init();
10029af0:	ebfffe14 	bl	10029348 <finsh_error_init>
	finsh_heap_init();
10029af4:	ebfffe42 	bl	10029404 <finsh_heap_init>

	return 0;
10029af8:	e3a03000 	mov	r3, #0
}
10029afc:	e1a00003 	mov	r0, r3
10029b00:	e24bd004 	sub	sp, fp, #4
10029b04:	e8bd8800 	pop	{fp, pc}

10029b08 <finsh_stack_bottom>:

long finsh_stack_bottom()
{
10029b08:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10029b0c:	e28db000 	add	fp, sp, #0
    return finsh_vm_stack[0].long_value;
10029b10:	e30338a4 	movw	r3, #14500	; 0x38a4
10029b14:	e3413004 	movt	r3, #4100	; 0x1004
10029b18:	e5933000 	ldr	r3, [r3]
}
10029b1c:	e1a00003 	mov	r0, r3
10029b20:	e24bd000 	sub	sp, fp, #0
10029b24:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10029b28:	e12fff1e 	bx	lr

10029b2c <finsh_flush>:

int finsh_flush(struct finsh_parser* parser)
{
10029b2c:	e92d4800 	push	{fp, lr}
10029b30:	e28db004 	add	fp, sp, #4
10029b34:	e24dd008 	sub	sp, sp, #8
10029b38:	e50b0008 	str	r0, [fp, #-8]
	finsh_parser_init(parser);
10029b3c:	e51b0008 	ldr	r0, [fp, #-8]
10029b40:	eb000e04 	bl	1002d358 <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
10029b44:	eb000010 	bl	10029b8c <finsh_node_init>
	finsh_error_init();
10029b48:	ebfffdfe 	bl	10029348 <finsh_error_init>

	return 0;
10029b4c:	e3a03000 	mov	r3, #0
}
10029b50:	e1a00003 	mov	r0, r3
10029b54:	e24bd004 	sub	sp, fp, #4
10029b58:	e8bd8800 	pop	{fp, pc}

10029b5c <finsh_reset>:

int finsh_reset(struct finsh_parser* parser)
{
10029b5c:	e92d4800 	push	{fp, lr}
10029b60:	e28db004 	add	fp, sp, #4
10029b64:	e24dd008 	sub	sp, sp, #8
10029b68:	e50b0008 	str	r0, [fp, #-8]
	/* finsh init */
	finsh_node_init();
10029b6c:	eb000006 	bl	10029b8c <finsh_node_init>
	finsh_var_init();
10029b70:	eb000e04 	bl	1002d388 <finsh_var_init>
	finsh_error_init();
10029b74:	ebfffdf3 	bl	10029348 <finsh_error_init>
	finsh_heap_init();
10029b78:	ebfffe21 	bl	10029404 <finsh_heap_init>

	return 0;
10029b7c:	e3a03000 	mov	r3, #0
}
10029b80:	e1a00003 	mov	r0, r3
10029b84:	e24bd004 	sub	sp, fp, #4
10029b88:	e8bd8800 	pop	{fp, pc}

10029b8c <finsh_node_init>:
#include "finsh_heap.h"

struct finsh_node global_node_table[FINSH_NODE_MAX];

int finsh_node_init()
{
10029b8c:	e92d4800 	push	{fp, lr}
10029b90:	e28db004 	add	fp, sp, #4
	memset(global_node_table, 0, sizeof(global_node_table));
10029b94:	e3030620 	movw	r0, #13856	; 0x3620
10029b98:	e3410004 	movt	r0, #4100	; 0x1004
10029b9c:	e3a01000 	mov	r1, #0
10029ba0:	e3a02d05 	mov	r2, #320	; 0x140
10029ba4:	fa0015fc 	blx	1002f39c <memset>

	return 0;
10029ba8:	e3a03000 	mov	r3, #0
}
10029bac:	e1a00003 	mov	r0, r3
10029bb0:	e8bd8800 	pop	{fp, pc}

10029bb4 <finsh_node_allocate>:

struct finsh_node* finsh_node_allocate(u_char type)
{
10029bb4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10029bb8:	e28db000 	add	fp, sp, #0
10029bbc:	e24dd014 	sub	sp, sp, #20
10029bc0:	e1a03000 	mov	r3, r0
10029bc4:	e54b300d 	strb	r3, [fp, #-13]
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
10029bc8:	e3a03000 	mov	r3, #0
10029bcc:	e50b3008 	str	r3, [fp, #-8]
10029bd0:	ea00000d 	b	10029c0c <finsh_node_allocate+0x58>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
10029bd4:	e3032620 	movw	r2, #13856	; 0x3620
10029bd8:	e3412004 	movt	r2, #4100	; 0x1004
10029bdc:	e51b3008 	ldr	r3, [fp, #-8]
10029be0:	e1a03103 	lsl	r3, r3, #2
10029be4:	e1a01103 	lsl	r1, r3, #2
10029be8:	e0833001 	add	r3, r3, r1
10029bec:	e0823003 	add	r3, r2, r3
10029bf0:	e5d33000 	ldrb	r3, [r3]
10029bf4:	e3530000 	cmp	r3, #0
10029bf8:	1a000000 	bne	10029c00 <finsh_node_allocate+0x4c>
10029bfc:	ea000005 	b	10029c18 <finsh_node_allocate+0x64>
struct finsh_node* finsh_node_allocate(u_char type)
{
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
10029c00:	e51b3008 	ldr	r3, [fp, #-8]
10029c04:	e2833001 	add	r3, r3, #1
10029c08:	e50b3008 	str	r3, [fp, #-8]
10029c0c:	e51b3008 	ldr	r3, [fp, #-8]
10029c10:	e353000f 	cmp	r3, #15
10029c14:	daffffee 	ble	10029bd4 <finsh_node_allocate+0x20>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
	}

	if (i == FINSH_NODE_MAX) return NULL;
10029c18:	e51b3008 	ldr	r3, [fp, #-8]
10029c1c:	e3530010 	cmp	r3, #16
10029c20:	1a000001 	bne	10029c2c <finsh_node_allocate+0x78>
10029c24:	e3a03000 	mov	r3, #0
10029c28:	ea00000f 	b	10029c6c <finsh_node_allocate+0xb8>

	/* fill type field */
	global_node_table[i].node_type = type;
10029c2c:	e3032620 	movw	r2, #13856	; 0x3620
10029c30:	e3412004 	movt	r2, #4100	; 0x1004
10029c34:	e51b3008 	ldr	r3, [fp, #-8]
10029c38:	e1a03103 	lsl	r3, r3, #2
10029c3c:	e1a01103 	lsl	r1, r3, #2
10029c40:	e0833001 	add	r3, r3, r1
10029c44:	e0823003 	add	r3, r2, r3
10029c48:	e55b200d 	ldrb	r2, [fp, #-13]
10029c4c:	e5c32000 	strb	r2, [r3]

	/* return this allocated node */
	return &global_node_table[i];
10029c50:	e51b3008 	ldr	r3, [fp, #-8]
10029c54:	e1a03103 	lsl	r3, r3, #2
10029c58:	e1a02103 	lsl	r2, r3, #2
10029c5c:	e0833002 	add	r3, r3, r2
10029c60:	e3032620 	movw	r2, #13856	; 0x3620
10029c64:	e3412004 	movt	r2, #4100	; 0x1004
10029c68:	e0833002 	add	r3, r3, r2
}
10029c6c:	e1a00003 	mov	r0, r3
10029c70:	e24bd000 	sub	sp, fp, #0
10029c74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10029c78:	e12fff1e 	bx	lr

10029c7c <finsh_node_new_id>:

struct finsh_node* finsh_node_new_id(char* id)
{
10029c7c:	e92d4800 	push	{fp, lr}
10029c80:	e28db004 	add	fp, sp, #4
10029c84:	e24dd018 	sub	sp, sp, #24
10029c88:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_node* node;
	void*  symbol;
	unsigned char type;

	symbol	= NULL;
10029c8c:	e3a03000 	mov	r3, #0
10029c90:	e50b300c 	str	r3, [fp, #-12]
	type	= 0;
10029c94:	e3a03000 	mov	r3, #0
10029c98:	e54b300d 	strb	r3, [fp, #-13]
	node	= NULL;
10029c9c:	e3a03000 	mov	r3, #0
10029ca0:	e50b3008 	str	r3, [fp, #-8]

	/* lookup variable firstly */
	symbol = (void*)finsh_var_lookup(id);
10029ca4:	e51b0018 	ldr	r0, [fp, #-24]
10029ca8:	eb000e4c 	bl	1002d5e0 <finsh_var_lookup>
10029cac:	e50b000c 	str	r0, [fp, #-12]
	if (symbol == NULL)
10029cb0:	e51b300c 	ldr	r3, [fp, #-12]
10029cb4:	e3530000 	cmp	r3, #0
10029cb8:	1a000011 	bne	10029d04 <finsh_node_new_id+0x88>
	{
		/* then lookup system variable */
		symbol = (void*)finsh_sysvar_lookup(id);
10029cbc:	e51b0018 	ldr	r0, [fp, #-24]
10029cc0:	eb000ea5 	bl	1002d75c <finsh_sysvar_lookup>
10029cc4:	e50b000c 	str	r0, [fp, #-12]
		if (symbol == NULL)
10029cc8:	e51b300c 	ldr	r3, [fp, #-12]
10029ccc:	e3530000 	cmp	r3, #0
10029cd0:	1a000008 	bne	10029cf8 <finsh_node_new_id+0x7c>
		{
			/* then lookup system call */
			symbol = (void*)finsh_syscall_lookup(id);
10029cd4:	e51b0018 	ldr	r0, [fp, #-24]
10029cd8:	eb000f34 	bl	1002d9b0 <finsh_syscall_lookup>
10029cdc:	e50b000c 	str	r0, [fp, #-12]
			if (symbol != NULL) type = FINSH_IDTYPE_SYSCALL;
10029ce0:	e51b300c 	ldr	r3, [fp, #-12]
10029ce4:	e3530000 	cmp	r3, #0
10029ce8:	0a000007 	beq	10029d0c <finsh_node_new_id+0x90>
10029cec:	e3a03004 	mov	r3, #4
10029cf0:	e54b300d 	strb	r3, [fp, #-13]
10029cf4:	ea000004 	b	10029d0c <finsh_node_new_id+0x90>
		}
		else type = FINSH_IDTYPE_SYSVAR;
10029cf8:	e3a03002 	mov	r3, #2
10029cfc:	e54b300d 	strb	r3, [fp, #-13]
10029d00:	ea000001 	b	10029d0c <finsh_node_new_id+0x90>
	}
	else type = FINSH_IDTYPE_VAR;
10029d04:	e3a03001 	mov	r3, #1
10029d08:	e54b300d 	strb	r3, [fp, #-13]

	if (symbol != NULL)
10029d0c:	e51b300c 	ldr	r3, [fp, #-12]
10029d10:	e3530000 	cmp	r3, #0
10029d14:	0a000020 	beq	10029d9c <finsh_node_new_id+0x120>
	{
		/* allocate a new node */
		node = finsh_node_allocate(FINSH_NODE_ID);
10029d18:	e3a00001 	mov	r0, #1
10029d1c:	ebffffa4 	bl	10029bb4 <finsh_node_allocate>
10029d20:	e50b0008 	str	r0, [fp, #-8]

		/* allocate node error */
		if (node == NULL)
10029d24:	e51b3008 	ldr	r3, [fp, #-8]
10029d28:	e3530000 	cmp	r3, #0
10029d2c:	1a000003 	bne	10029d40 <finsh_node_new_id+0xc4>
		{
			finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10029d30:	e3a00006 	mov	r0, #6
10029d34:	ebfffd8e 	bl	10029374 <finsh_error_set>
			return NULL;
10029d38:	e3a03000 	mov	r3, #0
10029d3c:	ea000019 	b	10029da8 <finsh_node_new_id+0x12c>
		}

		/* fill node value according type */
		switch (type)
10029d40:	e55b300d 	ldrb	r3, [fp, #-13]
10029d44:	e3530002 	cmp	r3, #2
10029d48:	0a000007 	beq	10029d6c <finsh_node_new_id+0xf0>
10029d4c:	e3530004 	cmp	r3, #4
10029d50:	0a000009 	beq	10029d7c <finsh_node_new_id+0x100>
10029d54:	e3530001 	cmp	r3, #1
10029d58:	1a00000b 	bne	10029d8c <finsh_node_new_id+0x110>
		{
		case FINSH_IDTYPE_VAR:
			node->id.var = (struct finsh_var*)symbol;
10029d5c:	e51b3008 	ldr	r3, [fp, #-8]
10029d60:	e51b200c 	ldr	r2, [fp, #-12]
10029d64:	e5832008 	str	r2, [r3, #8]
			break;
10029d68:	ea000007 	b	10029d8c <finsh_node_new_id+0x110>

		case FINSH_IDTYPE_SYSVAR:
			node->id.sysvar = (struct finsh_sysvar*)symbol;
10029d6c:	e51b3008 	ldr	r3, [fp, #-8]
10029d70:	e51b200c 	ldr	r2, [fp, #-12]
10029d74:	e5832008 	str	r2, [r3, #8]
			break;
10029d78:	ea000003 	b	10029d8c <finsh_node_new_id+0x110>

		case FINSH_IDTYPE_SYSCALL:
			node->id.syscall = (struct finsh_syscall*)symbol;
10029d7c:	e51b3008 	ldr	r3, [fp, #-8]
10029d80:	e51b200c 	ldr	r2, [fp, #-12]
10029d84:	e5832008 	str	r2, [r3, #8]
			break;
10029d88:	e1a00000 	nop			; (mov r0, r0)
		}
		/* fill identifier type */
		node->idtype = type;
10029d8c:	e51b3008 	ldr	r3, [fp, #-8]
10029d90:	e55b200d 	ldrb	r2, [fp, #-13]
10029d94:	e5c32002 	strb	r2, [r3, #2]
10029d98:	ea000001 	b	10029da4 <finsh_node_new_id+0x128>
	}
	else finsh_error_set(FINSH_ERROR_UNKNOWN_SYMBOL);
10029d9c:	e3a0000d 	mov	r0, #13
10029da0:	ebfffd73 	bl	10029374 <finsh_error_set>

	return node;
10029da4:	e51b3008 	ldr	r3, [fp, #-8]
}
10029da8:	e1a00003 	mov	r0, r3
10029dac:	e24bd004 	sub	sp, fp, #4
10029db0:	e8bd8800 	pop	{fp, pc}

10029db4 <finsh_node_new_char>:

struct finsh_node* finsh_node_new_char(char c)
{
10029db4:	e92d4800 	push	{fp, lr}
10029db8:	e28db004 	add	fp, sp, #4
10029dbc:	e24dd010 	sub	sp, sp, #16
10029dc0:	e1a03000 	mov	r3, r0
10029dc4:	e54b300d 	strb	r3, [fp, #-13]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_CHAR);
10029dc8:	e3a00002 	mov	r0, #2
10029dcc:	ebffff78 	bl	10029bb4 <finsh_node_allocate>
10029dd0:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
10029dd4:	e51b3008 	ldr	r3, [fp, #-8]
10029dd8:	e3530000 	cmp	r3, #0
10029ddc:	1a000003 	bne	10029df0 <finsh_node_new_char+0x3c>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10029de0:	e3a00006 	mov	r0, #6
10029de4:	ebfffd62 	bl	10029374 <finsh_error_set>
		return NULL;
10029de8:	e3a03000 	mov	r3, #0
10029dec:	ea000003 	b	10029e00 <finsh_node_new_char+0x4c>
	}

	node->value.char_value = c;
10029df0:	e51b3008 	ldr	r3, [fp, #-8]
10029df4:	e55b200d 	ldrb	r2, [fp, #-13]
10029df8:	e5c32004 	strb	r2, [r3, #4]
	return node;
10029dfc:	e51b3008 	ldr	r3, [fp, #-8]
}
10029e00:	e1a00003 	mov	r0, r3
10029e04:	e24bd004 	sub	sp, fp, #4
10029e08:	e8bd8800 	pop	{fp, pc}

10029e0c <finsh_node_new_int>:

struct finsh_node* finsh_node_new_int(int i)
{
10029e0c:	e92d4800 	push	{fp, lr}
10029e10:	e28db004 	add	fp, sp, #4
10029e14:	e24dd010 	sub	sp, sp, #16
10029e18:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_INT);
10029e1c:	e3a00003 	mov	r0, #3
10029e20:	ebffff63 	bl	10029bb4 <finsh_node_allocate>
10029e24:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
10029e28:	e51b3008 	ldr	r3, [fp, #-8]
10029e2c:	e3530000 	cmp	r3, #0
10029e30:	1a000003 	bne	10029e44 <finsh_node_new_int+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10029e34:	e3a00006 	mov	r0, #6
10029e38:	ebfffd4d 	bl	10029374 <finsh_error_set>
		return NULL;
10029e3c:	e3a03000 	mov	r3, #0
10029e40:	ea000003 	b	10029e54 <finsh_node_new_int+0x48>
	}

	node->value.int_value = i;
10029e44:	e51b3008 	ldr	r3, [fp, #-8]
10029e48:	e51b2010 	ldr	r2, [fp, #-16]
10029e4c:	e5832004 	str	r2, [r3, #4]
	return node;
10029e50:	e51b3008 	ldr	r3, [fp, #-8]
}
10029e54:	e1a00003 	mov	r0, r3
10029e58:	e24bd004 	sub	sp, fp, #4
10029e5c:	e8bd8800 	pop	{fp, pc}

10029e60 <finsh_node_new_long>:

struct finsh_node* finsh_node_new_long(long l)
{
10029e60:	e92d4800 	push	{fp, lr}
10029e64:	e28db004 	add	fp, sp, #4
10029e68:	e24dd010 	sub	sp, sp, #16
10029e6c:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_LONG);
10029e70:	e3a00004 	mov	r0, #4
10029e74:	ebffff4e 	bl	10029bb4 <finsh_node_allocate>
10029e78:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
10029e7c:	e51b3008 	ldr	r3, [fp, #-8]
10029e80:	e3530000 	cmp	r3, #0
10029e84:	1a000003 	bne	10029e98 <finsh_node_new_long+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10029e88:	e3a00006 	mov	r0, #6
10029e8c:	ebfffd38 	bl	10029374 <finsh_error_set>
		return NULL;
10029e90:	e3a03000 	mov	r3, #0
10029e94:	ea000003 	b	10029ea8 <finsh_node_new_long+0x48>
	}

	node->value.long_value = l;
10029e98:	e51b3008 	ldr	r3, [fp, #-8]
10029e9c:	e51b2010 	ldr	r2, [fp, #-16]
10029ea0:	e5832004 	str	r2, [r3, #4]
	return node;
10029ea4:	e51b3008 	ldr	r3, [fp, #-8]
}
10029ea8:	e1a00003 	mov	r0, r3
10029eac:	e24bd004 	sub	sp, fp, #4
10029eb0:	e8bd8800 	pop	{fp, pc}

10029eb4 <finsh_node_new_string>:

struct finsh_node* finsh_node_new_string(char* s)
{
10029eb4:	e92d4810 	push	{r4, fp, lr}
10029eb8:	e28db008 	add	fp, sp, #8
10029ebc:	e24dd014 	sub	sp, sp, #20
10029ec0:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_STRING);
10029ec4:	e3a00005 	mov	r0, #5
10029ec8:	ebffff39 	bl	10029bb4 <finsh_node_allocate>
10029ecc:	e50b0010 	str	r0, [fp, #-16]
	if (node == NULL)
10029ed0:	e51b3010 	ldr	r3, [fp, #-16]
10029ed4:	e3530000 	cmp	r3, #0
10029ed8:	1a000003 	bne	10029eec <finsh_node_new_string+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10029edc:	e3a00006 	mov	r0, #6
10029ee0:	ebfffd23 	bl	10029374 <finsh_error_set>
		return NULL;
10029ee4:	e3a03000 	mov	r3, #0
10029ee8:	ea00001a 	b	10029f58 <finsh_node_new_string+0xa4>
	}

	/* make string */
	node->value.ptr = finsh_heap_allocate(strlen(s) + 1);
10029eec:	e51b0018 	ldr	r0, [fp, #-24]
10029ef0:	fa00162c 	blx	1002f7a8 <strlen>
10029ef4:	e1a03000 	mov	r3, r0
10029ef8:	e2833001 	add	r3, r3, #1
10029efc:	e1a00003 	mov	r0, r3
10029f00:	ebfffd5c 	bl	10029478 <finsh_heap_allocate>
10029f04:	e1a02000 	mov	r2, r0
10029f08:	e51b3010 	ldr	r3, [fp, #-16]
10029f0c:	e5832004 	str	r2, [r3, #4]
	strncpy(node->value.ptr, s, strlen(s));
10029f10:	e51b3010 	ldr	r3, [fp, #-16]
10029f14:	e5934004 	ldr	r4, [r3, #4]
10029f18:	e51b0018 	ldr	r0, [fp, #-24]
10029f1c:	fa001621 	blx	1002f7a8 <strlen>
10029f20:	e1a03000 	mov	r3, r0
10029f24:	e1a00004 	mov	r0, r4
10029f28:	e51b1018 	ldr	r1, [fp, #-24]
10029f2c:	e1a02003 	mov	r2, r3
10029f30:	fa001659 	blx	1002f89c <strncpy>
	((u_char*)node->value.ptr)[strlen(s)] = '\0';
10029f34:	e51b3010 	ldr	r3, [fp, #-16]
10029f38:	e5934004 	ldr	r4, [r3, #4]
10029f3c:	e51b0018 	ldr	r0, [fp, #-24]
10029f40:	fa001618 	blx	1002f7a8 <strlen>
10029f44:	e1a03000 	mov	r3, r0
10029f48:	e0843003 	add	r3, r4, r3
10029f4c:	e3a02000 	mov	r2, #0
10029f50:	e5c32000 	strb	r2, [r3]

	return node;
10029f54:	e51b3010 	ldr	r3, [fp, #-16]
}
10029f58:	e1a00003 	mov	r0, r3
10029f5c:	e24bd008 	sub	sp, fp, #8
10029f60:	e8bd8810 	pop	{r4, fp, pc}

10029f64 <finsh_node_new_ptr>:

struct finsh_node* finsh_node_new_ptr(void* ptr)
{
10029f64:	e92d4800 	push	{fp, lr}
10029f68:	e28db004 	add	fp, sp, #4
10029f6c:	e24dd010 	sub	sp, sp, #16
10029f70:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_NULL);
10029f74:	e3a00006 	mov	r0, #6
10029f78:	ebffff0d 	bl	10029bb4 <finsh_node_allocate>
10029f7c:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
10029f80:	e51b3008 	ldr	r3, [fp, #-8]
10029f84:	e3530000 	cmp	r3, #0
10029f88:	1a000003 	bne	10029f9c <finsh_node_new_ptr+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10029f8c:	e3a00006 	mov	r0, #6
10029f90:	ebfffcf7 	bl	10029374 <finsh_error_set>
		return NULL;
10029f94:	e3a03000 	mov	r3, #0
10029f98:	ea000003 	b	10029fac <finsh_node_new_ptr+0x48>
	}

	node->value.ptr = ptr;
10029f9c:	e51b3008 	ldr	r3, [fp, #-8]
10029fa0:	e51b2010 	ldr	r2, [fp, #-16]
10029fa4:	e5832004 	str	r2, [r3, #4]
	return node;
10029fa8:	e51b3008 	ldr	r3, [fp, #-8]
}
10029fac:	e1a00003 	mov	r0, r3
10029fb0:	e24bd004 	sub	sp, fp, #4
10029fb4:	e8bd8800 	pop	{fp, pc}

10029fb8 <OP_no_op>:
        finsh_sp--; \
    }while (0)

/* --- noop --- */
void OP_no_op()
{
10029fb8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10029fbc:	e28db000 	add	fp, sp, #0
	/* none */
	return ;
10029fc0:	e1a00000 	nop			; (mov r0, r0)
}
10029fc4:	e24bd000 	sub	sp, fp, #0
10029fc8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10029fcc:	e12fff1e 	bx	lr

10029fd0 <OP_add_byte>:

/* --- add --- */
void OP_add_byte()
{
10029fd0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10029fd4:	e28db000 	add	fp, sp, #0
    OP_BIN_BYTE(+);
10029fd8:	e30339a8 	movw	r3, #14760	; 0x39a8
10029fdc:	e3413004 	movt	r3, #4100	; 0x1004
10029fe0:	e5933000 	ldr	r3, [r3]
10029fe4:	e2432008 	sub	r2, r3, #8
10029fe8:	e30339a8 	movw	r3, #14760	; 0x39a8
10029fec:	e3413004 	movt	r3, #4100	; 0x1004
10029ff0:	e5933000 	ldr	r3, [r3]
10029ff4:	e2433008 	sub	r3, r3, #8
10029ff8:	e5d31000 	ldrb	r1, [r3]
10029ffc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a000:	e3413004 	movt	r3, #4100	; 0x1004
1002a004:	e5933000 	ldr	r3, [r3]
1002a008:	e2433004 	sub	r3, r3, #4
1002a00c:	e5d33000 	ldrb	r3, [r3]
1002a010:	e0813003 	add	r3, r1, r3
1002a014:	e6ef3073 	uxtb	r3, r3
1002a018:	e5c23000 	strb	r3, [r2]
1002a01c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a020:	e3413004 	movt	r3, #4100	; 0x1004
1002a024:	e5933000 	ldr	r3, [r3]
1002a028:	e2432004 	sub	r2, r3, #4
1002a02c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a030:	e3413004 	movt	r3, #4100	; 0x1004
1002a034:	e5832000 	str	r2, [r3]

	return ;
1002a038:	e1a00000 	nop			; (mov r0, r0)
}
1002a03c:	e24bd000 	sub	sp, fp, #0
1002a040:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a044:	e12fff1e 	bx	lr

1002a048 <OP_add_word>:

void OP_add_word()
{
1002a048:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a04c:	e28db000 	add	fp, sp, #0
    OP_BIN_WORD(+);
1002a050:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a054:	e3413004 	movt	r3, #4100	; 0x1004
1002a058:	e5933000 	ldr	r3, [r3]
1002a05c:	e2432008 	sub	r2, r3, #8
1002a060:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a064:	e3413004 	movt	r3, #4100	; 0x1004
1002a068:	e5933000 	ldr	r3, [r3]
1002a06c:	e2433008 	sub	r3, r3, #8
1002a070:	e1d330b0 	ldrh	r3, [r3]
1002a074:	e6ff1073 	uxth	r1, r3
1002a078:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a07c:	e3413004 	movt	r3, #4100	; 0x1004
1002a080:	e5933000 	ldr	r3, [r3]
1002a084:	e2433004 	sub	r3, r3, #4
1002a088:	e1d330b0 	ldrh	r3, [r3]
1002a08c:	e6ff3073 	uxth	r3, r3
1002a090:	e0813003 	add	r3, r1, r3
1002a094:	e6ff3073 	uxth	r3, r3
1002a098:	e6ff3073 	uxth	r3, r3
1002a09c:	e1c230b0 	strh	r3, [r2]
1002a0a0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a0a4:	e3413004 	movt	r3, #4100	; 0x1004
1002a0a8:	e5933000 	ldr	r3, [r3]
1002a0ac:	e2432004 	sub	r2, r3, #4
1002a0b0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a0b4:	e3413004 	movt	r3, #4100	; 0x1004
1002a0b8:	e5832000 	str	r2, [r3]

	return ;
1002a0bc:	e1a00000 	nop			; (mov r0, r0)
}
1002a0c0:	e24bd000 	sub	sp, fp, #0
1002a0c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a0c8:	e12fff1e 	bx	lr

1002a0cc <OP_add_dword>:

void OP_add_dword()
{
1002a0cc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a0d0:	e28db000 	add	fp, sp, #0
    OP_BIN_DWORD(+);
1002a0d4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a0d8:	e3413004 	movt	r3, #4100	; 0x1004
1002a0dc:	e5933000 	ldr	r3, [r3]
1002a0e0:	e2432008 	sub	r2, r3, #8
1002a0e4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a0e8:	e3413004 	movt	r3, #4100	; 0x1004
1002a0ec:	e5933000 	ldr	r3, [r3]
1002a0f0:	e2433008 	sub	r3, r3, #8
1002a0f4:	e5931000 	ldr	r1, [r3]
1002a0f8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a0fc:	e3413004 	movt	r3, #4100	; 0x1004
1002a100:	e5933000 	ldr	r3, [r3]
1002a104:	e2433004 	sub	r3, r3, #4
1002a108:	e5933000 	ldr	r3, [r3]
1002a10c:	e0813003 	add	r3, r1, r3
1002a110:	e5823000 	str	r3, [r2]
1002a114:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a118:	e3413004 	movt	r3, #4100	; 0x1004
1002a11c:	e5933000 	ldr	r3, [r3]
1002a120:	e2432004 	sub	r2, r3, #4
1002a124:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a128:	e3413004 	movt	r3, #4100	; 0x1004
1002a12c:	e5832000 	str	r2, [r3]

	return ;
1002a130:	e1a00000 	nop			; (mov r0, r0)
}
1002a134:	e24bd000 	sub	sp, fp, #0
1002a138:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a13c:	e12fff1e 	bx	lr

1002a140 <OP_sub_byte>:

/* --- sub --- */
void OP_sub_byte()
{
1002a140:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a144:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(-);
1002a148:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a14c:	e3413004 	movt	r3, #4100	; 0x1004
1002a150:	e5933000 	ldr	r3, [r3]
1002a154:	e2432008 	sub	r2, r3, #8
1002a158:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a15c:	e3413004 	movt	r3, #4100	; 0x1004
1002a160:	e5933000 	ldr	r3, [r3]
1002a164:	e2433008 	sub	r3, r3, #8
1002a168:	e5d31000 	ldrb	r1, [r3]
1002a16c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a170:	e3413004 	movt	r3, #4100	; 0x1004
1002a174:	e5933000 	ldr	r3, [r3]
1002a178:	e2433004 	sub	r3, r3, #4
1002a17c:	e5d33000 	ldrb	r3, [r3]
1002a180:	e0633001 	rsb	r3, r3, r1
1002a184:	e6ef3073 	uxtb	r3, r3
1002a188:	e5c23000 	strb	r3, [r2]
1002a18c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a190:	e3413004 	movt	r3, #4100	; 0x1004
1002a194:	e5933000 	ldr	r3, [r3]
1002a198:	e2432004 	sub	r2, r3, #4
1002a19c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a1a0:	e3413004 	movt	r3, #4100	; 0x1004
1002a1a4:	e5832000 	str	r2, [r3]

	return ;
1002a1a8:	e1a00000 	nop			; (mov r0, r0)
}
1002a1ac:	e24bd000 	sub	sp, fp, #0
1002a1b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a1b4:	e12fff1e 	bx	lr

1002a1b8 <OP_sub_word>:

void OP_sub_word()
{
1002a1b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a1bc:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(-);
1002a1c0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a1c4:	e3413004 	movt	r3, #4100	; 0x1004
1002a1c8:	e5933000 	ldr	r3, [r3]
1002a1cc:	e2432008 	sub	r2, r3, #8
1002a1d0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a1d4:	e3413004 	movt	r3, #4100	; 0x1004
1002a1d8:	e5933000 	ldr	r3, [r3]
1002a1dc:	e2433008 	sub	r3, r3, #8
1002a1e0:	e1d330b0 	ldrh	r3, [r3]
1002a1e4:	e6ff1073 	uxth	r1, r3
1002a1e8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a1ec:	e3413004 	movt	r3, #4100	; 0x1004
1002a1f0:	e5933000 	ldr	r3, [r3]
1002a1f4:	e2433004 	sub	r3, r3, #4
1002a1f8:	e1d330b0 	ldrh	r3, [r3]
1002a1fc:	e6ff3073 	uxth	r3, r3
1002a200:	e0633001 	rsb	r3, r3, r1
1002a204:	e6ff3073 	uxth	r3, r3
1002a208:	e6ff3073 	uxth	r3, r3
1002a20c:	e1c230b0 	strh	r3, [r2]
1002a210:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a214:	e3413004 	movt	r3, #4100	; 0x1004
1002a218:	e5933000 	ldr	r3, [r3]
1002a21c:	e2432004 	sub	r2, r3, #4
1002a220:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a224:	e3413004 	movt	r3, #4100	; 0x1004
1002a228:	e5832000 	str	r2, [r3]

	return ;
1002a22c:	e1a00000 	nop			; (mov r0, r0)
}
1002a230:	e24bd000 	sub	sp, fp, #0
1002a234:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a238:	e12fff1e 	bx	lr

1002a23c <OP_sub_dword>:

void OP_sub_dword()
{
1002a23c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a240:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(-);
1002a244:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a248:	e3413004 	movt	r3, #4100	; 0x1004
1002a24c:	e5933000 	ldr	r3, [r3]
1002a250:	e2432008 	sub	r2, r3, #8
1002a254:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a258:	e3413004 	movt	r3, #4100	; 0x1004
1002a25c:	e5933000 	ldr	r3, [r3]
1002a260:	e2433008 	sub	r3, r3, #8
1002a264:	e5931000 	ldr	r1, [r3]
1002a268:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a26c:	e3413004 	movt	r3, #4100	; 0x1004
1002a270:	e5933000 	ldr	r3, [r3]
1002a274:	e2433004 	sub	r3, r3, #4
1002a278:	e5933000 	ldr	r3, [r3]
1002a27c:	e0633001 	rsb	r3, r3, r1
1002a280:	e5823000 	str	r3, [r2]
1002a284:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a288:	e3413004 	movt	r3, #4100	; 0x1004
1002a28c:	e5933000 	ldr	r3, [r3]
1002a290:	e2432004 	sub	r2, r3, #4
1002a294:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a298:	e3413004 	movt	r3, #4100	; 0x1004
1002a29c:	e5832000 	str	r2, [r3]

	return ;
1002a2a0:	e1a00000 	nop			; (mov r0, r0)
}
1002a2a4:	e24bd000 	sub	sp, fp, #0
1002a2a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a2ac:	e12fff1e 	bx	lr

1002a2b0 <OP_div_byte>:

/* --- div --- */
void OP_div_byte()
{
1002a2b0:	e92d4818 	push	{r3, r4, fp, lr}
1002a2b4:	e28db00c 	add	fp, sp, #12
	OP_BIN_BYTE(/);
1002a2b8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a2bc:	e3413004 	movt	r3, #4100	; 0x1004
1002a2c0:	e5933000 	ldr	r3, [r3]
1002a2c4:	e2434008 	sub	r4, r3, #8
1002a2c8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a2cc:	e3413004 	movt	r3, #4100	; 0x1004
1002a2d0:	e5933000 	ldr	r3, [r3]
1002a2d4:	e2433008 	sub	r3, r3, #8
1002a2d8:	e5d32000 	ldrb	r2, [r3]
1002a2dc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a2e0:	e3413004 	movt	r3, #4100	; 0x1004
1002a2e4:	e5933000 	ldr	r3, [r3]
1002a2e8:	e2433004 	sub	r3, r3, #4
1002a2ec:	e5d33000 	ldrb	r3, [r3]
1002a2f0:	e1a00002 	mov	r0, r2
1002a2f4:	e1a01003 	mov	r1, r3
1002a2f8:	fa0012b0 	blx	1002edc0 <__aeabi_uidiv>
1002a2fc:	e1a03000 	mov	r3, r0
1002a300:	e6ef3073 	uxtb	r3, r3
1002a304:	e5c43000 	strb	r3, [r4]
1002a308:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a30c:	e3413004 	movt	r3, #4100	; 0x1004
1002a310:	e5933000 	ldr	r3, [r3]
1002a314:	e2432004 	sub	r2, r3, #4
1002a318:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a31c:	e3413004 	movt	r3, #4100	; 0x1004
1002a320:	e5832000 	str	r2, [r3]

	return ;
1002a324:	e1a00000 	nop			; (mov r0, r0)
}
1002a328:	e8bd8818 	pop	{r3, r4, fp, pc}

1002a32c <OP_div_word>:

void OP_div_word()
{
1002a32c:	e92d4818 	push	{r3, r4, fp, lr}
1002a330:	e28db00c 	add	fp, sp, #12
	OP_BIN_WORD(/);
1002a334:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a338:	e3413004 	movt	r3, #4100	; 0x1004
1002a33c:	e5933000 	ldr	r3, [r3]
1002a340:	e2434008 	sub	r4, r3, #8
1002a344:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a348:	e3413004 	movt	r3, #4100	; 0x1004
1002a34c:	e5933000 	ldr	r3, [r3]
1002a350:	e2433008 	sub	r3, r3, #8
1002a354:	e1d330b0 	ldrh	r3, [r3]
1002a358:	e6bf2073 	sxth	r2, r3
1002a35c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a360:	e3413004 	movt	r3, #4100	; 0x1004
1002a364:	e5933000 	ldr	r3, [r3]
1002a368:	e2433004 	sub	r3, r3, #4
1002a36c:	e1d330b0 	ldrh	r3, [r3]
1002a370:	e6bf3073 	sxth	r3, r3
1002a374:	e1a00002 	mov	r0, r2
1002a378:	e1a01003 	mov	r1, r3
1002a37c:	fa00132d 	blx	1002f038 <__aeabi_idiv>
1002a380:	e1a03000 	mov	r3, r0
1002a384:	e6ff3073 	uxth	r3, r3
1002a388:	e1c430b0 	strh	r3, [r4]
1002a38c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a390:	e3413004 	movt	r3, #4100	; 0x1004
1002a394:	e5933000 	ldr	r3, [r3]
1002a398:	e2432004 	sub	r2, r3, #4
1002a39c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a3a0:	e3413004 	movt	r3, #4100	; 0x1004
1002a3a4:	e5832000 	str	r2, [r3]

	return ;
1002a3a8:	e1a00000 	nop			; (mov r0, r0)
}
1002a3ac:	e8bd8818 	pop	{r3, r4, fp, pc}

1002a3b0 <OP_div_dword>:

void OP_div_dword()
{
1002a3b0:	e92d4818 	push	{r3, r4, fp, lr}
1002a3b4:	e28db00c 	add	fp, sp, #12
	OP_BIN_DWORD(/);
1002a3b8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a3bc:	e3413004 	movt	r3, #4100	; 0x1004
1002a3c0:	e5933000 	ldr	r3, [r3]
1002a3c4:	e2434008 	sub	r4, r3, #8
1002a3c8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a3cc:	e3413004 	movt	r3, #4100	; 0x1004
1002a3d0:	e5933000 	ldr	r3, [r3]
1002a3d4:	e2433008 	sub	r3, r3, #8
1002a3d8:	e5932000 	ldr	r2, [r3]
1002a3dc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a3e0:	e3413004 	movt	r3, #4100	; 0x1004
1002a3e4:	e5933000 	ldr	r3, [r3]
1002a3e8:	e2433004 	sub	r3, r3, #4
1002a3ec:	e5933000 	ldr	r3, [r3]
1002a3f0:	e1a00002 	mov	r0, r2
1002a3f4:	e1a01003 	mov	r1, r3
1002a3f8:	fa00130e 	blx	1002f038 <__aeabi_idiv>
1002a3fc:	e1a03000 	mov	r3, r0
1002a400:	e5843000 	str	r3, [r4]
1002a404:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a408:	e3413004 	movt	r3, #4100	; 0x1004
1002a40c:	e5933000 	ldr	r3, [r3]
1002a410:	e2432004 	sub	r2, r3, #4
1002a414:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a418:	e3413004 	movt	r3, #4100	; 0x1004
1002a41c:	e5832000 	str	r2, [r3]

	return ;
1002a420:	e1a00000 	nop			; (mov r0, r0)
}
1002a424:	e8bd8818 	pop	{r3, r4, fp, pc}

1002a428 <OP_mod_byte>:

/* --- mod --- */
void OP_mod_byte()
{
1002a428:	e92d4818 	push	{r3, r4, fp, lr}
1002a42c:	e28db00c 	add	fp, sp, #12
	OP_BIN_BYTE(%);
1002a430:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a434:	e3413004 	movt	r3, #4100	; 0x1004
1002a438:	e5933000 	ldr	r3, [r3]
1002a43c:	e2434008 	sub	r4, r3, #8
1002a440:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a444:	e3413004 	movt	r3, #4100	; 0x1004
1002a448:	e5933000 	ldr	r3, [r3]
1002a44c:	e2433008 	sub	r3, r3, #8
1002a450:	e5d32000 	ldrb	r2, [r3]
1002a454:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a458:	e3413004 	movt	r3, #4100	; 0x1004
1002a45c:	e5933000 	ldr	r3, [r3]
1002a460:	e2433004 	sub	r3, r3, #4
1002a464:	e5d33000 	ldrb	r3, [r3]
1002a468:	e1a00002 	mov	r0, r2
1002a46c:	e1a01003 	mov	r1, r3
1002a470:	fa0012e9 	blx	1002f01c <__aeabi_uidivmod>
1002a474:	e1a03001 	mov	r3, r1
1002a478:	e6ef3073 	uxtb	r3, r3
1002a47c:	e5c43000 	strb	r3, [r4]
1002a480:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a484:	e3413004 	movt	r3, #4100	; 0x1004
1002a488:	e5933000 	ldr	r3, [r3]
1002a48c:	e2432004 	sub	r2, r3, #4
1002a490:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a494:	e3413004 	movt	r3, #4100	; 0x1004
1002a498:	e5832000 	str	r2, [r3]

	return ;
1002a49c:	e1a00000 	nop			; (mov r0, r0)
}
1002a4a0:	e8bd8818 	pop	{r3, r4, fp, pc}

1002a4a4 <OP_mod_word>:

void OP_mod_word()
{
1002a4a4:	e92d4818 	push	{r3, r4, fp, lr}
1002a4a8:	e28db00c 	add	fp, sp, #12
	OP_BIN_WORD(%);
1002a4ac:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a4b0:	e3413004 	movt	r3, #4100	; 0x1004
1002a4b4:	e5933000 	ldr	r3, [r3]
1002a4b8:	e2434008 	sub	r4, r3, #8
1002a4bc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a4c0:	e3413004 	movt	r3, #4100	; 0x1004
1002a4c4:	e5933000 	ldr	r3, [r3]
1002a4c8:	e2433008 	sub	r3, r3, #8
1002a4cc:	e1d330b0 	ldrh	r3, [r3]
1002a4d0:	e6bf2073 	sxth	r2, r3
1002a4d4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a4d8:	e3413004 	movt	r3, #4100	; 0x1004
1002a4dc:	e5933000 	ldr	r3, [r3]
1002a4e0:	e2433004 	sub	r3, r3, #4
1002a4e4:	e1d330b0 	ldrh	r3, [r3]
1002a4e8:	e6bf3073 	sxth	r3, r3
1002a4ec:	e1a00002 	mov	r0, r2
1002a4f0:	e1a01003 	mov	r1, r3
1002a4f4:	fa001374 	blx	1002f2cc <__aeabi_idivmod>
1002a4f8:	e1a03001 	mov	r3, r1
1002a4fc:	e6ff3073 	uxth	r3, r3
1002a500:	e1c430b0 	strh	r3, [r4]
1002a504:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a508:	e3413004 	movt	r3, #4100	; 0x1004
1002a50c:	e5933000 	ldr	r3, [r3]
1002a510:	e2432004 	sub	r2, r3, #4
1002a514:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a518:	e3413004 	movt	r3, #4100	; 0x1004
1002a51c:	e5832000 	str	r2, [r3]

	return ;
1002a520:	e1a00000 	nop			; (mov r0, r0)
}
1002a524:	e8bd8818 	pop	{r3, r4, fp, pc}

1002a528 <OP_mod_dword>:

void OP_mod_dword()
{
1002a528:	e92d4818 	push	{r3, r4, fp, lr}
1002a52c:	e28db00c 	add	fp, sp, #12
	OP_BIN_DWORD(%);
1002a530:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a534:	e3413004 	movt	r3, #4100	; 0x1004
1002a538:	e5933000 	ldr	r3, [r3]
1002a53c:	e2434008 	sub	r4, r3, #8
1002a540:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a544:	e3413004 	movt	r3, #4100	; 0x1004
1002a548:	e5933000 	ldr	r3, [r3]
1002a54c:	e2433008 	sub	r3, r3, #8
1002a550:	e5932000 	ldr	r2, [r3]
1002a554:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a558:	e3413004 	movt	r3, #4100	; 0x1004
1002a55c:	e5933000 	ldr	r3, [r3]
1002a560:	e2433004 	sub	r3, r3, #4
1002a564:	e5933000 	ldr	r3, [r3]
1002a568:	e1a00002 	mov	r0, r2
1002a56c:	e1a01003 	mov	r1, r3
1002a570:	fa001355 	blx	1002f2cc <__aeabi_idivmod>
1002a574:	e1a03001 	mov	r3, r1
1002a578:	e5843000 	str	r3, [r4]
1002a57c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a580:	e3413004 	movt	r3, #4100	; 0x1004
1002a584:	e5933000 	ldr	r3, [r3]
1002a588:	e2432004 	sub	r2, r3, #4
1002a58c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a590:	e3413004 	movt	r3, #4100	; 0x1004
1002a594:	e5832000 	str	r2, [r3]

	return ;
1002a598:	e1a00000 	nop			; (mov r0, r0)
}
1002a59c:	e8bd8818 	pop	{r3, r4, fp, pc}

1002a5a0 <OP_mul_byte>:

/* --- mul --- */
void OP_mul_byte()
{
1002a5a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a5a4:	e28db000 	add	fp, sp, #0
    OP_BIN_BYTE(*);
1002a5a8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a5ac:	e3413004 	movt	r3, #4100	; 0x1004
1002a5b0:	e5933000 	ldr	r3, [r3]
1002a5b4:	e2432008 	sub	r2, r3, #8
1002a5b8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a5bc:	e3413004 	movt	r3, #4100	; 0x1004
1002a5c0:	e5933000 	ldr	r3, [r3]
1002a5c4:	e2433008 	sub	r3, r3, #8
1002a5c8:	e5d31000 	ldrb	r1, [r3]
1002a5cc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a5d0:	e3413004 	movt	r3, #4100	; 0x1004
1002a5d4:	e5933000 	ldr	r3, [r3]
1002a5d8:	e2433004 	sub	r3, r3, #4
1002a5dc:	e5d33000 	ldrb	r3, [r3]
1002a5e0:	e1630381 	smulbb	r3, r1, r3
1002a5e4:	e6ef3073 	uxtb	r3, r3
1002a5e8:	e5c23000 	strb	r3, [r2]
1002a5ec:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a5f0:	e3413004 	movt	r3, #4100	; 0x1004
1002a5f4:	e5933000 	ldr	r3, [r3]
1002a5f8:	e2432004 	sub	r2, r3, #4
1002a5fc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a600:	e3413004 	movt	r3, #4100	; 0x1004
1002a604:	e5832000 	str	r2, [r3]

	return ;
1002a608:	e1a00000 	nop			; (mov r0, r0)
}
1002a60c:	e24bd000 	sub	sp, fp, #0
1002a610:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a614:	e12fff1e 	bx	lr

1002a618 <OP_mul_word>:

void OP_mul_word()
{
1002a618:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a61c:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(*);
1002a620:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a624:	e3413004 	movt	r3, #4100	; 0x1004
1002a628:	e5933000 	ldr	r3, [r3]
1002a62c:	e2432008 	sub	r2, r3, #8
1002a630:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a634:	e3413004 	movt	r3, #4100	; 0x1004
1002a638:	e5933000 	ldr	r3, [r3]
1002a63c:	e2433008 	sub	r3, r3, #8
1002a640:	e1d330b0 	ldrh	r3, [r3]
1002a644:	e6ff1073 	uxth	r1, r3
1002a648:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a64c:	e3413004 	movt	r3, #4100	; 0x1004
1002a650:	e5933000 	ldr	r3, [r3]
1002a654:	e2433004 	sub	r3, r3, #4
1002a658:	e1d330b0 	ldrh	r3, [r3]
1002a65c:	e6ff3073 	uxth	r3, r3
1002a660:	e1630381 	smulbb	r3, r1, r3
1002a664:	e6ff3073 	uxth	r3, r3
1002a668:	e6ff3073 	uxth	r3, r3
1002a66c:	e1c230b0 	strh	r3, [r2]
1002a670:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a674:	e3413004 	movt	r3, #4100	; 0x1004
1002a678:	e5933000 	ldr	r3, [r3]
1002a67c:	e2432004 	sub	r2, r3, #4
1002a680:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a684:	e3413004 	movt	r3, #4100	; 0x1004
1002a688:	e5832000 	str	r2, [r3]

	return ;
1002a68c:	e1a00000 	nop			; (mov r0, r0)
}
1002a690:	e24bd000 	sub	sp, fp, #0
1002a694:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a698:	e12fff1e 	bx	lr

1002a69c <OP_mul_dword>:

void OP_mul_dword()
{
1002a69c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a6a0:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(*);
1002a6a4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a6a8:	e3413004 	movt	r3, #4100	; 0x1004
1002a6ac:	e5933000 	ldr	r3, [r3]
1002a6b0:	e2432008 	sub	r2, r3, #8
1002a6b4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a6b8:	e3413004 	movt	r3, #4100	; 0x1004
1002a6bc:	e5933000 	ldr	r3, [r3]
1002a6c0:	e2433008 	sub	r3, r3, #8
1002a6c4:	e5931000 	ldr	r1, [r3]
1002a6c8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a6cc:	e3413004 	movt	r3, #4100	; 0x1004
1002a6d0:	e5933000 	ldr	r3, [r3]
1002a6d4:	e2433004 	sub	r3, r3, #4
1002a6d8:	e5933000 	ldr	r3, [r3]
1002a6dc:	e0030193 	mul	r3, r3, r1
1002a6e0:	e5823000 	str	r3, [r2]
1002a6e4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a6e8:	e3413004 	movt	r3, #4100	; 0x1004
1002a6ec:	e5933000 	ldr	r3, [r3]
1002a6f0:	e2432004 	sub	r2, r3, #4
1002a6f4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a6f8:	e3413004 	movt	r3, #4100	; 0x1004
1002a6fc:	e5832000 	str	r2, [r3]

	return ;
1002a700:	e1a00000 	nop			; (mov r0, r0)
}
1002a704:	e24bd000 	sub	sp, fp, #0
1002a708:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a70c:	e12fff1e 	bx	lr

1002a710 <OP_and_byte>:

/* --- and --- */
void OP_and_byte()
{
1002a710:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a714:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(&);
1002a718:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a71c:	e3413004 	movt	r3, #4100	; 0x1004
1002a720:	e5933000 	ldr	r3, [r3]
1002a724:	e2432008 	sub	r2, r3, #8
1002a728:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a72c:	e3413004 	movt	r3, #4100	; 0x1004
1002a730:	e5933000 	ldr	r3, [r3]
1002a734:	e2433008 	sub	r3, r3, #8
1002a738:	e5d31000 	ldrb	r1, [r3]
1002a73c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a740:	e3413004 	movt	r3, #4100	; 0x1004
1002a744:	e5933000 	ldr	r3, [r3]
1002a748:	e2433004 	sub	r3, r3, #4
1002a74c:	e5d33000 	ldrb	r3, [r3]
1002a750:	e0033001 	and	r3, r3, r1
1002a754:	e6ef3073 	uxtb	r3, r3
1002a758:	e5c23000 	strb	r3, [r2]
1002a75c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a760:	e3413004 	movt	r3, #4100	; 0x1004
1002a764:	e5933000 	ldr	r3, [r3]
1002a768:	e2432004 	sub	r2, r3, #4
1002a76c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a770:	e3413004 	movt	r3, #4100	; 0x1004
1002a774:	e5832000 	str	r2, [r3]

	return ;
1002a778:	e1a00000 	nop			; (mov r0, r0)
}
1002a77c:	e24bd000 	sub	sp, fp, #0
1002a780:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a784:	e12fff1e 	bx	lr

1002a788 <OP_and_word>:

void OP_and_word()
{
1002a788:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a78c:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(&);
1002a790:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a794:	e3413004 	movt	r3, #4100	; 0x1004
1002a798:	e5933000 	ldr	r3, [r3]
1002a79c:	e2432008 	sub	r2, r3, #8
1002a7a0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a7a4:	e3413004 	movt	r3, #4100	; 0x1004
1002a7a8:	e5933000 	ldr	r3, [r3]
1002a7ac:	e2433008 	sub	r3, r3, #8
1002a7b0:	e1d310b0 	ldrh	r1, [r3]
1002a7b4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a7b8:	e3413004 	movt	r3, #4100	; 0x1004
1002a7bc:	e5933000 	ldr	r3, [r3]
1002a7c0:	e2433004 	sub	r3, r3, #4
1002a7c4:	e1d330b0 	ldrh	r3, [r3]
1002a7c8:	e0033001 	and	r3, r3, r1
1002a7cc:	e6ff3073 	uxth	r3, r3
1002a7d0:	e1c230b0 	strh	r3, [r2]
1002a7d4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a7d8:	e3413004 	movt	r3, #4100	; 0x1004
1002a7dc:	e5933000 	ldr	r3, [r3]
1002a7e0:	e2432004 	sub	r2, r3, #4
1002a7e4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a7e8:	e3413004 	movt	r3, #4100	; 0x1004
1002a7ec:	e5832000 	str	r2, [r3]

	return ;
1002a7f0:	e1a00000 	nop			; (mov r0, r0)
}
1002a7f4:	e24bd000 	sub	sp, fp, #0
1002a7f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a7fc:	e12fff1e 	bx	lr

1002a800 <OP_and_dword>:

void OP_and_dword()
{
1002a800:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a804:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(&);
1002a808:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a80c:	e3413004 	movt	r3, #4100	; 0x1004
1002a810:	e5933000 	ldr	r3, [r3]
1002a814:	e2432008 	sub	r2, r3, #8
1002a818:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a81c:	e3413004 	movt	r3, #4100	; 0x1004
1002a820:	e5933000 	ldr	r3, [r3]
1002a824:	e2433008 	sub	r3, r3, #8
1002a828:	e5931000 	ldr	r1, [r3]
1002a82c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a830:	e3413004 	movt	r3, #4100	; 0x1004
1002a834:	e5933000 	ldr	r3, [r3]
1002a838:	e2433004 	sub	r3, r3, #4
1002a83c:	e5933000 	ldr	r3, [r3]
1002a840:	e0033001 	and	r3, r3, r1
1002a844:	e5823000 	str	r3, [r2]
1002a848:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a84c:	e3413004 	movt	r3, #4100	; 0x1004
1002a850:	e5933000 	ldr	r3, [r3]
1002a854:	e2432004 	sub	r2, r3, #4
1002a858:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a85c:	e3413004 	movt	r3, #4100	; 0x1004
1002a860:	e5832000 	str	r2, [r3]

	return ;
1002a864:	e1a00000 	nop			; (mov r0, r0)
}
1002a868:	e24bd000 	sub	sp, fp, #0
1002a86c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a870:	e12fff1e 	bx	lr

1002a874 <OP_or_byte>:

/* --- or --- */
void OP_or_byte()
{
1002a874:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a878:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(|);
1002a87c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a880:	e3413004 	movt	r3, #4100	; 0x1004
1002a884:	e5933000 	ldr	r3, [r3]
1002a888:	e2432008 	sub	r2, r3, #8
1002a88c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a890:	e3413004 	movt	r3, #4100	; 0x1004
1002a894:	e5933000 	ldr	r3, [r3]
1002a898:	e2433008 	sub	r3, r3, #8
1002a89c:	e5d31000 	ldrb	r1, [r3]
1002a8a0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a8a4:	e3413004 	movt	r3, #4100	; 0x1004
1002a8a8:	e5933000 	ldr	r3, [r3]
1002a8ac:	e2433004 	sub	r3, r3, #4
1002a8b0:	e5d33000 	ldrb	r3, [r3]
1002a8b4:	e1813003 	orr	r3, r1, r3
1002a8b8:	e6ef3073 	uxtb	r3, r3
1002a8bc:	e5c23000 	strb	r3, [r2]
1002a8c0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a8c4:	e3413004 	movt	r3, #4100	; 0x1004
1002a8c8:	e5933000 	ldr	r3, [r3]
1002a8cc:	e2432004 	sub	r2, r3, #4
1002a8d0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a8d4:	e3413004 	movt	r3, #4100	; 0x1004
1002a8d8:	e5832000 	str	r2, [r3]

	return ;
1002a8dc:	e1a00000 	nop			; (mov r0, r0)
}
1002a8e0:	e24bd000 	sub	sp, fp, #0
1002a8e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a8e8:	e12fff1e 	bx	lr

1002a8ec <OP_or_word>:

void OP_or_word()
{
1002a8ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a8f0:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(|);
1002a8f4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a8f8:	e3413004 	movt	r3, #4100	; 0x1004
1002a8fc:	e5933000 	ldr	r3, [r3]
1002a900:	e2432008 	sub	r2, r3, #8
1002a904:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a908:	e3413004 	movt	r3, #4100	; 0x1004
1002a90c:	e5933000 	ldr	r3, [r3]
1002a910:	e2433008 	sub	r3, r3, #8
1002a914:	e1d310b0 	ldrh	r1, [r3]
1002a918:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a91c:	e3413004 	movt	r3, #4100	; 0x1004
1002a920:	e5933000 	ldr	r3, [r3]
1002a924:	e2433004 	sub	r3, r3, #4
1002a928:	e1d330b0 	ldrh	r3, [r3]
1002a92c:	e1813003 	orr	r3, r1, r3
1002a930:	e6ff3073 	uxth	r3, r3
1002a934:	e1c230b0 	strh	r3, [r2]
1002a938:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a93c:	e3413004 	movt	r3, #4100	; 0x1004
1002a940:	e5933000 	ldr	r3, [r3]
1002a944:	e2432004 	sub	r2, r3, #4
1002a948:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a94c:	e3413004 	movt	r3, #4100	; 0x1004
1002a950:	e5832000 	str	r2, [r3]

	return ;
1002a954:	e1a00000 	nop			; (mov r0, r0)
}
1002a958:	e24bd000 	sub	sp, fp, #0
1002a95c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a960:	e12fff1e 	bx	lr

1002a964 <OP_or_dword>:

void OP_or_dword()
{
1002a964:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a968:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(|);
1002a96c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a970:	e3413004 	movt	r3, #4100	; 0x1004
1002a974:	e5933000 	ldr	r3, [r3]
1002a978:	e2432008 	sub	r2, r3, #8
1002a97c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a980:	e3413004 	movt	r3, #4100	; 0x1004
1002a984:	e5933000 	ldr	r3, [r3]
1002a988:	e2433008 	sub	r3, r3, #8
1002a98c:	e5931000 	ldr	r1, [r3]
1002a990:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a994:	e3413004 	movt	r3, #4100	; 0x1004
1002a998:	e5933000 	ldr	r3, [r3]
1002a99c:	e2433004 	sub	r3, r3, #4
1002a9a0:	e5933000 	ldr	r3, [r3]
1002a9a4:	e1813003 	orr	r3, r1, r3
1002a9a8:	e5823000 	str	r3, [r2]
1002a9ac:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a9b0:	e3413004 	movt	r3, #4100	; 0x1004
1002a9b4:	e5933000 	ldr	r3, [r3]
1002a9b8:	e2432004 	sub	r2, r3, #4
1002a9bc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a9c0:	e3413004 	movt	r3, #4100	; 0x1004
1002a9c4:	e5832000 	str	r2, [r3]

	return ;
1002a9c8:	e1a00000 	nop			; (mov r0, r0)
}
1002a9cc:	e24bd000 	sub	sp, fp, #0
1002a9d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002a9d4:	e12fff1e 	bx	lr

1002a9d8 <OP_xor_byte>:

/* --- xor --- */
void OP_xor_byte()
{
1002a9d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002a9dc:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(^);
1002a9e0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a9e4:	e3413004 	movt	r3, #4100	; 0x1004
1002a9e8:	e5933000 	ldr	r3, [r3]
1002a9ec:	e2432008 	sub	r2, r3, #8
1002a9f0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002a9f4:	e3413004 	movt	r3, #4100	; 0x1004
1002a9f8:	e5933000 	ldr	r3, [r3]
1002a9fc:	e2433008 	sub	r3, r3, #8
1002aa00:	e5d31000 	ldrb	r1, [r3]
1002aa04:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aa08:	e3413004 	movt	r3, #4100	; 0x1004
1002aa0c:	e5933000 	ldr	r3, [r3]
1002aa10:	e2433004 	sub	r3, r3, #4
1002aa14:	e5d33000 	ldrb	r3, [r3]
1002aa18:	e0233001 	eor	r3, r3, r1
1002aa1c:	e6ef3073 	uxtb	r3, r3
1002aa20:	e5c23000 	strb	r3, [r2]
1002aa24:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aa28:	e3413004 	movt	r3, #4100	; 0x1004
1002aa2c:	e5933000 	ldr	r3, [r3]
1002aa30:	e2432004 	sub	r2, r3, #4
1002aa34:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aa38:	e3413004 	movt	r3, #4100	; 0x1004
1002aa3c:	e5832000 	str	r2, [r3]

	return ;
1002aa40:	e1a00000 	nop			; (mov r0, r0)
}
1002aa44:	e24bd000 	sub	sp, fp, #0
1002aa48:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002aa4c:	e12fff1e 	bx	lr

1002aa50 <OP_xor_word>:

void OP_xor_word()
{
1002aa50:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002aa54:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(^);
1002aa58:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aa5c:	e3413004 	movt	r3, #4100	; 0x1004
1002aa60:	e5933000 	ldr	r3, [r3]
1002aa64:	e2432008 	sub	r2, r3, #8
1002aa68:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aa6c:	e3413004 	movt	r3, #4100	; 0x1004
1002aa70:	e5933000 	ldr	r3, [r3]
1002aa74:	e2433008 	sub	r3, r3, #8
1002aa78:	e1d310b0 	ldrh	r1, [r3]
1002aa7c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aa80:	e3413004 	movt	r3, #4100	; 0x1004
1002aa84:	e5933000 	ldr	r3, [r3]
1002aa88:	e2433004 	sub	r3, r3, #4
1002aa8c:	e1d330b0 	ldrh	r3, [r3]
1002aa90:	e0233001 	eor	r3, r3, r1
1002aa94:	e6ff3073 	uxth	r3, r3
1002aa98:	e1c230b0 	strh	r3, [r2]
1002aa9c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aaa0:	e3413004 	movt	r3, #4100	; 0x1004
1002aaa4:	e5933000 	ldr	r3, [r3]
1002aaa8:	e2432004 	sub	r2, r3, #4
1002aaac:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aab0:	e3413004 	movt	r3, #4100	; 0x1004
1002aab4:	e5832000 	str	r2, [r3]

	return ;
1002aab8:	e1a00000 	nop			; (mov r0, r0)
}
1002aabc:	e24bd000 	sub	sp, fp, #0
1002aac0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002aac4:	e12fff1e 	bx	lr

1002aac8 <OP_xor_dword>:

void OP_xor_dword()
{
1002aac8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002aacc:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(^);
1002aad0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aad4:	e3413004 	movt	r3, #4100	; 0x1004
1002aad8:	e5933000 	ldr	r3, [r3]
1002aadc:	e2432008 	sub	r2, r3, #8
1002aae0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aae4:	e3413004 	movt	r3, #4100	; 0x1004
1002aae8:	e5933000 	ldr	r3, [r3]
1002aaec:	e2433008 	sub	r3, r3, #8
1002aaf0:	e5931000 	ldr	r1, [r3]
1002aaf4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aaf8:	e3413004 	movt	r3, #4100	; 0x1004
1002aafc:	e5933000 	ldr	r3, [r3]
1002ab00:	e2433004 	sub	r3, r3, #4
1002ab04:	e5933000 	ldr	r3, [r3]
1002ab08:	e0233001 	eor	r3, r3, r1
1002ab0c:	e5823000 	str	r3, [r2]
1002ab10:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ab14:	e3413004 	movt	r3, #4100	; 0x1004
1002ab18:	e5933000 	ldr	r3, [r3]
1002ab1c:	e2432004 	sub	r2, r3, #4
1002ab20:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ab24:	e3413004 	movt	r3, #4100	; 0x1004
1002ab28:	e5832000 	str	r2, [r3]

	return ;
1002ab2c:	e1a00000 	nop			; (mov r0, r0)
}
1002ab30:	e24bd000 	sub	sp, fp, #0
1002ab34:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002ab38:	e12fff1e 	bx	lr

1002ab3c <OP_bw_byte>:

/* --- bw --- */
void OP_bw_byte()
{
1002ab3c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ab40:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->char_value = ~ ((finsh_sp - 1)->char_value);
1002ab44:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ab48:	e3413004 	movt	r3, #4100	; 0x1004
1002ab4c:	e5933000 	ldr	r3, [r3]
1002ab50:	e2432004 	sub	r2, r3, #4
1002ab54:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ab58:	e3413004 	movt	r3, #4100	; 0x1004
1002ab5c:	e5933000 	ldr	r3, [r3]
1002ab60:	e2433004 	sub	r3, r3, #4
1002ab64:	e5d33000 	ldrb	r3, [r3]
1002ab68:	e1e03003 	mvn	r3, r3
1002ab6c:	e6ef3073 	uxtb	r3, r3
1002ab70:	e5c23000 	strb	r3, [r2]

	return ;
1002ab74:	e1a00000 	nop			; (mov r0, r0)
}
1002ab78:	e24bd000 	sub	sp, fp, #0
1002ab7c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002ab80:	e12fff1e 	bx	lr

1002ab84 <OP_bw_word>:

void OP_bw_word()
{
1002ab84:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ab88:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->short_value = ~ ((finsh_sp - 1)->short_value);
1002ab8c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ab90:	e3413004 	movt	r3, #4100	; 0x1004
1002ab94:	e5933000 	ldr	r3, [r3]
1002ab98:	e2432004 	sub	r2, r3, #4
1002ab9c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aba0:	e3413004 	movt	r3, #4100	; 0x1004
1002aba4:	e5933000 	ldr	r3, [r3]
1002aba8:	e2433004 	sub	r3, r3, #4
1002abac:	e1d330b0 	ldrh	r3, [r3]
1002abb0:	e1e03003 	mvn	r3, r3
1002abb4:	e6ff3073 	uxth	r3, r3
1002abb8:	e1c230b0 	strh	r3, [r2]

	return ;
1002abbc:	e1a00000 	nop			; (mov r0, r0)
}
1002abc0:	e24bd000 	sub	sp, fp, #0
1002abc4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002abc8:	e12fff1e 	bx	lr

1002abcc <OP_bw_dword>:

void OP_bw_dword()
{
1002abcc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002abd0:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->long_value = ~ ((finsh_sp - 1)->long_value);
1002abd4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002abd8:	e3413004 	movt	r3, #4100	; 0x1004
1002abdc:	e5933000 	ldr	r3, [r3]
1002abe0:	e2432004 	sub	r2, r3, #4
1002abe4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002abe8:	e3413004 	movt	r3, #4100	; 0x1004
1002abec:	e5933000 	ldr	r3, [r3]
1002abf0:	e2433004 	sub	r3, r3, #4
1002abf4:	e5933000 	ldr	r3, [r3]
1002abf8:	e1e03003 	mvn	r3, r3
1002abfc:	e5823000 	str	r3, [r2]

	return ;
1002ac00:	e1a00000 	nop			; (mov r0, r0)
}
1002ac04:	e24bd000 	sub	sp, fp, #0
1002ac08:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002ac0c:	e12fff1e 	bx	lr

1002ac10 <OP_shl_byte>:

/* --- shl --- */
void OP_shl_byte()
{
1002ac10:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ac14:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(<<);
1002ac18:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ac1c:	e3413004 	movt	r3, #4100	; 0x1004
1002ac20:	e5933000 	ldr	r3, [r3]
1002ac24:	e2432008 	sub	r2, r3, #8
1002ac28:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ac2c:	e3413004 	movt	r3, #4100	; 0x1004
1002ac30:	e5933000 	ldr	r3, [r3]
1002ac34:	e2433008 	sub	r3, r3, #8
1002ac38:	e5d33000 	ldrb	r3, [r3]
1002ac3c:	e1a01003 	mov	r1, r3
1002ac40:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ac44:	e3413004 	movt	r3, #4100	; 0x1004
1002ac48:	e5933000 	ldr	r3, [r3]
1002ac4c:	e2433004 	sub	r3, r3, #4
1002ac50:	e5d33000 	ldrb	r3, [r3]
1002ac54:	e1a03311 	lsl	r3, r1, r3
1002ac58:	e6ef3073 	uxtb	r3, r3
1002ac5c:	e5c23000 	strb	r3, [r2]
1002ac60:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ac64:	e3413004 	movt	r3, #4100	; 0x1004
1002ac68:	e5933000 	ldr	r3, [r3]
1002ac6c:	e2432004 	sub	r2, r3, #4
1002ac70:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ac74:	e3413004 	movt	r3, #4100	; 0x1004
1002ac78:	e5832000 	str	r2, [r3]

	return ;
1002ac7c:	e1a00000 	nop			; (mov r0, r0)
}
1002ac80:	e24bd000 	sub	sp, fp, #0
1002ac84:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002ac88:	e12fff1e 	bx	lr

1002ac8c <OP_shl_word>:

void OP_shl_word()
{
1002ac8c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ac90:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(<<);
1002ac94:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ac98:	e3413004 	movt	r3, #4100	; 0x1004
1002ac9c:	e5933000 	ldr	r3, [r3]
1002aca0:	e2432008 	sub	r2, r3, #8
1002aca4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aca8:	e3413004 	movt	r3, #4100	; 0x1004
1002acac:	e5933000 	ldr	r3, [r3]
1002acb0:	e2433008 	sub	r3, r3, #8
1002acb4:	e1d330b0 	ldrh	r3, [r3]
1002acb8:	e6bf1073 	sxth	r1, r3
1002acbc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002acc0:	e3413004 	movt	r3, #4100	; 0x1004
1002acc4:	e5933000 	ldr	r3, [r3]
1002acc8:	e2433004 	sub	r3, r3, #4
1002accc:	e1d330b0 	ldrh	r3, [r3]
1002acd0:	e6bf3073 	sxth	r3, r3
1002acd4:	e1a03311 	lsl	r3, r1, r3
1002acd8:	e6ff3073 	uxth	r3, r3
1002acdc:	e1c230b0 	strh	r3, [r2]
1002ace0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ace4:	e3413004 	movt	r3, #4100	; 0x1004
1002ace8:	e5933000 	ldr	r3, [r3]
1002acec:	e2432004 	sub	r2, r3, #4
1002acf0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002acf4:	e3413004 	movt	r3, #4100	; 0x1004
1002acf8:	e5832000 	str	r2, [r3]

	return ;
1002acfc:	e1a00000 	nop			; (mov r0, r0)
}
1002ad00:	e24bd000 	sub	sp, fp, #0
1002ad04:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002ad08:	e12fff1e 	bx	lr

1002ad0c <OP_shl_dword>:

void OP_shl_dword()
{
1002ad0c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ad10:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(<<);
1002ad14:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ad18:	e3413004 	movt	r3, #4100	; 0x1004
1002ad1c:	e5933000 	ldr	r3, [r3]
1002ad20:	e2432008 	sub	r2, r3, #8
1002ad24:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ad28:	e3413004 	movt	r3, #4100	; 0x1004
1002ad2c:	e5933000 	ldr	r3, [r3]
1002ad30:	e2433008 	sub	r3, r3, #8
1002ad34:	e5931000 	ldr	r1, [r3]
1002ad38:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ad3c:	e3413004 	movt	r3, #4100	; 0x1004
1002ad40:	e5933000 	ldr	r3, [r3]
1002ad44:	e2433004 	sub	r3, r3, #4
1002ad48:	e5933000 	ldr	r3, [r3]
1002ad4c:	e1a03311 	lsl	r3, r1, r3
1002ad50:	e5823000 	str	r3, [r2]
1002ad54:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ad58:	e3413004 	movt	r3, #4100	; 0x1004
1002ad5c:	e5933000 	ldr	r3, [r3]
1002ad60:	e2432004 	sub	r2, r3, #4
1002ad64:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ad68:	e3413004 	movt	r3, #4100	; 0x1004
1002ad6c:	e5832000 	str	r2, [r3]

	return ;
1002ad70:	e1a00000 	nop			; (mov r0, r0)
}
1002ad74:	e24bd000 	sub	sp, fp, #0
1002ad78:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002ad7c:	e12fff1e 	bx	lr

1002ad80 <OP_shr_byte>:

/* --- shr --- */
void OP_shr_byte()
{
1002ad80:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ad84:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(>>);
1002ad88:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ad8c:	e3413004 	movt	r3, #4100	; 0x1004
1002ad90:	e5933000 	ldr	r3, [r3]
1002ad94:	e2432008 	sub	r2, r3, #8
1002ad98:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ad9c:	e3413004 	movt	r3, #4100	; 0x1004
1002ada0:	e5933000 	ldr	r3, [r3]
1002ada4:	e2433008 	sub	r3, r3, #8
1002ada8:	e5d33000 	ldrb	r3, [r3]
1002adac:	e1a01003 	mov	r1, r3
1002adb0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002adb4:	e3413004 	movt	r3, #4100	; 0x1004
1002adb8:	e5933000 	ldr	r3, [r3]
1002adbc:	e2433004 	sub	r3, r3, #4
1002adc0:	e5d33000 	ldrb	r3, [r3]
1002adc4:	e1a03351 	asr	r3, r1, r3
1002adc8:	e6ef3073 	uxtb	r3, r3
1002adcc:	e5c23000 	strb	r3, [r2]
1002add0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002add4:	e3413004 	movt	r3, #4100	; 0x1004
1002add8:	e5933000 	ldr	r3, [r3]
1002addc:	e2432004 	sub	r2, r3, #4
1002ade0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ade4:	e3413004 	movt	r3, #4100	; 0x1004
1002ade8:	e5832000 	str	r2, [r3]

	return ;
1002adec:	e1a00000 	nop			; (mov r0, r0)
}
1002adf0:	e24bd000 	sub	sp, fp, #0
1002adf4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002adf8:	e12fff1e 	bx	lr

1002adfc <OP_shr_word>:

void OP_shr_word()
{
1002adfc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ae00:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(>>);
1002ae04:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ae08:	e3413004 	movt	r3, #4100	; 0x1004
1002ae0c:	e5933000 	ldr	r3, [r3]
1002ae10:	e2432008 	sub	r2, r3, #8
1002ae14:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ae18:	e3413004 	movt	r3, #4100	; 0x1004
1002ae1c:	e5933000 	ldr	r3, [r3]
1002ae20:	e2433008 	sub	r3, r3, #8
1002ae24:	e1d330b0 	ldrh	r3, [r3]
1002ae28:	e6bf1073 	sxth	r1, r3
1002ae2c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ae30:	e3413004 	movt	r3, #4100	; 0x1004
1002ae34:	e5933000 	ldr	r3, [r3]
1002ae38:	e2433004 	sub	r3, r3, #4
1002ae3c:	e1d330b0 	ldrh	r3, [r3]
1002ae40:	e6bf3073 	sxth	r3, r3
1002ae44:	e1a03351 	asr	r3, r1, r3
1002ae48:	e6ff3073 	uxth	r3, r3
1002ae4c:	e1c230b0 	strh	r3, [r2]
1002ae50:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ae54:	e3413004 	movt	r3, #4100	; 0x1004
1002ae58:	e5933000 	ldr	r3, [r3]
1002ae5c:	e2432004 	sub	r2, r3, #4
1002ae60:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ae64:	e3413004 	movt	r3, #4100	; 0x1004
1002ae68:	e5832000 	str	r2, [r3]

	return ;
1002ae6c:	e1a00000 	nop			; (mov r0, r0)
}
1002ae70:	e24bd000 	sub	sp, fp, #0
1002ae74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002ae78:	e12fff1e 	bx	lr

1002ae7c <OP_shr_dword>:

void OP_shr_dword()
{
1002ae7c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ae80:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(>>);
1002ae84:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ae88:	e3413004 	movt	r3, #4100	; 0x1004
1002ae8c:	e5933000 	ldr	r3, [r3]
1002ae90:	e2432008 	sub	r2, r3, #8
1002ae94:	e30339a8 	movw	r3, #14760	; 0x39a8
1002ae98:	e3413004 	movt	r3, #4100	; 0x1004
1002ae9c:	e5933000 	ldr	r3, [r3]
1002aea0:	e2433008 	sub	r3, r3, #8
1002aea4:	e5931000 	ldr	r1, [r3]
1002aea8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aeac:	e3413004 	movt	r3, #4100	; 0x1004
1002aeb0:	e5933000 	ldr	r3, [r3]
1002aeb4:	e2433004 	sub	r3, r3, #4
1002aeb8:	e5933000 	ldr	r3, [r3]
1002aebc:	e1a03351 	asr	r3, r1, r3
1002aec0:	e5823000 	str	r3, [r2]
1002aec4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aec8:	e3413004 	movt	r3, #4100	; 0x1004
1002aecc:	e5933000 	ldr	r3, [r3]
1002aed0:	e2432004 	sub	r2, r3, #4
1002aed4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aed8:	e3413004 	movt	r3, #4100	; 0x1004
1002aedc:	e5832000 	str	r2, [r3]

	return ;
1002aee0:	e1a00000 	nop			; (mov r0, r0)
}
1002aee4:	e24bd000 	sub	sp, fp, #0
1002aee8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002aeec:	e12fff1e 	bx	lr

1002aef0 <OP_ld_byte>:

/* --- ld --- */
void OP_ld_byte()
{
1002aef0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002aef4:	e28db000 	add	fp, sp, #0
	finsh_sp->char_value = *finsh_pc;
1002aef8:	e30339a8 	movw	r3, #14760	; 0x39a8
1002aefc:	e3413004 	movt	r3, #4100	; 0x1004
1002af00:	e5932000 	ldr	r2, [r3]
1002af04:	e30339a4 	movw	r3, #14756	; 0x39a4
1002af08:	e3413004 	movt	r3, #4100	; 0x1004
1002af0c:	e5933000 	ldr	r3, [r3]
1002af10:	e5d33000 	ldrb	r3, [r3]
1002af14:	e5c23000 	strb	r3, [r2]

	finsh_sp++;
1002af18:	e30339a8 	movw	r3, #14760	; 0x39a8
1002af1c:	e3413004 	movt	r3, #4100	; 0x1004
1002af20:	e5933000 	ldr	r3, [r3]
1002af24:	e2832004 	add	r2, r3, #4
1002af28:	e30339a8 	movw	r3, #14760	; 0x39a8
1002af2c:	e3413004 	movt	r3, #4100	; 0x1004
1002af30:	e5832000 	str	r2, [r3]
	finsh_pc++;
1002af34:	e30339a4 	movw	r3, #14756	; 0x39a4
1002af38:	e3413004 	movt	r3, #4100	; 0x1004
1002af3c:	e5933000 	ldr	r3, [r3]
1002af40:	e2832001 	add	r2, r3, #1
1002af44:	e30339a4 	movw	r3, #14756	; 0x39a4
1002af48:	e3413004 	movt	r3, #4100	; 0x1004
1002af4c:	e5832000 	str	r2, [r3]

	return ;
1002af50:	e1a00000 	nop			; (mov r0, r0)
}
1002af54:	e24bd000 	sub	sp, fp, #0
1002af58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002af5c:	e12fff1e 	bx	lr

1002af60 <OP_ld_word>:

void OP_ld_word()
{
1002af60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002af64:	e28db000 	add	fp, sp, #0
	finsh_sp->short_value = FINSH_GET16(finsh_pc);
1002af68:	e30339a8 	movw	r3, #14760	; 0x39a8
1002af6c:	e3413004 	movt	r3, #4100	; 0x1004
1002af70:	e5932000 	ldr	r2, [r3]
1002af74:	e30339a4 	movw	r3, #14756	; 0x39a4
1002af78:	e3413004 	movt	r3, #4100	; 0x1004
1002af7c:	e5933000 	ldr	r3, [r3]
1002af80:	e5d33000 	ldrb	r3, [r3]
1002af84:	e6ff1073 	uxth	r1, r3
1002af88:	e30339a4 	movw	r3, #14756	; 0x39a4
1002af8c:	e3413004 	movt	r3, #4100	; 0x1004
1002af90:	e5933000 	ldr	r3, [r3]
1002af94:	e2833001 	add	r3, r3, #1
1002af98:	e5d33000 	ldrb	r3, [r3]
1002af9c:	e1a03403 	lsl	r3, r3, #8
1002afa0:	e6ff3073 	uxth	r3, r3
1002afa4:	e1813003 	orr	r3, r1, r3
1002afa8:	e6ff3073 	uxth	r3, r3
1002afac:	e1c230b0 	strh	r3, [r2]

	finsh_sp ++;
1002afb0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002afb4:	e3413004 	movt	r3, #4100	; 0x1004
1002afb8:	e5933000 	ldr	r3, [r3]
1002afbc:	e2832004 	add	r2, r3, #4
1002afc0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002afc4:	e3413004 	movt	r3, #4100	; 0x1004
1002afc8:	e5832000 	str	r2, [r3]
	finsh_pc += 2;
1002afcc:	e30339a4 	movw	r3, #14756	; 0x39a4
1002afd0:	e3413004 	movt	r3, #4100	; 0x1004
1002afd4:	e5933000 	ldr	r3, [r3]
1002afd8:	e2832002 	add	r2, r3, #2
1002afdc:	e30339a4 	movw	r3, #14756	; 0x39a4
1002afe0:	e3413004 	movt	r3, #4100	; 0x1004
1002afe4:	e5832000 	str	r2, [r3]

	return ;
1002afe8:	e1a00000 	nop			; (mov r0, r0)
}
1002afec:	e24bd000 	sub	sp, fp, #0
1002aff0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002aff4:	e12fff1e 	bx	lr

1002aff8 <OP_ld_dword>:

void OP_ld_dword()
{
1002aff8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002affc:	e28db000 	add	fp, sp, #0
	finsh_sp->long_value = FINSH_GET32(finsh_pc);
1002b000:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b004:	e3413004 	movt	r3, #4100	; 0x1004
1002b008:	e5932000 	ldr	r2, [r3]
1002b00c:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b010:	e3413004 	movt	r3, #4100	; 0x1004
1002b014:	e5933000 	ldr	r3, [r3]
1002b018:	e5d33000 	ldrb	r3, [r3]
1002b01c:	e1a01003 	mov	r1, r3
1002b020:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b024:	e3413004 	movt	r3, #4100	; 0x1004
1002b028:	e5933000 	ldr	r3, [r3]
1002b02c:	e2833001 	add	r3, r3, #1
1002b030:	e5d33000 	ldrb	r3, [r3]
1002b034:	e1a03403 	lsl	r3, r3, #8
1002b038:	e1811003 	orr	r1, r1, r3
1002b03c:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b040:	e3413004 	movt	r3, #4100	; 0x1004
1002b044:	e5933000 	ldr	r3, [r3]
1002b048:	e2833002 	add	r3, r3, #2
1002b04c:	e5d33000 	ldrb	r3, [r3]
1002b050:	e1a03803 	lsl	r3, r3, #16
1002b054:	e1811003 	orr	r1, r1, r3
1002b058:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b05c:	e3413004 	movt	r3, #4100	; 0x1004
1002b060:	e5933000 	ldr	r3, [r3]
1002b064:	e2833003 	add	r3, r3, #3
1002b068:	e5d33000 	ldrb	r3, [r3]
1002b06c:	e1a03c03 	lsl	r3, r3, #24
1002b070:	e1813003 	orr	r3, r1, r3
1002b074:	e5823000 	str	r3, [r2]

	finsh_sp ++;
1002b078:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b07c:	e3413004 	movt	r3, #4100	; 0x1004
1002b080:	e5933000 	ldr	r3, [r3]
1002b084:	e2832004 	add	r2, r3, #4
1002b088:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b08c:	e3413004 	movt	r3, #4100	; 0x1004
1002b090:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
1002b094:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b098:	e3413004 	movt	r3, #4100	; 0x1004
1002b09c:	e5933000 	ldr	r3, [r3]
1002b0a0:	e2832004 	add	r2, r3, #4
1002b0a4:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b0a8:	e3413004 	movt	r3, #4100	; 0x1004
1002b0ac:	e5832000 	str	r2, [r3]

	return ;
1002b0b0:	e1a00000 	nop			; (mov r0, r0)
}
1002b0b4:	e24bd000 	sub	sp, fp, #0
1002b0b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b0bc:	e12fff1e 	bx	lr

1002b0c0 <OP_ld_value_byte>:

void OP_ld_value_byte()
{
1002b0c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b0c4:	e28db000 	add	fp, sp, #0
1002b0c8:	e24dd00c 	sub	sp, sp, #12
	char* c;

	c = (char*) (FINSH_GET32(finsh_pc));
1002b0cc:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b0d0:	e3413004 	movt	r3, #4100	; 0x1004
1002b0d4:	e5933000 	ldr	r3, [r3]
1002b0d8:	e5d33000 	ldrb	r3, [r3]
1002b0dc:	e1a02003 	mov	r2, r3
1002b0e0:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b0e4:	e3413004 	movt	r3, #4100	; 0x1004
1002b0e8:	e5933000 	ldr	r3, [r3]
1002b0ec:	e2833001 	add	r3, r3, #1
1002b0f0:	e5d33000 	ldrb	r3, [r3]
1002b0f4:	e1a03403 	lsl	r3, r3, #8
1002b0f8:	e1822003 	orr	r2, r2, r3
1002b0fc:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b100:	e3413004 	movt	r3, #4100	; 0x1004
1002b104:	e5933000 	ldr	r3, [r3]
1002b108:	e2833002 	add	r3, r3, #2
1002b10c:	e5d33000 	ldrb	r3, [r3]
1002b110:	e1a03803 	lsl	r3, r3, #16
1002b114:	e1822003 	orr	r2, r2, r3
1002b118:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b11c:	e3413004 	movt	r3, #4100	; 0x1004
1002b120:	e5933000 	ldr	r3, [r3]
1002b124:	e2833003 	add	r3, r3, #3
1002b128:	e5d33000 	ldrb	r3, [r3]
1002b12c:	e1a03c03 	lsl	r3, r3, #24
1002b130:	e1823003 	orr	r3, r2, r3
1002b134:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->char_value = *c;
1002b138:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b13c:	e3413004 	movt	r3, #4100	; 0x1004
1002b140:	e5933000 	ldr	r3, [r3]
1002b144:	e51b2008 	ldr	r2, [fp, #-8]
1002b148:	e5d22000 	ldrb	r2, [r2]
1002b14c:	e5c32000 	strb	r2, [r3]

	finsh_sp ++;
1002b150:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b154:	e3413004 	movt	r3, #4100	; 0x1004
1002b158:	e5933000 	ldr	r3, [r3]
1002b15c:	e2832004 	add	r2, r3, #4
1002b160:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b164:	e3413004 	movt	r3, #4100	; 0x1004
1002b168:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
1002b16c:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b170:	e3413004 	movt	r3, #4100	; 0x1004
1002b174:	e5933000 	ldr	r3, [r3]
1002b178:	e2832004 	add	r2, r3, #4
1002b17c:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b180:	e3413004 	movt	r3, #4100	; 0x1004
1002b184:	e5832000 	str	r2, [r3]

	return;
1002b188:	e1a00000 	nop			; (mov r0, r0)
}
1002b18c:	e24bd000 	sub	sp, fp, #0
1002b190:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b194:	e12fff1e 	bx	lr

1002b198 <OP_ld_value_byte_stack>:

void OP_ld_value_byte_stack()
{
1002b198:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b19c:	e28db000 	add	fp, sp, #0
1002b1a0:	e24dd00c 	sub	sp, sp, #12
	char* c;

	c = (char *)(finsh_sp - 1)->long_value;
1002b1a4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b1a8:	e3413004 	movt	r3, #4100	; 0x1004
1002b1ac:	e5933000 	ldr	r3, [r3]
1002b1b0:	e2433004 	sub	r3, r3, #4
1002b1b4:	e5933000 	ldr	r3, [r3]
1002b1b8:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->char_value = *c;
1002b1bc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b1c0:	e3413004 	movt	r3, #4100	; 0x1004
1002b1c4:	e5933000 	ldr	r3, [r3]
1002b1c8:	e2433004 	sub	r3, r3, #4
1002b1cc:	e51b2008 	ldr	r2, [fp, #-8]
1002b1d0:	e5d22000 	ldrb	r2, [r2]
1002b1d4:	e5c32000 	strb	r2, [r3]

	return;
1002b1d8:	e1a00000 	nop			; (mov r0, r0)
}
1002b1dc:	e24bd000 	sub	sp, fp, #0
1002b1e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b1e4:	e12fff1e 	bx	lr

1002b1e8 <OP_ld_value_word>:

void OP_ld_value_word()
{
1002b1e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b1ec:	e28db000 	add	fp, sp, #0
1002b1f0:	e24dd00c 	sub	sp, sp, #12
	short* s;

	s = (short*) (FINSH_GET32(finsh_pc));
1002b1f4:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b1f8:	e3413004 	movt	r3, #4100	; 0x1004
1002b1fc:	e5933000 	ldr	r3, [r3]
1002b200:	e5d33000 	ldrb	r3, [r3]
1002b204:	e1a02003 	mov	r2, r3
1002b208:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b20c:	e3413004 	movt	r3, #4100	; 0x1004
1002b210:	e5933000 	ldr	r3, [r3]
1002b214:	e2833001 	add	r3, r3, #1
1002b218:	e5d33000 	ldrb	r3, [r3]
1002b21c:	e1a03403 	lsl	r3, r3, #8
1002b220:	e1822003 	orr	r2, r2, r3
1002b224:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b228:	e3413004 	movt	r3, #4100	; 0x1004
1002b22c:	e5933000 	ldr	r3, [r3]
1002b230:	e2833002 	add	r3, r3, #2
1002b234:	e5d33000 	ldrb	r3, [r3]
1002b238:	e1a03803 	lsl	r3, r3, #16
1002b23c:	e1822003 	orr	r2, r2, r3
1002b240:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b244:	e3413004 	movt	r3, #4100	; 0x1004
1002b248:	e5933000 	ldr	r3, [r3]
1002b24c:	e2833003 	add	r3, r3, #3
1002b250:	e5d33000 	ldrb	r3, [r3]
1002b254:	e1a03c03 	lsl	r3, r3, #24
1002b258:	e1823003 	orr	r3, r2, r3
1002b25c:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->short_value = *s;
1002b260:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b264:	e3413004 	movt	r3, #4100	; 0x1004
1002b268:	e5933000 	ldr	r3, [r3]
1002b26c:	e51b2008 	ldr	r2, [fp, #-8]
1002b270:	e1d220b0 	ldrh	r2, [r2]
1002b274:	e1c320b0 	strh	r2, [r3]

	finsh_sp ++;
1002b278:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b27c:	e3413004 	movt	r3, #4100	; 0x1004
1002b280:	e5933000 	ldr	r3, [r3]
1002b284:	e2832004 	add	r2, r3, #4
1002b288:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b28c:	e3413004 	movt	r3, #4100	; 0x1004
1002b290:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
1002b294:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b298:	e3413004 	movt	r3, #4100	; 0x1004
1002b29c:	e5933000 	ldr	r3, [r3]
1002b2a0:	e2832004 	add	r2, r3, #4
1002b2a4:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b2a8:	e3413004 	movt	r3, #4100	; 0x1004
1002b2ac:	e5832000 	str	r2, [r3]

	return;
1002b2b0:	e1a00000 	nop			; (mov r0, r0)
}
1002b2b4:	e24bd000 	sub	sp, fp, #0
1002b2b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b2bc:	e12fff1e 	bx	lr

1002b2c0 <OP_ld_value_word_stack>:

void OP_ld_value_word_stack()
{
1002b2c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b2c4:	e28db000 	add	fp, sp, #0
1002b2c8:	e24dd00c 	sub	sp, sp, #12
	short* s;

	s = (short *)(finsh_sp - 1)->long_value;
1002b2cc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b2d0:	e3413004 	movt	r3, #4100	; 0x1004
1002b2d4:	e5933000 	ldr	r3, [r3]
1002b2d8:	e2433004 	sub	r3, r3, #4
1002b2dc:	e5933000 	ldr	r3, [r3]
1002b2e0:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->short_value = *s;
1002b2e4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b2e8:	e3413004 	movt	r3, #4100	; 0x1004
1002b2ec:	e5933000 	ldr	r3, [r3]
1002b2f0:	e2433004 	sub	r3, r3, #4
1002b2f4:	e51b2008 	ldr	r2, [fp, #-8]
1002b2f8:	e1d220b0 	ldrh	r2, [r2]
1002b2fc:	e1c320b0 	strh	r2, [r3]

	return;
1002b300:	e1a00000 	nop			; (mov r0, r0)
}
1002b304:	e24bd000 	sub	sp, fp, #0
1002b308:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b30c:	e12fff1e 	bx	lr

1002b310 <OP_ld_value_dword>:

void OP_ld_value_dword()
{
1002b310:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b314:	e28db000 	add	fp, sp, #0
1002b318:	e24dd00c 	sub	sp, sp, #12
	long* l;

	l = (long*) (FINSH_GET32(finsh_pc));
1002b31c:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b320:	e3413004 	movt	r3, #4100	; 0x1004
1002b324:	e5933000 	ldr	r3, [r3]
1002b328:	e5d33000 	ldrb	r3, [r3]
1002b32c:	e1a02003 	mov	r2, r3
1002b330:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b334:	e3413004 	movt	r3, #4100	; 0x1004
1002b338:	e5933000 	ldr	r3, [r3]
1002b33c:	e2833001 	add	r3, r3, #1
1002b340:	e5d33000 	ldrb	r3, [r3]
1002b344:	e1a03403 	lsl	r3, r3, #8
1002b348:	e1822003 	orr	r2, r2, r3
1002b34c:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b350:	e3413004 	movt	r3, #4100	; 0x1004
1002b354:	e5933000 	ldr	r3, [r3]
1002b358:	e2833002 	add	r3, r3, #2
1002b35c:	e5d33000 	ldrb	r3, [r3]
1002b360:	e1a03803 	lsl	r3, r3, #16
1002b364:	e1822003 	orr	r2, r2, r3
1002b368:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b36c:	e3413004 	movt	r3, #4100	; 0x1004
1002b370:	e5933000 	ldr	r3, [r3]
1002b374:	e2833003 	add	r3, r3, #3
1002b378:	e5d33000 	ldrb	r3, [r3]
1002b37c:	e1a03c03 	lsl	r3, r3, #24
1002b380:	e1823003 	orr	r3, r2, r3
1002b384:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->long_value = *l;
1002b388:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b38c:	e3413004 	movt	r3, #4100	; 0x1004
1002b390:	e5933000 	ldr	r3, [r3]
1002b394:	e51b2008 	ldr	r2, [fp, #-8]
1002b398:	e5922000 	ldr	r2, [r2]
1002b39c:	e5832000 	str	r2, [r3]

	finsh_sp ++;
1002b3a0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b3a4:	e3413004 	movt	r3, #4100	; 0x1004
1002b3a8:	e5933000 	ldr	r3, [r3]
1002b3ac:	e2832004 	add	r2, r3, #4
1002b3b0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b3b4:	e3413004 	movt	r3, #4100	; 0x1004
1002b3b8:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
1002b3bc:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b3c0:	e3413004 	movt	r3, #4100	; 0x1004
1002b3c4:	e5933000 	ldr	r3, [r3]
1002b3c8:	e2832004 	add	r2, r3, #4
1002b3cc:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b3d0:	e3413004 	movt	r3, #4100	; 0x1004
1002b3d4:	e5832000 	str	r2, [r3]

	return;
1002b3d8:	e1a00000 	nop			; (mov r0, r0)
}
1002b3dc:	e24bd000 	sub	sp, fp, #0
1002b3e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b3e4:	e12fff1e 	bx	lr

1002b3e8 <OP_ld_value_dword_stack>:

void OP_ld_value_dword_stack()
{
1002b3e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b3ec:	e28db000 	add	fp, sp, #0
1002b3f0:	e24dd00c 	sub	sp, sp, #12
	long* l;

	l = (long *)(finsh_sp - 1)->long_value;
1002b3f4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b3f8:	e3413004 	movt	r3, #4100	; 0x1004
1002b3fc:	e5933000 	ldr	r3, [r3]
1002b400:	e2433004 	sub	r3, r3, #4
1002b404:	e5933000 	ldr	r3, [r3]
1002b408:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->long_value = *l;
1002b40c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b410:	e3413004 	movt	r3, #4100	; 0x1004
1002b414:	e5933000 	ldr	r3, [r3]
1002b418:	e2433004 	sub	r3, r3, #4
1002b41c:	e51b2008 	ldr	r2, [fp, #-8]
1002b420:	e5922000 	ldr	r2, [r2]
1002b424:	e5832000 	str	r2, [r3]

	return;
1002b428:	e1a00000 	nop			; (mov r0, r0)
}
1002b42c:	e24bd000 	sub	sp, fp, #0
1002b430:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b434:	e12fff1e 	bx	lr

1002b438 <OP_st_byte>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_byte()
{
1002b438:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b43c:	e28db000 	add	fp, sp, #0
	*(char*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->char_value;
1002b440:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b444:	e3413004 	movt	r3, #4100	; 0x1004
1002b448:	e5933000 	ldr	r3, [r3]
1002b44c:	e2433008 	sub	r3, r3, #8
1002b450:	e5933000 	ldr	r3, [r3]
1002b454:	e1a02003 	mov	r2, r3
1002b458:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b45c:	e3413004 	movt	r3, #4100	; 0x1004
1002b460:	e5933000 	ldr	r3, [r3]
1002b464:	e2433004 	sub	r3, r3, #4
1002b468:	e5d33000 	ldrb	r3, [r3]
1002b46c:	e5c23000 	strb	r3, [r2]
	finsh_sp --;
1002b470:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b474:	e3413004 	movt	r3, #4100	; 0x1004
1002b478:	e5933000 	ldr	r3, [r3]
1002b47c:	e2432004 	sub	r2, r3, #4
1002b480:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b484:	e3413004 	movt	r3, #4100	; 0x1004
1002b488:	e5832000 	str	r2, [r3]

	return ;
1002b48c:	e1a00000 	nop			; (mov r0, r0)
}
1002b490:	e24bd000 	sub	sp, fp, #0
1002b494:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b498:	e12fff1e 	bx	lr

1002b49c <OP_st_word>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_word()
{
1002b49c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b4a0:	e28db000 	add	fp, sp, #0
	*(short*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->short_value;
1002b4a4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b4a8:	e3413004 	movt	r3, #4100	; 0x1004
1002b4ac:	e5933000 	ldr	r3, [r3]
1002b4b0:	e2433008 	sub	r3, r3, #8
1002b4b4:	e5933000 	ldr	r3, [r3]
1002b4b8:	e1a02003 	mov	r2, r3
1002b4bc:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b4c0:	e3413004 	movt	r3, #4100	; 0x1004
1002b4c4:	e5933000 	ldr	r3, [r3]
1002b4c8:	e2433004 	sub	r3, r3, #4
1002b4cc:	e1d330b0 	ldrh	r3, [r3]
1002b4d0:	e1c230b0 	strh	r3, [r2]
	finsh_sp --;
1002b4d4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b4d8:	e3413004 	movt	r3, #4100	; 0x1004
1002b4dc:	e5933000 	ldr	r3, [r3]
1002b4e0:	e2432004 	sub	r2, r3, #4
1002b4e4:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b4e8:	e3413004 	movt	r3, #4100	; 0x1004
1002b4ec:	e5832000 	str	r2, [r3]

	return ;
1002b4f0:	e1a00000 	nop			; (mov r0, r0)
}
1002b4f4:	e24bd000 	sub	sp, fp, #0
1002b4f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b4fc:	e12fff1e 	bx	lr

1002b500 <OP_st_dword>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_dword()
{
1002b500:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b504:	e28db000 	add	fp, sp, #0
	*(long*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->long_value;
1002b508:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b50c:	e3413004 	movt	r3, #4100	; 0x1004
1002b510:	e5933000 	ldr	r3, [r3]
1002b514:	e2433008 	sub	r3, r3, #8
1002b518:	e5933000 	ldr	r3, [r3]
1002b51c:	e1a02003 	mov	r2, r3
1002b520:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b524:	e3413004 	movt	r3, #4100	; 0x1004
1002b528:	e5933000 	ldr	r3, [r3]
1002b52c:	e2433004 	sub	r3, r3, #4
1002b530:	e5933000 	ldr	r3, [r3]
1002b534:	e5823000 	str	r3, [r2]
	finsh_sp --;
1002b538:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b53c:	e3413004 	movt	r3, #4100	; 0x1004
1002b540:	e5933000 	ldr	r3, [r3]
1002b544:	e2432004 	sub	r2, r3, #4
1002b548:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b54c:	e3413004 	movt	r3, #4100	; 0x1004
1002b550:	e5832000 	str	r2, [r3]

	return ;
1002b554:	e1a00000 	nop			; (mov r0, r0)
}
1002b558:	e24bd000 	sub	sp, fp, #0
1002b55c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b560:	e12fff1e 	bx	lr

1002b564 <OP_pop>:

/* --- pop --- */
void OP_pop()
{
1002b564:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002b568:	e28db000 	add	fp, sp, #0
	finsh_sp --;
1002b56c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b570:	e3413004 	movt	r3, #4100	; 0x1004
1002b574:	e5933000 	ldr	r3, [r3]
1002b578:	e2432004 	sub	r2, r3, #4
1002b57c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b580:	e3413004 	movt	r3, #4100	; 0x1004
1002b584:	e5832000 	str	r2, [r3]
	return ;
1002b588:	e1a00000 	nop			; (mov r0, r0)
}
1002b58c:	e24bd000 	sub	sp, fp, #0
1002b590:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002b594:	e12fff1e 	bx	lr

1002b598 <OP_call>:

/* --- call --- */
void OP_call()
{
1002b598:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
1002b59c:	e28db020 	add	fp, sp, #32
1002b5a0:	e24dd094 	sub	sp, sp, #148	; 0x94
	typedef unsigned long var_t;
	typedef var_t (*op_func)();
	op_func f;
	var_t   r;

	parameters = *finsh_pc ++;
1002b5a4:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b5a8:	e3413004 	movt	r3, #4100	; 0x1004
1002b5ac:	e5932000 	ldr	r2, [r3]
1002b5b0:	e2821001 	add	r1, r2, #1
1002b5b4:	e30339a4 	movw	r3, #14756	; 0x39a4
1002b5b8:	e3413004 	movt	r3, #4100	; 0x1004
1002b5bc:	e5831000 	str	r1, [r3]
1002b5c0:	e5d23000 	ldrb	r3, [r2]
1002b5c4:	e50b3030 	str	r3, [fp, #-48]	; 0x30

	i = 0; finsh_sp --;
1002b5c8:	e3a03000 	mov	r3, #0
1002b5cc:	e50b3028 	str	r3, [fp, #-40]	; 0x28
1002b5d0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b5d4:	e3413004 	movt	r3, #4100	; 0x1004
1002b5d8:	e5933000 	ldr	r3, [r3]
1002b5dc:	e2432004 	sub	r2, r3, #4
1002b5e0:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b5e4:	e3413004 	movt	r3, #4100	; 0x1004
1002b5e8:	e5832000 	str	r2, [r3]
	while (i < parameters)
1002b5ec:	ea000016 	b	1002b64c <OP_call+0xb4>
	{
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
1002b5f0:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
1002b5f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002b5f8:	e0633002 	rsb	r3, r3, r2
1002b5fc:	e2432001 	sub	r2, r3, #1
1002b600:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b604:	e3413004 	movt	r3, #4100	; 0x1004
1002b608:	e5933000 	ldr	r3, [r3]
1002b60c:	e5933000 	ldr	r3, [r3]
1002b610:	e1a01003 	mov	r1, r3
1002b614:	e1a03102 	lsl	r3, r2, #2
1002b618:	e24b2024 	sub	r2, fp, #36	; 0x24
1002b61c:	e0823003 	add	r3, r2, r3
1002b620:	e5031050 	str	r1, [r3, #-80]	; 0x50
		finsh_sp --;
1002b624:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b628:	e3413004 	movt	r3, #4100	; 0x1004
1002b62c:	e5933000 	ldr	r3, [r3]
1002b630:	e2432004 	sub	r2, r3, #4
1002b634:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b638:	e3413004 	movt	r3, #4100	; 0x1004
1002b63c:	e5832000 	str	r2, [r3]
		i++;
1002b640:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002b644:	e2833001 	add	r3, r3, #1
1002b648:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	var_t   r;

	parameters = *finsh_pc ++;

	i = 0; finsh_sp --;
	while (i < parameters)
1002b64c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1002b650:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1002b654:	e1520003 	cmp	r2, r3
1002b658:	3affffe4 	bcc	1002b5f0 <OP_call+0x58>
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
		finsh_sp --;
		i++;
	}

	f = (op_func)(finsh_sp->long_value);
1002b65c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002b660:	e3413004 	movt	r3, #4100	; 0x1004
1002b664:	e5933000 	ldr	r3, [r3]
1002b668:	e5933000 	ldr	r3, [r3]
1002b66c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	switch (parameters)
1002b670:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1002b674:	e3530010 	cmp	r3, #16
1002b678:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002b67c:	ea00015e 	b	1002bbfc <OP_call+0x664>
1002b680:	1002b6c4 	.word	0x1002b6c4
1002b684:	1002b6d8 	.word	0x1002b6d8
1002b688:	1002b6f0 	.word	0x1002b6f0
1002b68c:	1002b710 	.word	0x1002b710
1002b690:	1002b72c 	.word	0x1002b72c
1002b694:	1002b74c 	.word	0x1002b74c
1002b698:	1002b778 	.word	0x1002b778
1002b69c:	1002b7b0 	.word	0x1002b7b0
1002b6a0:	1002b7f4 	.word	0x1002b7f4
1002b6a4:	1002b844 	.word	0x1002b844
1002b6a8:	1002b89c 	.word	0x1002b89c
1002b6ac:	1002b8fc 	.word	0x1002b8fc
1002b6b0:	1002b964 	.word	0x1002b964
1002b6b4:	1002b9d4 	.word	0x1002b9d4
1002b6b8:	1002ba4c 	.word	0x1002ba4c
1002b6bc:	1002bad0 	.word	0x1002bad0
1002b6c0:	1002bb60 	.word	0x1002bb60
	{
	case 0:
		r = f(0);
1002b6c4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1002b6c8:	e3a00000 	mov	r0, #0
1002b6cc:	e12fff33 	blx	r3
1002b6d0:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
1002b6d4:	ea00014b 	b	1002bc08 <OP_call+0x670>

	case 1:
		r = f(parameterv[0]);
1002b6d8:	e51b2074 	ldr	r2, [fp, #-116]	; 0x74
1002b6dc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1002b6e0:	e1a00002 	mov	r0, r2
1002b6e4:	e12fff33 	blx	r3
1002b6e8:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
1002b6ec:	ea000145 	b	1002bc08 <OP_call+0x670>

	case 2:
		r = f(parameterv[0], parameterv[1]);
1002b6f0:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
1002b6f4:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
1002b6f8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1002b6fc:	e1a00001 	mov	r0, r1
1002b700:	e1a01002 	mov	r1, r2
1002b704:	e12fff33 	blx	r3
1002b708:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
1002b70c:	ea00013d 	b	1002bc08 <OP_call+0x670>

	case 3:
		r = f(parameterv[0], parameterv[1], parameterv[2]);
1002b710:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
1002b714:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
1002b718:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
1002b71c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1002b720:	e12fff33 	blx	r3
1002b724:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
1002b728:	ea000136 	b	1002bc08 <OP_call+0x670>

	case 4:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3]);
1002b72c:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
1002b730:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
1002b734:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
1002b738:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
1002b73c:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b740:	e12fff3c 	blx	ip
1002b744:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
1002b748:	ea00012e 	b	1002bc08 <OP_call+0x670>

	case 5:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b74c:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
1002b750:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
1002b754:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
1002b758:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
1002b75c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
1002b760:	e58d3000 	str	r3, [sp]
1002b764:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b768:	e1a0300e 	mov	r3, lr
1002b76c:	e12fff3c 	blx	ip
1002b770:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4]);
		break;
1002b774:	ea000123 	b	1002bc08 <OP_call+0x670>

	case 6:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b778:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
1002b77c:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
1002b780:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
1002b784:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
1002b788:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
1002b78c:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
1002b790:	e58d2000 	str	r2, [sp]
1002b794:	e58d3004 	str	r3, [sp, #4]
1002b798:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b79c:	e1a02004 	mov	r2, r4
1002b7a0:	e1a0300e 	mov	r3, lr
1002b7a4:	e12fff3c 	blx	ip
1002b7a8:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5]);
		break;
1002b7ac:	ea000115 	b	1002bc08 <OP_call+0x670>

	case 7:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b7b0:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
1002b7b4:	e51b5070 	ldr	r5, [fp, #-112]	; 0x70
1002b7b8:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
1002b7bc:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
1002b7c0:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
1002b7c4:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
1002b7c8:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
1002b7cc:	e58d1000 	str	r1, [sp]
1002b7d0:	e58d2004 	str	r2, [sp, #4]
1002b7d4:	e58d3008 	str	r3, [sp, #8]
1002b7d8:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b7dc:	e1a01005 	mov	r1, r5
1002b7e0:	e1a02004 	mov	r2, r4
1002b7e4:	e1a0300e 	mov	r3, lr
1002b7e8:	e12fff3c 	blx	ip
1002b7ec:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6]);
		break;
1002b7f0:	ea000104 	b	1002bc08 <OP_call+0x670>

	case 8:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b7f4:	e51b6074 	ldr	r6, [fp, #-116]	; 0x74
1002b7f8:	e51b5070 	ldr	r5, [fp, #-112]	; 0x70
1002b7fc:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
1002b800:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
1002b804:	e51b0064 	ldr	r0, [fp, #-100]	; 0x64
1002b808:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
1002b80c:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
1002b810:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
1002b814:	e58d0000 	str	r0, [sp]
1002b818:	e58d1004 	str	r1, [sp, #4]
1002b81c:	e58d2008 	str	r2, [sp, #8]
1002b820:	e58d300c 	str	r3, [sp, #12]
1002b824:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b828:	e1a00006 	mov	r0, r6
1002b82c:	e1a01005 	mov	r1, r5
1002b830:	e1a02004 	mov	r2, r4
1002b834:	e1a0300e 	mov	r3, lr
1002b838:	e12fff3c 	blx	ip
1002b83c:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7]);
		break;
1002b840:	ea0000f0 	b	1002bc08 <OP_call+0x670>

	case 9:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b844:	e51b6074 	ldr	r6, [fp, #-116]	; 0x74
1002b848:	e51b5070 	ldr	r5, [fp, #-112]	; 0x70
1002b84c:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
1002b850:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
1002b854:	e51bc064 	ldr	ip, [fp, #-100]	; 0x64
1002b858:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
1002b85c:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
1002b860:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
1002b864:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
1002b868:	e58dc000 	str	ip, [sp]
1002b86c:	e58d0004 	str	r0, [sp, #4]
1002b870:	e58d1008 	str	r1, [sp, #8]
1002b874:	e58d200c 	str	r2, [sp, #12]
1002b878:	e58d3010 	str	r3, [sp, #16]
1002b87c:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b880:	e1a00006 	mov	r0, r6
1002b884:	e1a01005 	mov	r1, r5
1002b888:	e1a02004 	mov	r2, r4
1002b88c:	e1a0300e 	mov	r3, lr
1002b890:	e12fff3c 	blx	ip
1002b894:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8]);
		break;
1002b898:	ea0000da 	b	1002bc08 <OP_call+0x670>

	case 10:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b89c:	e51b7074 	ldr	r7, [fp, #-116]	; 0x74
1002b8a0:	e51b6070 	ldr	r6, [fp, #-112]	; 0x70
1002b8a4:	e51b506c 	ldr	r5, [fp, #-108]	; 0x6c
1002b8a8:	e51b4068 	ldr	r4, [fp, #-104]	; 0x68
1002b8ac:	e51be064 	ldr	lr, [fp, #-100]	; 0x64
1002b8b0:	e51bc060 	ldr	ip, [fp, #-96]	; 0x60
1002b8b4:	e51b005c 	ldr	r0, [fp, #-92]	; 0x5c
1002b8b8:	e51b1058 	ldr	r1, [fp, #-88]	; 0x58
1002b8bc:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
1002b8c0:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
1002b8c4:	e58de000 	str	lr, [sp]
1002b8c8:	e58dc004 	str	ip, [sp, #4]
1002b8cc:	e58d0008 	str	r0, [sp, #8]
1002b8d0:	e58d100c 	str	r1, [sp, #12]
1002b8d4:	e58d2010 	str	r2, [sp, #16]
1002b8d8:	e58d3014 	str	r3, [sp, #20]
1002b8dc:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b8e0:	e1a00007 	mov	r0, r7
1002b8e4:	e1a01006 	mov	r1, r6
1002b8e8:	e1a02005 	mov	r2, r5
1002b8ec:	e1a03004 	mov	r3, r4
1002b8f0:	e12fff3c 	blx	ip
1002b8f4:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9]);
		break;
1002b8f8:	ea0000c2 	b	1002bc08 <OP_call+0x670>

	case 11:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b8fc:	e51b8074 	ldr	r8, [fp, #-116]	; 0x74
1002b900:	e51b7070 	ldr	r7, [fp, #-112]	; 0x70
1002b904:	e51b606c 	ldr	r6, [fp, #-108]	; 0x6c
1002b908:	e51b5068 	ldr	r5, [fp, #-104]	; 0x68
1002b90c:	e51b4064 	ldr	r4, [fp, #-100]	; 0x64
1002b910:	e51be060 	ldr	lr, [fp, #-96]	; 0x60
1002b914:	e51bc05c 	ldr	ip, [fp, #-92]	; 0x5c
1002b918:	e51b0058 	ldr	r0, [fp, #-88]	; 0x58
1002b91c:	e51b1054 	ldr	r1, [fp, #-84]	; 0x54
1002b920:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
1002b924:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
1002b928:	e58d4000 	str	r4, [sp]
1002b92c:	e58de004 	str	lr, [sp, #4]
1002b930:	e58dc008 	str	ip, [sp, #8]
1002b934:	e58d000c 	str	r0, [sp, #12]
1002b938:	e58d1010 	str	r1, [sp, #16]
1002b93c:	e58d2014 	str	r2, [sp, #20]
1002b940:	e58d3018 	str	r3, [sp, #24]
1002b944:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b948:	e1a00008 	mov	r0, r8
1002b94c:	e1a01007 	mov	r1, r7
1002b950:	e1a02006 	mov	r2, r6
1002b954:	e1a03005 	mov	r3, r5
1002b958:	e12fff3c 	blx	ip
1002b95c:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10]);
		break;
1002b960:	ea0000a8 	b	1002bc08 <OP_call+0x670>

	case 12:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b964:	e51b9074 	ldr	r9, [fp, #-116]	; 0x74
1002b968:	e51b8070 	ldr	r8, [fp, #-112]	; 0x70
1002b96c:	e51b706c 	ldr	r7, [fp, #-108]	; 0x6c
1002b970:	e51b6068 	ldr	r6, [fp, #-104]	; 0x68
1002b974:	e51b5064 	ldr	r5, [fp, #-100]	; 0x64
1002b978:	e51b4060 	ldr	r4, [fp, #-96]	; 0x60
1002b97c:	e51be05c 	ldr	lr, [fp, #-92]	; 0x5c
1002b980:	e51bc058 	ldr	ip, [fp, #-88]	; 0x58
1002b984:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
1002b988:	e51b1050 	ldr	r1, [fp, #-80]	; 0x50
1002b98c:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
1002b990:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
1002b994:	e58d5000 	str	r5, [sp]
1002b998:	e58d4004 	str	r4, [sp, #4]
1002b99c:	e58de008 	str	lr, [sp, #8]
1002b9a0:	e58dc00c 	str	ip, [sp, #12]
1002b9a4:	e58d0010 	str	r0, [sp, #16]
1002b9a8:	e58d1014 	str	r1, [sp, #20]
1002b9ac:	e58d2018 	str	r2, [sp, #24]
1002b9b0:	e58d301c 	str	r3, [sp, #28]
1002b9b4:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002b9b8:	e1a00009 	mov	r0, r9
1002b9bc:	e1a01008 	mov	r1, r8
1002b9c0:	e1a02007 	mov	r2, r7
1002b9c4:	e1a03006 	mov	r3, r6
1002b9c8:	e12fff3c 	blx	ip
1002b9cc:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11]);
		break;
1002b9d0:	ea00008c 	b	1002bc08 <OP_call+0x670>

	case 13:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002b9d4:	e51ba074 	ldr	sl, [fp, #-116]	; 0x74
1002b9d8:	e51b9070 	ldr	r9, [fp, #-112]	; 0x70
1002b9dc:	e51b806c 	ldr	r8, [fp, #-108]	; 0x6c
1002b9e0:	e51b7068 	ldr	r7, [fp, #-104]	; 0x68
1002b9e4:	e51b6064 	ldr	r6, [fp, #-100]	; 0x64
1002b9e8:	e51b5060 	ldr	r5, [fp, #-96]	; 0x60
1002b9ec:	e51b405c 	ldr	r4, [fp, #-92]	; 0x5c
1002b9f0:	e51be058 	ldr	lr, [fp, #-88]	; 0x58
1002b9f4:	e51bc054 	ldr	ip, [fp, #-84]	; 0x54
1002b9f8:	e51b0050 	ldr	r0, [fp, #-80]	; 0x50
1002b9fc:	e51b104c 	ldr	r1, [fp, #-76]	; 0x4c
1002ba00:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
1002ba04:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
1002ba08:	e58d6000 	str	r6, [sp]
1002ba0c:	e58d5004 	str	r5, [sp, #4]
1002ba10:	e58d4008 	str	r4, [sp, #8]
1002ba14:	e58de00c 	str	lr, [sp, #12]
1002ba18:	e58dc010 	str	ip, [sp, #16]
1002ba1c:	e58d0014 	str	r0, [sp, #20]
1002ba20:	e58d1018 	str	r1, [sp, #24]
1002ba24:	e58d201c 	str	r2, [sp, #28]
1002ba28:	e58d3020 	str	r3, [sp, #32]
1002ba2c:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002ba30:	e1a0000a 	mov	r0, sl
1002ba34:	e1a01009 	mov	r1, r9
1002ba38:	e1a02008 	mov	r2, r8
1002ba3c:	e1a03007 	mov	r3, r7
1002ba40:	e12fff3c 	blx	ip
1002ba44:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12]);
		break;
1002ba48:	ea00006e 	b	1002bc08 <OP_call+0x670>

	case 14:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002ba4c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
1002ba50:	e50b3078 	str	r3, [fp, #-120]	; 0x78
1002ba54:	e51ba070 	ldr	sl, [fp, #-112]	; 0x70
1002ba58:	e51b906c 	ldr	r9, [fp, #-108]	; 0x6c
1002ba5c:	e51b8068 	ldr	r8, [fp, #-104]	; 0x68
1002ba60:	e51b7064 	ldr	r7, [fp, #-100]	; 0x64
1002ba64:	e51b6060 	ldr	r6, [fp, #-96]	; 0x60
1002ba68:	e51b505c 	ldr	r5, [fp, #-92]	; 0x5c
1002ba6c:	e51b4058 	ldr	r4, [fp, #-88]	; 0x58
1002ba70:	e51be054 	ldr	lr, [fp, #-84]	; 0x54
1002ba74:	e51bc050 	ldr	ip, [fp, #-80]	; 0x50
1002ba78:	e51b004c 	ldr	r0, [fp, #-76]	; 0x4c
1002ba7c:	e51b1048 	ldr	r1, [fp, #-72]	; 0x48
1002ba80:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
1002ba84:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002ba88:	e58d7000 	str	r7, [sp]
1002ba8c:	e58d6004 	str	r6, [sp, #4]
1002ba90:	e58d5008 	str	r5, [sp, #8]
1002ba94:	e58d400c 	str	r4, [sp, #12]
1002ba98:	e58de010 	str	lr, [sp, #16]
1002ba9c:	e58dc014 	str	ip, [sp, #20]
1002baa0:	e58d0018 	str	r0, [sp, #24]
1002baa4:	e58d101c 	str	r1, [sp, #28]
1002baa8:	e58d2020 	str	r2, [sp, #32]
1002baac:	e58d3024 	str	r3, [sp, #36]	; 0x24
1002bab0:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002bab4:	e51b0078 	ldr	r0, [fp, #-120]	; 0x78
1002bab8:	e1a0100a 	mov	r1, sl
1002babc:	e1a02009 	mov	r2, r9
1002bac0:	e1a03008 	mov	r3, r8
1002bac4:	e12fff3c 	blx	ip
1002bac8:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13]);
		break;
1002bacc:	ea00004d 	b	1002bc08 <OP_call+0x670>

	case 15:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002bad0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
1002bad4:	e50b3078 	str	r3, [fp, #-120]	; 0x78
1002bad8:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
1002badc:	e50b207c 	str	r2, [fp, #-124]	; 0x7c
1002bae0:	e51ba06c 	ldr	sl, [fp, #-108]	; 0x6c
1002bae4:	e51b9068 	ldr	r9, [fp, #-104]	; 0x68
1002bae8:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
1002baec:	e51b8060 	ldr	r8, [fp, #-96]	; 0x60
1002baf0:	e51b705c 	ldr	r7, [fp, #-92]	; 0x5c
1002baf4:	e51b6058 	ldr	r6, [fp, #-88]	; 0x58
1002baf8:	e51b5054 	ldr	r5, [fp, #-84]	; 0x54
1002bafc:	e51b4050 	ldr	r4, [fp, #-80]	; 0x50
1002bb00:	e51be04c 	ldr	lr, [fp, #-76]	; 0x4c
1002bb04:	e51bc048 	ldr	ip, [fp, #-72]	; 0x48
1002bb08:	e51b0044 	ldr	r0, [fp, #-68]	; 0x44
1002bb0c:	e51b1040 	ldr	r1, [fp, #-64]	; 0x40
1002bb10:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
1002bb14:	e58d2000 	str	r2, [sp]
1002bb18:	e58d8004 	str	r8, [sp, #4]
1002bb1c:	e58d7008 	str	r7, [sp, #8]
1002bb20:	e58d600c 	str	r6, [sp, #12]
1002bb24:	e58d5010 	str	r5, [sp, #16]
1002bb28:	e58d4014 	str	r4, [sp, #20]
1002bb2c:	e58de018 	str	lr, [sp, #24]
1002bb30:	e58dc01c 	str	ip, [sp, #28]
1002bb34:	e58d0020 	str	r0, [sp, #32]
1002bb38:	e58d1024 	str	r1, [sp, #36]	; 0x24
1002bb3c:	e58d3028 	str	r3, [sp, #40]	; 0x28
1002bb40:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002bb44:	e51b0078 	ldr	r0, [fp, #-120]	; 0x78
1002bb48:	e51b107c 	ldr	r1, [fp, #-124]	; 0x7c
1002bb4c:	e1a0200a 	mov	r2, sl
1002bb50:	e1a03009 	mov	r3, r9
1002bb54:	e12fff3c 	blx	ip
1002bb58:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14]);
		break;
1002bb5c:	ea000029 	b	1002bc08 <OP_call+0x670>

	case 16:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1002bb60:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
1002bb64:	e50b3078 	str	r3, [fp, #-120]	; 0x78
1002bb68:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
1002bb6c:	e50b207c 	str	r2, [fp, #-124]	; 0x7c
1002bb70:	e51bc06c 	ldr	ip, [fp, #-108]	; 0x6c
1002bb74:	e50bc080 	str	ip, [fp, #-128]	; 0x80
1002bb78:	e51ba068 	ldr	sl, [fp, #-104]	; 0x68
1002bb7c:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
1002bb80:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
1002bb84:	e51b905c 	ldr	r9, [fp, #-92]	; 0x5c
1002bb88:	e51b8058 	ldr	r8, [fp, #-88]	; 0x58
1002bb8c:	e51b7054 	ldr	r7, [fp, #-84]	; 0x54
1002bb90:	e51b6050 	ldr	r6, [fp, #-80]	; 0x50
1002bb94:	e51b504c 	ldr	r5, [fp, #-76]	; 0x4c
1002bb98:	e51b4048 	ldr	r4, [fp, #-72]	; 0x48
1002bb9c:	e51be044 	ldr	lr, [fp, #-68]	; 0x44
1002bba0:	e51bc040 	ldr	ip, [fp, #-64]	; 0x40
1002bba4:	e51b103c 	ldr	r1, [fp, #-60]	; 0x3c
1002bba8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1002bbac:	e58d2000 	str	r2, [sp]
1002bbb0:	e58d0004 	str	r0, [sp, #4]
1002bbb4:	e58d9008 	str	r9, [sp, #8]
1002bbb8:	e58d800c 	str	r8, [sp, #12]
1002bbbc:	e58d7010 	str	r7, [sp, #16]
1002bbc0:	e58d6014 	str	r6, [sp, #20]
1002bbc4:	e58d5018 	str	r5, [sp, #24]
1002bbc8:	e58d401c 	str	r4, [sp, #28]
1002bbcc:	e58de020 	str	lr, [sp, #32]
1002bbd0:	e58dc024 	str	ip, [sp, #36]	; 0x24
1002bbd4:	e58d1028 	str	r1, [sp, #40]	; 0x28
1002bbd8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
1002bbdc:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1002bbe0:	e51b0078 	ldr	r0, [fp, #-120]	; 0x78
1002bbe4:	e51b107c 	ldr	r1, [fp, #-124]	; 0x7c
1002bbe8:	e51b2080 	ldr	r2, [fp, #-128]	; 0x80
1002bbec:	e1a0300a 	mov	r3, sl
1002bbf0:	e12fff3c 	blx	ip
1002bbf4:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14], parameterv[15]);
		break;
1002bbf8:	ea000002 	b	1002bc08 <OP_call+0x670>

	default:
		r = 0;
1002bbfc:	e3a03000 	mov	r3, #0
1002bc00:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
		break;
1002bc04:	e1a00000 	nop			; (mov r0, r0)
	}

	finsh_sp->long_value = r;
1002bc08:	e30339a8 	movw	r3, #14760	; 0x39a8
1002bc0c:	e3413004 	movt	r3, #4100	; 0x1004
1002bc10:	e5933000 	ldr	r3, [r3]
1002bc14:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
1002bc18:	e5832000 	str	r2, [r3]
	finsh_sp ++;
1002bc1c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002bc20:	e3413004 	movt	r3, #4100	; 0x1004
1002bc24:	e5933000 	ldr	r3, [r3]
1002bc28:	e2832004 	add	r2, r3, #4
1002bc2c:	e30339a8 	movw	r3, #14760	; 0x39a8
1002bc30:	e3413004 	movt	r3, #4100	; 0x1004
1002bc34:	e5832000 	str	r2, [r3]

	return ;
1002bc38:	e1a00000 	nop			; (mov r0, r0)
}
1002bc3c:	e24bd020 	sub	sp, fp, #32
1002bc40:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

1002bc44 <proc_variable_decl>:
	| declarator
declarator -> identifier
	| identifier ASSIGN expr_assign
*/
static struct finsh_node* proc_variable_decl(struct finsh_parser* self)
{
1002bc44:	e92d4800 	push	{fp, lr}
1002bc48:	e28db004 	add	fp, sp, #4
1002bc4c:	e24dd040 	sub	sp, sp, #64	; 0x40
1002bc50:	e50b0040 	str	r0, [fp, #-64]	; 0x40

	struct finsh_node *node;
	struct finsh_node *end;
	struct finsh_node *assign;

    node = NULL;
1002bc54:	e3a03000 	mov	r3, #0
1002bc58:	e50b300c 	str	r3, [fp, #-12]
	end  = NULL;
1002bc5c:	e3a03000 	mov	r3, #0
1002bc60:	e50b3010 	str	r3, [fp, #-16]

	/* get type */
	type = proc_type(self);
1002bc64:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002bc68:	eb000109 	bl	1002c094 <proc_type>
1002bc6c:	e1a03000 	mov	r3, r0
1002bc70:	e54b3011 	strb	r3, [fp, #-17]

	/*process id.*/
	if (proc_identifier(self, id) == 0)
1002bc74:	e24b3038 	sub	r3, fp, #56	; 0x38
1002bc78:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002bc7c:	e1a01003 	mov	r1, r3
1002bc80:	eb0001ad 	bl	1002c33c <proc_identifier>
1002bc84:	e1a03000 	mov	r3, r0
1002bc88:	e3530000 	cmp	r3, #0
1002bc8c:	1a000009 	bne	1002bcb8 <proc_variable_decl+0x74>
	{
		/* if add variable failed */
		if (finsh_var_insert(id, type) < 0)
1002bc90:	e55b3011 	ldrb	r3, [fp, #-17]
1002bc94:	e24b2038 	sub	r2, fp, #56	; 0x38
1002bc98:	e1a00002 	mov	r0, r2
1002bc9c:	e1a01003 	mov	r1, r3
1002bca0:	eb0005c2 	bl	1002d3b0 <finsh_var_insert>
1002bca4:	e1a03000 	mov	r3, r0
1002bca8:	e3530000 	cmp	r3, #0
1002bcac:	aa000001 	bge	1002bcb8 <proc_variable_decl+0x74>
		{
			finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
1002bcb0:	e3a00004 	mov	r0, #4
1002bcb4:	ebfff5ae 	bl	10029374 <finsh_error_set>
		}
	}

	next_token(token, &(self->token));
1002bcb8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002bcbc:	e2833004 	add	r3, r3, #4
1002bcc0:	e1a00003 	mov	r0, r3
1002bcc4:	eb000781 	bl	1002dad0 <finsh_token_token>
1002bcc8:	e1a03000 	mov	r3, r0
1002bccc:	e54b3005 	strb	r3, [fp, #-5]
	switch ( token )
1002bcd0:	e55b3005 	ldrb	r3, [fp, #-5]
1002bcd4:	e3530004 	cmp	r3, #4
1002bcd8:	0a0000e5 	beq	1002c074 <proc_variable_decl+0x430>
1002bcdc:	e353000c 	cmp	r3, #12
1002bce0:	0a00007f 	beq	1002bee4 <proc_variable_decl+0x2a0>
1002bce4:	e3530003 	cmp	r3, #3
1002bce8:	1a0000e3 	bne	1002c07c <proc_variable_decl+0x438>
	{
	case finsh_token_type_comma:/*',', it's a variable_list declaration.*/
		if (proc_identifier(self, id) == 0)
1002bcec:	e24b3038 	sub	r3, fp, #56	; 0x38
1002bcf0:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002bcf4:	e1a01003 	mov	r1, r3
1002bcf8:	eb00018f 	bl	1002c33c <proc_identifier>
1002bcfc:	e1a03000 	mov	r3, r0
1002bd00:	e3530000 	cmp	r3, #0
1002bd04:	1a000009 	bne	1002bd30 <proc_variable_decl+0xec>
		{
			/* if add variable failed */
			if (finsh_var_insert(id, type) < 0)
1002bd08:	e55b3011 	ldrb	r3, [fp, #-17]
1002bd0c:	e24b2038 	sub	r2, fp, #56	; 0x38
1002bd10:	e1a00002 	mov	r0, r2
1002bd14:	e1a01003 	mov	r1, r3
1002bd18:	eb0005a4 	bl	1002d3b0 <finsh_var_insert>
1002bd1c:	e1a03000 	mov	r3, r0
1002bd20:	e3530000 	cmp	r3, #0
1002bd24:	aa000001 	bge	1002bd30 <proc_variable_decl+0xec>
			{
				finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
1002bd28:	e3a00004 	mov	r0, #4
1002bd2c:	ebfff590 	bl	10029374 <finsh_error_set>
			}
		}

		next_token(token, &(self->token));
1002bd30:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002bd34:	e2833004 	add	r3, r3, #4
1002bd38:	e1a00003 	mov	r0, r3
1002bd3c:	eb000763 	bl	1002dad0 <finsh_token_token>
1002bd40:	e1a03000 	mov	r3, r0
1002bd44:	e54b3005 	strb	r3, [fp, #-5]
		if ( token == finsh_token_type_assign )
1002bd48:	e55b3005 	ldrb	r3, [fp, #-5]
1002bd4c:	e353000c 	cmp	r3, #12
1002bd50:	1a000016 	bne	1002bdb0 <proc_variable_decl+0x16c>
		{
			/* get the right side of assign expression */
			assign = proc_assign_expr(self);
1002bd54:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002bd58:	eb0001c5 	bl	1002c474 <proc_assign_expr>
1002bd5c:	e50b0018 	str	r0, [fp, #-24]

			if (assign != NULL)
1002bd60:	e51b3018 	ldr	r3, [fp, #-24]
1002bd64:	e3530000 	cmp	r3, #0
1002bd68:	0a000010 	beq	1002bdb0 <proc_variable_decl+0x16c>
			{
				struct finsh_node* idnode;

				idnode = finsh_node_new_id(id);
1002bd6c:	e24b3038 	sub	r3, fp, #56	; 0x38
1002bd70:	e1a00003 	mov	r0, r3
1002bd74:	ebfff7c0 	bl	10029c7c <finsh_node_new_id>
1002bd78:	e50b001c 	str	r0, [fp, #-28]
				end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1002bd7c:	e3a00013 	mov	r0, #19
1002bd80:	e51b101c 	ldr	r1, [fp, #-28]
1002bd84:	e51b2018 	ldr	r2, [fp, #-24]
1002bd88:	eb0004b9 	bl	1002d074 <make_sys_node>
1002bd8c:	e50b0010 	str	r0, [fp, #-16]
				node = end;
1002bd90:	e51b3010 	ldr	r3, [fp, #-16]
1002bd94:	e50b300c 	str	r3, [fp, #-12]

				next_token(token, &(self->token));
1002bd98:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002bd9c:	e2833004 	add	r3, r3, #4
1002bda0:	e1a00003 	mov	r0, r3
1002bda4:	eb000749 	bl	1002dad0 <finsh_token_token>
1002bda8:	e1a03000 	mov	r3, r0
1002bdac:	e54b3005 	strb	r3, [fp, #-5]
			}
		}

		while ( token == finsh_token_type_comma )
1002bdb0:	ea00003e 	b	1002beb0 <proc_variable_decl+0x26c>
		{
			if (proc_identifier(self, id) == 0)
1002bdb4:	e24b3038 	sub	r3, fp, #56	; 0x38
1002bdb8:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002bdbc:	e1a01003 	mov	r1, r3
1002bdc0:	eb00015d 	bl	1002c33c <proc_identifier>
1002bdc4:	e1a03000 	mov	r3, r0
1002bdc8:	e3530000 	cmp	r3, #0
1002bdcc:	1a000009 	bne	1002bdf8 <proc_variable_decl+0x1b4>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
1002bdd0:	e55b3011 	ldrb	r3, [fp, #-17]
1002bdd4:	e24b2038 	sub	r2, fp, #56	; 0x38
1002bdd8:	e1a00002 	mov	r0, r2
1002bddc:	e1a01003 	mov	r1, r3
1002bde0:	eb000572 	bl	1002d3b0 <finsh_var_insert>
1002bde4:	e1a03000 	mov	r3, r0
1002bde8:	e3530000 	cmp	r3, #0
1002bdec:	aa000001 	bge	1002bdf8 <proc_variable_decl+0x1b4>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
1002bdf0:	e3a00004 	mov	r0, #4
1002bdf4:	ebfff55e 	bl	10029374 <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
1002bdf8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002bdfc:	e2833004 	add	r3, r3, #4
1002be00:	e1a00003 	mov	r0, r3
1002be04:	eb000731 	bl	1002dad0 <finsh_token_token>
1002be08:	e1a03000 	mov	r3, r0
1002be0c:	e54b3005 	strb	r3, [fp, #-5]
			if ( token == finsh_token_type_assign )
1002be10:	e55b3005 	ldrb	r3, [fp, #-5]
1002be14:	e353000c 	cmp	r3, #12
1002be18:	1a000024 	bne	1002beb0 <proc_variable_decl+0x26c>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
1002be1c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002be20:	eb000193 	bl	1002c474 <proc_assign_expr>
1002be24:	e50b0018 	str	r0, [fp, #-24]

				if (assign != NULL)
1002be28:	e51b3018 	ldr	r3, [fp, #-24]
1002be2c:	e3530000 	cmp	r3, #0
1002be30:	0a00001e 	beq	1002beb0 <proc_variable_decl+0x26c>
				{
					struct finsh_node* idnode;

					idnode = finsh_node_new_id(id);
1002be34:	e24b3038 	sub	r3, fp, #56	; 0x38
1002be38:	e1a00003 	mov	r0, r3
1002be3c:	ebfff78e 	bl	10029c7c <finsh_node_new_id>
1002be40:	e50b0020 	str	r0, [fp, #-32]

					/* make assign expression node */
					if (node != NULL)
1002be44:	e51b300c 	ldr	r3, [fp, #-12]
1002be48:	e3530000 	cmp	r3, #0
1002be4c:	0a00000a 	beq	1002be7c <proc_variable_decl+0x238>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1002be50:	e3a00013 	mov	r0, #19
1002be54:	e51b1020 	ldr	r1, [fp, #-32]
1002be58:	e51b2018 	ldr	r2, [fp, #-24]
1002be5c:	eb000484 	bl	1002d074 <make_sys_node>
1002be60:	e1a02000 	mov	r2, r0
1002be64:	e51b3010 	ldr	r3, [fp, #-16]
1002be68:	e583200c 	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
1002be6c:	e51b3010 	ldr	r3, [fp, #-16]
1002be70:	e593300c 	ldr	r3, [r3, #12]
1002be74:	e50b3010 	str	r3, [fp, #-16]
1002be78:	ea000006 	b	1002be98 <proc_variable_decl+0x254>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1002be7c:	e3a00013 	mov	r0, #19
1002be80:	e51b1020 	ldr	r1, [fp, #-32]
1002be84:	e51b2018 	ldr	r2, [fp, #-24]
1002be88:	eb000479 	bl	1002d074 <make_sys_node>
1002be8c:	e50b0010 	str	r0, [fp, #-16]
						node = end;
1002be90:	e51b3010 	ldr	r3, [fp, #-16]
1002be94:	e50b300c 	str	r3, [fp, #-12]
					}

					next_token(token, &(self->token));
1002be98:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002be9c:	e2833004 	add	r3, r3, #4
1002bea0:	e1a00003 	mov	r0, r3
1002bea4:	eb000709 	bl	1002dad0 <finsh_token_token>
1002bea8:	e1a03000 	mov	r3, r0
1002beac:	e54b3005 	strb	r3, [fp, #-5]

				next_token(token, &(self->token));
			}
		}

		while ( token == finsh_token_type_comma )
1002beb0:	e55b3005 	ldrb	r3, [fp, #-5]
1002beb4:	e3530003 	cmp	r3, #3
1002beb8:	0affffbd 	beq	1002bdb4 <proc_variable_decl+0x170>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
1002bebc:	e55b3005 	ldrb	r3, [fp, #-5]
1002bec0:	e3530004 	cmp	r3, #4
1002bec4:	0a000004 	beq	1002bedc <proc_variable_decl+0x298>
1002bec8:	e3a00001 	mov	r0, #1
1002becc:	ebfff528 	bl	10029374 <finsh_error_set>
1002bed0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002bed4:	e3a02001 	mov	r2, #1
1002bed8:	e5c32005 	strb	r2, [r3, #5]
		return node;
1002bedc:	e51b300c 	ldr	r3, [fp, #-12]
1002bee0:	ea000068 	b	1002c088 <proc_variable_decl+0x444>

	case finsh_token_type_assign:/*'=', it's a variable with assign declaration.*/
	{
		struct finsh_node *idnode;

		assign = proc_assign_expr(self);
1002bee4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002bee8:	eb000161 	bl	1002c474 <proc_assign_expr>
1002beec:	e50b0018 	str	r0, [fp, #-24]
		if (assign != NULL)
1002bef0:	e51b3018 	ldr	r3, [fp, #-24]
1002bef4:	e3530000 	cmp	r3, #0
1002bef8:	0a000010 	beq	1002bf40 <proc_variable_decl+0x2fc>
		{
			idnode = finsh_node_new_id(id);
1002befc:	e24b3038 	sub	r3, fp, #56	; 0x38
1002bf00:	e1a00003 	mov	r0, r3
1002bf04:	ebfff75c 	bl	10029c7c <finsh_node_new_id>
1002bf08:	e50b0024 	str	r0, [fp, #-36]	; 0x24

			/* make assign expression node */
			end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1002bf0c:	e3a00013 	mov	r0, #19
1002bf10:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
1002bf14:	e51b2018 	ldr	r2, [fp, #-24]
1002bf18:	eb000455 	bl	1002d074 <make_sys_node>
1002bf1c:	e50b0010 	str	r0, [fp, #-16]
			node = end;
1002bf20:	e51b3010 	ldr	r3, [fp, #-16]
1002bf24:	e50b300c 	str	r3, [fp, #-12]

			next_token(token, &(self->token));
1002bf28:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002bf2c:	e2833004 	add	r3, r3, #4
1002bf30:	e1a00003 	mov	r0, r3
1002bf34:	eb0006e5 	bl	1002dad0 <finsh_token_token>
1002bf38:	e1a03000 	mov	r3, r0
1002bf3c:	e54b3005 	strb	r3, [fp, #-5]
		}

		while ( token == finsh_token_type_comma )
1002bf40:	ea00003e 	b	1002c040 <proc_variable_decl+0x3fc>
		{
			if (proc_identifier(self, id) == 0)
1002bf44:	e24b3038 	sub	r3, fp, #56	; 0x38
1002bf48:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002bf4c:	e1a01003 	mov	r1, r3
1002bf50:	eb0000f9 	bl	1002c33c <proc_identifier>
1002bf54:	e1a03000 	mov	r3, r0
1002bf58:	e3530000 	cmp	r3, #0
1002bf5c:	1a000009 	bne	1002bf88 <proc_variable_decl+0x344>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
1002bf60:	e55b3011 	ldrb	r3, [fp, #-17]
1002bf64:	e24b2038 	sub	r2, fp, #56	; 0x38
1002bf68:	e1a00002 	mov	r0, r2
1002bf6c:	e1a01003 	mov	r1, r3
1002bf70:	eb00050e 	bl	1002d3b0 <finsh_var_insert>
1002bf74:	e1a03000 	mov	r3, r0
1002bf78:	e3530000 	cmp	r3, #0
1002bf7c:	aa000001 	bge	1002bf88 <proc_variable_decl+0x344>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
1002bf80:	e3a00004 	mov	r0, #4
1002bf84:	ebfff4fa 	bl	10029374 <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
1002bf88:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002bf8c:	e2833004 	add	r3, r3, #4
1002bf90:	e1a00003 	mov	r0, r3
1002bf94:	eb0006cd 	bl	1002dad0 <finsh_token_token>
1002bf98:	e1a03000 	mov	r3, r0
1002bf9c:	e54b3005 	strb	r3, [fp, #-5]
			if (token == finsh_token_type_assign)
1002bfa0:	e55b3005 	ldrb	r3, [fp, #-5]
1002bfa4:	e353000c 	cmp	r3, #12
1002bfa8:	1a000024 	bne	1002c040 <proc_variable_decl+0x3fc>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
1002bfac:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1002bfb0:	eb00012f 	bl	1002c474 <proc_assign_expr>
1002bfb4:	e50b0018 	str	r0, [fp, #-24]

				if (assign != NULL)
1002bfb8:	e51b3018 	ldr	r3, [fp, #-24]
1002bfbc:	e3530000 	cmp	r3, #0
1002bfc0:	0a00001e 	beq	1002c040 <proc_variable_decl+0x3fc>
				{
					idnode = finsh_node_new_id(id);
1002bfc4:	e24b3038 	sub	r3, fp, #56	; 0x38
1002bfc8:	e1a00003 	mov	r0, r3
1002bfcc:	ebfff72a 	bl	10029c7c <finsh_node_new_id>
1002bfd0:	e50b0024 	str	r0, [fp, #-36]	; 0x24

					/* make assign expression node */
					if (node != NULL)
1002bfd4:	e51b300c 	ldr	r3, [fp, #-12]
1002bfd8:	e3530000 	cmp	r3, #0
1002bfdc:	0a00000a 	beq	1002c00c <proc_variable_decl+0x3c8>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1002bfe0:	e3a00013 	mov	r0, #19
1002bfe4:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
1002bfe8:	e51b2018 	ldr	r2, [fp, #-24]
1002bfec:	eb000420 	bl	1002d074 <make_sys_node>
1002bff0:	e1a02000 	mov	r2, r0
1002bff4:	e51b3010 	ldr	r3, [fp, #-16]
1002bff8:	e583200c 	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
1002bffc:	e51b3010 	ldr	r3, [fp, #-16]
1002c000:	e593300c 	ldr	r3, [r3, #12]
1002c004:	e50b3010 	str	r3, [fp, #-16]
1002c008:	ea000006 	b	1002c028 <proc_variable_decl+0x3e4>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1002c00c:	e3a00013 	mov	r0, #19
1002c010:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
1002c014:	e51b2018 	ldr	r2, [fp, #-24]
1002c018:	eb000415 	bl	1002d074 <make_sys_node>
1002c01c:	e50b0010 	str	r0, [fp, #-16]
						node = end;
1002c020:	e51b3010 	ldr	r3, [fp, #-16]
1002c024:	e50b300c 	str	r3, [fp, #-12]
					}

					next_token(token, &(self->token));
1002c028:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002c02c:	e2833004 	add	r3, r3, #4
1002c030:	e1a00003 	mov	r0, r3
1002c034:	eb0006a5 	bl	1002dad0 <finsh_token_token>
1002c038:	e1a03000 	mov	r3, r0
1002c03c:	e54b3005 	strb	r3, [fp, #-5]
			node = end;

			next_token(token, &(self->token));
		}

		while ( token == finsh_token_type_comma )
1002c040:	e55b3005 	ldrb	r3, [fp, #-5]
1002c044:	e3530003 	cmp	r3, #3
1002c048:	0affffbd 	beq	1002bf44 <proc_variable_decl+0x300>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
1002c04c:	e55b3005 	ldrb	r3, [fp, #-5]
1002c050:	e3530004 	cmp	r3, #4
1002c054:	0a000004 	beq	1002c06c <proc_variable_decl+0x428>
1002c058:	e3a00001 	mov	r0, #1
1002c05c:	ebfff4c4 	bl	10029374 <finsh_error_set>
1002c060:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1002c064:	e3a02001 	mov	r2, #1
1002c068:	e5c32005 	strb	r2, [r3, #5]
		return node;
1002c06c:	e51b300c 	ldr	r3, [fp, #-12]
1002c070:	ea000004 	b	1002c088 <proc_variable_decl+0x444>
	}

	case finsh_token_type_semicolon:/*';', it's a variable declaration.*/
		return node;
1002c074:	e51b300c 	ldr	r3, [fp, #-12]
1002c078:	ea000002 	b	1002c088 <proc_variable_decl+0x444>

	default:
		finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
1002c07c:	e3a00002 	mov	r0, #2
1002c080:	ebfff4bb 	bl	10029374 <finsh_error_set>

		return NULL;
1002c084:	e3a03000 	mov	r3, #0
	}
}
1002c088:	e1a00003 	mov	r0, r3
1002c08c:	e24bd004 	sub	sp, fp, #4
1002c090:	e8bd8800 	pop	{fp, pc}

1002c094 <proc_type>:
	| SHORT
	| INT
	| STRING
*/
static enum finsh_type proc_type(struct finsh_parser* self)
{
1002c094:	e92d4800 	push	{fp, lr}
1002c098:	e28db004 	add	fp, sp, #4
1002c09c:	e24dd010 	sub	sp, sp, #16
1002c0a0:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_type type;
	enum finsh_token_type token;

	/* set init type */
	type = finsh_type_unknown;
1002c0a4:	e3a03000 	mov	r3, #0
1002c0a8:	e54b3005 	strb	r3, [fp, #-5]

	next_token(token, &(self->token));
1002c0ac:	e51b3010 	ldr	r3, [fp, #-16]
1002c0b0:	e2833004 	add	r3, r3, #4
1002c0b4:	e1a00003 	mov	r0, r3
1002c0b8:	eb000684 	bl	1002dad0 <finsh_token_token>
1002c0bc:	e1a03000 	mov	r3, r0
1002c0c0:	e54b3006 	strb	r3, [fp, #-6]
	if ( is_base_type(token) ) /* base_type */
1002c0c4:	e55b3006 	ldrb	r3, [fp, #-6]
1002c0c8:	e3530014 	cmp	r3, #20
1002c0cc:	0a00000b 	beq	1002c100 <proc_type+0x6c>
1002c0d0:	e55b3006 	ldrb	r3, [fp, #-6]
1002c0d4:	e3530015 	cmp	r3, #21
1002c0d8:	0a000008 	beq	1002c100 <proc_type+0x6c>
1002c0dc:	e55b3006 	ldrb	r3, [fp, #-6]
1002c0e0:	e3530016 	cmp	r3, #22
1002c0e4:	0a000005 	beq	1002c100 <proc_type+0x6c>
1002c0e8:	e55b3006 	ldrb	r3, [fp, #-6]
1002c0ec:	e3530017 	cmp	r3, #23
1002c0f0:	0a000002 	beq	1002c100 <proc_type+0x6c>
1002c0f4:	e55b3006 	ldrb	r3, [fp, #-6]
1002c0f8:	e3530018 	cmp	r3, #24
1002c0fc:	1a000019 	bne	1002c168 <proc_type+0xd4>
	{
		switch (token)
1002c100:	e55b3006 	ldrb	r3, [fp, #-6]
1002c104:	e2433014 	sub	r3, r3, #20
1002c108:	e3530004 	cmp	r3, #4
1002c10c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002c110:	ea00007d 	b	1002c30c <proc_type+0x278>
1002c114:	1002c128 	.word	0x1002c128
1002c118:	1002c134 	.word	0x1002c134
1002c11c:	1002c140 	.word	0x1002c140
1002c120:	1002c14c 	.word	0x1002c14c
1002c124:	1002c158 	.word	0x1002c158
		{
		case finsh_token_type_void:
			type = finsh_type_void;
1002c128:	e3a03001 	mov	r3, #1
1002c12c:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c130:	ea00000b 	b	1002c164 <proc_type+0xd0>

		case finsh_token_type_char:
			type = finsh_type_char;
1002c134:	e3a03003 	mov	r3, #3
1002c138:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c13c:	ea000008 	b	1002c164 <proc_type+0xd0>

		case finsh_token_type_short:
			type = finsh_type_short;
1002c140:	e3a03006 	mov	r3, #6
1002c144:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c148:	ea000005 	b	1002c164 <proc_type+0xd0>

		case finsh_token_type_int:
			type = finsh_type_int;
1002c14c:	e3a03009 	mov	r3, #9
1002c150:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c154:	ea000002 	b	1002c164 <proc_type+0xd0>

		case finsh_token_type_long:
			type = finsh_type_long;
1002c158:	e3a0300c 	mov	r3, #12
1002c15c:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c160:	e1a00000 	nop			; (mov r0, r0)

		default:
			goto __return;
		}
	}
1002c164:	ea000035 	b	1002c240 <proc_type+0x1ac>
	else if ( token == finsh_token_type_unsigned ) /* unsigned base_type */
1002c168:	e55b3006 	ldrb	r3, [fp, #-6]
1002c16c:	e3530019 	cmp	r3, #25
1002c170:	1a000031 	bne	1002c23c <proc_type+0x1a8>
	{
		next_token(token, &(self->token));
1002c174:	e51b3010 	ldr	r3, [fp, #-16]
1002c178:	e2833004 	add	r3, r3, #4
1002c17c:	e1a00003 	mov	r0, r3
1002c180:	eb000652 	bl	1002dad0 <finsh_token_token>
1002c184:	e1a03000 	mov	r3, r0
1002c188:	e54b3006 	strb	r3, [fp, #-6]
		if ( is_base_type(token) )
1002c18c:	e55b3006 	ldrb	r3, [fp, #-6]
1002c190:	e3530014 	cmp	r3, #20
1002c194:	0a00000b 	beq	1002c1c8 <proc_type+0x134>
1002c198:	e55b3006 	ldrb	r3, [fp, #-6]
1002c19c:	e3530015 	cmp	r3, #21
1002c1a0:	0a000008 	beq	1002c1c8 <proc_type+0x134>
1002c1a4:	e55b3006 	ldrb	r3, [fp, #-6]
1002c1a8:	e3530016 	cmp	r3, #22
1002c1ac:	0a000005 	beq	1002c1c8 <proc_type+0x134>
1002c1b0:	e55b3006 	ldrb	r3, [fp, #-6]
1002c1b4:	e3530017 	cmp	r3, #23
1002c1b8:	0a000002 	beq	1002c1c8 <proc_type+0x134>
1002c1bc:	e55b3006 	ldrb	r3, [fp, #-6]
1002c1c0:	e3530018 	cmp	r3, #24
1002c1c4:	1a000016 	bne	1002c224 <proc_type+0x190>
		{
			switch (token)
1002c1c8:	e55b3006 	ldrb	r3, [fp, #-6]
1002c1cc:	e2433015 	sub	r3, r3, #21
1002c1d0:	e3530003 	cmp	r3, #3
1002c1d4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002c1d8:	ea00004d 	b	1002c314 <proc_type+0x280>
1002c1dc:	1002c1ec 	.word	0x1002c1ec
1002c1e0:	1002c1f8 	.word	0x1002c1f8
1002c1e4:	1002c204 	.word	0x1002c204
1002c1e8:	1002c210 	.word	0x1002c210
			{
			case finsh_token_type_char:
				type = finsh_type_uchar;
1002c1ec:	e3a03004 	mov	r3, #4
1002c1f0:	e54b3005 	strb	r3, [fp, #-5]
				break;
1002c1f4:	ea000008 	b	1002c21c <proc_type+0x188>

			case finsh_token_type_short:
				type = finsh_type_ushort;
1002c1f8:	e3a03007 	mov	r3, #7
1002c1fc:	e54b3005 	strb	r3, [fp, #-5]
				break;
1002c200:	ea000005 	b	1002c21c <proc_type+0x188>

			case finsh_token_type_int:
				type = finsh_type_uint;
1002c204:	e3a0300a 	mov	r3, #10
1002c208:	e54b3005 	strb	r3, [fp, #-5]
				break;
1002c20c:	ea000002 	b	1002c21c <proc_type+0x188>

			case finsh_token_type_long:
				type = finsh_type_ulong;
1002c210:	e3a0300d 	mov	r3, #13
1002c214:	e54b3005 	strb	r3, [fp, #-5]
				break;
1002c218:	e1a00000 	nop			; (mov r0, r0)

			default:
				goto __return;
			}
		}
1002c21c:	e1a00000 	nop			; (mov r0, r0)
1002c220:	ea000006 	b	1002c240 <proc_type+0x1ac>
		else
		{
			finsh_token_replay(&(self->token));
1002c224:	e51b3010 	ldr	r3, [fp, #-16]
1002c228:	e3a02001 	mov	r2, #1
1002c22c:	e5c32005 	strb	r2, [r3, #5]
			finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
1002c230:	e3a00002 	mov	r0, #2
1002c234:	ebfff44e 	bl	10029374 <finsh_error_set>
1002c238:	ea000000 	b	1002c240 <proc_type+0x1ac>
		}
	}
	else
	{
		goto __return;
1002c23c:	ea000035 	b	1002c318 <proc_type+0x284>
	}

	/* parse for pointer */
	next_token(token, &(self->token));
1002c240:	e51b3010 	ldr	r3, [fp, #-16]
1002c244:	e2833004 	add	r3, r3, #4
1002c248:	e1a00003 	mov	r0, r3
1002c24c:	eb00061f 	bl	1002dad0 <finsh_token_token>
1002c250:	e1a03000 	mov	r3, r0
1002c254:	e54b3006 	strb	r3, [fp, #-6]
	if (token == finsh_token_type_mul)
1002c258:	e55b3006 	ldrb	r3, [fp, #-6]
1002c25c:	e3530005 	cmp	r3, #5
1002c260:	1a000024 	bne	1002c2f8 <proc_type+0x264>
	{
		switch (type)
1002c264:	e55b3005 	ldrb	r3, [fp, #-5]
1002c268:	e2433001 	sub	r3, r3, #1
1002c26c:	e353000c 	cmp	r3, #12
1002c270:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002c274:	ea00001b 	b	1002c2e8 <proc_type+0x254>
1002c278:	1002c2ac 	.word	0x1002c2ac
1002c27c:	1002c2e8 	.word	0x1002c2e8
1002c280:	1002c2b8 	.word	0x1002c2b8
1002c284:	1002c2b8 	.word	0x1002c2b8
1002c288:	1002c2e8 	.word	0x1002c2e8
1002c28c:	1002c2c4 	.word	0x1002c2c4
1002c290:	1002c2c4 	.word	0x1002c2c4
1002c294:	1002c2e8 	.word	0x1002c2e8
1002c298:	1002c2d0 	.word	0x1002c2d0
1002c29c:	1002c2d0 	.word	0x1002c2d0
1002c2a0:	1002c2e8 	.word	0x1002c2e8
1002c2a4:	1002c2dc 	.word	0x1002c2dc
1002c2a8:	1002c2dc 	.word	0x1002c2dc
		{
		case finsh_type_void:
			type = finsh_type_voidp;
1002c2ac:	e3a03002 	mov	r3, #2
1002c2b0:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c2b4:	ea00000e 	b	1002c2f4 <proc_type+0x260>

		case finsh_type_char:
		case finsh_type_uchar:
			type = finsh_type_charp;
1002c2b8:	e3a03005 	mov	r3, #5
1002c2bc:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c2c0:	ea00000b 	b	1002c2f4 <proc_type+0x260>

		case finsh_type_short:
		case finsh_type_ushort:
			type = finsh_type_shortp;
1002c2c4:	e3a03008 	mov	r3, #8
1002c2c8:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c2cc:	ea000008 	b	1002c2f4 <proc_type+0x260>

		case finsh_type_int:
		case finsh_type_uint:
			type = finsh_type_intp;
1002c2d0:	e3a0300b 	mov	r3, #11
1002c2d4:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c2d8:	ea000005 	b	1002c2f4 <proc_type+0x260>

		case finsh_type_long:
		case finsh_type_ulong:
			type = finsh_type_longp;
1002c2dc:	e3a0300e 	mov	r3, #14
1002c2e0:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c2e4:	ea000002 	b	1002c2f4 <proc_type+0x260>

		default:
			type = finsh_type_voidp;
1002c2e8:	e3a03002 	mov	r3, #2
1002c2ec:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002c2f0:	e1a00000 	nop			; (mov r0, r0)
1002c2f4:	ea000002 	b	1002c304 <proc_type+0x270>
		}
	}
	else finsh_token_replay(&(self->token));
1002c2f8:	e51b3010 	ldr	r3, [fp, #-16]
1002c2fc:	e3a02001 	mov	r2, #1
1002c300:	e5c32005 	strb	r2, [r3, #5]

	return type;
1002c304:	e55b3005 	ldrb	r3, [fp, #-5]
1002c308:	ea000008 	b	1002c330 <proc_type+0x29c>
		case finsh_token_type_long:
			type = finsh_type_long;
			break;

		default:
			goto __return;
1002c30c:	e1a00000 	nop			; (mov r0, r0)
1002c310:	ea000000 	b	1002c318 <proc_type+0x284>
			case finsh_token_type_long:
				type = finsh_type_ulong;
				break;

			default:
				goto __return;
1002c314:	e1a00000 	nop			; (mov r0, r0)
	else finsh_token_replay(&(self->token));

	return type;

__return:
	finsh_token_replay(&(self->token));
1002c318:	e51b3010 	ldr	r3, [fp, #-16]
1002c31c:	e3a02001 	mov	r2, #1
1002c320:	e5c32005 	strb	r2, [r3, #5]
	finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
1002c324:	e3a00003 	mov	r0, #3
1002c328:	ebfff411 	bl	10029374 <finsh_error_set>

	return type;
1002c32c:	e55b3005 	ldrb	r3, [fp, #-5]
}
1002c330:	e1a00003 	mov	r0, r3
1002c334:	e24bd004 	sub	sp, fp, #4
1002c338:	e8bd8800 	pop	{fp, pc}

1002c33c <proc_identifier>:

/*
identifier -> IDENTIFIER
*/
static int proc_identifier(struct finsh_parser* self, char* id)
{
1002c33c:	e92d4800 	push	{fp, lr}
1002c340:	e28db004 	add	fp, sp, #4
1002c344:	e24dd010 	sub	sp, sp, #16
1002c348:	e50b0010 	str	r0, [fp, #-16]
1002c34c:	e50b1014 	str	r1, [fp, #-20]
	enum finsh_token_type token;

	match_token(token, &(self->token), finsh_token_type_identifier);
1002c350:	e51b3010 	ldr	r3, [fp, #-16]
1002c354:	e2833004 	add	r3, r3, #4
1002c358:	e1a00003 	mov	r0, r3
1002c35c:	eb0005db 	bl	1002dad0 <finsh_token_token>
1002c360:	e1a03000 	mov	r3, r0
1002c364:	e54b3005 	strb	r3, [fp, #-5]
1002c368:	e55b3005 	ldrb	r3, [fp, #-5]
1002c36c:	e353001f 	cmp	r3, #31
1002c370:	0a000004 	beq	1002c388 <proc_identifier+0x4c>
1002c374:	e3a00001 	mov	r0, #1
1002c378:	ebfff3fd 	bl	10029374 <finsh_error_set>
1002c37c:	e51b3010 	ldr	r3, [fp, #-16]
1002c380:	e3a02001 	mov	r2, #1
1002c384:	e5c32005 	strb	r2, [r3, #5]

	strncpy(id, (char*)self->token.string, FINSH_NAME_MAX);
1002c388:	e51b3010 	ldr	r3, [fp, #-16]
1002c38c:	e2833014 	add	r3, r3, #20
1002c390:	e51b0014 	ldr	r0, [fp, #-20]
1002c394:	e1a01003 	mov	r1, r3
1002c398:	e3a02010 	mov	r2, #16
1002c39c:	fa000d3e 	blx	1002f89c <strncpy>

	return 0;
1002c3a0:	e3a03000 	mov	r3, #0
}
1002c3a4:	e1a00003 	mov	r0, r3
1002c3a8:	e24bd004 	sub	sp, fp, #4
1002c3ac:	e8bd8800 	pop	{fp, pc}

1002c3b0 <proc_expr_statement>:
/*
statement_expr -> ';'
	| expr ';'
*/
static struct finsh_node* proc_expr_statement(struct finsh_parser* self)
{
1002c3b0:	e92d4800 	push	{fp, lr}
1002c3b4:	e28db004 	add	fp, sp, #4
1002c3b8:	e24dd010 	sub	sp, sp, #16
1002c3bc:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	struct finsh_node* expr;

	expr = NULL;
1002c3c0:	e3a03000 	mov	r3, #0
1002c3c4:	e50b3008 	str	r3, [fp, #-8]
	next_token(token, &(self->token));
1002c3c8:	e51b3010 	ldr	r3, [fp, #-16]
1002c3cc:	e2833004 	add	r3, r3, #4
1002c3d0:	e1a00003 	mov	r0, r3
1002c3d4:	eb0005bd 	bl	1002dad0 <finsh_token_token>
1002c3d8:	e1a03000 	mov	r3, r0
1002c3dc:	e54b3009 	strb	r3, [fp, #-9]
	if ( token != finsh_token_type_semicolon )
1002c3e0:	e55b3009 	ldrb	r3, [fp, #-9]
1002c3e4:	e3530004 	cmp	r3, #4
1002c3e8:	0a000013 	beq	1002c43c <proc_expr_statement+0x8c>
	{
		finsh_token_replay(&(self->token));
1002c3ec:	e51b3010 	ldr	r3, [fp, #-16]
1002c3f0:	e3a02001 	mov	r2, #1
1002c3f4:	e5c32005 	strb	r2, [r3, #5]
		expr = proc_expr(self);
1002c3f8:	e51b0010 	ldr	r0, [fp, #-16]
1002c3fc:	eb000012 	bl	1002c44c <proc_expr>
1002c400:	e50b0008 	str	r0, [fp, #-8]

		match_token(token, &(self->token), finsh_token_type_semicolon);
1002c404:	e51b3010 	ldr	r3, [fp, #-16]
1002c408:	e2833004 	add	r3, r3, #4
1002c40c:	e1a00003 	mov	r0, r3
1002c410:	eb0005ae 	bl	1002dad0 <finsh_token_token>
1002c414:	e1a03000 	mov	r3, r0
1002c418:	e54b3009 	strb	r3, [fp, #-9]
1002c41c:	e55b3009 	ldrb	r3, [fp, #-9]
1002c420:	e3530004 	cmp	r3, #4
1002c424:	0a000004 	beq	1002c43c <proc_expr_statement+0x8c>
1002c428:	e3a00001 	mov	r0, #1
1002c42c:	ebfff3d0 	bl	10029374 <finsh_error_set>
1002c430:	e51b3010 	ldr	r3, [fp, #-16]
1002c434:	e3a02001 	mov	r2, #1
1002c438:	e5c32005 	strb	r2, [r3, #5]
	}

	return expr;
1002c43c:	e51b3008 	ldr	r3, [fp, #-8]
}
1002c440:	e1a00003 	mov	r0, r3
1002c444:	e24bd004 	sub	sp, fp, #4
1002c448:	e8bd8800 	pop	{fp, pc}

1002c44c <proc_expr>:

/*
expr -> expr_assign
*/
static struct finsh_node* proc_expr(struct finsh_parser* self)
{
1002c44c:	e92d4800 	push	{fp, lr}
1002c450:	e28db004 	add	fp, sp, #4
1002c454:	e24dd008 	sub	sp, sp, #8
1002c458:	e50b0008 	str	r0, [fp, #-8]
	return proc_assign_expr(self);
1002c45c:	e51b0008 	ldr	r0, [fp, #-8]
1002c460:	eb000003 	bl	1002c474 <proc_assign_expr>
1002c464:	e1a03000 	mov	r3, r0
}
1002c468:	e1a00003 	mov	r0, r3
1002c46c:	e24bd004 	sub	sp, fp, #4
1002c470:	e8bd8800 	pop	{fp, pc}

1002c474 <proc_assign_expr>:
/*
expr_assign -> expr_inclusive_or
	| expr_unary ASSIGN expr_assign
*/
static struct finsh_node* proc_assign_expr(struct finsh_parser* self)
{
1002c474:	e92d4800 	push	{fp, lr}
1002c478:	e28db004 	add	fp, sp, #4
1002c47c:	e24dd018 	sub	sp, sp, #24
1002c480:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* or;
	struct finsh_node* assign;

	or = proc_inclusive_or_expr(self);
1002c484:	e51b0018 	ldr	r0, [fp, #-24]
1002c488:	eb000019 	bl	1002c4f4 <proc_inclusive_or_expr>
1002c48c:	e50b0008 	str	r0, [fp, #-8]

	next_token(token, &(self->token));
1002c490:	e51b3018 	ldr	r3, [fp, #-24]
1002c494:	e2833004 	add	r3, r3, #4
1002c498:	e1a00003 	mov	r0, r3
1002c49c:	eb00058b 	bl	1002dad0 <finsh_token_token>
1002c4a0:	e1a03000 	mov	r3, r0
1002c4a4:	e54b3009 	strb	r3, [fp, #-9]

	if (token == finsh_token_type_assign)
1002c4a8:	e55b3009 	ldrb	r3, [fp, #-9]
1002c4ac:	e353000c 	cmp	r3, #12
1002c4b0:	1a000008 	bne	1002c4d8 <proc_assign_expr+0x64>
	{
		assign = proc_assign_expr(self);
1002c4b4:	e51b0018 	ldr	r0, [fp, #-24]
1002c4b8:	ebffffed 	bl	1002c474 <proc_assign_expr>
1002c4bc:	e50b0010 	str	r0, [fp, #-16]

		return make_sys_node(FINSH_NODE_SYS_ASSIGN, or, assign);
1002c4c0:	e3a00013 	mov	r0, #19
1002c4c4:	e51b1008 	ldr	r1, [fp, #-8]
1002c4c8:	e51b2010 	ldr	r2, [fp, #-16]
1002c4cc:	eb0002e8 	bl	1002d074 <make_sys_node>
1002c4d0:	e1a03000 	mov	r3, r0
1002c4d4:	ea000003 	b	1002c4e8 <proc_assign_expr+0x74>
	}
	else finsh_token_replay(&(self->token));
1002c4d8:	e51b3018 	ldr	r3, [fp, #-24]
1002c4dc:	e3a02001 	mov	r2, #1
1002c4e0:	e5c32005 	strb	r2, [r3, #5]

	return or;
1002c4e4:	e51b3008 	ldr	r3, [fp, #-8]
}
1002c4e8:	e1a00003 	mov	r0, r3
1002c4ec:	e24bd004 	sub	sp, fp, #4
1002c4f0:	e8bd8800 	pop	{fp, pc}

1002c4f4 <proc_inclusive_or_expr>:
/*
expr_inclusive_or -> expr_exclusive_or
	| expr_inclusive_or '|' expr_exclusive_or
*/
static struct finsh_node* proc_inclusive_or_expr(struct finsh_parser* self)
{
1002c4f4:	e92d4800 	push	{fp, lr}
1002c4f8:	e28db004 	add	fp, sp, #4
1002c4fc:	e24dd018 	sub	sp, sp, #24
1002c500:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* xor;
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);
1002c504:	e51b0018 	ldr	r0, [fp, #-24]
1002c508:	eb000025 	bl	1002c5a4 <proc_exclusive_or_expr>
1002c50c:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1002c510:	e51b3018 	ldr	r3, [fp, #-24]
1002c514:	e2833004 	add	r3, r3, #4
1002c518:	e1a00003 	mov	r0, r3
1002c51c:	eb00056b 	bl	1002dad0 <finsh_token_token>
1002c520:	e1a03000 	mov	r3, r0
1002c524:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_or )
1002c528:	ea000013 	b	1002c57c <proc_inclusive_or_expr+0x88>
	{
		xor_new = proc_exclusive_or_expr(self);
1002c52c:	e51b0018 	ldr	r0, [fp, #-24]
1002c530:	eb00001b 	bl	1002c5a4 <proc_exclusive_or_expr>
1002c534:	e50b0010 	str	r0, [fp, #-16]

		if (xor_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c538:	e51b3010 	ldr	r3, [fp, #-16]
1002c53c:	e3530000 	cmp	r3, #0
1002c540:	1a000002 	bne	1002c550 <proc_inclusive_or_expr+0x5c>
1002c544:	e3a00005 	mov	r0, #5
1002c548:	ebfff389 	bl	10029374 <finsh_error_set>
1002c54c:	ea000004 	b	1002c564 <proc_inclusive_or_expr+0x70>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);
1002c550:	e3a0000d 	mov	r0, #13
1002c554:	e51b100c 	ldr	r1, [fp, #-12]
1002c558:	e51b2010 	ldr	r2, [fp, #-16]
1002c55c:	eb0002c4 	bl	1002d074 <make_sys_node>
1002c560:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
1002c564:	e51b3018 	ldr	r3, [fp, #-24]
1002c568:	e2833004 	add	r3, r3, #4
1002c56c:	e1a00003 	mov	r0, r3
1002c570:	eb000556 	bl	1002dad0 <finsh_token_token>
1002c574:	e1a03000 	mov	r3, r0
1002c578:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_or )
1002c57c:	e55b3005 	ldrb	r3, [fp, #-5]
1002c580:	e353000e 	cmp	r3, #14
1002c584:	0affffe8 	beq	1002c52c <proc_inclusive_or_expr+0x38>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1002c588:	e51b3018 	ldr	r3, [fp, #-24]
1002c58c:	e3a02001 	mov	r2, #1
1002c590:	e5c32005 	strb	r2, [r3, #5]
	return xor;
1002c594:	e51b300c 	ldr	r3, [fp, #-12]
}
1002c598:	e1a00003 	mov	r0, r3
1002c59c:	e24bd004 	sub	sp, fp, #4
1002c5a0:	e8bd8800 	pop	{fp, pc}

1002c5a4 <proc_exclusive_or_expr>:
/*
expr_exclusive_or -> expr_and
	| expr_exclusive '^' expr_and
*/
static struct finsh_node* proc_exclusive_or_expr(struct finsh_parser* self)
{
1002c5a4:	e92d4800 	push	{fp, lr}
1002c5a8:	e28db004 	add	fp, sp, #4
1002c5ac:	e24dd018 	sub	sp, sp, #24
1002c5b0:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
1002c5b4:	e51b0018 	ldr	r0, [fp, #-24]
1002c5b8:	eb000025 	bl	1002c654 <proc_and_expr>
1002c5bc:	e50b000c 	str	r0, [fp, #-12]
	next_token(token, &(self->token));
1002c5c0:	e51b3018 	ldr	r3, [fp, #-24]
1002c5c4:	e2833004 	add	r3, r3, #4
1002c5c8:	e1a00003 	mov	r0, r3
1002c5cc:	eb00053f 	bl	1002dad0 <finsh_token_token>
1002c5d0:	e1a03000 	mov	r3, r0
1002c5d4:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_xor )
1002c5d8:	ea000013 	b	1002c62c <proc_exclusive_or_expr+0x88>
	{
		and_new = proc_and_expr(self);
1002c5dc:	e51b0018 	ldr	r0, [fp, #-24]
1002c5e0:	eb00001b 	bl	1002c654 <proc_and_expr>
1002c5e4:	e50b0010 	str	r0, [fp, #-16]
		if (and_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c5e8:	e51b3010 	ldr	r3, [fp, #-16]
1002c5ec:	e3530000 	cmp	r3, #0
1002c5f0:	1a000002 	bne	1002c600 <proc_exclusive_or_expr+0x5c>
1002c5f4:	e3a00005 	mov	r0, #5
1002c5f8:	ebfff35d 	bl	10029374 <finsh_error_set>
1002c5fc:	ea000004 	b	1002c614 <proc_exclusive_or_expr+0x70>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);
1002c600:	e3a0000e 	mov	r0, #14
1002c604:	e51b100c 	ldr	r1, [fp, #-12]
1002c608:	e51b2010 	ldr	r2, [fp, #-16]
1002c60c:	eb000298 	bl	1002d074 <make_sys_node>
1002c610:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
1002c614:	e51b3018 	ldr	r3, [fp, #-24]
1002c618:	e2833004 	add	r3, r3, #4
1002c61c:	e1a00003 	mov	r0, r3
1002c620:	eb00052a 	bl	1002dad0 <finsh_token_token>
1002c624:	e1a03000 	mov	r3, r0
1002c628:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
	next_token(token, &(self->token));
	while ( token == finsh_token_type_xor )
1002c62c:	e55b3005 	ldrb	r3, [fp, #-5]
1002c630:	e353000f 	cmp	r3, #15
1002c634:	0affffe8 	beq	1002c5dc <proc_exclusive_or_expr+0x38>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1002c638:	e51b3018 	ldr	r3, [fp, #-24]
1002c63c:	e3a02001 	mov	r2, #1
1002c640:	e5c32005 	strb	r2, [r3, #5]
	return and;
1002c644:	e51b300c 	ldr	r3, [fp, #-12]
}
1002c648:	e1a00003 	mov	r0, r3
1002c64c:	e24bd004 	sub	sp, fp, #4
1002c650:	e8bd8800 	pop	{fp, pc}

1002c654 <proc_and_expr>:
/*
expr_and -> expr_shift
	| expr_and '&' expr_shift
*/
static struct finsh_node* proc_and_expr(struct finsh_parser* self)
{
1002c654:	e92d4800 	push	{fp, lr}
1002c658:	e28db004 	add	fp, sp, #4
1002c65c:	e24dd018 	sub	sp, sp, #24
1002c660:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* shift;
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);
1002c664:	e51b0018 	ldr	r0, [fp, #-24]
1002c668:	eb000025 	bl	1002c704 <proc_shift_expr>
1002c66c:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1002c670:	e51b3018 	ldr	r3, [fp, #-24]
1002c674:	e2833004 	add	r3, r3, #4
1002c678:	e1a00003 	mov	r0, r3
1002c67c:	eb000513 	bl	1002dad0 <finsh_token_token>
1002c680:	e1a03000 	mov	r3, r0
1002c684:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_and )
1002c688:	ea000013 	b	1002c6dc <proc_and_expr+0x88>
	{
		shift_new = proc_shift_expr(self);
1002c68c:	e51b0018 	ldr	r0, [fp, #-24]
1002c690:	eb00001b 	bl	1002c704 <proc_shift_expr>
1002c694:	e50b0010 	str	r0, [fp, #-16]

		if (shift_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c698:	e51b3010 	ldr	r3, [fp, #-16]
1002c69c:	e3530000 	cmp	r3, #0
1002c6a0:	1a000002 	bne	1002c6b0 <proc_and_expr+0x5c>
1002c6a4:	e3a00005 	mov	r0, #5
1002c6a8:	ebfff331 	bl	10029374 <finsh_error_set>
1002c6ac:	ea000004 	b	1002c6c4 <proc_and_expr+0x70>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);
1002c6b0:	e3a0000c 	mov	r0, #12
1002c6b4:	e51b100c 	ldr	r1, [fp, #-12]
1002c6b8:	e51b2010 	ldr	r2, [fp, #-16]
1002c6bc:	eb00026c 	bl	1002d074 <make_sys_node>
1002c6c0:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
1002c6c4:	e51b3018 	ldr	r3, [fp, #-24]
1002c6c8:	e2833004 	add	r3, r3, #4
1002c6cc:	e1a00003 	mov	r0, r3
1002c6d0:	eb0004fe 	bl	1002dad0 <finsh_token_token>
1002c6d4:	e1a03000 	mov	r3, r0
1002c6d8:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_and )
1002c6dc:	e55b3005 	ldrb	r3, [fp, #-5]
1002c6e0:	e353000d 	cmp	r3, #13
1002c6e4:	0affffe8 	beq	1002c68c <proc_and_expr+0x38>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1002c6e8:	e51b3018 	ldr	r3, [fp, #-24]
1002c6ec:	e3a02001 	mov	r2, #1
1002c6f0:	e5c32005 	strb	r2, [r3, #5]
	return shift;
1002c6f4:	e51b300c 	ldr	r3, [fp, #-12]
}
1002c6f8:	e1a00003 	mov	r0, r3
1002c6fc:	e24bd004 	sub	sp, fp, #4
1002c700:	e8bd8800 	pop	{fp, pc}

1002c704 <proc_shift_expr>:
expr_shift -> expr_additive
	| expr_shift '<<' expr_additive
	| expr_shift '>>' expr_additive
*/
static struct finsh_node* proc_shift_expr(struct finsh_parser* self)
{
1002c704:	e92d4800 	push	{fp, lr}
1002c708:	e28db004 	add	fp, sp, #4
1002c70c:	e24dd018 	sub	sp, sp, #24
1002c710:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* add;
	struct finsh_node* add_new;

	add = proc_additive_expr(self);
1002c714:	e51b0018 	ldr	r0, [fp, #-24]
1002c718:	eb000038 	bl	1002c800 <proc_additive_expr>
1002c71c:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1002c720:	e51b3018 	ldr	r3, [fp, #-24]
1002c724:	e2833004 	add	r3, r3, #4
1002c728:	e1a00003 	mov	r0, r3
1002c72c:	eb0004e7 	bl	1002dad0 <finsh_token_token>
1002c730:	e1a03000 	mov	r3, r0
1002c734:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
1002c738:	ea000023 	b	1002c7cc <proc_shift_expr+0xc8>
	{
		add_new = proc_additive_expr(self);
1002c73c:	e51b0018 	ldr	r0, [fp, #-24]
1002c740:	eb00002e 	bl	1002c800 <proc_additive_expr>
1002c744:	e50b0010 	str	r0, [fp, #-16]
		if (add_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c748:	e51b3010 	ldr	r3, [fp, #-16]
1002c74c:	e3530000 	cmp	r3, #0
1002c750:	1a000002 	bne	1002c760 <proc_shift_expr+0x5c>
1002c754:	e3a00005 	mov	r0, #5
1002c758:	ebfff305 	bl	10029374 <finsh_error_set>
1002c75c:	ea000014 	b	1002c7b4 <proc_shift_expr+0xb0>
		else
		{
			switch (token)
1002c760:	e55b3005 	ldrb	r3, [fp, #-5]
1002c764:	e3530011 	cmp	r3, #17
1002c768:	0a000002 	beq	1002c778 <proc_shift_expr+0x74>
1002c76c:	e3530012 	cmp	r3, #18
1002c770:	0a000006 	beq	1002c790 <proc_shift_expr+0x8c>
1002c774:	ea00000b 	b	1002c7a8 <proc_shift_expr+0xa4>
			{
			case finsh_token_type_shl:
				add = make_sys_node(FINSH_NODE_SYS_SHL, add, add_new);
1002c778:	e3a00010 	mov	r0, #16
1002c77c:	e51b100c 	ldr	r1, [fp, #-12]
1002c780:	e51b2010 	ldr	r2, [fp, #-16]
1002c784:	eb00023a 	bl	1002d074 <make_sys_node>
1002c788:	e50b000c 	str	r0, [fp, #-12]
				break;
1002c78c:	ea000008 	b	1002c7b4 <proc_shift_expr+0xb0>
			case finsh_token_type_shr:
				add = make_sys_node(FINSH_NODE_SYS_SHR, add, add_new);
1002c790:	e3a00011 	mov	r0, #17
1002c794:	e51b100c 	ldr	r1, [fp, #-12]
1002c798:	e51b2010 	ldr	r2, [fp, #-16]
1002c79c:	eb000234 	bl	1002d074 <make_sys_node>
1002c7a0:	e50b000c 	str	r0, [fp, #-12]
				break;
1002c7a4:	ea000002 	b	1002c7b4 <proc_shift_expr+0xb0>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c7a8:	e3a00005 	mov	r0, #5
1002c7ac:	ebfff2f0 	bl	10029374 <finsh_error_set>
				break;
1002c7b0:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
1002c7b4:	e51b3018 	ldr	r3, [fp, #-24]
1002c7b8:	e2833004 	add	r3, r3, #4
1002c7bc:	e1a00003 	mov	r0, r3
1002c7c0:	eb0004c2 	bl	1002dad0 <finsh_token_token>
1002c7c4:	e1a03000 	mov	r3, r0
1002c7c8:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* add_new;

	add = proc_additive_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
1002c7cc:	e55b3005 	ldrb	r3, [fp, #-5]
1002c7d0:	e3530011 	cmp	r3, #17
1002c7d4:	0affffd8 	beq	1002c73c <proc_shift_expr+0x38>
1002c7d8:	e55b3005 	ldrb	r3, [fp, #-5]
1002c7dc:	e3530012 	cmp	r3, #18
1002c7e0:	0affffd5 	beq	1002c73c <proc_shift_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1002c7e4:	e51b3018 	ldr	r3, [fp, #-24]
1002c7e8:	e3a02001 	mov	r2, #1
1002c7ec:	e5c32005 	strb	r2, [r3, #5]
	return add;
1002c7f0:	e51b300c 	ldr	r3, [fp, #-12]
}
1002c7f4:	e1a00003 	mov	r0, r3
1002c7f8:	e24bd004 	sub	sp, fp, #4
1002c7fc:	e8bd8800 	pop	{fp, pc}

1002c800 <proc_additive_expr>:
expr_additive -> expr_multiplicative
	| expr_additive SUB expr_multiplicative
	| expr_additive ADD expr_multiplicative
*/
static struct finsh_node* proc_additive_expr(struct finsh_parser* self)
{
1002c800:	e92d4800 	push	{fp, lr}
1002c804:	e28db004 	add	fp, sp, #4
1002c808:	e24dd018 	sub	sp, sp, #24
1002c80c:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* mul;
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);
1002c810:	e51b0018 	ldr	r0, [fp, #-24]
1002c814:	eb000037 	bl	1002c8f8 <proc_multiplicative_expr>
1002c818:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1002c81c:	e51b3018 	ldr	r3, [fp, #-24]
1002c820:	e2833004 	add	r3, r3, #4
1002c824:	e1a00003 	mov	r0, r3
1002c828:	eb0004a8 	bl	1002dad0 <finsh_token_token>
1002c82c:	e1a03000 	mov	r3, r0
1002c830:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
1002c834:	ea000022 	b	1002c8c4 <proc_additive_expr+0xc4>
	{
		mul_new = proc_multiplicative_expr(self);
1002c838:	e51b0018 	ldr	r0, [fp, #-24]
1002c83c:	eb00002d 	bl	1002c8f8 <proc_multiplicative_expr>
1002c840:	e50b0010 	str	r0, [fp, #-16]
		if (mul_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c844:	e51b3010 	ldr	r3, [fp, #-16]
1002c848:	e3530000 	cmp	r3, #0
1002c84c:	1a000002 	bne	1002c85c <proc_additive_expr+0x5c>
1002c850:	e3a00005 	mov	r0, #5
1002c854:	ebfff2c6 	bl	10029374 <finsh_error_set>
1002c858:	ea000013 	b	1002c8ac <proc_additive_expr+0xac>
		else
		{
			switch (token)
1002c85c:	e55b3005 	ldrb	r3, [fp, #-5]
1002c860:	e3530006 	cmp	r3, #6
1002c864:	0a000007 	beq	1002c888 <proc_additive_expr+0x88>
1002c868:	e3530008 	cmp	r3, #8
1002c86c:	1a00000b 	bne	1002c8a0 <proc_additive_expr+0xa0>
			{
			case finsh_token_type_sub:
				mul = make_sys_node(FINSH_NODE_SYS_SUB, mul, mul_new);
1002c870:	e3a00008 	mov	r0, #8
1002c874:	e51b100c 	ldr	r1, [fp, #-12]
1002c878:	e51b2010 	ldr	r2, [fp, #-16]
1002c87c:	eb0001fc 	bl	1002d074 <make_sys_node>
1002c880:	e50b000c 	str	r0, [fp, #-12]
				break;
1002c884:	ea000008 	b	1002c8ac <proc_additive_expr+0xac>
			case finsh_token_type_add:
				mul = make_sys_node(FINSH_NODE_SYS_ADD, mul, mul_new);
1002c888:	e3a00007 	mov	r0, #7
1002c88c:	e51b100c 	ldr	r1, [fp, #-12]
1002c890:	e51b2010 	ldr	r2, [fp, #-16]
1002c894:	eb0001f6 	bl	1002d074 <make_sys_node>
1002c898:	e50b000c 	str	r0, [fp, #-12]
				break;
1002c89c:	ea000002 	b	1002c8ac <proc_additive_expr+0xac>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c8a0:	e3a00005 	mov	r0, #5
1002c8a4:	ebfff2b2 	bl	10029374 <finsh_error_set>
				break;
1002c8a8:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
1002c8ac:	e51b3018 	ldr	r3, [fp, #-24]
1002c8b0:	e2833004 	add	r3, r3, #4
1002c8b4:	e1a00003 	mov	r0, r3
1002c8b8:	eb000484 	bl	1002dad0 <finsh_token_token>
1002c8bc:	e1a03000 	mov	r3, r0
1002c8c0:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
1002c8c4:	e55b3005 	ldrb	r3, [fp, #-5]
1002c8c8:	e3530008 	cmp	r3, #8
1002c8cc:	0affffd9 	beq	1002c838 <proc_additive_expr+0x38>
1002c8d0:	e55b3005 	ldrb	r3, [fp, #-5]
1002c8d4:	e3530006 	cmp	r3, #6
1002c8d8:	0affffd6 	beq	1002c838 <proc_additive_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1002c8dc:	e51b3018 	ldr	r3, [fp, #-24]
1002c8e0:	e3a02001 	mov	r2, #1
1002c8e4:	e5c32005 	strb	r2, [r3, #5]
	return mul;
1002c8e8:	e51b300c 	ldr	r3, [fp, #-12]
}
1002c8ec:	e1a00003 	mov	r0, r3
1002c8f0:	e24bd004 	sub	sp, fp, #4
1002c8f4:	e8bd8800 	pop	{fp, pc}

1002c8f8 <proc_multiplicative_expr>:
	| expr_multiplicative '*' expr_cast
	| expr_multiplicative '/' expr_cast
	| expr_multiplicative '%' expr_cast
*/
static struct finsh_node* proc_multiplicative_expr(struct finsh_parser* self)
{
1002c8f8:	e92d4800 	push	{fp, lr}
1002c8fc:	e28db004 	add	fp, sp, #4
1002c900:	e24dd018 	sub	sp, sp, #24
1002c904:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
1002c908:	e51b0018 	ldr	r0, [fp, #-24]
1002c90c:	eb000042 	bl	1002ca1c <proc_cast_expr>
1002c910:	e50b000c 	str	r0, [fp, #-12]
	next_token(token, &(self->token));
1002c914:	e51b3018 	ldr	r3, [fp, #-24]
1002c918:	e2833004 	add	r3, r3, #4
1002c91c:	e1a00003 	mov	r0, r3
1002c920:	eb00046a 	bl	1002dad0 <finsh_token_token>
1002c924:	e1a03000 	mov	r3, r0
1002c928:	e54b3005 	strb	r3, [fp, #-5]
	while (token == finsh_token_type_mul ||
1002c92c:	ea00002a 	b	1002c9dc <proc_multiplicative_expr+0xe4>
		token == finsh_token_type_div ||
		token == finsh_token_type_mod )
	{
		cast_new = proc_cast_expr(self);
1002c930:	e51b0018 	ldr	r0, [fp, #-24]
1002c934:	eb000038 	bl	1002ca1c <proc_cast_expr>
1002c938:	e50b0010 	str	r0, [fp, #-16]
		if (cast_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c93c:	e51b3010 	ldr	r3, [fp, #-16]
1002c940:	e3530000 	cmp	r3, #0
1002c944:	1a000002 	bne	1002c954 <proc_multiplicative_expr+0x5c>
1002c948:	e3a00005 	mov	r0, #5
1002c94c:	ebfff288 	bl	10029374 <finsh_error_set>
1002c950:	ea00001b 	b	1002c9c4 <proc_multiplicative_expr+0xcc>
		else
		{
			switch (token)
1002c954:	e55b3005 	ldrb	r3, [fp, #-5]
1002c958:	e353000a 	cmp	r3, #10
1002c95c:	0a000009 	beq	1002c988 <proc_multiplicative_expr+0x90>
1002c960:	e353000b 	cmp	r3, #11
1002c964:	0a00000d 	beq	1002c9a0 <proc_multiplicative_expr+0xa8>
1002c968:	e3530005 	cmp	r3, #5
1002c96c:	1a000011 	bne	1002c9b8 <proc_multiplicative_expr+0xc0>
			{
			case finsh_token_type_mul:
				cast = make_sys_node(FINSH_NODE_SYS_MUL, cast, cast_new);
1002c970:	e3a00009 	mov	r0, #9
1002c974:	e51b100c 	ldr	r1, [fp, #-12]
1002c978:	e51b2010 	ldr	r2, [fp, #-16]
1002c97c:	eb0001bc 	bl	1002d074 <make_sys_node>
1002c980:	e50b000c 	str	r0, [fp, #-12]
				break;
1002c984:	ea00000e 	b	1002c9c4 <proc_multiplicative_expr+0xcc>

			case finsh_token_type_div:
				cast = make_sys_node(FINSH_NODE_SYS_DIV, cast, cast_new);
1002c988:	e3a0000a 	mov	r0, #10
1002c98c:	e51b100c 	ldr	r1, [fp, #-12]
1002c990:	e51b2010 	ldr	r2, [fp, #-16]
1002c994:	eb0001b6 	bl	1002d074 <make_sys_node>
1002c998:	e50b000c 	str	r0, [fp, #-12]
				break;
1002c99c:	ea000008 	b	1002c9c4 <proc_multiplicative_expr+0xcc>

			case finsh_token_type_mod:
				cast = make_sys_node(FINSH_NODE_SYS_MOD, cast, cast_new);
1002c9a0:	e3a0000b 	mov	r0, #11
1002c9a4:	e51b100c 	ldr	r1, [fp, #-12]
1002c9a8:	e51b2010 	ldr	r2, [fp, #-16]
1002c9ac:	eb0001b0 	bl	1002d074 <make_sys_node>
1002c9b0:	e50b000c 	str	r0, [fp, #-12]
				break;
1002c9b4:	ea000002 	b	1002c9c4 <proc_multiplicative_expr+0xcc>

			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002c9b8:	e3a00005 	mov	r0, #5
1002c9bc:	ebfff26c 	bl	10029374 <finsh_error_set>
				break;
1002c9c0:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
1002c9c4:	e51b3018 	ldr	r3, [fp, #-24]
1002c9c8:	e2833004 	add	r3, r3, #4
1002c9cc:	e1a00003 	mov	r0, r3
1002c9d0:	eb00043e 	bl	1002dad0 <finsh_token_token>
1002c9d4:	e1a03000 	mov	r3, r0
1002c9d8:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
	next_token(token, &(self->token));
	while (token == finsh_token_type_mul ||
1002c9dc:	e55b3005 	ldrb	r3, [fp, #-5]
1002c9e0:	e3530005 	cmp	r3, #5
1002c9e4:	0affffd1 	beq	1002c930 <proc_multiplicative_expr+0x38>
1002c9e8:	e55b3005 	ldrb	r3, [fp, #-5]
1002c9ec:	e353000a 	cmp	r3, #10
1002c9f0:	0affffce 	beq	1002c930 <proc_multiplicative_expr+0x38>
		token == finsh_token_type_div ||
1002c9f4:	e55b3005 	ldrb	r3, [fp, #-5]
1002c9f8:	e353000b 	cmp	r3, #11
1002c9fc:	0affffcb 	beq	1002c930 <proc_multiplicative_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1002ca00:	e51b3018 	ldr	r3, [fp, #-24]
1002ca04:	e3a02001 	mov	r2, #1
1002ca08:	e5c32005 	strb	r2, [r3, #5]
	return cast;
1002ca0c:	e51b300c 	ldr	r3, [fp, #-12]
}
1002ca10:	e1a00003 	mov	r0, r3
1002ca14:	e24bd004 	sub	sp, fp, #4
1002ca18:	e8bd8800 	pop	{fp, pc}

1002ca1c <proc_cast_expr>:
20060313, add recast parse
expr_cast -> expr_unary
	| '(' type ')' expr_cast
*/
static struct finsh_node* proc_cast_expr(struct finsh_parser* self)
{
1002ca1c:	e92d4800 	push	{fp, lr}
1002ca20:	e28db004 	add	fp, sp, #4
1002ca24:	e24dd010 	sub	sp, sp, #16
1002ca28:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	enum finsh_type type;
	struct finsh_node* cast;

	next_token(token, &(self->token));
1002ca2c:	e51b3010 	ldr	r3, [fp, #-16]
1002ca30:	e2833004 	add	r3, r3, #4
1002ca34:	e1a00003 	mov	r0, r3
1002ca38:	eb000424 	bl	1002dad0 <finsh_token_token>
1002ca3c:	e1a03000 	mov	r3, r0
1002ca40:	e54b3005 	strb	r3, [fp, #-5]
	if (token == finsh_token_type_left_paren)
1002ca44:	e55b3005 	ldrb	r3, [fp, #-5]
1002ca48:	e3530001 	cmp	r3, #1
1002ca4c:	1a00001c 	bne	1002cac4 <proc_cast_expr+0xa8>
	{
		type = proc_type(self);
1002ca50:	e51b0010 	ldr	r0, [fp, #-16]
1002ca54:	ebfffd8e 	bl	1002c094 <proc_type>
1002ca58:	e1a03000 	mov	r3, r0
1002ca5c:	e54b3006 	strb	r3, [fp, #-6]
		match_token(token, &(self->token), finsh_token_type_right_paren);
1002ca60:	e51b3010 	ldr	r3, [fp, #-16]
1002ca64:	e2833004 	add	r3, r3, #4
1002ca68:	e1a00003 	mov	r0, r3
1002ca6c:	eb000417 	bl	1002dad0 <finsh_token_token>
1002ca70:	e1a03000 	mov	r3, r0
1002ca74:	e54b3005 	strb	r3, [fp, #-5]
1002ca78:	e55b3005 	ldrb	r3, [fp, #-5]
1002ca7c:	e3530002 	cmp	r3, #2
1002ca80:	0a000004 	beq	1002ca98 <proc_cast_expr+0x7c>
1002ca84:	e3a00001 	mov	r0, #1
1002ca88:	ebfff239 	bl	10029374 <finsh_error_set>
1002ca8c:	e51b3010 	ldr	r3, [fp, #-16]
1002ca90:	e3a02001 	mov	r2, #1
1002ca94:	e5c32005 	strb	r2, [r3, #5]

		cast = proc_cast_expr(self);
1002ca98:	e51b0010 	ldr	r0, [fp, #-16]
1002ca9c:	ebffffde 	bl	1002ca1c <proc_cast_expr>
1002caa0:	e50b000c 	str	r0, [fp, #-12]
		if (cast != NULL)
1002caa4:	e51b300c 	ldr	r3, [fp, #-12]
1002caa8:	e3530000 	cmp	r3, #0
1002caac:	0a000004 	beq	1002cac4 <proc_cast_expr+0xa8>
		{
			cast->data_type = type;
1002cab0:	e51b300c 	ldr	r3, [fp, #-12]
1002cab4:	e55b2006 	ldrb	r2, [fp, #-6]
1002cab8:	e5c32001 	strb	r2, [r3, #1]
			return cast;
1002cabc:	e51b300c 	ldr	r3, [fp, #-12]
1002cac0:	ea000005 	b	1002cadc <proc_cast_expr+0xc0>
		}
	}

	finsh_token_replay(&(self->token));
1002cac4:	e51b3010 	ldr	r3, [fp, #-16]
1002cac8:	e3a02001 	mov	r2, #1
1002cacc:	e5c32005 	strb	r2, [r3, #5]
	return proc_unary_expr(self);
1002cad0:	e51b0010 	ldr	r0, [fp, #-16]
1002cad4:	eb000003 	bl	1002cae8 <proc_unary_expr>
1002cad8:	e1a03000 	mov	r3, r0
}
1002cadc:	e1a00003 	mov	r0, r3
1002cae0:	e24bd004 	sub	sp, fp, #4
1002cae4:	e8bd8800 	pop	{fp, pc}

1002cae8 <proc_unary_expr>:
	| '~' expr_cast
	| '*' expr_cast
	| '&' expr_cast
*/
static struct finsh_node* proc_unary_expr(struct finsh_parser* self)
{
1002cae8:	e92d4800 	push	{fp, lr}
1002caec:	e28db004 	add	fp, sp, #4
1002caf0:	e24dd010 	sub	sp, sp, #16
1002caf4:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	struct finsh_node *cast;

	next_token(token, &(self->token));
1002caf8:	e51b3010 	ldr	r3, [fp, #-16]
1002cafc:	e2833004 	add	r3, r3, #4
1002cb00:	e1a00003 	mov	r0, r3
1002cb04:	eb0003f1 	bl	1002dad0 <finsh_token_token>
1002cb08:	e1a03000 	mov	r3, r0
1002cb0c:	e54b3005 	strb	r3, [fp, #-5]
	switch (token)
1002cb10:	e55b3005 	ldrb	r3, [fp, #-5]
1002cb14:	e2433005 	sub	r3, r3, #5
1002cb18:	e353000b 	cmp	r3, #11
1002cb1c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002cb20:	ea000049 	b	1002cc4c <proc_unary_expr+0x164>
1002cb24:	1002cc04 	.word	0x1002cc04
1002cb28:	1002cb54 	.word	0x1002cb54
1002cb2c:	1002cb68 	.word	0x1002cb68
1002cb30:	1002cb8c 	.word	0x1002cb8c
1002cb34:	1002cbbc 	.word	0x1002cbbc
1002cb38:	1002cc4c 	.word	0x1002cc4c
1002cb3c:	1002cc4c 	.word	0x1002cc4c
1002cb40:	1002cc4c 	.word	0x1002cc4c
1002cb44:	1002cc28 	.word	0x1002cc28
1002cb48:	1002cc4c 	.word	0x1002cc4c
1002cb4c:	1002cc4c 	.word	0x1002cc4c
1002cb50:	1002cbe0 	.word	0x1002cbe0
	{
	case finsh_token_type_add: /* + */
		cast = proc_cast_expr(self);
1002cb54:	e51b0010 	ldr	r0, [fp, #-16]
1002cb58:	ebffffaf 	bl	1002ca1c <proc_cast_expr>
1002cb5c:	e50b000c 	str	r0, [fp, #-12]
		return cast;
1002cb60:	e51b300c 	ldr	r3, [fp, #-12]
1002cb64:	ea00003e 	b	1002cc64 <proc_unary_expr+0x17c>

	case finsh_token_type_inc: /* ++ */
		cast = proc_cast_expr(self);
1002cb68:	e51b0010 	ldr	r0, [fp, #-16]
1002cb6c:	ebffffaa 	bl	1002ca1c <proc_cast_expr>
1002cb70:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_PREINC, cast, NULL);
1002cb74:	e3a00015 	mov	r0, #21
1002cb78:	e51b100c 	ldr	r1, [fp, #-12]
1002cb7c:	e3a02000 	mov	r2, #0
1002cb80:	eb00013b 	bl	1002d074 <make_sys_node>
1002cb84:	e1a03000 	mov	r3, r0
1002cb88:	ea000035 	b	1002cc64 <proc_unary_expr+0x17c>

	case finsh_token_type_sub: /* - */
		cast = proc_cast_expr(self);
1002cb8c:	e51b0010 	ldr	r0, [fp, #-16]
1002cb90:	ebffffa1 	bl	1002ca1c <proc_cast_expr>
1002cb94:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_SUB, finsh_node_new_long(0), cast);
1002cb98:	e3a00000 	mov	r0, #0
1002cb9c:	ebfff4af 	bl	10029e60 <finsh_node_new_long>
1002cba0:	e1a03000 	mov	r3, r0
1002cba4:	e3a00008 	mov	r0, #8
1002cba8:	e1a01003 	mov	r1, r3
1002cbac:	e51b200c 	ldr	r2, [fp, #-12]
1002cbb0:	eb00012f 	bl	1002d074 <make_sys_node>
1002cbb4:	e1a03000 	mov	r3, r0
1002cbb8:	ea000029 	b	1002cc64 <proc_unary_expr+0x17c>

	case finsh_token_type_dec: /* -- */
		cast = proc_cast_expr(self);
1002cbbc:	e51b0010 	ldr	r0, [fp, #-16]
1002cbc0:	ebffff95 	bl	1002ca1c <proc_cast_expr>
1002cbc4:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_PREDEC, cast, NULL);
1002cbc8:	e3a00016 	mov	r0, #22
1002cbcc:	e51b100c 	ldr	r1, [fp, #-12]
1002cbd0:	e3a02000 	mov	r2, #0
1002cbd4:	eb000126 	bl	1002d074 <make_sys_node>
1002cbd8:	e1a03000 	mov	r3, r0
1002cbdc:	ea000020 	b	1002cc64 <proc_unary_expr+0x17c>

	case finsh_token_type_bitwise: /* ~ */
		cast = proc_cast_expr(self);
1002cbe0:	e51b0010 	ldr	r0, [fp, #-16]
1002cbe4:	ebffff8c 	bl	1002ca1c <proc_cast_expr>
1002cbe8:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_BITWISE, cast, NULL);
1002cbec:	e3a0000f 	mov	r0, #15
1002cbf0:	e51b100c 	ldr	r1, [fp, #-12]
1002cbf4:	e3a02000 	mov	r2, #0
1002cbf8:	eb00011d 	bl	1002d074 <make_sys_node>
1002cbfc:	e1a03000 	mov	r3, r0
1002cc00:	ea000017 	b	1002cc64 <proc_unary_expr+0x17c>

    case finsh_token_type_mul: /* * */
        cast = proc_cast_expr(self);
1002cc04:	e51b0010 	ldr	r0, [fp, #-16]
1002cc08:	ebffff83 	bl	1002ca1c <proc_cast_expr>
1002cc0c:	e50b000c 	str	r0, [fp, #-12]
        return make_sys_node(FINSH_NODE_SYS_GETVALUE, cast, NULL);
1002cc10:	e3a00019 	mov	r0, #25
1002cc14:	e51b100c 	ldr	r1, [fp, #-12]
1002cc18:	e3a02000 	mov	r2, #0
1002cc1c:	eb000114 	bl	1002d074 <make_sys_node>
1002cc20:	e1a03000 	mov	r3, r0
1002cc24:	ea00000e 	b	1002cc64 <proc_unary_expr+0x17c>

    case finsh_token_type_and: /* & */
        cast = proc_cast_expr(self);
1002cc28:	e51b0010 	ldr	r0, [fp, #-16]
1002cc2c:	ebffff7a 	bl	1002ca1c <proc_cast_expr>
1002cc30:	e50b000c 	str	r0, [fp, #-12]
        return make_sys_node(FINSH_NODE_SYS_GETADDR, cast, NULL);
1002cc34:	e3a0001a 	mov	r0, #26
1002cc38:	e51b100c 	ldr	r1, [fp, #-12]
1002cc3c:	e3a02000 	mov	r2, #0
1002cc40:	eb00010b 	bl	1002d074 <make_sys_node>
1002cc44:	e1a03000 	mov	r3, r0
1002cc48:	ea000005 	b	1002cc64 <proc_unary_expr+0x17c>

	default:
		finsh_token_replay(&(self->token));
1002cc4c:	e51b3010 	ldr	r3, [fp, #-16]
1002cc50:	e3a02001 	mov	r2, #1
1002cc54:	e5c32005 	strb	r2, [r3, #5]
		return proc_postfix_expr(self);
1002cc58:	e51b0010 	ldr	r0, [fp, #-16]
1002cc5c:	eb000003 	bl	1002cc70 <proc_postfix_expr>
1002cc60:	e1a03000 	mov	r3, r0
	}
}
1002cc64:	e1a00003 	mov	r0, r3
1002cc68:	e24bd004 	sub	sp, fp, #4
1002cc6c:	e8bd8800 	pop	{fp, pc}

1002cc70 <proc_postfix_expr>:
	| expr_postfix INC
	| expr_postfix DEC
	| expr_postfix '(' param_list ')'
*/
static struct finsh_node* proc_postfix_expr(struct finsh_parser* self)
{
1002cc70:	e92d4800 	push	{fp, lr}
1002cc74:	e28db004 	add	fp, sp, #4
1002cc78:	e24dd018 	sub	sp, sp, #24
1002cc7c:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);
1002cc80:	e51b0018 	ldr	r0, [fp, #-24]
1002cc84:	eb000056 	bl	1002cde4 <proc_primary_expr>
1002cc88:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1002cc8c:	e51b3018 	ldr	r3, [fp, #-24]
1002cc90:	e2833004 	add	r3, r3, #4
1002cc94:	e1a00003 	mov	r0, r3
1002cc98:	eb00038c 	bl	1002dad0 <finsh_token_token>
1002cc9c:	e1a03000 	mov	r3, r0
1002cca0:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_inc 	||
1002cca4:	ea00003e 	b	1002cda4 <proc_postfix_expr+0x134>
		token == finsh_token_type_dec 		||
		token == finsh_token_type_left_paren )
	{
		switch (token)
1002cca8:	e55b3005 	ldrb	r3, [fp, #-5]
1002ccac:	e3530007 	cmp	r3, #7
1002ccb0:	0a000004 	beq	1002ccc8 <proc_postfix_expr+0x58>
1002ccb4:	e3530009 	cmp	r3, #9
1002ccb8:	0a000008 	beq	1002cce0 <proc_postfix_expr+0x70>
1002ccbc:	e3530001 	cmp	r3, #1
1002ccc0:	0a00000c 	beq	1002ccf8 <proc_postfix_expr+0x88>
				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
			}
			break;

		default:
			break;
1002ccc4:	ea000030 	b	1002cd8c <proc_postfix_expr+0x11c>
		token == finsh_token_type_left_paren )
	{
		switch (token)
		{
		case finsh_token_type_inc :/* '++' */
			postfix = make_sys_node(FINSH_NODE_SYS_INC, postfix, NULL);
1002ccc8:	e3a00017 	mov	r0, #23
1002cccc:	e51b100c 	ldr	r1, [fp, #-12]
1002ccd0:	e3a02000 	mov	r2, #0
1002ccd4:	eb0000e6 	bl	1002d074 <make_sys_node>
1002ccd8:	e50b000c 	str	r0, [fp, #-12]
			break;
1002ccdc:	ea00002a 	b	1002cd8c <proc_postfix_expr+0x11c>

		case finsh_token_type_dec :/* '--' */
			postfix = make_sys_node(FINSH_NODE_SYS_DEC, postfix, NULL);
1002cce0:	e3a00018 	mov	r0, #24
1002cce4:	e51b100c 	ldr	r1, [fp, #-12]
1002cce8:	e3a02000 	mov	r2, #0
1002ccec:	eb0000e0 	bl	1002d074 <make_sys_node>
1002ccf0:	e50b000c 	str	r0, [fp, #-12]
			break;
1002ccf4:	ea000024 	b	1002cd8c <proc_postfix_expr+0x11c>

		case finsh_token_type_left_paren :/* '(' */
			{
				struct finsh_node* param_list;

				param_list = NULL;
1002ccf8:	e3a03000 	mov	r3, #0
1002ccfc:	e50b3010 	str	r3, [fp, #-16]
				next_token(token, &(self->token));
1002cd00:	e51b3018 	ldr	r3, [fp, #-24]
1002cd04:	e2833004 	add	r3, r3, #4
1002cd08:	e1a00003 	mov	r0, r3
1002cd0c:	eb00036f 	bl	1002dad0 <finsh_token_token>
1002cd10:	e1a03000 	mov	r3, r0
1002cd14:	e54b3005 	strb	r3, [fp, #-5]
				if (token != finsh_token_type_right_paren)
1002cd18:	e55b3005 	ldrb	r3, [fp, #-5]
1002cd1c:	e3530002 	cmp	r3, #2
1002cd20:	0a000013 	beq	1002cd74 <proc_postfix_expr+0x104>
				{
					finsh_token_replay(&(self->token));
1002cd24:	e51b3018 	ldr	r3, [fp, #-24]
1002cd28:	e3a02001 	mov	r2, #1
1002cd2c:	e5c32005 	strb	r2, [r3, #5]
					param_list = proc_param_list(self);
1002cd30:	e51b0018 	ldr	r0, [fp, #-24]
1002cd34:	eb00009a 	bl	1002cfa4 <proc_param_list>
1002cd38:	e50b0010 	str	r0, [fp, #-16]

					match_token(token, &(self->token), finsh_token_type_right_paren);
1002cd3c:	e51b3018 	ldr	r3, [fp, #-24]
1002cd40:	e2833004 	add	r3, r3, #4
1002cd44:	e1a00003 	mov	r0, r3
1002cd48:	eb000360 	bl	1002dad0 <finsh_token_token>
1002cd4c:	e1a03000 	mov	r3, r0
1002cd50:	e54b3005 	strb	r3, [fp, #-5]
1002cd54:	e55b3005 	ldrb	r3, [fp, #-5]
1002cd58:	e3530002 	cmp	r3, #2
1002cd5c:	0a000004 	beq	1002cd74 <proc_postfix_expr+0x104>
1002cd60:	e3a00001 	mov	r0, #1
1002cd64:	ebfff182 	bl	10029374 <finsh_error_set>
1002cd68:	e51b3018 	ldr	r3, [fp, #-24]
1002cd6c:	e3a02001 	mov	r2, #1
1002cd70:	e5c32005 	strb	r2, [r3, #5]
				}

				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
1002cd74:	e3a00012 	mov	r0, #18
1002cd78:	e51b100c 	ldr	r1, [fp, #-12]
1002cd7c:	e51b2010 	ldr	r2, [fp, #-16]
1002cd80:	eb0000bb 	bl	1002d074 <make_sys_node>
1002cd84:	e50b000c 	str	r0, [fp, #-12]
			}
			break;
1002cd88:	e1a00000 	nop			; (mov r0, r0)

		default:
			break;
		}

		next_token(token, &(self->token));
1002cd8c:	e51b3018 	ldr	r3, [fp, #-24]
1002cd90:	e2833004 	add	r3, r3, #4
1002cd94:	e1a00003 	mov	r0, r3
1002cd98:	eb00034c 	bl	1002dad0 <finsh_token_token>
1002cd9c:	e1a03000 	mov	r3, r0
1002cda0:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_inc 	||
1002cda4:	e55b3005 	ldrb	r3, [fp, #-5]
1002cda8:	e3530007 	cmp	r3, #7
1002cdac:	0affffbd 	beq	1002cca8 <proc_postfix_expr+0x38>
1002cdb0:	e55b3005 	ldrb	r3, [fp, #-5]
1002cdb4:	e3530009 	cmp	r3, #9
1002cdb8:	0affffba 	beq	1002cca8 <proc_postfix_expr+0x38>
		token == finsh_token_type_dec 		||
1002cdbc:	e55b3005 	ldrb	r3, [fp, #-5]
1002cdc0:	e3530001 	cmp	r3, #1
1002cdc4:	0affffb7 	beq	1002cca8 <proc_postfix_expr+0x38>
		}

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1002cdc8:	e51b3018 	ldr	r3, [fp, #-24]
1002cdcc:	e3a02001 	mov	r2, #1
1002cdd0:	e5c32005 	strb	r2, [r3, #5]
	return postfix;
1002cdd4:	e51b300c 	ldr	r3, [fp, #-12]
}
1002cdd8:	e1a00003 	mov	r0, r3
1002cddc:	e24bd004 	sub	sp, fp, #4
1002cde0:	e8bd8800 	pop	{fp, pc}

1002cde4 <proc_primary_expr>:
expr_primary -> literal
	| '(' expr ')'
	| identifier
*/
static struct finsh_node* proc_primary_expr(struct finsh_parser* self)
{
1002cde4:	e92d4800 	push	{fp, lr}
1002cde8:	e28db004 	add	fp, sp, #4
1002cdec:	e24dd028 	sub	sp, sp, #40	; 0x28
1002cdf0:	e50b0028 	str	r0, [fp, #-40]	; 0x28
	enum finsh_token_type token;
	struct finsh_node* expr;

	next_token(token, &(self->token));
1002cdf4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002cdf8:	e2833004 	add	r3, r3, #4
1002cdfc:	e1a00003 	mov	r0, r3
1002ce00:	eb000332 	bl	1002dad0 <finsh_token_token>
1002ce04:	e1a03000 	mov	r3, r0
1002ce08:	e54b3005 	strb	r3, [fp, #-5]
	switch ( token )
1002ce0c:	e55b3005 	ldrb	r3, [fp, #-5]
1002ce10:	e2433001 	sub	r3, r3, #1
1002ce14:	e353001e 	cmp	r3, #30
1002ce18:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002ce1c:	ea000059 	b	1002cf88 <proc_primary_expr+0x1a4>
1002ce20:	1002cecc 	.word	0x1002cecc
1002ce24:	1002cf88 	.word	0x1002cf88
1002ce28:	1002cf88 	.word	0x1002cf88
1002ce2c:	1002cf88 	.word	0x1002cf88
1002ce30:	1002cf88 	.word	0x1002cf88
1002ce34:	1002cf88 	.word	0x1002cf88
1002ce38:	1002cf88 	.word	0x1002cf88
1002ce3c:	1002cf88 	.word	0x1002cf88
1002ce40:	1002cf88 	.word	0x1002cf88
1002ce44:	1002cf88 	.word	0x1002cf88
1002ce48:	1002cf88 	.word	0x1002cf88
1002ce4c:	1002cf88 	.word	0x1002cf88
1002ce50:	1002cf88 	.word	0x1002cf88
1002ce54:	1002cf88 	.word	0x1002cf88
1002ce58:	1002cf88 	.word	0x1002cf88
1002ce5c:	1002cf88 	.word	0x1002cf88
1002ce60:	1002cf88 	.word	0x1002cf88
1002ce64:	1002cf88 	.word	0x1002cf88
1002ce68:	1002cf88 	.word	0x1002cf88
1002ce6c:	1002cf88 	.word	0x1002cf88
1002ce70:	1002cf88 	.word	0x1002cf88
1002ce74:	1002cf88 	.word	0x1002cf88
1002ce78:	1002cf88 	.word	0x1002cf88
1002ce7c:	1002cf88 	.word	0x1002cf88
1002ce80:	1002cf88 	.word	0x1002cf88
1002ce84:	1002cf48 	.word	0x1002cf48
1002ce88:	1002cf18 	.word	0x1002cf18
1002ce8c:	1002cf30 	.word	0x1002cf30
1002ce90:	1002cf60 	.word	0x1002cf60
1002ce94:	1002cf78 	.word	0x1002cf78
1002ce98:	1002ce9c 	.word	0x1002ce9c
	{
	case finsh_token_type_identifier:
		{
			char id[FINSH_NAME_MAX + 1];

			finsh_token_replay(&(self->token));
1002ce9c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002cea0:	e3a02001 	mov	r2, #1
1002cea4:	e5c32005 	strb	r2, [r3, #5]
			proc_identifier(self, id);
1002cea8:	e24b3020 	sub	r3, fp, #32
1002ceac:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
1002ceb0:	e1a01003 	mov	r1, r3
1002ceb4:	ebfffd20 	bl	1002c33c <proc_identifier>
			return finsh_node_new_id(id);
1002ceb8:	e24b3020 	sub	r3, fp, #32
1002cebc:	e1a00003 	mov	r0, r3
1002cec0:	ebfff36d 	bl	10029c7c <finsh_node_new_id>
1002cec4:	e1a03000 	mov	r3, r0
1002cec8:	ea000032 	b	1002cf98 <proc_primary_expr+0x1b4>
		}

	case finsh_token_type_left_paren:
		expr = proc_expr(self);
1002cecc:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
1002ced0:	ebfffd5d 	bl	1002c44c <proc_expr>
1002ced4:	e50b000c 	str	r0, [fp, #-12]
		match_token(token, &(self->token), finsh_token_type_right_paren);
1002ced8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002cedc:	e2833004 	add	r3, r3, #4
1002cee0:	e1a00003 	mov	r0, r3
1002cee4:	eb0002f9 	bl	1002dad0 <finsh_token_token>
1002cee8:	e1a03000 	mov	r3, r0
1002ceec:	e54b3005 	strb	r3, [fp, #-5]
1002cef0:	e55b3005 	ldrb	r3, [fp, #-5]
1002cef4:	e3530002 	cmp	r3, #2
1002cef8:	0a000004 	beq	1002cf10 <proc_primary_expr+0x12c>
1002cefc:	e3a00001 	mov	r0, #1
1002cf00:	ebfff11b 	bl	10029374 <finsh_error_set>
1002cf04:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002cf08:	e3a02001 	mov	r2, #1
1002cf0c:	e5c32005 	strb	r2, [r3, #5]
		return expr;
1002cf10:	e51b300c 	ldr	r3, [fp, #-12]
1002cf14:	ea00001f 	b	1002cf98 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_int:
		return finsh_node_new_int(self->token.value.int_value);
1002cf18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002cf1c:	e5933010 	ldr	r3, [r3, #16]
1002cf20:	e1a00003 	mov	r0, r3
1002cf24:	ebfff3b8 	bl	10029e0c <finsh_node_new_int>
1002cf28:	e1a03000 	mov	r3, r0
1002cf2c:	ea000019 	b	1002cf98 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_long:
		return finsh_node_new_long(self->token.value.long_value);
1002cf30:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002cf34:	e5933010 	ldr	r3, [r3, #16]
1002cf38:	e1a00003 	mov	r0, r3
1002cf3c:	ebfff3c7 	bl	10029e60 <finsh_node_new_long>
1002cf40:	e1a03000 	mov	r3, r0
1002cf44:	ea000013 	b	1002cf98 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_char:
		return finsh_node_new_char(self->token.value.char_value);
1002cf48:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002cf4c:	e5d33010 	ldrb	r3, [r3, #16]
1002cf50:	e1a00003 	mov	r0, r3
1002cf54:	ebfff396 	bl	10029db4 <finsh_node_new_char>
1002cf58:	e1a03000 	mov	r3, r0
1002cf5c:	ea00000d 	b	1002cf98 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_string:
		return finsh_node_new_string((char*)self->token.string);
1002cf60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002cf64:	e2833014 	add	r3, r3, #20
1002cf68:	e1a00003 	mov	r0, r3
1002cf6c:	ebfff3d0 	bl	10029eb4 <finsh_node_new_string>
1002cf70:	e1a03000 	mov	r3, r0
1002cf74:	ea000007 	b	1002cf98 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_null:
		return finsh_node_new_ptr(NULL);
1002cf78:	e3a00000 	mov	r0, #0
1002cf7c:	ebfff3f8 	bl	10029f64 <finsh_node_new_ptr>
1002cf80:	e1a03000 	mov	r3, r0
1002cf84:	ea000003 	b	1002cf98 <proc_primary_expr+0x1b4>

	default:
		finsh_error_set(FINSH_ERROR_INVALID_TOKEN);
1002cf88:	e3a00001 	mov	r0, #1
1002cf8c:	ebfff0f8 	bl	10029374 <finsh_error_set>
		break;
1002cf90:	e1a00000 	nop			; (mov r0, r0)
	}

	return NULL;
1002cf94:	e3a03000 	mov	r3, #0
}
1002cf98:	e1a00003 	mov	r0, r3
1002cf9c:	e24bd004 	sub	sp, fp, #4
1002cfa0:	e8bd8800 	pop	{fp, pc}

1002cfa4 <proc_param_list>:
param_list -> empty
	| expr_assign
	| param_list ',' expr_assign
*/
static struct finsh_node* proc_param_list(struct finsh_parser* self)
{
1002cfa4:	e92d4800 	push	{fp, lr}
1002cfa8:	e28db004 	add	fp, sp, #4
1002cfac:	e24dd018 	sub	sp, sp, #24
1002cfb0:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node *node, *assign;

	assign = proc_assign_expr(self);
1002cfb4:	e51b0018 	ldr	r0, [fp, #-24]
1002cfb8:	ebfffd2d 	bl	1002c474 <proc_assign_expr>
1002cfbc:	e50b000c 	str	r0, [fp, #-12]
	if (assign == NULL) return NULL;
1002cfc0:	e51b300c 	ldr	r3, [fp, #-12]
1002cfc4:	e3530000 	cmp	r3, #0
1002cfc8:	1a000001 	bne	1002cfd4 <proc_param_list+0x30>
1002cfcc:	e3a03000 	mov	r3, #0
1002cfd0:	ea000024 	b	1002d068 <proc_param_list+0xc4>
	node = assign;
1002cfd4:	e51b300c 	ldr	r3, [fp, #-12]
1002cfd8:	e50b3010 	str	r3, [fp, #-16]

	next_token(token, &(self->token));
1002cfdc:	e51b3018 	ldr	r3, [fp, #-24]
1002cfe0:	e2833004 	add	r3, r3, #4
1002cfe4:	e1a00003 	mov	r0, r3
1002cfe8:	eb0002b8 	bl	1002dad0 <finsh_token_token>
1002cfec:	e1a03000 	mov	r3, r0
1002cff0:	e54b3005 	strb	r3, [fp, #-5]
	while (token == finsh_token_type_comma )
1002cff4:	ea000014 	b	1002d04c <proc_param_list+0xa8>
	{
		finsh_node_sibling(assign) = proc_assign_expr(self);
1002cff8:	e51b0018 	ldr	r0, [fp, #-24]
1002cffc:	ebfffd1c 	bl	1002c474 <proc_assign_expr>
1002d000:	e1a02000 	mov	r2, r0
1002d004:	e51b300c 	ldr	r3, [fp, #-12]
1002d008:	e583200c 	str	r2, [r3, #12]

		if (finsh_node_sibling(assign) != NULL)	assign = finsh_node_sibling(assign);
1002d00c:	e51b300c 	ldr	r3, [fp, #-12]
1002d010:	e593300c 	ldr	r3, [r3, #12]
1002d014:	e3530000 	cmp	r3, #0
1002d018:	0a000003 	beq	1002d02c <proc_param_list+0x88>
1002d01c:	e51b300c 	ldr	r3, [fp, #-12]
1002d020:	e593300c 	ldr	r3, [r3, #12]
1002d024:	e50b300c 	str	r3, [fp, #-12]
1002d028:	ea000001 	b	1002d034 <proc_param_list+0x90>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1002d02c:	e3a00005 	mov	r0, #5
1002d030:	ebfff0cf 	bl	10029374 <finsh_error_set>

		next_token(token, &(self->token));
1002d034:	e51b3018 	ldr	r3, [fp, #-24]
1002d038:	e2833004 	add	r3, r3, #4
1002d03c:	e1a00003 	mov	r0, r3
1002d040:	eb0002a2 	bl	1002dad0 <finsh_token_token>
1002d044:	e1a03000 	mov	r3, r0
1002d048:	e54b3005 	strb	r3, [fp, #-5]
	assign = proc_assign_expr(self);
	if (assign == NULL) return NULL;
	node = assign;

	next_token(token, &(self->token));
	while (token == finsh_token_type_comma )
1002d04c:	e55b3005 	ldrb	r3, [fp, #-5]
1002d050:	e3530003 	cmp	r3, #3
1002d054:	0affffe7 	beq	1002cff8 <proc_param_list+0x54>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1002d058:	e51b3018 	ldr	r3, [fp, #-24]
1002d05c:	e3a02001 	mov	r2, #1
1002d060:	e5c32005 	strb	r2, [r3, #5]

	return node;
1002d064:	e51b3010 	ldr	r3, [fp, #-16]
}
1002d068:	e1a00003 	mov	r0, r3
1002d06c:	e24bd004 	sub	sp, fp, #4
1002d070:	e8bd8800 	pop	{fp, pc}

1002d074 <make_sys_node>:
node1__
       \
       node2
*/
static struct finsh_node* make_sys_node(u_char type, struct finsh_node* node1, struct finsh_node* node2)
{
1002d074:	e92d4800 	push	{fp, lr}
1002d078:	e28db004 	add	fp, sp, #4
1002d07c:	e24dd018 	sub	sp, sp, #24
1002d080:	e1a03000 	mov	r3, r0
1002d084:	e50b1014 	str	r1, [fp, #-20]
1002d088:	e50b2018 	str	r2, [fp, #-24]
1002d08c:	e54b300d 	strb	r3, [fp, #-13]
	struct finsh_node* node;

	node = finsh_node_allocate(type);
1002d090:	e55b300d 	ldrb	r3, [fp, #-13]
1002d094:	e1a00003 	mov	r0, r3
1002d098:	ebfff2c5 	bl	10029bb4 <finsh_node_allocate>
1002d09c:	e50b0008 	str	r0, [fp, #-8]

	if ((node1 != NULL) && (node != NULL))
1002d0a0:	e51b3014 	ldr	r3, [fp, #-20]
1002d0a4:	e3530000 	cmp	r3, #0
1002d0a8:	0a000009 	beq	1002d0d4 <make_sys_node+0x60>
1002d0ac:	e51b3008 	ldr	r3, [fp, #-8]
1002d0b0:	e3530000 	cmp	r3, #0
1002d0b4:	0a000006 	beq	1002d0d4 <make_sys_node+0x60>
	{
		finsh_node_child(node) = node1;
1002d0b8:	e51b3008 	ldr	r3, [fp, #-8]
1002d0bc:	e51b2014 	ldr	r2, [fp, #-20]
1002d0c0:	e5832010 	str	r2, [r3, #16]
		finsh_node_sibling(node1) = node2;
1002d0c4:	e51b3014 	ldr	r3, [fp, #-20]
1002d0c8:	e51b2018 	ldr	r2, [fp, #-24]
1002d0cc:	e583200c 	str	r2, [r3, #12]
1002d0d0:	ea000001 	b	1002d0dc <make_sys_node+0x68>
	}
	else finsh_error_set(FINSH_ERROR_NULL_NODE);
1002d0d4:	e3a0000e 	mov	r0, #14
1002d0d8:	ebfff0a5 	bl	10029374 <finsh_error_set>

	return node;
1002d0dc:	e51b3008 	ldr	r3, [fp, #-8]
}
1002d0e0:	e1a00003 	mov	r0, r3
1002d0e4:	e24bd004 	sub	sp, fp, #4
1002d0e8:	e8bd8800 	pop	{fp, pc}

1002d0ec <finsh_parser_run>:

/*
start -> statement_expr | decl_variable
*/
void finsh_parser_run(struct finsh_parser* self, const u_char* string)
{
1002d0ec:	e92d4800 	push	{fp, lr}
1002d0f0:	e28db004 	add	fp, sp, #4
1002d0f4:	e24dd010 	sub	sp, sp, #16
1002d0f8:	e50b0010 	str	r0, [fp, #-16]
1002d0fc:	e50b1014 	str	r1, [fp, #-20]
	enum finsh_token_type token;
	struct finsh_node *node;

    node = NULL;
1002d100:	e3a03000 	mov	r3, #0
1002d104:	e50b300c 	str	r3, [fp, #-12]

	/* init parser */
	self->parser_string = (u_char*)string;
1002d108:	e51b3010 	ldr	r3, [fp, #-16]
1002d10c:	e51b2014 	ldr	r2, [fp, #-20]
1002d110:	e5832000 	str	r2, [r3]

	/* init token */
	finsh_token_init(&(self->token), self->parser_string);
1002d114:	e51b3010 	ldr	r3, [fp, #-16]
1002d118:	e2832004 	add	r2, r3, #4
1002d11c:	e51b3010 	ldr	r3, [fp, #-16]
1002d120:	e5933000 	ldr	r3, [r3]
1002d124:	e1a00002 	mov	r0, r2
1002d128:	e1a01003 	mov	r1, r3
1002d12c:	eb000259 	bl	1002da98 <finsh_token_init>

	/* get next token */
	next_token(token, &(self->token));
1002d130:	e51b3010 	ldr	r3, [fp, #-16]
1002d134:	e2833004 	add	r3, r3, #4
1002d138:	e1a00003 	mov	r0, r3
1002d13c:	eb000263 	bl	1002dad0 <finsh_token_token>
1002d140:	e1a03000 	mov	r3, r0
1002d144:	e54b3005 	strb	r3, [fp, #-5]
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
1002d148:	ea00007a 	b	1002d338 <finsh_parser_run+0x24c>
	{
		switch (token)
1002d14c:	e55b3005 	ldrb	r3, [fp, #-5]
1002d150:	e353001f 	cmp	r3, #31
1002d154:	1a00001b 	bne	1002d1c8 <finsh_parser_run+0xdc>
		{
        case finsh_token_type_identifier:
            /* process expr_statement */
            finsh_token_replay(&(self->token));
1002d158:	e51b3010 	ldr	r3, [fp, #-16]
1002d15c:	e3a02001 	mov	r2, #1
1002d160:	e5c32005 	strb	r2, [r3, #5]

			if (self->root != NULL)
1002d164:	e51b3010 	ldr	r3, [fp, #-16]
1002d168:	e5933098 	ldr	r3, [r3, #152]	; 0x98
1002d16c:	e3530000 	cmp	r3, #0
1002d170:	0a00000c 	beq	1002d1a8 <finsh_parser_run+0xbc>
			{
				finsh_node_sibling(node) = proc_expr_statement(self);
1002d174:	e51b0010 	ldr	r0, [fp, #-16]
1002d178:	ebfffc8c 	bl	1002c3b0 <proc_expr_statement>
1002d17c:	e1a02000 	mov	r2, r0
1002d180:	e51b300c 	ldr	r3, [fp, #-12]
1002d184:	e583200c 	str	r2, [r3, #12]
				if (finsh_node_sibling(node) != NULL)
1002d188:	e51b300c 	ldr	r3, [fp, #-12]
1002d18c:	e593300c 	ldr	r3, [r3, #12]
1002d190:	e3530000 	cmp	r3, #0
1002d194:	0a00000a 	beq	1002d1c4 <finsh_parser_run+0xd8>
					node = finsh_node_sibling(node);
1002d198:	e51b300c 	ldr	r3, [fp, #-12]
1002d19c:	e593300c 	ldr	r3, [r3, #12]
1002d1a0:	e50b300c 	str	r3, [fp, #-12]
			else
			{
            	node = proc_expr_statement(self);
				self->root = node;
			}
            break;
1002d1a4:	ea000058 	b	1002d30c <finsh_parser_run+0x220>
				if (finsh_node_sibling(node) != NULL)
					node = finsh_node_sibling(node);
			}
			else
			{
            	node = proc_expr_statement(self);
1002d1a8:	e51b0010 	ldr	r0, [fp, #-16]
1002d1ac:	ebfffc7f 	bl	1002c3b0 <proc_expr_statement>
1002d1b0:	e50b000c 	str	r0, [fp, #-12]
				self->root = node;
1002d1b4:	e51b3010 	ldr	r3, [fp, #-16]
1002d1b8:	e51b200c 	ldr	r2, [fp, #-12]
1002d1bc:	e5832098 	str	r2, [r3, #152]	; 0x98
			}
            break;
1002d1c0:	ea000051 	b	1002d30c <finsh_parser_run+0x220>
1002d1c4:	ea000050 	b	1002d30c <finsh_parser_run+0x220>

		default:
            if (is_base_type(token) || token == finsh_token_type_unsigned)
1002d1c8:	e55b3005 	ldrb	r3, [fp, #-5]
1002d1cc:	e3530014 	cmp	r3, #20
1002d1d0:	0a00000e 	beq	1002d210 <finsh_parser_run+0x124>
1002d1d4:	e55b3005 	ldrb	r3, [fp, #-5]
1002d1d8:	e3530015 	cmp	r3, #21
1002d1dc:	0a00000b 	beq	1002d210 <finsh_parser_run+0x124>
1002d1e0:	e55b3005 	ldrb	r3, [fp, #-5]
1002d1e4:	e3530016 	cmp	r3, #22
1002d1e8:	0a000008 	beq	1002d210 <finsh_parser_run+0x124>
1002d1ec:	e55b3005 	ldrb	r3, [fp, #-5]
1002d1f0:	e3530017 	cmp	r3, #23
1002d1f4:	0a000005 	beq	1002d210 <finsh_parser_run+0x124>
1002d1f8:	e55b3005 	ldrb	r3, [fp, #-5]
1002d1fc:	e3530018 	cmp	r3, #24
1002d200:	0a000002 	beq	1002d210 <finsh_parser_run+0x124>
1002d204:	e55b3005 	ldrb	r3, [fp, #-5]
1002d208:	e3530019 	cmp	r3, #25
1002d20c:	1a00001b 	bne	1002d280 <finsh_parser_run+0x194>
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));
1002d210:	e51b3010 	ldr	r3, [fp, #-16]
1002d214:	e3a02001 	mov	r2, #1
1002d218:	e5c32005 	strb	r2, [r3, #5]

				if (self->root != NULL)
1002d21c:	e51b3010 	ldr	r3, [fp, #-16]
1002d220:	e5933098 	ldr	r3, [r3, #152]	; 0x98
1002d224:	e3530000 	cmp	r3, #0
1002d228:	0a00000c 	beq	1002d260 <finsh_parser_run+0x174>
				{
					finsh_node_sibling(node) = proc_variable_decl(self);
1002d22c:	e51b0010 	ldr	r0, [fp, #-16]
1002d230:	ebfffa83 	bl	1002bc44 <proc_variable_decl>
1002d234:	e1a02000 	mov	r2, r0
1002d238:	e51b300c 	ldr	r3, [fp, #-12]
1002d23c:	e583200c 	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
1002d240:	e51b300c 	ldr	r3, [fp, #-12]
1002d244:	e593300c 	ldr	r3, [r3, #12]
1002d248:	e3530000 	cmp	r3, #0
1002d24c:	0a00000a 	beq	1002d27c <finsh_parser_run+0x190>
						node = finsh_node_sibling(node);
1002d250:	e51b300c 	ldr	r3, [fp, #-12]
1002d254:	e593300c 	ldr	r3, [r3, #12]
1002d258:	e50b300c 	str	r3, [fp, #-12]
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
1002d25c:	ea000029 	b	1002d308 <finsh_parser_run+0x21c>
					if (finsh_node_sibling(node) != NULL)
						node = finsh_node_sibling(node);
				}
				else
				{
					node = proc_variable_decl(self);
1002d260:	e51b0010 	ldr	r0, [fp, #-16]
1002d264:	ebfffa76 	bl	1002bc44 <proc_variable_decl>
1002d268:	e50b000c 	str	r0, [fp, #-12]
					self->root = node;
1002d26c:	e51b3010 	ldr	r3, [fp, #-16]
1002d270:	e51b200c 	ldr	r2, [fp, #-12]
1002d274:	e5832098 	str	r2, [r3, #152]	; 0x98
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
1002d278:	ea000022 	b	1002d308 <finsh_parser_run+0x21c>
1002d27c:	ea000021 	b	1002d308 <finsh_parser_run+0x21c>
				}
            }
            else
            {
            	/* process expr_statement */
                finsh_token_replay(&(self->token));
1002d280:	e51b3010 	ldr	r3, [fp, #-16]
1002d284:	e3a02001 	mov	r2, #1
1002d288:	e5c32005 	strb	r2, [r3, #5]

				if (self->root != NULL)
1002d28c:	e51b3010 	ldr	r3, [fp, #-16]
1002d290:	e5933098 	ldr	r3, [r3, #152]	; 0x98
1002d294:	e3530000 	cmp	r3, #0
1002d298:	0a000013 	beq	1002d2ec <finsh_parser_run+0x200>
				{
                    finsh_node_sibling(node) = proc_expr_statement(self);
1002d29c:	e51b0010 	ldr	r0, [fp, #-16]
1002d2a0:	ebfffc42 	bl	1002c3b0 <proc_expr_statement>
1002d2a4:	e1a02000 	mov	r2, r0
1002d2a8:	e51b300c 	ldr	r3, [fp, #-12]
1002d2ac:	e583200c 	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
1002d2b0:	e51b300c 	ldr	r3, [fp, #-12]
1002d2b4:	e593300c 	ldr	r3, [r3, #12]
1002d2b8:	e3530000 	cmp	r3, #0
1002d2bc:	0a000003 	beq	1002d2d0 <finsh_parser_run+0x1e4>
						node = finsh_node_sibling(node);
1002d2c0:	e51b300c 	ldr	r3, [fp, #-12]
1002d2c4:	e593300c 	ldr	r3, [r3, #12]
1002d2c8:	e50b300c 	str	r3, [fp, #-12]
1002d2cc:	ea00000d 	b	1002d308 <finsh_parser_run+0x21c>
					else next_token(token, &(self->token));
1002d2d0:	e51b3010 	ldr	r3, [fp, #-16]
1002d2d4:	e2833004 	add	r3, r3, #4
1002d2d8:	e1a00003 	mov	r0, r3
1002d2dc:	eb0001fb 	bl	1002dad0 <finsh_token_token>
1002d2e0:	e1a03000 	mov	r3, r0
1002d2e4:	e54b3005 	strb	r3, [fp, #-5]
					node = proc_expr_statement(self);
					self->root = node;
				}
            }

			break;
1002d2e8:	ea000006 	b	1002d308 <finsh_parser_run+0x21c>
						node = finsh_node_sibling(node);
					else next_token(token, &(self->token));
				}
				else
				{
					node = proc_expr_statement(self);
1002d2ec:	e51b0010 	ldr	r0, [fp, #-16]
1002d2f0:	ebfffc2e 	bl	1002c3b0 <proc_expr_statement>
1002d2f4:	e50b000c 	str	r0, [fp, #-12]
					self->root = node;
1002d2f8:	e51b3010 	ldr	r3, [fp, #-16]
1002d2fc:	e51b200c 	ldr	r2, [fp, #-12]
1002d300:	e5832098 	str	r2, [r3, #152]	; 0x98
				}
            }

			break;
1002d304:	eaffffff 	b	1002d308 <finsh_parser_run+0x21c>
1002d308:	e1a00000 	nop			; (mov r0, r0)
		}

		/* no root found, break out */
		if (self->root == NULL) break;
1002d30c:	e51b3010 	ldr	r3, [fp, #-16]
1002d310:	e5933098 	ldr	r3, [r3, #152]	; 0x98
1002d314:	e3530000 	cmp	r3, #0
1002d318:	1a000000 	bne	1002d320 <finsh_parser_run+0x234>
1002d31c:	ea00000b 	b	1002d350 <finsh_parser_run+0x264>

        /* get next token */
		next_token(token, &(self->token));
1002d320:	e51b3010 	ldr	r3, [fp, #-16]
1002d324:	e2833004 	add	r3, r3, #4
1002d328:	e1a00003 	mov	r0, r3
1002d32c:	eb0001e7 	bl	1002dad0 <finsh_token_token>
1002d330:	e1a03000 	mov	r3, r0
1002d334:	e54b3005 	strb	r3, [fp, #-5]
	/* init token */
	finsh_token_init(&(self->token), self->parser_string);

	/* get next token */
	next_token(token, &(self->token));
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
1002d338:	e55b3005 	ldrb	r3, [fp, #-5]
1002d33c:	e3530021 	cmp	r3, #33	; 0x21
1002d340:	0a000002 	beq	1002d350 <finsh_parser_run+0x264>
1002d344:	e55b3005 	ldrb	r3, [fp, #-5]
1002d348:	e3530020 	cmp	r3, #32
1002d34c:	1affff7e 	bne	1002d14c <finsh_parser_run+0x60>
		if (self->root == NULL) break;

        /* get next token */
		next_token(token, &(self->token));
	}
}
1002d350:	e24bd004 	sub	sp, fp, #4
1002d354:	e8bd8800 	pop	{fp, pc}

1002d358 <finsh_parser_init>:

int finsh_parser_init(struct finsh_parser* self)
{
1002d358:	e92d4800 	push	{fp, lr}
1002d35c:	e28db004 	add	fp, sp, #4
1002d360:	e24dd008 	sub	sp, sp, #8
1002d364:	e50b0008 	str	r0, [fp, #-8]
	memset(self, 0, sizeof(struct finsh_parser));
1002d368:	e51b0008 	ldr	r0, [fp, #-8]
1002d36c:	e3a01000 	mov	r1, #0
1002d370:	e3a0209c 	mov	r2, #156	; 0x9c
1002d374:	fa000808 	blx	1002f39c <memset>

	return 0;
1002d378:	e3a03000 	mov	r3, #0
}
1002d37c:	e1a00003 	mov	r0, r3
1002d380:	e24bd004 	sub	sp, fp, #4
1002d384:	e8bd8800 	pop	{fp, pc}

1002d388 <finsh_var_init>:

struct finsh_var global_variable[FINSH_VARIABLE_MAX];
struct finsh_sysvar_item* global_sysvar_list;

int finsh_var_init()
{
1002d388:	e92d4800 	push	{fp, lr}
1002d38c:	e28db004 	add	fp, sp, #4
	memset(global_variable, 0, sizeof(global_variable));
1002d390:	e3030764 	movw	r0, #14180	; 0x3764
1002d394:	e3410004 	movt	r0, #4100	; 0x1004
1002d398:	e3a01000 	mov	r1, #0
1002d39c:	e3a020c0 	mov	r2, #192	; 0xc0
1002d3a0:	fa0007fd 	blx	1002f39c <memset>

	return 0;
1002d3a4:	e3a03000 	mov	r3, #0
}
1002d3a8:	e1a00003 	mov	r0, r3
1002d3ac:	e8bd8800 	pop	{fp, pc}

1002d3b0 <finsh_var_insert>:

int finsh_var_insert(const char* name, int type)
{
1002d3b0:	e92d4800 	push	{fp, lr}
1002d3b4:	e28db004 	add	fp, sp, #4
1002d3b8:	e24dd010 	sub	sp, sp, #16
1002d3bc:	e50b0010 	str	r0, [fp, #-16]
1002d3c0:	e50b1014 	str	r1, [fp, #-20]
	int i, empty;

	empty = -1;
1002d3c4:	e3e03000 	mvn	r3, #0
1002d3c8:	e50b300c 	str	r3, [fp, #-12]
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1002d3cc:	e3a03000 	mov	r3, #0
1002d3d0:	e50b3008 	str	r3, [fp, #-8]
1002d3d4:	ea000026 	b	1002d474 <finsh_var_insert+0xc4>
	{
		/* there is a same name variable exist. */
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
1002d3d8:	e51b3008 	ldr	r3, [fp, #-8]
1002d3dc:	e1a02003 	mov	r2, r3
1002d3e0:	e1a03182 	lsl	r3, r2, #3
1002d3e4:	e1a02003 	mov	r2, r3
1002d3e8:	e1a03102 	lsl	r3, r2, #2
1002d3ec:	e0623003 	rsb	r3, r2, r3
1002d3f0:	e3032764 	movw	r2, #14180	; 0x3764
1002d3f4:	e3412004 	movt	r2, #4100	; 0x1004
1002d3f8:	e0833002 	add	r3, r3, r2
1002d3fc:	e1a00003 	mov	r0, r3
1002d400:	e51b1010 	ldr	r1, [fp, #-16]
1002d404:	e3a02010 	mov	r2, #16
1002d408:	fa0008fd 	blx	1002f804 <strncmp>
1002d40c:	e1a03000 	mov	r3, r0
1002d410:	e3530000 	cmp	r3, #0
1002d414:	1a000001 	bne	1002d420 <finsh_var_insert+0x70>
			return -1;
1002d418:	e3e03000 	mvn	r3, #0
1002d41c:	ea000038 	b	1002d504 <finsh_var_insert+0x154>

		if (global_variable[i].type == finsh_type_unknown && empty == -1)
1002d420:	e3032764 	movw	r2, #14180	; 0x3764
1002d424:	e3412004 	movt	r2, #4100	; 0x1004
1002d428:	e51b3008 	ldr	r3, [fp, #-8]
1002d42c:	e1a01003 	mov	r1, r3
1002d430:	e1a03181 	lsl	r3, r1, #3
1002d434:	e1a01003 	mov	r1, r3
1002d438:	e1a03101 	lsl	r3, r1, #2
1002d43c:	e0613003 	rsb	r3, r1, r3
1002d440:	e0823003 	add	r3, r2, r3
1002d444:	e2833010 	add	r3, r3, #16
1002d448:	e5d33001 	ldrb	r3, [r3, #1]
1002d44c:	e3530000 	cmp	r3, #0
1002d450:	1a000004 	bne	1002d468 <finsh_var_insert+0xb8>
1002d454:	e51b300c 	ldr	r3, [fp, #-12]
1002d458:	e3730001 	cmn	r3, #1
1002d45c:	1a000001 	bne	1002d468 <finsh_var_insert+0xb8>
		{
			empty = i;
1002d460:	e51b3008 	ldr	r3, [fp, #-8]
1002d464:	e50b300c 	str	r3, [fp, #-12]
int finsh_var_insert(const char* name, int type)
{
	int i, empty;

	empty = -1;
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1002d468:	e51b3008 	ldr	r3, [fp, #-8]
1002d46c:	e2833001 	add	r3, r3, #1
1002d470:	e50b3008 	str	r3, [fp, #-8]
1002d474:	e51b3008 	ldr	r3, [fp, #-8]
1002d478:	e3530007 	cmp	r3, #7
1002d47c:	daffffd5 	ble	1002d3d8 <finsh_var_insert+0x28>
			empty = i;
		}
	}

	/* there is no empty entry */
	if (empty == -1) return -1;
1002d480:	e51b300c 	ldr	r3, [fp, #-12]
1002d484:	e3730001 	cmn	r3, #1
1002d488:	1a000001 	bne	1002d494 <finsh_var_insert+0xe4>
1002d48c:	e3e03000 	mvn	r3, #0
1002d490:	ea00001b 	b	1002d504 <finsh_var_insert+0x154>

	/* insert entry */
	strncpy(global_variable[empty].name, name, FINSH_NAME_MAX);
1002d494:	e51b300c 	ldr	r3, [fp, #-12]
1002d498:	e1a02003 	mov	r2, r3
1002d49c:	e1a03182 	lsl	r3, r2, #3
1002d4a0:	e1a02003 	mov	r2, r3
1002d4a4:	e1a03102 	lsl	r3, r2, #2
1002d4a8:	e0623003 	rsb	r3, r2, r3
1002d4ac:	e3032764 	movw	r2, #14180	; 0x3764
1002d4b0:	e3412004 	movt	r2, #4100	; 0x1004
1002d4b4:	e0833002 	add	r3, r3, r2
1002d4b8:	e1a00003 	mov	r0, r3
1002d4bc:	e51b1010 	ldr	r1, [fp, #-16]
1002d4c0:	e3a02010 	mov	r2, #16
1002d4c4:	fa0008f4 	blx	1002f89c <strncpy>
	global_variable[empty].type = type;
1002d4c8:	e51b3014 	ldr	r3, [fp, #-20]
1002d4cc:	e6ef0073 	uxtb	r0, r3
1002d4d0:	e3032764 	movw	r2, #14180	; 0x3764
1002d4d4:	e3412004 	movt	r2, #4100	; 0x1004
1002d4d8:	e51b300c 	ldr	r3, [fp, #-12]
1002d4dc:	e1a01003 	mov	r1, r3
1002d4e0:	e1a03181 	lsl	r3, r1, #3
1002d4e4:	e1a01003 	mov	r1, r3
1002d4e8:	e1a03101 	lsl	r3, r1, #2
1002d4ec:	e0613003 	rsb	r3, r1, r3
1002d4f0:	e0823003 	add	r3, r2, r3
1002d4f4:	e2833010 	add	r3, r3, #16
1002d4f8:	e1a02000 	mov	r2, r0
1002d4fc:	e5c32001 	strb	r2, [r3, #1]

	/* return the offset */
	return empty;
1002d500:	e51b300c 	ldr	r3, [fp, #-12]
}
1002d504:	e1a00003 	mov	r0, r3
1002d508:	e24bd004 	sub	sp, fp, #4
1002d50c:	e8bd8800 	pop	{fp, pc}

1002d510 <finsh_var_delete>:

int finsh_var_delete(const char* name)
{
1002d510:	e92d4800 	push	{fp, lr}
1002d514:	e28db004 	add	fp, sp, #4
1002d518:	e24dd010 	sub	sp, sp, #16
1002d51c:	e50b0010 	str	r0, [fp, #-16]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1002d520:	e3a03000 	mov	r3, #0
1002d524:	e50b3008 	str	r3, [fp, #-8]
1002d528:	ea000013 	b	1002d57c <finsh_var_delete+0x6c>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
1002d52c:	e51b3008 	ldr	r3, [fp, #-8]
1002d530:	e1a02003 	mov	r2, r3
1002d534:	e1a03182 	lsl	r3, r2, #3
1002d538:	e1a02003 	mov	r2, r3
1002d53c:	e1a03102 	lsl	r3, r2, #2
1002d540:	e0623003 	rsb	r3, r2, r3
1002d544:	e3032764 	movw	r2, #14180	; 0x3764
1002d548:	e3412004 	movt	r2, #4100	; 0x1004
1002d54c:	e0833002 	add	r3, r3, r2
1002d550:	e1a00003 	mov	r0, r3
1002d554:	e51b1010 	ldr	r1, [fp, #-16]
1002d558:	e3a02010 	mov	r2, #16
1002d55c:	fa0008a8 	blx	1002f804 <strncmp>
1002d560:	e1a03000 	mov	r3, r0
1002d564:	e3530000 	cmp	r3, #0
1002d568:	1a000000 	bne	1002d570 <finsh_var_delete+0x60>
			break;
1002d56c:	ea000005 	b	1002d588 <finsh_var_delete+0x78>

int finsh_var_delete(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1002d570:	e51b3008 	ldr	r3, [fp, #-8]
1002d574:	e2833001 	add	r3, r3, #1
1002d578:	e50b3008 	str	r3, [fp, #-8]
1002d57c:	e51b3008 	ldr	r3, [fp, #-8]
1002d580:	e3530007 	cmp	r3, #7
1002d584:	daffffe8 	ble	1002d52c <finsh_var_delete+0x1c>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return -1;
1002d588:	e51b3008 	ldr	r3, [fp, #-8]
1002d58c:	e3530008 	cmp	r3, #8
1002d590:	1a000001 	bne	1002d59c <finsh_var_delete+0x8c>
1002d594:	e3e03000 	mvn	r3, #0
1002d598:	ea00000d 	b	1002d5d4 <finsh_var_delete+0xc4>

	memset(&global_variable[i], 0, sizeof(struct finsh_var));
1002d59c:	e51b3008 	ldr	r3, [fp, #-8]
1002d5a0:	e1a02003 	mov	r2, r3
1002d5a4:	e1a03182 	lsl	r3, r2, #3
1002d5a8:	e1a02003 	mov	r2, r3
1002d5ac:	e1a03102 	lsl	r3, r2, #2
1002d5b0:	e0623003 	rsb	r3, r2, r3
1002d5b4:	e3032764 	movw	r2, #14180	; 0x3764
1002d5b8:	e3412004 	movt	r2, #4100	; 0x1004
1002d5bc:	e0833002 	add	r3, r3, r2
1002d5c0:	e1a00003 	mov	r0, r3
1002d5c4:	e3a01000 	mov	r1, #0
1002d5c8:	e3a02018 	mov	r2, #24
1002d5cc:	fa000772 	blx	1002f39c <memset>

	return 0;
1002d5d0:	e3a03000 	mov	r3, #0
}
1002d5d4:	e1a00003 	mov	r0, r3
1002d5d8:	e24bd004 	sub	sp, fp, #4
1002d5dc:	e8bd8800 	pop	{fp, pc}

1002d5e0 <finsh_var_lookup>:

struct finsh_var* finsh_var_lookup(const char* name)
{
1002d5e0:	e92d4800 	push	{fp, lr}
1002d5e4:	e28db004 	add	fp, sp, #4
1002d5e8:	e24dd010 	sub	sp, sp, #16
1002d5ec:	e50b0010 	str	r0, [fp, #-16]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1002d5f0:	e3a03000 	mov	r3, #0
1002d5f4:	e50b3008 	str	r3, [fp, #-8]
1002d5f8:	ea000013 	b	1002d64c <finsh_var_lookup+0x6c>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
1002d5fc:	e51b3008 	ldr	r3, [fp, #-8]
1002d600:	e1a02003 	mov	r2, r3
1002d604:	e1a03182 	lsl	r3, r2, #3
1002d608:	e1a02003 	mov	r2, r3
1002d60c:	e1a03102 	lsl	r3, r2, #2
1002d610:	e0623003 	rsb	r3, r2, r3
1002d614:	e3032764 	movw	r2, #14180	; 0x3764
1002d618:	e3412004 	movt	r2, #4100	; 0x1004
1002d61c:	e0833002 	add	r3, r3, r2
1002d620:	e1a00003 	mov	r0, r3
1002d624:	e51b1010 	ldr	r1, [fp, #-16]
1002d628:	e3a02010 	mov	r2, #16
1002d62c:	fa000874 	blx	1002f804 <strncmp>
1002d630:	e1a03000 	mov	r3, r0
1002d634:	e3530000 	cmp	r3, #0
1002d638:	1a000000 	bne	1002d640 <finsh_var_lookup+0x60>
			break;
1002d63c:	ea000005 	b	1002d658 <finsh_var_lookup+0x78>

struct finsh_var* finsh_var_lookup(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1002d640:	e51b3008 	ldr	r3, [fp, #-8]
1002d644:	e2833001 	add	r3, r3, #1
1002d648:	e50b3008 	str	r3, [fp, #-8]
1002d64c:	e51b3008 	ldr	r3, [fp, #-8]
1002d650:	e3530007 	cmp	r3, #7
1002d654:	daffffe8 	ble	1002d5fc <finsh_var_lookup+0x1c>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return NULL;
1002d658:	e51b3008 	ldr	r3, [fp, #-8]
1002d65c:	e3530008 	cmp	r3, #8
1002d660:	1a000001 	bne	1002d66c <finsh_var_lookup+0x8c>
1002d664:	e3a03000 	mov	r3, #0
1002d668:	ea000008 	b	1002d690 <finsh_var_lookup+0xb0>

	return &global_variable[i];
1002d66c:	e51b3008 	ldr	r3, [fp, #-8]
1002d670:	e1a02003 	mov	r2, r3
1002d674:	e1a03182 	lsl	r3, r2, #3
1002d678:	e1a02003 	mov	r2, r3
1002d67c:	e1a03102 	lsl	r3, r2, #2
1002d680:	e0623003 	rsb	r3, r2, r3
1002d684:	e3032764 	movw	r2, #14180	; 0x3764
1002d688:	e3412004 	movt	r2, #4100	; 0x1004
1002d68c:	e0833002 	add	r3, r3, r2
}
1002d690:	e1a00003 	mov	r0, r3
1002d694:	e24bd004 	sub	sp, fp, #4
1002d698:	e8bd8800 	pop	{fp, pc}

1002d69c <finsh_sysvar_append>:

#ifdef RT_USING_HEAP
void finsh_sysvar_append(const char* name, u_char type, void* var_addr)
{
1002d69c:	e92d4800 	push	{fp, lr}
1002d6a0:	e28db004 	add	fp, sp, #4
1002d6a4:	e24dd018 	sub	sp, sp, #24
1002d6a8:	e50b0010 	str	r0, [fp, #-16]
1002d6ac:	e1a03001 	mov	r3, r1
1002d6b0:	e50b2018 	str	r2, [fp, #-24]
1002d6b4:	e54b3011 	strb	r3, [fp, #-17]
	/* create a sysvar */
	struct finsh_sysvar_item* item;

	item = (struct finsh_sysvar_item*) rt_malloc (sizeof(struct finsh_sysvar_item));
1002d6b8:	e3a00014 	mov	r0, #20
1002d6bc:	ebff9af4 	bl	10014294 <rt_malloc>
1002d6c0:	e50b0008 	str	r0, [fp, #-8]
	if (item != NULL)
1002d6c4:	e51b3008 	ldr	r3, [fp, #-8]
1002d6c8:	e3530000 	cmp	r3, #0
1002d6cc:	0a000020 	beq	1002d754 <finsh_sysvar_append+0xb8>
	{
		item->next = NULL;
1002d6d0:	e51b3008 	ldr	r3, [fp, #-8]
1002d6d4:	e3a02000 	mov	r2, #0
1002d6d8:	e5832000 	str	r2, [r3]
		item->sysvar.name = rt_strdup(name);
1002d6dc:	e51b0010 	ldr	r0, [fp, #-16]
1002d6e0:	ebff94e6 	bl	10012a80 <rt_strdup>
1002d6e4:	e1a02000 	mov	r2, r0
1002d6e8:	e51b3008 	ldr	r3, [fp, #-8]
1002d6ec:	e5832004 	str	r2, [r3, #4]
		item->sysvar.type = type;
1002d6f0:	e51b3008 	ldr	r3, [fp, #-8]
1002d6f4:	e55b2011 	ldrb	r2, [fp, #-17]
1002d6f8:	e5c3200c 	strb	r2, [r3, #12]
		item->sysvar.var = var_addr;
1002d6fc:	e51b3008 	ldr	r3, [fp, #-8]
1002d700:	e51b2018 	ldr	r2, [fp, #-24]
1002d704:	e5832010 	str	r2, [r3, #16]

		if (global_sysvar_list == NULL)
1002d708:	e3033760 	movw	r3, #14176	; 0x3760
1002d70c:	e3413004 	movt	r3, #4100	; 0x1004
1002d710:	e5933000 	ldr	r3, [r3]
1002d714:	e3530000 	cmp	r3, #0
1002d718:	1a000004 	bne	1002d730 <finsh_sysvar_append+0x94>
		{
			global_sysvar_list = item;
1002d71c:	e3033760 	movw	r3, #14176	; 0x3760
1002d720:	e3413004 	movt	r3, #4100	; 0x1004
1002d724:	e51b2008 	ldr	r2, [fp, #-8]
1002d728:	e5832000 	str	r2, [r3]
1002d72c:	ea000008 	b	1002d754 <finsh_sysvar_append+0xb8>
		}
		else
		{
			item->next = global_sysvar_list;
1002d730:	e3033760 	movw	r3, #14176	; 0x3760
1002d734:	e3413004 	movt	r3, #4100	; 0x1004
1002d738:	e5932000 	ldr	r2, [r3]
1002d73c:	e51b3008 	ldr	r3, [fp, #-8]
1002d740:	e5832000 	str	r2, [r3]
			global_sysvar_list = item;
1002d744:	e3033760 	movw	r3, #14176	; 0x3760
1002d748:	e3413004 	movt	r3, #4100	; 0x1004
1002d74c:	e51b2008 	ldr	r2, [fp, #-8]
1002d750:	e5832000 	str	r2, [r3]
		}
	}
}
1002d754:	e24bd004 	sub	sp, fp, #4
1002d758:	e8bd8800 	pop	{fp, pc}

1002d75c <finsh_sysvar_lookup>:
#endif

struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
1002d75c:	e92d4810 	push	{r4, fp, lr}
1002d760:	e28db008 	add	fp, sp, #8
1002d764:	e24dd014 	sub	sp, sp, #20
1002d768:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
1002d76c:	e30f393c 	movw	r3, #63804	; 0xf93c
1002d770:	e3413003 	movt	r3, #4099	; 0x1003
1002d774:	e5933000 	ldr	r3, [r3]
1002d778:	e50b3010 	str	r3, [fp, #-16]
1002d77c:	ea00000c 	b	1002d7b4 <finsh_sysvar_lookup+0x58>
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
	{
		if (strcmp(index->name, name) == 0)
1002d780:	e51b3010 	ldr	r3, [fp, #-16]
1002d784:	e5933000 	ldr	r3, [r3]
1002d788:	e1a00003 	mov	r0, r3
1002d78c:	e51b1018 	ldr	r1, [fp, #-24]
1002d790:	fa00051a 	blx	1002ec00 <strcmp>
1002d794:	e1a03000 	mov	r3, r0
1002d798:	e3530000 	cmp	r3, #0
1002d79c:	1a000001 	bne	1002d7a8 <finsh_sysvar_lookup+0x4c>
			return index;
1002d7a0:	e51b3010 	ldr	r3, [fp, #-16]
1002d7a4:	ea000023 	b	1002d838 <finsh_sysvar_lookup+0xdc>
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
1002d7a8:	e51b3010 	ldr	r3, [fp, #-16]
1002d7ac:	e2833010 	add	r3, r3, #16
1002d7b0:	e50b3010 	str	r3, [fp, #-16]
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
1002d7b4:	e30f3940 	movw	r3, #63808	; 0xf940
1002d7b8:	e3413003 	movt	r3, #4099	; 0x1003
1002d7bc:	e5933000 	ldr	r3, [r3]
struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
1002d7c0:	e51b2010 	ldr	r2, [fp, #-16]
1002d7c4:	e1520003 	cmp	r2, r3
1002d7c8:	3affffec 	bcc	1002d780 <finsh_sysvar_lookup+0x24>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
1002d7cc:	e3033760 	movw	r3, #14176	; 0x3760
1002d7d0:	e3413004 	movt	r3, #4100	; 0x1004
1002d7d4:	e5933000 	ldr	r3, [r3]
1002d7d8:	e50b3014 	str	r3, [fp, #-20]
	while (item != NULL)
1002d7dc:	ea000011 	b	1002d828 <finsh_sysvar_lookup+0xcc>
	{
		if (strncmp(item->sysvar.name, name, strlen(name)) == 0)
1002d7e0:	e51b3014 	ldr	r3, [fp, #-20]
1002d7e4:	e5934004 	ldr	r4, [r3, #4]
1002d7e8:	e51b0018 	ldr	r0, [fp, #-24]
1002d7ec:	fa0007ed 	blx	1002f7a8 <strlen>
1002d7f0:	e1a03000 	mov	r3, r0
1002d7f4:	e1a00004 	mov	r0, r4
1002d7f8:	e51b1018 	ldr	r1, [fp, #-24]
1002d7fc:	e1a02003 	mov	r2, r3
1002d800:	fa0007ff 	blx	1002f804 <strncmp>
1002d804:	e1a03000 	mov	r3, r0
1002d808:	e3530000 	cmp	r3, #0
1002d80c:	1a000002 	bne	1002d81c <finsh_sysvar_lookup+0xc0>
		{
			return &(item->sysvar);
1002d810:	e51b3014 	ldr	r3, [fp, #-20]
1002d814:	e2833004 	add	r3, r3, #4
1002d818:	ea000006 	b	1002d838 <finsh_sysvar_lookup+0xdc>
		}

		/* move to next item */
		item = item->next;
1002d81c:	e51b3014 	ldr	r3, [fp, #-20]
1002d820:	e5933000 	ldr	r3, [r3]
1002d824:	e50b3014 	str	r3, [fp, #-20]
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
	while (item != NULL)
1002d828:	e51b3014 	ldr	r3, [fp, #-20]
1002d82c:	e3530000 	cmp	r3, #0
1002d830:	1affffea 	bne	1002d7e0 <finsh_sysvar_lookup+0x84>
		/* move to next item */
		item = item->next;
	}

	/* can't find variable */
	return NULL;
1002d834:	e3a03000 	mov	r3, #0
}
1002d838:	e1a00003 	mov	r0, r3
1002d83c:	e24bd008 	sub	sp, fp, #8
1002d840:	e8bd8810 	pop	{r4, fp, pc}

1002d844 <finsh_vm_run>:
/* syscall list, for dynamic system call register */
struct finsh_syscall_item* global_syscall_list = NULL;

// #define FINSH_VM_DISASSEMBLE
void finsh_vm_run()
{
1002d844:	e92d4800 	push	{fp, lr}
1002d848:	e28db004 	add	fp, sp, #4
1002d84c:	e24dd008 	sub	sp, sp, #8
	void finsh_disassemble();
	finsh_disassemble();
#endif

	/* set sp(stack pointer) to the beginning of stack */
	finsh_sp = &finsh_vm_stack[0];
1002d850:	e30339a8 	movw	r3, #14760	; 0x39a8
1002d854:	e3413004 	movt	r3, #4100	; 0x1004
1002d858:	e30328a4 	movw	r2, #14500	; 0x38a4
1002d85c:	e3412004 	movt	r2, #4100	; 0x1004
1002d860:	e5832000 	str	r2, [r3]

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];
1002d864:	e30339a4 	movw	r3, #14756	; 0x39a4
1002d868:	e3413004 	movt	r3, #4100	; 0x1004
1002d86c:	e3032824 	movw	r2, #14372	; 0x3824
1002d870:	e3412004 	movt	r2, #4100	; 0x1004
1002d874:	e5832000 	str	r2, [r3]

	while ((finsh_pc - &text_segment[0] >= 0) &&
1002d878:	ea00000d 	b	1002d8b4 <finsh_vm_run+0x70>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
	{
		/* get op */
		op = *finsh_pc++;
1002d87c:	e30339a4 	movw	r3, #14756	; 0x39a4
1002d880:	e3413004 	movt	r3, #4100	; 0x1004
1002d884:	e5932000 	ldr	r2, [r3]
1002d888:	e2821001 	add	r1, r2, #1
1002d88c:	e30339a4 	movw	r3, #14756	; 0x39a4
1002d890:	e3413004 	movt	r3, #4100	; 0x1004
1002d894:	e5831000 	str	r1, [r3]
1002d898:	e5d23000 	ldrb	r3, [r2]
1002d89c:	e54b3005 	strb	r3, [fp, #-5]

		/* call op function */
		op_table[op]();
1002d8a0:	e55b2005 	ldrb	r2, [fp, #-5]
1002d8a4:	e3053a20 	movw	r3, #23072	; 0x5a20
1002d8a8:	e3413003 	movt	r3, #4099	; 0x1003
1002d8ac:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1002d8b0:	e12fff33 	blx	r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
1002d8b4:	e30339a4 	movw	r3, #14756	; 0x39a4
1002d8b8:	e3413004 	movt	r3, #4100	; 0x1004
1002d8bc:	e5933000 	ldr	r3, [r3]
1002d8c0:	e1a02003 	mov	r2, r3
1002d8c4:	e3033824 	movw	r3, #14372	; 0x3824
1002d8c8:	e3413004 	movt	r3, #4100	; 0x1004
1002d8cc:	e0633002 	rsb	r3, r3, r2
1002d8d0:	e3530000 	cmp	r3, #0
1002d8d4:	ba000008 	blt	1002d8fc <finsh_vm_run+0xb8>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
1002d8d8:	e30339a4 	movw	r3, #14756	; 0x39a4
1002d8dc:	e3413004 	movt	r3, #4100	; 0x1004
1002d8e0:	e5933000 	ldr	r3, [r3]
1002d8e4:	e1a02003 	mov	r2, r3
1002d8e8:	e3033824 	movw	r3, #14372	; 0x3824
1002d8ec:	e3413004 	movt	r3, #4100	; 0x1004
1002d8f0:	e0633002 	rsb	r3, r3, r2
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
1002d8f4:	e353007f 	cmp	r3, #127	; 0x7f
1002d8f8:	daffffdf 	ble	1002d87c <finsh_vm_run+0x38>
		op = *finsh_pc++;

		/* call op function */
		op_table[op]();
	}
}
1002d8fc:	e24bd004 	sub	sp, fp, #4
1002d900:	e8bd8800 	pop	{fp, pc}

1002d904 <finsh_syscall_append>:

#ifdef RT_USING_HEAP
void finsh_syscall_append(const char* name, syscall_func func)
{
1002d904:	e92d4800 	push	{fp, lr}
1002d908:	e28db004 	add	fp, sp, #4
1002d90c:	e24dd010 	sub	sp, sp, #16
1002d910:	e50b0010 	str	r0, [fp, #-16]
1002d914:	e50b1014 	str	r1, [fp, #-20]
	/* create the syscall */
	struct finsh_syscall_item* item;

	item = (struct finsh_syscall_item*)rt_malloc(sizeof(struct finsh_syscall_item));
1002d918:	e3a00010 	mov	r0, #16
1002d91c:	ebff9a5c 	bl	10014294 <rt_malloc>
1002d920:	e50b0008 	str	r0, [fp, #-8]
	if (item != RT_NULL)
1002d924:	e51b3008 	ldr	r3, [fp, #-8]
1002d928:	e3530000 	cmp	r3, #0
1002d92c:	0a00001d 	beq	1002d9a8 <finsh_syscall_append+0xa4>
	{
		item->next = NULL;
1002d930:	e51b3008 	ldr	r3, [fp, #-8]
1002d934:	e3a02000 	mov	r2, #0
1002d938:	e5832000 	str	r2, [r3]
		item->syscall.name = rt_strdup(name);
1002d93c:	e51b0010 	ldr	r0, [fp, #-16]
1002d940:	ebff944e 	bl	10012a80 <rt_strdup>
1002d944:	e1a02000 	mov	r2, r0
1002d948:	e51b3008 	ldr	r3, [fp, #-8]
1002d94c:	e5832004 	str	r2, [r3, #4]
		item->syscall.func = func;
1002d950:	e51b3008 	ldr	r3, [fp, #-8]
1002d954:	e51b2014 	ldr	r2, [fp, #-20]
1002d958:	e583200c 	str	r2, [r3, #12]

		if (global_syscall_list == NULL)
1002d95c:	e30f3950 	movw	r3, #63824	; 0xf950
1002d960:	e3413003 	movt	r3, #4099	; 0x1003
1002d964:	e5933000 	ldr	r3, [r3]
1002d968:	e3530000 	cmp	r3, #0
1002d96c:	1a000004 	bne	1002d984 <finsh_syscall_append+0x80>
		{
			global_syscall_list = item;
1002d970:	e30f3950 	movw	r3, #63824	; 0xf950
1002d974:	e3413003 	movt	r3, #4099	; 0x1003
1002d978:	e51b2008 	ldr	r2, [fp, #-8]
1002d97c:	e5832000 	str	r2, [r3]
1002d980:	ea000008 	b	1002d9a8 <finsh_syscall_append+0xa4>
		}
		else
		{
			item->next = global_syscall_list;
1002d984:	e30f3950 	movw	r3, #63824	; 0xf950
1002d988:	e3413003 	movt	r3, #4099	; 0x1003
1002d98c:	e5932000 	ldr	r2, [r3]
1002d990:	e51b3008 	ldr	r3, [fp, #-8]
1002d994:	e5832000 	str	r2, [r3]
			global_syscall_list = item;
1002d998:	e30f3950 	movw	r3, #63824	; 0xf950
1002d99c:	e3413003 	movt	r3, #4099	; 0x1003
1002d9a0:	e51b2008 	ldr	r2, [fp, #-8]
1002d9a4:	e5832000 	str	r2, [r3]
		}
	}
}
1002d9a8:	e24bd004 	sub	sp, fp, #4
1002d9ac:	e8bd8800 	pop	{fp, pc}

1002d9b0 <finsh_syscall_lookup>:
	return (struct finsh_sysvar*)ptr;
}
#endif

struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
1002d9b0:	e92d4810 	push	{r4, fp, lr}
1002d9b4:	e28db008 	add	fp, sp, #8
1002d9b8:	e24dd014 	sub	sp, sp, #20
1002d9bc:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
1002d9c0:	e30f3934 	movw	r3, #63796	; 0xf934
1002d9c4:	e3413003 	movt	r3, #4099	; 0x1003
1002d9c8:	e5933000 	ldr	r3, [r3]
1002d9cc:	e50b3010 	str	r3, [fp, #-16]
1002d9d0:	ea00000c 	b	1002da08 <finsh_syscall_lookup+0x58>
	{
		if (strcmp(index->name, name) == 0)
1002d9d4:	e51b3010 	ldr	r3, [fp, #-16]
1002d9d8:	e5933000 	ldr	r3, [r3]
1002d9dc:	e1a00003 	mov	r0, r3
1002d9e0:	e51b1018 	ldr	r1, [fp, #-24]
1002d9e4:	fa000485 	blx	1002ec00 <strcmp>
1002d9e8:	e1a03000 	mov	r3, r0
1002d9ec:	e3530000 	cmp	r3, #0
1002d9f0:	1a000001 	bne	1002d9fc <finsh_syscall_lookup+0x4c>
			return index;
1002d9f4:	e51b3010 	ldr	r3, [fp, #-16]
1002d9f8:	ea000023 	b	1002da8c <finsh_syscall_lookup+0xdc>
struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
1002d9fc:	e51b3010 	ldr	r3, [fp, #-16]
1002da00:	e283300c 	add	r3, r3, #12
1002da04:	e50b3010 	str	r3, [fp, #-16]
1002da08:	e30f3938 	movw	r3, #63800	; 0xf938
1002da0c:	e3413003 	movt	r3, #4099	; 0x1003
1002da10:	e5933000 	ldr	r3, [r3]
1002da14:	e51b2010 	ldr	r2, [fp, #-16]
1002da18:	e1520003 	cmp	r2, r3
1002da1c:	3affffec 	bcc	1002d9d4 <finsh_syscall_lookup+0x24>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
1002da20:	e30f3950 	movw	r3, #63824	; 0xf950
1002da24:	e3413003 	movt	r3, #4099	; 0x1003
1002da28:	e5933000 	ldr	r3, [r3]
1002da2c:	e50b3014 	str	r3, [fp, #-20]
	while (item != NULL)
1002da30:	ea000011 	b	1002da7c <finsh_syscall_lookup+0xcc>
	{
		if (strncmp(item->syscall.name, name, strlen(name)) == 0)
1002da34:	e51b3014 	ldr	r3, [fp, #-20]
1002da38:	e5934004 	ldr	r4, [r3, #4]
1002da3c:	e51b0018 	ldr	r0, [fp, #-24]
1002da40:	fa000758 	blx	1002f7a8 <strlen>
1002da44:	e1a03000 	mov	r3, r0
1002da48:	e1a00004 	mov	r0, r4
1002da4c:	e51b1018 	ldr	r1, [fp, #-24]
1002da50:	e1a02003 	mov	r2, r3
1002da54:	fa00076a 	blx	1002f804 <strncmp>
1002da58:	e1a03000 	mov	r3, r0
1002da5c:	e3530000 	cmp	r3, #0
1002da60:	1a000002 	bne	1002da70 <finsh_syscall_lookup+0xc0>
		{
			return &(item->syscall);
1002da64:	e51b3014 	ldr	r3, [fp, #-20]
1002da68:	e2833004 	add	r3, r3, #4
1002da6c:	ea000006 	b	1002da8c <finsh_syscall_lookup+0xdc>
		}

		item = item->next;
1002da70:	e51b3014 	ldr	r3, [fp, #-20]
1002da74:	e5933000 	ldr	r3, [r3]
1002da78:	e50b3014 	str	r3, [fp, #-20]
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
	while (item != NULL)
1002da7c:	e51b3014 	ldr	r3, [fp, #-20]
1002da80:	e3530000 	cmp	r3, #0
1002da84:	1affffea 	bne	1002da34 <finsh_syscall_lookup+0x84>
		}

		item = item->next;
	}

	return NULL;
1002da88:	e3a03000 	mov	r3, #0
}
1002da8c:	e1a00003 	mov	r0, r3
1002da90:	e24bd008 	sub	sp, fp, #8
1002da94:	e8bd8810 	pop	{r4, fp, pc}

1002da98 <finsh_token_init>:
static void token_trim_space(struct finsh_token* self);
static char token_proc_char(struct finsh_token* self);
static int token_proc_escape(struct finsh_token* self);

void finsh_token_init(struct finsh_token* self, u_char* line)
{
1002da98:	e92d4800 	push	{fp, lr}
1002da9c:	e28db004 	add	fp, sp, #4
1002daa0:	e24dd008 	sub	sp, sp, #8
1002daa4:	e50b0008 	str	r0, [fp, #-8]
1002daa8:	e50b100c 	str	r1, [fp, #-12]
	memset(self, 0, sizeof(struct finsh_token));
1002daac:	e51b0008 	ldr	r0, [fp, #-8]
1002dab0:	e3a01000 	mov	r1, #0
1002dab4:	e3a02094 	mov	r2, #148	; 0x94
1002dab8:	fa000637 	blx	1002f39c <memset>

	self->line = line;
1002dabc:	e51b3008 	ldr	r3, [fp, #-8]
1002dac0:	e51b200c 	ldr	r2, [fp, #-12]
1002dac4:	e5832090 	str	r2, [r3, #144]	; 0x90
}
1002dac8:	e24bd004 	sub	sp, fp, #4
1002dacc:	e8bd8800 	pop	{fp, pc}

1002dad0 <finsh_token_token>:

enum finsh_token_type finsh_token_token(struct finsh_token* self)
{
1002dad0:	e92d4800 	push	{fp, lr}
1002dad4:	e28db004 	add	fp, sp, #4
1002dad8:	e24dd008 	sub	sp, sp, #8
1002dadc:	e50b0008 	str	r0, [fp, #-8]
	if ( self->replay )	self->replay = 0;
1002dae0:	e51b3008 	ldr	r3, [fp, #-8]
1002dae4:	e5d33001 	ldrb	r3, [r3, #1]
1002dae8:	e3530000 	cmp	r3, #0
1002daec:	0a000003 	beq	1002db00 <finsh_token_token+0x30>
1002daf0:	e51b3008 	ldr	r3, [fp, #-8]
1002daf4:	e3a02000 	mov	r2, #0
1002daf8:	e5c32001 	strb	r2, [r3, #1]
1002dafc:	ea000001 	b	1002db08 <finsh_token_token+0x38>
	else token_run(self);
1002db00:	e51b0008 	ldr	r0, [fp, #-8]
1002db04:	eb0000a3 	bl	1002dd98 <token_run>

	return (enum finsh_token_type)self->current_token;
1002db08:	e51b3008 	ldr	r3, [fp, #-8]
1002db0c:	e5d33008 	ldrb	r3, [r3, #8]
}
1002db10:	e1a00003 	mov	r0, r3
1002db14:	e24bd004 	sub	sp, fp, #4
1002db18:	e8bd8800 	pop	{fp, pc}

1002db1c <finsh_token_get_token>:

void finsh_token_get_token(struct finsh_token* self, u_char* token)
{
1002db1c:	e92d4800 	push	{fp, lr}
1002db20:	e28db004 	add	fp, sp, #4
1002db24:	e24dd008 	sub	sp, sp, #8
1002db28:	e50b0008 	str	r0, [fp, #-8]
1002db2c:	e50b100c 	str	r1, [fp, #-12]
	strncpy((char*)token, (char*)self->string, FINSH_NAME_MAX);
1002db30:	e51b3008 	ldr	r3, [fp, #-8]
1002db34:	e2833010 	add	r3, r3, #16
1002db38:	e51b000c 	ldr	r0, [fp, #-12]
1002db3c:	e1a01003 	mov	r1, r3
1002db40:	e3a02010 	mov	r2, #16
1002db44:	fa000754 	blx	1002f89c <strncpy>
}
1002db48:	e24bd004 	sub	sp, fp, #4
1002db4c:	e8bd8800 	pop	{fp, pc}

1002db50 <token_get_string>:

int token_get_string(struct finsh_token* self, u_char* str)
{
1002db50:	e92d4800 	push	{fp, lr}
1002db54:	e28db004 	add	fp, sp, #4
1002db58:	e24dd010 	sub	sp, sp, #16
1002db5c:	e50b0010 	str	r0, [fp, #-16]
1002db60:	e50b1014 	str	r1, [fp, #-20]
	unsigned char *p=str;
1002db64:	e51b3014 	ldr	r3, [fp, #-20]
1002db68:	e50b3008 	str	r3, [fp, #-8]
	char ch;

	ch = token_next_char(self);
1002db6c:	e51b0010 	ldr	r0, [fp, #-16]
1002db70:	eb000043 	bl	1002dc84 <token_next_char>
1002db74:	e1a03000 	mov	r3, r0
1002db78:	e54b3009 	strb	r3, [fp, #-9]
	if (is_eof(self)) return -1;
1002db7c:	e51b3010 	ldr	r3, [fp, #-16]
1002db80:	e5d33000 	ldrb	r3, [r3]
1002db84:	e3530000 	cmp	r3, #0
1002db88:	0a000001 	beq	1002db94 <token_get_string+0x44>
1002db8c:	e3e03000 	mvn	r3, #0
1002db90:	ea000038 	b	1002dc78 <token_get_string+0x128>

	str[0] = '\0';
1002db94:	e51b3014 	ldr	r3, [fp, #-20]
1002db98:	e3a02000 	mov	r2, #0
1002db9c:	e5c32000 	strb	r2, [r3]

	if ( is_digit(ch) )/*the first character of identifier is not a digit.*/
1002dba0:	e55b3009 	ldrb	r3, [fp, #-9]
1002dba4:	e353002f 	cmp	r3, #47	; 0x2f
1002dba8:	9a000006 	bls	1002dbc8 <token_get_string+0x78>
1002dbac:	e55b3009 	ldrb	r3, [fp, #-9]
1002dbb0:	e3530039 	cmp	r3, #57	; 0x39
1002dbb4:	8a000003 	bhi	1002dbc8 <token_get_string+0x78>
	{
		token_prev_char(self);
1002dbb8:	e51b0010 	ldr	r0, [fp, #-16]
1002dbbc:	eb00005f 	bl	1002dd40 <token_prev_char>
		return -1;
1002dbc0:	e3e03000 	mvn	r3, #0
1002dbc4:	ea00002b 	b	1002dc78 <token_get_string+0x128>
	}

	while (!is_separator(ch) && !is_eof(self))
1002dbc8:	ea000008 	b	1002dbf0 <token_get_string+0xa0>
	{
		*p++ = ch;
1002dbcc:	e51b3008 	ldr	r3, [fp, #-8]
1002dbd0:	e2832001 	add	r2, r3, #1
1002dbd4:	e50b2008 	str	r2, [fp, #-8]
1002dbd8:	e55b2009 	ldrb	r2, [fp, #-9]
1002dbdc:	e5c32000 	strb	r2, [r3]

		ch = token_next_char(self);
1002dbe0:	e51b0010 	ldr	r0, [fp, #-16]
1002dbe4:	eb000026 	bl	1002dc84 <token_next_char>
1002dbe8:	e1a03000 	mov	r3, r0
1002dbec:	e54b3009 	strb	r3, [fp, #-9]
	{
		token_prev_char(self);
		return -1;
	}

	while (!is_separator(ch) && !is_eof(self))
1002dbf0:	e55b3009 	ldrb	r3, [fp, #-9]
1002dbf4:	e3530060 	cmp	r3, #96	; 0x60
1002dbf8:	9a000002 	bls	1002dc08 <token_get_string+0xb8>
1002dbfc:	e55b3009 	ldrb	r3, [fp, #-9]
1002dc00:	e353007a 	cmp	r3, #122	; 0x7a
1002dc04:	9a00000e 	bls	1002dc44 <token_get_string+0xf4>
1002dc08:	e55b3009 	ldrb	r3, [fp, #-9]
1002dc0c:	e3530040 	cmp	r3, #64	; 0x40
1002dc10:	9a000002 	bls	1002dc20 <token_get_string+0xd0>
1002dc14:	e55b3009 	ldrb	r3, [fp, #-9]
1002dc18:	e353005a 	cmp	r3, #90	; 0x5a
1002dc1c:	9a000008 	bls	1002dc44 <token_get_string+0xf4>
1002dc20:	e55b3009 	ldrb	r3, [fp, #-9]
1002dc24:	e353002f 	cmp	r3, #47	; 0x2f
1002dc28:	9a000002 	bls	1002dc38 <token_get_string+0xe8>
1002dc2c:	e55b3009 	ldrb	r3, [fp, #-9]
1002dc30:	e3530039 	cmp	r3, #57	; 0x39
1002dc34:	9a000002 	bls	1002dc44 <token_get_string+0xf4>
1002dc38:	e55b3009 	ldrb	r3, [fp, #-9]
1002dc3c:	e353005f 	cmp	r3, #95	; 0x5f
1002dc40:	1a000003 	bne	1002dc54 <token_get_string+0x104>
1002dc44:	e51b3010 	ldr	r3, [fp, #-16]
1002dc48:	e5d33000 	ldrb	r3, [r3]
1002dc4c:	e3530000 	cmp	r3, #0
1002dc50:	0affffdd 	beq	1002dbcc <token_get_string+0x7c>
	{
		*p++ = ch;

		ch = token_next_char(self);
	}
	self->eof = 0;
1002dc54:	e51b3010 	ldr	r3, [fp, #-16]
1002dc58:	e3a02000 	mov	r2, #0
1002dc5c:	e5c32000 	strb	r2, [r3]

	token_prev_char(self);
1002dc60:	e51b0010 	ldr	r0, [fp, #-16]
1002dc64:	eb000035 	bl	1002dd40 <token_prev_char>
	*p = '\0';
1002dc68:	e51b3008 	ldr	r3, [fp, #-8]
1002dc6c:	e3a02000 	mov	r2, #0
1002dc70:	e5c32000 	strb	r2, [r3]

	return 0;
1002dc74:	e3a03000 	mov	r3, #0
}
1002dc78:	e1a00003 	mov	r0, r3
1002dc7c:	e24bd004 	sub	sp, fp, #4
1002dc80:	e8bd8800 	pop	{fp, pc}

1002dc84 <token_next_char>:

/*
get next character.
*/
static char token_next_char(struct finsh_token* self)
{
1002dc84:	e92d4810 	push	{r4, fp, lr}
1002dc88:	e28db008 	add	fp, sp, #8
1002dc8c:	e24dd00c 	sub	sp, sp, #12
1002dc90:	e50b0010 	str	r0, [fp, #-16]
	if (self->eof) return '\0';
1002dc94:	e51b3010 	ldr	r3, [fp, #-16]
1002dc98:	e5d33000 	ldrb	r3, [r3]
1002dc9c:	e3530000 	cmp	r3, #0
1002dca0:	0a000001 	beq	1002dcac <token_next_char+0x28>
1002dca4:	e3a03000 	mov	r3, #0
1002dca8:	ea000021 	b	1002dd34 <token_next_char+0xb0>

	if (self->position == (int)strlen((char*)self->line) || self->line[self->position] =='\n')
1002dcac:	e51b3010 	ldr	r3, [fp, #-16]
1002dcb0:	e5934004 	ldr	r4, [r3, #4]
1002dcb4:	e51b3010 	ldr	r3, [fp, #-16]
1002dcb8:	e5933090 	ldr	r3, [r3, #144]	; 0x90
1002dcbc:	e1a00003 	mov	r0, r3
1002dcc0:	fa0006b8 	blx	1002f7a8 <strlen>
1002dcc4:	e1a03000 	mov	r3, r0
1002dcc8:	e1540003 	cmp	r4, r3
1002dccc:	0a000007 	beq	1002dcf0 <token_next_char+0x6c>
1002dcd0:	e51b3010 	ldr	r3, [fp, #-16]
1002dcd4:	e5933090 	ldr	r3, [r3, #144]	; 0x90
1002dcd8:	e51b2010 	ldr	r2, [fp, #-16]
1002dcdc:	e5922004 	ldr	r2, [r2, #4]
1002dce0:	e0833002 	add	r3, r3, r2
1002dce4:	e5d33000 	ldrb	r3, [r3]
1002dce8:	e353000a 	cmp	r3, #10
1002dcec:	1a000007 	bne	1002dd10 <token_next_char+0x8c>
	{
			self->eof = 1;
1002dcf0:	e51b3010 	ldr	r3, [fp, #-16]
1002dcf4:	e3a02001 	mov	r2, #1
1002dcf8:	e5c32000 	strb	r2, [r3]
			self->position = 0;
1002dcfc:	e51b3010 	ldr	r3, [fp, #-16]
1002dd00:	e3a02000 	mov	r2, #0
1002dd04:	e5832004 	str	r2, [r3, #4]
			return '\0';
1002dd08:	e3a03000 	mov	r3, #0
1002dd0c:	ea000008 	b	1002dd34 <token_next_char+0xb0>
	}

	return self->line[self->position++];
1002dd10:	e51b3010 	ldr	r3, [fp, #-16]
1002dd14:	e5932090 	ldr	r2, [r3, #144]	; 0x90
1002dd18:	e51b3010 	ldr	r3, [fp, #-16]
1002dd1c:	e5933004 	ldr	r3, [r3, #4]
1002dd20:	e2830001 	add	r0, r3, #1
1002dd24:	e51b1010 	ldr	r1, [fp, #-16]
1002dd28:	e5810004 	str	r0, [r1, #4]
1002dd2c:	e0823003 	add	r3, r2, r3
1002dd30:	e5d33000 	ldrb	r3, [r3]
}
1002dd34:	e1a00003 	mov	r0, r3
1002dd38:	e24bd008 	sub	sp, fp, #8
1002dd3c:	e8bd8810 	pop	{r4, fp, pc}

1002dd40 <token_prev_char>:

static void token_prev_char(struct finsh_token* self)
{
1002dd40:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002dd44:	e28db000 	add	fp, sp, #0
1002dd48:	e24dd00c 	sub	sp, sp, #12
1002dd4c:	e50b0008 	str	r0, [fp, #-8]
	if ( self->eof ) return;
1002dd50:	e51b3008 	ldr	r3, [fp, #-8]
1002dd54:	e5d33000 	ldrb	r3, [r3]
1002dd58:	e3530000 	cmp	r3, #0
1002dd5c:	0a000000 	beq	1002dd64 <token_prev_char+0x24>
1002dd60:	ea000009 	b	1002dd8c <token_prev_char+0x4c>

	if ( self->position == 0 ) return;
1002dd64:	e51b3008 	ldr	r3, [fp, #-8]
1002dd68:	e5933004 	ldr	r3, [r3, #4]
1002dd6c:	e3530000 	cmp	r3, #0
1002dd70:	1a000000 	bne	1002dd78 <token_prev_char+0x38>
1002dd74:	ea000004 	b	1002dd8c <token_prev_char+0x4c>
    else self->position--;
1002dd78:	e51b3008 	ldr	r3, [fp, #-8]
1002dd7c:	e5933004 	ldr	r3, [r3, #4]
1002dd80:	e2432001 	sub	r2, r3, #1
1002dd84:	e51b3008 	ldr	r3, [fp, #-8]
1002dd88:	e5832004 	str	r2, [r3, #4]
}
1002dd8c:	e24bd000 	sub	sp, fp, #0
1002dd90:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002dd94:	e12fff1e 	bx	lr

1002dd98 <token_run>:

static void token_run(struct finsh_token* self)
{
1002dd98:	e92d4800 	push	{fp, lr}
1002dd9c:	e28db004 	add	fp, sp, #4
1002dda0:	e24dd010 	sub	sp, sp, #16
1002dda4:	e50b0010 	str	r0, [fp, #-16]
	char ch;

	token_trim_space(self); /* first trim space and tab. */
1002dda8:	e51b0010 	ldr	r0, [fp, #-16]
1002ddac:	eb00014c 	bl	1002e2e4 <token_trim_space>
	token_get_string(self, &(self->string[0]));
1002ddb0:	e51b3010 	ldr	r3, [fp, #-16]
1002ddb4:	e2833010 	add	r3, r3, #16
1002ddb8:	e51b0010 	ldr	r0, [fp, #-16]
1002ddbc:	e1a01003 	mov	r1, r3
1002ddc0:	ebffff62 	bl	1002db50 <token_get_string>

	if ( is_eof(self) ) /*if it is eof, break;*/
1002ddc4:	e51b3010 	ldr	r3, [fp, #-16]
1002ddc8:	e5d33000 	ldrb	r3, [r3]
1002ddcc:	e3530000 	cmp	r3, #0
1002ddd0:	0a000003 	beq	1002dde4 <token_run+0x4c>
	{
		self->current_token = finsh_token_type_eof;
1002ddd4:	e51b3010 	ldr	r3, [fp, #-16]
1002ddd8:	e3a02021 	mov	r2, #33	; 0x21
1002dddc:	e5c32008 	strb	r2, [r3, #8]
		return ;
1002dde0:	ea000117 	b	1002e244 <token_run+0x4ac>
	}

	if (self->string[0] != '\0') /*It is a key word or a identifier.*/
1002dde4:	e51b3010 	ldr	r3, [fp, #-16]
1002dde8:	e5d33010 	ldrb	r3, [r3, #16]
1002ddec:	e3530000 	cmp	r3, #0
1002ddf0:	0a00000b 	beq	1002de24 <token_run+0x8c>
	{
		if ( !token_match_name(self, (char*)self->string) )
1002ddf4:	e51b3010 	ldr	r3, [fp, #-16]
1002ddf8:	e2833010 	add	r3, r3, #16
1002ddfc:	e51b0010 	ldr	r0, [fp, #-16]
1002de00:	e1a01003 	mov	r1, r3
1002de04:	eb000110 	bl	1002e24c <token_match_name>
1002de08:	e1a03000 	mov	r3, r0
1002de0c:	e3530000 	cmp	r3, #0
1002de10:	1a00010b 	bne	1002e244 <token_run+0x4ac>
		{
			self->current_token = finsh_token_type_identifier;
1002de14:	e51b3010 	ldr	r3, [fp, #-16]
1002de18:	e3a0201f 	mov	r2, #31
1002de1c:	e5c32008 	strb	r2, [r3, #8]
1002de20:	ea000107 	b	1002e244 <token_run+0x4ac>
		}
	}
	else/*It is a operator character.*/
	{
		ch = token_next_char(self);
1002de24:	e51b0010 	ldr	r0, [fp, #-16]
1002de28:	ebffff95 	bl	1002dc84 <token_next_char>
1002de2c:	e1a03000 	mov	r3, r0
1002de30:	e54b3005 	strb	r3, [fp, #-5]

		switch ( ch )
1002de34:	e55b3005 	ldrb	r3, [fp, #-5]
1002de38:	e2433022 	sub	r3, r3, #34	; 0x22
1002de3c:	e353005c 	cmp	r3, #92	; 0x5c
1002de40:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002de44:	ea0000ed 	b	1002e200 <token_run+0x468>
1002de48:	1002e1e8 	.word	0x1002e1e8
1002de4c:	1002e200 	.word	0x1002e200
1002de50:	1002e200 	.word	0x1002e200
1002de54:	1002e180 	.word	0x1002e180
1002de58:	1002dffc 	.word	0x1002dffc
1002de5c:	1002e1c0 	.word	0x1002e1c0
1002de60:	1002dfbc 	.word	0x1002dfbc
1002de64:	1002dfcc 	.word	0x1002dfcc
1002de68:	1002e00c 	.word	0x1002e00c
1002de6c:	1002e01c 	.word	0x1002e01c
1002de70:	1002dfdc 	.word	0x1002dfdc
1002de74:	1002e060 	.word	0x1002e060
1002de78:	1002e200 	.word	0x1002e200
1002de7c:	1002e0a4 	.word	0x1002e0a4
1002de80:	1002e200 	.word	0x1002e200
1002de84:	1002e200 	.word	0x1002e200
1002de88:	1002e200 	.word	0x1002e200
1002de8c:	1002e200 	.word	0x1002e200
1002de90:	1002e200 	.word	0x1002e200
1002de94:	1002e200 	.word	0x1002e200
1002de98:	1002e200 	.word	0x1002e200
1002de9c:	1002e200 	.word	0x1002e200
1002dea0:	1002e200 	.word	0x1002e200
1002dea4:	1002e200 	.word	0x1002e200
1002dea8:	1002e200 	.word	0x1002e200
1002deac:	1002dfec 	.word	0x1002dfec
1002deb0:	1002e0e8 	.word	0x1002e0e8
1002deb4:	1002e1b0 	.word	0x1002e1b0
1002deb8:	1002e12c 	.word	0x1002e12c
1002debc:	1002e200 	.word	0x1002e200
1002dec0:	1002e200 	.word	0x1002e200
1002dec4:	1002e200 	.word	0x1002e200
1002dec8:	1002e200 	.word	0x1002e200
1002decc:	1002e200 	.word	0x1002e200
1002ded0:	1002e200 	.word	0x1002e200
1002ded4:	1002e200 	.word	0x1002e200
1002ded8:	1002e200 	.word	0x1002e200
1002dedc:	1002e200 	.word	0x1002e200
1002dee0:	1002e200 	.word	0x1002e200
1002dee4:	1002e200 	.word	0x1002e200
1002dee8:	1002e200 	.word	0x1002e200
1002deec:	1002e200 	.word	0x1002e200
1002def0:	1002e200 	.word	0x1002e200
1002def4:	1002e200 	.word	0x1002e200
1002def8:	1002e200 	.word	0x1002e200
1002defc:	1002e200 	.word	0x1002e200
1002df00:	1002e200 	.word	0x1002e200
1002df04:	1002e200 	.word	0x1002e200
1002df08:	1002e200 	.word	0x1002e200
1002df0c:	1002e200 	.word	0x1002e200
1002df10:	1002e200 	.word	0x1002e200
1002df14:	1002e200 	.word	0x1002e200
1002df18:	1002e200 	.word	0x1002e200
1002df1c:	1002e200 	.word	0x1002e200
1002df20:	1002e200 	.word	0x1002e200
1002df24:	1002e200 	.word	0x1002e200
1002df28:	1002e200 	.word	0x1002e200
1002df2c:	1002e200 	.word	0x1002e200
1002df30:	1002e200 	.word	0x1002e200
1002df34:	1002e200 	.word	0x1002e200
1002df38:	1002e1a0 	.word	0x1002e1a0
1002df3c:	1002e200 	.word	0x1002e200
1002df40:	1002e200 	.word	0x1002e200
1002df44:	1002e200 	.word	0x1002e200
1002df48:	1002e200 	.word	0x1002e200
1002df4c:	1002e200 	.word	0x1002e200
1002df50:	1002e200 	.word	0x1002e200
1002df54:	1002e200 	.word	0x1002e200
1002df58:	1002e200 	.word	0x1002e200
1002df5c:	1002e200 	.word	0x1002e200
1002df60:	1002e200 	.word	0x1002e200
1002df64:	1002e200 	.word	0x1002e200
1002df68:	1002e200 	.word	0x1002e200
1002df6c:	1002e200 	.word	0x1002e200
1002df70:	1002e200 	.word	0x1002e200
1002df74:	1002e200 	.word	0x1002e200
1002df78:	1002e200 	.word	0x1002e200
1002df7c:	1002e200 	.word	0x1002e200
1002df80:	1002e200 	.word	0x1002e200
1002df84:	1002e200 	.word	0x1002e200
1002df88:	1002e200 	.word	0x1002e200
1002df8c:	1002e200 	.word	0x1002e200
1002df90:	1002e200 	.word	0x1002e200
1002df94:	1002e200 	.word	0x1002e200
1002df98:	1002e200 	.word	0x1002e200
1002df9c:	1002e200 	.word	0x1002e200
1002dfa0:	1002e200 	.word	0x1002e200
1002dfa4:	1002e200 	.word	0x1002e200
1002dfa8:	1002e200 	.word	0x1002e200
1002dfac:	1002e200 	.word	0x1002e200
1002dfb0:	1002e170 	.word	0x1002e170
1002dfb4:	1002e200 	.word	0x1002e200
1002dfb8:	1002e190 	.word	0x1002e190
		{
		case '(':
			self->current_token = finsh_token_type_left_paren;
1002dfbc:	e51b3010 	ldr	r3, [fp, #-16]
1002dfc0:	e3a02001 	mov	r2, #1
1002dfc4:	e5c32008 	strb	r2, [r3, #8]
			break;
1002dfc8:	ea00009d 	b	1002e244 <token_run+0x4ac>

		case ')':
			self->current_token = finsh_token_type_right_paren;
1002dfcc:	e51b3010 	ldr	r3, [fp, #-16]
1002dfd0:	e3a02002 	mov	r2, #2
1002dfd4:	e5c32008 	strb	r2, [r3, #8]
			break;
1002dfd8:	ea000099 	b	1002e244 <token_run+0x4ac>

		case ',':
			self->current_token = finsh_token_type_comma;
1002dfdc:	e51b3010 	ldr	r3, [fp, #-16]
1002dfe0:	e3a02003 	mov	r2, #3
1002dfe4:	e5c32008 	strb	r2, [r3, #8]
			break;
1002dfe8:	ea000095 	b	1002e244 <token_run+0x4ac>

		case ';':
			self->current_token = finsh_token_type_semicolon;
1002dfec:	e51b3010 	ldr	r3, [fp, #-16]
1002dff0:	e3a02004 	mov	r2, #4
1002dff4:	e5c32008 	strb	r2, [r3, #8]
			break;
1002dff8:	ea000091 	b	1002e244 <token_run+0x4ac>

		case '&':
			self->current_token = finsh_token_type_and;
1002dffc:	e51b3010 	ldr	r3, [fp, #-16]
1002e000:	e3a0200d 	mov	r2, #13
1002e004:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e008:	ea00008d 	b	1002e244 <token_run+0x4ac>

		case '*':
			self->current_token = finsh_token_type_mul;
1002e00c:	e51b3010 	ldr	r3, [fp, #-16]
1002e010:	e3a02005 	mov	r2, #5
1002e014:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e018:	ea000089 	b	1002e244 <token_run+0x4ac>

		case '+':
			ch = token_next_char(self);
1002e01c:	e51b0010 	ldr	r0, [fp, #-16]
1002e020:	ebffff17 	bl	1002dc84 <token_next_char>
1002e024:	e1a03000 	mov	r3, r0
1002e028:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '+' )
1002e02c:	e55b3005 	ldrb	r3, [fp, #-5]
1002e030:	e353002b 	cmp	r3, #43	; 0x2b
1002e034:	1a000003 	bne	1002e048 <token_run+0x2b0>
			{
				self->current_token = finsh_token_type_inc;
1002e038:	e51b3010 	ldr	r3, [fp, #-16]
1002e03c:	e3a02007 	mov	r2, #7
1002e040:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_add;
			}
			break;
1002e044:	ea00007e 	b	1002e244 <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_inc;
			}
			else
			{
				token_prev_char(self);
1002e048:	e51b0010 	ldr	r0, [fp, #-16]
1002e04c:	ebffff3b 	bl	1002dd40 <token_prev_char>
				self->current_token = finsh_token_type_add;
1002e050:	e51b3010 	ldr	r3, [fp, #-16]
1002e054:	e3a02006 	mov	r2, #6
1002e058:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1002e05c:	ea000078 	b	1002e244 <token_run+0x4ac>

		case '-':
			ch = token_next_char(self);
1002e060:	e51b0010 	ldr	r0, [fp, #-16]
1002e064:	ebffff06 	bl	1002dc84 <token_next_char>
1002e068:	e1a03000 	mov	r3, r0
1002e06c:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '-' )
1002e070:	e55b3005 	ldrb	r3, [fp, #-5]
1002e074:	e353002d 	cmp	r3, #45	; 0x2d
1002e078:	1a000003 	bne	1002e08c <token_run+0x2f4>
			{
				self->current_token = finsh_token_type_dec;
1002e07c:	e51b3010 	ldr	r3, [fp, #-16]
1002e080:	e3a02009 	mov	r2, #9
1002e084:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_sub;
			}
			break;
1002e088:	ea00006d 	b	1002e244 <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_dec;
			}
			else
			{
				token_prev_char(self);
1002e08c:	e51b0010 	ldr	r0, [fp, #-16]
1002e090:	ebffff2a 	bl	1002dd40 <token_prev_char>
				self->current_token = finsh_token_type_sub;
1002e094:	e51b3010 	ldr	r3, [fp, #-16]
1002e098:	e3a02008 	mov	r2, #8
1002e09c:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1002e0a0:	ea000067 	b	1002e244 <token_run+0x4ac>

		case '/':
			ch = token_next_char(self);
1002e0a4:	e51b0010 	ldr	r0, [fp, #-16]
1002e0a8:	ebfffef5 	bl	1002dc84 <token_next_char>
1002e0ac:	e1a03000 	mov	r3, r0
1002e0b0:	e54b3005 	strb	r3, [fp, #-5]
			if (ch == '/')
1002e0b4:	e55b3005 	ldrb	r3, [fp, #-5]
1002e0b8:	e353002f 	cmp	r3, #47	; 0x2f
1002e0bc:	1a000003 	bne	1002e0d0 <token_run+0x338>
			{
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
1002e0c0:	e51b3010 	ldr	r3, [fp, #-16]
1002e0c4:	e3a02021 	mov	r2, #33	; 0x21
1002e0c8:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_div;
			}
			break;
1002e0cc:	ea00005c 	b	1002e244 <token_run+0x4ac>
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
			}
			else
			{
				token_prev_char(self);
1002e0d0:	e51b0010 	ldr	r0, [fp, #-16]
1002e0d4:	ebffff19 	bl	1002dd40 <token_prev_char>
				self->current_token = finsh_token_type_div;
1002e0d8:	e51b3010 	ldr	r3, [fp, #-16]
1002e0dc:	e3a0200a 	mov	r2, #10
1002e0e0:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1002e0e4:	ea000056 	b	1002e244 <token_run+0x4ac>

		case '<':
			ch = token_next_char(self);
1002e0e8:	e51b0010 	ldr	r0, [fp, #-16]
1002e0ec:	ebfffee4 	bl	1002dc84 <token_next_char>
1002e0f0:	e1a03000 	mov	r3, r0
1002e0f4:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '<' )
1002e0f8:	e55b3005 	ldrb	r3, [fp, #-5]
1002e0fc:	e353003c 	cmp	r3, #60	; 0x3c
1002e100:	1a000003 	bne	1002e114 <token_run+0x37c>
			{
				self->current_token = finsh_token_type_shl;
1002e104:	e51b3010 	ldr	r3, [fp, #-16]
1002e108:	e3a02011 	mov	r2, #17
1002e10c:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
1002e110:	ea00004b 	b	1002e244 <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_shl;
			}
			else
			{
				token_prev_char(self);
1002e114:	e51b0010 	ldr	r0, [fp, #-16]
1002e118:	ebffff08 	bl	1002dd40 <token_prev_char>
				self->current_token = finsh_token_type_bad;
1002e11c:	e51b3010 	ldr	r3, [fp, #-16]
1002e120:	e3a02020 	mov	r2, #32
1002e124:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1002e128:	ea000045 	b	1002e244 <token_run+0x4ac>

		case '>':
			ch = token_next_char(self);
1002e12c:	e51b0010 	ldr	r0, [fp, #-16]
1002e130:	ebfffed3 	bl	1002dc84 <token_next_char>
1002e134:	e1a03000 	mov	r3, r0
1002e138:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '>' )
1002e13c:	e55b3005 	ldrb	r3, [fp, #-5]
1002e140:	e353003e 	cmp	r3, #62	; 0x3e
1002e144:	1a000003 	bne	1002e158 <token_run+0x3c0>
			{
				self->current_token = finsh_token_type_shr;
1002e148:	e51b3010 	ldr	r3, [fp, #-16]
1002e14c:	e3a02012 	mov	r2, #18
1002e150:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
1002e154:	ea00003a 	b	1002e244 <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_shr;
			}
			else
			{
				token_prev_char(self);
1002e158:	e51b0010 	ldr	r0, [fp, #-16]
1002e15c:	ebfffef7 	bl	1002dd40 <token_prev_char>
				self->current_token = finsh_token_type_bad;
1002e160:	e51b3010 	ldr	r3, [fp, #-16]
1002e164:	e3a02020 	mov	r2, #32
1002e168:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1002e16c:	ea000034 	b	1002e244 <token_run+0x4ac>

		case '|':
			self->current_token = finsh_token_type_or;
1002e170:	e51b3010 	ldr	r3, [fp, #-16]
1002e174:	e3a0200e 	mov	r2, #14
1002e178:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e17c:	ea000030 	b	1002e244 <token_run+0x4ac>

		case '%':
			self->current_token = finsh_token_type_mod;
1002e180:	e51b3010 	ldr	r3, [fp, #-16]
1002e184:	e3a0200b 	mov	r2, #11
1002e188:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e18c:	ea00002c 	b	1002e244 <token_run+0x4ac>

		case '~':
			self->current_token = finsh_token_type_bitwise;
1002e190:	e51b3010 	ldr	r3, [fp, #-16]
1002e194:	e3a02010 	mov	r2, #16
1002e198:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e19c:	ea000028 	b	1002e244 <token_run+0x4ac>

		case '^':
			self->current_token = finsh_token_type_xor;
1002e1a0:	e51b3010 	ldr	r3, [fp, #-16]
1002e1a4:	e3a0200f 	mov	r2, #15
1002e1a8:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e1ac:	ea000024 	b	1002e244 <token_run+0x4ac>

		case '=':
			self->current_token = finsh_token_type_assign;
1002e1b0:	e51b3010 	ldr	r3, [fp, #-16]
1002e1b4:	e3a0200c 	mov	r2, #12
1002e1b8:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e1bc:	ea000020 	b	1002e244 <token_run+0x4ac>

		case '\'':
			self->value.char_value = token_proc_char(self);
1002e1c0:	e51b0010 	ldr	r0, [fp, #-16]
1002e1c4:	eb00005b 	bl	1002e338 <token_proc_char>
1002e1c8:	e1a03000 	mov	r3, r0
1002e1cc:	e1a02003 	mov	r2, r3
1002e1d0:	e51b3010 	ldr	r3, [fp, #-16]
1002e1d4:	e5c3200c 	strb	r2, [r3, #12]
			self->current_token = finsh_token_type_value_char;
1002e1d8:	e51b3010 	ldr	r3, [fp, #-16]
1002e1dc:	e3a0201a 	mov	r2, #26
1002e1e0:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e1e4:	ea000016 	b	1002e244 <token_run+0x4ac>

		case '"':
			token_proc_string(self);
1002e1e8:	e51b0010 	ldr	r0, [fp, #-16]
1002e1ec:	eb0000b3 	bl	1002e4c0 <token_proc_string>
			self->current_token = finsh_token_type_value_string;
1002e1f0:	e51b3010 	ldr	r3, [fp, #-16]
1002e1f4:	e3a0201d 	mov	r2, #29
1002e1f8:	e5c32008 	strb	r2, [r3, #8]
			break;
1002e1fc:	ea000010 	b	1002e244 <token_run+0x4ac>

		default:
			if ( is_digit(ch) )
1002e200:	e55b3005 	ldrb	r3, [fp, #-5]
1002e204:	e353002f 	cmp	r3, #47	; 0x2f
1002e208:	9a000007 	bls	1002e22c <token_run+0x494>
1002e20c:	e55b3005 	ldrb	r3, [fp, #-5]
1002e210:	e3530039 	cmp	r3, #57	; 0x39
1002e214:	8a000004 	bhi	1002e22c <token_run+0x494>
			{
				token_prev_char(self);
1002e218:	e51b0010 	ldr	r0, [fp, #-16]
1002e21c:	ebfffec7 	bl	1002dd40 <token_prev_char>
				token_proc_number(self);
1002e220:	e51b0010 	ldr	r0, [fp, #-16]
1002e224:	eb00014a 	bl	1002e754 <token_proc_number>
				break;
1002e228:	ea000005 	b	1002e244 <token_run+0x4ac>
			}

			finsh_error_set(FINSH_ERROR_UNKNOWN_TOKEN);
1002e22c:	e3a0000b 	mov	r0, #11
1002e230:	ebffec4f 	bl	10029374 <finsh_error_set>
			self->current_token = finsh_token_type_bad;
1002e234:	e51b3010 	ldr	r3, [fp, #-16]
1002e238:	e3a02020 	mov	r2, #32
1002e23c:	e5c32008 	strb	r2, [r3, #8]

			break;
1002e240:	e1a00000 	nop			; (mov r0, r0)
		}
	}
}
1002e244:	e24bd004 	sub	sp, fp, #4
1002e248:	e8bd8800 	pop	{fp, pc}

1002e24c <token_match_name>:

static int token_match_name(struct finsh_token* self, const char* str)
{
1002e24c:	e92d4800 	push	{fp, lr}
1002e250:	e28db004 	add	fp, sp, #4
1002e254:	e24dd010 	sub	sp, sp, #16
1002e258:	e50b0010 	str	r0, [fp, #-16]
1002e25c:	e50b1014 	str	r1, [fp, #-20]
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
1002e260:	e3a03000 	mov	r3, #0
1002e264:	e50b3008 	str	r3, [fp, #-8]
1002e268:	ea000016 	b	1002e2c8 <token_match_name+0x7c>
	{
		if ( strcmp(finsh_name_table[i].name, str)==0 )
1002e26c:	e3053b24 	movw	r3, #23332	; 0x5b24
1002e270:	e3413003 	movt	r3, #4099	; 0x1003
1002e274:	e51b2008 	ldr	r2, [fp, #-8]
1002e278:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1002e27c:	e1a00003 	mov	r0, r3
1002e280:	e51b1014 	ldr	r1, [fp, #-20]
1002e284:	fa00025d 	blx	1002ec00 <strcmp>
1002e288:	e1a03000 	mov	r3, r0
1002e28c:	e3530000 	cmp	r3, #0
1002e290:	1a000009 	bne	1002e2bc <token_match_name+0x70>
		{
			self->current_token = finsh_name_table[i].type;
1002e294:	e3052b24 	movw	r2, #23332	; 0x5b24
1002e298:	e3412003 	movt	r2, #4099	; 0x1003
1002e29c:	e51b3008 	ldr	r3, [fp, #-8]
1002e2a0:	e1a03183 	lsl	r3, r3, #3
1002e2a4:	e0823003 	add	r3, r2, r3
1002e2a8:	e5d32004 	ldrb	r2, [r3, #4]
1002e2ac:	e51b3010 	ldr	r3, [fp, #-16]
1002e2b0:	e5c32008 	strb	r2, [r3, #8]
			return 1;
1002e2b4:	e3a03001 	mov	r3, #1
1002e2b8:	ea000006 	b	1002e2d8 <token_match_name+0x8c>

static int token_match_name(struct finsh_token* self, const char* str)
{
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
1002e2bc:	e51b3008 	ldr	r3, [fp, #-8]
1002e2c0:	e2833001 	add	r3, r3, #1
1002e2c4:	e50b3008 	str	r3, [fp, #-8]
1002e2c8:	e51b3008 	ldr	r3, [fp, #-8]
1002e2cc:	e3530007 	cmp	r3, #7
1002e2d0:	9affffe5 	bls	1002e26c <token_match_name+0x20>
			self->current_token = finsh_name_table[i].type;
			return 1;
		}
	}

	return 0;
1002e2d4:	e3a03000 	mov	r3, #0
}
1002e2d8:	e1a00003 	mov	r0, r3
1002e2dc:	e24bd004 	sub	sp, fp, #4
1002e2e0:	e8bd8800 	pop	{fp, pc}

1002e2e4 <token_trim_space>:

static void token_trim_space(struct finsh_token* self)
{
1002e2e4:	e92d4800 	push	{fp, lr}
1002e2e8:	e28db004 	add	fp, sp, #4
1002e2ec:	e24dd010 	sub	sp, sp, #16
1002e2f0:	e50b0010 	str	r0, [fp, #-16]
	char ch;
	while ( (ch = token_next_char(self)) ==' ' || 
1002e2f4:	e51b0010 	ldr	r0, [fp, #-16]
1002e2f8:	ebfffe61 	bl	1002dc84 <token_next_char>
1002e2fc:	e1a03000 	mov	r3, r0
1002e300:	e54b3005 	strb	r3, [fp, #-5]
1002e304:	e55b3005 	ldrb	r3, [fp, #-5]
1002e308:	e3530020 	cmp	r3, #32
1002e30c:	0afffff8 	beq	1002e2f4 <token_trim_space+0x10>
1002e310:	e55b3005 	ldrb	r3, [fp, #-5]
1002e314:	e3530009 	cmp	r3, #9
1002e318:	0afffff5 	beq	1002e2f4 <token_trim_space+0x10>
        ch == '\t' || 
1002e31c:	e55b3005 	ldrb	r3, [fp, #-5]
1002e320:	e353000d 	cmp	r3, #13
1002e324:	0afffff2 	beq	1002e2f4 <token_trim_space+0x10>
        ch == '\r');

	token_prev_char(self);
1002e328:	e51b0010 	ldr	r0, [fp, #-16]
1002e32c:	ebfffe83 	bl	1002dd40 <token_prev_char>
}
1002e330:	e24bd004 	sub	sp, fp, #4
1002e334:	e8bd8800 	pop	{fp, pc}

1002e338 <token_proc_char>:

static char token_proc_char(struct finsh_token* self)
{
1002e338:	e92d4800 	push	{fp, lr}
1002e33c:	e28db004 	add	fp, sp, #4
1002e340:	e24dd018 	sub	sp, sp, #24
1002e344:	e50b0018 	str	r0, [fp, #-24]
	char ch;
	char buf[4], *p;

	p = buf;
1002e348:	e24b3010 	sub	r3, fp, #16
1002e34c:	e50b300c 	str	r3, [fp, #-12]
	ch = token_next_char(self);
1002e350:	e51b0018 	ldr	r0, [fp, #-24]
1002e354:	ebfffe4a 	bl	1002dc84 <token_next_char>
1002e358:	e1a03000 	mov	r3, r0
1002e35c:	e54b3005 	strb	r3, [fp, #-5]

	if ( ch == '\\' )
1002e360:	e55b3005 	ldrb	r3, [fp, #-5]
1002e364:	e353005c 	cmp	r3, #92	; 0x5c
1002e368:	1a000045 	bne	1002e484 <token_proc_char+0x14c>
	{
		ch = token_next_char(self);
1002e36c:	e51b0018 	ldr	r0, [fp, #-24]
1002e370:	ebfffe43 	bl	1002dc84 <token_next_char>
1002e374:	e1a03000 	mov	r3, r0
1002e378:	e54b3005 	strb	r3, [fp, #-5]
		switch ( ch )
1002e37c:	e55b3005 	ldrb	r3, [fp, #-5]
1002e380:	e353006e 	cmp	r3, #110	; 0x6e
1002e384:	0a00000f 	beq	1002e3c8 <token_proc_char+0x90>
1002e388:	e353006e 	cmp	r3, #110	; 0x6e
1002e38c:	ca000006 	bgt	1002e3ac <token_proc_char+0x74>
1002e390:	e353005c 	cmp	r3, #92	; 0x5c
1002e394:	0a00001a 	beq	1002e404 <token_proc_char+0xcc>
1002e398:	e3530062 	cmp	r3, #98	; 0x62
1002e39c:	0a000012 	beq	1002e3ec <token_proc_char+0xb4>
1002e3a0:	e3530027 	cmp	r3, #39	; 0x27
1002e3a4:	0a000019 	beq	1002e410 <token_proc_char+0xd8>
1002e3a8:	ea00001b 	b	1002e41c <token_proc_char+0xe4>
1002e3ac:	e3530074 	cmp	r3, #116	; 0x74
1002e3b0:	0a000007 	beq	1002e3d4 <token_proc_char+0x9c>
1002e3b4:	e3530076 	cmp	r3, #118	; 0x76
1002e3b8:	0a000008 	beq	1002e3e0 <token_proc_char+0xa8>
1002e3bc:	e3530072 	cmp	r3, #114	; 0x72
1002e3c0:	0a00000c 	beq	1002e3f8 <token_proc_char+0xc0>
1002e3c4:	ea000014 	b	1002e41c <token_proc_char+0xe4>
		{
		case 'n': ch = '\n'; break;
1002e3c8:	e3a0300a 	mov	r3, #10
1002e3cc:	e54b3005 	strb	r3, [fp, #-5]
1002e3d0:	ea00002b 	b	1002e484 <token_proc_char+0x14c>
		case 't': ch = '\t'; break;
1002e3d4:	e3a03009 	mov	r3, #9
1002e3d8:	e54b3005 	strb	r3, [fp, #-5]
1002e3dc:	ea000028 	b	1002e484 <token_proc_char+0x14c>
		case 'v': ch = '\v'; break;
1002e3e0:	e3a0300b 	mov	r3, #11
1002e3e4:	e54b3005 	strb	r3, [fp, #-5]
1002e3e8:	ea000025 	b	1002e484 <token_proc_char+0x14c>
		case 'b': ch = '\b'; break;
1002e3ec:	e3a03008 	mov	r3, #8
1002e3f0:	e54b3005 	strb	r3, [fp, #-5]
1002e3f4:	ea000022 	b	1002e484 <token_proc_char+0x14c>
		case 'r': ch = '\r'; break;
1002e3f8:	e3a0300d 	mov	r3, #13
1002e3fc:	e54b3005 	strb	r3, [fp, #-5]
1002e400:	ea00001f 	b	1002e484 <token_proc_char+0x14c>
		case '\\': ch = '\\';  break;
1002e404:	e3a0305c 	mov	r3, #92	; 0x5c
1002e408:	e54b3005 	strb	r3, [fp, #-5]
1002e40c:	ea00001c 	b	1002e484 <token_proc_char+0x14c>
		case '\'': ch = '\'';  break;
1002e410:	e3a03027 	mov	r3, #39	; 0x27
1002e414:	e54b3005 	strb	r3, [fp, #-5]
1002e418:	ea000019 	b	1002e484 <token_proc_char+0x14c>
		default :
			while ( is_digit(ch) )/*for '\113' char*/
1002e41c:	ea000008 	b	1002e444 <token_proc_char+0x10c>
			{
				ch = token_next_char(self);
1002e420:	e51b0018 	ldr	r0, [fp, #-24]
1002e424:	ebfffe16 	bl	1002dc84 <token_next_char>
1002e428:	e1a03000 	mov	r3, r0
1002e42c:	e54b3005 	strb	r3, [fp, #-5]
				*p++ = ch;
1002e430:	e51b300c 	ldr	r3, [fp, #-12]
1002e434:	e2832001 	add	r2, r3, #1
1002e438:	e50b200c 	str	r2, [fp, #-12]
1002e43c:	e55b2005 	ldrb	r2, [fp, #-5]
1002e440:	e5c32000 	strb	r2, [r3]
		case 'b': ch = '\b'; break;
		case 'r': ch = '\r'; break;
		case '\\': ch = '\\';  break;
		case '\'': ch = '\'';  break;
		default :
			while ( is_digit(ch) )/*for '\113' char*/
1002e444:	e55b3005 	ldrb	r3, [fp, #-5]
1002e448:	e353002f 	cmp	r3, #47	; 0x2f
1002e44c:	9a000002 	bls	1002e45c <token_proc_char+0x124>
1002e450:	e55b3005 	ldrb	r3, [fp, #-5]
1002e454:	e3530039 	cmp	r3, #57	; 0x39
1002e458:	9afffff0 	bls	1002e420 <token_proc_char+0xe8>
			{
				ch = token_next_char(self);
				*p++ = ch;
			}

			token_prev_char(self);
1002e45c:	e51b0018 	ldr	r0, [fp, #-24]
1002e460:	ebfffe36 	bl	1002dd40 <token_prev_char>
			*p = '\0';
1002e464:	e51b300c 	ldr	r3, [fp, #-12]
1002e468:	e3a02000 	mov	r2, #0
1002e46c:	e5c32000 	strb	r2, [r3]
			ch = atoi(p);
1002e470:	e51b000c 	ldr	r0, [fp, #-12]
1002e474:	fa00039c 	blx	1002f2ec <atoi>
1002e478:	e1a03000 	mov	r3, r0
1002e47c:	e54b3005 	strb	r3, [fp, #-5]
			break;
1002e480:	e1a00000 	nop			; (mov r0, r0)
		}
	}

	if ( token_next_char(self) != '\'' )
1002e484:	e51b0018 	ldr	r0, [fp, #-24]
1002e488:	ebfffdfd 	bl	1002dc84 <token_next_char>
1002e48c:	e1a03000 	mov	r3, r0
1002e490:	e3530027 	cmp	r3, #39	; 0x27
1002e494:	0a000005 	beq	1002e4b0 <token_proc_char+0x178>
	{
		token_prev_char(self);
1002e498:	e51b0018 	ldr	r0, [fp, #-24]
1002e49c:	ebfffe27 	bl	1002dd40 <token_prev_char>
		finsh_error_set(FINSH_ERROR_EXPECT_CHAR);
1002e4a0:	e3a00009 	mov	r0, #9
1002e4a4:	ebffebb2 	bl	10029374 <finsh_error_set>
		return ch;
1002e4a8:	e55b3005 	ldrb	r3, [fp, #-5]
1002e4ac:	ea000000 	b	1002e4b4 <token_proc_char+0x17c>
	}

	return ch;
1002e4b0:	e55b3005 	ldrb	r3, [fp, #-5]
}
1002e4b4:	e1a00003 	mov	r0, r3
1002e4b8:	e24bd004 	sub	sp, fp, #4
1002e4bc:	e8bd8800 	pop	{fp, pc}

1002e4c0 <token_proc_string>:

static u_char* token_proc_string(struct finsh_token* self)
{
1002e4c0:	e92d4800 	push	{fp, lr}
1002e4c4:	e28db004 	add	fp, sp, #4
1002e4c8:	e24dd010 	sub	sp, sp, #16
1002e4cc:	e50b0010 	str	r0, [fp, #-16]
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
1002e4d0:	e51b3010 	ldr	r3, [fp, #-16]
1002e4d4:	e2833010 	add	r3, r3, #16
1002e4d8:	e50b3008 	str	r3, [fp, #-8]
1002e4dc:	ea000021 	b	1002e568 <token_proc_string+0xa8>
	{
		char ch = token_next_char(self);
1002e4e0:	e51b0010 	ldr	r0, [fp, #-16]
1002e4e4:	ebfffde6 	bl	1002dc84 <token_next_char>
1002e4e8:	e1a03000 	mov	r3, r0
1002e4ec:	e54b3009 	strb	r3, [fp, #-9]

		if ( is_eof(self) )
1002e4f0:	e51b3010 	ldr	r3, [fp, #-16]
1002e4f4:	e5d33000 	ldrb	r3, [r3]
1002e4f8:	e3530000 	cmp	r3, #0
1002e4fc:	0a000003 	beq	1002e510 <token_proc_string+0x50>
		{
			finsh_error_set(FINSH_ERROR_UNEXPECT_END);
1002e500:	e3a0000a 	mov	r0, #10
1002e504:	ebffeb9a 	bl	10029374 <finsh_error_set>
			return NULL;;
1002e508:	e3a03000 	mov	r3, #0
1002e50c:	ea00001c 	b	1002e584 <token_proc_string+0xc4>
		}
		if ( ch == '\\' )
1002e510:	e55b3009 	ldrb	r3, [fp, #-9]
1002e514:	e353005c 	cmp	r3, #92	; 0x5c
1002e518:	1a000004 	bne	1002e530 <token_proc_string+0x70>
		{
			ch = token_proc_escape(self);
1002e51c:	e51b0010 	ldr	r0, [fp, #-16]
1002e520:	eb00001a 	bl	1002e590 <token_proc_escape>
1002e524:	e1a03000 	mov	r3, r0
1002e528:	e54b3009 	strb	r3, [fp, #-9]
1002e52c:	ea000008 	b	1002e554 <token_proc_string+0x94>
		}
		else if ( ch == '"' )/*end of string.*/
1002e530:	e55b3009 	ldrb	r3, [fp, #-9]
1002e534:	e3530022 	cmp	r3, #34	; 0x22
1002e538:	1a000005 	bne	1002e554 <token_proc_string+0x94>
		{
			*p = '\0';
1002e53c:	e51b3008 	ldr	r3, [fp, #-8]
1002e540:	e3a02000 	mov	r2, #0
1002e544:	e5c32000 	strb	r2, [r3]
			return self->string;
1002e548:	e51b3010 	ldr	r3, [fp, #-16]
1002e54c:	e2833010 	add	r3, r3, #16
1002e550:	ea00000b 	b	1002e584 <token_proc_string+0xc4>
		}

		*p++ = ch;
1002e554:	e51b3008 	ldr	r3, [fp, #-8]
1002e558:	e2832001 	add	r2, r3, #1
1002e55c:	e50b2008 	str	r2, [fp, #-8]
1002e560:	e55b2009 	ldrb	r2, [fp, #-9]
1002e564:	e5c32000 	strb	r2, [r3]

static u_char* token_proc_string(struct finsh_token* self)
{
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
1002e568:	e51b3008 	ldr	r3, [fp, #-8]
1002e56c:	e51b2010 	ldr	r2, [fp, #-16]
1002e570:	e2822010 	add	r2, r2, #16
1002e574:	e0623003 	rsb	r3, r2, r3
1002e578:	e353007f 	cmp	r3, #127	; 0x7f
1002e57c:	daffffd7 	ble	1002e4e0 <token_proc_string+0x20>
		}

		*p++ = ch;
	}

	return NULL;
1002e580:	e3a03000 	mov	r3, #0
}
1002e584:	e1a00003 	mov	r0, r3
1002e588:	e24bd004 	sub	sp, fp, #4
1002e58c:	e8bd8800 	pop	{fp, pc}

1002e590 <token_proc_escape>:

static int token_proc_escape(struct finsh_token* self)
{
1002e590:	e92d4800 	push	{fp, lr}
1002e594:	e28db004 	add	fp, sp, #4
1002e598:	e24dd010 	sub	sp, sp, #16
1002e59c:	e50b0010 	str	r0, [fp, #-16]
	char ch;
	int result=0;
1002e5a0:	e3a03000 	mov	r3, #0
1002e5a4:	e50b300c 	str	r3, [fp, #-12]

	ch = token_next_char(self);
1002e5a8:	e51b0010 	ldr	r0, [fp, #-16]
1002e5ac:	ebfffdb4 	bl	1002dc84 <token_next_char>
1002e5b0:	e1a03000 	mov	r3, r0
1002e5b4:	e54b3005 	strb	r3, [fp, #-5]
	switch (ch)
1002e5b8:	e55b3005 	ldrb	r3, [fp, #-5]
1002e5bc:	e2433061 	sub	r3, r3, #97	; 0x61
1002e5c0:	e3530017 	cmp	r3, #23
1002e5c4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1002e5c8:	ea000044 	b	1002e6e0 <token_proc_escape+0x150>
1002e5cc:	1002e674 	.word	0x1002e674
1002e5d0:	1002e650 	.word	0x1002e650
1002e5d4:	1002e6e0 	.word	0x1002e6e0
1002e5d8:	1002e6e0 	.word	0x1002e6e0
1002e5dc:	1002e6e0 	.word	0x1002e6e0
1002e5e0:	1002e668 	.word	0x1002e668
1002e5e4:	1002e6e0 	.word	0x1002e6e0
1002e5e8:	1002e6e0 	.word	0x1002e6e0
1002e5ec:	1002e6e0 	.word	0x1002e6e0
1002e5f0:	1002e6e0 	.word	0x1002e6e0
1002e5f4:	1002e6e0 	.word	0x1002e6e0
1002e5f8:	1002e6e0 	.word	0x1002e6e0
1002e5fc:	1002e6e0 	.word	0x1002e6e0
1002e600:	1002e62c 	.word	0x1002e62c
1002e604:	1002e6e0 	.word	0x1002e6e0
1002e608:	1002e6e0 	.word	0x1002e6e0
1002e60c:	1002e6e0 	.word	0x1002e6e0
1002e610:	1002e65c 	.word	0x1002e65c
1002e614:	1002e6e0 	.word	0x1002e6e0
1002e618:	1002e638 	.word	0x1002e638
1002e61c:	1002e6e0 	.word	0x1002e6e0
1002e620:	1002e644 	.word	0x1002e644
1002e624:	1002e6e0 	.word	0x1002e6e0
1002e628:	1002e680 	.word	0x1002e680
	{
	case 'n':
		result = '\n';
1002e62c:	e3a0300a 	mov	r3, #10
1002e630:	e50b300c 	str	r3, [fp, #-12]
		break;
1002e634:	ea000042 	b	1002e744 <token_proc_escape+0x1b4>
	case 't':
		result = '\t';
1002e638:	e3a03009 	mov	r3, #9
1002e63c:	e50b300c 	str	r3, [fp, #-12]
		break;
1002e640:	ea00003f 	b	1002e744 <token_proc_escape+0x1b4>
	case 'v':
		result = '\v';
1002e644:	e3a0300b 	mov	r3, #11
1002e648:	e50b300c 	str	r3, [fp, #-12]
		break;
1002e64c:	ea00003c 	b	1002e744 <token_proc_escape+0x1b4>
	case 'b':
		result = '\b';
1002e650:	e3a03008 	mov	r3, #8
1002e654:	e50b300c 	str	r3, [fp, #-12]
		break;
1002e658:	ea000039 	b	1002e744 <token_proc_escape+0x1b4>
	case 'r':
		result = '\r';
1002e65c:	e3a0300d 	mov	r3, #13
1002e660:	e50b300c 	str	r3, [fp, #-12]
		break;
1002e664:	ea000036 	b	1002e744 <token_proc_escape+0x1b4>
	case 'f':
		result = '\f';
1002e668:	e3a0300c 	mov	r3, #12
1002e66c:	e50b300c 	str	r3, [fp, #-12]
		break;
1002e670:	ea000033 	b	1002e744 <token_proc_escape+0x1b4>
	case 'a':
		result = '\007';
1002e674:	e3a03007 	mov	r3, #7
1002e678:	e50b300c 	str	r3, [fp, #-12]
		break;
1002e67c:	ea000030 	b	1002e744 <token_proc_escape+0x1b4>
	case 'x':
		result = 0;
1002e680:	e3a03000 	mov	r3, #0
1002e684:	e50b300c 	str	r3, [fp, #-12]
		ch  = token_next_char(self);
1002e688:	e51b0010 	ldr	r0, [fp, #-16]
1002e68c:	ebfffd7c 	bl	1002dc84 <token_next_char>
1002e690:	e1a03000 	mov	r3, r0
1002e694:	e54b3005 	strb	r3, [fp, #-5]
		while ( (ch - '0')<16u )
1002e698:	ea000009 	b	1002e6c4 <token_proc_escape+0x134>
		{
			result = result*16 + ch - '0';
1002e69c:	e51b300c 	ldr	r3, [fp, #-12]
1002e6a0:	e1a02203 	lsl	r2, r3, #4
1002e6a4:	e55b3005 	ldrb	r3, [fp, #-5]
1002e6a8:	e0823003 	add	r3, r2, r3
1002e6ac:	e2433030 	sub	r3, r3, #48	; 0x30
1002e6b0:	e50b300c 	str	r3, [fp, #-12]
			ch = token_next_char(self);
1002e6b4:	e51b0010 	ldr	r0, [fp, #-16]
1002e6b8:	ebfffd71 	bl	1002dc84 <token_next_char>
1002e6bc:	e1a03000 	mov	r3, r0
1002e6c0:	e54b3005 	strb	r3, [fp, #-5]
		result = '\007';
		break;
	case 'x':
		result = 0;
		ch  = token_next_char(self);
		while ( (ch - '0')<16u )
1002e6c4:	e55b3005 	ldrb	r3, [fp, #-5]
1002e6c8:	e2433030 	sub	r3, r3, #48	; 0x30
1002e6cc:	e353000f 	cmp	r3, #15
1002e6d0:	9afffff1 	bls	1002e69c <token_proc_escape+0x10c>
		{
			result = result*16 + ch - '0';
			ch = token_next_char(self);
		}
		token_prev_char(self);
1002e6d4:	e51b0010 	ldr	r0, [fp, #-16]
1002e6d8:	ebfffd98 	bl	1002dd40 <token_prev_char>
		break;
1002e6dc:	ea000018 	b	1002e744 <token_proc_escape+0x1b4>
	default:
		if ( (ch - '0') < 8u)
1002e6e0:	e55b3005 	ldrb	r3, [fp, #-5]
1002e6e4:	e2433030 	sub	r3, r3, #48	; 0x30
1002e6e8:	e3530007 	cmp	r3, #7
1002e6ec:	8a000013 	bhi	1002e740 <token_proc_escape+0x1b0>
		{
			result = 0;
1002e6f0:	e3a03000 	mov	r3, #0
1002e6f4:	e50b300c 	str	r3, [fp, #-12]
			while ( (ch - '0') < 8u )
1002e6f8:	ea000009 	b	1002e724 <token_proc_escape+0x194>
			{
				result = result*8 + ch - '0';
1002e6fc:	e51b300c 	ldr	r3, [fp, #-12]
1002e700:	e1a02183 	lsl	r2, r3, #3
1002e704:	e55b3005 	ldrb	r3, [fp, #-5]
1002e708:	e0823003 	add	r3, r2, r3
1002e70c:	e2433030 	sub	r3, r3, #48	; 0x30
1002e710:	e50b300c 	str	r3, [fp, #-12]
				ch = token_next_char(self);
1002e714:	e51b0010 	ldr	r0, [fp, #-16]
1002e718:	ebfffd59 	bl	1002dc84 <token_next_char>
1002e71c:	e1a03000 	mov	r3, r0
1002e720:	e54b3005 	strb	r3, [fp, #-5]
		break;
	default:
		if ( (ch - '0') < 8u)
		{
			result = 0;
			while ( (ch - '0') < 8u )
1002e724:	e55b3005 	ldrb	r3, [fp, #-5]
1002e728:	e2433030 	sub	r3, r3, #48	; 0x30
1002e72c:	e3530007 	cmp	r3, #7
1002e730:	9afffff1 	bls	1002e6fc <token_proc_escape+0x16c>
			{
				result = result*8 + ch - '0';
				ch = token_next_char(self);
			}

			token_prev_char(self);
1002e734:	e51b0010 	ldr	r0, [fp, #-16]
1002e738:	ebfffd80 	bl	1002dd40 <token_prev_char>
		}
		break;
1002e73c:	eaffffff 	b	1002e740 <token_proc_escape+0x1b0>
1002e740:	e1a00000 	nop			; (mov r0, r0)
	}

	return result;
1002e744:	e51b300c 	ldr	r3, [fp, #-12]
}
1002e748:	e1a00003 	mov	r0, r3
1002e74c:	e24bd004 	sub	sp, fp, #4
1002e750:	e8bd8800 	pop	{fp, pc}

1002e754 <token_proc_number>:

/*
(0|0x|0X|0b|0B)number+(l|L)
*/
static void token_proc_number(struct finsh_token* self)
{
1002e754:	e92d4800 	push	{fp, lr}
1002e758:	e28db004 	add	fp, sp, #4
1002e75c:	e24dd098 	sub	sp, sp, #152	; 0x98
1002e760:	e50b0098 	str	r0, [fp, #-152]	; 0x98
	char ch;
	char *p, buf[128];
	long value;

	value = 0;
1002e764:	e3a03000 	mov	r3, #0
1002e768:	e50b3010 	str	r3, [fp, #-16]
	p = buf;
1002e76c:	e24b3094 	sub	r3, fp, #148	; 0x94
1002e770:	e50b300c 	str	r3, [fp, #-12]

	ch  = token_next_char(self);
1002e774:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e778:	ebfffd41 	bl	1002dc84 <token_next_char>
1002e77c:	e1a03000 	mov	r3, r0
1002e780:	e54b3005 	strb	r3, [fp, #-5]
	if ( ch == '0' )
1002e784:	e55b3005 	ldrb	r3, [fp, #-5]
1002e788:	e3530030 	cmp	r3, #48	; 0x30
1002e78c:	1a00007f 	bne	1002e990 <token_proc_number+0x23c>
	{
		int b;
		ch = token_next_char(self);
1002e790:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e794:	ebfffd3a 	bl	1002dc84 <token_next_char>
1002e798:	e1a03000 	mov	r3, r0
1002e79c:	e54b3005 	strb	r3, [fp, #-5]
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
1002e7a0:	e55b3005 	ldrb	r3, [fp, #-5]
1002e7a4:	e3530078 	cmp	r3, #120	; 0x78
1002e7a8:	0a000002 	beq	1002e7b8 <token_proc_number+0x64>
1002e7ac:	e55b3005 	ldrb	r3, [fp, #-5]
1002e7b0:	e3530058 	cmp	r3, #88	; 0x58
1002e7b4:	1a00001f 	bne	1002e838 <token_proc_number+0xe4>
		{
			b = 16;
1002e7b8:	e3a03010 	mov	r3, #16
1002e7bc:	e50b3014 	str	r3, [fp, #-20]
			ch = token_next_char(self);
1002e7c0:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e7c4:	ebfffd2e 	bl	1002dc84 <token_next_char>
1002e7c8:	e1a03000 	mov	r3, r0
1002e7cc:	e54b3005 	strb	r3, [fp, #-5]
			while ( is_digit(ch) || is_alpha(ch) )
1002e7d0:	ea000008 	b	1002e7f8 <token_proc_number+0xa4>
			{
				*p++ = ch;
1002e7d4:	e51b300c 	ldr	r3, [fp, #-12]
1002e7d8:	e2832001 	add	r2, r3, #1
1002e7dc:	e50b200c 	str	r2, [fp, #-12]
1002e7e0:	e55b2005 	ldrb	r2, [fp, #-5]
1002e7e4:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
1002e7e8:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e7ec:	ebfffd24 	bl	1002dc84 <token_next_char>
1002e7f0:	e1a03000 	mov	r3, r0
1002e7f4:	e54b3005 	strb	r3, [fp, #-5]
		ch = token_next_char(self);
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
		{
			b = 16;
			ch = token_next_char(self);
			while ( is_digit(ch) || is_alpha(ch) )
1002e7f8:	e55b3005 	ldrb	r3, [fp, #-5]
1002e7fc:	e353002f 	cmp	r3, #47	; 0x2f
1002e800:	9a000002 	bls	1002e810 <token_proc_number+0xbc>
1002e804:	e55b3005 	ldrb	r3, [fp, #-5]
1002e808:	e3530039 	cmp	r3, #57	; 0x39
1002e80c:	9afffff0 	bls	1002e7d4 <token_proc_number+0x80>
1002e810:	e55b3005 	ldrb	r3, [fp, #-5]
1002e814:	e3833020 	orr	r3, r3, #32
1002e818:	e6ef3073 	uxtb	r3, r3
1002e81c:	e2433061 	sub	r3, r3, #97	; 0x61
1002e820:	e3530019 	cmp	r3, #25
1002e824:	9affffea 	bls	1002e7d4 <token_proc_number+0x80>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
1002e828:	e51b300c 	ldr	r3, [fp, #-12]
1002e82c:	e3a02000 	mov	r2, #0
1002e830:	e5c32000 	strb	r2, [r3]
1002e834:	ea000044 	b	1002e94c <token_proc_number+0x1f8>
		}
		else if ( ch == 'b' || ch == 'B' )
1002e838:	e55b3005 	ldrb	r3, [fp, #-5]
1002e83c:	e3530062 	cmp	r3, #98	; 0x62
1002e840:	0a000002 	beq	1002e850 <token_proc_number+0xfc>
1002e844:	e55b3005 	ldrb	r3, [fp, #-5]
1002e848:	e3530042 	cmp	r3, #66	; 0x42
1002e84c:	1a000019 	bne	1002e8b8 <token_proc_number+0x164>
		{
			b = 2;
1002e850:	e3a03002 	mov	r3, #2
1002e854:	e50b3014 	str	r3, [fp, #-20]
			ch = token_next_char(self);
1002e858:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e85c:	ebfffd08 	bl	1002dc84 <token_next_char>
1002e860:	e1a03000 	mov	r3, r0
1002e864:	e54b3005 	strb	r3, [fp, #-5]
			while ( (ch=='0')||(ch=='1') )
1002e868:	ea000008 	b	1002e890 <token_proc_number+0x13c>
			{
				*p++ = ch;
1002e86c:	e51b300c 	ldr	r3, [fp, #-12]
1002e870:	e2832001 	add	r2, r3, #1
1002e874:	e50b200c 	str	r2, [fp, #-12]
1002e878:	e55b2005 	ldrb	r2, [fp, #-5]
1002e87c:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
1002e880:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e884:	ebfffcfe 	bl	1002dc84 <token_next_char>
1002e888:	e1a03000 	mov	r3, r0
1002e88c:	e54b3005 	strb	r3, [fp, #-5]
		}
		else if ( ch == 'b' || ch == 'B' )
		{
			b = 2;
			ch = token_next_char(self);
			while ( (ch=='0')||(ch=='1') )
1002e890:	e55b3005 	ldrb	r3, [fp, #-5]
1002e894:	e3530030 	cmp	r3, #48	; 0x30
1002e898:	0afffff3 	beq	1002e86c <token_proc_number+0x118>
1002e89c:	e55b3005 	ldrb	r3, [fp, #-5]
1002e8a0:	e3530031 	cmp	r3, #49	; 0x31
1002e8a4:	0afffff0 	beq	1002e86c <token_proc_number+0x118>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
1002e8a8:	e51b300c 	ldr	r3, [fp, #-12]
1002e8ac:	e3a02000 	mov	r2, #0
1002e8b0:	e5c32000 	strb	r2, [r3]
1002e8b4:	ea000024 	b	1002e94c <token_proc_number+0x1f8>
		}
		else if ( '0' <= ch && ch <= '7' )
1002e8b8:	e55b3005 	ldrb	r3, [fp, #-5]
1002e8bc:	e353002f 	cmp	r3, #47	; 0x2f
1002e8c0:	9a000018 	bls	1002e928 <token_proc_number+0x1d4>
1002e8c4:	e55b3005 	ldrb	r3, [fp, #-5]
1002e8c8:	e3530037 	cmp	r3, #55	; 0x37
1002e8cc:	8a000015 	bhi	1002e928 <token_proc_number+0x1d4>
		{
			b = 8;
1002e8d0:	e3a03008 	mov	r3, #8
1002e8d4:	e50b3014 	str	r3, [fp, #-20]
			while ( '0' <= ch && ch <= '7' )
1002e8d8:	ea000008 	b	1002e900 <token_proc_number+0x1ac>
			{
				*p++ = ch;
1002e8dc:	e51b300c 	ldr	r3, [fp, #-12]
1002e8e0:	e2832001 	add	r2, r3, #1
1002e8e4:	e50b200c 	str	r2, [fp, #-12]
1002e8e8:	e55b2005 	ldrb	r2, [fp, #-5]
1002e8ec:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
1002e8f0:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e8f4:	ebfffce2 	bl	1002dc84 <token_next_char>
1002e8f8:	e1a03000 	mov	r3, r0
1002e8fc:	e54b3005 	strb	r3, [fp, #-5]
			*p = '\0';
		}
		else if ( '0' <= ch && ch <= '7' )
		{
			b = 8;
			while ( '0' <= ch && ch <= '7' )
1002e900:	e55b3005 	ldrb	r3, [fp, #-5]
1002e904:	e353002f 	cmp	r3, #47	; 0x2f
1002e908:	9a000002 	bls	1002e918 <token_proc_number+0x1c4>
1002e90c:	e55b3005 	ldrb	r3, [fp, #-5]
1002e910:	e3530037 	cmp	r3, #55	; 0x37
1002e914:	9afffff0 	bls	1002e8dc <token_proc_number+0x188>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
1002e918:	e51b300c 	ldr	r3, [fp, #-12]
1002e91c:	e3a02000 	mov	r2, #0
1002e920:	e5c32000 	strb	r2, [r3]
1002e924:	ea000008 	b	1002e94c <token_proc_number+0x1f8>
		}
		else
		{
			token_prev_char(self);
1002e928:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e92c:	ebfffd03 	bl	1002dd40 <token_prev_char>

			/* made as 0 value */
			self->value.int_value = 0;
1002e930:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1002e934:	e3a02000 	mov	r2, #0
1002e938:	e583200c 	str	r2, [r3, #12]
			self->current_token = finsh_token_type_value_int;
1002e93c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1002e940:	e3a0201b 	mov	r2, #27
1002e944:	e5c32008 	strb	r2, [r3, #8]
			return;
1002e948:	ea000035 	b	1002ea24 <token_proc_number+0x2d0>
		}

		self->value.int_value = token_spec_number(buf, strlen(buf), b);
1002e94c:	e24b3094 	sub	r3, fp, #148	; 0x94
1002e950:	e1a00003 	mov	r0, r3
1002e954:	fa000393 	blx	1002f7a8 <strlen>
1002e958:	e1a03000 	mov	r3, r0
1002e95c:	e1a02003 	mov	r2, r3
1002e960:	e24b3094 	sub	r3, fp, #148	; 0x94
1002e964:	e1a00003 	mov	r0, r3
1002e968:	e1a01002 	mov	r1, r2
1002e96c:	e51b2014 	ldr	r2, [fp, #-20]
1002e970:	eb00002d 	bl	1002ea2c <token_spec_number>
1002e974:	e1a02000 	mov	r2, r0
1002e978:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1002e97c:	e583200c 	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
1002e980:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1002e984:	e3a0201b 	mov	r2, #27
1002e988:	e5c32008 	strb	r2, [r3, #8]
1002e98c:	ea000018 	b	1002e9f4 <token_proc_number+0x2a0>
	}
	else
	{
		while ( is_digit(ch) )
1002e990:	ea00000b 	b	1002e9c4 <token_proc_number+0x270>
		{
			value = value*10 + ( ch - '0' );
1002e994:	e51b3010 	ldr	r3, [fp, #-16]
1002e998:	e1a03083 	lsl	r3, r3, #1
1002e99c:	e1a02103 	lsl	r2, r3, #2
1002e9a0:	e0832002 	add	r2, r3, r2
1002e9a4:	e55b3005 	ldrb	r3, [fp, #-5]
1002e9a8:	e2433030 	sub	r3, r3, #48	; 0x30
1002e9ac:	e0823003 	add	r3, r2, r3
1002e9b0:	e50b3010 	str	r3, [fp, #-16]
			ch = token_next_char(self);
1002e9b4:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002e9b8:	ebfffcb1 	bl	1002dc84 <token_next_char>
1002e9bc:	e1a03000 	mov	r3, r0
1002e9c0:	e54b3005 	strb	r3, [fp, #-5]
		self->value.int_value = token_spec_number(buf, strlen(buf), b);
		self->current_token = finsh_token_type_value_int;
	}
	else
	{
		while ( is_digit(ch) )
1002e9c4:	e55b3005 	ldrb	r3, [fp, #-5]
1002e9c8:	e353002f 	cmp	r3, #47	; 0x2f
1002e9cc:	9a000002 	bls	1002e9dc <token_proc_number+0x288>
1002e9d0:	e55b3005 	ldrb	r3, [fp, #-5]
1002e9d4:	e3530039 	cmp	r3, #57	; 0x39
1002e9d8:	9affffed 	bls	1002e994 <token_proc_number+0x240>
		{
			value = value*10 + ( ch - '0' );
			ch = token_next_char(self);
		}

		self->value.int_value = value;
1002e9dc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1002e9e0:	e51b2010 	ldr	r2, [fp, #-16]
1002e9e4:	e583200c 	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
1002e9e8:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1002e9ec:	e3a0201b 	mov	r2, #27
1002e9f0:	e5c32008 	strb	r2, [r3, #8]
	}

	switch ( ch )
1002e9f4:	e55b3005 	ldrb	r3, [fp, #-5]
1002e9f8:	e353004c 	cmp	r3, #76	; 0x4c
1002e9fc:	0a000001 	beq	1002ea08 <token_proc_number+0x2b4>
1002ea00:	e353006c 	cmp	r3, #108	; 0x6c
1002ea04:	1a000003 	bne	1002ea18 <token_proc_number+0x2c4>
	{
	case 'l':
	case 'L':
		self->current_token = finsh_token_type_value_long;
1002ea08:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1002ea0c:	e3a0201c 	mov	r2, #28
1002ea10:	e5c32008 	strb	r2, [r3, #8]
		break;
1002ea14:	ea000002 	b	1002ea24 <token_proc_number+0x2d0>

	default:
		token_prev_char(self);
1002ea18:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1002ea1c:	ebfffcc7 	bl	1002dd40 <token_prev_char>
		break;
1002ea20:	e1a00000 	nop			; (mov r0, r0)
	}
}
1002ea24:	e24bd004 	sub	sp, fp, #4
1002ea28:	e8bd8800 	pop	{fp, pc}

1002ea2c <token_spec_number>:

/*use 64 bit number*/
#define BN_SIZE 2

static long token_spec_number(char* string, int length, int b)
{
1002ea2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1002ea30:	e28db000 	add	fp, sp, #0
1002ea34:	e24dd03c 	sub	sp, sp, #60	; 0x3c
1002ea38:	e50b0030 	str	r0, [fp, #-48]	; 0x30
1002ea3c:	e50b1034 	str	r1, [fp, #-52]	; 0x34
1002ea40:	e50b2038 	str	r2, [fp, #-56]	; 0x38
	char* p;
	int t;
	int i, j, shift=1;
1002ea44:	e3a03001 	mov	r3, #1
1002ea48:	e50b3018 	str	r3, [fp, #-24]
	unsigned int bn[BN_SIZE], v;
	long d;

	p = string;
1002ea4c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1002ea50:	e50b3008 	str	r3, [fp, #-8]
	i = 0;
1002ea54:	e3a03000 	mov	r3, #0
1002ea58:	e50b3010 	str	r3, [fp, #-16]

	switch ( b )
1002ea5c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1002ea60:	e3530008 	cmp	r3, #8
1002ea64:	0a000007 	beq	1002ea88 <token_spec_number+0x5c>
1002ea68:	e3530010 	cmp	r3, #16
1002ea6c:	0a000002 	beq	1002ea7c <token_spec_number+0x50>
1002ea70:	e3530002 	cmp	r3, #2
1002ea74:	0a000006 	beq	1002ea94 <token_spec_number+0x68>
		break;
	case 8:  shift = 3;
		break;
	case 2:  shift = 1;
		break;
	default: break;
1002ea78:	ea000008 	b	1002eaa0 <token_spec_number+0x74>
	p = string;
	i = 0;

	switch ( b )
	{
	case 16: shift = 4;
1002ea7c:	e3a03004 	mov	r3, #4
1002ea80:	e50b3018 	str	r3, [fp, #-24]
		break;
1002ea84:	ea000005 	b	1002eaa0 <token_spec_number+0x74>
	case 8:  shift = 3;
1002ea88:	e3a03003 	mov	r3, #3
1002ea8c:	e50b3018 	str	r3, [fp, #-24]
		break;
1002ea90:	ea000002 	b	1002eaa0 <token_spec_number+0x74>
	case 2:  shift = 1;
1002ea94:	e3a03001 	mov	r3, #1
1002ea98:	e50b3018 	str	r3, [fp, #-24]
		break;
1002ea9c:	e1a00000 	nop			; (mov r0, r0)
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;
1002eaa0:	e3a03000 	mov	r3, #0
1002eaa4:	e50b3014 	str	r3, [fp, #-20]
1002eaa8:	ea000008 	b	1002ead0 <token_spec_number+0xa4>
1002eaac:	e51b3014 	ldr	r3, [fp, #-20]
1002eab0:	e1a03103 	lsl	r3, r3, #2
1002eab4:	e24b2004 	sub	r2, fp, #4
1002eab8:	e0823003 	add	r3, r2, r3
1002eabc:	e3a02000 	mov	r2, #0
1002eac0:	e5032024 	str	r2, [r3, #-36]	; 0x24
1002eac4:	e51b3014 	ldr	r3, [fp, #-20]
1002eac8:	e2833001 	add	r3, r3, #1
1002eacc:	e50b3014 	str	r3, [fp, #-20]
1002ead0:	e51b3014 	ldr	r3, [fp, #-20]
1002ead4:	e3530001 	cmp	r3, #1
1002ead8:	dafffff3 	ble	1002eaac <token_spec_number+0x80>

	while ( i<length )
1002eadc:	ea00003c 	b	1002ebd4 <token_spec_number+0x1a8>
	{
		t = *p++;
1002eae0:	e51b3008 	ldr	r3, [fp, #-8]
1002eae4:	e2832001 	add	r2, r3, #1
1002eae8:	e50b2008 	str	r2, [fp, #-8]
1002eaec:	e5d33000 	ldrb	r3, [r3]
1002eaf0:	e50b300c 	str	r3, [fp, #-12]
		if ( t>='a' && t <='f' )
1002eaf4:	e51b300c 	ldr	r3, [fp, #-12]
1002eaf8:	e3530060 	cmp	r3, #96	; 0x60
1002eafc:	da000006 	ble	1002eb1c <token_spec_number+0xf0>
1002eb00:	e51b300c 	ldr	r3, [fp, #-12]
1002eb04:	e3530066 	cmp	r3, #102	; 0x66
1002eb08:	ca000003 	bgt	1002eb1c <token_spec_number+0xf0>
		{
			t = t - 'a' +10;
1002eb0c:	e51b300c 	ldr	r3, [fp, #-12]
1002eb10:	e2433057 	sub	r3, r3, #87	; 0x57
1002eb14:	e50b300c 	str	r3, [fp, #-12]
1002eb18:	ea00000c 	b	1002eb50 <token_spec_number+0x124>
		}
		else if ( t >='A' && t <='F' )
1002eb1c:	e51b300c 	ldr	r3, [fp, #-12]
1002eb20:	e3530040 	cmp	r3, #64	; 0x40
1002eb24:	da000006 	ble	1002eb44 <token_spec_number+0x118>
1002eb28:	e51b300c 	ldr	r3, [fp, #-12]
1002eb2c:	e3530046 	cmp	r3, #70	; 0x46
1002eb30:	ca000003 	bgt	1002eb44 <token_spec_number+0x118>
		{
			t = t - 'A' +10;
1002eb34:	e51b300c 	ldr	r3, [fp, #-12]
1002eb38:	e2433037 	sub	r3, r3, #55	; 0x37
1002eb3c:	e50b300c 	str	r3, [fp, #-12]
1002eb40:	ea000002 	b	1002eb50 <token_spec_number+0x124>
		}
		else t = t - '0';
1002eb44:	e51b300c 	ldr	r3, [fp, #-12]
1002eb48:	e2433030 	sub	r3, r3, #48	; 0x30
1002eb4c:	e50b300c 	str	r3, [fp, #-12]

		for ( j=0; j<BN_SIZE ; j++)
1002eb50:	e3a03000 	mov	r3, #0
1002eb54:	e50b3014 	str	r3, [fp, #-20]
1002eb58:	ea000017 	b	1002ebbc <token_spec_number+0x190>
		{
			v = bn[j];
1002eb5c:	e51b3014 	ldr	r3, [fp, #-20]
1002eb60:	e1a03103 	lsl	r3, r3, #2
1002eb64:	e24b2004 	sub	r2, fp, #4
1002eb68:	e0823003 	add	r3, r2, r3
1002eb6c:	e5133024 	ldr	r3, [r3, #-36]	; 0x24
1002eb70:	e50b301c 	str	r3, [fp, #-28]
			bn[j] = (v<<shift) | t;
1002eb74:	e51b201c 	ldr	r2, [fp, #-28]
1002eb78:	e51b3018 	ldr	r3, [fp, #-24]
1002eb7c:	e1a02312 	lsl	r2, r2, r3
1002eb80:	e51b300c 	ldr	r3, [fp, #-12]
1002eb84:	e1822003 	orr	r2, r2, r3
1002eb88:	e51b3014 	ldr	r3, [fp, #-20]
1002eb8c:	e1a03103 	lsl	r3, r3, #2
1002eb90:	e24b1004 	sub	r1, fp, #4
1002eb94:	e0813003 	add	r3, r1, r3
1002eb98:	e5032024 	str	r2, [r3, #-36]	; 0x24
			t = v >> (32 - shift);
1002eb9c:	e51b3018 	ldr	r3, [fp, #-24]
1002eba0:	e2633020 	rsb	r3, r3, #32
1002eba4:	e51b201c 	ldr	r2, [fp, #-28]
1002eba8:	e1a03332 	lsr	r3, r2, r3
1002ebac:	e50b300c 	str	r3, [fp, #-12]
		{
			t = t - 'A' +10;
		}
		else t = t - '0';

		for ( j=0; j<BN_SIZE ; j++)
1002ebb0:	e51b3014 	ldr	r3, [fp, #-20]
1002ebb4:	e2833001 	add	r3, r3, #1
1002ebb8:	e50b3014 	str	r3, [fp, #-20]
1002ebbc:	e51b3014 	ldr	r3, [fp, #-20]
1002ebc0:	e3530001 	cmp	r3, #1
1002ebc4:	daffffe4 	ble	1002eb5c <token_spec_number+0x130>
		{
			v = bn[j];
			bn[j] = (v<<shift) | t;
			t = v >> (32 - shift);
		}
		i++;
1002ebc8:	e51b3010 	ldr	r3, [fp, #-16]
1002ebcc:	e2833001 	add	r3, r3, #1
1002ebd0:	e50b3010 	str	r3, [fp, #-16]
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;

	while ( i<length )
1002ebd4:	e51b2010 	ldr	r2, [fp, #-16]
1002ebd8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1002ebdc:	e1520003 	cmp	r2, r3
1002ebe0:	baffffbe 	blt	1002eae0 <token_spec_number+0xb4>
			t = v >> (32 - shift);
		}
		i++;
	}

	d = (long)bn[0];
1002ebe4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1002ebe8:	e50b3020 	str	r3, [fp, #-32]

	return d;
1002ebec:	e51b3020 	ldr	r3, [fp, #-32]
}
1002ebf0:	e1a00003 	mov	r0, r3
1002ebf4:	e24bd000 	sub	sp, fp, #0
1002ebf8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1002ebfc:	e12fff1e 	bx	lr

1002ec00 <strcmp>:
1002ec00:	ea80 0c01 	eor.w	ip, r0, r1
1002ec04:	f01c 0f03 	tst.w	ip, #3
1002ec08:	d137      	bne.n	1002ec7a <strcmp+0x7a>
1002ec0a:	f010 0c03 	ands.w	ip, r0, #3
1002ec0e:	f020 0003 	bic.w	r0, r0, #3
1002ec12:	f021 0103 	bic.w	r1, r1, #3
1002ec16:	f850 2b04 	ldr.w	r2, [r0], #4
1002ec1a:	bf08      	it	eq
1002ec1c:	f851 3b04 	ldreq.w	r3, [r1], #4
1002ec20:	d00e      	beq.n	1002ec40 <strcmp+0x40>
1002ec22:	f08c 0c03 	eor.w	ip, ip, #3
1002ec26:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
1002ec2a:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
1002ec2e:	fa23 fc0c 	lsr.w	ip, r3, ip
1002ec32:	f851 3b04 	ldr.w	r3, [r1], #4
1002ec36:	ea42 020c 	orr.w	r2, r2, ip
1002ec3a:	ea43 030c 	orr.w	r3, r3, ip
1002ec3e:	bf00      	nop
1002ec40:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
1002ec44:	429a      	cmp	r2, r3
1002ec46:	bf01      	itttt	eq
1002ec48:	ea2c 0c02 	biceq.w	ip, ip, r2
1002ec4c:	f01c 3f80 	tsteq.w	ip, #2155905152	; 0x80808080
1002ec50:	f850 2b04 	ldreq.w	r2, [r0], #4
1002ec54:	f851 3b04 	ldreq.w	r3, [r1], #4
1002ec58:	d0f2      	beq.n	1002ec40 <strcmp+0x40>
1002ec5a:	ea4f 6002 	mov.w	r0, r2, lsl #24
1002ec5e:	ea4f 2212 	mov.w	r2, r2, lsr #8
1002ec62:	2801      	cmp	r0, #1
1002ec64:	bf28      	it	cs
1002ec66:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
1002ec6a:	bf08      	it	eq
1002ec6c:	0a1b      	lsreq	r3, r3, #8
1002ec6e:	d0f4      	beq.n	1002ec5a <strcmp+0x5a>
1002ec70:	f003 03ff 	and.w	r3, r3, #255	; 0xff
1002ec74:	0e00      	lsrs	r0, r0, #24
1002ec76:	1ac0      	subs	r0, r0, r3
1002ec78:	4770      	bx	lr
1002ec7a:	f010 0f03 	tst.w	r0, #3
1002ec7e:	d00a      	beq.n	1002ec96 <strcmp+0x96>
1002ec80:	f810 2b01 	ldrb.w	r2, [r0], #1
1002ec84:	f811 3b01 	ldrb.w	r3, [r1], #1
1002ec88:	2a01      	cmp	r2, #1
1002ec8a:	bf28      	it	cs
1002ec8c:	429a      	cmpcs	r2, r3
1002ec8e:	d0f4      	beq.n	1002ec7a <strcmp+0x7a>
1002ec90:	eba2 0003 	sub.w	r0, r2, r3
1002ec94:	4770      	bx	lr
1002ec96:	f84d 5d04 	str.w	r5, [sp, #-4]!
1002ec9a:	f850 2b04 	ldr.w	r2, [r0], #4
1002ec9e:	f001 0503 	and.w	r5, r1, #3
1002eca2:	f021 0103 	bic.w	r1, r1, #3
1002eca6:	f851 3b04 	ldr.w	r3, [r1], #4
1002ecaa:	2d02      	cmp	r5, #2
1002ecac:	d026      	beq.n	1002ecfc <strcmp+0xfc>
1002ecae:	d84d      	bhi.n	1002ed4c <strcmp+0x14c>
1002ecb0:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
1002ecb4:	ebb5 2f13 	cmp.w	r5, r3, lsr #8
1002ecb8:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
1002ecbc:	ea2c 0c02 	bic.w	ip, ip, r2
1002ecc0:	d10d      	bne.n	1002ecde <strcmp+0xde>
1002ecc2:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
1002ecc6:	bf08      	it	eq
1002ecc8:	f851 3b04 	ldreq.w	r3, [r1], #4
1002eccc:	d10a      	bne.n	1002ece4 <strcmp+0xe4>
1002ecce:	ea85 0502 	eor.w	r5, r5, r2
1002ecd2:	ebb5 6f03 	cmp.w	r5, r3, lsl #24
1002ecd6:	d10c      	bne.n	1002ecf2 <strcmp+0xf2>
1002ecd8:	f850 2b04 	ldr.w	r2, [r0], #4
1002ecdc:	e7e8      	b.n	1002ecb0 <strcmp+0xb0>
1002ecde:	ea4f 2313 	mov.w	r3, r3, lsr #8
1002ece2:	e05b      	b.n	1002ed9c <strcmp+0x19c>
1002ece4:	f03c 4c7f 	bics.w	ip, ip, #4278190080	; 0xff000000
1002ece8:	d154      	bne.n	1002ed94 <strcmp+0x194>
1002ecea:	780b      	ldrb	r3, [r1, #0]
1002ecec:	ea4f 6512 	mov.w	r5, r2, lsr #24
1002ecf0:	e054      	b.n	1002ed9c <strcmp+0x19c>
1002ecf2:	ea4f 6512 	mov.w	r5, r2, lsr #24
1002ecf6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
1002ecfa:	e04f      	b.n	1002ed9c <strcmp+0x19c>
1002ecfc:	ea4f 4502 	mov.w	r5, r2, lsl #16
1002ed00:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
1002ed04:	ea4f 4515 	mov.w	r5, r5, lsr #16
1002ed08:	ea2c 0c02 	bic.w	ip, ip, r2
1002ed0c:	ebb5 4f13 	cmp.w	r5, r3, lsr #16
1002ed10:	d118      	bne.n	1002ed44 <strcmp+0x144>
1002ed12:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
1002ed16:	bf08      	it	eq
1002ed18:	f851 3b04 	ldreq.w	r3, [r1], #4
1002ed1c:	d107      	bne.n	1002ed2e <strcmp+0x12e>
1002ed1e:	ea85 0502 	eor.w	r5, r5, r2
1002ed22:	ebb5 4f03 	cmp.w	r5, r3, lsl #16
1002ed26:	d109      	bne.n	1002ed3c <strcmp+0x13c>
1002ed28:	f850 2b04 	ldr.w	r2, [r0], #4
1002ed2c:	e7e6      	b.n	1002ecfc <strcmp+0xfc>
1002ed2e:	ea5f 4c0c 	movs.w	ip, ip, lsl #16
1002ed32:	d12f      	bne.n	1002ed94 <strcmp+0x194>
1002ed34:	880b      	ldrh	r3, [r1, #0]
1002ed36:	ea4f 4512 	mov.w	r5, r2, lsr #16
1002ed3a:	e02f      	b.n	1002ed9c <strcmp+0x19c>
1002ed3c:	ea4f 4303 	mov.w	r3, r3, lsl #16
1002ed40:	ea4f 4512 	mov.w	r5, r2, lsr #16
1002ed44:	ea4f 4313 	mov.w	r3, r3, lsr #16
1002ed48:	e028      	b.n	1002ed9c <strcmp+0x19c>
1002ed4a:	bf00      	nop
1002ed4c:	f002 05ff 	and.w	r5, r2, #255	; 0xff
1002ed50:	ebb5 6f13 	cmp.w	r5, r3, lsr #24
1002ed54:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
1002ed58:	ea2c 0c02 	bic.w	ip, ip, r2
1002ed5c:	d10d      	bne.n	1002ed7a <strcmp+0x17a>
1002ed5e:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
1002ed62:	bf08      	it	eq
1002ed64:	f851 3b04 	ldreq.w	r3, [r1], #4
1002ed68:	d10a      	bne.n	1002ed80 <strcmp+0x180>
1002ed6a:	ea85 0502 	eor.w	r5, r5, r2
1002ed6e:	ebb5 2f03 	cmp.w	r5, r3, lsl #8
1002ed72:	d10a      	bne.n	1002ed8a <strcmp+0x18a>
1002ed74:	f850 2b04 	ldr.w	r2, [r0], #4
1002ed78:	e7e8      	b.n	1002ed4c <strcmp+0x14c>
1002ed7a:	ea4f 6313 	mov.w	r3, r3, lsr #24
1002ed7e:	e00d      	b.n	1002ed9c <strcmp+0x19c>
1002ed80:	f012 0fff 	tst.w	r2, #255	; 0xff
1002ed84:	d006      	beq.n	1002ed94 <strcmp+0x194>
1002ed86:	f851 3b04 	ldr.w	r3, [r1], #4
1002ed8a:	ea4f 2512 	mov.w	r5, r2, lsr #8
1002ed8e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
1002ed92:	e003      	b.n	1002ed9c <strcmp+0x19c>
1002ed94:	f04f 0000 	mov.w	r0, #0
1002ed98:	bc20      	pop	{r5}
1002ed9a:	4770      	bx	lr
1002ed9c:	f005 02ff 	and.w	r2, r5, #255	; 0xff
1002eda0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
1002eda4:	2801      	cmp	r0, #1
1002eda6:	bf28      	it	cs
1002eda8:	4290      	cmpcs	r0, r2
1002edaa:	bf04      	itt	eq
1002edac:	0a2d      	lsreq	r5, r5, #8
1002edae:	0a1b      	lsreq	r3, r3, #8
1002edb0:	d0f4      	beq.n	1002ed9c <strcmp+0x19c>
1002edb2:	eba2 0000 	sub.w	r0, r2, r0
1002edb6:	bc20      	pop	{r5}
1002edb8:	4770      	bx	lr
1002edba:	bf00      	nop
1002edbc:	0000      	movs	r0, r0
	...

1002edc0 <__aeabi_uidiv>:
1002edc0:	1e4a      	subs	r2, r1, #1
1002edc2:	bf08      	it	eq
1002edc4:	4770      	bxeq	lr
1002edc6:	f0c0 8124 	bcc.w	1002f012 <__aeabi_uidiv+0x252>
1002edca:	4288      	cmp	r0, r1
1002edcc:	f240 8116 	bls.w	1002effc <__aeabi_uidiv+0x23c>
1002edd0:	4211      	tst	r1, r2
1002edd2:	f000 8117 	beq.w	1002f004 <__aeabi_uidiv+0x244>
1002edd6:	fab0 f380 	clz	r3, r0
1002edda:	fab1 f281 	clz	r2, r1
1002edde:	eba2 0303 	sub.w	r3, r2, r3
1002ede2:	f1c3 031f 	rsb	r3, r3, #31
1002ede6:	a204      	add	r2, pc, #16	; (adr r2, 1002edf8 <__aeabi_uidiv+0x38>)
1002ede8:	eb02 1303 	add.w	r3, r2, r3, lsl #4
1002edec:	f04f 0200 	mov.w	r2, #0
1002edf0:	469f      	mov	pc, r3
1002edf2:	bf00      	nop
1002edf4:	f3af 8000 	nop.w
1002edf8:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
1002edfc:	bf00      	nop
1002edfe:	eb42 0202 	adc.w	r2, r2, r2
1002ee02:	bf28      	it	cs
1002ee04:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
1002ee08:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
1002ee0c:	bf00      	nop
1002ee0e:	eb42 0202 	adc.w	r2, r2, r2
1002ee12:	bf28      	it	cs
1002ee14:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
1002ee18:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
1002ee1c:	bf00      	nop
1002ee1e:	eb42 0202 	adc.w	r2, r2, r2
1002ee22:	bf28      	it	cs
1002ee24:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
1002ee28:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
1002ee2c:	bf00      	nop
1002ee2e:	eb42 0202 	adc.w	r2, r2, r2
1002ee32:	bf28      	it	cs
1002ee34:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
1002ee38:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
1002ee3c:	bf00      	nop
1002ee3e:	eb42 0202 	adc.w	r2, r2, r2
1002ee42:	bf28      	it	cs
1002ee44:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
1002ee48:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
1002ee4c:	bf00      	nop
1002ee4e:	eb42 0202 	adc.w	r2, r2, r2
1002ee52:	bf28      	it	cs
1002ee54:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
1002ee58:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
1002ee5c:	bf00      	nop
1002ee5e:	eb42 0202 	adc.w	r2, r2, r2
1002ee62:	bf28      	it	cs
1002ee64:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
1002ee68:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
1002ee6c:	bf00      	nop
1002ee6e:	eb42 0202 	adc.w	r2, r2, r2
1002ee72:	bf28      	it	cs
1002ee74:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
1002ee78:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
1002ee7c:	bf00      	nop
1002ee7e:	eb42 0202 	adc.w	r2, r2, r2
1002ee82:	bf28      	it	cs
1002ee84:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
1002ee88:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
1002ee8c:	bf00      	nop
1002ee8e:	eb42 0202 	adc.w	r2, r2, r2
1002ee92:	bf28      	it	cs
1002ee94:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
1002ee98:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
1002ee9c:	bf00      	nop
1002ee9e:	eb42 0202 	adc.w	r2, r2, r2
1002eea2:	bf28      	it	cs
1002eea4:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
1002eea8:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
1002eeac:	bf00      	nop
1002eeae:	eb42 0202 	adc.w	r2, r2, r2
1002eeb2:	bf28      	it	cs
1002eeb4:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
1002eeb8:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
1002eebc:	bf00      	nop
1002eebe:	eb42 0202 	adc.w	r2, r2, r2
1002eec2:	bf28      	it	cs
1002eec4:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
1002eec8:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
1002eecc:	bf00      	nop
1002eece:	eb42 0202 	adc.w	r2, r2, r2
1002eed2:	bf28      	it	cs
1002eed4:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
1002eed8:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
1002eedc:	bf00      	nop
1002eede:	eb42 0202 	adc.w	r2, r2, r2
1002eee2:	bf28      	it	cs
1002eee4:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
1002eee8:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
1002eeec:	bf00      	nop
1002eeee:	eb42 0202 	adc.w	r2, r2, r2
1002eef2:	bf28      	it	cs
1002eef4:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
1002eef8:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
1002eefc:	bf00      	nop
1002eefe:	eb42 0202 	adc.w	r2, r2, r2
1002ef02:	bf28      	it	cs
1002ef04:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
1002ef08:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
1002ef0c:	bf00      	nop
1002ef0e:	eb42 0202 	adc.w	r2, r2, r2
1002ef12:	bf28      	it	cs
1002ef14:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
1002ef18:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
1002ef1c:	bf00      	nop
1002ef1e:	eb42 0202 	adc.w	r2, r2, r2
1002ef22:	bf28      	it	cs
1002ef24:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
1002ef28:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
1002ef2c:	bf00      	nop
1002ef2e:	eb42 0202 	adc.w	r2, r2, r2
1002ef32:	bf28      	it	cs
1002ef34:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
1002ef38:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
1002ef3c:	bf00      	nop
1002ef3e:	eb42 0202 	adc.w	r2, r2, r2
1002ef42:	bf28      	it	cs
1002ef44:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
1002ef48:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
1002ef4c:	bf00      	nop
1002ef4e:	eb42 0202 	adc.w	r2, r2, r2
1002ef52:	bf28      	it	cs
1002ef54:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
1002ef58:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
1002ef5c:	bf00      	nop
1002ef5e:	eb42 0202 	adc.w	r2, r2, r2
1002ef62:	bf28      	it	cs
1002ef64:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
1002ef68:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
1002ef6c:	bf00      	nop
1002ef6e:	eb42 0202 	adc.w	r2, r2, r2
1002ef72:	bf28      	it	cs
1002ef74:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
1002ef78:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
1002ef7c:	bf00      	nop
1002ef7e:	eb42 0202 	adc.w	r2, r2, r2
1002ef82:	bf28      	it	cs
1002ef84:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
1002ef88:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
1002ef8c:	bf00      	nop
1002ef8e:	eb42 0202 	adc.w	r2, r2, r2
1002ef92:	bf28      	it	cs
1002ef94:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
1002ef98:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
1002ef9c:	bf00      	nop
1002ef9e:	eb42 0202 	adc.w	r2, r2, r2
1002efa2:	bf28      	it	cs
1002efa4:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
1002efa8:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
1002efac:	bf00      	nop
1002efae:	eb42 0202 	adc.w	r2, r2, r2
1002efb2:	bf28      	it	cs
1002efb4:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
1002efb8:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
1002efbc:	bf00      	nop
1002efbe:	eb42 0202 	adc.w	r2, r2, r2
1002efc2:	bf28      	it	cs
1002efc4:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
1002efc8:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
1002efcc:	bf00      	nop
1002efce:	eb42 0202 	adc.w	r2, r2, r2
1002efd2:	bf28      	it	cs
1002efd4:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
1002efd8:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
1002efdc:	bf00      	nop
1002efde:	eb42 0202 	adc.w	r2, r2, r2
1002efe2:	bf28      	it	cs
1002efe4:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
1002efe8:	ebb0 0f01 	cmp.w	r0, r1
1002efec:	bf00      	nop
1002efee:	eb42 0202 	adc.w	r2, r2, r2
1002eff2:	bf28      	it	cs
1002eff4:	eba0 0001 	subcs.w	r0, r0, r1
1002eff8:	4610      	mov	r0, r2
1002effa:	4770      	bx	lr
1002effc:	bf0c      	ite	eq
1002effe:	2001      	moveq	r0, #1
1002f000:	2000      	movne	r0, #0
1002f002:	4770      	bx	lr
1002f004:	fab1 f281 	clz	r2, r1
1002f008:	f1c2 021f 	rsb	r2, r2, #31
1002f00c:	fa20 f002 	lsr.w	r0, r0, r2
1002f010:	4770      	bx	lr
1002f012:	b108      	cbz	r0, 1002f018 <__aeabi_uidiv+0x258>
1002f014:	f04f 30ff 	mov.w	r0, #4294967295
1002f018:	f000 b966 	b.w	1002f2e8 <__aeabi_idiv0>

1002f01c <__aeabi_uidivmod>:
1002f01c:	2900      	cmp	r1, #0
1002f01e:	d0f8      	beq.n	1002f012 <__aeabi_uidiv+0x252>
1002f020:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
1002f024:	f7ff fecc 	bl	1002edc0 <__aeabi_uidiv>
1002f028:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
1002f02c:	fb02 f300 	mul.w	r3, r2, r0
1002f030:	eba1 0103 	sub.w	r1, r1, r3
1002f034:	4770      	bx	lr
1002f036:	bf00      	nop

1002f038 <__aeabi_idiv>:
1002f038:	2900      	cmp	r1, #0
1002f03a:	f000 813e 	beq.w	1002f2ba <.divsi3_skip_div0_test+0x27c>

1002f03e <.divsi3_skip_div0_test>:
1002f03e:	ea80 0c01 	eor.w	ip, r0, r1
1002f042:	bf48      	it	mi
1002f044:	4249      	negmi	r1, r1
1002f046:	1e4a      	subs	r2, r1, #1
1002f048:	f000 811f 	beq.w	1002f28a <.divsi3_skip_div0_test+0x24c>
1002f04c:	0003      	movs	r3, r0
1002f04e:	bf48      	it	mi
1002f050:	4243      	negmi	r3, r0
1002f052:	428b      	cmp	r3, r1
1002f054:	f240 811e 	bls.w	1002f294 <.divsi3_skip_div0_test+0x256>
1002f058:	4211      	tst	r1, r2
1002f05a:	f000 8123 	beq.w	1002f2a4 <.divsi3_skip_div0_test+0x266>
1002f05e:	fab3 f283 	clz	r2, r3
1002f062:	fab1 f081 	clz	r0, r1
1002f066:	eba0 0202 	sub.w	r2, r0, r2
1002f06a:	f1c2 021f 	rsb	r2, r2, #31
1002f06e:	a004      	add	r0, pc, #16	; (adr r0, 1002f080 <.divsi3_skip_div0_test+0x42>)
1002f070:	eb00 1202 	add.w	r2, r0, r2, lsl #4
1002f074:	f04f 0000 	mov.w	r0, #0
1002f078:	4697      	mov	pc, r2
1002f07a:	bf00      	nop
1002f07c:	f3af 8000 	nop.w
1002f080:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
1002f084:	bf00      	nop
1002f086:	eb40 0000 	adc.w	r0, r0, r0
1002f08a:	bf28      	it	cs
1002f08c:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
1002f090:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
1002f094:	bf00      	nop
1002f096:	eb40 0000 	adc.w	r0, r0, r0
1002f09a:	bf28      	it	cs
1002f09c:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
1002f0a0:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
1002f0a4:	bf00      	nop
1002f0a6:	eb40 0000 	adc.w	r0, r0, r0
1002f0aa:	bf28      	it	cs
1002f0ac:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
1002f0b0:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
1002f0b4:	bf00      	nop
1002f0b6:	eb40 0000 	adc.w	r0, r0, r0
1002f0ba:	bf28      	it	cs
1002f0bc:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
1002f0c0:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
1002f0c4:	bf00      	nop
1002f0c6:	eb40 0000 	adc.w	r0, r0, r0
1002f0ca:	bf28      	it	cs
1002f0cc:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
1002f0d0:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
1002f0d4:	bf00      	nop
1002f0d6:	eb40 0000 	adc.w	r0, r0, r0
1002f0da:	bf28      	it	cs
1002f0dc:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
1002f0e0:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
1002f0e4:	bf00      	nop
1002f0e6:	eb40 0000 	adc.w	r0, r0, r0
1002f0ea:	bf28      	it	cs
1002f0ec:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
1002f0f0:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
1002f0f4:	bf00      	nop
1002f0f6:	eb40 0000 	adc.w	r0, r0, r0
1002f0fa:	bf28      	it	cs
1002f0fc:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
1002f100:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
1002f104:	bf00      	nop
1002f106:	eb40 0000 	adc.w	r0, r0, r0
1002f10a:	bf28      	it	cs
1002f10c:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
1002f110:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
1002f114:	bf00      	nop
1002f116:	eb40 0000 	adc.w	r0, r0, r0
1002f11a:	bf28      	it	cs
1002f11c:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
1002f120:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
1002f124:	bf00      	nop
1002f126:	eb40 0000 	adc.w	r0, r0, r0
1002f12a:	bf28      	it	cs
1002f12c:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
1002f130:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
1002f134:	bf00      	nop
1002f136:	eb40 0000 	adc.w	r0, r0, r0
1002f13a:	bf28      	it	cs
1002f13c:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
1002f140:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
1002f144:	bf00      	nop
1002f146:	eb40 0000 	adc.w	r0, r0, r0
1002f14a:	bf28      	it	cs
1002f14c:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
1002f150:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
1002f154:	bf00      	nop
1002f156:	eb40 0000 	adc.w	r0, r0, r0
1002f15a:	bf28      	it	cs
1002f15c:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
1002f160:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
1002f164:	bf00      	nop
1002f166:	eb40 0000 	adc.w	r0, r0, r0
1002f16a:	bf28      	it	cs
1002f16c:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
1002f170:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
1002f174:	bf00      	nop
1002f176:	eb40 0000 	adc.w	r0, r0, r0
1002f17a:	bf28      	it	cs
1002f17c:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
1002f180:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
1002f184:	bf00      	nop
1002f186:	eb40 0000 	adc.w	r0, r0, r0
1002f18a:	bf28      	it	cs
1002f18c:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
1002f190:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
1002f194:	bf00      	nop
1002f196:	eb40 0000 	adc.w	r0, r0, r0
1002f19a:	bf28      	it	cs
1002f19c:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
1002f1a0:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
1002f1a4:	bf00      	nop
1002f1a6:	eb40 0000 	adc.w	r0, r0, r0
1002f1aa:	bf28      	it	cs
1002f1ac:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
1002f1b0:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
1002f1b4:	bf00      	nop
1002f1b6:	eb40 0000 	adc.w	r0, r0, r0
1002f1ba:	bf28      	it	cs
1002f1bc:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
1002f1c0:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
1002f1c4:	bf00      	nop
1002f1c6:	eb40 0000 	adc.w	r0, r0, r0
1002f1ca:	bf28      	it	cs
1002f1cc:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
1002f1d0:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
1002f1d4:	bf00      	nop
1002f1d6:	eb40 0000 	adc.w	r0, r0, r0
1002f1da:	bf28      	it	cs
1002f1dc:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
1002f1e0:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
1002f1e4:	bf00      	nop
1002f1e6:	eb40 0000 	adc.w	r0, r0, r0
1002f1ea:	bf28      	it	cs
1002f1ec:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
1002f1f0:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
1002f1f4:	bf00      	nop
1002f1f6:	eb40 0000 	adc.w	r0, r0, r0
1002f1fa:	bf28      	it	cs
1002f1fc:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
1002f200:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
1002f204:	bf00      	nop
1002f206:	eb40 0000 	adc.w	r0, r0, r0
1002f20a:	bf28      	it	cs
1002f20c:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
1002f210:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
1002f214:	bf00      	nop
1002f216:	eb40 0000 	adc.w	r0, r0, r0
1002f21a:	bf28      	it	cs
1002f21c:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
1002f220:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
1002f224:	bf00      	nop
1002f226:	eb40 0000 	adc.w	r0, r0, r0
1002f22a:	bf28      	it	cs
1002f22c:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
1002f230:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
1002f234:	bf00      	nop
1002f236:	eb40 0000 	adc.w	r0, r0, r0
1002f23a:	bf28      	it	cs
1002f23c:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
1002f240:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
1002f244:	bf00      	nop
1002f246:	eb40 0000 	adc.w	r0, r0, r0
1002f24a:	bf28      	it	cs
1002f24c:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
1002f250:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
1002f254:	bf00      	nop
1002f256:	eb40 0000 	adc.w	r0, r0, r0
1002f25a:	bf28      	it	cs
1002f25c:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
1002f260:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
1002f264:	bf00      	nop
1002f266:	eb40 0000 	adc.w	r0, r0, r0
1002f26a:	bf28      	it	cs
1002f26c:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
1002f270:	ebb3 0f01 	cmp.w	r3, r1
1002f274:	bf00      	nop
1002f276:	eb40 0000 	adc.w	r0, r0, r0
1002f27a:	bf28      	it	cs
1002f27c:	eba3 0301 	subcs.w	r3, r3, r1
1002f280:	f1bc 0f00 	cmp.w	ip, #0
1002f284:	bf48      	it	mi
1002f286:	4240      	negmi	r0, r0
1002f288:	4770      	bx	lr
1002f28a:	ea9c 0f00 	teq	ip, r0
1002f28e:	bf48      	it	mi
1002f290:	4240      	negmi	r0, r0
1002f292:	4770      	bx	lr
1002f294:	bf38      	it	cc
1002f296:	2000      	movcc	r0, #0
1002f298:	bf04      	itt	eq
1002f29a:	ea4f 70ec 	moveq.w	r0, ip, asr #31
1002f29e:	f040 0001 	orreq.w	r0, r0, #1
1002f2a2:	4770      	bx	lr
1002f2a4:	fab1 f281 	clz	r2, r1
1002f2a8:	f1c2 021f 	rsb	r2, r2, #31
1002f2ac:	f1bc 0f00 	cmp.w	ip, #0
1002f2b0:	fa23 f002 	lsr.w	r0, r3, r2
1002f2b4:	bf48      	it	mi
1002f2b6:	4240      	negmi	r0, r0
1002f2b8:	4770      	bx	lr
1002f2ba:	2800      	cmp	r0, #0
1002f2bc:	bfc8      	it	gt
1002f2be:	f06f 4000 	mvngt.w	r0, #2147483648	; 0x80000000
1002f2c2:	bfb8      	it	lt
1002f2c4:	f04f 4000 	movlt.w	r0, #2147483648	; 0x80000000
1002f2c8:	f000 b80e 	b.w	1002f2e8 <__aeabi_idiv0>

1002f2cc <__aeabi_idivmod>:
1002f2cc:	2900      	cmp	r1, #0
1002f2ce:	d0f4      	beq.n	1002f2ba <.divsi3_skip_div0_test+0x27c>
1002f2d0:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
1002f2d4:	f7ff feb3 	bl	1002f03e <.divsi3_skip_div0_test>
1002f2d8:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
1002f2dc:	fb02 f300 	mul.w	r3, r2, r0
1002f2e0:	eba1 0103 	sub.w	r1, r1, r3
1002f2e4:	4770      	bx	lr
1002f2e6:	bf00      	nop

1002f2e8 <__aeabi_idiv0>:
1002f2e8:	4770      	bx	lr
1002f2ea:	bf00      	nop

1002f2ec <atoi>:
1002f2ec:	2100      	movs	r1, #0
1002f2ee:	220a      	movs	r2, #10
1002f2f0:	f000 bbaa 	b.w	1002fa48 <strtol>

1002f2f4 <memcpy>:
1002f2f4:	2a0f      	cmp	r2, #15
1002f2f6:	b5f0      	push	{r4, r5, r6, r7, lr}
1002f2f8:	d949      	bls.n	1002f38e <memcpy+0x9a>
1002f2fa:	ea40 0301 	orr.w	r3, r0, r1
1002f2fe:	079b      	lsls	r3, r3, #30
1002f300:	d148      	bne.n	1002f394 <memcpy+0xa0>
1002f302:	f100 0410 	add.w	r4, r0, #16
1002f306:	f101 0310 	add.w	r3, r1, #16
1002f30a:	4615      	mov	r5, r2
1002f30c:	f853 6c10 	ldr.w	r6, [r3, #-16]
1002f310:	3d10      	subs	r5, #16
1002f312:	2d0f      	cmp	r5, #15
1002f314:	f103 0310 	add.w	r3, r3, #16
1002f318:	f104 0410 	add.w	r4, r4, #16
1002f31c:	f844 6c20 	str.w	r6, [r4, #-32]
1002f320:	f853 6c1c 	ldr.w	r6, [r3, #-28]
1002f324:	f844 6c1c 	str.w	r6, [r4, #-28]
1002f328:	f853 6c18 	ldr.w	r6, [r3, #-24]
1002f32c:	f844 6c18 	str.w	r6, [r4, #-24]
1002f330:	f853 6c14 	ldr.w	r6, [r3, #-20]
1002f334:	f844 6c14 	str.w	r6, [r4, #-20]
1002f338:	d8e8      	bhi.n	1002f30c <memcpy+0x18>
1002f33a:	f1a2 0310 	sub.w	r3, r2, #16
1002f33e:	f002 0e0f 	and.w	lr, r2, #15
1002f342:	f023 030f 	bic.w	r3, r3, #15
1002f346:	f1be 0f03 	cmp.w	lr, #3
1002f34a:	f103 0310 	add.w	r3, r3, #16
1002f34e:	4419      	add	r1, r3
1002f350:	4403      	add	r3, r0
1002f352:	d921      	bls.n	1002f398 <memcpy+0xa4>
1002f354:	1f1e      	subs	r6, r3, #4
1002f356:	460d      	mov	r5, r1
1002f358:	4674      	mov	r4, lr
1002f35a:	f855 7b04 	ldr.w	r7, [r5], #4
1002f35e:	3c04      	subs	r4, #4
1002f360:	2c03      	cmp	r4, #3
1002f362:	f846 7f04 	str.w	r7, [r6, #4]!
1002f366:	d8f8      	bhi.n	1002f35a <memcpy+0x66>
1002f368:	f1ae 0404 	sub.w	r4, lr, #4
1002f36c:	f002 0203 	and.w	r2, r2, #3
1002f370:	f024 0403 	bic.w	r4, r4, #3
1002f374:	3404      	adds	r4, #4
1002f376:	4423      	add	r3, r4
1002f378:	4421      	add	r1, r4
1002f37a:	b152      	cbz	r2, 1002f392 <memcpy+0x9e>
1002f37c:	3b01      	subs	r3, #1
1002f37e:	440a      	add	r2, r1
1002f380:	f811 4b01 	ldrb.w	r4, [r1], #1
1002f384:	4291      	cmp	r1, r2
1002f386:	f803 4f01 	strb.w	r4, [r3, #1]!
1002f38a:	d1f9      	bne.n	1002f380 <memcpy+0x8c>
1002f38c:	bdf0      	pop	{r4, r5, r6, r7, pc}
1002f38e:	4603      	mov	r3, r0
1002f390:	e7f3      	b.n	1002f37a <memcpy+0x86>
1002f392:	bdf0      	pop	{r4, r5, r6, r7, pc}
1002f394:	4603      	mov	r3, r0
1002f396:	e7f1      	b.n	1002f37c <memcpy+0x88>
1002f398:	4672      	mov	r2, lr
1002f39a:	e7ee      	b.n	1002f37a <memcpy+0x86>

1002f39c <memset>:
1002f39c:	0783      	lsls	r3, r0, #30
1002f39e:	b470      	push	{r4, r5, r6}
1002f3a0:	d04a      	beq.n	1002f438 <memset+0x9c>
1002f3a2:	1e54      	subs	r4, r2, #1
1002f3a4:	2a00      	cmp	r2, #0
1002f3a6:	d045      	beq.n	1002f434 <memset+0x98>
1002f3a8:	b2cd      	uxtb	r5, r1
1002f3aa:	4603      	mov	r3, r0
1002f3ac:	e002      	b.n	1002f3b4 <memset+0x18>
1002f3ae:	2c00      	cmp	r4, #0
1002f3b0:	d040      	beq.n	1002f434 <memset+0x98>
1002f3b2:	4614      	mov	r4, r2
1002f3b4:	f803 5b01 	strb.w	r5, [r3], #1
1002f3b8:	f013 0f03 	tst.w	r3, #3
1002f3bc:	f104 32ff 	add.w	r2, r4, #4294967295
1002f3c0:	d1f5      	bne.n	1002f3ae <memset+0x12>
1002f3c2:	2c03      	cmp	r4, #3
1002f3c4:	d92f      	bls.n	1002f426 <memset+0x8a>
1002f3c6:	b2cd      	uxtb	r5, r1
1002f3c8:	2c0f      	cmp	r4, #15
1002f3ca:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
1002f3ce:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
1002f3d2:	d91a      	bls.n	1002f40a <memset+0x6e>
1002f3d4:	f103 0210 	add.w	r2, r3, #16
1002f3d8:	4626      	mov	r6, r4
1002f3da:	3e10      	subs	r6, #16
1002f3dc:	f842 5c10 	str.w	r5, [r2, #-16]
1002f3e0:	2e0f      	cmp	r6, #15
1002f3e2:	f842 5c0c 	str.w	r5, [r2, #-12]
1002f3e6:	f842 5c08 	str.w	r5, [r2, #-8]
1002f3ea:	f102 0210 	add.w	r2, r2, #16
1002f3ee:	f842 5c14 	str.w	r5, [r2, #-20]
1002f3f2:	d8f2      	bhi.n	1002f3da <memset+0x3e>
1002f3f4:	f1a4 0210 	sub.w	r2, r4, #16
1002f3f8:	f004 040f 	and.w	r4, r4, #15
1002f3fc:	f022 020f 	bic.w	r2, r2, #15
1002f400:	2c03      	cmp	r4, #3
1002f402:	f102 0210 	add.w	r2, r2, #16
1002f406:	4413      	add	r3, r2
1002f408:	d90d      	bls.n	1002f426 <memset+0x8a>
1002f40a:	461e      	mov	r6, r3
1002f40c:	4622      	mov	r2, r4
1002f40e:	3a04      	subs	r2, #4
1002f410:	f846 5b04 	str.w	r5, [r6], #4
1002f414:	2a03      	cmp	r2, #3
1002f416:	d8fa      	bhi.n	1002f40e <memset+0x72>
1002f418:	1f22      	subs	r2, r4, #4
1002f41a:	f004 0403 	and.w	r4, r4, #3
1002f41e:	f022 0203 	bic.w	r2, r2, #3
1002f422:	3204      	adds	r2, #4
1002f424:	4413      	add	r3, r2
1002f426:	b12c      	cbz	r4, 1002f434 <memset+0x98>
1002f428:	b2c9      	uxtb	r1, r1
1002f42a:	441c      	add	r4, r3
1002f42c:	f803 1b01 	strb.w	r1, [r3], #1
1002f430:	42a3      	cmp	r3, r4
1002f432:	d1fb      	bne.n	1002f42c <memset+0x90>
1002f434:	bc70      	pop	{r4, r5, r6}
1002f436:	4770      	bx	lr
1002f438:	4614      	mov	r4, r2
1002f43a:	4603      	mov	r3, r0
1002f43c:	e7c1      	b.n	1002f3c2 <memset+0x26>
1002f43e:	bf00      	nop

1002f440 <putenv>:
1002f440:	f646 53b8 	movw	r3, #28088	; 0x6db8
1002f444:	4601      	mov	r1, r0
1002f446:	f2c1 0303 	movt	r3, #4099	; 0x1003
1002f44a:	6818      	ldr	r0, [r3, #0]
1002f44c:	f000 b800 	b.w	1002f450 <_putenv_r>

1002f450 <_putenv_r>:
1002f450:	b570      	push	{r4, r5, r6, lr}
1002f452:	4606      	mov	r6, r0
1002f454:	f000 f994 	bl	1002f780 <_strdup_r>
1002f458:	b1a0      	cbz	r0, 1002f484 <_putenv_r+0x34>
1002f45a:	213d      	movs	r1, #61	; 0x3d
1002f45c:	4605      	mov	r5, r0
1002f45e:	f000 f919 	bl	1002f694 <strchr>
1002f462:	b188      	cbz	r0, 1002f488 <_putenv_r+0x38>
1002f464:	4602      	mov	r2, r0
1002f466:	4629      	mov	r1, r5
1002f468:	2300      	movs	r3, #0
1002f46a:	4630      	mov	r0, r6
1002f46c:	f802 3b01 	strb.w	r3, [r2], #1
1002f470:	2301      	movs	r3, #1
1002f472:	f000 f84b 	bl	1002f50c <_setenv_r>
1002f476:	4629      	mov	r1, r5
1002f478:	4604      	mov	r4, r0
1002f47a:	4630      	mov	r0, r6
1002f47c:	f7f0 efe4 	blx	10020448 <_free_r>
1002f480:	4620      	mov	r0, r4
1002f482:	bd70      	pop	{r4, r5, r6, pc}
1002f484:	2001      	movs	r0, #1
1002f486:	bd70      	pop	{r4, r5, r6, pc}
1002f488:	4630      	mov	r0, r6
1002f48a:	4629      	mov	r1, r5
1002f48c:	f7f0 efdc 	blx	10020448 <_free_r>
1002f490:	2001      	movs	r0, #1
1002f492:	bd70      	pop	{r4, r5, r6, pc}

1002f494 <_puts_r>:
1002f494:	b530      	push	{r4, r5, lr}
1002f496:	4605      	mov	r5, r0
1002f498:	b089      	sub	sp, #36	; 0x24
1002f49a:	4608      	mov	r0, r1
1002f49c:	460c      	mov	r4, r1
1002f49e:	f000 f983 	bl	1002f7a8 <strlen>
1002f4a2:	6baa      	ldr	r2, [r5, #56]	; 0x38
1002f4a4:	f246 33e0 	movw	r3, #25568	; 0x63e0
1002f4a8:	f2c1 0303 	movt	r3, #4099	; 0x1003
1002f4ac:	9404      	str	r4, [sp, #16]
1002f4ae:	9306      	str	r3, [sp, #24]
1002f4b0:	2302      	movs	r3, #2
1002f4b2:	68ac      	ldr	r4, [r5, #8]
1002f4b4:	9302      	str	r3, [sp, #8]
1002f4b6:	1c41      	adds	r1, r0, #1
1002f4b8:	9005      	str	r0, [sp, #20]
1002f4ba:	9103      	str	r1, [sp, #12]
1002f4bc:	2001      	movs	r0, #1
1002f4be:	a904      	add	r1, sp, #16
1002f4c0:	9007      	str	r0, [sp, #28]
1002f4c2:	9101      	str	r1, [sp, #4]
1002f4c4:	b1b2      	cbz	r2, 1002f4f4 <_puts_r+0x60>
1002f4c6:	89a3      	ldrh	r3, [r4, #12]
1002f4c8:	4628      	mov	r0, r5
1002f4ca:	4621      	mov	r1, r4
1002f4cc:	049a      	lsls	r2, r3, #18
1002f4ce:	bf5f      	itttt	pl
1002f4d0:	f443 5300 	orrpl.w	r3, r3, #8192	; 0x2000
1002f4d4:	81a3      	strhpl	r3, [r4, #12]
1002f4d6:	6e62      	ldrpl	r2, [r4, #100]	; 0x64
1002f4d8:	f422 5200 	bicpl.w	r2, r2, #8192	; 0x2000
1002f4dc:	bf58      	it	pl
1002f4de:	6662      	strpl	r2, [r4, #100]	; 0x64
1002f4e0:	aa01      	add	r2, sp, #4
1002f4e2:	f000 fb53 	bl	1002fb8c <__sfvwrite_r>
1002f4e6:	2800      	cmp	r0, #0
1002f4e8:	bf14      	ite	ne
1002f4ea:	f04f 30ff 	movne.w	r0, #4294967295
1002f4ee:	200a      	moveq	r0, #10
1002f4f0:	b009      	add	sp, #36	; 0x24
1002f4f2:	bd30      	pop	{r4, r5, pc}
1002f4f4:	4628      	mov	r0, r5
1002f4f6:	f000 fb3f 	bl	1002fb78 <__sinit>
1002f4fa:	e7e4      	b.n	1002f4c6 <_puts_r+0x32>

1002f4fc <puts>:
1002f4fc:	f646 53b8 	movw	r3, #28088	; 0x6db8
1002f500:	4601      	mov	r1, r0
1002f502:	f2c1 0303 	movt	r3, #4099	; 0x1003
1002f506:	6818      	ldr	r0, [r3, #0]
1002f508:	f7ff bfc4 	b.w	1002f494 <_puts_r>

1002f50c <_setenv_r>:
1002f50c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1002f510:	460e      	mov	r6, r1
1002f512:	b083      	sub	sp, #12
1002f514:	4605      	mov	r5, r0
1002f516:	213d      	movs	r1, #61	; 0x3d
1002f518:	4630      	mov	r0, r6
1002f51a:	4614      	mov	r4, r2
1002f51c:	461f      	mov	r7, r3
1002f51e:	f000 f8b9 	bl	1002f694 <strchr>
1002f522:	2800      	cmp	r0, #0
1002f524:	d168      	bne.n	1002f5f8 <_setenv_r+0xec>
1002f526:	4628      	mov	r0, r5
1002f528:	f000 fa9c 	bl	1002fa64 <__env_lock>
1002f52c:	4620      	mov	r0, r4
1002f52e:	f000 f93b 	bl	1002f7a8 <strlen>
1002f532:	4631      	mov	r1, r6
1002f534:	aa01      	add	r2, sp, #4
1002f536:	4680      	mov	r8, r0
1002f538:	4628      	mov	r0, r5
1002f53a:	f000 fcdb 	bl	1002fef4 <_findenv_r>
1002f53e:	4682      	mov	sl, r0
1002f540:	2800      	cmp	r0, #0
1002f542:	d063      	beq.n	1002f60c <_setenv_r+0x100>
1002f544:	2f00      	cmp	r7, #0
1002f546:	d046      	beq.n	1002f5d6 <_setenv_r+0xca>
1002f548:	f000 f92e 	bl	1002f7a8 <strlen>
1002f54c:	4580      	cmp	r8, r0
1002f54e:	d94a      	bls.n	1002f5e6 <_setenv_r+0xda>
1002f550:	9f01      	ldr	r7, [sp, #4]
1002f552:	f646 59bc 	movw	r9, #28092	; 0x6dbc
1002f556:	f2c1 0903 	movt	r9, #4099	; 0x1003
1002f55a:	00bf      	lsls	r7, r7, #2
1002f55c:	7831      	ldrb	r1, [r6, #0]
1002f55e:	293d      	cmp	r1, #61	; 0x3d
1002f560:	bf18      	it	ne
1002f562:	2900      	cmpne	r1, #0
1002f564:	bf14      	ite	ne
1002f566:	2101      	movne	r1, #1
1002f568:	2100      	moveq	r1, #0
1002f56a:	d007      	beq.n	1002f57c <_setenv_r+0x70>
1002f56c:	4631      	mov	r1, r6
1002f56e:	f811 3f01 	ldrb.w	r3, [r1, #1]!
1002f572:	2b3d      	cmp	r3, #61	; 0x3d
1002f574:	bf18      	it	ne
1002f576:	2b00      	cmpne	r3, #0
1002f578:	d1f9      	bne.n	1002f56e <_setenv_r+0x62>
1002f57a:	1b89      	subs	r1, r1, r6
1002f57c:	4441      	add	r1, r8
1002f57e:	4628      	mov	r0, r5
1002f580:	3102      	adds	r1, #2
1002f582:	f8d9 8000 	ldr.w	r8, [r9]
1002f586:	f7f0 eeec 	blx	10020360 <_malloc_r>
1002f58a:	f646 53bc 	movw	r3, #28092	; 0x6dbc
1002f58e:	f2c1 0303 	movt	r3, #4099	; 0x1003
1002f592:	f848 0007 	str.w	r0, [r8, r7]
1002f596:	2800      	cmp	r0, #0
1002f598:	d076      	beq.n	1002f688 <_setenv_r+0x17c>
1002f59a:	681a      	ldr	r2, [r3, #0]
1002f59c:	1c71      	adds	r1, r6, #1
1002f59e:	9801      	ldr	r0, [sp, #4]
1002f5a0:	7833      	ldrb	r3, [r6, #0]
1002f5a2:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
1002f5a6:	2b00      	cmp	r3, #0
1002f5a8:	bf18      	it	ne
1002f5aa:	2b3d      	cmpne	r3, #61	; 0x3d
1002f5ac:	7003      	strb	r3, [r0, #0]
1002f5ae:	d009      	beq.n	1002f5c4 <_setenv_r+0xb8>
1002f5b0:	1c42      	adds	r2, r0, #1
1002f5b2:	f811 3b01 	ldrb.w	r3, [r1], #1
1002f5b6:	4610      	mov	r0, r2
1002f5b8:	2b00      	cmp	r3, #0
1002f5ba:	bf18      	it	ne
1002f5bc:	2b3d      	cmpne	r3, #61	; 0x3d
1002f5be:	f802 3b01 	strb.w	r3, [r2], #1
1002f5c2:	d1f6      	bne.n	1002f5b2 <_setenv_r+0xa6>
1002f5c4:	4602      	mov	r2, r0
1002f5c6:	233d      	movs	r3, #61	; 0x3d
1002f5c8:	7003      	strb	r3, [r0, #0]
1002f5ca:	f814 3b01 	ldrb.w	r3, [r4], #1
1002f5ce:	f802 3f01 	strb.w	r3, [r2, #1]!
1002f5d2:	2b00      	cmp	r3, #0
1002f5d4:	d1f9      	bne.n	1002f5ca <_setenv_r+0xbe>
1002f5d6:	4628      	mov	r0, r5
1002f5d8:	f000 fa46 	bl	1002fa68 <__env_unlock>
1002f5dc:	2300      	movs	r3, #0
1002f5de:	4618      	mov	r0, r3
1002f5e0:	b003      	add	sp, #12
1002f5e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1002f5e6:	f10a 30ff 	add.w	r0, sl, #4294967295
1002f5ea:	f814 3b01 	ldrb.w	r3, [r4], #1
1002f5ee:	f800 3f01 	strb.w	r3, [r0, #1]!
1002f5f2:	2b00      	cmp	r3, #0
1002f5f4:	d1f9      	bne.n	1002f5ea <_setenv_r+0xde>
1002f5f6:	e7ee      	b.n	1002f5d6 <_setenv_r+0xca>
1002f5f8:	f7d9 ebb6 	blx	10008d68 <__errno>
1002f5fc:	f04f 33ff 	mov.w	r3, #4294967295
1002f600:	2216      	movs	r2, #22
1002f602:	6002      	str	r2, [r0, #0]
1002f604:	4618      	mov	r0, r3
1002f606:	b003      	add	sp, #12
1002f608:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1002f60c:	f646 59bc 	movw	r9, #28092	; 0x6dbc
1002f610:	f2c1 0903 	movt	r9, #4099	; 0x1003
1002f614:	f8d9 1000 	ldr.w	r1, [r9]
1002f618:	6808      	ldr	r0, [r1, #0]
1002f61a:	b390      	cbz	r0, 1002f682 <_setenv_r+0x176>
1002f61c:	460b      	mov	r3, r1
1002f61e:	f853 2f04 	ldr.w	r2, [r3, #4]!
1002f622:	f10a 0a01 	add.w	sl, sl, #1
1002f626:	2a00      	cmp	r2, #0
1002f628:	d1f9      	bne.n	1002f61e <_setenv_r+0x112>
1002f62a:	f10a 0202 	add.w	r2, sl, #2
1002f62e:	0092      	lsls	r2, r2, #2
1002f630:	f64f 1354 	movw	r3, #63828	; 0xf954
1002f634:	f2c1 0303 	movt	r3, #4099	; 0x1003
1002f638:	6818      	ldr	r0, [r3, #0]
1002f63a:	b178      	cbz	r0, 1002f65c <_setenv_r+0x150>
1002f63c:	4628      	mov	r0, r5
1002f63e:	f7f0 eeb4 	blx	100203a8 <_realloc_r>
1002f642:	f8c9 0000 	str.w	r0, [r9]
1002f646:	b1f8      	cbz	r0, 1002f688 <_setenv_r+0x17c>
1002f648:	ea4f 078a 	mov.w	r7, sl, lsl #2
1002f64c:	f10a 0301 	add.w	r3, sl, #1
1002f650:	2200      	movs	r2, #0
1002f652:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
1002f656:	f8cd a004 	str.w	sl, [sp, #4]
1002f65a:	e77f      	b.n	1002f55c <_setenv_r+0x50>
1002f65c:	4611      	mov	r1, r2
1002f65e:	4628      	mov	r0, r5
1002f660:	2201      	movs	r2, #1
1002f662:	601a      	str	r2, [r3, #0]
1002f664:	f7f0 ee7c 	blx	10020360 <_malloc_r>
1002f668:	4683      	mov	fp, r0
1002f66a:	b168      	cbz	r0, 1002f688 <_setenv_r+0x17c>
1002f66c:	ea4f 078a 	mov.w	r7, sl, lsl #2
1002f670:	f8d9 1000 	ldr.w	r1, [r9]
1002f674:	463a      	mov	r2, r7
1002f676:	f7ff fe3d 	bl	1002f2f4 <memcpy>
1002f67a:	4658      	mov	r0, fp
1002f67c:	f8c9 b000 	str.w	fp, [r9]
1002f680:	e7e4      	b.n	1002f64c <_setenv_r+0x140>
1002f682:	4682      	mov	sl, r0
1002f684:	2208      	movs	r2, #8
1002f686:	e7d3      	b.n	1002f630 <_setenv_r+0x124>
1002f688:	4628      	mov	r0, r5
1002f68a:	f000 f9ed 	bl	1002fa68 <__env_unlock>
1002f68e:	f04f 33ff 	mov.w	r3, #4294967295
1002f692:	e7a4      	b.n	1002f5de <_setenv_r+0xd2>

1002f694 <strchr>:
1002f694:	b2c9      	uxtb	r1, r1
1002f696:	b470      	push	{r4, r5, r6}
1002f698:	2900      	cmp	r1, #0
1002f69a:	d040      	beq.n	1002f71e <strchr+0x8a>
1002f69c:	0784      	lsls	r4, r0, #30
1002f69e:	d010      	beq.n	1002f6c2 <strchr+0x2e>
1002f6a0:	7803      	ldrb	r3, [r0, #0]
1002f6a2:	2b00      	cmp	r3, #0
1002f6a4:	d068      	beq.n	1002f778 <strchr+0xe4>
1002f6a6:	4299      	cmp	r1, r3
1002f6a8:	bf18      	it	ne
1002f6aa:	1c43      	addne	r3, r0, #1
1002f6ac:	d106      	bne.n	1002f6bc <strchr+0x28>
1002f6ae:	e034      	b.n	1002f71a <strchr+0x86>
1002f6b0:	f813 2b01 	ldrb.w	r2, [r3], #1
1002f6b4:	2a00      	cmp	r2, #0
1002f6b6:	d05c      	beq.n	1002f772 <strchr+0xde>
1002f6b8:	4291      	cmp	r1, r2
1002f6ba:	d02e      	beq.n	1002f71a <strchr+0x86>
1002f6bc:	079a      	lsls	r2, r3, #30
1002f6be:	4618      	mov	r0, r3
1002f6c0:	d1f6      	bne.n	1002f6b0 <strchr+0x1c>
1002f6c2:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
1002f6c6:	6804      	ldr	r4, [r0, #0]
1002f6c8:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
1002f6cc:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
1002f6d0:	ea84 0506 	eor.w	r5, r4, r6
1002f6d4:	ea22 0204 	bic.w	r2, r2, r4
1002f6d8:	f1a5 3301 	sub.w	r3, r5, #16843009	; 0x1010101
1002f6dc:	ea23 0305 	bic.w	r3, r3, r5
1002f6e0:	4313      	orrs	r3, r2
1002f6e2:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1002f6e6:	d10f      	bne.n	1002f708 <strchr+0x74>
1002f6e8:	f850 5f04 	ldr.w	r5, [r0, #4]!
1002f6ec:	ea86 0305 	eor.w	r3, r6, r5
1002f6f0:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
1002f6f4:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
1002f6f8:	ea22 0205 	bic.w	r2, r2, r5
1002f6fc:	ea24 0303 	bic.w	r3, r4, r3
1002f700:	4313      	orrs	r3, r2
1002f702:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1002f706:	d0ef      	beq.n	1002f6e8 <strchr+0x54>
1002f708:	7803      	ldrb	r3, [r0, #0]
1002f70a:	b923      	cbnz	r3, 1002f716 <strchr+0x82>
1002f70c:	e034      	b.n	1002f778 <strchr+0xe4>
1002f70e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
1002f712:	2b00      	cmp	r3, #0
1002f714:	d030      	beq.n	1002f778 <strchr+0xe4>
1002f716:	4299      	cmp	r1, r3
1002f718:	d1f9      	bne.n	1002f70e <strchr+0x7a>
1002f71a:	bc70      	pop	{r4, r5, r6}
1002f71c:	4770      	bx	lr
1002f71e:	0781      	lsls	r1, r0, #30
1002f720:	d00d      	beq.n	1002f73e <strchr+0xaa>
1002f722:	7803      	ldrb	r3, [r0, #0]
1002f724:	2b00      	cmp	r3, #0
1002f726:	d0f8      	beq.n	1002f71a <strchr+0x86>
1002f728:	1c43      	adds	r3, r0, #1
1002f72a:	e002      	b.n	1002f732 <strchr+0x9e>
1002f72c:	7802      	ldrb	r2, [r0, #0]
1002f72e:	2a00      	cmp	r2, #0
1002f730:	d0f3      	beq.n	1002f71a <strchr+0x86>
1002f732:	f013 0f03 	tst.w	r3, #3
1002f736:	4618      	mov	r0, r3
1002f738:	f103 0301 	add.w	r3, r3, #1
1002f73c:	d1f6      	bne.n	1002f72c <strchr+0x98>
1002f73e:	6802      	ldr	r2, [r0, #0]
1002f740:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
1002f744:	ea23 0302 	bic.w	r3, r3, r2
1002f748:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1002f74c:	d108      	bne.n	1002f760 <strchr+0xcc>
1002f74e:	f850 2f04 	ldr.w	r2, [r0, #4]!
1002f752:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
1002f756:	ea23 0302 	bic.w	r3, r3, r2
1002f75a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1002f75e:	d0f6      	beq.n	1002f74e <strchr+0xba>
1002f760:	7803      	ldrb	r3, [r0, #0]
1002f762:	2b00      	cmp	r3, #0
1002f764:	d0d9      	beq.n	1002f71a <strchr+0x86>
1002f766:	f810 3f01 	ldrb.w	r3, [r0, #1]!
1002f76a:	2b00      	cmp	r3, #0
1002f76c:	d1fb      	bne.n	1002f766 <strchr+0xd2>
1002f76e:	bc70      	pop	{r4, r5, r6}
1002f770:	4770      	bx	lr
1002f772:	4610      	mov	r0, r2
1002f774:	bc70      	pop	{r4, r5, r6}
1002f776:	4770      	bx	lr
1002f778:	4618      	mov	r0, r3
1002f77a:	bc70      	pop	{r4, r5, r6}
1002f77c:	4770      	bx	lr
1002f77e:	bf00      	nop

1002f780 <_strdup_r>:
1002f780:	b570      	push	{r4, r5, r6, lr}
1002f782:	4606      	mov	r6, r0
1002f784:	4608      	mov	r0, r1
1002f786:	460d      	mov	r5, r1
1002f788:	f000 f80e 	bl	1002f7a8 <strlen>
1002f78c:	1c44      	adds	r4, r0, #1
1002f78e:	4630      	mov	r0, r6
1002f790:	4621      	mov	r1, r4
1002f792:	f7f0 ede6 	blx	10020360 <_malloc_r>
1002f796:	4606      	mov	r6, r0
1002f798:	b118      	cbz	r0, 1002f7a2 <_strdup_r+0x22>
1002f79a:	4629      	mov	r1, r5
1002f79c:	4622      	mov	r2, r4
1002f79e:	f7ff fda9 	bl	1002f2f4 <memcpy>
1002f7a2:	4630      	mov	r0, r6
1002f7a4:	bd70      	pop	{r4, r5, r6, pc}
1002f7a6:	bf00      	nop

1002f7a8 <strlen>:
1002f7a8:	f020 0103 	bic.w	r1, r0, #3
1002f7ac:	f010 0003 	ands.w	r0, r0, #3
1002f7b0:	f1c0 0000 	rsb	r0, r0, #0
1002f7b4:	f851 3b04 	ldr.w	r3, [r1], #4
1002f7b8:	f100 0c04 	add.w	ip, r0, #4
1002f7bc:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
1002f7c0:	f06f 0200 	mvn.w	r2, #0
1002f7c4:	bf1c      	itt	ne
1002f7c6:	fa22 f20c 	lsrne.w	r2, r2, ip
1002f7ca:	4313      	orrne	r3, r2
1002f7cc:	f04f 0c01 	mov.w	ip, #1
1002f7d0:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
1002f7d4:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
1002f7d8:	eba3 020c 	sub.w	r2, r3, ip
1002f7dc:	ea22 0203 	bic.w	r2, r2, r3
1002f7e0:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
1002f7e4:	bf04      	itt	eq
1002f7e6:	f851 3b04 	ldreq.w	r3, [r1], #4
1002f7ea:	3004      	addeq	r0, #4
1002f7ec:	d0f4      	beq.n	1002f7d8 <strlen+0x30>
1002f7ee:	f1c2 0100 	rsb	r1, r2, #0
1002f7f2:	ea02 0201 	and.w	r2, r2, r1
1002f7f6:	fab2 f282 	clz	r2, r2
1002f7fa:	f1c2 021f 	rsb	r2, r2, #31
1002f7fe:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
1002f802:	4770      	bx	lr

1002f804 <strncmp>:
1002f804:	2a00      	cmp	r2, #0
1002f806:	d03f      	beq.n	1002f888 <strncmp+0x84>
1002f808:	ea40 0301 	orr.w	r3, r0, r1
1002f80c:	f013 0303 	ands.w	r3, r3, #3
1002f810:	b4f0      	push	{r4, r5, r6, r7}
1002f812:	d125      	bne.n	1002f860 <strncmp+0x5c>
1002f814:	2a03      	cmp	r2, #3
1002f816:	d923      	bls.n	1002f860 <strncmp+0x5c>
1002f818:	6804      	ldr	r4, [r0, #0]
1002f81a:	680d      	ldr	r5, [r1, #0]
1002f81c:	42ac      	cmp	r4, r5
1002f81e:	d11f      	bne.n	1002f860 <strncmp+0x5c>
1002f820:	3a04      	subs	r2, #4
1002f822:	d036      	beq.n	1002f892 <strncmp+0x8e>
1002f824:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
1002f828:	ea25 0404 	bic.w	r4, r5, r4
1002f82c:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
1002f830:	d131      	bne.n	1002f896 <strncmp+0x92>
1002f832:	1d07      	adds	r7, r0, #4
1002f834:	1d0d      	adds	r5, r1, #4
1002f836:	e00d      	b.n	1002f854 <strncmp+0x50>
1002f838:	f857 3b04 	ldr.w	r3, [r7], #4
1002f83c:	680e      	ldr	r6, [r1, #0]
1002f83e:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
1002f842:	42b3      	cmp	r3, r6
1002f844:	ea24 0403 	bic.w	r4, r4, r3
1002f848:	d10a      	bne.n	1002f860 <strncmp+0x5c>
1002f84a:	3a04      	subs	r2, #4
1002f84c:	d021      	beq.n	1002f892 <strncmp+0x8e>
1002f84e:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
1002f852:	d116      	bne.n	1002f882 <strncmp+0x7e>
1002f854:	2a03      	cmp	r2, #3
1002f856:	4629      	mov	r1, r5
1002f858:	4638      	mov	r0, r7
1002f85a:	f105 0504 	add.w	r5, r5, #4
1002f85e:	d8eb      	bhi.n	1002f838 <strncmp+0x34>
1002f860:	7803      	ldrb	r3, [r0, #0]
1002f862:	3a01      	subs	r2, #1
1002f864:	780c      	ldrb	r4, [r1, #0]
1002f866:	42a3      	cmp	r3, r4
1002f868:	d007      	beq.n	1002f87a <strncmp+0x76>
1002f86a:	e00f      	b.n	1002f88c <strncmp+0x88>
1002f86c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
1002f870:	3a01      	subs	r2, #1
1002f872:	f811 4f01 	ldrb.w	r4, [r1, #1]!
1002f876:	42a3      	cmp	r3, r4
1002f878:	d108      	bne.n	1002f88c <strncmp+0x88>
1002f87a:	2a00      	cmp	r2, #0
1002f87c:	bf18      	it	ne
1002f87e:	2b00      	cmpne	r3, #0
1002f880:	d1f4      	bne.n	1002f86c <strncmp+0x68>
1002f882:	2000      	movs	r0, #0
1002f884:	bcf0      	pop	{r4, r5, r6, r7}
1002f886:	4770      	bx	lr
1002f888:	4610      	mov	r0, r2
1002f88a:	4770      	bx	lr
1002f88c:	1b18      	subs	r0, r3, r4
1002f88e:	bcf0      	pop	{r4, r5, r6, r7}
1002f890:	4770      	bx	lr
1002f892:	4610      	mov	r0, r2
1002f894:	e7fb      	b.n	1002f88e <strncmp+0x8a>
1002f896:	4618      	mov	r0, r3
1002f898:	e7f9      	b.n	1002f88e <strncmp+0x8a>
1002f89a:	bf00      	nop

1002f89c <strncpy>:
1002f89c:	ea40 0301 	orr.w	r3, r0, r1
1002f8a0:	f013 0f03 	tst.w	r3, #3
1002f8a4:	b470      	push	{r4, r5, r6}
1002f8a6:	bf0c      	ite	eq
1002f8a8:	2301      	moveq	r3, #1
1002f8aa:	2300      	movne	r3, #0
1002f8ac:	2a03      	cmp	r2, #3
1002f8ae:	bf94      	ite	ls
1002f8b0:	2300      	movls	r3, #0
1002f8b2:	f003 0301 	andhi.w	r3, r3, #1
1002f8b6:	4606      	mov	r6, r0
1002f8b8:	b18b      	cbz	r3, 1002f8de <strncpy+0x42>
1002f8ba:	460b      	mov	r3, r1
1002f8bc:	4606      	mov	r6, r0
1002f8be:	4619      	mov	r1, r3
1002f8c0:	f853 5b04 	ldr.w	r5, [r3], #4
1002f8c4:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
1002f8c8:	ea24 0405 	bic.w	r4, r4, r5
1002f8cc:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
1002f8d0:	d105      	bne.n	1002f8de <strncpy+0x42>
1002f8d2:	3a04      	subs	r2, #4
1002f8d4:	f846 5b04 	str.w	r5, [r6], #4
1002f8d8:	2a03      	cmp	r2, #3
1002f8da:	4619      	mov	r1, r3
1002f8dc:	d8ef      	bhi.n	1002f8be <strncpy+0x22>
1002f8de:	b1a2      	cbz	r2, 1002f90a <strncpy+0x6e>
1002f8e0:	780c      	ldrb	r4, [r1, #0]
1002f8e2:	3a01      	subs	r2, #1
1002f8e4:	1c73      	adds	r3, r6, #1
1002f8e6:	3101      	adds	r1, #1
1002f8e8:	7034      	strb	r4, [r6, #0]
1002f8ea:	b13c      	cbz	r4, 1002f8fc <strncpy+0x60>
1002f8ec:	b16a      	cbz	r2, 1002f90a <strncpy+0x6e>
1002f8ee:	f811 4b01 	ldrb.w	r4, [r1], #1
1002f8f2:	3a01      	subs	r2, #1
1002f8f4:	f803 4b01 	strb.w	r4, [r3], #1
1002f8f8:	2c00      	cmp	r4, #0
1002f8fa:	d1f7      	bne.n	1002f8ec <strncpy+0x50>
1002f8fc:	b12a      	cbz	r2, 1002f90a <strncpy+0x6e>
1002f8fe:	441a      	add	r2, r3
1002f900:	2100      	movs	r1, #0
1002f902:	f803 1b01 	strb.w	r1, [r3], #1
1002f906:	4293      	cmp	r3, r2
1002f908:	d1fb      	bne.n	1002f902 <strncpy+0x66>
1002f90a:	bc70      	pop	{r4, r5, r6}
1002f90c:	4770      	bx	lr
1002f90e:	bf00      	nop

1002f910 <_strtol_r>:
1002f910:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1002f914:	f646 1488 	movw	r4, #27016	; 0x6988
1002f918:	b085      	sub	sp, #20
1002f91a:	f2c1 0403 	movt	r4, #4099	; 0x1003
1002f91e:	468b      	mov	fp, r1
1002f920:	461f      	mov	r7, r3
1002f922:	9003      	str	r0, [sp, #12]
1002f924:	6826      	ldr	r6, [r4, #0]
1002f926:	e000      	b.n	1002f92a <_strtol_r+0x1a>
1002f928:	4621      	mov	r1, r4
1002f92a:	460c      	mov	r4, r1
1002f92c:	f814 5b01 	ldrb.w	r5, [r4], #1
1002f930:	1973      	adds	r3, r6, r5
1002f932:	785b      	ldrb	r3, [r3, #1]
1002f934:	f003 0308 	and.w	r3, r3, #8
1002f938:	f003 08ff 	and.w	r8, r3, #255	; 0xff
1002f93c:	2b00      	cmp	r3, #0
1002f93e:	d1f3      	bne.n	1002f928 <_strtol_r+0x18>
1002f940:	2d2d      	cmp	r5, #45	; 0x2d
1002f942:	d071      	beq.n	1002fa28 <_strtol_r+0x118>
1002f944:	2d2b      	cmp	r5, #43	; 0x2b
1002f946:	bf04      	itt	eq
1002f948:	1c8c      	addeq	r4, r1, #2
1002f94a:	784d      	ldrbeq	r5, [r1, #1]
1002f94c:	f037 0310 	bics.w	r3, r7, #16
1002f950:	d10b      	bne.n	1002f96a <_strtol_r+0x5a>
1002f952:	fab7 f387 	clz	r3, r7
1002f956:	2d30      	cmp	r5, #48	; 0x30
1002f958:	ea4f 1353 	mov.w	r3, r3, lsr #5
1002f95c:	d069      	beq.n	1002fa32 <_strtol_r+0x122>
1002f95e:	b123      	cbz	r3, 1002f96a <_strtol_r+0x5a>
1002f960:	270a      	movs	r7, #10
1002f962:	46ba      	mov	sl, r7
1002f964:	e002      	b.n	1002f96c <_strtol_r+0x5c>
1002f966:	b103      	cbz	r3, 1002f96a <_strtol_r+0x5a>
1002f968:	2708      	movs	r7, #8
1002f96a:	46ba      	mov	sl, r7
1002f96c:	f1b8 0f00 	cmp.w	r8, #0
1002f970:	4651      	mov	r1, sl
1002f972:	9202      	str	r2, [sp, #8]
1002f974:	bf14      	ite	ne
1002f976:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
1002f97a:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
1002f97e:	4660      	mov	r0, ip
1002f980:	f8cd c004 	str.w	ip, [sp, #4]
1002f984:	f7ff fb4a 	bl	1002f01c <__aeabi_uidivmod>
1002f988:	f8dd c004 	ldr.w	ip, [sp, #4]
1002f98c:	4660      	mov	r0, ip
1002f98e:	4689      	mov	r9, r1
1002f990:	4651      	mov	r1, sl
1002f992:	f7ff fa15 	bl	1002edc0 <__aeabi_uidiv>
1002f996:	2300      	movs	r3, #0
1002f998:	469c      	mov	ip, r3
1002f99a:	9a02      	ldr	r2, [sp, #8]
1002f99c:	e00c      	b.n	1002f9b8 <_strtol_r+0xa8>
1002f99e:	454d      	cmp	r5, r9
1002f9a0:	bfd4      	ite	le
1002f9a2:	2100      	movle	r1, #0
1002f9a4:	2101      	movgt	r1, #1
1002f9a6:	4584      	cmp	ip, r0
1002f9a8:	bf18      	it	ne
1002f9aa:	2100      	movne	r1, #0
1002f9ac:	b9e1      	cbnz	r1, 1002f9e8 <_strtol_r+0xd8>
1002f9ae:	fb0a 5c0c 	mla	ip, sl, ip, r5
1002f9b2:	2301      	movs	r3, #1
1002f9b4:	f814 5b01 	ldrb.w	r5, [r4], #1
1002f9b8:	1971      	adds	r1, r6, r5
1002f9ba:	7849      	ldrb	r1, [r1, #1]
1002f9bc:	f011 0f04 	tst.w	r1, #4
1002f9c0:	bf18      	it	ne
1002f9c2:	3d30      	subne	r5, #48	; 0x30
1002f9c4:	d107      	bne.n	1002f9d6 <_strtol_r+0xc6>
1002f9c6:	f011 0103 	ands.w	r1, r1, #3
1002f9ca:	d010      	beq.n	1002f9ee <_strtol_r+0xde>
1002f9cc:	2901      	cmp	r1, #1
1002f9ce:	bf0c      	ite	eq
1002f9d0:	2137      	moveq	r1, #55	; 0x37
1002f9d2:	2157      	movne	r1, #87	; 0x57
1002f9d4:	1a6d      	subs	r5, r5, r1
1002f9d6:	42af      	cmp	r7, r5
1002f9d8:	dd09      	ble.n	1002f9ee <_strtol_r+0xde>
1002f9da:	4584      	cmp	ip, r0
1002f9dc:	bf94      	ite	ls
1002f9de:	2100      	movls	r1, #0
1002f9e0:	2101      	movhi	r1, #1
1002f9e2:	ea51 73d3 	orrs.w	r3, r1, r3, lsr #31
1002f9e6:	d0da      	beq.n	1002f99e <_strtol_r+0x8e>
1002f9e8:	f04f 33ff 	mov.w	r3, #4294967295
1002f9ec:	e7e2      	b.n	1002f9b4 <_strtol_r+0xa4>
1002f9ee:	1c59      	adds	r1, r3, #1
1002f9f0:	d00b      	beq.n	1002fa0a <_strtol_r+0xfa>
1002f9f2:	f1c8 0000 	rsb	r0, r8, #0
1002f9f6:	ea8c 0000 	eor.w	r0, ip, r0
1002f9fa:	4440      	add	r0, r8
1002f9fc:	b112      	cbz	r2, 1002fa04 <_strtol_r+0xf4>
1002f9fe:	b98b      	cbnz	r3, 1002fa24 <_strtol_r+0x114>
1002fa00:	465c      	mov	r4, fp
1002fa02:	6014      	str	r4, [r2, #0]
1002fa04:	b005      	add	sp, #20
1002fa06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1002fa0a:	9903      	ldr	r1, [sp, #12]
1002fa0c:	f1b8 0f00 	cmp.w	r8, #0
1002fa10:	f04f 0322 	mov.w	r3, #34	; 0x22
1002fa14:	bf14      	ite	ne
1002fa16:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
1002fa1a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
1002fa1e:	600b      	str	r3, [r1, #0]
1002fa20:	2a00      	cmp	r2, #0
1002fa22:	d0ef      	beq.n	1002fa04 <_strtol_r+0xf4>
1002fa24:	3c01      	subs	r4, #1
1002fa26:	e7ec      	b.n	1002fa02 <_strtol_r+0xf2>
1002fa28:	1c8c      	adds	r4, r1, #2
1002fa2a:	784d      	ldrb	r5, [r1, #1]
1002fa2c:	f04f 0801 	mov.w	r8, #1
1002fa30:	e78c      	b.n	1002f94c <_strtol_r+0x3c>
1002fa32:	7821      	ldrb	r1, [r4, #0]
1002fa34:	f001 01df 	and.w	r1, r1, #223	; 0xdf
1002fa38:	2958      	cmp	r1, #88	; 0x58
1002fa3a:	d194      	bne.n	1002f966 <_strtol_r+0x56>
1002fa3c:	2710      	movs	r7, #16
1002fa3e:	7865      	ldrb	r5, [r4, #1]
1002fa40:	46ba      	mov	sl, r7
1002fa42:	3402      	adds	r4, #2
1002fa44:	e792      	b.n	1002f96c <_strtol_r+0x5c>
1002fa46:	bf00      	nop

1002fa48 <strtol>:
1002fa48:	b430      	push	{r4, r5}
1002fa4a:	f646 54b8 	movw	r4, #28088	; 0x6db8
1002fa4e:	460d      	mov	r5, r1
1002fa50:	f2c1 0403 	movt	r4, #4099	; 0x1003
1002fa54:	4613      	mov	r3, r2
1002fa56:	4601      	mov	r1, r0
1002fa58:	462a      	mov	r2, r5
1002fa5a:	6820      	ldr	r0, [r4, #0]
1002fa5c:	bc30      	pop	{r4, r5}
1002fa5e:	f7ff bf57 	b.w	1002f910 <_strtol_r>
1002fa62:	bf00      	nop

1002fa64 <__env_lock>:
1002fa64:	4770      	bx	lr
1002fa66:	bf00      	nop

1002fa68 <__env_unlock>:
1002fa68:	4770      	bx	lr
1002fa6a:	bf00      	nop

1002fa6c <_cleanup_r>:
1002fa6c:	f240 2119 	movw	r1, #537	; 0x219
1002fa70:	f2c1 0103 	movt	r1, #4099	; 0x1003
1002fa74:	f000 ba16 	b.w	1002fea4 <_fwalk_reent>

1002fa78 <__sinit.part.1>:
1002fa78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1002fa7c:	f64f 236d 	movw	r3, #64109	; 0xfa6d
1002fa80:	6845      	ldr	r5, [r0, #4]
1002fa82:	2400      	movs	r4, #0
1002fa84:	4607      	mov	r7, r0
1002fa86:	b083      	sub	sp, #12
1002fa88:	f500 723b 	add.w	r2, r0, #748	; 0x2ec
1002fa8c:	f2c1 0302 	movt	r3, #4098	; 0x1002
1002fa90:	f8c0 22e8 	str.w	r2, [r0, #744]	; 0x2e8
1002fa94:	2103      	movs	r1, #3
1002fa96:	63c3      	str	r3, [r0, #60]	; 0x3c
1002fa98:	2208      	movs	r2, #8
1002fa9a:	f8c0 12e4 	str.w	r1, [r0, #740]	; 0x2e4
1002fa9e:	2304      	movs	r3, #4
1002faa0:	f8c7 42e0 	str.w	r4, [r7, #736]	; 0x2e0
1002faa4:	4621      	mov	r1, r4
1002faa6:	602c      	str	r4, [r5, #0]
1002faa8:	f105 005c 	add.w	r0, r5, #92	; 0x5c
1002faac:	606c      	str	r4, [r5, #4]
1002faae:	f240 0bd1 	movw	fp, #209	; 0xd1
1002fab2:	60ac      	str	r4, [r5, #8]
1002fab4:	f240 0af5 	movw	sl, #245	; 0xf5
1002fab8:	666c      	str	r4, [r5, #100]	; 0x64
1002faba:	f240 192d 	movw	r9, #301	; 0x12d
1002fabe:	81ec      	strh	r4, [r5, #14]
1002fac0:	f240 184d 	movw	r8, #333	; 0x14d
1002fac4:	612c      	str	r4, [r5, #16]
1002fac6:	f2c1 0b03 	movt	fp, #4099	; 0x1003
1002faca:	616c      	str	r4, [r5, #20]
1002facc:	f2c1 0a03 	movt	sl, #4099	; 0x1003
1002fad0:	61ac      	str	r4, [r5, #24]
1002fad2:	f2c1 0903 	movt	r9, #4099	; 0x1003
1002fad6:	81ab      	strh	r3, [r5, #12]
1002fad8:	f2c1 0803 	movt	r8, #4099	; 0x1003
1002fadc:	f7ff fc5e 	bl	1002f39c <memset>
1002fae0:	68be      	ldr	r6, [r7, #8]
1002fae2:	2301      	movs	r3, #1
1002fae4:	f8c5 b020 	str.w	fp, [r5, #32]
1002fae8:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
1002faec:	f04f 0e09 	mov.w	lr, #9
1002faf0:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
1002faf4:	4621      	mov	r1, r4
1002faf6:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
1002fafa:	f106 005c 	add.w	r0, r6, #92	; 0x5c
1002fafe:	61ed      	str	r5, [r5, #28]
1002fb00:	2208      	movs	r2, #8
1002fb02:	81f3      	strh	r3, [r6, #14]
1002fb04:	f8a6 e00c 	strh.w	lr, [r6, #12]
1002fb08:	6034      	str	r4, [r6, #0]
1002fb0a:	6074      	str	r4, [r6, #4]
1002fb0c:	60b4      	str	r4, [r6, #8]
1002fb0e:	6674      	str	r4, [r6, #100]	; 0x64
1002fb10:	6134      	str	r4, [r6, #16]
1002fb12:	6174      	str	r4, [r6, #20]
1002fb14:	61b4      	str	r4, [r6, #24]
1002fb16:	9301      	str	r3, [sp, #4]
1002fb18:	f7ff fc40 	bl	1002f39c <memset>
1002fb1c:	68fd      	ldr	r5, [r7, #12]
1002fb1e:	f04f 0c12 	mov.w	ip, #18
1002fb22:	61f6      	str	r6, [r6, #28]
1002fb24:	f04f 0e02 	mov.w	lr, #2
1002fb28:	f8c6 b020 	str.w	fp, [r6, #32]
1002fb2c:	4621      	mov	r1, r4
1002fb2e:	f8c6 a024 	str.w	sl, [r6, #36]	; 0x24
1002fb32:	f105 005c 	add.w	r0, r5, #92	; 0x5c
1002fb36:	f8c6 9028 	str.w	r9, [r6, #40]	; 0x28
1002fb3a:	2208      	movs	r2, #8
1002fb3c:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
1002fb40:	602c      	str	r4, [r5, #0]
1002fb42:	606c      	str	r4, [r5, #4]
1002fb44:	60ac      	str	r4, [r5, #8]
1002fb46:	666c      	str	r4, [r5, #100]	; 0x64
1002fb48:	612c      	str	r4, [r5, #16]
1002fb4a:	616c      	str	r4, [r5, #20]
1002fb4c:	61ac      	str	r4, [r5, #24]
1002fb4e:	f8a5 c00c 	strh.w	ip, [r5, #12]
1002fb52:	f8a5 e00e 	strh.w	lr, [r5, #14]
1002fb56:	f7ff fc21 	bl	1002f39c <memset>
1002fb5a:	9b01      	ldr	r3, [sp, #4]
1002fb5c:	61ed      	str	r5, [r5, #28]
1002fb5e:	f8c5 b020 	str.w	fp, [r5, #32]
1002fb62:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
1002fb66:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
1002fb6a:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
1002fb6e:	63bb      	str	r3, [r7, #56]	; 0x38
1002fb70:	b003      	add	sp, #12
1002fb72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1002fb76:	bf00      	nop

1002fb78 <__sinit>:
1002fb78:	6b83      	ldr	r3, [r0, #56]	; 0x38
1002fb7a:	b103      	cbz	r3, 1002fb7e <__sinit+0x6>
1002fb7c:	4770      	bx	lr
1002fb7e:	f7ff bf7b 	b.w	1002fa78 <__sinit.part.1>
1002fb82:	bf00      	nop

1002fb84 <__sfp_lock_acquire>:
1002fb84:	4770      	bx	lr
1002fb86:	bf00      	nop

1002fb88 <__sfp_lock_release>:
1002fb88:	4770      	bx	lr
1002fb8a:	bf00      	nop

1002fb8c <__sfvwrite_r>:
1002fb8c:	6893      	ldr	r3, [r2, #8]
1002fb8e:	2b00      	cmp	r3, #0
1002fb90:	d07c      	beq.n	1002fc8c <__sfvwrite_r+0x100>
1002fb92:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1002fb96:	460c      	mov	r4, r1
1002fb98:	f8b1 e00c 	ldrh.w	lr, [r1, #12]
1002fb9c:	b083      	sub	sp, #12
1002fb9e:	4681      	mov	r9, r0
1002fba0:	4616      	mov	r6, r2
1002fba2:	f01e 0f08 	tst.w	lr, #8
1002fba6:	d028      	beq.n	1002fbfa <__sfvwrite_r+0x6e>
1002fba8:	690b      	ldr	r3, [r1, #16]
1002fbaa:	b333      	cbz	r3, 1002fbfa <__sfvwrite_r+0x6e>
1002fbac:	f00e 0802 	and.w	r8, lr, #2
1002fbb0:	6835      	ldr	r5, [r6, #0]
1002fbb2:	fa1f f088 	uxth.w	r0, r8
1002fbb6:	b380      	cbz	r0, 1002fc1a <__sfvwrite_r+0x8e>
1002fbb8:	f04f 0a00 	mov.w	sl, #0
1002fbbc:	f44f 4b7c 	mov.w	fp, #64512	; 0xfc00
1002fbc0:	46d0      	mov	r8, sl
1002fbc2:	f6c7 7bff 	movt	fp, #32767	; 0x7fff
1002fbc6:	45d8      	cmp	r8, fp
1002fbc8:	4643      	mov	r3, r8
1002fbca:	4652      	mov	r2, sl
1002fbcc:	4648      	mov	r0, r9
1002fbce:	bf28      	it	cs
1002fbd0:	465b      	movcs	r3, fp
1002fbd2:	f1b8 0f00 	cmp.w	r8, #0
1002fbd6:	d053      	beq.n	1002fc80 <__sfvwrite_r+0xf4>
1002fbd8:	69e1      	ldr	r1, [r4, #28]
1002fbda:	6a67      	ldr	r7, [r4, #36]	; 0x24
1002fbdc:	47b8      	blx	r7
1002fbde:	2800      	cmp	r0, #0
1002fbe0:	4482      	add	sl, r0
1002fbe2:	ebc0 0808 	rsb	r8, r0, r8
1002fbe6:	dd71      	ble.n	1002fccc <__sfvwrite_r+0x140>
1002fbe8:	68b3      	ldr	r3, [r6, #8]
1002fbea:	1a18      	subs	r0, r3, r0
1002fbec:	60b0      	str	r0, [r6, #8]
1002fbee:	2800      	cmp	r0, #0
1002fbf0:	d1e9      	bne.n	1002fbc6 <__sfvwrite_r+0x3a>
1002fbf2:	2000      	movs	r0, #0
1002fbf4:	b003      	add	sp, #12
1002fbf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1002fbfa:	4648      	mov	r0, r9
1002fbfc:	4621      	mov	r1, r4
1002fbfe:	f000 faa9 	bl	10030154 <__swsetup_r>
1002fc02:	2800      	cmp	r0, #0
1002fc04:	f040 8145 	bne.w	1002fe92 <__sfvwrite_r+0x306>
1002fc08:	f8b4 e00c 	ldrh.w	lr, [r4, #12]
1002fc0c:	6835      	ldr	r5, [r6, #0]
1002fc0e:	f00e 0802 	and.w	r8, lr, #2
1002fc12:	fa1f f088 	uxth.w	r0, r8
1002fc16:	2800      	cmp	r0, #0
1002fc18:	d1ce      	bne.n	1002fbb8 <__sfvwrite_r+0x2c>
1002fc1a:	f01e 0b01 	ands.w	fp, lr, #1
1002fc1e:	d15e      	bne.n	1002fcde <__sfvwrite_r+0x152>
1002fc20:	46d8      	mov	r8, fp
1002fc22:	f1b8 0f00 	cmp.w	r8, #0
1002fc26:	d025      	beq.n	1002fc74 <__sfvwrite_r+0xe8>
1002fc28:	f41e 7f00 	tst.w	lr, #512	; 0x200
1002fc2c:	68a7      	ldr	r7, [r4, #8]
1002fc2e:	d02f      	beq.n	1002fc90 <__sfvwrite_r+0x104>
1002fc30:	45b8      	cmp	r8, r7
1002fc32:	46ba      	mov	sl, r7
1002fc34:	f0c0 80ab 	bcc.w	1002fd8e <__sfvwrite_r+0x202>
1002fc38:	f41e 6f90 	tst.w	lr, #1152	; 0x480
1002fc3c:	f040 80b8 	bne.w	1002fdb0 <__sfvwrite_r+0x224>
1002fc40:	6820      	ldr	r0, [r4, #0]
1002fc42:	4659      	mov	r1, fp
1002fc44:	4652      	mov	r2, sl
1002fc46:	f000 f9df 	bl	10030008 <memmove>
1002fc4a:	68a2      	ldr	r2, [r4, #8]
1002fc4c:	6821      	ldr	r1, [r4, #0]
1002fc4e:	4640      	mov	r0, r8
1002fc50:	1bd7      	subs	r7, r2, r7
1002fc52:	60a7      	str	r7, [r4, #8]
1002fc54:	eb01 030a 	add.w	r3, r1, sl
1002fc58:	6023      	str	r3, [r4, #0]
1002fc5a:	68b3      	ldr	r3, [r6, #8]
1002fc5c:	4483      	add	fp, r0
1002fc5e:	ebc0 0808 	rsb	r8, r0, r8
1002fc62:	1a18      	subs	r0, r3, r0
1002fc64:	60b0      	str	r0, [r6, #8]
1002fc66:	2800      	cmp	r0, #0
1002fc68:	d0c3      	beq.n	1002fbf2 <__sfvwrite_r+0x66>
1002fc6a:	f8b4 e00c 	ldrh.w	lr, [r4, #12]
1002fc6e:	f1b8 0f00 	cmp.w	r8, #0
1002fc72:	d1d9      	bne.n	1002fc28 <__sfvwrite_r+0x9c>
1002fc74:	f8d5 b000 	ldr.w	fp, [r5]
1002fc78:	3508      	adds	r5, #8
1002fc7a:	f855 8c04 	ldr.w	r8, [r5, #-4]
1002fc7e:	e7d0      	b.n	1002fc22 <__sfvwrite_r+0x96>
1002fc80:	f8d5 a000 	ldr.w	sl, [r5]
1002fc84:	3508      	adds	r5, #8
1002fc86:	f855 8c04 	ldr.w	r8, [r5, #-4]
1002fc8a:	e79c      	b.n	1002fbc6 <__sfvwrite_r+0x3a>
1002fc8c:	2000      	movs	r0, #0
1002fc8e:	4770      	bx	lr
1002fc90:	6820      	ldr	r0, [r4, #0]
1002fc92:	6923      	ldr	r3, [r4, #16]
1002fc94:	4298      	cmp	r0, r3
1002fc96:	d804      	bhi.n	1002fca2 <__sfvwrite_r+0x116>
1002fc98:	f8d4 a014 	ldr.w	sl, [r4, #20]
1002fc9c:	45d0      	cmp	r8, sl
1002fc9e:	f080 80b8 	bcs.w	1002fe12 <__sfvwrite_r+0x286>
1002fca2:	4547      	cmp	r7, r8
1002fca4:	4659      	mov	r1, fp
1002fca6:	bf28      	it	cs
1002fca8:	4647      	movcs	r7, r8
1002fcaa:	463a      	mov	r2, r7
1002fcac:	f000 f9ac 	bl	10030008 <memmove>
1002fcb0:	68a3      	ldr	r3, [r4, #8]
1002fcb2:	6822      	ldr	r2, [r4, #0]
1002fcb4:	1bdb      	subs	r3, r3, r7
1002fcb6:	60a3      	str	r3, [r4, #8]
1002fcb8:	443a      	add	r2, r7
1002fcba:	6022      	str	r2, [r4, #0]
1002fcbc:	2b00      	cmp	r3, #0
1002fcbe:	d14e      	bne.n	1002fd5e <__sfvwrite_r+0x1d2>
1002fcc0:	4648      	mov	r0, r9
1002fcc2:	4621      	mov	r1, r4
1002fcc4:	f000 fb94 	bl	100303f0 <_fflush_r>
1002fcc8:	2800      	cmp	r0, #0
1002fcca:	d048      	beq.n	1002fd5e <__sfvwrite_r+0x1d2>
1002fccc:	89a3      	ldrh	r3, [r4, #12]
1002fcce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
1002fcd2:	f04f 30ff 	mov.w	r0, #4294967295
1002fcd6:	81a3      	strh	r3, [r4, #12]
1002fcd8:	b003      	add	sp, #12
1002fcda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1002fcde:	4680      	mov	r8, r0
1002fce0:	4683      	mov	fp, r0
1002fce2:	4682      	mov	sl, r0
1002fce4:	9000      	str	r0, [sp, #0]
1002fce6:	f1ba 0f00 	cmp.w	sl, #0
1002fcea:	d030      	beq.n	1002fd4e <__sfvwrite_r+0x1c2>
1002fcec:	9b00      	ldr	r3, [sp, #0]
1002fcee:	2b00      	cmp	r3, #0
1002fcf0:	d051      	beq.n	1002fd96 <__sfvwrite_r+0x20a>
1002fcf2:	68a1      	ldr	r1, [r4, #8]
1002fcf4:	45d0      	cmp	r8, sl
1002fcf6:	6963      	ldr	r3, [r4, #20]
1002fcf8:	4642      	mov	r2, r8
1002fcfa:	6820      	ldr	r0, [r4, #0]
1002fcfc:	bf28      	it	cs
1002fcfe:	4652      	movcs	r2, sl
1002fd00:	eb03 0c01 	add.w	ip, r3, r1
1002fd04:	6921      	ldr	r1, [r4, #16]
1002fd06:	4562      	cmp	r2, ip
1002fd08:	4617      	mov	r7, r2
1002fd0a:	468e      	mov	lr, r1
1002fd0c:	bfd4      	ite	le
1002fd0e:	2100      	movle	r1, #0
1002fd10:	2101      	movgt	r1, #1
1002fd12:	4570      	cmp	r0, lr
1002fd14:	bf98      	it	ls
1002fd16:	2100      	movls	r1, #0
1002fd18:	2900      	cmp	r1, #0
1002fd1a:	f040 808d 	bne.w	1002fe38 <__sfvwrite_r+0x2ac>
1002fd1e:	429a      	cmp	r2, r3
1002fd20:	db1f      	blt.n	1002fd62 <__sfvwrite_r+0x1d6>
1002fd22:	6a67      	ldr	r7, [r4, #36]	; 0x24
1002fd24:	4648      	mov	r0, r9
1002fd26:	69e1      	ldr	r1, [r4, #28]
1002fd28:	465a      	mov	r2, fp
1002fd2a:	47b8      	blx	r7
1002fd2c:	1e07      	subs	r7, r0, #0
1002fd2e:	ddcd      	ble.n	1002fccc <__sfvwrite_r+0x140>
1002fd30:	ebb8 0807 	subs.w	r8, r8, r7
1002fd34:	d022      	beq.n	1002fd7c <__sfvwrite_r+0x1f0>
1002fd36:	68b3      	ldr	r3, [r6, #8]
1002fd38:	44bb      	add	fp, r7
1002fd3a:	ebc7 0a0a 	rsb	sl, r7, sl
1002fd3e:	1bdf      	subs	r7, r3, r7
1002fd40:	60b7      	str	r7, [r6, #8]
1002fd42:	2f00      	cmp	r7, #0
1002fd44:	f43f af55 	beq.w	1002fbf2 <__sfvwrite_r+0x66>
1002fd48:	f1ba 0f00 	cmp.w	sl, #0
1002fd4c:	d1ce      	bne.n	1002fcec <__sfvwrite_r+0x160>
1002fd4e:	f8d5 b000 	ldr.w	fp, [r5]
1002fd52:	2300      	movs	r3, #0
1002fd54:	f8d5 a004 	ldr.w	sl, [r5, #4]
1002fd58:	3508      	adds	r5, #8
1002fd5a:	9300      	str	r3, [sp, #0]
1002fd5c:	e7c3      	b.n	1002fce6 <__sfvwrite_r+0x15a>
1002fd5e:	4638      	mov	r0, r7
1002fd60:	e77b      	b.n	1002fc5a <__sfvwrite_r+0xce>
1002fd62:	4659      	mov	r1, fp
1002fd64:	f000 f950 	bl	10030008 <memmove>
1002fd68:	68a2      	ldr	r2, [r4, #8]
1002fd6a:	6823      	ldr	r3, [r4, #0]
1002fd6c:	ebb8 0807 	subs.w	r8, r8, r7
1002fd70:	eba2 0207 	sub.w	r2, r2, r7
1002fd74:	60a2      	str	r2, [r4, #8]
1002fd76:	443b      	add	r3, r7
1002fd78:	6023      	str	r3, [r4, #0]
1002fd7a:	d1dc      	bne.n	1002fd36 <__sfvwrite_r+0x1aa>
1002fd7c:	4648      	mov	r0, r9
1002fd7e:	4621      	mov	r1, r4
1002fd80:	f000 fb36 	bl	100303f0 <_fflush_r>
1002fd84:	2800      	cmp	r0, #0
1002fd86:	d1a1      	bne.n	1002fccc <__sfvwrite_r+0x140>
1002fd88:	f8cd 8000 	str.w	r8, [sp]
1002fd8c:	e7d3      	b.n	1002fd36 <__sfvwrite_r+0x1aa>
1002fd8e:	6820      	ldr	r0, [r4, #0]
1002fd90:	4647      	mov	r7, r8
1002fd92:	46c2      	mov	sl, r8
1002fd94:	e755      	b.n	1002fc42 <__sfvwrite_r+0xb6>
1002fd96:	4658      	mov	r0, fp
1002fd98:	210a      	movs	r1, #10
1002fd9a:	4652      	mov	r2, sl
1002fd9c:	f000 f8ea 	bl	1002ff74 <memchr>
1002fda0:	2800      	cmp	r0, #0
1002fda2:	d071      	beq.n	1002fe88 <__sfvwrite_r+0x2fc>
1002fda4:	3001      	adds	r0, #1
1002fda6:	2301      	movs	r3, #1
1002fda8:	ebcb 0800 	rsb	r8, fp, r0
1002fdac:	9300      	str	r3, [sp, #0]
1002fdae:	e7a0      	b.n	1002fcf2 <__sfvwrite_r+0x166>
1002fdb0:	6963      	ldr	r3, [r4, #20]
1002fdb2:	6921      	ldr	r1, [r4, #16]
1002fdb4:	6827      	ldr	r7, [r4, #0]
1002fdb6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
1002fdba:	1a7f      	subs	r7, r7, r1
1002fdbc:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
1002fdc0:	1c78      	adds	r0, r7, #1
1002fdc2:	4440      	add	r0, r8
1002fdc4:	ea4f 0a63 	mov.w	sl, r3, asr #1
1002fdc8:	4582      	cmp	sl, r0
1002fdca:	4652      	mov	r2, sl
1002fdcc:	bf3c      	itt	cc
1002fdce:	4682      	movcc	sl, r0
1002fdd0:	4652      	movcc	r2, sl
1002fdd2:	f41e 6f80 	tst.w	lr, #1024	; 0x400
1002fdd6:	d045      	beq.n	1002fe64 <__sfvwrite_r+0x2d8>
1002fdd8:	4611      	mov	r1, r2
1002fdda:	4648      	mov	r0, r9
1002fddc:	f7f0 eac0 	blx	10020360 <_malloc_r>
1002fde0:	2800      	cmp	r0, #0
1002fde2:	d059      	beq.n	1002fe98 <__sfvwrite_r+0x30c>
1002fde4:	463a      	mov	r2, r7
1002fde6:	6921      	ldr	r1, [r4, #16]
1002fde8:	9000      	str	r0, [sp, #0]
1002fdea:	f7ff fa83 	bl	1002f2f4 <memcpy>
1002fdee:	89a2      	ldrh	r2, [r4, #12]
1002fdf0:	9b00      	ldr	r3, [sp, #0]
1002fdf2:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
1002fdf6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
1002fdfa:	81a2      	strh	r2, [r4, #12]
1002fdfc:	19d8      	adds	r0, r3, r7
1002fdfe:	f8c4 a014 	str.w	sl, [r4, #20]
1002fe02:	ebc7 070a 	rsb	r7, r7, sl
1002fe06:	6123      	str	r3, [r4, #16]
1002fe08:	60a7      	str	r7, [r4, #8]
1002fe0a:	46c2      	mov	sl, r8
1002fe0c:	6020      	str	r0, [r4, #0]
1002fe0e:	4647      	mov	r7, r8
1002fe10:	e717      	b.n	1002fc42 <__sfvwrite_r+0xb6>
1002fe12:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
1002fe16:	4540      	cmp	r0, r8
1002fe18:	4651      	mov	r1, sl
1002fe1a:	bf28      	it	cs
1002fe1c:	4640      	movcs	r0, r8
1002fe1e:	f7ff f90b 	bl	1002f038 <__aeabi_idiv>
1002fe22:	6a67      	ldr	r7, [r4, #36]	; 0x24
1002fe24:	69e1      	ldr	r1, [r4, #28]
1002fe26:	465a      	mov	r2, fp
1002fe28:	fb00 f30a 	mul.w	r3, r0, sl
1002fe2c:	4648      	mov	r0, r9
1002fe2e:	47b8      	blx	r7
1002fe30:	2800      	cmp	r0, #0
1002fe32:	f73f af12 	bgt.w	1002fc5a <__sfvwrite_r+0xce>
1002fe36:	e749      	b.n	1002fccc <__sfvwrite_r+0x140>
1002fe38:	4662      	mov	r2, ip
1002fe3a:	4659      	mov	r1, fp
1002fe3c:	f8cd c004 	str.w	ip, [sp, #4]
1002fe40:	f000 f8e2 	bl	10030008 <memmove>
1002fe44:	6823      	ldr	r3, [r4, #0]
1002fe46:	4648      	mov	r0, r9
1002fe48:	f8dd c004 	ldr.w	ip, [sp, #4]
1002fe4c:	4621      	mov	r1, r4
1002fe4e:	4463      	add	r3, ip
1002fe50:	6023      	str	r3, [r4, #0]
1002fe52:	f000 facd 	bl	100303f0 <_fflush_r>
1002fe56:	f8dd c004 	ldr.w	ip, [sp, #4]
1002fe5a:	2800      	cmp	r0, #0
1002fe5c:	f47f af36 	bne.w	1002fccc <__sfvwrite_r+0x140>
1002fe60:	4667      	mov	r7, ip
1002fe62:	e765      	b.n	1002fd30 <__sfvwrite_r+0x1a4>
1002fe64:	4648      	mov	r0, r9
1002fe66:	f7f0 eaa0 	blx	100203a8 <_realloc_r>
1002fe6a:	4603      	mov	r3, r0
1002fe6c:	2800      	cmp	r0, #0
1002fe6e:	d1c5      	bne.n	1002fdfc <__sfvwrite_r+0x270>
1002fe70:	4648      	mov	r0, r9
1002fe72:	6921      	ldr	r1, [r4, #16]
1002fe74:	f7f0 eae8 	blx	10020448 <_free_r>
1002fe78:	89a3      	ldrh	r3, [r4, #12]
1002fe7a:	220c      	movs	r2, #12
1002fe7c:	f8c9 2000 	str.w	r2, [r9]
1002fe80:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1002fe84:	b29b      	uxth	r3, r3
1002fe86:	e722      	b.n	1002fcce <__sfvwrite_r+0x142>
1002fe88:	2301      	movs	r3, #1
1002fe8a:	f10a 0801 	add.w	r8, sl, #1
1002fe8e:	9300      	str	r3, [sp, #0]
1002fe90:	e72f      	b.n	1002fcf2 <__sfvwrite_r+0x166>
1002fe92:	f04f 30ff 	mov.w	r0, #4294967295
1002fe96:	e6ad      	b.n	1002fbf4 <__sfvwrite_r+0x68>
1002fe98:	220c      	movs	r2, #12
1002fe9a:	89a3      	ldrh	r3, [r4, #12]
1002fe9c:	f8c9 2000 	str.w	r2, [r9]
1002fea0:	e715      	b.n	1002fcce <__sfvwrite_r+0x142>
1002fea2:	bf00      	nop

1002fea4 <_fwalk_reent>:
1002fea4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
1002fea8:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
1002feac:	d01e      	beq.n	1002feec <_fwalk_reent+0x48>
1002feae:	4688      	mov	r8, r1
1002feb0:	4606      	mov	r6, r0
1002feb2:	f04f 0900 	mov.w	r9, #0
1002feb6:	687d      	ldr	r5, [r7, #4]
1002feb8:	68bc      	ldr	r4, [r7, #8]
1002feba:	3d01      	subs	r5, #1
1002febc:	d410      	bmi.n	1002fee0 <_fwalk_reent+0x3c>
1002febe:	89a3      	ldrh	r3, [r4, #12]
1002fec0:	3d01      	subs	r5, #1
1002fec2:	2b01      	cmp	r3, #1
1002fec4:	d908      	bls.n	1002fed8 <_fwalk_reent+0x34>
1002fec6:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
1002feca:	4621      	mov	r1, r4
1002fecc:	4630      	mov	r0, r6
1002fece:	3301      	adds	r3, #1
1002fed0:	d002      	beq.n	1002fed8 <_fwalk_reent+0x34>
1002fed2:	47c0      	blx	r8
1002fed4:	ea49 0900 	orr.w	r9, r9, r0
1002fed8:	1c6b      	adds	r3, r5, #1
1002feda:	f104 0468 	add.w	r4, r4, #104	; 0x68
1002fede:	d1ee      	bne.n	1002febe <_fwalk_reent+0x1a>
1002fee0:	683f      	ldr	r7, [r7, #0]
1002fee2:	2f00      	cmp	r7, #0
1002fee4:	d1e7      	bne.n	1002feb6 <_fwalk_reent+0x12>
1002fee6:	4648      	mov	r0, r9
1002fee8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
1002feec:	46b9      	mov	r9, r7
1002feee:	4648      	mov	r0, r9
1002fef0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

1002fef4 <_findenv_r>:
1002fef4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
1002fef8:	f646 58bc 	movw	r8, #28092	; 0x6dbc
1002fefc:	f2c1 0803 	movt	r8, #4099	; 0x1003
1002ff00:	460e      	mov	r6, r1
1002ff02:	4617      	mov	r7, r2
1002ff04:	4681      	mov	r9, r0
1002ff06:	f7ff fdad 	bl	1002fa64 <__env_lock>
1002ff0a:	f8d8 5000 	ldr.w	r5, [r8]
1002ff0e:	b1fd      	cbz	r5, 1002ff50 <_findenv_r+0x5c>
1002ff10:	7833      	ldrb	r3, [r6, #0]
1002ff12:	4634      	mov	r4, r6
1002ff14:	2b3d      	cmp	r3, #61	; 0x3d
1002ff16:	bf18      	it	ne
1002ff18:	2b00      	cmpne	r3, #0
1002ff1a:	d005      	beq.n	1002ff28 <_findenv_r+0x34>
1002ff1c:	f814 3f01 	ldrb.w	r3, [r4, #1]!
1002ff20:	2b3d      	cmp	r3, #61	; 0x3d
1002ff22:	bf18      	it	ne
1002ff24:	2b00      	cmpne	r3, #0
1002ff26:	d1f9      	bne.n	1002ff1c <_findenv_r+0x28>
1002ff28:	2b3d      	cmp	r3, #61	; 0x3d
1002ff2a:	d011      	beq.n	1002ff50 <_findenv_r+0x5c>
1002ff2c:	6828      	ldr	r0, [r5, #0]
1002ff2e:	1ba4      	subs	r4, r4, r6
1002ff30:	b170      	cbz	r0, 1002ff50 <_findenv_r+0x5c>
1002ff32:	4631      	mov	r1, r6
1002ff34:	4622      	mov	r2, r4
1002ff36:	f7ff fc65 	bl	1002f804 <strncmp>
1002ff3a:	b928      	cbnz	r0, 1002ff48 <_findenv_r+0x54>
1002ff3c:	682b      	ldr	r3, [r5, #0]
1002ff3e:	eb03 0a04 	add.w	sl, r3, r4
1002ff42:	5d1b      	ldrb	r3, [r3, r4]
1002ff44:	2b3d      	cmp	r3, #61	; 0x3d
1002ff46:	d009      	beq.n	1002ff5c <_findenv_r+0x68>
1002ff48:	f855 0f04 	ldr.w	r0, [r5, #4]!
1002ff4c:	2800      	cmp	r0, #0
1002ff4e:	d1f0      	bne.n	1002ff32 <_findenv_r+0x3e>
1002ff50:	4648      	mov	r0, r9
1002ff52:	f7ff fd89 	bl	1002fa68 <__env_unlock>
1002ff56:	2000      	movs	r0, #0
1002ff58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1002ff5c:	f8d8 3000 	ldr.w	r3, [r8]
1002ff60:	4648      	mov	r0, r9
1002ff62:	1aed      	subs	r5, r5, r3
1002ff64:	10ad      	asrs	r5, r5, #2
1002ff66:	603d      	str	r5, [r7, #0]
1002ff68:	f7ff fd7e 	bl	1002fa68 <__env_unlock>
1002ff6c:	f10a 0001 	add.w	r0, sl, #1
1002ff70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

1002ff74 <memchr>:
1002ff74:	0783      	lsls	r3, r0, #30
1002ff76:	b2c9      	uxtb	r1, r1
1002ff78:	b470      	push	{r4, r5, r6}
1002ff7a:	d040      	beq.n	1002fffe <memchr+0x8a>
1002ff7c:	1e54      	subs	r4, r2, #1
1002ff7e:	2a00      	cmp	r2, #0
1002ff80:	d03f      	beq.n	10030002 <memchr+0x8e>
1002ff82:	7803      	ldrb	r3, [r0, #0]
1002ff84:	428b      	cmp	r3, r1
1002ff86:	bf18      	it	ne
1002ff88:	1c43      	addne	r3, r0, #1
1002ff8a:	d105      	bne.n	1002ff98 <memchr+0x24>
1002ff8c:	e01d      	b.n	1002ffca <memchr+0x56>
1002ff8e:	b1f4      	cbz	r4, 1002ffce <memchr+0x5a>
1002ff90:	7802      	ldrb	r2, [r0, #0]
1002ff92:	3c01      	subs	r4, #1
1002ff94:	428a      	cmp	r2, r1
1002ff96:	d018      	beq.n	1002ffca <memchr+0x56>
1002ff98:	f013 0f03 	tst.w	r3, #3
1002ff9c:	4618      	mov	r0, r3
1002ff9e:	f103 0301 	add.w	r3, r3, #1
1002ffa2:	d1f4      	bne.n	1002ff8e <memchr+0x1a>
1002ffa4:	2c03      	cmp	r4, #3
1002ffa6:	d815      	bhi.n	1002ffd4 <memchr+0x60>
1002ffa8:	b18c      	cbz	r4, 1002ffce <memchr+0x5a>
1002ffaa:	7803      	ldrb	r3, [r0, #0]
1002ffac:	428b      	cmp	r3, r1
1002ffae:	bf1c      	itt	ne
1002ffb0:	1905      	addne	r5, r0, r4
1002ffb2:	1c43      	addne	r3, r0, #1
1002ffb4:	d103      	bne.n	1002ffbe <memchr+0x4a>
1002ffb6:	e008      	b.n	1002ffca <memchr+0x56>
1002ffb8:	7802      	ldrb	r2, [r0, #0]
1002ffba:	428a      	cmp	r2, r1
1002ffbc:	d005      	beq.n	1002ffca <memchr+0x56>
1002ffbe:	42ab      	cmp	r3, r5
1002ffc0:	4618      	mov	r0, r3
1002ffc2:	f103 0301 	add.w	r3, r3, #1
1002ffc6:	d1f7      	bne.n	1002ffb8 <memchr+0x44>
1002ffc8:	2000      	movs	r0, #0
1002ffca:	bc70      	pop	{r4, r5, r6}
1002ffcc:	4770      	bx	lr
1002ffce:	4620      	mov	r0, r4
1002ffd0:	bc70      	pop	{r4, r5, r6}
1002ffd2:	4770      	bx	lr
1002ffd4:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
1002ffd8:	4602      	mov	r2, r0
1002ffda:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
1002ffde:	4610      	mov	r0, r2
1002ffe0:	3204      	adds	r2, #4
1002ffe2:	6803      	ldr	r3, [r0, #0]
1002ffe4:	4073      	eors	r3, r6
1002ffe6:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
1002ffea:	ea25 0303 	bic.w	r3, r5, r3
1002ffee:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1002fff2:	d1d9      	bne.n	1002ffa8 <memchr+0x34>
1002fff4:	3c04      	subs	r4, #4
1002fff6:	4610      	mov	r0, r2
1002fff8:	2c03      	cmp	r4, #3
1002fffa:	d8f0      	bhi.n	1002ffde <memchr+0x6a>
1002fffc:	e7d4      	b.n	1002ffa8 <memchr+0x34>
1002fffe:	4614      	mov	r4, r2
10030000:	e7d0      	b.n	1002ffa4 <memchr+0x30>
10030002:	4610      	mov	r0, r2
10030004:	e7e1      	b.n	1002ffca <memchr+0x56>
10030006:	bf00      	nop

10030008 <memmove>:
10030008:	4288      	cmp	r0, r1
1003000a:	b5f0      	push	{r4, r5, r6, r7, lr}
1003000c:	d90d      	bls.n	1003002a <memmove+0x22>
1003000e:	188b      	adds	r3, r1, r2
10030010:	4298      	cmp	r0, r3
10030012:	d20a      	bcs.n	1003002a <memmove+0x22>
10030014:	1881      	adds	r1, r0, r2
10030016:	2a00      	cmp	r2, #0
10030018:	d055      	beq.n	100300c6 <memmove+0xbe>
1003001a:	1a9a      	subs	r2, r3, r2
1003001c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
10030020:	4293      	cmp	r3, r2
10030022:	f801 4d01 	strb.w	r4, [r1, #-1]!
10030026:	d1f9      	bne.n	1003001c <memmove+0x14>
10030028:	bdf0      	pop	{r4, r5, r6, r7, pc}
1003002a:	2a0f      	cmp	r2, #15
1003002c:	d949      	bls.n	100300c2 <memmove+0xba>
1003002e:	ea40 0301 	orr.w	r3, r0, r1
10030032:	079b      	lsls	r3, r3, #30
10030034:	d148      	bne.n	100300c8 <memmove+0xc0>
10030036:	f100 0410 	add.w	r4, r0, #16
1003003a:	f101 0310 	add.w	r3, r1, #16
1003003e:	4615      	mov	r5, r2
10030040:	f853 6c10 	ldr.w	r6, [r3, #-16]
10030044:	3d10      	subs	r5, #16
10030046:	2d0f      	cmp	r5, #15
10030048:	f103 0310 	add.w	r3, r3, #16
1003004c:	f104 0410 	add.w	r4, r4, #16
10030050:	f844 6c20 	str.w	r6, [r4, #-32]
10030054:	f853 6c1c 	ldr.w	r6, [r3, #-28]
10030058:	f844 6c1c 	str.w	r6, [r4, #-28]
1003005c:	f853 6c18 	ldr.w	r6, [r3, #-24]
10030060:	f844 6c18 	str.w	r6, [r4, #-24]
10030064:	f853 6c14 	ldr.w	r6, [r3, #-20]
10030068:	f844 6c14 	str.w	r6, [r4, #-20]
1003006c:	d8e8      	bhi.n	10030040 <memmove+0x38>
1003006e:	f1a2 0310 	sub.w	r3, r2, #16
10030072:	f002 0e0f 	and.w	lr, r2, #15
10030076:	f023 030f 	bic.w	r3, r3, #15
1003007a:	f1be 0f03 	cmp.w	lr, #3
1003007e:	f103 0310 	add.w	r3, r3, #16
10030082:	4419      	add	r1, r3
10030084:	4403      	add	r3, r0
10030086:	d921      	bls.n	100300cc <memmove+0xc4>
10030088:	1f1e      	subs	r6, r3, #4
1003008a:	460d      	mov	r5, r1
1003008c:	4674      	mov	r4, lr
1003008e:	f855 7b04 	ldr.w	r7, [r5], #4
10030092:	3c04      	subs	r4, #4
10030094:	2c03      	cmp	r4, #3
10030096:	f846 7f04 	str.w	r7, [r6, #4]!
1003009a:	d8f8      	bhi.n	1003008e <memmove+0x86>
1003009c:	f1ae 0404 	sub.w	r4, lr, #4
100300a0:	f002 0203 	and.w	r2, r2, #3
100300a4:	f024 0403 	bic.w	r4, r4, #3
100300a8:	3404      	adds	r4, #4
100300aa:	4423      	add	r3, r4
100300ac:	4421      	add	r1, r4
100300ae:	b152      	cbz	r2, 100300c6 <memmove+0xbe>
100300b0:	3b01      	subs	r3, #1
100300b2:	440a      	add	r2, r1
100300b4:	f811 4b01 	ldrb.w	r4, [r1], #1
100300b8:	4291      	cmp	r1, r2
100300ba:	f803 4f01 	strb.w	r4, [r3, #1]!
100300be:	d1f9      	bne.n	100300b4 <memmove+0xac>
100300c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
100300c2:	4603      	mov	r3, r0
100300c4:	e7f3      	b.n	100300ae <memmove+0xa6>
100300c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
100300c8:	4603      	mov	r3, r0
100300ca:	e7f1      	b.n	100300b0 <memmove+0xa8>
100300cc:	4672      	mov	r2, lr
100300ce:	e7ee      	b.n	100300ae <memmove+0xa6>

100300d0 <__sread>:
100300d0:	b510      	push	{r4, lr}
100300d2:	460c      	mov	r4, r1
100300d4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
100300d8:	f7f0 e81e 	blx	10020118 <_read_r>
100300dc:	2800      	cmp	r0, #0
100300de:	bfab      	itete	ge
100300e0:	6d23      	ldrge	r3, [r4, #80]	; 0x50
100300e2:	89a3      	ldrhlt	r3, [r4, #12]
100300e4:	181b      	addge	r3, r3, r0
100300e6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
100300ea:	bfac      	ite	ge
100300ec:	6523      	strge	r3, [r4, #80]	; 0x50
100300ee:	81a3      	strhlt	r3, [r4, #12]
100300f0:	bd10      	pop	{r4, pc}
100300f2:	bf00      	nop

100300f4 <__swrite>:
100300f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
100300f8:	4616      	mov	r6, r2
100300fa:	898a      	ldrh	r2, [r1, #12]
100300fc:	461d      	mov	r5, r3
100300fe:	460c      	mov	r4, r1
10030100:	4607      	mov	r7, r0
10030102:	05d3      	lsls	r3, r2, #23
10030104:	d506      	bpl.n	10030114 <__swrite+0x20>
10030106:	2200      	movs	r2, #0
10030108:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
1003010c:	2302      	movs	r3, #2
1003010e:	f7ef efbe 	blx	1002008c <_lseek_r>
10030112:	89a2      	ldrh	r2, [r4, #12]
10030114:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
10030118:	4638      	mov	r0, r7
1003011a:	81a2      	strh	r2, [r4, #12]
1003011c:	462b      	mov	r3, r5
1003011e:	4632      	mov	r2, r6
10030120:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
10030124:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
10030128:	f002 b9ce 	b.w	100324c8 <___write_r_from_thumb>

1003012c <__sseek>:
1003012c:	b510      	push	{r4, lr}
1003012e:	460c      	mov	r4, r1
10030130:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
10030134:	f7ef efaa 	blx	1002008c <_lseek_r>
10030138:	89a3      	ldrh	r3, [r4, #12]
1003013a:	1c42      	adds	r2, r0, #1
1003013c:	bf16      	itet	ne
1003013e:	6520      	strne	r0, [r4, #80]	; 0x50
10030140:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
10030144:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
10030148:	81a3      	strh	r3, [r4, #12]
1003014a:	bd10      	pop	{r4, pc}

1003014c <__sclose>:
1003014c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
10030150:	f002 b9be 	b.w	100324d0 <___close_r_from_thumb>

10030154 <__swsetup_r>:
10030154:	b538      	push	{r3, r4, r5, lr}
10030156:	f646 53b8 	movw	r3, #28088	; 0x6db8
1003015a:	f2c1 0303 	movt	r3, #4099	; 0x1003
1003015e:	4605      	mov	r5, r0
10030160:	6818      	ldr	r0, [r3, #0]
10030162:	460c      	mov	r4, r1
10030164:	b110      	cbz	r0, 1003016c <__swsetup_r+0x18>
10030166:	6b83      	ldr	r3, [r0, #56]	; 0x38
10030168:	2b00      	cmp	r3, #0
1003016a:	d036      	beq.n	100301da <__swsetup_r+0x86>
1003016c:	89a2      	ldrh	r2, [r4, #12]
1003016e:	b293      	uxth	r3, r2
10030170:	0718      	lsls	r0, r3, #28
10030172:	d50c      	bpl.n	1003018e <__swsetup_r+0x3a>
10030174:	6920      	ldr	r0, [r4, #16]
10030176:	b1a8      	cbz	r0, 100301a4 <__swsetup_r+0x50>
10030178:	f013 0201 	ands.w	r2, r3, #1
1003017c:	d01e      	beq.n	100301bc <__swsetup_r+0x68>
1003017e:	6963      	ldr	r3, [r4, #20]
10030180:	2200      	movs	r2, #0
10030182:	60a2      	str	r2, [r4, #8]
10030184:	425b      	negs	r3, r3
10030186:	61a3      	str	r3, [r4, #24]
10030188:	b1f0      	cbz	r0, 100301c8 <__swsetup_r+0x74>
1003018a:	2000      	movs	r0, #0
1003018c:	bd38      	pop	{r3, r4, r5, pc}
1003018e:	06d9      	lsls	r1, r3, #27
10030190:	d53a      	bpl.n	10030208 <__swsetup_r+0xb4>
10030192:	0758      	lsls	r0, r3, #29
10030194:	d424      	bmi.n	100301e0 <__swsetup_r+0x8c>
10030196:	6920      	ldr	r0, [r4, #16]
10030198:	f042 0308 	orr.w	r3, r2, #8
1003019c:	81a3      	strh	r3, [r4, #12]
1003019e:	b29b      	uxth	r3, r3
100301a0:	2800      	cmp	r0, #0
100301a2:	d1e9      	bne.n	10030178 <__swsetup_r+0x24>
100301a4:	f403 7220 	and.w	r2, r3, #640	; 0x280
100301a8:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
100301ac:	d0e4      	beq.n	10030178 <__swsetup_r+0x24>
100301ae:	4628      	mov	r0, r5
100301b0:	4621      	mov	r1, r4
100301b2:	f000 f933 	bl	1003041c <__smakebuf_r>
100301b6:	89a3      	ldrh	r3, [r4, #12]
100301b8:	6920      	ldr	r0, [r4, #16]
100301ba:	e7dd      	b.n	10030178 <__swsetup_r+0x24>
100301bc:	0799      	lsls	r1, r3, #30
100301be:	bf58      	it	pl
100301c0:	6962      	ldrpl	r2, [r4, #20]
100301c2:	60a2      	str	r2, [r4, #8]
100301c4:	2800      	cmp	r0, #0
100301c6:	d1e0      	bne.n	1003018a <__swsetup_r+0x36>
100301c8:	89a3      	ldrh	r3, [r4, #12]
100301ca:	061a      	lsls	r2, r3, #24
100301cc:	d5de      	bpl.n	1003018c <__swsetup_r+0x38>
100301ce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
100301d2:	f04f 30ff 	mov.w	r0, #4294967295
100301d6:	81a3      	strh	r3, [r4, #12]
100301d8:	bd38      	pop	{r3, r4, r5, pc}
100301da:	f7ff fccd 	bl	1002fb78 <__sinit>
100301de:	e7c5      	b.n	1003016c <__swsetup_r+0x18>
100301e0:	6b21      	ldr	r1, [r4, #48]	; 0x30
100301e2:	b149      	cbz	r1, 100301f8 <__swsetup_r+0xa4>
100301e4:	f104 0340 	add.w	r3, r4, #64	; 0x40
100301e8:	4299      	cmp	r1, r3
100301ea:	d003      	beq.n	100301f4 <__swsetup_r+0xa0>
100301ec:	4628      	mov	r0, r5
100301ee:	f7f0 e92c 	blx	10020448 <_free_r>
100301f2:	89a2      	ldrh	r2, [r4, #12]
100301f4:	2300      	movs	r3, #0
100301f6:	6323      	str	r3, [r4, #48]	; 0x30
100301f8:	6920      	ldr	r0, [r4, #16]
100301fa:	f022 0224 	bic.w	r2, r2, #36	; 0x24
100301fe:	2300      	movs	r3, #0
10030200:	6063      	str	r3, [r4, #4]
10030202:	b292      	uxth	r2, r2
10030204:	6020      	str	r0, [r4, #0]
10030206:	e7c7      	b.n	10030198 <__swsetup_r+0x44>
10030208:	f042 0240 	orr.w	r2, r2, #64	; 0x40
1003020c:	2309      	movs	r3, #9
1003020e:	f04f 30ff 	mov.w	r0, #4294967295
10030212:	602b      	str	r3, [r5, #0]
10030214:	81a2      	strh	r2, [r4, #12]
10030216:	bd38      	pop	{r3, r4, r5, pc}

10030218 <_fclose_r>:
10030218:	2900      	cmp	r1, #0
1003021a:	d03d      	beq.n	10030298 <_fclose_r+0x80>
1003021c:	b570      	push	{r4, r5, r6, lr}
1003021e:	4605      	mov	r5, r0
10030220:	460c      	mov	r4, r1
10030222:	b108      	cbz	r0, 10030228 <_fclose_r+0x10>
10030224:	6b83      	ldr	r3, [r0, #56]	; 0x38
10030226:	b37b      	cbz	r3, 10030288 <_fclose_r+0x70>
10030228:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
1003022c:	b90b      	cbnz	r3, 10030232 <_fclose_r+0x1a>
1003022e:	2000      	movs	r0, #0
10030230:	bd70      	pop	{r4, r5, r6, pc}
10030232:	4628      	mov	r0, r5
10030234:	4621      	mov	r1, r4
10030236:	f000 f831 	bl	1003029c <__sflush_r>
1003023a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
1003023c:	4606      	mov	r6, r0
1003023e:	b133      	cbz	r3, 1003024e <_fclose_r+0x36>
10030240:	4628      	mov	r0, r5
10030242:	69e1      	ldr	r1, [r4, #28]
10030244:	4798      	blx	r3
10030246:	2800      	cmp	r0, #0
10030248:	bfb8      	it	lt
1003024a:	f04f 36ff 	movlt.w	r6, #4294967295
1003024e:	89a3      	ldrh	r3, [r4, #12]
10030250:	061b      	lsls	r3, r3, #24
10030252:	d41c      	bmi.n	1003028e <_fclose_r+0x76>
10030254:	6b21      	ldr	r1, [r4, #48]	; 0x30
10030256:	b141      	cbz	r1, 1003026a <_fclose_r+0x52>
10030258:	f104 0340 	add.w	r3, r4, #64	; 0x40
1003025c:	4299      	cmp	r1, r3
1003025e:	d002      	beq.n	10030266 <_fclose_r+0x4e>
10030260:	4628      	mov	r0, r5
10030262:	f7f0 e8f2 	blx	10020448 <_free_r>
10030266:	2300      	movs	r3, #0
10030268:	6323      	str	r3, [r4, #48]	; 0x30
1003026a:	6c61      	ldr	r1, [r4, #68]	; 0x44
1003026c:	b121      	cbz	r1, 10030278 <_fclose_r+0x60>
1003026e:	4628      	mov	r0, r5
10030270:	f7f0 e8ea 	blx	10020448 <_free_r>
10030274:	2300      	movs	r3, #0
10030276:	6463      	str	r3, [r4, #68]	; 0x44
10030278:	f7ff fc84 	bl	1002fb84 <__sfp_lock_acquire>
1003027c:	2300      	movs	r3, #0
1003027e:	81a3      	strh	r3, [r4, #12]
10030280:	f7ff fc82 	bl	1002fb88 <__sfp_lock_release>
10030284:	4630      	mov	r0, r6
10030286:	bd70      	pop	{r4, r5, r6, pc}
10030288:	f7ff fc76 	bl	1002fb78 <__sinit>
1003028c:	e7cc      	b.n	10030228 <_fclose_r+0x10>
1003028e:	4628      	mov	r0, r5
10030290:	6921      	ldr	r1, [r4, #16]
10030292:	f7f0 e8da 	blx	10020448 <_free_r>
10030296:	e7dd      	b.n	10030254 <_fclose_r+0x3c>
10030298:	2000      	movs	r0, #0
1003029a:	4770      	bx	lr

1003029c <__sflush_r>:
1003029c:	898b      	ldrh	r3, [r1, #12]
1003029e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
100302a2:	4680      	mov	r8, r0
100302a4:	b29a      	uxth	r2, r3
100302a6:	460d      	mov	r5, r1
100302a8:	0710      	lsls	r0, r2, #28
100302aa:	d43c      	bmi.n	10030326 <__sflush_r+0x8a>
100302ac:	684a      	ldr	r2, [r1, #4]
100302ae:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
100302b2:	818b      	strh	r3, [r1, #12]
100302b4:	2a00      	cmp	r2, #0
100302b6:	dd78      	ble.n	100303aa <__sflush_r+0x10e>
100302b8:	6aaf      	ldr	r7, [r5, #40]	; 0x28
100302ba:	2f00      	cmp	r7, #0
100302bc:	d04c      	beq.n	10030358 <__sflush_r+0xbc>
100302be:	b29b      	uxth	r3, r3
100302c0:	f8d8 4000 	ldr.w	r4, [r8]
100302c4:	f403 5080 	and.w	r0, r3, #4096	; 0x1000
100302c8:	2200      	movs	r2, #0
100302ca:	f8c8 2000 	str.w	r2, [r8]
100302ce:	b286      	uxth	r6, r0
100302d0:	2e00      	cmp	r6, #0
100302d2:	d06e      	beq.n	100303b2 <__sflush_r+0x116>
100302d4:	6d2a      	ldr	r2, [r5, #80]	; 0x50
100302d6:	075b      	lsls	r3, r3, #29
100302d8:	d505      	bpl.n	100302e6 <__sflush_r+0x4a>
100302da:	6b2b      	ldr	r3, [r5, #48]	; 0x30
100302dc:	6869      	ldr	r1, [r5, #4]
100302de:	1a52      	subs	r2, r2, r1
100302e0:	b10b      	cbz	r3, 100302e6 <__sflush_r+0x4a>
100302e2:	6beb      	ldr	r3, [r5, #60]	; 0x3c
100302e4:	1ad2      	subs	r2, r2, r3
100302e6:	4640      	mov	r0, r8
100302e8:	69e9      	ldr	r1, [r5, #28]
100302ea:	2300      	movs	r3, #0
100302ec:	47b8      	blx	r7
100302ee:	1c46      	adds	r6, r0, #1
100302f0:	d03d      	beq.n	1003036e <__sflush_r+0xd2>
100302f2:	89ab      	ldrh	r3, [r5, #12]
100302f4:	2100      	movs	r1, #0
100302f6:	692a      	ldr	r2, [r5, #16]
100302f8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
100302fc:	6069      	str	r1, [r5, #4]
100302fe:	b29b      	uxth	r3, r3
10030300:	602a      	str	r2, [r5, #0]
10030302:	04da      	lsls	r2, r3, #19
10030304:	81ab      	strh	r3, [r5, #12]
10030306:	d44e      	bmi.n	100303a6 <__sflush_r+0x10a>
10030308:	6b29      	ldr	r1, [r5, #48]	; 0x30
1003030a:	f8c8 4000 	str.w	r4, [r8]
1003030e:	b319      	cbz	r1, 10030358 <__sflush_r+0xbc>
10030310:	f105 0340 	add.w	r3, r5, #64	; 0x40
10030314:	4299      	cmp	r1, r3
10030316:	d002      	beq.n	1003031e <__sflush_r+0x82>
10030318:	4640      	mov	r0, r8
1003031a:	f7f0 e896 	blx	10020448 <_free_r>
1003031e:	2000      	movs	r0, #0
10030320:	6328      	str	r0, [r5, #48]	; 0x30
10030322:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
10030326:	690e      	ldr	r6, [r1, #16]
10030328:	b1b6      	cbz	r6, 10030358 <__sflush_r+0xbc>
1003032a:	680c      	ldr	r4, [r1, #0]
1003032c:	600e      	str	r6, [r1, #0]
1003032e:	0791      	lsls	r1, r2, #30
10030330:	eba4 0406 	sub.w	r4, r4, r6
10030334:	bf0c      	ite	eq
10030336:	696b      	ldreq	r3, [r5, #20]
10030338:	2300      	movne	r3, #0
1003033a:	60ab      	str	r3, [r5, #8]
1003033c:	e00a      	b.n	10030354 <__sflush_r+0xb8>
1003033e:	4632      	mov	r2, r6
10030340:	4623      	mov	r3, r4
10030342:	6a6f      	ldr	r7, [r5, #36]	; 0x24
10030344:	4640      	mov	r0, r8
10030346:	69e9      	ldr	r1, [r5, #28]
10030348:	47b8      	blx	r7
1003034a:	2800      	cmp	r0, #0
1003034c:	eba4 0400 	sub.w	r4, r4, r0
10030350:	4406      	add	r6, r0
10030352:	dd04      	ble.n	1003035e <__sflush_r+0xc2>
10030354:	2c00      	cmp	r4, #0
10030356:	dcf2      	bgt.n	1003033e <__sflush_r+0xa2>
10030358:	2000      	movs	r0, #0
1003035a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1003035e:	89ab      	ldrh	r3, [r5, #12]
10030360:	f04f 30ff 	mov.w	r0, #4294967295
10030364:	f043 0340 	orr.w	r3, r3, #64	; 0x40
10030368:	81ab      	strh	r3, [r5, #12]
1003036a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1003036e:	f8d8 2000 	ldr.w	r2, [r8]
10030372:	fab2 f182 	clz	r1, r2
10030376:	0949      	lsrs	r1, r1, #5
10030378:	2a1d      	cmp	r2, #29
1003037a:	bf14      	ite	ne
1003037c:	460b      	movne	r3, r1
1003037e:	f041 0301 	orreq.w	r3, r1, #1
10030382:	2a16      	cmp	r2, #22
10030384:	bf08      	it	eq
10030386:	f043 0301 	orreq.w	r3, r3, #1
1003038a:	b353      	cbz	r3, 100303e2 <__sflush_r+0x146>
1003038c:	89ab      	ldrh	r3, [r5, #12]
1003038e:	2600      	movs	r6, #0
10030390:	692a      	ldr	r2, [r5, #16]
10030392:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
10030396:	606e      	str	r6, [r5, #4]
10030398:	b29b      	uxth	r3, r3
1003039a:	81ab      	strh	r3, [r5, #12]
1003039c:	04db      	lsls	r3, r3, #19
1003039e:	602a      	str	r2, [r5, #0]
100303a0:	d5b2      	bpl.n	10030308 <__sflush_r+0x6c>
100303a2:	2900      	cmp	r1, #0
100303a4:	d0b0      	beq.n	10030308 <__sflush_r+0x6c>
100303a6:	6528      	str	r0, [r5, #80]	; 0x50
100303a8:	e7ae      	b.n	10030308 <__sflush_r+0x6c>
100303aa:	6bca      	ldr	r2, [r1, #60]	; 0x3c
100303ac:	2a00      	cmp	r2, #0
100303ae:	dc83      	bgt.n	100302b8 <__sflush_r+0x1c>
100303b0:	e7d2      	b.n	10030358 <__sflush_r+0xbc>
100303b2:	69e9      	ldr	r1, [r5, #28]
100303b4:	4632      	mov	r2, r6
100303b6:	4640      	mov	r0, r8
100303b8:	2301      	movs	r3, #1
100303ba:	47b8      	blx	r7
100303bc:	1c41      	adds	r1, r0, #1
100303be:	4602      	mov	r2, r0
100303c0:	d002      	beq.n	100303c8 <__sflush_r+0x12c>
100303c2:	89ab      	ldrh	r3, [r5, #12]
100303c4:	6aaf      	ldr	r7, [r5, #40]	; 0x28
100303c6:	e786      	b.n	100302d6 <__sflush_r+0x3a>
100303c8:	f8d8 3000 	ldr.w	r3, [r8]
100303cc:	2b00      	cmp	r3, #0
100303ce:	d0f8      	beq.n	100303c2 <__sflush_r+0x126>
100303d0:	2b1d      	cmp	r3, #29
100303d2:	bf18      	it	ne
100303d4:	2b16      	cmpne	r3, #22
100303d6:	d1c2      	bne.n	1003035e <__sflush_r+0xc2>
100303d8:	f8c8 4000 	str.w	r4, [r8]
100303dc:	4630      	mov	r0, r6
100303de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
100303e2:	89ab      	ldrh	r3, [r5, #12]
100303e4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
100303e8:	81ab      	strh	r3, [r5, #12]
100303ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
100303ee:	bf00      	nop

100303f0 <_fflush_r>:
100303f0:	b510      	push	{r4, lr}
100303f2:	4604      	mov	r4, r0
100303f4:	b082      	sub	sp, #8
100303f6:	b108      	cbz	r0, 100303fc <_fflush_r+0xc>
100303f8:	6b83      	ldr	r3, [r0, #56]	; 0x38
100303fa:	b153      	cbz	r3, 10030412 <_fflush_r+0x22>
100303fc:	f9b1 000c 	ldrsh.w	r0, [r1, #12]
10030400:	b908      	cbnz	r0, 10030406 <_fflush_r+0x16>
10030402:	b002      	add	sp, #8
10030404:	bd10      	pop	{r4, pc}
10030406:	4620      	mov	r0, r4
10030408:	b002      	add	sp, #8
1003040a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
1003040e:	f7ff bf45 	b.w	1003029c <__sflush_r>
10030412:	9101      	str	r1, [sp, #4]
10030414:	f7ff fbb0 	bl	1002fb78 <__sinit>
10030418:	9901      	ldr	r1, [sp, #4]
1003041a:	e7ef      	b.n	100303fc <_fflush_r+0xc>

1003041c <__smakebuf_r>:
1003041c:	898b      	ldrh	r3, [r1, #12]
1003041e:	b29a      	uxth	r2, r3
10030420:	f012 0f02 	tst.w	r2, #2
10030424:	d141      	bne.n	100304aa <__smakebuf_r+0x8e>
10030426:	b5f0      	push	{r4, r5, r6, r7, lr}
10030428:	460c      	mov	r4, r1
1003042a:	89c9      	ldrh	r1, [r1, #14]
1003042c:	b091      	sub	sp, #68	; 0x44
1003042e:	4605      	mov	r5, r0
10030430:	b209      	sxth	r1, r1
10030432:	2900      	cmp	r1, #0
10030434:	db19      	blt.n	1003046a <__smakebuf_r+0x4e>
10030436:	aa01      	add	r2, sp, #4
10030438:	f7ef ed98 	blx	1001ff6c <_fstat_r>
1003043c:	2800      	cmp	r0, #0
1003043e:	db12      	blt.n	10030466 <__smakebuf_r+0x4a>
10030440:	9b02      	ldr	r3, [sp, #8]
10030442:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
10030446:	f5a3 5700 	sub.w	r7, r3, #8192	; 0x2000
1003044a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
1003044e:	fab7 f787 	clz	r7, r7
10030452:	ea4f 1757 	mov.w	r7, r7, lsr #5
10030456:	d02f      	beq.n	100304b8 <__smakebuf_r+0x9c>
10030458:	89a3      	ldrh	r3, [r4, #12]
1003045a:	f44f 6680 	mov.w	r6, #1024	; 0x400
1003045e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
10030462:	81a3      	strh	r3, [r4, #12]
10030464:	e00c      	b.n	10030480 <__smakebuf_r+0x64>
10030466:	89a3      	ldrh	r3, [r4, #12]
10030468:	b29a      	uxth	r2, r3
1003046a:	f012 0f80 	tst.w	r2, #128	; 0x80
1003046e:	f04f 0700 	mov.w	r7, #0
10030472:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
10030476:	81a3      	strh	r3, [r4, #12]
10030478:	bf0c      	ite	eq
1003047a:	f44f 6680 	moveq.w	r6, #1024	; 0x400
1003047e:	2640      	movne	r6, #64	; 0x40
10030480:	4628      	mov	r0, r5
10030482:	4631      	mov	r1, r6
10030484:	f7ef ef6c 	blx	10020360 <_malloc_r>
10030488:	89a3      	ldrh	r3, [r4, #12]
1003048a:	2800      	cmp	r0, #0
1003048c:	d02f      	beq.n	100304ee <__smakebuf_r+0xd2>
1003048e:	f64f 226d 	movw	r2, #64109	; 0xfa6d
10030492:	f043 0380 	orr.w	r3, r3, #128	; 0x80
10030496:	f2c1 0202 	movt	r2, #4098	; 0x1002
1003049a:	63ea      	str	r2, [r5, #60]	; 0x3c
1003049c:	6020      	str	r0, [r4, #0]
1003049e:	6120      	str	r0, [r4, #16]
100304a0:	6166      	str	r6, [r4, #20]
100304a2:	81a3      	strh	r3, [r4, #12]
100304a4:	b9bf      	cbnz	r7, 100304d6 <__smakebuf_r+0xba>
100304a6:	b011      	add	sp, #68	; 0x44
100304a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
100304aa:	f101 0343 	add.w	r3, r1, #67	; 0x43
100304ae:	2201      	movs	r2, #1
100304b0:	600b      	str	r3, [r1, #0]
100304b2:	610b      	str	r3, [r1, #16]
100304b4:	614a      	str	r2, [r1, #20]
100304b6:	4770      	bx	lr
100304b8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
100304ba:	f240 132d 	movw	r3, #301	; 0x12d
100304be:	f2c1 0303 	movt	r3, #4099	; 0x1003
100304c2:	429a      	cmp	r2, r3
100304c4:	d1c8      	bne.n	10030458 <__smakebuf_r+0x3c>
100304c6:	89a3      	ldrh	r3, [r4, #12]
100304c8:	f44f 6280 	mov.w	r2, #1024	; 0x400
100304cc:	4616      	mov	r6, r2
100304ce:	64e2      	str	r2, [r4, #76]	; 0x4c
100304d0:	4313      	orrs	r3, r2
100304d2:	81a3      	strh	r3, [r4, #12]
100304d4:	e7d4      	b.n	10030480 <__smakebuf_r+0x64>
100304d6:	4628      	mov	r0, r5
100304d8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
100304dc:	f7ef ed74 	blx	1001ffc8 <_isatty_r>
100304e0:	2800      	cmp	r0, #0
100304e2:	d0e0      	beq.n	100304a6 <__smakebuf_r+0x8a>
100304e4:	89a3      	ldrh	r3, [r4, #12]
100304e6:	f043 0301 	orr.w	r3, r3, #1
100304ea:	81a3      	strh	r3, [r4, #12]
100304ec:	e7db      	b.n	100304a6 <__smakebuf_r+0x8a>
100304ee:	059a      	lsls	r2, r3, #22
100304f0:	d4d9      	bmi.n	100304a6 <__smakebuf_r+0x8a>
100304f2:	f043 0302 	orr.w	r3, r3, #2
100304f6:	f104 0243 	add.w	r2, r4, #67	; 0x43
100304fa:	81a3      	strh	r3, [r4, #12]
100304fc:	2301      	movs	r3, #1
100304fe:	6022      	str	r2, [r4, #0]
10030500:	6122      	str	r2, [r4, #16]
10030502:	6163      	str	r3, [r4, #20]
10030504:	e7cf      	b.n	100304a6 <__smakebuf_r+0x8a>
10030506:	bf00      	nop

10030508 <ceil>:
10030508:	b470      	push	{r4, r5, r6}
1003050a:	b083      	sub	sp, #12
1003050c:	ed8d 0b00 	vstr	d0, [sp]
10030510:	9901      	ldr	r1, [sp, #4]
10030512:	9c00      	ldr	r4, [sp, #0]
10030514:	f3c1 520a 	ubfx	r2, r1, #20, #11
10030518:	f2a2 33ff 	subw	r3, r2, #1023	; 0x3ff
1003051c:	460d      	mov	r5, r1
1003051e:	2b13      	cmp	r3, #19
10030520:	4620      	mov	r0, r4
10030522:	dc27      	bgt.n	10030574 <ceil+0x6c>
10030524:	2b00      	cmp	r3, #0
10030526:	db58      	blt.n	100305da <ceil+0xd2>
10030528:	f64f 72ff 	movw	r2, #65535	; 0xffff
1003052c:	f2c0 020f 	movt	r2, #15
10030530:	411a      	asrs	r2, r3
10030532:	ea02 0601 	and.w	r6, r2, r1
10030536:	4334      	orrs	r4, r6
10030538:	d021      	beq.n	1003057e <ceil+0x76>
1003053a:	ed9f 7b37 	vldr	d7, [pc, #220]	; 10030618 <ceil+0x110>
1003053e:	ed9d 6b00 	vldr	d6, [sp]
10030542:	ee36 7b07 	vadd.f64	d7, d6, d7
10030546:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
1003054a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
1003054e:	dd0a      	ble.n	10030566 <ceil+0x5e>
10030550:	2900      	cmp	r1, #0
10030552:	f04f 0000 	mov.w	r0, #0
10030556:	bfc2      	ittt	gt
10030558:	f44f 1180 	movgt.w	r1, #1048576	; 0x100000
1003055c:	fa41 f303 	asrgt.w	r3, r1, r3
10030560:	18ed      	addgt	r5, r5, r3
10030562:	ea25 0102 	bic.w	r1, r5, r2
10030566:	460b      	mov	r3, r1
10030568:	4602      	mov	r2, r0
1003056a:	ec43 2b10 	vmov	d0, r2, r3
1003056e:	b003      	add	sp, #12
10030570:	bc70      	pop	{r4, r5, r6}
10030572:	4770      	bx	lr
10030574:	2b33      	cmp	r3, #51	; 0x33
10030576:	dd07      	ble.n	10030588 <ceil+0x80>
10030578:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
1003057c:	d041      	beq.n	10030602 <ceil+0xfa>
1003057e:	ed9d 0b00 	vldr	d0, [sp]
10030582:	b003      	add	sp, #12
10030584:	bc70      	pop	{r4, r5, r6}
10030586:	4770      	bx	lr
10030588:	f2a2 4613 	subw	r6, r2, #1043	; 0x413
1003058c:	f04f 34ff 	mov.w	r4, #4294967295
10030590:	40f4      	lsrs	r4, r6
10030592:	4204      	tst	r4, r0
10030594:	d0f3      	beq.n	1003057e <ceil+0x76>
10030596:	ed9f 7b20 	vldr	d7, [pc, #128]	; 10030618 <ceil+0x110>
1003059a:	ed9d 6b00 	vldr	d6, [sp]
1003059e:	ee36 7b07 	vadd.f64	d7, d6, d7
100305a2:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
100305a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100305aa:	dddc      	ble.n	10030566 <ceil+0x5e>
100305ac:	2900      	cmp	r1, #0
100305ae:	dd0c      	ble.n	100305ca <ceil+0xc2>
100305b0:	2b14      	cmp	r3, #20
100305b2:	bf08      	it	eq
100305b4:	3501      	addeq	r5, #1
100305b6:	d008      	beq.n	100305ca <ceil+0xc2>
100305b8:	f5c2 6286 	rsb	r2, r2, #1072	; 0x430
100305bc:	2101      	movs	r1, #1
100305be:	3203      	adds	r2, #3
100305c0:	4091      	lsls	r1, r2
100305c2:	1809      	adds	r1, r1, r0
100305c4:	bf28      	it	cs
100305c6:	3501      	addcs	r5, #1
100305c8:	4608      	mov	r0, r1
100305ca:	ea20 0004 	bic.w	r0, r0, r4
100305ce:	4629      	mov	r1, r5
100305d0:	460b      	mov	r3, r1
100305d2:	4602      	mov	r2, r0
100305d4:	ec43 2b10 	vmov	d0, r2, r3
100305d8:	e7c9      	b.n	1003056e <ceil+0x66>
100305da:	ed9f 7b0f 	vldr	d7, [pc, #60]	; 10030618 <ceil+0x110>
100305de:	ee30 7b07 	vadd.f64	d7, d0, d7
100305e2:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
100305e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100305ea:	ddbc      	ble.n	10030566 <ceil+0x5e>
100305ec:	2900      	cmp	r1, #0
100305ee:	db0d      	blt.n	1003060c <ceil+0x104>
100305f0:	4321      	orrs	r1, r4
100305f2:	bf08      	it	eq
100305f4:	4608      	moveq	r0, r1
100305f6:	d0b6      	beq.n	10030566 <ceil+0x5e>
100305f8:	2100      	movs	r1, #0
100305fa:	4608      	mov	r0, r1
100305fc:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
10030600:	e7b1      	b.n	10030566 <ceil+0x5e>
10030602:	ed9d 7b00 	vldr	d7, [sp]
10030606:	ee37 0b07 	vadd.f64	d0, d7, d7
1003060a:	e7ba      	b.n	10030582 <ceil+0x7a>
1003060c:	2000      	movs	r0, #0
1003060e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
10030612:	e7a8      	b.n	10030566 <ceil+0x5e>
10030614:	f3af 8000 	nop.w
10030618:	8800759c 	.word	0x8800759c
1003061c:	7e37e43c 	.word	0x7e37e43c

10030620 <cosf>:
10030620:	ee10 3a10 	vmov	r3, s0
10030624:	f640 72d8 	movw	r2, #4056	; 0xfd8
10030628:	f6c3 7249 	movt	r2, #16201	; 0x3f49
1003062c:	b500      	push	{lr}
1003062e:	b083      	sub	sp, #12
10030630:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10030634:	4293      	cmp	r3, r2
10030636:	dd1a      	ble.n	1003066e <cosf+0x4e>
10030638:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
1003063c:	bfa8      	it	ge
1003063e:	ee30 0a40 	vsubge.f32	s0, s0, s0
10030642:	db02      	blt.n	1003064a <cosf+0x2a>
10030644:	b003      	add	sp, #12
10030646:	f85d fb04 	ldr.w	pc, [sp], #4
1003064a:	4668      	mov	r0, sp
1003064c:	f001 f80c 	bl	10031668 <__ieee754_rem_pio2f>
10030650:	ed9d 0a00 	vldr	s0, [sp]
10030654:	f000 0003 	and.w	r0, r0, #3
10030658:	2801      	cmp	r0, #1
1003065a:	d016      	beq.n	1003068a <cosf+0x6a>
1003065c:	2802      	cmp	r0, #2
1003065e:	d00d      	beq.n	1003067c <cosf+0x5c>
10030660:	b1d0      	cbz	r0, 10030698 <cosf+0x78>
10030662:	2001      	movs	r0, #1
10030664:	eddd 0a01 	vldr	s1, [sp, #4]
10030668:	f001 fcae 	bl	10031fc8 <__kernel_sinf>
1003066c:	e7ea      	b.n	10030644 <cosf+0x24>
1003066e:	eddf 0a0d 	vldr	s1, [pc, #52]	; 100306a4 <cosf+0x84>
10030672:	f001 f933 	bl	100318dc <__kernel_cosf>
10030676:	b003      	add	sp, #12
10030678:	f85d fb04 	ldr.w	pc, [sp], #4
1003067c:	eddd 0a01 	vldr	s1, [sp, #4]
10030680:	f001 f92c 	bl	100318dc <__kernel_cosf>
10030684:	eeb1 0a40 	vneg.f32	s0, s0
10030688:	e7dc      	b.n	10030644 <cosf+0x24>
1003068a:	eddd 0a01 	vldr	s1, [sp, #4]
1003068e:	f001 fc9b 	bl	10031fc8 <__kernel_sinf>
10030692:	eeb1 0a40 	vneg.f32	s0, s0
10030696:	e7d5      	b.n	10030644 <cosf+0x24>
10030698:	eddd 0a01 	vldr	s1, [sp, #4]
1003069c:	f001 f91e 	bl	100318dc <__kernel_cosf>
100306a0:	e7d0      	b.n	10030644 <cosf+0x24>
100306a2:	bf00      	nop
100306a4:	00000000 	.word	0x00000000

100306a8 <sinf>:
100306a8:	ee10 3a10 	vmov	r3, s0
100306ac:	f640 72d8 	movw	r2, #4056	; 0xfd8
100306b0:	f6c3 7249 	movt	r2, #16201	; 0x3f49
100306b4:	b500      	push	{lr}
100306b6:	b083      	sub	sp, #12
100306b8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
100306bc:	4293      	cmp	r3, r2
100306be:	dd1b      	ble.n	100306f8 <sinf+0x50>
100306c0:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
100306c4:	bfa8      	it	ge
100306c6:	ee30 0a40 	vsubge.f32	s0, s0, s0
100306ca:	db02      	blt.n	100306d2 <sinf+0x2a>
100306cc:	b003      	add	sp, #12
100306ce:	f85d fb04 	ldr.w	pc, [sp], #4
100306d2:	4668      	mov	r0, sp
100306d4:	f000 ffc8 	bl	10031668 <__ieee754_rem_pio2f>
100306d8:	ed9d 0a00 	vldr	s0, [sp]
100306dc:	f000 0003 	and.w	r0, r0, #3
100306e0:	2801      	cmp	r0, #1
100306e2:	d019      	beq.n	10030718 <sinf+0x70>
100306e4:	2802      	cmp	r0, #2
100306e6:	d00f      	beq.n	10030708 <sinf+0x60>
100306e8:	b1d8      	cbz	r0, 10030722 <sinf+0x7a>
100306ea:	eddd 0a01 	vldr	s1, [sp, #4]
100306ee:	f001 f8f5 	bl	100318dc <__kernel_cosf>
100306f2:	eeb1 0a40 	vneg.f32	s0, s0
100306f6:	e7e9      	b.n	100306cc <sinf+0x24>
100306f8:	eddf 0a0d 	vldr	s1, [pc, #52]	; 10030730 <sinf+0x88>
100306fc:	2000      	movs	r0, #0
100306fe:	f001 fc63 	bl	10031fc8 <__kernel_sinf>
10030702:	b003      	add	sp, #12
10030704:	f85d fb04 	ldr.w	pc, [sp], #4
10030708:	2001      	movs	r0, #1
1003070a:	eddd 0a01 	vldr	s1, [sp, #4]
1003070e:	f001 fc5b 	bl	10031fc8 <__kernel_sinf>
10030712:	eeb1 0a40 	vneg.f32	s0, s0
10030716:	e7d9      	b.n	100306cc <sinf+0x24>
10030718:	eddd 0a01 	vldr	s1, [sp, #4]
1003071c:	f001 f8de 	bl	100318dc <__kernel_cosf>
10030720:	e7d4      	b.n	100306cc <sinf+0x24>
10030722:	2001      	movs	r0, #1
10030724:	eddd 0a01 	vldr	s1, [sp, #4]
10030728:	f001 fc4e 	bl	10031fc8 <__kernel_sinf>
1003072c:	e7ce      	b.n	100306cc <sinf+0x24>
1003072e:	bf00      	nop
10030730:	00000000 	.word	0x00000000

10030734 <log>:
10030734:	b510      	push	{r4, lr}
10030736:	f646 54c0 	movw	r4, #28096	; 0x6dc0
1003073a:	ed2d 8b04 	vpush	{d8-d9}
1003073e:	f2c1 0403 	movt	r4, #4099	; 0x1003
10030742:	eeb0 9b40 	vmov.f64	d9, d0
10030746:	b08a      	sub	sp, #40	; 0x28
10030748:	f000 f9ea 	bl	10030b20 <__ieee754_log>
1003074c:	f994 3000 	ldrsb.w	r3, [r4]
10030750:	3301      	adds	r3, #1
10030752:	eeb0 8b40 	vmov.f64	d8, d0
10030756:	d009      	beq.n	1003076c <log+0x38>
10030758:	eeb0 0b49 	vmov.f64	d0, d9
1003075c:	f001 fc8c 	bl	10032078 <__fpclassifyd>
10030760:	b120      	cbz	r0, 1003076c <log+0x38>
10030762:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
10030766:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
1003076a:	dd05      	ble.n	10030778 <log+0x44>
1003076c:	eeb0 0b48 	vmov.f64	d0, d8
10030770:	b00a      	add	sp, #40	; 0x28
10030772:	ecbd 8b04 	vpop	{d8-d9}
10030776:	bd10      	pop	{r4, pc}
10030778:	7822      	ldrb	r2, [r4, #0]
1003077a:	f246 33e4 	movw	r3, #25572	; 0x63e4
1003077e:	f2c1 0303 	movt	r3, #4099	; 0x1003
10030782:	2100      	movs	r1, #0
10030784:	ed8d 9b02 	vstr	d9, [sp, #8]
10030788:	9301      	str	r3, [sp, #4]
1003078a:	9108      	str	r1, [sp, #32]
1003078c:	ed8d 9b04 	vstr	d9, [sp, #16]
10030790:	b99a      	cbnz	r2, 100307ba <log+0x86>
10030792:	f64f 73ff 	movw	r3, #65535	; 0xffff
10030796:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
1003079a:	f2cc 73ef 	movt	r3, #51183	; 0xc7ef
1003079e:	e9cd 2306 	strd	r2, r3, [sp, #24]
100307a2:	eeb5 9b40 	vcmp.f64	d9, #0.0
100307a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100307aa:	d038      	beq.n	1003081e <log+0xea>
100307ac:	2301      	movs	r3, #1
100307ae:	9300      	str	r3, [sp, #0]
100307b0:	4668      	mov	r0, sp
100307b2:	f001 fc8d 	bl	100320d0 <matherr>
100307b6:	b9a0      	cbnz	r0, 100307e2 <log+0xae>
100307b8:	e00f      	b.n	100307da <log+0xa6>
100307ba:	eeb5 9b40 	vcmp.f64	d9, #0.0
100307be:	2100      	movs	r1, #0
100307c0:	2000      	movs	r0, #0
100307c2:	f6cf 71f0 	movt	r1, #65520	; 0xfff0
100307c6:	e9cd 0106 	strd	r0, r1, [sp, #24]
100307ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100307ce:	d018      	beq.n	10030802 <log+0xce>
100307d0:	2a02      	cmp	r2, #2
100307d2:	f04f 0301 	mov.w	r3, #1
100307d6:	9300      	str	r3, [sp, #0]
100307d8:	d1ea      	bne.n	100307b0 <log+0x7c>
100307da:	f7d8 eac6 	blx	10008d68 <__errno>
100307de:	2321      	movs	r3, #33	; 0x21
100307e0:	6003      	str	r3, [r0, #0]
100307e2:	f246 30e8 	movw	r0, #25576	; 0x63e8
100307e6:	f2c1 0003 	movt	r0, #4099	; 0x1003
100307ea:	f001 fc75 	bl	100320d8 <nan>
100307ee:	ed8d 0b06 	vstr	d0, [sp, #24]
100307f2:	9b08      	ldr	r3, [sp, #32]
100307f4:	b9b3      	cbnz	r3, 10030824 <log+0xf0>
100307f6:	ed9d 0b06 	vldr	d0, [sp, #24]
100307fa:	b00a      	add	sp, #40	; 0x28
100307fc:	ecbd 8b04 	vpop	{d8-d9}
10030800:	bd10      	pop	{r4, pc}
10030802:	2302      	movs	r3, #2
10030804:	429a      	cmp	r2, r3
10030806:	9300      	str	r3, [sp, #0]
10030808:	d004      	beq.n	10030814 <log+0xe0>
1003080a:	4668      	mov	r0, sp
1003080c:	f001 fc60 	bl	100320d0 <matherr>
10030810:	2800      	cmp	r0, #0
10030812:	d1ee      	bne.n	100307f2 <log+0xbe>
10030814:	f7d8 eaa8 	blx	10008d68 <__errno>
10030818:	2322      	movs	r3, #34	; 0x22
1003081a:	6003      	str	r3, [r0, #0]
1003081c:	e7e9      	b.n	100307f2 <log+0xbe>
1003081e:	2302      	movs	r3, #2
10030820:	9300      	str	r3, [sp, #0]
10030822:	e7f2      	b.n	1003080a <log+0xd6>
10030824:	f7d8 eaa0 	blx	10008d68 <__errno>
10030828:	9b08      	ldr	r3, [sp, #32]
1003082a:	6003      	str	r3, [r0, #0]
1003082c:	e7e3      	b.n	100307f6 <log+0xc2>
1003082e:	bf00      	nop

10030830 <pow>:
10030830:	b5f0      	push	{r4, r5, r6, r7, lr}
10030832:	f646 54c0 	movw	r4, #28096	; 0x6dc0
10030836:	ed2d 8b08 	vpush	{d8-d11}
1003083a:	f2c1 0403 	movt	r4, #4099	; 0x1003
1003083e:	eeb0 ab40 	vmov.f64	d10, d0
10030842:	b08b      	sub	sp, #44	; 0x2c
10030844:	eeb0 9b41 	vmov.f64	d9, d1
10030848:	f000 faa6 	bl	10030d98 <__ieee754_pow>
1003084c:	f994 3000 	ldrsb.w	r3, [r4]
10030850:	3301      	adds	r3, #1
10030852:	eeb0 8b40 	vmov.f64	d8, d0
10030856:	d004      	beq.n	10030862 <pow+0x32>
10030858:	eeb0 0b49 	vmov.f64	d0, d9
1003085c:	f001 fc0c 	bl	10032078 <__fpclassifyd>
10030860:	b928      	cbnz	r0, 1003086e <pow+0x3e>
10030862:	eeb0 0b48 	vmov.f64	d0, d8
10030866:	b00b      	add	sp, #44	; 0x2c
10030868:	ecbd 8b08 	vpop	{d8-d11}
1003086c:	bdf0      	pop	{r4, r5, r6, r7, pc}
1003086e:	eeb0 0b4a 	vmov.f64	d0, d10
10030872:	f001 fc01 	bl	10032078 <__fpclassifyd>
10030876:	bb10      	cbnz	r0, 100308be <pow+0x8e>
10030878:	eeb5 9b40 	vcmp.f64	d9, #0.0
1003087c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10030880:	d1ef      	bne.n	10030862 <pow+0x32>
10030882:	7822      	ldrb	r2, [r4, #0]
10030884:	2700      	movs	r7, #0
10030886:	f246 33ec 	movw	r3, #25580	; 0x63ec
1003088a:	2600      	movs	r6, #0
1003088c:	2aff      	cmp	r2, #255	; 0xff
1003088e:	bf18      	it	ne
10030890:	2a02      	cmpne	r2, #2
10030892:	f6c3 77f0 	movt	r7, #16368	; 0x3ff0
10030896:	f2c1 0303 	movt	r3, #4099	; 0x1003
1003089a:	f04f 0101 	mov.w	r1, #1
1003089e:	9008      	str	r0, [sp, #32]
100308a0:	ed8d ab02 	vstr	d10, [sp, #8]
100308a4:	e88d 000a 	stmia.w	sp, {r1, r3}
100308a8:	e9cd 6706 	strd	r6, r7, [sp, #24]
100308ac:	ed8d 9b04 	vstr	d9, [sp, #16]
100308b0:	d12a      	bne.n	10030908 <pow+0xd8>
100308b2:	ed9d 0b06 	vldr	d0, [sp, #24]
100308b6:	b00b      	add	sp, #44	; 0x2c
100308b8:	ecbd 8b08 	vpop	{d8-d11}
100308bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
100308be:	ed9f bb96 	vldr	d11, [pc, #600]	; 10030b18 <pow+0x2e8>
100308c2:	eeb4 ab4b 	vcmp.f64	d10, d11
100308c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100308ca:	d12a      	bne.n	10030922 <pow+0xf2>
100308cc:	eeb4 9b4b 	vcmp.f64	d9, d11
100308d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100308d4:	d15e      	bne.n	10030994 <pow+0x164>
100308d6:	f994 2000 	ldrsb.w	r2, [r4]
100308da:	f246 33ec 	movw	r3, #25580	; 0x63ec
100308de:	f2c1 0303 	movt	r3, #4099	; 0x1003
100308e2:	2001      	movs	r0, #1
100308e4:	2100      	movs	r1, #0
100308e6:	ed8d ab02 	vstr	d10, [sp, #8]
100308ea:	e88d 0009 	stmia.w	sp, {r0, r3}
100308ee:	9108      	str	r1, [sp, #32]
100308f0:	ed8d 9b04 	vstr	d9, [sp, #16]
100308f4:	ed8d bb06 	vstr	d11, [sp, #24]
100308f8:	b132      	cbz	r2, 10030908 <pow+0xd8>
100308fa:	2300      	movs	r3, #0
100308fc:	2200      	movs	r2, #0
100308fe:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
10030902:	e9cd 2306 	strd	r2, r3, [sp, #24]
10030906:	e7d4      	b.n	100308b2 <pow+0x82>
10030908:	4668      	mov	r0, sp
1003090a:	f001 fbe1 	bl	100320d0 <matherr>
1003090e:	2800      	cmp	r0, #0
10030910:	d072      	beq.n	100309f8 <pow+0x1c8>
10030912:	9b08      	ldr	r3, [sp, #32]
10030914:	2b00      	cmp	r3, #0
10030916:	d0cc      	beq.n	100308b2 <pow+0x82>
10030918:	f7d8 ea26 	blx	10008d68 <__errno>
1003091c:	9b08      	ldr	r3, [sp, #32]
1003091e:	6003      	str	r3, [r0, #0]
10030920:	e7c7      	b.n	100308b2 <pow+0x82>
10030922:	eeb0 0b48 	vmov.f64	d0, d8
10030926:	f001 fb9f 	bl	10032068 <finite>
1003092a:	4605      	mov	r5, r0
1003092c:	2800      	cmp	r0, #0
1003092e:	d068      	beq.n	10030a02 <pow+0x1d2>
10030930:	eeb5 8b40 	vcmp.f64	d8, #0.0
10030934:	2600      	movs	r6, #0
10030936:	2700      	movs	r7, #0
10030938:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
1003093c:	d191      	bne.n	10030862 <pow+0x32>
1003093e:	eeb0 0b4a 	vmov.f64	d0, d10
10030942:	f001 fb91 	bl	10032068 <finite>
10030946:	2800      	cmp	r0, #0
10030948:	d08b      	beq.n	10030862 <pow+0x32>
1003094a:	eeb0 0b49 	vmov.f64	d0, d9
1003094e:	f001 fb8b 	bl	10032068 <finite>
10030952:	2800      	cmp	r0, #0
10030954:	d085      	beq.n	10030862 <pow+0x32>
10030956:	f994 2000 	ldrsb.w	r2, [r4]
1003095a:	f246 33ec 	movw	r3, #25580	; 0x63ec
1003095e:	f2c1 0303 	movt	r3, #4099	; 0x1003
10030962:	2004      	movs	r0, #4
10030964:	2a02      	cmp	r2, #2
10030966:	f04f 0100 	mov.w	r1, #0
1003096a:	ed8d ab02 	vstr	d10, [sp, #8]
1003096e:	e9cd 6706 	strd	r6, r7, [sp, #24]
10030972:	e88d 0009 	stmia.w	sp, {r0, r3}
10030976:	ed8d 9b04 	vstr	d9, [sp, #16]
1003097a:	9108      	str	r1, [sp, #32]
1003097c:	f000 8090 	beq.w	10030aa0 <pow+0x270>
10030980:	4668      	mov	r0, sp
10030982:	f001 fba5 	bl	100320d0 <matherr>
10030986:	2800      	cmp	r0, #0
10030988:	f000 808a 	beq.w	10030aa0 <pow+0x270>
1003098c:	9b08      	ldr	r3, [sp, #32]
1003098e:	2b00      	cmp	r3, #0
10030990:	d08f      	beq.n	100308b2 <pow+0x82>
10030992:	e7c1      	b.n	10030918 <pow+0xe8>
10030994:	eeb0 0b49 	vmov.f64	d0, d9
10030998:	f001 fb66 	bl	10032068 <finite>
1003099c:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
100309a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100309a4:	bf4c      	ite	mi
100309a6:	2301      	movmi	r3, #1
100309a8:	2300      	movpl	r3, #0
100309aa:	2800      	cmp	r0, #0
100309ac:	bf0c      	ite	eq
100309ae:	2000      	moveq	r0, #0
100309b0:	f003 0001 	andne.w	r0, r3, #1
100309b4:	2800      	cmp	r0, #0
100309b6:	f43f af54 	beq.w	10030862 <pow+0x32>
100309ba:	7822      	ldrb	r2, [r4, #0]
100309bc:	f246 33ec 	movw	r3, #25580	; 0x63ec
100309c0:	f2c1 0303 	movt	r3, #4099	; 0x1003
100309c4:	2101      	movs	r1, #1
100309c6:	9301      	str	r3, [sp, #4]
100309c8:	2300      	movs	r3, #0
100309ca:	ed8d ab02 	vstr	d10, [sp, #8]
100309ce:	9100      	str	r1, [sp, #0]
100309d0:	9308      	str	r3, [sp, #32]
100309d2:	ed8d 9b04 	vstr	d9, [sp, #16]
100309d6:	2a00      	cmp	r2, #0
100309d8:	d03e      	beq.n	10030a58 <pow+0x228>
100309da:	2a02      	cmp	r2, #2
100309dc:	f04f 0100 	mov.w	r1, #0
100309e0:	f04f 0000 	mov.w	r0, #0
100309e4:	f6cf 71f0 	movt	r1, #65520	; 0xfff0
100309e8:	e9cd 0106 	strd	r0, r1, [sp, #24]
100309ec:	d12e      	bne.n	10030a4c <pow+0x21c>
100309ee:	f7d8 e9bc 	blx	10008d68 <__errno>
100309f2:	2321      	movs	r3, #33	; 0x21
100309f4:	6003      	str	r3, [r0, #0]
100309f6:	e7c9      	b.n	1003098c <pow+0x15c>
100309f8:	f7d8 e9b6 	blx	10008d68 <__errno>
100309fc:	2321      	movs	r3, #33	; 0x21
100309fe:	6003      	str	r3, [r0, #0]
10030a00:	e787      	b.n	10030912 <pow+0xe2>
10030a02:	eeb0 0b4a 	vmov.f64	d0, d10
10030a06:	f001 fb2f 	bl	10032068 <finite>
10030a0a:	2800      	cmp	r0, #0
10030a0c:	d090      	beq.n	10030930 <pow+0x100>
10030a0e:	eeb0 0b49 	vmov.f64	d0, d9
10030a12:	f001 fb29 	bl	10032068 <finite>
10030a16:	2800      	cmp	r0, #0
10030a18:	d08a      	beq.n	10030930 <pow+0x100>
10030a1a:	eeb0 0b48 	vmov.f64	d0, d8
10030a1e:	f001 fb2b 	bl	10032078 <__fpclassifyd>
10030a22:	b9e0      	cbnz	r0, 10030a5e <pow+0x22e>
10030a24:	7822      	ldrb	r2, [r4, #0]
10030a26:	f246 33ec 	movw	r3, #25580	; 0x63ec
10030a2a:	f2c1 0303 	movt	r3, #4099	; 0x1003
10030a2e:	2101      	movs	r1, #1
10030a30:	9008      	str	r0, [sp, #32]
10030a32:	ed8d ab02 	vstr	d10, [sp, #8]
10030a36:	e88d 000a 	stmia.w	sp, {r1, r3}
10030a3a:	ed8d 9b04 	vstr	d9, [sp, #16]
10030a3e:	b15a      	cbz	r2, 10030a58 <pow+0x228>
10030a40:	2a02      	cmp	r2, #2
10030a42:	ee8b bb0b 	vdiv.f64	d11, d11, d11
10030a46:	ed8d bb06 	vstr	d11, [sp, #24]
10030a4a:	d0d0      	beq.n	100309ee <pow+0x1be>
10030a4c:	4668      	mov	r0, sp
10030a4e:	f001 fb3f 	bl	100320d0 <matherr>
10030a52:	2800      	cmp	r0, #0
10030a54:	d19a      	bne.n	1003098c <pow+0x15c>
10030a56:	e7ca      	b.n	100309ee <pow+0x1be>
10030a58:	ed8d bb06 	vstr	d11, [sp, #24]
10030a5c:	e7f6      	b.n	10030a4c <pow+0x21c>
10030a5e:	f994 2000 	ldrsb.w	r2, [r4]
10030a62:	f246 33ec 	movw	r3, #25580	; 0x63ec
10030a66:	f2c1 0303 	movt	r3, #4099	; 0x1003
10030a6a:	2103      	movs	r1, #3
10030a6c:	9508      	str	r5, [sp, #32]
10030a6e:	ed8d ab02 	vstr	d10, [sp, #8]
10030a72:	e88d 000a 	stmia.w	sp, {r1, r3}
10030a76:	ed8d 9b04 	vstr	d9, [sp, #16]
10030a7a:	b9b2      	cbnz	r2, 10030aaa <pow+0x27a>
10030a7c:	f64f 73ff 	movw	r3, #65535	; 0xffff
10030a80:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
10030a84:	f2c4 73ef 	movt	r3, #18415	; 0x47ef
10030a88:	e9cd 2306 	strd	r2, r3, [sp, #24]
10030a8c:	eeb5 abc0 	vcmpe.f64	d10, #0.0
10030a90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10030a94:	d428      	bmi.n	10030ae8 <pow+0x2b8>
10030a96:	f994 3000 	ldrsb.w	r3, [r4]
10030a9a:	2b02      	cmp	r3, #2
10030a9c:	f47f af70 	bne.w	10030980 <pow+0x150>
10030aa0:	f7d8 e962 	blx	10008d68 <__errno>
10030aa4:	2322      	movs	r3, #34	; 0x22
10030aa6:	6003      	str	r3, [r0, #0]
10030aa8:	e770      	b.n	1003098c <pow+0x15c>
10030aaa:	eeb5 abc0 	vcmpe.f64	d10, #0.0
10030aae:	2300      	movs	r3, #0
10030ab0:	2200      	movs	r2, #0
10030ab2:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
10030ab6:	e9cd 2306 	strd	r2, r3, [sp, #24]
10030aba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10030abe:	d5ea      	bpl.n	10030a96 <pow+0x266>
10030ac0:	eeb6 7b00 	vmov.f64	d7, #96	; 0x60
10030ac4:	ee29 9b07 	vmul.f64	d9, d9, d7
10030ac8:	eeb0 0b49 	vmov.f64	d0, d9
10030acc:	f001 fb0c 	bl	100320e8 <rint>
10030ad0:	eeb4 0b49 	vcmp.f64	d0, d9
10030ad4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10030ad8:	d0dd      	beq.n	10030a96 <pow+0x266>
10030ada:	2300      	movs	r3, #0
10030adc:	2200      	movs	r2, #0
10030ade:	f6cf 73f0 	movt	r3, #65520	; 0xfff0
10030ae2:	e9cd 2306 	strd	r2, r3, [sp, #24]
10030ae6:	e7d6      	b.n	10030a96 <pow+0x266>
10030ae8:	eeb6 7b00 	vmov.f64	d7, #96	; 0x60
10030aec:	ee29 9b07 	vmul.f64	d9, d9, d7
10030af0:	eeb0 0b49 	vmov.f64	d0, d9
10030af4:	f001 faf8 	bl	100320e8 <rint>
10030af8:	eeb4 0b49 	vcmp.f64	d0, d9
10030afc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10030b00:	d0c9      	beq.n	10030a96 <pow+0x266>
10030b02:	f64f 73ff 	movw	r3, #65535	; 0xffff
10030b06:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
10030b0a:	f2cc 73ef 	movt	r3, #51183	; 0xc7ef
10030b0e:	e9cd 2306 	strd	r2, r3, [sp, #24]
10030b12:	e7c0      	b.n	10030a96 <pow+0x266>
10030b14:	f3af 8000 	nop.w
	...

10030b20 <__ieee754_log>:
10030b20:	b4f0      	push	{r4, r5, r6, r7}
10030b22:	ed2d 8b06 	vpush	{d8-d10}
10030b26:	b082      	sub	sp, #8
10030b28:	ed8d 0b00 	vstr	d0, [sp]
10030b2c:	9901      	ldr	r1, [sp, #4]
10030b2e:	9b00      	ldr	r3, [sp, #0]
10030b30:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
10030b34:	da4e      	bge.n	10030bd4 <__ieee754_log+0xb4>
10030b36:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
10030b3a:	4313      	orrs	r3, r2
10030b3c:	f000 809c 	beq.w	10030c78 <__ieee754_log+0x158>
10030b40:	2900      	cmp	r1, #0
10030b42:	f2c0 80d3 	blt.w	10030cec <__ieee754_log+0x1cc>
10030b46:	ed9d 6b00 	vldr	d6, [sp]
10030b4a:	f64f 73ff 	movw	r3, #65535	; 0xffff
10030b4e:	f6c7 73ef 	movt	r3, #32751	; 0x7fef
10030b52:	f06f 0035 	mvn.w	r0, #53	; 0x35
10030b56:	ed9f 7b76 	vldr	d7, [pc, #472]	; 10030d30 <__ieee754_log+0x210>
10030b5a:	ee26 7b07 	vmul.f64	d7, d6, d7
10030b5e:	ed8d 7b00 	vstr	d7, [sp]
10030b62:	9901      	ldr	r1, [sp, #4]
10030b64:	4299      	cmp	r1, r3
10030b66:	dc3c      	bgt.n	10030be2 <__ieee754_log+0xc2>
10030b68:	f3c1 0513 	ubfx	r5, r1, #0, #20
10030b6c:	eeb7 0b00 	vmov.f64	d0, #112	; 0x70
10030b70:	f505 2415 	add.w	r4, r5, #610304	; 0x95000
10030b74:	e9dd 2300 	ldrd	r2, r3, [sp]
10030b78:	f604 7464 	addw	r4, r4, #3940	; 0xf64
10030b7c:	1509      	asrs	r1, r1, #20
10030b7e:	f404 1480 	and.w	r4, r4, #1048576	; 0x100000
10030b82:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
10030b86:	f084 577f 	eor.w	r7, r4, #1069547520	; 0x3fc00000
10030b8a:	1cae      	adds	r6, r5, #2
10030b8c:	f487 1740 	eor.w	r7, r7, #3145728	; 0x300000
10030b90:	4401      	add	r1, r0
10030b92:	ea47 0305 	orr.w	r3, r7, r5
10030b96:	f3c6 0013 	ubfx	r0, r6, #0, #20
10030b9a:	2802      	cmp	r0, #2
10030b9c:	eb01 5114 	add.w	r1, r1, r4, lsr #20
10030ba0:	ec43 2b17 	vmov	d7, r2, r3
10030ba4:	ee37 0b40 	vsub.f64	d0, d7, d0
10030ba8:	dc24      	bgt.n	10030bf4 <__ieee754_log+0xd4>
10030baa:	eeb5 0b40 	vcmp.f64	d0, #0.0
10030bae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10030bb2:	d16c      	bne.n	10030c8e <__ieee754_log+0x16e>
10030bb4:	2900      	cmp	r1, #0
10030bb6:	f000 80a2 	beq.w	10030cfe <__ieee754_log+0x1de>
10030bba:	ee07 1a90 	vmov	s15, r1
10030bbe:	ed9f 0b5e 	vldr	d0, [pc, #376]	; 10030d38 <__ieee754_log+0x218>
10030bc2:	eeb8 7be7 	vcvt.f64.s32	d7, s15
10030bc6:	ed9f 6b5e 	vldr	d6, [pc, #376]	; 10030d40 <__ieee754_log+0x220>
10030bca:	ee27 0b00 	vmul.f64	d0, d7, d0
10030bce:	ee07 0b06 	vmla.f64	d0, d7, d6
10030bd2:	e00a      	b.n	10030bea <__ieee754_log+0xca>
10030bd4:	f64f 73ff 	movw	r3, #65535	; 0xffff
10030bd8:	2000      	movs	r0, #0
10030bda:	f6c7 73ef 	movt	r3, #32751	; 0x7fef
10030bde:	4299      	cmp	r1, r3
10030be0:	ddc2      	ble.n	10030b68 <__ieee754_log+0x48>
10030be2:	ed9d 7b00 	vldr	d7, [sp]
10030be6:	ee37 0b07 	vadd.f64	d0, d7, d7
10030bea:	b002      	add	sp, #8
10030bec:	ecbd 8b06 	vpop	{d8-d10}
10030bf0:	bcf0      	pop	{r4, r5, r6, r7}
10030bf2:	4770      	bx	lr
10030bf4:	eeb0 6b00 	vmov.f64	d6, #0
10030bf8:	f5a5 22c2 	sub.w	r2, r5, #397312	; 0x61000
10030bfc:	ed9f ab52 	vldr	d10, [pc, #328]	; 10030d48 <__ieee754_log+0x228>
10030c00:	f5c5 23d7 	rsb	r3, r5, #440320	; 0x6b800
10030c04:	f2a2 427a 	subw	r2, r2, #1146	; 0x47a
10030c08:	3351      	adds	r3, #81	; 0x51
10030c0a:	4313      	orrs	r3, r2
10030c0c:	ed9f 8b50 	vldr	d8, [pc, #320]	; 10030d50 <__ieee754_log+0x230>
10030c10:	2b00      	cmp	r3, #0
10030c12:	ed9f 9b51 	vldr	d9, [pc, #324]	; 10030d58 <__ieee754_log+0x238>
10030c16:	ee30 6b06 	vadd.f64	d6, d0, d6
10030c1a:	ed9f 1b51 	vldr	d1, [pc, #324]	; 10030d60 <__ieee754_log+0x240>
10030c1e:	ed9f 4b52 	vldr	d4, [pc, #328]	; 10030d68 <__ieee754_log+0x248>
10030c22:	ed9f 7b53 	vldr	d7, [pc, #332]	; 10030d70 <__ieee754_log+0x250>
10030c26:	ee80 6b06 	vdiv.f64	d6, d0, d6
10030c2a:	ed9f 2b53 	vldr	d2, [pc, #332]	; 10030d78 <__ieee754_log+0x258>
10030c2e:	ee26 3b06 	vmul.f64	d3, d6, d6
10030c32:	ee23 5b03 	vmul.f64	d5, d3, d3
10030c36:	ee05 8b0a 	vmla.f64	d8, d5, d10
10030c3a:	ee05 1b09 	vmla.f64	d1, d5, d9
10030c3e:	ee08 4b05 	vmla.f64	d4, d8, d5
10030c42:	ee01 7b05 	vmla.f64	d7, d1, d5
10030c46:	ee04 2b05 	vmla.f64	d2, d4, d5
10030c4a:	ee27 7b05 	vmul.f64	d7, d7, d5
10030c4e:	ee05 1a90 	vmov	s11, r1
10030c52:	ee02 7b03 	vmla.f64	d7, d2, d3
10030c56:	eeb8 4be5 	vcvt.f64.s32	d4, s11
10030c5a:	dd26      	ble.n	10030caa <__ieee754_log+0x18a>
10030c5c:	eeb6 5b00 	vmov.f64	d5, #96	; 0x60
10030c60:	ee20 5b05 	vmul.f64	d5, d0, d5
10030c64:	ee25 5b00 	vmul.f64	d5, d5, d0
10030c68:	bb79      	cbnz	r1, 10030cca <__ieee754_log+0x1aa>
10030c6a:	ee35 7b07 	vadd.f64	d7, d5, d7
10030c6e:	ee07 5b46 	vmls.f64	d5, d7, d6
10030c72:	ee30 0b45 	vsub.f64	d0, d0, d5
10030c76:	e7b8      	b.n	10030bea <__ieee754_log+0xca>
10030c78:	ed9f 7b41 	vldr	d7, [pc, #260]	; 10030d80 <__ieee754_log+0x260>
10030c7c:	ed9f 0b42 	vldr	d0, [pc, #264]	; 10030d88 <__ieee754_log+0x268>
10030c80:	ee87 0b00 	vdiv.f64	d0, d7, d0
10030c84:	b002      	add	sp, #8
10030c86:	ecbd 8b06 	vpop	{d8-d10}
10030c8a:	bcf0      	pop	{r4, r5, r6, r7}
10030c8c:	4770      	bx	lr
10030c8e:	eeb6 6b00 	vmov.f64	d6, #96	; 0x60
10030c92:	ed9f 7b3f 	vldr	d7, [pc, #252]	; 10030d90 <__ieee754_log+0x270>
10030c96:	ee00 6b47 	vmls.f64	d6, d0, d7
10030c9a:	ee20 7b00 	vmul.f64	d7, d0, d0
10030c9e:	ee27 6b06 	vmul.f64	d6, d7, d6
10030ca2:	bb79      	cbnz	r1, 10030d04 <__ieee754_log+0x1e4>
10030ca4:	ee30 0b46 	vsub.f64	d0, d0, d6
10030ca8:	e79f      	b.n	10030bea <__ieee754_log+0xca>
10030caa:	b3d1      	cbz	r1, 10030d22 <__ieee754_log+0x202>
10030cac:	ed9f 5b22 	vldr	d5, [pc, #136]	; 10030d38 <__ieee754_log+0x218>
10030cb0:	ee30 7b47 	vsub.f64	d7, d0, d7
10030cb4:	ed9f 3b22 	vldr	d3, [pc, #136]	; 10030d40 <__ieee754_log+0x220>
10030cb8:	ee24 5b05 	vmul.f64	d5, d4, d5
10030cbc:	ee17 5b06 	vnmls.f64	d5, d7, d6
10030cc0:	ee35 0b40 	vsub.f64	d0, d5, d0
10030cc4:	ee14 0b03 	vnmls.f64	d0, d4, d3
10030cc8:	e78f      	b.n	10030bea <__ieee754_log+0xca>
10030cca:	ed9f 3b1b 	vldr	d3, [pc, #108]	; 10030d38 <__ieee754_log+0x218>
10030cce:	ee35 7b07 	vadd.f64	d7, d5, d7
10030cd2:	ed9f 2b1b 	vldr	d2, [pc, #108]	; 10030d40 <__ieee754_log+0x220>
10030cd6:	ee24 3b03 	vmul.f64	d3, d4, d3
10030cda:	ee07 3b06 	vmla.f64	d3, d7, d6
10030cde:	ee35 5b43 	vsub.f64	d5, d5, d3
10030ce2:	ee35 0b40 	vsub.f64	d0, d5, d0
10030ce6:	ee14 0b02 	vnmls.f64	d0, d4, d2
10030cea:	e77e      	b.n	10030bea <__ieee754_log+0xca>
10030cec:	ed9d 7b00 	vldr	d7, [sp]
10030cf0:	ed9f 0b25 	vldr	d0, [pc, #148]	; 10030d88 <__ieee754_log+0x268>
10030cf4:	ee37 7b47 	vsub.f64	d7, d7, d7
10030cf8:	ee87 0b00 	vdiv.f64	d0, d7, d0
10030cfc:	e775      	b.n	10030bea <__ieee754_log+0xca>
10030cfe:	ed9f 0b22 	vldr	d0, [pc, #136]	; 10030d88 <__ieee754_log+0x268>
10030d02:	e772      	b.n	10030bea <__ieee754_log+0xca>
10030d04:	ee07 1a90 	vmov	s15, r1
10030d08:	ed9f 4b0b 	vldr	d4, [pc, #44]	; 10030d38 <__ieee754_log+0x218>
10030d0c:	eeb8 7be7 	vcvt.f64.s32	d7, s15
10030d10:	ed9f 5b0b 	vldr	d5, [pc, #44]	; 10030d40 <__ieee754_log+0x220>
10030d14:	ee07 6b44 	vmls.f64	d6, d7, d4
10030d18:	ee36 0b40 	vsub.f64	d0, d6, d0
10030d1c:	ee17 0b05 	vnmls.f64	d0, d7, d5
10030d20:	e763      	b.n	10030bea <__ieee754_log+0xca>
10030d22:	ee30 7b47 	vsub.f64	d7, d0, d7
10030d26:	ee07 0b46 	vmls.f64	d0, d7, d6
10030d2a:	e75e      	b.n	10030bea <__ieee754_log+0xca>
10030d2c:	f3af 8000 	nop.w
10030d30:	00000000 	.word	0x00000000
10030d34:	43500000 	.word	0x43500000
10030d38:	35793c76 	.word	0x35793c76
10030d3c:	3dea39ef 	.word	0x3dea39ef
10030d40:	fee00000 	.word	0xfee00000
10030d44:	3fe62e42 	.word	0x3fe62e42
10030d48:	df3e5244 	.word	0xdf3e5244
10030d4c:	3fc2f112 	.word	0x3fc2f112
10030d50:	96cb03de 	.word	0x96cb03de
10030d54:	3fc74664 	.word	0x3fc74664
10030d58:	d078c69f 	.word	0xd078c69f
10030d5c:	3fc39a09 	.word	0x3fc39a09
10030d60:	1d8e78af 	.word	0x1d8e78af
10030d64:	3fcc71c5 	.word	0x3fcc71c5
10030d68:	94229359 	.word	0x94229359
10030d6c:	3fd24924 	.word	0x3fd24924
10030d70:	9997fa04 	.word	0x9997fa04
10030d74:	3fd99999 	.word	0x3fd99999
10030d78:	55555593 	.word	0x55555593
10030d7c:	3fe55555 	.word	0x3fe55555
10030d80:	00000000 	.word	0x00000000
10030d84:	c3500000 	.word	0xc3500000
	...
10030d90:	55555555 	.word	0x55555555
10030d94:	3fd55555 	.word	0x3fd55555

10030d98 <__ieee754_pow>:
10030d98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
10030d9c:	ec59 8b11 	vmov	r8, r9, d1
10030da0:	ed2d 8b10 	vpush	{d8-d15}
10030da4:	ee11 2a10 	vmov	r2, s2
10030da8:	b085      	sub	sp, #20
10030daa:	f029 4500 	bic.w	r5, r9, #2147483648	; 0x80000000
10030dae:	46ca      	mov	sl, r9
10030db0:	ea55 0308 	orrs.w	r3, r5, r8
10030db4:	d012      	beq.n	10030ddc <__ieee754_pow+0x44>
10030db6:	ec57 6b10 	vmov	r6, r7, d0
10030dba:	2300      	movs	r3, #0
10030dbc:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
10030dc0:	ee10 ba10 	vmov	fp, s0
10030dc4:	f027 4400 	bic.w	r4, r7, #2147483648	; 0x80000000
10030dc8:	4638      	mov	r0, r7
10030dca:	429c      	cmp	r4, r3
10030dcc:	dd0d      	ble.n	10030dea <__ieee754_pow+0x52>
10030dce:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
10030dd2:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
10030dd6:	ea53 030b 	orrs.w	r3, r3, fp
10030dda:	d16b      	bne.n	10030eb4 <__ieee754_pow+0x11c>
10030ddc:	eeb7 0b00 	vmov.f64	d0, #112	; 0x70
10030de0:	b005      	add	sp, #20
10030de2:	ecbd 8b10 	vpop	{d8-d15}
10030de6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
10030dea:	bf0c      	ite	eq
10030dec:	2101      	moveq	r1, #1
10030dee:	2100      	movne	r1, #0
10030df0:	2e00      	cmp	r6, #0
10030df2:	bf0c      	ite	eq
10030df4:	2100      	moveq	r1, #0
10030df6:	f001 0101 	andne.w	r1, r1, #1
10030dfa:	429d      	cmp	r5, r3
10030dfc:	bfc8      	it	gt
10030dfe:	f041 0101 	orrgt.w	r1, r1, #1
10030e02:	2900      	cmp	r1, #0
10030e04:	d1e3      	bne.n	10030dce <__ieee754_pow+0x36>
10030e06:	1aeb      	subs	r3, r5, r3
10030e08:	fab3 f383 	clz	r3, r3
10030e0c:	095b      	lsrs	r3, r3, #5
10030e0e:	f1b8 0f00 	cmp.w	r8, #0
10030e12:	bf0c      	ite	eq
10030e14:	2100      	moveq	r1, #0
10030e16:	f003 0101 	andne.w	r1, r3, #1
10030e1a:	2900      	cmp	r1, #0
10030e1c:	d1d7      	bne.n	10030dce <__ieee754_pow+0x36>
10030e1e:	2f00      	cmp	r7, #0
10030e20:	db53      	blt.n	10030eca <__ieee754_pow+0x132>
10030e22:	b99a      	cbnz	r2, 10030e4c <__ieee754_pow+0xb4>
10030e24:	2b00      	cmp	r3, #0
10030e26:	d174      	bne.n	10030f12 <__ieee754_pow+0x17a>
10030e28:	2300      	movs	r3, #0
10030e2a:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
10030e2e:	429d      	cmp	r5, r3
10030e30:	f000 80a1 	beq.w	10030f76 <__ieee754_pow+0x1de>
10030e34:	f1ba 4f80 	cmp.w	sl, #1073741824	; 0x40000000
10030e38:	f000 82aa 	beq.w	10031390 <__ieee754_pow+0x5f8>
10030e3c:	2300      	movs	r3, #0
10030e3e:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
10030e42:	2800      	cmp	r0, #0
10030e44:	bfa8      	it	ge
10030e46:	459a      	cmpge	sl, r3
10030e48:	f000 8317 	beq.w	1003147a <__ieee754_pow+0x6e2>
10030e4c:	ec47 6b10 	vmov	d0, r6, r7
10030e50:	9002      	str	r0, [sp, #8]
10030e52:	9100      	str	r1, [sp, #0]
10030e54:	f001 f8fe 	bl	10032054 <fabs>
10030e58:	9900      	ldr	r1, [sp, #0]
10030e5a:	9802      	ldr	r0, [sp, #8]
10030e5c:	f1bb 0f00 	cmp.w	fp, #0
10030e60:	d108      	bne.n	10030e74 <__ieee754_pow+0xdc>
10030e62:	2200      	movs	r2, #0
10030e64:	f020 4340 	bic.w	r3, r0, #3221225472	; 0xc0000000
10030e68:	f6c3 72f0 	movt	r2, #16368	; 0x3ff0
10030e6c:	2c00      	cmp	r4, #0
10030e6e:	bf18      	it	ne
10030e70:	4293      	cmpne	r3, r2
10030e72:	d066      	beq.n	10030f42 <__ieee754_pow+0x1aa>
10030e74:	0fc0      	lsrs	r0, r0, #31
10030e76:	3801      	subs	r0, #1
10030e78:	ea51 0300 	orrs.w	r3, r1, r0
10030e7c:	d074      	beq.n	10030f68 <__ieee754_pow+0x1d0>
10030e7e:	2300      	movs	r3, #0
10030e80:	f2c4 13e0 	movt	r3, #16864	; 0x41e0
10030e84:	429d      	cmp	r5, r3
10030e86:	f340 80e7 	ble.w	10031058 <__ieee754_pow+0x2c0>
10030e8a:	2300      	movs	r3, #0
10030e8c:	f2c4 33f0 	movt	r3, #17392	; 0x43f0
10030e90:	429d      	cmp	r5, r3
10030e92:	f340 82b0 	ble.w	100313f6 <__ieee754_pow+0x65e>
10030e96:	f64f 73ff 	movw	r3, #65535	; 0xffff
10030e9a:	f6c3 73ef 	movt	r3, #16367	; 0x3fef
10030e9e:	429c      	cmp	r4, r3
10030ea0:	f340 827b 	ble.w	1003139a <__ieee754_pow+0x602>
10030ea4:	f1ba 0f00 	cmp.w	sl, #0
10030ea8:	dd48      	ble.n	10030f3c <__ieee754_pow+0x1a4>
10030eaa:	ed9f 0b3d 	vldr	d0, [pc, #244]	; 10030fa0 <__ieee754_pow+0x208>
10030eae:	ee20 0b00 	vmul.f64	d0, d0, d0
10030eb2:	e795      	b.n	10030de0 <__ieee754_pow+0x48>
10030eb4:	f246 30e8 	movw	r0, #25576	; 0x63e8
10030eb8:	f2c1 0003 	movt	r0, #4099	; 0x1003
10030ebc:	b005      	add	sp, #20
10030ebe:	ecbd 8b10 	vpop	{d8-d15}
10030ec2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
10030ec6:	f001 b907 	b.w	100320d8 <nan>
10030eca:	f64f 7eff 	movw	lr, #65535	; 0xffff
10030ece:	f2c4 3e3f 	movt	lr, #17215	; 0x433f
10030ed2:	4575      	cmp	r5, lr
10030ed4:	dc5c      	bgt.n	10030f90 <__ieee754_pow+0x1f8>
10030ed6:	f64f 7eff 	movw	lr, #65535	; 0xffff
10030eda:	f6c3 7eef 	movt	lr, #16367	; 0x3fef
10030ede:	4575      	cmp	r5, lr
10030ee0:	dd9f      	ble.n	10030e22 <__ieee754_pow+0x8a>
10030ee2:	ea4f 5e25 	mov.w	lr, r5, asr #20
10030ee6:	f240 4c13 	movw	ip, #1043	; 0x413
10030eea:	45e6      	cmp	lr, ip
10030eec:	f340 82d9 	ble.w	100314a2 <__ieee754_pow+0x70a>
10030ef0:	f5ce 6e86 	rsb	lr, lr, #1072	; 0x430
10030ef4:	f10e 0e03 	add.w	lr, lr, #3
10030ef8:	fa28 fc0e 	lsr.w	ip, r8, lr
10030efc:	fa0c fe0e 	lsl.w	lr, ip, lr
10030f00:	45c6      	cmp	lr, r8
10030f02:	bf04      	itt	eq
10030f04:	f00c 0101 	andeq.w	r1, ip, #1
10030f08:	f1c1 0102 	rsbeq	r1, r1, #2
10030f0c:	2a00      	cmp	r2, #0
10030f0e:	d089      	beq.n	10030e24 <__ieee754_pow+0x8c>
10030f10:	e79c      	b.n	10030e4c <__ieee754_pow+0xb4>
10030f12:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
10030f16:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
10030f1a:	ea53 030b 	orrs.w	r3, r3, fp
10030f1e:	f43f af5d 	beq.w	10030ddc <__ieee754_pow+0x44>
10030f22:	f64f 73ff 	movw	r3, #65535	; 0xffff
10030f26:	f6c3 73ef 	movt	r3, #16367	; 0x3fef
10030f2a:	429c      	cmp	r4, r3
10030f2c:	f340 825a 	ble.w	100313e4 <__ieee754_pow+0x64c>
10030f30:	f1ba 0f00 	cmp.w	sl, #0
10030f34:	ec49 8b10 	vmov	d0, r8, r9
10030f38:	f6bf af52 	bge.w	10030de0 <__ieee754_pow+0x48>
10030f3c:	ed9f 0b1a 	vldr	d0, [pc, #104]	; 10030fa8 <__ieee754_pow+0x210>
10030f40:	e74e      	b.n	10030de0 <__ieee754_pow+0x48>
10030f42:	f1ba 0f00 	cmp.w	sl, #0
10030f46:	f2c0 828c 	blt.w	10031462 <__ieee754_pow+0x6ca>
10030f4a:	2800      	cmp	r0, #0
10030f4c:	f6bf af48 	bge.w	10030de0 <__ieee754_pow+0x48>
10030f50:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
10030f54:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
10030f58:	430b      	orrs	r3, r1
10030f5a:	f040 82b1 	bne.w	100314c0 <__ieee754_pow+0x728>
10030f5e:	ee30 0b40 	vsub.f64	d0, d0, d0
10030f62:	ee80 0b00 	vdiv.f64	d0, d0, d0
10030f66:	e73b      	b.n	10030de0 <__ieee754_pow+0x48>
10030f68:	ec47 6b17 	vmov	d7, r6, r7
10030f6c:	ee37 0b47 	vsub.f64	d0, d7, d7
10030f70:	ee80 0b00 	vdiv.f64	d0, d0, d0
10030f74:	e734      	b.n	10030de0 <__ieee754_pow+0x48>
10030f76:	f1ba 0f00 	cmp.w	sl, #0
10030f7a:	ec47 6b10 	vmov	d0, r6, r7
10030f7e:	f6bf af2f 	bge.w	10030de0 <__ieee754_pow+0x48>
10030f82:	eeb7 0b00 	vmov.f64	d0, #112	; 0x70
10030f86:	ec47 6b17 	vmov	d7, r6, r7
10030f8a:	ee80 0b07 	vdiv.f64	d0, d0, d7
10030f8e:	e727      	b.n	10030de0 <__ieee754_pow+0x48>
10030f90:	2102      	movs	r1, #2
10030f92:	2a00      	cmp	r2, #0
10030f94:	f43f af46 	beq.w	10030e24 <__ieee754_pow+0x8c>
10030f98:	e758      	b.n	10030e4c <__ieee754_pow+0xb4>
10030f9a:	bf00      	nop
10030f9c:	f3af 8000 	nop.w
10030fa0:	8800759c 	.word	0x8800759c
10030fa4:	7e37e43c 	.word	0x7e37e43c
	...
10030fb4:	43400000 	.word	0x43400000
10030fb8:	4a454eef 	.word	0x4a454eef
10030fbc:	3fca7e28 	.word	0x3fca7e28
10030fc0:	93c9db65 	.word	0x93c9db65
10030fc4:	3fcd864a 	.word	0x3fcd864a
10030fc8:	e0000000 	.word	0xe0000000
10030fcc:	3feec709 	.word	0x3feec709
10030fd0:	145b01f5 	.word	0x145b01f5
10030fd4:	be3e2fe0 	.word	0xbe3e2fe0
10030fd8:	dc3a03fd 	.word	0xdc3a03fd
10030fdc:	3feec709 	.word	0x3feec709
10030fe0:	33333303 	.word	0x33333303
10030fe4:	3fe33333 	.word	0x3fe33333
10030fe8:	db6fabff 	.word	0xdb6fabff
10030fec:	3fdb6db6 	.word	0x3fdb6db6
10030ff0:	a91d4101 	.word	0xa91d4101
10030ff4:	3fd17460 	.word	0x3fd17460
10030ff8:	518f264d 	.word	0x518f264d
10030ffc:	3fd55555 	.word	0x3fd55555
10031000:	652b82fe 	.word	0x652b82fe
10031004:	3c971547 	.word	0x3c971547
10031008:	0ca86c39 	.word	0x0ca86c39
1003100c:	be205c61 	.word	0xbe205c61
10031010:	5555553e 	.word	0x5555553e
10031014:	3fc55555 	.word	0x3fc55555
10031018:	c5d26bf1 	.word	0xc5d26bf1
1003101c:	3ebbbd41 	.word	0x3ebbbd41
10031020:	16bebd93 	.word	0x16bebd93
10031024:	3f66c16c 	.word	0x3f66c16c
10031028:	af25de2c 	.word	0xaf25de2c
1003102c:	3f11566a 	.word	0x3f11566a
10031030:	fefa39ef 	.word	0xfefa39ef
10031034:	3fe62e42 	.word	0x3fe62e42
10031038:	72bea4d0 	.word	0x72bea4d0
1003103c:	3e663769 	.word	0x3e663769
10031040:	00000000 	.word	0x00000000
10031044:	3fe62e43 	.word	0x3fe62e43
10031048:	c2f8f359 	.word	0xc2f8f359
1003104c:	01a56e1f 	.word	0x01a56e1f
10031050:	55555555 	.word	0x55555555
10031054:	3fd55555 	.word	0x3fd55555
10031058:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
1003105c:	bfa8      	it	ge
1003105e:	2500      	movge	r5, #0
10031060:	da07      	bge.n	10031072 <__ieee754_pow+0x2da>
10031062:	ed1f 7b2d 	vldr	d7, [pc, #-180]	; 10030fb0 <__ieee754_pow+0x218>
10031066:	f06f 0534 	mvn.w	r5, #52	; 0x34
1003106a:	ee20 0b07 	vmul.f64	d0, d0, d7
1003106e:	ee10 4a90 	vmov	r4, s1
10031072:	f3c4 0313 	ubfx	r3, r4, #0, #20
10031076:	1522      	asrs	r2, r4, #20
10031078:	f649 048e 	movw	r4, #39054	; 0x988e
1003107c:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
10031080:	f2c0 0403 	movt	r4, #3
10031084:	42a3      	cmp	r3, r4
10031086:	f043 577f 	orr.w	r7, r3, #1069547520	; 0x3fc00000
1003108a:	4415      	add	r5, r2
1003108c:	bfd8      	it	le
1003108e:	f04f 0c00 	movle.w	ip, #0
10031092:	f447 1740 	orr.w	r7, r7, #3145728	; 0x300000
10031096:	bfd8      	it	le
10031098:	4664      	movle	r4, ip
1003109a:	dd0f      	ble.n	100310bc <__ieee754_pow+0x324>
1003109c:	f24b 6279 	movw	r2, #46713	; 0xb679
100310a0:	f2c0 020b 	movt	r2, #11
100310a4:	4293      	cmp	r3, r2
100310a6:	bfc3      	ittte	gt
100310a8:	3501      	addgt	r5, #1
100310aa:	f5a7 1780 	subgt.w	r7, r7, #1048576	; 0x100000
100310ae:	f04f 0c00 	movgt.w	ip, #0
100310b2:	f44f 2c80 	movle.w	ip, #262144	; 0x40000
100310b6:	bfcc      	ite	gt
100310b8:	4664      	movgt	r4, ip
100310ba:	2401      	movle	r4, #1
100310bc:	00e4      	lsls	r4, r4, #3
100310be:	f246 4310 	movw	r3, #25616	; 0x6410
100310c2:	ed8d 0b00 	vstr	d0, [sp]
100310c6:	f2c1 0303 	movt	r3, #4099	; 0x1003
100310ca:	191e      	adds	r6, r3, r4
100310cc:	e9dd 2300 	ldrd	r2, r3, [sp]
100310d0:	463b      	mov	r3, r7
100310d2:	ea4f 0e67 	mov.w	lr, r7, asr #1
100310d6:	ed96 9b00 	vldr	d9, [r6]
100310da:	f04e 5e00 	orr.w	lr, lr, #536870912	; 0x20000000
100310de:	f50e 2e00 	add.w	lr, lr, #524288	; 0x80000
100310e2:	2600      	movs	r6, #0
100310e4:	eb0e 070c 	add.w	r7, lr, ip
100310e8:	ec43 2b17 	vmov	d7, r2, r3
100310ec:	f246 4300 	movw	r3, #25600	; 0x6400
100310f0:	f2c1 0303 	movt	r3, #4099	; 0x1003
100310f4:	4423      	add	r3, r4
100310f6:	ee37 5b09 	vadd.f64	d5, d7, d9
100310fa:	f246 32f0 	movw	r2, #25584	; 0x63f0
100310fe:	ed1f 6b52 	vldr	d6, [pc, #-328]	; 10030fb8 <__ieee754_pow+0x220>
10031102:	f2c1 0203 	movt	r2, #4099	; 0x1003
10031106:	4414      	add	r4, r2
10031108:	ed1f ab53 	vldr	d10, [pc, #-332]	; 10030fc0 <__ieee754_pow+0x228>
1003110c:	ed1f 8b48 	vldr	d8, [pc, #-288]	; 10030ff0 <__ieee754_pow+0x258>
10031110:	eeb7 1b00 	vmov.f64	d1, #112	; 0x70
10031114:	ec47 6b13 	vmov	d3, r6, r7
10031118:	ed1f 0b49 	vldr	d0, [pc, #-292]	; 10030ff8 <__ieee754_pow+0x260>
1003111c:	ed1f bb4e 	vldr	d11, [pc, #-312]	; 10030fe8 <__ieee754_pow+0x250>
10031120:	ed1f cb51 	vldr	d12, [pc, #-324]	; 10030fe0 <__ieee754_pow+0x248>
10031124:	ee81 1b05 	vdiv.f64	d1, d1, d5
10031128:	ed93 5b00 	vldr	d5, [r3]
1003112c:	ed1f db56 	vldr	d13, [pc, #-344]	; 10030fd8 <__ieee754_pow+0x240>
10031130:	ed8d 5b02 	vstr	d5, [sp, #8]
10031134:	ed1f eb5a 	vldr	d14, [pc, #-360]	; 10030fd0 <__ieee754_pow+0x238>
10031138:	ed1f fb5d 	vldr	d15, [pc, #-372]	; 10030fc8 <__ieee754_pow+0x230>
1003113c:	ee37 5b49 	vsub.f64	d5, d7, d9
10031140:	ee25 2b01 	vmul.f64	d2, d5, d1
10031144:	ee22 4b02 	vmul.f64	d4, d2, d2
10031148:	ed8d 2b00 	vstr	d2, [sp]
1003114c:	e9dd 2300 	ldrd	r2, r3, [sp]
10031150:	2200      	movs	r2, #0
10031152:	ee04 ab06 	vmla.f64	d10, d4, d6
10031156:	ec43 2b16 	vmov	d6, r2, r3
1003115a:	ee0a 8b04 	vmla.f64	d8, d10, d4
1003115e:	ed94 ab00 	vldr	d10, [r4]
10031162:	ee06 5b43 	vmls.f64	d5, d6, d3
10031166:	ee33 3b49 	vsub.f64	d3, d3, d9
1003116a:	ee08 0b04 	vmla.f64	d0, d8, d4
1003116e:	ee37 3b43 	vsub.f64	d3, d7, d3
10031172:	ee06 5b43 	vmls.f64	d5, d6, d3
10031176:	ee00 bb04 	vmla.f64	d11, d0, d4
1003117a:	ee25 1b01 	vmul.f64	d1, d5, d1
1003117e:	ee05 5a90 	vmov	s11, r5
10031182:	ee36 7b02 	vadd.f64	d7, d6, d2
10031186:	ee0b cb04 	vmla.f64	d12, d11, d4
1003118a:	ee27 7b01 	vmul.f64	d7, d7, d1
1003118e:	ee24 4b04 	vmul.f64	d4, d4, d4
10031192:	ee26 0b06 	vmul.f64	d0, d6, d6
10031196:	ee04 7b0c 	vmla.f64	d7, d4, d12
1003119a:	eeb0 3b08 	vmov.f64	d3, #8
1003119e:	ee30 4b03 	vadd.f64	d4, d0, d3
100311a2:	ee34 4b07 	vadd.f64	d4, d4, d7
100311a6:	ed8d 4b00 	vstr	d4, [sp]
100311aa:	9200      	str	r2, [sp, #0]
100311ac:	ed9d 4b00 	vldr	d4, [sp]
100311b0:	eeb8 5be5 	vcvt.f64.s32	d5, s11
100311b4:	ee34 3b43 	vsub.f64	d3, d4, d3
100311b8:	ee33 3b40 	vsub.f64	d3, d3, d0
100311bc:	ee37 3b43 	vsub.f64	d3, d7, d3
100311c0:	ee23 2b02 	vmul.f64	d2, d3, d2
100311c4:	ee01 2b04 	vmla.f64	d2, d1, d4
100311c8:	ee26 6b04 	vmul.f64	d6, d6, d4
100311cc:	ee36 7b02 	vadd.f64	d7, d6, d2
100311d0:	ed8d 7b00 	vstr	d7, [sp]
100311d4:	9200      	str	r2, [sp, #0]
100311d6:	ed9d 3b00 	vldr	d3, [sp]
100311da:	ee33 7b46 	vsub.f64	d7, d3, d6
100311de:	ed9d 6b02 	vldr	d6, [sp, #8]
100311e2:	ee32 7b47 	vsub.f64	d7, d2, d7
100311e6:	ee27 7b0d 	vmul.f64	d7, d7, d13
100311ea:	ee03 7b0e 	vmla.f64	d7, d3, d14
100311ee:	ee23 3b0f 	vmul.f64	d3, d3, d15
100311f2:	ee37 7b06 	vadd.f64	d7, d7, d6
100311f6:	ee33 6b07 	vadd.f64	d6, d3, d7
100311fa:	ee36 6b0a 	vadd.f64	d6, d6, d10
100311fe:	ee36 6b05 	vadd.f64	d6, d6, d5
10031202:	ed8d 6b00 	vstr	d6, [sp]
10031206:	9200      	str	r2, [sp, #0]
10031208:	ed9d 6b00 	vldr	d6, [sp]
1003120c:	ee36 5b45 	vsub.f64	d5, d6, d5
10031210:	ee35 ab4a 	vsub.f64	d10, d5, d10
10031214:	ee3a 0b43 	vsub.f64	d0, d10, d3
10031218:	ee37 7b40 	vsub.f64	d7, d7, d0
1003121c:	ec49 8b14 	vmov	d4, r8, r9
10031220:	464d      	mov	r5, r9
10031222:	2400      	movs	r4, #0
10031224:	3901      	subs	r1, #1
10031226:	ec45 4b15 	vmov	d5, r4, r5
1003122a:	ea51 0300 	orrs.w	r3, r1, r0
1003122e:	f64f 73ff 	movw	r3, #65535	; 0xffff
10031232:	f2c4 038f 	movt	r3, #16527	; 0x408f
10031236:	ee24 7b07 	vmul.f64	d7, d4, d7
1003123a:	ee34 4b45 	vsub.f64	d4, d4, d5
1003123e:	ee04 7b06 	vmla.f64	d7, d4, d6
10031242:	ee25 5b06 	vmul.f64	d5, d5, d6
10031246:	ee37 6b05 	vadd.f64	d6, d7, d5
1003124a:	eeb7 8b00 	vmov.f64	d8, #112	; 0x70
1003124e:	ed8d 6b00 	vstr	d6, [sp]
10031252:	9801      	ldr	r0, [sp, #4]
10031254:	9a00      	ldr	r2, [sp, #0]
10031256:	eebf 6b00 	vmov.f64	d6, #240	; 0xf0
1003125a:	bf08      	it	eq
1003125c:	eeb0 8b46 	vmoveq.f64	d8, d6
10031260:	4298      	cmp	r0, r3
10031262:	f340 809f 	ble.w	100313a4 <__ieee754_pow+0x60c>
10031266:	f100 433f 	add.w	r3, r0, #3204448256	; 0xbf000000
1003126a:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
1003126e:	4313      	orrs	r3, r2
10031270:	f040 80fc 	bne.w	1003146c <__ieee754_pow+0x6d4>
10031274:	ed1f 6b9e 	vldr	d6, [pc, #-632]	; 10031000 <__ieee754_pow+0x268>
10031278:	ed9d 4b00 	vldr	d4, [sp]
1003127c:	ee37 6b06 	vadd.f64	d6, d7, d6
10031280:	ee34 4b45 	vsub.f64	d4, d4, d5
10031284:	eeb4 6bc4 	vcmpe.f64	d6, d4
10031288:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
1003128c:	bfd8      	it	le
1003128e:	4603      	movle	r3, r0
10031290:	f300 80ec 	bgt.w	1003146c <__ieee754_pow+0x6d4>
10031294:	151b      	asrs	r3, r3, #20
10031296:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
1003129a:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
1003129e:	f64f 76ff 	movw	r6, #65535	; 0xffff
100312a2:	411a      	asrs	r2, r3
100312a4:	f2c0 060f 	movt	r6, #15
100312a8:	4402      	add	r2, r0
100312aa:	2400      	movs	r4, #0
100312ac:	f3c2 510a 	ubfx	r1, r2, #20, #11
100312b0:	f3c2 0313 	ubfx	r3, r2, #0, #20
100312b4:	f2a1 37ff 	subw	r7, r1, #1023	; 0x3ff
100312b8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
100312bc:	413e      	asrs	r6, r7
100312be:	f5c1 6182 	rsb	r1, r1, #1040	; 0x410
100312c2:	ea22 0506 	bic.w	r5, r2, r6
100312c6:	3103      	adds	r1, #3
100312c8:	410b      	asrs	r3, r1
100312ca:	ec45 4b16 	vmov	d6, r4, r5
100312ce:	ea83 73e0 	eor.w	r3, r3, r0, asr #31
100312d2:	eb03 70d0 	add.w	r0, r3, r0, lsr #31
100312d6:	ee35 5b46 	vsub.f64	d5, d5, d6
100312da:	0501      	lsls	r1, r0, #20
100312dc:	ee37 6b05 	vadd.f64	d6, d7, d5
100312e0:	ed8d 6b00 	vstr	d6, [sp]
100312e4:	e9dd 2300 	ldrd	r2, r3, [sp]
100312e8:	2200      	movs	r2, #0
100312ea:	ed1f 4bb9 	vldr	d4, [pc, #-740]	; 10031008 <__ieee754_pow+0x270>
100312ee:	ec43 2b16 	vmov	d6, r2, r3
100312f2:	ed1f abb1 	vldr	d10, [pc, #-708]	; 10031030 <__ieee754_pow+0x298>
100312f6:	ee36 5b45 	vsub.f64	d5, d6, d5
100312fa:	ed1f 3baf 	vldr	d3, [pc, #-700]	; 10031040 <__ieee754_pow+0x2a8>
100312fe:	ed1f 9bb2 	vldr	d9, [pc, #-712]	; 10031038 <__ieee754_pow+0x2a0>
10031302:	ed1f 0bbb 	vldr	d0, [pc, #-748]	; 10031018 <__ieee754_pow+0x280>
10031306:	ee26 4b04 	vmul.f64	d4, d6, d4
1003130a:	ed1f 1bb9 	vldr	d1, [pc, #-740]	; 10031028 <__ieee754_pow+0x290>
1003130e:	ed1f 2bbc 	vldr	d2, [pc, #-752]	; 10031020 <__ieee754_pow+0x288>
10031312:	ed1f bbc1 	vldr	d11, [pc, #-772]	; 10031010 <__ieee754_pow+0x278>
10031316:	ee37 7b45 	vsub.f64	d7, d7, d5
1003131a:	ee07 4b0a 	vmla.f64	d4, d7, d10
1003131e:	ee26 3b03 	vmul.f64	d3, d6, d3
10031322:	ee33 5b04 	vadd.f64	d5, d3, d4
10031326:	ee25 7b05 	vmul.f64	d7, d5, d5
1003132a:	ee17 0b09 	vnmls.f64	d0, d7, d9
1003132e:	ee00 1b07 	vmla.f64	d1, d0, d7
10031332:	ee11 2b07 	vnmls.f64	d2, d1, d7
10031336:	ee02 bb07 	vmla.f64	d11, d2, d7
1003133a:	eeb0 6b45 	vmov.f64	d6, d5
1003133e:	ee0b 6b47 	vmls.f64	d6, d11, d7
10031342:	eeb0 2b00 	vmov.f64	d2, #0
10031346:	ee25 7b06 	vmul.f64	d7, d5, d6
1003134a:	ee36 6b42 	vsub.f64	d6, d6, d2
1003134e:	ee87 7b06 	vdiv.f64	d7, d7, d6
10031352:	ee35 3b43 	vsub.f64	d3, d5, d3
10031356:	ee34 4b43 	vsub.f64	d4, d4, d3
1003135a:	ee05 4b04 	vmla.f64	d4, d5, d4
1003135e:	ee37 6b44 	vsub.f64	d6, d7, d4
10031362:	eeb7 7b00 	vmov.f64	d7, #112	; 0x70
10031366:	ee36 0b45 	vsub.f64	d0, d6, d5
1003136a:	ee37 0b40 	vsub.f64	d0, d7, d0
1003136e:	ee10 3a90 	vmov	r3, s1
10031372:	4419      	add	r1, r3
10031374:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
10031378:	f2c0 80a7 	blt.w	100314ca <__ieee754_pow+0x732>
1003137c:	ed8d 0b00 	vstr	d0, [sp]
10031380:	e9dd 2300 	ldrd	r2, r3, [sp]
10031384:	460b      	mov	r3, r1
10031386:	ec43 2b10 	vmov	d0, r2, r3
1003138a:	ee28 0b00 	vmul.f64	d0, d8, d0
1003138e:	e527      	b.n	10030de0 <__ieee754_pow+0x48>
10031390:	ec47 6b17 	vmov	d7, r6, r7
10031394:	ee27 0b07 	vmul.f64	d0, d7, d7
10031398:	e522      	b.n	10030de0 <__ieee754_pow+0x48>
1003139a:	f1ba 0f00 	cmp.w	sl, #0
1003139e:	f6bf adcd 	bge.w	10030f3c <__ieee754_pow+0x1a4>
100313a2:	e582      	b.n	10030eaa <__ieee754_pow+0x112>
100313a4:	f64c 31ff 	movw	r1, #52223	; 0xcbff
100313a8:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
100313ac:	f2c4 0190 	movt	r1, #16528	; 0x4090
100313b0:	428b      	cmp	r3, r1
100313b2:	dd6b      	ble.n	1003148c <__ieee754_pow+0x6f4>
100313b4:	f44f 5150 	mov.w	r1, #13312	; 0x3400
100313b8:	f6c3 716f 	movt	r1, #16239	; 0x3f6f
100313bc:	4401      	add	r1, r0
100313be:	430a      	orrs	r2, r1
100313c0:	d109      	bne.n	100313d6 <__ieee754_pow+0x63e>
100313c2:	ed9d 6b00 	vldr	d6, [sp]
100313c6:	ee36 6b45 	vsub.f64	d6, d6, d5
100313ca:	eeb4 7bc6 	vcmpe.f64	d7, d6
100313ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100313d2:	f63f af5f 	bhi.w	10031294 <__ieee754_pow+0x4fc>
100313d6:	ed1f 0be4 	vldr	d0, [pc, #-912]	; 10031048 <__ieee754_pow+0x2b0>
100313da:	ee28 8b00 	vmul.f64	d8, d8, d0
100313de:	ee28 0b00 	vmul.f64	d0, d8, d0
100313e2:	e4fd      	b.n	10030de0 <__ieee754_pow+0x48>
100313e4:	ec49 8b17 	vmov	d7, r8, r9
100313e8:	f1ba 0f00 	cmp.w	sl, #0
100313ec:	eeb1 0b47 	vneg.f64	d0, d7
100313f0:	f6bf ada4 	bge.w	10030f3c <__ieee754_pow+0x1a4>
100313f4:	e4f4      	b.n	10030de0 <__ieee754_pow+0x48>
100313f6:	f64f 73fe 	movw	r3, #65534	; 0xfffe
100313fa:	f6c3 73ef 	movt	r3, #16367	; 0x3fef
100313fe:	429c      	cmp	r4, r3
10031400:	ddcb      	ble.n	1003139a <__ieee754_pow+0x602>
10031402:	2300      	movs	r3, #0
10031404:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
10031408:	429c      	cmp	r4, r3
1003140a:	f73f ad4b 	bgt.w	10030ea4 <__ieee754_pow+0x10c>
1003140e:	eeb7 7b00 	vmov.f64	d7, #112	; 0x70
10031412:	ed1f 6bf1 	vldr	d6, [pc, #-964]	; 10031050 <__ieee754_pow+0x2b8>
10031416:	ed9f 3b32 	vldr	d3, [pc, #200]	; 100314e0 <__ieee754_pow+0x748>
1003141a:	ed9f 4b33 	vldr	d4, [pc, #204]	; 100314e8 <__ieee754_pow+0x750>
1003141e:	ee30 0b47 	vsub.f64	d0, d0, d7
10031422:	ed9f 5b33 	vldr	d5, [pc, #204]	; 100314f0 <__ieee754_pow+0x758>
10031426:	eeb5 7b00 	vmov.f64	d7, #80	; 0x50
1003142a:	ee00 6b47 	vmls.f64	d6, d0, d7
1003142e:	eeb6 7b00 	vmov.f64	d7, #96	; 0x60
10031432:	ee06 7b40 	vmls.f64	d7, d6, d0
10031436:	ee20 6b00 	vmul.f64	d6, d0, d0
1003143a:	ee26 7b07 	vmul.f64	d7, d6, d7
1003143e:	ee27 7b03 	vmul.f64	d7, d7, d3
10031442:	ee10 7b04 	vnmls.f64	d7, d0, d4
10031446:	ee20 0b05 	vmul.f64	d0, d0, d5
1003144a:	ee30 6b07 	vadd.f64	d6, d0, d7
1003144e:	ec53 2b16 	vmov	r2, r3, d6
10031452:	2200      	movs	r2, #0
10031454:	ec43 2b16 	vmov	d6, r2, r3
10031458:	ee36 0b40 	vsub.f64	d0, d6, d0
1003145c:	ee37 7b40 	vsub.f64	d7, d7, d0
10031460:	e6dc      	b.n	1003121c <__ieee754_pow+0x484>
10031462:	eeb7 7b00 	vmov.f64	d7, #112	; 0x70
10031466:	ee87 0b00 	vdiv.f64	d0, d7, d0
1003146a:	e56e      	b.n	10030f4a <__ieee754_pow+0x1b2>
1003146c:	ed9f 0b22 	vldr	d0, [pc, #136]	; 100314f8 <__ieee754_pow+0x760>
10031470:	ee28 8b00 	vmul.f64	d8, d8, d0
10031474:	ee28 0b00 	vmul.f64	d0, d8, d0
10031478:	e4b2      	b.n	10030de0 <__ieee754_pow+0x48>
1003147a:	ec47 6b10 	vmov	d0, r6, r7
1003147e:	b005      	add	sp, #20
10031480:	ecbd 8b10 	vpop	{d8-d15}
10031484:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
10031488:	f000 b83a 	b.w	10031500 <__ieee754_sqrt>
1003148c:	2200      	movs	r2, #0
1003148e:	f6c3 72e0 	movt	r2, #16352	; 0x3fe0
10031492:	4293      	cmp	r3, r2
10031494:	f73f aefe 	bgt.w	10031294 <__ieee754_pow+0x4fc>
10031498:	ed9d 6b00 	vldr	d6, [sp]
1003149c:	4621      	mov	r1, r4
1003149e:	4620      	mov	r0, r4
100314a0:	e71e      	b.n	100312e0 <__ieee754_pow+0x548>
100314a2:	2a00      	cmp	r2, #0
100314a4:	f47f acd2 	bne.w	10030e4c <__ieee754_pow+0xb4>
100314a8:	f5ce 6e82 	rsb	lr, lr, #1040	; 0x410
100314ac:	f10e 0e03 	add.w	lr, lr, #3
100314b0:	fa45 f20e 	asr.w	r2, r5, lr
100314b4:	fa02 f10e 	lsl.w	r1, r2, lr
100314b8:	42a9      	cmp	r1, r5
100314ba:	d009      	beq.n	100314d0 <__ieee754_pow+0x738>
100314bc:	2100      	movs	r1, #0
100314be:	e4b1      	b.n	10030e24 <__ieee754_pow+0x8c>
100314c0:	2901      	cmp	r1, #1
100314c2:	bf08      	it	eq
100314c4:	eeb1 0b40 	vnegeq.f64	d0, d0
100314c8:	e48a      	b.n	10030de0 <__ieee754_pow+0x48>
100314ca:	f000 fe9d 	bl	10032208 <scalbn>
100314ce:	e75c      	b.n	1003138a <__ieee754_pow+0x5f2>
100314d0:	f002 0201 	and.w	r2, r2, #1
100314d4:	f1c2 0102 	rsb	r1, r2, #2
100314d8:	e4a4      	b.n	10030e24 <__ieee754_pow+0x8c>
100314da:	bf00      	nop
100314dc:	f3af 8000 	nop.w
100314e0:	652b82fe 	.word	0x652b82fe
100314e4:	3ff71547 	.word	0x3ff71547
100314e8:	f85ddf44 	.word	0xf85ddf44
100314ec:	3e54ae0b 	.word	0x3e54ae0b
100314f0:	60000000 	.word	0x60000000
100314f4:	3ff71547 	.word	0x3ff71547
100314f8:	8800759c 	.word	0x8800759c
100314fc:	7e37e43c 	.word	0x7e37e43c

10031500 <__ieee754_sqrt>:
10031500:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
10031504:	b082      	sub	sp, #8
10031506:	2100      	movs	r1, #0
10031508:	2000      	movs	r0, #0
1003150a:	ed8d 0b00 	vstr	d0, [sp]
1003150e:	f6c7 71f0 	movt	r1, #32752	; 0x7ff0
10031512:	9b01      	ldr	r3, [sp, #4]
10031514:	f6c7 70f0 	movt	r0, #32752	; 0x7ff0
10031518:	9c00      	ldr	r4, [sp, #0]
1003151a:	4019      	ands	r1, r3
1003151c:	4281      	cmp	r1, r0
1003151e:	f000 8090 	beq.w	10031642 <__ieee754_sqrt+0x142>
10031522:	2b00      	cmp	r3, #0
10031524:	4622      	mov	r2, r4
10031526:	dd70      	ble.n	1003160a <__ieee754_sqrt+0x10a>
10031528:	151e      	asrs	r6, r3, #20
1003152a:	d07b      	beq.n	10031624 <__ieee754_sqrt+0x124>
1003152c:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
10031530:	f3c3 0313 	ubfx	r3, r3, #0, #20
10031534:	07f1      	lsls	r1, r6, #31
10031536:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
1003153a:	bf42      	ittt	mi
1003153c:	0fd1      	lsrmi	r1, r2, #31
1003153e:	0052      	lslmi	r2, r2, #1
10031540:	eb01 0343 	addmi.w	r3, r1, r3, lsl #1
10031544:	2700      	movs	r7, #0
10031546:	0fd1      	lsrs	r1, r2, #31
10031548:	1076      	asrs	r6, r6, #1
1003154a:	0052      	lsls	r2, r2, #1
1003154c:	eb01 0343 	add.w	r3, r1, r3, lsl #1
10031550:	2016      	movs	r0, #22
10031552:	46be      	mov	lr, r7
10031554:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
10031558:	eb0e 0401 	add.w	r4, lr, r1
1003155c:	0fd5      	lsrs	r5, r2, #31
1003155e:	429c      	cmp	r4, r3
10031560:	ea4f 0242 	mov.w	r2, r2, lsl #1
10031564:	bfde      	ittt	le
10031566:	1b1b      	suble	r3, r3, r4
10031568:	eb04 0e01 	addle.w	lr, r4, r1
1003156c:	187f      	addle	r7, r7, r1
1003156e:	3801      	subs	r0, #1
10031570:	eb05 0343 	add.w	r3, r5, r3, lsl #1
10031574:	ea4f 0151 	mov.w	r1, r1, lsr #1
10031578:	d1ee      	bne.n	10031558 <__ieee754_sqrt+0x58>
1003157a:	2520      	movs	r5, #32
1003157c:	4684      	mov	ip, r0
1003157e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
10031582:	4573      	cmp	r3, lr
10031584:	eb01 040c 	add.w	r4, r1, ip
10031588:	dc03      	bgt.n	10031592 <__ieee754_sqrt+0x92>
1003158a:	4294      	cmp	r4, r2
1003158c:	bf98      	it	ls
1003158e:	4573      	cmpls	r3, lr
10031590:	d10d      	bne.n	100315ae <__ieee754_sqrt+0xae>
10031592:	2c00      	cmp	r4, #0
10031594:	eb04 0c01 	add.w	ip, r4, r1
10031598:	db27      	blt.n	100315ea <__ieee754_sqrt+0xea>
1003159a:	46f0      	mov	r8, lr
1003159c:	ebce 0303 	rsb	r3, lr, r3
100315a0:	4294      	cmp	r4, r2
100315a2:	bf88      	it	hi
100315a4:	f103 33ff 	addhi.w	r3, r3, #4294967295
100315a8:	1b12      	subs	r2, r2, r4
100315aa:	4408      	add	r0, r1
100315ac:	46c6      	mov	lr, r8
100315ae:	3d01      	subs	r5, #1
100315b0:	ea4f 74d2 	mov.w	r4, r2, lsr #31
100315b4:	ea4f 0151 	mov.w	r1, r1, lsr #1
100315b8:	eb04 0343 	add.w	r3, r4, r3, lsl #1
100315bc:	ea4f 0242 	mov.w	r2, r2, lsl #1
100315c0:	d1df      	bne.n	10031582 <__ieee754_sqrt+0x82>
100315c2:	4313      	orrs	r3, r2
100315c4:	d118      	bne.n	100315f8 <__ieee754_sqrt+0xf8>
100315c6:	0840      	lsrs	r0, r0, #1
100315c8:	1079      	asrs	r1, r7, #1
100315ca:	07fb      	lsls	r3, r7, #31
100315cc:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
100315d0:	bf48      	it	mi
100315d2:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
100315d6:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
100315da:	eb01 5306 	add.w	r3, r1, r6, lsl #20
100315de:	4602      	mov	r2, r0
100315e0:	ec43 2b10 	vmov	d0, r2, r3
100315e4:	b002      	add	sp, #8
100315e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
100315ea:	f1bc 0f00 	cmp.w	ip, #0
100315ee:	bfa8      	it	ge
100315f0:	f10e 0801 	addge.w	r8, lr, #1
100315f4:	dad2      	bge.n	1003159c <__ieee754_sqrt+0x9c>
100315f6:	e7d0      	b.n	1003159a <__ieee754_sqrt+0x9a>
100315f8:	1c42      	adds	r2, r0, #1
100315fa:	bf04      	itt	eq
100315fc:	3701      	addeq	r7, #1
100315fe:	4628      	moveq	r0, r5
10031600:	d0e2      	beq.n	100315c8 <__ieee754_sqrt+0xc8>
10031602:	f000 0301 	and.w	r3, r0, #1
10031606:	4418      	add	r0, r3
10031608:	e7dd      	b.n	100315c6 <__ieee754_sqrt+0xc6>
1003160a:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
1003160e:	4321      	orrs	r1, r4
10031610:	d01c      	beq.n	1003164c <__ieee754_sqrt+0x14c>
10031612:	461e      	mov	r6, r3
10031614:	bb0b      	cbnz	r3, 1003165a <__ieee754_sqrt+0x15a>
10031616:	0ad3      	lsrs	r3, r2, #11
10031618:	3e15      	subs	r6, #21
1003161a:	0552      	lsls	r2, r2, #21
1003161c:	2b00      	cmp	r3, #0
1003161e:	d0fa      	beq.n	10031616 <__ieee754_sqrt+0x116>
10031620:	02dc      	lsls	r4, r3, #11
10031622:	d416      	bmi.n	10031652 <__ieee754_sqrt+0x152>
10031624:	2100      	movs	r1, #0
10031626:	005b      	lsls	r3, r3, #1
10031628:	3101      	adds	r1, #1
1003162a:	02d8      	lsls	r0, r3, #11
1003162c:	d5fb      	bpl.n	10031626 <__ieee754_sqrt+0x126>
1003162e:	f1c1 0401 	rsb	r4, r1, #1
10031632:	f1c1 0020 	rsb	r0, r1, #32
10031636:	fa22 f000 	lsr.w	r0, r2, r0
1003163a:	4426      	add	r6, r4
1003163c:	4303      	orrs	r3, r0
1003163e:	408a      	lsls	r2, r1
10031640:	e774      	b.n	1003152c <__ieee754_sqrt+0x2c>
10031642:	ee00 0b00 	vmla.f64	d0, d0, d0
10031646:	b002      	add	sp, #8
10031648:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1003164c:	ed9d 0b00 	vldr	d0, [sp]
10031650:	e7c8      	b.n	100315e4 <__ieee754_sqrt+0xe4>
10031652:	2020      	movs	r0, #32
10031654:	2401      	movs	r4, #1
10031656:	2100      	movs	r1, #0
10031658:	e7ed      	b.n	10031636 <__ieee754_sqrt+0x136>
1003165a:	ed9d 7b00 	vldr	d7, [sp]
1003165e:	ee37 0b47 	vsub.f64	d0, d7, d7
10031662:	ee80 0b00 	vdiv.f64	d0, d0, d0
10031666:	e7bd      	b.n	100315e4 <__ieee754_sqrt+0xe4>

10031668 <__ieee754_rem_pio2f>:
10031668:	ee10 3a10 	vmov	r3, s0
1003166c:	f640 72d8 	movw	r2, #4056	; 0xfd8
10031670:	b570      	push	{r4, r5, r6, lr}
10031672:	f6c3 7249 	movt	r2, #16201	; 0x3f49
10031676:	b086      	sub	sp, #24
10031678:	4605      	mov	r5, r0
1003167a:	ee10 6a10 	vmov	r6, s0
1003167e:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
10031682:	4294      	cmp	r4, r2
10031684:	dd7d      	ble.n	10031782 <__ieee754_rem_pio2f+0x11a>
10031686:	f64c 32e3 	movw	r2, #52195	; 0xcbe3
1003168a:	f2c4 0216 	movt	r2, #16406	; 0x4016
1003168e:	4294      	cmp	r4, r2
10031690:	dc27      	bgt.n	100316e2 <__ieee754_rem_pio2f+0x7a>
10031692:	2b00      	cmp	r3, #0
10031694:	f44f 627d 	mov.w	r2, #4048	; 0xfd0
10031698:	eddf 7a88 	vldr	s15, [pc, #544]	; 100318bc <__ieee754_rem_pio2f+0x254>
1003169c:	f024 040f 	bic.w	r4, r4, #15
100316a0:	f6c3 72c9 	movt	r2, #16329	; 0x3fc9
100316a4:	eeb0 7a40 	vmov.f32	s14, s0
100316a8:	f340 80eb 	ble.w	10031882 <__ieee754_rem_pio2f+0x21a>
100316ac:	4294      	cmp	r4, r2
100316ae:	bf0a      	itet	eq
100316b0:	eddf 6a83 	vldreq	s13, [pc, #524]	; 100318c0 <__ieee754_rem_pio2f+0x258>
100316b4:	2001      	movne	r0, #1
100316b6:	2001      	moveq	r0, #1
100316b8:	ee70 7a67 	vsub.f32	s15, s0, s15
100316bc:	bf12      	itee	ne
100316be:	ed9f 7a81 	vldrne	s14, [pc, #516]	; 100318c4 <__ieee754_rem_pio2f+0x25c>
100316c2:	ed9f 7a81 	vldreq	s14, [pc, #516]	; 100318c8 <__ieee754_rem_pio2f+0x260>
100316c6:	ee77 7ae6 	vsubeq.f32	s15, s15, s13
100316ca:	ee77 6ac7 	vsub.f32	s13, s15, s14
100316ce:	ee77 7ae6 	vsub.f32	s15, s15, s13
100316d2:	edc5 6a00 	vstr	s13, [r5]
100316d6:	ee77 7ac7 	vsub.f32	s15, s15, s14
100316da:	edc5 7a01 	vstr	s15, [r5, #4]
100316de:	b006      	add	sp, #24
100316e0:	bd70      	pop	{r4, r5, r6, pc}
100316e2:	f44f 6278 	mov.w	r2, #3968	; 0xf80
100316e6:	f2c4 3249 	movt	r2, #17225	; 0x4349
100316ea:	4294      	cmp	r4, r2
100316ec:	dd58      	ble.n	100317a0 <__ieee754_rem_pio2f+0x138>
100316ee:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
100316f2:	da4d      	bge.n	10031790 <__ieee754_rem_pio2f+0x128>
100316f4:	15e2      	asrs	r2, r4, #23
100316f6:	eddf 7a75 	vldr	s15, [pc, #468]	; 100318cc <__ieee754_rem_pio2f+0x264>
100316fa:	3a86      	subs	r2, #134	; 0x86
100316fc:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
10031700:	ee07 3a10 	vmov	s14, r3
10031704:	eefd 6ac7 	vcvt.s32.f32	s13, s14
10031708:	eef8 6ae6 	vcvt.f32.s32	s13, s13
1003170c:	ee37 7a66 	vsub.f32	s14, s14, s13
10031710:	edcd 6a03 	vstr	s13, [sp, #12]
10031714:	ee27 7a27 	vmul.f32	s14, s14, s15
10031718:	eefd 6ac7 	vcvt.s32.f32	s13, s14
1003171c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
10031720:	ee37 7a66 	vsub.f32	s14, s14, s13
10031724:	edcd 6a04 	vstr	s13, [sp, #16]
10031728:	ee67 7a27 	vmul.f32	s15, s14, s15
1003172c:	eef5 7a40 	vcmp.f32	s15, #0.0
10031730:	edcd 7a05 	vstr	s15, [sp, #20]
10031734:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10031738:	bf18      	it	ne
1003173a:	2303      	movne	r3, #3
1003173c:	d106      	bne.n	1003174c <__ieee754_rem_pio2f+0xe4>
1003173e:	eef5 6a40 	vcmp.f32	s13, #0.0
10031742:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10031746:	bf14      	ite	ne
10031748:	2302      	movne	r3, #2
1003174a:	2301      	moveq	r3, #1
1003174c:	f246 41a0 	movw	r1, #25760	; 0x64a0
10031750:	2002      	movs	r0, #2
10031752:	f2c1 0103 	movt	r1, #4099	; 0x1003
10031756:	e88d 0003 	stmia.w	sp, {r0, r1}
1003175a:	a803      	add	r0, sp, #12
1003175c:	4629      	mov	r1, r5
1003175e:	f000 f941 	bl	100319e4 <__kernel_rem_pio2f>
10031762:	2e00      	cmp	r6, #0
10031764:	dabb      	bge.n	100316de <__ieee754_rem_pio2f+0x76>
10031766:	ed95 7a00 	vldr	s14, [r5]
1003176a:	4240      	negs	r0, r0
1003176c:	edd5 7a01 	vldr	s15, [r5, #4]
10031770:	eeb1 7a47 	vneg.f32	s14, s14
10031774:	eef1 7a67 	vneg.f32	s15, s15
10031778:	ed85 7a00 	vstr	s14, [r5]
1003177c:	edc5 7a01 	vstr	s15, [r5, #4]
10031780:	e7ad      	b.n	100316de <__ieee754_rem_pio2f+0x76>
10031782:	2200      	movs	r2, #0
10031784:	2000      	movs	r0, #0
10031786:	ed85 0a00 	vstr	s0, [r5]
1003178a:	606a      	str	r2, [r5, #4]
1003178c:	b006      	add	sp, #24
1003178e:	bd70      	pop	{r4, r5, r6, pc}
10031790:	ee70 7a40 	vsub.f32	s15, s0, s0
10031794:	2000      	movs	r0, #0
10031796:	edc5 7a01 	vstr	s15, [r5, #4]
1003179a:	edc5 7a00 	vstr	s15, [r5]
1003179e:	e79e      	b.n	100316de <__ieee754_rem_pio2f+0x76>
100317a0:	f000 fdc2 	bl	10032328 <fabsf>
100317a4:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
100317a8:	eddf 6a49 	vldr	s13, [pc, #292]	; 100318d0 <__ieee754_rem_pio2f+0x268>
100317ac:	ed9f 6a43 	vldr	s12, [pc, #268]	; 100318bc <__ieee754_rem_pio2f+0x254>
100317b0:	ed9f 7a44 	vldr	s14, [pc, #272]	; 100318c4 <__ieee754_rem_pio2f+0x25c>
100317b4:	ee40 7a26 	vmla.f32	s15, s0, s13
100317b8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
100317bc:	ee17 0a90 	vmov	r0, s15
100317c0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
100317c4:	ee06 0ac6 	vmls.f32	s0, s13, s12
100317c8:	281f      	cmp	r0, #31
100317ca:	ee66 7a87 	vmul.f32	s15, s13, s14
100317ce:	dc21      	bgt.n	10031814 <__ieee754_rem_pio2f+0x1ac>
100317d0:	f246 4220 	movw	r2, #25632	; 0x6420
100317d4:	1e41      	subs	r1, r0, #1
100317d6:	f2c1 0203 	movt	r2, #4099	; 0x1003
100317da:	f024 03ff 	bic.w	r3, r4, #255	; 0xff
100317de:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
100317e2:	4293      	cmp	r3, r2
100317e4:	d016      	beq.n	10031814 <__ieee754_rem_pio2f+0x1ac>
100317e6:	ee30 7a67 	vsub.f32	s14, s0, s15
100317ea:	ed85 7a00 	vstr	s14, [r5]
100317ee:	2e00      	cmp	r6, #0
100317f0:	ee30 0a47 	vsub.f32	s0, s0, s14
100317f4:	ee30 0a67 	vsub.f32	s0, s0, s15
100317f8:	ed85 0a01 	vstr	s0, [r5, #4]
100317fc:	f6bf af6f 	bge.w	100316de <__ieee754_rem_pio2f+0x76>
10031800:	4240      	negs	r0, r0
10031802:	eeb1 7a47 	vneg.f32	s14, s14
10031806:	eeb1 0a40 	vneg.f32	s0, s0
1003180a:	ed85 7a00 	vstr	s14, [r5]
1003180e:	ed85 0a01 	vstr	s0, [r5, #4]
10031812:	e764      	b.n	100316de <__ieee754_rem_pio2f+0x76>
10031814:	ee30 7a67 	vsub.f32	s14, s0, s15
10031818:	15e4      	asrs	r4, r4, #23
1003181a:	ee17 3a10 	vmov	r3, s14
1003181e:	f3c3 53c7 	ubfx	r3, r3, #23, #8
10031822:	1ae3      	subs	r3, r4, r3
10031824:	2b08      	cmp	r3, #8
10031826:	dde0      	ble.n	100317ea <__ieee754_rem_pio2f+0x182>
10031828:	eddf 7a25 	vldr	s15, [pc, #148]	; 100318c0 <__ieee754_rem_pio2f+0x258>
1003182c:	ed9f 7a26 	vldr	s14, [pc, #152]	; 100318c8 <__ieee754_rem_pio2f+0x260>
10031830:	ee66 7aa7 	vmul.f32	s15, s13, s15
10031834:	ee30 6a67 	vsub.f32	s12, s0, s15
10031838:	ee30 0a46 	vsub.f32	s0, s0, s12
1003183c:	ee30 0a67 	vsub.f32	s0, s0, s15
10031840:	eef0 7a40 	vmov.f32	s15, s0
10031844:	ee56 7a87 	vnmls.f32	s15, s13, s14
10031848:	ee36 7a67 	vsub.f32	s14, s12, s15
1003184c:	ee17 3a10 	vmov	r3, s14
10031850:	f3c3 53c7 	ubfx	r3, r3, #23, #8
10031854:	1ae4      	subs	r4, r4, r3
10031856:	2c19      	cmp	r4, #25
10031858:	bfdc      	itt	le
1003185a:	ed85 7a00 	vstrle	s14, [r5]
1003185e:	eeb0 0a46 	vmovle.f32	s0, s12
10031862:	ddc4      	ble.n	100317ee <__ieee754_rem_pio2f+0x186>
10031864:	eddf 7a1b 	vldr	s15, [pc, #108]	; 100318d4 <__ieee754_rem_pio2f+0x26c>
10031868:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 100318d8 <__ieee754_rem_pio2f+0x270>
1003186c:	ee66 7aa7 	vmul.f32	s15, s13, s15
10031870:	ee36 0a67 	vsub.f32	s0, s12, s15
10031874:	ee36 6a40 	vsub.f32	s12, s12, s0
10031878:	ee76 7a67 	vsub.f32	s15, s12, s15
1003187c:	ee56 7a87 	vnmls.f32	s15, s13, s14
10031880:	e7b1      	b.n	100317e6 <__ieee754_rem_pio2f+0x17e>
10031882:	ee70 7a27 	vadd.f32	s15, s0, s15
10031886:	4294      	cmp	r4, r2
10031888:	bf0b      	itete	eq
1003188a:	eddf 6a0d 	vldreq	s13, [pc, #52]	; 100318c0 <__ieee754_rem_pio2f+0x258>
1003188e:	f04f 30ff 	movne.w	r0, #4294967295
10031892:	f04f 30ff 	moveq.w	r0, #4294967295
10031896:	ed9f 7a0b 	vldrne	s14, [pc, #44]	; 100318c4 <__ieee754_rem_pio2f+0x25c>
1003189a:	bf04      	itt	eq
1003189c:	ed9f 7a0a 	vldreq	s14, [pc, #40]	; 100318c8 <__ieee754_rem_pio2f+0x260>
100318a0:	ee77 7aa6 	vaddeq.f32	s15, s15, s13
100318a4:	ee77 6a87 	vadd.f32	s13, s15, s14
100318a8:	ee77 7ae6 	vsub.f32	s15, s15, s13
100318ac:	edc5 6a00 	vstr	s13, [r5]
100318b0:	ee77 7a87 	vadd.f32	s15, s15, s14
100318b4:	edc5 7a01 	vstr	s15, [r5, #4]
100318b8:	e711      	b.n	100316de <__ieee754_rem_pio2f+0x76>
100318ba:	bf00      	nop
100318bc:	3fc90f80 	.word	0x3fc90f80
100318c0:	37354400 	.word	0x37354400
100318c4:	37354443 	.word	0x37354443
100318c8:	2e85a308 	.word	0x2e85a308
100318cc:	43800000 	.word	0x43800000
100318d0:	3f22f984 	.word	0x3f22f984
100318d4:	2e85a300 	.word	0x2e85a300
100318d8:	248d3132 	.word	0x248d3132

100318dc <__kernel_cosf>:
100318dc:	ee10 3a10 	vmov	r3, s0
100318e0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
100318e4:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
100318e8:	da2c      	bge.n	10031944 <__kernel_cosf+0x68>
100318ea:	eefd 7ac0 	vcvt.s32.f32	s15, s0
100318ee:	ee17 3a90 	vmov	r3, s15
100318f2:	2b00      	cmp	r3, #0
100318f4:	d067      	beq.n	100319c6 <__kernel_cosf+0xea>
100318f6:	ee20 7a00 	vmul.f32	s14, s0, s0
100318fa:	eddf 7a34 	vldr	s15, [pc, #208]	; 100319cc <__kernel_cosf+0xf0>
100318fe:	ed9f 5a34 	vldr	s10, [pc, #208]	; 100319d0 <__kernel_cosf+0xf4>
10031902:	eddf 5a34 	vldr	s11, [pc, #208]	; 100319d4 <__kernel_cosf+0xf8>
10031906:	ed9f 6a34 	vldr	s12, [pc, #208]	; 100319d8 <__kernel_cosf+0xfc>
1003190a:	ee07 5a27 	vmla.f32	s10, s14, s15
1003190e:	eddf 7a33 	vldr	s15, [pc, #204]	; 100319dc <__kernel_cosf+0x100>
10031912:	eddf 6a33 	vldr	s13, [pc, #204]	; 100319e0 <__kernel_cosf+0x104>
10031916:	ee55 5a07 	vnmls.f32	s11, s10, s14
1003191a:	ee05 6a87 	vmla.f32	s12, s11, s14
1003191e:	ee56 7a07 	vnmls.f32	s15, s12, s14
10031922:	ee47 6a87 	vmla.f32	s13, s15, s14
10031926:	ee66 6a87 	vmul.f32	s13, s13, s14
1003192a:	ee20 0a20 	vmul.f32	s0, s0, s1
1003192e:	ee17 0a26 	vnmls.f32	s0, s14, s13
10031932:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
10031936:	ee17 0a27 	vnmls.f32	s0, s14, s15
1003193a:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
1003193e:	ee37 0ac0 	vsub.f32	s0, s15, s0
10031942:	4770      	bx	lr
10031944:	ee20 7a00 	vmul.f32	s14, s0, s0
10031948:	f649 1299 	movw	r2, #39321	; 0x9999
1003194c:	eddf 7a1f 	vldr	s15, [pc, #124]	; 100319cc <__kernel_cosf+0xf0>
10031950:	f6c3 6299 	movt	r2, #16025	; 0x3e99
10031954:	4293      	cmp	r3, r2
10031956:	ed9f 5a1e 	vldr	s10, [pc, #120]	; 100319d0 <__kernel_cosf+0xf4>
1003195a:	eddf 5a1e 	vldr	s11, [pc, #120]	; 100319d4 <__kernel_cosf+0xf8>
1003195e:	ed9f 6a1e 	vldr	s12, [pc, #120]	; 100319d8 <__kernel_cosf+0xfc>
10031962:	ee07 5a27 	vmla.f32	s10, s14, s15
10031966:	eddf 7a1d 	vldr	s15, [pc, #116]	; 100319dc <__kernel_cosf+0x100>
1003196a:	eddf 6a1d 	vldr	s13, [pc, #116]	; 100319e0 <__kernel_cosf+0x104>
1003196e:	ee55 5a07 	vnmls.f32	s11, s10, s14
10031972:	ee05 6a87 	vmla.f32	s12, s11, s14
10031976:	ee56 7a07 	vnmls.f32	s15, s12, s14
1003197a:	ee47 6a87 	vmla.f32	s13, s15, s14
1003197e:	ee66 6a87 	vmul.f32	s13, s13, s14
10031982:	ddd2      	ble.n	1003192a <__kernel_cosf+0x4e>
10031984:	2200      	movs	r2, #0
10031986:	f6c3 7248 	movt	r2, #16200	; 0x3f48
1003198a:	4293      	cmp	r3, r2
1003198c:	bfdc      	itt	le
1003198e:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
10031992:	ee07 3a90 	vmovle	s15, r3
10031996:	ee20 0a20 	vmul.f32	s0, s0, s1
1003199a:	bfd4      	ite	le
1003199c:	eeb7 6a00 	vmovle.f32	s12, #112	; 0x70
100319a0:	eef5 7a02 	vmovgt.f32	s15, #82	; 0x52
100319a4:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
100319a8:	bfd8      	it	le
100319aa:	ee36 6a67 	vsuble.f32	s12, s12, s15
100319ae:	ee17 0a26 	vnmls.f32	s0, s14, s13
100319b2:	ee57 7a25 	vnmls.f32	s15, s14, s11
100319b6:	bfc8      	it	gt
100319b8:	eeb6 6a07 	vmovgt.f32	s12, #103	; 0x67
100319bc:	ee37 0ac0 	vsub.f32	s0, s15, s0
100319c0:	ee36 0a40 	vsub.f32	s0, s12, s0
100319c4:	4770      	bx	lr
100319c6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
100319ca:	4770      	bx	lr
100319cc:	ad47d74e 	.word	0xad47d74e
100319d0:	310f74f6 	.word	0x310f74f6
100319d4:	3493f27c 	.word	0x3493f27c
100319d8:	37d00d01 	.word	0x37d00d01
100319dc:	3ab60b61 	.word	0x3ab60b61
100319e0:	3d2aaaab 	.word	0x3d2aaaab

100319e4 <__kernel_rem_pio2f>:
100319e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
100319e8:	1ed5      	subs	r5, r2, #3
100319ea:	ed2d 8b04 	vpush	{d8-d9}
100319ee:	f102 0404 	add.w	r4, r2, #4
100319f2:	bf58      	it	pl
100319f4:	462c      	movpl	r4, r5
100319f6:	1e5f      	subs	r7, r3, #1
100319f8:	10e4      	asrs	r4, r4, #3
100319fa:	f246 75b8 	movw	r5, #26552	; 0x67b8
100319fe:	f2c1 0503 	movt	r5, #4099	; 0x1003
10031a02:	4682      	mov	sl, r0
10031a04:	b0d7      	sub	sp, #348	; 0x15c
10031a06:	9e64      	ldr	r6, [sp, #400]	; 0x190
10031a08:	9302      	str	r3, [sp, #8]
10031a0a:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
10031a0e:	9101      	str	r1, [sp, #4]
10031a10:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
10031a14:	4619      	mov	r1, r3
10031a16:	ea6f 0b01 	mvn.w	fp, r1
10031a1a:	9303      	str	r3, [sp, #12]
10031a1c:	eb02 0bcb 	add.w	fp, r2, fp, lsl #3
10031a20:	19ba      	adds	r2, r7, r6
10031a22:	eba3 0307 	sub.w	r3, r3, r7
10031a26:	d414      	bmi.n	10031a52 <__kernel_rem_pio2f+0x6e>
10031a28:	441a      	add	r2, r3
10031a2a:	9865      	ldr	r0, [sp, #404]	; 0x194
10031a2c:	a91a      	add	r1, sp, #104	; 0x68
10031a2e:	3201      	adds	r2, #1
10031a30:	2b00      	cmp	r3, #0
10031a32:	bfa8      	it	ge
10031a34:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
10031a38:	f103 0301 	add.w	r3, r3, #1
10031a3c:	bfb2      	itee	lt
10031a3e:	eddf 7ac9 	vldrlt	s15, [pc, #804]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031a42:	ee07 4a90 	vmovge	s15, r4
10031a46:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
10031a4a:	4293      	cmp	r3, r2
10031a4c:	ece1 7a01 	vstmia	r1!, {s15}
10031a50:	d1ee      	bne.n	10031a30 <__kernel_rem_pio2f+0x4c>
10031a52:	2e00      	cmp	r6, #0
10031a54:	db1a      	blt.n	10031a8c <__kernel_rem_pio2f+0xa8>
10031a56:	9b02      	ldr	r3, [sp, #8]
10031a58:	1c70      	adds	r0, r6, #1
10031a5a:	a91a      	add	r1, sp, #104	; 0x68
10031a5c:	ac42      	add	r4, sp, #264	; 0x108
10031a5e:	eb01 0080 	add.w	r0, r1, r0, lsl #2
10031a62:	009d      	lsls	r5, r3, #2
10031a64:	2f00      	cmp	r7, #0
10031a66:	f2c0 81c7 	blt.w	10031df8 <__kernel_rem_pio2f+0x414>
10031a6a:	eddf 7abe 	vldr	s15, [pc, #760]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031a6e:	194b      	adds	r3, r1, r5
10031a70:	4652      	mov	r2, sl
10031a72:	ed33 7a01 	vldmdb	r3!, {s14}
10031a76:	ecf2 6a01 	vldmia	r2!, {s13}
10031a7a:	4299      	cmp	r1, r3
10031a7c:	ee46 7a87 	vmla.f32	s15, s13, s14
10031a80:	d1f7      	bne.n	10031a72 <__kernel_rem_pio2f+0x8e>
10031a82:	3104      	adds	r1, #4
10031a84:	ece4 7a01 	vstmia	r4!, {s15}
10031a88:	4281      	cmp	r1, r0
10031a8a:	d1eb      	bne.n	10031a64 <__kernel_rem_pio2f+0x80>
10031a8c:	9a02      	ldr	r2, [sp, #8]
10031a8e:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
10031a92:	3b01      	subs	r3, #1
10031a94:	eddf 8ab1 	vldr	s17, [pc, #708]	; 10031d5c <__kernel_rem_pio2f+0x378>
10031a98:	4634      	mov	r4, r6
10031a9a:	ebc2 7982 	rsb	r9, r2, r2, lsl #30
10031a9e:	009b      	lsls	r3, r3, #2
10031aa0:	ed9f 8aaf 	vldr	s16, [pc, #700]	; 10031d60 <__kernel_rem_pio2f+0x37c>
10031aa4:	f103 0804 	add.w	r8, r3, #4
10031aa8:	aa06      	add	r2, sp, #24
10031aaa:	ea4f 0989 	mov.w	r9, r9, lsl #2
10031aae:	4490      	add	r8, r2
10031ab0:	4413      	add	r3, r2
10031ab2:	9304      	str	r3, [sp, #16]
10031ab4:	00a5      	lsls	r5, r4, #2
10031ab6:	ab56      	add	r3, sp, #344	; 0x158
10031ab8:	442b      	add	r3, r5
10031aba:	2c00      	cmp	r4, #0
10031abc:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
10031ac0:	dd16      	ble.n	10031af0 <__kernel_rem_pio2f+0x10c>
10031ac2:	a942      	add	r1, sp, #264	; 0x108
10031ac4:	aa05      	add	r2, sp, #20
10031ac6:	194b      	adds	r3, r1, r5
10031ac8:	ee60 7a28 	vmul.f32	s15, s0, s17
10031acc:	ed33 7a01 	vldmdb	r3!, {s14}
10031ad0:	428b      	cmp	r3, r1
10031ad2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
10031ad6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
10031ada:	ee07 0ac8 	vmls.f32	s0, s15, s16
10031ade:	eefd 6ac0 	vcvt.s32.f32	s13, s0
10031ae2:	ee16 0a90 	vmov	r0, s13
10031ae6:	ee37 0a87 	vadd.f32	s0, s15, s14
10031aea:	f842 0f04 	str.w	r0, [r2, #4]!
10031aee:	d1eb      	bne.n	10031ac8 <__kernel_rem_pio2f+0xe4>
10031af0:	4658      	mov	r0, fp
10031af2:	f000 fc69 	bl	100323c8 <scalbnf>
10031af6:	eeb0 9a40 	vmov.f32	s18, s0
10031afa:	eeb4 0a00 	vmov.f32	s0, #64	; 0x40
10031afe:	ee29 0a00 	vmul.f32	s0, s18, s0
10031b02:	f000 fc19 	bl	10032338 <floorf>
10031b06:	f1bb 0f00 	cmp.w	fp, #0
10031b0a:	eef2 7a00 	vmov.f32	s15, #32
10031b0e:	ee00 9a67 	vmls.f32	s18, s0, s15
10031b12:	eefd 9ac9 	vcvt.s32.f32	s19, s18
10031b16:	eef8 7ae9 	vcvt.f32.s32	s15, s19
10031b1a:	ee39 9a67 	vsub.f32	s18, s18, s15
10031b1e:	f340 813e 	ble.w	10031d9e <__kernel_rem_pio2f+0x3ba>
10031b22:	ee19 ca90 	vmov	ip, s19
10031b26:	f104 3eff 	add.w	lr, r4, #4294967295
10031b2a:	ab06      	add	r3, sp, #24
10031b2c:	f1cb 0108 	rsb	r1, fp, #8
10031b30:	f1cb 0007 	rsb	r0, fp, #7
10031b34:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
10031b38:	fa43 f201 	asr.w	r2, r3, r1
10031b3c:	4494      	add	ip, r2
10031b3e:	408a      	lsls	r2, r1
10031b40:	1a9a      	subs	r2, r3, r2
10031b42:	ab06      	add	r3, sp, #24
10031b44:	ee09 ca90 	vmov	s19, ip
10031b48:	fa42 f100 	asr.w	r1, r2, r0
10031b4c:	f843 202e 	str.w	r2, [r3, lr, lsl #2]
10031b50:	2900      	cmp	r1, #0
10031b52:	dd39      	ble.n	10031bc8 <__kernel_rem_pio2f+0x1e4>
10031b54:	ee19 3a90 	vmov	r3, s19
10031b58:	2c00      	cmp	r4, #0
10031b5a:	f103 0301 	add.w	r3, r3, #1
10031b5e:	ee09 3a90 	vmov	s19, r3
10031b62:	f340 81c8 	ble.w	10031ef6 <__kernel_rem_pio2f+0x512>
10031b66:	2200      	movs	r2, #0
10031b68:	f10d 0e14 	add.w	lr, sp, #20
10031b6c:	4610      	mov	r0, r2
10031b6e:	e008      	b.n	10031b82 <__kernel_rem_pio2f+0x19e>
10031b70:	f5c3 7c80 	rsb	ip, r3, #256	; 0x100
10031b74:	b113      	cbz	r3, 10031b7c <__kernel_rem_pio2f+0x198>
10031b76:	2001      	movs	r0, #1
10031b78:	f8ce c000 	str.w	ip, [lr]
10031b7c:	3201      	adds	r2, #1
10031b7e:	4294      	cmp	r4, r2
10031b80:	dd0c      	ble.n	10031b9c <__kernel_rem_pio2f+0x1b8>
10031b82:	f85e 3f04 	ldr.w	r3, [lr, #4]!
10031b86:	2800      	cmp	r0, #0
10031b88:	d0f2      	beq.n	10031b70 <__kernel_rem_pio2f+0x18c>
10031b8a:	3201      	adds	r2, #1
10031b8c:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
10031b90:	4294      	cmp	r4, r2
10031b92:	f04f 0001 	mov.w	r0, #1
10031b96:	f8ce 3000 	str.w	r3, [lr]
10031b9a:	dcf2      	bgt.n	10031b82 <__kernel_rem_pio2f+0x19e>
10031b9c:	f1bb 0f00 	cmp.w	fp, #0
10031ba0:	dd10      	ble.n	10031bc4 <__kernel_rem_pio2f+0x1e0>
10031ba2:	f1bb 0f01 	cmp.w	fp, #1
10031ba6:	f000 8101 	beq.w	10031dac <__kernel_rem_pio2f+0x3c8>
10031baa:	f1bb 0f02 	cmp.w	fp, #2
10031bae:	d109      	bne.n	10031bc4 <__kernel_rem_pio2f+0x1e0>
10031bb0:	1e62      	subs	r2, r4, #1
10031bb2:	ab06      	add	r3, sp, #24
10031bb4:	f10d 0e18 	add.w	lr, sp, #24
10031bb8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
10031bbc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
10031bc0:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
10031bc4:	2902      	cmp	r1, #2
10031bc6:	d059      	beq.n	10031c7c <__kernel_rem_pio2f+0x298>
10031bc8:	eeb5 9a40 	vcmp.f32	s18, #0.0
10031bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10031bd0:	d166      	bne.n	10031ca0 <__kernel_rem_pio2f+0x2bc>
10031bd2:	1e63      	subs	r3, r4, #1
10031bd4:	429e      	cmp	r6, r3
10031bd6:	dc0b      	bgt.n	10031bf0 <__kernel_rem_pio2f+0x20c>
10031bd8:	aa06      	add	r2, sp, #24
10031bda:	4415      	add	r5, r2
10031bdc:	2200      	movs	r2, #0
10031bde:	f855 0d04 	ldr.w	r0, [r5, #-4]!
10031be2:	4545      	cmp	r5, r8
10031be4:	ea42 0200 	orr.w	r2, r2, r0
10031be8:	d1f9      	bne.n	10031bde <__kernel_rem_pio2f+0x1fa>
10031bea:	2a00      	cmp	r2, #0
10031bec:	f040 816e 	bne.w	10031ecc <__kernel_rem_pio2f+0x4e8>
10031bf0:	1e73      	subs	r3, r6, #1
10031bf2:	aa06      	add	r2, sp, #24
10031bf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
10031bf8:	2b00      	cmp	r3, #0
10031bfa:	f040 817a 	bne.w	10031ef2 <__kernel_rem_pio2f+0x50e>
10031bfe:	9b04      	ldr	r3, [sp, #16]
10031c00:	2501      	movs	r5, #1
10031c02:	f853 2d04 	ldr.w	r2, [r3, #-4]!
10031c06:	3501      	adds	r5, #1
10031c08:	2a00      	cmp	r2, #0
10031c0a:	d0fa      	beq.n	10031c02 <__kernel_rem_pio2f+0x21e>
10031c0c:	4425      	add	r5, r4
10031c0e:	f104 0e01 	add.w	lr, r4, #1
10031c12:	45ae      	cmp	lr, r5
10031c14:	dc30      	bgt.n	10031c78 <__kernel_rem_pio2f+0x294>
10031c16:	9a02      	ldr	r2, [sp, #8]
10031c18:	9b03      	ldr	r3, [sp, #12]
10031c1a:	18a0      	adds	r0, r4, r2
10031c1c:	eb05 0c02 	add.w	ip, r5, r2
10031c20:	4473      	add	r3, lr
10031c22:	aa1a      	add	r2, sp, #104	; 0x68
10031c24:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
10031c28:	eb02 0080 	add.w	r0, r2, r0, lsl #2
10031c2c:	3b01      	subs	r3, #1
10031c2e:	9a65      	ldr	r2, [sp, #404]	; 0x194
10031c30:	eb02 0483 	add.w	r4, r2, r3, lsl #2
10031c34:	ab1a      	add	r3, sp, #104	; 0x68
10031c36:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
10031c3a:	ab42      	add	r3, sp, #264	; 0x108
10031c3c:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
10031c40:	f854 3f04 	ldr.w	r3, [r4, #4]!
10031c44:	2f00      	cmp	r7, #0
10031c46:	ee07 3a90 	vmov	s15, r3
10031c4a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
10031c4e:	ece0 7a01 	vstmia	r0!, {s15}
10031c52:	eddf 7a44 	vldr	s15, [pc, #272]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031c56:	db0b      	blt.n	10031c70 <__kernel_rem_pio2f+0x28c>
10031c58:	eb00 0109 	add.w	r1, r0, r9
10031c5c:	4652      	mov	r2, sl
10031c5e:	4603      	mov	r3, r0
10031c60:	ed33 7a01 	vldmdb	r3!, {s14}
10031c64:	ecf2 6a01 	vldmia	r2!, {s13}
10031c68:	428b      	cmp	r3, r1
10031c6a:	ee46 7a87 	vmla.f32	s15, s13, s14
10031c6e:	d1f7      	bne.n	10031c60 <__kernel_rem_pio2f+0x27c>
10031c70:	4560      	cmp	r0, ip
10031c72:	ecee 7a01 	vstmia	lr!, {s15}
10031c76:	d1e3      	bne.n	10031c40 <__kernel_rem_pio2f+0x25c>
10031c78:	462c      	mov	r4, r5
10031c7a:	e71b      	b.n	10031ab4 <__kernel_rem_pio2f+0xd0>
10031c7c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
10031c80:	ee30 9a49 	vsub.f32	s18, s0, s18
10031c84:	2800      	cmp	r0, #0
10031c86:	d09f      	beq.n	10031bc8 <__kernel_rem_pio2f+0x1e4>
10031c88:	4658      	mov	r0, fp
10031c8a:	9105      	str	r1, [sp, #20]
10031c8c:	f000 fb9c 	bl	100323c8 <scalbnf>
10031c90:	9905      	ldr	r1, [sp, #20]
10031c92:	ee39 9a40 	vsub.f32	s18, s18, s0
10031c96:	eeb5 9a40 	vcmp.f32	s18, #0.0
10031c9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10031c9e:	d098      	beq.n	10031bd2 <__kernel_rem_pio2f+0x1ee>
10031ca0:	eeb0 0a49 	vmov.f32	s0, s18
10031ca4:	f1cb 0000 	rsb	r0, fp, #0
10031ca8:	9102      	str	r1, [sp, #8]
10031caa:	f000 fb8d 	bl	100323c8 <scalbnf>
10031cae:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 10031d60 <__kernel_rem_pio2f+0x37c>
10031cb2:	9902      	ldr	r1, [sp, #8]
10031cb4:	eeb4 0ac7 	vcmpe.f32	s0, s14
10031cb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10031cbc:	f2c0 817b 	blt.w	10031fb6 <__kernel_rem_pio2f+0x5d2>
10031cc0:	eddf 7a26 	vldr	s15, [pc, #152]	; 10031d5c <__kernel_rem_pio2f+0x378>
10031cc4:	a806      	add	r0, sp, #24
10031cc6:	1c63      	adds	r3, r4, #1
10031cc8:	f10b 0b08 	add.w	fp, fp, #8
10031ccc:	ee60 7a27 	vmul.f32	s15, s0, s15
10031cd0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
10031cd4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
10031cd8:	ee07 0ac7 	vmls.f32	s0, s15, s14
10031cdc:	eebd 0ac0 	vcvt.s32.f32	s0, s0
10031ce0:	ee10 2a10 	vmov	r2, s0
10031ce4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
10031ce8:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
10031cec:	ee17 2a90 	vmov	r2, s15
10031cf0:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
10031cf4:	4658      	mov	r0, fp
10031cf6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
10031cfa:	9303      	str	r3, [sp, #12]
10031cfc:	9102      	str	r1, [sp, #8]
10031cfe:	f000 fb63 	bl	100323c8 <scalbnf>
10031d02:	9b03      	ldr	r3, [sp, #12]
10031d04:	9902      	ldr	r1, [sp, #8]
10031d06:	2b00      	cmp	r3, #0
10031d08:	f2c0 80c5 	blt.w	10031e96 <__kernel_rem_pio2f+0x4b2>
10031d0c:	f103 0e01 	add.w	lr, r3, #1
10031d10:	ed9f 7a12 	vldr	s14, [pc, #72]	; 10031d5c <__kernel_rem_pio2f+0x378>
10031d14:	ac42      	add	r4, sp, #264	; 0x108
10031d16:	a806      	add	r0, sp, #24
10031d18:	ea4f 028e 	mov.w	r2, lr, lsl #2
10031d1c:	4410      	add	r0, r2
10031d1e:	18a7      	adds	r7, r4, r2
10031d20:	ed70 7a01 	vldmdb	r0!, {s15}
10031d24:	eef8 7ae7 	vcvt.f32.s32	s15, s15
10031d28:	ee67 7a80 	vmul.f32	s15, s15, s0
10031d2c:	ed67 7a01 	vstmdb	r7!, {s15}
10031d30:	ee20 0a07 	vmul.f32	s0, s0, s14
10031d34:	42a7      	cmp	r7, r4
10031d36:	d1f3      	bne.n	10031d20 <__kernel_rem_pio2f+0x33c>
10031d38:	3a04      	subs	r2, #4
10031d3a:	2500      	movs	r5, #0
10031d3c:	4417      	add	r7, r2
10031d3e:	2e00      	cmp	r6, #0
10031d40:	f2c0 80a6 	blt.w	10031e90 <__kernel_rem_pio2f+0x4ac>
10031d44:	2d00      	cmp	r5, #0
10031d46:	f2c0 80a3 	blt.w	10031e90 <__kernel_rem_pio2f+0x4ac>
10031d4a:	f246 70c4 	movw	r0, #26564	; 0x67c4
10031d4e:	463c      	mov	r4, r7
10031d50:	f2c1 0003 	movt	r0, #4099	; 0x1003
10031d54:	eddf 7a03 	vldr	s15, [pc, #12]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031d58:	2200      	movs	r2, #0
10031d5a:	e007      	b.n	10031d6c <__kernel_rem_pio2f+0x388>
10031d5c:	3b800000 	.word	0x3b800000
10031d60:	43800000 	.word	0x43800000
10031d64:	00000000 	.word	0x00000000
10031d68:	42aa      	cmp	r2, r5
10031d6a:	dc08      	bgt.n	10031d7e <__kernel_rem_pio2f+0x39a>
10031d6c:	ecf0 6a01 	vldmia	r0!, {s13}
10031d70:	3201      	adds	r2, #1
10031d72:	4296      	cmp	r6, r2
10031d74:	ecb4 7a01 	vldmia	r4!, {s14}
10031d78:	ee46 7a87 	vmla.f32	s15, s13, s14
10031d7c:	daf4      	bge.n	10031d68 <__kernel_rem_pio2f+0x384>
10031d7e:	aa56      	add	r2, sp, #344	; 0x158
10031d80:	3f04      	subs	r7, #4
10031d82:	eb02 0285 	add.w	r2, r2, r5, lsl #2
10031d86:	3501      	adds	r5, #1
10031d88:	4575      	cmp	r5, lr
10031d8a:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
10031d8e:	d1d6      	bne.n	10031d3e <__kernel_rem_pio2f+0x35a>
10031d90:	9a64      	ldr	r2, [sp, #400]	; 0x190
10031d92:	2a03      	cmp	r2, #3
10031d94:	d860      	bhi.n	10031e58 <__kernel_rem_pio2f+0x474>
10031d96:	e8df f002 	tbb	[pc, r2]
10031d9a:	3868      	.short	0x3868
10031d9c:	b038      	.short	0xb038
10031d9e:	d110      	bne.n	10031dc2 <__kernel_rem_pio2f+0x3de>
10031da0:	1e63      	subs	r3, r4, #1
10031da2:	aa06      	add	r2, sp, #24
10031da4:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
10031da8:	1209      	asrs	r1, r1, #8
10031daa:	e6d1      	b.n	10031b50 <__kernel_rem_pio2f+0x16c>
10031dac:	1e62      	subs	r2, r4, #1
10031dae:	ab06      	add	r3, sp, #24
10031db0:	f10d 0e18 	add.w	lr, sp, #24
10031db4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
10031db8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
10031dbc:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
10031dc0:	e700      	b.n	10031bc4 <__kernel_rem_pio2f+0x1e0>
10031dc2:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
10031dc6:	eeb4 9ae7 	vcmpe.f32	s18, s15
10031dca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
10031dce:	bfb8      	it	lt
10031dd0:	2100      	movlt	r1, #0
10031dd2:	f6ff aef9 	blt.w	10031bc8 <__kernel_rem_pio2f+0x1e4>
10031dd6:	ee19 3a90 	vmov	r3, s19
10031dda:	2c00      	cmp	r4, #0
10031ddc:	bfc8      	it	gt
10031dde:	2102      	movgt	r1, #2
10031de0:	f103 0301 	add.w	r3, r3, #1
10031de4:	ee09 3a90 	vmov	s19, r3
10031de8:	f73f aebd 	bgt.w	10031b66 <__kernel_rem_pio2f+0x182>
10031dec:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
10031df0:	2102      	movs	r1, #2
10031df2:	ee37 9ac9 	vsub.f32	s18, s15, s18
10031df6:	e6e7      	b.n	10031bc8 <__kernel_rem_pio2f+0x1e4>
10031df8:	ed5f 7a26 	vldr	s15, [pc, #-152]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031dfc:	3104      	adds	r1, #4
10031dfe:	4281      	cmp	r1, r0
10031e00:	ece4 7a01 	vstmia	r4!, {s15}
10031e04:	f47f ae2e 	bne.w	10031a64 <__kernel_rem_pio2f+0x80>
10031e08:	e640      	b.n	10031a8c <__kernel_rem_pio2f+0xa8>
10031e0a:	ed5f 7a2a 	vldr	s15, [pc, #-168]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031e0e:	aa2e      	add	r2, sp, #184	; 0xb8
10031e10:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
10031e14:	ed3e 7a01 	vldmdb	lr!, {s14}
10031e18:	4596      	cmp	lr, r2
10031e1a:	ee77 7a87 	vadd.f32	s15, s15, s14
10031e1e:	d1f9      	bne.n	10031e14 <__kernel_rem_pio2f+0x430>
10031e20:	2900      	cmp	r1, #0
10031e22:	d043      	beq.n	10031eac <__kernel_rem_pio2f+0x4c8>
10031e24:	eeb1 7a67 	vneg.f32	s14, s15
10031e28:	9a01      	ldr	r2, [sp, #4]
10031e2a:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
10031e2e:	2b00      	cmp	r3, #0
10031e30:	ed82 7a00 	vstr	s14, [r2]
10031e34:	ee76 7ae7 	vsub.f32	s15, s13, s15
10031e38:	dd09      	ble.n	10031e4e <__kernel_rem_pio2f+0x46a>
10031e3a:	a82f      	add	r0, sp, #188	; 0xbc
10031e3c:	2201      	movs	r2, #1
10031e3e:	ecb0 7a01 	vldmia	r0!, {s14}
10031e42:	3201      	adds	r2, #1
10031e44:	4293      	cmp	r3, r2
10031e46:	ee77 7a87 	vadd.f32	s15, s15, s14
10031e4a:	daf8      	bge.n	10031e3e <__kernel_rem_pio2f+0x45a>
10031e4c:	b109      	cbz	r1, 10031e52 <__kernel_rem_pio2f+0x46e>
10031e4e:	eef1 7a67 	vneg.f32	s15, s15
10031e52:	9b01      	ldr	r3, [sp, #4]
10031e54:	edc3 7a01 	vstr	s15, [r3, #4]
10031e58:	ee19 3a90 	vmov	r3, s19
10031e5c:	f003 0007 	and.w	r0, r3, #7
10031e60:	b057      	add	sp, #348	; 0x15c
10031e62:	ecbd 8b04 	vpop	{d8-d9}
10031e66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
10031e6a:	ed5f 7a42 	vldr	s15, [pc, #-264]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031e6e:	aa2e      	add	r2, sp, #184	; 0xb8
10031e70:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
10031e74:	3b01      	subs	r3, #1
10031e76:	ed3e 7a01 	vldmdb	lr!, {s14}
10031e7a:	1c5a      	adds	r2, r3, #1
10031e7c:	ee77 7a87 	vadd.f32	s15, s15, s14
10031e80:	d1f8      	bne.n	10031e74 <__kernel_rem_pio2f+0x490>
10031e82:	b109      	cbz	r1, 10031e88 <__kernel_rem_pio2f+0x4a4>
10031e84:	eef1 7a67 	vneg.f32	s15, s15
10031e88:	9b01      	ldr	r3, [sp, #4]
10031e8a:	edc3 7a00 	vstr	s15, [r3]
10031e8e:	e7e3      	b.n	10031e58 <__kernel_rem_pio2f+0x474>
10031e90:	ed5f 7a4c 	vldr	s15, [pc, #-304]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031e94:	e773      	b.n	10031d7e <__kernel_rem_pio2f+0x39a>
10031e96:	9a64      	ldr	r2, [sp, #400]	; 0x190
10031e98:	2a03      	cmp	r2, #3
10031e9a:	d8dd      	bhi.n	10031e58 <__kernel_rem_pio2f+0x474>
10031e9c:	e8df f002 	tbb	[pc, r2]
10031ea0:	7f020213 	.word	0x7f020213
10031ea4:	ed5f 7a51 	vldr	s15, [pc, #-324]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031ea8:	2900      	cmp	r1, #0
10031eaa:	d1bb      	bne.n	10031e24 <__kernel_rem_pio2f+0x440>
10031eac:	9a01      	ldr	r2, [sp, #4]
10031eae:	2b00      	cmp	r3, #0
10031eb0:	ed9d 7a2e 	vldr	s14, [sp, #184]	; 0xb8
10031eb4:	edc2 7a00 	vstr	s15, [r2]
10031eb8:	ee77 7a67 	vsub.f32	s15, s14, s15
10031ebc:	dcbd      	bgt.n	10031e3a <__kernel_rem_pio2f+0x456>
10031ebe:	9b01      	ldr	r3, [sp, #4]
10031ec0:	edc3 7a01 	vstr	s15, [r3, #4]
10031ec4:	e7c8      	b.n	10031e58 <__kernel_rem_pio2f+0x474>
10031ec6:	ed5f 7a59 	vldr	s15, [pc, #-356]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031eca:	e7da      	b.n	10031e82 <__kernel_rem_pio2f+0x49e>
10031ecc:	aa06      	add	r2, sp, #24
10031ece:	f1ab 0b08 	sub.w	fp, fp, #8
10031ed2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
10031ed6:	2a00      	cmp	r2, #0
10031ed8:	f47f af0c 	bne.w	10031cf4 <__kernel_rem_pio2f+0x310>
10031edc:	aa06      	add	r2, sp, #24
10031ede:	eb02 0283 	add.w	r2, r2, r3, lsl #2
10031ee2:	f852 0d04 	ldr.w	r0, [r2, #-4]!
10031ee6:	3b01      	subs	r3, #1
10031ee8:	f1ab 0b08 	sub.w	fp, fp, #8
10031eec:	2800      	cmp	r0, #0
10031eee:	d0f8      	beq.n	10031ee2 <__kernel_rem_pio2f+0x4fe>
10031ef0:	e700      	b.n	10031cf4 <__kernel_rem_pio2f+0x310>
10031ef2:	2501      	movs	r5, #1
10031ef4:	e68a      	b.n	10031c0c <__kernel_rem_pio2f+0x228>
10031ef6:	2000      	movs	r0, #0
10031ef8:	e650      	b.n	10031b9c <__kernel_rem_pio2f+0x1b8>
10031efa:	2b00      	cmp	r3, #0
10031efc:	dd4f      	ble.n	10031f9e <__kernel_rem_pio2f+0x5ba>
10031efe:	009a      	lsls	r2, r3, #2
10031f00:	a856      	add	r0, sp, #344	; 0x158
10031f02:	1886      	adds	r6, r0, r2
10031f04:	ad2e      	add	r5, sp, #184	; 0xb8
10031f06:	1d14      	adds	r4, r2, #4
10031f08:	18a8      	adds	r0, r5, r2
10031f0a:	ed16 7a28 	vldr	s14, [r6, #-160]	; 0xffffff60
10031f0e:	442c      	add	r4, r5
10031f10:	ed70 7a01 	vldmdb	r0!, {s15}
10031f14:	ee77 6a27 	vadd.f32	s13, s14, s15
10031f18:	42a8      	cmp	r0, r5
10031f1a:	ee77 7ae6 	vsub.f32	s15, s15, s13
10031f1e:	ee77 7a27 	vadd.f32	s15, s14, s15
10031f22:	eeb0 7a66 	vmov.f32	s14, s13
10031f26:	ed64 7a01 	vstmdb	r4!, {s15}
10031f2a:	edc0 6a00 	vstr	s13, [r0]
10031f2e:	d1ef      	bne.n	10031f10 <__kernel_rem_pio2f+0x52c>
10031f30:	2b01      	cmp	r3, #1
10031f32:	dd34      	ble.n	10031f9e <__kernel_rem_pio2f+0x5ba>
10031f34:	ab56      	add	r3, sp, #344	; 0x158
10031f36:	189c      	adds	r4, r3, r2
10031f38:	1d13      	adds	r3, r2, #4
10031f3a:	4403      	add	r3, r0
10031f3c:	4402      	add	r2, r0
10031f3e:	ed14 7a28 	vldr	s14, [r4, #-160]	; 0xffffff60
10031f42:	ac2f      	add	r4, sp, #188	; 0xbc
10031f44:	4618      	mov	r0, r3
10031f46:	ed72 7a01 	vldmdb	r2!, {s15}
10031f4a:	ee77 6a87 	vadd.f32	s13, s15, s14
10031f4e:	42a2      	cmp	r2, r4
10031f50:	ee77 7ae6 	vsub.f32	s15, s15, s13
10031f54:	ee77 7a87 	vadd.f32	s15, s15, s14
10031f58:	eeb0 7a66 	vmov.f32	s14, s13
10031f5c:	ed60 7a01 	vstmdb	r0!, {s15}
10031f60:	edc2 6a00 	vstr	s13, [r2]
10031f64:	d1ef      	bne.n	10031f46 <__kernel_rem_pio2f+0x562>
10031f66:	ed5f 7a81 	vldr	s15, [pc, #-516]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031f6a:	aa30      	add	r2, sp, #192	; 0xc0
10031f6c:	ed33 7a01 	vldmdb	r3!, {s14}
10031f70:	4293      	cmp	r3, r2
10031f72:	ee77 7a87 	vadd.f32	s15, s15, s14
10031f76:	d1f9      	bne.n	10031f6c <__kernel_rem_pio2f+0x588>
10031f78:	b1a9      	cbz	r1, 10031fa6 <__kernel_rem_pio2f+0x5c2>
10031f7a:	eef1 7a67 	vneg.f32	s15, s15
10031f7e:	9a01      	ldr	r2, [sp, #4]
10031f80:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
10031f84:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
10031f88:	eef1 6a66 	vneg.f32	s13, s13
10031f8c:	edc2 7a02 	vstr	s15, [r2, #8]
10031f90:	eef1 7a47 	vneg.f32	s15, s14
10031f94:	edc2 6a00 	vstr	s13, [r2]
10031f98:	edc2 7a01 	vstr	s15, [r2, #4]
10031f9c:	e75c      	b.n	10031e58 <__kernel_rem_pio2f+0x474>
10031f9e:	ed5f 7a8f 	vldr	s15, [pc, #-572]	; 10031d64 <__kernel_rem_pio2f+0x380>
10031fa2:	2900      	cmp	r1, #0
10031fa4:	d1e9      	bne.n	10031f7a <__kernel_rem_pio2f+0x596>
10031fa6:	9801      	ldr	r0, [sp, #4]
10031fa8:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
10031faa:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
10031fac:	edc0 7a02 	vstr	s15, [r0, #8]
10031fb0:	6002      	str	r2, [r0, #0]
10031fb2:	6043      	str	r3, [r0, #4]
10031fb4:	e750      	b.n	10031e58 <__kernel_rem_pio2f+0x474>
10031fb6:	eebd 0ac0 	vcvt.s32.f32	s0, s0
10031fba:	a806      	add	r0, sp, #24
10031fbc:	4623      	mov	r3, r4
10031fbe:	ee10 2a10 	vmov	r2, s0
10031fc2:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
10031fc6:	e695      	b.n	10031cf4 <__kernel_rem_pio2f+0x310>

10031fc8 <__kernel_sinf>:
10031fc8:	ee10 3a10 	vmov	r3, s0
10031fcc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10031fd0:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
10031fd4:	da04      	bge.n	10031fe0 <__kernel_sinf+0x18>
10031fd6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
10031fda:	ee17 3a90 	vmov	r3, s15
10031fde:	b323      	cbz	r3, 1003202a <__kernel_sinf+0x62>
10031fe0:	ee60 7a00 	vmul.f32	s15, s0, s0
10031fe4:	ed9f 7a15 	vldr	s14, [pc, #84]	; 1003203c <__kernel_sinf+0x74>
10031fe8:	eddf 5a15 	vldr	s11, [pc, #84]	; 10032040 <__kernel_sinf+0x78>
10031fec:	ed9f 6a15 	vldr	s12, [pc, #84]	; 10032044 <__kernel_sinf+0x7c>
10031ff0:	eddf 6a15 	vldr	s13, [pc, #84]	; 10032048 <__kernel_sinf+0x80>
10031ff4:	ee57 5a87 	vnmls.f32	s11, s15, s14
10031ff8:	ed9f 7a14 	vldr	s14, [pc, #80]	; 1003204c <__kernel_sinf+0x84>
10031ffc:	ee05 6aa7 	vmla.f32	s12, s11, s15
10032000:	ee56 6a27 	vnmls.f32	s13, s12, s15
10032004:	ee27 6a80 	vmul.f32	s12, s15, s0
10032008:	ee06 7aa7 	vmla.f32	s14, s13, s15
1003200c:	b170      	cbz	r0, 1003202c <__kernel_sinf+0x64>
1003200e:	eddf 6a10 	vldr	s13, [pc, #64]	; 10032050 <__kernel_sinf+0x88>
10032012:	ee26 7a07 	vmul.f32	s14, s12, s14
10032016:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
1003201a:	ee10 7aa5 	vnmls.f32	s14, s1, s11
1003201e:	ee57 0a27 	vnmls.f32	s1, s14, s15
10032022:	ee46 0a26 	vmla.f32	s1, s12, s13
10032026:	ee30 0a60 	vsub.f32	s0, s0, s1
1003202a:	4770      	bx	lr
1003202c:	eddf 6a08 	vldr	s13, [pc, #32]	; 10032050 <__kernel_sinf+0x88>
10032030:	ee57 6a87 	vnmls.f32	s13, s15, s14
10032034:	ee06 0a86 	vmla.f32	s0, s13, s12
10032038:	4770      	bx	lr
1003203a:	bf00      	nop
1003203c:	2f2ec9d3 	.word	0x2f2ec9d3
10032040:	32d72f34 	.word	0x32d72f34
10032044:	3638ef1b 	.word	0x3638ef1b
10032048:	39500d01 	.word	0x39500d01
1003204c:	3c088889 	.word	0x3c088889
10032050:	3e2aaaab 	.word	0x3e2aaaab

10032054 <fabs>:
10032054:	ec51 0b10 	vmov	r0, r1, d0
10032058:	ee10 2a10 	vmov	r2, s0
1003205c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
10032060:	ec43 2b10 	vmov	d0, r2, r3
10032064:	4770      	bx	lr
10032066:	bf00      	nop

10032068 <finite>:
10032068:	ee10 3a90 	vmov	r3, s1
1003206c:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
10032070:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
10032074:	0fc0      	lsrs	r0, r0, #31
10032076:	4770      	bx	lr

10032078 <__fpclassifyd>:
10032078:	ec53 2b10 	vmov	r2, r3, d0
1003207c:	4618      	mov	r0, r3
1003207e:	ea52 0300 	orrs.w	r3, r2, r0
10032082:	d101      	bne.n	10032088 <__fpclassifyd+0x10>
10032084:	2002      	movs	r0, #2
10032086:	4770      	bx	lr
10032088:	fab2 f382 	clz	r3, r2
1003208c:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
10032090:	bf08      	it	eq
10032092:	2a00      	cmpeq	r2, #0
10032094:	ea4f 1353 	mov.w	r3, r3, lsr #5
10032098:	d0f4      	beq.n	10032084 <__fpclassifyd+0xc>
1003209a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
1003209e:	f64f 72ff 	movw	r2, #65535	; 0xffff
100320a2:	f5a0 1180 	sub.w	r1, r0, #1048576	; 0x100000
100320a6:	f6c7 72df 	movt	r2, #32735	; 0x7fdf
100320aa:	4291      	cmp	r1, r2
100320ac:	d801      	bhi.n	100320b2 <__fpclassifyd+0x3a>
100320ae:	2004      	movs	r0, #4
100320b0:	4770      	bx	lr
100320b2:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
100320b6:	d201      	bcs.n	100320bc <__fpclassifyd+0x44>
100320b8:	2003      	movs	r0, #3
100320ba:	4770      	bx	lr
100320bc:	2200      	movs	r2, #0
100320be:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
100320c2:	4290      	cmp	r0, r2
100320c4:	bf14      	ite	ne
100320c6:	2000      	movne	r0, #0
100320c8:	f003 0001 	andeq.w	r0, r3, #1
100320cc:	4770      	bx	lr
100320ce:	bf00      	nop

100320d0 <matherr>:
100320d0:	2000      	movs	r0, #0
100320d2:	4770      	bx	lr
100320d4:	0000      	movs	r0, r0
	...

100320d8 <nan>:
100320d8:	ed9f 0b01 	vldr	d0, [pc, #4]	; 100320e0 <nan+0x8>
100320dc:	4770      	bx	lr
100320de:	bf00      	nop
100320e0:	00000000 	.word	0x00000000
100320e4:	7ff80000 	.word	0x7ff80000

100320e8 <rint>:
100320e8:	ec53 2b10 	vmov	r2, r3, d0
100320ec:	b4f0      	push	{r4, r5, r6, r7}
100320ee:	b084      	sub	sp, #16
100320f0:	ee10 7a10 	vmov	r7, s0
100320f4:	f3c3 550a 	ubfx	r5, r3, #20, #11
100320f8:	4619      	mov	r1, r3
100320fa:	f2a5 30ff 	subw	r0, r5, #1023	; 0x3ff
100320fe:	0fde      	lsrs	r6, r3, #31
10032100:	2813      	cmp	r0, #19
10032102:	4614      	mov	r4, r2
10032104:	dc32      	bgt.n	1003216c <rint+0x84>
10032106:	2800      	cmp	r0, #0
10032108:	db4c      	blt.n	100321a4 <rint+0xbc>
1003210a:	f64f 75ff 	movw	r5, #65535	; 0xffff
1003210e:	f2c0 050f 	movt	r5, #15
10032112:	4105      	asrs	r5, r0
10032114:	ea05 0703 	and.w	r7, r5, r3
10032118:	4317      	orrs	r7, r2
1003211a:	d02c      	beq.n	10032176 <rint+0x8e>
1003211c:	086d      	lsrs	r5, r5, #1
1003211e:	402b      	ands	r3, r5
10032120:	431c      	orrs	r4, r3
10032122:	d00c      	beq.n	1003213e <rint+0x56>
10032124:	f44f 2380 	mov.w	r3, #262144	; 0x40000
10032128:	2813      	cmp	r0, #19
1003212a:	ea21 0505 	bic.w	r5, r1, r5
1003212e:	fa43 f100 	asr.w	r1, r3, r0
10032132:	ea41 0105 	orr.w	r1, r1, r5
10032136:	bf0c      	ite	eq
10032138:	f04f 4400 	moveq.w	r4, #2147483648	; 0x80000000
1003213c:	2400      	movne	r4, #0
1003213e:	f246 70f0 	movw	r0, #26608	; 0x67f0
10032142:	460b      	mov	r3, r1
10032144:	f2c1 0003 	movt	r0, #4099	; 0x1003
10032148:	eb00 06c6 	add.w	r6, r0, r6, lsl #3
1003214c:	4622      	mov	r2, r4
1003214e:	ed96 0b00 	vldr	d0, [r6]
10032152:	ec43 2b17 	vmov	d7, r2, r3
10032156:	ee30 7b07 	vadd.f64	d7, d0, d7
1003215a:	ed8d 7b02 	vstr	d7, [sp, #8]
1003215e:	ed9d 7b02 	vldr	d7, [sp, #8]
10032162:	ee37 0b40 	vsub.f64	d0, d7, d0
10032166:	b004      	add	sp, #16
10032168:	bcf0      	pop	{r4, r5, r6, r7}
1003216a:	4770      	bx	lr
1003216c:	2833      	cmp	r0, #51	; 0x33
1003216e:	dd07      	ble.n	10032180 <rint+0x98>
10032170:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
10032174:	d045      	beq.n	10032202 <rint+0x11a>
10032176:	ec43 2b10 	vmov	d0, r2, r3
1003217a:	b004      	add	sp, #16
1003217c:	bcf0      	pop	{r4, r5, r6, r7}
1003217e:	4770      	bx	lr
10032180:	f2a5 4513 	subw	r5, r5, #1043	; 0x413
10032184:	f04f 30ff 	mov.w	r0, #4294967295
10032188:	40e8      	lsrs	r0, r5
1003218a:	4210      	tst	r0, r2
1003218c:	d0f3      	beq.n	10032176 <rint+0x8e>
1003218e:	0840      	lsrs	r0, r0, #1
10032190:	4210      	tst	r0, r2
10032192:	bf1f      	itttt	ne
10032194:	ea27 0000 	bicne.w	r0, r7, r0
10032198:	f04f 4380 	movne.w	r3, #1073741824	; 0x40000000
1003219c:	fa43 f405 	asrne.w	r4, r3, r5
100321a0:	4304      	orrne	r4, r0
100321a2:	e7cc      	b.n	1003213e <rint+0x56>
100321a4:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
100321a8:	4310      	orrs	r0, r2
100321aa:	d0e4      	beq.n	10032176 <rint+0x8e>
100321ac:	f3c3 0013 	ubfx	r0, r3, #0, #20
100321b0:	0c59      	lsrs	r1, r3, #17
100321b2:	4307      	orrs	r7, r0
100321b4:	f246 70f0 	movw	r0, #26608	; 0x67f0
100321b8:	427c      	negs	r4, r7
100321ba:	f2c1 0003 	movt	r0, #4099	; 0x1003
100321be:	4327      	orrs	r7, r4
100321c0:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
100321c4:	0449      	lsls	r1, r1, #17
100321c6:	0b3f      	lsrs	r7, r7, #12
100321c8:	ed90 5b00 	vldr	d5, [r0]
100321cc:	f407 2700 	and.w	r7, r7, #524288	; 0x80000
100321d0:	ea47 0301 	orr.w	r3, r7, r1
100321d4:	ec43 2b16 	vmov	d6, r2, r3
100321d8:	ee35 6b06 	vadd.f64	d6, d5, d6
100321dc:	ed8d 6b02 	vstr	d6, [sp, #8]
100321e0:	ed9d 7b02 	vldr	d7, [sp, #8]
100321e4:	ee37 7b45 	vsub.f64	d7, d7, d5
100321e8:	ee17 1a90 	vmov	r1, s15
100321ec:	ed8d 7b00 	vstr	d7, [sp]
100321f0:	e9dd 2300 	ldrd	r2, r3, [sp]
100321f4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
100321f8:	ea41 73c6 	orr.w	r3, r1, r6, lsl #31
100321fc:	ec43 2b10 	vmov	d0, r2, r3
10032200:	e7bb      	b.n	1003217a <rint+0x92>
10032202:	ee30 0b00 	vadd.f64	d0, d0, d0
10032206:	e7b8      	b.n	1003217a <rint+0x92>

10032208 <scalbn>:
10032208:	b510      	push	{r4, lr}
1003220a:	ed2d 8b02 	vpush	{d8}
1003220e:	b082      	sub	sp, #8
10032210:	ed8d 0b00 	vstr	d0, [sp]
10032214:	9b01      	ldr	r3, [sp, #4]
10032216:	9900      	ldr	r1, [sp, #0]
10032218:	f3c3 520a 	ubfx	r2, r3, #20, #11
1003221c:	bb4a      	cbnz	r2, 10032272 <scalbn+0x6a>
1003221e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10032222:	430b      	orrs	r3, r1
10032224:	d031      	beq.n	1003228a <scalbn+0x82>
10032226:	ed9f 7b38 	vldr	d7, [pc, #224]	; 10032308 <scalbn+0x100>
1003222a:	f643 42b0 	movw	r2, #15536	; 0x3cb0
1003222e:	f6cf 72ff 	movt	r2, #65535	; 0xffff
10032232:	4290      	cmp	r0, r2
10032234:	ee20 7b07 	vmul.f64	d7, d0, d7
10032238:	ed8d 7b00 	vstr	d7, [sp]
1003223c:	9b01      	ldr	r3, [sp, #4]
1003223e:	bfa4      	itt	ge
10032240:	f3c3 520a 	ubfxge	r2, r3, #20, #11
10032244:	3a36      	subge	r2, #54	; 0x36
10032246:	db26      	blt.n	10032296 <scalbn+0x8e>
10032248:	1814      	adds	r4, r2, r0
1003224a:	f240 72fe 	movw	r2, #2046	; 0x7fe
1003224e:	4294      	cmp	r4, r2
10032250:	dc30      	bgt.n	100322b4 <scalbn+0xac>
10032252:	2c00      	cmp	r4, #0
10032254:	dd27      	ble.n	100322a6 <scalbn+0x9e>
10032256:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
1003225a:	e9dd 2300 	ldrd	r2, r3, [sp]
1003225e:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
10032262:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
10032266:	ec43 2b10 	vmov	d0, r2, r3
1003226a:	b002      	add	sp, #8
1003226c:	ecbd 8b02 	vpop	{d8}
10032270:	bd10      	pop	{r4, pc}
10032272:	f240 71ff 	movw	r1, #2047	; 0x7ff
10032276:	428a      	cmp	r2, r1
10032278:	d1e6      	bne.n	10032248 <scalbn+0x40>
1003227a:	ed9d 7b00 	vldr	d7, [sp]
1003227e:	ee37 0b07 	vadd.f64	d0, d7, d7
10032282:	b002      	add	sp, #8
10032284:	ecbd 8b02 	vpop	{d8}
10032288:	bd10      	pop	{r4, pc}
1003228a:	ed9d 0b00 	vldr	d0, [sp]
1003228e:	b002      	add	sp, #8
10032290:	ecbd 8b02 	vpop	{d8}
10032294:	bd10      	pop	{r4, pc}
10032296:	ed9f 0b1e 	vldr	d0, [pc, #120]	; 10032310 <scalbn+0x108>
1003229a:	ee27 0b00 	vmul.f64	d0, d7, d0
1003229e:	b002      	add	sp, #8
100322a0:	ecbd 8b02 	vpop	{d8}
100322a4:	bd10      	pop	{r4, pc}
100322a6:	f114 0f35 	cmn.w	r4, #53	; 0x35
100322aa:	da11      	bge.n	100322d0 <scalbn+0xc8>
100322ac:	f24c 3350 	movw	r3, #50000	; 0xc350
100322b0:	4298      	cmp	r0, r3
100322b2:	dd1d      	ble.n	100322f0 <scalbn+0xe8>
100322b4:	ed9f 8b18 	vldr	d8, [pc, #96]	; 10032318 <scalbn+0x110>
100322b8:	ed9d 1b00 	vldr	d1, [sp]
100322bc:	eeb0 0b48 	vmov.f64	d0, d8
100322c0:	f000 f8e8 	bl	10032494 <copysign>
100322c4:	ee20 0b08 	vmul.f64	d0, d0, d8
100322c8:	b002      	add	sp, #8
100322ca:	ecbd 8b02 	vpop	{d8}
100322ce:	bd10      	pop	{r4, pc}
100322d0:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
100322d4:	3436      	adds	r4, #54	; 0x36
100322d6:	e9dd 2300 	ldrd	r2, r3, [sp]
100322da:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
100322de:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
100322e2:	ed9f 0b0f 	vldr	d0, [pc, #60]	; 10032320 <scalbn+0x118>
100322e6:	ec43 2b17 	vmov	d7, r2, r3
100322ea:	ee27 0b00 	vmul.f64	d0, d7, d0
100322ee:	e7bc      	b.n	1003226a <scalbn+0x62>
100322f0:	ed9f 8b07 	vldr	d8, [pc, #28]	; 10032310 <scalbn+0x108>
100322f4:	ed9d 1b00 	vldr	d1, [sp]
100322f8:	eeb0 0b48 	vmov.f64	d0, d8
100322fc:	f000 f8ca 	bl	10032494 <copysign>
10032300:	ee20 0b08 	vmul.f64	d0, d0, d8
10032304:	e7b1      	b.n	1003226a <scalbn+0x62>
10032306:	bf00      	nop
10032308:	00000000 	.word	0x00000000
1003230c:	43500000 	.word	0x43500000
10032310:	c2f8f359 	.word	0xc2f8f359
10032314:	01a56e1f 	.word	0x01a56e1f
10032318:	8800759c 	.word	0x8800759c
1003231c:	7e37e43c 	.word	0x7e37e43c
10032320:	00000000 	.word	0x00000000
10032324:	3c900000 	.word	0x3c900000

10032328 <fabsf>:
10032328:	ee10 3a10 	vmov	r3, s0
1003232c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10032330:	ee00 3a10 	vmov	s0, r3
10032334:	4770      	bx	lr
10032336:	bf00      	nop

10032338 <floorf>:
10032338:	ee10 2a10 	vmov	r2, s0
1003233c:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
10032340:	0dcb      	lsrs	r3, r1, #23
10032342:	3b7f      	subs	r3, #127	; 0x7f
10032344:	2b16      	cmp	r3, #22
10032346:	dc1f      	bgt.n	10032388 <floorf+0x50>
10032348:	2b00      	cmp	r3, #0
1003234a:	ee10 0a10 	vmov	r0, s0
1003234e:	db21      	blt.n	10032394 <floorf+0x5c>
10032350:	f64f 71ff 	movw	r1, #65535	; 0xffff
10032354:	f2c0 017f 	movt	r1, #127	; 0x7f
10032358:	4119      	asrs	r1, r3
1003235a:	4211      	tst	r1, r2
1003235c:	d028      	beq.n	100323b0 <floorf+0x78>
1003235e:	eddf 7a18 	vldr	s15, [pc, #96]	; 100323c0 <floorf+0x88>
10032362:	ee70 7a27 	vadd.f32	s15, s0, s15
10032366:	eef5 7ac0 	vcmpe.f32	s15, #0.0
1003236a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
1003236e:	dd1f      	ble.n	100323b0 <floorf+0x78>
10032370:	2a00      	cmp	r2, #0
10032372:	bfbe      	ittt	lt
10032374:	f44f 0200 	movlt.w	r2, #8388608	; 0x800000
10032378:	fa42 f303 	asrlt.w	r3, r2, r3
1003237c:	18c0      	addlt	r0, r0, r3
1003237e:	ea20 0301 	bic.w	r3, r0, r1
10032382:	ee00 3a10 	vmov	s0, r3
10032386:	4770      	bx	lr
10032388:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
1003238c:	d310      	bcc.n	100323b0 <floorf+0x78>
1003238e:	ee30 0a00 	vadd.f32	s0, s0, s0
10032392:	4770      	bx	lr
10032394:	eddf 7a0a 	vldr	s15, [pc, #40]	; 100323c0 <floorf+0x88>
10032398:	ee70 7a27 	vadd.f32	s15, s0, s15
1003239c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
100323a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
100323a4:	dd04      	ble.n	100323b0 <floorf+0x78>
100323a6:	2a00      	cmp	r2, #0
100323a8:	bfa8      	it	ge
100323aa:	ed9f 0a06 	vldrge	s0, [pc, #24]	; 100323c4 <floorf+0x8c>
100323ae:	db00      	blt.n	100323b2 <floorf+0x7a>
100323b0:	4770      	bx	lr
100323b2:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
100323b6:	2900      	cmp	r1, #0
100323b8:	bf18      	it	ne
100323ba:	eeb0 0a67 	vmovne.f32	s0, s15
100323be:	4770      	bx	lr
100323c0:	7149f2ca 	.word	0x7149f2ca
100323c4:	00000000 	.word	0x00000000

100323c8 <scalbnf>:
100323c8:	b508      	push	{r3, lr}
100323ca:	ee10 3a10 	vmov	r3, s0
100323ce:	ed2d 8b02 	vpush	{d8}
100323d2:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
100323d6:	d014      	beq.n	10032402 <scalbnf+0x3a>
100323d8:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
100323dc:	bf28      	it	cs
100323de:	ee30 0a00 	vaddcs.f32	s0, s0, s0
100323e2:	d20e      	bcs.n	10032402 <scalbnf+0x3a>
100323e4:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
100323e8:	d30e      	bcc.n	10032408 <scalbnf+0x40>
100323ea:	0dd2      	lsrs	r2, r2, #23
100323ec:	4402      	add	r2, r0
100323ee:	2afe      	cmp	r2, #254	; 0xfe
100323f0:	dc2c      	bgt.n	1003244c <scalbnf+0x84>
100323f2:	2a00      	cmp	r2, #0
100323f4:	dd18      	ble.n	10032428 <scalbnf+0x60>
100323f6:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
100323fa:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
100323fe:	ee00 3a10 	vmov	s0, r3
10032402:	ecbd 8b02 	vpop	{d8}
10032406:	bd08      	pop	{r3, pc}
10032408:	eddf 7a1e 	vldr	s15, [pc, #120]	; 10032484 <scalbnf+0xbc>
1003240c:	f643 43b0 	movw	r3, #15536	; 0x3cb0
10032410:	f6cf 73ff 	movt	r3, #65535	; 0xffff
10032414:	4298      	cmp	r0, r3
10032416:	ee20 0a27 	vmul.f32	s0, s0, s15
1003241a:	db22      	blt.n	10032462 <scalbnf+0x9a>
1003241c:	ee10 3a10 	vmov	r3, s0
10032420:	f3c3 52c7 	ubfx	r2, r3, #23, #8
10032424:	3a19      	subs	r2, #25
10032426:	e7e1      	b.n	100323ec <scalbnf+0x24>
10032428:	f112 0f16 	cmn.w	r2, #22
1003242c:	da1e      	bge.n	1003246c <scalbnf+0xa4>
1003242e:	f24c 3350 	movw	r3, #50000	; 0xc350
10032432:	4298      	cmp	r0, r3
10032434:	dc0a      	bgt.n	1003244c <scalbnf+0x84>
10032436:	ed9f 8a14 	vldr	s16, [pc, #80]	; 10032488 <scalbnf+0xc0>
1003243a:	eef0 0a40 	vmov.f32	s1, s0
1003243e:	eeb0 0a48 	vmov.f32	s0, s16
10032442:	f000 f835 	bl	100324b0 <copysignf>
10032446:	ee20 0a08 	vmul.f32	s0, s0, s16
1003244a:	e7da      	b.n	10032402 <scalbnf+0x3a>
1003244c:	ed9f 8a0f 	vldr	s16, [pc, #60]	; 1003248c <scalbnf+0xc4>
10032450:	eef0 0a40 	vmov.f32	s1, s0
10032454:	eeb0 0a48 	vmov.f32	s0, s16
10032458:	f000 f82a 	bl	100324b0 <copysignf>
1003245c:	ee20 0a08 	vmul.f32	s0, s0, s16
10032460:	e7cf      	b.n	10032402 <scalbnf+0x3a>
10032462:	eddf 0a09 	vldr	s1, [pc, #36]	; 10032488 <scalbnf+0xc0>
10032466:	ee20 0a20 	vmul.f32	s0, s0, s1
1003246a:	e7ca      	b.n	10032402 <scalbnf+0x3a>
1003246c:	3219      	adds	r2, #25
1003246e:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
10032472:	eddf 7a07 	vldr	s15, [pc, #28]	; 10032490 <scalbnf+0xc8>
10032476:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
1003247a:	ee00 3a10 	vmov	s0, r3
1003247e:	ee20 0a27 	vmul.f32	s0, s0, s15
10032482:	e7be      	b.n	10032402 <scalbnf+0x3a>
10032484:	4c000000 	.word	0x4c000000
10032488:	0da24260 	.word	0x0da24260
1003248c:	7149f2ca 	.word	0x7149f2ca
10032490:	33000000 	.word	0x33000000

10032494 <copysign>:
10032494:	ec53 2b10 	vmov	r2, r3, d0
10032498:	ee11 1a90 	vmov	r1, s3
1003249c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
100324a0:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
100324a4:	ea40 0301 	orr.w	r3, r0, r1
100324a8:	ec43 2b10 	vmov	d0, r2, r3
100324ac:	4770      	bx	lr
100324ae:	bf00      	nop

100324b0 <copysignf>:
100324b0:	ee10 3a10 	vmov	r3, s0
100324b4:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
100324b8:	ee10 3a90 	vmov	r3, s1
100324bc:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
100324c0:	4313      	orrs	r3, r2
100324c2:	ee00 3a10 	vmov	s0, r3
100324c6:	4770      	bx	lr

100324c8 <___write_r_from_thumb>:
100324c8:	4778      	bx	pc
100324ca:	46c0      	nop			; (mov r8, r8)
100324cc:	eaffb761 	b	10020258 <_write_r>

100324d0 <___close_r_from_thumb>:
100324d0:	4778      	bx	pc
100324d2:	46c0      	nop			; (mov r8, r8)
100324d4:	eaffb670 	b	1001fe9c <_close_r>

100324d8 <__fsym_state>:
100324d8:	10035b64 10035b6c 1000cd54              d[..l[..T...

100324e4 <__fsym___cmd_state>:
100324e4:	10035b74 10035b80 1000cd54              t[...[..T...

100324f0 <__fsym_pwmtest>:
100324f0:	10035b88 10035b90 1000d040              .[...[..@...

100324fc <__fsym___cmd_pwmtest>:
100324fc:	10035bac 10035bbc 1000d040              .[...[..@...

10032508 <__fsym_adctest>:
10032508:	10035bd8 10035be0 1000d348              .[...[..H...

10032514 <__fsym___cmd_adctest>:
10032514:	10035bf4 10035c04 1000d348              .[...\..H...

10032520 <__fsym_qeptest>:
10032520:	10035c18 10035c20 1000d60c              .\.. \......

1003252c <__fsym___cmd_qeptest>:
1003252c:	10035c34 10035c44 1000d60c              4\..D\......

10032538 <__fsym_mmtest>:
10032538:	10035c58 10035c60 1000d870              X\..`\..p...

10032544 <__fsym___cmd_mmtest>:
10032544:	10035c70 10035c80 1000d870              p\...\..p...

10032550 <__fsym_rlytest>:
10032550:	10035c90 10035c98 1000da00              .\...\......

1003255c <__fsym___cmd_rlytest>:
1003255c:	10035ca8 10035cb8 1000da00              .\...\......

10032568 <__fsym_sharememtest>:
10032568:	10035cc8 10035cd8 1000daa8              .\...\......

10032574 <__fsym___cmd_sharememtest>:
10032574:	10035cec 10035d00 1000daa8              .\...]......

10032580 <__fsym_SFItest>:
10032580:	10035d14 10035d1c 1000e268              .]...]..h...

1003258c <__fsym___cmd_SFItest>:
1003258c:	10035d34 10035d44 1000e268              4]..D]..h...

10032598 <__fsym_list_mem>:
10032598:	10035d5c 10035d68 10014dc8              \]..h]...M..

100325a4 <__fsym_vbrb>:
100325a4:	10035d88 10035d90 1001c5a4              .]...]......

100325b0 <__fsym_vbchn>:
100325b0:	10035dac 10035db4 1001c6e0              .]...]......

100325bc <__fsym_vbses>:
100325bc:	10035dd0 10035dd8 1001c75c              .]...]..\...

100325c8 <__fsym_vbque>:
100325c8:	10035df4 10035dfc 1001c858              .]...]..X...

100325d4 <__fsym_vbtsz>:
100325d4:	10035e18 10035e20 1001c884              .^.. ^......

100325e0 <__fsym_vbdq>:
100325e0:	10035e30 10035e38 1001c8a0              0^..8^......

100325ec <__fsym_hello>:
100325ec:	10035e4c 10035e54 10023b54              L^..T^..T;..

100325f8 <__fsym_version>:
100325f8:	10035e64 10035e6c 10023b74              d^..l^..t;..

10032604 <__fsym___cmd_version>:
10032604:	10035e90 10035ea0 10023b74              .^...^..t;..

10032610 <__fsym_list_thread>:
10032610:	10035ec4 10035ed0 10023d44              .^...^..D=..

1003261c <__fsym___cmd_list_thread>:
1003261c:	10035edc 10035ef0 10023d44              .^...^..D=..

10032628 <__fsym_list_sem>:
10032628:	10035efc 10035f08 10023f14              .^..._...?..

10032634 <__fsym___cmd_list_sem>:
10032634:	10035f24 10035f34 10023f14              $_..4_...?..

10032640 <__fsym_list_event>:
10032640:	10035f50 10035f5c 10024038              P_..\_..8@..

1003264c <__fsym___cmd_list_event>:
1003264c:	10035f74 10035f88 10024038              t_..._..8@..

10032658 <__fsym_list_mutex>:
10032658:	10035fa0 10035fac 1002411c              ._..._...A..

10032664 <__fsym___cmd_list_mutex>:
10032664:	10035fc4 10035fd8 1002411c              ._..._...A..

10032670 <__fsym_list_mailbox>:
10032670:	10035ff0 10036000 10024288              ._...`...B..

1003267c <__fsym___cmd_list_mailbox>:
1003267c:	10036018 1003602c 10024288              .`..,`...B..

10032688 <__fsym_list_msgqueue>:
10032688:	10036044 10036054 100243d4              D`..T`...C..

10032694 <__fsym___cmd_list_msgqueue>:
10032694:	10036074 10036088 100243d4              t`...`...C..

100326a0 <__fsym_list_mempool>:
100326a0:	100360a8 100360b8 10024524              .`...`..$E..

100326ac <__fsym___cmd_list_mempool>:
100326ac:	100360d4 100360e8 10024524              .`...`..$E..

100326b8 <__fsym_list_timer>:
100326b8:	10036104 10036110 10024628              .a...a..(F..

100326c4 <__fsym___cmd_list_timer>:
100326c4:	10036128 1003613c 10024628              (a..<a..(F..

100326d0 <__fsym_list_device>:
100326d0:	10036154 10036160 1002472c              Ta..`a..,G..

100326dc <__fsym___cmd_list_device>:
100326dc:	10036178 1003618c 1002472c              xa...a..,G..

100326e8 <__fsym_list>:
100326e8:	100361a4 100361ac 1002474c              .a...a..LG..

100326f4 <__fsym___cmd_ps>:
100326f4:	100361ec 100361f8 10024ea0              .a...a...N..

10032700 <__fsym___cmd_time>:
10032700:	10036214 10036220 10024ec8              .b.. b...N..

1003270c <__fsym___cmd_free>:
1003270c:	1003623c 10036248 10024ef0              <b..Hb...N..

10032718 <__fsym___cmd_exit>:
10032718:	10036270 1003627c 10024f3c              pb..|b..<O..

10032724 <__fsym_msh>:
10032724:	1003629c 100362a0 10024f74              .b...b..tO..

10032730 <__fsym___cmd_help>:
10032730:	100362b4 100362c0 10024fa0              .b...b...O..

1003273c <__fsymtab_end>:
1003273c:	100361c8 	.word	0x100361c8
10032740:	100361d0 	.word	0x100361d0
10032744:	00000009 	.word	0x00000009
10032748:	1003f944 	.word	0x1003f944

1003274c <__rt_init_rti_start>:
1003274c:	1000e46c                                l...

10032750 <__rt_init_adc_hw_init>:
10032750:	10009dac                                ....

10032754 <__rt_init_rt_hw_timer_init>:
10032754:	1000a184                                ....

10032758 <__rt_init_motor_misc_hw_init>:
10032758:	1000a8d8                                ....

1003275c <__rt_init_pwm_hw_init>:
1003275c:	1000ac58                                X...

10032760 <__rt_init_qep_hw_init>:
10032760:	1000b088                                ....

10032764 <__rt_init_sharemem_hw_init>:
10032764:	1000b3e8                                ....

10032768 <__rt_init_rt_hw_uart_init>:
10032768:	1000cb40                                @...

1003276c <__rt_init_rti_board_end>:
1003276c:	1000e488                                ....

10032770 <__rt_init_pwm_config_init>:
10032770:	1000ad24                                $...

10032774 <__rt_init_qep_config_init>:
10032774:	1000b150                                P...

10032778 <__rt_init_rt_vbus_do_init>:
10032778:	1000cc04                                ....

1003277c <__rt_init_finsh_system_init>:
1003277c:	10023990                                .9..

10032780 <__rt_init_libc_system_init>:
10032780:	1001fe6c                                l...

10032784 <__rt_init_USER_MotorTask_init>:
10032784:	1000e170                                p...

10032788 <__rt_init_rti_end>:
10032788:	1000e4a4                                ....
